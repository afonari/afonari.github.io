
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichister.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;	</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;math.h&gt;</a>
<a name="ln43">#include &lt;string.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;ichierr.h&quot;</a>
<a name="ln48">#include &quot;inpdef.h&quot;</a>
<a name="ln49">#include &quot;extr_ct.h&quot;</a>
<a name="ln50">#include &quot;ichister.h&quot;</a>
<a name="ln51">#include &quot;ichiring.h&quot;</a>
<a name="ln52">#include &quot;ichi.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;ichicomp.h&quot;</a>
<a name="ln55">#include &quot;util.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">#define    ZTYPE_DOWN     (-1)  /*  should be equal to -ZTYPE_UP */</a>
<a name="ln58">#define    ZTYPE_NONE     0</a>
<a name="ln59">#define    ZTYPE_UP       1     /*  should be equal to -ZTYPE_DOWN */</a>
<a name="ln60">#define    ZTYPE_3D       3</a>
<a name="ln61">#define    ZTYPE_EITHER   9999</a>
<a name="ln62"> </a>
<a name="ln63">/*  criteria for ill-defined */</a>
<a name="ln64">#define MIN_ANGLE             0.10   /*  5.73 degrees */</a>
<a name="ln65">#define MIN_SINE              0.03   /*  min edge/plane angle in case the tetrahedra has significantly different edge length */</a>
<a name="ln66">#define MIN_ANGLE_DBOND       0.087156 /* 5 degrees = max angle considered as too small for unambiguous double bond stereo */</a>
<a name="ln67">#define MIN_SINE_OUTSIDE      0.06   /*  min edge/plane angle to determine whether the central atom is outside of the tetrahedra */</a>
<a name="ln68">#define MIN_SINE_SQUARE       0.125  /*  min edge/plane angle in case the tetrahedra is somewhat close to a parallelogram */</a>
<a name="ln69">#define MIN_SINE_EDGE         0.167  /*  min sine/(min.edge) ratio to avoid undefined in case of long edges */</a>
<a name="ln70">#define MIN_LEN_STRAIGHT      1.900  /*  min length of two normalized to 1 bonds in a straight line */</a>
<a name="ln71">#define MAX_SINE              0.70710678118654752440084436210485 /*  1/sqrt(2)=sin(pi/4) */</a>
<a name="ln72">#define MIN_BOND_LEN          0.000001</a>
<a name="ln73">#define ZERO_LENGTH           MIN_BOND_LEN</a>
<a name="ln74">#define ZERO_FLOAT            1.0e-12</a>
<a name="ln75">#define BOND_PARITY_UNDEFINED 64</a>
<a name="ln76">#if ( STEREO_CENTER_BONDS_NORM == 1 )</a>
<a name="ln77">#define MPY_SINE              1.00  /*  was 3.0 */</a>
<a name="ln78">#define MAX_EDGE_RATIO        2.50   /*  max max/min edge ratio for a tetrahedra close to a parallelogram  */</a>
<a name="ln79">#else</a>
<a name="ln80">#define MPY_SINE              3.00</a>
<a name="ln81">#define MAX_EDGE_RATIO        6.00   /*  max max/min edge ratio for a tetrahedra close to a parallelogram  */</a>
<a name="ln82">#endif</a>
<a name="ln83">/*  local prototypes */</a>
<a name="ln84">static int save_a_stereo_bond( int z_prod, int result_action,</a>
<a name="ln85">                        int at1, int ord1, AT_NUMB *stereo_bond_neighbor1, S_CHAR *stereo_bond_ord1, S_CHAR *stereo_bond_z_prod1, S_CHAR *stereo_bond_parity1, </a>
<a name="ln86">                        int at2, int ord2, AT_NUMB *stereo_bond_neighbor2, S_CHAR *stereo_bond_ord2, S_CHAR *stereo_bond_z_prod2, S_CHAR *stereo_bond_parity2 );</a>
<a name="ln87">static double get_z_coord( inp_ATOM* at, int cur_atom, int neigh_no,  int *nType,int bPointedEdgeStereo );</a>
<a name="ln88">static double len3( const double c[] );</a>
<a name="ln89">static double len2( const double c[] );</a>
<a name="ln90">static double* diff3( const double a[], const double b[], double result[] );</a>
<a name="ln91">static double* add3( const double a[], const double b[], double result[] );</a>
<a name="ln92">static double* mult3( const double a[], double b, double result[] );</a>
<a name="ln93">static double* copy3( const double a[], double result[] );</a>
<a name="ln94">static double* change_sign3( const double a[], double result[] );</a>
<a name="ln95">static double dot_prod3( const double a[], const double b[] );</a>
<a name="ln96">static int dot_prodchar3( const S_CHAR a[], const S_CHAR b[] );</a>
<a name="ln97">static double* cross_prod3( const double a[], const double b[], double result[] );</a>
<a name="ln98">static double triple_prod( double a[], double b[], double c[], double *sine_value );</a>
<a name="ln99">static double triple_prod_and_min_abs_sine(double at_coord[][3], double *min_sine);</a>
<a name="ln100">static int are_3_vect_in_one_plane( double at_coord[][3], double min_sine);</a>
<a name="ln101">static int triple_prod_char( inp_ATOM *at, int at_1, int i_next_at_1, S_CHAR *z_dir1,</a>
<a name="ln102">                                           int at_2, int i_next_at_2, S_CHAR *z_dir2 );</a>
<a name="ln103"> </a>
<a name="ln104">static int CompDble( const void *a1, const void *a2 );</a>
<a name="ln105">static int Get2DTetrahedralAmbiguity( double at_coord[][3], int bAddExplicitNeighbor, int bFix2DstereoBorderCase );</a>
<a name="ln106">static double triple_prod_and_min_abs_sine2(double at_coord[][3], double central_at_coord[], int bAddedExplicitNeighbor, double *min_sine, int *bAmbiguous);</a>
<a name="ln107">static int are_4at_in_one_plane( double at_coord[][3], double min_sine);</a>
<a name="ln108">static int bInpAtomHasRequirdNeigh ( inp_ATOM *at, int cur_at, int RequirdNeighType, int NumDbleBonds );</a>
<a name="ln109">static int bIsSuitableHeteroInpAtom( inp_ATOM  *at );</a>
<a name="ln110">static int bIsOxide( inp_ATOM  *at, int cur_at );</a>
<a name="ln111">static int half_stereo_bond_parity( inp_ATOM *at, int cur_at, inp_ATOM *at_removed_H, int num_removed_H, S_CHAR *z_dir, </a>
<a name="ln112">                                   int bPointedEdgeStereo, int vABParityUnknown );</a>
<a name="ln113">static int get_allowed_stereo_bond_type( int bond_type );</a>
<a name="ln114">static int can_be_a_stereo_bond_with_isotopic_H( inp_ATOM *at, int cur_at, INCHI_MODE nMode );</a>
<a name="ln115">static int half_stereo_bond_action( int nParity, int bUnknown, int bIsotopic, int vABParityUnknown );</a>
<a name="ln116">static int set_stereo_bonds_parity( sp_ATOM *out_at, inp_ATOM *at, int at_1, inp_ATOM *at_removed_H, int num_removed_H,</a>
<a name="ln117">                                   INCHI_MODE nMode, QUEUE *q, AT_RANK *nAtomLevel, </a>
<a name="ln118">                                   S_CHAR *cSource, AT_RANK min_sb_ring_size, </a>
<a name="ln119">                                   int bPointedEdgeStereo, int vABParityUnknown );</a>
<a name="ln120">static int can_be_a_stereo_atom_with_isotopic_H( inp_ATOM *at, int cur_at, int bPointedEdgeStereo );</a>
<a name="ln121">static int set_stereo_atom_parity( sp_ATOM *out_at, inp_ATOM *at, int cur_at, inp_ATOM *at_removed_H, int num_removed_H, </a>
<a name="ln122">                                  int bPointedEdgeStereo, int vABParityUnknown );</a>
<a name="ln123">/*</a>
<a name="ln124">int set_stereo_parity( inp_ATOM* at, sp_ATOM* at_output, int num_at, int num_removed_H,</a>
<a name="ln125">                       int *nMaxNumStereoAtoms, int *nMaxNumStereoBonds, INCHI_MODE nMode, int bPointedEdgeStereo, vABParityUnknown );</a>
<a name="ln126">int get_opposite_sb_atom( inp_ATOM *at, int cur_atom, int icur2nxt, int *pnxt_atom, int *pinxt2cur, int *pinxt_sb_parity_ord );</a>
<a name="ln127">*/</a>
<a name="ln128">int ReconcileCmlIncidentBondParities( inp_ATOM *at, int cur_atom, int prev_atom, S_CHAR *visited, int bDisconnected );</a>
<a name="ln129">int comp_AT_NUMB( const void* a1, const void* a2);</a>
<a name="ln130">int GetHalfStereobond0DParity( inp_ATOM *at, int cur_at, AT_NUMB nSbNeighOrigAtNumb[], int nNumExplictAttachments, int bond_parity, int nFlag );</a>
<a name="ln131">int GetStereocenter0DParity( inp_ATOM *at, int cur_at, int j1, AT_NUMB nSbNeighOrigAtNumb[], int nFlag );</a>
<a name="ln132">int GetSbNeighOrigAtNumb( inp_ATOM *at, int cur_at, inp_ATOM *at_removed_H, int num_removed_H, AT_NUMB nSbNeighOrigAtNumb[]);</a>
<a name="ln133">int FixSb0DParities( inp_ATOM *at, /* inp_ATOM *at_removed_H, int num_removed_H,*/ int chain_length,</a>
<a name="ln134">                     int at_1, int i_next_at_1, S_CHAR z_dir1[],</a>
<a name="ln135">                     int at_2, int i_next_at_2, S_CHAR z_dir2[],</a>
<a name="ln136">                     int *pparity1, int *pparity2 );</a>
<a name="ln137"> </a>
<a name="ln138">/******************************************************************/</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">static double         *pDoubleForSort;</a>
<a name="ln142"> </a>
<a name="ln143">/**********************************************************************************/</a>
<a name="ln144">int comp_AT_NUMB( const void* a1, const void* a2)</a>
<a name="ln145">{</a>
<a name="ln146">    return (int)*(const AT_NUMB*)a1 - (int)*(const AT_NUMB*)a2;</a>
<a name="ln147">}</a>
<a name="ln148">/******************************************************************/</a>
<a name="ln149">double get_z_coord( inp_ATOM* at, int cur_atom, int neigh_no,  int *nType, int bPointedEdgeStereo )</a>
<a name="ln150">{</a>
<a name="ln151">    int stereo_value = at[cur_atom].bond_stereo[neigh_no];</a>
<a name="ln152">    int stereo_type  = abs( stereo_value );</a>
<a name="ln153">    int neigh        = (int)at[cur_atom].neighbor[neigh_no];</a>
<a name="ln154">    double z         = at[neigh].z - at[cur_atom].z;</a>
<a name="ln155">    int    bFlat;</a>
<a name="ln156"> </a>
<a name="ln157">    if ( (bFlat = (fabs(z) &lt; ZERO_LENGTH)) ) {</a>
<a name="ln158">        int i;</a>
<a name="ln159">        for ( i = 0; i &lt; at[cur_atom].valence; i ++ ) {</a>
<a name="ln160">            if ( fabs(at[cur_atom].z - at[(int)at[cur_atom].neighbor[i]].z) &gt; ZERO_LENGTH ) {</a>
<a name="ln161">                bFlat = 0;</a>
<a name="ln162">                break;</a>
<a name="ln163">            }</a>
<a name="ln164">        }</a>
<a name="ln165">    }</a>
<a name="ln166"> </a>
<a name="ln167">    if ( bFlat ) {</a>
<a name="ln168">        if ( !bPointedEdgeStereo || bPointedEdgeStereo * stereo_value &gt;= 0 ) {</a>
<a name="ln169">            /* bPointedEdgeStereo &gt; 0: define stereo from pointed end of the stereo bond only */</a>
<a name="ln170">            /* bPointedEdgeStereo &lt; 0: define stereo from wide end of the stereo bond only (case of removed H) */</a>
<a name="ln171">            switch( stereo_type ) {</a>
<a name="ln172">                /*  1=Up (solid triangle), 6=Down (Dashed triangle), 4=Either (zigzag triangle) */</a>
<a name="ln173">            case 0: /*  No stereo */</a>
<a name="ln174">                *nType = ZTYPE_NONE;</a>
<a name="ln175">                break;</a>
<a name="ln176">            case STEREO_SNGL_UP: /*  1= Up */</a>
<a name="ln177">                *nType = ZTYPE_UP;</a>
<a name="ln178">                break;</a>
<a name="ln179">            case STEREO_SNGL_EITHER: /*  4 = Either */</a>
<a name="ln180">                *nType = ZTYPE_EITHER;</a>
<a name="ln181">                break;</a>
<a name="ln182">            case STEREO_SNGL_DOWN: /*  6 = Down */</a>
<a name="ln183">                *nType = ZTYPE_DOWN;</a>
<a name="ln184">                break;</a>
<a name="ln185">            default:</a>
<a name="ln186">                *nType = ZTYPE_NONE; /*  ignore unexpected values */</a>
<a name="ln187">            }</a>
<a name="ln188">            if ( stereo_value &lt; 0 &amp;&amp; (*nType == ZTYPE_DOWN || *nType == ZTYPE_UP) )</a>
<a name="ln189">                *nType = -*nType;</a>
<a name="ln190">        } else {</a>
<a name="ln191">            *nType = ZTYPE_NONE; /* no stereo */</a>
<a name="ln192">        }</a>
<a name="ln193">    } else</a>
<a name="ln194">    if ( stereo_type == STEREO_SNGL_EITHER &amp;&amp;</a>
<a name="ln195">         ( !bPointedEdgeStereo || bPointedEdgeStereo * stereo_value &gt;= 0 ) ) {</a>
<a name="ln196">        *nType = ZTYPE_EITHER; </a>
<a name="ln197">    } else {</a>
<a name="ln198">        *nType = ZTYPE_3D;</a>
<a name="ln199">    }</a>
<a name="ln200">    return z;</a>
<a name="ln201">}</a>
<a name="ln202">/******************************************************************/</a>
<a name="ln203">double len3( const double c[] )</a>
<a name="ln204">{</a>
<a name="ln205">    return sqrt( c[0]*c[0]   + c[1]*c[1]   + c[2]*c[2] );</a>
<a name="ln206">}</a>
<a name="ln207">/******************************************************************/</a>
<a name="ln208">double len2( const double c[] )</a>
<a name="ln209">{</a>
<a name="ln210">    return sqrt( c[0]*c[0]   + c[1]*c[1] );</a>
<a name="ln211">}</a>
<a name="ln212">/******************************************************************/</a>
<a name="ln213">double* diff3( const double a[], const double b[], double result[] )</a>
<a name="ln214">{</a>
<a name="ln215"> </a>
<a name="ln216">    result[0] =  a[0] - b[0];</a>
<a name="ln217">    result[1] =  a[1] - b[1];</a>
<a name="ln218">    result[2] =  a[2] - b[2];</a>
<a name="ln219"> </a>
<a name="ln220">    return result;</a>
<a name="ln221">}</a>
<a name="ln222">/******************************************************************/</a>
<a name="ln223">double* add3( const double a[], const double b[], double result[] )</a>
<a name="ln224">{</a>
<a name="ln225">    result[0] =  a[0] + b[0];</a>
<a name="ln226">    result[1] =  a[1] + b[1];</a>
<a name="ln227">    result[2] =  a[2] + b[2];</a>
<a name="ln228"> </a>
<a name="ln229">    return result;</a>
<a name="ln230">}</a>
<a name="ln231">/******************************************************************/</a>
<a name="ln232">double* mult3( const double a[], double b, double result[] )</a>
<a name="ln233">{</a>
<a name="ln234">    result[0] = a[0] * b;</a>
<a name="ln235">    result[1] = a[1] * b;</a>
<a name="ln236">    result[2] = a[2] * b;</a>
<a name="ln237"> </a>
<a name="ln238">    return result;</a>
<a name="ln239">}</a>
<a name="ln240">/*************************************************************/</a>
<a name="ln241">double* copy3( const double a[], double result[] )</a>
<a name="ln242">{</a>
<a name="ln243">    result[0] = a[0];</a>
<a name="ln244">    result[1] = a[1];</a>
<a name="ln245">    result[2] = a[2];</a>
<a name="ln246"> </a>
<a name="ln247">    return result;</a>
<a name="ln248">}</a>
<a name="ln249">/*************************************************************/</a>
<a name="ln250">double* change_sign3( const double a[], double result[] )</a>
<a name="ln251">{</a>
<a name="ln252">    result[0] = -a[0];</a>
<a name="ln253">    result[1] = -a[1];</a>
<a name="ln254">    result[2] = -a[2];</a>
<a name="ln255"> </a>
<a name="ln256">    return result;</a>
<a name="ln257">}</a>
<a name="ln258">/*************************************************************/</a>
<a name="ln259">double dot_prod3( const double a[], const double b[] )</a>
<a name="ln260">{</a>
<a name="ln261">    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];</a>
<a name="ln262">}</a>
<a name="ln263">/*************************************************************/</a>
<a name="ln264">int dot_prodchar3( const S_CHAR a[], const S_CHAR b[] )</a>
<a name="ln265">{</a>
<a name="ln266">    int prod = ((int)a[0]*(int)b[0] + (int)a[1]*(int)b[1] + (int)a[2]*(int)b[2])/100;</a>
<a name="ln267">    if ( prod &gt; 100 )</a>
<a name="ln268">        prod = 100;</a>
<a name="ln269">    else</a>
<a name="ln270">    if ( prod &lt; -100 )</a>
<a name="ln271">        prod = -100;</a>
<a name="ln272">    return prod;</a>
<a name="ln273">}</a>
<a name="ln274">/*************************************************************/</a>
<a name="ln275">double* cross_prod3( const double a[], const double b[], double result[] )</a>
<a name="ln276">{</a>
<a name="ln277">    double tmp[3];</a>
<a name="ln278">    </a>
<a name="ln279">    tmp[0] =  (a[1]*b[2]-a[2]*b[1]);</a>
<a name="ln280">    tmp[1] = -(a[0]*b[2]-a[2]*b[0]);</a>
<a name="ln281">    tmp[2] =  (a[0]*b[1]-a[1]*b[0]);</a>
<a name="ln282"> </a>
<a name="ln283">    result[0] = tmp[0];</a>
<a name="ln284">    result[1] = tmp[1];</a>
<a name="ln285">    result[2] = tmp[2];</a>
<a name="ln286"> </a>
<a name="ln287">    return result;</a>
<a name="ln288">}</a>
<a name="ln289">/*************************************************************/</a>
<a name="ln290">double triple_prod( double a[], double b[], double c[], double *sine_value )</a>
<a name="ln291">{</a>
<a name="ln292">    double ab[3], dot_prod_ab_c, abs_c, abs_ab;</a>
<a name="ln293">    cross_prod3( a, b, ab );</a>
<a name="ln294">    /* ab[0] =  (a[1]*b[2]-a[2]*b[1]); */</a>
<a name="ln295">    /* ab[1] = -(a[0]*b[2]-a[2]*b[0]); */</a>
<a name="ln296">    /* ab[2] =  (a[0]*b[1]-a[1]*b[0]); */</a>
<a name="ln297">    dot_prod_ab_c   =  dot_prod3( ab, c );</a>
<a name="ln298">    /* dot_prod_ab_c   =  ab[0]*c[0] + ab[1]*c[1] + ab[2]*c[2]; */</a>
<a name="ln299">    if ( sine_value ) {</a>
<a name="ln300">        abs_c  = len3( c );</a>
<a name="ln301">        /* abs_c  = sqrt( c[0]*c[0]   + c[1]*c[1]   + c[2]*c[2] ); */</a>
<a name="ln302">        abs_ab = len3( ab );</a>
<a name="ln303">        /* abs_ab = sqrt( ab[0]*ab[0] + ab[1]*ab[1] + ab[2]*ab[2] ); */</a>
<a name="ln304"> </a>
<a name="ln305">        if ( abs_c &gt; 1.e-7 /* otherwise c has zero length */ &amp;&amp; abs_ab &gt; 1.e-7 /* otherwise a is parallel to b*/ ) {</a>
<a name="ln306">            *sine_value = MPY_SINE * dot_prod_ab_c / ( abs_c * abs_ab);</a>
<a name="ln307">            /*  *sine_value = dot_prod_ab_c / ( abs_c * abs_ab); */</a>
<a name="ln308">        } else {</a>
<a name="ln309">            *sine_value = 0.0;</a>
<a name="ln310">        }</a>
<a name="ln311">    }</a>
<a name="ln312">    return dot_prod_ab_c;</a>
<a name="ln313">}</a>
<a name="ln314">/*************************************************************/</a>
<a name="ln315">int CompDble( const void *a1, const void *a2 )</a>
<a name="ln316">{</a>
<a name="ln317">    double diff = pDoubleForSort[*(const int*)a1] - pDoubleForSort[*(const int*)a2];</a>
<a name="ln318">    if ( diff &gt; 0.0 )</a>
<a name="ln319">        return 1;</a>
<a name="ln320">    if ( diff &lt; 0.0 )</a>
<a name="ln321">        return -1;</a>
<a name="ln322">    return 0;</a>
<a name="ln323">}</a>
<a name="ln324">/*************************************************************/</a>
<a name="ln325">#define T2D_OKAY  1</a>
<a name="ln326">#define T2D_WARN  2</a>
<a name="ln327">#define T2D_UNDF  4</a>
<a name="ln328">int Get2DTetrahedralAmbiguity( double at_coord[][3], int bAddExplicitNeighbor, int bFix2DstereoBorderCase )</a>
<a name="ln329">{</a>
<a name="ln330">/*	const double one_pi = 2.0*atan2(1.0 , 0.0 ); */</a>
<a name="ln331">const double one_pi = 3.14159265358979323846; /* M_PI */</a>
<a name="ln332">const double two_pi = 2.0*one_pi;</a>
<a name="ln333">const double dAngleAndPiMaxDiff = 2.0*atan2(1.0, sqrt(7.0)); /*  min sine between 2 InPlane bonds */</a>
<a name="ln334">int    nBondType[MAX_NUM_STEREO_ATOM_NEIGH], nBondOrder[MAX_NUM_STEREO_ATOM_NEIGH];</a>
<a name="ln335">double dBondDirection[MAX_NUM_STEREO_ATOM_NEIGH];</a>
<a name="ln336">volatile double dAngle, dAlpha, dLimit, dBisector; </a>
<a name="ln337">    /* 2010-02-10  added 'volatile': workaround ensuring proper behavior for gcc 32-bit */</a>
<a name="ln338">    /* cml-enabled compiles at &gt;=O1 for SID484922 and alike (both lin&amp;win had problems) */</a>
<a name="ln339">int  nNumNeigh = MAX_NUM_STEREO_ATOM_NEIGH - (bAddExplicitNeighbor != 0);</a>
<a name="ln340">int  i, num_Up, num_Dn, bPrev_Up, cur_len_Up, cur_first_Up, len_Up, first_Up;</a>
<a name="ln341">int  ret=0;</a>
<a name="ln342"> </a>
<a name="ln343">    for ( i = 0, num_Up = num_Dn = 0; i &lt; nNumNeigh; i ++ ) </a>
<a name="ln344">    {</a>
<a name="ln345">        dAngle = atan2( at_coord[i][1], at_coord[i][0] ); /*  range from -pi to +pi */</a>
<a name="ln346">        if ( dAngle &lt; 0.0 ) {</a>
<a name="ln347">            dAngle += two_pi;</a>
<a name="ln348">        }</a>
<a name="ln349">        dBondDirection[i] = dAngle;</a>
<a name="ln350">        nBondType[i] = (at_coord[i][2] &gt; 0.0)? 1 : (at_coord[i][2] &lt; 0.0)? -1 : 0; /* z-coord sign */</a>
<a name="ln351">        if ( nBondType[i] &gt; 0 ) {</a>
<a name="ln352">            num_Up ++;</a>
<a name="ln353">        } else</a>
<a name="ln354">        if ( nBondType[i] &lt; 0 ) {</a>
<a name="ln355">            num_Dn ++;</a>
<a name="ln356">        }</a>
<a name="ln357">        nBondOrder[i] = i;</a>
<a name="ln358">    }</a>
<a name="ln359">    if ( num_Up &lt; num_Dn ) {</a>
<a name="ln360">        for ( i = 0; i &lt; nNumNeigh; i ++ ) {</a>
<a name="ln361">            nBondType[i] = -nBondType[i];</a>
<a name="ln362">        }</a>
<a name="ln363">        inchi_swap( (char*)&amp;num_Dn, (char*)&amp;num_Up, sizeof(num_Dn) );</a>
<a name="ln364">    }</a>
<a name="ln365">    if ( !num_Up ) {</a>
<a name="ln366">        return T2D_UNDF;</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">    /*  sort according to the bond orientations */</a>
<a name="ln370">    pDoubleForSort = dBondDirection;</a>
<a name="ln371">    insertions_sort( nBondOrder, (unsigned) nNumNeigh, sizeof(nBondOrder[0]), CompDble );</a>
<a name="ln372">    </a>
<a name="ln373">    /*  find the longest contiguous sequence of Up bonds */</a>
<a name="ln374">    if ( num_Up == nNumNeigh ) {</a>
<a name="ln375">        /*  all bonds are Up */</a>
<a name="ln376">        len_Up   = cur_len_Up = nNumNeigh; /* added cur_len_Up initialization 1/8/2002 */</a>
<a name="ln377">        first_Up = 0;</a>
<a name="ln378">    } else {</a>
<a name="ln379">        /*  at least one bond is not Up */</a>
<a name="ln380">        cur_len_Up = len_Up = bPrev_Up = 0;</a>
<a name="ln381">        /* prev. cycle header version ---</a>
<a name="ln382">        for ( i = 0; 1; i ++ ) {</a>
<a name="ln383">            if ( i &gt;= nNumNeigh &amp;&amp; !bPrev_Up ) {</a>
<a name="ln384">                break;</a>
<a name="ln385">            }</a>
<a name="ln386">        ----------} */</a>
<a name="ln387">        /* look at all bonds and continue (circle therough the beginning) as long as the current bond is Up */</a>
<a name="ln388">        for ( i = 0; i &lt; nNumNeigh || bPrev_Up; i ++ ) {</a>
<a name="ln389">            if ( nBondType[nBondOrder[i % nNumNeigh]] &gt; 0 ) {</a>
<a name="ln390">                if ( bPrev_Up ) {</a>
<a name="ln391">                    cur_len_Up ++; /* uncrement number of Up bonds in current contiguous sequence of them */</a>
<a name="ln392">                } else {</a>
<a name="ln393">                    bPrev_Up     = 1; /* start new contiguous sequence of Up bonds */</a>
<a name="ln394">                    cur_len_Up   = 1;</a>
<a name="ln395">                    cur_first_Up = i % nNumNeigh;</a>
<a name="ln396">                }</a>
<a name="ln397">            } else</a>
<a name="ln398">            if ( bPrev_Up ) { /* end of contiguous sequence of Up bonds */</a>
<a name="ln399">                if ( cur_len_Up &gt; len_Up ) {</a>
<a name="ln400">                    first_Up = cur_first_Up; /* store the sequence because it is longer than the ptrvious one */</a>
<a name="ln401">                    len_Up   = cur_len_Up;</a>
<a name="ln402">                }</a>
<a name="ln403">                bPrev_Up = 0;</a>
<a name="ln404">            }</a>
<a name="ln405">        }</a>
<a name="ln406">    }</a>
<a name="ln407">#if ( FIX_2D_STEREO_BORDER_CASE == 1 )</a>
<a name="ln408">    /* check if the bonds with ordering numbers first_Up+len_Up and first_Up+len_Up+1 */</a>
<a name="ln409">    /* have identical angles. In this case switch their order to enlarge the Up sequence */</a>
<a name="ln410">#define ZERO_ANGLE  0.000001</a>
<a name="ln411">    if ( nNumNeigh - len_Up &gt;= 2 ) {</a>
<a name="ln412">        int next1, next2;</a>
<a name="ln413">        for ( i = 1; i &lt; nNumNeigh - len_Up; i ++ ) {</a>
<a name="ln414">            next2 = (first_Up+len_Up + i) % nNumNeigh; /* the 2nd after Up sequence */</a>
<a name="ln415">            if ( nBondType[nBondOrder[next2]] &gt; 0 ) {</a>
<a name="ln416">                next1 = (first_Up+len_Up) % nNumNeigh; /* the 1st after Up sequence */</a>
<a name="ln417">                dAngle = dBondDirection[nBondOrder[next1]] - dBondDirection[nBondOrder[next2]];</a>
<a name="ln418">                if ( fabs(dAngle) &lt; ZERO_ANGLE ) {</a>
<a name="ln419">                    inchi_swap( (char*)&amp;nBondOrder[next1], (char*)&amp;nBondOrder[next2], sizeof(nBondOrder[0]) );</a>
<a name="ln420">                    len_Up ++;</a>
<a name="ln421">                    break;</a>
<a name="ln422">                }</a>
<a name="ln423">            }</a>
<a name="ln424">        }</a>
<a name="ln425">    }</a>
<a name="ln426">    /* check whether the not-Up bond (located before the found first-Up) has */</a>
<a name="ln427">    /* same angle as the Up bond that precedes this not-Up bond */</a>
<a name="ln428">    if ( nNumNeigh - len_Up &gt;= 2 ) {</a>
<a name="ln429">        int next1, next2;</a>
<a name="ln430">        for ( i = 1; i &lt; nNumNeigh - len_Up; i ++ ) {</a>
<a name="ln431">            next2 = (first_Up+nNumNeigh - i - 1 ) % nNumNeigh; /* the 2nd before Up sequence */</a>
<a name="ln432">            if ( nBondType[nBondOrder[next2]] &gt; 0 ) {</a>
<a name="ln433">                next1 = (first_Up+nNumNeigh-1) % nNumNeigh; /* the 1st before Up sequence */</a>
<a name="ln434">                dAngle = dBondDirection[nBondOrder[next1]] - dBondDirection[nBondOrder[next2]];</a>
<a name="ln435">                if ( fabs(dAngle) &lt; ZERO_ANGLE ) {</a>
<a name="ln436">                    inchi_swap( (char*)&amp;nBondOrder[next1], (char*)&amp;nBondOrder[next2], sizeof(nBondOrder[0]) );</a>
<a name="ln437">                    first_Up = next1; </a>
<a name="ln438">                    len_Up ++;</a>
<a name="ln439">                    break;</a>
<a name="ln440">                }</a>
<a name="ln441">            }</a>
<a name="ln442">        }</a>
<a name="ln443">    }</a>
<a name="ln444">#else</a>
<a name="ln445">    if ( bFix2DstereoBorderCase ) {</a>
<a name="ln446">        /* check if the bonds with ordering numbers first_Up+len_Up and first_Up+len_Up+1 */</a>
<a name="ln447">        /* have identical angles. In this case switch their order to enlarge the Up sequence */</a>
<a name="ln448">#define ZERO_ANGLE  0.000001</a>
<a name="ln449">        if ( nNumNeigh - len_Up &gt;= 2 ) {</a>
<a name="ln450">            int next1, next2;</a>
<a name="ln451">            for ( i = 1; i &lt; nNumNeigh - len_Up; i ++ ) {</a>
<a name="ln452">                next2 = (first_Up+len_Up + i) % nNumNeigh; /* the 2nd after Up sequence */</a>
<a name="ln453">                if ( nBondType[nBondOrder[next2]] &gt; 0 ) {</a>
<a name="ln454">                    next1 = (first_Up+len_Up) % nNumNeigh; /* the 1st after Up sequence */</a>
<a name="ln455">                    dAngle = dBondDirection[nBondOrder[next1]] - dBondDirection[nBondOrder[next2]];</a>
<a name="ln456">                    if ( fabs(dAngle) &lt; ZERO_ANGLE ) {</a>
<a name="ln457">                        inchi_swap( (char*)&amp;nBondOrder[next1], (char*)&amp;nBondOrder[next2], sizeof(nBondOrder[0]) );</a>
<a name="ln458">                        len_Up ++;</a>
<a name="ln459">                        break;</a>
<a name="ln460">                    }</a>
<a name="ln461">                }</a>
<a name="ln462">            }</a>
<a name="ln463">        }</a>
<a name="ln464">        /* check whether the not-Up bond (located before the found first-Up) has */</a>
<a name="ln465">        /* same angle as the Up bond that precedes this not-Up bond */</a>
<a name="ln466">        if ( nNumNeigh - len_Up &gt;= 2 ) {</a>
<a name="ln467">            int next1, next2;</a>
<a name="ln468">            for ( i = 1; i &lt; nNumNeigh - len_Up; i ++ ) {</a>
<a name="ln469">                next2 = (first_Up+nNumNeigh - i - 1 ) % nNumNeigh; /* the 2nd before Up sequence */</a>
<a name="ln470">                if ( nBondType[nBondOrder[next2]] &gt; 0 ) {</a>
<a name="ln471">                    next1 = (first_Up+nNumNeigh-1) % nNumNeigh; /* the 1st before Up sequence */</a>
<a name="ln472">                    dAngle = dBondDirection[nBondOrder[next1]] - dBondDirection[nBondOrder[next2]];</a>
<a name="ln473">                    if ( fabs(dAngle) &lt; ZERO_ANGLE ) {</a>
<a name="ln474">                        inchi_swap( (char*)&amp;nBondOrder[next1], (char*)&amp;nBondOrder[next2], sizeof(nBondOrder[0]) );</a>
<a name="ln475">                        first_Up = next1; </a>
<a name="ln476">                        len_Up ++;</a>
<a name="ln477">                        break;</a>
<a name="ln478">                    }</a>
<a name="ln479">                }</a>
<a name="ln480">            }</a>
<a name="ln481">        }</a>
<a name="ln482">    }</a>
<a name="ln483">#endif</a>
<a name="ln484">    /*  Turn all the bonds around the center so that */</a>
<a name="ln485">    /*  the 1st Up bond has zero radian direction */</a>
<a name="ln486">    dAlpha = dBondDirection[nBondOrder[first_Up]];</a>
<a name="ln487">    for ( i = 0; i &lt; nNumNeigh; i ++ ) {</a>
<a name="ln488">        if ( i == nBondOrder[first_Up] ) {</a>
<a name="ln489">            dBondDirection[i] = 0.0;</a>
<a name="ln490">        } else {</a>
<a name="ln491">            dAngle = dBondDirection[i] - dAlpha;</a>
<a name="ln492">            if ( dAngle &lt; 0.0 ) {</a>
<a name="ln493">                dAngle += two_pi;</a>
<a name="ln494">            }</a>
<a name="ln495">            dBondDirection[i] = dAngle;</a>
<a name="ln496">        }</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">    /********************************************************</a>
<a name="ln500">     * Process particular cases</a>
<a name="ln501">     ********************************************************/</a>
<a name="ln502"> </a>
<a name="ln503"> </a>
<a name="ln504">    if ( nNumNeigh == 3 ) /************************ 3 bonds ************************/</a>
<a name="ln505">    {</a>
<a name="ln506">        </a>
<a name="ln507">        switch( num_Up ) </a>
<a name="ln508">        {</a>
<a name="ln509">            </a>
<a name="ln510"> </a>
<a name="ln511">            </a>
<a name="ln512">            case 0:	/* 0 Up */</a>
<a name="ln513">                    return T2D_UNDF;</a>
<a name="ln514">                </a>
<a name="ln515">            </a>
<a name="ln516"> </a>
<a name="ln517">            </a>
<a name="ln518">            case 1:	/* 1 Up */</a>
<a name="ln519">                    if ( num_Dn ) </a>
<a name="ln520">                    {</a>
<a name="ln521">#ifdef _DEBUG</a>
<a name="ln522">                        if ( num_Dn != 1 )  /*  debug only */</a>
<a name="ln523">                            return -1;</a>
<a name="ln524">#endif</a>
<a name="ln525">                        ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln526">                    } </a>
<a name="ln527">                    else </a>
<a name="ln528">                    {</a>
<a name="ln529">                        dAngle = dBondDirection[nBondOrder[(first_Up + 2) % nNumNeigh]] -</a>
<a name="ln530">                                 dBondDirection[nBondOrder[(first_Up + 1) % nNumNeigh]];</a>
<a name="ln531"> </a>
<a name="ln532">                        if ( dAngle &lt; 0.0 ) </a>
<a name="ln533">                            dAngle += two_pi;</a>
<a name="ln534">                        if ( dAngle - one_pi &lt; -MIN_ANGLE || dAngle - one_pi &gt; MIN_ANGLE  ) </a>
<a name="ln535">                        {</a>
<a name="ln536">                            ret = T2D_OKAY;</a>
<a name="ln537">                        }</a>
<a name="ln538">                        else </a>
<a name="ln539">                        {</a>
<a name="ln540">                            ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln541">                        }</a>
<a name="ln542">                    }</a>
<a name="ln543">                    break;</a>
<a name="ln544">        </a>
<a name="ln545"> </a>
<a name="ln546">            </a>
<a name="ln547">            </a>
<a name="ln548">            case 2:	/* 2 Up */</a>
<a name="ln549">                    if ( num_Dn ) </a>
<a name="ln550">                    {</a>
<a name="ln551">                        dAlpha = dBondDirection[nBondOrder[(first_Up + 1) % nNumNeigh]] -</a>
<a name="ln552">                                 dBondDirection[nBondOrder[(first_Up    ) % nNumNeigh]];</a>
<a name="ln553"> </a>
<a name="ln554">                        if ( dAlpha &lt; 0.0 ) </a>
<a name="ln555">                            dAlpha += two_pi;</a>
<a name="ln556"> </a>
<a name="ln557">                        if ( dAlpha &gt; one_pi - MIN_ANGLE ) </a>
<a name="ln558">                        {</a>
<a name="ln559">                            ret = T2D_OKAY;</a>
<a name="ln560">                        } </a>
<a name="ln561">                        else if ( dAlpha &lt; two_pi / 3.0 - MIN_ANGLE ) </a>
<a name="ln562">                        {</a>
<a name="ln563">                            ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln564">                        } </a>
<a name="ln565">                        else </a>
<a name="ln566">                        {</a>
<a name="ln567">                            /*  angle between 2 Up bonds is between 120 and 180 degrees */</a>
<a name="ln568">                            /*  direction of the (Alpha angle bisector) + 180 degrees	*/</a>
<a name="ln569">                            dBisector = dBondDirection[nBondOrder[(first_Up    ) % nNumNeigh]];</a>
<a name="ln570">                            dBisector+= dBondDirection[nBondOrder[(first_Up + 1 ) % nNumNeigh]];</a>
<a name="ln571">                            dBisector/= 2.0;</a>
<a name="ln572">                            dBisector-= one_pi;</a>
<a name="ln573">                            if ( dBisector &lt; 0.0 ) </a>
<a name="ln574">                            {</a>
<a name="ln575">                                dBisector += two_pi;</a>
<a name="ln576">                            }</a>
<a name="ln577">                            if ( dAlpha &lt; two_pi / 3.0 + MIN_ANGLE ) </a>
<a name="ln578">                            {</a>
<a name="ln579">                                /*  dAlpha is inside ( 2pi/3 - eps, 2pi/3 + eps ) interval */</a>
<a name="ln580">                                dLimit = MIN_ANGLE * 3.0 / 2.0;</a>
<a name="ln581">                            } </a>
<a name="ln582">                            else </a>
<a name="ln583">                            {</a>
<a name="ln584">                                dLimit = dAlpha * 3.0 / 2.0 - one_pi;</a>
<a name="ln585">                            }</a>
<a name="ln586"> </a>
<a name="ln587">                            dAngle = dBondDirection[nBondOrder[(first_Up + 2 ) % nNumNeigh]];</a>
<a name="ln588"> </a>
<a name="ln589">                            if ( dBisector - dAngle &lt; -dLimit ||</a>
<a name="ln590">                                  dBisector - dAngle &gt;  dLimit  ) </a>
<a name="ln591">                            {</a>
<a name="ln592">                                ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln593">                            } </a>
<a name="ln594">                            else </a>
<a name="ln595">                            {</a>
<a name="ln596">                                ret = T2D_OKAY;</a>
<a name="ln597">                            }</a>
<a name="ln598">                        }</a>
<a name="ln599">                    } /* if ( num_Dn )  */</a>
<a name="ln600">                    else </a>
<a name="ln601">                    {</a>
<a name="ln602">                        ret = T2D_OKAY;</a>
<a name="ln603">                    }</a>
<a name="ln604">                    break;</a>
<a name="ln605">        </a>
<a name="ln606">                    </a>
<a name="ln607">                    </a>
<a name="ln608">            case 3:	/* 3 Up */</a>
<a name="ln609">                    ret = T2D_OKAY;</a>
<a name="ln610">                    break;</a>
<a name="ln611">        </a>
<a name="ln612">                    </a>
<a name="ln613">            default:/* other Up */</a>
<a name="ln614">                    return -1;</a>
<a name="ln615"> </a>
<a name="ln616">        } /* eof switch( num_Up ) at  nNumNeigh == 3 */</a>
<a name="ln617"> </a>
<a name="ln618">    } </a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">    else if ( nNumNeigh == 4) /******************************* 4 bonds ********************/</a>
<a name="ln622">    {		</a>
<a name="ln623">        switch( num_Up ) </a>
<a name="ln624">        {</a>
<a name="ln625">        </a>
<a name="ln626">            case 0:	/* 0 Up */</a>
<a name="ln627">                    return T2D_UNDF;</a>
<a name="ln628"> </a>
<a name="ln629">        </a>
<a name="ln630">            case 1:	/* 1 Up */</a>
<a name="ln631">                    if ( num_Dn ) </a>
<a name="ln632">                    {</a>
<a name="ln633">                        if ( nBondType[nBondOrder[(first_Up + 2) % nNumNeigh]] &lt; 0 ) </a>
<a name="ln634">                        {</a>
<a name="ln635">                            /*</a>
<a name="ln636">                            * Up, In Plane, Dn, In Plane. Undefined if angle between</a>
<a name="ln637">                            * two In Plane bonds is wuthin pi +/- 2*arcsine(1/sqrt(8)) interval</a>
<a name="ln638">                            * That is, 138.5 to 221.4 degrees; for certainty the interval is</a>
<a name="ln639">                            * increased by 5.7 degrees at each end to</a>
<a name="ln640">                            * 134.8 to 227.1 degrees</a>
<a name="ln641">                            */</a>
<a name="ln642">                            dAngle = dBondDirection[nBondOrder[(first_Up + 3) % nNumNeigh]] -</a>
<a name="ln643">                                     dBondDirection[nBondOrder[(first_Up + 1) % nNumNeigh]];</a>
<a name="ln644">                            if ( dAngle &lt; 0.0 ) {</a>
<a name="ln645">                                dAngle += two_pi;</a>
<a name="ln646">                            }</a>
<a name="ln647">                            if ( fabs( dAngle - one_pi ) &lt; dAngleAndPiMaxDiff + MIN_ANGLE ) {</a>
<a name="ln648">                                ret = (T2D_UNDF | T2D_WARN); </a>
<a name="ln649">                            } </a>
<a name="ln650">                            else </a>
<a name="ln651">                            {</a>
<a name="ln652">                                ret = T2D_OKAY;</a>
<a name="ln653">                            }</a>
<a name="ln654">                        } </a>
<a name="ln655">                        else </a>
<a name="ln656">                        {</a>
<a name="ln657">                            ret = T2D_OKAY;</a>
<a name="ln658">                        }</a>
<a name="ln659">#ifdef _DEBUG</a>
<a name="ln660">                        if ( num_Dn != 1 )  /*  debug only */</a>
<a name="ln661">                        return -1;</a>
<a name="ln662">#endif</a>
<a name="ln663">                    } </a>
<a name="ln664">                    else </a>
<a name="ln665">                    {</a>
<a name="ln666">                        ret    = T2D_OKAY;</a>
<a name="ln667">                        dAngle = dBondDirection[nBondOrder[(first_Up + 3) % nNumNeigh]] -</a>
<a name="ln668">                                 dBondDirection[nBondOrder[(first_Up + 1) % nNumNeigh]];</a>
<a name="ln669">                        if ( dAngle &lt; 0.0 ) </a>
<a name="ln670">                        {</a>
<a name="ln671">                            dAngle += two_pi;</a>
<a name="ln672">                        }</a>
<a name="ln673">                        if ( dAngle &lt; one_pi - MIN_ANGLE ) </a>
<a name="ln674">                        {</a>
<a name="ln675">                            ret |= T2D_WARN;</a>
<a name="ln676">                        }</a>
<a name="ln677">                    }</a>
<a name="ln678">                    break;</a>
<a name="ln679"> </a>
<a name="ln680">        </a>
<a name="ln681">            case 2:	/* 2 Up */</a>
<a name="ln682">#if ( FIX_2D_STEREO_BORDER_CASE == 1 )</a>
<a name="ln683">                    if ( len_Up == 1 ) </a>
<a name="ln684">                    {</a>
<a name="ln685">                        ret = T2D_OKAY;</a>
<a name="ln686">                    } </a>
<a name="ln687">                    else </a>
<a name="ln688">                    {</a>
<a name="ln689">                        dAngle = dBondDirection[nBondOrder[(first_Up + 3) % nNumNeigh]] -</a>
<a name="ln690">                                 dBondDirection[nBondOrder[(first_Up + 0) % nNumNeigh]];</a>
<a name="ln691">                        dAngle = fabs(two_pi - dAngle);</a>
<a name="ln692">                        dAlpha = dBondDirection[nBondOrder[(first_Up + 2) % nNumNeigh]] -</a>
<a name="ln693">                                 dBondDirection[nBondOrder[(first_Up + 1) % nNumNeigh]];</a>
<a name="ln694">                        dAlpha = fabs(dAlpha);</a>
<a name="ln695">                        if ( dAngle &lt; 2.0 * ZERO_ANGLE &amp;&amp; dAlpha &gt; MIN_ANGLE ||</a>
<a name="ln696">                             dAlpha &lt; 2.0 * ZERO_ANGLE &amp;&amp; dAngle &gt; MIN_ANGLE  ) </a>
<a name="ln697">                        {</a>
<a name="ln698">                            ret = (T2D_OKAY | T2D_WARN);</a>
<a name="ln699">                        } </a>
<a name="ln700">                        else </a>
<a name="ln701">                        {</a>
<a name="ln702">                            ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln703">                        }</a>
<a name="ln704">                    }</a>
<a name="ln705">#else</a>
<a name="ln706">                    if ( bFix2DstereoBorderCase ) </a>
<a name="ln707">                    {</a>
<a name="ln708">                        /* bug fix */</a>
<a name="ln709">                        if ( len_Up == 1 ) </a>
<a name="ln710">                        {</a>
<a name="ln711">                            ret = T2D_OKAY;</a>
<a name="ln712">                        } </a>
<a name="ln713">                        else </a>
<a name="ln714">                        {</a>
<a name="ln715">                            dAngle = dBondDirection[nBondOrder[(first_Up + 3) % nNumNeigh]] -</a>
<a name="ln716">                                     dBondDirection[nBondOrder[(first_Up + 0) % nNumNeigh]];</a>
<a name="ln717">                            dAngle = fabs(two_pi - dAngle);</a>
<a name="ln718">                            dAlpha = dBondDirection[nBondOrder[(first_Up + 2) % nNumNeigh]] -</a>
<a name="ln719">                                     dBondDirection[nBondOrder[(first_Up + 1) % nNumNeigh]];</a>
<a name="ln720">                            dAlpha = fabs(dAlpha);</a>
<a name="ln721">                            if ( (dAngle &lt; 2.0 * ZERO_ANGLE &amp;&amp; dAlpha &gt; MIN_ANGLE) ||</a>
<a name="ln722">                                 (dAlpha &lt; 2.0 * ZERO_ANGLE &amp;&amp; dAngle &gt; MIN_ANGLE)  )</a>
<a name="ln723">                            {</a>
<a name="ln724">                                ret = (T2D_OKAY | T2D_WARN);</a>
<a name="ln725">                            } </a>
<a name="ln726">                            else </a>
<a name="ln727">                            {</a>
<a name="ln728">                            ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln729">                            }</a>
<a name="ln730">                        }</a>
<a name="ln731">                    } </a>
<a name="ln732">                    else </a>
<a name="ln733">                    {</a>
<a name="ln734">                        /* original InChI v. 1 bug */</a>
<a name="ln735">                        if ( cur_len_Up == 1 ) </a>
<a name="ln736">                        {</a>
<a name="ln737">                            ret = T2D_OKAY;</a>
<a name="ln738">                        } </a>
<a name="ln739">                        else </a>
<a name="ln740">                        {</a>
<a name="ln741">                            ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln742">                        }</a>
<a name="ln743">                    }</a>
<a name="ln744">#endif</a>
<a name="ln745">                    break;</a>
<a name="ln746">        </a>
<a name="ln747">        </a>
<a name="ln748">            case 3:	/* 3 Up */</a>
<a name="ln749">                    ret    = T2D_OKAY;</a>
<a name="ln750">                    dAngle = dBondDirection[nBondOrder[(first_Up + 2) % nNumNeigh]] -</a>
<a name="ln751">                             dBondDirection[nBondOrder[(first_Up + 0) % nNumNeigh]];</a>
<a name="ln752">                    if ( dAngle &lt; 0.0 ) </a>
<a name="ln753">                    {</a>
<a name="ln754">                        dAngle += two_pi;</a>
<a name="ln755">                    }</a>
<a name="ln756">                    if ( dAngle &lt; one_pi - MIN_ANGLE ) </a>
<a name="ln757">                    {</a>
<a name="ln758">                        ret |= T2D_WARN;</a>
<a name="ln759">                    }</a>
<a name="ln760">                    break;</a>
<a name="ln761">        </a>
<a name="ln762">            case 4:	/* 4 Up */</a>
<a name="ln763">                    ret = (T2D_UNDF | T2D_WARN);</a>
<a name="ln764">                    break;</a>
<a name="ln765">        </a>
<a name="ln766">            default:/* other Up */</a>
<a name="ln767">                    return -1; /*  program error */</a>
<a name="ln768">        </a>
<a name="ln769">        } /* eof switch( num_Up ) at  nNumNeigh == 4 */</a>
<a name="ln770"> </a>
<a name="ln771">        if ( ret == T2D_OKAY ) </a>
<a name="ln772">        {</a>
<a name="ln773">            /*  check whether all bonds are inside a less than 180 degrees sector */</a>
<a name="ln774">            for ( i = 0; i &lt; nNumNeigh; i ++ ) </a>
<a name="ln775">            {</a>
<a name="ln776">                dAngle = dBondDirection[nBondOrder[(i + nNumNeigh - 1) % nNumNeigh]] -</a>
<a name="ln777">                         dBondDirection[nBondOrder[ i % nNumNeigh]];</a>
<a name="ln778">                if ( dAngle &lt; 0.0 ) </a>
<a name="ln779">                {</a>
<a name="ln780">                    dAngle += two_pi;</a>
<a name="ln781">                }</a>
<a name="ln782">                if ( dAngle &lt; one_pi - MIN_ANGLE ) </a>
<a name="ln783">                {</a>
<a name="ln784">                    ret |= T2D_WARN;</a>
<a name="ln785">                    break;</a>
<a name="ln786">                }</a>
<a name="ln787">            }</a>
<a name="ln788">        }</a>
<a name="ln789"> </a>
<a name="ln790">    } /* eof nNumNeigh == 4 */</a>
<a name="ln791">    </a>
<a name="ln792">    else /*************************** number of bonds != 3 or 4 ******************/	</a>
<a name="ln793">    {</a>
<a name="ln794">        </a>
<a name="ln795">            return -1; /*  error */   </a>
<a name="ln796">    } </a>
<a name="ln797"> </a>
<a name="ln798"> </a>
<a name="ln799">    return ret;</a>
<a name="ln800"> </a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">/*************************************************************/</a>
<a name="ln804">double triple_prod_and_min_abs_sine2(double at_coord[][3], double central_at_coord[], int bAddedExplicitNeighbor, double *min_sine, int *bAmbiguous)</a>
<a name="ln805">{</a>
<a name="ln806">    double min_sine_value=9999.0, sine_value, min_edge_len, max_edge_len, min_edge_len_NoExplNeigh, max_edge_len_NoExplNeigh;</a>
<a name="ln807">    double s0, s1, s2, s3, e01, e02, e03, e12, e13, e23, tmp[3], e[3][3];</a>
<a name="ln808">    double prod, ret, central_prod[4];</a>
<a name="ln809">    int    bLongEdges;</a>
<a name="ln810"> </a>
<a name="ln811">    if ( !min_sine ) {</a>
<a name="ln812">        return triple_prod( at_coord[0], at_coord[1], at_coord[2], NULL );</a>
<a name="ln813">    }</a>
<a name="ln814">    </a>
<a name="ln815">    ret = triple_prod( at_coord[0], at_coord[1], at_coord[2], &amp;sine_value );</a>
<a name="ln816">    sine_value = MPY_SINE * fabs( sine_value );</a>
<a name="ln817">    </a>
<a name="ln818">    diff3( at_coord[1], at_coord[0], e[2] );</a>
<a name="ln819">    diff3( at_coord[0], at_coord[2], e[1] );</a>
<a name="ln820">    diff3( at_coord[2], at_coord[1], e[0] );</a>
<a name="ln821">    </a>
<a name="ln822">    /*  lengths of the 6 edges of the tetrahedra */</a>
<a name="ln823">    e03 = len3( at_coord[0] ); /* 1 */</a>
<a name="ln824">    e13 = len3( at_coord[1] );</a>
<a name="ln825">    e23 = len3( at_coord[2] ); /* includes added neighbor if bAddedExplicitNeighbor*/</a>
<a name="ln826">    e02 = len3( e[1] );        /* includes added neighbor if bAddedExplicitNeighbor*/</a>
<a name="ln827">    e12 = len3( e[0] );        /* includes added neighbor if bAddedExplicitNeighbor*/</a>
<a name="ln828">    e01 = len3( e[2] );        </a>
<a name="ln829">    </a>
<a name="ln830">    /*  min &amp; max edge length */</a>
<a name="ln831">    max_edge_len =</a>
<a name="ln832">    min_edge_len = e03;</a>
<a name="ln833"> </a>
<a name="ln834">    if ( min_edge_len &gt; e13 )</a>
<a name="ln835">        min_edge_len = e13;</a>
<a name="ln836">    if ( min_edge_len &gt; e01 )</a>
<a name="ln837">        min_edge_len = e01;</a>
<a name="ln838">    min_edge_len_NoExplNeigh = min_edge_len;</a>
<a name="ln839"> </a>
<a name="ln840">    if ( min_edge_len &gt; e23 )</a>
<a name="ln841">        min_edge_len = e23;</a>
<a name="ln842">    if ( min_edge_len &gt; e02 )</a>
<a name="ln843">        min_edge_len = e02;</a>
<a name="ln844">    if ( min_edge_len &gt; e12 )</a>
<a name="ln845">        min_edge_len = e12;</a>
<a name="ln846"> </a>
<a name="ln847">    if ( max_edge_len &lt; e13 )</a>
<a name="ln848">        max_edge_len = e13;</a>
<a name="ln849">    if ( max_edge_len &lt; e01 )</a>
<a name="ln850">        max_edge_len = e01;</a>
<a name="ln851">    max_edge_len_NoExplNeigh = max_edge_len;</a>
<a name="ln852"> </a>
<a name="ln853">    if ( max_edge_len &lt; e23 )</a>
<a name="ln854">        max_edge_len = e23;</a>
<a name="ln855">    if ( max_edge_len &lt; e02 )</a>
<a name="ln856">        max_edge_len = e02;</a>
<a name="ln857">    if ( max_edge_len &lt; e12 )</a>
<a name="ln858">        max_edge_len = e12;</a>
<a name="ln859">    </a>
<a name="ln860">    if ( !bAddedExplicitNeighbor ) {</a>
<a name="ln861">        min_edge_len_NoExplNeigh = min_edge_len;</a>
<a name="ln862">        max_edge_len_NoExplNeigh = max_edge_len;</a>
<a name="ln863">    }</a>
<a name="ln864"> </a>
<a name="ln865">    bLongEdges = bAddedExplicitNeighbor? </a>
<a name="ln866">                  ( max_edge_len_NoExplNeigh &lt; MAX_EDGE_RATIO * min_edge_len_NoExplNeigh ) :</a>
<a name="ln867">                  ( max_edge_len             &lt; MAX_EDGE_RATIO * min_edge_len );</a>
<a name="ln868"> </a>
<a name="ln869">    if ( sine_value &gt; MIN_SINE &amp;&amp; ( min_sine || bAmbiguous ) ) {</a>
<a name="ln870">        if ( min_sine ) {</a>
<a name="ln871">            prod = fabs( ret );</a>
<a name="ln872">            /*  tetrahedra height = volume(prod) / area of a plane(cross_prod) */</a>
<a name="ln873">            /*  (instead of a tetrahedra calculate parallelogram/parallelepiped area/volume) */</a>
<a name="ln874"> </a>
<a name="ln875">            /*  4 heights from each of the 4 vertices to the opposite plane */</a>
<a name="ln876">            s0  = prod / len3( cross_prod3( at_coord[1], at_coord[2], tmp ) );</a>
<a name="ln877">            s1  = prod / len3( cross_prod3( at_coord[0], at_coord[2], tmp ) );</a>
<a name="ln878">            s2  = prod / len3( cross_prod3( at_coord[0], at_coord[1], tmp ) );</a>
<a name="ln879">            s3  = prod / len3( cross_prod3( e[0], e[1], tmp ) );</a>
<a name="ln880">            /*  abs. value of a sine of an angle between each tetrahedra edge and plane */</a>
<a name="ln881">            /*  sine = height / edge length */</a>
<a name="ln882">            if ( (sine_value = s0/e01) &lt; min_sine_value )</a>
<a name="ln883">                min_sine_value = sine_value;</a>
<a name="ln884">            if ( (sine_value = s0/e02) &lt; min_sine_value )</a>
<a name="ln885">                min_sine_value = sine_value;</a>
<a name="ln886">            if ( (sine_value = s0/e03) &lt; min_sine_value )</a>
<a name="ln887">                min_sine_value = sine_value;</a>
<a name="ln888"> </a>
<a name="ln889">            if ( (sine_value = s1/e01) &lt; min_sine_value )</a>
<a name="ln890">                min_sine_value = sine_value;</a>
<a name="ln891">            if ( (sine_value = s1/e12) &lt; min_sine_value )</a>
<a name="ln892">                min_sine_value = sine_value;</a>
<a name="ln893">            if ( (sine_value = s1/e13) &lt; min_sine_value )</a>
<a name="ln894">                min_sine_value = sine_value;</a>
<a name="ln895"> </a>
<a name="ln896">            if ( (sine_value = s2/e02) &lt; min_sine_value )</a>
<a name="ln897">                min_sine_value = sine_value;</a>
<a name="ln898">            if ( (sine_value = s2/e12) &lt; min_sine_value )</a>
<a name="ln899">                min_sine_value = sine_value;</a>
<a name="ln900">            if ( (sine_value = s2/e23) &lt; min_sine_value )</a>
<a name="ln901">                min_sine_value = sine_value;</a>
<a name="ln902"> </a>
<a name="ln903">            if ( (sine_value = s3/e03) &lt; min_sine_value )</a>
<a name="ln904">                min_sine_value = sine_value;</a>
<a name="ln905">            if ( (sine_value = s3/e13) &lt; min_sine_value )</a>
<a name="ln906">                min_sine_value = sine_value;</a>
<a name="ln907">            if ( (sine_value = s3/e23) &lt; min_sine_value )</a>
<a name="ln908">                min_sine_value = sine_value;</a>
<a name="ln909">            /*  actually use triple sine */</a>
<a name="ln910">            *min_sine = sine_value = MPY_SINE * min_sine_value;</a>
<a name="ln911">        }</a>
<a name="ln912"> </a>
<a name="ln913">        if ( bAmbiguous &amp;&amp; sine_value &gt;= MIN_SINE ) {</a>
<a name="ln914">            /*  check whether the central atom is outside the tetrahedra (0,0,0), at_coord[0,1,2] */</a>
<a name="ln915">            /*  compare the tetrahedra volume and the volume of a tetrahedra having central_at_coord[] vertex */</a>
<a name="ln916">            int i;</a>
<a name="ln917">            diff3( central_at_coord, at_coord[0], tmp );</a>
<a name="ln918">            central_prod[0] = triple_prod( at_coord[0], at_coord[1], central_at_coord, NULL );</a>
<a name="ln919">            central_prod[1] = triple_prod( at_coord[1], at_coord[2], central_at_coord, NULL );</a>
<a name="ln920">            central_prod[2] = triple_prod( at_coord[2], at_coord[0], central_at_coord, NULL );</a>
<a name="ln921">            central_prod[3] = triple_prod( e[2], e[1], tmp, NULL );</a>
<a name="ln922">            for ( i = 0; i &lt;= 3; i ++ ) {</a>
<a name="ln923">                if ( central_prod[i] / ret &lt; -MIN_SINE_OUTSIDE ) {</a>
<a name="ln924">                    *bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln925">                    break;</a>
<a name="ln926">                }</a>
<a name="ln927">            }</a>
<a name="ln928">        }</a>
<a name="ln929">#if ( STEREO_CENTER_BONDS_NORM == 1 )        </a>
<a name="ln930">        </a>
<a name="ln931">        if ( bLongEdges &amp;&amp; !bAddedExplicitNeighbor &amp;&amp; max_edge_len &gt;= MIN_LEN_STRAIGHT ) {</a>
<a name="ln932">            /*  possible planar tetragon */</a>
<a name="ln933">            if ( sine_value &lt; MIN_SINE_SQUARE ) {</a>
<a name="ln934">                *min_sine = MIN_SINE / 2.0; /*  force parity to be undefined */</a>
<a name="ln935">                if ( bAmbiguous &amp;&amp; !*bAmbiguous ) {</a>
<a name="ln936">                    *bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln937">                }</a>
<a name="ln938">            }</a>
<a name="ln939">        }</a>
<a name="ln940">        </a>
<a name="ln941">        if ( bLongEdges &amp;&amp; sine_value &lt; MIN_SINE_SQUARE &amp;&amp; sine_value &lt; MIN_SINE_EDGE * min_edge_len_NoExplNeigh ) {</a>
<a name="ln942">            *min_sine = MIN_SINE / 2.0; /*  force parity to be undefined */</a>
<a name="ln943">            if ( bAmbiguous &amp;&amp; !*bAmbiguous ) {</a>
<a name="ln944">                *bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln945">            }</a>
<a name="ln946">        }</a>
<a name="ln947">#endif</a>
<a name="ln948"> </a>
<a name="ln949">    } else</a>
<a name="ln950">    if ( min_sine ) {</a>
<a name="ln951">        *min_sine = sine_value;</a>
<a name="ln952">    }</a>
<a name="ln953">    </a>
<a name="ln954">    return ret;</a>
<a name="ln955">}</a>
<a name="ln956">/*************************************************************/</a>
<a name="ln957">double triple_prod_and_min_abs_sine(double at_coord[][3], double *min_sine)</a>
<a name="ln958">{</a>
<a name="ln959">    double min_sine_value=9999.0, sine_value;</a>
<a name="ln960">    double prod=0.0;</a>
<a name="ln961"> </a>
<a name="ln962">    if ( !min_sine ) {</a>
<a name="ln963">        return triple_prod( at_coord[0], at_coord[1], at_coord[2], NULL );</a>
<a name="ln964">    }</a>
<a name="ln965">    </a>
<a name="ln966">    prod = triple_prod( at_coord[0], at_coord[1], at_coord[2], &amp;sine_value );</a>
<a name="ln967">    sine_value = fabs( sine_value );</a>
<a name="ln968">    min_sine_value = inchi_min( min_sine_value, sine_value );</a>
<a name="ln969">    </a>
<a name="ln970">    prod = triple_prod( at_coord[1], at_coord[2], at_coord[0], &amp;sine_value );</a>
<a name="ln971">    sine_value = fabs( sine_value );</a>
<a name="ln972">    min_sine_value = inchi_min( min_sine_value, sine_value );</a>
<a name="ln973">    </a>
<a name="ln974">    prod = triple_prod( at_coord[2], at_coord[0], at_coord[1], &amp;sine_value );</a>
<a name="ln975">    sine_value = fabs( sine_value );</a>
<a name="ln976">    min_sine_value = inchi_min( min_sine_value, sine_value );</a>
<a name="ln977"> </a>
<a name="ln978">    *min_sine = min_sine_value;</a>
<a name="ln979">    </a>
<a name="ln980">    return prod;</a>
<a name="ln981">}</a>
<a name="ln982">/*************************************************************/</a>
<a name="ln983">/*  Find if point (0,0,0)a and 3 atoms are in one plane */</a>
<a name="ln984">int are_3_vect_in_one_plane( double at_coord[][3], double min_sine)</a>
<a name="ln985">{</a>
<a name="ln986">    double actual_min_sine;</a>
<a name="ln987">    double prod;</a>
<a name="ln988">    prod = triple_prod_and_min_abs_sine( at_coord, &amp;actual_min_sine);</a>
<a name="ln989">    return actual_min_sine &lt;= min_sine;</a>
<a name="ln990">}</a>
<a name="ln991">/*************************************************************/</a>
<a name="ln992">/*  Find if 4 atoms are in one plane */</a>
<a name="ln993">int are_4at_in_one_plane( double at_coord[][3], double min_sine)</a>
<a name="ln994">{</a>
<a name="ln995">    double actual_min_sine, min_actual_min_sine;</a>
<a name="ln996">    double coord[3][3], prod;</a>
<a name="ln997">    int i, k, j;</a>
<a name="ln998">    for ( k = 0; k &lt; 4; k ++ ) { /* cycle added 4004-08-15 */</a>
<a name="ln999">        for ( i = j = 0; i &lt; 4; i ++ ) {</a>
<a name="ln1000">            if ( i != k ) {</a>
<a name="ln1001">                diff3( at_coord[i], at_coord[k], coord[j] );</a>
<a name="ln1002">                j ++;</a>
<a name="ln1003">            }</a>
<a name="ln1004">        }</a>
<a name="ln1005">        prod = triple_prod_and_min_abs_sine( coord, &amp;actual_min_sine);</a>
<a name="ln1006">        if ( !k || actual_min_sine &lt; min_actual_min_sine ) {</a>
<a name="ln1007">            min_actual_min_sine = actual_min_sine;</a>
<a name="ln1008">        }</a>
<a name="ln1009">    }</a>
<a name="ln1010">    return min_actual_min_sine &lt;= min_sine;</a>
<a name="ln1011">}</a>
<a name="ln1012">/*************************************************************/</a>
<a name="ln1013">int triple_prod_char( inp_ATOM *at, int at_1, int i_next_at_1, S_CHAR *z_dir1,</a>
<a name="ln1014">                                    int at_2, int i_next_at_2, S_CHAR *z_dir2 )</a>
<a name="ln1015">{</a>
<a name="ln1016">    inp_ATOM *at1, *at2;</a>
<a name="ln1017">    double    pnt[3][3], len;</a>
<a name="ln1018">    int       i;</a>
<a name="ln1019">    int       ret = 0;</a>
<a name="ln1020"> </a>
<a name="ln1021">    at1 = at + at_1;</a>
<a name="ln1022">    at2 = at + at[at_1].neighbor[i_next_at_1];</a>
<a name="ln1023"> </a>
<a name="ln1024">    pnt[0][0] = at2-&gt;x - at1-&gt;x;</a>
<a name="ln1025">    pnt[0][1] = at2-&gt;y - at1-&gt;y;</a>
<a name="ln1026">    pnt[0][2] = at2-&gt;z - at1-&gt;z;</a>
<a name="ln1027"> </a>
<a name="ln1028">    at2 = at + at_2;</a>
<a name="ln1029">    at1 = at + at[at_2].neighbor[i_next_at_2];</a>
<a name="ln1030"> </a>
<a name="ln1031">    pnt[1][0] = at2-&gt;x - at1-&gt;x; </a>
<a name="ln1032">    pnt[1][1] = at2-&gt;y - at1-&gt;y; </a>
<a name="ln1033">    pnt[1][2] = at2-&gt;z - at1-&gt;z;</a>
<a name="ln1034">/*</a>
<a name="ln1035"> *  resultant pnt vector directions:</a>
<a name="ln1036"> *</a>
<a name="ln1037"> *         pnt[0]              pnt[1]</a>
<a name="ln1038"> *</a>
<a name="ln1039"> *   [at_1]----&gt;[...]    [...]----&gt;[at_2]</a>
<a name="ln1040"> *</a>
<a name="ln1041"> *  </a>
<a name="ln1042"> *  add3 below: (pnt[0] + pnt[1]) -&gt; pnt[1]</a>
<a name="ln1043"> */</a>
<a name="ln1044">    add3( pnt[0], pnt[1], pnt[1] );</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047"> </a>
<a name="ln1048">    for ( i = 0; i &lt; 3; i ++ ) {</a>
<a name="ln1049">        pnt[0][i] = (double)z_dir1[i];</a>
<a name="ln1050">        pnt[2][i] = (double)z_dir2[i];</a>
<a name="ln1051">    }</a>
<a name="ln1052">    for ( i = 0; i &lt; 3; i ++ ) {</a>
<a name="ln1053">        len = len3( pnt[i] );</a>
<a name="ln1054">        if ( len &lt; MIN_BOND_LEN ) {</a>
<a name="ln1055">            if ( i == 1 &amp;&amp; (at[at_1].bUsed0DParity || at[at_2].bUsed0DParity) ) {</a>
<a name="ln1056">                pnt[i][0] = 0.0;</a>
<a name="ln1057">                pnt[i][1] = 1.0;</a>
<a name="ln1058">                pnt[i][2] = 0.0;</a>
<a name="ln1059">                len = 1.0; /* standard at_1--&gt;at_2 vector coordinates in case of 0D allene */</a>
<a name="ln1060">            } else {</a>
<a name="ln1061">                goto exit_function; /*  too short bond */</a>
<a name="ln1062">            }</a>
<a name="ln1063">        }</a>
<a name="ln1064">        mult3( pnt[i], 1.0/len, pnt[i] );</a>
<a name="ln1065">    }</a>
<a name="ln1066">    len = 100.0*triple_prod(pnt[0], pnt[1], pnt[2], NULL );</a>
<a name="ln1067">/*</a>
<a name="ln1068"> *   ^ pnt[0]</a>
<a name="ln1069"> *   |                         The orientation on this diagram</a>
<a name="ln1070"> *   |                         produces len = -100</a>
<a name="ln1071"> *  [at_1]------&gt;[at_2]</a>
<a name="ln1072"> *        pnt[1]    /</a>
<a name="ln1073"> *                 /</a>
<a name="ln1074"> *                / pnt[2]  (up from the plane)</a>
<a name="ln1075"> *               v</a>
<a name="ln1076"> *</a>
<a name="ln1077"> * Note: len is invariant upon at_1 &lt;--&gt; at_2 transposition because</a>
<a name="ln1078"> *       triple product changes sign upon pnt[0]&lt;--&gt;pnt[2] transposition and</a>
<a name="ln1079"> *       triple product changes sign upon pnt[1]--&gt; -pnt[1] change of direction:</a>
<a name="ln1080"> *</a>
<a name="ln1081"> * triple_prod(pnt[0],  pnt[1], pnt[2], NULL ) =</a>
<a name="ln1082"> * triple_prod(pnt[2], -pnt[1], pnt[0], NULL )</a>
<a name="ln1083"> *</a>
<a name="ln1084"> */</a>
<a name="ln1085">    </a>
<a name="ln1086">    ret = len &gt;= 0.0? (int)(floor(len+0.5)) : -(int)(floor(0.5-len));</a>
<a name="ln1087"> </a>
<a name="ln1088">exit_function:</a>
<a name="ln1089"> </a>
<a name="ln1090">    return ret;</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093"> </a>
<a name="ln1094">/****************************************************************/</a>
<a name="ln1095"> </a>
<a name="ln1096">#if ( NEW_STEREOCENTER_CHECK == 1 ) /* { */</a>
<a name="ln1097"> </a>
<a name="ln1098">/********************************************************************************************/</a>
<a name="ln1099">int bInpAtomHasRequirdNeigh ( inp_ATOM *at, int cur_at, int RequirdNeighType, int NumDbleBonds )</a>
<a name="ln1100">{</a>
<a name="ln1101">    /* RequirdNeighType:</a>
<a name="ln1102">          reqired neighbor types (bitmap):</a>
<a name="ln1103">               0 =&gt; any neighbors</a>
<a name="ln1104">               1 =&gt; no terminal hydrogen atom neighbors</a>
<a name="ln1105">               2 =&gt; no terminal -X and -XH together (don't care about -X, -XH bond type, charge, radical)</a>
<a name="ln1106">                    (X = tautomeric endpoint atom)</a>
<a name="ln1107">       NumDbleBonds:</a>
<a name="ln1108">          if non-zero then allow double, alternating and tautomeric bonds</a>
<a name="ln1109">    */</a>
<a name="ln1110">    int i, j, ni, nj, bond_type, num_1s, num_mult, num_other;</a>
<a name="ln1111"> </a>
<a name="ln1112">    if ( at[cur_at].endpoint ) {  /*  tautomeric endpoint cannot be a stereo center */</a>
<a name="ln1113">        return 0;</a>
<a name="ln1114">    }</a>
<a name="ln1115"> </a>
<a name="ln1116">    if ( (1 &amp; RequirdNeighType) &amp;&amp; at[cur_at].num_H ) {</a>
<a name="ln1117">        return 0;</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    if ( 2 &amp; RequirdNeighType ) {</a>
<a name="ln1121">        for ( i = 0; i &lt; at[cur_at].valence; i ++ ) {</a>
<a name="ln1122">            ni = (int)at[cur_at].neighbor[i];</a>
<a name="ln1123">            if ( at[ni].valence != 1 ||</a>
<a name="ln1124">                 !get_endpoint_valence( at[ni].el_number ) ) {</a>
<a name="ln1125">                continue;</a>
<a name="ln1126">            }</a>
<a name="ln1127">            for ( j = i+1; j &lt; at[cur_at].valence; j ++ ) {</a>
<a name="ln1128">                nj = (int)at[cur_at].neighbor[j];</a>
<a name="ln1129">                if ( at[nj].valence != 1 || </a>
<a name="ln1130">                     at[ni].el_number != at[nj].el_number || </a>
<a name="ln1131">                     !get_endpoint_valence( at[nj].el_number ) ) {</a>
<a name="ln1132">                    continue;</a>
<a name="ln1133">                }</a>
<a name="ln1134">                /*</a>
<a name="ln1135">                 * if (at[ni].num_H != at[nj].num_H) then the atoms (neighbors of at[cur_at]</a>
<a name="ln1136">                 * are tautomeric endpoints and are indistinguishable =&gt; cur_at is not stereogenic</a>
<a name="ln1137">                 * if (at[ni].num_H == at[nj].num_H) then the neighbors are indistinguishable</a>
<a name="ln1138">                 * and cur_at will be found non-sterogenic later</a>
<a name="ln1139">                 * get_endpoint_valence() check will not allow the neighbors to be carbons</a>
<a name="ln1140">                 * Therefore the following &quot;if&quot; is not needed; we may just return 0.</a>
<a name="ln1141">                 */</a>
<a name="ln1142">                if ( at[ni].num_H != at[nj].num_H &amp;&amp; strcmp(at[ni].elname, &quot;C&quot; ) ) {</a>
<a name="ln1143">                    return 0; /*  found -X and -XH neighbors */</a>
<a name="ln1144">                }</a>
<a name="ln1145">            }</a>
<a name="ln1146">        }</a>
<a name="ln1147">    }</a>
<a name="ln1148">    </a>
<a name="ln1149">    num_1s = num_mult = num_other = 0;</a>
<a name="ln1150"> </a>
<a name="ln1151">    for ( i = 0; i &lt; at[cur_at].valence; i ++ ) {</a>
<a name="ln1152">        bond_type = (at[cur_at].bond_type[i] &amp; ~BOND_MARK_ALL);</a>
<a name="ln1153">        switch( bond_type ) {</a>
<a name="ln1154">        case BOND_SINGLE:</a>
<a name="ln1155">            num_1s ++;</a>
<a name="ln1156">            break;</a>
<a name="ln1157">        case BOND_DOUBLE:</a>
<a name="ln1158">        case BOND_ALTERN:</a>
<a name="ln1159">        case BOND_TAUTOM:</a>
<a name="ln1160">        case BOND_ALT12NS:</a>
<a name="ln1161">            num_mult ++;</a>
<a name="ln1162">            break;</a>
<a name="ln1163">        default:</a>
<a name="ln1164">            num_other ++;</a>
<a name="ln1165">            break;</a>
<a name="ln1166">        }</a>
<a name="ln1167">    }</a>
<a name="ln1168">    </a>
<a name="ln1169">    if ( num_other ) {</a>
<a name="ln1170">        return 0;</a>
<a name="ln1171">    }</a>
<a name="ln1172"> </a>
<a name="ln1173">    if ( (NumDbleBonds &amp;&amp; NumDbleBonds &gt; num_mult) ||</a>
<a name="ln1174">         (!NumDbleBonds &amp;&amp; at[cur_at].valence != num_1s) ) {</a>
<a name="ln1175">        return 0;</a>
<a name="ln1176">    }</a>
<a name="ln1177">    return 1;</a>
<a name="ln1178">}</a>
<a name="ln1179">/********************************************************************************************/</a>
<a name="ln1180">int bCanInpAtomBeAStereoCenter( inp_ATOM *at, int cur_at, int bPointedEdgeStereo )</a>
<a name="ln1181">{</a>
<a name="ln1182">    </a>
<a name="ln1183">/*************************************************************************************</a>
<a name="ln1184"> * current version</a>
<a name="ln1185"> *************************************************************************************</a>
<a name="ln1186"> *       Use #define to split the stereocenter description table into parts</a>
<a name="ln1187"> *       to make it easier to read</a>
<a name="ln1188"> *</a>
<a name="ln1189"> *                      --------- 4 single bonds stereocenters -------</a>
<a name="ln1190"> *                       0       1       2       3      4       5</a>
<a name="ln1191"> *                                                                    </a>
<a name="ln1192"> *                       |       |       |       |      |       |     </a>
<a name="ln1193"> *                      -C-     -Si-    -Ge-    -Sn-   &gt;As[+]  &gt;B[-]  </a>
<a name="ln1194"> *                       |       |       |       |      |       |     </a>
<a name="ln1195"> */</a>
<a name="ln1196">#define SZELEM1         &quot;C\000&quot;,&quot;Si&quot;,   &quot;Ge&quot;,   &quot;Sn&quot;,   &quot;As&quot;, &quot;B\000&quot;,</a>
<a name="ln1197">#define CCHARGE1         0,      0,      0,      0,      1,   -1,    </a>
<a name="ln1198">#define CNUMBONDSANDH1   4,      4,      4,      4,      4,    4,    </a>
<a name="ln1199">#define CCHEMVALENCEH1   4,      4,      4,      4,      4,    4,    </a>
<a name="ln1200">#define CHAS3MEMBRING1   0,      0,      0,      0,      0,    0,    </a>
<a name="ln1201">#define CREQUIRDNEIGH1   0,      0,      0,      0,      3,    0,    </a>
<a name="ln1202">/*</a>
<a name="ln1203"> *                      --------------- S, Se stereocenters ----------</a>
<a name="ln1204"> *                       6       7       8       9      10     11    12    13</a>
<a name="ln1205"> *                                                                                </a>
<a name="ln1206"> *                               |       |      ||             |     |     ||     </a>
<a name="ln1207"> *                      -S=     =S=     -S[+]   &gt;S[+]   -Se=  =Se=  -Se[+] &gt;Se[+] </a>
<a name="ln1208"> *                       |       |       |       |       |     |     |      |     </a>
<a name="ln1209"> */</a>
<a name="ln1210">#define SZELEM2         &quot;S\000&quot;,&quot;S\000&quot;,&quot;S\000&quot;,&quot;S\000&quot;,&quot;Se&quot;, &quot;Se&quot;, &quot;Se&quot;,  &quot;Se&quot;,  </a>
<a name="ln1211">#define CCHARGE2         0,      0,      1,      1,      0,    0,    1,     1,    </a>
<a name="ln1212">#define CNUMBONDSANDH2   3,      4,      3,      4,      3,    4,    3,     4,    </a>
<a name="ln1213">#define CCHEMVALENCEH2   4,      6,      3,      5,      4,    6,    3,     5,    </a>
<a name="ln1214">#define CHAS3MEMBRING2   0,      0,      0,      0,      0,    0,    0,     0,    </a>
<a name="ln1215">#define CREQUIRDNEIGH2   3,      3,      3,      3,      3,    3,    3,     3,</a>
<a name="ln1216">/*</a>
<a name="ln1217"> *                      ------------------ N, P stereocenters -----------------</a>
<a name="ln1218"> *                        14     15       16     17     18       19       20    </a>
<a name="ln1219"> *                                                                               </a>
<a name="ln1220"> *                                                             Phosphine Arsine  </a>
<a name="ln1221"> *                                      X---Y                                    </a>
<a name="ln1222"> *                        |      |       \ /     |       |       \ /      \ /    </a>
<a name="ln1223"> *                       =N-    &gt;N[+]     N     &gt;P[+]   =P-       P        As    </a>
<a name="ln1224"> *                        |      |        |      |       |        |        |     </a>
<a name="ln1225"> */                                                                              </a>
<a name="ln1226">#define SZELEM3         &quot;N\000&quot;,&quot;N\000&quot;,&quot;N\000&quot;,&quot;P\000&quot;,&quot;P\000&quot;,&quot;P\000&quot;, &quot;As&quot;,</a>
<a name="ln1227">#define CCHARGE3         0,      1,      0,      1,      0,      0,       0,     </a>
<a name="ln1228">#define CNUMBONDSANDH3   4,      4,      3,      4,      4,      3,       3,     </a>
<a name="ln1229">#define CCHEMVALENCEH3   5,      4,      3,      4,      5,      3,       3,     </a>
<a name="ln1230">#define CHAS3MEMBRING3   0,      0,      1,      0,      0,      0,       0,     </a>
<a name="ln1231">#define CREQUIRDNEIGH3   3,      3,      1,      3,      3,      2,       2,     </a>
<a name="ln1232"> </a>
<a name="ln1233">#define PHOSPHINE_STEREO  19  /* the number must match Phosphine number in the comments, see above */</a>
<a name="ln1234">#define ARSINE_STEREO     20  /* the number must match Arsine number in the comments, see above */</a>
<a name="ln1235"> </a>
<a name="ln1236">    static char        szElem[][3]={ SZELEM1         SZELEM2         SZELEM3        };</a>
<a name="ln1237">    static S_CHAR        cCharge[]={ CCHARGE1        CCHARGE2        CCHARGE3       };</a>
<a name="ln1238">    static S_CHAR  cNumBondsAndH[]={ CNUMBONDSANDH1  CNUMBONDSANDH2  CNUMBONDSANDH3 };</a>
<a name="ln1239">    static S_CHAR  cChemValenceH[]={ CCHEMVALENCEH1  CCHEMVALENCEH2  CCHEMVALENCEH3 };</a>
<a name="ln1240">    static S_CHAR  cHas3MembRing[]={ CHAS3MEMBRING1  CHAS3MEMBRING2  CHAS3MEMBRING3 };</a>
<a name="ln1241">    static S_CHAR  cRequirdNeigh[]={ CREQUIRDNEIGH1  CREQUIRDNEIGH2  CREQUIRDNEIGH3 };</a>
<a name="ln1242"> </a>
<a name="ln1243">    static int n = sizeof(szElem)/sizeof(szElem[0]);</a>
<a name="ln1244">    /* reqired neighbor types (bitmap):</a>
<a name="ln1245">       0 =&gt; check bonds only</a>
<a name="ln1246">       1 =&gt; no terminal hydrogen atom neighbors</a>
<a name="ln1247">       2 =&gt; no terminal -X and -XH together (don't care the bond type, charge, radical)</a>
<a name="ln1248">            (X = tautomeric endpoint atom)</a>
<a name="ln1249">       Note: whenever cChemValenceH[] &gt; cNumBondsAndH[]</a>
<a name="ln1250">             the tautomeric and/or alternating bonds</a>
<a name="ln1251">             are permitted</a>
<a name="ln1252"> </a>
<a name="ln1253">    */</a>
<a name="ln1254">    int i, ret = 0;</a>
<a name="ln1255">    for ( i = 0; i &lt; n; i++ ) {</a>
<a name="ln1256">        if ( !strcmp( at[cur_at].elname, szElem[i]) &amp;&amp;</a>
<a name="ln1257">             at[cur_at].charge == cCharge[i] &amp;&amp;</a>
<a name="ln1258">             (!at[cur_at].radical || at[cur_at].radical == 1) &amp;&amp;</a>
<a name="ln1259">             at[cur_at].valence           +at[cur_at].num_H == cNumBondsAndH[i] &amp;&amp;</a>
<a name="ln1260">             at[cur_at].chem_bonds_valence+at[cur_at].num_H == cChemValenceH[i] &amp;&amp;</a>
<a name="ln1261">             (cHas3MembRing[i]? is_atom_in_3memb_ring( at, cur_at ) : 1) &amp;&amp;</a>
<a name="ln1262">             bInpAtomHasRequirdNeigh ( at, cur_at, cRequirdNeigh[i], cChemValenceH[i]-cNumBondsAndH[i]) ) {</a>
<a name="ln1263">            ret = cNumBondsAndH[i];</a>
<a name="ln1264">            break;</a>
<a name="ln1265">        }</a>
<a name="ln1266">    }</a>
<a name="ln1267"> </a>
<a name="ln1268">    if ( i == PHOSPHINE_STEREO &amp;&amp; !(bPointedEdgeStereo &amp; PES_BIT_PHOSPHINE_STEREO) )</a>
<a name="ln1269">        ret = 0;</a>
<a name="ln1270">    if ( i == ARSINE_STEREO &amp;&amp; !(bPointedEdgeStereo &amp; PES_BIT_ARSINE_STEREO) )</a>
<a name="ln1271">        ret = 0;</a>
<a name="ln1272">    return ret;</a>
<a name="ln1273">}</a>
<a name="ln1274"> </a>
<a name="ln1275">#else /* } NEW_STEREOCENTER_CHECK { */</a>
<a name="ln1276"> </a>
<a name="ln1277">/********************************************************************************************/</a>
<a name="ln1278">int bCanAtomBeAStereoCenter( char *elname, S_CHAR charge, S_CHAR radical )</a>
<a name="ln1279">{</a>
<a name="ln1280">    static const char   szElem[][3] = { &quot;C\000&quot;, &quot;Si&quot;, &quot;Ge&quot;, &quot;N\000&quot;, &quot;P\000&quot;, &quot;As&quot;, &quot;B\000&quot; };</a>
<a name="ln1281">    static const S_CHAR   cCharge[] = {  0,        0,    0,   1,       1,       1,    -1     };</a>
<a name="ln1282">    int i, ret = 0;</a>
<a name="ln1283">    for ( i = 0; i &lt; sizeof(szElem)/sizeof(szElem[0]); i++ ) {</a>
<a name="ln1284">        if ( !strcmp( elname, szElem[i] )  &amp;&amp; (charge == cCharge[i]) ) {</a>
<a name="ln1285">            ret = (!radical || radical == RADICAL_SINGLET);</a>
<a name="ln1286">            break;</a>
<a name="ln1287">        }</a>
<a name="ln1288">    }</a>
<a name="ln1289">    return ret;</a>
<a name="ln1290">}</a>
<a name="ln1291">#endif /* } NEW_STEREOCENTER_CHECK */</a>
<a name="ln1292"> </a>
<a name="ln1293">/****************************************************************/</a>
<a name="ln1294">/*  used for atoms adjacent to stereogenic bonds only */</a>
<a name="ln1295">int bAtomHasValence3( char *elname, S_CHAR charge, S_CHAR radical )</a>
<a name="ln1296">{</a>
<a name="ln1297">    static const char   szElem[][3] = {  &quot;N\000&quot; };</a>
<a name="ln1298">    static const S_CHAR   cCharge[] = {   0,     };</a>
<a name="ln1299">    int i, ret = 0;</a>
<a name="ln1300">    for ( i = 0; i &lt; (int)(sizeof(szElem)/sizeof(szElem[0])); i++ ) {</a>
<a name="ln1301">        if ( !strcmp( elname, szElem[i] ) &amp;&amp; (charge == cCharge[i]) ) {</a>
<a name="ln1302">            ret = ( !radical || radical == RADICAL_SINGLET );</a>
<a name="ln1303">            break;</a>
<a name="ln1304">        }</a>
<a name="ln1305">    }</a>
<a name="ln1306">    return ret;</a>
<a name="ln1307">}</a>
<a name="ln1308"> </a>
<a name="ln1309">/****************************************************************/</a>
<a name="ln1310">/*  used for atoms adjacent to stereogenic bonds only */</a>
<a name="ln1311">int bCanAtomHaveAStereoBond( char *elname, S_CHAR charge, S_CHAR radical )</a>
<a name="ln1312">{</a>
<a name="ln1313">    static const char   szElem[][3] = { &quot;C\000&quot;, &quot;Si&quot;, &quot;Ge&quot;, &quot;N\000&quot;, &quot;N\000&quot; };</a>
<a name="ln1314">    static const S_CHAR   cCharge[] = {  0,        0,    0,   0,       1,     };</a>
<a name="ln1315">    static const int       n = sizeof(szElem)/sizeof(szElem[0]);</a>
<a name="ln1316">    int i, ret = 0;</a>
<a name="ln1317">    for ( i = 0; i &lt; n; i++ ) {</a>
<a name="ln1318">        if ( !strcmp( elname, szElem[i] )  &amp;&amp; (charge == cCharge[i]) ) {</a>
<a name="ln1319">            ret = (!radical || radical == RADICAL_SINGLET);</a>
<a name="ln1320">            break;</a>
<a name="ln1321">        }</a>
<a name="ln1322">    }</a>
<a name="ln1323">    return ret;</a>
<a name="ln1324">}</a>
<a name="ln1325">/****************************************************************/</a>
<a name="ln1326">/*  used for atoms adjacent to stereogenic bonds only */</a>
<a name="ln1327">int bCanAtomBeMiddleAllene( char *elname, S_CHAR charge, S_CHAR radical )</a>
<a name="ln1328">{</a>
<a name="ln1329">    static const char   szElem[][3] = { &quot;C\000&quot;, &quot;Si&quot;, &quot;Ge&quot;,  };</a>
<a name="ln1330">    static const S_CHAR   cCharge[] = {  0,        0,    0,   };</a>
<a name="ln1331">    static const int       n = sizeof(szElem)/sizeof(szElem[0]);</a>
<a name="ln1332">    int i, ret = 0;</a>
<a name="ln1333">    for ( i = 0; i &lt; n; i++ ) {</a>
<a name="ln1334">        if ( !strcmp( elname, szElem[i] )  &amp;&amp; (charge == cCharge[i]) ) {</a>
<a name="ln1335">            ret = (!radical || radical == RADICAL_SINGLET);</a>
<a name="ln1336">            break;</a>
<a name="ln1337">        }</a>
<a name="ln1338">    }</a>
<a name="ln1339">    return ret;</a>
<a name="ln1340">}</a>
<a name="ln1341">/*****************************************************************/</a>
<a name="ln1342">int bIsSuitableHeteroInpAtom( inp_ATOM  *at )</a>
<a name="ln1343">{</a>
<a name="ln1344">    int val, num_H;</a>
<a name="ln1345">    if ( 0 == at-&gt;charge &amp;&amp;</a>
<a name="ln1346">         (!at-&gt;radical || RADICAL_SINGLET == at-&gt;radical) &amp;&amp;</a>
<a name="ln1347">         0 &lt; (val=get_endpoint_valence( at-&gt;el_number ) )) {</a>
<a name="ln1348">        num_H = at-&gt;num_H;</a>
<a name="ln1349">        if ( val == at-&gt;chem_bonds_valence + num_H ) {</a>
<a name="ln1350">            switch( val ) {</a>
<a name="ln1351">            case 2: /* O */</a>
<a name="ln1352">                if ( !num_H &amp;&amp; 1 == at-&gt;valence )</a>
<a name="ln1353">                    return 0; /* =O */</a>
<a name="ln1354">                break;        /* not found */</a>
<a name="ln1355">            case 3: /* N */</a>
<a name="ln1356">                if ( (1 == at-&gt;valence &amp;&amp; 1 == num_H) ||</a>
<a name="ln1357">                     (2 == at-&gt;valence &amp;&amp; 0 == num_H)  )</a>
<a name="ln1358">                    return 1; /* =N- or =NH */</a>
<a name="ln1359">                break;        /* not found */</a>
<a name="ln1360">            }</a>
<a name="ln1361">        }</a>
<a name="ln1362">    }</a>
<a name="ln1363">    return -1;</a>
<a name="ln1364">}</a>
<a name="ln1365">/****************************************************************/</a>
<a name="ln1366">int bIsOxide( inp_ATOM  *at, int cur_at )</a>
<a name="ln1367">{</a>
<a name="ln1368">    int i, bond_type;</a>
<a name="ln1369">    inp_ATOM  *a = at + cur_at, *an;</a>
<a name="ln1370">    for ( i = 0; i &lt; a-&gt;valence; i ++ ) {</a>
<a name="ln1371">        bond_type = (a-&gt;bond_type[i] &amp;= ~BOND_MARK_ALL);</a>
<a name="ln1372">        if ( bond_type == BOND_DOUBLE ) {</a>
<a name="ln1373">            an = at + (int)a-&gt;neighbor[i];</a>
<a name="ln1374">            if ( 1 == an-&gt;valence &amp;&amp;</a>
<a name="ln1375">                 !an-&gt;charge &amp;&amp; !an-&gt;num_H &amp;&amp; !an-&gt;radical &amp;&amp;</a>
<a name="ln1376">                 2 == get_endpoint_valence( an-&gt;el_number ) ) {</a>
<a name="ln1377">                return 1;</a>
<a name="ln1378">            }</a>
<a name="ln1379">        } else</a>
<a name="ln1380">        if ( bond_type == BOND_TAUTOM || bond_type == BOND_ALT12NS ) {</a>
<a name="ln1381">            an = at + (int)a-&gt;neighbor[i];</a>
<a name="ln1382">            if ( 1 == an-&gt;valence &amp;&amp;</a>
<a name="ln1383">                 2 == get_endpoint_valence( an-&gt;el_number ) ) {</a>
<a name="ln1384">                return 1;</a>
<a name="ln1385">            }</a>
<a name="ln1386">        }</a>
<a name="ln1387">    }</a>
<a name="ln1388">    return 0;</a>
<a name="ln1389">}</a>
<a name="ln1390">/****************************************************************/</a>
<a name="ln1391">/*  used for atoms adjacent to stereogenic bonds only */</a>
<a name="ln1392">int bCanAtomBeTerminalAllene( char *elname, S_CHAR charge, S_CHAR radical )</a>
<a name="ln1393">{</a>
<a name="ln1394">    static const char   szElem[][3] = { &quot;C\000&quot;, &quot;Si&quot;, &quot;Ge&quot;,  };</a>
<a name="ln1395">    static const S_CHAR   cCharge[] = {  0,        0,    0,   };</a>
<a name="ln1396">    static const int       n = sizeof(szElem)/sizeof(szElem[0]);</a>
<a name="ln1397">    int i, ret = 0;</a>
<a name="ln1398">    for ( i = 0; i &lt; n; i++ ) {</a>
<a name="ln1399">        if ( !strcmp( elname, szElem[i] ) &amp;&amp; (charge == cCharge[i]) ) {</a>
<a name="ln1400">            ret = (!radical || radical == RADICAL_SINGLET);</a>
<a name="ln1401">            break;</a>
<a name="ln1402">        }</a>
<a name="ln1403">    }</a>
<a name="ln1404">    return ret;</a>
<a name="ln1405">}</a>
<a name="ln1406">/************************************************************************/</a>
<a name="ln1407">int GetHalfStereobond0DParity( inp_ATOM *at, int cur_at, AT_NUMB nSbNeighOrigAtNumb[],</a>
<a name="ln1408">                               int nNumExplictAttachments, int bond_parity, int nFlag )</a>
<a name="ln1409">{</a>
<a name="ln1410">    int m, last_parity, cur_parity;</a>
<a name="ln1411">    int i, icur2nxt, icur2neigh, cur_order_parity, nxt_at;</a>
<a name="ln1412">    AT_NUMB nNextSbAtOrigNumb;</a>
<a name="ln1413">    /* find atom parities for all valid streobonds incident to at[cur_at] */</a>
<a name="ln1414">    for ( m = 0, last_parity = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[cur_at].sb_parity[m]; m ++ ) {</a>
<a name="ln1415">        icur2nxt = icur2neigh = -1; /* ordering number of neighbors in nSbNeighOrigAtNumb[] */</a>
<a name="ln1416">        cur_parity = 0;             /* parity for mth stereobond incident to the cur_at */</a>
<a name="ln1417">        if ( 0 &lt;= at[cur_at].sb_ord[m] &amp;&amp; at[cur_at].sb_ord[m] &lt; at[cur_at].valence &amp;&amp;</a>
<a name="ln1418">             0 &lt;= (nxt_at = at[cur_at].neighbor[(int)at[cur_at].sb_ord[m]]) &amp;&amp;</a>
<a name="ln1419">             at[nxt_at].valence &lt;= MAX_NUM_STEREO_BONDS &amp;&amp; /* make sure it is a valid stereobond */</a>
<a name="ln1420">             (nNextSbAtOrigNumb = at[nxt_at].orig_at_number) ) {</a>
<a name="ln1421">            /* since at[cur_at].sn_ord[m] = -1 for explicit H use at[cur_at].sn_orig_at_num[m] */</a>
<a name="ln1422">            for ( i = 0; i &lt; nNumExplictAttachments; i ++ ) {</a>
<a name="ln1423">                if ( at[cur_at].sn_orig_at_num[m] == nSbNeighOrigAtNumb[i] ) {</a>
<a name="ln1424">                    icur2neigh = i; /* neighbor */</a>
<a name="ln1425">                } else</a>
<a name="ln1426">                if ( nNextSbAtOrigNumb == nSbNeighOrigAtNumb[i] ) {</a>
<a name="ln1427">                    icur2nxt = i; /* atom connected by a stereobond */</a>
<a name="ln1428">                }</a>
<a name="ln1429">            }</a>
<a name="ln1430">            if ( icur2neigh &gt;= 0 &amp;&amp; icur2nxt &gt;= 0 ) {</a>
<a name="ln1431">                if ( ATOM_PARITY_WELL_DEF(at[cur_at].sb_parity[m]) ) {</a>
<a name="ln1432">                    /* parity of at[cur_atom] neighbor permutation to reach this order: { next_atom, neigh_atom, ...} */</a>
<a name="ln1433">                    cur_order_parity = (icur2nxt + icur2neigh + (icur2nxt &gt; icur2neigh) - 1) % 2;</a>
<a name="ln1434">                    cur_parity = 2 - (cur_order_parity + at[cur_at].sb_parity[m]) % 2;</a>
<a name="ln1435">                } else {</a>
<a name="ln1436">                    /* unknowm/undef parities do not depend on the neighbor order */</a>
<a name="ln1437">                    cur_parity = at[cur_at].sb_parity[m];</a>
<a name="ln1438">                }</a>
<a name="ln1439">            }</a>
<a name="ln1440">        } else {</a>
<a name="ln1441">            continue;</a>
<a name="ln1442">        }</a>
<a name="ln1443">        /* use a well-known parity if available; if not then use preferably the unknown */</a>
<a name="ln1444">        if ( !last_parity ) {</a>
<a name="ln1445">            last_parity = cur_parity;</a>
<a name="ln1446">        } else</a>
<a name="ln1447">        if ( last_parity != cur_parity &amp;&amp; cur_parity ) {</a>
<a name="ln1448">            if ( ATOM_PARITY_WELL_DEF(last_parity) ) {</a>
<a name="ln1449">                if ( ATOM_PARITY_WELL_DEF(cur_parity) ) {</a>
<a name="ln1450">                    last_parity = 0; /* error: all well-defined parities should be same */</a>
<a name="ln1451">                    break;</a>
<a name="ln1452">                }</a>
<a name="ln1453">            } else</a>
<a name="ln1454">            if ( ATOM_PARITY_WELL_DEF(cur_parity) ) {</a>
<a name="ln1455">                /* replace unknown/undefined parity with well-known */</a>
<a name="ln1456">                last_parity = cur_parity;</a>
<a name="ln1457">            } else {</a>
<a name="ln1458">                /* select min unknown/undefined parity (out of AB_PARITY_UNKN and AB_PARITY_UNDF) */</a>
<a name="ln1459">                last_parity = inchi_min(cur_parity, last_parity);</a>
<a name="ln1460">            }</a>
<a name="ln1461">        }</a>
<a name="ln1462">    }</a>
<a name="ln1463">    if ( last_parity ) {</a>
<a name="ln1464">        bond_parity = last_parity;</a>
<a name="ln1465">        at[cur_at].bUsed0DParity |= nFlag; /* set flag: used stereobond 0D parity */</a>
<a name="ln1466">    }</a>
<a name="ln1467">    return bond_parity;</a>
<a name="ln1468">}</a>
<a name="ln1469">/*******************************************************************************************/</a>
<a name="ln1470">int FixSb0DParities( inp_ATOM *at, /* inp_ATOM *at_removed_H, int num_removed_H,*/ int chain_length,</a>
<a name="ln1471">                     int at_1, int i_next_at_1, S_CHAR z_dir1[],</a>
<a name="ln1472">                     int at_2, int i_next_at_2, S_CHAR z_dir2[],</a>
<a name="ln1473">                     int *pparity1, int *pparity2 )</a>
<a name="ln1474">{</a>
<a name="ln1475">    int k, parity1, parity2, abs_parity1, abs_parity2;</a>
<a name="ln1476">    int j1, j2, parity_sign;</a>
<a name="ln1477">    /*</a>
<a name="ln1478">    AT_NUMB nSbNeighOrigAtNumb1[MAX_NUM_STEREO_BOND_NEIGH], nSbNeighOrigAtNumb2[MAX_NUM_STEREO_BOND_NEIGH];</a>
<a name="ln1479">    int     nNumExplictAttachments1, nNumExplictAttachments2;</a>
<a name="ln1480">    */</a>
<a name="ln1481">    parity1 = parity2 = AB_PARITY_NONE;</a>
<a name="ln1482">    j1      = j2      = -1;</a>
<a name="ln1483">    parity_sign = ( *pparity1 &lt; 0 || *pparity2 &lt; 0 )? -1 : 1;</a>
<a name="ln1484"> </a>
<a name="ln1485">    abs_parity1 = abs(*pparity1);</a>
<a name="ln1486">    abs_parity2 = abs(*pparity2);</a>
<a name="ln1487"> </a>
<a name="ln1488">    for ( k = 0; k &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[at_1].sb_parity[k]; k ++ ) {</a>
<a name="ln1489">        if ( at[at_1].sb_ord[k] == i_next_at_1 ) {</a>
<a name="ln1490">            parity1 = at[at_1].sb_parity[k];</a>
<a name="ln1491">            j1 = k;</a>
<a name="ln1492">        }</a>
<a name="ln1493">    }</a>
<a name="ln1494">    for ( k = 0; k &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[at_2].sb_parity[k]; k ++ ) {</a>
<a name="ln1495">        if ( at[at_2].sb_ord[k] == i_next_at_2 ) {</a>
<a name="ln1496">            parity2 = at[at_2].sb_parity[k];</a>
<a name="ln1497">            j2 = k;</a>
<a name="ln1498">        }</a>
<a name="ln1499">    }</a>
<a name="ln1500">    switch( (j1 &gt;= 0) + 2*(j2 &gt;= 0) ) {</a>
<a name="ln1501">    case 0:</a>
<a name="ln1502">        /* the bond has no 0D parity */</a>
<a name="ln1503">        *pparity1 = *pparity2 = parity_sign * AB_PARITY_UNDF;</a>
<a name="ln1504">        return 0;</a>
<a name="ln1505">    case 1:</a>
<a name="ln1506">    case 2:</a>
<a name="ln1507">        /* 0D parity data error */</a>
<a name="ln1508">        *pparity1 = *pparity2 =  AB_PARITY_NONE;</a>
<a name="ln1509">        return -1;</a>
<a name="ln1510">    case 3:</a>
<a name="ln1511">        /* the bond has 0D parity */</a>
<a name="ln1512">        switch (     !(ATOM_PARITY_WELL_DEF( abs_parity1 ) &amp;&amp; ATOM_PARITY_WELL_DEF( parity1 )) +</a>
<a name="ln1513">                 2 * !(ATOM_PARITY_WELL_DEF( abs_parity2 ) &amp;&amp; ATOM_PARITY_WELL_DEF( parity2 )) ) {</a>
<a name="ln1514">        case 0:</a>
<a name="ln1515">            /* both parities are well-defined; continue */</a>
<a name="ln1516">            break;</a>
<a name="ln1517">        case 1:</a>
<a name="ln1518">            /* 0D parity not well-defined for at_1 */</a>
<a name="ln1519">            *pparity1 = parity_sign * (ATOM_PARITY_WELL_DEF( parity1     )? abs_parity1 :</a>
<a name="ln1520">                                       ATOM_PARITY_WELL_DEF( abs_parity1 )? parity1 :</a>
<a name="ln1521">                                       inchi_min(abs_parity1, parity1));</a>
<a name="ln1522">            *pparity2 = parity_sign * abs_parity2;</a>
<a name="ln1523">            return -1;</a>
<a name="ln1524">        case 2:</a>
<a name="ln1525">            /* 0D parity not well-defined for at_2 */</a>
<a name="ln1526">            *pparity1 = parity_sign * abs_parity1;</a>
<a name="ln1527">            *pparity2 = parity_sign * (ATOM_PARITY_WELL_DEF( parity2     )? abs_parity2 :</a>
<a name="ln1528">                                       ATOM_PARITY_WELL_DEF( abs_parity2 )? parity2 :</a>
<a name="ln1529">                                       inchi_min(abs_parity2, parity2));</a>
<a name="ln1530">            return -1;</a>
<a name="ln1531">        case 3:</a>
<a name="ln1532">            abs_parity1 =  (ATOM_PARITY_WELL_DEF( parity1     )? abs_parity1 :</a>
<a name="ln1533">                            ATOM_PARITY_WELL_DEF( abs_parity1 )? parity1 :</a>
<a name="ln1534">                            inchi_min(abs_parity1, parity1));</a>
<a name="ln1535">            abs_parity2 =  (ATOM_PARITY_WELL_DEF( parity2     )? abs_parity2 :</a>
<a name="ln1536">                            ATOM_PARITY_WELL_DEF( abs_parity2 )? parity2 :</a>
<a name="ln1537">                            inchi_min(abs_parity2, parity2));</a>
<a name="ln1538">            *pparity1 = *pparity2 = parity_sign * inchi_min(abs_parity1, abs_parity2);</a>
<a name="ln1539">            /*return (parity1 == parity2)? 0 : -1;*/</a>
<a name="ln1540">            return -1;</a>
<a name="ln1541">        }</a>
<a name="ln1542">        break;</a>
<a name="ln1543">    }</a>
<a name="ln1544">    /* we are here if both end-atoms of the bond have well-defined 0D parities */</a>
<a name="ln1545">    /*</a>
<a name="ln1546">    nNumExplictAttachments1 = GetSbNeighOrigAtNumb( at, at_1, at_removed_H, num_removed_H, nSbNeighOrigAtNumb1 );</a>
<a name="ln1547">    nNumExplictAttachments2 = GetSbNeighOrigAtNumb( at, at_2, at_removed_H, num_removed_H, nSbNeighOrigAtNumb2 );</a>
<a name="ln1548">    parity1 = GetHalfStereobond0DParity( at, at_1, nSbNeighOrigAtNumb1, nNumExplictAttachments1, *pparity1, 0 );</a>
<a name="ln1549">    parity2 = GetHalfStereobond0DParity( at, at_2, nSbNeighOrigAtNumb2, nNumExplictAttachments2, *pparity2, 0 );</a>
<a name="ln1550">    */</a>
<a name="ln1551">    *pparity1 = parity_sign * abs_parity1;</a>
<a name="ln1552">    *pparity2 = parity_sign * abs_parity2;</a>
<a name="ln1553"> </a>
<a name="ln1554">    if ( chain_length % 2 ) {</a>
<a name="ln1555">        /* allene; chain_length = (number of double bonds) - 1 */</a>
<a name="ln1556">        /*</a>
<a name="ln1557">        int zer1 = ( !z_dir1[0] &amp;&amp; !z_dir1[1] &amp;&amp; !z_dir1[2] );</a>
<a name="ln1558">        int zer2 = ( !z_dir2[0] &amp;&amp; !z_dir2[1] &amp;&amp; !z_dir2[2] );</a>
<a name="ln1559">        */</a>
<a name="ln1560">        int bWrong_z_dir1 = (0 != (at[at_1].bUsed0DParity &amp; FlagSB_0D));</a>
<a name="ln1561">        int bWrong_z_dir2 = (0 != (at[at_2].bUsed0DParity &amp; FlagSB_0D));</a>
<a name="ln1562"> </a>
<a name="ln1563">        if ( bWrong_z_dir1 &amp;&amp; bWrong_z_dir2 ) {</a>
<a name="ln1564">            goto set_default;</a>
<a name="ln1565">        } else</a>
<a name="ln1566">        if ( bWrong_z_dir1 || bWrong_z_dir2 ) {</a>
<a name="ln1567">            double r12[3], zi1[3], zi2[3], abs_r12, abs_zi2;</a>
<a name="ln1568">            int    at_i1, at_i2, j;</a>
<a name="ln1569">            S_CHAR   z_dir[3];</a>
<a name="ln1570">            r12[0] = at[at_2].x - at[at_1].x;</a>
<a name="ln1571">            r12[1] = at[at_2].y - at[at_1].y;</a>
<a name="ln1572">            r12[2] = at[at_2].z - at[at_1].z;</a>
<a name="ln1573">            abs_r12 = len3( r12 );</a>
<a name="ln1574">            if ( abs_r12 &lt; MIN_BOND_LEN ) {</a>
<a name="ln1575">                goto set_default;</a>
<a name="ln1576">            }</a>
<a name="ln1577">            /* make r12[] point to the atom with 'good' z_dir[] */</a>
<a name="ln1578">            if ( bWrong_z_dir1 ) {</a>
<a name="ln1579">                at_i1 = at_2; /* has good z_dir2[] */</a>
<a name="ln1580">                at_i2 = at_1; /* has bad  z_dir1[] */</a>
<a name="ln1581">                zi1[0] = z_dir2[0];</a>
<a name="ln1582">                zi1[1] = z_dir2[1];</a>
<a name="ln1583">                zi1[2] = z_dir2[2];</a>
<a name="ln1584">                mult3( r12, 1.0/abs_r12, r12 ); /* make length = 1 */</a>
<a name="ln1585">            } else {</a>
<a name="ln1586">                at_i1 = at_1; /* has good z_dir1[] */</a>
<a name="ln1587">                at_i2 = at_2; /* has bad  z_dir2[] */</a>
<a name="ln1588">                zi1[0] = z_dir1[0];</a>
<a name="ln1589">                zi1[1] = z_dir1[1];</a>
<a name="ln1590">                zi1[2] = z_dir1[2];</a>
<a name="ln1591">                mult3( r12, -1.0/abs_r12, r12 ); /* make length = 1 */</a>
<a name="ln1592">            }</a>
<a name="ln1593">            cross_prod3( r12, zi1, zi2 );</a>
<a name="ln1594">            abs_zi2 = len3( zi2 );</a>
<a name="ln1595">            mult3( zi2, 100.0/abs_zi2, zi2 ); /* make length = 100 */</a>
<a name="ln1596">            for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1597">                z_dir[j] = (S_CHAR) (zi2[j]&gt;= 0.0?  floor(0.5 + zi2[j]) :</a>
<a name="ln1598">                                                   -floor(0.5 - zi2[j])); /*  abs(z_dir) = 100 */</a>
<a name="ln1599">            }</a>
<a name="ln1600">            if ( bWrong_z_dir1 ) {</a>
<a name="ln1601">                memcpy( z_dir1, z_dir, sizeof(z_dir) );</a>
<a name="ln1602">            } else {</a>
<a name="ln1603">                memcpy( z_dir2, z_dir, sizeof(z_dir) );</a>
<a name="ln1604">            }</a>
<a name="ln1605">        }</a>
<a name="ln1606">        return 0;</a>
<a name="ln1607"> </a>
<a name="ln1608">set_default:</a>
<a name="ln1609">        /* z_dir1[] = x-direction; z_dir2[] = z-direction; r12[] = y-direction */</a>
<a name="ln1610">        z_dir1[0] = 100;</a>
<a name="ln1611">        z_dir1[1] = z_dir1[2] = 0;</a>
<a name="ln1612">        z_dir2[0] = z_dir2[1] = 0;</a>
<a name="ln1613">        z_dir2[2] = 100;</a>
<a name="ln1614">    }</a>
<a name="ln1615">    return 0;</a>
<a name="ln1616">}</a>
<a name="ln1617">/**********************************************************/</a>
<a name="ln1618">/* without this InChI fails on reconstructed  CID=450438  */</a>
<a name="ln1619">/* (isotopic, Unknown SB adjacent to SB with known parity) */</a>
<a name="ln1620">/**********************************************************/</a>
<a name="ln1621">int FixUnkn0DStereoBonds(inp_ATOM *at, int num_at)</a>
<a name="ln1622">{</a>
<a name="ln1623">    int i, m, num=0;</a>
<a name="ln1624"> </a>
<a name="ln1625">    /* add usual Unknown stereobond descriptors to each Unknown bond */</a>
<a name="ln1626">    for( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1627">        for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i].sb_parity[m]; m ++ ) {</a>
<a name="ln1628">            if ( AB_PARITY_UNKN == at[i].sb_parity[m] ) {</a>
<a name="ln1629">                at[i].bond_stereo[ (int)at[i].sb_ord[m] ] = STEREO_DBLE_EITHER;</a>
<a name="ln1630">                num ++;</a>
<a name="ln1631">            }</a>
<a name="ln1632">        }</a>
<a name="ln1633">    }</a>
<a name="ln1634">#ifdef NEVER</a>
<a name="ln1635">    if ( num ) {</a>
<a name="ln1636">        int j;</a>
<a name="ln1637">        /* how to remove Unknown stereo bond parities */</a>
<a name="ln1638">        for( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1639">            for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i].sb_parity[m]; m ++ ) {</a>
<a name="ln1640">                if ( AB_PARITY_UNKN == at[i].sb_parity[m] ) {</a>
<a name="ln1641">                    for ( j = m+1; j &lt; MAX_NUM_STEREO_BONDS; j ++ ) {</a>
<a name="ln1642">                        at[i].sb_parity[j-1]      = at[i].sb_parity[j];</a>
<a name="ln1643">                        at[i].sb_ord[j-1]         = at[i].sb_ord[j];</a>
<a name="ln1644">                        at[i].sn_ord[j-1]         = at[i].sn_ord[j];</a>
<a name="ln1645">                        at[i].sn_orig_at_num[j-1] = at[i].sn_orig_at_num[j];</a>
<a name="ln1646">                    }</a>
<a name="ln1647">                    at[i].sb_parity[j-1]      = 0;</a>
<a name="ln1648">                    at[i].sb_ord[j-1]         = 0;</a>
<a name="ln1649">                    at[i].sn_ord[j-1]         = 0;</a>
<a name="ln1650">                    at[i].sn_orig_at_num[j-1] = 0;</a>
<a name="ln1651">                }</a>
<a name="ln1652">            }</a>
<a name="ln1653">        }</a>
<a name="ln1654">    }</a>
<a name="ln1655">#endif</a>
<a name="ln1656">    return num;</a>
<a name="ln1657">}</a>
<a name="ln1658">/*======================================================================================================</a>
<a name="ln1659"> </a>
<a name="ln1660">half_stereo_bond_parity() General Description:</a>
<a name="ln1661"> </a>
<a name="ln1662">    A) find projections of 3 bonds on a reasonable plane defined</a>
<a name="ln1663">       by a vector z_dir perpendicular to the plane</a>
<a name="ln1664">    B) calculate parity</a>
<a name="ln1665"> </a>
<a name="ln1666">half_stereo_bond_parity() Detailed Description:</a>
<a name="ln1667"> </a>
<a name="ln1668">    1) Find at_coord[] = vectors from the central atoms to its neighbors</a>
<a name="ln1669">    2) If only 2 neighbors are present, then create a reasonable 3rd neighbor</a>
<a name="ln1670">       (an implicit H or a fictitious atom in case of =NX) coordinates</a>
<a name="ln1671">    3) Normalize at_coord[] to unit length</a>
<a name="ln1672">    4) Find unit vector pnt[2] perpendicular to the plane containing</a>
<a name="ln1673">       at_coord[] arrow ends.</a>
<a name="ln1674">       Even though it is not necessary, make z-coordinate of pnt[2] positive.</a>
<a name="ln1675">       ** pnt[2] has the new z-axis direction **</a>
<a name="ln1676">    5) Let pnt[0] = perpendicular to pnt[2] component of at_coord[0];</a>
<a name="ln1677">       Normalize pnt[0] to unit length.</a>
<a name="ln1678">       ** pnt[0] has the new x-axis direction **</a>
<a name="ln1679">    6) Let pnt[1] = pnt[2] x pnt[0] (cross-product);</a>
<a name="ln1680">       ** pnt[1] has the new y-axis direction **</a>
<a name="ln1681">    7) Find at_coord[] in the new xyz-basis and normalize their xy-projections</a>
<a name="ln1682">       to a unit length</a>
<a name="ln1683">    8) In the new xy-plane find (counterclockwise) angles:</a>
<a name="ln1684">       tmp1 = (from at_coord[0] to at_coord[1])</a>
<a name="ln1685">       tmp2 = (from at_coord[0] to at_coord[2])</a>
<a name="ln1686">    9) Calculate the parity: if tmp1 &lt; tmp2 then 1 (odd) else 2 (even)</a>
<a name="ln1687">       (even: looking from the arrow end of the new z-axis, 0, 1, and 2 neighbors</a>
<a name="ln1688">        are in clockwise order)</a>
<a name="ln1689">   10) Calculate z_dir = 100*pnt[2].</a>
<a name="ln1690">   </a>
<a name="ln1691">   Note1. If z_dir vectors of atoms located at the opposite ends of a double bond have approximately</a>
<a name="ln1692">          opposite directions (that is, their dot-product is negative) then the parity of the</a>
<a name="ln1693">          stereogenic bond calculated from half-bond-parities should be inverted</a>
<a name="ln1694"> </a>
<a name="ln1695">   Note2. In case of a tetrahedral cumulene a triple product (z_dir1, (1-&gt;2), z_dir2) is used instead</a>
<a name="ln1696">          of the dot-product. (1-&gt;2) is a vector from the atom#1 to the atom #2. This triple product</a>
<a name="ln1697">          is invariant with respect to the atom numbering because it does not change upon (1,2)</a>
<a name="ln1698">          permutation.</a>
<a name="ln1699">  </a>
<a name="ln1700">  Stereo ambiguity in case of 2 neighbors:</a>
<a name="ln1701">  ----------------------------------------</a>
<a name="ln1702">  Undefined: single-double bond angle &gt; pi - arcsin(0.03) = 178.28164199834454285275613218975 degrees</a>
<a name="ln1703">  Ambiguous: single-double bond angle &gt; 175 degrees = pi - 0.087156 Rad</a>
<a name="ln1704"> </a>
<a name="ln1705">   Return values </a>
<a name="ln1706">   (cases: I=only in case of isotopic H atoms the neighbors are different,</a>
<a name="ln1707">           N=in case of non-isotopic H atoms the neighbors are different)</a>
<a name="ln1708"> </a>
<a name="ln1709">  -4 = AB_PARITY_UNDF =&gt; atom is adjacent to a stereogenic bond, but the geometry is undefined, I</a>
<a name="ln1710">  -3 = AB_PARITY_UNKN =&gt; atom is adjacent to a stereogenic bond, but the geometry is not known to the iuser, I</a>
<a name="ln1711">  -2 =-AB_PARITY_EVEN =&gt; parity of an atom adjacent to a stereogenic bond, I</a>
<a name="ln1712">  -1 =-AB_PARITY_ODD  =&gt; parity of an atom adjacent to a stereogenic bond, I</a>
<a name="ln1713">   0 = AB_PARITY_NONE =&gt; the atom is not adjacent to a stereogenic bond</a>
<a name="ln1714">   1 = AB_PARITY_ODD  =&gt; parity of an atom adjacent to a stereogenic bond, N&amp;I</a>
<a name="ln1715">   2 = AB_PARITY_EVEN =&gt; parity of an atom adjacent to a stereogenic bond, N&amp;I</a>
<a name="ln1716">   3 = AB_PARITY_UNKN =&gt; atom is adjacent to a stereogenic bond, but the geometry is not known to the iuser, N&amp;I</a>
<a name="ln1717">   4 = AB_PARITY_UNDF =&gt; atom is adjacent to a stereogenic bond, but the geometry is undefined, N&amp;I</a>
<a name="ln1718">   5 = AB_PARITY_IISO =&gt; atom constitutionally equivalent to this atom may be adjacent to a stereogenic bond, I</a>
<a name="ln1719"> </a>
<a name="ln1720"> </a>
<a name="ln1721">=====================================================================================================*/</a>
<a name="ln1722"> </a>
<a name="ln1723">int half_stereo_bond_parity( inp_ATOM *at, int cur_at, inp_ATOM *at_removed_H, </a>
<a name="ln1724">                            int num_removed_H, S_CHAR *z_dir, </a>
<a name="ln1725">                            int bPointedEdgeStereo, int vABParityUnknown )</a>
<a name="ln1726">{</a>
<a name="ln1727">    double at_coord[MAX_NUM_STEREO_BOND_NEIGH][3], c, s, tmp[3], tmp1, tmp2, min_tmp, max_tmp, z;</a>
<a name="ln1728">    double temp[3], pnt[3][3];</a>
<a name="ln1729">    int j, k, p0, p1, p2, next, bValence3=0, num_z, nType, num_either_single, num_either_double;</a>
<a name="ln1730">    int nNumExplictAttachments;</a>
<a name="ln1731">    int bond_parity  =  AB_PARITY_UNDF;</a>
<a name="ln1732">    int    num_H=0, num_iH, num_eH=0, num_nH=0 /* = num_iso_H[0] */;</a>
<a name="ln1733">    int    num_iso_H[NUM_H_ISOTOPES+1];</a>
<a name="ln1734">    int    index_H[5]; /*  cannot have more than 4 elements: 1 H, 1 1H, 1 D, 1 T atom(s) */</a>
<a name="ln1735">    /*	const double one_pi = 2.0*atan2(1.0 , 0.0 ); */</a>
<a name="ln1736">    const double one_pi = 3.14159265358979323846; /* M_PI */</a>
<a name="ln1737">    const double two_pi = 2.0*one_pi;</a>
<a name="ln1738">    int    bIgnoreIsotopicH = (0 != (at[cur_at].cFlags &amp; AT_FLAG_ISO_H_POINT));</a>
<a name="ln1739">    AT_NUMB nSbNeighOrigAtNumb[MAX_NUM_STEREO_BOND_NEIGH];</a>
<a name="ln1740"> </a>
<a name="ln1741"> </a>
<a name="ln1742">    if ( z_dir &amp;&amp; !z_dir[0] &amp;&amp; !z_dir[1] &amp;&amp; !z_dir[2] ) {</a>
<a name="ln1743">        z_dir[2]=100;</a>
<a name="ln1744">    }</a>
<a name="ln1745"> </a>
<a name="ln1746">    num_H  = at[cur_at].num_H;</a>
<a name="ln1747">    if ( num_H &gt; NUM_H_ISOTOPES )</a>
<a name="ln1748">        return 0; /*  at least 2 H atoms are isotopically identical */</a>
<a name="ln1749"> </a>
<a name="ln1750">    if ( MAX_NUM_STEREO_BOND_NEIGH &lt; at[cur_at].valence + num_H ||</a>
<a name="ln1751">         MIN_NUM_STEREO_BOND_NEIGH &gt; at[cur_at].valence + num_H )</a>
<a name="ln1752">        return 0;</a>
<a name="ln1753"> </a>
<a name="ln1754">    if ( !bCanAtomHaveAStereoBond( at[cur_at].elname, at[cur_at].charge, at[cur_at].radical ) )</a>
<a name="ln1755">        return 0;</a>
<a name="ln1756">    if ( !bIgnoreIsotopicH ) {</a>
<a name="ln1757">        for ( j = 0, num_nH = num_H; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln1758">            if ( (k = (int)at[cur_at].num_iso_H[j]) &gt; 1 ) {</a>
<a name="ln1759">                return AB_PARITY_IISO;  /*  two or more identical isotopic H atoms */</a>
<a name="ln1760">            }</a>
<a name="ln1761">            num_nH -= k;</a>
<a name="ln1762">        }</a>
<a name="ln1763">    }</a>
<a name="ln1764">    /*  at this point num_nH = number of non-isotopic H atoms */</a>
<a name="ln1765">    if ( num_nH &gt; 1 )</a>
<a name="ln1766">        return AB_PARITY_IISO; /*  two or more identical non-isotopic H atoms */</a>
<a name="ln1767">    if ( num_nH &lt; 0 )</a>
<a name="ln1768">        return CT_ISO_H_ERR;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1769"> </a>
<a name="ln1770">    /********************************************************************</a>
<a name="ln1771">     * Note. At this point all (implicit and explicit) isotopic</a>
<a name="ln1772">     * terminal H neighbors are either different or not present.</a>
<a name="ln1773">     ********************************************************************/</a>
<a name="ln1774"> </a>
<a name="ln1775">    /*  locate explicit hydrogen atoms */</a>
<a name="ln1776">    /*  (at_removed_H are sorted in ascending isotopic H mass order, non-isotopic first) */</a>
<a name="ln1777">    memset( num_iso_H, 0, sizeof(num_iso_H) );</a>
<a name="ln1778">    if ( at_removed_H &amp;&amp; num_removed_H &gt; 0 ) {</a>
<a name="ln1779">        for ( j = 0; j &lt; num_removed_H; j ++ ) {</a>
<a name="ln1780">            if ( at_removed_H[j].neighbor[0] == cur_at ) {</a>
<a name="ln1781">                k = bIgnoreIsotopicH? 0 : at_removed_H[j].iso_atw_diff;</a>
<a name="ln1782">                if ( 0 &lt;= k &amp;&amp; k &lt;= NUM_H_ISOTOPES ) {</a>
<a name="ln1783">                    if ( ++num_iso_H[k] &gt; 1 )   /*  num_iso_H[0] = number of non-isotopic H atoms */</a>
<a name="ln1784">                        return CT_ISO_H_ERR;    /*  program error in counting hydrogens */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1785">                    index_H[num_eH++] = j;</a>
<a name="ln1786">                } else {</a>
<a name="ln1787">                    return CT_ISO_H_ERR;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1788">                }</a>
<a name="ln1789">            }</a>
<a name="ln1790">        }</a>
<a name="ln1791">        num_iH = num_H - num_eH; /*  number of implicit non-isotopic and isotopic H atoms */</a>
<a name="ln1792">        if ( num_iH &gt; 1 ) {</a>
<a name="ln1793">            /*  more than one implicit H: cannot reconstruct the geometry */</a>
<a name="ln1794">            bond_parity = -AB_PARITY_UNDF;</a>
<a name="ln1795">            goto exit_function;</a>
<a name="ln1796">        }</a>
<a name="ln1797">    } else {</a>
<a name="ln1798">        num_iH = num_H;</a>
<a name="ln1799">    }</a>
<a name="ln1800">    /*  at this point num_iH = number of implicit non-isotopic and isotopic H atoms */</a>
<a name="ln1801">    if ( at[cur_at].valence + num_eH &lt; MIN_NUM_STEREO_BOND_NEIGH ) {</a>
<a name="ln1802">        /*  =NH or =CHD when no explicit H is present */</a>
<a name="ln1803">        return num_H == 1? AB_PARITY_UNDF : -AB_PARITY_UNDF;</a>
<a name="ln1804">    }</a>
<a name="ln1805"> </a>
<a name="ln1806">    bValence3 = bAtomHasValence3( at[cur_at].elname, at[cur_at].charge, at[cur_at].radical );</a>
<a name="ln1807">    /*</a>
<a name="ln1808">     * Can one explicit hydrogen be added to make asymmetric configuration?</a>
<a name="ln1809">     * For now we can add 1 H atom in case of an appropriate geometry if:</a>
<a name="ln1810">     * (a) one non-isotopic H (even if explicit isotopic H atoms are present), or</a>
<a name="ln1811">     * (b) one isotopic or non-isotopic H if NO explicit isotopic or non-isotopic H atom is present</a>
<a name="ln1812">     * This makes sense only in case chem. valence = 4. In case of chem. valence = 3, do not check.</a>
<a name="ln1813">     */</a>
<a name="ln1814">    if ( at[cur_at].valence + num_eH == MIN_NUM_STEREO_BOND_NEIGH &amp;&amp; !bValence3 &amp;&amp;</a>
<a name="ln1815">         !(/*(a)*/ (1 == num_nH &amp;&amp; !num_iso_H[0]) ||</a>
<a name="ln1816">           /*(b)*/ (1 == num_H  &amp;&amp; !num_eH))</a>
<a name="ln1817">       ) {</a>
<a name="ln1818">        goto exit_function;</a>
<a name="ln1819">        /* return num_H == 1? AB_PARITY_UNDF : -AB_PARITY_UNDF; */</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    /*  store neighbors coordinates */</a>
<a name="ln1823">    num_z = num_either_single = num_either_double = 0;</a>
<a name="ln1824">    for ( k = nNumExplictAttachments = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1825">        switch( k ) {</a>
<a name="ln1826">        case 0:</a>
<a name="ln1827">            for ( j = 0; j &lt; num_eH; j ++, nNumExplictAttachments ++ ) {</a>
<a name="ln1828">                next = index_H[j];</a>
<a name="ln1829">                at_coord[nNumExplictAttachments][0] = at_removed_H[next].x - at[cur_at].x;</a>
<a name="ln1830">                at_coord[nNumExplictAttachments][1] = at_removed_H[next].y - at[cur_at].y;</a>
<a name="ln1831">                nSbNeighOrigAtNumb[nNumExplictAttachments] = at_removed_H[next].orig_at_number;</a>
<a name="ln1832">                /* use the fact that (at_removed_H - at) = (number of atoms except removed explicit H) */</a>
<a name="ln1833">                z = -get_z_coord( at, (at_removed_H-at)+next, 0 /*neighbor #*/, &amp;nType, -(bPointedEdgeStereo &amp; PES_BIT_POINT_EDGE_STEREO) );</a>
<a name="ln1834">                switch ( nType ) {</a>
<a name="ln1835">                case ZTYPE_EITHER:</a>
<a name="ln1836">                    num_either_single ++; /*  bond in &quot;Either&quot; direction. */</a>
<a name="ln1837">                    break;</a>
<a name="ln1838">                case ZTYPE_UP:</a>
<a name="ln1839">                case ZTYPE_DOWN:</a>
<a name="ln1840">                    nType = -nType; /*  at_removed_H[] contains bonds TO the center, not from */</a>
<a name="ln1841">                    z = len2( at_coord[nNumExplictAttachments] );</a>
<a name="ln1842">                    /*</a>
<a name="ln1843">                    z = sqrt( at_coord[nNumExplictAttachments][0]*at_coord[nNumExplictAttachments][0]</a>
<a name="ln1844">                            + at_coord[nNumExplictAttachments][1]*at_coord[nNumExplictAttachments][1] );</a>
<a name="ln1845">                    */</a>
<a name="ln1846">                    if ( nType == ZTYPE_DOWN )</a>
<a name="ln1847">                        z = -z;</a>
<a name="ln1848">                    /*  no break; here */</a>
<a name="ln1849">                case ZTYPE_3D:</a>
<a name="ln1850">                    num_z ++;</a>
<a name="ln1851">                }</a>
<a name="ln1852">                at_coord[nNumExplictAttachments][2] = z;</a>
<a name="ln1853">            }</a>
<a name="ln1854">            break;</a>
<a name="ln1855">        case 1:</a>
<a name="ln1856">            for ( j = 0; j &lt; at[cur_at].valence; j ++, nNumExplictAttachments ++ ) {</a>
<a name="ln1857">                next = at[cur_at].neighbor[j];</a>
<a name="ln1858">                at_coord[nNumExplictAttachments][0] = at[next].x - at[cur_at].x;</a>
<a name="ln1859">                at_coord[nNumExplictAttachments][1] = at[next].y - at[cur_at].y;</a>
<a name="ln1860">                nSbNeighOrigAtNumb[nNumExplictAttachments] = at[next].orig_at_number;</a>
<a name="ln1861"> </a>
<a name="ln1862">                z = get_z_coord( at, cur_at, j /*neighbor #*/, &amp;nType, (bPointedEdgeStereo &amp; PES_BIT_POINT_EDGE_STEREO) );</a>
<a name="ln1863">                switch ( nType ) {</a>
<a name="ln1864">                case ZTYPE_EITHER:</a>
<a name="ln1865">                    num_either_single ++; /*  bond in &quot;Either&quot; direction. */</a>
<a name="ln1866">                    break;</a>
<a name="ln1867">                case ZTYPE_UP:</a>
<a name="ln1868">                case ZTYPE_DOWN:</a>
<a name="ln1869">                    z = len2( at_coord[nNumExplictAttachments] );</a>
<a name="ln1870">                    /*</a>
<a name="ln1871">                    z = sqrt( at_coord[nNumExplictAttachments][0]*at_coord[nNumExplictAttachments][0]</a>
<a name="ln1872">                            + at_coord[nNumExplictAttachments][1]*at_coord[nNumExplictAttachments][1] );</a>
<a name="ln1873">                    */</a>
<a name="ln1874">                    if ( nType == ZTYPE_DOWN )</a>
<a name="ln1875">                        z = -z;</a>
<a name="ln1876">                    /*  no break; here */</a>
<a name="ln1877">                case ZTYPE_3D:</a>
<a name="ln1878">                    num_z ++;</a>
<a name="ln1879">                }</a>
<a name="ln1880">                at_coord[nNumExplictAttachments][2] = z;</a>
<a name="ln1881">            }</a>
<a name="ln1882">            break;</a>
<a name="ln1883">        }</a>
<a name="ln1884">    }</a>
<a name="ln1885"> </a>
<a name="ln1886">    if ( num_either_single ) {</a>
<a name="ln1887">        bond_parity =  vABParityUnknown /*AB_PARITY_UNKN*/;  /*  single bond is 'unknown' */</a>
<a name="ln1888">        goto exit_function;</a>
<a name="ln1889">    }</a>
<a name="ln1890"> </a>
<a name="ln1891">    /* nNumExplictAttachments is a total number of attachments, including removed explicit terminal hydrogens */</a>
<a name="ln1892">    if ( nNumExplictAttachments == 2 ) {</a>
<a name="ln1893">        /*  create coordinates of the implicit hydrogen (or a fictitious atom in case of ==N-X ), */</a>
<a name="ln1894">        /*  coord[2][], attached to the cur_at. */</a>
<a name="ln1895">        for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1896">            at_coord[2][j] = - ( at_coord[0][j] + at_coord[1][j] );</a>
<a name="ln1897">        }</a>
<a name="ln1898">        nSbNeighOrigAtNumb[nNumExplictAttachments] = 0; /* implicit H or lone pair */</a>
<a name="ln1899">    }</a>
<a name="ln1900">    for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1901">        tmp[j] = len3( at_coord[j] );</a>
<a name="ln1902">    }</a>
<a name="ln1903">    min_tmp = inchi_min( tmp[0], inchi_min(tmp[1], tmp[2]) );</a>
<a name="ln1904">    max_tmp = inchi_max( tmp[0], inchi_max(tmp[1], tmp[2]) );</a>
<a name="ln1905">    if ( min_tmp &lt; MIN_BOND_LEN || min_tmp &lt; MIN_SINE*max_tmp ) {</a>
<a name="ln1906">        /*  all bonds or some of bonds are too short */</a>
<a name="ln1907">        if ( at[cur_at].sb_parity[0] ) {</a>
<a name="ln1908">            /* use bond psrity; the reconciliation in ReconcileAllCmlBondParities()</a>
<a name="ln1909">             * has made all ways to calculate parity produce same result</a>
<a name="ln1910">             */</a>
<a name="ln1911">            bond_parity = GetHalfStereobond0DParity( at, cur_at, nSbNeighOrigAtNumb,</a>
<a name="ln1912">                                                     nNumExplictAttachments, bond_parity, FlagSB_0D );</a>
<a name="ln1913">        }</a>
<a name="ln1914">        </a>
<a name="ln1915">        goto exit_function; </a>
<a name="ln1916">    }</a>
<a name="ln1917">    /*  normalize lengths to 1 */</a>
<a name="ln1918">    for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1919">        mult3( at_coord[j], 1.0/tmp[j], at_coord[j] );</a>
<a name="ln1920">    }</a>
<a name="ln1921"> </a>
<a name="ln1922">    /*  find projections of at_coord vector differences on the plane containing their arrowhead ends */</a>
<a name="ln1923">    for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1924">        /*  pnt[0..2] = {0-1, 1-2, 2-0} */</a>
<a name="ln1925">        tmp[j] = len3(diff3( at_coord[j], at_coord[(j+1)%3], pnt[j] ));</a>
<a name="ln1926">        if ( tmp[j] &lt; MIN_SINE ) {</a>
<a name="ln1927">            goto exit_function; /*  angle #i-cur_at-#j is too small */</a>
<a name="ln1928">        }</a>
<a name="ln1929">        mult3( pnt[j], 1.0/tmp[j], pnt[j] ); /* 2003-10-06 */</a>
<a name="ln1930">    }</a>
<a name="ln1931">    /*  find pnt[p2], a vector perpendicular to the plane, and its length tmp[p2] */</a>
<a name="ln1932">    /*  replace previous pnt[p2], tmp[p2] with new values; the old values do not have any additional */</a>
<a name="ln1933">    /*  information because pnt[p0]+pnt[p1]+pnt[p2]=0 */</a>
<a name="ln1934">    /*  10-6-2003: a cross-product of one pair pnt[j], pnt[(j+1)%3] can be very small. Find the larges one */</a>
<a name="ln1935">    tmp1 = len3( cross_prod3( pnt[0], pnt[1], temp ) );</a>
<a name="ln1936">    for (j = 1, k = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1937">        tmp2 = len3( cross_prod3( pnt[j], pnt[(j+1)%3], temp ) );</a>
<a name="ln1938">        if ( tmp2 &gt; tmp1 ) {</a>
<a name="ln1939">            tmp1 = tmp2;</a>
<a name="ln1940">            k     = j;</a>
<a name="ln1941">        }</a>
<a name="ln1942">    }</a>
<a name="ln1943">    /* previously p0=0, p1=1, p2=2 */</a>
<a name="ln1944">    p0 = k;</a>
<a name="ln1945">    p1 = (k+1)%3;</a>
<a name="ln1946">    p2 = (k+2)%3;</a>
<a name="ln1947">    tmp[p2] = len3( cross_prod3( pnt[p0], pnt[p1], pnt[p2] ) );</a>
<a name="ln1948">    if ( tmp[p2] &lt; MIN_SINE*tmp[p0]*tmp[p1]  ) {</a>
<a name="ln1949">        goto exit_function; /*  pnt[p0] is almost colinear to pnt[p1] */</a>
<a name="ln1950">    }</a>
<a name="ln1951">    /*  new basis: pnt[p0], pnt[p1], pnt[p2]; set z-coord sign and make abs(pnt[p2]) = 1 */</a>
<a name="ln1952">    mult3( pnt[p2], (pnt[p2][2]&gt;0.0? 1.0:-1.0)/tmp[p2], pnt[p2] ); /*  unit vector in the new z-axis direction */</a>
<a name="ln1953"> </a>
<a name="ln1954">    min_tmp = dot_prod3( at_coord[0], pnt[p2] ); /*  non-planarity measure (sine): hight of at_coord[] pyramid */</a>
<a name="ln1955">    mult3( pnt[p2], min_tmp, pnt[p0] ); /*  vector height of the pyramid, ideally 0 */</a>
<a name="ln1956">    /*  find new pnt[p0] = projection of at_coord[p0] on plane orthogonal to pnt[p2] */</a>
<a name="ln1957">    tmp[p0] = len3(diff3( at_coord[0], pnt[p0], pnt[p0] ));</a>
<a name="ln1958">    mult3( pnt[p0], 1.0/tmp[p0], pnt[p0] );  /*  new x axis basis vector */</a>
<a name="ln1959">    cross_prod3( pnt[p2], pnt[p0], pnt[p1] ); /*  new y axis basis vector */</a>
<a name="ln1960">    /*  find at_coord in the new basis of {pnt[p0], pnt[p1], pnt[p2]} */</a>
<a name="ln1961">    for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln1962">        copy3( at_coord[j], temp );</a>
<a name="ln1963">        for ( k = 0; k &lt; 3; k ++ ) {</a>
<a name="ln1964">            at_coord[j][k] = dot_prod3( temp, pnt[(k+p0)%3] );</a>
<a name="ln1965">        }</a>
<a name="ln1966">        /*  new xy plane projection length */</a>
<a name="ln1967">        tmp[j] = sqrt(at_coord[j][0]*at_coord[j][0] + at_coord[j][1]*at_coord[j][1]);</a>
<a name="ln1968">        /*  make new xy plane projection length = 1 */</a>
<a name="ln1969">        mult3( at_coord[j], 1.0/tmp[j], at_coord[j] );</a>
<a name="ln1970">    }</a>
<a name="ln1971">   </a>
<a name="ln1972">    s = fabs( at_coord[1][0]*at_coord[2][1] - at_coord[1][1]*at_coord[2][0] ); /*  1-2 sine */</a>
<a name="ln1973">    c =       at_coord[1][0]*at_coord[2][0] + at_coord[1][1]*at_coord[2][1];   /*  1-2 cosine */</a>
<a name="ln1974">    if ( s &lt; MIN_SINE &amp;&amp; c &gt; 0.5 ) {</a>
<a name="ln1975">        goto exit_function; /*  bonds to neigh. 1 and 2 have almost same direction; relative angles are undefined */</a>
<a name="ln1976">    }</a>
<a name="ln1977">    c = at_coord[0][0]; /*  cosine of the angle between new Ox axis and a bond to the neighbor 0. Should be 1 */</a>
<a name="ln1978">    s = at_coord[0][1]; /*  sine. Should be 0 */</a>
<a name="ln1979">    /*  turn vectors so that vector #1 (at_coord[0]) becomes {1, 0} */</a>
<a name="ln1980">    for ( j = 0; j &lt; MAX_NUM_STEREO_BOND_NEIGH; j ++ ) {</a>
<a name="ln1981">        tmp1 =  c*at_coord[j][0] + s*at_coord[j][1];</a>
<a name="ln1982">        tmp2 = -s*at_coord[j][0] + c*at_coord[j][1];</a>
<a name="ln1983">        at_coord[j][0] = tmp1;</a>
<a name="ln1984">        at_coord[j][1] = tmp2;</a>
<a name="ln1985">    }</a>
<a name="ln1986">    /*  counterclockwise angles from the direction to neigh 0 to to directions to neighbors 1 and 2: */</a>
<a name="ln1987">    tmp1 = atan2( at_coord[1][1], at_coord[1][0] ); /*  range -pi and +pi */</a>
<a name="ln1988">    tmp2 = atan2( at_coord[2][1], at_coord[2][0] );</a>
<a name="ln1989">    if ( tmp1 &lt; 0.0 )</a>
<a name="ln1990">        tmp1 += two_pi; /*  range 0 to 2*pi */</a>
<a name="ln1991">    if ( tmp2 &lt; 0.0 )</a>
<a name="ln1992">        tmp2 += two_pi;</a>
<a name="ln1993">    /*-----------------------------------</a>
<a name="ln1994">                        Example</a>
<a name="ln1995">      1 \               case tmp1 &lt; tmp2</a>
<a name="ln1996">         \              parity is odd</a>
<a name="ln1997">          \             (counterclockwise)</a>
<a name="ln1998">           A------- 0</a>
<a name="ln1999">          /</a>
<a name="ln2000">         /</a>
<a name="ln2001">      2 /</a>
<a name="ln2002"> </a>
<a name="ln2003">    ------------------------------------*/</a>
<a name="ln2004">    bond_parity = 2 - ( tmp1 &lt; tmp2 );</a>
<a name="ln2005">    for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln2006">        z_dir[j] = (S_CHAR) (pnt[p2][j]&gt;= 0.0?  floor(0.5 + 100.0 * pnt[p2][j]) :</a>
<a name="ln2007">                                               -floor(0.5 - 100.0 * pnt[p2][j])); /*  abs(z_dir) = 100 */</a>
<a name="ln2008">    }</a>
<a name="ln2009">    /*  check for ambiguity */</a>
<a name="ln2010">    if ( nNumExplictAttachments &gt; 2 ) {</a>
<a name="ln2011">        min_tmp = inchi_min( tmp1, tmp2 );</a>
<a name="ln2012">        max_tmp = inchi_max( tmp1, tmp2 );</a>
<a name="ln2013">        if ( min_tmp &gt; one_pi-MIN_SINE || max_tmp &lt; one_pi+MIN_SINE || max_tmp-min_tmp &gt; one_pi - MIN_SINE ) {</a>
<a name="ln2014">            at[cur_at].bAmbiguousStereo |= AMBIGUOUS_STEREO;</a>
<a name="ln2015">        } else /* 3D ambiguity 8-28-2002 */</a>
<a name="ln2016">        if ( fabs(at_coord[0][2]) &gt; MAX_SINE ) { /*  all fabs(at_coord[j][2] (j=0..2) must be equal */</a>
<a name="ln2017">            at[cur_at].bAmbiguousStereo |= AMBIGUOUS_STEREO;</a>
<a name="ln2018">        }</a>
<a name="ln2019">    } else</a>
<a name="ln2020">    if ( nNumExplictAttachments == 2 ) {  /* 10-6-2003: added */</a>
<a name="ln2021">        min_tmp = fabs(tmp1 - one_pi);</a>
<a name="ln2022">        if ( min_tmp &lt; MIN_SINE ) {</a>
<a name="ln2023">            bond_parity = AB_PARITY_UNDF; /* consider as undefined 10-6-2003 */</a>
<a name="ln2024">        } else</a>
<a name="ln2025">        if ( min_tmp &lt; MIN_ANGLE_DBOND ) {</a>
<a name="ln2026">            at[cur_at].bAmbiguousStereo |= AMBIGUOUS_STEREO;</a>
<a name="ln2027">        }</a>
<a name="ln2028">    }</a>
<a name="ln2029"> </a>
<a name="ln2030"> </a>
<a name="ln2031">    /*  for 3 neighbors moving implicit H to the index=0 from index=2 position */</a>
<a name="ln2032">    /*  can be done in 2 transpositions and does not change atom's parity */</a>
<a name="ln2033">exit_function:</a>
<a name="ln2034">    if ( num_H &gt; 1 &amp;&amp; bond_parity &gt; 0 &amp;&amp; !(bond_parity &amp; AB_PARITY_0D) /*&amp;&amp; PARITY_WELL_DEF(bond_parity)*/ ) {</a>
<a name="ln2035">        /*</a>
<a name="ln2036">         * stereo only if isotopes are counted.             Do not inverse</a>
<a name="ln2037">         * Examples:                                        sign for this:</a>
<a name="ln2038">         *     H                            D               </a>
<a name="ln2039">         *    /                            /                    H</a>
<a name="ln2040">         * ==C                      or  ==CH                   / </a>
<a name="ln2041">         *    \                                             ==N  (bValence3=1)</a>
<a name="ln2042">         *     D                  </a>
<a name="ln2043">         * two explicit         one explicit H isotope (D),</a>
<a name="ln2044">         * isotopic H atoms     one implicit H</a>
<a name="ln2045">         */</a>
<a name="ln2046">        bond_parity = -bond_parity; /*  refers to isotopically substituted structure only */</a>
<a name="ln2047">    }</a>
<a name="ln2048">    return bond_parity;</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">/*************************************************************/</a>
<a name="ln2052">int save_a_stereo_bond( int z_prod, int result_action,</a>
<a name="ln2053">                        int at1, int ord1, AT_NUMB *stereo_bond_neighbor1, S_CHAR *stereo_bond_ord1, S_CHAR *stereo_bond_z_prod1, S_CHAR *stereo_bond_parity1, </a>
<a name="ln2054">                        int at2, int ord2, AT_NUMB *stereo_bond_neighbor2, S_CHAR *stereo_bond_ord2, S_CHAR *stereo_bond_z_prod2, S_CHAR *stereo_bond_parity2 )</a>
<a name="ln2055">{</a>
<a name="ln2056">    int i1, i2;</a>
<a name="ln2057">    for ( i1 = 0; i1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; stereo_bond_neighbor1[i1]; i1 ++ )</a>
<a name="ln2058">        ;</a>
<a name="ln2059">    for ( i2 = 0; i2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; stereo_bond_neighbor2[i2]; i2 ++ )</a>
<a name="ln2060">        ;</a>
<a name="ln2061">    if ( i1 == MAX_NUM_STEREO_BONDS || i2 == MAX_NUM_STEREO_BONDS )</a>
<a name="ln2062">        return 0;</a>
<a name="ln2063">    </a>
<a name="ln2064">    stereo_bond_parity1[i1] =</a>
<a name="ln2065">    stereo_bond_parity2[i2] = result_action;</a>
<a name="ln2066"> </a>
<a name="ln2067">    stereo_bond_neighbor1[i1] = (AT_NUMB) (at2+1);</a>
<a name="ln2068">    stereo_bond_ord1[i1]      = (S_CHAR)ord1;</a>
<a name="ln2069">    stereo_bond_neighbor2[i2] = (AT_NUMB) (at1+1);</a>
<a name="ln2070">    stereo_bond_ord2[i2]      = (S_CHAR)ord2;</a>
<a name="ln2071">    stereo_bond_z_prod1[i1]   =</a>
<a name="ln2072">    stereo_bond_z_prod2[i2]   = (S_CHAR)z_prod;</a>
<a name="ln2073">    return 1;</a>
<a name="ln2074">}</a>
<a name="ln2075">/***************************************************************/</a>
<a name="ln2076">int get_allowed_stereo_bond_type( int bond_type )</a>
<a name="ln2077">{</a>
<a name="ln2078">#if (ALLOW_TAUT_ATTACHMENTS_TO_STEREO_BONDS == 0 )</a>
<a name="ln2079">    if ( (bond_type &amp; ~BOND_MARK_ALL) == BOND_TAUTOM )</a>
<a name="ln2080">        return 0; /*  no tautomer bonds allowed */</a>
<a name="ln2081">    else</a>
<a name="ln2082">#endif</a>
<a name="ln2083">#if ( EXCL_ALL_AROM_BOND_PARITY  == 1 )  /* { */</a>
<a name="ln2084">    /*  a stereo bond cannot belong to an aromatic atom */</a>
<a name="ln2085">    if ( (bond_type &amp;= ~BOND_MARK_ALL) == BOND_ALTERN )</a>
<a name="ln2086">    {</a>
<a name="ln2087">        return 0;</a>
<a name="ln2088">    }</a>
<a name="ln2089">#else  /* } { */</a>
<a name="ln2090">#if ( ADD_6MEMB_AROM_BOND_PARITY == 1 )</a>
<a name="ln2091">    /*  accept any aromatic bond as a stereo bond */</a>
<a name="ln2092">    if ( (bond_type &amp;= ~BOND_MARK_ALL) == BOND_ALTERN )</a>
<a name="ln2093">#else</a>
<a name="ln2094">    /*  accept only aromatic bonds in non-6-member rings */</a>
<a name="ln2095">    if ( (bond_type &amp;= ~BOND_MARK_ALL) == BOND_ALTERN ) )</a>
<a name="ln2096">#endif</a>
<a name="ln2097">    {</a>
<a name="ln2098">        return BOND_ALTERN;</a>
<a name="ln2099">    }</a>
<a name="ln2100">#endif  /* } */</a>
<a name="ln2101">    else</a>
<a name="ln2102">    /*  at this point BOND_MARK_ALL bits have been removed from bond_type */</a>
<a name="ln2103">    if ( bond_type == BOND_DOUBLE || bond_type == BOND_SINGLE ) {</a>
<a name="ln2104">        return bond_type;</a>
<a name="ln2105">    }</a>
<a name="ln2106">#if (ALLOW_TAUT_ATTACHMENTS_TO_STEREO_BONDS == 1 )</a>
<a name="ln2107">    else</a>
<a name="ln2108">    if ( bond_type == BOND_TAUTOM ) {</a>
<a name="ln2109">        return BOND_TAUTOM;</a>
<a name="ln2110">    }</a>
<a name="ln2111">#endif</a>
<a name="ln2112"> </a>
<a name="ln2113">    return 0; /*  wrong bond type */</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">/*************************************************************/</a>
<a name="ln2117">int can_be_a_stereo_bond_with_isotopic_H( inp_ATOM *at, int cur_at, INCHI_MODE nMode )</a>
<a name="ln2118">{</a>
<a name="ln2119">    int i, j, next_at, num_stereo_bonds, bFound;</a>
<a name="ln2120">    int bond_type, num_2s, num_alt;</a>
<a name="ln2121">    int num_2s_next, num_alt_next, num_wrong_bonds_1, num_wrong_bonds_2;</a>
<a name="ln2122">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2123">    int n2sh, num_2s_hetero[2], num_2s_hetero_next[2], next_next_at, type_N, type_N_next;</a>
<a name="ln2124">#endif</a>
<a name="ln2125">    if ( MAX_NUM_STEREO_BOND_NEIGH &lt; at[cur_at].valence+at[cur_at].num_H ||</a>
<a name="ln2126">         MIN_NUM_STEREO_BOND_NEIGH &gt; at[cur_at].valence+at[cur_at].num_H  )</a>
<a name="ln2127">        return 0;</a>
<a name="ln2128">    if ( !bCanAtomHaveAStereoBond( at[cur_at].elname, at[cur_at].charge, at[cur_at].radical ) )</a>
<a name="ln2129">        return 0;</a>
<a name="ln2130">    /*  count bonds and find the second atom on the stereo bond */</a>
<a name="ln2131">    num_2s = num_alt = num_wrong_bonds_1 = 0;</a>
<a name="ln2132">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2133">    num_2s_hetero[0] = num_2s_hetero[1] = type_N = 0;</a>
<a name="ln2134">    if ( 0 == at[cur_at].num_H &amp;&amp; 0 == at[cur_at].charge &amp;&amp; 0 == at[cur_at].radical &amp;&amp;</a>
<a name="ln2135">         3 == get_endpoint_valence( at[cur_at].el_number ) ) {</a>
<a name="ln2136">        if ( 2 == at[cur_at].valence &amp;&amp; 3 == at[cur_at].chem_bonds_valence ) {</a>
<a name="ln2137">            type_N = 1;</a>
<a name="ln2138">        } else</a>
<a name="ln2139">        if ( 3 == at[cur_at].valence &amp;&amp; 5 == at[cur_at].chem_bonds_valence ) {</a>
<a name="ln2140">            type_N = 2; /* unfortunately includes &gt;N# */</a>
<a name="ln2141">        }</a>
<a name="ln2142">    }</a>
<a name="ln2143">#endif</a>
<a name="ln2144">    for ( i = 0, num_stereo_bonds = 0; i &lt; at[cur_at].valence; i ++ ) {</a>
<a name="ln2145">        bFound    = 0;</a>
<a name="ln2146">        next_at   = at[cur_at].neighbor[i];</a>
<a name="ln2147">        bond_type = get_allowed_stereo_bond_type( (int)at[cur_at].bond_type[i] );</a>
<a name="ln2148">        if ( bond_type == BOND_ALTERN ) {</a>
<a name="ln2149">            num_alt ++;</a>
<a name="ln2150">            if ( cur_at &gt; next_at &amp;&amp; !(nMode &amp; CMODE_NO_ALT_SBONDS) )</a>
<a name="ln2151">                bFound = 1;</a>
<a name="ln2152">        } else</a>
<a name="ln2153">        if ( bond_type == BOND_DOUBLE ) {</a>
<a name="ln2154">            num_2s ++;</a>
<a name="ln2155">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2156">            if ( 0 &lt;= (n2sh = bIsSuitableHeteroInpAtom( at + next_at )) ) {</a>
<a name="ln2157">                num_2s_hetero[n2sh] ++; /* n2sh=0 -&gt; =N- or =NH; n2sh=1 -&gt; =O */</a>
<a name="ln2158">            }</a>
<a name="ln2159">#endif</a>
<a name="ln2160">            if ( cur_at &gt; next_at )</a>
<a name="ln2161">                bFound = 1;</a>
<a name="ln2162">        } else</a>
<a name="ln2163">        if ( bond_type != BOND_SINGLE &amp;&amp; bond_type != BOND_TAUTOM ) {</a>
<a name="ln2164">            num_wrong_bonds_1 ++;</a>
<a name="ln2165">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2166">            if ( num_wrong_bonds_1 &gt; 1 || (num_wrong_bonds_1 &amp;&amp; 2 &gt;= at[cur_at].valence) ) {</a>
<a name="ln2167">                return 0; /* wrong bond type */</a>
<a name="ln2168">            } else {</a>
<a name="ln2169">                continue;</a>
<a name="ln2170">            }</a>
<a name="ln2171">#else</a>
<a name="ln2172">            return 0; /*  wrong bond type */</a>
<a name="ln2173">#endif</a>
<a name="ln2174">        }</a>
<a name="ln2175"> </a>
<a name="ln2176">        if ( bFound ) {</a>
<a name="ln2177">            /*  check &quot;next_at&quot; atom on the opposite side of the bond */</a>
<a name="ln2178">            if ( MAX_NUM_STEREO_BOND_NEIGH &lt; at[next_at].valence+at[next_at].num_H ||</a>
<a name="ln2179">                 MIN_NUM_STEREO_BOND_NEIGH &gt; at[next_at].valence+at[next_at].num_H )</a>
<a name="ln2180">                continue;</a>
<a name="ln2181">            if ( !bCanAtomHaveAStereoBond( at[next_at].elname, at[next_at].charge, at[next_at].radical ) )</a>
<a name="ln2182">                continue;</a>
<a name="ln2183">            /*  next atom neighbors */</a>
<a name="ln2184">            num_2s_next = num_alt_next = num_wrong_bonds_2 = 0;</a>
<a name="ln2185">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2186">            num_2s_hetero_next[0] = num_2s_hetero_next[1] = type_N_next = 0;</a>
<a name="ln2187">            if ( 0 == at[next_at].num_H &amp;&amp; 0 == at[next_at].charge &amp;&amp; 0 == at[next_at].radical &amp;&amp;</a>
<a name="ln2188">                 3 == get_endpoint_valence( at[next_at].el_number ) ) {</a>
<a name="ln2189">                if ( 2 == at[next_at].valence &amp;&amp; 3 == at[next_at].chem_bonds_valence ) {</a>
<a name="ln2190">                    type_N_next = 1; /* -N= */</a>
<a name="ln2191">                } else</a>
<a name="ln2192">                if ( 3 == at[next_at].valence &amp;&amp; 5 == at[next_at].chem_bonds_valence ) {</a>
<a name="ln2193">                    type_N_next = 2; /* unfortunately includes &gt;N# */</a>
<a name="ln2194">                }</a>
<a name="ln2195">            }</a>
<a name="ln2196">#endif</a>
<a name="ln2197">            for ( j = 0; j &lt; at[next_at].valence; j ++ ) {</a>
<a name="ln2198">                bond_type = get_allowed_stereo_bond_type( (int)at[next_at].bond_type[j] );</a>
<a name="ln2199">                if ( bond_type == BOND_ALTERN )</a>
<a name="ln2200">                    num_alt_next ++;</a>
<a name="ln2201">                else</a>
<a name="ln2202">                if ( bond_type == BOND_DOUBLE ) {</a>
<a name="ln2203">                    num_2s_next ++;</a>
<a name="ln2204">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2205">                    next_next_at = at[next_at].neighbor[j];</a>
<a name="ln2206">                    if ( 0 &lt;= (n2sh = bIsSuitableHeteroInpAtom( at + next_next_at )) ) {</a>
<a name="ln2207">                        num_2s_hetero_next[n2sh] ++; /* n2sh=0 -&gt; =N- or =NH; n2sh=1 -&gt; =O */</a>
<a name="ln2208">                    }</a>
<a name="ln2209">#endif</a>
<a name="ln2210">                } else</a>
<a name="ln2211">                if ( bond_type != BOND_SINGLE &amp;&amp; bond_type != BOND_TAUTOM ) {</a>
<a name="ln2212">                    num_wrong_bonds_2 ++;</a>
<a name="ln2213">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2214">                    if ( num_wrong_bonds_1 &gt; 1 || (num_wrong_bonds_1 &amp;&amp; 2 &gt;= at[cur_at].valence) ) {</a>
<a name="ln2215">                        break; /* wrong bond type */</a>
<a name="ln2216">                    } else {</a>
<a name="ln2217">                        continue;</a>
<a name="ln2218">                    }</a>
<a name="ln2219">#else</a>
<a name="ln2220">                    break; /*  wrong bond type */</a>
<a name="ln2221">#endif</a>
<a name="ln2222">                }</a>
<a name="ln2223">            }</a>
<a name="ln2224">            /* figure out whether the at[cur_at]--at[next_at] bond may not be stereogenic */</a>
<a name="ln2225"> </a>
<a name="ln2226">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2227">            if ( 3 == (type_N | type_N_next) &amp;&amp;</a>
<a name="ln2228">                 ( (2 == type_N &amp;&amp; !bIsOxide( at, cur_at )) ||</a>
<a name="ln2229">                   (2 == type_N_next &amp;&amp; !bIsOxide( at, next_at )) ) ) {</a>
<a name="ln2230">                bFound = 0;</a>
<a name="ln2231">            } else</a>
<a name="ln2232">#endif</a>
<a name="ln2233">            if ( j &lt; at[next_at].valence ||                  /* at[next_at] has a wrong bond type*/</a>
<a name="ln2234">                 (num_alt_next&gt;0) + (num_2s_next&gt;0) != 1     /* only one type of stereogenic bond permitted */</a>
<a name="ln2235">                ) {</a>
<a name="ln2236">                bFound = 0;</a>
<a name="ln2237">            } else</a>
<a name="ln2238">            if ( 2 &lt; num_2s_next ) {</a>
<a name="ln2239">                bFound = 0;</a>
<a name="ln2240">            } else</a>
<a name="ln2241">            if ( 2 == num_2s_next ) {</a>
<a name="ln2242">                if ( 2 == at[next_at].valence ) {</a>
<a name="ln2243">                    ; /* only one double bond permitted except cumulenes */</a>
<a name="ln2244">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2245">                } else</a>
<a name="ln2246">                if ( 1 == (num_2s_hetero_next[0] | num_2s_hetero_next[1]) &amp;&amp;</a>
<a name="ln2247">                     3 == at[next_at].valence + at[next_at].num_H &amp;&amp;</a>
<a name="ln2248">                     5 == at[next_at].chem_bonds_valence + at[next_at].num_H &amp;&amp;</a>
<a name="ln2249">                     3 == get_endpoint_valence( at[next_at].el_number ) &amp;&amp;</a>
<a name="ln2250">                     (!type_N || bIsOxide( at, next_at )) ) {</a>
<a name="ln2251">                    ; /*</a>
<a name="ln2252">                       *   found:</a>
<a name="ln2253">                       *</a>
<a name="ln2254">                       *    \      /    \      /    \      /     </a>
<a name="ln2255">                       *     \    /      \    /      \    /      </a>
<a name="ln2256">                       *      N==C   or   N==C   or   N==N       </a>
<a name="ln2257">                       *    //    \     //    \     //    \      </a>
<a name="ln2258">                       *   O  ^    \   N  ^    \   O  ^    \     </a>
<a name="ln2259">                       *      |           |           |          </a>
<a name="ln2260">                       *      |           |           |          </a>
<a name="ln2261">                       *      at[next_at] at[next_at] at[next_at]</a>
<a name="ln2262">                       */</a>
<a name="ln2263">#endif</a>
<a name="ln2264">                } else {</a>
<a name="ln2265">                    bFound = 0;</a>
<a name="ln2266">                }</a>
<a name="ln2267">            }</a>
<a name="ln2268"> </a>
<a name="ln2269">        }</a>
<a name="ln2270">        if ( bFound ) {</a>
<a name="ln2271">           num_stereo_bonds++;</a>
<a name="ln2272">        }</a>
<a name="ln2273">    }</a>
<a name="ln2274">    </a>
<a name="ln2275">    if ( (num_alt&gt;0) + (num_2s&gt;0) != 1 || !num_stereo_bonds )</a>
<a name="ln2276">        return 0;</a>
<a name="ln2277">    if ( num_2s &gt; 1 ) {</a>
<a name="ln2278">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2279">        if ( 2 == num_2s &amp;&amp;</a>
<a name="ln2280">             1 == (num_2s_hetero[0] | num_2s_hetero[1]) &amp;&amp;</a>
<a name="ln2281">             3 == at[cur_at].valence + at[cur_at].num_H &amp;&amp;</a>
<a name="ln2282">             5 == at[cur_at].chem_bonds_valence + at[cur_at].num_H &amp;&amp;</a>
<a name="ln2283">             3 == get_endpoint_valence( at[cur_at].el_number ) ) {</a>
<a name="ln2284">            ;</a>
<a name="ln2285">        } else {</a>
<a name="ln2286">            return 0;</a>
<a name="ln2287">        }</a>
<a name="ln2288">#else</a>
<a name="ln2289">        return 0;</a>
<a name="ln2290">#endif</a>
<a name="ln2291">    }</a>
<a name="ln2292"> </a>
<a name="ln2293">    return num_stereo_bonds;</a>
<a name="ln2294">}</a>
<a name="ln2295">/*************************************************************/</a>
<a name="ln2296">int half_stereo_bond_action( int nParity, int bUnknown, int bIsotopic, int vABParityUnknown )</a>
<a name="ln2297">{</a>
<a name="ln2298">#define AB_NEGATIVE 0x10</a>
<a name="ln2299">#define AB_UNKNOWN  0x20</a>
<a name="ln2300">    int nAction;</a>
<a name="ln2301"> </a>
<a name="ln2302">    if ( nParity == AB_PARITY_NONE )</a>
<a name="ln2303">        return AB_PARITY_NONE;</a>
<a name="ln2304">    </a>
<a name="ln2305">    /*  Unknown (type 1) in the parity value may come from the 'Either' single bond only */</a>
<a name="ln2306">    /*  Treat it as a known single bond geometry and unknown (Either) double bond */</a>
<a name="ln2307">    if ( nParity == vABParityUnknown /*AB_PARITY_UNKN*/ )</a>
<a name="ln2308">        nParity = AB_PARITY_ODD  | AB_UNKNOWN;</a>
<a name="ln2309">    if ( nParity == -vABParityUnknown /*AB_PARITY_UNKN*/ )</a>
<a name="ln2310">        nParity = AB_PARITY_ODD  | AB_UNKNOWN | AB_NEGATIVE;</a>
<a name="ln2311"> </a>
<a name="ln2312">    /*  make positive, replace AB_PARITY_EVEN with AB_PARITY_ODD  */</a>
<a name="ln2313">    if ( nParity &lt; 0 )</a>
<a name="ln2314">        nParity = ((nParity == -AB_PARITY_EVEN)? AB_PARITY_ODD : (-nParity)) | AB_NEGATIVE;</a>
<a name="ln2315">    else</a>
<a name="ln2316">    if (nParity == AB_PARITY_EVEN)</a>
<a name="ln2317">        nParity = AB_PARITY_ODD;</a>
<a name="ln2318"> </a>
<a name="ln2319">    /*  Unknown (type 2): was detected in the double bond attribute */</a>
<a name="ln2320">    /*  (this 'unknown' came from 'Either' double bond) */</a>
<a name="ln2321">    /*  Treat both unknowns in the same way */</a>
<a name="ln2322">    if ( bUnknown )</a>
<a name="ln2323">        nParity |= AB_UNKNOWN;</a>
<a name="ln2324"> </a>
<a name="ln2325">    if ( bIsotopic ) {</a>
<a name="ln2326">        switch ( nParity ) {</a>
<a name="ln2327">        case AB_PARITY_ODD:</a>
<a name="ln2328">        case AB_PARITY_ODD | AB_NEGATIVE:</a>
<a name="ln2329">            nAction = AB_PARITY_CALC;</a>
<a name="ln2330">            break;</a>
<a name="ln2331">        case AB_PARITY_ODD  | AB_UNKNOWN:</a>
<a name="ln2332">        case AB_PARITY_UNDF | AB_UNKNOWN:</a>
<a name="ln2333">        case AB_PARITY_ODD  | AB_UNKNOWN | AB_NEGATIVE:</a>
<a name="ln2334">        case AB_PARITY_UNDF | AB_UNKNOWN | AB_NEGATIVE:</a>
<a name="ln2335">            nAction = vABParityUnknown /*AB_PARITY_UNKN*/;</a>
<a name="ln2336">            break;</a>
<a name="ln2337">        case AB_PARITY_IISO:</a>
<a name="ln2338">        case AB_PARITY_IISO | AB_UNKNOWN:</a>
<a name="ln2339">            nAction = AB_PARITY_NONE;</a>
<a name="ln2340">            break;</a>
<a name="ln2341">        case AB_PARITY_UNDF:</a>
<a name="ln2342">        case AB_PARITY_UNDF | AB_NEGATIVE:</a>
<a name="ln2343">            nAction = AB_PARITY_UNDF;</a>
<a name="ln2344">            break;</a>
<a name="ln2345">        default:</a>
<a name="ln2346">            nAction = -1; /*  program error */</a>
<a name="ln2347">        }</a>
<a name="ln2348">    } else {</a>
<a name="ln2349">        /*  Non-isotopic */</a>
<a name="ln2350">        switch ( nParity ) {</a>
<a name="ln2351">        case AB_PARITY_ODD:</a>
<a name="ln2352">            nAction = AB_PARITY_CALC;</a>
<a name="ln2353">            break;</a>
<a name="ln2354">        case AB_PARITY_ODD  | AB_UNKNOWN:</a>
<a name="ln2355">        case AB_PARITY_UNDF | AB_UNKNOWN:</a>
<a name="ln2356">            nAction = vABParityUnknown /*AB_PARITY_UNKN*/;</a>
<a name="ln2357">            break;</a>
<a name="ln2358">        /* case AB_PARITY_ODD  | AB_UNKNOWN | AB_NEGATIVE: */</a>
<a name="ln2359">        case AB_PARITY_UNDF:</a>
<a name="ln2360">            nAction = AB_PARITY_UNDF;</a>
<a name="ln2361">            break;</a>
<a name="ln2362">        case AB_PARITY_ODD  | AB_UNKNOWN | AB_NEGATIVE:</a>
<a name="ln2363">        case AB_PARITY_ODD  | AB_NEGATIVE:</a>
<a name="ln2364">        case AB_PARITY_IISO:</a>
<a name="ln2365">        case AB_PARITY_IISO | AB_UNKNOWN:</a>
<a name="ln2366">        case AB_PARITY_UNDF | AB_NEGATIVE:</a>
<a name="ln2367">        case AB_PARITY_UNDF | AB_UNKNOWN | AB_NEGATIVE:</a>
<a name="ln2368">            nAction = AB_PARITY_NONE;</a>
<a name="ln2369">            break;</a>
<a name="ln2370">        default:</a>
<a name="ln2371">            nAction = -1; /*  program error */</a>
<a name="ln2372">        }</a>
<a name="ln2373">    }</a>
<a name="ln2374">    return nAction;</a>
<a name="ln2375">#undef AB_NEGATIVE</a>
<a name="ln2376">#undef AB_UNKNOWN</a>
<a name="ln2377">}</a>
<a name="ln2378">/*************************************************************/</a>
<a name="ln2379">int set_stereo_bonds_parity( sp_ATOM *out_at, inp_ATOM *at, int at_1, inp_ATOM *at_removed_H, int num_removed_H,</a>
<a name="ln2380">  INCHI_MODE nMode, QUEUE *q, AT_RANK *nAtomLevel, S_CHAR *cSource, </a>
<a name="ln2381">  AT_RANK min_sb_ring_size, int bPointedEdgeStereo, int vABParityUnknown )</a>
<a name="ln2382">{</a>
<a name="ln2383">    int j, k, next_at_1, i_next_at_1, i_next_at_2, at_2, next_at_2, num_stereo_bonds, bFound, bAllene;</a>
<a name="ln2384">    int bond_type, num_2s_1, num_alt_1;</a>
<a name="ln2385">    int num_2s_2, num_alt_2;</a>
<a name="ln2386">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2387">    int num_wrong_bonds_1, num_wrong_bonds_2;</a>
<a name="ln2388">#endif</a>
<a name="ln2389">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2390">    int n2sh, num_2s_hetero[2], num_2s_hetero_next[2], next_next_at, type_N, type_N_next;</a>
<a name="ln2391">#endif</a>
<a name="ln2392">    int num_stored_stereo_bonds, num_stored_isotopic_stereo_bonds;</a>
<a name="ln2393">    int chain_length, num_chains, cur_chain_length;</a>
<a name="ln2394">    int all_at_2[MAX_NUM_STEREO_BONDS];</a>
<a name="ln2395">    int all_pos_1[MAX_NUM_STEREO_BONDS], all_pos_2[MAX_NUM_STEREO_BONDS];</a>
<a name="ln2396">    S_CHAR all_unkn[MAX_NUM_STEREO_BONDS];</a>
<a name="ln2397">    int /*at_1_parity, at_2_parity,*/ nUnknown, stop=0;</a>
<a name="ln2398">    </a>
<a name="ln2399">    /* at_1_parity = AB_PARITY_NONE; */ /*  do not know */</a>
<a name="ln2400">    /*  check valence */</a>
<a name="ln2401">    if ( MAX_NUM_STEREO_BOND_NEIGH &lt; at[at_1].valence+at[at_1].num_H ||</a>
<a name="ln2402">         MIN_NUM_STEREO_BOND_NEIGH &gt; at[at_1].valence+at[at_1].num_H  )</a>
<a name="ln2403">        return 0;</a>
<a name="ln2404">    if ( !bCanAtomHaveAStereoBond( at[at_1].elname, at[at_1].charge, at[at_1].radical ) )</a>
<a name="ln2405">        return 0;</a>
<a name="ln2406">    if ( at[at_1].c_point )</a>
<a name="ln2407">        return 0; /* rejects atoms that can lose or gain a (positive) charge. 01-24-2003 */</a>
<a name="ln2408"> </a>
<a name="ln2409">    /*  middle cumulene atoms, for example, =C=, should be ignored here */</a>
<a name="ln2410">    /*  only atoms at the ends of cumulene chains are considered. */</a>
<a name="ln2411">    if ( !at[at_1].num_H &amp;&amp; 2 == at[at_1].valence &amp;&amp;</a>
<a name="ln2412">         BOND_DOUBLE == get_allowed_stereo_bond_type( (int)at[at_1].bond_type[0] ) &amp;&amp;</a>
<a name="ln2413">         BOND_DOUBLE == get_allowed_stereo_bond_type( (int)at[at_1].bond_type[1] ) ) {</a>
<a name="ln2414">        return 0;</a>
<a name="ln2415">    }</a>
<a name="ln2416"> </a>
<a name="ln2417">    /*  count bonds and find the second atom on the stereo bond */</a>
<a name="ln2418">    num_2s_1 = num_alt_1 = 0;</a>
<a name="ln2419">    chain_length      = 0;</a>
<a name="ln2420">    num_chains        = 0;</a>
<a name="ln2421">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2422">    num_wrong_bonds_1 = 0;</a>
<a name="ln2423">#endif</a>
<a name="ln2424">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2425">    num_2s_hetero[0] = num_2s_hetero[1] = type_N = 0;</a>
<a name="ln2426">    if ( 0 == at[at_1].num_H &amp;&amp; 0 == at[at_1].charge &amp;&amp; 0 == at[at_1].radical &amp;&amp;</a>
<a name="ln2427">         3 == get_endpoint_valence( at[at_1].el_number ) ) {</a>
<a name="ln2428">        if ( 2 == at[at_1].valence &amp;&amp; 3 == at[at_1].chem_bonds_valence ) {</a>
<a name="ln2429">            type_N = 1;</a>
<a name="ln2430">        } else</a>
<a name="ln2431">        if ( 3 == at[at_1].valence &amp;&amp; 5 == at[at_1].chem_bonds_valence ) {</a>
<a name="ln2432">            type_N = 2; /* unfortunately includes &gt;N# */</a>
<a name="ln2433">        }</a>
<a name="ln2434">    }</a>
<a name="ln2435">#endif</a>
<a name="ln2436">    for ( i_next_at_1 = 0, num_stereo_bonds = 0; i_next_at_1 &lt; at[at_1].valence; i_next_at_1 ++ ) {</a>
<a name="ln2437">        nUnknown = (at[at_1].bond_stereo[i_next_at_1] == STEREO_DBLE_EITHER);</a>
<a name="ln2438">        bond_type = get_allowed_stereo_bond_type( (int)at[at_1].bond_type[i_next_at_1] );</a>
<a name="ln2439">        at_2 = -1; /* not found */</a>
<a name="ln2440">        if ( bond_type == BOND_ALTERN ||</a>
<a name="ln2441">             bond_type == BOND_DOUBLE ) {</a>
<a name="ln2442">            next_at_1 = at_2 = at[at_1].neighbor[i_next_at_1];</a>
<a name="ln2443">            next_at_2 = at_1;</a>
<a name="ln2444">        }</a>
<a name="ln2445">        switch ( bond_type ) {</a>
<a name="ln2446">        case BOND_ALTERN:</a>
<a name="ln2447">            num_alt_1 ++;</a>
<a name="ln2448">#if ( FIND_RING_SYSTEMS == 1 )</a>
<a name="ln2449">            if ( at[at_1].nRingSystem != at[at_2].nRingSystem )</a>
<a name="ln2450">                continue; /* reject alt. bond connecting different ring systems */</a>
<a name="ln2451">#endif</a>
<a name="ln2452">            if ( (nMode &amp; CMODE_NO_ALT_SBONDS) ||</a>
<a name="ln2453">                 !bCanAtomHaveAStereoBond( at[at_2].elname, at[at_2].charge, at[at_2].radical ) ) {</a>
<a name="ln2454">                continue; /*  reject non-stereogenic bond to neighbor ord. #i_next_at_1 */</a>
<a name="ln2455">            }</a>
<a name="ln2456">            break;</a>
<a name="ln2457">        case BOND_DOUBLE:</a>
<a name="ln2458">            /*  check for cumulene/allene */</a>
<a name="ln2459">            num_2s_1++;</a>
<a name="ln2460">            cur_chain_length = 0;</a>
<a name="ln2461">            if ( bCanAtomBeTerminalAllene( at[at_1].elname, at[at_1].charge, at[at_1].radical ) ) {</a>
<a name="ln2462">                /*</a>
<a name="ln2463">                 * Example of cumulene</a>
<a name="ln2464">                 * chain length = 2:     &gt;X=C=C=Y&lt;</a>
<a name="ln2465">                 *                        | | | |</a>
<a name="ln2466">                 *  1st cumulene atom= at_1 | | at_2 =last cumlene chain atom</a>
<a name="ln2467">                 *  next to at_1=   next_at_1 next_at_2  =previous to at_2</a>
<a name="ln2468">                 *</a>
<a name="ln2469">                 *  chain length odd:  stereocenter on the middle atom ( 1=&gt; allene )</a>
<a name="ln2470">                 *  chain length even: &quot;long stereogenic bond&quot;</a>
<a name="ln2471">                 */</a>
<a name="ln2472">                while ((bAllene = </a>
<a name="ln2473">                        !at[at_2].num_H &amp;&amp; at[at_2].valence == 2 &amp;&amp;</a>
<a name="ln2474">                        BOND_DOUBLE == get_allowed_stereo_bond_type( (int)at[at_2].bond_type[0] )  &amp;&amp;</a>
<a name="ln2475">                        BOND_DOUBLE == get_allowed_stereo_bond_type( (int)at[at_2].bond_type[1] )) &amp;&amp;          </a>
<a name="ln2476">                        bCanAtomBeMiddleAllene( at[at_2].elname, at[at_2].charge, at[at_2].radical ) ) {</a>
<a name="ln2477">                    k = ((int)at[at_2].neighbor[0]==next_at_2); /*  opposite neighbor position */</a>
<a name="ln2478">                    next_at_2 = at_2;</a>
<a name="ln2479">                    nUnknown += (at[at_2].bond_stereo[k] == STEREO_DBLE_EITHER);</a>
<a name="ln2480">                    at_2 = (int)at[at_2].neighbor[k];</a>
<a name="ln2481">                    cur_chain_length ++;  /*  count =C= atoms */</a>
<a name="ln2482">                }</a>
<a name="ln2483">                if ( cur_chain_length ) {</a>
<a name="ln2484">                    num_chains ++;</a>
<a name="ln2485">                    if ( bAllene /* at the end of the chain atom Y is =Y=, not =Y&lt; or =Y- */ ||</a>
<a name="ln2486">                         !bCanAtomBeTerminalAllene( at[at_2].elname, at[at_2].charge, at[at_2].radical ) ) {</a>
<a name="ln2487">                        cur_chain_length = 0;</a>
<a name="ln2488">                        continue; /*  ignore: does not fit cumulene description; go to check next at_1 neighbor */</a>
<a name="ln2489">                    }</a>
<a name="ln2490">                    chain_length = cur_chain_length; /*  accept a stereogenic cumulele */</a>
<a name="ln2491">                }</a>
<a name="ln2492">            }</a>
<a name="ln2493">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2494">            if ( !cur_chain_length &amp;&amp;</a>
<a name="ln2495">                 0 &lt;= (n2sh = bIsSuitableHeteroInpAtom( at + at_2 )) ) {</a>
<a name="ln2496">                num_2s_hetero[n2sh] ++; /* n2sh=0 -&gt; =N- or =NH; n2sh=1 -&gt; =O */</a>
<a name="ln2497">            }</a>
<a name="ln2498">#endif</a>
<a name="ln2499">            if ( !cur_chain_length &amp;&amp;</a>
<a name="ln2500">                 !bCanAtomHaveAStereoBond( at[at_2].elname, at[at_2].charge, at[at_2].radical ) ) {</a>
<a name="ln2501">                    continue; /*  reject non-stereogenic bond to neighbor #i_next_at_1 */</a>
<a name="ln2502">            }</a>
<a name="ln2503"> </a>
<a name="ln2504">            break;</a>
<a name="ln2505"> </a>
<a name="ln2506">        case BOND_SINGLE:</a>
<a name="ln2507">        case BOND_TAUTOM:</a>
<a name="ln2508">            continue; /*  reject non-stereogenic bond to neighbor #i_next_at_1 */</a>
<a name="ln2509">        default:</a>
<a name="ln2510">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2511">            num_wrong_bonds_1 ++;</a>
<a name="ln2512">            continue;</a>
<a name="ln2513">#else</a>
<a name="ln2514">            return 0; /*  wrong bond type; */</a>
<a name="ln2515">#endif</a>
<a name="ln2516">        }</a>
<a name="ln2517"> </a>
<a name="ln2518">        /*  check atom at the opposite end of possibly stereogenic bond */</a>
<a name="ln2519"> </a>
<a name="ln2520">        bFound   = (at_2 &gt;= 0 &amp;&amp; at_1 &gt; at_2 ); /*  i_next_at_1 = at_1 stereogenic bond neighbor attachment number */</a>
<a name="ln2521"> </a>
<a name="ln2522">        if ( bFound ) {</a>
<a name="ln2523">            /*  check &quot;at_2&quot; atom on the opposite side of the bond or cumulene chain */</a>
<a name="ln2524">            if ( MAX_NUM_STEREO_BOND_NEIGH &lt; at[at_2].valence+at[at_2].num_H ||</a>
<a name="ln2525">                 MIN_NUM_STEREO_BOND_NEIGH &gt; at[at_2].valence+at[at_2].num_H )</a>
<a name="ln2526">                continue;</a>
<a name="ln2527">            </a>
<a name="ln2528">            /*  check at_2 neighbors and bonds */</a>
<a name="ln2529">            num_2s_2 = num_alt_2 = 0;</a>
<a name="ln2530">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2531">            num_2s_hetero_next[0] = num_2s_hetero_next[1] = type_N_next = 0;</a>
<a name="ln2532">            if ( 0 == at[at_2].num_H &amp;&amp; 0 == at[at_2].charge &amp;&amp; 0 == at[at_2].radical &amp;&amp;</a>
<a name="ln2533">                 3 == get_endpoint_valence( at[at_2].el_number ) ) {</a>
<a name="ln2534">                if ( 2 == at[at_2].valence &amp;&amp; 3 == at[at_2].chem_bonds_valence ) {</a>
<a name="ln2535">                    type_N_next = 1; /* -N= */</a>
<a name="ln2536">                } else</a>
<a name="ln2537">                if ( 3 == at[at_2].valence &amp;&amp; 5 == at[at_2].chem_bonds_valence ) {</a>
<a name="ln2538">                    type_N_next = 2; /* unfortunately includes &gt;N# */</a>
<a name="ln2539">                }</a>
<a name="ln2540">            }</a>
<a name="ln2541">#endif</a>
<a name="ln2542">            i_next_at_2 = -1;  /*  unassigned mark */</a>
<a name="ln2543">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2544">            num_wrong_bonds_2 = 0;</a>
<a name="ln2545">#endif</a>
<a name="ln2546">            for ( j = 0; j &lt; at[at_2].valence; j ++ ) {</a>
<a name="ln2547">                bond_type = get_allowed_stereo_bond_type( (int)at[at_2].bond_type[j] );</a>
<a name="ln2548">                if ( !bond_type ) {</a>
<a name="ln2549">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2550">                    num_wrong_bonds_2 ++;</a>
<a name="ln2551">                    continue;  /*  this bond type is not allowed to be adjacent to a stereo bond */</a>
<a name="ln2552">#else</a>
<a name="ln2553">                    break;</a>
<a name="ln2554">#endif</a>
<a name="ln2555">                }</a>
<a name="ln2556">                if ( bond_type == BOND_DOUBLE ) {</a>
<a name="ln2557">                    num_2s_2 ++;</a>
<a name="ln2558">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2559">                    next_next_at = at[at_2].neighbor[j];</a>
<a name="ln2560">                    if ( 0 &lt;= (n2sh = bIsSuitableHeteroInpAtom( at + next_next_at )) ) {</a>
<a name="ln2561">                        num_2s_hetero_next[n2sh] ++; /* n2sh=0 -&gt; =N- or =NH; n2sh=1 -&gt; =O */</a>
<a name="ln2562">                    }</a>
<a name="ln2563">#endif</a>
<a name="ln2564">                } else {</a>
<a name="ln2565">                    num_alt_2  += ( bond_type == BOND_ALTERN );</a>
<a name="ln2566">                }</a>
<a name="ln2567">                if ( (int)at[at_2].neighbor[j] == next_at_2 )</a>
<a name="ln2568">                    i_next_at_2 = j; /*  assigned */</a>
<a name="ln2569">            }</a>
<a name="ln2570">            if ( </a>
<a name="ln2571">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2572">                 num_wrong_bonds_2 &gt; 1 || (num_wrong_bonds_2 &amp;&amp; 2 &gt;= at[at_2].valence) ||</a>
<a name="ln2573">#else</a>
<a name="ln2574">                 j &lt; at[at_2].valence /* &quot;next&quot; has a wrong bond type*/ ||</a>
<a name="ln2575">#endif</a>
<a name="ln2576">                 (num_alt_2&gt;0) + (num_2s_2&gt;0) != 1 || /* all double XOR all alt bonds only */</a>
<a name="ln2577">                  /* num_2s_2 &gt; 1  ||*/ /* only one double bond permitted */</a>
<a name="ln2578">                  i_next_at_2 &lt; 0 /* atom next to the opposite atom not found */ ) {</a>
<a name="ln2579">                bFound = 0;</a>
<a name="ln2580">            } else</a>
<a name="ln2581">            if ( at[at_2].c_point ) {</a>
<a name="ln2582">                bFound = 0; /* rejects atoms that can lose or gain a (positive) charge. 01-24-2003 */</a>
<a name="ln2583">            } else</a>
<a name="ln2584">            if ( num_2s_2 &gt; 2 ) {</a>
<a name="ln2585">                bFound = 0;</a>
<a name="ln2586">            } else</a>
<a name="ln2587">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2588">            if ( 3 == (type_N | type_N_next) &amp;&amp;</a>
<a name="ln2589">                 ( (2 == type_N &amp;&amp; !bIsOxide( at, at_1 )) ||</a>
<a name="ln2590">                   (2 == type_N_next &amp;&amp; !bIsOxide( at, at_2 )) ) ) {</a>
<a name="ln2591">                bFound = 0;</a>
<a name="ln2592">            } else</a>
<a name="ln2593">#endif</a>
<a name="ln2594">            if ( 2 == num_2s_2 ) {</a>
<a name="ln2595">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2596">                if ( !chain_length &amp;&amp;</a>
<a name="ln2597">                     1 == (num_2s_hetero_next[0] | num_2s_hetero_next[1]) &amp;&amp;</a>
<a name="ln2598">                     3 == at[at_2].valence + at[at_2].num_H &amp;&amp;</a>
<a name="ln2599">                     5 == at[at_2].chem_bonds_valence + at[at_2].num_H &amp;&amp;</a>
<a name="ln2600">                     3 == get_endpoint_valence( at[at_2].el_number ) &amp;&amp;</a>
<a name="ln2601">                     (!type_N || bIsOxide( at, at_2 )) ) {</a>
<a name="ln2602">                      /*</a>
<a name="ln2603">                       *   found:</a>
<a name="ln2604">                       *</a>
<a name="ln2605">                       *    \      /    \      /    \      /     </a>
<a name="ln2606">                       *     \    /      \    /      \    /      </a>
<a name="ln2607">                       *      N==C   or   N==C   or   N==N       </a>
<a name="ln2608">                       *    //    \     //    \     //    \      </a>
<a name="ln2609">                       *   O  ^    \   N  ^    \   O  ^    \     </a>
<a name="ln2610">                       *      |           |           |          </a>
<a name="ln2611">                       *      |           |           |          </a>
<a name="ln2612">                       *      at[at_2]    at[at_2]    at[at_2]</a>
<a name="ln2613">                       */</a>
<a name="ln2614">                    ;</a>
<a name="ln2615">                } else {</a>
<a name="ln2616">                    bFound = 0;</a>
<a name="ln2617">                }</a>
<a name="ln2618">#else</a>
<a name="ln2619">                bFound = 0;</a>
<a name="ln2620">#endif</a>
<a name="ln2621">            }</a>
<a name="ln2622"> </a>
<a name="ln2623"> </a>
<a name="ln2624">            if ( chain_length &amp;&amp; num_alt_2 )</a>
<a name="ln2625">                return 0; /*  allow no alt bonds in cumulenes */</a>
<a name="ln2626">        }</a>
<a name="ln2627">        if ( bFound ) {</a>
<a name="ln2628">            all_pos_1[num_stereo_bonds]   = i_next_at_1; /* neighbor to at_1 position */</a>
<a name="ln2629">            all_pos_2[num_stereo_bonds]   = i_next_at_2; /* neighbor to at_2 position */</a>
<a name="ln2630">            all_at_2[num_stereo_bonds]    = at_2;        /* at_2 */</a>
<a name="ln2631">            all_unkn[num_stereo_bonds]    = nUnknown;    /* stereogenic bond has Unknown configuration */</a>
<a name="ln2632">            /*</a>
<a name="ln2633">            if ( (at[at_1].bUsed0DParity &amp; 2) || (at[at_2].bUsed0DParity &amp; 2) ) {</a>
<a name="ln2634">                for ( k = 0; k &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[at_1].sb_parity[k]; k ++ ) {</a>
<a name="ln2635">                    if ( at[at_1].sb_neigh[k] == i_next_at_1 ) {</a>
<a name="ln2636">                        if ( at[at_1].sb_parity[k] == AB_PARITY_UNKN &amp;&amp; !nUnknown ) {</a>
<a name="ln2637">                            all_unkn[num_stereo_bonds] = 1;</a>
<a name="ln2638">                        }</a>
<a name="ln2639">                        break;</a>
<a name="ln2640">                    }</a>
<a name="ln2641">                }</a>
<a name="ln2642">            }</a>
<a name="ln2643">            */</a>
<a name="ln2644">            num_stereo_bonds ++;</a>
<a name="ln2645">        }</a>
<a name="ln2646">    }</a>
<a name="ln2647">    if ( num_chains &gt; 1 ) {</a>
<a name="ln2648">        return 0; /*  cannot be more than 1 cumulene chain. */</a>
<a name="ln2649">    }</a>
<a name="ln2650">#if ( ONE_BAD_SB_NEIGHBOR == 1 )</a>
<a name="ln2651">    if ( num_wrong_bonds_1 &gt; 1 || (num_wrong_bonds_1 &amp;&amp; 2 &gt;= at[at_1].valence) ) {</a>
<a name="ln2652">        return 0; /* wrong bond type */</a>
<a name="ln2653">    }</a>
<a name="ln2654">#endif</a>
<a name="ln2655">    /*  accept only short chains for now */</a>
<a name="ln2656">    /*  chain_length=1: &gt;C=C=C&lt;      tetrahedral center, allene */</a>
<a name="ln2657">    /*  chain_length=2: &gt;C=C=C=C&lt;    stereogenic bond, cumulene */</a>
<a name="ln2658">    if ( chain_length &amp;&amp; (num_stereo_bonds != 1 || num_alt_1 || chain_length &gt; MAX_CUMULENE_LEN) ) {</a>
<a name="ln2659">        return 0;</a>
<a name="ln2660">    }</a>
<a name="ln2661"> </a>
<a name="ln2662">    /*  we need 1 double bond/chain XOR up to 3 arom. bonds */</a>
<a name="ln2663">    /*  to have a stereogenic bond */</a>
<a name="ln2664">    if ( (num_alt_1&gt;0) + (num_2s_1&gt;0) != 1 || !num_stereo_bonds /*|| num_2s_1 &gt; 1*/ )</a>
<a name="ln2665">        return 0;</a>
<a name="ln2666"> </a>
<a name="ln2667">    if ( num_2s_1 &gt; 1 ) {</a>
<a name="ln2668">#if ( N_V_STEREOBONDS == 1 )</a>
<a name="ln2669">        if ( 2 == num_2s_1 &amp;&amp;</a>
<a name="ln2670">             2 == type_N   &amp;&amp;</a>
<a name="ln2671">             1 == (num_2s_hetero[0] | num_2s_hetero[1]) &amp;&amp;</a>
<a name="ln2672">             3 == at[at_1].valence + at[at_1].num_H &amp;&amp;</a>
<a name="ln2673">             5 == at[at_1].chem_bonds_valence + at[at_1].num_H &amp;&amp;</a>
<a name="ln2674">             3 == get_endpoint_valence( at[at_1].el_number ) ) {</a>
<a name="ln2675">            ;</a>
<a name="ln2676">        } else {</a>
<a name="ln2677">            return 0;</a>
<a name="ln2678">        }</a>
<a name="ln2679">#else</a>
<a name="ln2680">        return 0;</a>
<a name="ln2681">#endif</a>
<a name="ln2682">    }</a>
<a name="ln2683"> </a>
<a name="ln2684">    /* ================== calculate parities ====================== */</a>
<a name="ln2685">   </a>
<a name="ln2686">    </a>
<a name="ln2687">    /*  find possibly stereo bonds and save them */</a>
<a name="ln2688">    num_stored_isotopic_stereo_bonds = 0;</a>
<a name="ln2689">    num_stored_stereo_bonds          = 0;</a>
<a name="ln2690">    for ( k = 0; k &lt; num_stereo_bonds; k ++ ) {</a>
<a name="ln2691">        </a>
<a name="ln2692">        int cur_parity, next_parity, abs_cur_parity, abs_next_parity, dot_prod_z;</a>
<a name="ln2693">        S_CHAR z_dir1[3], z_dir2[3]; /*  3D vectors for half stereo bond parity direction */</a>
<a name="ln2694">        int  chain_len_bits = MAKE_BITS_CUMULENE_LEN(chain_length);</a>
<a name="ln2695">        int  cur_parity_defined, next_parity_defined;</a>
<a name="ln2696">        int  cur_action, next_action, result_action;</a>
<a name="ln2697">        </a>
<a name="ln2698">        at_2 = all_at_2[k];</a>
<a name="ln2699">        i_next_at_1 = all_pos_1[k];</a>
<a name="ln2700"> </a>
<a name="ln2701">#if ( MIN_SB_RING_SIZE &gt; 0 )</a>
<a name="ln2702">        if( at[at_1].nRingSystem == at[at_2].nRingSystem ) {</a>
<a name="ln2703">            /*  check min. ring size only if both double bond/cumulene */</a>
<a name="ln2704">            /*  ending atoms belong to the same ring system */</a>
<a name="ln2705">            j = is_bond_in_Nmax_memb_ring( at, at_1, i_next_at_1, q, nAtomLevel, cSource, min_sb_ring_size );</a>
<a name="ln2706">            if ( j &gt; 0 ) {</a>
<a name="ln2707">                continue;</a>
<a name="ln2708">            } else</a>
<a name="ln2709">            if ( j &lt; 0 ) {</a>
<a name="ln2710">                return CT_STEREOBOND_ERROR;</a>
<a name="ln2711">            }</a>
<a name="ln2712">        }</a>
<a name="ln2713">#endif</a>
<a name="ln2714"> </a>
<a name="ln2715">        i_next_at_2 = all_pos_2[k];</a>
<a name="ln2716">        nUnknown    = all_unkn[k];</a>
<a name="ln2717">        memset(z_dir1, 0, sizeof(z_dir1));</a>
<a name="ln2718">        memset(z_dir2, 0, sizeof(z_dir2));</a>
<a name="ln2719">        </a>
<a name="ln2720">        /********************************************************************************</a>
<a name="ln2721">         * find atom parities (negative means parity due to H-isotopes only)</a>
<a name="ln2722">         * and half stereo bond parity directions z_dir1, z_dir2.</a>
<a name="ln2723">         *</a>
<a name="ln2724">         * Bond can have unknown or undefined parity or no parity because of:</a>
<a name="ln2725">         * 1. Geometry (poorly defined, cannot calculate, for example linear =C-F</a>
<a name="ln2726">         *    or =CHD with no geometry) -- Undefined parity</a>
<a name="ln2727">         *                                                              H</a>
<a name="ln2728">         * 2. Identical H atoms (no parity in principle, for example =C&lt;  )</a>
<a name="ln2729">         *    -- No parity                                              H</a>
<a name="ln2730">         *</a>
<a name="ln2731">         * 3. The user said double bond stereo is unknown</a>
<a name="ln2732">         *    or at least one of single bonds is in unknown direction</a>
<a name="ln2733">         *    -- Unknown parity</a>
<a name="ln2734">         *</a>
<a name="ln2735">         * These 3 cases (see above) are referred below as 1, 2, 3.</a>
<a name="ln2736">         * Each of the cases may be present or not (2 possibilities)</a>
<a name="ln2737">         * Total number of combination is 2*2*2=8</a>
<a name="ln2738">         *</a>
<a name="ln2739">         * Since a case when all 3 are not present is a well-defined parity,</a>
<a name="ln2740">         * we do not consider this case here. Then 2*2*2-1=7 cases are left.</a>
<a name="ln2741">         *</a>
<a name="ln2742">         * If several cases are present, list them below separated by &quot;+&quot;.</a>
<a name="ln2743">         * For example, 1+2 means (1) undefined geometry and (2) no parity</a>
<a name="ln2744">         * is possible because of identical H atoms.</a>
<a name="ln2745">         *</a>
<a name="ln2746">         * N) Decision table, Non-isotopic, 2*2*2-1=7 cases:</a>
<a name="ln2747">         * =================================================</a>
<a name="ln2748">         * none     : 2+any: 1+2(e.g.=CH2); 1+2+3; 2; 2+3  AB_PARITY_NONE=0</a>
<a name="ln2749">         * undefined: 1                                    AB_PARITY_UNDF</a>
<a name="ln2750">         * unknown  : 1+3; 3                               AB_PARITY_UNKN</a>
<a name="ln2751">         *</a>
<a name="ln2752">         * I) Decision table, Isotopic, 2*2*2-1=7 cases:</a>
<a name="ln2753">         * =============================================</a>
<a name="ln2754">         * none     : none</a>
<a name="ln2755">         * undefined: 1; 1+2; 1+2+3; 2; 2+3</a>
<a name="ln2756">         * unknown  : 1+3; 3</a>
<a name="ln2757">         *</a>
<a name="ln2758">         * Note: When defining identical atoms H atoms in case 2,</a>
<a name="ln2759">         *       Isotopic and Non-isotopic cases are different:</a>
<a name="ln2760">         *  N: do NOT take into account the isotopic composition of H atoms</a>
<a name="ln2761">         *  I: DO take into account the isotopic composition of H atoms</a>
<a name="ln2762">         *     (it is assumed that H isotopes are always different)</a>
<a name="ln2763">         *</a>
<a name="ln2764">         * half_stereo_bond_parity() returns:</a>
<a name="ln2765">         * ==================================</a>
<a name="ln2766">         * Note: half_stereo_bond_parity() is unaware of case 3.</a>
<a name="ln2767">         *</a>
<a name="ln2768">         * can't be a half of a stereo bond    AB_PARITY_NONE</a>
<a name="ln2769">         * 1, isotopic &amp; non-isotopic:         AB_PARITY_UNDF</a>
<a name="ln2770">         * 1, isotopic only                   -AB_PARITY_UNDF</a>
<a name="ln2771">         * 2, no parity: identical H isotopes  AB_PARITY_IISO</a>
<a name="ln2772">         * 3, 'Either' single bond(s)          AB_PARITY_UNKN ???</a>
<a name="ln2773">         * 3, 'Either' single bond(s), iso H  -AB_PARITY_UNKN ???</a>
<a name="ln2774">         * defined parity                      AB_PARITY_ODD,  AB_PARITY_EVEN</a>
<a name="ln2775">         * defined parity for isotopic only:  -AB_PARITY_ODD, -AB_PARITY_EVEN</a>
<a name="ln2776">         *</a>
<a name="ln2777">         * Resultant value for the stereo bond parity</a>
<a name="ln2778">         * ---+-------------------+-------+--------+----------------+</a>
<a name="ln2779">         * 3? | half_stereo_bond_ | N or I| case 1,| bond parity    |</a>
<a name="ln2780">         *    |  parity()=        |       | 2 or 3 |                |</a>
<a name="ln2781">         * ---+-------------------+-------+--------+----------------+</a>
<a name="ln2782">         *   ( AB_PARITY_ODD/EVEN) =&gt; N&amp;I: -       =&gt; AB_PARITY_CALC (=6, calc.later)</a>
<a name="ln2783">         * 3+( AB_PARITY_ODD/EVEN) =&gt; N&amp;I: 3       =&gt; AB_PARITY_UNKN (=3)</a>
<a name="ln2784">         *   (-AB_PARITY_ODD/EVEN) =&gt; N:   2       =&gt; AB_PARITY_NONE (=0)</a>
<a name="ln2785">         *   (-AB_PARITY_ODD/EVEN) =&gt; I:   -       =&gt; AB_PARITY_CALC</a>
<a name="ln2786">         * 3+(-AB_PARITY_ODD/EVEN) =&gt; N:   2+3     =&gt; AB_PARITY_UNDF (=4)</a>
<a name="ln2787">         * 3+(-AB_PARITY_ODD/EVEN) =&gt; I:   3       =&gt; AB_PARITY_UNKN</a>
<a name="ln2788">         *   ( AB_PARITY_IISO )    =&gt; N:   1+2, 2  =&gt; AB_PARITY_NONE (=0)</a>
<a name="ln2789">         *   ( AB_PARITY_IISO )    =&gt; I:   1+2, 2  =&gt; AB_PARITY_UNDF</a>
<a name="ln2790">         * 3+( AB_PARITY_IISO )    =&gt; N:  1+2+3,2+3=&gt; AB_PARITY_NONE</a>
<a name="ln2791">         * 3+( AB_PARITY_IISO )    =&gt; I:  1+2+3,2+3=&gt; AB_PARITY_UNDF</a>
<a name="ln2792">         *   ( AB_PARITY_UNDF )    =&gt; N&amp;I: 1       =&gt; AB_PARITY_UNDF</a>
<a name="ln2793">         * 3+( AB_PARITY_UNDF )    =&gt; N&amp;I: 1+3     =&gt; AB_PARITY_UNKN</a>
<a name="ln2794">         *   (-AB_PARITY_UNDF )    =&gt; N:   1+2     =&gt; AB_PARITY_NONE</a>
<a name="ln2795">         *   (-AB_PARITY_UNDF )    =&gt; I:   1       =&gt; AB_PARITY_UNDF</a>
<a name="ln2796">         * 3+(-AB_PARITY_UNDF )    =&gt; N:   1+2+3   =&gt; AB_PARITY_NONE</a>
<a name="ln2797">         * 3+(-AB_PARITY_UNDF )    =&gt; I:   1+3     =&gt; AB_PARITY_UNKN</a>
<a name="ln2798">         * ---+-------------------+-------+--------+----------------+</a>
<a name="ln2799">        </a>
<a name="ln2800">         * If bond parity is undefined because abs(dot_prod_z) &lt; MIN_DOT_PROD</a>
<a name="ln2801">         * then replace: AB_PARITY_CALC </a>
<a name="ln2802">         *         with: AB_PARITY_UNDF</a>
<a name="ln2803">         * Joining two half_bond_parity() results:</a>
<a name="ln2804">         * </a>
<a name="ln2805">         *</a>
<a name="ln2806">         * atom1 \ atom2   | AB_PARITY_NONE  AB_PARITY_UNKN  AB_PARITY_UNDF  AB_PARITY_CALC</a>
<a name="ln2807">         * ----------------+---------------------------------------------------------------</a>
<a name="ln2808">         *0=AB_PARITY_NONE | AB_PARITY_NONE  AB_PARITY_NONE  AB_PARITY_NONE  AB_PARITY_NONE</a>
<a name="ln2809">         *3=AB_PARITY_UNKN |                 AB_PARITY_UNKN  AB_PARITY_UNKN  AB_PARITY_UNKN</a>
<a name="ln2810">         *4=AB_PARITY_UNDF |                                 AB_PARITY_UNDF  AB_PARITY_UNDF</a>
<a name="ln2811">         *6=AB_PARITY_CALC |                                                 AB_PARITY_CALC</a>
<a name="ln2812">         *</a>
<a name="ln2813">         * that is, take min out of the two</a>
<a name="ln2814">         *********************************************************************************/</a>
<a name="ln2815"> </a>
<a name="ln2816">        cur_parity  =  half_stereo_bond_parity( at, at_1, at_removed_H, num_removed_H, </a>
<a name="ln2817">                                                z_dir1, bPointedEdgeStereo, vABParityUnknown );</a>
<a name="ln2818">        next_parity =  half_stereo_bond_parity( at, at_2, at_removed_H, num_removed_H, </a>
<a name="ln2819">                                                z_dir2, bPointedEdgeStereo, vABParityUnknown );</a>
<a name="ln2820"> </a>
<a name="ln2821">        if ( RETURNED_ERROR(cur_parity) || RETURNED_ERROR(next_parity) ) {</a>
<a name="ln2822">            return CT_CALC_STEREO_ERR;</a>
<a name="ln2823">        }</a>
<a name="ln2824">        if ( (at[at_1].bUsed0DParity &amp; FlagSB_0D) || (at[at_2].bUsed0DParity &amp; FlagSB_0D) ) {</a>
<a name="ln2825">            FixSb0DParities( at, /* at_removed_H, num_removed_H,*/ chain_length,</a>
<a name="ln2826">                             at_1, i_next_at_1, z_dir1,</a>
<a name="ln2827">                             at_2, i_next_at_2, z_dir2, &amp;cur_parity, &amp;next_parity );</a>
<a name="ln2828">        }</a>
<a name="ln2829"> </a>
<a name="ln2830">        if ( cur_parity == AB_PARITY_NONE || abs(cur_parity) == AB_PARITY_IISO ) {</a>
<a name="ln2831">            continue;</a>
<a name="ln2832">        }</a>
<a name="ln2833">        if ( next_parity == AB_PARITY_NONE || abs(next_parity) == AB_PARITY_IISO ) {</a>
<a name="ln2834">            continue;</a>
<a name="ln2835">        }</a>
<a name="ln2836">            </a>
<a name="ln2837">        cur_action    = half_stereo_bond_action( cur_parity, nUnknown, 0, vABParityUnknown ); /*  -1 =&gt; program error */</a>
<a name="ln2838">        next_action   = half_stereo_bond_action( next_parity, nUnknown, 0, vABParityUnknown );</a>
<a name="ln2839">        result_action = inchi_min(cur_action, next_action);</a>
<a name="ln2840"> </a>
<a name="ln2841">        if ( result_action == -1 ) {</a>
<a name="ln2842">            stop = 1; /*  program error &lt;BRKPT&gt; */</a>
<a name="ln2843">        }</a>
<a name="ln2844"> </a>
<a name="ln2845">        abs_cur_parity   = abs( cur_parity );</a>
<a name="ln2846">        abs_next_parity  = abs( next_parity );</a>
<a name="ln2847">        cur_parity_defined  = ATOM_PARITY_WELL_DEF(abs_cur_parity);</a>
<a name="ln2848">        next_parity_defined = ATOM_PARITY_WELL_DEF(abs_next_parity);</a>
<a name="ln2849">        </a>
<a name="ln2850">        </a>
<a name="ln2851">        if ( cur_parity_defined &amp;&amp; next_parity_defined ) {</a>
<a name="ln2852">            /*  find how the whole bond parity depend on geometry */</a>
<a name="ln2853">            /*  if dot_prod_z &lt; 0 then bond_parity := 3-bond_parity */</a>
<a name="ln2854">            /*  can be done only for a well-defined geometry */</a>
<a name="ln2855">            /*</a>
<a name="ln2856">            dot_prod_z  = (chain_len_bits &amp; BIT_CUMULENE_CHI)? </a>
<a name="ln2857">                           triple_prod_char( at, at_1, i_next_at_1, z_dir1, at_2, i_next_at_2, z_dir2 ) :</a>
<a name="ln2858">                           dot_prodchar3(z_dir1, z_dir2);</a>
<a name="ln2859">            */</a>
<a name="ln2860">            dot_prod_z  = (chain_len_bits &amp;&amp; BOND_CHAIN_LEN(chain_len_bits)%2)? </a>
<a name="ln2861">                           triple_prod_char( at, at_1, i_next_at_1, z_dir1, at_2, i_next_at_2, z_dir2 ) :</a>
<a name="ln2862">                           dot_prodchar3(z_dir1, z_dir2);</a>
<a name="ln2863">    </a>
<a name="ln2864">            if ( abs(dot_prod_z) &lt; MIN_DOT_PROD ) {</a>
<a name="ln2865">                /*  The geometry is not well-defined. Eliminate AB_PARITY_CALC */</a>
<a name="ln2866">                result_action = inchi_min( result_action, AB_PARITY_UNDF );</a>
<a name="ln2867">            }</a>
<a name="ln2868">        } else {</a>
<a name="ln2869">            dot_prod_z = 0;</a>
<a name="ln2870">        }</a>
<a name="ln2871"> </a>
<a name="ln2872">        if ( result_action != AB_PARITY_NONE &amp;&amp; result_action != -1 ) {</a>
<a name="ln2873">            /*  stereo, no isotopes (only positive) */</a>
<a name="ln2874">            if ( cur_parity &gt; 0 &amp;&amp; next_parity &gt; 0 ) {</a>
<a name="ln2875">                if ( save_a_stereo_bond( dot_prod_z, result_action | chain_len_bits,</a>
<a name="ln2876">                                     at_1, i_next_at_1, out_at[at_1].stereo_bond_neighbor,</a>
<a name="ln2877">                                     out_at[at_1].stereo_bond_ord, out_at[at_1].stereo_bond_z_prod,</a>
<a name="ln2878">                                     out_at[at_1].stereo_bond_parity,</a>
<a name="ln2879">                                     at_2, i_next_at_2, out_at[at_2].stereo_bond_neighbor,</a>
<a name="ln2880">                                     out_at[at_2].stereo_bond_ord, out_at[at_2].stereo_bond_z_prod,</a>
<a name="ln2881">                                     out_at[at_2].stereo_bond_parity) ) {</a>
<a name="ln2882">                    if ( !out_at[at_1].parity ||</a>
<a name="ln2883">                         (cur_parity_defined &amp;&amp; !ATOM_PARITY_WELL_DEF(abs(out_at[at_1].parity))) ) {</a>
<a name="ln2884">                        out_at[at_1].parity = cur_parity;</a>
<a name="ln2885">                        memcpy( out_at[at_1].z_dir, z_dir1, sizeof(out_at[0].z_dir) );</a>
<a name="ln2886">                    }</a>
<a name="ln2887">                    if ( !out_at[at_2].parity ||</a>
<a name="ln2888">                         (next_parity_defined &amp;&amp; !ATOM_PARITY_WELL_DEF(abs(out_at[at_2].parity))) ) {</a>
<a name="ln2889">                        out_at[at_2].parity = next_parity;</a>
<a name="ln2890">                        memcpy( out_at[at_2].z_dir, z_dir2, sizeof(out_at[0].z_dir) );</a>
<a name="ln2891">                    }</a>
<a name="ln2892">                    out_at[at_1].bAmbiguousStereo |= at[at_1].bAmbiguousStereo;</a>
<a name="ln2893">                    out_at[at_2].bAmbiguousStereo |= at[at_2].bAmbiguousStereo;</a>
<a name="ln2894">                    num_stored_stereo_bonds ++;</a>
<a name="ln2895">                }</a>
<a name="ln2896">            }</a>
<a name="ln2897">        }</a>
<a name="ln2898">        </a>
<a name="ln2899">        /*  stereo + isotopic (all non-zero) */</a>
<a name="ln2900">        cur_action    = half_stereo_bond_action( cur_parity, nUnknown, 1, vABParityUnknown ); /*  -1 =&gt; program error */</a>
<a name="ln2901">        next_action   = half_stereo_bond_action( next_parity, nUnknown, 1, vABParityUnknown );</a>
<a name="ln2902">        result_action = inchi_min(cur_action, next_action);</a>
<a name="ln2903">        cur_parity  = abs_cur_parity;</a>
<a name="ln2904">        next_parity = abs_next_parity;</a>
<a name="ln2905">        if ( result_action != AB_PARITY_NONE &amp;&amp; result_action != -1 ) {</a>
<a name="ln2906">            /*  stero, isotopic */</a>
<a name="ln2907">            if ( cur_parity &gt; 0 &amp;&amp; next_parity &gt; 0 ) {</a>
<a name="ln2908">                if( save_a_stereo_bond( dot_prod_z, result_action | chain_len_bits,</a>
<a name="ln2909">                                     at_1, i_next_at_1, out_at[at_1].stereo_bond_neighbor2,</a>
<a name="ln2910">                                     out_at[at_1].stereo_bond_ord2, out_at[at_1].stereo_bond_z_prod2,</a>
<a name="ln2911">                                     out_at[at_1].stereo_bond_parity2,</a>
<a name="ln2912">                                     at_2, i_next_at_2, out_at[at_2].stereo_bond_neighbor2,</a>
<a name="ln2913">                                     out_at[at_2].stereo_bond_ord2, out_at[at_2].stereo_bond_z_prod2,</a>
<a name="ln2914">                                     out_at[at_2].stereo_bond_parity2) ) {</a>
<a name="ln2915">                    if ( !out_at[at_1].parity2 ||</a>
<a name="ln2916">                         (cur_parity_defined &amp;&amp; !ATOM_PARITY_WELL_DEF(abs(out_at[at_1].parity2))) ) {</a>
<a name="ln2917">                        out_at[at_1].parity2 = cur_parity /*| chain_len_bits*/;</a>
<a name="ln2918">                        if ( !out_at[at_1].parity ) {</a>
<a name="ln2919">                            memcpy( out_at[at_1].z_dir, z_dir1, sizeof(out_at[0].z_dir) );</a>
<a name="ln2920">                        }</a>
<a name="ln2921">                    }</a>
<a name="ln2922">                    if ( !out_at[at_2].parity2 || /* next line changed from abs(out_at[at_2].parity) 2006-03-05 */</a>
<a name="ln2923">                         (next_parity_defined &amp;&amp; !ATOM_PARITY_WELL_DEF(abs(out_at[at_2].parity2))) ) {</a>
<a name="ln2924">                        out_at[at_2].parity2 = next_parity /*| chain_len_bits*/;</a>
<a name="ln2925">                        if ( !out_at[at_2].parity ) {</a>
<a name="ln2926">                            memcpy( out_at[at_2].z_dir, z_dir2, sizeof(out_at[0].z_dir) );</a>
<a name="ln2927">                        }</a>
<a name="ln2928">                    }</a>
<a name="ln2929">                    out_at[at_1].bAmbiguousStereo |= at[at_1].bAmbiguousStereo;</a>
<a name="ln2930">                    out_at[at_2].bAmbiguousStereo |= at[at_2].bAmbiguousStereo;</a>
<a name="ln2931">                    num_stored_isotopic_stereo_bonds ++;</a>
<a name="ln2932">                }</a>
<a name="ln2933">            }</a>
<a name="ln2934">        } else</a>
<a name="ln2935">        if ( result_action == -1 ) {</a>
<a name="ln2936">            stop = 1; /*  program error? &lt;BRKPT&gt; */</a>
<a name="ln2937">        }</a>
<a name="ln2938"> </a>
<a name="ln2939">    }</a>
<a name="ln2940">    if ( stop ) {</a>
<a name="ln2941">        return CT_CALC_STEREO_ERR;</a>
<a name="ln2942">    }</a>
<a name="ln2943">    return /*num_stored_stereo_bonds+*/ num_stored_isotopic_stereo_bonds;</a>
<a name="ln2944">}</a>
<a name="ln2945"> </a>
<a name="ln2946"> </a>
<a name="ln2947">/*********************************************************************/</a>
<a name="ln2948">/*  if isotopic H, D, T added, can the atom be a stereo center? */</a>
<a name="ln2949">#if ( NEW_STEREOCENTER_CHECK == 1 )</a>
<a name="ln2950">/* int bCanInpAtomBeAStereoCenter( inp_ATOM *at, int cur_at ) */</a>
<a name="ln2951">int can_be_a_stereo_atom_with_isotopic_H( inp_ATOM *at, int cur_at, int bPointedEdgeStereo )</a>
<a name="ln2952">{</a>
<a name="ln2953">    int nNumNeigh;</a>
<a name="ln2954">    if ( (nNumNeigh = bCanInpAtomBeAStereoCenter( at, cur_at, bPointedEdgeStereo )) &amp;&amp;</a>
<a name="ln2955">         at[cur_at].valence + at[cur_at].num_H == nNumNeigh &amp;&amp;</a>
<a name="ln2956">         at[cur_at].num_H &lt;= NUM_H_ISOTOPES</a>
<a name="ln2957">       ) {</a>
<a name="ln2958">        return 1;</a>
<a name="ln2959">    }</a>
<a name="ln2960">    return 0;</a>
<a name="ln2961">}</a>
<a name="ln2962">#else</a>
<a name="ln2963">int can_be_a_stereo_atom_with_isotopic_H( inp_ATOM *at, int cur_at )</a>
<a name="ln2964">{</a>
<a name="ln2965">    int j, ret = 0;</a>
<a name="ln2966">    if ( bCanAtomBeAStereoCenter( at[cur_at].elname, at[cur_at].charge, at[cur_at].radical ) &amp;&amp;</a>
<a name="ln2967">         at[cur_at].valence + at[cur_at].num_H == MAX_NUM_STEREO_ATOM_NEIGH &amp;&amp;</a>
<a name="ln2968">         at[cur_at].num_H &lt; MAX_NUM_STEREO_ATOM_NEIGH</a>
<a name="ln2969">       ) {</a>
<a name="ln2970">        </a>
<a name="ln2971">        for ( j = 0, ret=1; ret &amp;&amp; j &lt; at[cur_at].valence; j ++ ) {</a>
<a name="ln2972">            if ( (at[cur_at].bond_type[j] &amp; ~BOND_MARK_ALL) != BOND_SINGLE ) {</a>
<a name="ln2973">                ret = 0;</a>
<a name="ln2974">            }</a>
<a name="ln2975">        }</a>
<a name="ln2976">    }</a>
<a name="ln2977">    return ret;</a>
<a name="ln2978">}</a>
<a name="ln2979">#endif</a>
<a name="ln2980">/***************************************************************/</a>
<a name="ln2981">int GetStereocenter0DParity( inp_ATOM *at, int cur_at, int j1, AT_NUMB nSbNeighOrigAtNumb[], int nFlag )</a>
<a name="ln2982">{</a>
<a name="ln2983">    int parity = AB_PARITY_NONE;</a>
<a name="ln2984">    if ( at[cur_at].p_parity &amp;&amp; (j1 == MAX_NUM_STEREO_ATOM_NEIGH-1 || j1 == MAX_NUM_STEREO_ATOM_NEIGH) ) {</a>
<a name="ln2985">        int i, num_trans_inp, num_trans_neigh;</a>
<a name="ln2986">        AT_NUMB nInpNeighOrigAtNumb[MAX_NUM_STEREO_ATOM_NEIGH];</a>
<a name="ln2987">        for ( i = 0; i &lt; MAX_NUM_STEREO_ATOM_NEIGH; i ++ ) {</a>
<a name="ln2988">            nInpNeighOrigAtNumb[i] = at[cur_at].p_orig_at_num[i];</a>
<a name="ln2989">            if ( nInpNeighOrigAtNumb[i] == at[cur_at].orig_at_number ) {</a>
<a name="ln2990">                nInpNeighOrigAtNumb[i] = 0; /* lone pair or explicit H */</a>
<a name="ln2991">            }</a>
<a name="ln2992">        }</a>
<a name="ln2993">        num_trans_inp   = insertions_sort( nInpNeighOrigAtNumb, MAX_NUM_STEREO_ATOM_NEIGH, sizeof(nInpNeighOrigAtNumb[0]), comp_AT_NUMB );</a>
<a name="ln2994">        num_trans_neigh = insertions_sort( nSbNeighOrigAtNumb, j1, sizeof(nSbNeighOrigAtNumb[0]), comp_AT_NUMB );</a>
<a name="ln2995">        if ( j1 == MAX_NUM_STEREO_ATOM_NEIGH-1 ) {</a>
<a name="ln2996">            ; /*num_trans_neigh += j1;*/ /* the lone pair or implicit H is implicitly at the top of the list */</a>
<a name="ln2997">        }</a>
<a name="ln2998">        if ( !memcmp( nInpNeighOrigAtNumb + MAX_NUM_STEREO_ATOM_NEIGH-j1, nSbNeighOrigAtNumb, j1*sizeof(AT_NUMB) ) ) {</a>
<a name="ln2999">            if ( ATOM_PARITY_WELL_DEF(at[cur_at].p_parity) ) {</a>
<a name="ln3000">                parity = 2 - (num_trans_inp + num_trans_neigh + at[cur_at].p_parity) % 2;</a>
<a name="ln3001">            } else {</a>
<a name="ln3002">                parity = at[cur_at].p_parity;</a>
<a name="ln3003">            }</a>
<a name="ln3004">            at[cur_at].bUsed0DParity |= nFlag; /* 0D parity used for streocenter parity */</a>
<a name="ln3005">        }</a>
<a name="ln3006">    }</a>
<a name="ln3007">    return parity;</a>
<a name="ln3008">}</a>
<a name="ln3009"> </a>
<a name="ln3010">/***************************************************************</a>
<a name="ln3011"> * Get stereo atom parity for the current order of attachments</a>
<a name="ln3012"> * The result in at[cur_at].parity is valid for previously removed</a>
<a name="ln3013"> * explicit hydrogen atoms, including isotopic ones, that are located in at_removed_H[]</a>
<a name="ln3014"> * The return value is a calculated parity.</a>
<a name="ln3015"> */</a>
<a name="ln3016">#define ADD_EXPLICIT_HYDROGEN_NEIGH  1</a>
<a name="ln3017">#define ADD_EXPLICIT_LONE_PAIR_NEIGH 2</a>
<a name="ln3018">int set_stereo_atom_parity( sp_ATOM *out_at, inp_ATOM *at, int cur_at, inp_ATOM *at_removed_H,</a>
<a name="ln3019">                            int num_removed_H, int bPointedEdgeStereo, int vABParityUnknown)</a>
<a name="ln3020">{</a>
<a name="ln3021">    int    j, k, next_at, num_z, j1, nType, num_explicit_H, tot_num_iso_H, nMustHaveNumNeigh;</a>
<a name="ln3022">    int    num_explicit_iso_H[NUM_H_ISOTOPES+1]; /*  numbers of removed hydrogen atoms */</a>
<a name="ln3023">    int    index_H[MAX_NUM_STEREO_ATOM_NEIGH]; /*  cannot have more than 4 elements: 1 H, 1 D, 1 T atom(s) */</a>
<a name="ln3024">    double z, sum_xyz[3], min_sine, triple_product;</a>
<a name="ln3025">    double at_coord[MAX_NUM_STEREO_ATOM_NEIGH][3];</a>
<a name="ln3026">    double bond_len_xy[4], rmax=0.0, rmin=0.0;</a>
<a name="ln3027">    double at_coord_center[3];</a>
<a name="ln3028">    int    parity, bAmbiguous = 0, bAddExplicitNeighbor = 0, b2D = 0, n2DTetrahedralAmbiguity = 0;</a>
<a name="ln3029">    int    bIgnoreIsotopicH = (0 != (at[cur_at].cFlags &amp; AT_FLAG_ISO_H_POINT));</a>
<a name="ln3030">    AT_NUMB nSbNeighOrigAtNumb[MAX_NUM_STEREO_ATOM_NEIGH];</a>
<a name="ln3031">    </a>
<a name="ln3032">    out_at[cur_at].parity  =</a>
<a name="ln3033">    out_at[cur_at].parity2 =</a>
<a name="ln3034">    out_at[cur_at].stereo_atom_parity  =</a>
<a name="ln3035">    out_at[cur_at].stereo_atom_parity2 = AB_PARITY_NONE;</a>
<a name="ln3036">    parity                             = AB_PARITY_NONE;</a>
<a name="ln3037"> </a>
<a name="ln3038">    memset(num_explicit_iso_H, 0, sizeof(num_explicit_iso_H));</a>
<a name="ln3039">    num_explicit_H = 0;</a>
<a name="ln3040"> </a>
<a name="ln3041">#if ( NEW_STEREOCENTER_CHECK == 1 )</a>
<a name="ln3042">    if ( !(nMustHaveNumNeigh = bCanInpAtomBeAStereoCenter( at, cur_at, bPointedEdgeStereo ) ) ||</a>
<a name="ln3043">         at[cur_at].num_H &gt; NUM_H_ISOTOPES</a>
<a name="ln3044">       ) {</a>
<a name="ln3045">        goto exit_function;</a>
<a name="ln3046">    }</a>
<a name="ln3047">#else</a>
<a name="ln3048">    nMustHaveNumNeigh = MAX_NUM_STEREO_ATOM_NEIGH;</a>
<a name="ln3049">    if ( !bCanAtomBeAStereoCenter( at[cur_at].elname, at[cur_at].charge, at[cur_at].radical ) ||</a>
<a name="ln3050">         at[cur_at].valence + at[cur_at].num_H != nMustHaveNumNeigh ||</a>
<a name="ln3051">         at[cur_at].num_H &gt; NUM_H_ISOTOPES</a>
<a name="ln3052">       ) {</a>
<a name="ln3053">        goto exit_function;</a>
<a name="ln3054">    }</a>
<a name="ln3055">    for ( j = 0; j &lt; at[cur_at].valence; j ++ ) {</a>
<a name="ln3056">        if ( (at[cur_at].bond_type[j] &amp; ~BOND_MARK_ALL) != BOND_SINGLE ) {</a>
<a name="ln3057">            goto exit_function;</a>
<a name="ln3058">        }</a>
<a name="ln3059">    }</a>
<a name="ln3060">#endif</a>
<a name="ln3061"> </a>
<a name="ln3062">    /*  numbers of isotopic H atoms */</a>
<a name="ln3063">    for ( j = 0, tot_num_iso_H = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln3064">        if ( at[cur_at].num_iso_H[j] &gt; 1 ) {</a>
<a name="ln3065">            goto exit_function; /*  two or more identical hydrogen isotopic neighbors */</a>
<a name="ln3066">        }</a>
<a name="ln3067">        tot_num_iso_H += at[cur_at].num_iso_H[j];</a>
<a name="ln3068">    }</a>
<a name="ln3069">    if ( bIgnoreIsotopicH ) {</a>
<a name="ln3070">        tot_num_iso_H = 0; /* isotopic H considered subject to exchange =&gt; ignore isotopic */</a>
<a name="ln3071">    }</a>
<a name="ln3072">    /*  number of non-isotopic H atoms */</a>
<a name="ln3073">    if ( at[cur_at].num_H - tot_num_iso_H &gt; 1 ) {</a>
<a name="ln3074">        goto exit_function; /*  two or more identical hydrogen non-isotopic neighbors */</a>
<a name="ln3075">    }</a>
<a name="ln3076">    </a>
<a name="ln3077">    /*  count removed explicit terminal hydrogens attached to at[cur_at]. */</a>
<a name="ln3078">    /*  the result is num_explicit_H. */</a>
<a name="ln3079">    /*  Removed hydrogens are sorted in increasing isotopic shift order */</a>
<a name="ln3080">    if ( at_removed_H &amp;&amp; num_removed_H &gt; 0 ) {</a>
<a name="ln3081">        for ( j = 0; j &lt; num_removed_H; j ++ ) {</a>
<a name="ln3082">            if ( at_removed_H[j].neighbor[0] == cur_at ) {</a>
<a name="ln3083">                k = at_removed_H[j].iso_atw_diff;</a>
<a name="ln3084">                /*  iso_atw_diff values: H=&gt;0, 1H=&gt;1, D=2H=&gt;2, T=3H=&gt;3 */</a>
<a name="ln3085">                if ( k &lt; 0 || k &gt; NUM_H_ISOTOPES || bIgnoreIsotopicH )</a>
<a name="ln3086">                    k = 0; /*  treat wrong H isotopes as non-isotopic H */</a>
<a name="ln3087">                num_explicit_iso_H[k] ++;</a>
<a name="ln3088">                index_H[num_explicit_H++] = j;</a>
<a name="ln3089">            }</a>
<a name="ln3090">        }</a>
<a name="ln3091">    }</a>
<a name="ln3092"> </a>
<a name="ln3093">    /*  coordinates initialization */</a>
<a name="ln3094">    num_z = 0;</a>
<a name="ln3095">    sum_xyz[0] = sum_xyz[1] = sum_xyz[2] = 0.0;</a>
<a name="ln3096"> </a>
<a name="ln3097">    at_coord_center[0] =</a>
<a name="ln3098">    at_coord_center[1] =</a>
<a name="ln3099">    at_coord_center[2] = 0.0;</a>
<a name="ln3100"> </a>
<a name="ln3101">    /*  fill out stereo center neighbors coordinates */</a>
<a name="ln3102">    /*  and obtain the parity from the geometry */</a>
<a name="ln3103"> </a>
<a name="ln3104">    for ( k = 0, j1 = 0; k &lt; 2; k ++ ) {</a>
<a name="ln3105">        switch( k ) {</a>
<a name="ln3106"> </a>
<a name="ln3107">        case 0:</a>
<a name="ln3108">            /*   add coordinates of removed hydrogens */</a>
<a name="ln3109">            for ( j = 0; j &lt; num_explicit_H; j ++, j1 ++ ) {</a>
<a name="ln3110">                next_at = index_H[j];</a>
<a name="ln3111">                /*  use bond description located at removed_H atom */</a>
<a name="ln3112">                /*  minus sign at get_z_coord: at_removed_H[] contains bonds TO at[cur_at], not FROM it. */</a>
<a name="ln3113">                /*  Note: &amp;at[(at_removed_H-at)+ next_at] == &amp;at_removed_H[next_at] */</a>
<a name="ln3114">                z = -get_z_coord( at, (at_removed_H-at)+ next_at, 0 /*neighbor #*/, &amp;nType, -(bPointedEdgeStereo &amp; PES_BIT_POINT_EDGE_STEREO) );</a>
<a name="ln3115">                switch ( nType ) {</a>
<a name="ln3116">                case ZTYPE_EITHER:</a>
<a name="ln3117">                    parity = vABParityUnknown /*AB_PARITY_UNKN*/ ; /*  no parity: bond in &quot;Either&quot; direction. */</a>
<a name="ln3118">                    goto exit_function;</a>
<a name="ln3119">                case ZTYPE_UP:</a>
<a name="ln3120">                case ZTYPE_DOWN:</a>
<a name="ln3121">                    nType = -nType; /*  at_removed_H[] contains bonds TO the center, not from */</a>
<a name="ln3122">                    b2D ++;</a>
<a name="ln3123">                    /*  no break; here */</a>
<a name="ln3124">                case ZTYPE_3D:</a>
<a name="ln3125">                    num_z ++;</a>
<a name="ln3126">                }</a>
<a name="ln3127"> </a>
<a name="ln3128">                nSbNeighOrigAtNumb[j1] = at_removed_H[next_at].orig_at_number;</a>
<a name="ln3129">                at_coord[j1][0] = at_removed_H[next_at].x-at[cur_at].x;</a>
<a name="ln3130">                at_coord[j1][1] = at_removed_H[next_at].y-at[cur_at].y;</a>
<a name="ln3131">                bond_len_xy[j1] = len2(at_coord[j1]);</a>
<a name="ln3132">                /* bond_len_xy[j1] = sqrt(at_coord[j1][0]*at_coord[j1][0]+at_coord[j1][1]*at_coord[j1][1]); */</a>
<a name="ln3133">                at_coord[j1][2] = (nType==ZTYPE_3D?    z :</a>
<a name="ln3134">                                   nType==ZTYPE_UP?    bond_len_xy[j1] :</a>
<a name="ln3135">                                   nType==ZTYPE_DOWN? -bond_len_xy[j1] : 0.0 );</a>
<a name="ln3136">            }</a>
<a name="ln3137">            break;</a>
<a name="ln3138">        case 1:</a>
<a name="ln3139">            /*  add all coordinates of other neighboring atoms */</a>
<a name="ln3140">            for ( j = 0; j &lt; at[cur_at].valence; j ++, j1 ++ ) {</a>
<a name="ln3141">                next_at = at[cur_at].neighbor[j];</a>
<a name="ln3142">                z = get_z_coord( at, cur_at, j, &amp;nType, (bPointedEdgeStereo &amp; PES_BIT_POINT_EDGE_STEREO) );</a>
<a name="ln3143">                switch ( nType ) {</a>
<a name="ln3144">                case ZTYPE_EITHER:</a>
<a name="ln3145">                    parity = vABParityUnknown /*AB_PARITY_UNKN*/; /*  unknown parity: bond in &quot;Either&quot; direction. */</a>
<a name="ln3146">                    goto exit_function;</a>
<a name="ln3147">                case ZTYPE_UP:</a>
<a name="ln3148">                case ZTYPE_DOWN:</a>
<a name="ln3149">                    b2D ++;</a>
<a name="ln3150">                case ZTYPE_3D:</a>
<a name="ln3151">                    num_z ++;</a>
<a name="ln3152">                }</a>
<a name="ln3153"> </a>
<a name="ln3154">                nSbNeighOrigAtNumb[j1] = at[next_at].orig_at_number;</a>
<a name="ln3155">                at_coord[j1][0] = at[next_at].x-at[cur_at].x;</a>
<a name="ln3156">                at_coord[j1][1] = at[next_at].y-at[cur_at].y;</a>
<a name="ln3157">                bond_len_xy[j1] = len2(at_coord[j1]);</a>
<a name="ln3158">                /* bond_len_xy[j1] = sqrt(at_coord[j1][0]*at_coord[j1][0]+at_coord[j1][1]*at_coord[j1][1]); */</a>
<a name="ln3159">                at_coord[j1][2] = (nType==ZTYPE_3D?    z :</a>
<a name="ln3160">                                   nType==ZTYPE_UP?    bond_len_xy[j1] :</a>
<a name="ln3161">                                   nType==ZTYPE_DOWN? -bond_len_xy[j1] : 0.0 );</a>
<a name="ln3162">            }</a>
<a name="ln3163">            break;</a>
<a name="ln3164">        }</a>
<a name="ln3165">    }</a>
<a name="ln3166">    /* j1 is the number of explicit neighbors (that is, all neighbors except implicit H) */</a>
<a name="ln3167"> </a>
<a name="ln3168">    b2D = (b2D == num_z &amp;&amp; num_z);  /*  1 =&gt; two-dimensional */</a>
<a name="ln3169"> </a>
<a name="ln3170">    if ( MAX_NUM_STEREO_ATOM_NEIGH   != at[cur_at].valence+num_explicit_H &amp;&amp;</a>
<a name="ln3171">         MAX_NUM_STEREO_ATOM_NEIGH-1 != at[cur_at].valence+num_explicit_H ) {</a>
<a name="ln3172">        /*  not enough geometry data to find the central atom parity */</a>
<a name="ln3173">        if ( nMustHaveNumNeigh == at[cur_at].valence+at[cur_at].num_H &amp;&amp;</a>
<a name="ln3174">             at[cur_at].num_H &gt; 1 ) {</a>
<a name="ln3175">            /*  only isotopic parity is possible; no non-isotopic parity */</a>
<a name="ln3176">            if ( parity == vABParityUnknown /*AB_PARITY_UNKN*/ ) {</a>
<a name="ln3177">                parity = -vABParityUnknown /*AB_PARITY_UNKN*/; /*  the user marked the center as &quot;unknown&quot; */</a>
<a name="ln3178">            } else {</a>
<a name="ln3179">                parity = -AB_PARITY_UNDF; /*  not enough geometry; only isotopic parity is possible */</a>
<a name="ln3180">            }</a>
<a name="ln3181">        } else {</a>
<a name="ln3182">            parity = AB_PARITY_NONE;      /*  not a stereocenter at all */</a>
<a name="ln3183">        }</a>
<a name="ln3184">        goto exit_function;</a>
<a name="ln3185">    }</a>
<a name="ln3186">    /*  make all vector lengths equal to 1; exit if too short. 9-10-2002 */</a>
<a name="ln3187">    for ( j = 0; j &lt; j1; j ++ ) {</a>
<a name="ln3188">        z = len3( at_coord[j] );</a>
<a name="ln3189">        if ( z &lt; MIN_BOND_LEN ) {</a>
<a name="ln3190">            /* bond length is too small: use 0D parities */</a>
<a name="ln3191">            if ( AB_PARITY_NONE == (parity = GetStereocenter0DParity( at, cur_at, j1, nSbNeighOrigAtNumb, FlagSC_0D )) ) {</a>
<a name="ln3192">                parity = AB_PARITY_UNDF;</a>
<a name="ln3193">            }</a>
<a name="ln3194">            goto exit_function;</a>
<a name="ln3195">        }</a>
<a name="ln3196">#if ( STEREO_CENTER_BONDS_NORM == 1 )</a>
<a name="ln3197">        else {</a>
<a name="ln3198">            mult3( at_coord[j], 1.0/z, at_coord[j] );</a>
<a name="ln3199">        }</a>
<a name="ln3200">#endif</a>
<a name="ln3201">        rmax = j? inchi_max( rmax, z) : z;</a>
<a name="ln3202">        rmin = j? inchi_min( rmin, z) : z;</a>
<a name="ln3203">    }</a>
<a name="ln3204">    if ( rmin / rmax &lt; MIN_SINE ) {</a>
<a name="ln3205">        /* bond ratio is too small: use 0D parities */</a>
<a name="ln3206">        if ( AB_PARITY_NONE == (parity = GetStereocenter0DParity( at, cur_at, j1, nSbNeighOrigAtNumb, FlagSC_0D )) ) {</a>
<a name="ln3207">            parity = AB_PARITY_UNDF;</a>
<a name="ln3208">        }</a>
<a name="ln3209">        goto exit_function;</a>
<a name="ln3210">    }</a>
<a name="ln3211">    for ( j = 0; j &lt; j1; j ++ ) {</a>
<a name="ln3212">        add3( sum_xyz, at_coord[j], sum_xyz );</a>
<a name="ln3213">    }</a>
<a name="ln3214"> </a>
<a name="ln3215"> </a>
<a name="ln3216"> </a>
<a name="ln3217">    /*  here j1 is a number of neighbors including explicit terminal isotopic H */</a>
<a name="ln3218">    /*  num_explicit_iso_H[0] = number of explicit non-isotopic hydrogen atom neighbors */</a>
<a name="ln3219">    j = j1;</a>
<a name="ln3220">    /*  Add Explicit Neighbor */</a>
<a name="ln3221">    if ( j1 == MAX_NUM_STEREO_ATOM_NEIGH-1 ) {</a>
<a name="ln3222">        /*  add an explicit neighbor if possible */</a>
<a name="ln3223">        if ( nMustHaveNumNeigh == MAX_NUM_STEREO_ATOM_NEIGH-1 ) {</a>
<a name="ln3224">            bAddExplicitNeighbor = ADD_EXPLICIT_LONE_PAIR_NEIGH;</a>
<a name="ln3225">        } else</a>
<a name="ln3226">        if ( nMustHaveNumNeigh == MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln3227">            /*  check whether an explicit non-isotopic hydrogen can be added */</a>
<a name="ln3228">            /*  to an atom that is a stereogenic atom */</a>
<a name="ln3229">            if ( 1 == at[cur_at].num_H - num_explicit_H &amp;&amp;     /*  the atom has only one one implicit hydrogen */</a>
<a name="ln3230">                 1 == at[cur_at].num_H - tot_num_iso_H ) {     /*  this hydrogen is non-isotopic */</a>
<a name="ln3231">                bAddExplicitNeighbor = ADD_EXPLICIT_HYDROGEN_NEIGH;</a>
<a name="ln3232">            }</a>
<a name="ln3233">        }</a>
<a name="ln3234">    }</a>
<a name="ln3235"> </a>
<a name="ln3236">    if ( bAddExplicitNeighbor ) {</a>
<a name="ln3237">        /***********************************************************</a>
<a name="ln3238">         * May happen only if (j1 == MAX_NUM_STEREO_ATOM_NEIGH-1)</a>
<a name="ln3239">         * 3 neighbors only, no H-neighbors. Create and add coordinates of an implicit H</a>
<a name="ln3240">         * or a fake 4th neighbor, that is, a lone pair </a>
<a name="ln3241">         */</a>
<a name="ln3242">        if ( parity == vABParityUnknown /*AB_PARITY_UNKN*/ ) {</a>
<a name="ln3243">            goto exit_function;  /*  the user insists the parity is unknown and the isotopic */</a>
<a name="ln3244">                                 /*  composition of the neighbors does not contradict */</a>
<a name="ln3245">        } else</a>
<a name="ln3246">        if ( num_z == 0 || are_3_vect_in_one_plane(at_coord, MIN_SINE) ) {</a>
<a name="ln3247">            /*  &quot;hydrogen down&quot; rule is needed to resolve an ambiguity */</a>
<a name="ln3248">            if ( num_z &gt; 0 ) {</a>
<a name="ln3249">                bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln3250">            }</a>
<a name="ln3251">#if ( APPLY_IMPLICIT_H_DOWN_RULE == 1 )  /* { */</a>
<a name="ln3252">            /*  Although H should be at the top of the list, add it to the bottom. */</a>
<a name="ln3253">            /*  This will be taken care of later by inverting parity 1&lt;-&gt;2 */</a>
<a name="ln3254">            at_coord[j][0] = 0.0;</a>
<a name="ln3255">            at_coord[j][1] = 0.0;</a>
<a name="ln3256">#if ( STEREO_CENTER_BONDS_NORM == 1 )</a>
<a name="ln3257">            at_coord[j][2] = -1.0;</a>
<a name="ln3258">#else</a>
<a name="ln3259">            at_coord[j][2] = -(bond_len_xy[0]+bond_len_xy[1]+bond_len_xy[2])/3.0;</a>
<a name="ln3260">#endif</a>
<a name="ln3261">#else /* } APPLY_IMPLICIT_H_DOWN_RULE { */</a>
<a name="ln3262">#if (ALWAYS_SET_STEREO_PARITY == 1)</a>
<a name="ln3263">            parity =  AB_PARITY_EVEN; /*  suppose atoms are pre-sorted (testing) */</a>
<a name="ln3264">#else</a>
<a name="ln3265">            /* all 3 bonds are in one plain: try to get 0D parities */</a>
<a name="ln3266">            if ( AB_PARITY_NONE == (parity = GetStereocenter0DParity( at, cur_at, j1, nSbNeighOrigAtNumb, FlagSC_0D )) ) {</a>
<a name="ln3267">                parity = AB_PARITY_UNDF;</a>
<a name="ln3268">            }</a>
<a name="ln3269">            /*parity =  AB_PARITY_UNDF;*/ /*  no parity can be calculated found */</a>
<a name="ln3270">#endif</a>
<a name="ln3271">            goto exit_function;</a>
<a name="ln3272">#endif /* } APPLY_IMPLICIT_H_DOWN_RULE */</a>
<a name="ln3273">        } else {</a>
<a name="ln3274">            /*  we have enough information to find implicit hydrogen coordinates */</a>
<a name="ln3275">            /*</a>
<a name="ln3276">            at_coord[j][0] = -sum_x;</a>
<a name="ln3277">            at_coord[j][1] = -sum_y;</a>
<a name="ln3278">            at_coord[j][2] = -sum_z;</a>
<a name="ln3279">            */</a>
<a name="ln3280">            copy3( sum_xyz, at_coord[j] );</a>
<a name="ln3281">            change_sign3( at_coord[j], at_coord[j] );</a>
<a name="ln3282">            z = len3( at_coord[j] );</a>
<a name="ln3283">#if ( FIX_STEREO_SCALING_BUG == 1 )</a>
<a name="ln3284">            if ( z &gt; 1.0 ) {</a>
<a name="ln3285">                rmax *= z;</a>
<a name="ln3286">            } else {</a>
<a name="ln3287">                rmin *= z;</a>
<a name="ln3288">            }</a>
<a name="ln3289">#else</a>
<a name="ln3290">            /* Comparing the original bond lengths to lenghts derived from normalized to 1 */</a>
<a name="ln3291">            /* This bug leads to pronouncing legitimate stereogenic atoms */</a>
<a name="ln3292">            /* connected by 3 bonds &quot;undefined&quot; if in a nicely drawn 2D structure */</a>
<a name="ln3293">            /* bond lengths are about 20 or greater. Reported by Reinhard Dunkel 2005-08-05 */</a>
<a name="ln3294">            if ( bPointedEdgeStereo &amp; PES_BIT_FIX_SP3_BUG ) {</a>
<a name="ln3295">                /* coordinate scaling bug fixed here */</a>
<a name="ln3296">                if ( z &gt; 1.0 ) {</a>
<a name="ln3297">                    rmax *= z;</a>
<a name="ln3298">                } else {</a>
<a name="ln3299">                    rmin *= z;</a>
<a name="ln3300">                }</a>
<a name="ln3301">            } else {</a>
<a name="ln3302">                /* original InChI v.1 bug */</a>
<a name="ln3303">                rmax = inchi_max( rmax, z );</a>
<a name="ln3304">                rmin = inchi_min( rmin, z );</a>
<a name="ln3305">            }</a>
<a name="ln3306">#endif</a>
<a name="ln3307">            if ( z &lt; MIN_BOND_LEN || rmin/rmax &lt; MIN_SINE ) {</a>
<a name="ln3308">                /* the new 4th bond is too short: try to get 0D parities */</a>
<a name="ln3309">                if ( AB_PARITY_NONE == (parity = GetStereocenter0DParity( at, cur_at, j1, nSbNeighOrigAtNumb, FlagSC_0D )) ) {</a>
<a name="ln3310">                    parity = AB_PARITY_UNDF;</a>
<a name="ln3311">                }</a>
<a name="ln3312">                goto exit_function;</a>
<a name="ln3313">            }</a>
<a name="ln3314">#if ( STEREO_CENTER_BOND4_NORM == 1 )</a>
<a name="ln3315">            else {</a>
<a name="ln3316">                mult3( at_coord[j], 1.0/z, at_coord[j] );</a>
<a name="ln3317">            }</a>
<a name="ln3318">#endif</a>
<a name="ln3319">        }</a>
<a name="ln3320">    } else</a>
<a name="ln3321">    if ( j1 != MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln3322">        if ( parity == vABParityUnknown /*AB_PARITY_UNKN*/ ) {</a>
<a name="ln3323">            parity = -AB_PARITY_UNDF; /*  isotopic composition of H-neighbors contradicts 'unknown' */</a>
<a name="ln3324">        }</a>
<a name="ln3325">        goto exit_function;</a>
<a name="ln3326">    } else /*  j1 == MAX_NUM_STEREO_ATOM_NEIGH */</a>
<a name="ln3327">    if ( num_z == 0 || are_4at_in_one_plane(at_coord, MIN_SINE) ) {</a>
<a name="ln3328">        /*  all four neighours in xy plane: undefined geometry. */</a>
<a name="ln3329">        if ( num_z &gt; 0 ) {</a>
<a name="ln3330">            bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln3331">        }</a>
<a name="ln3332">        if ( parity != vABParityUnknown /*AB_PARITY_UNKN*/ ) {</a>
<a name="ln3333">#if (ALWAYS_SET_STEREO_PARITY == 1)</a>
<a name="ln3334">            parity =  AB_PARITY_EVEN; /*  suppose atoms are pre-sorted (testing) */</a>
<a name="ln3335">#else</a>
<a name="ln3336">            /* all 4 bonds are in one plain: try to get 0D parities */</a>
<a name="ln3337">            if ( AB_PARITY_NONE == (parity = GetStereocenter0DParity( at, cur_at, j1, nSbNeighOrigAtNumb, FlagSC_0D )) ) {</a>
<a name="ln3338">                parity = AB_PARITY_UNDF;</a>
<a name="ln3339">            } else</a>
<a name="ln3340">            if ( ATOM_PARITY_WELL_DEF( parity ) ) {</a>
<a name="ln3341">                bAmbiguous &amp;= ~AMBIGUOUS_STEREO; /* 0D parity has resolved the ambiguity */</a>
<a name="ln3342">            }</a>
<a name="ln3343">#endif</a>
<a name="ln3344">        }</a>
<a name="ln3345">        goto exit_function;</a>
<a name="ln3346">    }</a>
<a name="ln3347">    /***********************************************************</a>
<a name="ln3348">     * At this point we have 4 neighboring atoms.</a>
<a name="ln3349">     * check for tetrahedral ambiguity in 2D case</a>
<a name="ln3350">     */</a>
<a name="ln3351">    if ( b2D ) </a>
<a name="ln3352">    {</a>
<a name="ln3353"> </a>
<a name="ln3354">        n2DTetrahedralAmbiguity = Get2DTetrahedralAmbiguity( at_coord, bAddExplicitNeighbor, (bPointedEdgeStereo &amp; PES_BIT_FIX_SP3_BUG ) );</a>
<a name="ln3355"> </a>
<a name="ln3356">        if ( 0 &lt; n2DTetrahedralAmbiguity ) </a>
<a name="ln3357">        {</a>
<a name="ln3358">            if ( T2D_WARN &amp; n2DTetrahedralAmbiguity ) {</a>
<a name="ln3359">                bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln3360">            }</a>
<a name="ln3361">            if ( T2D_UNDF &amp; n2DTetrahedralAmbiguity ) {</a>
<a name="ln3362">                if ( parity != vABParityUnknown /*AB_PARITY_UNKN*/ ) {</a>
<a name="ln3363">#if (ALWAYS_SET_STEREO_PARITY == 1)</a>
<a name="ln3364">                    parity =  AB_PARITY_EVEN; /*  suppose atoms are pre-sorted (testing) */</a>
<a name="ln3365">#else</a>
<a name="ln3366">                    parity =  AB_PARITY_UNDF; /*  no parity */</a>
<a name="ln3367">#endif</a>
<a name="ln3368">                }</a>
<a name="ln3369">                goto exit_function;</a>
<a name="ln3370">            }</a>
<a name="ln3371">        } else</a>
<a name="ln3372">        if ( n2DTetrahedralAmbiguity &lt; 0 ) {</a>
<a name="ln3373">            bAmbiguous |= AMBIGUOUS_STEREO_ERROR; /*  error */</a>
<a name="ln3374">            parity = AB_PARITY_UNDF;</a>
<a name="ln3375">            goto exit_function;</a>
<a name="ln3376">        }</a>
<a name="ln3377">    }</a>
<a name="ln3378"> </a>
<a name="ln3379">    /************************************************************/</a>
<a name="ln3380">    /*  Move coordinates origin to the neighbor #0 */</a>
<a name="ln3381">    for ( j = 1; j &lt; MAX_NUM_STEREO_ATOM_NEIGH; j ++ ) {</a>
<a name="ln3382">        diff3(at_coord[j], at_coord[0], at_coord[j]);</a>
<a name="ln3383">    }</a>
<a name="ln3384">    diff3(at_coord_center, at_coord[0], at_coord_center);</a>
<a name="ln3385"> </a>
<a name="ln3386">    /*</a>
<a name="ln3387">    for ( k = 0; k &lt; 3; k++ ) {</a>
<a name="ln3388">        for ( j = 1; j &lt; MAX_NUM_STEREO_ATOM_NEIGH; j ++ ) {</a>
<a name="ln3389">            at_coord[j][k] -= at_coord[0][k];</a>
<a name="ln3390">        }</a>
<a name="ln3391">        at_coord_center[k] -= at_coord[0][k];</a>
<a name="ln3392">    }</a>
<a name="ln3393">    */</a>
<a name="ln3394">    /********************************************************</a>
<a name="ln3395">     * find the central (cur_at) atom's parity</a>
<a name="ln3396">     * (orientation of atoms #1-3 when looking from #0)</a>
<a name="ln3397">     ********************************************************/</a>
<a name="ln3398">    triple_product = triple_prod_and_min_abs_sine2(&amp;at_coord[1], at_coord_center, bAddExplicitNeighbor, &amp;min_sine, &amp;bAmbiguous);</a>
<a name="ln3399">    /*</a>
<a name="ln3400">     * check for tetrahedral ambiguity -- leave it out for now</a>
<a name="ln3401">     */</a>
<a name="ln3402">    if ( fabs(triple_product) &gt; ZERO_FLOAT &amp;&amp; (min_sine &gt; MIN_SINE || (fabs(min_sine) &gt; ZERO_FLOAT &amp;&amp; (n2DTetrahedralAmbiguity &amp; T2D_OKAY )) ) ) {</a>
<a name="ln3403">         /* Even =&gt; sorted in correct order, Odd=&gt;transposed */</a>
<a name="ln3404">        parity = triple_product &gt; 0.0? AB_PARITY_EVEN : AB_PARITY_ODD;</a>
<a name="ln3405">        /* if ( num_explicit_H &amp;&amp; at[cur_at].removed_H_parity % 2 )  */</a>
<a name="ln3406">              /* odd transposition of the removed implicit H */</a>
<a name="ln3407">        /*     out_at[cur_at].parity = 3 - out_at[cur_at].parity; */</a>
<a name="ln3408">        </a>
<a name="ln3409">        /*  moved; see below */</a>
<a name="ln3410">        /* out_at[cur_at].bAmbiguousStereo |= bAmbiguous; */</a>
<a name="ln3411">        /* at[cur_at].bAmbiguousStereo |= bAmbiguous; */</a>
<a name="ln3412"> </a>
<a name="ln3413">        /*  for 4 attached atoms, moving the implicit H from index=3 to index=0 */</a>
<a name="ln3414">        /*  can be done in odd number (3) transpositions: (23)(12)(01), which inverts the parity */</a>
<a name="ln3415">        if ( j1 == MAX_NUM_STEREO_ATOM_NEIGH-1 ) {</a>
<a name="ln3416">            parity = 3 - parity;</a>
<a name="ln3417">        }</a>
<a name="ln3418">    } else {</a>
<a name="ln3419">#if (ALWAYS_SET_STEREO_PARITY == 1)</a>
<a name="ln3420">        parity =  AT_PARITY_EVEN; /*  suppose atoms are pre-sorted (testing) */</a>
<a name="ln3421">#else</a>
<a name="ln3422">        if ( num_z &gt; 0 ) {</a>
<a name="ln3423">            bAmbiguous |= AMBIGUOUS_STEREO;</a>
<a name="ln3424">        }</a>
<a name="ln3425">        parity =  AB_PARITY_UNDF; /*  no parity: 4 bonds are in one plane. */</a>
<a name="ln3426">#endif</a>
<a name="ln3427">    }</a>
<a name="ln3428">exit_function:</a>
<a name="ln3429"> </a>
<a name="ln3430">    if ( parity ) {</a>
<a name="ln3431">        out_at[cur_at].bAmbiguousStereo |= bAmbiguous;</a>
<a name="ln3432">        at[cur_at].bAmbiguousStereo |= bAmbiguous;</a>
<a name="ln3433">    }</a>
<a name="ln3434"> </a>
<a name="ln3435">    </a>
<a name="ln3436">    /*  non-isotopic parity */</a>
<a name="ln3437">    if ( at[cur_at].num_H &gt; 1 || parity &lt;= 0 )</a>
<a name="ln3438">        ; /*  no non-isotopic parity */</a>
<a name="ln3439">    else</a>
<a name="ln3440">        out_at[cur_at].parity = parity;</a>
<a name="ln3441"> </a>
<a name="ln3442">    /*  isotopic parity */</a>
<a name="ln3443">    if ( parity == -AB_PARITY_UNDF || parity == -vABParityUnknown /*AB_PARITY_UNKN*/ )</a>
<a name="ln3444">        parity = -parity;</a>
<a name="ln3445">    if ( parity &lt; 0 )</a>
<a name="ln3446">        parity = AB_PARITY_NONE;</a>
<a name="ln3447">    out_at[cur_at].parity2 = parity;</a>
<a name="ln3448"> </a>
<a name="ln3449"> </a>
<a name="ln3450">    parity = PARITY_VAL(out_at[cur_at].parity);</a>
<a name="ln3451">    out_at[cur_at].stereo_atom_parity = ATOM_PARITY_WELL_DEF( parity )? AB_PARITY_CALC : parity;</a>
<a name="ln3452">    parity = PARITY_VAL(out_at[cur_at].parity2);</a>
<a name="ln3453">    out_at[cur_at].stereo_atom_parity2 = ATOM_PARITY_WELL_DEF( parity )? AB_PARITY_CALC : parity;</a>
<a name="ln3454">    /*</a>
<a name="ln3455">    out_at[cur_at].parity2 = out_at[cur_at].parity; // save for stereo + isotopic canon.</a>
<a name="ln3456">    if ( out_at[cur_at].parity ) {</a>
<a name="ln3457">        if ( num_explicit_H &gt; 1 || j1 == MAX_NUM_STEREO_ATOM_NEIGH-1 &amp;&amp; num_explicit_H ) {</a>
<a name="ln3458">            //              X   H      X</a>
<a name="ln3459">            // for example,  &gt;C&lt;   or   &gt;C-D</a>
<a name="ln3460">            //              Y   D      Y</a>
<a name="ln3461">            // parity exists for stereo + isotopic atoms canonicalization only</a>
<a name="ln3462">            out_at[cur_at].parity  = 0;</a>
<a name="ln3463">        }</a>
<a name="ln3464">    }</a>
<a name="ln3465">    // returning 0 means this can be an adjacent to a stereogenic bond atom</a>
<a name="ln3466">    */</a>
<a name="ln3467">    </a>
<a name="ln3468">    return (int)out_at[cur_at].parity2;</a>
<a name="ln3469"> </a>
<a name="ln3470">}</a>
<a name="ln3471">#undef ADD_EXPLICIT_HYDROGEN_NEIGH</a>
<a name="ln3472">#undef ADD_EXPLICIT_LONE_PAIR_NEIGH</a>
<a name="ln3473"> </a>
<a name="ln3474">/*************************************************************/</a>
<a name="ln3475">int set_stereo_parity( inp_ATOM* at, sp_ATOM* at_output, int num_at, int num_removed_H,</a>
<a name="ln3476">                       int *nMaxNumStereoAtoms, int *nMaxNumStereoBonds, INCHI_MODE nMode,</a>
<a name="ln3477">                       int bPointedEdgeStereo, int vABParityUnknown )</a>
<a name="ln3478">{</a>
<a name="ln3479">    int num_3D_stereo_atoms=0;</a>
<a name="ln3480">    int num_stereo_bonds=0; /* added to fix allene stereo bug reported for FClC=C=CFCl by Burt Leland - 2009-02-05 DT */</a>
<a name="ln3481"> </a>
<a name="ln3482">    int i, is_stereo, num_stereo, max_stereo_atoms=0, max_stereo_bonds=0;</a>
<a name="ln3483">    QUEUE *q = NULL;</a>
<a name="ln3484">    AT_RANK *nAtomLevel = NULL;</a>
<a name="ln3485">    S_CHAR  *cSource    = NULL;</a>
<a name="ln3486">    AT_RANK min_sb_ring_size = 0;</a>
<a name="ln3487"> </a>
<a name="ln3488">    /**********************************************************</a>
<a name="ln3489">     *</a>
<a name="ln3490">     * Note: this parity reflects only relative positions of</a>
<a name="ln3491">     *       the atoms-neighbors and their ordering in the</a>
<a name="ln3492">     *       lists of neighbors.</a>
<a name="ln3493">     *</a>
<a name="ln3494">     *       To obtain the actual parity, the parity of a number </a>
<a name="ln3495">     *       of neighbors transpositions (to obtain a sorted</a>
<a name="ln3496">     *       list of numbers assigned to the atoms) should be</a>
<a name="ln3497">     *       added.</a>
<a name="ln3498">     *</a>
<a name="ln3499">     **********************************************************/</a>
<a name="ln3500"> </a>
<a name="ln3501">    /*********************************************************************************</a>
<a name="ln3502"> </a>
<a name="ln3503">     An example of parity=1 for stereogenic center, tetrahedral asymmetric atom</a>
<a name="ln3504">                   </a>
<a name="ln3505">                       </a>
<a name="ln3506">                    </a>
<a name="ln3507">                  (1)</a>
<a name="ln3508">                   |</a>
<a name="ln3509">                   |</a>
<a name="ln3510">               [C] |</a>
<a name="ln3511">                   |</a>
<a name="ln3512">         (2)------(0)</a>
<a name="ln3513">                  /</a>
<a name="ln3514">                /</a>
<a name="ln3515">              /</a>
<a name="ln3516">            /</a>
<a name="ln3517">         (3)</a>
<a name="ln3518">         </a>
<a name="ln3519"> </a>
<a name="ln3520">     Notation: (n) is a tetrahedral atom neighbor; n is an index of a neighbor in</a>
<a name="ln3521">     the central_at-&gt;neighbor[] array : neighbor atom number is central_at-&gt;neighbor[n].</a>
<a name="ln3522"> </a>
<a name="ln3523">     (0)-(1), (0)-(2), (0)-(3) are lines connecting atom [C] neighbors to neighbor (0)</a>
<a name="ln3524">     (0), (1) and (2) are in the plane</a>
<a name="ln3525">     (0)-(3) is directed from the plain to the viewer</a>
<a name="ln3526">     [C] is somewhere between (0), (1), (2), (3)</a>
<a name="ln3527">     Since (1)-(2)-(3)  are in a clockwise order when looking from (0), parity is 2, or even;</a>
<a name="ln3528">     otherwise parity would be 1, or odd.</a>
<a name="ln3529"> </a>
<a name="ln3530">    **********************************************************************************</a>
<a name="ln3531">    </a>
<a name="ln3532">      Examples of a stereogenic bond.</a>
<a name="ln3533">    </a>
<a name="ln3534">      Notation:   [atom number], (index of a neighbor):</a>
<a name="ln3535">                  [1] and [2] are atoms connected by the stereogenic bond</a>
<a name="ln3536">                  numbers in () are indexes of neighbors of [1] or [2].</a>
<a name="ln3537">                  (12 x 16)z = z-component of [1]-[2] and [1]-[6] cross-product</a>
<a name="ln3538"> </a>
<a name="ln3539">                                     atom [1]                     atom [2]                   </a>
<a name="ln3540">     [8]                    [4]      prod01 = (12 x 16)z &lt; 0      prod01 = (21 x 24)z &lt; 0    </a>
<a name="ln3541">       \                    /        prod02 = (12 x 18)z &gt; 0      prod02 = (21 x 25)z &gt; 0    </a>
<a name="ln3542">        (2)               (1)        0 transpositions because     0 transpositions because   </a>
<a name="ln3543">          \              /           double bond is in 0 posit.   double bond is in 0 position</a>
<a name="ln3544">          [1]==(0)(0)==[2]           0 = (prod01 &gt; prod02)        0 = (prod01 &gt; prod02)</a>
<a name="ln3545">          /              \                                                                   </a>
<a name="ln3546">        (1)               (2)        result: parity = 2, even     result: parity=2, even                                </a>
<a name="ln3547">       /                    \                                                                </a>
<a name="ln3548">     [6]                    [5]                                                              </a>
<a name="ln3549">                                                                                             </a>
<a name="ln3550">                                                                                             </a>
<a name="ln3551">                                                                                             </a>
<a name="ln3552">                                     atom [1]                     atom [2]                   </a>
<a name="ln3553">     [8]                    [5]      prod01 = (12 x 18)z &gt; 0      prod01 = (21 x 24)z &gt; 0    </a>
<a name="ln3554">       \                    /        prod02 = (12 x 16)z &lt; 0      prod02 = (21 x 25)z &lt; 0    </a>
<a name="ln3555">        (0)               (2)        2 transpositions to move     1 transposition to move    </a>
<a name="ln3556">          \              /           at [2] from 2 to 0 pos.      at [1] from 1 to 0 position</a>
<a name="ln3557">          [1]==(2)(1)==[2]           1 = (prod01 &gt; prod02)        1 = (prod01 &gt; prod02)      </a>
<a name="ln3558">          /              \                                                                   </a>
<a name="ln3559">        (1)               (0)        result: parity = (1+2)       result: parity=(1+1)           </a>
<a name="ln3560">       /                    \        2-(1+2)%2 = 1, odd           2-(1+1)%2 = 2, even</a>
<a name="ln3561">     [6]                    [4]           </a>
<a name="ln3562">                                          </a>
<a name="ln3563"> </a>
<a name="ln3564">    ***********************************************************************************</a>
<a name="ln3565">    Note: atoms' numbers [1], [2], [4],... are not used to calculate parity at this</a>
<a name="ln3566">          point. They will be used for each numbering in the canonicalization.</a>
<a name="ln3567">    Note: parity=3 for a stereo atom means entered undefined bond direction</a>
<a name="ln3568">          parity=4 for an atom means parity cannot be determined from the given geometry</a>
<a name="ln3569">    ***********************************************************************************/</a>
<a name="ln3570">    </a>
<a name="ln3571">    if ( !at_output || !at ) {</a>
<a name="ln3572">        return -1;</a>
<a name="ln3573">    }</a>
<a name="ln3574"> </a>
<a name="ln3575">    /*  clear stereo descriptors */</a>
<a name="ln3576"> </a>
<a name="ln3577">    for( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3578">        at_output[i].parity  = 0;</a>
<a name="ln3579">        at_output[i].parity2 = 0;</a>
<a name="ln3580">        memset(&amp;at_output[i].stereo_bond_neighbor[0], 0, sizeof(at_output[0].stereo_bond_neighbor) );</a>
<a name="ln3581">        memset(&amp;at_output[i].stereo_bond_neighbor2[0], 0, sizeof(at_output[0].stereo_bond_neighbor2) );</a>
<a name="ln3582">        memset(&amp;at_output[i].stereo_bond_ord[0], 0, sizeof(at_output[0].stereo_bond_ord) );</a>
<a name="ln3583">        memset(&amp;at_output[i].stereo_bond_ord2[0], 0, sizeof(at_output[0].stereo_bond_ord2) );</a>
<a name="ln3584">        memset(&amp;at_output[i].stereo_bond_z_prod[0], 0, sizeof(at_output[0].stereo_bond_z_prod) );</a>
<a name="ln3585">        memset(&amp;at_output[i].stereo_bond_z_prod2[0], 0, sizeof(at_output[0].stereo_bond_z_prod2) );</a>
<a name="ln3586">        memset(&amp;at_output[i].stereo_bond_parity[0], 0, sizeof(at_output[0].stereo_bond_parity) );</a>
<a name="ln3587">        memset(&amp;at_output[i].stereo_bond_parity2[0], 0, sizeof(at_output[0].stereo_bond_parity2) );</a>
<a name="ln3588">    }</a>
<a name="ln3589">    /*  estimate max numbers of stereo atoms and bonds if isotopic H are added */</a>
<a name="ln3590">    if ( nMaxNumStereoAtoms || nMaxNumStereoBonds ) {</a>
<a name="ln3591">        for( i = 0, num_stereo = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3592">            int num;</a>
<a name="ln3593">            num = can_be_a_stereo_atom_with_isotopic_H( at, i, bPointedEdgeStereo );</a>
<a name="ln3594">            if ( num ) {</a>
<a name="ln3595">                max_stereo_atoms += num;</a>
<a name="ln3596">            } else</a>
<a name="ln3597">            if ( (num = can_be_a_stereo_bond_with_isotopic_H( at, i, nMode ) ) ) { /*  accept cumulenes */</a>
<a name="ln3598">                max_stereo_bonds += num;</a>
<a name="ln3599">            }</a>
<a name="ln3600">        }</a>
<a name="ln3601">        if ( nMaxNumStereoAtoms )</a>
<a name="ln3602">            *nMaxNumStereoAtoms = max_stereo_atoms;</a>
<a name="ln3603">        if ( nMaxNumStereoBonds )</a>
<a name="ln3604">            *nMaxNumStereoBonds = max_stereo_bonds;</a>
<a name="ln3605">    }</a>
<a name="ln3606">    /*  calculate stereo descriptors */</a>
<a name="ln3607">#if ( MIN_SB_RING_SIZE &gt; 0 )</a>
<a name="ln3608">    min_sb_ring_size = (AT_RANK)(((nMode &amp; REQ_MODE_MIN_SB_RING_MASK) &gt;&gt; REQ_MODE_MIN_SB_RING_SHFT) &amp; AT_RANK_MASK);</a>
<a name="ln3609">    if ( min_sb_ring_size &gt;= 3 ) {</a>
<a name="ln3610">        /* create BFS data structure for finding for each stereo bond its min. ring sizes */</a>
<a name="ln3611">        q          = QueueCreate( num_at+1, sizeof(qInt) );</a>
<a name="ln3612">        nAtomLevel = (AT_RANK*)inchi_calloc(sizeof(nAtomLevel[0]),num_at);</a>
<a name="ln3613">        cSource    = (S_CHAR *)inchi_calloc(sizeof(cSource[0]),num_at);</a>
<a name="ln3614">        if ( !q || !cSource || !nAtomLevel ) {</a>
<a name="ln3615">            num_3D_stereo_atoms = CT_OUT_OF_RAM;</a>
<a name="ln3616">            goto exit_function;</a>
<a name="ln3617">        }</a>
<a name="ln3618">    } else {</a>
<a name="ln3619">        min_sb_ring_size = 2;</a>
<a name="ln3620">    }</a>
<a name="ln3621">#endif</a>
<a name="ln3622">    /* main cycle: set stereo parities */</a>
<a name="ln3623">    for( i = 0, num_stereo = 0; i &lt; num_at; i ++ ) </a>
<a name="ln3624">    {</a>
<a name="ln3625">        is_stereo = set_stereo_atom_parity( at_output, at, i, at+num_at, num_removed_H,</a>
<a name="ln3626">                                            bPointedEdgeStereo, vABParityUnknown ) ;</a>
<a name="ln3627">        if ( is_stereo ) </a>
<a name="ln3628">        {</a>
<a name="ln3629">            num_3D_stereo_atoms += ATOM_PARITY_WELL_DEF( is_stereo );</a>
<a name="ln3630">        } </a>
<a name="ln3631">        else </a>
<a name="ln3632">        {</a>
<a name="ln3633">            is_stereo = set_stereo_bonds_parity( at_output, at, i, at+num_at, num_removed_H, nMode,</a>
<a name="ln3634">                                       q, nAtomLevel, cSource, min_sb_ring_size, </a>
<a name="ln3635">                                       bPointedEdgeStereo, vABParityUnknown );</a>
<a name="ln3636">            if ( RETURNED_ERROR( is_stereo ) ) {</a>
<a name="ln3637">                num_3D_stereo_atoms = is_stereo;</a>
<a name="ln3638">                break;</a>
<a name="ln3639">            }</a>
<a name="ln3640">            num_stereo_bonds += (is_stereo != 0); /* added to fix bug reported by Burt Leland - 2009-02-05 DT */</a>
<a name="ln3641">        }</a>
<a name="ln3642">        num_stereo += (is_stereo != 0);</a>
<a name="ln3643">        is_stereo = is_stereo;</a>
<a name="ln3644">    }</a>
<a name="ln3645"> </a>
<a name="ln3646">    /* added to fix bug reported by Burt Leland - 2009-02-05 DT */</a>
<a name="ln3647">    if ( max_stereo_atoms &lt; num_3D_stereo_atoms &amp;&amp; nMaxNumStereoAtoms )</a>
<a name="ln3648">            *nMaxNumStereoAtoms = num_3D_stereo_atoms;</a>
<a name="ln3649">    if ( max_stereo_bonds &lt; num_stereo_bonds &amp;&amp; nMaxNumStereoBonds )</a>
<a name="ln3650">            *nMaxNumStereoBonds = num_stereo_bonds;</a>
<a name="ln3651"> </a>
<a name="ln3652">    /*</a>
<a name="ln3653">    if ( (nMode &amp; REQ_MODE_SC_IGN_ALL_UU ) </a>
<a name="ln3654">    REQ_MODE_SC_IGN_ALL_UU</a>
<a name="ln3655">    REQ_MODE_SB_IGN_ALL_UU</a>
<a name="ln3656">    */</a>
<a name="ln3657"> </a>
<a name="ln3658">#if ( MIN_SB_RING_SIZE &gt; 0 )</a>
<a name="ln3659">    if ( q ) {</a>
<a name="ln3660">        q = QueueDelete( q );</a>
<a name="ln3661">    }</a>
<a name="ln3662">    if ( nAtomLevel )</a>
<a name="ln3663">        inchi_free( nAtomLevel );</a>
<a name="ln3664">    if ( cSource )</a>
<a name="ln3665">        inchi_free( cSource );</a>
<a name="ln3666">exit_function:</a>
<a name="ln3667">#endif</a>
<a name="ln3668"> </a>
<a name="ln3669"> </a>
<a name="ln3670">    return num_3D_stereo_atoms;</a>
<a name="ln3671">}</a>
<a name="ln3672">/*****************************************************************</a>
<a name="ln3673"> *  Functions that disconnect bonds</a>
<a name="ln3674"> *</a>
<a name="ln3675"> *=== During Preprocessing ===</a>
<a name="ln3676"> *</a>
<a name="ln3677"> *  RemoveInpAtBond</a>
<a name="ln3678"> *  DisconnectMetalSalt (is not aware of bond parities)</a>
<a name="ln3679"> *  DisconnectAmmoniumSalt</a>
<a name="ln3680"> *</a>
<a name="ln3681"> *=== Before Normalization ===</a>
<a name="ln3682"> *</a>
<a name="ln3683"> *  remove_terminal_HDT</a>
<a name="ln3684"> *</a>
<a name="ln3685"> *=== During the Normalization ===</a>
<a name="ln3686"> *</a>
<a name="ln3687"> *  AddOrRemoveExplOrImplH</a>
<a name="ln3688"> *</a>
<a name="ln3689"> *****************************************************************/</a>
<a name="ln3690">int ReconcileAllCmlBondParities( inp_ATOM *at, int num_atoms, int bDisconnected )</a>
<a name="ln3691">{</a>
<a name="ln3692">    int i, ret = 0;</a>
<a name="ln3693">    S_CHAR *visited = (S_CHAR*) inchi_calloc( num_atoms, sizeof(*visited) );</a>
<a name="ln3694">    if ( !visited )</a>
<a name="ln3695">        return -1; /* out of RAM */</a>
<a name="ln3696">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3697">        if ( at[i].sb_parity[0] &amp;&amp; !visited[i] &amp;&amp; !(bDisconnected &amp;&amp; is_el_a_metal(at[i].el_number)) ) {</a>
<a name="ln3698">            if ( (ret = ReconcileCmlIncidentBondParities( at, i, -1, visited, bDisconnected )) ) {</a>
<a name="ln3699">                break; /* error */</a>
<a name="ln3700">            }</a>
<a name="ln3701">        }</a>
<a name="ln3702">    }</a>
<a name="ln3703">    inchi_free ( visited );</a>
<a name="ln3704">    return ret;</a>
<a name="ln3705">}</a>
<a name="ln3706">/*****************************************************************/</a>
<a name="ln3707">int ReconcileCmlIncidentBondParities( inp_ATOM *at, int cur_atom, int prev_atom, S_CHAR *visited, int bDisconnected )</a>
<a name="ln3708">{</a>
<a name="ln3709">    /* visited = 0 or parity =&gt; atom has not been visited</a>
<a name="ln3710">                 10 + parity =&gt; currently is on the stack + its final parity</a>
<a name="ln3711">                 20 + parity =&gt; has been visited; is not on the stack anymore + its final parity */</a>
<a name="ln3712">    int i, j, nxt_atom, ret = 0, len;</a>
<a name="ln3713">    int icur2nxt,  icur2neigh;   /* cur atom neighbors */</a>
<a name="ln3714">    int inxt2cur,  inxt2neigh;   /* next atom neighbors */</a>
<a name="ln3715">    int cur_parity, nxt_parity;</a>
<a name="ln3716">    int cur_order_parity, nxt_order_parity, cur_sb_parity, nxt_sb_parity, bCurMask, bNxtMask;</a>
<a name="ln3717">    /* !(bDisconnected &amp;&amp; is_el_a_metal(at[i].el_number) */</a>
<a name="ln3718">    </a>
<a name="ln3719">    if ( at[cur_atom].valence &gt; MAX_NUM_STEREO_BONDS )</a>
<a name="ln3720">        return 0; /* ignore */</a>
<a name="ln3721">    </a>
<a name="ln3722">    if ( !at[cur_atom].sb_parity[0] )</a>
<a name="ln3723">        return 1; /* wrong call */</a>
<a name="ln3724">    </a>
<a name="ln3725">    if ( visited[cur_atom] &gt;= 10 )</a>
<a name="ln3726">        return 2; /* program error */</a>
<a name="ln3727"> </a>
<a name="ln3728">    cur_parity = visited[cur_atom] % 10;</a>
<a name="ln3729"> </a>
<a name="ln3730">    visited[cur_atom] += 10;</a>
<a name="ln3731"> </a>
<a name="ln3732">    for ( i = 0; i &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[cur_atom].sb_parity[i]; i ++ ) {</a>
<a name="ln3733">        icur2nxt = (int)at[cur_atom].sb_ord[i];</a>
<a name="ln3734">        len = get_opposite_sb_atom( at, cur_atom, icur2nxt, &amp;nxt_atom, &amp;inxt2cur, &amp;j );</a>
<a name="ln3735">        if ( !len ) {</a>
<a name="ln3736">            return 4; /* could not find the opposite atom: bond parity data error */</a>
<a name="ln3737">        }</a>
<a name="ln3738">        if ( nxt_atom == prev_atom )</a>
<a name="ln3739">            continue;</a>
<a name="ln3740">        if ( visited[nxt_atom] &gt;= 20 )</a>
<a name="ln3741">            continue; /* back edge, second visit: ignore */</a>
<a name="ln3742">        if ( at[nxt_atom].valence &gt; MAX_NUM_STEREO_BONDS )</a>
<a name="ln3743">            continue; /* may be treated only after metal disconnection */</a>
<a name="ln3744"> </a>
<a name="ln3745">        if ( bDisconnected &amp;&amp; (at[cur_atom].sb_parity[i] &amp; SB_PARITY_FLAG) ) {</a>
<a name="ln3746">            cur_sb_parity = (at[cur_atom].sb_parity[i] &gt;&gt; SB_PARITY_SHFT);</a>
<a name="ln3747">            bCurMask = 3 &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln3748">        } else {</a>
<a name="ln3749">            cur_sb_parity = (at[cur_atom].sb_parity[i] &amp; SB_PARITY_MASK);</a>
<a name="ln3750">            bCurMask = 3;</a>
<a name="ln3751">        }</a>
<a name="ln3752">        if ( bDisconnected &amp;&amp; (at[nxt_atom].sb_parity[j] &amp; SB_PARITY_FLAG) ) {</a>
<a name="ln3753">            nxt_sb_parity = (at[nxt_atom].sb_parity[j] &gt;&gt; SB_PARITY_SHFT);</a>
<a name="ln3754">            bNxtMask = 3 &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln3755">        } else {</a>
<a name="ln3756">            nxt_sb_parity = (at[nxt_atom].sb_parity[j] &amp; SB_PARITY_MASK);</a>
<a name="ln3757">            bNxtMask = 3;</a>
<a name="ln3758">        }</a>
<a name="ln3759">        </a>
<a name="ln3760"> </a>
<a name="ln3761"> </a>
<a name="ln3762">        if ( !ATOM_PARITY_WELL_DEF(cur_sb_parity) ||</a>
<a name="ln3763">             !ATOM_PARITY_WELL_DEF(nxt_sb_parity)  ) {</a>
<a name="ln3764">            if ( cur_sb_parity == nxt_sb_parity ) {</a>
<a name="ln3765">                continue;</a>
<a name="ln3766">                /*goto move_forward;*/ /* bypass unknown/undefined */</a>
<a name="ln3767">            }</a>
<a name="ln3768">            return 3; /* sb parities do not match: bond parity data error */</a>
<a name="ln3769">        }</a>
<a name="ln3770"> </a>
<a name="ln3771">        icur2neigh  = (int)at[cur_atom].sn_ord[i];</a>
<a name="ln3772">        inxt2neigh  = (int)at[nxt_atom].sn_ord[j];</a>
<a name="ln3773">        /* parity of at[cur_atom].neighbor[] premutation to reach this order: { next_atom, neigh_atom, ...} */</a>
<a name="ln3774"> </a>
<a name="ln3775">        /* 1. move next_atom  from position=icur2nxt to position=0 =&gt;</a>
<a name="ln3776">         *         icur2nxt permutations</a>
<a name="ln3777">         * 2. move neigh_atom from position=inxt2neigh+(inxt2cur &gt; inxt2neigh) to position=1 =&gt;</a>
<a name="ln3778">         *         inxt2neigh+(inxt2cur &gt; inxt2neigh)-1 permutations.</a>
<a name="ln3779">         * Note if (inxt2cur &gt; inxt2neigh) then move #1 increments neigh_atom position</a>
<a name="ln3780">         * Note add 4 because icur2neigh may be negative due to isotopic H removal</a>
<a name="ln3781">         */</a>
<a name="ln3782">        cur_order_parity = (4+icur2nxt + icur2neigh + (icur2neigh &gt; icur2nxt)) % 2;</a>
<a name="ln3783">        /* same for next atom: */</a>
<a name="ln3784">        /* parity of at[nxt_atom].neighbor[] premutation to reach this order: { cur_atom, neigh_atom, ...} */</a>
<a name="ln3785">        nxt_order_parity = (4+inxt2cur + inxt2neigh + (inxt2neigh &gt; inxt2cur)) % 2;</a>
<a name="ln3786">        </a>
<a name="ln3787">        nxt_parity = visited[nxt_atom] % 10;</a>
<a name="ln3788">        </a>
<a name="ln3789">        if ( !cur_parity ) {</a>
<a name="ln3790">            cur_parity = 2 - (cur_order_parity + cur_sb_parity) % 2;</a>
<a name="ln3791">            visited[cur_atom] += cur_parity;</a>
<a name="ln3792">        } else</a>
<a name="ln3793">        if ( cur_parity != 2 - (cur_order_parity + cur_sb_parity) % 2 ) {</a>
<a name="ln3794"> </a>
<a name="ln3795">            /***** reconcile bond parities *****/</a>
<a name="ln3796"> </a>
<a name="ln3797">            /* Each bond parity is split into two values located at the end atoms.</a>
<a name="ln3798">               For T (trans) the values are (1,1) or (2,2)</a>
<a name="ln3799">               For C (cis)   the values are (1,2) or (2,1)</a>
<a name="ln3800">               The fact that one pair = another with inverted parities, namely</a>
<a name="ln3801">               Inv(1,1) = (2,2) and Inv(1,2) = (2,1), allows one to</a>
<a name="ln3802">               simultaneouly invert parities of the current bond end atoms</a>
<a name="ln3803">               (at[cur_atom].sb_parity[i], at[nxt_atom].sb_parity[j])</a>
<a name="ln3804">               so that the final current atom parity cur_parity</a>
<a name="ln3805">               calculated later in stereochemical canonicalization for</a>
<a name="ln3806">               each stereobond incident with the current atomis same.</a>
<a name="ln3807">               Achieving this is called here RECONCILIATION.</a>
<a name="ln3808">               If at the closure of an aromatic circuit the parities of</a>
<a name="ln3809">               next atom cannot be reconciled with already calculated then</a>
<a name="ln3810">               this function returns 5 (error).</a>
<a name="ln3811">            */</a>
<a name="ln3812">            </a>
<a name="ln3813">            at[cur_atom].sb_parity[i] ^= bCurMask;</a>
<a name="ln3814">            at[nxt_atom].sb_parity[j] ^= bNxtMask;</a>
<a name="ln3815">            cur_sb_parity ^= 3;</a>
<a name="ln3816">            nxt_sb_parity ^= 3;</a>
<a name="ln3817">        }</a>
<a name="ln3818">        </a>
<a name="ln3819">        if ( !nxt_parity ) {</a>
<a name="ln3820">            nxt_parity = 2 - (nxt_order_parity + nxt_sb_parity) % 2;</a>
<a name="ln3821">            visited[nxt_atom] += nxt_parity;</a>
<a name="ln3822">        } else</a>
<a name="ln3823">        if ( nxt_parity != 2 - (nxt_order_parity + nxt_sb_parity) % 2 ) {</a>
<a name="ln3824">            return 5; /* algorithm does not work for Mebius-like structures */</a>
<a name="ln3825">        }</a>
<a name="ln3826"> </a>
<a name="ln3827">/* move_forward: */</a>
<a name="ln3828">        if ( visited[nxt_atom] &lt; 10 ) {</a>
<a name="ln3829">            ret = ReconcileCmlIncidentBondParities( at, nxt_atom, cur_atom, visited, bDisconnected );</a>
<a name="ln3830">            if ( ret ) {</a>
<a name="ln3831">                break;</a>
<a name="ln3832">            }</a>
<a name="ln3833">        }</a>
<a name="ln3834">    }</a>
<a name="ln3835">    visited[cur_atom] += 10; /* all bonds incident to the current atom have</a>
<a name="ln3836">                                been processed or an error occurred. */ </a>
<a name="ln3837">    return ret;</a>
<a name="ln3838">}</a>
<a name="ln3839">/*****************************************************************/</a>
<a name="ln3840">int get_opposite_sb_atom( inp_ATOM *at, int cur_atom, int icur2nxt, int *pnxt_atom, int *pinxt2cur, int *pinxt_sb_parity_ord )</a>
<a name="ln3841">{</a>
<a name="ln3842">    AT_NUMB nxt_atom;</a>
<a name="ln3843">    int     j, len;</a>
<a name="ln3844">    </a>
<a name="ln3845">    len = 0;</a>
<a name="ln3846">    while ( len ++ &lt; 20 ) { /* arbitrarily set cumulene length limit to avoid infinite loop */</a>
<a name="ln3847">        nxt_atom = at[cur_atom].neighbor[icur2nxt];</a>
<a name="ln3848">        for ( j = 0; j &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[nxt_atom].sb_parity[j]; j ++ ) {</a>
<a name="ln3849">            if ( cur_atom == at[nxt_atom].neighbor[(int)at[nxt_atom].sb_ord[j]] ) {</a>
<a name="ln3850">                /* found the opposite atom */</a>
<a name="ln3851">                *pnxt_atom = nxt_atom;</a>
<a name="ln3852">                *pinxt2cur = at[nxt_atom].sb_ord[j];</a>
<a name="ln3853">                *pinxt_sb_parity_ord = j;</a>
<a name="ln3854">                return len;</a>
<a name="ln3855">            }</a>
<a name="ln3856">        }</a>
<a name="ln3857">        if ( j ) {</a>
<a name="ln3858">            return 0; /* reached atom(s) with stereobond (sb) parity, the opposite atom has not been found */</a>
<a name="ln3859">        }</a>
<a name="ln3860">        if ( at[nxt_atom].valence == 2 &amp;&amp; 2*BOND_TYPE_DOUBLE == at[nxt_atom].chem_bonds_valence ) {</a>
<a name="ln3861">            /* follow cumulene =X= path */</a>
<a name="ln3862">            icur2nxt = (at[nxt_atom].neighbor[0] == cur_atom);</a>
<a name="ln3863">            cur_atom = nxt_atom;</a>
<a name="ln3864">        } else {</a>
<a name="ln3865">            return 0; /* neither atom with a sb parity not middle cumulene could be reached */</a>
<a name="ln3866">        }</a>
<a name="ln3867">    }</a>
<a name="ln3868">    return 0; /* too long chain of cumulene was found */</a>
<a name="ln3869">}</a>

</code></pre>
<div class="balloon" rel="621"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nNumNeigh == 4' is always true.</p></div>
<div class="balloon" rel="370"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'dBondDirection' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="869"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: min_sine.</p></div>
<div class="balloon" rel="870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'min_sine' is always true.</p></div>
<div class="balloon" rel="988"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The 'prod' variable is assigned but is not used by the end of the function.</p></div>
<div class="balloon" rel="1418"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="3643"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'is_stereo' variable is assigned to itself.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

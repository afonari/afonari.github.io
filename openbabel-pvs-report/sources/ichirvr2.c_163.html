
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichirvr2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">/*^^^ */</a>
<a name="ln45">/*#define CHECK_WIN32_VC_HEAP*/</a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;ichi.h&quot;</a>
<a name="ln51">#include &quot;ichitime.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;inpdef.h&quot;</a>
<a name="ln54">#include &quot;ichimain.h&quot;</a>
<a name="ln55">#include &quot;ichierr.h&quot;</a>
<a name="ln56">#include &quot;incomdef.h&quot; </a>
<a name="ln57">#include &quot;ichiring.h&quot;</a>
<a name="ln58">#include &quot;extr_ct.h&quot;</a>
<a name="ln59">#include &quot;ichitaut.h&quot;</a>
<a name="ln60">#include &quot;ichinorm.h&quot;</a>
<a name="ln61">#include &quot;util.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;ichicomp.h&quot;</a>
<a name="ln64">#include &quot;ichister.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;ichi_bns.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;strutil.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">#include &quot;ichirvrs.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">/******************************************************************************************************/</a>
<a name="ln73">void CopyAt2St( inp_ATOM *at, inp_ATOM_STEREO * st, int num_atoms )</a>
<a name="ln74">{</a>
<a name="ln75">    int i;</a>
<a name="ln76">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln77">        if ( at[i].p_parity ) {</a>
<a name="ln78">            memcpy( st[i].p_orig_at_num, at[i].p_orig_at_num, sizeof(st[0].p_orig_at_num) );</a>
<a name="ln79">            st[i].p_parity = at[i].p_parity;</a>
<a name="ln80">        }</a>
<a name="ln81">        if ( at[i].sb_parity[0] ) {</a>
<a name="ln82">            memcpy( st[i].sb_ord, at[i].sb_ord, sizeof(st[0].sb_ord) );</a>
<a name="ln83">            memcpy( st[i].sb_parity, at[i].sb_parity, sizeof(st[0].sb_parity) );</a>
<a name="ln84">            memcpy( st[i].sn_ord, at[i].sn_ord, sizeof(st[0].sn_ord) );</a>
<a name="ln85">            memcpy( st[i].sn_orig_at_num, at[i].sn_orig_at_num, sizeof(st[0].sn_orig_at_num) );</a>
<a name="ln86">        }</a>
<a name="ln87">    }</a>
<a name="ln88">}</a>
<a name="ln89">void CopySt2At( inp_ATOM *at, inp_ATOM_STEREO * st, int num_atoms )</a>
<a name="ln90">{</a>
<a name="ln91">    int i;</a>
<a name="ln92">    if ( !st ) {</a>
<a name="ln93">        return;</a>
<a name="ln94">    }</a>
<a name="ln95">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln96">        if ( st[i].p_parity ) {</a>
<a name="ln97">            memcpy( at[i].p_orig_at_num, st[i].p_orig_at_num, sizeof(at[0].p_orig_at_num) );</a>
<a name="ln98">            at[i].p_parity = st[i].p_parity;</a>
<a name="ln99">        }</a>
<a name="ln100">        if ( st[i].sb_parity[0] ) {</a>
<a name="ln101">            memcpy( at[i].sb_ord, st[i].sb_ord, sizeof(st[0].sb_ord) );</a>
<a name="ln102">            memcpy( at[i].sb_parity, st[i].sb_parity, sizeof(at[0].sb_parity) );</a>
<a name="ln103">            memcpy( at[i].sn_ord, st[i].sn_ord, sizeof(at[0].sn_ord) );</a>
<a name="ln104">            memcpy( at[i].sn_orig_at_num, st[i].sn_orig_at_num, sizeof(at[0].sn_orig_at_num) );</a>
<a name="ln105">        }</a>
<a name="ln106">    }</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">/******************************************************************************************************/</a>
<a name="ln110">int RestoreAtomConnectionsSetStereo( StrFromINChI *pStruct, int iComponent, int iAtNoOffset, INChI *pInChI, INChI *pInChIMobH)</a>
<a name="ln111">{</a>
<a name="ln112">    inp_ATOM     *at  = NULL;</a>
<a name="ln113">    inp_ATOM_STEREO * st = NULL;</a>
<a name="ln114">    int           num_atoms, i, jv, jn, n_vertex, n_neigh, num_H, parity;</a>
<a name="ln115">    int           nNumDeletedH=0, iDeletedH=0, idelH1, idelH2, ret = 0, len;</a>
<a name="ln116">    int           num_stereo_bonds, num_stereo_centers, num_stereo_bonds2, num_stereo_centers2;</a>
<a name="ln117">    INChI_Stereo *pStereo = NULL, *pStereo2 = NULL;</a>
<a name="ln118">    AT_NUMB       nCumulene[MAX_CUMULENE_LEN+2];</a>
<a name="ln119"> </a>
<a name="ln120">    num_atoms = pInChI-&gt;nNumberOfAtoms;</a>
<a name="ln121">    if ( num_atoms &lt;= 0 ) {</a>
<a name="ln122">        return 0;</a>
<a name="ln123">    }</a>
<a name="ln124">    INCHI_HEAPCHK</a>
<a name="ln125">    /* atoms */</a>
<a name="ln126">    pStruct-&gt;at = at = (inp_ATOM *) inchi_calloc ( num_atoms, sizeof(pStruct-&gt;at[0]) );</a>
<a name="ln127">    if ( !at ) {</a>
<a name="ln128">        ret = RI_ERR_ALLOC;</a>
<a name="ln129">        goto exit_function;</a>
<a name="ln130">    }</a>
<a name="ln131">    pStruct-&gt;num_atoms = num_atoms;</a>
<a name="ln132">    /* charge */</a>
<a name="ln133">    pStruct-&gt;charge = pInChI-&gt;nTotalCharge;</a>
<a name="ln134">    /* elements, terminal atoms H */</a>
<a name="ln135">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln136">        at[i].el_number = pInChI-&gt;nAtom[i];</a>
<a name="ln137">        if ( GetElementFormulaFromAtNum(UCINT pInChI-&gt;nAtom[i], at[i].elname ) ) {</a>
<a name="ln138">            ret = RI_ERR_PROGR;</a>
<a name="ln139">            goto exit_function;</a>
<a name="ln140">        }</a>
<a name="ln141">        at[i].orig_at_number = iAtNoOffset + i+1;</a>
<a name="ln142">        at[i].orig_compt_at_numb = i + 1;</a>
<a name="ln143">        at[i].component = iComponent + 1;</a>
<a name="ln144">        num_H = pInChI-&gt;nNum_H[i];</a>
<a name="ln145">        /* --- pInChI-&gt;nNum_H_fixed[i] was added to pInChI-&gt;nNum_H[i] ---</a>
<a name="ln146">        if ( pInChI-&gt;nNum_H_fixed ) {</a>
<a name="ln147">            num_H += pInChI-&gt;nNum_H_fixed[i];</a>
<a name="ln148">        }</a>
<a name="ln149">        */</a>
<a name="ln150">        at[i].num_H = num_H;</a>
<a name="ln151">    }</a>
<a name="ln152">    INCHI_HEAPCHK</a>
<a name="ln153">    /* connections */</a>
<a name="ln154">    for ( i = 1, n_vertex = pInChI-&gt;nConnTable[0]-1; i &lt; pInChI-&gt;lenConnTable; i ++ ) {</a>
<a name="ln155">        if ( (n_neigh = pInChI-&gt;nConnTable[i]-1) &lt; n_vertex ) {</a>
<a name="ln156">            /*  vertex - neighbor connection */</a>
<a name="ln157">            jv = at[n_vertex].valence ++;</a>
<a name="ln158">            at[n_vertex].neighbor[jv] = n_neigh;</a>
<a name="ln159">            at[n_vertex].bond_type[jv] = BOND_TYPE_SINGLE;</a>
<a name="ln160">            at[n_vertex].chem_bonds_valence += at[n_vertex].bond_type[jv];</a>
<a name="ln161">            /*  neighbor - vertex connection */</a>
<a name="ln162">            jn = at[n_neigh].valence ++;</a>
<a name="ln163">            at[n_neigh].neighbor[jn] = n_vertex;</a>
<a name="ln164">            at[n_neigh].bond_type[jn] = BOND_TYPE_SINGLE;</a>
<a name="ln165">            at[n_neigh].chem_bonds_valence += at[n_neigh].bond_type[jn];</a>
<a name="ln166">        } else</a>
<a name="ln167">        if ( (n_vertex = n_neigh) &gt;= num_atoms ) {</a>
<a name="ln168">            ret = RI_ERR_PROGR;</a>
<a name="ln169">            goto exit_function;</a>
<a name="ln170">        }</a>
<a name="ln171">    }</a>
<a name="ln172">    INCHI_HEAPCHK</a>
<a name="ln173">    /* isotopic atoms */</a>
<a name="ln174">    if ( pInChI-&gt;IsotopicAtom &amp;&amp; pInChI-&gt;nNumberOfIsotopicAtoms ) {</a>
<a name="ln175">        for ( i = 0; i &lt; pInChI-&gt;nNumberOfIsotopicAtoms; i ++ ) {</a>
<a name="ln176">            n_vertex = pInChI-&gt;IsotopicAtom[i].nAtomNumber-1;</a>
<a name="ln177">            at[n_vertex].iso_atw_diff = (char)pInChI-&gt;IsotopicAtom[i].nIsoDifference;</a>
<a name="ln178">            at[n_vertex].num_iso_H[0] = (char)pInChI-&gt;IsotopicAtom[i].nNum_H;</a>
<a name="ln179">            at[n_vertex].num_iso_H[1] = (char)pInChI-&gt;IsotopicAtom[i].nNum_D;</a>
<a name="ln180">            at[n_vertex].num_iso_H[2] = (char)pInChI-&gt;IsotopicAtom[i].nNum_T;</a>
<a name="ln181">        }</a>
<a name="ln182">        pStruct-&gt;bIsotopic |= 1;</a>
<a name="ln183">    }</a>
<a name="ln184">    INCHI_HEAPCHK</a>
<a name="ln185">    /* tautomeric groups */</a>
<a name="ln186">    if ( (ret = GetTgroupInfoFromInChI( &amp;pStruct-&gt;ti, at, NULL, pInChI )) ) {</a>
<a name="ln187">        goto exit_function;</a>
<a name="ln188">    }</a>
<a name="ln189"> </a>
<a name="ln190">    /* coordinates: data from unused members: pInChI-&gt;IsotopicTGroup and InChI-&gt;nNumberOfIsotopicTGroups */</a>
<a name="ln191">    if ( pInChI-&gt;IsotopicTGroup &amp;&amp; !pInChI-&gt;nNumberOfIsotopicTGroups ) {</a>
<a name="ln192">        pStruct-&gt;pXYZ = (XYZ_COORD *) pInChI-&gt;IsotopicTGroup;</a>
<a name="ln193">        pInChI-&gt;IsotopicTGroup = NULL;</a>
<a name="ln194">    }</a>
<a name="ln195">    /* stereo */</a>
<a name="ln196">    if ( pInChI-&gt;StereoIsotopic &amp;&amp; </a>
<a name="ln197">         (pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds +</a>
<a name="ln198">          pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln199">        pStereo = pInChI-&gt;StereoIsotopic;</a>
<a name="ln200">    } else</a>
<a name="ln201">    if ( pInChI-&gt;Stereo &amp;&amp; </a>
<a name="ln202">         (pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds +</a>
<a name="ln203">          pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln204">        pStereo = pInChI-&gt;Stereo;</a>
<a name="ln205">    } else {</a>
<a name="ln206">        pStereo = NULL;</a>
<a name="ln207">    }</a>
<a name="ln208">    /* stereo2: Mobile-H in addition to Fixed-H*/</a>
<a name="ln209">    pStereo2 = NULL;</a>
<a name="ln210">    if ( pInChIMobH &amp;&amp; pInChIMobH-&gt;nNumberOfAtoms ) {</a>
<a name="ln211">        if ( pInChIMobH-&gt;StereoIsotopic &amp;&amp; </a>
<a name="ln212">             (pInChIMobH-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds +</a>
<a name="ln213">              pInChIMobH-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln214">            pStereo2 = pInChIMobH-&gt;StereoIsotopic;</a>
<a name="ln215">        } else</a>
<a name="ln216">        if ( pInChIMobH-&gt;Stereo &amp;&amp; </a>
<a name="ln217">             (pInChIMobH-&gt;Stereo-&gt;nNumberOfStereoBonds +</a>
<a name="ln218">              pInChIMobH-&gt;Stereo-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln219">            pStereo2 = pInChIMobH-&gt;Stereo;</a>
<a name="ln220">        }</a>
<a name="ln221">    }</a>
<a name="ln222">    INCHI_HEAPCHK</a>
<a name="ln223"> </a>
<a name="ln224">    num_stereo_bonds = num_stereo_bonds2 = 0;</a>
<a name="ln225">    num_stereo_centers = num_stereo_centers2 = 0;</a>
<a name="ln226">    /* -- have already been done in the initialization --</a>
<a name="ln227">       iDeletedH = 0;</a>
<a name="ln228">       nNumDeletedH = 0;</a>
<a name="ln229">    */</a>
<a name="ln230">    if ( pStereo || pStereo2 ) {</a>
<a name="ln231">        /* count implicit H needed for parities and reallocate at[]; set at[n_vertex].at_type=1 for these atoms */</a>
<a name="ln232">        int len1  = pStereo? pStereo-&gt;nNumberOfStereoCenters : 0;</a>
<a name="ln233">        int len2 = pStereo2? pStereo2-&gt;nNumberOfStereoCenters : 0;</a>
<a name="ln234">        int i2, diff, diff2;</a>
<a name="ln235">        for ( i = i2 = 0; i &lt; len1 || i2 &lt; len2; ) {</a>
<a name="ln236">            if ( i &lt; len1 &amp;&amp; i2 &lt; len2 ) {</a>
<a name="ln237">                diff = (int)pStereo-&gt;nNumber[i] - (int)pStereo2-&gt;nNumber[i2];</a>
<a name="ln238">                if ( diff &lt;= 0 ) {</a>
<a name="ln239">                    n_vertex = pStereo-&gt;nNumber[i]-1;</a>
<a name="ln240">                    i ++;</a>
<a name="ln241">                    i2 += !diff;</a>
<a name="ln242">                } else {</a>
<a name="ln243">                    n_vertex = pStereo2-&gt;nNumber[i2]-1;</a>
<a name="ln244">                    num_stereo_centers2 ++;</a>
<a name="ln245">                    i2 ++;</a>
<a name="ln246">                }</a>
<a name="ln247">            } else</a>
<a name="ln248">            if ( i &lt; len1 ) {</a>
<a name="ln249">                n_vertex = pStereo-&gt;nNumber[i]-1;</a>
<a name="ln250">                i ++;</a>
<a name="ln251">            } else {</a>
<a name="ln252">                n_vertex = pStereo2-&gt;nNumber[i2]-1;</a>
<a name="ln253">                num_stereo_centers2 ++;</a>
<a name="ln254">                i2 ++;</a>
<a name="ln255">            }</a>
<a name="ln256">            /* find whether it is an allene */</a>
<a name="ln257">            if ( at[n_vertex].valence == 2 &amp;&amp;</a>
<a name="ln258">                 at[n_vertex].num_H   == 0 &amp;&amp;</a>
<a name="ln259">                 bCanAtomBeMiddleAllene(at[n_vertex].elname, 0, 0) &amp;&amp;</a>
<a name="ln260">                 at[jv = at[n_vertex].neighbor[0]].valence + at[jv].num_H == 3 &amp;&amp;</a>
<a name="ln261">                 bCanAtomBeTerminalAllene(at[jv].elname, 0, 0)     &amp;&amp;</a>
<a name="ln262">                 at[jn = at[n_vertex].neighbor[1]].valence + at[jn].num_H == 3 &amp;&amp;</a>
<a name="ln263">                 bCanAtomBeTerminalAllene(at[jn].elname, 0, 0) ) {</a>
<a name="ln264">                /* allene */</a>
<a name="ln265">                if ( !at[jv].at_type &amp;&amp; at[jv].num_H ) {</a>
<a name="ln266">                    nNumDeletedH += at[jv].num_H;</a>
<a name="ln267">                    at[jv].at_type ++;  /* H should be added as an explicit H */</a>
<a name="ln268">                }</a>
<a name="ln269">                if ( !at[jn].at_type &amp;&amp; at[jn].num_H ) {</a>
<a name="ln270">                    nNumDeletedH += at[jn].num_H;</a>
<a name="ln271">                    at[jn].at_type ++;  /* H should be added as an explicit H */</a>
<a name="ln272">                }</a>
<a name="ln273">            } else {</a>
<a name="ln274">                /* stereogenic atom - sp3 */</a>
<a name="ln275">                if ( !at[n_vertex].at_type &amp;&amp; at[n_vertex].num_H ) {</a>
<a name="ln276">                    nNumDeletedH += at[n_vertex].num_H;</a>
<a name="ln277">                    at[n_vertex].at_type ++; /* H should be added as an explicit H */</a>
<a name="ln278">                }</a>
<a name="ln279">            }</a>
<a name="ln280">        }</a>
<a name="ln281">        INCHI_HEAPCHK</a>
<a name="ln282">        len1  = pStereo? pStereo-&gt;nNumberOfStereoBonds : 0;</a>
<a name="ln283">        len2 = pStereo2? pStereo2-&gt;nNumberOfStereoBonds : 0;</a>
<a name="ln284">        for ( i = i2 = 0; i &lt; len1 || i2 &lt; len2; ) {</a>
<a name="ln285">            if ( i &lt; len1 &amp;&amp; i2 &lt; len2 ) {</a>
<a name="ln286">                diff  = (int)pStereo-&gt;nBondAtom1[i] - (int)pStereo2-&gt;nBondAtom1[i2];</a>
<a name="ln287">                diff2 = (int)pStereo-&gt;nBondAtom2[i] - (int)pStereo2-&gt;nBondAtom2[i2];</a>
<a name="ln288">                if ( diff &lt; 0 || (diff == 0 &amp;&amp; diff2 &lt;= 0)) {</a>
<a name="ln289">                    n_vertex = pStereo-&gt;nBondAtom1[i]-1;</a>
<a name="ln290">                    n_neigh  = pStereo-&gt;nBondAtom2[i]-1;</a>
<a name="ln291">                    i ++;</a>
<a name="ln292">                    i2 += !diff &amp;&amp; !diff2;</a>
<a name="ln293">                } else {</a>
<a name="ln294">                    n_vertex = pStereo2-&gt;nBondAtom1[i2]-1;</a>
<a name="ln295">                    n_neigh  = pStereo2-&gt;nBondAtom2[i2]-1;</a>
<a name="ln296">                    num_stereo_bonds2 ++;</a>
<a name="ln297">                    i2 ++;</a>
<a name="ln298">                }</a>
<a name="ln299">            } else</a>
<a name="ln300">            if ( i &lt; len1 ) {</a>
<a name="ln301">                n_vertex = pStereo-&gt;nBondAtom1[i]-1;</a>
<a name="ln302">                n_neigh  = pStereo-&gt;nBondAtom2[i]-1;</a>
<a name="ln303">                i ++;</a>
<a name="ln304">            } else {</a>
<a name="ln305">                n_vertex = pStereo2-&gt;nBondAtom1[i2]-1;</a>
<a name="ln306">                n_neigh  = pStereo2-&gt;nBondAtom2[i2]-1;</a>
<a name="ln307">                num_stereo_bonds2 ++;</a>
<a name="ln308">                i2 ++;</a>
<a name="ln309">            }</a>
<a name="ln310">            if ( !is_in_the_list( at[n_vertex].neighbor, (AT_NUMB)n_neigh, at[n_vertex].valence ) ) {</a>
<a name="ln311">                /* must be a cumulene */</a>
<a name="ln312">                if ( !bFindCumuleneChain( at, (AT_NUMB)n_vertex, (AT_NUMB)n_neigh, nCumulene, MAX_CUMULENE_LEN+1 ) ) {</a>
<a name="ln313">                    ret = RI_ERR_SYNTAX; /* not a cumulene */</a>
<a name="ln314">                    goto exit_function;</a>
<a name="ln315">                }</a>
<a name="ln316">            }</a>
<a name="ln317">            if ( !at[n_vertex].at_type &amp;&amp; at[n_vertex].num_H ) {</a>
<a name="ln318">                nNumDeletedH += at[n_vertex].num_H;</a>
<a name="ln319">                at[n_vertex].at_type ++;  /* H should be added as an explicit H */</a>
<a name="ln320">            }</a>
<a name="ln321">            if ( !at[n_neigh].at_type &amp;&amp; at[n_neigh].num_H ) {</a>
<a name="ln322">                nNumDeletedH += at[n_neigh].num_H;</a>
<a name="ln323">                at[n_neigh].at_type ++;   /* H should be added as an explicit H */</a>
<a name="ln324">            }</a>
<a name="ln325">        }</a>
<a name="ln326">        INCHI_HEAPCHK</a>
<a name="ln327">        if ( nNumDeletedH ) {</a>
<a name="ln328">            /* add explicit H */</a>
<a name="ln329">            inp_ATOM *at2 = (inp_ATOM *)inchi_calloc( num_atoms + nNumDeletedH, sizeof(at2[0]) );</a>
<a name="ln330">            if ( !at2 ) {</a>
<a name="ln331">                ret = RI_ERR_ALLOC;</a>
<a name="ln332">                goto exit_function;</a>
<a name="ln333">            }</a>
<a name="ln334">            pStruct-&gt;num_deleted_H = nNumDeletedH;</a>
<a name="ln335">            memcpy( at2, at, num_atoms * sizeof(at2[0]) );</a>
<a name="ln336">            inchi_free( at );</a>
<a name="ln337">            pStruct-&gt;at =  at = at2;</a>
<a name="ln338">            /* fill out deleted H atom info */</a>
<a name="ln339">            for ( i = num_atoms; i &lt; num_atoms + nNumDeletedH; i ++ ) {</a>
<a name="ln340">                strcpy( at[i].elname, &quot;H&quot; );</a>
<a name="ln341">                at[i].el_number = EL_NUMBER_H;</a>
<a name="ln342">                at[i].orig_at_number = iAtNoOffset + i+1;</a>
<a name="ln343">                at[i].orig_compt_at_numb = i + 1;</a>
<a name="ln344">                at[i].component = iComponent + 1;</a>
<a name="ln345">            }</a>
<a name="ln346">            /* connect deleted H */</a>
<a name="ln347">            for( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln348">                if ( at[i].at_type == 1 ) {</a>
<a name="ln349">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, i, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln350">                        goto exit_function;</a>
<a name="ln351">                    }</a>
<a name="ln352">                }</a>
<a name="ln353">            }</a>
<a name="ln354">        }</a>
<a name="ln355">        INCHI_HEAPCHK</a>
<a name="ln356">    }</a>
<a name="ln357"> </a>
<a name="ln358">    if ( pStereo ) {</a>
<a name="ln359">        /* mark stereo centers, they have already been connected the added explicit H, if any */</a>
<a name="ln360">        int bInvertedParity   = (pStereo-&gt;nCompInv2Abs == -1);</a>
<a name="ln361">        for ( i = 0; i &lt; pStereo-&gt;nNumberOfStereoCenters; i ++ ) {</a>
<a name="ln362">            n_vertex = pStereo-&gt;nNumber[i]-1;</a>
<a name="ln363">            parity   = pStereo-&gt;t_parity[i];</a>
<a name="ln364">            if ( bInvertedParity ) {</a>
<a name="ln365">                parity = (parity == AB_PARITY_EVEN)? AB_PARITY_ODD : (parity == AB_PARITY_ODD)? AB_PARITY_EVEN : parity;</a>
<a name="ln366">            }</a>
<a name="ln367">            /* find whether it is allene */</a>
<a name="ln368">            if ( at[n_vertex].valence == 2 &amp;&amp;</a>
<a name="ln369">                 at[n_vertex].num_H   == 0 &amp;&amp;</a>
<a name="ln370">                 bCanAtomBeMiddleAllene(at[n_vertex].elname, 0, 0) &amp;&amp;</a>
<a name="ln371">                 /* allene has exactly 2 double bonds */</a>
<a name="ln372">                 (jv = at[n_vertex].neighbor[0], at[jv].valence + at[jv].num_H == 3) &amp;&amp;</a>
<a name="ln373">                 bCanAtomBeTerminalAllene(at[jv].elname, 0, 0)     &amp;&amp;</a>
<a name="ln374">                 (jn = at[n_vertex].neighbor[1], at[jn].valence + at[jn].num_H == 3) &amp;&amp;</a>
<a name="ln375">                 bCanAtomBeTerminalAllene(at[jn].elname, 0, 0) ) {</a>
<a name="ln376">                /* allene: add explicit H if implicit H are present */</a>
<a name="ln377">                /* iDeletedH = current number of already added explicit H */</a>
<a name="ln378">                /* idelH1    = index in at[] of the explicit H added to atom jv */</a>
<a name="ln379">                if ( at[jv].num_H ) {</a>
<a name="ln380">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, jv, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln381">                        goto exit_function;</a>
<a name="ln382">                    }</a>
<a name="ln383">                } else {</a>
<a name="ln384">                    /* index of the stereo atom neighbor */</a>
<a name="ln385">                    idelH1 = at[jv].neighbor[at[jv].neighbor[0]==n_vertex];</a>
<a name="ln386">                }</a>
<a name="ln387">                if ( at[jn].num_H ) {</a>
<a name="ln388">                    /* iDeletedH = current number of already added explicit H */</a>
<a name="ln389">                    /* idelH2    = index of the explicit H added to atom jn */</a>
<a name="ln390">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, jn, num_atoms, &amp;iDeletedH, &amp;idelH2, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln391">                        goto exit_function;</a>
<a name="ln392">                    }</a>
<a name="ln393">                } else {</a>
<a name="ln394">                    idelH2 = at[jn].neighbor[at[jn].neighbor[0]==n_vertex];</a>
<a name="ln395">                }</a>
<a name="ln396">                /* allene: set bond types to double */</a>
<a name="ln397">                /*</a>
<a name="ln398">                if ( 0 &gt; (ret = set_bond_type( at, (AT_NUMB)n_vertex, (AT_NUMB)jv, BOND_TYPE_DOUBLE ) ) ||</a>
<a name="ln399">                     0 &gt; (ret = set_bond_type( at, (AT_NUMB)n_vertex, (AT_NUMB)jn, BOND_TYPE_DOUBLE ) ) ) {</a>
<a name="ln400">                    goto exit_function;</a>
<a name="ln401">                }</a>
<a name="ln402">                */</a>
<a name="ln403">                /* allene: make 0D parity */</a>
<a name="ln404">                ret = set_cumulene_0D_parity( at, st, num_atoms, idelH1, jv, jn, idelH2, parity, 2 );</a>
<a name="ln405">                if ( ret &lt; 0 ) {</a>
<a name="ln406">                    goto exit_function;</a>
<a name="ln407">                }</a>
<a name="ln408">            } else {</a>
<a name="ln409">                /* stereogenic sp3 atom */</a>
<a name="ln410">                if ( at[n_vertex].num_H ) {</a>
<a name="ln411">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, n_vertex, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln412">                        goto exit_function;</a>
<a name="ln413">                    }</a>
<a name="ln414">                }</a>
<a name="ln415">                ret = set_atom_0D_parity( at, st, num_atoms, nNumDeletedH, n_vertex, parity );</a>
<a name="ln416">                if ( ret &lt; 0 ) {</a>
<a name="ln417">                    goto exit_function;</a>
<a name="ln418">                }</a>
<a name="ln419">                num_stereo_centers ++;</a>
<a name="ln420">            }</a>
<a name="ln421">            if ( ret &lt; 0 ) {</a>
<a name="ln422">                goto exit_function;</a>
<a name="ln423">            }</a>
<a name="ln424">        }</a>
<a name="ln425">        INCHI_HEAPCHK</a>
<a name="ln426">        /* mark stereobonds */</a>
<a name="ln427">        for ( i = 0; i &lt; pStereo-&gt;nNumberOfStereoBonds; i ++ ) {</a>
<a name="ln428">            jv     = pStereo-&gt;nBondAtom1[i]-1;</a>
<a name="ln429">            jn     = pStereo-&gt;nBondAtom2[i]-1;</a>
<a name="ln430">            parity = pStereo-&gt;b_parity[i];</a>
<a name="ln431">            if ( !is_in_the_list( at[jv].neighbor, (AT_NUMB)jn, at[jv].valence ) ) {</a>
<a name="ln432">                /* must be a cumulene */</a>
<a name="ln433">                if ( !bFindCumuleneChain( at, (AT_NUMB)jv, (AT_NUMB)jn, nCumulene, MAX_CUMULENE_LEN+1 ) ) {</a>
<a name="ln434">                    return RI_ERR_SYNTAX; /* not a cumulene */</a>
<a name="ln435">                }</a>
<a name="ln436">                len = MAX_CUMULENE_LEN+1;</a>
<a name="ln437">            } else {</a>
<a name="ln438">                /* a regular double or alt bond */</a>
<a name="ln439">                nCumulene[0] = jv;</a>
<a name="ln440">                nCumulene[1] = jn;</a>
<a name="ln441">                len = 1; /* cumulene length is number of bonds, not number of atoms */</a>
<a name="ln442">            }</a>
<a name="ln443">            /* cumulene or double bond: add explicit H if implicit H are present */</a>
<a name="ln444">            if ( at[jv].num_H ) {</a>
<a name="ln445">                if ( 0 &gt; (ret = AddExplicitDeletedH( at, jv, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln446">                    goto exit_function;</a>
<a name="ln447">                }</a>
<a name="ln448">            } else {</a>
<a name="ln449">                /* double bond neighbor that has the smallest canonical number; it is either 0th or 1st */</a>
<a name="ln450">                idelH1 = at[jv].neighbor[at[jv].neighbor[0]==nCumulene[1]];</a>
<a name="ln451">            }</a>
<a name="ln452">            if ( at[jn].num_H ) {</a>
<a name="ln453">                if ( 0 &gt; (ret = AddExplicitDeletedH( at, jn, num_atoms, &amp;iDeletedH, &amp;idelH2, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln454">                    goto exit_function;</a>
<a name="ln455">                }</a>
<a name="ln456">            } else {</a>
<a name="ln457">                idelH2 = at[jn].neighbor[at[jn].neighbor[0]==nCumulene[len-1]];</a>
<a name="ln458">            }</a>
<a name="ln459">            if ( 0 &gt; (ret = set_cumulene_0D_parity( at, st, num_atoms, idelH1, jv, jn, idelH2, parity, len )) ) {</a>
<a name="ln460">                goto exit_function;</a>
<a name="ln461">            }</a>
<a name="ln462">        }</a>
<a name="ln463">        INCHI_HEAPCHK</a>
<a name="ln464">    }</a>
<a name="ln465">    /* allocate memory for Mobile-H-only stereo */</a>
<a name="ln466">    if ( num_stereo_centers2 + num_stereo_bonds2 ) {</a>
<a name="ln467">        if ( !(st = (inp_ATOM_STEREO *)inchi_calloc( num_atoms, sizeof(st[0])))) {</a>
<a name="ln468">            ret = RI_ERR_ALLOC;</a>
<a name="ln469">            goto exit_function;</a>
<a name="ln470">        }</a>
<a name="ln471">        CopyAt2St( at, st, num_atoms );</a>
<a name="ln472">    }</a>
<a name="ln473">    pStruct-&gt;st = st;</a>
<a name="ln474">    if ( num_stereo_centers2 ) {</a>
<a name="ln475">        /* In case of Fixed-H */</a>
<a name="ln476">        /* mark additional Mobile-H stereo centers, they have already been connected the added explicit H, if any */</a>
<a name="ln477">        int bInvertedParity   = (pStereo2-&gt;nCompInv2Abs == -1);</a>
<a name="ln478">        for ( i = 0; i &lt; pStereo2-&gt;nNumberOfStereoCenters; i ++ ) {</a>
<a name="ln479">            n_vertex = pStereo2-&gt;nNumber[i]-1;</a>
<a name="ln480">            parity   = pStereo2-&gt;t_parity[i];</a>
<a name="ln481">            if ( at[n_vertex].p_parity ) {</a>
<a name="ln482">                continue; /* the parity has already been set for Fixed-H */</a>
<a name="ln483">            }</a>
<a name="ln484">            if ( bInvertedParity ) {</a>
<a name="ln485">                parity = (parity == AB_PARITY_EVEN)? AB_PARITY_ODD : (parity == AB_PARITY_ODD)? AB_PARITY_EVEN : parity;</a>
<a name="ln486">            }</a>
<a name="ln487">            /* find whether it is allene */</a>
<a name="ln488">            if ( at[n_vertex].valence == 2 &amp;&amp;</a>
<a name="ln489">                 at[n_vertex].num_H   == 0 &amp;&amp;</a>
<a name="ln490">                 bCanAtomBeMiddleAllene(at[n_vertex].elname, 0, 0) &amp;&amp;</a>
<a name="ln491">                 /* allene has exactly 2 double bonds */</a>
<a name="ln492">                 (jv = at[n_vertex].neighbor[0], at[jv].valence + at[jv].num_H == 3) &amp;&amp;</a>
<a name="ln493">                 bCanAtomBeTerminalAllene(at[jv].elname, 0, 0)     &amp;&amp;</a>
<a name="ln494">                 (jn = at[n_vertex].neighbor[1], at[jn].valence + at[jn].num_H == 3) &amp;&amp;</a>
<a name="ln495">                 bCanAtomBeTerminalAllene(at[jn].elname, 0, 0) ) {</a>
<a name="ln496">                /* allene: add explicit H if implicit H are present */</a>
<a name="ln497">                /* iDeletedH = current number of already added explicit H */</a>
<a name="ln498">                /* idelH1    = index in at[] of the explicit H added to atom jv */</a>
<a name="ln499">                if ( at[jv].num_H ) {</a>
<a name="ln500">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, jv, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln501">                        goto exit_function;</a>
<a name="ln502">                    }</a>
<a name="ln503">                } else {</a>
<a name="ln504">                    /* index of the stereo atom neighbor */</a>
<a name="ln505">                    idelH1 = at[jv].neighbor[at[jv].neighbor[0]==n_vertex];</a>
<a name="ln506">                }</a>
<a name="ln507">                if ( at[jn].num_H ) {</a>
<a name="ln508">                    /* iDeletedH = current number of already added explicit H */</a>
<a name="ln509">                    /* idelH2    = index of the explicit H added to atom jn */</a>
<a name="ln510">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, jn, num_atoms, &amp;iDeletedH, &amp;idelH2, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln511">                        goto exit_function;</a>
<a name="ln512">                    }</a>
<a name="ln513">                } else {</a>
<a name="ln514">                    idelH2 = at[jn].neighbor[at[jn].neighbor[0]==n_vertex];</a>
<a name="ln515">                }</a>
<a name="ln516">                /* allene: set bond types to double */</a>
<a name="ln517">                /*</a>
<a name="ln518">                if ( 0 &gt; (ret = set_bond_type( at, (AT_NUMB)n_vertex, (AT_NUMB)jv, BOND_TYPE_DOUBLE ) ) ||</a>
<a name="ln519">                     0 &gt; (ret = set_bond_type( at, (AT_NUMB)n_vertex, (AT_NUMB)jn, BOND_TYPE_DOUBLE ) ) ) {</a>
<a name="ln520">                    goto exit_function;</a>
<a name="ln521">                }</a>
<a name="ln522">                */</a>
<a name="ln523">                /* allene: make 0D parity */</a>
<a name="ln524">                ret = set_cumulene_0D_parity( at, st, num_atoms, idelH1, jv, jn, idelH2, parity, 2 );</a>
<a name="ln525">                if ( ret &lt; 0 ) {</a>
<a name="ln526">                    goto exit_function;</a>
<a name="ln527">                }</a>
<a name="ln528">            } else {</a>
<a name="ln529">                /* stereogenic sp3 atom */</a>
<a name="ln530">                if ( at[n_vertex].num_H ) {</a>
<a name="ln531">                    if ( 0 &gt; (ret = AddExplicitDeletedH( at, n_vertex, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln532">                        goto exit_function;</a>
<a name="ln533">                    }</a>
<a name="ln534">                }</a>
<a name="ln535">                ret = set_atom_0D_parity( at, st, num_atoms, nNumDeletedH, n_vertex, parity );</a>
<a name="ln536">                if ( ret &lt; 0 ) {</a>
<a name="ln537">                    goto exit_function;</a>
<a name="ln538">                }</a>
<a name="ln539">                num_stereo_centers ++;</a>
<a name="ln540">            }</a>
<a name="ln541">            if ( ret &lt; 0 ) {</a>
<a name="ln542">                goto exit_function;</a>
<a name="ln543">            }</a>
<a name="ln544">        }</a>
<a name="ln545">    }</a>
<a name="ln546">    if ( num_stereo_bonds2 ) {</a>
<a name="ln547">        /* In case of Fixed-H */</a>
<a name="ln548">        /* mark additional Mobile-H stereobonds, they have already been connected the added explicit H, if any */</a>
<a name="ln549">        for ( i = 0; i &lt; pStereo2-&gt;nNumberOfStereoBonds; i ++ ) {</a>
<a name="ln550">            jv     = pStereo2-&gt;nBondAtom1[i]-1;</a>
<a name="ln551">            jn     = pStereo2-&gt;nBondAtom2[i]-1;</a>
<a name="ln552">            parity = pStereo2-&gt;b_parity[i];</a>
<a name="ln553">            if ( !is_in_the_list( at[jv].neighbor, (AT_NUMB)jn, at[jv].valence ) ) {</a>
<a name="ln554">                /* must be a cumulene */</a>
<a name="ln555">                if ( !bFindCumuleneChain( at, (AT_NUMB)jv, (AT_NUMB)jn, nCumulene, MAX_CUMULENE_LEN+1 ) ) {</a>
<a name="ln556">                    return RI_ERR_SYNTAX; /* not a cumulene */</a>
<a name="ln557">                }</a>
<a name="ln558">                len = MAX_CUMULENE_LEN+1;</a>
<a name="ln559">            } else {</a>
<a name="ln560">                /* a regular double or alt bond */</a>
<a name="ln561">                nCumulene[0] = jv;</a>
<a name="ln562">                nCumulene[1] = jn;</a>
<a name="ln563">                len = 1; /* cumulene length is number of bonds, not number of atoms */</a>
<a name="ln564">            }</a>
<a name="ln565">            /* cumulene or double bond: add explicit H if implicit H are present */</a>
<a name="ln566">            if ( at[jv].num_H ) {</a>
<a name="ln567">                if ( 0 &gt; (ret = AddExplicitDeletedH( at, jv, num_atoms, &amp;iDeletedH, &amp;idelH1, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln568">                    goto exit_function;</a>
<a name="ln569">                }</a>
<a name="ln570">            } else {</a>
<a name="ln571">                /* double bond neighbor that has the smallest canonical number */</a>
<a name="ln572">                idelH1 = at[jv].neighbor[at[jv].neighbor[0]==nCumulene[1]];</a>
<a name="ln573">            }</a>
<a name="ln574">            if ( at[jn].num_H ) {</a>
<a name="ln575">                if ( 0 &gt; (ret = AddExplicitDeletedH( at, jn, num_atoms, &amp;iDeletedH, &amp;idelH2, nNumDeletedH, pStereo2 != NULL ))) {</a>
<a name="ln576">                    goto exit_function;</a>
<a name="ln577">                }</a>
<a name="ln578">            } else {</a>
<a name="ln579">                idelH2 = at[jn].neighbor[at[jn].neighbor[0]==nCumulene[len-1]];</a>
<a name="ln580">            }</a>
<a name="ln581">            if ( 0 &gt; (ret = set_cumulene_0D_parity( at, st, num_atoms, idelH1, jv, jn, idelH2, parity, len )) ) {</a>
<a name="ln582">                goto exit_function;</a>
<a name="ln583">            }</a>
<a name="ln584">        }</a>
<a name="ln585"> </a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588"> </a>
<a name="ln589">    ret = num_atoms;</a>
<a name="ln590"> </a>
<a name="ln591">exit_function:</a>
<a name="ln592">    return ret;</a>
<a name="ln593">}</a>
<a name="ln594">/*************************************************************/</a>
<a name="ln595">int SetStereoBondTypeFor0DParity( inp_ATOM *at, int i1, int m1 )</a>
<a name="ln596">{</a>
<a name="ln597">    AT_NUMB nCumulene[MAX_CUMULENE_LEN+2];</a>
<a name="ln598">    int j, n1, n2, k1, m2, ret, nLenCumulene = 0, bond_type;</a>
<a name="ln599">    k1 = at[i1].sb_ord[m1];</a>
<a name="ln600">    n1 = i1;</a>
<a name="ln601">    nCumulene[nLenCumulene ++] = n1;</a>
<a name="ln602">    do {</a>
<a name="ln603">        n2 = at[n1].neighbor[k1]; /* next atom */</a>
<a name="ln604">        nCumulene[nLenCumulene ++] = n2;</a>
<a name="ln605">        for (m2 = 0; m2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[n2].sb_parity[m2]; m2 ++ ) {</a>
<a name="ln606">            if ( n1 == at[n2].neighbor[(int)at[n2].sb_ord[m2]] ) {</a>
<a name="ln607">                /* found the endatom */</a>
<a name="ln608">                goto found;</a>
<a name="ln609">            }</a>
<a name="ln610">        }</a>
<a name="ln611">        if ( at[n2].num_H || at[n2].valence != 2 || at[n2].endpoint ) {</a>
<a name="ln612">            break; /* not a middle cumulene */</a>
<a name="ln613">        }</a>
<a name="ln614">        k1 = (at[n2].neighbor[0] == n1);</a>
<a name="ln615">        n1 = n2;</a>
<a name="ln616">    } while ( at[n1].valence == 2 &amp;&amp; !at[n1].num_H &amp;&amp; nLenCumulene &lt; MAX_CUMULENE_LEN+2 &amp;&amp;</a>
<a name="ln617">              bCanAtomBeMiddleAllene( at[n1].elname, at[n1].charge, at[n1].radical ) );</a>
<a name="ln618">    return RI_ERR_SYNTAX; /* failed */</a>
<a name="ln619"> </a>
<a name="ln620">found:</a>
<a name="ln621">    if ( nLenCumulene == 2 ) {</a>
<a name="ln622">        bond_type = BOND_TYPE_STEREO; /* double bond or alternating bond */</a>
<a name="ln623">    } else {</a>
<a name="ln624">        bond_type = BOND_TYPE_DOUBLE; /* cumulene or allene */</a>
<a name="ln625">    }</a>
<a name="ln626"> </a>
<a name="ln627">    for ( j = 1; j &lt; nLenCumulene; j ++ ) {</a>
<a name="ln628">        /* if bond_type = BOND_TYPE_DOUBLE then increments at-&gt;cham_bonds_valence: */</a>
<a name="ln629">        /* at-&gt;cham_bonds_valence += BOND_TYPE_DOUBLE-BOND_TYPE_SINGLE */</a>
<a name="ln630">        if ( 0 &gt; (ret = set_bond_type( at, (AT_NUMB)nCumulene[j-1], (AT_NUMB)nCumulene[j], bond_type ) ) ) {</a>
<a name="ln631">            return RI_ERR_PROGR; /* failed */</a>
<a name="ln632">        }</a>
<a name="ln633">    }</a>
<a name="ln634">    return nLenCumulene;</a>
<a name="ln635">}</a>
<a name="ln636">/******************************************************************************************************/</a>
<a name="ln637">int SetStereoBondTypesFrom0DStereo( StrFromINChI *pStruct, INChI *pInChI)</a>
<a name="ln638">{</a>
<a name="ln639">    INChI_Stereo *pStereo;</a>
<a name="ln640">    inp_ATOM     *at        = pStruct-&gt;at;</a>
<a name="ln641">    int           num_atoms = pStruct-&gt;num_atoms;</a>
<a name="ln642">    int           i, j, num_stereo_bonds, ret; </a>
<a name="ln643"> </a>
<a name="ln644">    if ( pInChI-&gt;StereoIsotopic &amp;&amp; </a>
<a name="ln645">         (pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds +</a>
<a name="ln646">          pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln647">        pStereo = pInChI-&gt;StereoIsotopic;</a>
<a name="ln648">    } else</a>
<a name="ln649">    if ( pInChI-&gt;Stereo &amp;&amp; </a>
<a name="ln650">         (pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds +</a>
<a name="ln651">          pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln652">        pStereo = pInChI-&gt;Stereo;</a>
<a name="ln653">    } else {</a>
<a name="ln654">        pStereo = NULL;</a>
<a name="ln655">    }</a>
<a name="ln656">    </a>
<a name="ln657">    /************************ set bond types separately from stereo *******************/</a>
<a name="ln658">    if ( pStereo ) {</a>
<a name="ln659">        num_stereo_bonds = 0;</a>
<a name="ln660">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln661">            /* set BOND_TYPE_DOUBLE in allenes and cumulenes */</a>
<a name="ln662">            /* set BOND_TYPE_STEREO in double bond stereo */</a>
<a name="ln663">            for ( j = 0; j &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i].sb_parity[j]; j ++ ) {</a>
<a name="ln664">                num_stereo_bonds ++;</a>
<a name="ln665">                if ( 0 &gt; (ret = SetStereoBondTypeFor0DParity( at, i,  j ) ) ) {</a>
<a name="ln666">                    goto exit_function;</a>
<a name="ln667">                }</a>
<a name="ln668">            }</a>
<a name="ln669">        }</a>
<a name="ln670">        if ( num_stereo_bonds ) {</a>
<a name="ln671">            int num_bond_type_stereo;</a>
<a name="ln672">            int num_bond_type_altern;</a>
<a name="ln673">            AT_NUMB neigh;</a>
<a name="ln674">            /* replace adjacent BOND_TYPE_STEREO with BOND_TYPE_ALTERN */</a>
<a name="ln675">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln676">                num_bond_type_stereo = 0;</a>
<a name="ln677">                num_bond_type_altern = 0;</a>
<a name="ln678">                for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln679">                    num_bond_type_stereo += ( at[i].bond_type[j] == BOND_TYPE_STEREO );</a>
<a name="ln680">                    num_bond_type_altern += ( at[i].bond_type[j] == BOND_TYPE_ALTERN );</a>
<a name="ln681">                }</a>
<a name="ln682">                if ( num_bond_type_stereo + num_bond_type_altern &gt; 1 &amp;&amp; num_bond_type_stereo ) {</a>
<a name="ln683">                    for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln684">                        if  ( at[i].bond_type[j] == BOND_TYPE_STEREO ) {</a>
<a name="ln685">                            neigh = at[i].neighbor[j];</a>
<a name="ln686">                            /* does not change at[i].chem_bond_valence in case of BOND_TYPE_ALTERN */</a>
<a name="ln687">                            if ( 0 &gt; (ret = set_bond_type( at, (AT_NUMB)i, neigh, BOND_TYPE_ALTERN ) ) ) {</a>
<a name="ln688">                                goto exit_function;</a>
<a name="ln689">                            }</a>
<a name="ln690">                        }</a>
<a name="ln691">                    }</a>
<a name="ln692">                }</a>
<a name="ln693">                /* at this point only isolated stereo bonds have type BOND_TYPE_STEREO */</a>
<a name="ln694">            }</a>
<a name="ln695">            /* increment at[i].chem_bonds_valence if at[i] has an altern. bond */</a>
<a name="ln696">            /* replace BOND_TYPE_STEREO with BOND_TYPE_DOUBLE and increment   */</a>
<a name="ln697">            /* chem_bonds_valence of the adjacent atoms */</a>
<a name="ln698">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln699">                num_bond_type_stereo = 0;</a>
<a name="ln700">                num_bond_type_altern = 0;</a>
<a name="ln701">                for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln702">                    num_bond_type_stereo += ( at[i].bond_type[j] == BOND_TYPE_STEREO );</a>
<a name="ln703">                    num_bond_type_altern += ( at[i].bond_type[j] == BOND_TYPE_ALTERN );</a>
<a name="ln704">                }</a>
<a name="ln705">                if ( !num_bond_type_stereo &amp;&amp; num_bond_type_altern ) {</a>
<a name="ln706">                    /* an atom has only BOND_TYPE_ALTERN =&gt; adjacent BOND_TYPE_ALTERN case */</a>
<a name="ln707">                    at[i].chem_bonds_valence += 1;</a>
<a name="ln708">                } else</a>
<a name="ln709">                if ( num_bond_type_stereo == 1 ) {</a>
<a name="ln710">                    /* isolated BOND_TYPE_STEREO =&gt; replace with BOND_TYPE_DOUBLE */</a>
<a name="ln711">                    for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln712">                        if  ( at[i].bond_type[j] == BOND_TYPE_STEREO ) {</a>
<a name="ln713">                            neigh = at[i].neighbor[j];</a>
<a name="ln714">                            /* replacing BOND_TYPE_STEREO with BOND_TYPE_DOUBLE */</a>
<a name="ln715">                            /* does not change at-&gt;chem_bonds_valence */</a>
<a name="ln716">                            if ( 0 &gt; (ret = set_bond_type( at, (AT_NUMB)i, neigh, BOND_TYPE_DOUBLE ) ) ) {</a>
<a name="ln717">                                goto exit_function;</a>
<a name="ln718">                            }</a>
<a name="ln719">                            at[i].chem_bonds_valence ++;</a>
<a name="ln720">                            at[(int)neigh].chem_bonds_valence ++;</a>
<a name="ln721">                        }</a>
<a name="ln722">                    }</a>
<a name="ln723">                } else</a>
<a name="ln724">                if ( num_bond_type_stereo + num_bond_type_altern ) {</a>
<a name="ln725">                    /* an atom still has both BOND_TYPE_STEREO and BOND_TYPE_ALTERN */</a>
<a name="ln726">                    ret = RI_ERR_PROGR;</a>
<a name="ln727">                    goto exit_function;</a>
<a name="ln728">                }</a>
<a name="ln729">            }</a>
<a name="ln730">            INCHI_HEAPCHK</a>
<a name="ln731">        }</a>
<a name="ln732">    }</a>
<a name="ln733">    ret = 0; /* success */</a>
<a name="ln734">exit_function:</a>
<a name="ln735">    return ret;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">/******************************************************************************************************/</a>
<a name="ln739">int CopyBnsToAtom( StrFromINChI *pStruct, BN_STRUCT  *pBNS, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups, int bAllowZeroBondOrder )</a>
<a name="ln740">{</a>
<a name="ln741">    int i, j, atom_charge, left_charge, charge, ret = 0, v1, nMinorder;</a>
<a name="ln742">    int          num_at = pStruct-&gt;num_atoms;</a>
<a name="ln743">    inp_ATOM    *at     = pStruct-&gt;at;</a>
<a name="ln744">    ICHICONST SRM *pSrm = pStruct-&gt;pSrm;</a>
<a name="ln745">    BNS_VERTEX  *pv;</a>
<a name="ln746">    BNS_EDGE    *pe;</a>
<a name="ln747">    int          chem_bonds_valence, bond_order;</a>
<a name="ln748"> </a>
<a name="ln749">    atom_charge = left_charge = 0;</a>
<a name="ln750">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln751">        pv = pBNS-&gt;vert + i;</a>
<a name="ln752">        /* bonds */</a>
<a name="ln753">        chem_bonds_valence = 0;</a>
<a name="ln754">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln755">            pe = pBNS-&gt;edge + pv-&gt;iedge[j];</a>
<a name="ln756">            BondFlowMaxcapMinorder( at, pVA, pSrm, i, j, NULL, &amp;nMinorder, NULL );</a>
<a name="ln757">            bond_order = pe-&gt;flow + nMinorder;</a>
<a name="ln758">            if ( !bAllowZeroBondOrder &amp;&amp; !bond_order ) {</a>
<a name="ln759">                bond_order = 1;</a>
<a name="ln760">            }</a>
<a name="ln761">            chem_bonds_valence += bond_order;</a>
<a name="ln762">            at[i].bond_type[j]  = bond_order;  /* BOND_MARK_HIGHLIGHT */</a>
<a name="ln763">        }</a>
<a name="ln764">        at[i].chem_bonds_valence = chem_bonds_valence;</a>
<a name="ln765">        /* charges (both may be present resulting in zero) */</a>
<a name="ln766">        at[i].charge = pVA[i].cInitCharge;</a>
<a name="ln767">        if ( pVA[i].nCMinusGroupEdge ) {</a>
<a name="ln768">            pe = pBNS-&gt;edge + pVA[i].nCMinusGroupEdge - 1;</a>
<a name="ln769">            if ( (charge = pe-&gt;flow) ) {</a>
<a name="ln770">                at[i].charge  -= charge;</a>
<a name="ln771">                atom_charge   -= charge;</a>
<a name="ln772">            }</a>
<a name="ln773">        }</a>
<a name="ln774">        if ( pVA[i].nCPlusGroupEdge ) {</a>
<a name="ln775">            pe = pBNS-&gt;edge + pVA[i].nCPlusGroupEdge - 1;</a>
<a name="ln776">            if ( (charge = pe-&gt;cap - pe-&gt;flow) ) {</a>
<a name="ln777">                at[i].charge += charge;</a>
<a name="ln778">                atom_charge  += charge;</a>
<a name="ln779">            }</a>
<a name="ln780">        }</a>
<a name="ln781">        if ( pv-&gt;st_edge.cap &gt; pv-&gt;st_edge.flow ) {</a>
<a name="ln782">            at[i].radical = RADICAL_SINGLET + (pv-&gt;st_edge.cap - pv-&gt;st_edge.flow);</a>
<a name="ln783">        }</a>
<a name="ln784">    }</a>
<a name="ln785">    /* find charge excess */</a>
<a name="ln786">    for ( i = num_at; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln787">        pv = pBNS-&gt;vert + i;</a>
<a name="ln788">        if ( (charge = pv-&gt;st_edge.cap - pv-&gt;st_edge.flow) ) {</a>
<a name="ln789">            if ( IS_BNS_VT_C_OR_CSUPER_GR(pv-&gt;type) ) {</a>
<a name="ln790">                left_charge -= charge;</a>
<a name="ln791">            } else </a>
<a name="ln792">            if ( IS_BNS_VT_YVCONNECTOR(pv-&gt;type) ) {</a>
<a name="ln793">                left_charge += charge;</a>
<a name="ln794">            }</a>
<a name="ln795">        }</a>
<a name="ln796">    }</a>
<a name="ln797">    /* tautomeric H and (-) */</a>
<a name="ln798">    for ( i = 0; i &lt; pBNS-&gt;num_t_groups; i ++ ) {</a>
<a name="ln799">        /* tautomeric groups are first non-atom vertices;</a>
<a name="ln800">           order of them is same as in pTCGroups-&gt;pTCG[] */</a>
<a name="ln801">        int num_H       = pTCGroups-&gt;pTCG[i].tg_num_H;</a>
<a name="ln802">        int num_Minus   = pTCGroups-&gt;pTCG[i].tg_num_Minus;</a>
<a name="ln803">        int bMinusFirst = (pTCGroups-&gt;pTCG[i].tg_RestoreFlags &amp; TGRF_MINUS_FIRST);</a>
<a name="ln804">        int num_at_add;</a>
<a name="ln805">        Vertex vMinus = NO_VERTEX;</a>
<a name="ln806">        pv  = pBNS-&gt;vert + num_at + i;  /* t-group vertex */</a>
<a name="ln807">        if ( !(pv-&gt;type &amp; BNS_VERT_TYPE_TGROUP) ) {</a>
<a name="ln808">            return RI_ERR_PROGR;</a>
<a name="ln809">        }</a>
<a name="ln810">        if ( pTCGroups-&gt;pTCG[i].tg_set_Minus &gt; 0 &amp;&amp; num_Minus &gt; 0 ) {</a>
<a name="ln811">            vMinus = pTCGroups-&gt;pTCG[i].tg_set_Minus-1;</a>
<a name="ln812">            num_Minus --;</a>
<a name="ln813">        }</a>
<a name="ln814"> </a>
<a name="ln815">        if ( bMinusFirst ) {</a>
<a name="ln816">            for ( j = 0; j &lt; pv-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln817">                pe = pBNS-&gt;edge + pv-&gt;iedge[j];</a>
<a name="ln818">                v1 = pe-&gt;neighbor1;</a>
<a name="ln819">                num_at_add = pe-&gt;flow;</a>
<a name="ln820">                if ( v1 == vMinus ) {</a>
<a name="ln821">                    if ( num_at_add ) {</a>
<a name="ln822">                        at[v1].charge = -1;  /* no checking at[v1].charge == 0 for now ??? */</a>
<a name="ln823">                        num_at_add --;       /* no checking  num_at_add &gt; 0 for now ??? */</a>
<a name="ln824">                    } else {</a>
<a name="ln825">                        num_Minus ++;        /* error ??? */</a>
<a name="ln826">                    }</a>
<a name="ln827">                    vMinus = NO_VERTEX;</a>
<a name="ln828">                }</a>
<a name="ln829">                if ( num_at_add &gt; 0 ) {</a>
<a name="ln830">                    /* atom has tautomeric attachment; do not allow =N(-) */</a>
<a name="ln831">                    if ( num_Minus &amp;&amp; !at[v1].charge &amp;&amp;</a>
<a name="ln832">                         at[v1].valence == at[v1].chem_bonds_valence ) {</a>
<a name="ln833">                        at[v1].charge --;</a>
<a name="ln834">                        num_at_add --;</a>
<a name="ln835">                        num_Minus --;</a>
<a name="ln836">                    }</a>
<a name="ln837">                    if ( num_at_add &gt; 0 ) {</a>
<a name="ln838">                        at[v1].num_H += num_at_add;</a>
<a name="ln839">                        num_H -= num_at_add;</a>
<a name="ln840">                        num_at_add = 0;</a>
<a name="ln841">                    }</a>
<a name="ln842">                }</a>
<a name="ln843">                at[v1].endpoint = i+1;</a>
<a name="ln844">            }</a>
<a name="ln845">            if ( (num_H+num_Minus != pv-&gt;st_edge.cap - pv-&gt;st_edge.flow) &amp;&amp; (num_H || num_Minus || vMinus != NO_VERTEX) ) {</a>
<a name="ln846">                return RI_ERR_PROGR;</a>
<a name="ln847">            }</a>
<a name="ln848">        } else {</a>
<a name="ln849">            for ( j = pv-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln850">                pe = pBNS-&gt;edge + pv-&gt;iedge[j];</a>
<a name="ln851">                v1 = pe-&gt;neighbor1;</a>
<a name="ln852">                num_at_add = pe-&gt;flow;</a>
<a name="ln853">                if ( v1 == vMinus ) {</a>
<a name="ln854">                    if ( num_at_add ) {</a>
<a name="ln855">                        at[v1].charge = -1;  /* no checking at[v1].charge == 0 for now ??? */</a>
<a name="ln856">                        num_at_add --;       /* no checking  num_at_add &gt; 0 for now ??? */</a>
<a name="ln857">                    } else {</a>
<a name="ln858">                        num_Minus ++;        /* error ??? */</a>
<a name="ln859">                    }</a>
<a name="ln860">                    vMinus = NO_VERTEX;</a>
<a name="ln861">                }</a>
<a name="ln862">                if ( num_at_add &gt; 0 ) {</a>
<a name="ln863">                    /* atom has tautomeric attachment; do not allow =N(-) */</a>
<a name="ln864">                    if ( num_Minus &amp;&amp; !at[v1].charge &amp;&amp;</a>
<a name="ln865">                         at[v1].valence == at[v1].chem_bonds_valence ) {</a>
<a name="ln866">                        at[v1].charge --;</a>
<a name="ln867">                        num_at_add --;</a>
<a name="ln868">                        num_Minus --;</a>
<a name="ln869">                    }</a>
<a name="ln870">                    if ( num_at_add &gt; 0 ) {</a>
<a name="ln871">                        at[v1].num_H += num_at_add;</a>
<a name="ln872">                        num_H -= num_at_add;</a>
<a name="ln873">                        num_at_add = 0;</a>
<a name="ln874">                    }</a>
<a name="ln875">                }</a>
<a name="ln876">                at[v1].endpoint = i+1;</a>
<a name="ln877">            }</a>
<a name="ln878">            if ( (num_H+num_Minus != pv-&gt;st_edge.cap - pv-&gt;st_edge.flow) &amp;&amp; (num_H || num_Minus || vMinus != NO_VERTEX) ) {</a>
<a name="ln879">                return RI_ERR_PROGR;</a>
<a name="ln880">            }</a>
<a name="ln881">        }</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">    return ret;</a>
<a name="ln885">}</a>
<a name="ln886">/******************************************************************************************************/</a>
<a name="ln887">int CheckBnsConsistency( StrFromINChI *pStruct, BN_STRUCT  *pBNS, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups, int bNoRad )</a>
<a name="ln888">{</a>
<a name="ln889">    int nOutput = 0;</a>
<a name="ln890">#ifndef TARGET_API_LIB</a>
<a name="ln891">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln892">    char s[128];</a>
<a name="ln893">    int i, j, atom_charge, left_charge, charge, excess_charge, ret = 0;</a>
<a name="ln894">    int v1, v2, flow, tot_st_flow, tot_st_cap, num_electrons, nNumMetalAtoms;</a>
<a name="ln895">    int       num_at = pStruct-&gt;num_atoms;</a>
<a name="ln896">    inp_ATOM *at     = pStruct-&gt;at;</a>
<a name="ln897">    BNS_VERTEX  *pv;</a>
<a name="ln898">    BNS_EDGE    *pe;</a>
<a name="ln899">#ifdef _DEBUG</a>
<a name="ln900">    int       bDebugOutput = 0;</a>
<a name="ln901">    bNoRad = 1;</a>
<a name="ln902">    bDebugOutput = 1;</a>
<a name="ln903">#endif</a>
<a name="ln904">    /* count electrons and metals */</a>
<a name="ln905">    num_electrons = -pTCGroups-&gt;total_charge;</a>
<a name="ln906">    nNumMetalAtoms = 0;</a>
<a name="ln907">    for ( i = 0; i &lt; pTCGroups-&gt;num_tgroups; i ++ ) {</a>
<a name="ln908">        num_electrons += pTCGroups-&gt;pTCG[i].tg_num_H;</a>
<a name="ln909">    }</a>
<a name="ln910">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln911">        num_electrons += at[i].el_number + at[i].num_H;</a>
<a name="ln912">        nNumMetalAtoms += pVA[i].cMetal;</a>
<a name="ln913">    }</a>
<a name="ln914">    /* create output string */</a>
<a name="ln915">    sprintf( s, &quot;%d:%d%sM%02dv%da%de%db%d* &quot;,</a>
<a name="ln916">                bNoRad, pTCGroups-&gt;iComponent+1, num_electrons%2?&quot;O&quot;:&quot;E&quot;, nNumMetalAtoms,</a>
<a name="ln917">                pBNS-&gt;num_vertices, num_at, pBNS-&gt;num_edges, pBNS-&gt;num_bonds );</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920">    tot_st_flow = tot_st_cap = 0;</a>
<a name="ln921">    atom_charge = left_charge = 0;</a>
<a name="ln922">    if ( pBNS-&gt;num_atoms != num_at ) {</a>
<a name="ln923">        fprintf( stdout, &quot;\n%sNum. atoms discrepancy: %d(BNS) vs. %d(at) &quot;, s, pBNS-&gt;num_atoms, num_at);</a>
<a name="ln924">        nOutput ++;</a>
<a name="ln925">    }</a>
<a name="ln926">    /* check edges */</a>
<a name="ln927">#ifdef _DEBUG</a>
<a name="ln928">    if ( bDebugOutput &amp;&amp; bNoRad ) {</a>
<a name="ln929">        fprintf( stderr, &quot;\n\n------begin------------------------------------------------\n&quot; );</a>
<a name="ln930">        fprintf( stderr, &quot;\n\fedge    cap       flow     v1   v2\n\n&quot; );</a>
<a name="ln931">        /*                  xxxx xxxx/xxxx xxxx/xxxx xxxx xxxx    */</a>
<a name="ln932">    }</a>
<a name="ln933">#endif</a>
<a name="ln934">    for ( i = 0; i &lt; pBNS-&gt;num_edges; i ++ ) {</a>
<a name="ln935">        pe = pBNS-&gt;edge + i;</a>
<a name="ln936">        v1 = pe-&gt;neighbor1;</a>
<a name="ln937">        v2 = v1 ^ pe-&gt;neighbor12;</a>
<a name="ln938">        if ( pe-&gt;cap &lt; pe-&gt;flow || pe-&gt;flow &lt; 0 ) {</a>
<a name="ln939">            fprintf( stdout, &quot;\n%sedge %d (%d-%d) has cap=%d flow=%d  &quot;, s, i, v1, v2, pe-&gt;cap, pe-&gt;flow );</a>
<a name="ln940">            nOutput ++;</a>
<a name="ln941">        }</a>
<a name="ln942">#ifdef _DEBUG</a>
<a name="ln943">        if ( bDebugOutput &amp;&amp; bNoRad ) {</a>
<a name="ln944">            /*                xxxx  xxxx/xxxx xxxx/xxxx xxxx xxxx    */</a>
<a name="ln945">            fprintf( stderr, &quot;%4d %4d/%-4d %4d/%-4d %4d %4d\n&quot;, i, pe-&gt;cap, pe-&gt;cap0, pe-&gt;flow, pe-&gt;flow0, v1, v2 ); </a>
<a name="ln946">        }</a>
<a name="ln947">#endif</a>
<a name="ln948">    }</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">    /* check vertices */</a>
<a name="ln952">#ifdef _DEBUG</a>
<a name="ln953">    if ( bDebugOutput &amp;&amp; bNoRad ) {</a>
<a name="ln954">        fprintf( stderr, &quot;\n\fvert   st-cap   st-flow   type iedge : neigh\n\n&quot; );</a>
<a name="ln955">        /*                   xxxx xxxx/xxxx xxxx/xxxx 0xXXX xxxx : xxx    */</a>
<a name="ln956">    }</a>
<a name="ln957">#endif</a>
<a name="ln958">    for ( i = 0; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln959">        pv = pBNS-&gt;vert + i;</a>
<a name="ln960">#ifdef _DEBUG</a>
<a name="ln961">        if ( bDebugOutput &amp;&amp; bNoRad ) {</a>
<a name="ln962">            /*                   xxxx xxxx/xxxx xxxx/xxxx 0xXXX xxxx : xxx    */</a>
<a name="ln963">            int j;</a>
<a name="ln964">            const char *s;</a>
<a name="ln965">            char sAtom[6];</a>
<a name="ln966">            switch( pv-&gt;type ) {</a>
<a name="ln967">            case BNS_VERT_TYPE_ATOM:</a>
<a name="ln968">                sprintf( sAtom, &quot;At %-2.2s&quot;, i &lt; num_at? at[i].elname : &quot;??&quot; );</a>
<a name="ln969">                s = sAtom;</a>
<a name="ln970">                break;</a>
<a name="ln971">            case BNS_VERT_TYPE_ATOM | BNS_VERT_TYPE_ENDPOINT:</a>
<a name="ln972">                s = &quot;Endpt&quot;;</a>
<a name="ln973">                break;</a>
<a name="ln974">            case BNS_VT_C_POS:</a>
<a name="ln975">                s = &quot;(+)  &quot;;</a>
<a name="ln976">                break;</a>
<a name="ln977">            case BNS_VT_C_NEG:</a>
<a name="ln978">                s = &quot;(-)  &quot;;</a>
<a name="ln979">                break;</a>
<a name="ln980">            case BNS_VT_C_POS_C:</a>
<a name="ln981">                s = &quot;(+C) &quot;;</a>
<a name="ln982">                break;</a>
<a name="ln983">            case BNS_VT_C_NEG_C:</a>
<a name="ln984">                s = &quot;(-C) &quot;;</a>
<a name="ln985">                break;</a>
<a name="ln986">            case BNS_VT_C_POS_M:</a>
<a name="ln987">                s = &quot;(+M) &quot;;</a>
<a name="ln988">                break;</a>
<a name="ln989">            case BNS_VT_C_NEG_M:</a>
<a name="ln990">                s = &quot;(-M) &quot;;</a>
<a name="ln991">                break;</a>
<a name="ln992">            case BNS_VT_C_POS_ALL:</a>
<a name="ln993">                s = &quot;(+)Sg&quot;;</a>
<a name="ln994">                break;</a>
<a name="ln995">            case BNS_VT_C_NEG_ALL:</a>
<a name="ln996">                s = &quot;(-)Sg&quot;;</a>
<a name="ln997">                break;</a>
<a name="ln998">            case BNS_VT_M_GROUP:</a>
<a name="ln999">                s = &quot;M-grp&quot;;</a>
<a name="ln1000">                break;</a>
<a name="ln1001">            case BNS_VERT_TYPE__AUX | BNS_VERT_TYPE_TEMP:</a>
<a name="ln1002">                s = &quot;ChStr&quot;;</a>
<a name="ln1003">                break;</a>
<a name="ln1004">            case BNS_VERT_TYPE__AUX:</a>
<a name="ln1005">                s = &quot;Yconn&quot;;</a>
<a name="ln1006">                break;</a>
<a name="ln1007">            case BNS_VERT_TYPE_TGROUP:</a>
<a name="ln1008">                s = &quot;T-grp&quot;;</a>
<a name="ln1009">                break;</a>
<a name="ln1010">            default:</a>
<a name="ln1011">                s = &quot;Unkn.&quot;;</a>
<a name="ln1012">                break;</a>
<a name="ln1013">            }</a>
<a name="ln1014">            fprintf( stderr,    &quot;%4d %4d/%-4d %4d/%-4d 0x%03X %5s&quot;,</a>
<a name="ln1015">                                i, pv-&gt;st_edge.cap, pv-&gt;st_edge.cap0, pv-&gt;st_edge.flow, pv-&gt;st_edge.flow0,</a>
<a name="ln1016">                                pv-&gt;type, s );</a>
<a name="ln1017">            for ( j = 0; j &lt; pv-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln1018">                fprintf( stderr, &quot; %2d&quot;, pv-&gt;iedge[j] );</a>
<a name="ln1019">            }</a>
<a name="ln1020">            fprintf( stderr, &quot;:&quot; );</a>
<a name="ln1021">            for ( j = 0; j &lt; pv-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln1022">                pe = pBNS-&gt;edge + pv-&gt;iedge[j];</a>
<a name="ln1023">                fprintf( stderr, &quot; %2d&quot;, pe-&gt;neighbor12 ^ i );</a>
<a name="ln1024">            }</a>
<a name="ln1025">            fprintf( stderr, &quot;\n&quot; );</a>
<a name="ln1026">        }</a>
<a name="ln1027">#endif</a>
<a name="ln1028">        tot_st_flow += pv-&gt;st_edge.flow;</a>
<a name="ln1029">        tot_st_cap  += pv-&gt;st_edge.cap;</a>
<a name="ln1030">        if ( pv-&gt;num_adj_edges &gt; pv-&gt;max_adj_edges ) {</a>
<a name="ln1031">            fprintf( stdout, &quot;\n%s%s %d type 0x%X \&quot;%s\&quot; num_edges=%d &gt; max=%d  &quot;, s,</a>
<a name="ln1032">                i &lt; num_at? &quot;atom&quot;:&quot;vertex&quot;, i,</a>
<a name="ln1033">                pv-&gt;type, at[i].elname, pv-&gt;num_adj_edges, pv-&gt;max_adj_edges );</a>
<a name="ln1034">            nOutput ++;</a>
<a name="ln1035">        }</a>
<a name="ln1036">        if ( i &lt; num_at ) {</a>
<a name="ln1037">            /* charge on atoms */</a>
<a name="ln1038">            charge = pVA[i].cInitCharge;</a>
<a name="ln1039">            if ( pVA[i].nCMinusGroupEdge ) {</a>
<a name="ln1040">                pe = pBNS-&gt;edge + pVA[i].nCMinusGroupEdge - 1;</a>
<a name="ln1041">                if ( pe-&gt;flow &gt; 0 ) {</a>
<a name="ln1042">                    charge   -= pe-&gt;flow;</a>
<a name="ln1043">                }</a>
<a name="ln1044">            }</a>
<a name="ln1045">            if ( pVA[i].nCPlusGroupEdge ) {</a>
<a name="ln1046">                pe = pBNS-&gt;edge + pVA[i].nCPlusGroupEdge - 1;</a>
<a name="ln1047">                if ( pe-&gt;cap &gt; pe-&gt;flow  ) {</a>
<a name="ln1048">                    charge  += pe-&gt;cap - pe-&gt;flow;</a>
<a name="ln1049">                }</a>
<a name="ln1050">            }</a>
<a name="ln1051">            if ( bNoRad &amp;&amp; pv-&gt;st_edge.flow != pv-&gt;st_edge.cap ) {</a>
<a name="ln1052">                fprintf( stdout, &quot;\n%s%s %d: type 0x%X \&quot;%s\&quot; unexpected st_cap=%d st_flow=%d &quot;, s,</a>
<a name="ln1053">                    i &lt; num_at? &quot;atom&quot;:&quot;vertex&quot;, i,</a>
<a name="ln1054">                    pv-&gt;type, at[i].elname, pv-&gt;st_edge.cap, pv-&gt;st_edge.flow );</a>
<a name="ln1055">                nOutput ++;</a>
<a name="ln1056">            } else</a>
<a name="ln1057">            if ( bNoRad &amp;&amp; charge &amp;&amp; !strcmp(at[i].elname, &quot;C&quot;) ) {</a>
<a name="ln1058">                /* ignore carbonyls */</a>
<a name="ln1059">                if ( i == 0 &amp;&amp; num_at == 2 &amp;&amp; !strcmp(at[1].elname, &quot;O&quot;) &amp;&amp;</a>
<a name="ln1060">                     !at[0].num_H &amp;&amp; !at[1].num_H &amp;&amp; !pTCGroups-&gt;total_charge) {</a>
<a name="ln1061">                    ; /* C(-)#O(+) structure */</a>
<a name="ln1062">                } else {</a>
<a name="ln1063">                    fprintf( stdout, &quot;\n%s%s %d: type 0x%X \&quot;%s\&quot; charge=%d &quot;, s,</a>
<a name="ln1064">                        i &lt; num_at? &quot;atom&quot;:&quot;vertex&quot;, i,</a>
<a name="ln1065">                        pv-&gt;type, at[i].elname, charge );</a>
<a name="ln1066">                    nOutput ++;</a>
<a name="ln1067">                }</a>
<a name="ln1068">            }</a>
<a name="ln1069">            atom_charge += charge;</a>
<a name="ln1070">        } else</a>
<a name="ln1071">        if ( (charge = pv-&gt;st_edge.cap - pv-&gt;st_edge.flow) &gt; 0 ) {</a>
<a name="ln1072">            /* excess charge */</a>
<a name="ln1073">            if ( !bNoRad &amp;&amp; IS_BNS_VT_C_OR_CSUPER_GR(pv-&gt;type) ) {</a>
<a name="ln1074">                left_charge -= charge;</a>
<a name="ln1075">            } else </a>
<a name="ln1076">            if ( !bNoRad &amp;&amp; IS_BNS_VT_YVCONNECTOR(pv-&gt;type) ) {</a>
<a name="ln1077">                left_charge += charge;</a>
<a name="ln1078">            } else</a>
<a name="ln1079">            if ( !bNoRad &amp;&amp; IS_BNS_VT_M_GR(pv-&gt;type) &amp;&amp;</a>
<a name="ln1080">                 0 &lt;= (j=pTCGroups-&gt;nGroup[TCG_MeFlower3]) &amp;&amp; </a>
<a name="ln1081">                 i == pTCGroups-&gt;pTCG[j].nVertexNumber ) {</a>
<a name="ln1082">                ; /* additional &quot;radical&quot; on metal flower */</a>
<a name="ln1083">            } else</a>
<a name="ln1084">            if ( !(pv-&gt;type &amp; BNS_VERT_TYPE_TGROUP) || bNoRad ) {</a>
<a name="ln1085">                /* t-groups before running BFS should have st_cap &gt; st_flow */</a>
<a name="ln1086">                fprintf( stdout, &quot;\n%s%s %d: type 0x%X unexpected st_cap=%d st_flow=%d &quot;, s,</a>
<a name="ln1087">                    i &lt; num_at? &quot;atom&quot;:&quot;vertex&quot;, i,</a>
<a name="ln1088">                    pv-&gt;type, pv-&gt;st_edge.cap, pv-&gt;st_edge.flow);</a>
<a name="ln1089">                nOutput ++;</a>
<a name="ln1090">            }</a>
<a name="ln1091">        }</a>
<a name="ln1092">        if ( pv-&gt;st_edge.cap &lt; pv-&gt;st_edge.flow || pv-&gt;st_edge.flow &lt; 0 ) {</a>
<a name="ln1093">            fprintf( stdout, &quot;\n%s%s %d: type 0x%X \&quot;%s\&quot; st_cap=%d st_flow=%d  &quot;, s,</a>
<a name="ln1094">                i &lt; num_at? &quot;atom&quot;:&quot;vertex&quot;, i,</a>
<a name="ln1095">                pv-&gt;type, i &lt; num_at? at[i].elname:&quot;&quot;, pv-&gt;st_edge.cap, pv-&gt;st_edge.flow );</a>
<a name="ln1096">            nOutput ++;</a>
<a name="ln1097">        }</a>
<a name="ln1098">        /* check edge_flow vs. st_flow consistency */</a>
<a name="ln1099">        for( j = 0, flow = 0; j &lt; pv-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln1100">            pe = pBNS-&gt;edge + pv-&gt;iedge[j];</a>
<a name="ln1101">            flow += pe-&gt;flow;</a>
<a name="ln1102">        }</a>
<a name="ln1103">        if ( flow != pv-&gt;st_edge.flow ) {</a>
<a name="ln1104">            fprintf( stdout, &quot;\n%s%s %d: type 0x%X \&quot;%s\&quot; st_flow=%d edge_flow=%d  &quot;, s,</a>
<a name="ln1105">                i &lt; num_at? &quot;atom&quot;:&quot;vertex&quot;, i,</a>
<a name="ln1106">                pv-&gt;type, i &lt; num_at? at[i].elname:&quot;&quot;, pv-&gt;st_edge.flow, flow );</a>
<a name="ln1107">            nOutput ++;</a>
<a name="ln1108">        }</a>
<a name="ln1109">    }</a>
<a name="ln1110">#ifdef _DEBUG</a>
<a name="ln1111">    if ( bDebugOutput &amp;&amp; bNoRad ) {</a>
<a name="ln1112">        fprintf( stderr, &quot;\n------end--------------------------------------------------\n&quot; );</a>
<a name="ln1113">    }</a>
<a name="ln1114">#endif</a>
<a name="ln1115">    /*</a>
<a name="ln1116">    if ( num_electrons %= 2 ) {</a>
<a name="ln1117">        fprintf( stdout, &quot;\n%d*Odd number of electrons (%d atoms) &quot;, bNoRad, num_at );</a>
<a name="ln1118">        nOutput ++;</a>
<a name="ln1119">    }</a>
<a name="ln1120">    */</a>
<a name="ln1121">    /* tautomeric groups charge */</a>
<a name="ln1122">    for ( i = 0, charge = 0; i &lt; pTCGroups-&gt;num_tgroups; i ++ ) {</a>
<a name="ln1123">        charge -= pTCGroups-&gt;pTCG[i].tg_num_Minus;</a>
<a name="ln1124">    }</a>
<a name="ln1125">    /* compare */</a>
<a name="ln1126">    if ( charge != pTCGroups-&gt;tgroup_charge ) {</a>
<a name="ln1127">        fprintf( stdout, &quot;\n%sCounted t-group charge=%d while %d was saved  &quot;, s,</a>
<a name="ln1128">               charge, pTCGroups-&gt;tgroup_charge);</a>
<a name="ln1129">        nOutput ++;</a>
<a name="ln1130">    }</a>
<a name="ln1131">    /* add other charges */</a>
<a name="ln1132">    charge += atom_charge + left_charge;</a>
<a name="ln1133">    excess_charge = pTCGroups-&gt;total_charge - pTCGroups-&gt;added_charge - pTCGroups-&gt;tgroup_charge;</a>
<a name="ln1134">    if ( charge != pTCGroups-&gt;total_charge &amp;&amp; excess_charge != pTCGroups-&gt;total_charge - charge ) {</a>
<a name="ln1135">        fprintf( stdout, &quot;\n%sCounted total charge=%d while %d was saved; excess charge=%d  &quot;, s,</a>
<a name="ln1136">            charge, pTCGroups-&gt;total_charge, excess_charge );</a>
<a name="ln1137">        nOutput ++;</a>
<a name="ln1138">    }</a>
<a name="ln1139">    if ( tot_st_cap != pBNS-&gt;tot_st_cap || tot_st_flow != pBNS-&gt;tot_st_flow ) {</a>
<a name="ln1140">        fprintf( stdout, &quot;\n%sCounted/saved total st_flow=%d/%d st_cap=%d/%d  &quot;, s,</a>
<a name="ln1141">            tot_st_flow, pBNS-&gt;tot_st_flow, tot_st_cap, pBNS-&gt;tot_st_cap );</a>
<a name="ln1142">        nOutput ++;</a>
<a name="ln1143">    }</a>
<a name="ln1144">    if ( nOutput ) {</a>
<a name="ln1145">        fprintf( stdout, &quot;\n&quot; );</a>
<a name="ln1146">    }</a>
<a name="ln1147">#endif</a>
<a name="ln1148">#endif</a>
<a name="ln1149">    return nOutput;</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">/******************************************************************************************************/</a>
<a name="ln1153">int AddExplicitDeletedH( inp_ATOM *at, int jv, int num_at, int *iDeletedH, int *iH, int nNumDeletedH, int bTwoStereo )</a>
<a name="ln1154">{</a>
<a name="ln1155">    inp_ATOM  *cur_H, *cur_at = at+jv;</a>
<a name="ln1156">    int        tot_num_iso_H = NUM_ISO_H(cur_at, 0);</a>
<a name="ln1157">    int        num_H     = cur_at-&gt;num_H;</a>
<a name="ln1158">    int        iso_H     = 0;</a>
<a name="ln1159">    S_CHAR     num_iso_H[NUM_H_ISOTOPES];</a>
<a name="ln1160">    int        i;</a>
<a name="ln1161"> </a>
<a name="ln1162">    if ( !at[jv].at_type ) {</a>
<a name="ln1163">        return RI_ERR_PROGR;</a>
<a name="ln1164">    }</a>
<a name="ln1165"> </a>
<a name="ln1166">    if ( at[jv].at_type &gt; 1 ) {</a>
<a name="ln1167">        /* explicit hydrogens have already been added; find them */</a>
<a name="ln1168">        for ( i = 0; i &lt; *iDeletedH; i ++ ) {</a>
<a name="ln1169">            if ( at[num_at + i].neighbor[0] == jv ) {</a>
<a name="ln1170">                *iH = num_at + i; /* return the first found H, it has the smallest canonical pseudo rank */</a>
<a name="ln1171">                return 0;</a>
<a name="ln1172">            }</a>
<a name="ln1173">        }</a>
<a name="ln1174">        return RI_ERR_PROGR;</a>
<a name="ln1175">    }</a>
<a name="ln1176">    /* add all explicit H disconnected from at[jv] in order H, 1H, D, T */</a>
<a name="ln1177">    *iH = *iDeletedH + num_at; /* num_H includes all H, both isotopic and normal */</a>
<a name="ln1178">    for ( i = 0; i &lt; NUM_H_ISOTOPES; i ++ ) {</a>
<a name="ln1179">        num_iso_H[i] = at[jv].num_iso_H[i];</a>
<a name="ln1180">    }</a>
<a name="ln1181">    for ( ; num_H &amp;&amp; (*iDeletedH) &lt; nNumDeletedH; (*iDeletedH) ++ ) {</a>
<a name="ln1182">        cur_H = at + num_at + (*iDeletedH); /* first available empty atom will be this explicit H */</a>
<a name="ln1183">        cur_H-&gt;neighbor[cur_H-&gt;valence] = jv; /* connect this new atom H to the real atom */</a>
<a name="ln1184">        cur_H-&gt;bond_type[cur_H-&gt;valence] = BOND_TYPE_SINGLE;</a>
<a name="ln1185">        cur_H-&gt;valence ++;</a>
<a name="ln1186">        if ( num_H &gt; tot_num_iso_H ) {</a>
<a name="ln1187">            num_H --;</a>
<a name="ln1188">            if ( num_H != tot_num_iso_H ) {</a>
<a name="ln1189">                /* may happen when Mobile-H stereo included in Fixed-H processing */</a>
<a name="ln1190">                if ( bTwoStereo ) {</a>
<a name="ln1191">                    continue;</a>
<a name="ln1192">                } else {</a>
<a name="ln1193">                    return RI_ERR_SYNTAX; /* two identical H neighbors of a stereo atom/bond */</a>
<a name="ln1194">                }</a>
<a name="ln1195">            }</a>
<a name="ln1196">        } else {</a>
<a name="ln1197">            while ( iso_H &lt; NUM_H_ISOTOPES &amp;&amp; !num_iso_H[iso_H] )</a>
<a name="ln1198">                iso_H ++;</a>
<a name="ln1199">            if ( iso_H &lt; NUM_H_ISOTOPES ) {</a>
<a name="ln1200">                cur_H-&gt;iso_atw_diff = iso_H + 1; /* isotopic shift + 1 */</a>
<a name="ln1201">                num_H --;</a>
<a name="ln1202">                tot_num_iso_H --;</a>
<a name="ln1203">                num_iso_H[iso_H] --;</a>
<a name="ln1204">                if ( num_iso_H[iso_H] ) {</a>
<a name="ln1205">                    return RI_ERR_SYNTAX; /* two identical isotopic H neighbors of a stereo atom/bond */</a>
<a name="ln1206">                }</a>
<a name="ln1207">            } else {</a>
<a name="ln1208">                return RI_ERR_SYNTAX; /* not enough isotopic H */</a>
<a name="ln1209">            }</a>
<a name="ln1210">        }</a>
<a name="ln1211">    }</a>
<a name="ln1212">    if ( num_H ) {</a>
<a name="ln1213">        return RI_ERR_SYNTAX;</a>
<a name="ln1214">    }</a>
<a name="ln1215">    at[jv].at_type ++; /* at[jv].at_type==2 =&gt; explicit hydrogens have already been added */</a>
<a name="ln1216">    return 0; /* success */    </a>
<a name="ln1217">}</a>
<a name="ln1218">/******************************************************************************************************/</a>
<a name="ln1219">int bFindCumuleneChain( inp_ATOM *at, AT_NUMB i1, AT_NUMB i2, AT_NUMB nCumulene[], int nMaxLen )</a>
<a name="ln1220">/* nMaxLen = number of bonds in cumulene = 3 = MAX_CUMULENE_LEN+1 */</a>
<a name="ln1221">/* nCumulene[nMaxLen+1] will contain cumulene chain &gt;i1=x=y=i2&lt; in this order */</a>
<a name="ln1222">{</a>
<a name="ln1223">    int i, len, iat, nat;</a>
<a name="ln1224">    nCumulene[0] = i1;</a>
<a name="ln1225">    for ( i = 0; i &lt; at[i1].valence; i ++ ) {</a>
<a name="ln1226">        len = 0;</a>
<a name="ln1227">        iat = i1; /* current */</a>
<a name="ln1228">        nat = at[i1].neighbor[i]; /* next */</a>
<a name="ln1229">        if ( len+1 == nMaxLen ) {</a>
<a name="ln1230">            if ( nat == i2 ) {</a>
<a name="ln1231">                nCumulene[++len] = nat;</a>
<a name="ln1232">                return 1; /* success */</a>
<a name="ln1233">            }</a>
<a name="ln1234">            continue; /* check next at[i1] neighbor */</a>
<a name="ln1235">        }</a>
<a name="ln1236">        while ( at[nat].valence == 2 &amp;&amp;</a>
<a name="ln1237">                at[nat].num_H   == 0 &amp;&amp;</a>
<a name="ln1238">                bCanAtomBeMiddleAllene(at[nat].elname, 0, 0) ) {</a>
<a name="ln1239">            nCumulene[++len] = nat;</a>
<a name="ln1240">            nat = at[nat].neighbor[at[nat].neighbor[0]==iat]; /* new next */</a>
<a name="ln1241">            if ( len+1 == nMaxLen ) {</a>
<a name="ln1242">                if ( nat == i2 ) {</a>
<a name="ln1243">                    nCumulene[++len] = nat;</a>
<a name="ln1244">                    return 1; /* success */</a>
<a name="ln1245">                }</a>
<a name="ln1246">                break; /* check next at[i1] neighbor */</a>
<a name="ln1247">            }</a>
<a name="ln1248">            iat = nCumulene[len]; /* new current */</a>
<a name="ln1249">        }</a>
<a name="ln1250">    }</a>
<a name="ln1251">    return 0; /* failed */</a>
<a name="ln1252">}</a>
<a name="ln1253">/******************************************************************************************************/</a>
<a name="ln1254">int set_bond_type( inp_ATOM *at, AT_NUMB i1, AT_NUMB i2, int bType )</a>
<a name="ln1255">{</a>
<a name="ln1256">    AT_NUMB *p1 = is_in_the_list( at[i1].neighbor, i2, at[i1].valence );</a>
<a name="ln1257">    AT_NUMB *p2 = is_in_the_list( at[i2].neighbor, i1, at[i2].valence );</a>
<a name="ln1258">    if ( p1 &amp;&amp; p2 ) {</a>
<a name="ln1259">        int j1 = p1 - at[i1].neighbor;</a>
<a name="ln1260">        int j2 = p2 - at[i2].neighbor;</a>
<a name="ln1261">        int bTypePrev = at[i1].bond_type[j1];</a>
<a name="ln1262">        at[i1].bond_type[j1] = bType;</a>
<a name="ln1263">        at[i2].bond_type[j2] = bType;</a>
<a name="ln1264">        if ( bTypePrev &amp;&amp; bTypePrev &lt;= BOND_TYPE_TRIPLE &amp;&amp;</a>
<a name="ln1265">             bType     &amp;&amp; bType     &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1266">            at[i1].chem_bonds_valence += bType - bTypePrev;</a>
<a name="ln1267">            at[i2].chem_bonds_valence += bType - bTypePrev;</a>
<a name="ln1268">        }</a>
<a name="ln1269">        return 0;</a>
<a name="ln1270">    }</a>
<a name="ln1271">    return RI_ERR_SYNTAX;</a>
<a name="ln1272">}</a>
<a name="ln1273">/******************************************************************************************************/</a>
<a name="ln1274">int set_cumulene_0D_parity( inp_ATOM *at, inp_ATOM_STEREO *st, int num_at, int idelH1, int i1, int i2, int idelH2, int parity, int len )</a>
<a name="ln1275">{</a>
<a name="ln1276">    AT_NUMB nCumulene[MAX_CUMULENE_LEN+2];</a>
<a name="ln1277">    AT_NUMB *p1, *p2;</a>
<a name="ln1278">    int     m1, m2, parity1, parity2, sb_ord_m1, sb_ord_m2, k1, k2, num_neigh1, num_neigh2;</a>
<a name="ln1279">    /* the following types must exactly match types in inp_ATOM and inp_ATOM_STEREO */</a>
<a name="ln1280">    S_CHAR  *sb_ord1, *sn_ord1, *sb_parity1;</a>
<a name="ln1281">    S_CHAR  *sb_ord2, *sn_ord2, *sb_parity2;</a>
<a name="ln1282">    AT_NUMB *sn_orig_at_num1;</a>
<a name="ln1283">    AT_NUMB *sn_orig_at_num2;</a>
<a name="ln1284"> </a>
<a name="ln1285"> </a>
<a name="ln1286">    if ( !bFindCumuleneChain( at, (AT_NUMB)i1, (AT_NUMB)i2, nCumulene, len ) ) {</a>
<a name="ln1287">        return RI_ERR_SYNTAX; /* not an allene */</a>
<a name="ln1288">    }</a>
<a name="ln1289">    /* stereo bond neighbors: index of a stereo bond in its end-atom adjacency lists */</a>
<a name="ln1290">    if ( (p1 = is_in_the_list( at[i1].neighbor, nCumulene[1], at[i1].valence )) &amp;&amp;</a>
<a name="ln1291">         (p2 = is_in_the_list( at[i2].neighbor, nCumulene[len-1], at[i2].valence )) ) {</a>
<a name="ln1292">        sb_ord_m1 = p1 - at[i1].neighbor; /* indes of stereobond in the atom's adjacency list */</a>
<a name="ln1293">        sb_ord_m2 = p2 - at[i2].neighbor;</a>
<a name="ln1294">    } else {</a>
<a name="ln1295">        return RI_ERR_PROGR;</a>
<a name="ln1296">    }</a>
<a name="ln1297">    num_neigh1 = at[i1].valence + at[i1].num_H;</a>
<a name="ln1298">    num_neigh2 = at[i2].valence + at[i2].num_H;</a>
<a name="ln1299"> </a>
<a name="ln1300">    if ( num_neigh1 &lt; MIN_NUM_STEREO_BOND_NEIGH || num_neigh1 &gt; MAX_NUM_STEREO_BOND_NEIGH ||</a>
<a name="ln1301">         num_neigh2 &lt; MIN_NUM_STEREO_BOND_NEIGH || num_neigh2 &gt; MAX_NUM_STEREO_BOND_NEIGH ) {</a>
<a name="ln1302">        return RI_ERR_SYNTAX;</a>
<a name="ln1303">    }</a>
<a name="ln1304"> </a>
<a name="ln1305"> </a>
<a name="ln1306">    sb_ord1    = st? st[i1].sb_ord : at[i1].sb_ord;</a>
<a name="ln1307">    sb_ord2    = st? st[i2].sb_ord : at[i2].sb_ord;</a>
<a name="ln1308">    sb_parity1 = st? st[i1].sb_parity : at[i1].sb_parity;</a>
<a name="ln1309">    sb_parity2 = st? st[i2].sb_parity : at[i2].sb_parity;</a>
<a name="ln1310"> </a>
<a name="ln1311">    /* find the first unoccupied locations in the stereobond 0D descriptor lists; check whether the stereo has already been set */</a>
<a name="ln1312">    for( m1 = k1 = 0; m1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; sb_parity1[m1] &amp;&amp; !(k1 = sb_ord1[m1] == sb_ord_m1); m1 ++ )</a>
<a name="ln1313">        ;</a>
<a name="ln1314">    for( m2 = k2 = 0; m2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; sb_parity2[m2] &amp;&amp; !(k2 = sb_ord2[m2] == sb_ord_m2); m2 ++ )</a>
<a name="ln1315">        ;</a>
<a name="ln1316">    if ( m1 == MAX_NUM_STEREO_BONDS || m2 == MAX_NUM_STEREO_BONDS ) {</a>
<a name="ln1317">        return RI_ERR_SYNTAX;</a>
<a name="ln1318">    }</a>
<a name="ln1319">    if ( k1 &amp;&amp; k2 ) {</a>
<a name="ln1320">        return 0; /* the stereo descriptor of this bond/allene/cumulene has already been set */</a>
<a name="ln1321">    }</a>
<a name="ln1322">    if ( k1 || k2 ) {</a>
<a name="ln1323">        return RI_ERR_SYNTAX; /* only half of a bond was set */</a>
<a name="ln1324">    }</a>
<a name="ln1325"> </a>
<a name="ln1326">    sn_ord1    = st? st[i1].sn_ord : at[i1].sn_ord;</a>
<a name="ln1327">    sn_ord2    = st? st[i2].sn_ord : at[i2].sn_ord;</a>
<a name="ln1328">    sn_orig_at_num1 = st? st[i1].sn_orig_at_num : at[i1].sn_orig_at_num;</a>
<a name="ln1329">    sn_orig_at_num2 = st? st[i2].sn_orig_at_num : at[i2].sn_orig_at_num;</a>
<a name="ln1330"> </a>
<a name="ln1331">    /* stereo bond neighbors connection index */</a>
<a name="ln1332">    sb_ord1[m1] = sb_ord_m1;</a>
<a name="ln1333">    sb_ord2[m2] = sb_ord_m2;</a>
<a name="ln1334">    /* stereo bond end atom neighbors */</a>
<a name="ln1335">    sn_orig_at_num1[m1] = at[idelH1].orig_at_number;</a>
<a name="ln1336">    if ( idelH1 &lt; num_at ) {</a>
<a name="ln1337">        if ( (p1 = is_in_the_list( at[i1].neighbor, (AT_NUMB)idelH1, at[i1].valence )) ) {</a>
<a name="ln1338">            sn_ord1[m1] = p1 - at[i1].neighbor;</a>
<a name="ln1339">        } else {</a>
<a name="ln1340">            return RI_ERR_PROGR;</a>
<a name="ln1341">        }</a>
<a name="ln1342">    } else {</a>
<a name="ln1343">        sn_ord1[m1] = -1;</a>
<a name="ln1344">    }</a>
<a name="ln1345">    </a>
<a name="ln1346">    sn_orig_at_num2[m2] = at[idelH2].orig_at_number;</a>
<a name="ln1347">    if ( idelH2 &lt; num_at ) {</a>
<a name="ln1348">        if ( (p2 = is_in_the_list( at[i2].neighbor, (AT_NUMB)idelH2, at[i2].valence )) ) {</a>
<a name="ln1349">            sn_ord2[m2] = p2 - at[i2].neighbor;</a>
<a name="ln1350">        } else {</a>
<a name="ln1351">            return RI_ERR_PROGR;</a>
<a name="ln1352">        }</a>
<a name="ln1353">    } else {</a>
<a name="ln1354">        sn_ord2[m2] = -1;</a>
<a name="ln1355">    }</a>
<a name="ln1356">    if ( ATOM_PARITY_WELL_DEF(parity) ) {</a>
<a name="ln1357">        /* special case: 2 bonds to sb atom =&gt; inverse parity because */</a>
<a name="ln1358">        /* InChI parity refers to the lone pair as a neighbor */</a>
<a name="ln1359">        int num_inv = (num_neigh1 == MIN_NUM_STEREO_BOND_NEIGH) + (num_neigh2 == MIN_NUM_STEREO_BOND_NEIGH);</a>
<a name="ln1360">        if ( num_inv % 2 ) {</a>
<a name="ln1361">            parity = (parity == AB_PARITY_EVEN)? AB_PARITY_ODD : AB_PARITY_EVEN;</a>
<a name="ln1362">        }</a>
<a name="ln1363">        parity1 = AB_PARITY_EVEN;</a>
<a name="ln1364">        parity2 = (parity == AB_PARITY_EVEN)? AB_PARITY_EVEN : AB_PARITY_ODD;</a>
<a name="ln1365">    } else {</a>
<a name="ln1366">        parity1 = parity2 = parity;</a>
<a name="ln1367">    }</a>
<a name="ln1368">    sb_parity1[m1] = parity1;</a>
<a name="ln1369">    sb_parity2[m2] = parity2;</a>
<a name="ln1370"> </a>
<a name="ln1371">    return 0;</a>
<a name="ln1372">}</a>
<a name="ln1373">/******************************************************************************************************/</a>
<a name="ln1374">int set_atom_0D_parity( inp_ATOM *at, inp_ATOM_STEREO *st, int num_at, int num_deleted_H, int i1, int parity )</a>
<a name="ln1375">{</a>
<a name="ln1376">    int     m1=0, m2, i, j, tot_num_neigh;</a>
<a name="ln1377">    /* the following types must exactly match types in inp_ATOM and inp_ATOM_STEREO */</a>
<a name="ln1378">    /* Given parity from InChI, the order of stereo center neighbors is: */</a>
<a name="ln1379">    /* 1. The stereocenter itself if the total number of neighbors is 3 (not 4) */</a>
<a name="ln1380">    /* 2. Explicit H: non-isotopic, isotopic in order ofascending  atomic mass */</a>
<a name="ln1381">    /*         Explicit H have already been sorted in this order */</a>
<a name="ln1382">    /* 3. Normal neighboring atoms, atom numbers (=canonical numbers from InChI - 1) in ascending order */</a>
<a name="ln1383">    /*         Normal neighboring atoms have already been sorted in this order */</a>
<a name="ln1384">    S_CHAR  *p_parity;</a>
<a name="ln1385">    AT_NUMB *p_orig_at_num;</a>
<a name="ln1386"> </a>
<a name="ln1387">    if ( !st || !at[i1].p_parity ) {</a>
<a name="ln1388">        m1            = 0;</a>
<a name="ln1389">        p_parity      = st? &amp;st[i1].p_parity : &amp;at[i1].p_parity;</a>
<a name="ln1390">        p_orig_at_num = st? st[i1].p_orig_at_num : at[i1].p_orig_at_num;</a>
<a name="ln1391"> </a>
<a name="ln1392">        tot_num_neigh = at[i1].valence + at[i1].num_H;</a>
<a name="ln1393">        if ( tot_num_neigh == MAX_NUM_STEREO_ATOM_NEIGH-1 ) {</a>
<a name="ln1394">            /* only 3 neighbors: the atom itself is the first neighbor */</a>
<a name="ln1395">            p_orig_at_num[m1 ++] = at[i1].orig_at_number;</a>
<a name="ln1396">        } else</a>
<a name="ln1397">        if ( tot_num_neigh != MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln1398">            return RI_ERR_PROGR; /* wrong number of members */</a>
<a name="ln1399">        }</a>
<a name="ln1400">        m2 = m1 + (MAX_NUM_STEREO_ATOM_NEIGH - at[i1].valence);</a>
<a name="ln1401">        /* stereoneighbors: deleted explicit atoms H first, in order of increasing isotopic mass */</a>
<a name="ln1402">        if ( at[i1].num_H ) {</a>
<a name="ln1403">            for ( j = 0; m1 &lt; m2 &amp;&amp; j &lt; num_deleted_H; j ++ ) {</a>
<a name="ln1404">                if ( at[j + num_at].neighbor[0] == i1 ) {</a>
<a name="ln1405">                    p_orig_at_num[m1 ++] = at[j + num_at].orig_at_number;</a>
<a name="ln1406">                }</a>
<a name="ln1407">            }</a>
<a name="ln1408">        }</a>
<a name="ln1409">        if ( m1 + at[i1].valence != MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln1410">            return RI_ERR_PROGR; /* wrong number of members */</a>
<a name="ln1411">        }</a>
<a name="ln1412">        /* stereoneighbors: other than explicit H atoms */</a>
<a name="ln1413">        for ( i = 0; i &lt; at[i1].valence; i ++ ) {</a>
<a name="ln1414">            m2 = at[i1].neighbor[i];</a>
<a name="ln1415">            p_orig_at_num[m1 ++] = at[m2].orig_at_number;</a>
<a name="ln1416">        }</a>
<a name="ln1417">        *p_parity = parity;</a>
<a name="ln1418">    }</a>
<a name="ln1419"> </a>
<a name="ln1420">    return 0;</a>
<a name="ln1421">}</a>
<a name="ln1422">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln1423">/******************************************************************************************************/</a>
<a name="ln1424">int MoveRadToAtomsAddCharges( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln1425">                    inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups, int forbidden_mask )</a>
<a name="ln1426">{</a>
<a name="ln1427">    int nNumRad, ret = 0, ret2;</a>
<a name="ln1428">    int i, j, k, num_rad_not_atom, num_moved=0, num_candidates= 0, extra_charge=0, added_charge, delta;</a>
<a name="ln1429">    BNS_EDGE   *pEdge;</a>
<a name="ln1430">    BNS_VERTEX *pv;</a>
<a name="ln1431">    Vertex      v1, v2;</a>
<a name="ln1432">    S_SHORT    *pnRad = NULL, *pnDelta = NULL;</a>
<a name="ln1433">    CC_CAND    *pCand = NULL;</a>
<a name="ln1434">    int         cnBits, bAtomRadRemoved = 0;</a>
<a name="ln1435"> </a>
<a name="ln1436">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln1437">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln1438">    int len_at = num_at + num_deleted_H;</a>
<a name="ln1439"> </a>
<a name="ln1440">    for ( i = pBNS-&gt;num_atoms, num_rad_not_atom=0; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln1441">        num_rad_not_atom += pBNS-&gt;vert[i].st_edge.cap - pBNS-&gt;vert[i].st_edge.flow;</a>
<a name="ln1442">    }</a>
<a name="ln1443">    if ( !num_rad_not_atom ) {</a>
<a name="ln1444">        goto exit_function;</a>
<a name="ln1445">    }</a>
<a name="ln1446">    /****************************************************/</a>
<a name="ln1447">    /*                                                  */</a>
<a name="ln1448">    /*    Move radicals from ChargeStruct to atoms      */</a>
<a name="ln1449">    /*                                                  */</a>
<a name="ln1450">    /****************************************************/</a>
<a name="ln1451">    </a>
<a name="ln1452">    /* allocate memory to keep track of moved radicals */</a>
<a name="ln1453">    pnRad   = (S_SHORT *) inchi_malloc(pBNS-&gt;num_vertices * sizeof(pnRad[0]));</a>
<a name="ln1454">    pnDelta = (S_SHORT *)inchi_calloc(pBNS-&gt;num_atoms, sizeof(pnDelta[0]));</a>
<a name="ln1455">    if ( !pnRad || !pnDelta ) {</a>
<a name="ln1456">        ret = RI_ERR_ALLOC;</a>
<a name="ln1457">        goto exit_function;</a>
<a name="ln1458">    }</a>
<a name="ln1459">    for ( i = 0; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln1460">        pnRad[i] = pBNS-&gt;vert[i].st_edge.cap - pBNS-&gt;vert[i].st_edge.flow;</a>
<a name="ln1461">    }</a>
<a name="ln1462">    while( 1 ) {</a>
<a name="ln1463">        /* remove radicals from atoms */</a>
<a name="ln1464">        for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln1465">            pnDelta[i] = pBNS-&gt;vert[i].st_edge.cap - pBNS-&gt;vert[i].st_edge.flow;</a>
<a name="ln1466">            pBNS-&gt;vert[i].st_edge.cap -= pnDelta[i];</a>
<a name="ln1467">            bAtomRadRemoved += (0 != pnDelta[i]);</a>
<a name="ln1468">        }</a>
<a name="ln1469">        ret = SetRadEndpoints( pBNS, pBD, RAD_SRCH_FROM_FICT );</a>
<a name="ln1470">        if ( !ret ) {</a>
<a name="ln1471">            break;</a>
<a name="ln1472">        }</a>
<a name="ln1473">        if ( ret &lt; 0 ) {</a>
<a name="ln1474">            goto exit_function;</a>
<a name="ln1475">        }</a>
<a name="ln1476">        nNumRad = ret;</a>
<a name="ln1477">        for ( i = 0; i &lt; nNumRad; i ++ ) {</a>
<a name="ln1478">            pEdge = pBNS-&gt;edge + pBD-&gt;RadEdges[i];</a>
<a name="ln1479">            v1 = pEdge-&gt;neighbor1;</a>
<a name="ln1480">            v2 = pEdge-&gt;neighbor12 ^ v1;</a>
<a name="ln1481">            pBNS-&gt;vert[v1].st_edge.flow -=   pEdge-&gt;flow;</a>
<a name="ln1482">            pBNS-&gt;vert[v2].st_edge.flow -=   pEdge-&gt;flow;</a>
<a name="ln1483">            pBNS-&gt;tot_st_flow           -= 2*pEdge-&gt;flow;</a>
<a name="ln1484">            pEdge-&gt;flow                  = 0;</a>
<a name="ln1485">            pEdge-&gt;forbidden |= forbidden_mask;</a>
<a name="ln1486">            pBNS-&gt;edge_forbidden_mask |= forbidden_mask;</a>
<a name="ln1487">        }</a>
<a name="ln1488">        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1489">        if ( ret &lt; 0 ) {</a>
<a name="ln1490">            goto exit_function;</a>
<a name="ln1491">        } else {</a>
<a name="ln1492">            num_moved += ret;</a>
<a name="ln1493">        }</a>
<a name="ln1494">        RemoveRadEndpoints( pBNS, pBD, NULL );</a>
<a name="ln1495">        if ( ret == 0 ) {</a>
<a name="ln1496">            break;  /* could not move more radicals */</a>
<a name="ln1497">        }</a>
<a name="ln1498">        if ( bAtomRadRemoved ) {</a>
<a name="ln1499">            /* restore radicals to atoms */</a>
<a name="ln1500">            for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln1501">                pBNS-&gt;vert[i].st_edge.cap += pnDelta[i];</a>
<a name="ln1502">            }</a>
<a name="ln1503">            bAtomRadRemoved = 0;</a>
<a name="ln1504">        }</a>
<a name="ln1505">    }</a>
<a name="ln1506">    if ( bAtomRadRemoved ) {</a>
<a name="ln1507">        /* restore radicals to atoms */</a>
<a name="ln1508">        for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln1509">            pBNS-&gt;vert[i].st_edge.cap += pnDelta[i];</a>
<a name="ln1510">        }</a>
<a name="ln1511">        bAtomRadRemoved = 0;</a>
<a name="ln1512">    }</a>
<a name="ln1513">    pBNS-&gt;edge_forbidden_mask &amp;= ~forbidden_mask;</a>
<a name="ln1514"> </a>
<a name="ln1515"> </a>
<a name="ln1516">    /****************************************************/</a>
<a name="ln1517">    /*                                                  */</a>
<a name="ln1518">    /*    Fix the charges                               */</a>
<a name="ln1519">    /*                                                  */</a>
<a name="ln1520">    /****************************************************/</a>
<a name="ln1521">    if ( num_moved ) {</a>
<a name="ln1522">        /* find reqired charge */</a>
<a name="ln1523">        extra_charge = 0;</a>
<a name="ln1524">        for ( i = pBNS-&gt;num_atoms, pv=pBNS-&gt;vert+i; i &lt; pBNS-&gt;num_vertices; i ++, pv++ ) {</a>
<a name="ln1525">            if ( (delta = pv-&gt;st_edge.cap - pv-&gt;st_edge.flow) ) {</a>
<a name="ln1526">                if ( IS_BNS_VT_C_OR_CSUPER_GR(pv-&gt;type) ) {</a>
<a name="ln1527">                    extra_charge -= delta;</a>
<a name="ln1528">                } else</a>
<a name="ln1529">                if ( BNS_VERT_TYPE__AUX == pv-&gt;type ) {</a>
<a name="ln1530">                    extra_charge += delta;</a>
<a name="ln1531">                } else {</a>
<a name="ln1532">                    ret = RI_ERR_PROGR;</a>
<a name="ln1533">                    goto exit_function;</a>
<a name="ln1534">                }</a>
<a name="ln1535">            }</a>
<a name="ln1536">        }</a>
<a name="ln1537">        if ( !extra_charge ) {</a>
<a name="ln1538">            goto exit_function;</a>
<a name="ln1539">        }</a>
<a name="ln1540">        /* find differences */</a>
<a name="ln1541">        num_candidates = 0;</a>
<a name="ln1542">        for ( i = 0; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln1543">            pnRad[i] = (pBNS-&gt;vert[i].st_edge.cap - pBNS-&gt;vert[i].st_edge.flow) - pnRad[i];</a>
<a name="ln1544">            if ( i &lt; pBNS-&gt;num_atoms &amp;&amp; pnRad[i] &gt; 0 &amp;&amp; !pVA[i].nTautGroupEdge ) {</a>
<a name="ln1545">                num_candidates ++;</a>
<a name="ln1546">            }</a>
<a name="ln1547">        }</a>
<a name="ln1548">    }</a>
<a name="ln1549">    if ( num_candidates &gt; 0 ) {</a>
<a name="ln1550">        pCand = (CC_CAND *)inchi_calloc( num_candidates, sizeof(pCand[0]) );</a>
<a name="ln1551">        if ( !pCand ) {</a>
<a name="ln1552">            ret = RI_ERR_ALLOC;</a>
<a name="ln1553">            goto exit_function;</a>
<a name="ln1554">        }</a>
<a name="ln1555">        /* create atom */</a>
<a name="ln1556">        memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln1557">        pStruct-&gt;at = at2;</a>
<a name="ln1558">        ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln1559">        pStruct-&gt;at = at;</a>
<a name="ln1560">        if ( ret2 &lt; 0 ) {</a>
<a name="ln1561">            ret = ret2;</a>
<a name="ln1562">            goto exit_function;</a>
<a name="ln1563">        }</a>
<a name="ln1564"> </a>
<a name="ln1565">        for ( i = 0, j = 0; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln1566">            if ( i &lt; pBNS-&gt;num_atoms &amp;&amp; pnRad[i] &gt; 0 &amp;&amp; !pVA[i].nTautGroupEdge ) {</a>
<a name="ln1567">                pCand[j].iat                  = i;</a>
<a name="ln1568">                pCand[j].num_bonds            = at2[i].valence;</a>
<a name="ln1569">                pCand[j].chem_valence         = at2[i].chem_bonds_valence;</a>
<a name="ln1570">                pCand[j].cMetal               = pVA[i].cMetal;</a>
<a name="ln1571">                pCand[j].cNumBondsToMetal     = pVA[i].cNumBondsToMetal;</a>
<a name="ln1572">                pCand[j].cNumValenceElectrons = pVA[i].cNumValenceElectrons;</a>
<a name="ln1573">                pCand[j].cPeriodicRowNumber   = pVA[i].cPeriodicRowNumber;</a>
<a name="ln1574">                pCand[j].el_number            = at2[i].el_number;</a>
<a name="ln1575">                cnBits = (pVA[i].cnListIndex &gt; 0)? cnList[pVA[i].cnListIndex-1].bits : 0;</a>
<a name="ln1576">                while ( cnBits &gt; 0 ) {</a>
<a name="ln1577">                    pCand[j].cNumChargeStates ++;</a>
<a name="ln1578">                    cnBits &gt;&gt;= cn_bits_shift;</a>
<a name="ln1579">                }</a>
<a name="ln1580">                j ++;</a>
<a name="ln1581">            }</a>
<a name="ln1582">        }</a>
<a name="ln1583">        if ( j &gt; 1 ) {</a>
<a name="ln1584">            qsort( pCand, j, sizeof(pCand[0]), comp_cc_cand );</a>
<a name="ln1585">        }</a>
<a name="ln1586">        added_charge = 0;</a>
<a name="ln1587">        </a>
<a name="ln1588">        for ( k = 0; k &lt; j; k ++ ) {</a>
<a name="ln1589">            int rest_of_charge = extra_charge - added_charge;</a>
<a name="ln1590">            int charge_per_left_atom = (abs(rest_of_charge) + j-k - 1)/(j-k);</a>
<a name="ln1591">            int this_atom_add_charge = rest_of_charge &gt; 0? charge_per_left_atom : -charge_per_left_atom;</a>
<a name="ln1592">            pVA[pCand[k].iat].cInitCharge += this_atom_add_charge;</a>
<a name="ln1593">            added_charge                  += this_atom_add_charge;</a>
<a name="ln1594">            if ( this_atom_add_charge ) {</a>
<a name="ln1595">                for ( i = pBNS-&gt;num_vertices-1, pv = pBNS-&gt;vert + i; this_atom_add_charge &amp;&amp; pBNS-&gt;num_atoms &lt;= i; i --, pv -- ) {</a>
<a name="ln1596">                    if ( (delta = pv-&gt;st_edge.cap - pv-&gt;st_edge.flow) ) {</a>
<a name="ln1597">                        if ( this_atom_add_charge &lt; 0 &amp;&amp; IS_BNS_VT_C_OR_CSUPER_GR(pv-&gt;type) ) {</a>
<a name="ln1598">                            if ( delta + this_atom_add_charge &gt; 0 ) {</a>
<a name="ln1599">                                delta = -this_atom_add_charge;</a>
<a name="ln1600">                            }</a>
<a name="ln1601">                            pv-&gt;st_edge.cap      -= delta;</a>
<a name="ln1602">                            pBNS-&gt;tot_st_cap     -= delta;</a>
<a name="ln1603">                            this_atom_add_charge += delta;</a>
<a name="ln1604">                        } else</a>
<a name="ln1605">                        if ( this_atom_add_charge &gt; 0 &amp;&amp; BNS_VERT_TYPE__AUX == pv-&gt;type ) {</a>
<a name="ln1606">                            if ( delta &gt; this_atom_add_charge ) {</a>
<a name="ln1607">                                delta = this_atom_add_charge;</a>
<a name="ln1608">                            }</a>
<a name="ln1609">                            pv-&gt;st_edge.cap      -= delta;</a>
<a name="ln1610">                            pBNS-&gt;tot_st_cap     -= delta;</a>
<a name="ln1611">                            this_atom_add_charge -= delta;</a>
<a name="ln1612">                        }</a>
<a name="ln1613">                    }  </a>
<a name="ln1614">                }</a>
<a name="ln1615">            }</a>
<a name="ln1616">        }</a>
<a name="ln1617">    }</a>
<a name="ln1618"> </a>
<a name="ln1619">exit_function:</a>
<a name="ln1620">    if ( pnRad ) {</a>
<a name="ln1621">        inchi_free( pnRad );</a>
<a name="ln1622">    }</a>
<a name="ln1623">    if ( pnDelta ) {</a>
<a name="ln1624">        inchi_free( pnDelta );</a>
<a name="ln1625">    }</a>
<a name="ln1626">    if ( pCand ) {</a>
<a name="ln1627">        inchi_free( pCand );</a>
<a name="ln1628">    }</a>
<a name="ln1629">    return ret;</a>
<a name="ln1630">}</a>
<a name="ln1631">#endif</a>
<a name="ln1632">/**************************************************************************************************/</a>
<a name="ln1633">typedef struct tagMobileHGroups {</a>
<a name="ln1634">    AT_NUMB group_number;</a>
<a name="ln1635">    AT_NUMB atom_number;</a>
<a name="ln1636">    AT_NUMB atom_type_pVA;</a>
<a name="ln1637">    S_CHAR  ineigh;</a>
<a name="ln1638">    S_CHAR  bond_type;</a>
<a name="ln1639">    S_CHAR  forbidden;</a>
<a name="ln1640">   /* S_CHAR  el_type;*/</a>
<a name="ln1641">    S_CHAR  endpoint_valence;</a>
<a name="ln1642">    S_CHAR  num_bonds;</a>
<a name="ln1643">    S_CHAR  bonds_valence;</a>
<a name="ln1644">    S_CHAR  num_bonds_non_metal;</a>
<a name="ln1645">    S_CHAR  bonds_valence_non_metal;</a>
<a name="ln1646"> </a>
<a name="ln1647">} MOBILE_GR;</a>
<a name="ln1648"> </a>
<a name="ln1649">typedef struct tagMobileGroupList {</a>
<a name="ln1650">    AT_NUMB group_number;</a>
<a name="ln1651">    AT_NUMB num;</a>
<a name="ln1652">} MGROUPS;</a>
<a name="ln1653">/**************************************************************************************************/</a>
<a name="ln1654">int AdjustTgroupsToForbiddenEdges2( BN_STRUCT *pBNS, inp_ATOM *at, VAL_AT *pVA,</a>
<a name="ln1655">                                    int num_atoms, int forbidden_mask )</a>
<a name="ln1656">{</a>
<a name="ln1657">    int i, j, k;</a>
<a name="ln1658">    int centerpoint_type, neigh_type;</a>
<a name="ln1659">    int num_changes;</a>
<a name="ln1660">    int num_donors, num_acceptors, num_donor_endpoints, num_acceptor_endpoints;</a>
<a name="ln1661">    int neigh, tg_number, num_eql_mobile_gr, num_dif_mobile_gr, bond_type, has_mobile_H, has_mobile;</a>
<a name="ln1662">    int num_forbidden, ind_forbidden, forbidden, num_N, num_O, num_P, num_S, num_OSt;</a>
<a name="ln1663">    int val, delta_val, delta_met, num_bonds_non_metal, bonds_valence_non_metal;</a>
<a name="ln1664">    int num_bonds, bonds_valence;</a>
<a name="ln1665">    int inv_forbidden_mask = ~forbidden_mask;</a>
<a name="ln1666">    MOBILE_GR MobileGr[MAXVAL];</a>
<a name="ln1667">    int       num_endpoints;</a>
<a name="ln1668">    MGROUPS   MGroups[MAXVAL];</a>
<a name="ln1669">    int       num_mgroups, num_diff_t_groups;</a>
<a name="ln1670">    BNS_EDGE   *e, *e1, *e2, *ev, *ev1, *ev2;</a>
<a name="ln1671">    BNS_VERTEX *pv1, *pv2;</a>
<a name="ln1672">    num_changes = 0;</a>
<a name="ln1673">    /* search for possible centerpoints */</a>
<a name="ln1674">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1675">        </a>
<a name="ln1676">        if ( at[i].chem_bonds_valence == at[i].valence || at[i].num_H ||</a>
<a name="ln1677">             at[i].endpoint || at[i].charge || at[i].radical ||</a>
<a name="ln1678">             !is_centerpoint_elem(at[i].el_number) ||</a>
<a name="ln1679">             !(centerpoint_type = get_pVA_atom_type( pVA, at, i, 0 )) ||</a>
<a name="ln1680">             2 &gt; (delta_val = at[i].chem_bonds_valence - (val = get_el_valence(at[i].el_number, 0, 0))) ||</a>
<a name="ln1681">             2 &gt; (delta_met = (bonds_valence_non_metal = nNoMetalBondsValence(at, i)) - val )</a>
<a name="ln1682">           ) {</a>
<a name="ln1683">            continue;</a>
<a name="ln1684">        }</a>
<a name="ln1685">        </a>
<a name="ln1686">        num_donors = num_acceptors = num_donor_endpoints = num_acceptor_endpoints = 0;</a>
<a name="ln1687">        num_mgroups = num_endpoints = num_diff_t_groups = 0;</a>
<a name="ln1688">        has_mobile = has_mobile_H = num_eql_mobile_gr = num_dif_mobile_gr = tg_number = 0;</a>
<a name="ln1689">        ind_forbidden = -1;</a>
<a name="ln1690">        num_forbidden = 0;</a>
<a name="ln1691">        num_N = num_O = num_P = num_S = num_OSt = 0;</a>
<a name="ln1692">        num_bonds_non_metal = nNoMetalNumBonds(at, i);</a>
<a name="ln1693">        bonds_valence = at[i].chem_bonds_valence;</a>
<a name="ln1694">        num_bonds     = at[i].valence;</a>
<a name="ln1695"> </a>
<a name="ln1696">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1697">            /* collect neighbors info */</a>
<a name="ln1698">            neigh      = at[i].neighbor[j];</a>
<a name="ln1699">            val        = get_endpoint_valence( at[neigh].el_number );</a>
<a name="ln1700">            forbidden  = pBNS-&gt;edge[(int)pBNS-&gt;vert[i].iedge[j]].forbidden;</a>
<a name="ln1701">            bond_type = (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln1702">            neigh_type = get_pVA_atom_type( pVA, at, neigh, bond_type);</a>
<a name="ln1703">            if ( !forbidden &amp;&amp; !at[neigh].endpoint ) {</a>
<a name="ln1704">                /* save forbidden bonds */</a>
<a name="ln1705">                if ( is_el_a_metal(at[neigh].el_number) ) {</a>
<a name="ln1706">                    continue;</a>
<a name="ln1707">                }</a>
<a name="ln1708">                switch( bond_type ) {</a>
<a name="ln1709">                case BOND_TYPE_SINGLE:</a>
<a name="ln1710">                    if ( !at[neigh].num_H &amp;&amp; at[neigh].charge != -1 ) {</a>
<a name="ln1711">                        continue; /* not a donor */</a>
<a name="ln1712">                    }</a>
<a name="ln1713">                    break;</a>
<a name="ln1714">                case BOND_TYPE_DOUBLE:</a>
<a name="ln1715">                    if ( !neigh_type ) {</a>
<a name="ln1716">                        continue;</a>
<a name="ln1717">                    }</a>
<a name="ln1718">                    break;</a>
<a name="ln1719">                default:</a>
<a name="ln1720">                    continue;</a>
<a name="ln1721">                }</a>
<a name="ln1722">            }</a>
<a name="ln1723"> </a>
<a name="ln1724">            MobileGr[num_endpoints].atom_number      = neigh;</a>
<a name="ln1725">            MobileGr[num_endpoints].ineigh           = j;</a>
<a name="ln1726">            MobileGr[num_endpoints].bond_type        = bond_type;</a>
<a name="ln1727">            MobileGr[num_endpoints].group_number     = at[neigh].endpoint;</a>
<a name="ln1728">            MobileGr[num_endpoints].endpoint_valence = val;</a>
<a name="ln1729">            MobileGr[num_endpoints].forbidden        = forbidden;</a>
<a name="ln1730">            MobileGr[num_endpoints].atom_type_pVA    = neigh_type;</a>
<a name="ln1731">            MobileGr[num_endpoints].num_bonds        = at[neigh].valence;</a>
<a name="ln1732">            MobileGr[num_endpoints].bonds_valence    = at[neigh].chem_bonds_valence;</a>
<a name="ln1733">            MobileGr[num_endpoints].num_bonds_non_metal     = nNoMetalNumBonds(at, neigh);</a>
<a name="ln1734">            MobileGr[num_endpoints].bonds_valence_non_metal = nNoMetalBondsValence( at, neigh );</a>
<a name="ln1735"> </a>
<a name="ln1736">            if ( forbidden &amp; forbidden_mask ) {</a>
<a name="ln1737">                num_forbidden ++;</a>
<a name="ln1738">                ind_forbidden = num_endpoints;</a>
<a name="ln1739">            }</a>
<a name="ln1740">            num_O   += 0 != (neigh_type &amp; EL_TYPE_O) &amp;&amp; at[neigh].valence == 1; /* ignore -O- */</a>
<a name="ln1741">            num_N   += 0 != (neigh_type &amp; EL_TYPE_N) &amp;&amp;</a>
<a name="ln1742">                            !(at[neigh].valence == 3 &amp;&amp; at[neigh].chem_bonds_valence == 3); /* ignore -N&lt; */</a>
<a name="ln1743">            num_S   += 0 != (neigh_type &amp; EL_TYPE_S) &amp;&amp; at[neigh].valence == 1; /* ignore -S- */</a>
<a name="ln1744">            num_P   += 0 != (neigh_type &amp; EL_TYPE_P) &amp;&amp;</a>
<a name="ln1745">                            !(at[neigh].valence == 3 &amp;&amp; at[neigh].chem_bonds_valence == 3); /* ignore -P&lt; */</a>
<a name="ln1746">            num_OSt += 0 != (neigh_type &amp; EL_TYPE_OSt);</a>
<a name="ln1747">            num_acceptors += (bond_type == BOND_TYPE_DOUBLE) &amp;&amp; (neigh_type &amp; EL_TYPE_PT);</a>
<a name="ln1748">            num_donors    += (bond_type == BOND_TYPE_SINGLE) &amp;&amp; (neigh_type &amp; EL_TYPE_PT) &amp;&amp;</a>
<a name="ln1749">                             (at[neigh].num_H || at[neigh].charge==-1 || at[neigh].endpoint);</a>
<a name="ln1750">            if ( at[neigh].endpoint ) {</a>
<a name="ln1751">                num_acceptor_endpoints += (bond_type == BOND_TYPE_DOUBLE);</a>
<a name="ln1752">                num_donor_endpoints    += (bond_type == BOND_TYPE_SINGLE);</a>
<a name="ln1753">                if ( !tg_number ) {</a>
<a name="ln1754">                    tg_number = at[neigh].endpoint;</a>
<a name="ln1755">                    num_eql_mobile_gr = 1;</a>
<a name="ln1756">                } else</a>
<a name="ln1757">                if ( tg_number == at[neigh].endpoint ) {</a>
<a name="ln1758">                    num_eql_mobile_gr ++;</a>
<a name="ln1759">                } else {</a>
<a name="ln1760">                    num_dif_mobile_gr ++;</a>
<a name="ln1761">                }</a>
<a name="ln1762">            } else</a>
<a name="ln1763">            if ( bond_type == BOND_TYPE_SINGLE &amp;&amp; val ) {</a>
<a name="ln1764">                if ( at[neigh].endpoint ) {</a>
<a name="ln1765">                    has_mobile_H |= 1; </a>
<a name="ln1766">                    has_mobile   |= 1; </a>
<a name="ln1767">                } else {</a>
<a name="ln1768">                    has_mobile_H |= (0 != at[neigh].num_H); </a>
<a name="ln1769">                    has_mobile   |= (0 != at[neigh].num_H) || (at[neigh].charge == -1); </a>
<a name="ln1770">                }</a>
<a name="ln1771">            }</a>
<a name="ln1772">            num_endpoints ++;</a>
<a name="ln1773"> </a>
<a name="ln1774">            if ( at[neigh].endpoint || (neigh_type &amp; EL_TYPE_PT) ) {</a>
<a name="ln1775">                for ( k = 0; k &lt; num_mgroups; k ++ ) {</a>
<a name="ln1776">                    if ( MGroups[k].group_number == at[neigh].endpoint ) {</a>
<a name="ln1777">                        MGroups[k].num ++;</a>
<a name="ln1778">                        break;</a>
<a name="ln1779">                    }</a>
<a name="ln1780">                }</a>
<a name="ln1781">                if ( k == num_mgroups ) {</a>
<a name="ln1782">                    MGroups[k].group_number = at[neigh].endpoint;</a>
<a name="ln1783">                    MGroups[k].num          = 1;</a>
<a name="ln1784">                    num_mgroups ++;</a>
<a name="ln1785">                    num_diff_t_groups += (0 != at[neigh].endpoint);</a>
<a name="ln1786">                }</a>
<a name="ln1787">            }</a>
<a name="ln1788">        }</a>
<a name="ln1789">        if ( !num_acceptors || !num_donors || /* num_acceptors &gt; 2 ||*/</a>
<a name="ln1790">             (num_eql_mobile_gr == num_endpoints &amp;&amp; !num_forbidden) ||</a>
<a name="ln1791">             (!tg_number &amp;&amp; !has_mobile_H) ) {</a>
<a name="ln1792">            continue; /* nothing to do */</a>
<a name="ln1793">        }</a>
<a name="ln1794">        </a>
<a name="ln1795">/* case_5_1: */</a>
<a name="ln1796">        /***************** determine the case ************************/</a>
<a name="ln1797">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln1798">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln1799">             (centerpoint_type == EL_TYPE_C) &amp;&amp;</a>
<a name="ln1800">             2 == num_O &amp;&amp; 1 == num_N+num_S &amp;&amp; num_OSt &amp;&amp;</a>
<a name="ln1801">             1 == num_forbidden &amp;&amp; 3 == num_eql_mobile_gr  ) {</a>
<a name="ln1802">            /******************************************************** </a>
<a name="ln1803">             ***         InChI Tech. Man., Table 5, case 1        *** </a>
<a name="ln1804">             ******************************************************** </a>
<a name="ln1805">                       2                  </a>
<a name="ln1806">                      OH                OH     X  =  N, S, Se, Te</a>
<a name="ln1807">                     /                 /       f  =  fixed bond</a>
<a name="ln1808">                 e  /                 /        tg =  Mobile-H vertex</a>
<a name="ln1809">              HX---C      --&gt;    X===C   </a>
<a name="ln1810">           ev2|| f  \\ ev1         f  \  </a>
<a name="ln1811">              ||     \\                \ </a>
<a name="ln1812">              tg------O                 OH</a>
<a name="ln1813">                       1</a>
<a name="ln1814">            Problem:</a>
<a name="ln1815">              XH, O, and O belong to the same Mobile-H group.</a>
<a name="ln1816">              Fixed bond prevents the correct structure restoration:</a>
<a name="ln1817">              H cannot migrate from X to O because HX-N bond is fixed</a>
<a name="ln1818">            Solution:</a>
<a name="ln1819">              Move H from X to allow XH-C bond change</a>
<a name="ln1820">              (this unfixes the bond, see SetForbiddenEdges(...) )</a>
<a name="ln1821">            *********************************************************/</a>
<a name="ln1822">            int jXH = -1, jO1 = -1, jO2 = -1, n = 0;</a>
<a name="ln1823">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln1824">                if ( (MobileGr[j].atom_type_pVA &amp; (EL_TYPE_N | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln1825">                     (MobileGr[j].forbidden == forbidden_mask) &amp;&amp;</a>
<a name="ln1826">                     MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1827">                     jXH &lt; 0 ) {</a>
<a name="ln1828">                    jXH = j;</a>
<a name="ln1829">                    n ++;</a>
<a name="ln1830">                } else</a>
<a name="ln1831">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_O &amp;&amp;</a>
<a name="ln1832">                     MobileGr[j].num_bonds_non_metal == 1 &amp;&amp;</a>
<a name="ln1833">                     !MobileGr[j].forbidden ) {</a>
<a name="ln1834">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp; jO1 &lt; 0 ) {</a>
<a name="ln1835">                        jO1 = j;</a>
<a name="ln1836">                        n ++;</a>
<a name="ln1837">                    } else</a>
<a name="ln1838">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp; jO2 &lt; 0 ) {</a>
<a name="ln1839">                        jO2 = j;</a>
<a name="ln1840">                        n ++;</a>
<a name="ln1841">                    }</a>
<a name="ln1842">                }</a>
<a name="ln1843">            }</a>
<a name="ln1844">            if ( n != 3 ) {</a>
<a name="ln1845">                goto case_5_2;</a>
<a name="ln1846">            }</a>
<a name="ln1847">            /* XH-C edge */</a>
<a name="ln1848">            e   = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jXH].ineigh];</a>
<a name="ln1849">            /* C=O  edge */</a>
<a name="ln1850">            ev1 = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jO1].ineigh];</a>
<a name="ln1851">            /* XH-tg edge */</a>
<a name="ln1852">            ev2 = pBNS-&gt;edge + pVA[MobileGr[jXH].atom_number].nTautGroupEdge - 1;</a>
<a name="ln1853"> </a>
<a name="ln1854">            if ( !ev1-&gt;flow || !ev2-&gt;flow ) {</a>
<a name="ln1855">                goto case_5_2;</a>
<a name="ln1856">            }</a>
<a name="ln1857"> </a>
<a name="ln1858">            /* do not remove forbidden edge bit */</a>
<a name="ln1859">            e-&gt;flow ++;</a>
<a name="ln1860">            ev1-&gt;flow --;</a>
<a name="ln1861">            ev2-&gt;flow --;</a>
<a name="ln1862">            pBNS-&gt;vert[ev1-&gt;neighbor12 ^ i].st_edge.flow --;</a>
<a name="ln1863">            pBNS-&gt;vert[ev2-&gt;neighbor12 ^ ev2-&gt;neighbor1].st_edge.flow --;</a>
<a name="ln1864">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln1865">            num_changes ++;</a>
<a name="ln1866">            continue;</a>
<a name="ln1867">        }</a>
<a name="ln1868">case_5_2:</a>
<a name="ln1869">        /*********************************************************************/</a>
<a name="ln1870">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln1871">             5 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln1872">             (centerpoint_type == EL_TYPE_N) &amp;&amp;</a>
<a name="ln1873">             2 == num_O &amp;&amp; 1 == num_N+num_S &amp;&amp;</a>
<a name="ln1874">             1 == num_forbidden &amp;&amp; 3 == num_eql_mobile_gr  ) {</a>
<a name="ln1875">            /******************************************************** </a>
<a name="ln1876">             ***         InChI Tech. Man., Table 5, case 2        *** </a>
<a name="ln1877">             ******************************************************** </a>
<a name="ln1878">                                         </a>
<a name="ln1879">                      O                 OH     X  =  N, S, Se, Te</a>
<a name="ln1880">                     //                /       f  =  fixed bond</a>
<a name="ln1881">                 e  //                /        tg =  Mobile-H vertex</a>
<a name="ln1882">              HX---N      --&gt;    X===N   </a>
<a name="ln1883">           ev2|| f  \\ ev1         f  \\ </a>
<a name="ln1884">              ||     \\                \\</a>
<a name="ln1885">              tg------O                 O</a>
<a name="ln1886">              </a>
<a name="ln1887">            Problem:</a>
<a name="ln1888">              XH, O, and O belong to the same Mobile-H group.</a>
<a name="ln1889">              Fixed bond prevents the correct structure restoration:</a>
<a name="ln1890">              H cannot migrate from X to O because HX-N bond is fixed</a>
<a name="ln1891">            Solution:</a>
<a name="ln1892">              Move H from X to allow XH-N bond change</a>
<a name="ln1893">              (this unfixes the bond, see SetForbiddenEdges(...) )</a>
<a name="ln1894">            *********************************************************/</a>
<a name="ln1895">            int jXH = -1, jO1 = -1, jO2 = -1, n = 0;</a>
<a name="ln1896">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln1897">                if ( (MobileGr[j].atom_type_pVA &amp; (EL_TYPE_N | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln1898">                     (MobileGr[j].forbidden == forbidden_mask) &amp;&amp;</a>
<a name="ln1899">                     MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1900">                     jXH &lt; 0 ) {</a>
<a name="ln1901">                    jXH = j;</a>
<a name="ln1902">                    n ++;</a>
<a name="ln1903">                } else</a>
<a name="ln1904">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_O &amp;&amp;</a>
<a name="ln1905">                     MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1906">                     MobileGr[j].num_bonds_non_metal == 1 &amp;&amp;</a>
<a name="ln1907">                     !MobileGr[j].forbidden ) {</a>
<a name="ln1908">                    if ( jO1 &lt; 0 ) {</a>
<a name="ln1909">                        jO1 = j;</a>
<a name="ln1910">                        n ++;</a>
<a name="ln1911">                    } else</a>
<a name="ln1912">                    if ( jO2 &lt; 0 ) {</a>
<a name="ln1913">                        jO2 = j;</a>
<a name="ln1914">                        n ++;</a>
<a name="ln1915">                    }</a>
<a name="ln1916">                }</a>
<a name="ln1917">            }</a>
<a name="ln1918">            if ( n != 3 ) {</a>
<a name="ln1919">                goto case_5_4;</a>
<a name="ln1920">            }</a>
<a name="ln1921">            /* XH-N edge */</a>
<a name="ln1922">            e   = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jXH].ineigh];</a>
<a name="ln1923">            /* N=O  edge */</a>
<a name="ln1924">            ev1 = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jO1].ineigh];</a>
<a name="ln1925">            /* XH-tg edge */</a>
<a name="ln1926">            ev2 = pBNS-&gt;edge + pVA[MobileGr[jXH].atom_number].nTautGroupEdge - 1;</a>
<a name="ln1927"> </a>
<a name="ln1928">            if ( !ev1-&gt;flow || !ev2-&gt;flow ) {</a>
<a name="ln1929">                goto case_5_4;</a>
<a name="ln1930">            }</a>
<a name="ln1931">            /* do not remove forbidden edge bit */</a>
<a name="ln1932">            e-&gt;flow ++;</a>
<a name="ln1933">            ev1-&gt;flow --;</a>
<a name="ln1934">            ev2-&gt;flow --;</a>
<a name="ln1935">            pBNS-&gt;vert[ev1-&gt;neighbor12 ^ i].st_edge.flow --; /* first =O vertex */</a>
<a name="ln1936">            pBNS-&gt;vert[ev2-&gt;neighbor12 ^ ev2-&gt;neighbor1].st_edge.flow --; /* taut group vertex tg */</a>
<a name="ln1937">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln1938">            num_changes ++;</a>
<a name="ln1939">            continue;</a>
<a name="ln1940">        }</a>
<a name="ln1941">case_5_4:</a>
<a name="ln1942">        /*********************************************************************/</a>
<a name="ln1943">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln1944">             5 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln1945">             (centerpoint_type &amp; (EL_TYPE_N | EL_TYPE_P)) &amp;&amp;</a>
<a name="ln1946">             1 == num_O+num_S &amp;&amp; 0 &lt; num_N &amp;&amp; 2 == (num_N + num_P) &amp;&amp;</a>
<a name="ln1947">             1 == num_forbidden &amp;&amp; num_O+num_S+num_N == num_eql_mobile_gr  ) {</a>
<a name="ln1948">            /******************************************************** </a>
<a name="ln1949">             ***         InChI Tech. Man., Table 5, case 4        *** </a>
<a name="ln1950">             ******************************************************** </a>
<a name="ln1951">                                               O  =  O, S, Se, Te</a>
<a name="ln1952">                       X                 X     X  =  N, P, As</a>
<a name="ln1953">                     //                //      f  =  fixed bond</a>
<a name="ln1954">                 e  // ev2            //       tg =  Mobile-H vertex</a>
<a name="ln1955">               O===N      --&gt;   HO---N   </a>
<a name="ln1956">              || f  \  ev1         f  \\ </a>
<a name="ln1957">              ||     \                 \\</a>
<a name="ln1958">              tg------NH                N </a>
<a name="ln1959">                        </a>
<a name="ln1960">            Problem:</a>
<a name="ln1961">              O, NH, and possibly X belong to the same Mobile-H group.</a>
<a name="ln1962">              Fixed bond prevents the correct structure restoration:</a>
<a name="ln1963">              H cannot migrate from NH to O because O=N bond is fixed</a>
<a name="ln1964">            Solution:</a>
<a name="ln1965">              Move H from NH to O to allow O=N bond change</a>
<a name="ln1966">              (this unfixes the bond, see fix_special_bonds(...) )</a>
<a name="ln1967">            *********************************************************/</a>
<a name="ln1968">            int jO = -1, jNH = -1, jX = -1, n = 0;</a>
<a name="ln1969">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln1970">                if ( (MobileGr[j].atom_type_pVA &amp; (EL_TYPE_O | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln1971">                     MobileGr[j].forbidden == forbidden_mask &amp;&amp;</a>
<a name="ln1972">                     MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1973">                     MobileGr[j].num_bonds_non_metal == 1 &amp;&amp;</a>
<a name="ln1974">                     jO &lt; 0 ) {</a>
<a name="ln1975">                    jO = j;</a>
<a name="ln1976">                    n ++;</a>
<a name="ln1977">                } else</a>
<a name="ln1978">                if ( (MobileGr[j].atom_type_pVA &amp; (EL_TYPE_N | EL_TYPE_P)) &amp;&amp;</a>
<a name="ln1979">                     !MobileGr[j].forbidden ) {</a>
<a name="ln1980">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1981">                         (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N &amp;&amp; jNH &lt; 0 ) {</a>
<a name="ln1982">                        jNH = j;</a>
<a name="ln1983">                        n ++;</a>
<a name="ln1984">                    } else</a>
<a name="ln1985">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp; jX &lt; 0 ) {</a>
<a name="ln1986">                        jX = j;</a>
<a name="ln1987">                        n ++;</a>
<a name="ln1988">                    }</a>
<a name="ln1989">                }</a>
<a name="ln1990">            }</a>
<a name="ln1991">            if ( n != 3 ) {</a>
<a name="ln1992">                goto case_5_6;</a>
<a name="ln1993">            }</a>
<a name="ln1994">            /* O=N edge */</a>
<a name="ln1995">            e   = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jO].ineigh];</a>
<a name="ln1996">            /* N-NH  edge */</a>
<a name="ln1997">            ev1 = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jNH].ineigh];</a>
<a name="ln1998">            /* N=X edge */</a>
<a name="ln1999">            ev2 = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jX].ineigh];</a>
<a name="ln2000"> </a>
<a name="ln2001">            if ( !e-&gt;flow ) {</a>
<a name="ln2002">                goto case_5_6;</a>
<a name="ln2003">            }</a>
<a name="ln2004">            /* do not remove forbidden edge bit */</a>
<a name="ln2005">            e-&gt;flow --;</a>
<a name="ln2006">            ev1-&gt;flow ++;</a>
<a name="ln2007">            pBNS-&gt;vert[e-&gt;neighbor12 ^ i].st_edge.flow --;</a>
<a name="ln2008">            pBNS-&gt;vert[ev1-&gt;neighbor12 ^ i].st_edge.flow --;</a>
<a name="ln2009">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2010">            num_changes ++;</a>
<a name="ln2011">            continue;</a>
<a name="ln2012">        }</a>
<a name="ln2013">case_5_6:</a>
<a name="ln2014">        /********* InChI Tech.Man. Table 5, case 6 **************/</a>
<a name="ln2015">        if ( 2 == delta_met &amp;&amp; 4 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2016">             5 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2017">             1 == num_forbidden &amp;&amp; 1 &lt; num_eql_mobile_gr &amp;&amp;</a>
<a name="ln2018">             !num_dif_mobile_gr &amp;&amp;</a>
<a name="ln2019">             (centerpoint_type &amp; (EL_TYPE_N | EL_TYPE_P)) &amp;&amp;</a>
<a name="ln2020">             1 &lt;= num_N &amp;&amp; 2 &lt;= num_N+num_O+num_S &amp;&amp;</a>
<a name="ln2021">             1 == num_acceptor_endpoints &amp;&amp; 0 &lt; num_donor_endpoints ) {</a>
<a name="ln2022">            int jN = -1, njFix = 0, jFix[4], n = 0;</a>
<a name="ln2023">                /* centerpoint is N, P, As, Sb</a>
<a name="ln2024"> </a>
<a name="ln2025">                  input             output</a>
<a name="ln2026">                  -----             ------</a>
<a name="ln2027">                     end </a>
<a name="ln2028">                     po- </a>
<a name="ln2029">                     int </a>
<a name="ln2030">                     2</a>
<a name="ln2031">                     </a>
<a name="ln2032">                  X  ZH              X  Z     Z=N,O,S,Se,Te [terminal endpoint]</a>
<a name="ln2033">                   \ |                \ ||      </a>
<a name="ln2034">                    \| f   f           \||      </a>
<a name="ln2035">                 Y---N===N---       Y---N---NH---</a>
<a name="ln2036">                       e                  f      </a>
<a name="ln2037">                    cen  end         no bond           </a>
<a name="ln2038">                    ter  po-         fixed  </a>
<a name="ln2039">                    po-  int          </a>
<a name="ln2040">                    int  1        tautomerism O==N--NH is allowed</a>
<a name="ln2041">                    </a>
<a name="ln2042">                  Problem: OH and =N- belong to a Mobile-H group, but</a>
<a name="ln2043">                           forbidden edge e does not allow them to be</a>
<a name="ln2044">                           tautomeric in the restored structure.</a>
<a name="ln2045"> </a>
<a name="ln2046">                  Solution:</a>
<a name="ln2047">                    </a>
<a name="ln2048">                  1. Decrement flow in edge e</a>
<a name="ln2049">                  2. Decrement st_edge flow in N and N connected by e</a>
<a name="ln2050">                  3. Fix all single order bonds to not terminal tautomeric N around N(centerpoint)</a>
<a name="ln2051">                  4. Run BNS to establist new flow distribution</a>
<a name="ln2052">                */</a>
<a name="ln2053">            /* fixed bond */</a>
<a name="ln2054">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2055">                neigh = MobileGr[j].atom_number;</a>
<a name="ln2056">                if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2057">                     (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N &amp;&amp;</a>
<a name="ln2058">                     MobileGr[j].num_bonds_non_metal == 2     &amp;&amp;</a>
<a name="ln2059">                     MobileGr[j].bonds_valence_non_metal == 3 &amp;&amp;</a>
<a name="ln2060">                     at[neigh].endpoint &amp;&amp;</a>
<a name="ln2061">                     !at[neigh].num_H &amp;&amp; !at[neigh].charge &amp;&amp;</a>
<a name="ln2062">                     !at[neigh].radical &amp;&amp;</a>
<a name="ln2063">                     (MobileGr[j].forbidden &amp; forbidden_mask) &amp;&amp; jN &lt; 0 ) {</a>
<a name="ln2064">                    jN = j;</a>
<a name="ln2065">                    n ++;</a>
<a name="ln2066">                } else</a>
<a name="ln2067">                if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2068">                     at[neigh].endpoint ) {</a>
<a name="ln2069">                    if ( MobileGr[j].num_bonds &gt; 1 ) {</a>
<a name="ln2070">                        jFix[njFix ++] = j;</a>
<a name="ln2071">                    }</a>
<a name="ln2072">                    n ++;</a>
<a name="ln2073">                }</a>
<a name="ln2074">            }</a>
<a name="ln2075"> </a>
<a name="ln2076">            if ( jN &lt; 0 || n &lt; 2 || 1 + njFix == n ) {</a>
<a name="ln2077">                goto case_5_7;  /* nothing to do */</a>
<a name="ln2078">            }</a>
<a name="ln2079"> </a>
<a name="ln2080">            e   = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jN].ineigh];  /* fixed edge */</a>
<a name="ln2081">            if ( !e-&gt;flow ) {</a>
<a name="ln2082">                goto case_5_7;</a>
<a name="ln2083">            }</a>
<a name="ln2084">            e-&gt;flow --;</a>
<a name="ln2085">            pBNS-&gt;vert[i].st_edge.flow --;</a>
<a name="ln2086">            pBNS-&gt;vert[e-&gt;neighbor12 ^ i].st_edge.flow --;</a>
<a name="ln2087">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2088"> </a>
<a name="ln2089">            for ( j = 0; j &lt; njFix; j ++ ) {</a>
<a name="ln2090">                /* edges to fix */</a>
<a name="ln2091">                ev = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[(int)MobileGr[jFix[j]].ineigh];</a>
<a name="ln2092">                ev-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2093">            }</a>
<a name="ln2094">            num_changes ++;</a>
<a name="ln2095">            continue;</a>
<a name="ln2096">        }</a>
<a name="ln2097">case_5_7:</a>
<a name="ln2098">        /*********************************************************************/</a>
<a name="ln2099">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2100">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2101">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2102">             2 == num_O+num_S &amp;&amp; 1 == num_OSt &amp;&amp; 1 == num_N &amp;&amp;</a>
<a name="ln2103">             1 == num_forbidden &amp;&amp; 3 == num_eql_mobile_gr &amp;&amp; </a>
<a name="ln2104">             MobileGr[ind_forbidden].bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln2105">            /******************************************************** </a>
<a name="ln2106">             ***         InChI Tech. Man., Table 5, case 7        *** </a>
<a name="ln2107">             ******************************************************** </a>
<a name="ln2108">                                               O  =  O, S, Se, Te</a>
<a name="ln2109">                      OH                OH     S  =  S, Se, Te</a>
<a name="ln2110">                     /                 /       f  =  fixed bond</a>
<a name="ln2111">                 e  /ev2           f  /        tg =  Mobile-H vertex</a>
<a name="ln2112">              HN---S      --&gt;    N===S         X  =  N or non-endpoint;</a>
<a name="ln2113">              || f  \\                \</a>
<a name="ln2114">           ev2||     \\ev1             \ </a>
<a name="ln2115">              tg------O                 OH</a>
<a name="ln2116">                                               N, O, O</a>
<a name="ln2117">            Problem:                           =======</a>
<a name="ln2118">              O, NH, OH belong to the same Mobile-H group.</a>
<a name="ln2119">              Fixed bond prevents the correct structure restoration:</a>
<a name="ln2120">              H cannot migrate from NH to O because HN-S bond is fixed</a>
<a name="ln2121">            Solution:</a>
<a name="ln2122">              Move H from NH to =O to allow HN=S bond change by making a 2nd terminal -OH</a>
<a name="ln2123">              (this unfixes the bond, see fix_special_bonds(...) )</a>
<a name="ln2124">            *********************************************************/</a>
<a name="ln2125">            int jO = -1, jNH = -1, jOH = -1, n = 0;</a>
<a name="ln2126">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2127">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N &amp;&amp;</a>
<a name="ln2128">                     MobileGr[j].forbidden == forbidden_mask &amp;&amp;</a>
<a name="ln2129">                     MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2130">                     MobileGr[j].num_bonds_non_metal &lt;= 2 &amp;&amp;</a>
<a name="ln2131">                     jNH &lt; 0 ) {</a>
<a name="ln2132">                    jNH = j;</a>
<a name="ln2133">                    n ++;</a>
<a name="ln2134">                } else</a>
<a name="ln2135">                if ( (MobileGr[j].atom_type_pVA &amp; (EL_TYPE_O | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln2136">                     !MobileGr[j].forbidden &amp;&amp;</a>
<a name="ln2137">                     MobileGr[j].num_bonds_non_metal == 1 ) {</a>
<a name="ln2138">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2139">                         jO &lt; 0 ) {</a>
<a name="ln2140">                        jO = j;</a>
<a name="ln2141">                        n ++;</a>
<a name="ln2142">                    } else</a>
<a name="ln2143">                    if ( jOH &lt; 0 ) {</a>
<a name="ln2144">                        jOH = j;</a>
<a name="ln2145">                        n ++;</a>
<a name="ln2146">                    }</a>
<a name="ln2147">                }</a>
<a name="ln2148">            }</a>
<a name="ln2149">            if ( n != 3 ) {</a>
<a name="ln2150">                goto case_5_9a;</a>
<a name="ln2151">            }</a>
<a name="ln2152">            /* NH-S edge */</a>
<a name="ln2153">            e   = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jNH].ineigh];</a>
<a name="ln2154">            /* S=O  edge */</a>
<a name="ln2155">            ev1 = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jO].ineigh];</a>
<a name="ln2156">            /* XH-tg edge */</a>
<a name="ln2157">            ev2 = pBNS-&gt;edge + pVA[MobileGr[jNH].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2158"> </a>
<a name="ln2159">            if ( !ev1-&gt;flow || !ev2-&gt;flow ) {</a>
<a name="ln2160">                goto case_5_9a;</a>
<a name="ln2161">            }</a>
<a name="ln2162"> </a>
<a name="ln2163">            /* do not remove forbidden edge bit */</a>
<a name="ln2164">            e-&gt;flow ++;</a>
<a name="ln2165">            ev1-&gt;flow --;</a>
<a name="ln2166">            ev2-&gt;flow --;</a>
<a name="ln2167">            pBNS-&gt;vert[ev1-&gt;neighbor12 ^ i].st_edge.flow --; /* first =O vertex */</a>
<a name="ln2168">            pBNS-&gt;vert[ev2-&gt;neighbor12 ^ ev2-&gt;neighbor1].st_edge.flow --; /* taut group vertex tg */</a>
<a name="ln2169">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2170">            num_changes ++;</a>
<a name="ln2171">            continue;</a>
<a name="ln2172">        }</a>
<a name="ln2173">case_5_9a:</a>
<a name="ln2174">        /*********************************************************************/</a>
<a name="ln2175">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2176">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2177">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2178">             1 == num_O+num_S &amp;&amp; !num_OSt &amp;&amp; 1 &lt;= num_N &amp;&amp;</a>
<a name="ln2179">             1 == num_forbidden &amp;&amp;</a>
<a name="ln2180">             num_O+num_S+num_N == num_eql_mobile_gr &amp;&amp; </a>
<a name="ln2181">             MobileGr[ind_forbidden].bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln2182">            /******************************************************** </a>
<a name="ln2183">             ***         InChI Tech. Man., Table 5, case 9a       *** </a>
<a name="ln2184">             ******************************************************** </a>
<a name="ln2185">                                               O  =  O, S, Se, Te</a>
<a name="ln2186">                      X                 X      S  =  S, Se, Te</a>
<a name="ln2187">                     /                 /       f  =  fixed bond</a>
<a name="ln2188">                    /                 /        tg =  Mobile-H vertex</a>
<a name="ln2189">              HN---S      --&gt;    N===S         X  =  N or non-endpoint;</a>
<a name="ln2190">              ||    \\ e              \       -X is not -O(terminal)</a>
<a name="ln2191">              ||    f\\               f\ </a>
<a name="ln2192">              tg------O                 OH</a>
<a name="ln2193">                                               N, N, O  or N, O</a>
<a name="ln2194">            Problem:                           ================</a>
<a name="ln2195">              O, NH belong to the same Mobile-H group.</a>
<a name="ln2196">              Fixed bond prevents the correct structure restoration:</a>
<a name="ln2197">              H cannot migrate from NH to O because O=S bond is fixed</a>
<a name="ln2198">            Solution:</a>
<a name="ln2199">              Move H from NH to =O to allow O=S bond change by making a terminal -OH</a>
<a name="ln2200">              (this unfixes the bond, see fix_special_bonds(...) )</a>
<a name="ln2201">            *********************************************************/</a>
<a name="ln2202">            int jO = -1, jNH = -1, jX = -1, n = 0;</a>
<a name="ln2203">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2204">                if ( (MobileGr[j].atom_type_pVA &amp; (EL_TYPE_O | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln2205">                     MobileGr[j].forbidden == forbidden_mask &amp;&amp;</a>
<a name="ln2206">                     MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2207">                     MobileGr[j].num_bonds_non_metal == 1 &amp;&amp;</a>
<a name="ln2208">                     jO &lt; 0 ) {</a>
<a name="ln2209">                    jO = j;</a>
<a name="ln2210">                    n ++;</a>
<a name="ln2211">                } else</a>
<a name="ln2212">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N &amp;&amp;</a>
<a name="ln2213">                     !MobileGr[j].forbidden &amp;&amp;</a>
<a name="ln2214">                     MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2215">                     jNH &lt; 0 ) {</a>
<a name="ln2216">                    jNH = j;</a>
<a name="ln2217">                    n ++;</a>
<a name="ln2218">                } else</a>
<a name="ln2219">                if ( jX &lt; 0 ) {</a>
<a name="ln2220">                    jX = j;</a>
<a name="ln2221">                    n ++;</a>
<a name="ln2222">                }</a>
<a name="ln2223">            }</a>
<a name="ln2224">            if ( jO &lt; 0 || jNH &lt; 0 ) {</a>
<a name="ln2225">                goto case_5_8b_to_9b;</a>
<a name="ln2226">            }</a>
<a name="ln2227"> </a>
<a name="ln2228">            e = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[ind_forbidden].ineigh];</a>
<a name="ln2229">            if ( !e-&gt;flow ) {</a>
<a name="ln2230">                goto case_5_8b_to_9b;</a>
<a name="ln2231">            }</a>
<a name="ln2232">            e-&gt;flow --;</a>
<a name="ln2233">            pBNS-&gt;vert[e-&gt;neighbor1].st_edge.flow --;</a>
<a name="ln2234">            pBNS-&gt;vert[e-&gt;neighbor1 ^ e-&gt;neighbor12].st_edge.flow --;</a>
<a name="ln2235">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2236">            num_changes ++;</a>
<a name="ln2237">            continue;</a>
<a name="ln2238">        }</a>
<a name="ln2239">case_5_8b_to_9b: /* #1 */</a>
<a name="ln2240">        /*********************************************************************/</a>
<a name="ln2241">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2242">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2243">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2244">             0 == num_O+num_S &amp;&amp; 2 == num_N &amp;&amp; 0 == num_P &amp;&amp; !num_OSt &amp;&amp;</a>
<a name="ln2245">             1 == num_forbidden &amp;&amp;</a>
<a name="ln2246">             1 == num_eql_mobile_gr &amp;&amp; 0 == num_dif_mobile_gr &amp;&amp;</a>
<a name="ln2247">             1 == num_donor_endpoints &amp;&amp; 0 == num_acceptor_endpoints &amp;&amp;</a>
<a name="ln2248">             1 == num_donors          &amp;&amp; 1 == num_acceptors &amp;&amp;</a>
<a name="ln2249">             MobileGr[ind_forbidden].bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln2250">            /******************************************************** </a>
<a name="ln2251">             ***         InChI Tech. Man., Table 5, case 8b-&gt;9b   *** </a>
<a name="ln2252">             ******************************************************** </a>
<a name="ln2253">                             ---&gt;                    O  =  O, S, Se, Te      </a>
<a name="ln2254">                      X                  X           S  =  S, Se, Te         </a>
<a name="ln2255">             \      f/          \      f/            f  =  fixed bond        </a>
<a name="ln2256">              \ ev  /  C=====Z   \     /  C-----ZH   tg =  Mobile-H vertex   </a>
<a name="ln2257">               N===S   |     |    N===S  ||     ||   X  =  is N not an endpoint;</a>
<a name="ln2258">             not    \  |     |         \ ||     ||  -X is not terminal -O,-S,-Se,-Te or</a>
<a name="ln2259">             an      \ |  e  |          \||  e  ||        any N, P, As</a>
<a name="ln2260">           endpoint   NH=====tg          N------tg</a>
<a name="ln2261">                     is an                   f       N, N, X, fixed single</a>
<a name="ln2262">                   endpoint                          =====================</a>
<a name="ln2263"> </a>
<a name="ln2264">            Problem:</a>
<a name="ln2265">              N is not a Mobile-H endpoint, NH is a Mobile-H endpoint</a>
<a name="ln2266">              Unfixed bond N==S prevents the correct structure restoration:</a>
<a name="ln2267">              H can migrate from NH to N because N=S bond is not fixed</a>
<a name="ln2268">            Solution:</a>
<a name="ln2269">              Move H from NH to =Z to make N=S bond fixed (Table 5, case 9)</a>
<a name="ln2270">              (this unfixes the bond, see fix_special_bonds(...) )</a>
<a name="ln2271">            *********************************************************/</a>
<a name="ln2272">            int jN = -1, jNH = -1, jX = -1, n = 0;</a>
<a name="ln2273">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2274">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N &amp;&amp;</a>
<a name="ln2275">                     !(MobileGr[j].forbidden &amp; forbidden_mask) ) {</a>
<a name="ln2276">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2277">                         !at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2278">                         jN &lt; 0 ) {</a>
<a name="ln2279">                        jN = j;</a>
<a name="ln2280">                        n ++;</a>
<a name="ln2281">                    } else</a>
<a name="ln2282">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2283">                         MobileGr[j].num_bonds == 2 &amp;&amp;</a>
<a name="ln2284">                         MobileGr[j].bonds_valence == 2 &amp;&amp;</a>
<a name="ln2285">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2286">                         jNH &lt; 0 ) {</a>
<a name="ln2287">                        jNH = j;</a>
<a name="ln2288">                        n ++;</a>
<a name="ln2289">                    }</a>
<a name="ln2290">                } else</a>
<a name="ln2291">                if ( !((MobileGr[j].atom_type_pVA &amp; (EL_TYPE_N | EL_TYPE_P)) ||</a>
<a name="ln2292">                       ((MobileGr[j].atom_type_pVA &amp; (EL_TYPE_O | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln2293">                        MobileGr[j].num_bonds &gt; 1) ) &amp;&amp;</a>
<a name="ln2294">                     (MobileGr[j].forbidden &amp; forbidden_mask) &amp;&amp;</a>
<a name="ln2295">                     MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2296">                     jX &lt; 0 ) {</a>
<a name="ln2297">                    jX = j;</a>
<a name="ln2298">                    n ++;</a>
<a name="ln2299">                }</a>
<a name="ln2300">            }</a>
<a name="ln2301">            if ( n != 3 ) {</a>
<a name="ln2302">                goto case_5_8c_to_9c;</a>
<a name="ln2303">            }</a>
<a name="ln2304"> </a>
<a name="ln2305">            e = pBNS-&gt;edge + pVA[MobileGr[jNH].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2306">            if ( !e-&gt;flow ) {</a>
<a name="ln2307">                goto case_5_8c_to_9c; /* should not happen ??? */</a>
<a name="ln2308">            }</a>
<a name="ln2309">            e-&gt;flow --;</a>
<a name="ln2310">            pBNS-&gt;vert[e-&gt;neighbor1].st_edge.flow --;</a>
<a name="ln2311">            pBNS-&gt;vert[e-&gt;neighbor1 ^ e-&gt;neighbor12].st_edge.flow --;</a>
<a name="ln2312">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2313">            e-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2314">            num_changes ++;</a>
<a name="ln2315">            continue;</a>
<a name="ln2316">        }</a>
<a name="ln2317">case_5_8c_to_9c: /* #2 */</a>
<a name="ln2318">        /*********************************************************************/</a>
<a name="ln2319">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2320">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2321">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2322">             0 == num_O+num_S &amp;&amp; 3 == num_N &amp;&amp; 0 == num_P &amp;&amp;</a>
<a name="ln2323">             1 == num_forbidden &amp;&amp;</a>
<a name="ln2324">             3 == num_eql_mobile_gr &amp;&amp; 0 == num_dif_mobile_gr &amp;&amp;</a>
<a name="ln2325">             2 == num_donor_endpoints &amp;&amp; 1 == num_acceptor_endpoints &amp;&amp;</a>
<a name="ln2326">             2 == num_donors          &amp;&amp; 1 == num_acceptors &amp;&amp;</a>
<a name="ln2327">             MobileGr[ind_forbidden].bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln2328">            /******************************************************** </a>
<a name="ln2329">             ***         InChI Tech. Man., Table 5, case 8c-&gt;9c   *** </a>
<a name="ln2330">             ******************************************************** </a>
<a name="ln2331">                is an endpoint ---&gt;                  O  =  O, S, Se, Te      </a>
<a name="ln2332">                      NH2(X)             NH2(X)      S  =  S, Se, Te         </a>
<a name="ln2333">             \       / pv1  pv2 \       /            f  =  fixed bond        </a>
<a name="ln2334">              \ 1   /  C-----ZH  \     /  C=====Z    tg =  Mobile-H vertex   </a>
<a name="ln2335">               N===S  ||     ||   N===S   |     |    X  =  is N not an endpoint;</a>
<a name="ln2336">            is an   \f||ev1  ||ev2     \f |     |   -X is not terminal -O,-S,-Se,-Te or</a>
<a name="ln2337">          endpoint   \||  e  ||         \ |  e  |         any N, P, As</a>
<a name="ln2338">                    2 N------tg          NH=====tg   C is a centerpoint of a t-group</a>
<a name="ln2339">                     is an                   f       N, N, X, fixed single</a>
<a name="ln2340">                   endpoint                          =====================</a>
<a name="ln2341"> </a>
<a name="ln2342">            Problem:</a>
<a name="ln2343">              N is not a Mobile-H endpoint, NH is a Mobile-H endpoint</a>
<a name="ln2344">              Unfixed bond N==S prevents the correct structure restoration:</a>
<a name="ln2345">              H can migrate from NH to N because N=S bond is not fixed</a>
<a name="ln2346">            Solution:</a>
<a name="ln2347">              Move H from NH to =Z to make N=S bond fixed (Table 5, case 9)</a>
<a name="ln2348">              (this unfixes the bond, see fix_special_bonds(...) )</a>
<a name="ln2349">            *********************************************************/</a>
<a name="ln2350">            int jN1 = -1, jN2 = -1, jX = -1, n = 0;</a>
<a name="ln2351">            EdgeIndex ie, ie1, ie2;</a>
<a name="ln2352">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2353">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N &amp;&amp;</a>
<a name="ln2354">                     !(MobileGr[j].forbidden &amp; forbidden_mask) ) {</a>
<a name="ln2355">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2356">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2357">                         jN1 &lt; 0 ) {</a>
<a name="ln2358">                        jN1 = j;</a>
<a name="ln2359">                        n ++;</a>
<a name="ln2360">                    } else</a>
<a name="ln2361">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2362">                         MobileGr[j].num_bonds == 2 &amp;&amp;</a>
<a name="ln2363">                         MobileGr[j].bonds_valence == 3 &amp;&amp;</a>
<a name="ln2364">                         MobileGr[j].forbidden == forbidden_mask &amp;&amp;</a>
<a name="ln2365">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2366">                         jN2 &lt; 0 ) {</a>
<a name="ln2367">                        jN2 = j;</a>
<a name="ln2368">                        n ++;</a>
<a name="ln2369">                    } else</a>
<a name="ln2370">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2371">                         MobileGr[j].num_bonds &lt;= 2 &amp;&amp;</a>
<a name="ln2372">                         MobileGr[j].bonds_valence &lt;= 3 &amp;&amp;</a>
<a name="ln2373">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2374">                         jX &lt; 0 ) {</a>
<a name="ln2375">                        jX = j;</a>
<a name="ln2376">                        n ++;</a>
<a name="ln2377">                    }</a>
<a name="ln2378">                }</a>
<a name="ln2379">            }</a>
<a name="ln2380">            if ( n != 3 ) {</a>
<a name="ln2381">                goto case_5_9b_to_8b;</a>
<a name="ln2382">            }</a>
<a name="ln2383"> </a>
<a name="ln2384">            e = pBNS-&gt;edge + pVA[MobileGr[jN2].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2385">            if ( e-&gt;flow ) {</a>
<a name="ln2386">                goto case_5_9b_to_8b; /* should not happen ??? */</a>
<a name="ln2387">            }</a>
<a name="ln2388">            pv1 = pBNS-&gt;vert + e-&gt;neighbor1;  /* must be jN2 */</a>
<a name="ln2389">            pv2 = pBNS-&gt;vert + (e-&gt;neighbor1 ^ e-&gt;neighbor12);</a>
<a name="ln2390">            ie = e - pBNS-&gt;edge;</a>
<a name="ln2391">            ie1 = ie2 = -1;</a>
<a name="ln2392">            for ( j = 0; j &lt; pv1-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln2393">                ev1 = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln2394">                if ( ev1-&gt;flow &amp;&amp; !ev1-&gt;forbidden ) {</a>
<a name="ln2395">                    ie1 = ev1 - pBNS-&gt;edge;</a>
<a name="ln2396">                    pv1 = pBNS-&gt;vert + (ev1-&gt;neighbor12 ^ (pv1 - pBNS-&gt;vert));</a>
<a name="ln2397">                    break;</a>
<a name="ln2398">                }</a>
<a name="ln2399">            }</a>
<a name="ln2400">            for ( j = 0; j &lt; pv2-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln2401">                ev2 = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln2402">                if ( ev2-&gt;flow &amp;&amp; !ev2-&gt;forbidden ) {</a>
<a name="ln2403">                    ie2 = ev2 - pBNS-&gt;edge;</a>
<a name="ln2404">                    pv2 = pBNS-&gt;vert + (ev2-&gt;neighbor12 ^ (pv2 - pBNS-&gt;vert));</a>
<a name="ln2405">                    break;</a>
<a name="ln2406">                }</a>
<a name="ln2407">            }</a>
<a name="ln2408">            if ( ie1 &lt; 0 || ie2 &lt; 0 ) {</a>
<a name="ln2409">                goto case_5_9b_to_8b;</a>
<a name="ln2410">            }</a>
<a name="ln2411">            e-&gt;flow ++;</a>
<a name="ln2412">            e-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2413">            ev1-&gt;flow --;</a>
<a name="ln2414">            ev2-&gt;flow --;</a>
<a name="ln2415">            pv1-&gt;st_edge.flow --;</a>
<a name="ln2416">            pv2-&gt;st_edge.flow --;</a>
<a name="ln2417">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2418">            num_changes ++;</a>
<a name="ln2419">            continue;</a>
<a name="ln2420">        }</a>
<a name="ln2421">case_5_9b_to_8b: /* #3 */</a>
<a name="ln2422">        /*********************************************************************/</a>
<a name="ln2423">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2424">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2425">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2426">             0 == num_O+num_S &amp;&amp; 2 == num_N &amp;&amp; 0 == num_P &amp;&amp;</a>
<a name="ln2427">             1 == num_forbidden &amp;&amp;</a>
<a name="ln2428">             2 == num_eql_mobile_gr &amp;&amp; 0 == num_dif_mobile_gr &amp;&amp;</a>
<a name="ln2429">             1 == num_donor_endpoints &amp;&amp; 1 == num_acceptor_endpoints &amp;&amp;</a>
<a name="ln2430">             1 == num_donors          &amp;&amp; 1 == num_acceptors &amp;&amp;</a>
<a name="ln2431">             MobileGr[ind_forbidden].bond_type == BOND_TYPE_DOUBLE ) {</a>
<a name="ln2432">            /******************************************************** </a>
<a name="ln2433">             ***         InChI Tech. Man., Table 5, case 9b-&gt;8b   *** </a>
<a name="ln2434">             ******************************************************** </a>
<a name="ln2435">                           ---&gt;                      O  =  O, S, Se, Te      </a>
<a name="ln2436">                  X    is an              X          S  =  S, Se, Te         </a>
<a name="ln2437">         \       /   endpoint    \       /           f  =  fixed bond        </a>
<a name="ln2438">          \ 1ev /  C-----ZH       \     /  C=====Z   tg =  Mobile-H vertex   </a>
<a name="ln2439">           N===S  ||     ||        N===S   |     |   X  =  is N not an endpoint;</a>
<a name="ln2440">      is an  f  \ ||     ||          f  \  |     |  -X is not terminal -O,-S,-Se,-Te or</a>
<a name="ln2441">   endpoint     2\||  e  ||              \ |  e  |        any N, P, As</a>
<a name="ln2442">                  N------tg               NH=====tg</a>
<a name="ln2443">               is an                          f      N, N, X, fixed double</a>
<a name="ln2444">            endpoint                                 =====================</a>
<a name="ln2445"> </a>
<a name="ln2446">            Problem:</a>
<a name="ln2447">              N1 and N2 are Mobile-H endpoints and belong to the same Mobile-H group.</a>
<a name="ln2448">              Fixed bond N1==S prevents the correct structure restoration:</a>
<a name="ln2449">              H cannot migrate ZH-&gt;N2-&gt;N1 because N1=S bond is fixed</a>
<a name="ln2450">            Solution:</a>
<a name="ln2451">              Move H from ZH to N2 to make N1=S bond unfixed and fix S-X bond (Table 5, case 8)</a>
<a name="ln2452">              (see fix_special_bonds(...) for details )</a>
<a name="ln2453">            *********************************************************/</a>
<a name="ln2454">            int jN1 = -1, jN2 = -1, jX = -1, n = 0;</a>
<a name="ln2455">            EdgeIndex ie, ie1, ie2;</a>
<a name="ln2456">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2457">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N ) {</a>
<a name="ln2458">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2459">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2460">                         (MobileGr[j].forbidden == forbidden_mask) &amp;&amp;</a>
<a name="ln2461">                         jN1 &lt; 0 ) {</a>
<a name="ln2462">                        jN1 = j;</a>
<a name="ln2463">                        n ++;</a>
<a name="ln2464">                    } else</a>
<a name="ln2465">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2466">                         MobileGr[j].num_bonds == 2 &amp;&amp;</a>
<a name="ln2467">                         MobileGr[j].bonds_valence == 3 &amp;&amp;</a>
<a name="ln2468">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2469">                         !(MobileGr[j].forbidden &amp; forbidden_mask) &amp;&amp;</a>
<a name="ln2470">                         jN2 &lt; 0 ) {</a>
<a name="ln2471">                        jN2 = j;</a>
<a name="ln2472">                        n ++;</a>
<a name="ln2473">                    }</a>
<a name="ln2474">                } else</a>
<a name="ln2475">                if ( !((MobileGr[j].atom_type_pVA &amp; (EL_TYPE_N | EL_TYPE_P)) ||</a>
<a name="ln2476">                       ((MobileGr[j].atom_type_pVA &amp; (EL_TYPE_O | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln2477">                        MobileGr[j].num_bonds &gt; 1) ) &amp;&amp;</a>
<a name="ln2478">                     !(MobileGr[j].forbidden &amp; forbidden_mask) &amp;&amp;</a>
<a name="ln2479">                     MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2480">                     jX &lt; 0 ) {</a>
<a name="ln2481">                    jX = j;</a>
<a name="ln2482">                    n ++;</a>
<a name="ln2483">                }</a>
<a name="ln2484">            }</a>
<a name="ln2485">            if ( jN1 &lt; 0 || jN2 &lt; 0 ) {</a>
<a name="ln2486">                goto case_5_9c_to_8c;</a>
<a name="ln2487">            }</a>
<a name="ln2488"> </a>
<a name="ln2489">            ev = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jN1].ineigh];</a>
<a name="ln2490">            e = pBNS-&gt;edge + pVA[MobileGr[jN2].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2491">            if ( e-&gt;flow ) {</a>
<a name="ln2492">                goto case_5_9c_to_8c; /* should not happen ??? */</a>
<a name="ln2493">            }</a>
<a name="ln2494">            pv1 = pBNS-&gt;vert + e-&gt;neighbor1;  /* must be jN2 */</a>
<a name="ln2495">            pv2 = pBNS-&gt;vert + (e-&gt;neighbor1 ^ e-&gt;neighbor12);</a>
<a name="ln2496">            ie = e - pBNS-&gt;edge;</a>
<a name="ln2497">            ie1 = ie2 = -1;</a>
<a name="ln2498">            ev-&gt;forbidden &amp;= inv_forbidden_mask;</a>
<a name="ln2499">            for ( j = 0; j &lt; pv1-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln2500">                ev1 = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln2501">                if ( ev1-&gt;flow &amp;&amp; !ev1-&gt;forbidden ) {</a>
<a name="ln2502">                    ie1 = ev1 - pBNS-&gt;edge;</a>
<a name="ln2503">                    pv1 = pBNS-&gt;vert + (ev1-&gt;neighbor12 ^ (pv1 - pBNS-&gt;vert));</a>
<a name="ln2504">                    break;</a>
<a name="ln2505">                }</a>
<a name="ln2506">            }</a>
<a name="ln2507">            for ( j = 0; j &lt; pv2-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln2508">                ev2 = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln2509">                if ( ev2-&gt;flow &amp;&amp; !ev2-&gt;forbidden ) {</a>
<a name="ln2510">                    ie2 = ev2 - pBNS-&gt;edge;</a>
<a name="ln2511">                    pv2 = pBNS-&gt;vert + (ev2-&gt;neighbor12 ^ (pv2 - pBNS-&gt;vert));</a>
<a name="ln2512">                    break;</a>
<a name="ln2513">                }</a>
<a name="ln2514">            }</a>
<a name="ln2515">            if ( ie1 &lt; 0 || ie2 &lt; 0 ) {</a>
<a name="ln2516">                ev-&gt;forbidden |= forbidden_mask; /* failed; restore the forbidden bit */ </a>
<a name="ln2517">                goto case_5_9c_to_8c;</a>
<a name="ln2518">            }</a>
<a name="ln2519">            e-&gt;flow ++;</a>
<a name="ln2520">            e-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2521">            ev1-&gt;flow --;</a>
<a name="ln2522">            ev2-&gt;flow --;</a>
<a name="ln2523">            pv1-&gt;st_edge.flow --;</a>
<a name="ln2524">            pv2-&gt;st_edge.flow --;</a>
<a name="ln2525">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2526">            num_changes ++;</a>
<a name="ln2527">            continue;</a>
<a name="ln2528">        }</a>
<a name="ln2529">case_5_9c_to_8c: /* #4 */</a>
<a name="ln2530">        /*********************************************************************/</a>
<a name="ln2531">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2532">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2533">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2534">             0 == num_O+num_S &amp;&amp; 3 == num_N &amp;&amp; 0 == num_P &amp;&amp;</a>
<a name="ln2535">             0 == num_forbidden &amp;&amp;</a>
<a name="ln2536">             2 == num_diff_t_groups &amp;&amp; 2 == num_mgroups &amp;&amp; /* all neighbors belong to 2 t-groups */</a>
<a name="ln2537">             3 == num_eql_mobile_gr + num_dif_mobile_gr &amp;&amp; /* all 3 neighbors belong to t-groups */</a>
<a name="ln2538">             2 == num_donor_endpoints &amp;&amp; 1 == num_acceptor_endpoints &amp;&amp;</a>
<a name="ln2539">             2 == num_donors          &amp;&amp; 1 == num_acceptors ) {</a>
<a name="ln2540">            /******************************************************** </a>
<a name="ln2541">             ***         InChI Tech. Man., Table 5, case 8c-&gt;9c   *** </a>
<a name="ln2542">             ******************************************************** </a>
<a name="ln2543">                is an endpoint ---&gt;                  O  =  O, S, Se, Te      </a>
<a name="ln2544">                tg1   NH2(X)             NH2(X)      S  =  S, Se, Te         </a>
<a name="ln2545">             \       / pv1  pv2 \       /            f  =  fixed bond        </a>
<a name="ln2546">              \(1)  /  C=====Z   \     /  C-----ZH   tg =  Mobile-H vertex   </a>
<a name="ln2547">               N===S   |     |    N===S  ||     ||   X  =  is N not an endpoint;</a>
<a name="ln2548">            is an   \  |ev1  | ev2     \ ||     ||  -X is not terminal -O,-S,-Se,-Te or</a>
<a name="ln2549">          endpoint   \ |  e  |          \||  e  ||        any N, P, As</a>
<a name="ln2550">          tg1      (2)NH=====tg          N------tg   C is a centerpoint of a t-group</a>
<a name="ln2551">                     is an                   f       N, N, X, fixed single</a>
<a name="ln2552">                   endpoint                          =====================</a>
<a name="ln2553">                   tg2</a>
<a name="ln2554">            Problem:</a>
<a name="ln2555">              N (1) and NH2 are Mobile-H group 1 endpoiints, NH (2) is a Mobile-H group 2 endpoint</a>
<a name="ln2556">              Unfixed bonds N==S--NH(2) allows the two Mobile H groups to merge</a>
<a name="ln2557">              hence prevents the correct structure restoration:</a>
<a name="ln2558">              H can migrate from NH (2) to N (1) because S-NH(1) bond is not fixed</a>
<a name="ln2559">            Solution:</a>
<a name="ln2560">              Move H from NH(2) to =Z to make S-NH(2) bond fixed (Table 5, case 8c)</a>
<a name="ln2561">              (this unfixes the bond, see fix_special_bonds(...) )</a>
<a name="ln2562">            *********************************************************/</a>
<a name="ln2563">            int jN1 = -1, jN2 = -1, jX = -1, n = 0;</a>
<a name="ln2564">            /* find t-group that is represented by only one neighbor */</a>
<a name="ln2565">            for ( j = 0, k = 0; j &lt; num_mgroups; j ++ ) {</a>
<a name="ln2566">                if ( 1 == MGroups[k].num &amp;&amp; MGroups[k].group_number ) {</a>
<a name="ln2567">                    k = MGroups[k].group_number;</a>
<a name="ln2568">                    break;</a>
<a name="ln2569">                }</a>
<a name="ln2570">            }</a>
<a name="ln2571">            if ( !k ) {</a>
<a name="ln2572">                goto case_5_9c_to_9d;</a>
<a name="ln2573">            }</a>
<a name="ln2574">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2575">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N ) {</a>
<a name="ln2576">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2577">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2578">                         at[MobileGr[j].atom_number].endpoint != k &amp;&amp;</a>
<a name="ln2579">                         jN1 &lt; 0 ) {</a>
<a name="ln2580">                        jN1 = j;</a>
<a name="ln2581">                        n ++;</a>
<a name="ln2582">                    } else</a>
<a name="ln2583">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2584">                         MobileGr[j].num_bonds == 2 &amp;&amp;</a>
<a name="ln2585">                         MobileGr[j].bonds_valence == 2 &amp;&amp;</a>
<a name="ln2586">                         at[MobileGr[j].atom_number].endpoint == k &amp;&amp;</a>
<a name="ln2587">                         jN2 &lt; 0 ) {</a>
<a name="ln2588">                        jN2 = j;</a>
<a name="ln2589">                        n ++;</a>
<a name="ln2590">                    } else</a>
<a name="ln2591">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2592">                         MobileGr[j].num_bonds &lt;= 2 &amp;&amp;</a>
<a name="ln2593">                         MobileGr[j].bonds_valence &lt;= 3 &amp;&amp;</a>
<a name="ln2594">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2595">                         at[MobileGr[j].atom_number].endpoint != k &amp;&amp;</a>
<a name="ln2596">                         jX &lt; 0 ) {</a>
<a name="ln2597">                        jX = j;</a>
<a name="ln2598">                        n ++;</a>
<a name="ln2599">                    }</a>
<a name="ln2600">                }</a>
<a name="ln2601">            }</a>
<a name="ln2602">            if ( n != 3 ) {</a>
<a name="ln2603">                goto case_5_9c_to_9d;</a>
<a name="ln2604">            }</a>
<a name="ln2605"> </a>
<a name="ln2606">            e = pBNS-&gt;edge + pVA[MobileGr[jN2].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2607">            if ( !e-&gt;flow ) {</a>
<a name="ln2608">                goto case_5_9c_to_9d; /* should not happen ??? */</a>
<a name="ln2609">            }</a>
<a name="ln2610">            e-&gt;flow --;</a>
<a name="ln2611">            pBNS-&gt;vert[e-&gt;neighbor1].st_edge.flow --;</a>
<a name="ln2612">            pBNS-&gt;vert[e-&gt;neighbor1 ^ e-&gt;neighbor12].st_edge.flow --;</a>
<a name="ln2613">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2614">            e-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2615">            num_changes ++;</a>
<a name="ln2616">            continue;</a>
<a name="ln2617">        }</a>
<a name="ln2618">case_5_9c_to_9d: /* #6 */</a>
<a name="ln2619">        /*********************************************************************/</a>
<a name="ln2620">        if ( 3 == num_bonds_non_metal &amp;&amp;</a>
<a name="ln2621">             4 == bonds_valence_non_metal &amp;&amp;</a>
<a name="ln2622">             (centerpoint_type == EL_TYPE_S) &amp;&amp;</a>
<a name="ln2623">             0 == num_O+num_S &amp;&amp; 3 == num_N &amp;&amp; 0 == num_P &amp;&amp;</a>
<a name="ln2624">             0 == num_forbidden &amp;&amp;</a>
<a name="ln2625">             3 == num_mgroups &amp;&amp; 2 == num_diff_t_groups &amp;&amp;</a>
<a name="ln2626">             2 == num_donor_endpoints &amp;&amp; 0 == num_acceptor_endpoints &amp;&amp;</a>
<a name="ln2627">             2 == num_donors          &amp;&amp; 1 == num_acceptors ) {</a>
<a name="ln2628">            /******************************************************** </a>
<a name="ln2629">             ***         InChI Tech. Man., Table 5, case 9b-&gt;8b   *** </a>
<a name="ln2630">             ******************************************************** </a>
<a name="ln2631">                 3(X)      ---&gt;         e2|          O  =  O, S, Se, Te      </a>
<a name="ln2632">                  NH---is an              N======    S  =  S, Se, Te         </a>
<a name="ln2633">         \       /   endpoint    \       /           f  =  fixed bond        </a>
<a name="ln2634">          \ 1   /  C=====Z        \  f  /  C-----Z   tg =  Mobile-H vertex   </a>
<a name="ln2635">           N===S   |     |         N===S  ||     ||  X  =  is N not an endpoint;</a>
<a name="ln2636">     is an  ev  \  |     |           ev \ ||     || -X is not terminal -O,-S,-Se,-Te or</a>
<a name="ln2637">   endpoint     2\ |  e1 |               \||  e1 ||       any N, P, As</a>
<a name="ln2638">                  NH=====tg               N------tg</a>
<a name="ln2639">               is an                          f      N, N, X, fixed double</a>
<a name="ln2640">            endpoint                                 =====================</a>
<a name="ln2641"> </a>
<a name="ln2642">            Problem:</a>
<a name="ln2643">              N1, N2, and N3 are Mobile-H endpoints and belong to the same Mobile-H group.</a>
<a name="ln2644">              Fixed bond N1==S prevents the correct structure restoration:</a>
<a name="ln2645">              H cannot migrate N3-&gt;N2-&gt;N1 because N1=S bond is fixed</a>
<a name="ln2646">            Solution:</a>
<a name="ln2647">              Move mobile H to N2 and N3 to make N1=S bond unfixed (Table 5, case 9c)</a>
<a name="ln2648">              (see fix_special_bonds(...) for details )</a>
<a name="ln2649">            *********************************************************/</a>
<a name="ln2650">            int jN1 = -1, jN2 = -1, jX = -1, n = 0;</a>
<a name="ln2651">            for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln2652">                if ( (MobileGr[j].atom_type_pVA &amp; EL_TYPE_MASK) == EL_TYPE_N ) {</a>
<a name="ln2653">                    if ( MobileGr[j].bond_type == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2654">                         !at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2655">                         !(MobileGr[j].forbidden &amp; forbidden_mask) &amp;&amp;</a>
<a name="ln2656">                         jN1 &lt; 0 ) {</a>
<a name="ln2657">                        jN1 = j;</a>
<a name="ln2658">                        n ++;</a>
<a name="ln2659">                    } else</a>
<a name="ln2660">                    if ( MobileGr[j].bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2661">                         MobileGr[j].num_bonds == 2 &amp;&amp;</a>
<a name="ln2662">                         MobileGr[j].bonds_valence &lt;= 3 &amp;&amp;</a>
<a name="ln2663">                         at[MobileGr[j].atom_number].endpoint &amp;&amp;</a>
<a name="ln2664">                         !(MobileGr[j].forbidden &amp; forbidden_mask) ) {</a>
<a name="ln2665">                        if ( jN2 &lt; 0 ) {</a>
<a name="ln2666">                            jN2 = j;</a>
<a name="ln2667">                            n ++;</a>
<a name="ln2668">                        } else</a>
<a name="ln2669">                        if ( jX &lt; 0 ) {</a>
<a name="ln2670">                            jX = j;</a>
<a name="ln2671">                            n ++;</a>
<a name="ln2672">                        }</a>
<a name="ln2673">                    }</a>
<a name="ln2674">                }</a>
<a name="ln2675">            }</a>
<a name="ln2676">            if ( n != 3 ) {</a>
<a name="ln2677">                goto case_end;</a>
<a name="ln2678">            }</a>
<a name="ln2679">            ev = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[MobileGr[jN1].ineigh];</a>
<a name="ln2680">            if ( !e-&gt;flow ) {</a>
<a name="ln2681">                goto case_end;</a>
<a name="ln2682">            }</a>
<a name="ln2683">            e1 = pBNS-&gt;edge + pVA[MobileGr[jN2].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2684">            if ( !e1-&gt;flow ) {</a>
<a name="ln2685">                goto case_end; /* should not happen ??? */</a>
<a name="ln2686">            }</a>
<a name="ln2687">            e2 = pBNS-&gt;edge + pVA[MobileGr[jX].atom_number].nTautGroupEdge - 1;</a>
<a name="ln2688">            if ( !e2-&gt;flow ) {</a>
<a name="ln2689">                goto case_end; /* should not happen ??? */</a>
<a name="ln2690">            }</a>
<a name="ln2691">            /* take care of edge e1 */</a>
<a name="ln2692">            e = e1;</a>
<a name="ln2693">            e-&gt;flow --;</a>
<a name="ln2694">            pBNS-&gt;vert[e-&gt;neighbor1].st_edge.flow --;</a>
<a name="ln2695">            pBNS-&gt;vert[e-&gt;neighbor1 ^ e-&gt;neighbor12].st_edge.flow --;</a>
<a name="ln2696">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2697">            e-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2698">            num_changes ++;</a>
<a name="ln2699">            /* take care of edge e2 */</a>
<a name="ln2700">            e = e2;</a>
<a name="ln2701">            e-&gt;flow --;</a>
<a name="ln2702">            pBNS-&gt;vert[e-&gt;neighbor1].st_edge.flow --;</a>
<a name="ln2703">            pBNS-&gt;vert[e-&gt;neighbor1 ^ e-&gt;neighbor12].st_edge.flow --;</a>
<a name="ln2704">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2705">            e-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2706">            num_changes ++;</a>
<a name="ln2707">            /* take care of edge ev: do not let it change */</a>
<a name="ln2708">            ev-&gt;forbidden |= forbidden_mask;</a>
<a name="ln2709">            continue;</a>
<a name="ln2710">        }</a>
<a name="ln2711">case_end:;</a>
<a name="ln2712">    }</a>
<a name="ln2713">/*exit_function:*/</a>
<a name="ln2714">    return num_changes;</a>
<a name="ln2715">}</a>
<a name="ln2716">/******************************************************************************************************/</a>
<a name="ln2717">/* Replace ambiguous neutral (+)edge-&gt;flow=0, (-)edge-&gt;flow=1 with (+)edge-&gt;flow=1, (-)edge-&gt;flow=0   */</a>
<a name="ln2718">/******************************************************************************************************/</a>
<a name="ln2719">int RearrangePlusMinusEdgesFlow( BN_STRUCT *pBNS, BN_DATA *pBD, VAL_AT *pVA,</a>
<a name="ln2720">                                 ALL_TC_GROUPS *pTCGroups, int forbidden_edge_mask )</a>
<a name="ln2721">{</a>
<a name="ln2722">    int ret, ePlus, eMinus;</a>
<a name="ln2723">    EDGE_LIST NewlyFixedEdges;</a>
<a name="ln2724">    BNS_EDGE *pPlus, *pMinus;</a>
<a name="ln2725">    int i, k1, k2, num_found, num_tot, delta, v1, v2;</a>
<a name="ln2726"> </a>
<a name="ln2727">    ret = 0;</a>
<a name="ln2728"> </a>
<a name="ln2729">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln2730">    for ( i = 0, num_found = num_tot = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln2731">        eMinus = pVA[i].nCMinusGroupEdge - 1;</a>
<a name="ln2732">        ePlus  = pVA[i].nCPlusGroupEdge - 1;</a>
<a name="ln2733">        num_tot += (eMinus &gt;= 0) + (ePlus &gt;= 0);</a>
<a name="ln2734">        if ( eMinus &gt;= 0 &amp;&amp; ePlus &gt;= 0 ) {</a>
<a name="ln2735">            pPlus  = pBNS-&gt;edge + ePlus;</a>
<a name="ln2736">            pMinus = pBNS-&gt;edge + eMinus;</a>
<a name="ln2737">            if ( (k1=pMinus-&gt;flow) &gt; 0 &amp;&amp;  (k2=pPlus-&gt;cap-pPlus-&gt;flow) &gt; 0 ) {</a>
<a name="ln2738">                num_found ++;</a>
<a name="ln2739">            }</a>
<a name="ln2740">        } </a>
<a name="ln2741">    }</a>
<a name="ln2742">    if ( !num_found ) {</a>
<a name="ln2743">        goto exit_function;</a>
<a name="ln2744">    }</a>
<a name="ln2745">    if ( (ret = AllocEdgeList( &amp;NewlyFixedEdges, num_tot + pBNS-&gt;num_bonds )) ) {</a>
<a name="ln2746">        goto exit_function;</a>
<a name="ln2747">    }</a>
<a name="ln2748"> </a>
<a name="ln2749">    for ( i = 0, num_found = num_tot = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln2750">        eMinus = pVA[i].nCMinusGroupEdge - 1;</a>
<a name="ln2751">        ePlus  = pVA[i].nCPlusGroupEdge - 1;</a>
<a name="ln2752">        num_tot += (eMinus &gt;= 0) + (ePlus &gt;= 0);</a>
<a name="ln2753">        if ( eMinus &gt;= 0 &amp;&amp; ePlus &gt;= 0 ) {</a>
<a name="ln2754">            pPlus  = pBNS-&gt;edge + ePlus;</a>
<a name="ln2755">            pMinus = pBNS-&gt;edge + eMinus;</a>
<a name="ln2756">            if ( (k1=pMinus-&gt;flow) &gt; 0 &amp;&amp;  (k2=pPlus-&gt;cap  - pPlus-&gt;flow) &gt; 0 ) {</a>
<a name="ln2757">                /* rearrange */</a>
<a name="ln2758">                v1 = pMinus-&gt;neighbor1;</a>
<a name="ln2759">                v2 = pMinus-&gt;neighbor12 ^ v1;</a>
<a name="ln2760">                delta = inchi_min(k1,k2);</a>
<a name="ln2761">                pMinus-&gt;flow -= delta;</a>
<a name="ln2762">                pBNS-&gt;vert[v1].st_edge.flow -= delta;</a>
<a name="ln2763">                pBNS-&gt;vert[v2].st_edge.flow -= delta;</a>
<a name="ln2764">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2765">            }</a>
<a name="ln2766">            /* fix charges */</a>
<a name="ln2767">            pPlus-&gt;forbidden  |= forbidden_edge_mask;</a>
<a name="ln2768">            pMinus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2769">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, eMinus, 0 )) ||</a>
<a name="ln2770">                 (ret = AddToEdgeList( &amp;NewlyFixedEdges, ePlus, 0 ))) {</a>
<a name="ln2771">                goto exit_function;</a>
<a name="ln2772">            }</a>
<a name="ln2773">        } else</a>
<a name="ln2774">        if ( eMinus &gt;= 0 ) {</a>
<a name="ln2775">            /* fix charges */</a>
<a name="ln2776">            pMinus = pBNS-&gt;edge + eMinus;</a>
<a name="ln2777">            pMinus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2778">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, eMinus, 0 )) ) {</a>
<a name="ln2779">                goto exit_function;</a>
<a name="ln2780">            }</a>
<a name="ln2781">        } else</a>
<a name="ln2782">        if ( ePlus &gt;= 0 ) {</a>
<a name="ln2783">            /* fix charges */</a>
<a name="ln2784">            pPlus  = pBNS-&gt;edge + ePlus;</a>
<a name="ln2785">            pPlus-&gt;forbidden  |= forbidden_edge_mask;</a>
<a name="ln2786">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, ePlus, 0 )) ) {</a>
<a name="ln2787">                goto exit_function;</a>
<a name="ln2788">            }</a>
<a name="ln2789">        }</a>
<a name="ln2790">    }</a>
<a name="ln2791">    for ( i = 0; i &lt; pBNS-&gt;num_bonds; i ++ ) {</a>
<a name="ln2792">        pBNS-&gt;edge[i].forbidden |= forbidden_edge_mask;</a>
<a name="ln2793">        if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, i, 0 )) ) {</a>
<a name="ln2794">            goto exit_function;</a>
<a name="ln2795">        }</a>
<a name="ln2796">    }</a>
<a name="ln2797">    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2798">    RemoveForbiddenEdgeMask( pBNS, &amp;NewlyFixedEdges, forbidden_edge_mask );</a>
<a name="ln2799">    if ( ret &lt; 0 ) {</a>
<a name="ln2800">        goto exit_function;</a>
<a name="ln2801">    }</a>
<a name="ln2802"> </a>
<a name="ln2803">exit_function:</a>
<a name="ln2804">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_FREE );</a>
<a name="ln2805">    return ret;</a>
<a name="ln2806">}</a>
<a name="ln2807">/******************************************************************************************************/</a>
<a name="ln2808">int IncrementZeroOrderBondsToHeteroat( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln2809">                                            inp_ATOM *at, inp_ATOM *at2,</a>
<a name="ln2810">                                            VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln2811">                                            int *pnNumRunBNS, int *pnTotalDelta,</a>
<a name="ln2812">                                            int forbidden_edge_mask)</a>
<a name="ln2813">{</a>
<a name="ln2814">#define FIX_BOND_ADD_ALLOC 128    </a>
<a name="ln2815">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln2816">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln2817">    BNS_EDGE   *pe, *peZero, *peNeighMeigh = NULL, *peMeFlower;</a>
<a name="ln2818">    BNS_VERTEX *pMeFlower = NULL, *pNeigh = NULL, *pNeighNeigh=NULL;</a>
<a name="ln2819">    </a>
<a name="ln2820">    int i, j, k, ret2, ret, bFixedCarbonCharges, num_changes, bSuccess;</a>
<a name="ln2821">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln2822">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln2823">    int len_at = num_at + num_deleted_H;</a>
<a name="ln2824">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln2825">    Vertex vMeFlower0, vNeigh, vNeighMeigh = NO_VERTEX;</a>
<a name="ln2826">    </a>
<a name="ln2827">    EDGE_LIST CarbonChargeEdges;</a>
<a name="ln2828">    EDGE_LIST NewlyFixedEdges;</a>
<a name="ln2829"> </a>
<a name="ln2830">    ret = 0;</a>
<a name="ln2831">    num_changes = 0;</a>
<a name="ln2832"> </a>
<a name="ln2833">    bFixedCarbonCharges = 0;</a>
<a name="ln2834">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln2835">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln2836"> </a>
<a name="ln2837">    if ( !pTCGroups-&gt;num_metal_atoms || </a>
<a name="ln2838">         0 &gt; (k=pTCGroups-&gt;nGroup[TCG_MeFlower0]) ||</a>
<a name="ln2839">         0 &gt; (vMeFlower0 = pTCGroups-&gt;pTCG[k].nVertexNumber)) {</a>
<a name="ln2840">        goto exit_function;</a>
<a name="ln2841">    }</a>
<a name="ln2842"> </a>
<a name="ln2843">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln2844">    pStruct-&gt;at = at2;</a>
<a name="ln2845">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2846">    pStruct-&gt;at = at;</a>
<a name="ln2847">    if ( ret2 &lt; 0 ) {</a>
<a name="ln2848">        ret = ret2;</a>
<a name="ln2849">        goto exit_function;</a>
<a name="ln2850">    }</a>
<a name="ln2851">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2852">        if ( !pVA[i].cMetal || pVA[i].nMetalGroupEdge &lt;= 0 ) {</a>
<a name="ln2853">            continue;</a>
<a name="ln2854">        }</a>
<a name="ln2855">        peMeFlower = pBNS-&gt;edge + pVA[i].nMetalGroupEdge-1;</a>
<a name="ln2856">        if ( vMeFlower0 != (peMeFlower-&gt;neighbor12 ^ i) ) {</a>
<a name="ln2857">            ret = RI_ERR_PROGR;</a>
<a name="ln2858">            goto exit_function;</a>
<a name="ln2859">        }</a>
<a name="ln2860">        pMeFlower = pBNS-&gt;vert + vMeFlower0;</a>
<a name="ln2861"> </a>
<a name="ln2862">        for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln2863">            if ( !peMeFlower-&gt;flow ) {</a>
<a name="ln2864">                break; /* cannot do anything */</a>
<a name="ln2865">            }</a>
<a name="ln2866">            if ( !(at2[i].bond_type[j] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln2867">                /* found a zero order bond */</a>
<a name="ln2868">                if ( !bFixedCarbonCharges ) {</a>
<a name="ln2869">                    /* do not let carbon atoms get charged */</a>
<a name="ln2870">                    if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln2871">                        goto exit_function;</a>
<a name="ln2872">                    }</a>
<a name="ln2873">                    bFixedCarbonCharges ++;</a>
<a name="ln2874">                }</a>
<a name="ln2875">                peZero = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[j];</a>
<a name="ln2876">                if ( peZero-&gt;flow ) {</a>
<a name="ln2877">                    ret = RI_ERR_PROGR;</a>
<a name="ln2878">                    goto exit_function;</a>
<a name="ln2879">                }</a>
<a name="ln2880">                /* fix other edges */</a>
<a name="ln2881">                for ( k = 0; k &lt; at2[i].valence; k ++ ) {</a>
<a name="ln2882">                    pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[k];</a>
<a name="ln2883">                    if ( pe-&gt;flow == 1 &amp;&amp; !(pe-&gt;forbidden &amp; forbidden_edge_mask) ) {</a>
<a name="ln2884">                        if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, pe - pBNS-&gt;edge, FIX_BOND_ADD_ALLOC )) ) {</a>
<a name="ln2885">                            goto exit_function;</a>
<a name="ln2886">                        }</a>
<a name="ln2887">                        pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2888">                    }</a>
<a name="ln2889">                }</a>
<a name="ln2890">                /* do not create =N(+)= in a ring or #O(+) terminal */</a>
<a name="ln2891">                for ( k = 0; k &lt; num_at; k ++ ) {</a>
<a name="ln2892">                    if ( !pVA[k].cMetal &amp;&amp; pVA[k].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln2893">                         at2[k].valence == 2 &amp;&amp; !at2[k].num_H &amp;&amp; pVA[k].cMinRingSize &lt;= 6 &amp;&amp;</a>
<a name="ln2894">                         pVA[k].nCPlusGroupEdge &gt; 0 &amp;&amp;</a>
<a name="ln2895">                         (pe=pBNS-&gt;edge + pVA[k].nCPlusGroupEdge-1)-&gt;flow==1 &amp;&amp;</a>
<a name="ln2896">                         !(pe-&gt;forbidden &amp; forbidden_edge_mask)) {</a>
<a name="ln2897"> </a>
<a name="ln2898">                        if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, pe - pBNS-&gt;edge, FIX_BOND_ADD_ALLOC )) ) {</a>
<a name="ln2899">                            goto exit_function;</a>
<a name="ln2900">                        }</a>
<a name="ln2901">                        pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2902">                    }</a>
<a name="ln2903">                }</a>
<a name="ln2904"> </a>
<a name="ln2905">                /* metal's neighbor connected by a zero-order bond */</a>
<a name="ln2906">                pNeigh = pBNS-&gt;vert + (vNeigh = at2[i].neighbor[j]);</a>
<a name="ln2907">                /*for ( k = 0; k &lt; pNeigh-&gt;num_adj_edges; k ++ )*/</a>
<a name="ln2908">                for ( k = pNeigh-&gt;num_adj_edges-1; 0 &lt;= k; k -- )</a>
<a name="ln2909">                {</a>
<a name="ln2910">                    peNeighMeigh = pBNS-&gt;edge + pNeigh-&gt;iedge[k];</a>
<a name="ln2911">                    if ( !peNeighMeigh-&gt;flow ) {</a>
<a name="ln2912">                        continue;</a>
<a name="ln2913">                    }</a>
<a name="ln2914">                    vNeighMeigh = peNeighMeigh-&gt;neighbor12 ^ vNeigh;</a>
<a name="ln2915">                    if ( vNeighMeigh != i &amp;&amp; vNeighMeigh != vMeFlower0 ) {</a>
<a name="ln2916">                        /* metal neighbor's neighbor connected by a not-zero-order bond */</a>
<a name="ln2917">                        pNeighNeigh = pBNS-&gt;vert + vNeighMeigh;</a>
<a name="ln2918">                        break; /* found */</a>
<a name="ln2919">                    }</a>
<a name="ln2920">                }</a>
<a name="ln2921">                if ( k &lt; 0 ) {</a>
<a name="ln2922">                    continue; /* neighbor not found */</a>
<a name="ln2923">                }</a>
<a name="ln2924">                peZero-&gt;flow ++;</a>
<a name="ln2925">                peZero-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2926">                peMeFlower-&gt;flow --;</a>
<a name="ln2927">                peNeighMeigh-&gt;flow --;</a>
<a name="ln2928">                pMeFlower-&gt;st_edge.flow --;</a>
<a name="ln2929">                pNeighNeigh-&gt;st_edge.flow --;</a>
<a name="ln2930">                pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln2931">                /* test */</a>
<a name="ln2932">                bSuccess = 0;</a>
<a name="ln2933">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2934">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2935"> </a>
<a name="ln2936">                if ( ret == 1 &amp;&amp; ((vPathEnd == vMeFlower0 &amp;&amp; vPathStart == vNeighMeigh) ||</a>
<a name="ln2937">                                  (vPathEnd == vNeighMeigh &amp;&amp; vPathStart == vMeFlower0)) &amp;&amp; abs(nDeltaCharge) &lt;= 2 ) {</a>
<a name="ln2938">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2939">                    if ( ret &gt; 0 ) {</a>
<a name="ln2940">                        (*pnNumRunBNS) ++;</a>
<a name="ln2941">                        *pnTotalDelta += ret;</a>
<a name="ln2942">                        num_changes ++;</a>
<a name="ln2943">                        bSuccess = ret;</a>
<a name="ln2944">                    }</a>
<a name="ln2945">                    if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, peZero - pBNS-&gt;edge, FIX_BOND_ADD_ALLOC )) ) {</a>
<a name="ln2946">                        goto exit_function;</a>
<a name="ln2947">                    }</a>
<a name="ln2948">                } else {</a>
<a name="ln2949">                    peZero-&gt;flow --;</a>
<a name="ln2950">                    peZero-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln2951">                    peMeFlower-&gt;flow ++;</a>
<a name="ln2952">                    peNeighMeigh-&gt;flow ++;</a>
<a name="ln2953">                    pMeFlower-&gt;st_edge.flow ++;</a>
<a name="ln2954">                    pNeighNeigh-&gt;st_edge.flow ++;</a>
<a name="ln2955">                    pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln2956">                }</a>
<a name="ln2957">                RemoveForbiddenEdgeMask( pBNS, &amp;NewlyFixedEdges, forbidden_edge_mask );</a>
<a name="ln2958">                NewlyFixedEdges.num_edges = 0;</a>
<a name="ln2959">                if ( bSuccess ) {</a>
<a name="ln2960">                    /* update at2[] */</a>
<a name="ln2961">                    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln2962">                    pStruct-&gt;at = at2;</a>
<a name="ln2963">                    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2964">                    pStruct-&gt;at = at;</a>
<a name="ln2965">                    if ( ret2 &lt; 0 ) {</a>
<a name="ln2966">                        ret = ret2;</a>
<a name="ln2967">                        goto exit_function;</a>
<a name="ln2968">                    }</a>
<a name="ln2969">                }</a>
<a name="ln2970">            }</a>
<a name="ln2971">        }</a>
<a name="ln2972">    }</a>
<a name="ln2973">    ret = num_changes;</a>
<a name="ln2974"> </a>
<a name="ln2975">exit_function:</a>
<a name="ln2976">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln2977">    RemoveForbiddenEdgeMask( pBNS, &amp;NewlyFixedEdges, forbidden_edge_mask );</a>
<a name="ln2978">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln2979">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_FREE );</a>
<a name="ln2980">    return ret;</a>
<a name="ln2981">}</a>
<a name="ln2982">/***********************************************************************</a>
<a name="ln2983">        NH2                NH2</a>
<a name="ln2984">           \                  \</a>
<a name="ln2985">            C==S(+)-   =&gt;      C(+)-S-   where NH2 are not tautomeric</a>
<a name="ln2986">           /                  /</a>
<a name="ln2987">        NH2                NH2</a>
<a name="ln2988">************************************************************************/</a>
<a name="ln2989">int MovePlusFromS2DiaminoCarbon( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln2990">                    inp_ATOM *at, inp_ATOM *at2,</a>
<a name="ln2991">                    VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln2992">                    int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln2993">{</a>
<a name="ln2994">    int i, j, k, ret, ret2, cur_success;</a>
<a name="ln2995">    int delta;</a>
<a name="ln2996">    EdgeIndex        ePlusS, ePlusC, eMinusC, e;</a>
<a name="ln2997">    BNS_VERTEX *pvS, *pvC, *pv1, *pv2;</a>
<a name="ln2998">    BNS_EDGE   *pePlusS, *pePlusC, *pe1, *pe2, *peCN[3], *peSC, *pe;</a>
<a name="ln2999">    Vertex     vC, vN;</a>
<a name="ln3000">    </a>
<a name="ln3001">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln3002">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln3003">    int len_at = num_at + num_deleted_H;</a>
<a name="ln3004">    </a>
<a name="ln3005">    Vertex     vPathStart, vPathEnd, v1, v2;</a>
<a name="ln3006">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln3007"> </a>
<a name="ln3008">    EDGE_LIST AllChargeEdges;</a>
<a name="ln3009">    </a>
<a name="ln3010">    ret = 0;</a>
<a name="ln3011">    cur_success = 0;</a>
<a name="ln3012"> </a>
<a name="ln3013">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln3014"> </a>
<a name="ln3015">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln3016">    pStruct-&gt;at = at2;</a>
<a name="ln3017">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln3018">    pStruct-&gt;at = at;</a>
<a name="ln3019">    if ( ret2 &lt; 0 ) {</a>
<a name="ln3020">        ret = ret2;</a>
<a name="ln3021">        goto exit_function;</a>
<a name="ln3022">    }</a>
<a name="ln3023">    /* find (NH2)C=S(+) */</a>
<a name="ln3024">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3025">        if ( !pVA[i].cMetal &amp;&amp; pVA[i].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln3026">             at2[i].valence == 2 &amp;&amp; </a>
<a name="ln3027">             (pvS = pBNS-&gt;vert+i)-&gt;st_edge.cap == pvS-&gt;st_edge.flow &amp;&amp;</a>
<a name="ln3028">             0 &lt;= (ePlusS = pVA[i].nCPlusGroupEdge-1) &amp;&amp; !(pePlusS=pBNS-&gt;edge+ePlusS)-&gt;flow &amp;&amp; /* S(+) */</a>
<a name="ln3029">             (pe1=pBNS-&gt;edge + pvS-&gt;iedge[0])-&gt;flow + </a>
<a name="ln3030">             (pe2=pBNS-&gt;edge + pvS-&gt;iedge[1])-&gt;flow == 1 /* -S(+)= */ &amp;&amp;</a>
<a name="ln3031">             pVA[vC = (peSC=pe1-&gt;flow? pe1 : pe2)-&gt;neighbor12 ^ i].cNumValenceElectrons == 4 &amp;&amp;</a>
<a name="ln3032">             at2[vC].valence == 3 &amp;&amp;</a>
<a name="ln3033">             0 &lt;= (ePlusC=pVA[vC].nCPlusGroupEdge-1) &amp;&amp; (pePlusC=pBNS-&gt;edge+ePlusC)-&gt;flow &amp;&amp;</a>
<a name="ln3034">             !(0 &lt;= (eMinusC=pVA[vC].nCMinusGroupEdge-1) &amp;&amp; pBNS-&gt;edge[eMinusC].flow ) ) {</a>
<a name="ln3035">            /* found &gt;C=S(+)- */</a>
<a name="ln3036">            pvC = pBNS-&gt;vert + vC;</a>
<a name="ln3037">            for ( j = k = 0; j &lt; at[vC].valence; j ++ ) {</a>
<a name="ln3038">                if ( peSC != (peCN[k] = pBNS-&gt;edge + pvC-&gt;iedge[j]) &amp;&amp; !peCN[k]-&gt;flow ) {</a>
<a name="ln3039">                    k ++; /* a single bond from C */</a>
<a name="ln3040">                }</a>
<a name="ln3041">            }</a>
<a name="ln3042">            if ( k != 2 ) {</a>
<a name="ln3043">                continue;</a>
<a name="ln3044">            }</a>
<a name="ln3045">            for ( j = 0; j &lt; k; j ++ ) {</a>
<a name="ln3046">                vN = peCN[j]-&gt;neighbor12 ^ vC;</a>
<a name="ln3047">                if ( pVA[vN].cNumValenceElectrons != 5 ||</a>
<a name="ln3048">                     pBNS-&gt;vert[vN].st_edge.cap != pBNS-&gt;vert[vN].st_edge.flow ||</a>
<a name="ln3049">                     at2[vN].num_H != 2 ||</a>
<a name="ln3050">                     at2[vN].endpoint || (pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;endpoint[vN]) ) {</a>
<a name="ln3051">                    break; /* does not fit the pattern */</a>
<a name="ln3052">                }</a>
<a name="ln3053">            }</a>
<a name="ln3054">            if ( j != k ) {</a>
<a name="ln3055">                continue;</a>
<a name="ln3056">            }</a>
<a name="ln3057">            /* fix all charges */</a>
<a name="ln3058">            if ( !AllChargeEdges.num_edges ) {</a>
<a name="ln3059">                for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln3060">                    if ( 0 &lt;= (e = pVA[j].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln3061">                         (ret = AddToEdgeList( &amp;AllChargeEdges, e, 2*num_at )) ) {</a>
<a name="ln3062">                        goto exit_function;</a>
<a name="ln3063">                    }</a>
<a name="ln3064">                    if ( 0 &lt;= (e = pVA[j].nCMinusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln3065">                         (ret = AddToEdgeList( &amp;AllChargeEdges, e, 2*num_at )) ) {</a>
<a name="ln3066">                        goto exit_function;</a>
<a name="ln3067">                    }</a>
<a name="ln3068">                }</a>
<a name="ln3069">            }</a>
<a name="ln3070">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3071">            pePlusS-&gt;forbidden &amp;= ~forbidden_edge_mask;</a>
<a name="ln3072">            pe   = pePlusC;</a>
<a name="ln3073">            if ( !pe-&gt;flow )</a>
<a name="ln3074">                continue;</a>
<a name="ln3075">            delta = 1;</a>
<a name="ln3076">            pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3077">            pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3078"> </a>
<a name="ln3079">            pe-&gt;flow -= delta;</a>
<a name="ln3080">            pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln3081">            pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln3082">            pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln3083"> </a>
<a name="ln3084">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3085">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3086"> </a>
<a name="ln3087">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3088">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln3089">                /* Remover (+)charge from S =&gt; nDeltaCharge == -1 */</a>
<a name="ln3090">                /* Flow change on pe (+)charge edge (atom S) is not known to RunBnsTestOnce()) */</a>
<a name="ln3091">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3092">                if ( ret &gt; 0 ) {</a>
<a name="ln3093">                    (*pnNumRunBNS) ++;</a>
<a name="ln3094">                    cur_success ++;</a>
<a name="ln3095">                }</a>
<a name="ln3096">            } else {</a>
<a name="ln3097">                pe-&gt;flow += delta;</a>
<a name="ln3098">                pv1-&gt;st_edge.flow += delta;</a>
<a name="ln3099">                pv2-&gt;st_edge.flow += delta;</a>
<a name="ln3100">                pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln3101">            }</a>
<a name="ln3102">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3103">        }</a>
<a name="ln3104">    }</a>
<a name="ln3105">exit_function:</a>
<a name="ln3106">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln3107">    return ret;</a>
<a name="ln3108">}</a>
<a name="ln3109">/******************************************************************************************************/</a>
<a name="ln3110">int EliminateChargeSeparationOnHeteroatoms( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln3111">                                            inp_ATOM *at, inp_ATOM *at2,</a>
<a name="ln3112">                                            VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3113">                                            int *pnNumRunBNS, int *pnTotalDelta,</a>
<a name="ln3114">                                            int forbidden_edge_mask, int forbidden_stereo_edge_mask)</a>
<a name="ln3115">    /********* Avoid charge separation on heteroatoms ******************/</a>
<a name="ln3116">{</a>
<a name="ln3117">    int i, j, k, ret, ret2, num_pos, num_neg, num_min=0, bFixedCarbonCharges;</a>
<a name="ln3118">    int vPlusSuper;  /* (+)super vertex */</a>
<a name="ln3119">    int ePlusSuper;  /* edge from vPlusSuper to (+/-) */</a>
<a name="ln3120">    int vPlusMinus;  /* (+/-) vertex */</a>
<a name="ln3121">    int nDeltaPlus1, nDeltaMinus1, delta;</a>
<a name="ln3122">    BNS_VERTEX *pvPlusSuper, *pvPlusMinus;</a>
<a name="ln3123">    BNS_EDGE   *pEdge;</a>
<a name="ln3124">    </a>
<a name="ln3125">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln3126">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln3127">    int len_at = num_at + num_deleted_H;</a>
<a name="ln3128">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln3129">    </a>
<a name="ln3130">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln3131">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln3132"> </a>
<a name="ln3133">    EDGE_LIST FixedLargeRingStereoEdges, CarbonChargeEdges;</a>
<a name="ln3134">    </a>
<a name="ln3135">    ret = 0;</a>
<a name="ln3136"> </a>
<a name="ln3137">    AllocEdgeList( &amp;FixedLargeRingStereoEdges, EDGE_LIST_CLEAR );</a>
<a name="ln3138">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln3139">    bFixedCarbonCharges = 0;</a>
<a name="ln3140"> </a>
<a name="ln3141">    if ( forbidden_stereo_edge_mask ) {</a>
<a name="ln3142">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3143">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln3144">                if ( pBNS-&gt;edge[k = pBNS-&gt;vert[i].iedge[j]].forbidden == forbidden_stereo_edge_mask ) {</a>
<a name="ln3145">                    int nMinRingSize = is_bond_in_Nmax_memb_ring( at2, i, j, pStruct-&gt;pbfsq-&gt;q,</a>
<a name="ln3146">                                                             pStruct-&gt;pbfsq-&gt;nAtomLevel,</a>
<a name="ln3147">                                                             pStruct-&gt;pbfsq-&gt;cSource, 99 /* max ring size */ );</a>
<a name="ln3148">                    if ( 0 &lt; nMinRingSize &amp;&amp; (ret = AddToEdgeList( &amp;FixedLargeRingStereoEdges, k, 64 ))) {</a>
<a name="ln3149">                        goto exit_function;</a>
<a name="ln3150">                    }</a>
<a name="ln3151">                }</a>
<a name="ln3152">            }</a>
<a name="ln3153">        }</a>
<a name="ln3154">        if ( !FixedLargeRingStereoEdges.num_edges ) {</a>
<a name="ln3155">            goto exit_function;</a>
<a name="ln3156">        } else {</a>
<a name="ln3157">            /* allow stereobonds in rings change */</a>
<a name="ln3158">            RemoveForbiddenEdgeMask( pBNS, &amp;FixedLargeRingStereoEdges, forbidden_stereo_edge_mask );</a>
<a name="ln3159">        }</a>
<a name="ln3160">    }</a>
<a name="ln3161"> </a>
<a name="ln3162">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln3163">    pStruct-&gt;at = at2;</a>
<a name="ln3164">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln3165">    pStruct-&gt;at = at;</a>
<a name="ln3166">    if ( ret2 &lt; 0 ) {</a>
<a name="ln3167">        ret = ret2;</a>
<a name="ln3168">        goto exit_function;</a>
<a name="ln3169">    }</a>
<a name="ln3170">    /* count charges */</a>
<a name="ln3171">    num_pos = num_neg = 0;</a>
<a name="ln3172">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3173">        if ( !pVA[i].cMetal &amp;&amp; !at2[i].radical ) {</a>
<a name="ln3174">            num_pos += ( at2[i].charge &gt; 0 );</a>
<a name="ln3175">            num_neg += ( at2[i].charge &lt; 0 );</a>
<a name="ln3176">        }</a>
<a name="ln3177">    }</a>
<a name="ln3178">    num_min = inchi_min( num_pos, num_neg );</a>
<a name="ln3179"> </a>
<a name="ln3180"> </a>
<a name="ln3181">    if ( num_min &amp;&amp; </a>
<a name="ln3182">         (k          = pTCGroups-&gt;nGroup[TCG_Plus]) &gt;= 0 &amp;&amp;</a>
<a name="ln3183">         (ePlusSuper = pTCGroups-&gt;pTCG[k].nForwardEdge) &gt; 0 &amp;&amp;</a>
<a name="ln3184">         (vPlusSuper = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at &amp;&amp;</a>
<a name="ln3185">         !(pEdge=pBNS-&gt;edge + ePlusSuper)-&gt;forbidden ) {</a>
<a name="ln3186"> </a>
<a name="ln3187">        vPlusMinus = pEdge-&gt;neighbor12 ^ vPlusSuper;</a>
<a name="ln3188">        pvPlusSuper = pBNS-&gt;vert + vPlusSuper;</a>
<a name="ln3189">        pvPlusMinus = pBNS-&gt;vert + vPlusMinus;</a>
<a name="ln3190">        num_min     = inchi_min( num_min, pEdge-&gt;flow );</a>
<a name="ln3191">        nDeltaPlus1  = pvPlusSuper-&gt;st_edge.cap - pvPlusSuper-&gt;st_edge.flow;</a>
<a name="ln3192">        nDeltaMinus1 = pvPlusMinus-&gt;st_edge.cap - pvPlusMinus-&gt;st_edge.flow;</a>
<a name="ln3193">        if ( num_min &amp;&amp; (!nDeltaPlus1 &amp;&amp; !nDeltaMinus1 ) ) {</a>
<a name="ln3194">            if ( !bFixedCarbonCharges ) { /* 02-02-2006 */</a>
<a name="ln3195">                /* do not let carbon atoms get charged */</a>
<a name="ln3196">                if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln3197">                    goto exit_function;</a>
<a name="ln3198">                }</a>
<a name="ln3199">                bFixedCarbonCharges ++;</a>
<a name="ln3200">            }</a>
<a name="ln3201">            delta = 1;</a>
<a name="ln3202">            pEdge-&gt;forbidden          |= forbidden_edge_mask;</a>
<a name="ln3203">            pBNS-&gt;edge_forbidden_mask |= forbidden_edge_mask;</a>
<a name="ln3204">            for ( i = 0; i &lt; num_min; i += delta ) {</a>
<a name="ln3205">                /* cancel 1 pair of charges at a time   */</a>
<a name="ln3206">                /* an attempt to cancel all at once may */</a>
<a name="ln3207">                /* convert a pair of N(IV)(+) into a pair of N(V) neutral with total charge reduced by 2 */</a>
<a name="ln3208">                pEdge-&gt;flow               -= delta;</a>
<a name="ln3209">                pvPlusSuper-&gt;st_edge.flow -= delta;</a>
<a name="ln3210">                pvPlusMinus-&gt;st_edge.flow -= delta;</a>
<a name="ln3211">                pBNS-&gt;tot_st_flow         -= 2*delta;</a>
<a name="ln3212">                /* test for charhe cancellation */</a>
<a name="ln3213">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3214">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3215">                if ( ret &lt; 0 ) {</a>
<a name="ln3216">                    goto exit_function;</a>
<a name="ln3217">                }</a>
<a name="ln3218">                if ( ret == 1 &amp;&amp; ((vPathEnd == vPlusSuper &amp;&amp; vPathStart == vPlusMinus) ||</a>
<a name="ln3219">                                  (vPathEnd == vPlusMinus &amp;&amp; vPathStart == vPlusSuper)) &amp;&amp; nDeltaCharge &lt; 0 ) {</a>
<a name="ln3220">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3221">                    (*pnNumRunBNS) ++;</a>
<a name="ln3222">                    if ( ret &lt; 0 ) {</a>
<a name="ln3223">                        goto exit_function;</a>
<a name="ln3224">                    } else</a>
<a name="ln3225">                    if ( ret == 1 ) {</a>
<a name="ln3226">                        *pnTotalDelta += ret;</a>
<a name="ln3227">                    } else {</a>
<a name="ln3228">                        ret = RI_ERR_PROGR;</a>
<a name="ln3229">                        goto exit_function;</a>
<a name="ln3230">                    }</a>
<a name="ln3231">                } else {</a>
<a name="ln3232">                    pEdge-&gt;flow               += delta;</a>
<a name="ln3233">                    pvPlusSuper-&gt;st_edge.flow += delta;</a>
<a name="ln3234">                    pvPlusMinus-&gt;st_edge.flow += delta;</a>
<a name="ln3235">                    pBNS-&gt;tot_st_flow         += 2*delta;</a>
<a name="ln3236">                    break;</a>
<a name="ln3237">                }</a>
<a name="ln3238">            }</a>
<a name="ln3239">            num_min -= i; /* how many pairs of charges left */</a>
<a name="ln3240">            pEdge-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3241">        }</a>
<a name="ln3242">        nDeltaPlus1  = pvPlusSuper-&gt;st_edge.cap - pvPlusSuper-&gt;st_edge.flow;</a>
<a name="ln3243">        nDeltaMinus1 = pvPlusMinus-&gt;st_edge.cap - pvPlusMinus-&gt;st_edge.flow;</a>
<a name="ln3244">        if ( num_min &gt; 1 &amp;&amp; (!nDeltaPlus1 &amp;&amp; !nDeltaMinus1 ) ) {</a>
<a name="ln3245">            delta = 2;</a>
<a name="ln3246">            pEdge-&gt;forbidden          |= forbidden_edge_mask;</a>
<a name="ln3247">            pBNS-&gt;edge_forbidden_mask |= forbidden_edge_mask;</a>
<a name="ln3248">            for ( i = 0; i &lt; num_min; i += delta ) {</a>
<a name="ln3249">                /* cancel 2 pairs of opposite charges at a time   */</a>
<a name="ln3250">                /* 1. test cancellation of a pair of (+) charges */</a>
<a name="ln3251">                pvPlusSuper-&gt;st_edge.cap += delta;</a>
<a name="ln3252">                pBNS-&gt;tot_st_cap         += delta;</a>
<a name="ln3253">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3254">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3255">                if ( ret &lt; 0 ) {</a>
<a name="ln3256">                    goto exit_function;</a>
<a name="ln3257">                }</a>
<a name="ln3258">                pvPlusSuper-&gt;st_edge.cap -= delta;</a>
<a name="ln3259">                pBNS-&gt;tot_st_cap         -= delta;</a>
<a name="ln3260">                if ( ret != 1 || (vPathEnd != vPlusSuper || vPathStart != vPlusSuper) || nDeltaCharge &gt;= 0 ) {</a>
<a name="ln3261">                    break;</a>
<a name="ln3262">                }</a>
<a name="ln3263">                /* 2. test cancellation of a pair of (-) charges */</a>
<a name="ln3264">                pvPlusMinus-&gt;st_edge.cap += delta;</a>
<a name="ln3265">                pBNS-&gt;tot_st_cap         += delta;</a>
<a name="ln3266">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3267">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3268">                if ( ret &lt; 0 ) {</a>
<a name="ln3269">                    goto exit_function;</a>
<a name="ln3270">                }</a>
<a name="ln3271">                pvPlusMinus-&gt;st_edge.cap -= delta;</a>
<a name="ln3272">                pBNS-&gt;tot_st_cap         -= delta;</a>
<a name="ln3273">                if ( ret != 1 || (vPathEnd != vPlusMinus || vPathStart != vPlusMinus) || nDeltaCharge &gt;= 0 ) {</a>
<a name="ln3274">                    break;</a>
<a name="ln3275">                }</a>
<a name="ln3276">                /* 3. Actually cancel the pair of charges */</a>
<a name="ln3277">                pEdge-&gt;flow               -= delta;</a>
<a name="ln3278">                pvPlusSuper-&gt;st_edge.flow -= delta;</a>
<a name="ln3279">                pvPlusMinus-&gt;st_edge.flow -= delta;</a>
<a name="ln3280">                pBNS-&gt;tot_st_flow         -= 2*delta;</a>
<a name="ln3281">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3282">                (*pnNumRunBNS) ++;</a>
<a name="ln3283">                if ( ret &lt; 0 ) {</a>
<a name="ln3284">                    goto exit_function;</a>
<a name="ln3285">                } else</a>
<a name="ln3286">                if ( ret == 2 ) {</a>
<a name="ln3287">                    *pnTotalDelta += ret;</a>
<a name="ln3288">                } else {</a>
<a name="ln3289">                    ret = RI_ERR_PROGR;</a>
<a name="ln3290">                    goto exit_function;</a>
<a name="ln3291">                }</a>
<a name="ln3292">            }</a>
<a name="ln3293">            num_min -= i; /* how many pairs of charges left */</a>
<a name="ln3294">            pEdge-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3295">        }</a>
<a name="ln3296">    }</a>
<a name="ln3297">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln3298">    pStruct-&gt;at = at;</a>
<a name="ln3299">exit_function:</a>
<a name="ln3300">    if ( bFixedCarbonCharges ) {</a>
<a name="ln3301">        RemoveForbiddenEdgeMask(pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask ); </a>
<a name="ln3302">        AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln3303">    }</a>
<a name="ln3304">    if ( forbidden_stereo_edge_mask &amp;&amp; FixedLargeRingStereoEdges.num_edges ) {</a>
<a name="ln3305">        SetForbiddenEdgeMask( pBNS, &amp;FixedLargeRingStereoEdges, forbidden_stereo_edge_mask );</a>
<a name="ln3306">    }</a>
<a name="ln3307">    AllocEdgeList( &amp;FixedLargeRingStereoEdges, EDGE_LIST_FREE );</a>
<a name="ln3308"> </a>
<a name="ln3309">    return ret &lt; 0? ret : num_min;</a>
<a name="ln3310">}</a>
<a name="ln3311">#if (MOVE_CHARGES_FROM_HETEREO_TO_METAL == 1 )</a>
<a name="ln3312">/********************** not used *************************************************************************/</a>
<a name="ln3313">int MoveChargeFromHeteroatomsToMetals( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln3314">                                       inp_ATOM *at, inp_ATOM *at2,</a>
<a name="ln3315">                                       VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3316">                                       int *pnNumRunBNS, int *pnTotalDelta,</a>
<a name="ln3317">                                       int forbidden_edge_mask)</a>
<a name="ln3318">    /********* Avoid charge separation on heteroatoms ******************/</a>
<a name="ln3319">{</a>
<a name="ln3320">    int i, k, ret, ret2, num_pos, num_neg, num_min;</a>
<a name="ln3321">    int vPlusSuper, vMinusSuper;  /* (+), (-) super vertices */</a>
<a name="ln3322">    int ePlusSuper, eMinusSuper;  /* edges from vPlusSuper or vMinusSuper to (+/-) */</a>
<a name="ln3323">    int vPlMn;  /* (+/-) vertex */</a>
<a name="ln3324">    int vPlusHeteroat, vMinusHeteroat; /* (+), (-) heteroatom vertices */</a>
<a name="ln3325">    int ePlusHeteroat, eMinusHeteroat; /* edges from (+) or (-) heteroatom vertex to super (+) or (-) */</a>
<a name="ln3326">    int vPlusCarbons,  vMinusCarbons; /* (+), (-) carbons vertices */</a>
<a name="ln3327">    int ePlusCarbons,  eMinusCarbons; /* edges from (+), (-) carbons vertices to super (+) or (-) */</a>
<a name="ln3328">    int vPlusMetals,   vMinusMetals; /* (+), (-) carbons vertices */</a>
<a name="ln3329">    int ePlusMetals,   eMinusMetals; /* edges from (+), (-) carbons vertices to super (+) or (-) */</a>
<a name="ln3330">    int eMinusHeteroToSuper;         /* edge (-)vHetero-[eMinusHeteroat]-Y-[eMinusHeteroToSuper]-(-)vPlusSuper */</a>
<a name="ln3331">    int v1, v2;</a>
<a name="ln3332">    int nDeltaPlus1, nDeltaMinus1, delta;</a>
<a name="ln3333">    BNS_VERTEX *pvPlusSuper, *pvMinusSuper, *pvPlMn;</a>
<a name="ln3334">    BNS_VERTEX *pvPlusHeteroat, *pvMinusHeteroat, *pvPlusCarbons, *pvMinusCarbons;</a>
<a name="ln3335">    BNS_VERTEX *pvPlusMetals,  *pvMinusMetals;</a>
<a name="ln3336">    BNS_EDGE   *pEdgePlusHeteroat, *pEdgeMinusHeteroat, *pEdgeMinusHeteroToSuper;</a>
<a name="ln3337">    BNS_EDGE   *pEdgePlusCarbons, *pEdgeMinusCarbons, *pEdgePlusMetals, *pEdgeMinusMetals;</a>
<a name="ln3338">    BNS_EDGE   *pEdgePlusSuper, *pEdgeMinusSuper;</a>
<a name="ln3339">    </a>
<a name="ln3340">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln3341">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln3342">    int len_at = num_at + num_deleted_H;</a>
<a name="ln3343">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln3344">    </a>
<a name="ln3345">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln3346">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln3347"> </a>
<a name="ln3348"> </a>
<a name="ln3349">    ret = 0;</a>
<a name="ln3350"> </a>
<a name="ln3351">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln3352">    pStruct-&gt;at = at2;</a>
<a name="ln3353">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln3354">    pStruct-&gt;at = at;</a>
<a name="ln3355">    if ( ret2 &lt; 0 ) {</a>
<a name="ln3356">        ret = ret2;</a>
<a name="ln3357">        goto exit_function;</a>
<a name="ln3358">    }</a>
<a name="ln3359">    /* (+) */</a>
<a name="ln3360">    pEdgePlusSuper = NULL;</a>
<a name="ln3361">    pvPlusSuper    = NULL;</a>
<a name="ln3362">    if ( (k          = pTCGroups-&gt;nGroup[TCG_Plus]) &gt;= 0 &amp;&amp;</a>
<a name="ln3363">         (ePlusSuper = pTCGroups-&gt;pTCG[k].nForwardEdge) &gt; 0 &amp;&amp;</a>
<a name="ln3364">         (vPlusSuper = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3365">         pEdgePlusSuper = pBNS-&gt;edge + ePlusSuper;</a>
<a name="ln3366">         pvPlusSuper    = pBNS-&gt;vert + vPlusSuper;</a>
<a name="ln3367">    }</a>
<a name="ln3368">    pEdgePlusCarbons = NULL;</a>
<a name="ln3369">    pvPlusCarbons    = NULL;</a>
<a name="ln3370">    if ( (k            = pTCGroups-&gt;nGroup[TCG_Plus_C0] )  &gt; 0 &amp;&amp;</a>
<a name="ln3371">         (ePlusCarbons = pTCGroups-&gt;pTCG[k].nForwardEdge)  &gt; 0 &amp;&amp;</a>
<a name="ln3372">         (vPlusCarbons = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3373">        pEdgePlusCarbons = pBNS-&gt;edge + ePlusCarbons;</a>
<a name="ln3374">        pvPlusCarbons    = pBNS-&gt;vert + vPlusCarbons;</a>
<a name="ln3375">    }</a>
<a name="ln3376">    pEdgePlusHeteroat = NULL;</a>
<a name="ln3377">    pvPlusHeteroat    = NULL;</a>
<a name="ln3378">    if ( (k             = pTCGroups-&gt;nGroup[TCG_Plus0] )  &gt; 0 &amp;&amp;</a>
<a name="ln3379">         (ePlusHeteroat = pTCGroups-&gt;pTCG[k].nForwardEdge)  &gt; 0 &amp;&amp;</a>
<a name="ln3380">         (vPlusHeteroat = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3381">        pEdgePlusHeteroat = pBNS-&gt;edge + ePlusHeteroat;</a>
<a name="ln3382">        pvPlusHeteroat     = pBNS-&gt;vert + vPlusHeteroat;</a>
<a name="ln3383">    }</a>
<a name="ln3384">    pEdgePlusMetals = NULL;</a>
<a name="ln3385">    pvPlusMetals    = NULL;</a>
<a name="ln3386">    if ( (k             = pTCGroups-&gt;nGroup[TCG_Plus_M0] )  &gt; 0 &amp;&amp;</a>
<a name="ln3387">         (ePlusMetals = pTCGroups-&gt;pTCG[k].nForwardEdge)  &gt; 0 &amp;&amp;</a>
<a name="ln3388">         (vPlusMetals = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3389">        pEdgePlusMetals = pBNS-&gt;edge + ePlusMetals;</a>
<a name="ln3390">        pvPlusMetals    = pBNS-&gt;vert + vPlusMetals;</a>
<a name="ln3391">    }</a>
<a name="ln3392">    /* (-) */</a>
<a name="ln3393">    pEdgeMinusSuper = NULL;</a>
<a name="ln3394">    pvMinusSuper    = NULL;</a>
<a name="ln3395">    if ( (k          = pTCGroups-&gt;nGroup[TCG_Minus]) &gt;= 0 &amp;&amp;</a>
<a name="ln3396">         (eMinusSuper = pTCGroups-&gt;pTCG[k].nForwardEdge) &gt; 0 &amp;&amp;</a>
<a name="ln3397">         (vMinusSuper = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3398">         pEdgeMinusSuper = pBNS-&gt;edge + eMinusSuper;</a>
<a name="ln3399">         pvMinusSuper    = pBNS-&gt;vert + vMinusSuper;</a>
<a name="ln3400">    }</a>
<a name="ln3401">    pEdgeMinusCarbons = NULL;</a>
<a name="ln3402">    pvMinusCarbons    = NULL;</a>
<a name="ln3403">    if ( (k            = pTCGroups-&gt;nGroup[TCG_Minus_C0] )  &gt; 0 &amp;&amp;</a>
<a name="ln3404">         (eMinusCarbons = pTCGroups-&gt;pTCG[k].nForwardEdge)  &gt; 0 &amp;&amp;</a>
<a name="ln3405">         (vMinusCarbons = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3406">        pEdgeMinusCarbons = pBNS-&gt;edge + eMinusCarbons;</a>
<a name="ln3407">        pvMinusCarbons    = pBNS-&gt;vert + vMinusCarbons;</a>
<a name="ln3408">    }</a>
<a name="ln3409">    pEdgeMinusHeteroat = NULL;</a>
<a name="ln3410">    pvMinusHeteroat    = NULL;</a>
<a name="ln3411">    pEdgeMinusHeteroToSuper = NULL;</a>
<a name="ln3412">    if ( (k             = pTCGroups-&gt;nGroup[TCG_Minus0] )  &gt; 0 &amp;&amp;</a>
<a name="ln3413">         (eMinusHeteroat = pTCGroups-&gt;pTCG[k].nForwardEdge)  &gt; 0 &amp;&amp;</a>
<a name="ln3414">         (vMinusHeteroat = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3415">        BNS_VERTEX *pvYMinusHetero;</a>
<a name="ln3416">        BNS_EDGE   *pe;</a>
<a name="ln3417">        int         vYMinusHetero;</a>
<a name="ln3418">        pEdgeMinusHeteroat = pBNS-&gt;edge + eMinusHeteroat;</a>
<a name="ln3419">        pvMinusHeteroat    = pBNS-&gt;vert + vMinusHeteroat;</a>
<a name="ln3420">        /* next edge toward (-)super */</a>
<a name="ln3421">        if ( pvMinusSuper ) {</a>
<a name="ln3422">            vYMinusHetero = pEdgeMinusHeteroat-&gt;neighbor12 ^ vMinusHeteroat;</a>
<a name="ln3423">            pvYMinusHetero = pBNS-&gt;vert + vYMinusHetero;</a>
<a name="ln3424">            for ( i = 0; i &lt; pvYMinusHetero-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln3425">                pe = pBNS-&gt;edge + pvYMinusHetero-&gt;iedge[i];</a>
<a name="ln3426">                if ( (pe-&gt;neighbor12 ^ vYMinusHetero) == vMinusSuper ) {</a>
<a name="ln3427">                    pEdgeMinusHeteroToSuper = pe;</a>
<a name="ln3428">                    eMinusHeteroToSuper     = pe - pBNS-&gt;edge;</a>
<a name="ln3429">                    break;</a>
<a name="ln3430">                }</a>
<a name="ln3431">            }</a>
<a name="ln3432">        }</a>
<a name="ln3433">    }</a>
<a name="ln3434">    pEdgeMinusMetals = NULL;</a>
<a name="ln3435">    pvMinusMetals    = NULL;</a>
<a name="ln3436">    if ( (k             = pTCGroups-&gt;nGroup[TCG_Minus_M0] )  &gt; 0 &amp;&amp;</a>
<a name="ln3437">         (eMinusMetals = pTCGroups-&gt;pTCG[k].nForwardEdge)  &gt; 0 &amp;&amp;</a>
<a name="ln3438">         (vMinusMetals = pTCGroups-&gt;pTCG[k].nVertexNumber) &gt;= num_at ) {</a>
<a name="ln3439">        pEdgeMinusMetals = pBNS-&gt;edge + eMinusMetals;</a>
<a name="ln3440">        pvMinusMetals    = pBNS-&gt;vert + vMinusMetals;</a>
<a name="ln3441">    }</a>
<a name="ln3442">    /* (+/-) */</a>
<a name="ln3443">    pvPlMn = NULL;</a>
<a name="ln3444">    if ( pEdgePlusSuper ) {</a>
<a name="ln3445">        vPlMn = pEdgePlusSuper-&gt;neighbor12 ^ vPlusSuper;</a>
<a name="ln3446">        pvPlMn = pBNS-&gt;vert + vPlMn;</a>
<a name="ln3447">    } else</a>
<a name="ln3448">    if ( pEdgeMinusSuper ) {</a>
<a name="ln3449">        vPlMn = pEdgeMinusSuper-&gt;neighbor12 ^ vMinusSuper;</a>
<a name="ln3450">        pvPlMn = pBNS-&gt;vert + vPlMn;</a>
<a name="ln3451">    }</a>
<a name="ln3452">    num_pos = num_neg = 0;</a>
<a name="ln3453">    /***************************************************************/</a>
<a name="ln3454">    /* Positive Charges                                            */</a>
<a name="ln3455">    /***************************************************************/</a>
<a name="ln3456">    if ( pEdgePlusHeteroat &amp;&amp; pEdgePlusMetals ) {</a>
<a name="ln3457">        /* count charges */</a>
<a name="ln3458">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3459">            if ( !at2[i].radical &amp;&amp;</a>
<a name="ln3460">                  at2[i].charge &gt; 0 &amp;&amp; </a>
<a name="ln3461">                  (k = pVA[i].nCPlusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln3462">                v1 = pBNS-&gt;edge[k].neighbor1;</a>
<a name="ln3463">                v2 = pBNS-&gt;edge[k].neighbor1 ^ pBNS-&gt;edge[k].neighbor12;</a>
<a name="ln3464">                if ( v1 == vPlusHeteroat || v2 == vPlusHeteroat ) {</a>
<a name="ln3465">                    num_pos ++;</a>
<a name="ln3466">                }</a>
<a name="ln3467">            }</a>
<a name="ln3468">        }</a>
<a name="ln3469">        /* attempt to move (+) from heteroatoms to metal atoms */</a>
<a name="ln3470">        num_min = inchi_min( num_pos, pEdgePlusHeteroat-&gt;flow );</a>
<a name="ln3471"> </a>
<a name="ln3472">        nDeltaPlus1  = pvPlusSuper-&gt;st_edge.cap - pvPlusSuper-&gt;st_edge.flow;</a>
<a name="ln3473">        nDeltaMinus1 = pvPlMn-&gt;st_edge.cap - pvPlMn-&gt;st_edge.flow;</a>
<a name="ln3474">        if ( num_min &amp;&amp; !nDeltaPlus1 &amp;&amp; !nDeltaMinus1 ) {</a>
<a name="ln3475">            if ( pEdgePlusSuper ) {</a>
<a name="ln3476">                pEdgePlusSuper-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3477">            }</a>
<a name="ln3478">            if ( pEdgeMinusSuper ) {</a>
<a name="ln3479">                pEdgeMinusSuper-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3480">            }</a>
<a name="ln3481">            if ( pEdgePlusCarbons ) {</a>
<a name="ln3482">                pEdgePlusCarbons-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3483">            }</a>
<a name="ln3484">            if ( pEdgeMinusCarbons ) {</a>
<a name="ln3485">                pEdgeMinusCarbons-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3486">            }</a>
<a name="ln3487">            if ( pEdgePlusHeteroat ) {</a>
<a name="ln3488">                pEdgePlusHeteroat-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3489">            }</a>
<a name="ln3490">            if ( pEdgeMinusHeteroat ) {</a>
<a name="ln3491">                pEdgeMinusHeteroat-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3492">            }</a>
<a name="ln3493">            delta = 1;</a>
<a name="ln3494">            for ( i = 0; i &lt; num_min; i += delta ) {</a>
<a name="ln3495">                v1 = pEdgePlusHeteroat-&gt;neighbor1;</a>
<a name="ln3496">                v2 = pEdgePlusHeteroat-&gt;neighbor12 ^ v1;</a>
<a name="ln3497">                pEdgePlusHeteroat-&gt;flow     -= delta;</a>
<a name="ln3498">                pBNS-&gt;vert[v1].st_edge.flow -= delta;</a>
<a name="ln3499">                pBNS-&gt;vert[v2].st_edge.flow -= delta;</a>
<a name="ln3500">                pBNS-&gt;tot_st_flow           -= 2*delta;</a>
<a name="ln3501">                /* test for charhe cancellation */</a>
<a name="ln3502">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3503">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3504">                if ( ret &lt; 0 ) {</a>
<a name="ln3505">                    goto exit_function;</a>
<a name="ln3506">                }</a>
<a name="ln3507">                if ( ret == 1 &amp;&amp; (vPathEnd == v1 &amp;&amp; vPathStart == v2 ||</a>
<a name="ln3508">                                  vPathEnd == v2 &amp;&amp; vPathStart == v1) &amp;&amp; nDeltaCharge == 0 ) {</a>
<a name="ln3509">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3510">                    (*pnNumRunBNS) ++;</a>
<a name="ln3511">                    if ( ret &lt; 0 ) {</a>
<a name="ln3512">                        goto exit_function;</a>
<a name="ln3513">                    } else</a>
<a name="ln3514">                    if ( ret == 1 ) {</a>
<a name="ln3515">                        *pnTotalDelta += ret;</a>
<a name="ln3516">                    } else {</a>
<a name="ln3517">                        ret = RI_ERR_PROGR;</a>
<a name="ln3518">                        goto exit_function;</a>
<a name="ln3519">                    }</a>
<a name="ln3520">                } else {</a>
<a name="ln3521">                    pEdgePlusHeteroat-&gt;flow     += delta;</a>
<a name="ln3522">                    pBNS-&gt;vert[v1].st_edge.flow += delta;</a>
<a name="ln3523">                    pBNS-&gt;vert[v2].st_edge.flow += delta;</a>
<a name="ln3524">                    pBNS-&gt;tot_st_flow           += 2*delta;</a>
<a name="ln3525">                    break;</a>
<a name="ln3526">                }</a>
<a name="ln3527">            }</a>
<a name="ln3528">            if ( pEdgePlusSuper ) {</a>
<a name="ln3529">                pEdgePlusSuper-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3530">            }</a>
<a name="ln3531">            if ( pEdgeMinusSuper ) {</a>
<a name="ln3532">                pEdgeMinusSuper-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3533">            }</a>
<a name="ln3534">            if ( pEdgePlusCarbons ) {</a>
<a name="ln3535">                pEdgePlusCarbons-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3536">            }</a>
<a name="ln3537">            if ( pEdgeMinusCarbons ) {</a>
<a name="ln3538">                pEdgeMinusCarbons-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3539">            }</a>
<a name="ln3540">            if ( pEdgePlusHeteroat ) {</a>
<a name="ln3541">                pEdgePlusHeteroat-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3542">            }</a>
<a name="ln3543">            if ( pEdgeMinusHeteroat ) {</a>
<a name="ln3544">                pEdgeMinusHeteroat-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3545">            }</a>
<a name="ln3546">        }</a>
<a name="ln3547">    }</a>
<a name="ln3548">    /***************************************************************/</a>
<a name="ln3549">    /* Negative Charges                                            */</a>
<a name="ln3550">    /***************************************************************/</a>
<a name="ln3551">    if ( pEdgeMinusHeteroToSuper &amp;&amp; pEdgeMinusMetals ) {</a>
<a name="ln3552">        /* count charges */</a>
<a name="ln3553">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3554">            if ( !at2[i].radical &amp;&amp;</a>
<a name="ln3555">                  at2[i].charge &lt; 0 &amp;&amp; </a>
<a name="ln3556">                  (k = pVA[i].nCMinusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln3557">                v1 = pBNS-&gt;edge[k].neighbor1;</a>
<a name="ln3558">                v2 = pBNS-&gt;edge[k].neighbor1 ^ pBNS-&gt;edge[k].neighbor12;</a>
<a name="ln3559">                if ( v1 == vMinusHeteroat || v2 == vMinusHeteroat ) {</a>
<a name="ln3560">                    num_neg ++;</a>
<a name="ln3561">                }</a>
<a name="ln3562">            }</a>
<a name="ln3563">        }</a>
<a name="ln3564">        if ( num_neg ) {</a>
<a name="ln3565">            /* attempt to move (+) from heteroatoms to metal atoms */</a>
<a name="ln3566">            num_min = inchi_min( num_neg, pEdgeMinusHeteroToSuper-&gt;flow );</a>
<a name="ln3567">        }</a>
<a name="ln3568"> </a>
<a name="ln3569">        nDeltaPlus1  = pvPlusSuper-&gt;st_edge.cap - pvPlusSuper-&gt;st_edge.flow;</a>
<a name="ln3570">        nDeltaMinus1 = pvPlMn-&gt;st_edge.cap - pvPlMn-&gt;st_edge.flow;</a>
<a name="ln3571">        if ( num_min &amp;&amp; !nDeltaPlus1 &amp;&amp; !nDeltaMinus1 ) {</a>
<a name="ln3572">            if ( pEdgePlusSuper ) {</a>
<a name="ln3573">                pEdgePlusSuper-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3574">            }</a>
<a name="ln3575">            if ( pEdgeMinusSuper ) {</a>
<a name="ln3576">                pEdgeMinusSuper-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3577">            }</a>
<a name="ln3578">            if ( pEdgePlusCarbons ) {</a>
<a name="ln3579">                pEdgePlusCarbons-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3580">            }</a>
<a name="ln3581">            if ( pEdgeMinusCarbons ) {</a>
<a name="ln3582">                pEdgeMinusCarbons-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3583">            }</a>
<a name="ln3584">            if ( pEdgePlusHeteroat ) {</a>
<a name="ln3585">                pEdgePlusHeteroat-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3586">            }</a>
<a name="ln3587">            if ( pEdgeMinusHeteroToSuper ) {</a>
<a name="ln3588">                pEdgeMinusHeteroToSuper-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3589">            }</a>
<a name="ln3590">            delta = 1;</a>
<a name="ln3591">            for ( i = 0; i &lt; num_min; i += delta ) {</a>
<a name="ln3592">                v1 = pEdgeMinusHeteroToSuper-&gt;neighbor1;</a>
<a name="ln3593">                v2 = pEdgeMinusHeteroToSuper-&gt;neighbor12 ^ v1;</a>
<a name="ln3594">                pEdgeMinusHeteroToSuper-&gt;flow -= delta;</a>
<a name="ln3595">                pBNS-&gt;vert[v1].st_edge.flow   -= delta;</a>
<a name="ln3596">                pBNS-&gt;vert[v2].st_edge.flow   -= delta;</a>
<a name="ln3597">                pBNS-&gt;tot_st_flow             -= 2*delta;</a>
<a name="ln3598">                /* test for charhe cancellation */</a>
<a name="ln3599">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3600">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3601">                if ( ret &lt; 0 ) {</a>
<a name="ln3602">                    goto exit_function;</a>
<a name="ln3603">                }</a>
<a name="ln3604">                if ( ret == 1 &amp;&amp; (vPathEnd == v1 &amp;&amp; vPathStart == v2 ||</a>
<a name="ln3605">                                  vPathEnd == v2 &amp;&amp; vPathStart == v1) &amp;&amp; nDeltaCharge == 0 ) {</a>
<a name="ln3606">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3607">                    (*pnNumRunBNS) ++;</a>
<a name="ln3608">                    if ( ret &lt; 0 ) {</a>
<a name="ln3609">                        goto exit_function;</a>
<a name="ln3610">                    } else</a>
<a name="ln3611">                    if ( ret == 1 ) {</a>
<a name="ln3612">                        *pnTotalDelta += ret;</a>
<a name="ln3613">                    } else {</a>
<a name="ln3614">                        ret = RI_ERR_PROGR;</a>
<a name="ln3615">                        goto exit_function;</a>
<a name="ln3616">                    }</a>
<a name="ln3617">                } else {</a>
<a name="ln3618">                    pEdgeMinusHeteroToSuper-&gt;flow += delta;</a>
<a name="ln3619">                    pBNS-&gt;vert[v1].st_edge.flow   += delta;</a>
<a name="ln3620">                    pBNS-&gt;vert[v2].st_edge.flow   += delta;</a>
<a name="ln3621">                    pBNS-&gt;tot_st_flow             += 2*delta;</a>
<a name="ln3622">                    break;</a>
<a name="ln3623">                }</a>
<a name="ln3624">            }</a>
<a name="ln3625">            if ( pEdgePlusSuper ) {</a>
<a name="ln3626">                pEdgePlusSuper-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3627">            }</a>
<a name="ln3628">            if ( pEdgeMinusSuper ) {</a>
<a name="ln3629">                pEdgeMinusSuper-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3630">            }</a>
<a name="ln3631">            if ( pEdgePlusCarbons ) {</a>
<a name="ln3632">                pEdgePlusCarbons-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3633">            }</a>
<a name="ln3634">            if ( pEdgeMinusCarbons ) {</a>
<a name="ln3635">                pEdgeMinusCarbons-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3636">            }</a>
<a name="ln3637">            if ( pEdgePlusHeteroat ) {</a>
<a name="ln3638">                pEdgePlusHeteroat-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3639">            }</a>
<a name="ln3640">            if ( pEdgeMinusHeteroToSuper ) {</a>
<a name="ln3641">                pEdgeMinusHeteroToSuper-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3642">            }</a>
<a name="ln3643">        }</a>
<a name="ln3644">    }</a>
<a name="ln3645">exit_function:</a>
<a name="ln3646">    return ret;</a>
<a name="ln3647">}</a>
<a name="ln3648">#endif</a>
<a name="ln3649">/******************************************************************************************************/</a>
<a name="ln3650">int RestoreCyanoGroup( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln3651">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3652">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln3653">{</a>
<a name="ln3654">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln3655">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln3656">    BNS_EDGE  *pe;</a>
<a name="ln3657">    </a>
<a name="ln3658">    int i, j, ret2, ret;</a>
<a name="ln3659">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln3660">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln3661">    int len_at = num_at + num_deleted_H;</a>
<a name="ln3662">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln3663">    Vertex v1, v2;</a>
<a name="ln3664"> </a>
<a name="ln3665">    EDGE_LIST CarbonChargeEdges;</a>
<a name="ln3666">    </a>
<a name="ln3667">    ret = 0;</a>
<a name="ln3668">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln3669"> </a>
<a name="ln3670">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln3671">    pStruct-&gt;at = at2;</a>
<a name="ln3672">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln3673">    pStruct-&gt;at = at;</a>
<a name="ln3674">    if ( ret2 &lt; 0 ) {</a>
<a name="ln3675">        ret = ret2;</a>
<a name="ln3676">        goto exit_function;</a>
<a name="ln3677">    }</a>
<a name="ln3678"> </a>
<a name="ln3679">    for ( i = 0; i &lt; num_at &amp;&amp; 0 &lt;= ret; i ++ ) {</a>
<a name="ln3680">        if ( at2[i].valence == 1 &amp;&amp;</a>
<a name="ln3681">             at2[i].num_H   == 0 &amp;&amp;</a>
<a name="ln3682">             at2[i].chem_bonds_valence == 2 &amp;&amp;</a>
<a name="ln3683">             at2[i].charge == -1 &amp;&amp;</a>
<a name="ln3684">             at2[i].radical == 0 &amp;&amp;</a>
<a name="ln3685">             pVA[i].cNumValenceElectrons == 5 &amp;&amp;  /* terminal N(-)=, P, As, Sb, Bi */</a>
<a name="ln3686">             pVA[i].nCMinusGroupEdge &gt; 0 &amp;&amp;</a>
<a name="ln3687">             pVA[i].nTautGroupEdge == 0 &amp;&amp;</a>
<a name="ln3688">             at2[j=at2[i].neighbor[0]].valence == 2 &amp;&amp;</a>
<a name="ln3689">             at2[j].num_H == 0 &amp;&amp;</a>
<a name="ln3690">             at2[j].chem_bonds_valence == 4 &amp;&amp;</a>
<a name="ln3691">             at2[j].charge == 0 &amp;&amp;</a>
<a name="ln3692">             at2[j].radical == 0 &amp;&amp;</a>
<a name="ln3693">             pVA[j].cNumValenceElectrons == 4 &amp;&amp; /* C or Si or Ge or Sn or Pb */</a>
<a name="ln3694">             pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln3695">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_MN ) {</a>
<a name="ln3696">            /* found N(-)=C= */</a>
<a name="ln3697">            pe = pBNS-&gt;edge + (pVA[i].nCMinusGroupEdge-1); /* N#N(+) triple bond edge */</a>
<a name="ln3698">            </a>
<a name="ln3699">            if ( !pe-&gt;flow ) {</a>
<a name="ln3700">                continue; /* wrong atom ??? Strange... */</a>
<a name="ln3701">            }</a>
<a name="ln3702">            v1 = pe-&gt;neighbor1;</a>
<a name="ln3703">            v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln3704">            pe-&gt;flow --;</a>
<a name="ln3705">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln3706">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln3707">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln3708">            pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3709"> </a>
<a name="ln3710">            /* do not let carbon atoms get charged */</a>
<a name="ln3711">            if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln3712">                goto exit_function;</a>
<a name="ln3713">            }</a>
<a name="ln3714">            </a>
<a name="ln3715">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3716">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3717"> </a>
<a name="ln3718">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3719">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln3720">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3721">                (*pnNumRunBNS) ++;</a>
<a name="ln3722">                *pnTotalDelta += ret;</a>
<a name="ln3723">            } else {</a>
<a name="ln3724">                pe-&gt;flow ++;</a>
<a name="ln3725">                pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln3726">                pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln3727">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln3728">            }</a>
<a name="ln3729">            RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln3730">            </a>
<a name="ln3731">            pe-&gt;forbidden &amp;= inv_forbidden_edge_mask; /* unmask the edges */</a>
<a name="ln3732">        }</a>
<a name="ln3733">    }</a>
<a name="ln3734"> </a>
<a name="ln3735">exit_function:</a>
<a name="ln3736"> </a>
<a name="ln3737">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln3738">    return ret;</a>
<a name="ln3739">}</a>
<a name="ln3740">/******************************************************************************************************/</a>
<a name="ln3741">int RestoreIsoCyanoGroup( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln3742">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3743">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln3744">{</a>
<a name="ln3745">#define INC_EDGE_LIST 16</a>
<a name="ln3746">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln3747">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms, num_failed, num_success;</a>
<a name="ln3748">    BNS_EDGE  *pe;</a>
<a name="ln3749">    Vertex    v1, v2;</a>
<a name="ln3750">    </a>
<a name="ln3751">    int i, j, ret2, ret, bIsCarbon;</a>
<a name="ln3752">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln3753">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln3754">    int len_at = num_at + num_deleted_H;</a>
<a name="ln3755">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln3756">    EdgeIndex eNMinusEdge, eNPlusEdge, eNPlusEdge1, eN34Edge;</a>
<a name="ln3757">    EdgeIndex eNFlowerEdge1;</a>
<a name="ln3758"> </a>
<a name="ln3759">    EDGE_LIST CarbonChargeEdges, AllChargeEdges, IsoCyanoCarbonChargeEdges;</a>
<a name="ln3760"> </a>
<a name="ln3761">    ret = 0;</a>
<a name="ln3762">    num_failed = num_success = 0;</a>
<a name="ln3763">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR ); /* carbon charge edges */</a>
<a name="ln3764">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_CLEAR );    /* heteroatom charge edges */</a>
<a name="ln3765">    AllocEdgeList( &amp;IsoCyanoCarbonChargeEdges, EDGE_LIST_CLEAR );   /* C in C(+)#N(+) charge edges */</a>
<a name="ln3766"> </a>
<a name="ln3767">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln3768">    pStruct-&gt;at = at2;</a>
<a name="ln3769">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln3770">    pStruct-&gt;at = at;</a>
<a name="ln3771">    if ( ret2 &lt; 0 ) {</a>
<a name="ln3772">        ret = ret2;</a>
<a name="ln3773">        goto exit_function;</a>
<a name="ln3774">    }</a>
<a name="ln3775">    /* 1st attempt: take care of C(+)#N(+)-  =&gt; C(-)#N(+)- and remove 2 negative charges */</a>
<a name="ln3776">    /* This would produce nDeltaCharge = 2 */</a>
<a name="ln3777">    AllocEdgeList( &amp;CarbonChargeEdges, 2*num_at );</a>
<a name="ln3778">    for ( i = 0; i &lt; num_at &amp;&amp; 0 &lt;= ret; i ++ ) {</a>
<a name="ln3779">        /* accumulate edges for subsequent fixing them */</a>
<a name="ln3780">        bIsCarbon = (pVA[i].cNumValenceElectrons == 4 &amp;&amp; pVA[i].cPeriodicRowNumber == 1);</a>
<a name="ln3781">        eNFlowerEdge1 = NO_VERTEX;</a>
<a name="ln3782">        if ( (eNMinusEdge = pVA[i].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln3783">             !pBNS-&gt;edge[eNMinusEdge].forbidden ) {</a>
<a name="ln3784">            if ( bIsCarbon ) {</a>
<a name="ln3785">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln3786">                    goto exit_function;</a>
<a name="ln3787">                }</a>
<a name="ln3788">            } else</a>
<a name="ln3789">            if ( !pVA[i].cMetal &amp;&amp; !at2[i].endpoint &amp;&amp; at2[i].charge != -1 ) {</a>
<a name="ln3790">                if ( (ret = AddToEdgeList( &amp;AllChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln3791">                    goto exit_function;</a>
<a name="ln3792">                }</a>
<a name="ln3793">            }</a>
<a name="ln3794">        }</a>
<a name="ln3795">        if ( (eNPlusEdge = pVA[i].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln3796">             !pBNS-&gt;edge[eNPlusEdge].forbidden ) {</a>
<a name="ln3797">            if ( bIsCarbon ) {</a>
<a name="ln3798">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln3799">                    goto exit_function;</a>
<a name="ln3800">                }</a>
<a name="ln3801">            } else</a>
<a name="ln3802">            if ( !pVA[i].cMetal &amp;&amp; !at2[i].endpoint  ) {</a>
<a name="ln3803">                if ( (ret = AddToEdgeList( &amp;AllChargeEdges, eNPlusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln3804">                    goto exit_function;</a>
<a name="ln3805">                }</a>
<a name="ln3806">                if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln3807">                     NO_VERTEX != (eNFlowerEdge1 = GetChargeFlowerUpperEdge( pBNS, pVA, eNPlusEdge )) &amp;&amp;</a>
<a name="ln3808">                     !pBNS-&gt;edge[eNFlowerEdge1].flow ) {</a>
<a name="ln3809">                    if ( (ret = AddToEdgeList( &amp;AllChargeEdges, eNFlowerEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln3810">                        goto exit_function;</a>
<a name="ln3811">                    }</a>
<a name="ln3812">                }</a>
<a name="ln3813">            }</a>
<a name="ln3814">        }</a>
<a name="ln3815">        if ( bIsCarbon &amp;&amp;</a>
<a name="ln3816">             0 &lt;= eNMinusEdge &amp;&amp;</a>
<a name="ln3817">             0 &lt;= eNPlusEdge &amp;&amp;</a>
<a name="ln3818">             at2[i].valence == 1 &amp;&amp;</a>
<a name="ln3819">             at2[i].num_H   == 0 &amp;&amp;</a>
<a name="ln3820">             at2[i].radical   == 0 &amp;&amp;</a>
<a name="ln3821">             !pBNS-&gt;edge[eNMinusEdge].forbidden &amp;&amp;</a>
<a name="ln3822">             pBNS-&gt;edge[eNMinusEdge].flow == 0 &amp;&amp;</a>
<a name="ln3823">             !pBNS-&gt;edge[eNPlusEdge].forbidden &amp;&amp;</a>
<a name="ln3824">             pBNS-&gt;edge[eNPlusEdge].flow == 0 &amp;&amp;   /* found terminal C(+) */</a>
<a name="ln3825">             </a>
<a name="ln3826">             at2[j=at2[i].neighbor[0]].valence == 2 &amp;&amp;</a>
<a name="ln3827">             at2[j].num_H == 0 &amp;&amp;</a>
<a name="ln3828">             at2[j].radical == 0 &amp;&amp;</a>
<a name="ln3829">             pVA[j].cNumValenceElectrons == 5 &amp;&amp; </a>
<a name="ln3830">             (eNPlusEdge1  = pVA[j].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln3831">             pBNS-&gt;edge[eNPlusEdge].flow == 0  ) {     /* -N(+)- */</a>
<a name="ln3832"> </a>
<a name="ln3833">#ifdef NEVER /* I have not found a good reason to do this yet */</a>
<a name="ln3834">            /* fix (+) charge on -N(+)- as much as C charges are fixed */</a>
<a name="ln3835">            if ( ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge1, INC_EDGE_LIST ) ) {</a>
<a name="ln3836">                goto exit_function;</a>
<a name="ln3837">            }</a>
<a name="ln3838">            /* fix floer edge to prevent N(V) ??? */</a>
<a name="ln3839">            if ( NO_VERTEX != (eNFlowerEdge1 = GetChargeFlowerUpperEdge( pBNS, pVA, eNPlusEdge1 )) &amp;&amp;</a>
<a name="ln3840">                 !pBNS-&gt;edge[eNFlowerEdge1].flow ) {</a>
<a name="ln3841">                if ( ret = AddToEdgeList( &amp;CarbonChargeEdges, eNFlowerEdge1, INC_EDGE_LIST ) ) {</a>
<a name="ln3842">                    goto exit_function;</a>
<a name="ln3843">                }</a>
<a name="ln3844">            }</a>
<a name="ln3845">#endif</a>
<a name="ln3846">            /*</a>
<a name="ln3847">               Carbon(+)         Carbon(-) </a>
<a name="ln3848">               ChargeStruct:     ChargeStruct:</a>
<a name="ln3849">                                 </a>
<a name="ln3850">                         5(+C)             5(+C)</a>
<a name="ln3851">                        /                 //    </a>
<a name="ln3852">               6(-C)  4          6(-C)  4</a>
<a name="ln3853">                   \ //             \\ /        </a>
<a name="ln3854">                    3                 3         </a>
<a name="ln3855">                    |                 |         </a>
<a name="ln3856">                    2                 2         </a>
<a name="ln3857">                    ||                || </a>
<a name="ln3858">                   -C1-              -C1-       </a>
<a name="ln3859">                    |                 |</a>
<a name="ln3860"> </a>
<a name="ln3861">             3-6 is (-) Charge Edge; 4-5 is (+) Charge Edge</a>
<a name="ln3862"> </a>
<a name="ln3863">             To convert the left pattern to the right one:</a>
<a name="ln3864"> </a>
<a name="ln3865">             We need to release these charge edges and decrement</a>
<a name="ln3866">             edge 3-4 flow to change charge from (+) to (-)</a>
<a name="ln3867">            </a>
<a name="ln3868">            */</a>
<a name="ln3869"> </a>
<a name="ln3870">            /* find vertices 4 and 5 */</a>
<a name="ln3871">            v1 = pBNS-&gt;edge[eNPlusEdge].neighbor1; /* one of two vertices incident with edge 4-5 */</a>
<a name="ln3872">            v2 = pBNS-&gt;edge[eNPlusEdge].neighbor12 ^ v1;</a>
<a name="ln3873">            if ( IS_BNS_VT_C_GR(pBNS-&gt;vert[v1].type) ) {</a>
<a name="ln3874">                /* v1 is 5(+C) */</a>
<a name="ln3875">                Vertex tmp = v1;</a>
<a name="ln3876">                v1 = v2;</a>
<a name="ln3877">                v2 = tmp;</a>
<a name="ln3878">            }</a>
<a name="ln3879">            /* v1 should be 4, v2 - 5(+C) */</a>
<a name="ln3880">            if ( !IS_BNS_VT_CHRG_STRUCT(pBNS-&gt;vert[v1].type) || pBNS-&gt;vert[v1].num_adj_edges != 2 ) {</a>
<a name="ln3881">                continue; /* mismatch */</a>
<a name="ln3882">            }</a>
<a name="ln3883">            /* find edge 3-4 */</a>
<a name="ln3884">            eN34Edge = pBNS-&gt;vert[v1].iedge[pBNS-&gt;vert[v1].iedge[0] == eNPlusEdge];</a>
<a name="ln3885">            if ( pBNS-&gt;edge[eN34Edge].forbidden || !pBNS-&gt;edge[eN34Edge].flow ) {</a>
<a name="ln3886">                continue;</a>
<a name="ln3887">            }</a>
<a name="ln3888">            /* save 3 edges: 6-3, 4-5, and 3-4 in this order */</a>
<a name="ln3889">            if ( (ret = AddToEdgeList( &amp;IsoCyanoCarbonChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln3890">                goto exit_function;</a>
<a name="ln3891">            }</a>
<a name="ln3892">            if ( (ret = AddToEdgeList( &amp;IsoCyanoCarbonChargeEdges, eNPlusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln3893">                goto exit_function;</a>
<a name="ln3894">            }</a>
<a name="ln3895">            if ( (ret = AddToEdgeList( &amp;IsoCyanoCarbonChargeEdges, eN34Edge, INC_EDGE_LIST )) ) {</a>
<a name="ln3896">                goto exit_function;</a>
<a name="ln3897">            }</a>
<a name="ln3898">        }</a>
<a name="ln3899">    }</a>
<a name="ln3900">    /* 1st attempt: move (-) charges from heteroatoms to C(+) */</a>
<a name="ln3901">    SetForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln3902">    SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3903">    RemoveForbiddenEdgeMask( pBNS, &amp;IsoCyanoCarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln3904">    for ( i = IsoCyanoCarbonChargeEdges.num_edges-3; 0 &lt;= i; i -= 3 ) {</a>
<a name="ln3905">        eNMinusEdge = IsoCyanoCarbonChargeEdges.pnEdges[i];</a>
<a name="ln3906">        eNPlusEdge  = IsoCyanoCarbonChargeEdges.pnEdges[i+1];</a>
<a name="ln3907">        eN34Edge    = IsoCyanoCarbonChargeEdges.pnEdges[i+2];</a>
<a name="ln3908">        </a>
<a name="ln3909">        pe = pBNS-&gt;edge + eN34Edge;</a>
<a name="ln3910">        pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3911">        if ( !pe-&gt;flow ) {</a>
<a name="ln3912">            continue; /* already done */</a>
<a name="ln3913">        }</a>
<a name="ln3914"> </a>
<a name="ln3915">        v1 = pe-&gt;neighbor1;</a>
<a name="ln3916">        v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln3917">        pe-&gt;flow --;</a>
<a name="ln3918">        pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln3919">        pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln3920">        pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln3921">        </a>
<a name="ln3922">        ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3923">                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3924"> </a>
<a name="ln3925">        if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3926">                          (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge &lt;= -2 ) {</a>
<a name="ln3927">            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3928">            (*pnNumRunBNS) ++;</a>
<a name="ln3929">            *pnTotalDelta += ret;</a>
<a name="ln3930">            num_success ++;</a>
<a name="ln3931">        } else {</a>
<a name="ln3932">            pe-&gt;flow ++;</a>
<a name="ln3933">            pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln3934">            pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln3935">            pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln3936">            pe-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln3937">            num_failed ++;</a>
<a name="ln3938">        }</a>
<a name="ln3939">    }</a>
<a name="ln3940">    if ( num_failed ) {</a>
<a name="ln3941">        /* relax conditions: allow all heteroatoms to change charge */</a>
<a name="ln3942">        RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3943">        for ( i = IsoCyanoCarbonChargeEdges.num_edges-3; 0 &lt;= i; i -= 3 ) {</a>
<a name="ln3944">            eNMinusEdge = IsoCyanoCarbonChargeEdges.pnEdges[i];</a>
<a name="ln3945">            eNPlusEdge  = IsoCyanoCarbonChargeEdges.pnEdges[i+1];</a>
<a name="ln3946">            eN34Edge    = IsoCyanoCarbonChargeEdges.pnEdges[i+2];</a>
<a name="ln3947">            </a>
<a name="ln3948">            pe = pBNS-&gt;edge + eN34Edge;</a>
<a name="ln3949">            pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3950">            if ( !pe-&gt;flow ) {</a>
<a name="ln3951">                continue; /* already done */</a>
<a name="ln3952">            }</a>
<a name="ln3953"> </a>
<a name="ln3954">            v1 = pe-&gt;neighbor1;</a>
<a name="ln3955">            v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln3956">            pe-&gt;flow --;</a>
<a name="ln3957">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln3958">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln3959">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln3960">            </a>
<a name="ln3961">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3962">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3963"> </a>
<a name="ln3964">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3965">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge &lt;= 2 ) {</a>
<a name="ln3966">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3967">                (*pnNumRunBNS) ++;</a>
<a name="ln3968">                *pnTotalDelta += ret;</a>
<a name="ln3969">                num_success ++;</a>
<a name="ln3970">            } else {</a>
<a name="ln3971">                pe-&gt;flow ++;</a>
<a name="ln3972">                pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln3973">                pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln3974">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln3975">                pe-&gt;forbidden &amp;= inv_forbidden_edge_mask; /* let it change if it wants */</a>
<a name="ln3976">                num_failed ++;</a>
<a name="ln3977">            }</a>
<a name="ln3978">        }</a>
<a name="ln3979">    }</a>
<a name="ln3980">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln3981">    RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3982">    RemoveForbiddenEdgeMask( pBNS, &amp;IsoCyanoCarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln3983"> </a>
<a name="ln3984"> </a>
<a name="ln3985">exit_function:</a>
<a name="ln3986"> </a>
<a name="ln3987">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln3988">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln3989">    AllocEdgeList( &amp;IsoCyanoCarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln3990">    return ret;</a>
<a name="ln3991">#undef INC_EDGE_LIST</a>
<a name="ln3992">}</a>
<a name="ln3993"> </a>
<a name="ln3994">/******************************************************************************************************/</a>
<a name="ln3995">int FixMetal_Nminus_Ominus( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln3996">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3997">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln3998">{</a>
<a name="ln3999">#define INC_EDGE_LIST 16</a>
<a name="ln4000">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln4001">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln4002">    int        num_failed, num_success, n, nDeltaChargeMax, nMetalCharge;</a>
<a name="ln4003">    BNS_EDGE  *pe;</a>
<a name="ln4004">    Vertex    v1, v2;</a>
<a name="ln4005">    </a>
<a name="ln4006">    int i, j, k, ret2, ret;</a>
<a name="ln4007">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln4008">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln4009">    int len_at = num_at + num_deleted_H;</a>
<a name="ln4010">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln4011">    EdgeIndex e, eNMinusEdge, eNMinusEdge1, eNMinusEdge2, eNPlusEdge2;</a>
<a name="ln4012"> </a>
<a name="ln4013">    EDGE_LIST AllChargeEdges;</a>
<a name="ln4014"> </a>
<a name="ln4015">    ret = 0;</a>
<a name="ln4016">    num_failed = num_success = 0;</a>
<a name="ln4017">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4018"> </a>
<a name="ln4019">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln4020">    pStruct-&gt;at = at2;</a>
<a name="ln4021">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4022">    pStruct-&gt;at = at;</a>
<a name="ln4023">    if ( ret2 &lt; 0 ) {</a>
<a name="ln4024">        ret = ret2;</a>
<a name="ln4025">        goto exit_function;</a>
<a name="ln4026">    }</a>
<a name="ln4027">    /* attepmt #1 N#N(+)-N =&gt; N(-)=N(+)=N */</a>
<a name="ln4028">    for ( i = 0; i &lt; num_at &amp;&amp; 0 &lt;= ret; i ++ ) {</a>
<a name="ln4029">        if ( at2[i].valence == 1 &amp;&amp;</a>
<a name="ln4030">             at2[i].num_H   == 0 &amp;&amp;</a>
<a name="ln4031">             at2[i].radical == 0 &amp;&amp;</a>
<a name="ln4032">             pVA[i].cNumValenceElectrons == 6 &amp;&amp;  /* terminal -O */</a>
<a name="ln4033">             (eNMinusEdge = pVA[i].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp; pBNS-&gt;edge[eNMinusEdge].flow == 1 &amp;&amp;</a>
<a name="ln4034">             !pBNS-&gt;edge[eNMinusEdge].forbidden &amp;&amp; /* terminal O(-) */</a>
<a name="ln4035">             </a>
<a name="ln4036">             at2[j=at2[i].neighbor[0]].valence == 2 &amp;&amp;</a>
<a name="ln4037">             at2[j].num_H == 0 &amp;&amp;</a>
<a name="ln4038">             at2[j].radical == 0 &amp;&amp;</a>
<a name="ln4039">             pVA[j].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4040">             (eNMinusEdge1 = pVA[j].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp; pBNS-&gt;edge[eNMinusEdge1].flow == 1 &amp;&amp;</a>
<a name="ln4041">             !pBNS-&gt;edge[eNMinusEdge1].forbidden &amp;&amp;</a>
<a name="ln4042">             </a>
<a name="ln4043">             pVA[k=at2[j].neighbor[at2[j].neighbor[0]==i]].cMetal &amp;&amp;</a>
<a name="ln4044"> </a>
<a name="ln4045">             (eNMinusEdge2 = pVA[k].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4046">             !pBNS-&gt;edge[eNMinusEdge2].forbidden &amp;&amp;</a>
<a name="ln4047">             (eNPlusEdge2 = pVA[k].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4048">             !pBNS-&gt;edge[eNPlusEdge2].forbidden  ) {</a>
<a name="ln4049"> </a>
<a name="ln4050">            /* found M(q)-N(-)-O(-); convert to M(q-2)-N=O */</a>
<a name="ln4051"> </a>
<a name="ln4052">            /* find all charge edges to fix */</a>
<a name="ln4053">            if ( 0 == AllChargeEdges.num_edges ) {</a>
<a name="ln4054">                for ( n = 0; n &lt; num_at; n ++ ) {</a>
<a name="ln4055">                    if ( (e = pVA[n].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4056">                         !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln4057">                        if ( (ret = AddToEdgeList( &amp;AllChargeEdges, e, num_at )) ) {</a>
<a name="ln4058">                            goto exit_function;</a>
<a name="ln4059">                        }</a>
<a name="ln4060">                    }</a>
<a name="ln4061">                    if ( (e = pVA[n].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4062">                         !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln4063">                        if ( (ret = AddToEdgeList( &amp;AllChargeEdges, e, num_at )) ) {</a>
<a name="ln4064">                            goto exit_function;</a>
<a name="ln4065">                        }</a>
<a name="ln4066">                        if ( pVA[n].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln4067">                             NO_VERTEX != (e = GetChargeFlowerUpperEdge( pBNS, pVA, e )) &amp;&amp;</a>
<a name="ln4068">                             pBNS-&gt;edge[e].flow == 0 ) {</a>
<a name="ln4069">                            if ( (ret = AddToEdgeList( &amp;AllChargeEdges, e, num_at )) ) {</a>
<a name="ln4070">                                goto exit_function;</a>
<a name="ln4071">                            }</a>
<a name="ln4072">                        }</a>
<a name="ln4073">                    }</a>
<a name="ln4074">                }</a>
<a name="ln4075">            }</a>
<a name="ln4076"> </a>
<a name="ln4077">            nMetalCharge = (pBNS-&gt;edge[eNPlusEdge2].cap - pBNS-&gt;edge[eNPlusEdge2].flow)</a>
<a name="ln4078">                           - pBNS-&gt;edge[eNMinusEdge2].flow;</a>
<a name="ln4079">            if ( nMetalCharge == 0 ) {</a>
<a name="ln4080">                /* change on O is invisible; charge from N(-) goes, charge comes to Metal */</a>
<a name="ln4081">                nDeltaChargeMax = 0;</a>
<a name="ln4082">            } else</a>
<a name="ln4083">            if ( nMetalCharge == 2 ) {</a>
<a name="ln4084">                /* charges on Metal and N disappear */</a>
<a name="ln4085">                nDeltaChargeMax = -2;</a>
<a name="ln4086">            } else {</a>
<a name="ln4087">                /* charge from N disappears */</a>
<a name="ln4088">                nDeltaChargeMax = -1;</a>
<a name="ln4089">            }</a>
<a name="ln4090"> </a>
<a name="ln4091">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4092">            pBNS-&gt;edge[eNMinusEdge1].forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4093">            pBNS-&gt;edge[eNMinusEdge2].forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4094">            pBNS-&gt;edge[eNPlusEdge2].forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4095"> </a>
<a name="ln4096">            pe = pBNS-&gt;edge + eNMinusEdge; /* must be already fixed as a charge edge */</a>
<a name="ln4097"> </a>
<a name="ln4098">            v1 = pe-&gt;neighbor1;</a>
<a name="ln4099">            v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln4100">            pe-&gt;flow --;</a>
<a name="ln4101">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln4102">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln4103">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln4104"> </a>
<a name="ln4105">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4106">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4107"> </a>
<a name="ln4108">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4109">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) /*&amp;&amp; nDeltaCharge == nDeltaChargeMax*/ ) {</a>
<a name="ln4110">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4111">                (*pnNumRunBNS) ++;</a>
<a name="ln4112">                *pnTotalDelta += ret;</a>
<a name="ln4113">                num_success ++;</a>
<a name="ln4114">            } else {</a>
<a name="ln4115">                pe-&gt;flow ++;</a>
<a name="ln4116">                pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln4117">                pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln4118">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln4119">                num_failed ++;</a>
<a name="ln4120">            }</a>
<a name="ln4121">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4122">        }</a>
<a name="ln4123">    }</a>
<a name="ln4124">    ret = num_success;</a>
<a name="ln4125"> </a>
<a name="ln4126">exit_function:</a>
<a name="ln4127"> </a>
<a name="ln4128">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4129"> </a>
<a name="ln4130">    return ret;</a>
<a name="ln4131">#undef INC_EDGE_LIST</a>
<a name="ln4132">}</a>
<a name="ln4133">/******************************************************************************************************/</a>
<a name="ln4134">int RestoreNNNgroup( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln4135">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln4136">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln4137">{</a>
<a name="ln4138">#define INC_EDGE_LIST 16</a>
<a name="ln4139">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln4140">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms, num_failed, num_success, n, nDeltaChargeMax;</a>
<a name="ln4141">    BNS_EDGE  *pe;</a>
<a name="ln4142">    Vertex    v1, v2;</a>
<a name="ln4143">    </a>
<a name="ln4144">    int i, j, k, ret2, ret;</a>
<a name="ln4145">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln4146">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln4147">    int len_at = num_at + num_deleted_H;</a>
<a name="ln4148">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln4149">    EdgeIndex eNMinusEdge, eNPlusEdge, eNMinusEdge1, eNPlusEdge1, eNMinusEdge2, eNPlusEdge2;</a>
<a name="ln4150">    EdgeIndex eNFlowerEdge1, eNFlowerEdge2;</a>
<a name="ln4151"> </a>
<a name="ln4152">    EDGE_LIST CarbonChargeEdges, AllChargeEdges, NNNChargeEdges, CurNNNChargeEdges, AllNNNTermAtoms, AllNIIIChargeEdges;</a>
<a name="ln4153"> </a>
<a name="ln4154">    ret = 0;</a>
<a name="ln4155">    num_failed = num_success = 0;</a>
<a name="ln4156">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4157">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4158">    AllocEdgeList( &amp;NNNChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4159">    AllocEdgeList( &amp;CurNNNChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4160">    AllocEdgeList( &amp;AllNNNTermAtoms, EDGE_LIST_CLEAR );</a>
<a name="ln4161">    AllocEdgeList( &amp;AllNIIIChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4162"> </a>
<a name="ln4163">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln4164">    pStruct-&gt;at = at2;</a>
<a name="ln4165">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4166">    pStruct-&gt;at = at;</a>
<a name="ln4167">    if ( ret2 &lt; 0 ) {</a>
<a name="ln4168">        ret = ret2;</a>
<a name="ln4169">        goto exit_function;</a>
<a name="ln4170">    }</a>
<a name="ln4171">    /* attepmt #1 N#N(+)-N =&gt; N(-)=N(+)=N: naive approach; expecting tp move (-) from some other atom */</a>
<a name="ln4172">    for ( i = 0; i &lt; num_at &amp;&amp; 0 &lt;= ret; i ++ ) {</a>
<a name="ln4173">        if ( at2[i].valence == 1 &amp;&amp;</a>
<a name="ln4174">             at2[i].num_H   == 0 &amp;&amp;</a>
<a name="ln4175">             at2[i].chem_bonds_valence == 3 &amp;&amp;</a>
<a name="ln4176">             at2[i].charge ==  0 &amp;&amp;</a>
<a name="ln4177">             at2[i].radical == 0 &amp;&amp;</a>
<a name="ln4178">             pVA[i].cNumValenceElectrons == 5 &amp;&amp;  /* terminal N# */</a>
<a name="ln4179">             (eNMinusEdge = pVA[i].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp; pBNS-&gt;edge[eNMinusEdge].flow == 0 &amp;&amp;</a>
<a name="ln4180">             !pBNS-&gt;edge[eNMinusEdge].forbidden &amp;&amp;</a>
<a name="ln4181">             at2[j=at2[i].neighbor[0]].valence == 2 &amp;&amp;</a>
<a name="ln4182">             at2[j].num_H == 0 &amp;&amp;</a>
<a name="ln4183">             at2[j].chem_bonds_valence == 4 &amp;&amp;</a>
<a name="ln4184">             at2[j].charge == 1 &amp;&amp;</a>
<a name="ln4185">             at2[j].radical == 0 &amp;&amp;</a>
<a name="ln4186">             pVA[j].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4187">             (eNPlusEdge = pVA[j].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge].flow == 0 &amp;&amp;</a>
<a name="ln4188">             !pBNS-&gt;edge[eNPlusEdge].forbidden &amp;&amp;</a>
<a name="ln4189">             at2[k=at2[j].neighbor[at2[j].neighbor[0]==i]].valence == 2 &amp;&amp;</a>
<a name="ln4190">             at2[k].num_H == 0 &amp;&amp;</a>
<a name="ln4191">             at2[k].chem_bonds_valence == 3 &amp;&amp;</a>
<a name="ln4192">             pVA[k].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4193">             (eNPlusEdge2 = pVA[k].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1 &amp;&amp;</a>
<a name="ln4194">             !pBNS-&gt;edge[eNPlusEdge2].forbidden &amp;&amp;</a>
<a name="ln4195">             pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln4196">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_MN ) {</a>
<a name="ln4197">            /* found N#N(+)-N~ where the last N (at2[k]) may be charged */</a>
<a name="ln4198">            pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0]; /* N#N(+) triple bond edge */</a>
<a name="ln4199">            </a>
<a name="ln4200">            v1 = pe-&gt;neighbor1;</a>
<a name="ln4201">            v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln4202">            pe-&gt;flow --;</a>
<a name="ln4203">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln4204">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln4205">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln4206"> </a>
<a name="ln4207">            pe-&gt;forbidden                     |= forbidden_edge_mask;</a>
<a name="ln4208">            pBNS-&gt;edge[eNPlusEdge].forbidden  |= forbidden_edge_mask;</a>
<a name="ln4209">            pBNS-&gt;edge[eNPlusEdge2].forbidden |= forbidden_edge_mask;</a>
<a name="ln4210">            </a>
<a name="ln4211">            </a>
<a name="ln4212">            if ( !CarbonChargeEdges.num_edges ) {</a>
<a name="ln4213">                /* do not let carbon atoms get charged */</a>
<a name="ln4214">                AllocEdgeList( &amp;CarbonChargeEdges, INC_EDGE_LIST ); </a>
<a name="ln4215">                if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln4216">                    goto exit_function;</a>
<a name="ln4217">                }</a>
<a name="ln4218">            } else {</a>
<a name="ln4219">                SetForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln4220">            }</a>
<a name="ln4221">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4222">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4223"> </a>
<a name="ln4224">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4225">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge &lt;= 0 ) {</a>
<a name="ln4226">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4227">                (*pnNumRunBNS) ++;</a>
<a name="ln4228">                *pnTotalDelta += ret;</a>
<a name="ln4229">                num_success ++;</a>
<a name="ln4230">                /* fix charges on N(-)=N(+)=N- */</a>
<a name="ln4231">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4232">                    goto exit_function;</a>
<a name="ln4233">                }</a>
<a name="ln4234">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4235">                    goto exit_function;</a>
<a name="ln4236">                }</a>
<a name="ln4237">            } else {</a>
<a name="ln4238">                pe-&gt;flow ++;</a>
<a name="ln4239">                pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln4240">                pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln4241">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln4242">                num_failed ++;</a>
<a name="ln4243">            }</a>
<a name="ln4244">            RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln4245"> </a>
<a name="ln4246">            pe-&gt;forbidden                     &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4247">            pBNS-&gt;edge[eNPlusEdge].forbidden  &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4248">            pBNS-&gt;edge[eNPlusEdge2].forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4249">        }</a>
<a name="ln4250">    }</a>
<a name="ln4251"> </a>
<a name="ln4252">    /* 2nd attempt: take care of N#N(+)-N=-...=N-N(-) */</a>
<a name="ln4253">    /* This would produce nDeltaCharge &gt;= 2 */</a>
<a name="ln4254">    </a>
<a name="ln4255">    AllChargeEdges.num_edges = 0;</a>
<a name="ln4256">    AllNNNTermAtoms.num_edges = 0;</a>
<a name="ln4257">    NNNChargeEdges.num_edges = 0;</a>
<a name="ln4258">    AllNIIIChargeEdges.num_edges = 0;</a>
<a name="ln4259"> </a>
<a name="ln4260">    for ( i = 0; i &lt; num_at &amp;&amp; 0 &lt;= ret; i ++ ) {</a>
<a name="ln4261">        if ( (eNMinusEdge = pVA[i].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4262">             !pBNS-&gt;edge[eNMinusEdge].forbidden ) {</a>
<a name="ln4263">            if ( (ret = AddToEdgeList( &amp;AllChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4264">                goto exit_function;</a>
<a name="ln4265">            }</a>
<a name="ln4266">        } else {</a>
<a name="ln4267">            eNMinusEdge = -1;</a>
<a name="ln4268">        }</a>
<a name="ln4269">        if ( (eNPlusEdge = pVA[i].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4270">             !pBNS-&gt;edge[eNPlusEdge].forbidden ) {</a>
<a name="ln4271">            if ( (ret = AddToEdgeList( &amp;AllChargeEdges, eNPlusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4272">                goto exit_function;</a>
<a name="ln4273">            }</a>
<a name="ln4274">            if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp; at2[i].valence == 3 &amp;&amp; at2[i].chem_bonds_valence == 3) {</a>
<a name="ln4275">                if ( (ret = AddToEdgeList( &amp;AllNIIIChargeEdges, eNPlusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4276">                    goto exit_function;</a>
<a name="ln4277">                }</a>
<a name="ln4278">            }</a>
<a name="ln4279">            /* N flower edge */</a>
<a name="ln4280">            if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp; pVA[i].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln4281">                 NO_VERTEX != (eNFlowerEdge1 = GetChargeFlowerUpperEdge( pBNS, pVA, eNPlusEdge )) &amp;&amp;</a>
<a name="ln4282">                 pBNS-&gt;edge[eNFlowerEdge1].flow == 0 &amp;&amp;</a>
<a name="ln4283">                 ( ret = AddToEdgeList( &amp;AllChargeEdges, eNFlowerEdge1, INC_EDGE_LIST ) ) ) {</a>
<a name="ln4284">                goto exit_function;</a>
<a name="ln4285">            }</a>
<a name="ln4286">        } else {</a>
<a name="ln4287">            eNPlusEdge = -1;</a>
<a name="ln4288">        }</a>
<a name="ln4289"> </a>
<a name="ln4290">        if ( 0 &lt;= eNMinusEdge &amp;&amp;</a>
<a name="ln4291">             at2[i].valence == 1 &amp;&amp;</a>
<a name="ln4292">             at2[i].num_H   == 0 &amp;&amp;</a>
<a name="ln4293">             at2[i].radical   == 0 &amp;&amp;</a>
<a name="ln4294">             pVA[i].cNumValenceElectrons == 5 &amp;&amp;  /* terminal N# */</a>
<a name="ln4295">             </a>
<a name="ln4296">             at2[j=at2[i].neighbor[0]].valence == 2 &amp;&amp;</a>
<a name="ln4297">             at2[j].num_H == 0 &amp;&amp;</a>
<a name="ln4298">             at2[j].radical == 0 &amp;&amp;</a>
<a name="ln4299">             pVA[j].cNumValenceElectrons == 5 &amp;&amp; </a>
<a name="ln4300">             (eNMinusEdge1 = pVA[j].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4301">             (eNPlusEdge1  = pVA[j].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4302">             !pBNS-&gt;edge[eNMinusEdge1].forbidden &amp;&amp;</a>
<a name="ln4303">             !pBNS-&gt;edge[eNPlusEdge1].forbidden &amp;&amp;</a>
<a name="ln4304"> </a>
<a name="ln4305">             at2[k=at2[j].neighbor[at2[j].neighbor[0]==i]].valence == 2 &amp;&amp;</a>
<a name="ln4306">             at2[k].num_H == 0 &amp;&amp;</a>
<a name="ln4307">             at2[k].radical == 0 &amp;&amp;</a>
<a name="ln4308">             pVA[k].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4309">             (eNMinusEdge2 = pVA[k].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4310">             (eNPlusEdge2  = pVA[k].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4311">             !pBNS-&gt;edge[eNMinusEdge2].forbidden &amp;&amp;</a>
<a name="ln4312">             !pBNS-&gt;edge[eNPlusEdge2].forbidden &amp;&amp;</a>
<a name="ln4313"> </a>
<a name="ln4314">             pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln4315">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_MN ) {</a>
<a name="ln4316">            /* found N#N(+)-N~ or N(-)=N-N= where the last N (at2[k]) may be charged */</a>
<a name="ln4317">            </a>
<a name="ln4318">            /* 1. N(-)=N(+)=N- */</a>
<a name="ln4319">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 1 &amp;&amp;  /* N(-) */</a>
<a name="ln4320">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4321">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4322">                continue; /* already good */</a>
<a name="ln4323">            }</a>
<a name="ln4324">            /* accumulate terminal atoms of all other NNN */</a>
<a name="ln4325">            if ( (ret = AddToEdgeList( &amp;AllNNNTermAtoms, i, INC_EDGE_LIST )) ) {</a>
<a name="ln4326">                goto exit_function;</a>
<a name="ln4327">            }</a>
<a name="ln4328">            /* 2. N#N(+)-N= */</a>
<a name="ln4329">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp; /* N */</a>
<a name="ln4330">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4331">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4332">                /* unfix (-) edge on terminal N# */</a>
<a name="ln4333">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4334">                    goto exit_function;</a>
<a name="ln4335">                }</a>
<a name="ln4336">                continue;</a>
<a name="ln4337">            }</a>
<a name="ln4338">            /* 3. N(-)=N-N= */</a>
<a name="ln4339">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 1 &amp;&amp; /* N(-) */</a>
<a name="ln4340">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 1 &amp;&amp; /* N */</a>
<a name="ln4341">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4342">                /* unfix (+) edge on middle N */</a>
<a name="ln4343">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4344">                    goto exit_function;</a>
<a name="ln4345">                }</a>
<a name="ln4346">                continue;</a>
<a name="ln4347">            }</a>
<a name="ln4348">            /* 4. N#N(+)-N(-)- */</a>
<a name="ln4349">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4350">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4351">                 pBNS-&gt;edge[eNMinusEdge2].flow == 1 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N(-) */ ) {</a>
<a name="ln4352">                /* unfix (-) edge on the 1st and 3rd N */</a>
<a name="ln4353">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4354">                    goto exit_function;</a>
<a name="ln4355">                }</a>
<a name="ln4356">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4357">                    goto exit_function;</a>
<a name="ln4358">                }</a>
<a name="ln4359">                continue;</a>
<a name="ln4360">            }</a>
<a name="ln4361">            /* 5. N#N(+)-N(+)# */</a>
<a name="ln4362">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4363">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4364">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 0    /* N(+) */ ) {</a>
<a name="ln4365">                /* unfix (-) edge on the 1st and (+) edge on the 3rd N */</a>
<a name="ln4366">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4367">                    goto exit_function;</a>
<a name="ln4368">                }</a>
<a name="ln4369">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4370">                    goto exit_function;</a>
<a name="ln4371">                }</a>
<a name="ln4372">                continue;</a>
<a name="ln4373">            }</a>
<a name="ln4374">        }</a>
<a name="ln4375">    }</a>
<a name="ln4376">    /* try to fix each NNN */</a>
<a name="ln4377">    for ( n = AllNNNTermAtoms.num_edges-1; 0 &lt;= n; n -- ) {</a>
<a name="ln4378">        i = AllNNNTermAtoms.pnEdges[n];</a>
<a name="ln4379">        eNMinusEdge = pVA[i].nCMinusGroupEdge - 1;</a>
<a name="ln4380">        /*eNPlusEdge = pVA[i].nCPlusGroupEdge - 1;*/</a>
<a name="ln4381">        j=at2[i].neighbor[0];</a>
<a name="ln4382">        eNMinusEdge1 = pVA[j].nCMinusGroupEdge - 1;</a>
<a name="ln4383">        eNPlusEdge1  = pVA[j].nCPlusGroupEdge - 1;</a>
<a name="ln4384">        k=at2[j].neighbor[at2[j].neighbor[0]==i];</a>
<a name="ln4385">        eNMinusEdge2 = pVA[k].nCMinusGroupEdge - 1;</a>
<a name="ln4386">        eNPlusEdge2  = pVA[k].nCPlusGroupEdge - 1;</a>
<a name="ln4387">        /*SetForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );*/</a>
<a name="ln4388">        /* 1. N(-)=N(+)=N- */</a>
<a name="ln4389">        if ( pBNS-&gt;edge[eNMinusEdge].flow  == 1 &amp;&amp;  /* N(-) */</a>
<a name="ln4390">             pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4391">             pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4392"> </a>
<a name="ln4393">            RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNMinusEdge );</a>
<a name="ln4394">            RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNMinusEdge1 );</a>
<a name="ln4395">            RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNPlusEdge1 );</a>
<a name="ln4396">            RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNMinusEdge2 );</a>
<a name="ln4397">            RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNPlusEdge2 );</a>
<a name="ln4398"> </a>
<a name="ln4399">            pe = NULL;</a>
<a name="ln4400">        } else   /* 2. N#N(+)-N= */</a>
<a name="ln4401">        if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4402">             pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4403">             pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4404">            /* decrement triple bond on terminal N# */</a>
<a name="ln4405">            pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0];</a>
<a name="ln4406">        } else</a>
<a name="ln4407">        /* 3. N(-)=N-N= */</a>
<a name="ln4408">        if ( pBNS-&gt;edge[eNMinusEdge].flow  == 1 &amp;&amp;  /* N(-) */</a>
<a name="ln4409">             pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 1 &amp;&amp; /* N */</a>
<a name="ln4410">             pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4411">            /* decrement flow on (+) charge edge of the middle =N- */</a>
<a name="ln4412">            pe = pBNS-&gt;edge + eNPlusEdge1;</a>
<a name="ln4413">        } else</a>
<a name="ln4414">        /* 4. N#N(+)-N(-)- */</a>
<a name="ln4415">        if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4416">             pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4417">             pBNS-&gt;edge[eNMinusEdge2].flow == 1 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N(-) */ ) {</a>
<a name="ln4418">            /* decrement triple bond on terminal N# */</a>
<a name="ln4419">            pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0];</a>
<a name="ln4420">        } else</a>
<a name="ln4421">        /* 5. N#N(+)-N(+)# */</a>
<a name="ln4422">        if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4423">             pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4424">             pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 0    /* N(+) */ ) {</a>
<a name="ln4425">            /* decrement triple bond on terminal N# */</a>
<a name="ln4426">            pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0];</a>
<a name="ln4427">        } else {</a>
<a name="ln4428">            pe = NULL; /* unknown case */</a>
<a name="ln4429">        }</a>
<a name="ln4430">        if ( pe ) {</a>
<a name="ln4431">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4432">            RemoveForbiddenEdgeMask( pBNS, &amp;NNNChargeEdges, forbidden_edge_mask );</a>
<a name="ln4433">            </a>
<a name="ln4434">            v1 = pe-&gt;neighbor1;</a>
<a name="ln4435">            v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln4436">            pe-&gt;flow --;</a>
<a name="ln4437">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln4438">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln4439">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln4440">            </a>
<a name="ln4441">            pe-&gt;forbidden                    |= forbidden_edge_mask;</a>
<a name="ln4442">            </a>
<a name="ln4443">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4444">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4445"> </a>
<a name="ln4446">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4447">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) /*&amp;&amp; nDeltaCharge &lt;= 2*/ ) {</a>
<a name="ln4448">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4449">                (*pnNumRunBNS) ++;</a>
<a name="ln4450">                *pnTotalDelta += ret;</a>
<a name="ln4451">                num_success ++;</a>
<a name="ln4452">                /* fix charges on N(-)=N(+)=N- */</a>
<a name="ln4453">                RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNMinusEdge );</a>
<a name="ln4454">                RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNMinusEdge1 );</a>
<a name="ln4455">                RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNPlusEdge1 );</a>
<a name="ln4456">                RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNMinusEdge2 );</a>
<a name="ln4457">                RemoveFromEdgeListByValue( &amp;NNNChargeEdges, eNPlusEdge2 );</a>
<a name="ln4458">            } else {</a>
<a name="ln4459">                pe-&gt;flow ++;</a>
<a name="ln4460">                pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln4461">                pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln4462">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln4463">                num_failed ++;</a>
<a name="ln4464">            }</a>
<a name="ln4465">            pe-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4466">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4467">        }</a>
<a name="ln4468">    }</a>
<a name="ln4469">    </a>
<a name="ln4470">    /* 3rd attempt */</a>
<a name="ln4471"> </a>
<a name="ln4472">    /*</a>
<a name="ln4473">    AllChargeEdges.num_edges = 0;</a>
<a name="ln4474">    AllNNNTermAtoms.num_edges = 0;</a>
<a name="ln4475">    NNNChargeEdges.num_edges = 0;</a>
<a name="ln4476">    */</a>
<a name="ln4477">    for ( i = 0; i &lt; num_at &amp;&amp; 0 &lt;= ret; i ++ ) {</a>
<a name="ln4478"> </a>
<a name="ln4479">        eNMinusEdge = pVA[i].nCMinusGroupEdge - 1;</a>
<a name="ln4480">        /*eNPlusEdge = pVA[i].nCPlusGroupEdge - 1;*/</a>
<a name="ln4481"> </a>
<a name="ln4482">        if ( 0 &lt;= eNMinusEdge &amp;&amp;</a>
<a name="ln4483">             at2[i].valence == 1 &amp;&amp;</a>
<a name="ln4484">             at2[i].num_H   == 0 &amp;&amp;</a>
<a name="ln4485">             at2[i].radical   == 0 &amp;&amp;</a>
<a name="ln4486">             pVA[i].cNumValenceElectrons == 5 &amp;&amp;  /* terminal N# */</a>
<a name="ln4487">             </a>
<a name="ln4488">             at2[j=at2[i].neighbor[0]].valence == 2 &amp;&amp;</a>
<a name="ln4489">             at2[j].num_H == 0 &amp;&amp;</a>
<a name="ln4490">             at2[j].radical == 0 &amp;&amp;</a>
<a name="ln4491">             pVA[j].cNumValenceElectrons == 5 &amp;&amp; </a>
<a name="ln4492">             (eNMinusEdge1 = pVA[j].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4493">             (eNPlusEdge1  = pVA[j].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4494">             !pBNS-&gt;edge[eNMinusEdge1].forbidden &amp;&amp;</a>
<a name="ln4495">             !pBNS-&gt;edge[eNPlusEdge1].forbidden &amp;&amp;</a>
<a name="ln4496"> </a>
<a name="ln4497">             at2[k=at2[j].neighbor[at2[j].neighbor[0]==i]].valence == 2 &amp;&amp;</a>
<a name="ln4498">             at2[k].num_H == 0 &amp;&amp;</a>
<a name="ln4499">             at2[k].radical == 0 &amp;&amp;</a>
<a name="ln4500">             pVA[k].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4501">             (eNMinusEdge2 = pVA[k].nCMinusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4502">             (eNPlusEdge2  = pVA[k].nCPlusGroupEdge - 1)&gt;= 0 &amp;&amp;</a>
<a name="ln4503">             !pBNS-&gt;edge[eNMinusEdge2].forbidden &amp;&amp;</a>
<a name="ln4504">             !pBNS-&gt;edge[eNPlusEdge2].forbidden &amp;&amp;</a>
<a name="ln4505"> </a>
<a name="ln4506">             pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln4507">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_MN ) {</a>
<a name="ln4508"> </a>
<a name="ln4509">            /* found N#N(+)-N~ or N(-)=N-N= where the last N (at2[k]) may be charged */</a>
<a name="ln4510">            NNNChargeEdges.num_edges = 0;</a>
<a name="ln4511"> </a>
<a name="ln4512">            eNFlowerEdge1 = GetChargeFlowerUpperEdge( pBNS, pVA, eNPlusEdge1 );</a>
<a name="ln4513">            eNFlowerEdge2 = GetChargeFlowerUpperEdge( pBNS, pVA, eNPlusEdge2 );</a>
<a name="ln4514"> </a>
<a name="ln4515">            /* 1. N(-)=N(+)=N- */</a>
<a name="ln4516">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 1 &amp;&amp;  /* N(-) */</a>
<a name="ln4517">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4518">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4519">                /* fix charges on N(-)=N(+)=N- */</a>
<a name="ln4520">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4521">                    goto exit_function;</a>
<a name="ln4522">                }</a>
<a name="ln4523">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4524">                    goto exit_function;</a>
<a name="ln4525">                }</a>
<a name="ln4526">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4527">                    goto exit_function;</a>
<a name="ln4528">                }</a>
<a name="ln4529">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4530">                    goto exit_function;</a>
<a name="ln4531">                }</a>
<a name="ln4532">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4533">                    goto exit_function;</a>
<a name="ln4534">                }</a>
<a name="ln4535">                continue; /* already good */</a>
<a name="ln4536">            }</a>
<a name="ln4537">            /* 2. N#N(+)-N= */</a>
<a name="ln4538">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp; /* N */</a>
<a name="ln4539">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4540">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4541">                /* unfix (-) edge on terminal N# */</a>
<a name="ln4542">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4543">                    goto exit_function;</a>
<a name="ln4544">                }</a>
<a name="ln4545">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4546">                    goto exit_function;</a>
<a name="ln4547">                }</a>
<a name="ln4548">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4549">                    goto exit_function;</a>
<a name="ln4550">                }</a>
<a name="ln4551">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4552">                    goto exit_function;</a>
<a name="ln4553">                }</a>
<a name="ln4554">                pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0];</a>
<a name="ln4555">                nDeltaChargeMax = 0;</a>
<a name="ln4556">                nDeltaChargeMax = (num_failed &amp;&amp; !num_success &amp;&amp; pStruct-&gt;nNumRemovedProtonsMobHInChI &gt; 0)? 2 : 0;</a>
<a name="ln4557">            } else</a>
<a name="ln4558">            /* 3. N(-)=N-N= */</a>
<a name="ln4559">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 1 &amp;&amp; /* N(-) */</a>
<a name="ln4560">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 1 &amp;&amp; /* N */</a>
<a name="ln4561">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N */ ) {</a>
<a name="ln4562">                /* unfix (+) edge on middle N */</a>
<a name="ln4563">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4564">                    goto exit_function;</a>
<a name="ln4565">                }</a>
<a name="ln4566">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4567">                    goto exit_function;</a>
<a name="ln4568">                }</a>
<a name="ln4569">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4570">                    goto exit_function;</a>
<a name="ln4571">                }</a>
<a name="ln4572">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4573">                    goto exit_function;</a>
<a name="ln4574">                }</a>
<a name="ln4575">                if ( NO_VERTEX != eNFlowerEdge1 &amp;&amp;</a>
<a name="ln4576">                     ( ret = AddToEdgeList( &amp;NNNChargeEdges, eNFlowerEdge1, INC_EDGE_LIST ) ) ) {</a>
<a name="ln4577">                    goto exit_function;</a>
<a name="ln4578">                }</a>
<a name="ln4579">                /* decrement flow on (+) charge edge of the middle =N- */</a>
<a name="ln4580">                pe = pBNS-&gt;edge + eNPlusEdge1;</a>
<a name="ln4581">                nDeltaChargeMax = 2;</a>
<a name="ln4582">            } else</a>
<a name="ln4583">            /* 4. N#N(+)-N(-)- */</a>
<a name="ln4584">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4585">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4586">                 pBNS-&gt;edge[eNMinusEdge2].flow == 1 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 1    /* N(-) */ ) {</a>
<a name="ln4587">                /* unfix (-) edge on the 1st and 3rd N */</a>
<a name="ln4588">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4589">                    goto exit_function;</a>
<a name="ln4590">                }</a>
<a name="ln4591">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4592">                    goto exit_function;</a>
<a name="ln4593">                }</a>
<a name="ln4594">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4595">                    goto exit_function;</a>
<a name="ln4596">                }</a>
<a name="ln4597">                /* decrement triple bond on terminal N# */</a>
<a name="ln4598">                pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0];</a>
<a name="ln4599">                nDeltaChargeMax = 0;</a>
<a name="ln4600">            } else</a>
<a name="ln4601">            /* 5. N#N(+)-N(+)# */</a>
<a name="ln4602">            if ( pBNS-&gt;edge[eNMinusEdge].flow  == 0 &amp;&amp;  /* N */</a>
<a name="ln4603">                 pBNS-&gt;edge[eNMinusEdge1].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge1].flow == 0 &amp;&amp; /* N(+) */</a>
<a name="ln4604">                 pBNS-&gt;edge[eNMinusEdge2].flow == 0 &amp;&amp; pBNS-&gt;edge[eNPlusEdge2].flow == 0    /* N(+) */ ) {</a>
<a name="ln4605">                /* unfix (-) edge on the 1st and (+) edge on the 3rd N */</a>
<a name="ln4606">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNPlusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4607">                    goto exit_function;</a>
<a name="ln4608">                }</a>
<a name="ln4609">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4610">                    goto exit_function;</a>
<a name="ln4611">                }</a>
<a name="ln4612">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNMinusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4613">                    goto exit_function;</a>
<a name="ln4614">                }</a>
<a name="ln4615">                /* decrement triple bond on terminal N# */</a>
<a name="ln4616">                pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[0];</a>
<a name="ln4617">                nDeltaChargeMax = 0;</a>
<a name="ln4618">            } else {</a>
<a name="ln4619">                continue;</a>
<a name="ln4620">            }</a>
<a name="ln4621"> </a>
<a name="ln4622">            if ( NO_VERTEX != eNFlowerEdge1 &amp;&amp; !pBNS-&gt;edge[eNFlowerEdge1].flow ) {</a>
<a name="ln4623">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNFlowerEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4624">                    goto exit_function;</a>
<a name="ln4625">                }</a>
<a name="ln4626">            }</a>
<a name="ln4627">            if ( NO_VERTEX != eNFlowerEdge2 &amp;&amp; !pBNS-&gt;edge[eNFlowerEdge2].flow ) {</a>
<a name="ln4628">                if ( (ret = AddToEdgeList( &amp;NNNChargeEdges, eNFlowerEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4629">                    goto exit_function;</a>
<a name="ln4630">                }</a>
<a name="ln4631">            }</a>
<a name="ln4632"> </a>
<a name="ln4633">            v1 = pe-&gt;neighbor1;</a>
<a name="ln4634">            v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln4635">            pe-&gt;flow --;</a>
<a name="ln4636">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln4637">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln4638">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln4639"> </a>
<a name="ln4640">            pe-&gt;forbidden                    |= forbidden_edge_mask;</a>
<a name="ln4641">            </a>
<a name="ln4642">            if ( !CarbonChargeEdges.num_edges ) {</a>
<a name="ln4643">                /* do not let carbon atoms get charged */</a>
<a name="ln4644">                AllocEdgeList( &amp;CarbonChargeEdges, INC_EDGE_LIST ); </a>
<a name="ln4645">                if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln4646">                    goto exit_function;</a>
<a name="ln4647">                }</a>
<a name="ln4648">            } else {</a>
<a name="ln4649">                SetForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln4650">            }</a>
<a name="ln4651">            SetForbiddenEdgeMask( pBNS, &amp;NNNChargeEdges, forbidden_edge_mask );</a>
<a name="ln4652"> </a>
<a name="ln4653">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4654">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4655"> </a>
<a name="ln4656">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4657">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge &lt;= nDeltaChargeMax ) {</a>
<a name="ln4658">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4659">                (*pnNumRunBNS) ++;</a>
<a name="ln4660">                *pnTotalDelta += ret;</a>
<a name="ln4661">                num_success ++;</a>
<a name="ln4662">                /* fix charges on N(-)=N(+)=N- */</a>
<a name="ln4663">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge, INC_EDGE_LIST )) ) {</a>
<a name="ln4664">                    goto exit_function;</a>
<a name="ln4665">                }</a>
<a name="ln4666">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4667">                    goto exit_function;</a>
<a name="ln4668">                }</a>
<a name="ln4669">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge1, INC_EDGE_LIST )) ) {</a>
<a name="ln4670">                    goto exit_function;</a>
<a name="ln4671">                }</a>
<a name="ln4672">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNPlusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4673">                    goto exit_function;</a>
<a name="ln4674">                }</a>
<a name="ln4675">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, eNMinusEdge2, INC_EDGE_LIST )) ) {</a>
<a name="ln4676">                    goto exit_function;</a>
<a name="ln4677">                }</a>
<a name="ln4678">            } else {</a>
<a name="ln4679">                pe-&gt;flow ++;</a>
<a name="ln4680">                pBNS-&gt;vert[v1].st_edge.flow ++;</a>
<a name="ln4681">                pBNS-&gt;vert[v2].st_edge.flow ++;</a>
<a name="ln4682">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln4683">                num_failed ++;</a>
<a name="ln4684">            }</a>
<a name="ln4685">            RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln4686">            RemoveForbiddenEdgeMask( pBNS, &amp;NNNChargeEdges, forbidden_edge_mask );</a>
<a name="ln4687">            pe-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4688">            /*pBNS-&gt;edge[eNPlusEdge].forbidden &amp;= inv_forbidden_edge_mask;*/ /* BC: array index out of range */</a>
<a name="ln4689">        }</a>
<a name="ln4690">    }</a>
<a name="ln4691">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln4692"> </a>
<a name="ln4693"> </a>
<a name="ln4694">exit_function:</a>
<a name="ln4695"> </a>
<a name="ln4696">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4697">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4698">    AllocEdgeList( &amp;NNNChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4699">    AllocEdgeList( &amp;CurNNNChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4700">    AllocEdgeList( &amp;AllNNNTermAtoms, EDGE_LIST_FREE );</a>
<a name="ln4701">    AllocEdgeList( &amp;AllNIIIChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4702">    return ret;</a>
<a name="ln4703">#undef INC_EDGE_LIST</a>
<a name="ln4704">}</a>
<a name="ln4705">/******************************************************************************************************/</a>
<a name="ln4706">int EliminateNitrogen5Val3Bonds(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln4707">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln4708">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln4709">{</a>
<a name="ln4710">    int i, j, k, bForbiddenCarbonCharges, ret2, ret;</a>
<a name="ln4711">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln4712">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln4713">    int len_at = num_at + num_deleted_H;</a>
<a name="ln4714">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln4715">    EDGE_LIST CarbonChargeEdges;</a>
<a name="ln4716"> </a>
<a name="ln4717">    ret = 0;</a>
<a name="ln4718">    bForbiddenCarbonCharges = 0;</a>
<a name="ln4719">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4720">        </a>
<a name="ln4721">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln4722">    pStruct-&gt;at = at2;</a>
<a name="ln4723">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4724">    if ( ret2 &lt; 0 ) {</a>
<a name="ln4725">        ret = ret2;</a>
<a name="ln4726">        goto exit_function;</a>
<a name="ln4727">    }</a>
<a name="ln4728"> </a>
<a name="ln4729">    /* forbid creation of other N(V) atoms */</a>
<a name="ln4730">    /* fix single bonds to metals */</a>
<a name="ln4731">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4732">        if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp; </a>
<a name="ln4733">             0 &lt;= (k = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[i].nCPlusGroupEdge-1 )) &amp;&amp;</a>
<a name="ln4734">             1 == pBNS-&gt;edge[k].flow) {</a>
<a name="ln4735">            pBNS-&gt;edge[k].forbidden |= forbidden_edge_mask;</a>
<a name="ln4736">        } else</a>
<a name="ln4737">        if ( pVA[i].cMetal ) {</a>
<a name="ln4738">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln4739">                if ( BOND_TYPE_SINGLE == (at2[i].bond_type[j] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln4740">                    pBNS-&gt;edge[pBNS-&gt;vert[i].iedge[j]].forbidden |= forbidden_edge_mask;</a>
<a name="ln4741">                }</a>
<a name="ln4742">            }</a>
<a name="ln4743">        }</a>
<a name="ln4744">    }</a>
<a name="ln4745"> </a>
<a name="ln4746">    /*------------------------------------------------------------------------------</a>
<a name="ln4747">                 (+)  single line =&gt; flow = 0                            (+)-(Y)=(+)super</a>
<a name="ln4748">            01  //    double line =&gt; flow = 1                fix-&gt; 01   // &lt;-- fix</a>
<a name="ln4749">         1 --- 0                                                 1 === 0    </a>
<a name="ln4750">          \\ //         edge eij connects vertices i &lt; j:         \   /  02 </a>
<a name="ln4751">        12  2   02 &lt;--- edge number: e02 connects vertices v0   12  2(..) &lt;- double 'radical'  </a>
<a name="ln4752">            |                        v0 and v2                      |       </a>
<a name="ln4753">           =N=      vertex N has number i                          =N=      </a>
<a name="ln4754">            |                                                       |       </a>
<a name="ln4755">    --------------------------------------------------------------------------------*/</a>
<a name="ln4756">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4757">        if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp; at2[i].valence == 3 &amp;&amp;</a>
<a name="ln4758">             at2[i].chem_bonds_valence == 5 &amp;&amp; !at2[i].charge &amp;&amp; !at2[i].radical &amp;&amp;</a>
<a name="ln4759">             !(at2[i].endpoint || (pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;endpoint[i])) &amp;&amp; pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln4760">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_NPN &amp;&amp;</a>
<a name="ln4761">             pVA[i].nCPlusGroupEdge &gt; 0 ) {</a>
<a name="ln4762">            </a>
<a name="ln4763">            Vertex v, v0 = NO_VERTEX, v1 = NO_VERTEX, v2 = NO_VERTEX;</a>
<a name="ln4764">            EdgeIndex iePlus, ie, ie12 = NO_VERTEX, ie02, ie01;</a>
<a name="ln4765">            BNS_VERTEX *pv0, *pv1, *pv2 = NULL;</a>
<a name="ln4766">            BNS_EDGE   *pePlus, *pe, *pe12 = NULL, *pe02 = NULL, *pe01 = NULL;</a>
<a name="ln4767">            Vertex     vPathStart, vPathEnd;</a>
<a name="ln4768">            int        nPathLen;</a>
<a name="ln4769">            int        nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln4770">            </a>
<a name="ln4771">            iePlus = pVA[i].nCPlusGroupEdge - 1;</a>
<a name="ln4772">            pePlus = pBNS-&gt;edge + iePlus;</a>
<a name="ln4773"> </a>
<a name="ln4774">            v0 = IS_BNS_VT_C_GR( pBNS-&gt;vert[pePlus-&gt;neighbor1].type )?</a>
<a name="ln4775">                 (pePlus-&gt;neighbor1 ^ pePlus-&gt;neighbor12) : pePlus-&gt;neighbor1;</a>
<a name="ln4776">            pv0 = pBNS-&gt;vert + v0;</a>
<a name="ln4777">            for ( j = 0; j &lt; pv0-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln4778">                ie = pv0-&gt;iedge[j];</a>
<a name="ln4779">                if ( ie == iePlus ) {</a>
<a name="ln4780">                    continue;</a>
<a name="ln4781">                }</a>
<a name="ln4782">                pe = pBNS-&gt;edge + ie;</a>
<a name="ln4783">                if ( pe-&gt;flow == 1 &amp;&amp; v2 == NO_VERTEX ) {</a>
<a name="ln4784">                    /* 0 - 2, edge 02 */</a>
<a name="ln4785">                    v2  = pe-&gt;neighbor12 ^ v0;</a>
<a name="ln4786">                    pv2 = pBNS-&gt;vert + v2;</a>
<a name="ln4787">                    ie02 = ie;</a>
<a name="ln4788">                    pe02 = pe;</a>
<a name="ln4789">                } else</a>
<a name="ln4790">                if ( pe-&gt;flow == 0 &amp;&amp; v1 == NO_VERTEX ) {</a>
<a name="ln4791">                    /* 0 - 1, edge 01 */</a>
<a name="ln4792">                    v1  = pe-&gt;neighbor12 ^ v0;</a>
<a name="ln4793">                    pv1 = pBNS-&gt;vert + v2;</a>
<a name="ln4794">                    ie01 = ie;</a>
<a name="ln4795">                    pe01 = pe;</a>
<a name="ln4796">                } else {</a>
<a name="ln4797">                    ret = RI_ERR_PROGR;</a>
<a name="ln4798">                    goto exit_function;</a>
<a name="ln4799">                }</a>
<a name="ln4800">            }</a>
<a name="ln4801">            if ( v1 == NO_VERTEX || v2 == NO_VERTEX ) {</a>
<a name="ln4802">                ret = RI_ERR_PROGR;</a>
<a name="ln4803">                goto exit_function;</a>
<a name="ln4804">            }</a>
<a name="ln4805">            for ( j = 0; j &lt; pv2-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln4806">                ie = pv2-&gt;iedge[j];</a>
<a name="ln4807">                pe = pBNS-&gt;edge + ie;</a>
<a name="ln4808">                v  = pe-&gt;neighbor12 ^ v2;</a>
<a name="ln4809">                if ( v == v0 || v == i ) {</a>
<a name="ln4810">                    continue;</a>
<a name="ln4811">                } else</a>
<a name="ln4812">                if ( v == v1 &amp;&amp; pe-&gt;flow == 1 ) {</a>
<a name="ln4813">                    /* 1 - 2, edge 12 */</a>
<a name="ln4814">                    ie12 = ie;</a>
<a name="ln4815">                    pe12 = pe;</a>
<a name="ln4816">                } else {</a>
<a name="ln4817">                    ret = RI_ERR_PROGR;</a>
<a name="ln4818">                    goto exit_function;</a>
<a name="ln4819">                }</a>
<a name="ln4820">            }</a>
<a name="ln4821">            if ( ie12 == NO_VERTEX ) {</a>
<a name="ln4822">                ret = RI_ERR_PROGR;</a>
<a name="ln4823">                goto exit_function;</a>
<a name="ln4824">            }</a>
<a name="ln4825">            /* rearrange cap and flow, forbid 2 edges */</a>
<a name="ln4826">            pe01-&gt;flow = 1;</a>
<a name="ln4827">            pe12-&gt;flow = 0;</a>
<a name="ln4828">            pe02-&gt;flow = 0;</a>
<a name="ln4829">            pv2-&gt;st_edge.flow -= 2;</a>
<a name="ln4830">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln4831">            pePlus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln4832">            pe01-&gt;forbidden   |= forbidden_edge_mask;</a>
<a name="ln4833">            </a>
<a name="ln4834">            if ( !bForbiddenCarbonCharges ) {</a>
<a name="ln4835">                if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln4836">                    goto exit_function;</a>
<a name="ln4837">                }</a>
<a name="ln4838">                bForbiddenCarbonCharges = 1;</a>
<a name="ln4839">            }</a>
<a name="ln4840"> </a>
<a name="ln4841"> </a>
<a name="ln4842">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4843">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4844">            if ( ret == 1 &amp;&amp; vPathEnd == v2 &amp;&amp; vPathStart == v2 &amp;&amp; nDeltaCharge &lt;= (pVA[i].cNumBondsToMetal? 2:0) ) {</a>
<a name="ln4845">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4846">            } else {</a>
<a name="ln4847">                pe01-&gt;flow = 0;</a>
<a name="ln4848">                pe12-&gt;flow = 1;</a>
<a name="ln4849">                pe02-&gt;flow = 1;</a>
<a name="ln4850">                pv2-&gt;st_edge.flow += 2;</a>
<a name="ln4851">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln4852">            }</a>
<a name="ln4853">            pePlus-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4854">            pe01-&gt;forbidden   &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4855"> </a>
<a name="ln4856">            if ( ret &lt; 0 ) {</a>
<a name="ln4857">                goto exit_function;</a>
<a name="ln4858">            } else</a>
<a name="ln4859">            if ( ret ) {</a>
<a name="ln4860">                memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln4861">                pStruct-&gt;at = at2;</a>
<a name="ln4862">                ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4863">                if ( ret2 &lt; 0 ) {</a>
<a name="ln4864">                    ret = ret2;</a>
<a name="ln4865">                    goto exit_function;</a>
<a name="ln4866">                }</a>
<a name="ln4867">            }</a>
<a name="ln4868">        }</a>
<a name="ln4869">    }</a>
<a name="ln4870">exit_function:</a>
<a name="ln4871">    /* allow creation of other N(V) atoms */</a>
<a name="ln4872">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4873">        if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp; </a>
<a name="ln4874">             0 &lt;= (k = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[i].nCPlusGroupEdge-1 )) &amp;&amp;</a>
<a name="ln4875">             1 == pBNS-&gt;edge[k].flow &amp;&amp; (pBNS-&gt;edge[k].forbidden &amp; forbidden_edge_mask) ) {</a>
<a name="ln4876">            pBNS-&gt;edge[k].forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4877">        } else</a>
<a name="ln4878">        if ( pVA[i].cMetal ) {</a>
<a name="ln4879">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln4880">                if ( BOND_TYPE_SINGLE == (at2[i].bond_type[j] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln4881">                    pBNS-&gt;edge[pBNS-&gt;vert[i].iedge[j]].forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4882">                }</a>
<a name="ln4883">            }</a>
<a name="ln4884">        }</a>
<a name="ln4885">    }</a>
<a name="ln4886">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln4887">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln4888">    return ret;</a>
<a name="ln4889">}</a>
<a name="ln4890">/******************************************************************************************************/</a>
<a name="ln4891">int Convert_SIV_to_SVI(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln4892">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln4893">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln4894">{</a>
<a name="ln4895">    int i, j, k, neigh, bForbiddenCarbonCharges, nFlowerEdge, delta, ret2, ret;</a>
<a name="ln4896">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln4897">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln4898">    int len_at = num_at + num_deleted_H;</a>
<a name="ln4899">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln4900">    EDGE_LIST CarbonChargeEdges, FlowerEdgesList;</a>
<a name="ln4901"> </a>
<a name="ln4902">    ret = 0;</a>
<a name="ln4903">    bForbiddenCarbonCharges = 0;</a>
<a name="ln4904">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln4905">    AllocEdgeList( &amp;FlowerEdgesList, EDGE_LIST_CLEAR );</a>
<a name="ln4906">        </a>
<a name="ln4907">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln4908">    pStruct-&gt;at = at2;</a>
<a name="ln4909">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4910">    if ( ret2 &lt; 0 ) {</a>
<a name="ln4911">        ret = ret2;</a>
<a name="ln4912">        goto exit_function;</a>
<a name="ln4913">    }</a>
<a name="ln4914"> </a>
<a name="ln4915">    /* forbid creation of other S(IV) atoms */</a>
<a name="ln4916">    /* fix single bonds to metals and (N(IV), flow=1), (S(IV), flow=0) */</a>
<a name="ln4917">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4918">        if ( (pVA[i].cNumValenceElectrons == 5 /* N(IV)*/ || pVA[i].cNumValenceElectrons == 6 /* S(VI)*/) &amp;&amp; </a>
<a name="ln4919">             0 &lt;= (k = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[i].nCPlusGroupEdge-1 )) &amp;&amp;</a>
<a name="ln4920">             !pBNS-&gt;edge[k].forbidden &amp;&amp;</a>
<a name="ln4921">             6 == pVA[i].cNumValenceElectrons + pBNS-&gt;edge[k].flow ) {</a>
<a name="ln4922"> </a>
<a name="ln4923">            pBNS-&gt;edge[k].forbidden |= forbidden_edge_mask;</a>
<a name="ln4924">            if ( (ret = AddToEdgeList( &amp;FlowerEdgesList, k, 64 )) ) {</a>
<a name="ln4925">                goto exit_function;</a>
<a name="ln4926">            }</a>
<a name="ln4927">        } else</a>
<a name="ln4928">        if ( pVA[i].cMetal ) {</a>
<a name="ln4929">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln4930">                if ( BOND_TYPE_SINGLE == (at2[i].bond_type[j] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln4931"> </a>
<a name="ln4932">                    pBNS-&gt;edge[k=pBNS-&gt;vert[i].iedge[j]].forbidden |= forbidden_edge_mask;</a>
<a name="ln4933">                    if ( (ret = AddToEdgeList( &amp;FlowerEdgesList, k, 64 )) ) {</a>
<a name="ln4934">                        goto exit_function;</a>
<a name="ln4935">                    }</a>
<a name="ln4936">                }</a>
<a name="ln4937">            }</a>
<a name="ln4938">        } else</a>
<a name="ln4939">        /* fix bonds to neighbors of S(IV) if they are not O,S,Se,Te with 2 or more bonds */</a>
<a name="ln4940">        /* exactly same if(..) as below */</a>
<a name="ln4941">        if ( pVA[i].cNumValenceElectrons == 6 &amp;&amp; at2[i].valence == 4 &amp;&amp;</a>
<a name="ln4942">             at2[i].chem_bonds_valence == 4 &amp;&amp; !at2[i].charge &amp;&amp; !at2[i].radical &amp;&amp;</a>
<a name="ln4943">             !at2[i].endpoint &amp;&amp; pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln4944">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_NPN &amp;&amp;</a>
<a name="ln4945">             0 &lt;= (nFlowerEdge = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[i].nCPlusGroupEdge-1 ) ) &amp;&amp;</a>
<a name="ln4946">             pBNS-&gt;edge[nFlowerEdge].flow &gt; 0 ) {</a>
<a name="ln4947"> </a>
<a name="ln4948">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln4949">                neigh = at2[i].neighbor[j];</a>
<a name="ln4950">                if ( pVA[neigh].cNumValenceElectrons != 6 &amp;&amp; at2[neigh].valence &gt; 1 ) {</a>
<a name="ln4951">                    k = pBNS-&gt;vert[i].iedge[j];</a>
<a name="ln4952">                    if ( !pBNS-&gt;edge[k].forbidden ) {</a>
<a name="ln4953">                        if ( (ret = AddToEdgeList( &amp;FlowerEdgesList, k, 64 )) ) {</a>
<a name="ln4954">                            goto exit_function;</a>
<a name="ln4955">                        }</a>
<a name="ln4956">                        pBNS-&gt;edge[k].forbidden |= forbidden_edge_mask;</a>
<a name="ln4957">                    }</a>
<a name="ln4958">                }</a>
<a name="ln4959">            }</a>
<a name="ln4960">        }</a>
<a name="ln4961">    }</a>
<a name="ln4962">    /*------------------------------------------------------------------------------</a>
<a name="ln4963">                        example: struct #301,</a>
<a name="ln4964">      |          |               disconnected porphyrin with four -SO3(-)</a>
<a name="ln4965">     -S-   =&gt;   =S=</a>
<a name="ln4966">      |          |</a>
<a name="ln4967">    </a>
<a name="ln4968">    -------------------------------------------------------------------------------*/</a>
<a name="ln4969"> </a>
<a name="ln4970">    /*-------------------------------------------------------------------------------</a>
<a name="ln4971">     found:                                       super(+)=(Y)        super(+)=(Y)   </a>
<a name="ln4972">                                                              \                   \           </a>
<a name="ln4973">             (+)  single line =&gt; flow = 0                     (+)                 (+)</a>
<a name="ln4974">        01  //    double line =&gt; flow = 1         fix-&gt; 01   //             01   //             </a>
<a name="ln4975">     1 === 0      triple line =&gt; flow = 2          (.)1 --- 0(.)  ---&gt;    1 --- 0               </a>
<a name="ln4976">      \   /       edge eij connects vertices i&lt;j:      \   /  02  run      \\ //  02            </a>
<a name="ln4977">    12  2   02 &lt;--- edge number: e02 connects        12  2        BFS    12  2                        </a>
<a name="ln4978">       |||              vertices v0 and v2              |||                  |                  </a>
<a name="ln4979">       -S-      vertex S has number i                   -S-                 =S=                 </a>
<a name="ln4980">       / \                                              / \                 / \                 </a>
<a name="ln4981">    --------------------------------------------------------------------------------*/</a>
<a name="ln4982">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4983">        if ( pVA[i].cNumValenceElectrons == 6 &amp;&amp; at2[i].valence == 4 &amp;&amp;</a>
<a name="ln4984">             at2[i].chem_bonds_valence == 4 &amp;&amp; !at2[i].charge &amp;&amp; !at2[i].radical &amp;&amp;</a>
<a name="ln4985">             !at2[i].endpoint &amp;&amp; pVA[i].cnListIndex &gt; 0 &amp;&amp;</a>
<a name="ln4986">             cnList[pVA[i].cnListIndex-1].bits == cn_bits_NPN &amp;&amp;</a>
<a name="ln4987">             /* 01 is nFlowerEdge */</a>
<a name="ln4988">             0 &lt;= (nFlowerEdge = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[i].nCPlusGroupEdge-1 ) ) &amp;&amp;</a>
<a name="ln4989">             pBNS-&gt;edge[nFlowerEdge].flow &gt; 0 ) {</a>
<a name="ln4990">            </a>
<a name="ln4991">            Vertex     v1 = NO_VERTEX, v2 = NO_VERTEX;</a>
<a name="ln4992">            BNS_VERTEX *pv1, *pv2;</a>
<a name="ln4993">            BNS_EDGE   *pe;</a>
<a name="ln4994">            Vertex     vPathStart, vPathEnd;</a>
<a name="ln4995">            int        nPathLen;</a>
<a name="ln4996">            int        nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln4997"> </a>
<a name="ln4998">            if ( !bForbiddenCarbonCharges ) {</a>
<a name="ln4999">                if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln5000">                    goto exit_function;</a>
<a name="ln5001">                }</a>
<a name="ln5002">                bForbiddenCarbonCharges = 1;</a>
<a name="ln5003">            }</a>
<a name="ln5004"> </a>
<a name="ln5005">            delta = 1;</a>
<a name="ln5006">            pe = pBNS-&gt;edge + nFlowerEdge;                 /* edge  01 */</a>
<a name="ln5007">            pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);       /* vertex 0 */</a>
<a name="ln5008">            pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1); /* vertex 1 */</a>
<a name="ln5009"> </a>
<a name="ln5010">            pe-&gt;forbidden     |= forbidden_edge_mask;</a>
<a name="ln5011">            pe-&gt;flow          -= delta;</a>
<a name="ln5012">            pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln5013">            pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln5014">            pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln5015"> </a>
<a name="ln5016">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln5017">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln5018">            if ( ret == 1 &amp;&amp; </a>
<a name="ln5019">                 ((vPathEnd == v1 &amp;&amp; vPathStart == v2) || (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln5020">                 nDeltaCharge &lt;= (pVA[i].cNumBondsToMetal? 2:0) ) {</a>
<a name="ln5021">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5022">            } else {</a>
<a name="ln5023">                pe-&gt;forbidden     &amp;= inv_forbidden_edge_mask;</a>
<a name="ln5024">                pe-&gt;flow          += delta;</a>
<a name="ln5025">                pv1-&gt;st_edge.flow += delta;</a>
<a name="ln5026">                pv2-&gt;st_edge.flow += delta;</a>
<a name="ln5027">                pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln5028">            }</a>
<a name="ln5029">            if ( ret &lt; 0 ) {</a>
<a name="ln5030">                goto exit_function;</a>
<a name="ln5031">            } else</a>
<a name="ln5032">            if ( ret ) {</a>
<a name="ln5033">                memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln5034">                pStruct-&gt;at = at2;</a>
<a name="ln5035">                ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln5036">                if ( ret2 &lt; 0 ) {</a>
<a name="ln5037">                    ret = ret2;</a>
<a name="ln5038">                    goto exit_function;</a>
<a name="ln5039">                }</a>
<a name="ln5040">                /* store the fixed edge to unfix it upon exit */</a>
<a name="ln5041">                if ( (ret = AddToEdgeList( &amp;FlowerEdgesList, nFlowerEdge, 64 )) ) {</a>
<a name="ln5042">                    goto exit_function;</a>
<a name="ln5043">                }</a>
<a name="ln5044">            }</a>
<a name="ln5045">        }</a>
<a name="ln5046">    }</a>
<a name="ln5047">exit_function:</a>
<a name="ln5048">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln5049">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln5050">    RemoveForbiddenEdgeMask( pBNS, &amp;FlowerEdgesList, forbidden_edge_mask );</a>
<a name="ln5051">    AllocEdgeList( &amp;FlowerEdgesList, EDGE_LIST_FREE );</a>
<a name="ln5052">    return ret;</a>
<a name="ln5053">}</a>
<a name="ln5054">/******************************************************************************************************</a>
<a name="ln5055">  </a>
<a name="ln5056"> </a>
<a name="ln5057">  =N(+)=O       =N-O(-)</a>
<a name="ln5058">            =&gt;</a>
<a name="ln5059">   M(q)         M(q+2)</a>
<a name="ln5060"> </a>
<a name="ln5061">*******************************************************************************************************/</a>
<a name="ln5062">int PlusFromDB_N_DB_O_to_Metal(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln5063">                     inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln5064">                     int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln5065">{</a>
<a name="ln5066">    int i, j, k, n, bForbiddenCarbonCharges, delta, ret2, ret, num_NO, num_M;</a>
<a name="ln5067">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln5068">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln5069">    int len_at = num_at + num_deleted_H;</a>
<a name="ln5070">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln5071">    EDGE_LIST CarbonChargeEdges, NO_ChargeEdgeList, NO_EdgeList;</a>
<a name="ln5072"> </a>
<a name="ln5073">    Vertex     v1, v2;</a>
<a name="ln5074">    BNS_VERTEX *pv1, *pv2;</a>
<a name="ln5075">    BNS_EDGE   *pe;</a>
<a name="ln5076">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln5077">    int        nPathLen;</a>
<a name="ln5078">    int        nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln5079"> </a>
<a name="ln5080"> </a>
<a name="ln5081">    if ( !pTCGroups-&gt;num_metal_atoms )</a>
<a name="ln5082">        return 0;</a>
<a name="ln5083"> </a>
<a name="ln5084">    ret = 0;</a>
<a name="ln5085">    bForbiddenCarbonCharges = 0;</a>
<a name="ln5086">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR ); /* all charges */</a>
<a name="ln5087">    AllocEdgeList( &amp;NO_ChargeEdgeList, EDGE_LIST_CLEAR ); /* charges to be changed */</a>
<a name="ln5088">    AllocEdgeList( &amp;NO_EdgeList, EDGE_LIST_CLEAR );       /* N(+)=O edges */</a>
<a name="ln5089">        </a>
<a name="ln5090">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln5091">    pStruct-&gt;at = at2;</a>
<a name="ln5092">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln5093">    if ( ret2 &lt; 0 ) {</a>
<a name="ln5094">        ret = ret2;</a>
<a name="ln5095">        goto exit_function;</a>
<a name="ln5096">    }</a>
<a name="ln5097">    num_NO = num_M = 0;</a>
<a name="ln5098">    /* forbid creation of other S(IV) atoms */</a>
<a name="ln5099">    /* fix single bonds to metals and (N(IV), flow=1), (S(IV), flow=0) */</a>
<a name="ln5100">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln5101">        if ( !pVA[i].cMetal ) {</a>
<a name="ln5102">            if ( (k = pVA[i].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden ) {</a>
<a name="ln5103">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, k, 64 )) ) {</a>
<a name="ln5104">                    goto exit_function;</a>
<a name="ln5105">                }</a>
<a name="ln5106">            }</a>
<a name="ln5107">            if ( (k = pVA[i].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden ) {</a>
<a name="ln5108">                if ( (ret = AddToEdgeList( &amp;CarbonChargeEdges, k, 64 )) ) {</a>
<a name="ln5109">                    goto exit_function;</a>
<a name="ln5110">                }</a>
<a name="ln5111">            }</a>
<a name="ln5112">        } else {</a>
<a name="ln5113">            num_M ++;</a>
<a name="ln5114">        }</a>
<a name="ln5115">        /*</a>
<a name="ln5116">        if ( pVA[i].cMetal ) {</a>
<a name="ln5117">            if ( (k = pVA[i].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden ) {</a>
<a name="ln5118">                if ( ret = AddToEdgeList( &amp;NO_ChargeEdgeList, k, 64 ) ) {</a>
<a name="ln5119">                    goto exit_function;</a>
<a name="ln5120">                }</a>
<a name="ln5121">            }</a>
<a name="ln5122">            if ( (k = pVA[i].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden ) {</a>
<a name="ln5123">                if ( ret = AddToEdgeList( &amp;NO_ChargeEdgeList, k, 64 ) ) {</a>
<a name="ln5124">                    goto exit_function;</a>
<a name="ln5125">                }</a>
<a name="ln5126">            }</a>
<a name="ln5127">        } else</a>
<a name="ln5128">        */</a>
<a name="ln5129">        if ( !pVA[i].cMetal &amp;&amp;</a>
<a name="ln5130">             pVA[i].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln5131">             at2[i].charge == 0 &amp;&amp; !at2[i].num_H &amp;&amp;</a>
<a name="ln5132">             1 == at2[i].valence &amp;&amp; 2 == at2[i].chem_bonds_valence &amp;&amp;</a>
<a name="ln5133">             pVA[j=at2[i].neighbor[0]].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln5134">             at2[j].charge == 1 &amp;&amp; !at2[j].num_H &amp;&amp;</a>
<a name="ln5135">             2 == at2[j].valence &amp;&amp; 4 == at2[j].chem_bonds_valence ) {</a>
<a name="ln5136">            /* found =N(+)=O */</a>
<a name="ln5137">            if ( (k = pVA[i].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden /* O */ &amp;&amp;</a>
<a name="ln5138">                 (n = pVA[j].nCPlusGroupEdge -1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[j].forbidden /* N */ ) {</a>
<a name="ln5139">                if ( (ret = AddToEdgeList( &amp;NO_ChargeEdgeList, k, 64 ) ) ||</a>
<a name="ln5140">                     (ret = AddToEdgeList( &amp;NO_ChargeEdgeList, n, 64 ) ) ) {</a>
<a name="ln5141">                    goto exit_function;</a>
<a name="ln5142">                }</a>
<a name="ln5143">                k = pBNS-&gt;vert[i].iedge[0];  /* N(+)=O bond */</a>
<a name="ln5144">                if ( !pBNS-&gt;edge[k].forbidden ) { </a>
<a name="ln5145">                    if ( (ret = AddToEdgeList( &amp;NO_EdgeList, k, 64 )) ) {</a>
<a name="ln5146">                        goto exit_function;</a>
<a name="ln5147">                    }</a>
<a name="ln5148">                    num_NO ++;</a>
<a name="ln5149">                }</a>
<a name="ln5150">            }</a>
<a name="ln5151">        }</a>
<a name="ln5152">    }</a>
<a name="ln5153">    if ( num_M &amp;&amp; num_NO ) {</a>
<a name="ln5154">        SetForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln5155">        SetForbiddenEdgeMask( pBNS, &amp;NO_EdgeList, forbidden_edge_mask );</a>
<a name="ln5156">        RemoveForbiddenEdgeMask( pBNS, &amp;NO_ChargeEdgeList, forbidden_edge_mask  );</a>
<a name="ln5157">        /* now only N(+), O(-) and metal charges are allowed to change */</a>
<a name="ln5158">        for ( i = 0; i &lt; NO_EdgeList.num_edges; i ++ ) {</a>
<a name="ln5159">            k = NO_EdgeList.pnEdges[i];</a>
<a name="ln5160">            delta = 1;</a>
<a name="ln5161">            pe = pBNS-&gt;edge + k;                 /* edge  N(+)=O */</a>
<a name="ln5162">            pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);       /* vertex 0 */</a>
<a name="ln5163">            pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1); /* vertex 1 */</a>
<a name="ln5164"> </a>
<a name="ln5165">            pe-&gt;flow          -= delta;</a>
<a name="ln5166">            pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln5167">            pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln5168">            pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln5169"> </a>
<a name="ln5170">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln5171">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln5172">            if ( ret == 1 &amp;&amp; </a>
<a name="ln5173">                 ((vPathEnd == v1 &amp;&amp; vPathStart == v2) || (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln5174">                 nDeltaCharge == 0 ) {</a>
<a name="ln5175">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5176">            } else {</a>
<a name="ln5177">                pe-&gt;forbidden     &amp;= inv_forbidden_edge_mask;</a>
<a name="ln5178">                pe-&gt;flow          += delta;</a>
<a name="ln5179">                pv1-&gt;st_edge.flow += delta;</a>
<a name="ln5180">                pv2-&gt;st_edge.flow += delta;</a>
<a name="ln5181">                pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln5182">            }</a>
<a name="ln5183">            if ( ret &lt; 0 ) {</a>
<a name="ln5184">                goto exit_function;</a>
<a name="ln5185">            }</a>
<a name="ln5186">        }</a>
<a name="ln5187">    }</a>
<a name="ln5188">exit_function:</a>
<a name="ln5189">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln5190">    RemoveForbiddenEdgeMask( pBNS, &amp;NO_EdgeList, forbidden_edge_mask );</a>
<a name="ln5191">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln5192">    AllocEdgeList( &amp;NO_EdgeList, EDGE_LIST_FREE );</a>
<a name="ln5193">    AllocEdgeList( &amp;NO_ChargeEdgeList, EDGE_LIST_FREE );</a>
<a name="ln5194">    return ret;</a>
<a name="ln5195">}</a>
<a name="ln5196">/******************************************************************************************************/</a>
<a name="ln5197">int MoveMobileHToAvoidFixedBonds(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln5198">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln5199">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln5200">{</a>
<a name="ln5201">    int ret2, ret;</a>
<a name="ln5202">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln5203">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln5204">    int len_at = num_at + num_deleted_H;</a>
<a name="ln5205">    int nNumFixedEdges, nNumAdjEdges;</a>
<a name="ln5206">    </a>
<a name="ln5207">    ret = 0;</a>
<a name="ln5208"> </a>
<a name="ln5209">    if ( pTCGroups-&gt;num_tgroups ) {</a>
<a name="ln5210">        memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln5211">        pStruct-&gt;at = at2;</a>
<a name="ln5212">        ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln5213">        pStruct-&gt;at = at;</a>
<a name="ln5214">        if ( ret2 &lt; 0 ) {</a>
<a name="ln5215">            ret = ret2;</a>
<a name="ln5216">            goto exit_function;</a>
<a name="ln5217">        }</a>
<a name="ln5218">#if ( FIND_RING_SYSTEMS == 1 )</a>
<a name="ln5219">        ret2 = MarkRingSystemsInp( at2, num_at, 0 );</a>
<a name="ln5220">        if ( ret2 &lt; 0 ) {</a>
<a name="ln5221">            ret = ret2;</a>
<a name="ln5222">            goto exit_function;</a>
<a name="ln5223">        }</a>
<a name="ln5224">#endif</a>
<a name="ln5225">        /* --- forbidden edges --- */</a>
<a name="ln5226">        ret2 = SetForbiddenEdges( pBNS, at2, num_at, forbidden_edge_mask );</a>
<a name="ln5227">        if ( ret2 &lt; 0 ) {</a>
<a name="ln5228">            ret2 = -(ret + 1);</a>
<a name="ln5229">        }</a>
<a name="ln5230">        nNumFixedEdges = ret2;</a>
<a name="ln5231">        ret = AdjustTgroupsToForbiddenEdges2( pBNS, at2, pVA, num_at, forbidden_edge_mask );</a>
<a name="ln5232">        nNumAdjEdges = ret;</a>
<a name="ln5233">        if ( ret ) {</a>
<a name="ln5234">            pBNS-&gt;edge_forbidden_mask |= forbidden_edge_mask;</a>
<a name="ln5235">            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5236">            (*pnNumRunBNS) ++;</a>
<a name="ln5237">            if ( ret &lt; 0 ) {</a>
<a name="ln5238">                goto exit_function;</a>
<a name="ln5239">            } else {</a>
<a name="ln5240">                *pnTotalDelta += ret;</a>
<a name="ln5241">            }</a>
<a name="ln5242">        }</a>
<a name="ln5243">        if ( nNumFixedEdges || nNumAdjEdges ) {</a>
<a name="ln5244">            /* removes this edge mask from ALL edges */</a>
<a name="ln5245">            RemoveForbiddenBondFlowBits( pBNS, forbidden_edge_mask );</a>
<a name="ln5246">        }</a>
<a name="ln5247">    }</a>
<a name="ln5248"> </a>
<a name="ln5249">exit_function:</a>
<a name="ln5250"> </a>
<a name="ln5251">    return ret;</a>
<a name="ln5252">}</a>
<a name="ln5253">/******************************************************************************************************/</a>
<a name="ln5254">/* Find and eliminate cases when Mobile H endpoint has radical on it (typical for wrong P(VI)(=O)3OH  */</a>
<a name="ln5255">int RemoveRadFromMobileHEndpoint(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln5256">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln5257">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln5258">{</a>
<a name="ln5259">    int i, num_fixes, tot_num_fixes = 0;</a>
<a name="ln5260">    </a>
<a name="ln5261">    int ret2, ret;</a>
<a name="ln5262">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln5263">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln5264">    int len_at = num_at + num_deleted_H;</a>
<a name="ln5265"> </a>
<a name="ln5266">    int         itg, j, k, n, m;</a>
<a name="ln5267">    Vertex      vtg1, endpoint0=NO_VERTEX, endpoint1, endpoint2, centerpoint;</a>
<a name="ln5268">    Vertex      centerpoint_found=NO_VERTEX;</a>
<a name="ln5269">    BNS_VERTEX *ptg1, *pEndp0=NULL, *pEndp1, *pEndp2, *pCentp, *pCentp_found, *pEndp2_found=NULL;</a>
<a name="ln5270">    BNS_EDGE   *etg0=NULL, *etg1, *etg2, *ecp0, *ecp1, *ecp2;</a>
<a name="ln5271">    BNS_EDGE   *etg1_found=NULL, *ecp0_found=NULL, *ecp1_found=NULL, *ecp2_found=NULL;</a>
<a name="ln5272">    int         tgroup_number, num_endpoints;</a>
<a name="ln5273">    </a>
<a name="ln5274">    ret = 0;</a>
<a name="ln5275"> </a>
<a name="ln5276">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln5277">    pStruct-&gt;at = at2;</a>
<a name="ln5278">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln5279">    if ( ret2 &lt; 0 ) {</a>
<a name="ln5280">        ret = ret2;</a>
<a name="ln5281">        goto exit_function;</a>
<a name="ln5282">    }</a>
<a name="ln5283">    while ( pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow &amp;&amp; pTCGroups-&gt;num_tgroups ) {</a>
<a name="ln5284">        num_fixes = 0;</a>
<a name="ln5285">        for ( itg = 0; itg &lt; pTCGroups-&gt;num_tgroups; itg ++ ) {</a>
<a name="ln5286">            pCentp_found=NULL;</a>
<a name="ln5287">            tgroup_number = pTCGroups-&gt;pTCG[itg].ord_num;</a>
<a name="ln5288">            vtg1 = pTCGroups-&gt;pTCG[itg].nVertexNumber;      /* taut group vertex index */</a>
<a name="ln5289">            ptg1 = pBNS-&gt;vert + vtg1;                       /* taut group vertex */</a>
<a name="ln5290">            num_endpoints = pTCGroups-&gt;pTCG[itg].num_edges;</a>
<a name="ln5291">            for ( i = 0; i &lt; num_endpoints; i ++ ) {</a>
<a name="ln5292">                etg0 = pBNS-&gt;edge + ptg1-&gt;iedge[i];         /* edge from t-group to endpoint */</a>
<a name="ln5293">                endpoint0 = etg0-&gt;neighbor12 ^ vtg1;        /* taut endpoint vertex index */</a>
<a name="ln5294">                pEndp0 = pBNS-&gt;vert + endpoint0;            /* taut endpoint vertex (possible location of mobile H */</a>
<a name="ln5295">                if ( pEndp0-&gt;st_edge.cap &gt; pEndp0-&gt;st_edge.flow ) {</a>
<a name="ln5296">                    /* radical endpoint1 has been detected */</a>
<a name="ln5297">                    /* find a 1-3 centerpoint that has two or more endpoints */</a>
<a name="ln5298">                    /* connected to the t-group vertex by edges with flow&gt;0 and */</a>
<a name="ln5299">                    /* to the centerpoint by edges with flow = 0 */</a>
<a name="ln5300">                    /* after that: (1) increment etg1 flow to eliminate radical */</a>
<a name="ln5301">                    /* (2) increment flow on one of the two other edges to the t-group */</a>
<a name="ln5302">                    /* (3) increment st_cap on the found centerpoint */</a>
<a name="ln5303">                    /* (4) rerun the BNS and re-create the structure */</a>
<a name="ln5304">                    break;</a>
<a name="ln5305">                }</a>
<a name="ln5306">            }</a>
<a name="ln5307">            if ( i == num_endpoints ) {</a>
<a name="ln5308">                continue;</a>
<a name="ln5309">            }</a>
<a name="ln5310">            if ( i &lt; num_endpoints ) {</a>
<a name="ln5311">                /* tautomeric endpoint found; traverse its t-group edges */</a>
<a name="ln5312">                for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln5313">                    if ( i == j ) {</a>
<a name="ln5314">                        continue; /* avoid the already found radical endpoint */</a>
<a name="ln5315">                    }</a>
<a name="ln5316">                    etg1 = pBNS-&gt;edge + ptg1-&gt;iedge[j];  /* another edge from t-group to another endpoinr */</a>
<a name="ln5317">                    endpoint1 = etg1-&gt;neighbor12 ^ vtg1; /* another endpoint vertex index */</a>
<a name="ln5318">                    pEndp1 = pBNS-&gt;vert + endpoint1;     /* another endpoint vertex */</a>
<a name="ln5319">                    if ( pEndp1-&gt;st_edge.cap &gt; pEndp1-&gt;st_edge.flow ) {</a>
<a name="ln5320">                        continue; /* one more radical-endpoint! What is going on here??? */</a>
<a name="ln5321">                    }</a>
<a name="ln5322">                    if ( !etg1-&gt;flow ) {</a>
<a name="ln5323">                        continue; /* avoid enpoints that do not have an attachment */</a>
<a name="ln5324">                    }</a>
<a name="ln5325">                    if ( !(pEndp1-&gt;type &amp; BNS_VERT_TYPE_ENDPOINT) ) {</a>
<a name="ln5326">                        continue; /* should not happen */</a>
<a name="ln5327">                    }</a>
<a name="ln5328">                    /* traverse endpoint1 edges to find a single bond connecting it to the centerpoint */</a>
<a name="ln5329">                    for ( k = 0; k &lt; at2[endpoint1].valence; k ++ ) {</a>
<a name="ln5330">                        ecp1 = pBNS-&gt;edge + pEndp1-&gt;iedge[k];</a>
<a name="ln5331">                        if ( ecp1-&gt;flow ) {</a>
<a name="ln5332">                            continue;</a>
<a name="ln5333">                        }</a>
<a name="ln5334">                        centerpoint = ecp1-&gt;neighbor12 ^ endpoint1;</a>
<a name="ln5335">                        pCentp = pBNS-&gt;vert + centerpoint;</a>
<a name="ln5336">                        /* traverse centerpoint edges to find a single bond to the 2nd endpoint */</a>
<a name="ln5337">                        for ( n = 0; n &lt; at2[centerpoint].valence; n ++ ) {</a>
<a name="ln5338">                            ecp2 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5339">                            if ( ecp2-&gt;flow ) {</a>
<a name="ln5340">                                continue;</a>
<a name="ln5341">                            }</a>
<a name="ln5342">                            endpoint2 = ecp2-&gt;neighbor12 ^ centerpoint;</a>
<a name="ln5343">                            if ( endpoint2 &lt;= endpoint1 || !pVA[endpoint2].nTautGroupEdge ) {</a>
<a name="ln5344">                                continue; /* don't go back: neighbors are in order of ascending ord. numbers */</a>
<a name="ln5345">                            }</a>
<a name="ln5346">                            pEndp2 = pBNS-&gt;vert + endpoint2;</a>
<a name="ln5347">                            if ( !(pEndp2-&gt;type &amp; BNS_VERT_TYPE_ENDPOINT) ) {</a>
<a name="ln5348">                                continue;</a>
<a name="ln5349">                            }</a>
<a name="ln5350">                            etg2 = pBNS-&gt;edge + pVA[endpoint2].nTautGroupEdge - 1;</a>
<a name="ln5351">                            if ( !etg2-&gt;flow || (etg2-&gt;neighbor12 ^ endpoint2) != vtg1 ) {</a>
<a name="ln5352">                                continue;</a>
<a name="ln5353">                            }</a>
<a name="ln5354">                            /* we have found the path:</a>
<a name="ln5355">                                              Endp1                                Endp1        </a>
<a name="ln5356">                                       etg1 //     \ ecp1                   etg1 /     \\ ecp1  </a>
<a name="ln5357">                                  etg0     //       \                  etg0     /       \\      </a>
<a name="ln5358">                             Endp0-----tg1           Centp  --&gt;   Endp0=====tg1           Centp </a>
<a name="ln5359">                              ^            \\       /                           \\       /      </a>
<a name="ln5360">                      radical |        etg2 \\     / ecp2                   etg2 \\     / ecp2  </a>
<a name="ln5361">                                              Endp2                                Endp2        </a>
<a name="ln5362">                            */                                                                  </a>
<a name="ln5363"> </a>
<a name="ln5364">                            /* compare centerpoints */</a>
<a name="ln5365">                            if ( !pCentp_found ||</a>
<a name="ln5366">                                 /* try to avoid carbons */</a>
<a name="ln5367">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5368">                                  pVA[centerpoint].cPeriodicRowNumber   != 1) &amp;&amp;</a>
<a name="ln5369">                                 pVA[centerpoint_found].cNumValenceElectrons == 4 &amp;&amp;</a>
<a name="ln5370">                                 pVA[centerpoint_found].cPeriodicRowNumber   == 1) ||</a>
<a name="ln5371">                                 /* try a better non-carbon */</a>
<a name="ln5372">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5373">                                  pVA[centerpoint].cPeriodicRowNumber   != 1  ) &amp;&amp;</a>
<a name="ln5374">                                 (at[centerpoint].valence &gt;  at[centerpoint_found].valence ||</a>
<a name="ln5375">                                  (at[centerpoint].valence == at[centerpoint_found].valence &amp;&amp;</a>
<a name="ln5376">                                  at[centerpoint].el_number &gt; at[centerpoint_found].el_number))) ) {</a>
<a name="ln5377"> </a>
<a name="ln5378">                                pCentp_found = pCentp;</a>
<a name="ln5379">                                etg1_found   = etg1;</a>
<a name="ln5380">                                ecp1_found   = ecp1;</a>
<a name="ln5381">                                centerpoint_found = centerpoint;</a>
<a name="ln5382">                                break;</a>
<a name="ln5383">                            }                                </a>
<a name="ln5384">                        }</a>
<a name="ln5385">                    }</a>
<a name="ln5386">                }</a>
<a name="ln5387">            }</a>
<a name="ln5388">            if ( pCentp_found ) {</a>
<a name="ln5389">                /* ---- (1) */</a>
<a name="ln5390">                etg0-&gt;flow ++;</a>
<a name="ln5391">                pEndp0-&gt;st_edge.flow ++;</a>
<a name="ln5392">                /* ---- (2) */</a>
<a name="ln5393">                etg1_found-&gt;flow --;</a>
<a name="ln5394">                /* ---- (3) */</a>
<a name="ln5395">                ecp1_found-&gt;flow ++;</a>
<a name="ln5396">                /* ---- (4) */</a>
<a name="ln5397">                pCentp_found-&gt;st_edge.flow ++;</a>
<a name="ln5398">                pCentp_found-&gt;st_edge.cap  ++;</a>
<a name="ln5399"> </a>
<a name="ln5400">                pBNS-&gt;tot_st_flow += 2;</a>
<a name="ln5401">                pBNS-&gt;tot_st_cap  += 1;</a>
<a name="ln5402">                pCentp_found = NULL;</a>
<a name="ln5403">                num_fixes ++;</a>
<a name="ln5404">                tot_num_fixes ++;   /* #1 Mob-H */</a>
<a name="ln5405">                continue;</a>
<a name="ln5406">            }</a>
<a name="ln5407"> </a>
<a name="ln5408">            /* 2nd attempt: increment flow in centerpoint---radical_endpint edge */</a>
<a name="ln5409">            if ( i &lt; num_endpoints ) {</a>
<a name="ln5410">                /* tautomeric endpoint found; traverse its t-group edges */</a>
<a name="ln5411">                for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln5412">                    if ( i == j ) {</a>
<a name="ln5413">                        continue; /* avoid the found radical endpoint */</a>
<a name="ln5414">                    }</a>
<a name="ln5415">                    etg1 = pBNS-&gt;edge + ptg1-&gt;iedge[j];</a>
<a name="ln5416">                    endpoint1 = etg1-&gt;neighbor12 ^ vtg1;</a>
<a name="ln5417">                    pEndp1 = pBNS-&gt;vert + endpoint1;     /* another endpoint */</a>
<a name="ln5418">                    if ( pEndp1-&gt;st_edge.cap &gt; pEndp1-&gt;st_edge.flow ) {</a>
<a name="ln5419">                        continue; /* one more radical-endpoint! What is going on here??? */</a>
<a name="ln5420">                    }</a>
<a name="ln5421">                    if ( !etg1-&gt;flow ) {</a>
<a name="ln5422">                        continue; /* avoid enpoints that do not have an attachment */</a>
<a name="ln5423">                    }</a>
<a name="ln5424">                    if ( !(pEndp1-&gt;type &amp; BNS_VERT_TYPE_ENDPOINT) ) {</a>
<a name="ln5425">                        continue; /* should not happen */</a>
<a name="ln5426">                    }</a>
<a name="ln5427">                    /* traverse endpoint1 edges to find the edge connecting it to the centerpoint */</a>
<a name="ln5428">                    for ( k = 0; k &lt; at2[endpoint1].valence; k ++ ) {</a>
<a name="ln5429">                        ecp1 = pBNS-&gt;edge + pEndp1-&gt;iedge[k];</a>
<a name="ln5430">                        if ( ecp1-&gt;flow ) {</a>
<a name="ln5431">                            continue;</a>
<a name="ln5432">                        }</a>
<a name="ln5433">                        centerpoint = ecp1-&gt;neighbor12 ^ endpoint1;</a>
<a name="ln5434">                        pCentp = pBNS-&gt;vert + centerpoint;</a>
<a name="ln5435">                        if ( pCentp-&gt;type &amp; BNS_VERT_TYPE_ENDPOINT ) {</a>
<a name="ln5436">                            continue; /* do not set another endpoint's valence = an unusual value */</a>
<a name="ln5437">                        }</a>
<a name="ln5438"> </a>
<a name="ln5439">                        /* traverse centerpoint edges to find edge connecting it to the endpoint0 */</a>
<a name="ln5440">                        ecp2 = NULL;</a>
<a name="ln5441">                        pEndp2 = NULL;</a>
<a name="ln5442">                        for ( n = 0; n &lt; at2[centerpoint].valence; n ++ ) {</a>
<a name="ln5443">                            ecp0 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5444">                            if ( ecp0-&gt;flow ) {</a>
<a name="ln5445">                                endpoint2 = ecp0-&gt;neighbor12 ^ centerpoint;</a>
<a name="ln5446">                                if ( (pBNS-&gt;vert[endpoint2].type &amp; BNS_VERT_TYPE_ENDPOINT) ) {</a>
<a name="ln5447">                                    continue; /* ignore endpoint2 if it is tautomeric endpoint */</a>
<a name="ln5448">                                }</a>
<a name="ln5449">                                /* check whether ecp0 is stereogenic: if it is then we cannot decrement its flow */</a>
<a name="ln5450">                                for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[centerpoint].sb_parity[m]; m ++ ) {</a>
<a name="ln5451">                                    if ( at[centerpoint].sb_ord[m] == n ) {</a>
<a name="ln5452">                                        endpoint2 = NO_VERTEX;</a>
<a name="ln5453">                                        break;</a>
<a name="ln5454">                                    }</a>
<a name="ln5455">                                }</a>
<a name="ln5456">                                if ( endpoint2 == NO_VERTEX ) {</a>
<a name="ln5457">                                    continue;</a>
<a name="ln5458">                                }</a>
<a name="ln5459">                                pEndp2 = pBNS-&gt;vert + endpoint2;  /* found */</a>
<a name="ln5460">                                ecp2   = ecp0;</a>
<a name="ln5461">                                break;</a>
<a name="ln5462">                            }</a>
<a name="ln5463">                        }</a>
<a name="ln5464">                        for ( n = 0; n &lt; at[centerpoint].valence; n ++ ) {</a>
<a name="ln5465">                            ecp0 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5466">                            if ( ecp0-&gt;flow ) {</a>
<a name="ln5467">                                continue;</a>
<a name="ln5468">                            }</a>
<a name="ln5469">                            if ( endpoint0 != (ecp0-&gt;neighbor12 ^ centerpoint) ) {</a>
<a name="ln5470">                                continue;</a>
<a name="ln5471">                            }                    </a>
<a name="ln5472">                            /* Found:</a>
<a name="ln5473">                                              Endp2(not endpoint)           Endp2(not radical)</a>
<a name="ln5474">                                               ||                             |</a>
<a name="ln5475">                                               ||ecp2                         |ecp2</a>
<a name="ln5476">                                          ecp0 ||  ecp1                 ecp0  |  ecp1     </a>
<a name="ln5477">                                     Endp0----Centp----Endp1       Endp0====Centp----Endp1</a>
<a name="ln5478">                                      ^  \             /      --&gt;      \             /    </a>
<a name="ln5479">                              radical |   \           /                 \           /     </a>
<a name="ln5480">                                           \         /                   \         /      </a>
<a name="ln5481">                                       etg0 \       / etg1           etg0 \       / etg1  </a>
<a name="ln5482">                                             \     /                       \     /        </a>
<a name="ln5483">                                               tg1                           tg1          </a>
<a name="ln5484"> </a>
<a name="ln5485">                             */</a>
<a name="ln5486"> </a>
<a name="ln5487">                            /* compare centerpoints */</a>
<a name="ln5488">                            if ( !pCentp_found ||</a>
<a name="ln5489">                                 /* try to avoid carbons */</a>
<a name="ln5490">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5491">                                  pVA[centerpoint].cPeriodicRowNumber   != 1) &amp;&amp;</a>
<a name="ln5492">                                 pVA[centerpoint_found].cNumValenceElectrons == 4 &amp;&amp;</a>
<a name="ln5493">                                 pVA[centerpoint_found].cPeriodicRowNumber   == 1) ||</a>
<a name="ln5494">                                 /* try a better non-carbon */</a>
<a name="ln5495">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5496">                                  pVA[centerpoint].cPeriodicRowNumber   != 1  ) &amp;&amp;</a>
<a name="ln5497">                                 (at[centerpoint].valence &gt;  at[centerpoint_found].valence ||</a>
<a name="ln5498">                                  (at[centerpoint].valence == at[centerpoint_found].valence &amp;&amp;</a>
<a name="ln5499">                                  at[centerpoint].el_number &gt; at[centerpoint_found].el_number))) ) {</a>
<a name="ln5500"> </a>
<a name="ln5501">                                pCentp_found = pCentp;</a>
<a name="ln5502">                                etg1_found   = etg1;</a>
<a name="ln5503">                                ecp0_found   = ecp0;</a>
<a name="ln5504">                                centerpoint_found = centerpoint;</a>
<a name="ln5505">                                pEndp2_found = pEndp2;</a>
<a name="ln5506">                                ecp2_found   = ecp2;</a>
<a name="ln5507">                                break;</a>
<a name="ln5508">                            }                                </a>
<a name="ln5509">                        }</a>
<a name="ln5510">                    }</a>
<a name="ln5511">                }</a>
<a name="ln5512">            }</a>
<a name="ln5513">            if ( pCentp_found ) {</a>
<a name="ln5514">                ecp0_found-&gt;flow ++;</a>
<a name="ln5515">                if ( ecp0_found-&gt;cap &lt; ecp0_found-&gt;flow ) {</a>
<a name="ln5516">                    ecp0_found-&gt;cap = ecp0_found-&gt;flow;</a>
<a name="ln5517">                }</a>
<a name="ln5518">                pEndp0-&gt;st_edge.flow ++;</a>
<a name="ln5519">                if ( pEndp2_found &amp;&amp; ecp2_found ) {</a>
<a name="ln5520">                    ecp2_found-&gt;flow --;</a>
<a name="ln5521">                    pEndp2_found-&gt;st_edge.flow --;</a>
<a name="ln5522">                } else {</a>
<a name="ln5523">                    /* Endp2 not found */</a>
<a name="ln5524">                    pCentp_found-&gt;st_edge.flow ++;</a>
<a name="ln5525">                    pCentp_found-&gt;st_edge.cap  ++;</a>
<a name="ln5526">                    pBNS-&gt;tot_st_flow += 2; /* radical elimination */</a>
<a name="ln5527">                    pBNS-&gt;tot_st_cap  += 1;</a>
<a name="ln5528">                }</a>
<a name="ln5529"> </a>
<a name="ln5530">                pCentp_found = NULL;</a>
<a name="ln5531">                num_fixes ++;</a>
<a name="ln5532">                tot_num_fixes ++;      /* #2 Mob-H */</a>
<a name="ln5533">                continue;</a>
<a name="ln5534">            }</a>
<a name="ln5535">            /* 3rd attempt: find =C= and move radical to it */</a>
<a name="ln5536">            if ( i &lt; num_endpoints ) {</a>
<a name="ln5537">                int jj, delta, bNotFixed = 1;</a>
<a name="ln5538">                Vertex     vPathStart, vPathEnd, v1, v2;</a>
<a name="ln5539">                int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln5540">                for ( jj = 0; jj &lt; num_at &amp;&amp; bNotFixed; jj ++ ) {</a>
<a name="ln5541">                    if ( at2[i].endpoint ) {</a>
<a name="ln5542">                        continue;</a>
<a name="ln5543">                    }</a>
<a name="ln5544">                    if ( 2 == at2[jj].valence &amp;&amp; pBNS-&gt;vert[jj].st_edge.cap == pBNS-&gt;vert[jj].st_edge.flow &amp;&amp;</a>
<a name="ln5545">                         4 == pVA[jj].cNumValenceElectrons &amp;&amp;</a>
<a name="ln5546">                         !(ecp0 = pBNS-&gt;edge + pBNS-&gt;vert[jj].iedge[0])-&gt;forbidden &amp;&amp;</a>
<a name="ln5547">                         !(ecp1 = pBNS-&gt;edge + pBNS-&gt;vert[jj].iedge[1])-&gt;forbidden &amp;&amp;</a>
<a name="ln5548">                         1 == ecp0-&gt;flow &amp;&amp; 1 == ecp1-&gt;flow &amp;&amp;</a>
<a name="ln5549">                         !at2[(int)at2[i].neighbor[0]].sb_parity[0] &amp;&amp;</a>
<a name="ln5550">                         !at2[(int)at2[i].neighbor[1]].sb_parity[0]  ) {</a>
<a name="ln5551">                        /* found =C=; make a radical and try to cancel the two radicals */</a>
<a name="ln5552">                        k = ecp0-&gt;neighbor12 ^ jj;</a>
<a name="ln5553">                        if ( at2[k].endpoint ) {</a>
<a name="ln5554">                            ecp0 = ecp1;</a>
<a name="ln5555">                            k = ecp0-&gt;neighbor12 ^ jj;</a>
<a name="ln5556">                            if ( at2[k].endpoint ) {</a>
<a name="ln5557">                                continue;</a>
<a name="ln5558">                            }</a>
<a name="ln5559">                        }</a>
<a name="ln5560">                        delta = 1;</a>
<a name="ln5561">                        /* decrement C valence */</a>
<a name="ln5562">                        pBNS-&gt;vert[jj].st_edge.flow -= delta;</a>
<a name="ln5563">                        pBNS-&gt;vert[jj].st_edge.cap  -= delta;</a>
<a name="ln5564">                        /* decrement bond order */</a>
<a name="ln5565">                        ecp0-&gt;flow                 -= delta;</a>
<a name="ln5566">                        /* reflect the changes in at2[k] to make it a radical */</a>
<a name="ln5567">                        pBNS-&gt;vert[k].st_edge.flow -= delta;</a>
<a name="ln5568">                        pBNS-&gt;tot_st_cap           -= delta;</a>
<a name="ln5569">                        pBNS-&gt;tot_st_flow          -= 2*delta;</a>
<a name="ln5570"> </a>
<a name="ln5571">                        v1 = endpoint0;</a>
<a name="ln5572">                        v2 = k;</a>
<a name="ln5573"> </a>
<a name="ln5574">                        ret2 = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln5575">                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln5576"> </a>
<a name="ln5577">                        if ( ret2 == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln5578">                                           (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 0 ) {</a>
<a name="ln5579">                            ret2 = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5580">                            if ( ret2 &gt; 0 ) {</a>
<a name="ln5581">                                num_fixes ++;</a>
<a name="ln5582">                                tot_num_fixes ++;   /* #3 Mob-H */</a>
<a name="ln5583">                                pBNS-&gt;vert[jj].st_edge.cap += delta; /* create radical on =C- */</a>
<a name="ln5584">                                pBNS-&gt;tot_st_cap          += delta;</a>
<a name="ln5585">                                pCentp_found  = NULL;</a>
<a name="ln5586">                                bNotFixed     = 0; /* exit from the cycle */</a>
<a name="ln5587">                                break;</a>
<a name="ln5588">                            }</a>
<a name="ln5589">                        } else {</a>
<a name="ln5590">                            /* failed */</a>
<a name="ln5591">                            pBNS-&gt;vert[jj].st_edge.flow += delta;</a>
<a name="ln5592">                            pBNS-&gt;vert[jj].st_edge.cap  += delta;</a>
<a name="ln5593">                            /* decrement bond order */</a>
<a name="ln5594">                            ecp0-&gt;flow                 += delta;</a>
<a name="ln5595">                            /* reflect the changes in at2[k] to make it a radical */</a>
<a name="ln5596">                            pBNS-&gt;vert[k].st_edge.flow += delta;</a>
<a name="ln5597">                            pBNS-&gt;tot_st_cap           += delta;</a>
<a name="ln5598">                            pBNS-&gt;tot_st_flow          += 2*delta;</a>
<a name="ln5599">                        }</a>
<a name="ln5600">                        if ( ret2 &lt; 0 ) {</a>
<a name="ln5601">                            ret = ret2;</a>
<a name="ln5602">                            goto exit_function;</a>
<a name="ln5603">                        }</a>
<a name="ln5604">                    }</a>
<a name="ln5605">                }</a>
<a name="ln5606">            }</a>
<a name="ln5607">        }</a>
<a name="ln5608">        if ( !num_fixes ) {</a>
<a name="ln5609">            break;</a>
<a name="ln5610">        }</a>
<a name="ln5611">    }</a>
<a name="ln5612">    ret = tot_num_fixes;</a>
<a name="ln5613">exit_function:</a>
<a name="ln5614">    pStruct-&gt;at = at;</a>
<a name="ln5615">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln5616">    return ret;</a>
<a name="ln5617">}</a>
<a name="ln5618">/******************************************************************************************************/</a>
<a name="ln5619">/* Find and eliminate cases when Mobile H endpoint has radical on it (typical for wrong P(VI)(=O)3OH  */</a>
<a name="ln5620">int RemoveRadFromMobileHEndpointFixH(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln5621">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln5622">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln5623">{</a>
<a name="ln5624">#define IS_C(x) (NO_VERTEX != x &amp;&amp; pVA[x].cNumValenceElectrons == 4 &amp;&amp; pVA[x].cPeriodicRowNumber == 1)</a>
<a name="ln5625">    int i, num_fixes, tot_num_fixes = 0;</a>
<a name="ln5626">    </a>
<a name="ln5627">    int ret2, ret;</a>
<a name="ln5628">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln5629">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln5630">    int len_at = num_at + num_deleted_H;</a>
<a name="ln5631">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln5632">    EDGE_LIST ChargeEdgeList, BondEdgeList;</a>
<a name="ln5633">    int         itg, j, k, n, m, num_endp;</a>
<a name="ln5634">    Vertex      endpoint0=NO_VERTEX, endpoint1, endpoint2=NO_VERTEX, centerpoint;</a>
<a name="ln5635">    Vertex      centerpoint_found=NO_VERTEX, endpoint2_found=NO_VERTEX;</a>
<a name="ln5636">    BNS_VERTEX *pEndp0=NULL, *pEndp1, *pEndp2, *pCentp, *pCentp_found, *pEndp2_found=NULL;</a>
<a name="ln5637">    BNS_EDGE   *ecp0, *ecp1, *ecp2, *ecp0_found=NULL, *ecp1_found=NULL, *ecp2_found=NULL;</a>
<a name="ln5638">    int          tgroup_number, num_endpoints;</a>
<a name="ln5639">    </a>
<a name="ln5640">    ret = 0;</a>
<a name="ln5641"> </a>
<a name="ln5642">    if ( pStruct-&gt;iMobileH != TAUT_NON )</a>
<a name="ln5643">        return ret;</a>
<a name="ln5644"> </a>
<a name="ln5645">    AllocEdgeList( &amp;ChargeEdgeList, EDGE_LIST_CLEAR);</a>
<a name="ln5646">    AllocEdgeList( &amp;BondEdgeList, EDGE_LIST_CLEAR);</a>
<a name="ln5647"> </a>
<a name="ln5648">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln5649">    pStruct-&gt;at = at2;</a>
<a name="ln5650">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln5651">    if ( ret2 &lt; 0 ) {</a>
<a name="ln5652">        ret = ret2;</a>
<a name="ln5653">        goto exit_function;</a>
<a name="ln5654">    }</a>
<a name="ln5655">    while ( pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow &amp;&amp; pStruct-&gt;ti.num_t_groups ) {</a>
<a name="ln5656">        int iEndpoint = 0;</a>
<a name="ln5657">        num_fixes = 0;</a>
<a name="ln5658">        for ( itg = 0; itg &lt; pStruct-&gt;ti.num_t_groups; iEndpoint += num_endpoints, itg ++ ) {</a>
<a name="ln5659">            pCentp_found=NULL;</a>
<a name="ln5660">            tgroup_number = pStruct-&gt;ti.t_group[itg].nGroupNumber;</a>
<a name="ln5661">            num_endpoints = pStruct-&gt;ti.t_group[itg].nNumEndpoints;</a>
<a name="ln5662">            for ( i = 0; i &lt; num_endpoints; i ++ ) {</a>
<a name="ln5663">                endpoint0 = pStruct-&gt;ti.nEndpointAtomNumber[iEndpoint+i];</a>
<a name="ln5664">                pEndp0 = pBNS-&gt;vert + endpoint0;  /* taut endpoint vertex (possible location of mobile H */</a>
<a name="ln5665">                if ( pEndp0-&gt;st_edge.cap &gt; pEndp0-&gt;st_edge.flow ) {</a>
<a name="ln5666">                    /* radical endpoint1 has been detected */</a>
<a name="ln5667">                    /* find a 1-3 centerpoint that has two or more endpoints */</a>
<a name="ln5668">                    /* connected to the t-group vertex by edges with flow&gt;0 and */</a>
<a name="ln5669">                    /* to the centerpoint by edges with flow = 0 */</a>
<a name="ln5670">                    /* after that: (1) increment etg1 flow to eliminate radical */</a>
<a name="ln5671">                    /* (2) increment flow on one of the two other edges to the t-group */</a>
<a name="ln5672">                    /* (3) increment st_cap on the found centerpoint */</a>
<a name="ln5673">                    /* (4) rerun the BNS and re-create the structure */</a>
<a name="ln5674">                    break;</a>
<a name="ln5675">                }</a>
<a name="ln5676">            }</a>
<a name="ln5677"> </a>
<a name="ln5678">            /* 2nd attempt: increment flow in centerpoint---radical_endpoint edge */</a>
<a name="ln5679">            pCentp_found = NULL;</a>
<a name="ln5680">            if ( i &lt; num_endpoints ) {</a>
<a name="ln5681">                /* tautomeric endpoint found; traverse its t-group edges */</a>
<a name="ln5682">                for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln5683">                    if ( i == j ) {</a>
<a name="ln5684">                        continue; /* avoid the found radical endpoint */</a>
<a name="ln5685">                    }</a>
<a name="ln5686">                    endpoint1 = pStruct-&gt;ti.nEndpointAtomNumber[iEndpoint+j];</a>
<a name="ln5687">                    pEndp1 = pBNS-&gt;vert + endpoint1;     /* another endpoint */</a>
<a name="ln5688"> </a>
<a name="ln5689">                    if ( pEndp1-&gt;st_edge.cap &gt; pEndp1-&gt;st_edge.flow ) {</a>
<a name="ln5690">                        continue; /* one more radical-endpoint! What is going on here??? */</a>
<a name="ln5691">                    }</a>
<a name="ln5692">                    if ( !at2[endpoint1].num_H &amp;&amp; at2[endpoint1].charge != -1 ) {</a>
<a name="ln5693">                        continue; /* avoid enpoints that do not have an attachment */</a>
<a name="ln5694">                    }</a>
<a name="ln5695">                    if ( !pStruct-&gt;endpoint[endpoint1] ) {</a>
<a name="ln5696">                        continue; /* should not happen */</a>
<a name="ln5697">                    }</a>
<a name="ln5698">                    /* traverse endpoint1 edges to find the edge connecting it to the centerpoint */</a>
<a name="ln5699">                    for ( k = 0; k &lt; pEndp1-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln5700">                        ecp1 = pBNS-&gt;edge + pEndp1-&gt;iedge[k];</a>
<a name="ln5701">                        if ( ecp1-&gt;flow ) {</a>
<a name="ln5702">                            continue;</a>
<a name="ln5703">                        }</a>
<a name="ln5704">                        centerpoint = ecp1-&gt;neighbor12 ^ endpoint1;</a>
<a name="ln5705">                        if ( centerpoint &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln5706">                            break; /* no more edges to atoms */</a>
<a name="ln5707">                        }</a>
<a name="ln5708">                        pCentp = pBNS-&gt;vert + centerpoint;</a>
<a name="ln5709">                        if ( pStruct-&gt;endpoint[centerpoint] ) {</a>
<a name="ln5710">                            continue; /* do not set another endpoint's valence = an unusual value */</a>
<a name="ln5711">                        }</a>
<a name="ln5712">                        /* traverse centerpoint edges to find edge connecting it to the endpoint0 */</a>
<a name="ln5713">                        /* 1. Find a double bond to an endpoint */</a>
<a name="ln5714">                        ecp2 = NULL;</a>
<a name="ln5715">                        pEndp2 = NULL;</a>
<a name="ln5716">                        for ( n = 0, num_endp = 0; n &lt; at2[centerpoint].valence; n ++ ) {</a>
<a name="ln5717">                            ecp0 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5718">                            if ( ecp0-&gt;flow ) {</a>
<a name="ln5719">                                endpoint2 = ecp0-&gt;neighbor12 ^ centerpoint;</a>
<a name="ln5720">                                if ( pStruct-&gt;endpoint[endpoint2] /* ??? */ ) {</a>
<a name="ln5721">                                    continue;</a>
<a name="ln5722">                                }</a>
<a name="ln5723">                                /* check whether ecp0 is stereogenic: if it is then we cannot decrement its flow */</a>
<a name="ln5724">                                for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[centerpoint].sb_parity[m]; m ++ ) {</a>
<a name="ln5725">                                    if ( at[centerpoint].sb_ord[m] == n ) {</a>
<a name="ln5726">                                        endpoint2 = NO_VERTEX;</a>
<a name="ln5727">                                        break;</a>
<a name="ln5728">                                    }</a>
<a name="ln5729">                                }</a>
<a name="ln5730">                                if ( endpoint2 == NO_VERTEX ) {</a>
<a name="ln5731">                                    continue;</a>
<a name="ln5732">                                }</a>
<a name="ln5733">                                pEndp2 = pBNS-&gt;vert + endpoint2;</a>
<a name="ln5734">                                ecp2   = ecp0;</a>
<a name="ln5735">                                break;</a>
<a name="ln5736">                            }</a>
<a name="ln5737">                        }</a>
<a name="ln5738">                        if ( !ecp2 ) {</a>
<a name="ln5739">                            continue;</a>
<a name="ln5740">                        }</a>
<a name="ln5741">                        /* 2. Find a single bond to an endpoint0 */</a>
<a name="ln5742">                        for ( n = 0, num_endp = 0; n &lt; at2[centerpoint].valence; n ++ ) {</a>
<a name="ln5743">                            ecp0 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5744">                            if ( ecp0-&gt;flow ) {</a>
<a name="ln5745">                                continue;</a>
<a name="ln5746">                            }</a>
<a name="ln5747">                            if ( endpoint0 != (ecp0-&gt;neighbor12 ^ centerpoint) ) {</a>
<a name="ln5748">                                continue;</a>
<a name="ln5749">                            }                    </a>
<a name="ln5750">                            /* Found:</a>
<a name="ln5751">                                              Endp2                         Endp2(not radical)</a>
<a name="ln5752">                                               ||                             |</a>
<a name="ln5753">                                               ||ecp2                         |ecp2</a>
<a name="ln5754">                                          ecp0 ||  ecp1                 ecp0  |  ecp1     </a>
<a name="ln5755">                                     Endp0----Centp----Endp1       Endp0====Centp----Endp1</a>
<a name="ln5756">                                      ^  \             /      --&gt;      \             /    </a>
<a name="ln5757">                              radical |   \           /                 \           /     </a>
<a name="ln5758">                                           \         /                   \         /      </a>
<a name="ln5759">                                       etg0 \       / etg1           etg0 \       / etg1  </a>
<a name="ln5760">                                             \     /                       \     /        </a>
<a name="ln5761">                                               tg1                           tg1          </a>
<a name="ln5762"> </a>
<a name="ln5763">                             */</a>
<a name="ln5764"> </a>
<a name="ln5765">                            /* compare centerpoints */</a>
<a name="ln5766">                            if ( !pCentp_found ||</a>
<a name="ln5767">                                 /* try to avoid carbons */</a>
<a name="ln5768">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5769">                                  pVA[centerpoint].cPeriodicRowNumber   != 1) &amp;&amp;</a>
<a name="ln5770">                                 pVA[centerpoint_found].cNumValenceElectrons == 4 &amp;&amp;</a>
<a name="ln5771">                                 pVA[centerpoint_found].cPeriodicRowNumber   == 1) ||</a>
<a name="ln5772">                                 /* try a better non-carbon */</a>
<a name="ln5773">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5774">                                  pVA[centerpoint].cPeriodicRowNumber   != 1  ) &amp;&amp;</a>
<a name="ln5775">                                 (at[centerpoint].valence &gt;  at[centerpoint_found].valence ||</a>
<a name="ln5776">                                  (at[centerpoint].valence == at[centerpoint_found].valence &amp;&amp;</a>
<a name="ln5777">                                  at[centerpoint].el_number &gt; at[centerpoint_found].el_number))) ) {</a>
<a name="ln5778"> </a>
<a name="ln5779">                                pCentp_found = pCentp;</a>
<a name="ln5780">                                ecp0_found   = ecp0;</a>
<a name="ln5781">                                centerpoint_found = centerpoint;</a>
<a name="ln5782">                                pEndp2_found = pEndp2;</a>
<a name="ln5783">                                ecp2_found   = ecp2;</a>
<a name="ln5784">                                break;</a>
<a name="ln5785">                            }                                </a>
<a name="ln5786">                        }</a>
<a name="ln5787">                    }</a>
<a name="ln5788">                }</a>
<a name="ln5789">            }</a>
<a name="ln5790">            /* decrement st_flow, st_cap on Endp2; decrement flow on ecp2; decrement st_flow on Centp */</a>
<a name="ln5791">            /* result: radicals on Endp0 and Centp =&gt; run BNS */</a>
<a name="ln5792">            if ( pCentp_found ) {</a>
<a name="ln5793">                /* make ecp0 a double bond, make ecp2 a single bond, remove radical */</a>
<a name="ln5794">                ecp0_found-&gt;flow ++;</a>
<a name="ln5795">                if ( ecp0_found-&gt;cap &lt; ecp0_found-&gt;flow ) {</a>
<a name="ln5796">                    ecp0_found-&gt;cap = ecp0_found-&gt;flow;</a>
<a name="ln5797">                }</a>
<a name="ln5798">                pEndp0-&gt;st_edge.flow ++;</a>
<a name="ln5799">                if ( pEndp2_found &amp;&amp; ecp2_found ) {</a>
<a name="ln5800">                    ecp2_found-&gt;flow --;</a>
<a name="ln5801">                    pEndp2_found-&gt;st_edge.flow --;</a>
<a name="ln5802">                } else {</a>
<a name="ln5803">                    /* Endp2 not found: only make ecp0 a double bond */</a>
<a name="ln5804">                    pCentp_found-&gt;st_edge.flow ++;</a>
<a name="ln5805">                    pCentp_found-&gt;st_edge.cap  ++;</a>
<a name="ln5806">                    pBNS-&gt;tot_st_flow += 2; /* radical elimination */</a>
<a name="ln5807">                    pBNS-&gt;tot_st_cap  += 1;</a>
<a name="ln5808">                }</a>
<a name="ln5809"> </a>
<a name="ln5810">                pCentp_found = NULL;</a>
<a name="ln5811">                num_fixes ++;    /* #2 */</a>
<a name="ln5812">                tot_num_fixes ++;</a>
<a name="ln5813">                continue;</a>
<a name="ln5814">            }</a>
<a name="ln5815">            /* 1st attempt */</a>
<a name="ln5816">            pCentp_found = NULL;</a>
<a name="ln5817">            if ( i &lt; num_endpoints ) {</a>
<a name="ln5818">                /* tautomeric endpoint found; traverse its t-group edges */</a>
<a name="ln5819">                for ( j = 0; j &lt; num_endpoints; j ++ ) {</a>
<a name="ln5820">                    if ( i == j ) {</a>
<a name="ln5821">                        continue; /* avoid the found radical endpoint */</a>
<a name="ln5822">                    }</a>
<a name="ln5823">                    endpoint1 = pStruct-&gt;ti.nEndpointAtomNumber[iEndpoint+j];</a>
<a name="ln5824">                    pEndp1 = pBNS-&gt;vert + endpoint1;     /* another endpoint */</a>
<a name="ln5825">                    if ( pEndp1-&gt;st_edge.cap &gt; pEndp1-&gt;st_edge.flow ) {</a>
<a name="ln5826">                        continue; /* one more radical-endpoint! What is going on here??? */</a>
<a name="ln5827">                    }</a>
<a name="ln5828">                    if ( !at2[endpoint1].num_H &amp;&amp; at2[endpoint1].charge != -1 ) {</a>
<a name="ln5829">                        continue; /* avoid enpoints that do not have an attachment */</a>
<a name="ln5830">                    }</a>
<a name="ln5831">                    if ( !pStruct-&gt;endpoint[endpoint1] ) {</a>
<a name="ln5832">                        continue; /* should not happen */</a>
<a name="ln5833">                    }</a>
<a name="ln5834">                    /* traverse endpoint1 edges to find the edge connecting it to the centerpoint */</a>
<a name="ln5835">                    for ( k = 0; k &lt; pEndp1-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln5836">                        ecp1 = pBNS-&gt;edge + pEndp1-&gt;iedge[k];</a>
<a name="ln5837">                        if ( ecp1-&gt;flow ) {</a>
<a name="ln5838">                            continue;</a>
<a name="ln5839">                        }</a>
<a name="ln5840">                        centerpoint = ecp1-&gt;neighbor12 ^ endpoint1;</a>
<a name="ln5841">                        if ( centerpoint &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln5842">                            break;</a>
<a name="ln5843">                        }</a>
<a name="ln5844">                        pCentp = pBNS-&gt;vert + centerpoint;</a>
<a name="ln5845">                        /* traverse centerpoint edges to find the 2nd endpoint */</a>
<a name="ln5846">                        for ( n = 0, num_endp = 0; n &lt; pCentp-&gt;num_adj_edges; n ++ ) {</a>
<a name="ln5847">                            ecp2 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5848">                            if ( ecp2-&gt;flow ) {</a>
<a name="ln5849">                                continue;</a>
<a name="ln5850">                            }</a>
<a name="ln5851">                            endpoint2 = ecp2-&gt;neighbor12 ^ centerpoint;</a>
<a name="ln5852">                            if ( endpoint2 &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln5853">                                break;</a>
<a name="ln5854">                            }</a>
<a name="ln5855">                            if ( !pStruct-&gt;endpoint[endpoint2] ) {</a>
<a name="ln5856">                                continue; </a>
<a name="ln5857">                            }</a>
<a name="ln5858">                            pEndp2 = pBNS-&gt;vert + endpoint2;</a>
<a name="ln5859">                            </a>
<a name="ln5860">                            if ( at2[endpoint2].num_H || at2[endpoint1].charge == -1 ) {</a>
<a name="ln5861">                                continue;</a>
<a name="ln5862">                            }</a>
<a name="ln5863"> </a>
<a name="ln5864">                            /* we have found the path:</a>
<a name="ln5865">                            </a>
<a name="ln5866">                            Endp1 has no attachments, Endp2 has.</a>
<a name="ln5867"> </a>
<a name="ln5868">                                              Endp1                                Endp1        </a>
<a name="ln5869">                                       etg1 //     \ ecp1                   etg1 /     \\ ecp1  </a>
<a name="ln5870">                                  etg0     //       \                  etg0     /       \\      </a>
<a name="ln5871">                             Endp0-----tg1           Centp  --&gt;   Endp0=====tg1           Centp </a>
<a name="ln5872">                              ^            \\       /                           \\       /      </a>
<a name="ln5873">                      radical |        etg2 \\     / ecp2                   etg2 \\     / ecp2  </a>
<a name="ln5874">                                              Endp2                                Endp2        </a>
<a name="ln5875">                            */                                                                  </a>
<a name="ln5876"> </a>
<a name="ln5877">                            /* compare centerpoints */</a>
<a name="ln5878">                            if ( !pCentp_found ||</a>
<a name="ln5879">                                 /* try to avoid carbons */</a>
<a name="ln5880">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5881">                                  pVA[centerpoint].cPeriodicRowNumber   != 1) &amp;&amp;</a>
<a name="ln5882">                                 pVA[centerpoint_found].cNumValenceElectrons == 4 &amp;&amp;</a>
<a name="ln5883">                                 pVA[centerpoint_found].cPeriodicRowNumber   == 1) ||</a>
<a name="ln5884">                                 /* try a better non-carbon */</a>
<a name="ln5885">                                 ((pVA[centerpoint].cNumValenceElectrons != 4 ||</a>
<a name="ln5886">                                  pVA[centerpoint].cPeriodicRowNumber   != 1  ) &amp;&amp;</a>
<a name="ln5887">                                 (at[centerpoint].valence &gt;  at[centerpoint_found].valence ||</a>
<a name="ln5888">                                  (at[centerpoint].valence == at[centerpoint_found].valence &amp;&amp;</a>
<a name="ln5889">                                  at[centerpoint].el_number &gt; at[centerpoint_found].el_number))) ) {</a>
<a name="ln5890"> </a>
<a name="ln5891">                                pCentp_found = pCentp;</a>
<a name="ln5892">                                ecp1_found   = ecp1;</a>
<a name="ln5893">                                centerpoint_found = centerpoint;</a>
<a name="ln5894">                                break;</a>
<a name="ln5895">                            }                                </a>
<a name="ln5896">                        }</a>
<a name="ln5897">                    }</a>
<a name="ln5898">                }</a>
<a name="ln5899">            }</a>
<a name="ln5900">            if ( pCentp_found ) {</a>
<a name="ln5901">                /* create a new radical at the centerpoint and try to cancel them */</a>
<a name="ln5902">                int delta = 1, ret3;</a>
<a name="ln5903">                Vertex     vPathStart, vPathEnd, v1, v2;</a>
<a name="ln5904">                int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln5905">                </a>
<a name="ln5906">                pCentp_found-&gt;st_edge.cap += delta;</a>
<a name="ln5907">                pBNS-&gt;tot_st_cap          += delta;</a>
<a name="ln5908"> </a>
<a name="ln5909">                v1 = pCentp_found - pBNS-&gt;vert;</a>
<a name="ln5910">                v2 = pEndp0 - pBNS-&gt;vert;</a>
<a name="ln5911">                ret3 = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln5912">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln5913"> </a>
<a name="ln5914">                if ( ret3 == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln5915">                                   (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge % 2 == 0 ) {</a>
<a name="ln5916">                    ret3 = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5917">                    if ( ret3 &gt; 0 ) {</a>
<a name="ln5918">                        num_fixes ++;</a>
<a name="ln5919">                        tot_num_fixes ++;   /* #1 */</a>
<a name="ln5920">                        pCentp_found = NULL;</a>
<a name="ln5921">                        continue;</a>
<a name="ln5922">                    }</a>
<a name="ln5923">                } else {</a>
<a name="ln5924">                    pCentp_found-&gt;st_edge.cap -= delta;</a>
<a name="ln5925">                    pBNS-&gt;tot_st_cap          -= delta;</a>
<a name="ln5926">                }</a>
<a name="ln5927">                if ( ret3 &lt; 0 ) {</a>
<a name="ln5928">                    ret = ret3;</a>
<a name="ln5929">                    goto exit_function;</a>
<a name="ln5930">                }</a>
<a name="ln5931">            }</a>
<a name="ln5932">            /*----------------------------------------------------------------------------------------</a>
<a name="ln5933">               3rd attempt:                                                         add radical to keep</a>
<a name="ln5934">              ==============           u,f=&gt;unfixed, fixed edges                    (N electrons)%2</a>
<a name="ln5935">                        (-)                       (-)                      (-)          |     </a>
<a name="ln5936">                     e0/  \\ e1          =&gt;     u/  \\u            =&gt;     //  \         v     </a>
<a name="ln5937">                      /    \\ ecp1 ecp2         /    \\   u    f         //    \             </a>
<a name="ln5938">                  C--X*     Y(-)--C==Z      C--X*     Y(-)--C*--Z      --X(-)   Y===C---Z*   </a>
<a name="ln5939">                    rad.    endp     not      rad.   endp  rad not      rad.   endp    not </a>
<a name="ln5940">                   Endp0   Endp1     endp     endp         to  endp     endp           endp</a>
<a name="ln5941">                                    Endp2                cancel                              </a>
<a name="ln5942">             </a>
<a name="ln5943">               Note: endpoints X and Y may belong to different t-groups</a>
<a name="ln5944">             ----------------------------------------------------------------------------------------*/</a>
<a name="ln5945">            pCentp_found = NULL;</a>
<a name="ln5946">            if ( i &lt; num_endpoints ) {</a>
<a name="ln5947">                int  e0, e1;</a>
<a name="ln5948">                if ( (e0=pVA[endpoint0].nCMinusGroupEdge-1)&lt;0 || pBNS-&gt;edge[e0].forbidden ) {</a>
<a name="ln5949">                    continue; /* no negative charge on Endp0 is possible */</a>
<a name="ln5950">                }</a>
<a name="ln5951">                /* a radical-tautomeric endpoint found; traverse all endpoints */</a>
<a name="ln5952">                for ( j = 0; j &lt; pStruct-&gt;ti.nNumEndpoints; j ++ ) {</a>
<a name="ln5953">                    if ( iEndpoint+i == j ) {</a>
<a name="ln5954">                        continue; /* avoid the found radical endpoint */</a>
<a name="ln5955">                    }</a>
<a name="ln5956"> </a>
<a name="ln5957">                    endpoint1 = pStruct-&gt;ti.nEndpointAtomNumber[j];</a>
<a name="ln5958">                    pEndp1 = pBNS-&gt;vert + endpoint1;     /* another endpoint */</a>
<a name="ln5959"> </a>
<a name="ln5960">                    if ( pEndp1-&gt;st_edge.cap &gt; pEndp1-&gt;st_edge.flow ) {</a>
<a name="ln5961">                        continue; /* one more radical-endpoint! What is going on here??? */</a>
<a name="ln5962">                    }</a>
<a name="ln5963">                    if ( ((e1=pVA[endpoint1].nCMinusGroupEdge-1)&lt;0 || !pBNS-&gt;edge[e1].flow) || pBNS-&gt;edge[e1].forbidden ) {</a>
<a name="ln5964">                        continue; /* no negative charge on Endp1 */</a>
<a name="ln5965">                    }</a>
<a name="ln5966">                    if ( !pStruct-&gt;endpoint[endpoint1] ) {</a>
<a name="ln5967">                        continue; /* should not happen */</a>
<a name="ln5968">                    }</a>
<a name="ln5969">                    /* traverse endpoint1 edges to find the edge connecting it to the centerpoint */</a>
<a name="ln5970">                    for ( k = 0; k &lt; pEndp1-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln5971">                        ecp1 = pBNS-&gt;edge + pEndp1-&gt;iedge[k];   /* e1C */</a>
<a name="ln5972">                        if ( ecp1-&gt;flow || ecp1-&gt;forbidden ) {</a>
<a name="ln5973">                            continue;</a>
<a name="ln5974">                        }</a>
<a name="ln5975">                        centerpoint = ecp1-&gt;neighbor12 ^ endpoint1;</a>
<a name="ln5976">                        if ( centerpoint &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln5977">                            break; /* no more edges to atoms */</a>
<a name="ln5978">                        }</a>
<a name="ln5979">                        pCentp = pBNS-&gt;vert + centerpoint;</a>
<a name="ln5980">                        if ( pStruct-&gt;endpoint[centerpoint] ) {</a>
<a name="ln5981">                            continue; /* do not set another endpoint's valence = an unusual value */</a>
<a name="ln5982">                        }</a>
<a name="ln5983">                        /* traverse centerpoint edges to find edge connecting it to the endpoint0 */</a>
<a name="ln5984">                        /* 1. Find a double bond to a not endpoint */</a>
<a name="ln5985">                        ecp2 = NULL;</a>
<a name="ln5986">                        pEndp2 = NULL;</a>
<a name="ln5987">                        for ( n = 0, num_endp = 0; n &lt; pCentp-&gt;num_adj_edges; n ++ ) {</a>
<a name="ln5988">                            ecp0 = pBNS-&gt;edge + pCentp-&gt;iedge[n];</a>
<a name="ln5989">                            if ( ecp0-&gt;flow &amp;&amp; !ecp0-&gt;forbidden ) {</a>
<a name="ln5990">                                endpoint2 = ecp0-&gt;neighbor12 ^ centerpoint;</a>
<a name="ln5991">                                if ( endpoint2 &gt;= pBNS-&gt;num_atoms || pStruct-&gt;endpoint[endpoint2] ) {</a>
<a name="ln5992">                                    continue;</a>
<a name="ln5993">                                }</a>
<a name="ln5994">                                /* check whether ecp0 is stereogenic: if it is then we cannot decrement its flow */</a>
<a name="ln5995">                                for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[centerpoint].sb_parity[m]; m ++ ) {</a>
<a name="ln5996">                                    if ( at[centerpoint].sb_ord[m] == n ) {</a>
<a name="ln5997">                                        endpoint2 = NO_VERTEX;</a>
<a name="ln5998">                                        break;</a>
<a name="ln5999">                                    }</a>
<a name="ln6000">                                }</a>
<a name="ln6001">                                if ( endpoint2 == NO_VERTEX ) {</a>
<a name="ln6002">                                    continue;</a>
<a name="ln6003">                                }</a>
<a name="ln6004">                                pEndp2 = pBNS-&gt;vert + endpoint2;</a>
<a name="ln6005">                                ecp2   = ecp0;           /* e2C */</a>
<a name="ln6006">                                break;</a>
<a name="ln6007">                            }</a>
<a name="ln6008">                        }</a>
<a name="ln6009">                        if ( !ecp2 )</a>
<a name="ln6010">                            continue;</a>
<a name="ln6011">                        /* compare centerpoints */</a>
<a name="ln6012">                        if ( !pCentp_found ||</a>
<a name="ln6013">                             /* try to find carbons */</a>
<a name="ln6014">                             (!IS_C(endpoint2_found) &amp;&amp; IS_C(endpoint2)) ||</a>
<a name="ln6015">                             (IS_C(endpoint2_found) &amp;&amp; IS_C(endpoint2) &amp;&amp;</a>
<a name="ln6016">                             !IS_C(centerpoint_found) &amp;&amp; IS_C(centerpoint)) ) {</a>
<a name="ln6017"> </a>
<a name="ln6018">                            pCentp_found = pCentp;</a>
<a name="ln6019">                            centerpoint_found = centerpoint;</a>
<a name="ln6020">                            endpoint2_found   = endpoint2;</a>
<a name="ln6021">                            ecp2_found   = ecp2;</a>
<a name="ln6022">                            ecp1_found   = ecp1;</a>
<a name="ln6023">                            ecp0_found   = pBNS-&gt;edge + e0;</a>
<a name="ln6024">                            break;</a>
<a name="ln6025">                        }</a>
<a name="ln6026">                    }</a>
<a name="ln6027">                }</a>
<a name="ln6028">            }</a>
<a name="ln6029">            /* decrement st_flow, st_cap on Endp2; decrement flow on ecp2; decrement st_flow on Centp */</a>
<a name="ln6030">            /* result: radicals on Endp0 and Centp =&gt; run BNS */</a>
<a name="ln6031">            if ( pCentp_found ) {</a>
<a name="ln6032">                Vertex     vPathStart, vPathEnd, v1, v2;</a>
<a name="ln6033">                int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln6034">                int        delta;</a>
<a name="ln6035"> </a>
<a name="ln6036">                Vertex    vEndp0 = ecp0_found-&gt;neighbor1;</a>
<a name="ln6037">                Vertex    vEndp1 = ecp1_found-&gt;neighbor12 ^ centerpoint_found;</a>
<a name="ln6038">                Vertex    vEndp2 = ecp2_found-&gt;neighbor12 ^ centerpoint_found;</a>
<a name="ln6039">                BNS_EDGE *pe0 = ecp0_found;</a>
<a name="ln6040">                BNS_EDGE *pe1 = pBNS-&gt;edge + (pVA[vEndp1].nCMinusGroupEdge - 1);</a>
<a name="ln6041">                pEndp1 = pBNS-&gt;vert + vEndp1;</a>
<a name="ln6042">                pEndp2 = pBNS-&gt;vert + vEndp2;</a>
<a name="ln6043">                pCentp = pCentp_found;</a>
<a name="ln6044">                if ( !ChargeEdgeList.num_alloc ) {</a>
<a name="ln6045">                    for ( n = 0; n &lt; pStruct-&gt;num_atoms; n ++ ) {</a>
<a name="ln6046">                        if ( (k = pVA[n].nCMinusGroupEdge)&gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden &amp;&amp;</a>
<a name="ln6047">                             (ret = AddToEdgeList( &amp;ChargeEdgeList, k, pStruct-&gt;num_atoms ) ) ) {</a>
<a name="ln6048">                            goto exit_function;</a>
<a name="ln6049">                        }</a>
<a name="ln6050">                        if ( (k = pVA[n].nCPlusGroupEdge)&gt;= 0 &amp;&amp; !pBNS-&gt;edge[k].forbidden &amp;&amp;</a>
<a name="ln6051">                             (ret = AddToEdgeList( &amp;ChargeEdgeList, k, pStruct-&gt;num_atoms ) ) ) {</a>
<a name="ln6052">                            goto exit_function;</a>
<a name="ln6053">                        }</a>
<a name="ln6054">                    }</a>
<a name="ln6055">                }</a>
<a name="ln6056">                if ( !BondEdgeList.num_alloc ) {</a>
<a name="ln6057">                    for ( n = 0; n &lt; pBNS-&gt;num_bonds; n ++ ) {</a>
<a name="ln6058">                        if ( (ret = AddToEdgeList( &amp;BondEdgeList, n, pBNS-&gt;num_bonds ) ) ) {</a>
<a name="ln6059">                            goto exit_function;</a>
<a name="ln6060">                        }</a>
<a name="ln6061">                    }</a>
<a name="ln6062">                }</a>
<a name="ln6063">                /* fix all bonds and charges */</a>
<a name="ln6064">                SetForbiddenEdgeMask( pBNS, &amp;ChargeEdgeList, forbidden_edge_mask );</a>
<a name="ln6065">                SetForbiddenEdgeMask( pBNS, &amp;BondEdgeList, forbidden_edge_mask );</a>
<a name="ln6066">                /* prepare flow for testing */</a>
<a name="ln6067">                delta = 1;</a>
<a name="ln6068">                ecp2_found-&gt;flow     -= delta;</a>
<a name="ln6069">                pCentp-&gt;st_edge.flow -= delta;</a>
<a name="ln6070">                pEndp2-&gt;st_edge.flow -= delta;</a>
<a name="ln6071">                pBNS-&gt;tot_st_flow    -= 2*delta;</a>
<a name="ln6072">                /* unfix edges to be changed */</a>
<a name="ln6073">                pe0-&gt;forbidden        &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6074">                pe1-&gt;forbidden        &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6075">                ecp1_found-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6076"> </a>
<a name="ln6077">                pBNS-&gt;tot_st_cap    += delta;</a>
<a name="ln6078"> </a>
<a name="ln6079">                v1 = vEndp0;</a>
<a name="ln6080">                v2 = centerpoint_found;</a>
<a name="ln6081">                ret2 = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln6082">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln6083"> </a>
<a name="ln6084">                if ( ret2 == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln6085">                                   (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 0 ) {</a>
<a name="ln6086">                    ret2 = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln6087">                    if ( ret2 &gt; 0 ) {</a>
<a name="ln6088">                        num_fixes ++;</a>
<a name="ln6089">                        tot_num_fixes ++; /* #3 */</a>
<a name="ln6090">                        pCentp_found = NULL;</a>
<a name="ln6091">                    }</a>
<a name="ln6092">                } else {</a>
<a name="ln6093">                    /* roll back */</a>
<a name="ln6094">                    ecp2_found-&gt;flow     += delta;</a>
<a name="ln6095">                    pCentp-&gt;st_edge.flow += delta;</a>
<a name="ln6096">                    pEndp2-&gt;st_edge.flow += delta;</a>
<a name="ln6097">                    pBNS-&gt;tot_st_flow    += 2*delta;</a>
<a name="ln6098">                }</a>
<a name="ln6099">                RemoveForbiddenEdgeMask( pBNS, &amp;ChargeEdgeList, forbidden_edge_mask );</a>
<a name="ln6100">                RemoveForbiddenEdgeMask( pBNS, &amp;BondEdgeList, forbidden_edge_mask );</a>
<a name="ln6101">                if ( ret2 &lt; 0 ) {</a>
<a name="ln6102">                    ret = ret2;</a>
<a name="ln6103">                    goto exit_function;</a>
<a name="ln6104">                }</a>
<a name="ln6105">                if ( !pCentp_found )</a>
<a name="ln6106">                    continue;</a>
<a name="ln6107">            }</a>
<a name="ln6108"> </a>
<a name="ln6109">        }</a>
<a name="ln6110">        if ( !num_fixes ) {</a>
<a name="ln6111">            break;</a>
<a name="ln6112">        }</a>
<a name="ln6113">    }</a>
<a name="ln6114"> </a>
<a name="ln6115">/************ again ***********************************************************/</a>
<a name="ln6116">    while ( pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow &amp;&amp; pStruct-&gt;ti.num_t_groups ) {</a>
<a name="ln6117">        int iEndpoint = 0;</a>
<a name="ln6118">        num_fixes = 0;</a>
<a name="ln6119">        for ( itg = 0; itg &lt; pStruct-&gt;ti.num_t_groups; iEndpoint += num_endpoints, itg ++ ) {</a>
<a name="ln6120">            pCentp_found=NULL;</a>
<a name="ln6121">            tgroup_number = pStruct-&gt;ti.t_group[itg].nGroupNumber;</a>
<a name="ln6122">            num_endpoints = pStruct-&gt;ti.t_group[itg].nNumEndpoints;</a>
<a name="ln6123">            for ( i = 0; i &lt; num_endpoints; i ++ ) {</a>
<a name="ln6124">                endpoint0 = pStruct-&gt;ti.nEndpointAtomNumber[iEndpoint+i];</a>
<a name="ln6125">                pEndp0 = pBNS-&gt;vert + endpoint0;  /* taut endpoint vertex (possible location of mobile H */</a>
<a name="ln6126">                if ( pEndp0-&gt;st_edge.cap &gt; pEndp0-&gt;st_edge.flow ) {</a>
<a name="ln6127">                    /* radical endpoint1 has been detected */</a>
<a name="ln6128">                    /* find a 1-3 centerpoint that has two or more endpoints */</a>
<a name="ln6129">                    /* connected to the t-group vertex by edges with flow&gt;0 and */</a>
<a name="ln6130">                    /* to the centerpoint by edges with flow = 0 */</a>
<a name="ln6131">                    /* after that: (1) increment etg1 flow to eliminate radical */</a>
<a name="ln6132">                    /* (2) increment flow on one of the two other edges to the t-group */</a>
<a name="ln6133">                    /* (3) increment st_cap on the found centerpoint */</a>
<a name="ln6134">                    /* (4) rerun the BNS and re-create the structure */</a>
<a name="ln6135">                    break;</a>
<a name="ln6136">                }</a>
<a name="ln6137">            }</a>
<a name="ln6138">            /* 4th attempt */</a>
<a name="ln6139">            if ( i &lt; num_endpoints ) {</a>
<a name="ln6140">                /* tautomeric endpoint found; traverse its t-group edges */</a>
<a name="ln6141">                pEndp2_found = NULL;</a>
<a name="ln6142">                for ( j = 0; j &lt; pEndp0-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln6143">                    ecp0 = pBNS-&gt;edge + pEndp0-&gt;iedge[j];</a>
<a name="ln6144">                    centerpoint = ecp0-&gt;neighbor12 ^ endpoint0;</a>
<a name="ln6145">                    if ( centerpoint &gt;= pBNS-&gt;num_atoms || ecp0-&gt;flow || pStruct-&gt;endpoint[centerpoint] ) {</a>
<a name="ln6146">                        continue; /* ignore non-single bonds, orig. InChI endpoints, and fictitious atoms */</a>
<a name="ln6147">                    }</a>
<a name="ln6148">                    pCentp = pBNS-&gt;vert + centerpoint;</a>
<a name="ln6149">                    for ( k = 0; k &lt; pCentp-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln6150">                        ecp1 = pBNS-&gt;edge + pCentp-&gt;iedge[k];</a>
<a name="ln6151">                        endpoint1 = ecp1-&gt;neighbor12 ^ centerpoint;</a>
<a name="ln6152">                        if ( endpoint1 &gt;= pBNS-&gt;num_atoms || !ecp1-&gt;flow || pStruct-&gt;endpoint[endpoint1] ) {</a>
<a name="ln6153">                            continue; /* ignore single bonds, orig. InChI endpoints, and fictitious atoms */</a>
<a name="ln6154">                        }</a>
<a name="ln6155">                        pEndp1 = pBNS-&gt;vert + endpoint1;</a>
<a name="ln6156">                        if ( endpoint1 == endpoint0 || pEndp1-&gt;st_edge.cap != pEndp1-&gt;st_edge.flow ) {</a>
<a name="ln6157">                            continue; /* ignore radicals */</a>
<a name="ln6158">                        }</a>
<a name="ln6159">                        if ( !pEndp2_found ||</a>
<a name="ln6160">                             /* try to find carbons */</a>
<a name="ln6161">                             (!IS_C(endpoint2_found) &amp;&amp; IS_C(endpoint1)) ||</a>
<a name="ln6162">                             (IS_C(endpoint2_found) &amp;&amp; IS_C(endpoint1) &amp;&amp;</a>
<a name="ln6163">                             !IS_C(centerpoint_found) &amp;&amp; IS_C(centerpoint)) ) {</a>
<a name="ln6164">                            pEndp2_found      = pEndp1;</a>
<a name="ln6165">                            pCentp_found      = pCentp;</a>
<a name="ln6166">                            endpoint2_found   = endpoint1;</a>
<a name="ln6167">                            centerpoint_found = centerpoint;</a>
<a name="ln6168">                            ecp1_found        = ecp0;</a>
<a name="ln6169">                            ecp2_found        = ecp1;</a>
<a name="ln6170">                        }</a>
<a name="ln6171">                    }</a>
<a name="ln6172">                }</a>
<a name="ln6173">                if ( pEndp2_found ) {</a>
<a name="ln6174">                    /* move radical from pEndp0 to pEndp2 */</a>
<a name="ln6175">                    pEndp0-&gt;st_edge.flow ++;</a>
<a name="ln6176">                    ecp1_found-&gt;flow ++;</a>
<a name="ln6177">                    ecp2_found-&gt;flow --;</a>
<a name="ln6178">                    pEndp2_found-&gt;st_edge.flow --;</a>
<a name="ln6179">                    pEndp2_found = NULL;</a>
<a name="ln6180">                    pCentp_found = NULL;</a>
<a name="ln6181">                    num_fixes ++;    /* #4 */</a>
<a name="ln6182">                    tot_num_fixes ++;</a>
<a name="ln6183">                    continue;</a>
<a name="ln6184">                }</a>
<a name="ln6185">            }</a>
<a name="ln6186">        }</a>
<a name="ln6187">        if ( !num_fixes ) {</a>
<a name="ln6188">            break;</a>
<a name="ln6189">        }</a>
<a name="ln6190">    }</a>
<a name="ln6191"> </a>
<a name="ln6192"> </a>
<a name="ln6193">    ret = tot_num_fixes;</a>
<a name="ln6194">exit_function:</a>
<a name="ln6195">    AllocEdgeList( &amp;ChargeEdgeList, EDGE_LIST_FREE);</a>
<a name="ln6196">    AllocEdgeList( &amp;BondEdgeList, EDGE_LIST_FREE);</a>
<a name="ln6197"> </a>
<a name="ln6198">    pStruct-&gt;at = at;</a>
<a name="ln6199">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln6200">    return ret;</a>
<a name="ln6201">#undef IS_C</a>
<a name="ln6202">}</a>
<a name="ln6203">/************************************************************************************************/</a>
<a name="ln6204">/* move (+) charges to &gt;N- and other centerpoints                                               */</a>
<a name="ln6205">int MoveChargeToMakeCenerpoints(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln6206">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln6207">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln6208">{</a>
<a name="ln6209">    int i, j, neigh, num_endpoints, tg_group=0, num_success;</a>
<a name="ln6210">    int ret2, ret, delta;</a>
<a name="ln6211">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln6212">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln6213">    int len_at = num_at + num_deleted_H;</a>
<a name="ln6214">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln6215"> </a>
<a name="ln6216">    /* for RunBnsTestOnce */</a>
<a name="ln6217">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln6218">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln6219"> </a>
<a name="ln6220">    BNS_EDGE   *pEdgePlus, *pEdgeMinus;</a>
<a name="ln6221">    Vertex      v1p, v2p, v1m, v2m;</a>
<a name="ln6222">    BNS_VERTEX *pv1p, *pv2p, *pv1m, *pv2m;</a>
<a name="ln6223"> </a>
<a name="ln6224">    ret = 0;</a>
<a name="ln6225">    num_success = 0;</a>
<a name="ln6226">    /* to simplify, prepare new at[] from pBNS */</a>
<a name="ln6227">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln6228">    pStruct-&gt;at = at2;</a>
<a name="ln6229">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln6230">    pStruct-&gt;at = at;</a>
<a name="ln6231">    if ( ret2 &lt; 0 ) {</a>
<a name="ln6232">        ret = ret2;</a>
<a name="ln6233">        goto exit_function;</a>
<a name="ln6234">    }</a>
<a name="ln6235"> </a>
<a name="ln6236">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln6237">        if ( pVA[i].cNumValenceElectrons != 4 &amp;&amp; /* not C, Si, Ge */</a>
<a name="ln6238">             !pVA[i].cMetal &amp;&amp; !pVA[i].nTautGroupEdge &amp;&amp;</a>
<a name="ln6239">             !at2[i].num_H &amp;&amp; at2[i].valence &gt;= 3 &amp;&amp;</a>
<a name="ln6240">             at2[i].valence == at2[i].chem_bonds_valence &amp;&amp;</a>
<a name="ln6241">             !at2[i].charge &amp;&amp; pVA[i].nCPlusGroupEdge &gt; 0 &amp;&amp;</a>
<a name="ln6242">             is_centerpoint_elem( at2[i].el_number ) ) {</a>
<a name="ln6243">            for ( j = 0, num_endpoints = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln6244">                neigh = at2[i].neighbor[j];</a>
<a name="ln6245">                if ( at2[neigh].endpoint ) {</a>
<a name="ln6246">                    if ( !num_endpoints ) {</a>
<a name="ln6247">                        tg_group = at2[neigh].endpoint;</a>
<a name="ln6248">                    } else</a>
<a name="ln6249">                    if ( tg_group != at2[neigh].endpoint ) {</a>
<a name="ln6250">                        break; /* not a centerpoint */</a>
<a name="ln6251">                    }</a>
<a name="ln6252">                    num_endpoints ++;</a>
<a name="ln6253">                }</a>
<a name="ln6254">            }</a>
<a name="ln6255">            if ( j == at2[i].valence &amp;&amp; num_endpoints &gt; 1 ) {</a>
<a name="ln6256">                /* found possible centerpoint */</a>
<a name="ln6257">                pEdgePlus  = pBNS-&gt;edge + (pVA[i].nCPlusGroupEdge-1);</a>
<a name="ln6258">                pEdgeMinus = (pVA[i].nCMinusGroupEdge &gt; 0)? pBNS-&gt;edge + (pVA[i].nCMinusGroupEdge-1) : NULL;</a>
<a name="ln6259">                if ( pEdgePlus-&gt;flow + (pEdgeMinus? pEdgeMinus-&gt;flow : 0) != 1 ) {</a>
<a name="ln6260">                    continue;</a>
<a name="ln6261">                }</a>
<a name="ln6262">                v1p = pEdgePlus-&gt;neighbor1;</a>
<a name="ln6263">                v2p = pEdgePlus-&gt;neighbor12 ^ v1p;</a>
<a name="ln6264">                pv1p = pBNS-&gt;vert + v1p;</a>
<a name="ln6265">                pv2p = pBNS-&gt;vert + v2p;</a>
<a name="ln6266">                if ( pEdgeMinus ) {</a>
<a name="ln6267">                    v1m  = pEdgeMinus-&gt;neighbor1;</a>
<a name="ln6268">                    v2m  = pEdgeMinus-&gt;neighbor12 ^ v1m;</a>
<a name="ln6269">                    pv1m = pBNS-&gt;vert + v1m;</a>
<a name="ln6270">                    pv2m = pBNS-&gt;vert + v2m;</a>
<a name="ln6271">                } else {</a>
<a name="ln6272">                    v1m = NO_VERTEX;</a>
<a name="ln6273">                    v2m = NO_VERTEX;</a>
<a name="ln6274">                    pv1m = NULL;</a>
<a name="ln6275">                    pv2m = NULL;</a>
<a name="ln6276">                }</a>
<a name="ln6277">                ret = 0;</a>
<a name="ln6278">                /* set new flow to run BNS Search */</a>
<a name="ln6279">                if ( (delta = pEdgePlus-&gt;flow) ) {</a>
<a name="ln6280">                    /* positive charge &lt;=&gt; flow=0 on (=) edge */</a>
<a name="ln6281">                    pEdgePlus-&gt;flow -= delta;</a>
<a name="ln6282">                    pv1p-&gt;st_edge.flow -= delta;</a>
<a name="ln6283">                    pv2p-&gt;st_edge.flow -= delta;</a>
<a name="ln6284">                    pBNS-&gt;tot_st_flow  -= 2*delta;</a>
<a name="ln6285">                    pEdgePlus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln6286">                    if ( pEdgeMinus ) {</a>
<a name="ln6287">                        pEdgeMinus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln6288">                    }</a>
<a name="ln6289">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln6290">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln6291">                    if ( ret &lt; 0 ) {</a>
<a name="ln6292">                        goto exit_function;</a>
<a name="ln6293">                    }</a>
<a name="ln6294">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1p &amp;&amp; vPathStart == v2p) ||</a>
<a name="ln6295">                                      (vPathEnd == v2p &amp;&amp; vPathStart == v1p)) &amp;&amp;</a>
<a name="ln6296">                                      nDeltaCharge == -1 /* charge moving to this atom disappers*/ ) {</a>
<a name="ln6297">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln6298">                        (*pnNumRunBNS) ++;</a>
<a name="ln6299">                        if ( ret &lt; 0 ) {</a>
<a name="ln6300">                            goto exit_function;</a>
<a name="ln6301">                        } else</a>
<a name="ln6302">                        if ( ret == 1 ) {</a>
<a name="ln6303">                            *pnTotalDelta += ret;</a>
<a name="ln6304">                        } else {</a>
<a name="ln6305">                            ret = RI_ERR_PROGR;</a>
<a name="ln6306">                            goto exit_function;</a>
<a name="ln6307">                        }</a>
<a name="ln6308">                    } else {</a>
<a name="ln6309">                        ret = 0;</a>
<a name="ln6310">                        pEdgePlus-&gt;flow    += delta;</a>
<a name="ln6311">                        pv1p-&gt;st_edge.flow += delta;</a>
<a name="ln6312">                        pv2p-&gt;st_edge.flow += delta;</a>
<a name="ln6313">                        pBNS-&gt;tot_st_flow  += 2*delta;</a>
<a name="ln6314">                    }</a>
<a name="ln6315">                    pEdgePlus-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6316">                    if ( pEdgeMinus ) {</a>
<a name="ln6317">                        pEdgeMinus-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6318">                    }</a>
<a name="ln6319">                } else</a>
<a name="ln6320">                if ( pEdgeMinus &amp;&amp; (delta == pEdgeMinus-&gt;flow) &amp;&amp; pEdgePlus-&gt;flow == 0 ) {</a>
<a name="ln6321">                    /* positive charge &lt;=&gt; flow=0 on (=) edge and flow=0 on (-) edge */</a>
<a name="ln6322">                    pEdgeMinus-&gt;flow -= delta;</a>
<a name="ln6323">                    pv1m-&gt;st_edge.flow -= delta;</a>
<a name="ln6324">                    pv2m-&gt;st_edge.flow -= delta;</a>
<a name="ln6325">                    pBNS-&gt;tot_st_flow  -= 2*delta;</a>
<a name="ln6326">                    pEdgePlus-&gt;forbidden  |= forbidden_edge_mask;</a>
<a name="ln6327">                    pEdgeMinus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln6328">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln6329">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln6330">                    if ( ret &lt; 0 ) {</a>
<a name="ln6331">                        goto exit_function;</a>
<a name="ln6332">                    }</a>
<a name="ln6333">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1m &amp;&amp; vPathStart == v2m) ||</a>
<a name="ln6334">                                      (vPathEnd == v2m &amp;&amp; vPathStart == v1m)) &amp;&amp;</a>
<a name="ln6335">                                      nDeltaCharge == -1  /* charge moving to this atom disappers*/ ) {</a>
<a name="ln6336">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln6337">                        (*pnNumRunBNS) ++;</a>
<a name="ln6338">                        if ( ret &lt; 0 ) {</a>
<a name="ln6339">                            goto exit_function;</a>
<a name="ln6340">                        } else</a>
<a name="ln6341">                        if ( ret == 1 ) {</a>
<a name="ln6342">                            *pnTotalDelta += ret;</a>
<a name="ln6343">                        } else {</a>
<a name="ln6344">                            ret = RI_ERR_PROGR;</a>
<a name="ln6345">                            goto exit_function;</a>
<a name="ln6346">                        }</a>
<a name="ln6347">                    } else {</a>
<a name="ln6348">                        ret = 0;</a>
<a name="ln6349">                        pEdgeMinus-&gt;flow   += delta;</a>
<a name="ln6350">                        pv1m-&gt;st_edge.flow += delta;</a>
<a name="ln6351">                        pv2m-&gt;st_edge.flow += delta;</a>
<a name="ln6352">                        pBNS-&gt;tot_st_flow  += 2*delta;</a>
<a name="ln6353">                    }</a>
<a name="ln6354">                    pEdgePlus-&gt;forbidden  &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6355">                    pEdgeMinus-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln6356">                }</a>
<a name="ln6357">                if ( ret ) {</a>
<a name="ln6358">                    num_success ++;</a>
<a name="ln6359">                    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln6360">                    pStruct-&gt;at = at2;</a>
<a name="ln6361">                    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln6362">                    pStruct-&gt;at = at;</a>
<a name="ln6363">                    if ( ret2 &lt; 0 ) {</a>
<a name="ln6364">                        ret = ret2;</a>
<a name="ln6365">                        goto exit_function;</a>
<a name="ln6366">                    }</a>
<a name="ln6367">                }</a>
<a name="ln6368">            }</a>
<a name="ln6369">        }</a>
<a name="ln6370">    }</a>
<a name="ln6371">    ret = num_success;</a>
<a name="ln6372">exit_function:</a>
<a name="ln6373">    return ret;</a>
<a name="ln6374">}</a>
<a name="ln6375">#endif</a>

</code></pre>
<div class="balloon" rel="197"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="202"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="212"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="385"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="394"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ret < 0' is always false.</p></div>
<div class="balloon" rel="450"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="466"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'num_stereo_centers2 + num_stereo_bonds2' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="505"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="514"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="541"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ret < 0' is always false.</p></div>
<div class="balloon" rel="477"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pStereo2' pointer was utilized before it was verified against nullptr. Check lines: 477, 500.</p></div>
<div class="balloon" rel="572"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="579"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="645"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="650"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="724"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="1312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B == C' kind. The expression is calculated as following: 'A = (B == C)'.</p></div>
<div class="balloon" rel="1314"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B == C' kind. The expression is calculated as following: 'A = (B == C)'.</p></div>
<div class="balloon" rel="3194"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!bFixedCarbonCharges' is always true.</p></div>
<div class="balloon" rel="3298"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pStruct->at' variable was assigned the same value.</p></div>
<div class="balloon" rel="3815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions 'pBNS->edge[eNPlusEdge].flow == 0' to the left and to the right of the '&&' operator.</p></div>
<div class="balloon" rel="3884"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4043"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4189"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4305"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4497"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4556"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'nDeltaChargeMax' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 4555, 4556.</p></div>
<div class="balloon" rel="4938"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="6320"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pEdgePlus->flow == 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

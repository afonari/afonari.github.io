
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichiread.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">/* #define CHECK_WIN32_VC_HEAP */</a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;ichicomp.h&quot;</a>
<a name="ln51">#include &quot;ichi.h&quot;</a>
<a name="ln52">#include &quot;ichitime.h&quot;</a>
<a name="ln53">#include &quot;util.h&quot;</a>
<a name="ln54">#include &quot;strutil.h&quot;</a>
<a name="ln55">#include &quot;ichi_io.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">/* reverse InChI */</a>
<a name="ln58">#include &quot;ichimain.h&quot;</a>
<a name="ln59">#include &quot;extr_ct.h&quot;</a>
<a name="ln60">#include &quot;ichitaut.h&quot;</a>
<a name="ln61">#include &quot;ichister.h&quot;</a>
<a name="ln62">#include &quot;strutil.h&quot;</a>
<a name="ln63">#include &quot;ichisize.h&quot;</a>
<a name="ln64">#include &quot;ichiring.h&quot;</a>
<a name="ln65">#include &quot;ichinorm.h&quot;</a>
<a name="ln66">#include &quot;ichierr.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;ichirvrs.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">/*^^^ */</a>
<a name="ln72">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln73">#include &quot;inchi_api.h&quot;</a>
<a name="ln74">#endif</a>
<a name="ln75">/*^^^ */</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">typedef struct tagLine </a>
<a name="ln80">{</a>
<a name="ln81">    char *str;</a>
<a name="ln82">    int   len;</a>
<a name="ln83">    int   len_alloc;</a>
<a name="ln84">    int   c;</a>
<a name="ln85">} SEGM_LINE;</a>
<a name="ln86">#define SEGM_LINE_ADD 128</a>
<a name="ln87"> </a>
<a name="ln88">typedef struct tagOneLinkedBond </a>
<a name="ln89">{</a>
<a name="ln90">    AT_NUMB neigh; /* canonical number of a neighbor */</a>
<a name="ln91">    AT_NUMB prev;  /* position of the previous neighbor in the list */</a>
<a name="ln92">} ONE_LINKED_BOND;</a>
<a name="ln93"> </a>
<a name="ln94">typedef struct tagLinkedBonds </a>
<a name="ln95">{</a>
<a name="ln96">    ONE_LINKED_BOND *pBond;</a>
<a name="ln97">    int len;</a>
<a name="ln98">    int len_alloc;</a>
<a name="ln99">}LINKED_BONDS;</a>
<a name="ln100">#define LINKED_BOND_ADD  128</a>
<a name="ln101"> </a>
<a name="ln102">typedef enum tagModeProtonIsoExchgH </a>
<a name="ln103">{</a>
<a name="ln104">    MODE_PIXH_UNDEFINED,     /* 0 */</a>
<a name="ln105">    MODE_PIXH_ADD_TO_FIRST,  /* 1 */</a>
<a name="ln106">    MODE_PIXH_ADD_TO_EACH,   /* 2 */</a>
<a name="ln107">    MODE_PIXH_ADD_A_PIXH_COMPONENT, /* 3 */</a>
<a name="ln108">    MODE_PIXH_KEEP_TOTALS         /* 4 */</a>
<a name="ln109">} MODE_PIXH;</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">/* local prototypes */</a>
<a name="ln113">static int GetInChIFormulaNumH(INChI *pInChI, int *nNumH);</a>
<a name="ln114">static int GetInChINumH(INChI *pInChI, int *nNumH);</a>
<a name="ln115">static int GetInChIIsoH(INChI *pInChI, int nNumIsotopicH[NUM_H_ISOTOPES]);</a>
<a name="ln116"> </a>
<a name="ln117">static int getInChIChar(INCHI_IOSTREAM *pInp);</a>
<a name="ln118">static int AddInChIChar(INCHI_IOSTREAM *pInp, SEGM_LINE *Line, const char *pszToken);</a>
<a name="ln119">static int AddLinkedBond(AT_NUMB at1, AT_NUMB at2, AT_NUMB num_at, LINKED_BONDS *pLB);</a>
<a name="ln120">static int bInChIHasReconnectedMetal(INChI *pInChI);</a>
<a name="ln121">static int SetProtonsAndXchgIsoH(int bInChI2Structure, </a>
<a name="ln122">                                 int bReqSplitOutputInChI, </a>
<a name="ln123">                                 int bReqProtonsForEachComponent,</a>
<a name="ln124">                                 int bReqNonTaut, int bReqStereo, </a>
<a name="ln125">                                 int num_components[INCHI_NUM],</a>
<a name="ln126">                                 MODE_PIXH nModeProtonIsoExchgH[INCHI_NUM], </a>
<a name="ln127">                                 InpInChI *OneInput);</a>
<a name="ln128">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln129">static int SetHillFormFromInChI(InpInChI *OneInput);</a>
<a name="ln130">#endif</a>
<a name="ln131"> </a>
<a name="ln132">static int nGetInChISegment(INCHI_IOSTREAM *pInp, SEGM_LINE *Line, const char *pszToken);</a>
<a name="ln133"> </a>
<a name="ln134">static int CopySegment(INChI *pInChITo, INChI *pInChIFrom, int StereoType, </a>
<a name="ln135">                       int bIsotopicTo, int bIsotopicFrom);</a>
<a name="ln136">static int nFillOutProtonMobileH(INChI *pInChI);</a>
<a name="ln137">static int nProtonCopyIsotopicInfo(INChI *pInChI_to, INChI *pInChI_from);</a>
<a name="ln138">static int CopyAtomNumbers(INChI *pInChI_To, int bIsoTo, INChI *pInChI_From, int bIsoFrom);</a>
<a name="ln139"> </a>
<a name="ln140">static int ParseSegmentFormula(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln141">                               int nNumComponents[]);</a>
<a name="ln142">static int ParseSegmentConnections(const char *str, int bMobileH, INChI **pInpInChI, </a>
<a name="ln143">                                   int *pnNumComponents, int *pbAbc);</a>
<a name="ln144">static int ParseSegmentMobileH(const char *str, int bMobileH, </a>
<a name="ln145">                               INChI *pInpInChI[], int pnNumComponents[], int *pbAbc);</a>
<a name="ln146">static int ParseSegmentCharge(const char *str, int bMobileH, </a>
<a name="ln147">                              INChI *pInpInChI[], int nNumComponents[]);</a>
<a name="ln148">static int ParseSegmentProtons(const char *str, int bMobileH, </a>
<a name="ln149">                               REM_PROTONS nNumProtons[], int nNumComponents[]);</a>
<a name="ln150">static int ParseSegmentSp2(const char *str, int bMobileH, </a>
<a name="ln151">                           INChI *pInpInChI[], int nNumComponents[], int state, int *pbAbc);</a>
<a name="ln152">static int ParseSegmentSp3(const char *str, int bMobileH, </a>
<a name="ln153">                           INChI *pInpInChI[], int nNumComponents[], int state, int *pbAbc);</a>
<a name="ln154">static int ParseSegmentSp3m(const char *str, int bMobileH, </a>
<a name="ln155">                            INChI *pInpInChI[], int nNumComponents[], int state);</a>
<a name="ln156">static int bIsSp3LayerNotEmpty(INChI *pInpInChI[], int bMobileH, </a>
<a name="ln157">                               int bIso, int nNumComponents);</a>
<a name="ln158">static int ParseSegmentSp3s(const char *str, int bMobileH, </a>
<a name="ln159">                            INChI *pInpInChI[], int s[TAUT_NUM][2], int ppnNumComponents[], int state);</a>
<a name="ln160">static int ParseSegmentIsoAtoms(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln161">                                int nNumComponents[], int state, int *pbAbc);</a>
<a name="ln162">static int ParseSegmentIsoExchgH(const char *str, int bMobileH, REM_PROTONS nNumProtons[], </a>
<a name="ln163">                                 int nNumComponents[], int state, int *pbAbc);</a>
<a name="ln164">static int ParseSegmentPerm(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln165">                            int ppnNumComponents[], int state, int *pbAbc);</a>
<a name="ln166">#if ( FIX_ISO_FIXEDH_BUG_READ == 1 )</a>
<a name="ln167">static int bIsoMayBeArranged(int bInchi2Struct, int iso_diff[NUM_H_ISOTOPES], </a>
<a name="ln168">                             REM_PROTONS nNumProtons[INCHI_NUM][TAUT_NUM],</a>
<a name="ln169">                             INChI *pInpInChI[INCHI_NUM][TAUT_NUM], int nNumComponents[INCHI_NUM][TAUT_NUM], int iINChI);</a>
<a name="ln170">#endif</a>
<a name="ln171"> </a>
<a name="ln172">static int ReadInChILine(INCHI_IOSTREAM *pInp, SEGM_LINE *pLine, </a>
<a name="ln173">                         char **pStr, int *pState,</a>
<a name="ln174">                         INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln175">                         int nNumComponents[INCHI_NUM][TAUT_NUM],</a>
<a name="ln176">                         REM_PROTONS nNumProtons[INCHI_NUM][TAUT_NUM],</a>
<a name="ln177">                         int s[INCHI_NUM][TAUT_NUM][2],</a>
<a name="ln178">                         int *bStdFormat, </a>
<a name="ln179">                         int *bInputHasSaveOpt, unsigned char *inp_save_opt_bits);</a>
<a name="ln180"> </a>
<a name="ln181">int InChILine2Data(INCHI_IOSTREAM *pInp, SEGM_LINE *pLine, </a>
<a name="ln182">                   char **pStr, int *pState, int *nErr,</a>
<a name="ln183">                   INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln184">                   int nNumComponents[INCHI_NUM][TAUT_NUM],</a>
<a name="ln185">                   REM_PROTONS nNumProtons[INCHI_NUM][TAUT_NUM],</a>
<a name="ln186">                   int s[INCHI_NUM][TAUT_NUM][2], </a>
<a name="ln187">                   int bReadCoord, int bInchi2Struct, </a>
<a name="ln188">                   INCHI_MODE nMode,</a>
<a name="ln189">                   int *bStdFormat, </a>
<a name="ln190">                   int *bInputHasSaveOpt, unsigned char *inp_save_opt_bits);</a>
<a name="ln191"> </a>
<a name="ln192">static int ReadInChICoord(INCHI_IOSTREAM *pInp, SEGM_LINE *pLine, int *pState,</a>
<a name="ln193">                          INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln194">                          int nNumComponents[INCHI_NUM][TAUT_NUM]);</a>
<a name="ln195"> </a>
<a name="ln196">static int OutputInChIAsRequested(INCHI_IOSTREAM *pOut, INCHI_IOSTREAM *pLog, </a>
<a name="ln197">                                  ICHICONST INPUT_PARMS *ip_inp, </a>
<a name="ln198">                                  STRUCT_DATA *sd_inp, </a>
<a name="ln199">                                  InpInChI *OneInput, </a>
<a name="ln200">                                  int num_components[INCHI_NUM],</a>
<a name="ln201">                                  MODE_PIXH nModeProtonIsoExchgH[INCHI_NUM], </a>
<a name="ln202">                                  long num_inp, unsigned char save_opt_bits);</a>
<a name="ln203"> </a>
<a name="ln204">static int ParseAuxSegmentVersion(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln205">                                  int ppnNumComponents[], int state);</a>
<a name="ln206">static int ParseAuxSegmentNumbers(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln207">                                  int ppnNumComponents[], int state, int *pbAbc);</a>
<a name="ln208">static int ParseAuxSegmentAtomEqu(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln209">                                  int ppnNumComponents[], int state);</a>
<a name="ln210">static int ParseAuxSegmentGroupEqu(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln211">                                   int ppnNumComponents[], int state);</a>
<a name="ln212">static int ParseAuxSegmentSp3Inv(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln213">                                 int ppnNumComponents[], int state);</a>
<a name="ln214">static int ParseAuxSegmentSp3InvNumbers(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln215">                                        int ppnNumComponents[], int state);</a>
<a name="ln216">static int ParseAuxSegmentReverseCRV(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln217">                                     int ppnNumComponents[], int state);</a>
<a name="ln218">static int ParseAuxSegmentReverseAtoms(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln219">                                       int ppnNumComponents[], int state);</a>
<a name="ln220">static int ParseAuxSegmentReverseBonds(const char *str, int bMobileH, INChI *pInpInChI[], </a>
<a name="ln221">                                       int ppnNumComponents[], int state);</a>
<a name="ln222">static int ParseAuxSegmentReverseXYZ(const char *str, int bMobileH, XYZ_COORD **ppXYZ, </a>
<a name="ln223">                                     INChI *pInpInChI[], int ppnNumComponents[], int state);</a>
<a name="ln224">static int AddAuxSegmentCoord(int nRet, XYZ_COORD *pXYZ, int nLenXYZ, </a>
<a name="ln225">                              INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln226">                              int nNumComponents[INCHI_NUM][TAUT_NUM]);</a>
<a name="ln227"> </a>
<a name="ln228">static const char *getInchiStateReadErr(int stat);</a>
<a name="ln229">static const char *getInchiErrName(int nErr);</a>
<a name="ln230"> </a>
<a name="ln231">#define SEG_END '/'</a>
<a name="ln232">/* the following 2 definitions are used to allow tab-delimited InChI input - 2008-11-17 DT */</a>
<a name="ln233">#define INCHI_INP_EOL(X) ((X)=='\n' || (X)=='\r' || (X)=='\t')</a>
<a name="ln234">/*#define INCHI_TOKEN &quot;/\n\r\t&quot;*/</a>
<a name="ln235">#define INCHI_TOKEN &quot;/\n\r\t\\&quot;</a>
<a name="ln236"> </a>
<a name="ln237">typedef enum tagInChI_STATE </a>
<a name="ln238">{</a>
<a name="ln239">    /* M */</a>
<a name="ln240">    IST_MOBILE_H_FORMULA,          /* 0 */</a>
<a name="ln241">    IST_MOBILE_H_CONNECTIONS,      /* 1 */</a>
<a name="ln242">    IST_MOBILE_H,                  /* 2 */</a>
<a name="ln243">    IST_MOBILE_H_CHARGE,           /* 3 */</a>
<a name="ln244">    IST_MOBILE_H_PROTONS,          /* 4 */</a>
<a name="ln245">    IST_MOBILE_H_SP2,              /* 5 */</a>
<a name="ln246">    IST_MOBILE_H_SP3,              /* 6 */</a>
<a name="ln247">    IST_MOBILE_H_SP3_M,            /* 7 */</a>
<a name="ln248">    IST_MOBILE_H_SP3_S,            /* 8 */</a>
<a name="ln249"> </a>
<a name="ln250">    /* Fork */</a>
<a name="ln251">    IST_MOBILE_H_ISO_LAYER_FORK,   /* 9 */</a>
<a name="ln252"> </a>
<a name="ln253">    /* MI */</a>
<a name="ln254">    IST_MOBILE_H_ISO_ATOMS,        /* 10 */</a>
<a name="ln255">    IST_MOBILE_H_ISO_EXCH_H,       /* 11 */</a>
<a name="ln256">    IST_MOBILE_H_ISO_SP2,          /* 12 */</a>
<a name="ln257">    IST_MOBILE_H_ISO_SP3,          /* 13 */</a>
<a name="ln258">    IST_MOBILE_H_ISO_SP3_M,        /* 14 */</a>
<a name="ln259">    IST_MOBILE_H_ISO_SP3_S,        /* 15 */</a>
<a name="ln260"> </a>
<a name="ln261">    /* Fork */</a>
<a name="ln262">    IST_FIXED_H_LAYER_FORK,        /* 16 */</a>
<a name="ln263">    </a>
<a name="ln264">    /* F */</a>
<a name="ln265">    IST_FIXED_H_FORMULA,           /* 17 */</a>
<a name="ln266">    IST_FIXED_H,                   /* 18 */</a>
<a name="ln267">    IST_FIXED_H_CHARGE,            /* 19 */</a>
<a name="ln268">    IST_FIXED_H_SP2,               /* 20 */</a>
<a name="ln269">    IST_FIXED_H_SP3,               /* 21 */</a>
<a name="ln270">    IST_FIXED_H_SP3_M,             /* 22 */</a>
<a name="ln271">    IST_FIXED_H_SP3_S,             /* 23 */</a>
<a name="ln272">    IST_FIXED_H_PERMUTATION,       /* 24 */</a>
<a name="ln273"> </a>
<a name="ln274">    /* Fork */</a>
<a name="ln275">    IST_FIXED_H_ISO_LAYER_FORK,    /* 25 */</a>
<a name="ln276"> </a>
<a name="ln277">    /* FI */</a>
<a name="ln278">    IST_FIXED_H_ISO_ATOMS,         /* 26 */</a>
<a name="ln279">    IST_FIXED_H_ISO_LAYER,         /* 27 */</a>
<a name="ln280">    IST_FIXED_H_ISO_SP2,           /* 28 */</a>
<a name="ln281">    IST_FIXED_H_ISO_SP3,           /* 29 */</a>
<a name="ln282">    IST_FIXED_H_ISO_SP3_M,         /* 30 */</a>
<a name="ln283">    IST_FIXED_H_ISO_SP3_S,         /* 31 */</a>
<a name="ln284">    IST_FIXED_H_ISO_PERMUTATION,   /* 32 */</a>
<a name="ln285"> </a>
<a name="ln286">    /* Reconnected */</a>
<a name="ln287">    IST_RECONNECTED_LAYER_FORK,    /* 33 */</a>
<a name="ln288">    IST_RECONNECTED_FORMULA,       /* 34 */</a>
<a name="ln289"> </a>
<a name="ln290">    /* Other reading errors */</a>
<a name="ln291">    IST_MATERIAL_BALANCE_ERROR,    /* 35 */</a>
<a name="ln292"> </a>
<a name="ln293">    IST_END                     =    -1</a>
<a name="ln294">}INCHI_STATE;</a>
<a name="ln295"> </a>
<a name="ln296">#define IST_HAPPENED_IN_RECMET   100</a>
<a name="ln297"> </a>
<a name="ln298">typedef struct tagInchiReadErrMsg </a>
<a name="ln299">{</a>
<a name="ln300">    int         stat;</a>
<a name="ln301">    const char  *msg;</a>
<a name="ln302">} INCHI_READ_ERR_MSG;</a>
<a name="ln303"> </a>
<a name="ln304">ICHICONST INCHI_READ_ERR_MSG irErrMsg[] = </a>
<a name="ln305">{</a>
<a name="ln306">    /* M */</a>
<a name="ln307">   {IST_MOBILE_H_FORMULA,            &quot;MOBILE_H_FORMULA&quot;          },</a>
<a name="ln308">   {IST_MOBILE_H_CONNECTIONS,        &quot;MOBILE_H_CONNECTIONS&quot;      },</a>
<a name="ln309">   {IST_MOBILE_H,                    &quot;MOBILE_H&quot;                  },</a>
<a name="ln310">   {IST_MOBILE_H_CHARGE,             &quot;MOBILE_H_CHARGE&quot;           },</a>
<a name="ln311">   {IST_MOBILE_H_PROTONS,            &quot;MOBILE_H_PROTONS&quot;          },</a>
<a name="ln312">   {IST_MOBILE_H_SP2,                &quot;MOBILE_H_SP2&quot;              },</a>
<a name="ln313">   {IST_MOBILE_H_SP3,                &quot;MOBILE_H_SP3&quot;              },</a>
<a name="ln314">   {IST_MOBILE_H_SP3_M,              &quot;MOBILE_H_SP3_/m&quot;           },</a>
<a name="ln315">   {IST_MOBILE_H_SP3_S,              &quot;MOBILE_H_SP3_/s&quot;           },</a>
<a name="ln316"> </a>
<a name="ln317">    /* Fork */</a>
<a name="ln318">   {IST_MOBILE_H_ISO_LAYER_FORK,     &quot;MOBILE_H_ISO_LAYER_FORK&quot;   },</a>
<a name="ln319"> </a>
<a name="ln320">    /* MI */</a>
<a name="ln321">   {IST_MOBILE_H_ISO_ATOMS,          &quot;MOBILE_H_ISO_ATOMS&quot;        },</a>
<a name="ln322">   {IST_MOBILE_H_ISO_EXCH_H,         &quot;MOBILE_H_ISO_EXCH_H&quot;       },</a>
<a name="ln323">   {IST_MOBILE_H_ISO_SP2,            &quot;MOBILE_H_ISO_SP2&quot;          },</a>
<a name="ln324">   {IST_MOBILE_H_ISO_SP3,            &quot;MOBILE_H_ISO_SP3&quot;          },</a>
<a name="ln325">   {IST_MOBILE_H_ISO_SP3_M,          &quot;MOBILE_H_ISO_SP3_/m&quot;       },</a>
<a name="ln326">   {IST_MOBILE_H_ISO_SP3_S,          &quot;MOBILE_H_ISO_SP3_/s&quot;       },</a>
<a name="ln327"> </a>
<a name="ln328">    /* Fork */</a>
<a name="ln329">  {IST_FIXED_H_LAYER_FORK,           &quot;FIXED_H_LAYER_FORK&quot;        },</a>
<a name="ln330"> </a>
<a name="ln331">    /* F */</a>
<a name="ln332">   {IST_FIXED_H_FORMULA,             &quot;FIXED_H_FORMULA&quot;           },</a>
<a name="ln333">   {IST_FIXED_H,                     &quot;FIXED_H&quot;                   },</a>
<a name="ln334">   {IST_FIXED_H_CHARGE,              &quot;FIXED_H_CHARGE&quot;            },</a>
<a name="ln335">   {IST_FIXED_H_SP2,                 &quot;FIXED_H_SP2&quot;               },</a>
<a name="ln336">   {IST_FIXED_H_SP3,                 &quot;FIXED_H_SP3&quot;               },</a>
<a name="ln337">   {IST_FIXED_H_SP3_M,               &quot;FIXED_H_SP3_/m&quot;            },</a>
<a name="ln338">   {IST_FIXED_H_SP3_S,               &quot;FIXED_H_SP3_/s&quot;            },</a>
<a name="ln339">   {IST_FIXED_H_PERMUTATION,         &quot;FIXED_H_PERMUTATION&quot;       },</a>
<a name="ln340"> </a>
<a name="ln341">    /* Fork */</a>
<a name="ln342">   {IST_FIXED_H_ISO_LAYER_FORK,      &quot;FIXED_H_ISO_LAYER_FORK&quot;    },</a>
<a name="ln343"> </a>
<a name="ln344">    /* FI */</a>
<a name="ln345">   {IST_FIXED_H_ISO_ATOMS,           &quot;FIXED_H_ISO_ATOMS&quot;         },</a>
<a name="ln346">   {IST_FIXED_H_ISO_LAYER,           &quot;FIXED_H_ISO_LAYER&quot;         },</a>
<a name="ln347">   {IST_FIXED_H_ISO_SP2,             &quot;FIXED_H_ISO_SP2&quot;           },</a>
<a name="ln348">   {IST_FIXED_H_ISO_SP3,             &quot;FIXED_H_ISO_SP3&quot;           },</a>
<a name="ln349">   {IST_FIXED_H_ISO_SP3_M,           &quot;FIXED_H_ISO_SP3_m&quot;         },</a>
<a name="ln350">   {IST_FIXED_H_ISO_SP3_S,           &quot;FIXED_H_ISO_SP3_s&quot;         },</a>
<a name="ln351">   {IST_FIXED_H_ISO_PERMUTATION,     &quot;FIXED_H_ISO_PERMUTATION&quot;   },</a>
<a name="ln352"> </a>
<a name="ln353">    /* Reconnected */</a>
<a name="ln354">   {IST_RECONNECTED_LAYER_FORK,      &quot;RECONNECTED_LAYER_FORK&quot;    },</a>
<a name="ln355">   {IST_RECONNECTED_FORMULA,         &quot;RECONNECTED_FORMULA&quot;       },</a>
<a name="ln356"> </a>
<a name="ln357">   {IST_MATERIAL_BALANCE_ERROR,      &quot;MATERIAL_BALANCE&quot;          },</a>
<a name="ln358"> </a>
<a name="ln359">   {IST_END,                         &quot;Unknown Error&quot;             }</a>
<a name="ln360">};</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363"> </a>
<a name="ln364">typedef enum tagCopySegmentType </a>
<a name="ln365">{</a>
<a name="ln366">    CPY_SP2,</a>
<a name="ln367">    CPY_SP3,</a>
<a name="ln368">    CPY_SP3_M,</a>
<a name="ln369">    CPY_SP3_S,</a>
<a name="ln370">    CPY_ISO_AT</a>
<a name="ln371">} COPY_SEG_TYPE;</a>
<a name="ln372"> </a>
<a name="ln373">#define NSTRLEN 64000</a>
<a name="ln374">#define MAX_MSG_LEN 512</a>
<a name="ln375">#define MAX_MSG_BUF_LEN 128</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">/*************************************************************************************/</a>
<a name="ln379">const char *getInchiStateReadErr(int stat)</a>
<a name="ln380">{</a>
<a name="ln381">    int i, bRecMet = 0;</a>
<a name="ln382">    static char szMsg[128];</a>
<a name="ln383">    if ( stat &gt;= IST_HAPPENED_IN_RECMET ) </a>
<a name="ln384">    {</a>
<a name="ln385">        bRecMet = 1;</a>
<a name="ln386">        stat -= IST_HAPPENED_IN_RECMET;</a>
<a name="ln387">    }</a>
<a name="ln388">    for ( i = 0; 0 &lt;= irErrMsg[i].stat &amp;&amp; stat != irErrMsg[i].stat; i ++ )</a>
<a name="ln389">        ;</a>
<a name="ln390">    sprintf(szMsg, </a>
<a name="ln391">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln392">        &quot;%s%.100s&quot;,</a>
<a name="ln393">#else</a>
<a name="ln394">        &quot;%s%s&quot;,</a>
<a name="ln395">#endif</a>
<a name="ln396">        irErrMsg[i].msg, bRecMet? &quot;, Reconnected layer&quot; : &quot;&quot;);</a>
<a name="ln397">    return szMsg;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/**************************************************************************************/</a>
<a name="ln401">const char *getInchiErrName(int nErr)</a>
<a name="ln402">{</a>
<a name="ln403">    switch ( nErr ) </a>
<a name="ln404">    {</a>
<a name="ln405">    case RI_ERR_ALLOC:</a>
<a name="ln406">        return &quot;Allocation failed&quot;;</a>
<a name="ln407">    case RI_ERR_PROGR:</a>
<a name="ln408">        return &quot;Program error&quot;;</a>
<a name="ln409">    case RI_ERR_SYNTAX:</a>
<a name="ln410">        return &quot;Syntax error&quot;;</a>
<a name="ln411">    case RI_ERR_EOL:</a>
<a name="ln412">        return &quot;End of line&quot;;</a>
<a name="ln413">    }</a>
<a name="ln414">    return &quot;Unknown error&quot;;</a>
<a name="ln415">}</a>
<a name="ln416">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln417">/*****************************************************************************************/</a>
<a name="ln418">int SetHillFormFromInChI(InpInChI *OneInput)</a>
<a name="ln419">{</a>
<a name="ln420">    int iINChI, iTaut, iComp, num_diff;</a>
<a name="ln421">    INChI *pINChI;</a>
<a name="ln422">    char *szHillFormulaOld;</a>
<a name="ln423">    for ( iINChI = 0, num_diff = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) </a>
<a name="ln424">    {</a>
<a name="ln425">        for ( iTaut = TAUT_NON; iTaut &lt; TAUT_NUM; iTaut ++ ) </a>
<a name="ln426">        {</a>
<a name="ln427">            for ( iComp = 0; iComp &lt; OneInput-&gt;nNumComponents[iINChI][iTaut]; iComp ++ ) </a>
<a name="ln428">            {</a>
<a name="ln429">                pINChI = &amp;OneInput-&gt;pInpInChI[iINChI][iTaut][iComp];</a>
<a name="ln430">                if ( !pINChI-&gt;nNumberOfAtoms || pINChI-&gt;bDeleted || !pINChI-&gt;szHillFormula || !pINChI-&gt;szHillFormula[0] ) </a>
<a name="ln431">                {</a>
<a name="ln432">                    continue;</a>
<a name="ln433">                }</a>
<a name="ln434">                szHillFormulaOld = pINChI-&gt;szHillFormula;</a>
<a name="ln435">                pINChI-&gt;szHillFormula = AllocateAndFillHillFormula(pINChI);</a>
<a name="ln436">                num_diff += !pINChI-&gt;szHillFormula || !pINChI-&gt;szHillFormula[0] || strcmp(pINChI-&gt;szHillFormula, szHillFormulaOld);</a>
<a name="ln437">                inchi_free(szHillFormulaOld);</a>
<a name="ln438">            }</a>
<a name="ln439">        }</a>
<a name="ln440">    }</a>
<a name="ln441">    return num_diff;</a>
<a name="ln442">}</a>
<a name="ln443">#endif</a>
<a name="ln444"> </a>
<a name="ln445"> </a>
<a name="ln446"> </a>
<a name="ln447">/********************** main entry point **********************************************/</a>
<a name="ln448"> </a>
<a name="ln449">int ReadWriteInChI(INCHI_IOSTREAM *pInp, INCHI_IOSTREAM *pOut, INCHI_IOSTREAM *pLog,</a>
<a name="ln450">                   INPUT_PARMS *ip_inp,  </a>
<a name="ln451">                   STRUCT_DATA *sd_inp,</a>
<a name="ln452">                   /* the following are InChI library-specific parameters */</a>
<a name="ln453">                   inp_ATOM **at, int *num_at,</a>
<a name="ln454">                   char *szMsg, int nMsgLen, unsigned long WarningFlags[2][2])</a>
<a name="ln455">{                </a>
<a name="ln456">    InpInChI OneInput;</a>
<a name="ln457">    int      i, j, nReadStatus, ret, nErr, iINChI;</a>
<a name="ln458">    char    *strHdr=NULL;</a>
<a name="ln459">    char    *szCurHdr = NULL;</a>
<a name="ln460">    int num_components[INCHI_NUM];</a>
<a name="ln461">    int bReqNonTaut = (0 != ((ip_inp-&gt;nMode &amp; REQ_MODE_BASIC) &amp;&amp; </a>
<a name="ln462">                             (ip_inp-&gt;nMode &amp; REQ_MODE_TAUT)));</a>
<a name="ln463">    /*</a>
<a name="ln464">    int bReqRecmet  = (0 != ((ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD) &amp;&amp;</a>
<a name="ln465">                             (ip-&gt;bTautFlags &amp; TG_FLAG_DISCONNECT_COORD)));</a>
<a name="ln466">    */</a>
<a name="ln467">    int bReqStereo  = (0 != (ip_inp-&gt;nMode &amp; REQ_MODE_STEREO));</a>
<a name="ln468">    int bHasSomeReconnected = 0, bHasSomeFixedH = 0, bHasMetal = 0;</a>
<a name="ln469">    int nModeFlagsStereo = 0, bTautFlags = 0; /* InChI creation flags modifications derived from current InChI */</a>
<a name="ln470">    MODE_PIXH nModeProtonIsoExchgH[INCHI_NUM];</a>
<a name="ln471"> </a>
<a name="ln472">    NORM_CANON_FLAGS ncFlags;</a>
<a name="ln473">    NORM_CANON_FLAGS *pncFlags = &amp;ncFlags;</a>
<a name="ln474">    INPUT_PARMS ip_cur, *ip;</a>
<a name="ln475">    STRUCT_DATA sd_cur, *sd;</a>
<a name="ln476">    int  nMessageLen = MAX_MSG_LEN;</a>
<a name="ln477">    char szMessage[MAX_MSG_LEN];</a>
<a name="ln478">    int  nInitLenMessage;</a>
<a name="ln479"> </a>
<a name="ln480">    int  pState, bStereoType;</a>
<a name="ln481">    int  bReqProtonsForEachComponent = 0;</a>
<a name="ln482">    int  bReqSplitOutputInChI = 0;</a>
<a name="ln483">    SEGM_LINE Line;</a>
<a name="ln484">    SEGM_LINE *pLine = &amp;Line;</a>
<a name="ln485">    long          ulProcessingTime = 0;</a>
<a name="ln486">    inchiTime     ulTStart;</a>
<a name="ln487">    long          num_processed = 0, num_errors = 0;</a>
<a name="ln488">    int  bPlainTabbedOutput;</a>
<a name="ln489">    const char *pTAB;</a>
<a name="ln490"> </a>
<a name="ln491">#ifdef TARGET_API_LIB</a>
<a name="ln492">    const int       bInChI2Structure = 0 != (ip_inp-&gt;bReadInChIOptions &amp; READ_INCHI_TO_STRUCTURE);</a>
<a name="ln493">    const int       bInChI2InChI     = 0 != (ip_inp-&gt;bReadInChIOptions &amp; READ_INCHI_OUTPUT_INCHI);</a>
<a name="ln494">#else</a>
<a name="ln495">    const int       bInChI2Structure = 0 != (ip_inp-&gt;bReadInChIOptions &amp; READ_INCHI_TO_STRUCTURE);</a>
<a name="ln496">    const int       bInChI2InChI     = 0 != (ip_inp-&gt;bReadInChIOptions &amp; READ_INCHI_OUTPUT_INCHI);</a>
<a name="ln497">#endif</a>
<a name="ln498">    const int       bReadCoord       = bInChI2Structure;</a>
<a name="ln499">    long      num_inp=0;</a>
<a name="ln500">   </a>
<a name="ln501">    int bInputInStdFormat=0;</a>
<a name="ln502">    int bInputHasSaveOpt=0;</a>
<a name="ln503">    unsigned char inp_save_opt_bits=0;</a>
<a name="ln504">    unsigned char save_opt_bits=0;</a>
<a name="ln505"> </a>
<a name="ln506">    ret         = 0;</a>
<a name="ln507">    nReadStatus = RI_ERR_EOL;</a>
<a name="ln508">    </a>
<a name="ln509">    memset(szMessage, 0, sizeof(szMessage));</a>
<a name="ln510">    memset(&amp;OneInput, 0, sizeof(OneInput));</a>
<a name="ln511">    memset(pLine, 0, sizeof(pLine[0]));</a>
<a name="ln512">    if ( szMsg ) </a>
<a name="ln513">        szMsg[0] = '\0';</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">    while( nReadStatus != RI_ERR_EOF ) </a>
<a name="ln517">    {</a>
<a name="ln518"> </a>
<a name="ln519">        for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) </a>
<a name="ln520">        {</a>
<a name="ln521">            for ( j = 0; j &lt; TAUT_NUM; j ++ ) </a>
<a name="ln522">            {</a>
<a name="ln523">                if ( OneInput.nNumProtons[iINChI][j].pNumProtons ) </a>
<a name="ln524">                {</a>
<a name="ln525">                    inchi_free(OneInput.nNumProtons[iINChI][j].pNumProtons);</a>
<a name="ln526">                    OneInput.nNumProtons[iINChI][j].pNumProtons = NULL;</a>
<a name="ln527">                }</a>
<a name="ln528">            }</a>
<a name="ln529">        }</a>
<a name="ln530">        </a>
<a name="ln531">        memset(&amp;OneInput, 0, sizeof(OneInput));</a>
<a name="ln532">        memset(pncFlags, 0, sizeof(*pncFlags));        </a>
<a name="ln533">        bStereoType = 0;</a>
<a name="ln534">        ip_cur = *ip_inp;</a>
<a name="ln535">        ip     = &amp;ip_cur;</a>
<a name="ln536">        sd_cur = *sd_inp;</a>
<a name="ln537">        sd     = &amp;sd_cur;</a>
<a name="ln538">        bReqSplitOutputInChI          = 0 != (ip-&gt;bReadInChIOptions &amp; READ_INCHI_SPLIT_OUTPUT);</a>
<a name="ln539">        bReqProtonsForEachComponent   = bReqSplitOutputInChI &amp;&amp; </a>
<a name="ln540">                                        0 != (READ_INCHI_KEEP_BALANCE_P &amp; ip-&gt;bReadInChIOptions);</a>
<a name="ln541"> </a>
<a name="ln542">        bPlainTabbedOutput     = 0 != (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_TABBED_OUTPUT);</a>
<a name="ln543">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_LIB_FOR_WINCHI) )    </a>
<a name="ln544">        pTAB                   = bPlainTabbedOutput? &quot;\t&quot; : &quot;\n&quot;;</a>
<a name="ln545">#else</a>
<a name="ln546">        pTAB                   = &quot;\n&quot;;</a>
<a name="ln547">#endif</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">        if ( bInChI2Structure ) </a>
<a name="ln551">        {</a>
<a name="ln552">#if ( bRELEASE_VERSION == 1 )            </a>
<a name="ln553">            bReqNonTaut = 1; /* bReqNonTaut=0 ignores Fixed-H layer in input InChI, for testing only */</a>
<a name="ln554">#endif</a>
<a name="ln555">            /* bReqRecmet  = 1; */</a>
<a name="ln556">            bReqStereo  = 1;</a>
<a name="ln557">            bReqSplitOutputInChI = 1;</a>
<a name="ln558">            bReqProtonsForEachComponent = bReqNonTaut;</a>
<a name="ln559">            ip-&gt;bTautFlags |= (TG_FLAG_DISCONNECT_COORD | TG_FLAG_RECONNECT_COORD);</a>
<a name="ln560">            ip-&gt;nMode      |= (REQ_MODE_BASIC | REQ_MODE_TAUT | REQ_MODE_STEREO | REQ_MODE_ISO_STEREO | REQ_MODE_ISO);</a>
<a name="ln561">        }</a>
<a name="ln562">        </a>
<a name="ln563">        </a>
<a name="ln564">        /************************************************************************/</a>
<a name="ln565">        /*                     Read InChI string                                */</a>
<a name="ln566">        /************************************************************************/</a>
<a name="ln567">        InchiTimeGet(&amp;ulTStart);</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">        nReadStatus = InChILine2Data(pInp, pLine, &amp;strHdr, &amp;pState, &amp;nErr, OneInput.pInpInChI,</a>
<a name="ln571">                                    OneInput.nNumComponents, OneInput.nNumProtons,</a>
<a name="ln572">                                    OneInput.s, bReadCoord, bInChI2Structure, </a>
<a name="ln573">                                    ip_inp-&gt;nMode, </a>
<a name="ln574">                                    &amp;bInputInStdFormat,&amp;bInputHasSaveOpt,&amp;inp_save_opt_bits);</a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577">        </a>
<a name="ln578">        ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln579"> </a>
<a name="ln580"> </a>
<a name="ln581">        if ( (nReadStatus == RI_ERR_EOL || nReadStatus == RI_ERR_EOF) &amp;&amp; !nErr &amp;&amp;</a>
<a name="ln582">                               OneInput.nNumComponents[INCHI_BAS][TAUT_YES] </a>
<a name="ln583">                             + OneInput.nNumComponents[INCHI_BAS][TAUT_NON] ) </a>
<a name="ln584">        {</a>
<a name="ln585">            /* InChI has been successfully read */</a>
<a name="ln586">        </a>
<a name="ln587">            ret = 0;</a>
<a name="ln588">            num_inp ++;</a>
<a name="ln589">            bHasSomeReconnected = 0;</a>
<a name="ln590">            bHasSomeFixedH      = 0;</a>
<a name="ln591"> </a>
<a name="ln592">            /* Does not allow conversion non-standard-&gt;standard */</a>
<a name="ln593">            /* (force target to be non-standard also)           */</a>
<a name="ln594">            if ( ip_inp-&gt;bINChIOutputOptions &amp; INCHI_OUT_STDINCHI ) </a>
<a name="ln595">            {</a>
<a name="ln596">                if ( !bInputInStdFormat )   /* Input InChI is a non-standard one  */</a>
<a name="ln597">                {</a>
<a name="ln598">                    ip-&gt;bINChIOutputOptions &amp;= ~INCHI_OUT_STDINCHI;</a>
<a name="ln599">                    if ( szCurHdr &amp;&amp; szCurHdr[0] ) </a>
<a name="ln600">                        inchi_ios_eprint( pLog, &quot;Warning: forced conversion to non-standard InChI for non-std input, %s\n&quot;, szCurHdr );</a>
<a name="ln601">                    else </a>
<a name="ln602">                        inchi_ios_eprint( pLog, &quot;Warning: forced conversion to non-standard InChI for non-std input, Structure %ld\n&quot;, num_inp );</a>
<a name="ln603">                }</a>
<a name="ln604">            }            </a>
<a name="ln605">            </a>
<a name="ln606">            if ( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_SAVEOPT )</a>
<a name="ln607">            {</a>
<a name="ln608">                if (!bInputHasSaveOpt)</a>
<a name="ln609">                {</a>
<a name="ln610">                    /* Does not allow to create SaveOpt if the source lacks appendix */</a>
<a name="ln611">                    ip-&gt;bINChIOutputOptions &amp;= ~INCHI_OUT_SAVEOPT;</a>
<a name="ln612">                    if ( szCurHdr &amp;&amp; szCurHdr[0] ) </a>
<a name="ln613">                        inchi_ios_eprint( pLog, &quot;Warning: ignore SaveOpt request for SaveOpt-less input, %s\n&quot;, szCurHdr );</a>
<a name="ln614">                    else </a>
<a name="ln615">                        inchi_ios_eprint( pLog, &quot;Warning: ignore SaveOpt request for SaveOpt-less input, Structure %ld\n&quot;, num_inp );</a>
<a name="ln616">                }</a>
<a name="ln617">                else</a>
<a name="ln618">                {</a>
<a name="ln619">                    /* Analyze existing and prepare new SaveOpt appendix */</a>
<a name="ln620"> </a>
<a name="ln621">                    if ( 0 != ( ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD) )</a>
<a name="ln622">                    {</a>
<a name="ln623">                        /* RecMet requested */</a>
<a name="ln624">                        if ( 0 != (inp_save_opt_bits &amp; SAVE_OPT_RECMET) ) </a>
<a name="ln625">                        {</a>
<a name="ln626">                            save_opt_bits |= SAVE_OPT_RECMET;</a>
<a name="ln627">                        }</a>
<a name="ln628">                        else</a>
<a name="ln629">                        {</a>
<a name="ln630">                            ip-&gt;bTautFlags &amp;= ~TG_FLAG_RECONNECT_COORD;</a>
<a name="ln631">                            if ( szCurHdr &amp;&amp; szCurHdr[0] ) </a>
<a name="ln632">                                inchi_ios_eprint( pLog, &quot;Warning: input created w/o RecMet - ignoring RecMet request, %s\n&quot;, szCurHdr );</a>
<a name="ln633">                            else </a>
<a name="ln634">                                inchi_ios_eprint( pLog, &quot;Warning: input created w/o RecMet - ignoring RecMet request, Structure %ld\n&quot;, num_inp );</a>
<a name="ln635">                        }</a>
<a name="ln636">                    }</a>
<a name="ln637">                    if ( 0 != (ip-&gt;nMode &amp; REQ_MODE_BASIC) )</a>
<a name="ln638">                    {</a>
<a name="ln639">                        /* FixedH requested */</a>
<a name="ln640">                        if ( 0 != (inp_save_opt_bits &amp; SAVE_OPT_FIXEDH) )</a>
<a name="ln641">                            save_opt_bits |= SAVE_OPT_FIXEDH;</a>
<a name="ln642">                        else</a>
<a name="ln643">                        {</a>
<a name="ln644">                            ip-&gt;nMode &amp;= ~REQ_MODE_BASIC;</a>
<a name="ln645">                            if ( szCurHdr &amp;&amp; szCurHdr[0] ) </a>
<a name="ln646">                                inchi_ios_eprint( pLog, &quot;Warning: input created w/o FixedH - ignoring FixedH request, %s\n&quot;, szCurHdr );</a>
<a name="ln647">                            else </a>
<a name="ln648">                                inchi_ios_eprint( pLog, &quot;Warning: input created w/o FixedH - ignoring FixedH request, Structure %ld\n&quot;, num_inp );</a>
<a name="ln649">                        }</a>
<a name="ln650">                    }</a>
<a name="ln651">                    /* Copy from source SaveOpt the bits which we do not touch  */</a>
<a name="ln652">                    /* while converting InChI:         SUU SLUUD KET 15T        */</a>
<a name="ln653">                    if ( 0 != ( inp_save_opt_bits &amp; SAVE_OPT_SUU) ) </a>
<a name="ln654">                        save_opt_bits |= SAVE_OPT_SUU;</a>
<a name="ln655">                    if ( 0 != ( inp_save_opt_bits &amp; SAVE_OPT_SLUUD) ) </a>
<a name="ln656">                        save_opt_bits |= SAVE_OPT_SLUUD;</a>
<a name="ln657">                    if ( 0 != ( inp_save_opt_bits &amp; SAVE_OPT_KET) ) </a>
<a name="ln658">                        save_opt_bits |= SAVE_OPT_KET;</a>
<a name="ln659">                    if ( 0 != ( inp_save_opt_bits &amp; SAVE_OPT_15T) ) </a>
<a name="ln660">                        save_opt_bits |= SAVE_OPT_15T;</a>
<a name="ln661">                    /* Check if /SNon requested and turn OFF stereo bits if so */</a>
<a name="ln662">                    if ( ! (ip-&gt;nMode &amp; REQ_MODE_STEREO) )</a>
<a name="ln663">                    {</a>
<a name="ln664">                        save_opt_bits &amp;= ~SAVE_OPT_SUU;</a>
<a name="ln665">                        save_opt_bits &amp;= ~SAVE_OPT_SLUUD;</a>
<a name="ln666">                    }</a>
<a name="ln667">                }</a>
<a name="ln668">            }</a>
<a name="ln669">            </a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">#ifndef TARGET_API_LIB</a>
<a name="ln673">            /*</a>
<a name="ln674">            inchi_ios_eprint(stderr, &quot;%ld: %s\r&quot;, num_inp, strHdr? strHdr : &quot;&quot;);</a>
<a name="ln675">            inchi_ios_eprint(pLog,  &quot;%ld: %s\n&quot;, num_inp, strHdr? strHdr : &quot;&quot;);</a>
<a name="ln676">            */</a>
<a name="ln677"> </a>
<a name="ln678">            if ( !ip-&gt;bNoStructLabels &amp;&amp; !(bInChI2Structure &amp;&amp; (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_SDFILE_ONLY)) ) </a>
<a name="ln679">            { </a>
<a name="ln680">                /* Added 2nd item: Do not output this extra line into the output SDfile. 2008-11-17 DCh */</a>
<a name="ln681">                if ( strHdr &amp;&amp; strstr(strHdr, &quot;Structure:&quot;)) </a>
<a name="ln682">                {</a>
<a name="ln683">                    inchi_ios_print(pOut,  &quot;%s%s&quot;, strHdr, pTAB); /* output header */</a>
<a name="ln684">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln685">#else</a>
<a name="ln686">                    sprintf(szMessage, &quot;%s (%ld)&quot;,  strHdr? strHdr : &quot;&quot;, num_inp);</a>
<a name="ln687">#endif</a>
<a name="ln688">                } </a>
<a name="ln689">                else </a>
<a name="ln690">                {</a>
<a name="ln691">                    /*</a>
<a name="ln692">                    inchi_ios_print(pOut,  &quot;Structure %ld (%s)%s&quot;, num_inp, strHdr? strHdr : &quot;&quot;, pTAB);</a>
<a name="ln693">                    sprintf(szMessage, &quot;Structure %ld (%s)%s&quot;, num_inp, strHdr? strHdr : &quot;&quot; , pTAB);</a>
<a name="ln694">                    */</a>
<a name="ln695">                    inchi_ios_print(pOut,  &quot;Structure: %ld. (%s)%s&quot;, num_inp, strHdr? strHdr : &quot;No struct name&quot; , pTAB); /* output header */</a>
<a name="ln696">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln697">#else</a>
<a name="ln698">                    sprintf(szMessage, &quot;Structure: %ld. (%s)%s&quot;, num_inp, strHdr? strHdr : &quot;No struct name&quot;, pTAB);</a>
<a name="ln699">#endif</a>
<a name="ln700">                }</a>
<a name="ln701">                if ( strHdr &amp;&amp; strHdr[0] ) </a>
<a name="ln702">                {</a>
<a name="ln703">                    strncpy(ip-&gt;szSdfDataHeader, strHdr, sizeof(ip-&gt;szSdfDataHeader));</a>
<a name="ln704">                    ip-&gt;szSdfDataHeader[sizeof(ip-&gt;szSdfDataHeader)-1] = '\0';</a>
<a name="ln705">                    ip-&gt;pSdfLabel = NULL;</a>
<a name="ln706">                    ip-&gt;pSdfValue = ip-&gt;szSdfDataHeader;</a>
<a name="ln707">                } </a>
<a name="ln708">                else </a>
<a name="ln709">                {</a>
<a name="ln710">                    ip-&gt;pSdfValue = NULL;</a>
<a name="ln711">                    ip-&gt;szSdfDataHeader[0] = '\0';</a>
<a name="ln712">                }</a>
<a name="ln713">            }</a>
<a name="ln714"> </a>
<a name="ln715">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln716">            sprintf(szMessage, &quot;%ld: %.400s&quot;, num_inp, strHdr? strHdr : &quot;&quot;);</a>
<a name="ln717">#else</a>
<a name="ln718">            sprintf(szMessage, &quot;%ld: %s&quot;, num_inp, strHdr? strHdr : &quot;&quot;);</a>
<a name="ln719">#endif</a>
<a name="ln720">#endif</a>
<a name="ln721">            </a>
<a name="ln722">            nInitLenMessage = strlen(szMessage);</a>
<a name="ln723">            if ( strHdr ) </a>
<a name="ln724">            {</a>
<a name="ln725">                szCurHdr = strHdr;</a>
<a name="ln726">                strHdr = NULL;</a>
<a name="ln727">            }</a>
<a name="ln728">            if ( szCurHdr &amp;&amp; ip &amp;&amp; ip-&gt;first_struct_number &gt; 0 ) </a>
<a name="ln729">            {</a>
<a name="ln730">                /* check whether the structure should be skipped */</a>
<a name="ln731">                static char szStruct[] = &quot;Structure:&quot;;</a>
<a name="ln732">                char *pStrNum = strstr(szCurHdr, szStruct);</a>
<a name="ln733">                long cur_struct_number;</a>
<a name="ln734">                if ( pStrNum ) </a>
<a name="ln735">                {</a>
<a name="ln736">                    pStrNum += sizeof(szStruct)-1; /* -1 takes care of the string terminal zero */</a>
<a name="ln737">                    cur_struct_number = inchi_strtol(pStrNum, NULL, 10);</a>
<a name="ln738">                    if ( cur_struct_number ) </a>
<a name="ln739">                    {</a>
<a name="ln740">                        OneInput.num_inp = cur_struct_number;</a>
<a name="ln741">                    }</a>
<a name="ln742">                    /* process request to bypass first several InChIs */</a>
<a name="ln743">                    if ( cur_struct_number &gt; 0 &amp;&amp; cur_struct_number &lt; ip-&gt;first_struct_number ) </a>
<a name="ln744">                    {</a>
<a name="ln745"> </a>
<a name="ln746">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )                   </a>
<a name="ln747">                        inchi_fprintf(stderr, &quot;Skipping %s\r&quot;, szMessage);</a>
<a name="ln748">#endif</a>
<a name="ln749">                        FreeInpInChI(&amp;OneInput);</a>
<a name="ln750">                        if ( szCurHdr ) </a>
<a name="ln751">                        {</a>
<a name="ln752">                            inchi_free(szCurHdr);</a>
<a name="ln753">                            szCurHdr = NULL;</a>
<a name="ln754">                        }</a>
<a name="ln755">                        INCHI_HEAPCHK</a>
<a name="ln756">                        continue;</a>
<a name="ln757">                    }</a>
<a name="ln758">                }</a>
<a name="ln759">            }</a>
<a name="ln760">            </a>
<a name="ln761">            num_processed ++;</a>
<a name="ln762">            </a>
<a name="ln763">            /* In case of splitting InChI into separate components */</a>
<a name="ln764">            /* decide whether to keep /p in each component or      */</a>
<a name="ln765">            /* output /p and /i/h as a separate component          */</a>
<a name="ln766">            /* Note: if InChI is not to be splitted DO NOT create  */</a>
<a name="ln767">            /* a separate component for /p, /i/h: it would be a bug*/</a>
<a name="ln768">        </a>
<a name="ln769">            InchiTimeGet(&amp;ulTStart);</a>
<a name="ln770"> </a>
<a name="ln771">            INCHI_HEAPCHK</a>
<a name="ln772">            ret = SetProtonsAndXchgIsoH(bInChI2Structure, bReqSplitOutputInChI, bReqProtonsForEachComponent,</a>
<a name="ln773">                           bReqNonTaut, bReqStereo, num_components, nModeProtonIsoExchgH, &amp;OneInput);</a>
<a name="ln774">            INCHI_HEAPCHK</a>
<a name="ln775">            if ( ret &lt; 0 ) </a>
<a name="ln776">            {</a>
<a name="ln777">                num_errors ++;</a>
<a name="ln778">                goto exit_error;</a>
<a name="ln779">            }</a>
<a name="ln780"> </a>
<a name="ln781">            sd-&gt;num_components[INCHI_BAS] = num_components[INCHI_BAS];</a>
<a name="ln782">            sd-&gt;num_components[INCHI_REC] = num_components[INCHI_REC];</a>
<a name="ln783"> </a>
<a name="ln784">            /* do we have reconnected InChI ? */</a>
<a name="ln785">            if ( (OneInput.nNumComponents[INCHI_REC][TAUT_YES] ||</a>
<a name="ln786">                  OneInput.nNumComponents[INCHI_REC][TAUT_NON]) &amp;&amp;</a>
<a name="ln787">                 (ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD) &amp;&amp;</a>
<a name="ln788">                 (ip-&gt;bTautFlags &amp; TG_FLAG_DISCONNECT_COORD) ) </a>
<a name="ln789">            {</a>
<a name="ln790">                /* needed for InChI string output to include reconnected InChI */</a>
<a name="ln791">                sd-&gt;bTautFlagsDone[0] |= TG_FLAG_DISCONNECT_COORD_DONE;</a>
<a name="ln792">                bHasSomeReconnected = 1;</a>
<a name="ln793">            }</a>
<a name="ln794">            /* Do we have fixed H InChI ? */</a>
<a name="ln795">            if ( bReqNonTaut &amp;&amp;</a>
<a name="ln796">                 /*OneInput.nNumComponents[bHasSomeReconnected?INCHI_REC:INCHI_BAS][TAUT_NON]*/</a>
<a name="ln797">                 (OneInput.nNumComponents[INCHI_REC][TAUT_NON] || </a>
<a name="ln798">                  OneInput.nNumComponents[INCHI_BAS][TAUT_NON]) ) </a>
<a name="ln799">            {</a>
<a name="ln800">                bHasSomeFixedH = 1;</a>
<a name="ln801">            }</a>
<a name="ln802">            </a>
<a name="ln803">            ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">           </a>
<a name="ln807">            if ( bInChI2Structure &amp;&amp; !bInChI2InChI ) </a>
<a name="ln808">            {</a>
<a name="ln809">                /**********************************************************************/</a>
<a name="ln810">                /*                     InChi --&gt; Structure                            */</a>
<a name="ln811">                /**********************************************************************/</a>
<a name="ln812">                </a>
<a name="ln813"> </a>
<a name="ln814">                int bINChIOutputOptions = </a>
<a name="ln815">#if ( I2S_MODIFY_OUTPUT == 1 )</a>
<a name="ln816">                /* transfer user's InChI output options to serialization 10-12-2007 */</a>
<a name="ln817">                    ip_inp-&gt;bINChIOutputOptions &amp; (</a>
<a name="ln818">                            INCHI_OUT_NO_AUX_INFO           |   /* do not output Aux Info */</a>
<a name="ln819">                            INCHI_OUT_SHORT_AUX_INFO        |   /* output short version of Aux Info */</a>
<a name="ln820">                            INCHI_OUT_ONLY_AUX_INFO         |   /* output only Aux Info */</a>
<a name="ln821">                         /* INCHI_OUT_EMBED_REC             |*/   /* embed reconnected INChI into disconnected INChI */</a>
<a name="ln822">                            INCHI_OUT_SDFILE_ONLY           |   /* save input data in a Molfile instead of creating INChI */</a>
<a name="ln823">                            INCHI_OUT_XML                   |   /* output xml INChI */</a>
<a name="ln824">                            INCHI_OUT_PLAIN_TEXT            |   /* output plain text INChI */</a>
<a name="ln825">                            INCHI_OUT_PLAIN_TEXT_COMMENTS   |   /* output plain text annotation */</a>
<a name="ln826">                            INCHI_OUT_XML_TEXT_COMMENTS     |   /* output xml text annotation */</a>
<a name="ln827">                         /* INCHI_OUT_WINCHI_WINDOW         |*/   /* output into wINChI text window */</a>
<a name="ln828">                            INCHI_OUT_TABBED_OUTPUT         |   /* tab-delimited (only for plain text) */</a>
<a name="ln829">                            INCHI_OUT_SDFILE_ATOMS_DT       |   /* SDfile output H isotopes as D and T */</a>
<a name="ln830">                            INCHI_OUT_SDFILE_SPLIT          |   /* Split SDfile into components */</a>
<a name="ln831">                            0);</a>
<a name="ln832"> </a>
<a name="ln833">            </a>
<a name="ln834">#else</a>
<a name="ln835">                            0;</a>
<a name="ln836">#endif</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">                SRM srm; /* rules how to handle bonds to metal atoms */</a>
<a name="ln840">                StrFromINChI *pStruct[INCHI_NUM][TAUT_NUM];</a>
<a name="ln841"> </a>
<a name="ln842"> </a>
<a name="ln843">                /* prepare parameters */</a>
<a name="ln844"> </a>
<a name="ln845">                InchiTimeGet(&amp;ulTStart);</a>
<a name="ln846"> </a>
<a name="ln847">                if ( bInputInStdFormat )</a>
<a name="ln848">                {</a>
<a name="ln849">                    if ( ip_inp-&gt;bINChIOutputOptions &amp; INCHI_OUT_STDINCHI )</a>
<a name="ln850">                        bINChIOutputOptions |= INCHI_OUT_STDINCHI;            </a>
<a name="ln851">                }</a>
<a name="ln852">                else</a>
<a name="ln853">                {</a>
<a name="ln854">                    if ( ip_inp-&gt;bINChIOutputOptions &amp; INCHI_OUT_SAVEOPT ) </a>
<a name="ln855">                        bINChIOutputOptions |= INCHI_OUT_SAVEOPT;            </a>
<a name="ln856">                }</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859"> </a>
<a name="ln860">                memset(pStruct, 0, sizeof(pStruct));</a>
<a name="ln861">                </a>
<a name="ln862">                /* structure restore parms */</a>
<a name="ln863">                SetUpSrm(&amp;srm);</a>
<a name="ln864">                </a>
<a name="ln865">                /* eliminate Fixed-H InChI that are exactly same as the corresponding Mobile-H structures */</a>
<a name="ln866">                RemoveFixHInChIIdentical2MobH(&amp;OneInput);</a>
<a name="ln867"> </a>
<a name="ln868">                /*-- recheck layers after the elimination; get optional stereo flags --*/</a>
<a name="ln869">                ret = DetectInpInchiCreationOptions(&amp;OneInput, </a>
<a name="ln870">                                                    &amp;bHasSomeReconnected, &amp;bHasMetal,</a>
<a name="ln871">                                                    &amp;bHasSomeFixedH, &amp;nModeFlagsStereo, </a>
<a name="ln872">                                                    &amp;bTautFlags);</a>
<a name="ln873">                if ( ret &lt; 0 ) </a>
<a name="ln874">                {</a>
<a name="ln875">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, </a>
<a name="ln876">                              &quot;Error in detecting input InChI options&quot;, &quot;; &quot;);</a>
<a name="ln877">                    num_errors ++;</a>
<a name="ln878">                    goto dealloc;</a>
<a name="ln879">                }</a>
<a name="ln880">                if ( bHasSomeFixedH &amp;&amp; !bReqNonTaut ) </a>
<a name="ln881">                {</a>
<a name="ln882">                    bHasSomeFixedH = 0;</a>
<a name="ln883">                }</a>
<a name="ln884">                /*---------------- set stereo flags ---------------------*/</a>
<a name="ln885">                ip-&gt;nMode &amp;= ~(REQ_MODE_STEREO | REQ_MODE_ISO_STEREO |</a>
<a name="ln886">                               REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO |</a>
<a name="ln887">                               REQ_MODE_CHIR_FLG_STEREO |</a>
<a name="ln888">                               REQ_MODE_SB_IGN_ALL_UU | REQ_MODE_SC_IGN_ALL_UU);</a>
<a name="ln889">                ip-&gt;nMode |= nModeFlagsStereo;</a>
<a name="ln890">                </a>
<a name="ln891">                /* Remove Phosphine and Arsine Stereo Flags */</a>
<a name="ln892">                ip-&gt;bTautFlags &amp;= ~TG_FLAG_PHOSPHINE_STEREO;</a>
<a name="ln893">                ip-&gt;bTautFlags &amp;= ~TG_FLAG_ARSINE_STEREO;</a>
<a name="ln894">                ip-&gt;bTautFlags &amp;= ~TG_FLAG_FIX_SP3_BUG;</a>
<a name="ln895"> </a>
<a name="ln896">                ip-&gt;bTautFlags |= bTautFlags;</a>
<a name="ln897"> </a>
<a name="ln898">                /* mark Disconnected InChI components that are exactly came as Reconnected ones */</a>
<a name="ln899">                /* Disconnected will have a negative number of the reconnected component */</a>
<a name="ln900">                /* Reconnected will have a positive number of the disconnected component */</a>
<a name="ln901">                MarkDisconectedIdenticalToReconnected (&amp;OneInput);</a>
<a name="ln902"> </a>
<a name="ln903">                /*****************************************************************************/</a>
<a name="ln904">                /* pay attention to:                                                         */</a>
<a name="ln905">                /* 1) .nLink &lt; 0 in Disonnected which means InChI is same as in Reconnected  */</a>
<a name="ln906">                /*    The component in Reconnected has .nLink pointing to the Disconnected;  */</a>
<a name="ln907">                /*    each .nLink = (1+component index) or -(1+component index)              */</a>
<a name="ln908">                /*    In the future .nLink&gt;0 in Disconnected shall point to the Reconnectrd  */</a>
<a name="ln909">                /*    component from which it was created                                    */</a>
<a name="ln910">                /* 2) Currently reversed structures from Disconnected components are created */</a>
<a name="ln911">                /*    and abandoned if Reconnected layer exists                              */</a>
<a name="ln912">                /* 3) Connect/disconnect H depends on the presence of atom/bond parity       */</a>
<a name="ln913">                /*    The combined Mobile/Fixed-H parity should be set for Fixed-H components*/</a>
<a name="ln914">                /* 4) No comparison of the Disconnected layer is done if Reconnected exists  */</a>
<a name="ln915">                /* 5) Reading InChI was not fully tested in case one component has stereo in */</a>
<a name="ln916">                /*    both Mobile-H and Fixed-H layers while another component has stereo    */</a>
<a name="ln917">                /*    only in Mobile-H layer                                                 */</a>
<a name="ln918">                /*****************************************************************************/</a>
<a name="ln919"> </a>
<a name="ln920">                /* main conversion InChI-&gt;Structure for each component and  */</a>
<a name="ln921">                /* after that pStruct[iRec][iMobH][iComponent].at2 is the structure,      */</a>
<a name="ln922">                /* pStruct[iRec][iMobH][iComponent].RevInChI full InChI for the structure */</a>
<a name="ln923">                /* In case of both Fixed-H and Mobile-H layers the results are in iMobH=0 */</a>
<a name="ln924">                /* In case of only Mobile-H/Main layer the results are in iMobH=1         */</a>
<a name="ln925">                ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln926"> </a>
<a name="ln927">                sd-&gt;ulStructTime = 0;</a>
<a name="ln928">                ret = AllInchiToStructure(ip, sd, num_inp, szCurHdr, &amp;srm, bHasSomeFixedH, pStruct, &amp;OneInput);</a>
<a name="ln929"> </a>
<a name="ln930">                ulProcessingTime += sd-&gt;ulStructTime;</a>
<a name="ln931">                InchiTimeGet(&amp;ulTStart);</a>
<a name="ln932">                /* ret &lt; 0 is error code; ret &gt; 0 is number of errors */</a>
<a name="ln933">                /* in pStruct[iInchiRec][iMobileH][iComponent].nError */</a>
<a name="ln934"> </a>
<a name="ln935">                if ( ret) </a>
<a name="ln936">                {</a>
<a name="ln937">                    /* conversion error */</a>
<a name="ln938">                    num_errors ++;</a>
<a name="ln939">                    goto dealloc;</a>
<a name="ln940">                }</a>
<a name="ln941">                </a>
<a name="ln942"> </a>
<a name="ln943">                /* an attempt to fix the numumber of removed protons in case of Mobile-H */</a>
<a name="ln944">                if ( !OneInput.nNumProtons[INCHI_BAS][TAUT_YES].pNumProtons &amp;&amp;</a>
<a name="ln945">                     !OneInput.nNumProtons[INCHI_REC][TAUT_YES].pNumProtons ) </a>
<a name="ln946">                {</a>
<a name="ln947">                    ret = AddProtonAndIsoHBalanceToMobHStruct(ip, sd, num_inp, bHasSomeFixedH, szCurHdr, pStruct, &amp;OneInput);</a>
<a name="ln948">                    if ( ret &lt; 0 ) </a>
<a name="ln949">                    {</a>
<a name="ln950">                        AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;Add/Remove protons error&quot;, &quot;; &quot;);</a>
<a name="ln951">                        num_errors ++;</a>
<a name="ln952">                        goto dealloc;</a>
<a name="ln953">                    }</a>
<a name="ln954">                }</a>
<a name="ln955">                </a>
<a name="ln956">                /* compare InChI from the Reversed Structure to the original input InChI */</a>
<a name="ln957">                </a>
<a name="ln958">                ret = CompareAllOrigInchiToRevInChI(pStruct, &amp;OneInput, bHasSomeFixedH, num_inp, szCurHdr);</a>
<a name="ln959">                if ( ret &lt; 0 ) </a>
<a name="ln960">                {</a>
<a name="ln961">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;InChI compare error&quot;, &quot;; &quot;);</a>
<a name="ln962">                    num_errors ++;</a>
<a name="ln963">                    goto dealloc;</a>
<a name="ln964">                }</a>
<a name="ln965">                </a>
<a name="ln966">                ret = CompareAllDisconnectedOrigInchiToRevInChI(pStruct, &amp;OneInput, bHasSomeFixedH,</a>
<a name="ln967">                                                                 num_inp, szCurHdr);</a>
<a name="ln968">                if ( ret &lt; 0 ) </a>
<a name="ln969">                {</a>
<a name="ln970">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;InChI compare2 error&quot;, &quot;; &quot;);</a>
<a name="ln971">                    num_errors ++;</a>
<a name="ln972">                    goto dealloc;</a>
<a name="ln973">                }</a>
<a name="ln974"> </a>
<a name="ln975">                if ( WarningFlags ) </a>
<a name="ln976">                {</a>
<a name="ln977">                    for ( i = 0; i &lt; 2; i ++ ) </a>
<a name="ln978">                    {</a>
<a name="ln979">                        for ( j = 0; j &lt; TAUT_NUM; j ++ ) </a>
<a name="ln980">                        {</a>
<a name="ln981">                            WarningFlags[i][j] = (unsigned long)OneInput.CompareInchiFlags[i][j];</a>
<a name="ln982">                        }</a>
<a name="ln983">                    }</a>
<a name="ln984">                }</a>
<a name="ln985">                </a>
<a name="ln986">                ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln987"> </a>
<a name="ln988">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln989">                ret = DisplayStructureComponents(ip, sd, num_inp, szCurHdr,</a>
<a name="ln990">                                                  &amp;srm, bReqNonTaut, pStruct, &amp;OneInput);</a>
<a name="ln991">                if ( ret &lt; 0 ) </a>
<a name="ln992">                {</a>
<a name="ln993">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;Display structure error&quot;, &quot;; &quot;);</a>
<a name="ln994">                }</a>
<a name="ln995">#endif</a>
<a name="ln996">                InchiTimeGet(&amp;ulTStart);</a>
<a name="ln997">                ret = MergeStructureComponents(ip, sd, num_inp, szCurHdr, &amp;srm, bReqNonTaut, pStruct, &amp;OneInput);</a>
<a name="ln998">                ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln999">                if ( ret &lt; 0 ) </a>
<a name="ln1000">                {</a>
<a name="ln1001">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;Merge Components error&quot;, &quot;; &quot;);</a>
<a name="ln1002">                    num_errors ++;</a>
<a name="ln1003">                    goto dealloc;</a>
<a name="ln1004">                }</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007"> </a>
<a name="ln1008">#ifdef TARGET_API_LIB</a>
<a name="ln1009">/*------------- for debug only -------------------</a>
<a name="ln1010">                InchiTimeGet(&amp;ulTStart);</a>
<a name="ln1011">                ret = OutputInChIOutOfStrFromINChI(ip, sd, num_inp, 0, </a>
<a name="ln1012">                                                   pOut, pLog, &amp;OneInput,</a>
<a name="ln1013">                                                   save_opt_bits);</a>
<a name="ln1014">                ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln1015">                if ( ret &lt; 0 ) {</a>
<a name="ln1016">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;Restored structure to InChI conversion failed&quot;, &quot;; &quot;);</a>
<a name="ln1017">                    goto dealloc;</a>
<a name="ln1018">                }</a>
<a name="ln1019">-------------------------------------------------*/</a>
<a name="ln1020">                if ( at &amp;&amp; num_at ) </a>
<a name="ln1021">                {</a>
<a name="ln1022">                    *at     = OneInput.atom;</a>
<a name="ln1023">                    *num_at = OneInput.num_atoms;</a>
<a name="ln1024">                    OneInput.atom = NULL;</a>
<a name="ln1025">                }</a>
<a name="ln1026">#else</a>
<a name="ln1027">                InchiTimeGet(&amp;ulTStart);</a>
<a name="ln1028">                ret = OutputInChIOutOfStrFromINChI(ip, sd, num_inp, bINChIOutputOptions, </a>
<a name="ln1029">                                                   pOut, /*pLog*/ NULL, &amp;OneInput, </a>
<a name="ln1030">                                                   bHasSomeFixedH, save_opt_bits);</a>
<a name="ln1031">                ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln1032">                if ( ret &lt; 0 ) </a>
<a name="ln1033">                {</a>
<a name="ln1034">                    AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;Restored structure to InChI conversion error&quot;, &quot;; &quot;);</a>
<a name="ln1035">                    num_errors ++;</a>
<a name="ln1036">                    goto dealloc;</a>
<a name="ln1037">                }</a>
<a name="ln1038">#endif</a>
<a name="ln1039"> </a>
<a name="ln1040">                if ( szMessage ) </a>
<a name="ln1041">                {</a>
<a name="ln1042">                    int len;</a>
<a name="ln1043">                    InchiTimeGet(&amp;ulTStart);</a>
<a name="ln1044">                    FillOutCompareMessage(szMessage, nMessageLen, OneInput.CompareInchiFlags[0]);</a>
<a name="ln1045">                    if ( OneInput.CompareInchiFlags[1][0] || OneInput.CompareInchiFlags[1][1] ) </a>
<a name="ln1046">                    {</a>
<a name="ln1047">                        AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;Disconnected: &quot;, &quot;; &quot;);</a>
<a name="ln1048">                        FillOutCompareMessage(szMessage, nMessageLen, OneInput.CompareInchiFlags[1]);</a>
<a name="ln1049">                    }</a>
<a name="ln1050">                    /* add a metal warning */</a>
<a name="ln1051">                    if ( bHasMetal &amp;&amp; nInitLenMessage &lt; (len=(int)strlen(szMessage)) ) </a>
<a name="ln1052">                    {</a>
<a name="ln1053">                        char szMetal[] = &quot; (Metal compound)&quot;;</a>
<a name="ln1054">                        int shift;</a>
<a name="ln1055">                        if ( len + (int)sizeof(szMetal) &gt; nMessageLen ) {</a>
<a name="ln1056">                            len = nMessageLen - (int)sizeof(szMetal);</a>
<a name="ln1057">                        }</a>
<a name="ln1058">                        shift = nInitLenMessage + (int)sizeof(szMetal) - 1;</a>
<a name="ln1059">                        memmove(szMessage+shift, szMessage + nInitLenMessage, (len-nInitLenMessage)*sizeof(szMessage[0]));</a>
<a name="ln1060">                        memcpy(szMessage + nInitLenMessage, szMetal, sizeof(szMetal)-sizeof(szMessage[0]));</a>
<a name="ln1061">                        szMessage[shift+len-nInitLenMessage] = '\0';</a>
<a name="ln1062">                    }</a>
<a name="ln1063">                    ulProcessingTime += InchiTimeElapsed(&amp;ulTStart);</a>
<a name="ln1064">                }</a>
<a name="ln1065">                </a>
<a name="ln1066">                ret = 0;</a>
<a name="ln1067"> </a>
<a name="ln1068">                /* deallocate */</a>
<a name="ln1069">dealloc:        </a>
<a name="ln1070">                if ( ret ) </a>
<a name="ln1071">                {</a>
<a name="ln1072">                    if ( ret &gt; 0 ) </a>
<a name="ln1073">                    {</a>
<a name="ln1074">                        int iRec, iMob, iComp, nComp, len;</a>
<a name="ln1075">                        char szTemp[128];</a>
<a name="ln1076">                        AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;*Conversion failed on component(s)&quot;, &quot;; &quot;);</a>
<a name="ln1077">                        len = strlen(szMessage);</a>
<a name="ln1078">                        for ( iRec = 0; iRec &lt; INCHI_NUM; iRec ++ ) </a>
<a name="ln1079">                        {</a>
<a name="ln1080">                            for ( iMob = bHasSomeFixedH? TAUT_NON : TAUT_YES; iMob &lt; TAUT_NUM; iMob ++ ) </a>
<a name="ln1081">                            {</a>
<a name="ln1082">                                nComp = OneInput.nNumComponents[iRec][iMob];</a>
<a name="ln1083">                                if ( !pStruct[iRec][iMob] ) </a>
<a name="ln1084">                                {</a>
<a name="ln1085">                                    continue;</a>
<a name="ln1086">                                }</a>
<a name="ln1087">                                for ( iComp = 0; iComp &lt; nComp; iComp ++ ) </a>
<a name="ln1088">                                {</a>
<a name="ln1089">                                    if ( pStruct[iRec][iMob][iComp].nError ) </a>
<a name="ln1090">                                    {</a>
<a name="ln1091">                                        char *szFormula = OneInput.pInpInChI[iRec][iMob][iComp].szHillFormula;</a>
<a name="ln1092">                                        sprintf (szTemp,</a>
<a name="ln1093">#if ( FIX_DALKE_BUGS == 1 )                                            </a>
<a name="ln1094">                                            &quot; %s%s%d(%.96s)&quot;,</a>
<a name="ln1095">#else</a>
<a name="ln1096">                                            &quot; %s%s%d(%s)&quot;,</a>
<a name="ln1097">#endif</a>
<a name="ln1098">                                            !bHasSomeReconnected? &quot;&quot; : iRec? &quot;R&quot; : &quot;D&quot;, </a>
<a name="ln1099">                                            !bHasSomeFixedH? &quot;&quot;: iMob? &quot;M&quot; : &quot;F&quot;,</a>
<a name="ln1100">                                            iComp + 1, szFormula? szFormula : &quot;???&quot;);</a>
<a name="ln1101">                                        AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, szTemp, NULL);</a>
<a name="ln1102">                                    }</a>
<a name="ln1103">                                }</a>
<a name="ln1104">                            }</a>
<a name="ln1105">                        }</a>
<a name="ln1106">                    } </a>
<a name="ln1107">                    else </a>
<a name="ln1108">                    {</a>
<a name="ln1109">                        if ( ret == CT_USER_QUIT_ERR ) </a>
<a name="ln1110">                        {</a>
<a name="ln1111">                            AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;*Terminated by the user*&quot;, &quot;; &quot;);</a>
<a name="ln1112">                        } else {</a>
<a name="ln1113">                            AddOneMsg(szMessage, (int)strlen(szMessage), nMessageLen, &quot;*Conversion failed*&quot;, &quot;; &quot;);</a>
<a name="ln1114">                        }</a>
<a name="ln1115">                    }</a>
<a name="ln1116">                }</a>
<a name="ln1117">                InchiTimeGet(&amp;ulTStart);</a>
<a name="ln1118">                /* print one structure report */</a>
<a name="ln1119">                if ( szMsg &amp;&amp; nMsgLen &gt; 1 ) </a>
<a name="ln1120">                {</a>
<a name="ln1121">                    int len = inchi_min( (int)strlen(szMessage), nMsgLen-1);</a>
<a name="ln1122">                    if ( len &gt; 0 ) </a>
<a name="ln1123">                    {</a>
<a name="ln1124">                        memcpy( szMsg, szMessage, len);</a>
<a name="ln1125">                        szMsg[len] = '\0';</a>
<a name="ln1126">                    } </a>
<a name="ln1127">                    else </a>
<a name="ln1128">                    {</a>
<a name="ln1129">                        szMsg[0] = '\0';</a>
<a name="ln1130">                    }</a>
<a name="ln1131">                }</a>
<a name="ln1132">                if ( nInitLenMessage &lt; (int)strlen(szMessage) ) </a>
<a name="ln1133">                {</a>
<a name="ln1134">                    inchi_ios_eprint(pLog, &quot;%s\n&quot;, szMessage);</a>
<a name="ln1135">                }</a>
<a name="ln1136">#ifndef TARGET_API_LIB</a>
<a name="ln1137">                else </a>
<a name="ln1138">                {</a>
<a name="ln1139">                    /*^^^inchi_ios_eprint( stderr, &quot;%s\r&quot;, szMessage );*/</a>
<a name="ln1140">                    inchi_fprintf( stderr, &quot;%s\r&quot;, szMessage );</a>
<a name="ln1141">                }</a>
<a name="ln1142">#endif                </a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">                FreeStrFromINChI( pStruct, OneInput.nNumComponents );</a>
<a name="ln1146">                FreeInpInChI( &amp;OneInput );</a>
<a name="ln1147">                if ( szCurHdr ) </a>
<a name="ln1148">                {</a>
<a name="ln1149">                    inchi_free( szCurHdr );</a>
<a name="ln1150">                    szCurHdr = NULL;</a>
<a name="ln1151">                }</a>
<a name="ln1152">                INCHI_HEAPCHK</a>
<a name="ln1153">                ulProcessingTime += InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1154">                if ( ret &lt; 0 ) </a>
<a name="ln1155">                {</a>
<a name="ln1156">                    goto exit_error;</a>
<a name="ln1157">                }</a>
<a name="ln1158"> </a>
<a name="ln1159">            }  /* if ( bInChI2Structure &amp;&amp; !bInChI2InChI ) */</a>
<a name="ln1160">            </a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163">            else if ( !bInChI2Structure &amp;&amp; bInChI2InChI ) </a>
<a name="ln1164">            {            </a>
<a name="ln1165">                /**********************************************************************/</a>
<a name="ln1166">                /*                     InChi --&gt; InChI string(s)                      */</a>
<a name="ln1167">                /**********************************************************************/</a>
<a name="ln1168"> </a>
<a name="ln1169">                int tmp = ip-&gt;bNoStructLabels;</a>
<a name="ln1170">                </a>
<a name="ln1171">                InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1172">                </a>
<a name="ln1173">                ip-&gt;bNoStructLabels = 1;</a>
<a name="ln1174">                INCHI_HEAPCHK</a>
<a name="ln1175">                ip-&gt;pSdfValue = NULL;</a>
<a name="ln1176">                ip-&gt;pSdfLabel = NULL;</a>
<a name="ln1177">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln1178">                SetHillFormFromInChI( &amp;OneInput );</a>
<a name="ln1179">#endif</a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">                ret = OutputInChIAsRequested(pOut, pLog, ip, sd, &amp;OneInput, </a>
<a name="ln1183">                                             num_components, nModeProtonIsoExchgH, </a>
<a name="ln1184">                                             num_inp, save_opt_bits);</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">#if ( !defined(TARGET_API_LIB) &amp;&amp; defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln1188">                /*^^^ calculate InChIKey if requested */</a>
<a name="ln1189">                /* However, do not calculat/write it if this function is called from within dll */</a>
<a name="ln1190">                {</a>
<a name="ln1191">                    char ik_string[256];    /*^^^ Resulting InChIKey string */</a>
<a name="ln1192">                    int ik_ret=0;           /*^^^ InChIKey-calc result code */</a>
<a name="ln1193">                    int xhash1, xhash2;</a>
<a name="ln1194">                    char szXtra1[65], szXtra2[65];</a>
<a name="ln1195"> </a>
<a name="ln1196">                    inchi_ios_flush2(pLog, stderr);</a>
<a name="ln1197"> </a>
<a name="ln1198">                    /*^^^ post-1.02b addition - correctly treat tabbed output with InChIKey */</a>
<a name="ln1199">                    if ( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_TABBED_OUTPUT ) </a>
<a name="ln1200">                        if ( ip-&gt;bCalcInChIHash != INCHIHASH_NONE )</a>
<a name="ln1201">                            if (pOut-&gt;s.pStr)</a>
<a name="ln1202">                                if (pOut-&gt;s.nUsedLength&gt;0)</a>
<a name="ln1203">                                    if (pOut-&gt;s.pStr[pOut-&gt;s.nUsedLength-1]=='\n')</a>
<a name="ln1204">                                        /* replace LF with TAB */</a>
<a name="ln1205">                                        pOut-&gt;s.pStr[pOut-&gt;s.nUsedLength-1] = '\t';</a>
<a name="ln1206"> </a>
<a name="ln1207"> </a>
<a name="ln1208">                    if ( ip-&gt;bCalcInChIHash != INCHIHASH_NONE )</a>
<a name="ln1209">                    {</a>
<a name="ln1210">                        char *buf = NULL;</a>
<a name="ln1211">                        size_t slen = pOut-&gt;s.nUsedLength;</a>
<a name="ln1212">                        extract_inchi_substring(&amp;buf, pOut-&gt;s.pStr, slen);</a>
<a name="ln1213">            </a>
<a name="ln1214">                        if (NULL!=buf)</a>
<a name="ln1215">                        {</a>
<a name="ln1216">                            xhash1 = xhash2 = 0;</a>
<a name="ln1217">                            if ( ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA1 ) ||</a>
<a name="ln1218">                                 ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA1_XTRA2 ) )</a>
<a name="ln1219">                                 xhash1 = 1;</a>
<a name="ln1220">                            if ( ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA2 ) ||</a>
<a name="ln1221">                                 ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA1_XTRA2 ) )</a>
<a name="ln1222">                                 xhash2 = 1;                </a>
<a name="ln1223">                            ik_ret = GetINCHIKeyFromINCHI(buf, xhash1, xhash2, </a>
<a name="ln1224">                                                          ik_string, szXtra1, szXtra2);</a>
<a name="ln1225">                            inchi_free(buf);</a>
<a name="ln1226">                        }</a>
<a name="ln1227">                        else</a>
<a name="ln1228">                            ik_ret = INCHIKEY_NOT_ENOUGH_MEMORY;                     </a>
<a name="ln1229">        </a>
<a name="ln1230"> </a>
<a name="ln1231">                        if (ik_ret==INCHIKEY_OK)   </a>
<a name="ln1232">                        {</a>
<a name="ln1233">                            inchi_ios_print(pOut, &quot;InChIKey=%-s\n&quot;,ik_string);</a>
<a name="ln1234">                        }</a>
<a name="ln1235">                        else    </a>
<a name="ln1236">                        {</a>
<a name="ln1237">                            inchi_ios_print(pLog, &quot;Warning (Could not compute InChIKey: &quot;, num_inp);</a>
<a name="ln1238">                            switch(ik_ret)</a>
<a name="ln1239">                            {</a>
<a name="ln1240">                                case INCHIKEY_UNKNOWN_ERROR:</a>
<a name="ln1241">                                    inchi_ios_print(pLog, &quot;unresolved error)&quot;);</a>
<a name="ln1242">                                    break;</a>
<a name="ln1243">                                case INCHIKEY_EMPTY_INPUT:</a>
<a name="ln1244">                                    inchi_ios_print(pLog,  &quot;got an empty string)&quot;);</a>
<a name="ln1245">                                    break;</a>
<a name="ln1246">                                case INCHIKEY_INVALID_INCHI_PREFIX:</a>
<a name="ln1247">                                case INCHIKEY_INVALID_INCHI:</a>
<a name="ln1248">                                case INCHIKEY_INVALID_STD_INCHI:</a>
<a name="ln1249">                                    inchi_ios_print(pLog, &quot;got non-InChI string)&quot;);</a>
<a name="ln1250">                                    break;</a>
<a name="ln1251">                                case INCHIKEY_NOT_ENOUGH_MEMORY:</a>
<a name="ln1252">                                    inchi_ios_print(pLog, &quot;not enough memory to treat the string)&quot;);</a>
<a name="ln1253">                                    break;</a>
<a name="ln1254">                                default:inchi_ios_print(pLog, &quot;internal program error)&quot;);</a>
<a name="ln1255">                                    break;</a>
<a name="ln1256">                            }</a>
<a name="ln1257">                            inchi_ios_print(pLog, &quot; structure #%-lu.\n&quot;, num_inp);</a>
<a name="ln1258">                            if ( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_TABBED_OUTPUT )</a>
<a name="ln1259">                                inchi_ios_print(pOut, &quot;\n&quot;);</a>
<a name="ln1260">                        } /* if (ip-&gt;bCalcInChIHash!=INCHIHASH_NONE) */</a>
<a name="ln1261"> </a>
<a name="ln1262">                </a>
<a name="ln1263">                        inchi_ios_flush(pOut);</a>
<a name="ln1264">                        inchi_ios_flush2(pLog, stderr);</a>
<a name="ln1265">            </a>
<a name="ln1266">                    } </a>
<a name="ln1267"> </a>
<a name="ln1268">                    else</a>
<a name="ln1269">                        inchi_ios_flush(pOut);</a>
<a name="ln1270">                } /* calculate InChIKey if requested */</a>
<a name="ln1271">#endif</a>
<a name="ln1272"> </a>
<a name="ln1273">                ip-&gt;bNoStructLabels = tmp;</a>
<a name="ln1274"> </a>
<a name="ln1275">#ifndef TARGET_API_LIB</a>
<a name="ln1276">                if ( ret &lt; 0 ) </a>
<a name="ln1277">                {</a>
<a name="ln1278">                    if ( szCurHdr &amp;&amp; szCurHdr[0] ) </a>
<a name="ln1279">                    {</a>
<a name="ln1280">                        inchi_ios_eprint( pLog, &quot;Error %d creating InChI string %s\n&quot;, ret, szCurHdr );</a>
<a name="ln1281">                    } </a>
<a name="ln1282">                    else </a>
<a name="ln1283">                    {</a>
<a name="ln1284">                        inchi_ios_eprint( pLog, &quot;Error %d creating InChI string, Structure %ld\n&quot;, ret, num_inp );</a>
<a name="ln1285">                    }</a>
<a name="ln1286">                    num_errors ++;</a>
<a name="ln1287">                } </a>
<a name="ln1288">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )                   </a>
<a name="ln1289">                else</a>
<a name="ln1290">                if ( szCurHdr &amp;&amp; szCurHdr[0] ) </a>
<a name="ln1291">                {</a>
<a name="ln1292">                    inchi_fprintf( stderr, &quot;%s\r&quot;, szCurHdr );</a>
<a name="ln1293">                }</a>
<a name="ln1294">#endif</a>
<a name="ln1295">#endif</a>
<a name="ln1296"> </a>
<a name="ln1297">                if ( szCurHdr ) </a>
<a name="ln1298">                {</a>
<a name="ln1299">                    inchi_free( szCurHdr );</a>
<a name="ln1300">                    szCurHdr = NULL;</a>
<a name="ln1301">                }</a>
<a name="ln1302">        </a>
<a name="ln1303">                INCHI_HEAPCHK</a>
<a name="ln1304">                ulProcessingTime += InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1305">        </a>
<a name="ln1306">            } /* if ( !bInChI2Structure &amp;&amp; bInChI2InChI )  */</a>
<a name="ln1307">        </a>
<a name="ln1308">            else </a>
<a name="ln1309">            {</a>
<a name="ln1310">                inchi_ios_eprint( pLog, &quot;\nWrong command line options: expected Inch2Struct or Inchi2Inchi\n&quot;, num_inp );</a>
<a name="ln1311">                break;</a>
<a name="ln1312">            }</a>
<a name="ln1313">    </a>
<a name="ln1314"> </a>
<a name="ln1315">            if ( nReadStatus == RI_ERR_EOF ) </a>
<a name="ln1316">            {</a>
<a name="ln1317">                break;</a>
<a name="ln1318">            }</a>
<a name="ln1319"> </a>
<a name="ln1320">        </a>
<a name="ln1321">        } /* InChI has been successfully read */</a>
<a name="ln1322">    </a>
<a name="ln1323">        else </a>
<a name="ln1324">    </a>
<a name="ln1325">        {</a>
<a name="ln1326">    </a>
<a name="ln1327">            /* InChI could not be read */</a>
<a name="ln1328">            if ( nReadStatus == RI_ERR_EOF &amp;&amp; nErr == 0 &amp;&amp; pState == 0 &amp;&amp; !strHdr ) </a>
<a name="ln1329">            {</a>
<a name="ln1330">                inchi_ios_eprint( pLog, &quot;\nEnd of file detected after structure %ld.    \n&quot;, num_inp );</a>
<a name="ln1331">            } </a>
<a name="ln1332">            else </a>
<a name="ln1333">            {</a>
<a name="ln1334">                /* output InChI parsing error message */</a>
<a name="ln1335">                char szHdrSimulation[128];</a>
<a name="ln1336">                num_inp ++;</a>
<a name="ln1337">                sprintf( szHdrSimulation, &quot;Structure: %ld&quot;, num_inp );</a>
<a name="ln1338">                inchi_ios_eprint( pLog, &quot;\n%s %s (%d) in %s (%d)\n&quot;, strHdr? strHdr : szHdrSimulation, getInchiErrName(nErr), nErr,  getInchiStateReadErr(pState), pState );</a>
<a name="ln1339">                num_errors ++;</a>
<a name="ln1340">                num_processed ++;</a>
<a name="ln1341">            }</a>
<a name="ln1342">            if ( strHdr ) </a>
<a name="ln1343">            {</a>
<a name="ln1344">                inchi_free( strHdr );</a>
<a name="ln1345">                strHdr = NULL;</a>
<a name="ln1346">            }</a>
<a name="ln1347">            if ( szCurHdr ) </a>
<a name="ln1348">            {</a>
<a name="ln1349">                inchi_free( szCurHdr );</a>
<a name="ln1350">                szCurHdr = NULL;</a>
<a name="ln1351">            }</a>
<a name="ln1352">            FreeInpInChI( &amp;OneInput );</a>
<a name="ln1353">        }</a>
<a name="ln1354"> </a>
<a name="ln1355"> </a>
<a name="ln1356">#ifdef TARGET_EXE_STANDALONE</a>
<a name="ln1357">#ifndef TARGET_API_LIB</a>
<a name="ln1358">        inchi_ios_flush(pOut);</a>
<a name="ln1359">        inchi_ios_flush2(pLog, stderr);</a>
<a name="ln1360">#endif</a>
<a name="ln1361">#endif</a>
<a name="ln1362"> </a>
<a name="ln1363"> </a>
<a name="ln1364">#ifdef TARGET_API_LIB</a>
<a name="ln1365">        break;  /* exit after the 1st structure */</a>
<a name="ln1366">#endif</a>
<a name="ln1367"> </a>
<a name="ln1368">    </a>
<a name="ln1369">    } /* while */</a>
<a name="ln1370"> </a>
<a name="ln1371"> </a>
<a name="ln1372"> </a>
<a name="ln1373"> </a>
<a name="ln1374">exit_error:</a>
<a name="ln1375"> </a>
<a name="ln1376">    FreeInpInChI( &amp;OneInput );</a>
<a name="ln1377">    if ( strHdr ) </a>
<a name="ln1378">    {</a>
<a name="ln1379">        inchi_free( strHdr );</a>
<a name="ln1380">        strHdr = NULL;</a>
<a name="ln1381">    }</a>
<a name="ln1382">    if ( pLine-&gt;str ) </a>
<a name="ln1383">    {</a>
<a name="ln1384">        inchi_free( pLine-&gt;str );</a>
<a name="ln1385">    }</a>
<a name="ln1386">    if ( szCurHdr ) </a>
<a name="ln1387">    {</a>
<a name="ln1388">        inchi_free( szCurHdr );</a>
<a name="ln1389">        szCurHdr = NULL;</a>
<a name="ln1390">    }</a>
<a name="ln1391">    </a>
<a name="ln1392">    INCHI_HEAPCHK</a>
<a name="ln1393"> </a>
<a name="ln1394">    if ( sd_inp ) </a>
<a name="ln1395">    {</a>
<a name="ln1396">        sd_inp-&gt;ulStructTime = ulProcessingTime;</a>
<a name="ln1397">        sd_inp-&gt;fPtrStart    = num_processed;</a>
<a name="ln1398">        sd_inp-&gt;fPtrEnd      = num_errors;</a>
<a name="ln1399">    }</a>
<a name="ln1400">    return ret;</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">/**********************************************************************************************/</a>
<a name="ln1406">int OutputInChIAsRequested(INCHI_IOSTREAM *pOut, INCHI_IOSTREAM *pLog, </a>
<a name="ln1407">                           ICHICONST INPUT_PARMS *ip_inp, </a>
<a name="ln1408">                           STRUCT_DATA *sd_inp, </a>
<a name="ln1409">                           InpInChI *OneInput, </a>
<a name="ln1410">                           int num_components[INCHI_NUM],</a>
<a name="ln1411">                           MODE_PIXH nModeProtonIsoExchgH[INCHI_NUM], </a>
<a name="ln1412">                           long num_inp, unsigned char save_opt_bits)</a>
<a name="ln1413">{</a>
<a name="ln1414">    int      j, k, k1, k2, ret2=0, iINChI, iINChI1, iINChI2;</a>
<a name="ln1415">    PINChI2 *pINChI[INCHI_NUM];</a>
<a name="ln1416">    PINChI_Aux2 *pINChI_Aux[INCHI_NUM];</a>
<a name="ln1417">    int bReqNonTaut;</a>
<a name="ln1418">    int bHasSomeReconnected;</a>
<a name="ln1419"> </a>
<a name="ln1420">    INPUT_PARMS ip_local;</a>
<a name="ln1421">    STRUCT_DATA sd_local;</a>
<a name="ln1422">    INPUT_PARMS *ip = &amp;ip_local;</a>
<a name="ln1423">    STRUCT_DATA *sd = &amp;sd_local;</a>
<a name="ln1424">    NORM_CANON_FLAGS ncFlags;</a>
<a name="ln1425">    NORM_CANON_FLAGS *pncFlags = &amp;ncFlags;</a>
<a name="ln1426">    const int nStrLen = NSTRLEN;</a>
<a name="ln1427">    char *pStr = NULL;</a>
<a name="ln1428">    int  nRet1, bSortPrintINChIFlags;</a>
<a name="ln1429">    int  bReqSplitOutputInChI;</a>
<a name="ln1430">    int  nNumOutputComponents;</a>
<a name="ln1431">    </a>
<a name="ln1432">    nRet1   = 0;</a>
<a name="ln1433">    k1 = k2 = 0;</a>
<a name="ln1434">    memset( pncFlags, 0, sizeof(*pncFlags) );</a>
<a name="ln1435">    memset( pINChI, 0, sizeof(pINChI) );</a>
<a name="ln1436">    memset( pINChI_Aux, 0, sizeof(pINChI_Aux) );</a>
<a name="ln1437"> </a>
<a name="ln1438">    *ip = *ip_inp;</a>
<a name="ln1439">    *sd = *sd_inp;</a>
<a name="ln1440">    bHasSomeReconnected = 0;</a>
<a name="ln1441">    bSortPrintINChIFlags = 0;</a>
<a name="ln1442">    nNumOutputComponents = 0;</a>
<a name="ln1443">    bReqNonTaut = (0 != (ip-&gt;nMode &amp; REQ_MODE_BASIC));</a>
<a name="ln1444">    bReqSplitOutputInChI = (0 != (ip-&gt;bReadInChIOptions &amp; READ_INCHI_SPLIT_OUTPUT));</a>
<a name="ln1445"> </a>
<a name="ln1446">    INCHI_HEAPCHK</a>
<a name="ln1447"> </a>
<a name="ln1448">    if ( num_components[INCHI_BAS] ) </a>
<a name="ln1449">    {</a>
<a name="ln1450">        MYREALLOC2(PINChI2, PINChI_Aux2, pINChI[INCHI_BAS], pINChI_Aux[INCHI_BAS], num_components[INCHI_BAS], num_components[INCHI_BAS], k1);</a>
<a name="ln1451">    }</a>
<a name="ln1452">    if ( num_components[INCHI_REC] ) </a>
<a name="ln1453">    {</a>
<a name="ln1454">        MYREALLOC2(PINChI2, PINChI_Aux2, pINChI[INCHI_REC], pINChI_Aux[INCHI_REC], num_components[INCHI_REC], num_components[INCHI_REC], k2);</a>
<a name="ln1455">    }</a>
<a name="ln1456">    pStr = (char*) inchi_malloc( nStrLen * sizeof(pStr[0]) );</a>
<a name="ln1457"> </a>
<a name="ln1458">    INCHI_HEAPCHK</a>
<a name="ln1459"> </a>
<a name="ln1460">    if ( k1 || k2 || !pStr ) </a>
<a name="ln1461">    {</a>
<a name="ln1462">        ret2 = RI_ERR_ALLOC;</a>
<a name="ln1463">        goto exit_error;</a>
<a name="ln1464">    }</a>
<a name="ln1465">    </a>
<a name="ln1466">    if ( num_components[INCHI_REC] &amp;&amp;</a>
<a name="ln1467">         (ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD) &amp;&amp;</a>
<a name="ln1468">         (ip-&gt;bTautFlags &amp; TG_FLAG_DISCONNECT_COORD) ) </a>
<a name="ln1469">    {</a>
<a name="ln1470">        sd-&gt;bTautFlagsDone[0] |= TG_FLAG_DISCONNECT_COORD_DONE;</a>
<a name="ln1471">        bHasSomeReconnected = 1;</a>
<a name="ln1472">    }</a>
<a name="ln1473"> </a>
<a name="ln1474"> </a>
<a name="ln1475">    for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) </a>
<a name="ln1476">    {</a>
<a name="ln1477">        for ( j = 0; j &lt; TAUT_NUM; j ++ ) </a>
<a name="ln1478">        {</a>
<a name="ln1479">            if ( bReqNonTaut || (j != TAUT_NON &amp;&amp; OneInput-&gt;pInpInChI[iINChI][j]) )</a>
<a name="ln1480">            {</a>
<a name="ln1481">                for ( k = 0; k &lt; num_components[iINChI]; k ++ ) </a>
<a name="ln1482">                {</a>
<a name="ln1483">                    /* allocate InChI &amp; AuxInfo */</a>
<a name="ln1484">                    if ( !(pINChI[iINChI][k][j] = (INChI *) inchi_calloc(1, sizeof(INChI)) ) ) </a>
<a name="ln1485">                    {</a>
<a name="ln1486">                        ret2 = RI_ERR_ALLOC;</a>
<a name="ln1487">                        goto exit_error;</a>
<a name="ln1488">                    }</a>
<a name="ln1489">                    if ( !(pINChI_Aux[iINChI][k][j] = (INChI_Aux *) inchi_calloc(1, sizeof(INChI_Aux)) ) ) </a>
<a name="ln1490">                    {</a>
<a name="ln1491">                        ret2 = RI_ERR_ALLOC;</a>
<a name="ln1492">                        goto exit_error;</a>
<a name="ln1493">                    }</a>
<a name="ln1494">                    /* copy InChI &amp; AuxInfo */</a>
<a name="ln1495">                    if ( k &lt; OneInput-&gt;nNumComponents[iINChI][j] ) </a>
<a name="ln1496">                    {</a>
<a name="ln1497"> </a>
<a name="ln1498">                        /* copy InChI */</a>
<a name="ln1499">                        *pINChI[iINChI][k][j] = OneInput-&gt;pInpInChI[iINChI][j][k];</a>
<a name="ln1500">                        memset(&amp;OneInput-&gt;pInpInChI[iINChI][j][k], 0, sizeof(OneInput-&gt;pInpInChI[iINChI][j][k]));</a>
<a name="ln1501">                        INCHI_HEAPCHK</a>
<a name="ln1502">                        /* take care of protons in AuxInfo */</a>
<a name="ln1503"> </a>
<a name="ln1504">                        if ( nModeProtonIsoExchgH[iINChI] == MODE_PIXH_ADD_TO_EACH &amp;&amp; j == TAUT_YES ) </a>
<a name="ln1505">                        {</a>
<a name="ln1506">                            pINChI_Aux[iINChI][k][j]-&gt;nNumRemovedProtons = </a>
<a name="ln1507">                                   OneInput-&gt;nNumProtons[iINChI][j].pNumProtons[k].nNumRemovedProtons;</a>
<a name="ln1508">                            for ( k1 = 0; k1 &lt; NUM_H_ISOTOPES; k1 ++ ) </a>
<a name="ln1509">                            {</a>
<a name="ln1510">                                pINChI_Aux[iINChI][k][j]-&gt;nNumRemovedIsotopicH[k1] =</a>
<a name="ln1511">                                    OneInput-&gt;nNumProtons[iINChI][j].pNumProtons[k].nNumRemovedIsotopicH[k1];</a>
<a name="ln1512">                            }</a>
<a name="ln1513">                            INCHI_HEAPCHK</a>
<a name="ln1514">                        } </a>
<a name="ln1515">                        else if ( (!k &amp;&amp; nModeProtonIsoExchgH[iINChI] == MODE_PIXH_ADD_TO_FIRST) ||</a>
<a name="ln1516">                             (k+1 == OneInput-&gt;nNumComponents[iINChI][j] &amp;&amp;</a>
<a name="ln1517">                             nModeProtonIsoExchgH[iINChI] == MODE_PIXH_ADD_A_PIXH_COMPONENT) ) </a>
<a name="ln1518">                        {</a>
<a name="ln1519">                            /* add protons and exchangeable isotopic H to the first component's AuxInfo */</a>
<a name="ln1520">                            pINChI_Aux[iINChI][k][j]-&gt;nNumRemovedProtons = OneInput-&gt;nNumProtons[iINChI][j].nNumRemovedProtons;</a>
<a name="ln1521">                            for ( k1 = 0; k1 &lt; NUM_H_ISOTOPES; k1 ++ ) </a>
<a name="ln1522">                            {</a>
<a name="ln1523">                                pINChI_Aux[iINChI][k][j]-&gt;nNumRemovedIsotopicH[k1] =</a>
<a name="ln1524">                                    OneInput-&gt;nNumProtons[iINChI][j].nNumRemovedIsotopicH[k1];</a>
<a name="ln1525">                            }</a>
<a name="ln1526">                            INCHI_HEAPCHK</a>
<a name="ln1527">                        } </a>
<a name="ln1528">                        else </a>
<a name="ln1529">                        {</a>
<a name="ln1530">                            pINChI_Aux[iINChI][k][j]-&gt;bDeleted = pINChI[iINChI][k][j]-&gt;bDeleted;</a>
<a name="ln1531">                        }</a>
<a name="ln1532"> </a>
<a name="ln1533">                        if ( j == TAUT_YES &amp;&amp; pINChI[iINChI][k][j] &amp;&amp; pINChI[iINChI][k][j]-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln1534">                             !pINChI[iINChI][k][j]-&gt;nNum_H_fixed ) </a>
<a name="ln1535">                        {</a>
<a name="ln1536">                            /* serializer crashes if it is not allocated */</a>
<a name="ln1537">                            pINChI[iINChI][k][j]-&gt;nNum_H_fixed = (S_CHAR *)inchi_calloc(pINChI[iINChI][k][j]-&gt;nNumberOfAtoms+1, sizeof(pINChI[0][0][0]-&gt;nNum_H_fixed[0]) );</a>
<a name="ln1538">                        }</a>
<a name="ln1539"> </a>
<a name="ln1540">                        if ( j == TAUT_YES &amp;&amp; k &lt; OneInput-&gt;nNumComponents[iINChI][TAUT_NON] &amp;&amp;</a>
<a name="ln1541">                             pINChI[iINChI][k][j] &amp;&amp; pINChI[iINChI][k][j]-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln1542">                             pINChI[iINChI][k][TAUT_NON] &amp;&amp; pINChI[iINChI][k][TAUT_NON]-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln1543">                             !CompareReversedINChI( pINChI[iINChI][k][j], pINChI[iINChI][k][TAUT_NON], NULL, NULL ) ) {</a>
<a name="ln1544">                            pINChI[iINChI][k][TAUT_NON]-&gt;nNumberOfAtoms = 0; /* eliminate non-taut equal to taut */</a>
<a name="ln1545">                        }</a>
<a name="ln1546">                             </a>
<a name="ln1547"> </a>
<a name="ln1548">                    } </a>
<a name="ln1549">                    else </a>
<a name="ln1550">                    {</a>
<a name="ln1551">                        /* extra component, usually it is a Mobile H component */</a>
<a name="ln1552">                        /* corresponding to a free proton component in Fixed H */</a>
<a name="ln1553">                        pINChI[iINChI][k][j]-&gt;bDeleted = 1;</a>
<a name="ln1554">                        pINChI_Aux[iINChI][k][j]-&gt;bDeleted = 1;</a>
<a name="ln1555">                    }</a>
<a name="ln1556"> </a>
<a name="ln1557">                } /* k */</a>
<a name="ln1558"> </a>
<a name="ln1559">            } /* if ( bReqNonTaut || j != TAUT_NON &amp;&amp; OneInput-&gt;pInpInChI[iINChI][j] )  */</a>
<a name="ln1560"> </a>
<a name="ln1561">            if ( OneInput-&gt;pInpInChI[iINChI][j] ) </a>
<a name="ln1562">            {</a>
<a name="ln1563">                INCHI_HEAPCHK</a>
<a name="ln1564">                inchi_free(OneInput-&gt;pInpInChI[iINChI][j]);</a>
<a name="ln1565">                OneInput-&gt;pInpInChI[iINChI][j] = NULL;</a>
<a name="ln1566">            }</a>
<a name="ln1567">        </a>
<a name="ln1568">        } /* j */</a>
<a name="ln1569"> </a>
<a name="ln1570">    } /* iINChI */</a>
<a name="ln1571">    </a>
<a name="ln1572">    if ( bReqSplitOutputInChI ) </a>
<a name="ln1573">    {</a>
<a name="ln1574">        if ( bHasSomeReconnected ) </a>
<a name="ln1575">        {</a>
<a name="ln1576">            iINChI1 = INCHI_REC; /* only reconnected */</a>
<a name="ln1577">            iINChI2 = INCHI_NUM;</a>
<a name="ln1578">            sd-&gt;num_components[INCHI_BAS] = sd-&gt;num_components[INCHI_REC];</a>
<a name="ln1579">        } </a>
<a name="ln1580">        else </a>
<a name="ln1581">        {</a>
<a name="ln1582">            iINChI1 = 0;         /* only disconnected */</a>
<a name="ln1583">            iINChI2 = iINChI1+1;</a>
<a name="ln1584">        }</a>
<a name="ln1585">        sd-&gt;num_components[INCHI_REC] = 0;  /* treat reconnected as connected */</a>
<a name="ln1586">        nNumOutputComponents = sd-&gt;num_components[INCHI_BAS];</a>
<a name="ln1587">    } </a>
<a name="ln1588">    else </a>
<a name="ln1589">    {</a>
<a name="ln1590">        iINChI1 = 0;</a>
<a name="ln1591">        iINChI2 = INCHI_NUM;</a>
<a name="ln1592">        nNumOutputComponents = 1;</a>
<a name="ln1593">    }</a>
<a name="ln1594"> </a>
<a name="ln1595"> </a>
<a name="ln1596">    for ( k1 = 0, k2 = (bReqSplitOutputInChI? k1+1 : nNumOutputComponents); k1 &lt; k2 &amp;&amp; k1 &lt; nNumOutputComponents; k1=k2, k2 ++ ) </a>
<a name="ln1597">    {</a>
<a name="ln1598"> </a>
<a name="ln1599">        if ( bReqSplitOutputInChI ) </a>
<a name="ln1600">        {</a>
<a name="ln1601">            sd-&gt;num_components[INCHI_BAS] = 1;</a>
<a name="ln1602">            sd-&gt;num_components[INCHI_REC] = 0;</a>
<a name="ln1603">            /* additional data */</a>
<a name="ln1604">            sd-&gt;num_non_taut[INCHI_BAS] =</a>
<a name="ln1605">            sd-&gt;num_taut[INCHI_BAS]     =</a>
<a name="ln1606">            sd-&gt;num_non_taut[INCHI_REC] =</a>
<a name="ln1607">            sd-&gt;num_taut[INCHI_REC]     = 0;</a>
<a name="ln1608">            iINChI = iINChI1;</a>
<a name="ln1609">            for ( j = 0; j &lt; TAUT_NUM &amp;&amp; sd-&gt;num_components[iINChI]; j ++ ) </a>
<a name="ln1610">            {</a>
<a name="ln1611">                for ( k = k1; k &lt; k2; k ++ ) </a>
<a name="ln1612">                {</a>
<a name="ln1613">                    /*  find where the current processed structure is located */</a>
<a name="ln1614">                    int cur_is_in_non_taut = (pINChI[iINChI][k][TAUT_NON] &amp;&amp; pINChI[iINChI][k][TAUT_NON]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln1615">                    int cur_is_in_taut     = (pINChI[iINChI][k][TAUT_YES] &amp;&amp; pINChI[iINChI][k][TAUT_YES]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln1616">                    int cur_is_non_taut = (cur_is_in_non_taut &amp;&amp; 0 == pINChI[iINChI][k][TAUT_NON]-&gt;lenTautomer) ||</a>
<a name="ln1617">                                          (cur_is_in_taut     &amp;&amp; 0 == pINChI[iINChI][k][TAUT_YES]-&gt;lenTautomer);</a>
<a name="ln1618">                    int cur_is_taut     = cur_is_in_taut     &amp;&amp; 0 &lt;  pINChI[iINChI][k][TAUT_YES]-&gt;lenTautomer;</a>
<a name="ln1619">                    if ( cur_is_non_taut + cur_is_taut ) </a>
<a name="ln1620">                    {</a>
<a name="ln1621">                        /*  count tautomeric and non-tautomeric components of the structures */</a>
<a name="ln1622">                        /*</a>
<a name="ln1623">                        int j1 = cur_is_in_non_taut? TAUT_NON:TAUT_YES;</a>
<a name="ln1624">                        int j2 = cur_is_in_taut?     TAUT_YES:TAUT_NON;</a>
<a name="ln1625">                        */</a>
<a name="ln1626">                        sd-&gt;num_non_taut[INCHI_BAS] += cur_is_non_taut;</a>
<a name="ln1627">                        sd-&gt;num_taut[INCHI_BAS]     += cur_is_taut;</a>
<a name="ln1628">                    }</a>
<a name="ln1629">                }</a>
<a name="ln1630">            }</a>
<a name="ln1631">            INCHI_HEAPCHK</a>
<a name="ln1632">        } </a>
<a name="ln1633">        else </a>
<a name="ln1634">        {</a>
<a name="ln1635">            sd-&gt;num_components[INCHI_BAS] = inchi_max( OneInput-&gt;nNumComponents[INCHI_BAS][TAUT_YES],</a>
<a name="ln1636">                                                       OneInput-&gt;nNumComponents[INCHI_BAS][TAUT_NON] );</a>
<a name="ln1637">            sd-&gt;num_components[INCHI_REC] = inchi_max( OneInput-&gt;nNumComponents[INCHI_REC][TAUT_YES],</a>
<a name="ln1638">                                                       OneInput-&gt;nNumComponents[INCHI_REC][TAUT_NON] );</a>
<a name="ln1639">        </a>
<a name="ln1640">            /* additional data needed for SortAndPrintINChI() */</a>
<a name="ln1641">            for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) </a>
<a name="ln1642">            {</a>
<a name="ln1643">                sd-&gt;num_non_taut[iINChI] =</a>
<a name="ln1644">                sd-&gt;num_taut[iINChI]     = 0;</a>
<a name="ln1645">                for ( j = 0; j &lt; TAUT_NUM &amp;&amp; sd-&gt;num_components[iINChI]; j ++ ) </a>
<a name="ln1646">                {</a>
<a name="ln1647">                    for ( k = k1; k &lt; k2; k ++ ) </a>
<a name="ln1648">                    {</a>
<a name="ln1649">                        /*  find where the current processed structure is located */</a>
<a name="ln1650">                        int cur_is_in_non_taut = (pINChI[iINChI][k][TAUT_NON] &amp;&amp; pINChI[iINChI][k][TAUT_NON]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln1651">                        int cur_is_in_taut     = (pINChI[iINChI][k][TAUT_YES] &amp;&amp; pINChI[iINChI][k][TAUT_YES]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln1652">                        int cur_is_non_taut = (cur_is_in_non_taut &amp;&amp; 0 == pINChI[iINChI][k][TAUT_NON]-&gt;lenTautomer) ||</a>
<a name="ln1653">                                              (cur_is_in_taut     &amp;&amp; 0 == pINChI[iINChI][k][TAUT_YES]-&gt;lenTautomer);</a>
<a name="ln1654">                        int cur_is_taut     = cur_is_in_taut     &amp;&amp; 0 &lt;  pINChI[iINChI][k][TAUT_YES]-&gt;lenTautomer;</a>
<a name="ln1655">                        if ( cur_is_non_taut + cur_is_taut ) {</a>
<a name="ln1656">                            /*  count tautomeric and non-tautomeric components of the structures */</a>
<a name="ln1657">                            /*</a>
<a name="ln1658">                            int j1 = cur_is_in_non_taut? TAUT_NON:TAUT_YES;</a>
<a name="ln1659">                            int j2 = cur_is_in_taut?     TAUT_YES:TAUT_NON;</a>
<a name="ln1660">                            */</a>
<a name="ln1661">                            sd-&gt;num_non_taut[iINChI] += cur_is_non_taut;</a>
<a name="ln1662">                            sd-&gt;num_taut[iINChI]     += cur_is_taut;</a>
<a name="ln1663">                        }</a>
<a name="ln1664">                    }</a>
<a name="ln1665">                }</a>
<a name="ln1666">            }</a>
<a name="ln1667">            INCHI_HEAPCHK</a>
<a name="ln1668">        }</a>
<a name="ln1669">        if ( bReqSplitOutputInChI ) </a>
<a name="ln1670">        {</a>
<a name="ln1671">            /* output components one by one (for splitting input InChI into components) */</a>
<a name="ln1672">            PINChI2 *pInChI_2[INCHI_NUM];</a>
<a name="ln1673">            PINChI_Aux2 *pInChI_Aux_2[INCHI_NUM];</a>
<a name="ln1674">            INChI *pInChI_1[1][2];</a>
<a name="ln1675">            INChI_Aux *pInChI_Aux_1[1][2];</a>
<a name="ln1676">            memset( pInChI_2, 0, sizeof(pInChI_2) );</a>
<a name="ln1677">            memset( pInChI_Aux_2, 0, sizeof(pInChI_Aux_2) );</a>
<a name="ln1678"> </a>
<a name="ln1679">            for ( j = 0; j &lt; TAUT_NUM; j ++ ) </a>
<a name="ln1680">            {</a>
<a name="ln1681">                pInChI_1[0][j]     = pINChI[iINChI1][k1][j];</a>
<a name="ln1682">                pInChI_Aux_1[0][j] = pINChI_Aux[iINChI1][k1][j];</a>
<a name="ln1683">            }</a>
<a name="ln1684">            pInChI_2[INCHI_BAS]     = pInChI_1;</a>
<a name="ln1685">            pInChI_Aux_2[INCHI_BAS] = pInChI_Aux_1;</a>
<a name="ln1686">            /* make sure purely reconnected InChI is marked as ReChI, not InChI */</a>
<a name="ln1687">            if ( bHasSomeReconnected &amp;&amp;</a>
<a name="ln1688">                 (bInChIHasReconnectedMetal( pInChI_1[0][TAUT_YES] ) ||</a>
<a name="ln1689">                  bInChIHasReconnectedMetal( pInChI_1[0][TAUT_NON] ) ) ) </a>
<a name="ln1690">            {</a>
<a name="ln1691">                bSortPrintINChIFlags = FLAG_SORT_PRINT_ReChI_PREFIX;</a>
<a name="ln1692">            } </a>
<a name="ln1693">            else </a>
<a name="ln1694">            {</a>
<a name="ln1695">                bSortPrintINChIFlags = 0;</a>
<a name="ln1696">            }</a>
<a name="ln1697">            INCHI_HEAPCHK</a>
<a name="ln1698">            nRet1 = SortAndPrintINChI(pOut, pStr, nStrLen, pLog, ip, NULL /*orig_inp_data*/, NULL  /*prep_inp_data*/,</a>
<a name="ln1699">                                      NULL /*composite_norm_data*/, NULL /*pOrigStruct*/,</a>
<a name="ln1700">                                      sd-&gt;num_components, sd-&gt;num_non_taut, sd-&gt;num_taut,</a>
<a name="ln1701">                                      sd-&gt;bTautFlags, sd-&gt;bTautFlagsDone, pncFlags, num_inp,</a>
<a name="ln1702">                                      pInChI_2, pInChI_Aux_2, &amp;bSortPrintINChIFlags,</a>
<a name="ln1703">                                      save_opt_bits);</a>
<a name="ln1704">            INCHI_HEAPCHK</a>
<a name="ln1705">        } </a>
<a name="ln1706">        else </a>
<a name="ln1707">        {</a>
<a name="ln1708">            INCHI_HEAPCHK</a>
<a name="ln1709">            bSortPrintINChIFlags = 0;</a>
<a name="ln1710">            nRet1 = SortAndPrintINChI(pOut, pStr, nStrLen, pLog, ip, NULL /*orig_inp_data*/, NULL  /*prep_inp_data*/,</a>
<a name="ln1711">                                      NULL /*composite_norm_data*/, NULL /*pOrigStruct*/,</a>
<a name="ln1712">                                      sd-&gt;num_components, sd-&gt;num_non_taut, sd-&gt;num_taut,</a>
<a name="ln1713">                                      sd-&gt;bTautFlags, sd-&gt;bTautFlagsDone, pncFlags, num_inp,</a>
<a name="ln1714">                                      pINChI, pINChI_Aux, &amp;bSortPrintINChIFlags,</a>
<a name="ln1715">                                      save_opt_bits);</a>
<a name="ln1716">            INCHI_HEAPCHK</a>
<a name="ln1717">        }</a>
<a name="ln1718">        if ( nRet1 == _IS_FATAL || nRet1 == _IS_ERROR ) </a>
<a name="ln1719">        {</a>
<a name="ln1720">            break;</a>
<a name="ln1721">        }</a>
<a name="ln1722">    }</a>
<a name="ln1723"> </a>
<a name="ln1724"> </a>
<a name="ln1725">    INCHI_HEAPCHK</a>
<a name="ln1726">    FreeAllINChIArrays( pINChI, pINChI_Aux, num_components );</a>
<a name="ln1727">    INCHI_HEAPCHK</a>
<a name="ln1728">    </a>
<a name="ln1729">    for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) </a>
<a name="ln1730">    {</a>
<a name="ln1731">        for ( j = 0; j &lt; TAUT_NUM; j ++ ) </a>
<a name="ln1732">        {</a>
<a name="ln1733">            if ( OneInput-&gt;nNumProtons[iINChI][j].pNumProtons ) </a>
<a name="ln1734">            {</a>
<a name="ln1735">                inchi_free( OneInput-&gt;nNumProtons[iINChI][j].pNumProtons );</a>
<a name="ln1736">                OneInput-&gt;nNumProtons[iINChI][j].pNumProtons = NULL;</a>
<a name="ln1737">            }</a>
<a name="ln1738">        }</a>
<a name="ln1739">    }</a>
<a name="ln1740"> </a>
<a name="ln1741">    INCHI_HEAPCHK</a>
<a name="ln1742">    if ( nRet1 == _IS_FATAL || nRet1 == _IS_ERROR ) </a>
<a name="ln1743">    {</a>
<a name="ln1744">        ret2 = RI_ERR_PROGR;</a>
<a name="ln1745">    }</a>
<a name="ln1746"> </a>
<a name="ln1747">exit_error:</a>
<a name="ln1748">    if ( pStr ) </a>
<a name="ln1749">        inchi_free( pStr );</a>
<a name="ln1750">    return ret2;</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">/**************************************************************************************/</a>
<a name="ln1754">int GetNumNeighborsFromInchi( INChI *pInChI, AT_NUMB nAtNumber )</a>
<a name="ln1755">{</a>
<a name="ln1756">    int i, j, n_vertex, n_neigh, nNumNeigh, bTautAtom, nNumH, nTotNumNeigh, num_atoms;</a>
<a name="ln1757">    AT_NUMB  taut_at_number;</a>
<a name="ln1758">    nAtNumber -= 1;</a>
<a name="ln1759">    nNumNeigh = 0; /* number of bonds */</a>
<a name="ln1760">    bTautAtom = 0; /* 1 if atom belongs to a Mobile-H group */</a>
<a name="ln1761">    nNumH     = 0; /* number of terminal neighbors H */</a>
<a name="ln1762">    num_atoms = pInChI-&gt;nNumberOfAtoms;</a>
<a name="ln1763">    /* from RestoreAtomConnectionsSetStereo() */</a>
<a name="ln1764">    /* Connection table structure: </a>
<a name="ln1765">       Vert(1) [, Neigh(11), Neigh(12),...], Vert(2) [, Neigh(2,1), Neigh(2,2),...] ...</a>
<a name="ln1766">       where Neigh(i,1) &lt; Neigh(i,2) &lt;... &lt; Vert(i);</a>
<a name="ln1767">             Vert(i) &lt; Vert(i+1)</a>
<a name="ln1768">     */</a>
<a name="ln1769">    for ( i = 1, n_vertex = pInChI-&gt;nConnTable[0]-1; i &lt; pInChI-&gt;lenConnTable; i ++ ) {</a>
<a name="ln1770">        if ( (n_neigh = pInChI-&gt;nConnTable[i]-1) &lt; n_vertex ) {</a>
<a name="ln1771">            /*  vertex - neighbor connection */</a>
<a name="ln1772">            nNumNeigh += ( nAtNumber == n_vertex || nAtNumber == n_neigh );</a>
<a name="ln1773">        } else</a>
<a name="ln1774">        /* n_neigh is the next vertex */</a>
<a name="ln1775">        if ( (n_vertex = n_neigh) &gt;= num_atoms ) {</a>
<a name="ln1776">            return  RI_ERR_PROGR;</a>
<a name="ln1777">        }</a>
<a name="ln1778">    }</a>
<a name="ln1779">    /* is atom tautomeric, from GetTgroupInfoFromInChI() */</a>
<a name="ln1780">    if ( pInChI &amp;&amp; pInChI-&gt;lenTautomer &gt; 1 &amp;&amp; pInChI-&gt;nTautomer &amp;&amp; pInChI-&gt;nTautomer[0] &gt; 0 ) {</a>
<a name="ln1781">        int itg, len_tg;</a>
<a name="ln1782">        int tot_len_tg = pInChI-&gt;lenTautomer - T_GROUP_HDR_LEN*pInChI-&gt;nTautomer[0] - 1; /* number of endpoints */</a>
<a name="ln1783">        j = 1; /* index in pInChI-&gt;nTautomer[] */</a>
<a name="ln1784">        i = 0; /* index in ti-&gt;nEndpointAtomNumber[] */</a>
<a name="ln1785">        for ( itg = 0; itg &lt; pInChI-&gt;nTautomer[0]; itg ++ ) {</a>
<a name="ln1786">            len_tg = pInChI-&gt;nTautomer[j]; /* t-group length not including pInChI-&gt;nTautomer[j] */</a>
<a name="ln1787">            j      += T_GROUP_HDR_LEN;   /* skip t-group header */</a>
<a name="ln1788">            len_tg -= T_GROUP_HDR_LEN-1;</a>
<a name="ln1789">            for( ; 0 &lt; len_tg --; j ++, i ++ ) {</a>
<a name="ln1790">                taut_at_number = pInChI-&gt;nTautomer[j]-1; /* Mobile-H group atom number */</a>
<a name="ln1791">                bTautAtom += (taut_at_number == nAtNumber);</a>
<a name="ln1792">            }</a>
<a name="ln1793">        }</a>
<a name="ln1794">        if ( i != tot_len_tg ) {</a>
<a name="ln1795">            return RI_ERR_PROGR;</a>
<a name="ln1796">        }</a>
<a name="ln1797">    }</a>
<a name="ln1798">    /* count hydrogen neighbors */</a>
<a name="ln1799">    if ( pInChI-&gt;nNum_H ) {</a>
<a name="ln1800">        nNumH = pInChI-&gt;nNum_H[nAtNumber];</a>
<a name="ln1801">    }</a>
<a name="ln1802">    /* conclusion: if not tautomeric then return positive number, otherwise add 1000 */</a>
<a name="ln1803">    nTotNumNeigh = nNumNeigh + nNumH;</a>
<a name="ln1804">    if ( bTautAtom ) {</a>
<a name="ln1805">        nTotNumNeigh += 1000;</a>
<a name="ln1806">    }</a>
<a name="ln1807">    return nTotNumNeigh;</a>
<a name="ln1808">}</a>
<a name="ln1809">/**************************************************************************************/</a>
<a name="ln1810">int CountStereoTypes( INChI *pInChI, int *num_known_SB, int *num_known_SC,</a>
<a name="ln1811">                                     int *num_unk_und_SB, int *num_unk_und_SC,</a>
<a name="ln1812">                                     int *num_SC_PIII, int *num_SC_AsIII)</a>
<a name="ln1813">{</a>
<a name="ln1814">    static U_CHAR el_number_P=0, el_number_As=0;</a>
<a name="ln1815">    INChI_Stereo *Stereo;</a>
<a name="ln1816">    int           i, ret;</a>
<a name="ln1817">    AT_NUMB       nAtNumber;</a>
<a name="ln1818">    U_CHAR        el_number;</a>
<a name="ln1819">    if ( !pInChI-&gt;nNumberOfAtoms || pInChI-&gt;bDeleted ) {</a>
<a name="ln1820">        return 0; /* no InChI */</a>
<a name="ln1821">    }</a>
<a name="ln1822">    Stereo = (pInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln1823">         (pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds +</a>
<a name="ln1824">         pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters ))? pInChI-&gt;StereoIsotopic:</a>
<a name="ln1825">                           (pInChI-&gt;Stereo &amp;&amp;</a>
<a name="ln1826">         (pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds +</a>
<a name="ln1827">         pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters ))? pInChI-&gt;Stereo : NULL;</a>
<a name="ln1828">    if ( !Stereo ) {</a>
<a name="ln1829">        return 1; /* No Stereo */</a>
<a name="ln1830">    }</a>
<a name="ln1831">    /* one-time initialization */</a>
<a name="ln1832">    if ( !el_number_P ) {</a>
<a name="ln1833">        el_number_P  = (U_CHAR)get_periodic_table_number( &quot;P&quot; );</a>
<a name="ln1834">        el_number_As = (U_CHAR)get_periodic_table_number( &quot;As&quot; );</a>
<a name="ln1835">    }</a>
<a name="ln1836">    /* count SB and cumulenes */</a>
<a name="ln1837">    for ( i = 0; i &lt; Stereo-&gt;nNumberOfStereoBonds; i ++ ) {</a>
<a name="ln1838">        if ( ATOM_PARITY_WELL_DEF(Stereo-&gt;b_parity[i]) ) {</a>
<a name="ln1839">            (*num_known_SB) ++;</a>
<a name="ln1840">        } else {</a>
<a name="ln1841">            (*num_unk_und_SB) ++;</a>
<a name="ln1842">        }</a>
<a name="ln1843">    }</a>
<a name="ln1844">    /* count SC and allenes */</a>
<a name="ln1845">    for ( i = 0; i &lt; Stereo-&gt;nNumberOfStereoCenters; i ++ ) {</a>
<a name="ln1846">        if ( !(nAtNumber = Stereo-&gt;nNumber[i]) || nAtNumber &gt; pInChI-&gt;nNumberOfAtoms ) {</a>
<a name="ln1847">            return RI_ERR_PROGR; /* wrong data, should never happen */</a>
<a name="ln1848">        }</a>
<a name="ln1849">        if ( ATOM_PARITY_WELL_DEF(Stereo-&gt;t_parity[i]) ) {</a>
<a name="ln1850">            (*num_known_SC) ++;</a>
<a name="ln1851">        } else {</a>
<a name="ln1852">            (*num_unk_und_SC) ++;</a>
<a name="ln1853">        }</a>
<a name="ln1854">        el_number = pInChI-&gt;nAtom[nAtNumber-1];</a>
<a name="ln1855">        if ( el_number != el_number_P &amp;&amp; el_number != el_number_As ) {</a>
<a name="ln1856">            continue;</a>
<a name="ln1857">        }</a>
<a name="ln1858">        ret = GetNumNeighborsFromInchi( pInChI, nAtNumber );</a>
<a name="ln1859">        if ( ret &lt; 0 ) {</a>
<a name="ln1860">            return ret;</a>
<a name="ln1861">        }</a>
<a name="ln1862">        if ( 3 == ret ) {</a>
<a name="ln1863">            *num_SC_PIII  += (el_number_P  == el_number);</a>
<a name="ln1864">            *num_SC_AsIII += (el_number_As == el_number);</a>
<a name="ln1865">        }</a>
<a name="ln1866">    }</a>
<a name="ln1867">    return 2; /* Has Stereo */</a>
<a name="ln1868">}</a>
<a name="ln1869">/**************************************************************************************/</a>
<a name="ln1870">int bInpInchiComponentExists( InpInChI *pOneInput, int iInChI, int bMobileH, int k )</a>
<a name="ln1871">{</a>
<a name="ln1872">    if ( (INCHI_BAS != iInChI   &amp;&amp; iInChI != INCHI_REC)  ||</a>
<a name="ln1873">         (TAUT_NON  != bMobileH &amp;&amp; TAUT_YES != bMobileH) || k &lt; 0 ) {</a>
<a name="ln1874">        return 0;</a>
<a name="ln1875">    }</a>
<a name="ln1876">    return ( k &lt; pOneInput-&gt;nNumComponents[iInChI][bMobileH] &amp;&amp;</a>
<a name="ln1877">                 pOneInput-&gt;pInpInChI[iInChI][bMobileH] &amp;&amp;</a>
<a name="ln1878">                 pOneInput-&gt;pInpInChI[iInChI][bMobileH][k].nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln1879">                !pOneInput-&gt;pInpInChI[iInChI][bMobileH][k].bDeleted );</a>
<a name="ln1880">}</a>
<a name="ln1881">/**************************************************************************************/</a>
<a name="ln1882">int bInpInchiComponentDeleted( InpInChI *pOneInput, int iInChI, int bMobileH, int k )</a>
<a name="ln1883">{</a>
<a name="ln1884">    if ( (INCHI_BAS != iInChI   &amp;&amp; iInChI != INCHI_REC)  ||</a>
<a name="ln1885">         (TAUT_NON  != bMobileH &amp;&amp; TAUT_YES != bMobileH) || k &lt; 0 ) {</a>
<a name="ln1886">        return 0;</a>
<a name="ln1887">    }</a>
<a name="ln1888">    return ( k &lt; pOneInput-&gt;nNumComponents[iInChI][bMobileH] &amp;&amp;</a>
<a name="ln1889">                 pOneInput-&gt;pInpInChI[iInChI][bMobileH] &amp;&amp;</a>
<a name="ln1890">                 pOneInput-&gt;pInpInChI[iInChI][bMobileH][k].nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln1891">                 pOneInput-&gt;pInpInChI[iInChI][bMobileH][k].bDeleted );</a>
<a name="ln1892">}</a>
<a name="ln1893">/**************************************************************************************/</a>
<a name="ln1894">int bRevInchiComponentExists( StrFromINChI *pStruct, int iInChI, int bMobileH, int k )</a>
<a name="ln1895">{</a>
<a name="ln1896">    if ( !pStruct || /*!pStruct-&gt;at2 ||*/ !pStruct-&gt;num_atoms ||</a>
<a name="ln1897">         (INCHI_BAS != iInChI   &amp;&amp; iInChI != INCHI_REC)  ||</a>
<a name="ln1898">         (TAUT_NON  != bMobileH &amp;&amp; TAUT_YES != bMobileH) || k &lt; 0 ) {</a>
<a name="ln1899">        return 0;</a>
<a name="ln1900">    }</a>
<a name="ln1901">    return ( k &lt; pStruct-&gt;RevInChI.num_components[iInChI] &amp;&amp;</a>
<a name="ln1902">                 pStruct-&gt;RevInChI.pINChI[iInChI] &amp;&amp;</a>
<a name="ln1903">                 pStruct-&gt;RevInChI.pINChI[iInChI][k][bMobileH] &amp;&amp;</a>
<a name="ln1904">                 pStruct-&gt;RevInChI.pINChI[iInChI][k][bMobileH]-&gt;nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln1905">                !pStruct-&gt;RevInChI.pINChI[iInChI][k][bMobileH]-&gt;bDeleted );</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908">/**************************************************************************************/</a>
<a name="ln1909">int bRevInchiComponentDeleted( StrFromINChI *pStruct, int iInChI, int bMobileH, int k )</a>
<a name="ln1910">{</a>
<a name="ln1911">    if ( !pStruct || /*!pStruct-&gt;at2 ||*/ !pStruct-&gt;num_atoms ||</a>
<a name="ln1912">         (INCHI_BAS != iInChI   &amp;&amp; iInChI != INCHI_REC)  ||</a>
<a name="ln1913">         (TAUT_NON  != bMobileH &amp;&amp; TAUT_YES != bMobileH) || k &lt; 0 ) {</a>
<a name="ln1914">        return 0;</a>
<a name="ln1915">    }</a>
<a name="ln1916">    return ( k &lt; pStruct-&gt;RevInChI.num_components[iInChI] &amp;&amp;</a>
<a name="ln1917">                 pStruct-&gt;RevInChI.pINChI[iInChI] &amp;&amp;</a>
<a name="ln1918">                 pStruct-&gt;RevInChI.pINChI[iInChI][k][bMobileH] &amp;&amp;</a>
<a name="ln1919">                 pStruct-&gt;RevInChI.pINChI[iInChI][k][bMobileH]-&gt;nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln1920">                 pStruct-&gt;RevInChI.pINChI[iInChI][k][bMobileH]-&gt;bDeleted );</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">/**************************************************************************************/</a>
<a name="ln1924">int DetectInpInchiCreationOptions ( InpInChI *pOneInput, int *bHasReconnected, int *bHasMetal,</a>
<a name="ln1925">                                             int *bHasFixedH, int *nModeFlagsStereo, int *bTautFlagsStereo )</a>
<a name="ln1926">{</a>
<a name="ln1927">    int ret=0, bHasStereo;</a>
<a name="ln1928">    int nModeFlagsValue=0, bTautFlagsValue; /* stereo flags */</a>
<a name="ln1929">    int iInChI, iMobileH, bIso, k, max_components, num_components;</a>
<a name="ln1930">    INChI *pInChI;</a>
<a name="ln1931">    int num_known_SB /*Stereo Bonds &amp; Cumulenes &gt;C==C==C==C&lt; */;</a>
<a name="ln1932">    int num_known_SC /* Stereo Centers &amp; Allenes &gt;C=C=C&lt; */;</a>
<a name="ln1933">    int num_unk_und_SB, num_unk_und_SC;</a>
<a name="ln1934">    int num_SC_PIII, num_SC_AsIII; /* has Phosphine or Arsine stereo center(s) */</a>
<a name="ln1935"> </a>
<a name="ln1936">    *bHasReconnected = *bHasFixedH = *nModeFlagsStereo = *bTautFlagsStereo = 0;</a>
<a name="ln1937">    nModeFlagsValue = bTautFlagsValue = bHasStereo = 0;</a>
<a name="ln1938">    num_known_SB = num_known_SC = num_unk_und_SB = num_unk_und_SC = num_SC_PIII = num_SC_AsIII = 0;</a>
<a name="ln1939">    *bHasMetal = 0;</a>
<a name="ln1940"> </a>
<a name="ln1941">    for ( iInChI   = 0; iInChI   &lt; INCHI_NUM; iInChI ++   ) </a>
<a name="ln1942">    {</a>
<a name="ln1943">        for ( iMobileH = 0; iMobileH &lt; TAUT_NUM;  iMobileH ++ ) </a>
<a name="ln1944">        {</a>
<a name="ln1945">            for ( bIso = 1; !nModeFlagsValue &amp;&amp; 0 &lt;= bIso; bIso -- ) </a>
<a name="ln1946">            {</a>
<a name="ln1947">                switch( pOneInput-&gt;s[iInChI][iMobileH][bIso] ) </a>
<a name="ln1948">                {</a>
<a name="ln1949">                case 1: /* SABS */</a>
<a name="ln1950">                    nModeFlagsValue |= REQ_MODE_STEREO | REQ_MODE_ISO_STEREO;</a>
<a name="ln1951">                    break;</a>
<a name="ln1952">                case 2:</a>
<a name="ln1953">                    nModeFlagsValue |= REQ_MODE_STEREO | REQ_MODE_ISO_STEREO | REQ_MODE_RELATIVE_STEREO;</a>
<a name="ln1954">                    break;</a>
<a name="ln1955">                case 3:</a>
<a name="ln1956">                    nModeFlagsValue |= REQ_MODE_STEREO | REQ_MODE_ISO_STEREO | REQ_MODE_RACEMIC_STEREO;</a>
<a name="ln1957">                }</a>
<a name="ln1958">            }</a>
<a name="ln1959">        </a>
<a name="ln1960">            max_components = pOneInput-&gt;pInpInChI[iInChI][iMobileH]?</a>
<a name="ln1961">                             pOneInput-&gt;nNumComponents[iInChI][iMobileH] : 0;</a>
<a name="ln1962"> </a>
<a name="ln1963">            for ( k = num_components = 0; k &lt; max_components; k ++ ) </a>
<a name="ln1964">            {</a>
<a name="ln1965">                pInChI = pOneInput-&gt;pInpInChI[iInChI][iMobileH] + k;</a>
<a name="ln1966">                ret = CountStereoTypes(pInChI, </a>
<a name="ln1967">                                       &amp;num_known_SB, &amp;num_known_SC,</a>
<a name="ln1968">                                       &amp;num_unk_und_SB, &amp;num_unk_und_SC,</a>
<a name="ln1969">                                       &amp;num_SC_PIII, &amp;num_SC_AsIII);</a>
<a name="ln1970">                if ( ret &lt; 0 ) </a>
<a name="ln1971">                {</a>
<a name="ln1972">                    return ret; /* error */</a>
<a name="ln1973">                }</a>
<a name="ln1974">                bHasStereo     += (ret == 2);</a>
<a name="ln1975">                if ( (ret &gt; 0) ) </a>
<a name="ln1976">                {</a>
<a name="ln1977">                    /* ret == 0 =&gt; Empty InChI, 1=&gt; No Stereo, 2=&gt; Has Stereo */</a>
<a name="ln1978">                    num_components ++;</a>
<a name="ln1979">                    *bHasReconnected |= ( iInChI   == INCHI_REC );</a>
<a name="ln1980">                    *bHasFixedH      |= ( iMobileH == TAUT_NON  );   </a>
<a name="ln1981">                }</a>
<a name="ln1982">                *bHasMetal |= bInChIHasReconnectedMetal( pInChI );</a>
<a name="ln1983">            }</a>
<a name="ln1984">        }</a>
<a name="ln1985">    }</a>
<a name="ln1986"> </a>
<a name="ln1987">    if ( (nModeFlagsValue &amp; REQ_MODE_RELATIVE_STEREO) &amp;&amp; (nModeFlagsValue &amp; REQ_MODE_RACEMIC_STEREO) ) </a>
<a name="ln1988">    {</a>
<a name="ln1989">        return RI_ERR_SYNTAX;</a>
<a name="ln1990">    }</a>
<a name="ln1991">    if ( bHasStereo &amp;&amp; !nModeFlagsValue ) /* REQ_MODE_SB_IGN_ALL_UU | REQ_MODE_SC_IGN_ALL_UU*/</a>
<a name="ln1992">    {  </a>
<a name="ln1993">        /* inversion does not change the stereo or no stereo at all */</a>
<a name="ln1994">        nModeFlagsValue = REQ_MODE_STEREO | REQ_MODE_ISO_STEREO; /* Abs */</a>
<a name="ln1995">    }</a>
<a name="ln1996"> </a>
<a name="ln1997">    if ( !num_known_SB &amp;&amp; num_unk_und_SB ) </a>
<a name="ln1998">    {</a>
<a name="ln1999">        ; /* full SUU option or SB part of it */</a>
<a name="ln2000">    } else </a>
<a name="ln2001">    {</a>
<a name="ln2002">        nModeFlagsValue |= REQ_MODE_SB_IGN_ALL_UU; /* ignore Unknown/Undefind SB if no well-defined SB exist */</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    if ( !num_known_SC &amp;&amp; num_unk_und_SC ) </a>
<a name="ln2006">    {</a>
<a name="ln2007">        ; /* full SUU option or SB part of it */</a>
<a name="ln2008">    } else </a>
<a name="ln2009">    {</a>
<a name="ln2010">        nModeFlagsValue |= REQ_MODE_SC_IGN_ALL_UU; /* ignore Unknown/Undefind SC if no well-defined SB exist */</a>
<a name="ln2011">    }</a>
<a name="ln2012"> </a>
<a name="ln2013">    /* Phosphine and Arsine Stereo */</a>
<a name="ln2014">    if ( num_SC_PIII ) </a>
<a name="ln2015">    {</a>
<a name="ln2016">        bTautFlagsValue |= TG_FLAG_PHOSPHINE_STEREO;</a>
<a name="ln2017">    }</a>
<a name="ln2018">    /* Phosphine and Arsine Stereo */</a>
<a name="ln2019">    if ( num_SC_AsIII ) </a>
<a name="ln2020">    {</a>
<a name="ln2021">        bTautFlagsValue |= TG_FLAG_ARSINE_STEREO;</a>
<a name="ln2022">    }</a>
<a name="ln2023"> </a>
<a name="ln2024">    *nModeFlagsStereo = nModeFlagsValue;</a>
<a name="ln2025">    *bTautFlagsStereo = bTautFlagsValue;</a>
<a name="ln2026">    </a>
<a name="ln2027">    return 0;</a>
<a name="ln2028">}</a>
<a name="ln2029"> </a>
<a name="ln2030">/******************************************************************************************************/</a>
<a name="ln2031">int bInChIHasReconnectedMetal( INChI *pInChI )</a>
<a name="ln2032">{</a>
<a name="ln2033">    int i;</a>
<a name="ln2034">    if ( pInChI &amp;&amp; !pInChI-&gt;bDeleted &amp;&amp; pInChI-&gt;nNumberOfAtoms &amp;&amp; pInChI-&gt;nAtom ) </a>
<a name="ln2035">    {</a>
<a name="ln2036">        for ( i = 0; i &lt; pInChI-&gt;nNumberOfAtoms; i ++ ) </a>
<a name="ln2037">        {</a>
<a name="ln2038">            if ( is_el_a_metal( (int)pInChI-&gt;nAtom[i] ) ) </a>
<a name="ln2039">            {</a>
<a name="ln2040">                if ( pInChI-&gt;nNumberOfAtoms &gt; 1 || (pInChI-&gt;nNum_H &amp;&amp; pInChI-&gt;nNum_H[0]) )</a>
<a name="ln2041">                {</a>
<a name="ln2042">                    return 1;</a>
<a name="ln2043">                }</a>
<a name="ln2044">            }</a>
<a name="ln2045">        }</a>
<a name="ln2046">    }</a>
<a name="ln2047">    return 0;</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050">/*****************************************************************************************/</a>
<a name="ln2051">int SetProtonsAndXchgIsoH( int bInChI2Structure, int bReqSplitOutputInChI, int bReqProtonsForEachComponent,</a>
<a name="ln2052">                           int bReqNonTaut, int bReqStereo, int num_components[INCHI_NUM],</a>
<a name="ln2053">                           MODE_PIXH nModeProtonIsoExchgH[INCHI_NUM], InpInChI *OneInput )</a>
<a name="ln2054">{</a>
<a name="ln2055">    int      j, k, k1, ret2=0, iINChI;</a>
<a name="ln2056">    int  bAvailableProtonsForEachComponent, bAvailableProtonsTotal;</a>
<a name="ln2057">    </a>
<a name="ln2058">    INCHI_HEAPCHK</a>
<a name="ln2059"> </a>
<a name="ln2060">    num_components[INCHI_BAS] = num_components[INCHI_REC] = 0;</a>
<a name="ln2061"> </a>
<a name="ln2062">    for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) {</a>
<a name="ln2063">        nModeProtonIsoExchgH[iINChI] = MODE_PIXH_UNDEFINED;</a>
<a name="ln2064">        /* are totals of /p and/or /i/h available ? */</a>
<a name="ln2065">        bAvailableProtonsTotal            = 0 != OneInput-&gt;nNumProtons[iINChI][TAUT_YES].nNumRemovedProtons;</a>
<a name="ln2066">        for ( k1 = 0; k1 &lt; NUM_H_ISOTOPES; k1 ++ ) {</a>
<a name="ln2067">            bAvailableProtonsTotal |= 0 !=OneInput-&gt;nNumProtons[iINChI][TAUT_YES].nNumRemovedIsotopicH[k1];</a>
<a name="ln2068">        }</a>
<a name="ln2069">        /* are /p and/or /i/h available for each component ? */</a>
<a name="ln2070">        bAvailableProtonsForEachComponent = (NULL != OneInput-&gt;nNumProtons[iINChI][TAUT_YES].pNumProtons);</a>
<a name="ln2071">        /* decision: add /p to each component, add total to the 1st, add total as one more component */</a>
<a name="ln2072">        /* In case of bInChI2Structure just keep totals if not available for each component */</a>
<a name="ln2073">        if ( bInChI2Structure ) {</a>
<a name="ln2074">            nModeProtonIsoExchgH[iINChI] = bAvailableProtonsForEachComponent? </a>
<a name="ln2075">                                       MODE_PIXH_ADD_TO_EACH:</a>
<a name="ln2076">                                       MODE_PIXH_KEEP_TOTALS;</a>
<a name="ln2077">        } else</a>
<a name="ln2078">        if ( !bReqSplitOutputInChI ) {</a>
<a name="ln2079">            nModeProtonIsoExchgH[iINChI] = bAvailableProtonsForEachComponent?</a>
<a name="ln2080">                                       MODE_PIXH_ADD_TO_EACH :</a>
<a name="ln2081">                                       MODE_PIXH_ADD_TO_FIRST;</a>
<a name="ln2082">        } else</a>
<a name="ln2083">        if ( !bAvailableProtonsForEachComponent ) {</a>
<a name="ln2084">            nModeProtonIsoExchgH[iINChI] = bAvailableProtonsTotal?</a>
<a name="ln2085">                                       MODE_PIXH_ADD_A_PIXH_COMPONENT :</a>
<a name="ln2086">                                       MODE_PIXH_ADD_TO_FIRST;</a>
<a name="ln2087">        } else</a>
<a name="ln2088">        /* bAvailableProtonsForEachComponent &amp;&amp; bReqSplitOutputInChI */</a>
<a name="ln2089">        if ( bReqProtonsForEachComponent ) {</a>
<a name="ln2090">            nModeProtonIsoExchgH[iINChI] =     MODE_PIXH_ADD_TO_EACH;</a>
<a name="ln2091">        } else {</a>
<a name="ln2092">            nModeProtonIsoExchgH[iINChI] = bReqNonTaut?</a>
<a name="ln2093">                                       MODE_PIXH_ADD_TO_EACH :</a>
<a name="ln2094">                                       MODE_PIXH_ADD_A_PIXH_COMPONENT;</a>
<a name="ln2095">        }</a>
<a name="ln2096">        /* remove unneeded data: protons for each component */</a>
<a name="ln2097">        if ( bAvailableProtonsForEachComponent &amp;&amp;</a>
<a name="ln2098">             nModeProtonIsoExchgH[iINChI] != MODE_PIXH_ADD_TO_EACH ) {</a>
<a name="ln2099">            inchi_free( OneInput-&gt;nNumProtons[iINChI][TAUT_YES].pNumProtons );</a>
<a name="ln2100">            OneInput-&gt;nNumProtons[iINChI][TAUT_YES].pNumProtons = NULL;</a>
<a name="ln2101">            bAvailableProtonsForEachComponent = 0;</a>
<a name="ln2102">        }</a>
<a name="ln2103">        /* remove unneeded data: total protons all components */</a>
<a name="ln2104">        if ( bAvailableProtonsTotal &amp;&amp; nModeProtonIsoExchgH[iINChI] == MODE_PIXH_ADD_TO_EACH ) {</a>
<a name="ln2105">            OneInput-&gt;nNumProtons[iINChI][TAUT_YES].nNumRemovedProtons = 0;</a>
<a name="ln2106">            for ( k1 = 0; k1 &lt; NUM_H_ISOTOPES; k1 ++ ) {</a>
<a name="ln2107">                OneInput-&gt;nNumProtons[iINChI][TAUT_YES].nNumRemovedIsotopicH[k1] = 0;</a>
<a name="ln2108">            }</a>
<a name="ln2109">            bAvailableProtonsTotal = 0;</a>
<a name="ln2110">        }</a>
<a name="ln2111">        /* remove unneeded data: Fixed-H InChI; no protons data exist for Fixed-H */</a>
<a name="ln2112">        if ( !bReqNonTaut &amp;&amp; OneInput-&gt;nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln2113">            j = TAUT_NON;</a>
<a name="ln2114">            for ( k = 0; k &lt; OneInput-&gt;nNumComponents[iINChI][j]; k ++ ) {</a>
<a name="ln2115">                Free_INChI_Members( &amp;OneInput-&gt;pInpInChI[iINChI][j][k] );</a>
<a name="ln2116">            }</a>
<a name="ln2117">            inchi_free( OneInput-&gt;pInpInChI[iINChI][j] );</a>
<a name="ln2118">            OneInput-&gt;pInpInChI[iINChI][j] = NULL;</a>
<a name="ln2119">            OneInput-&gt;nNumComponents[iINChI][j] = 0;</a>
<a name="ln2120">        }</a>
<a name="ln2121">#ifdef NEVER</a>
<a name="ln2122">        /* remove unneeded data: Mobile-H InChI ????? */</a>
<a name="ln2123">        if ( bReqNonTaut &amp;&amp; OneInput-&gt;nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln2124">            j = TAUT_YES;</a>
<a name="ln2125">            for ( k = 0; k &lt; OneInput-&gt;nNumComponents[iINChI][j]; k ++ ) {</a>
<a name="ln2126">                Free_INChI_Members( &amp;OneInput-&gt;pInpInChI[iINChI][j][k] );</a>
<a name="ln2127">            }</a>
<a name="ln2128">            inchi_free( OneInput-&gt;pInpInChI[iINChI][j] );</a>
<a name="ln2129">            OneInput-&gt;pInpInChI[iINChI][j] = NULL;</a>
<a name="ln2130">            OneInput-&gt;nNumComponents[iINChI][j] = 0;</a>
<a name="ln2131">            nModeProtonIsoExchgH[iINChI] = MODE_PIXH_UNDEFINED;</a>
<a name="ln2132">            if ( OneInput-&gt;nNumProtons[iINChI][TAUT_YES].pNumProtons ) {</a>
<a name="ln2133">                inchi_free( OneInput-&gt;nNumProtons[iINChI][TAUT_YES].pNumProtons);</a>
<a name="ln2134">                OneInput-&gt;nNumProtons[iINChI][TAUT_YES].pNumProtons = NULL;</a>
<a name="ln2135">            }</a>
<a name="ln2136">        }</a>
<a name="ln2137">#endif</a>
<a name="ln2138">        /* add one more component containing only /p and /i/h */</a>
<a name="ln2139">        if ( (nModeProtonIsoExchgH[iINChI] == MODE_PIXH_ADD_A_PIXH_COMPONENT &amp;&amp;</a>
<a name="ln2140">             OneInput-&gt;nNumComponents[iINChI][TAUT_YES])       ||</a>
<a name="ln2141">             /* always add one deleted component if no non-taut InChI is available */</a>
<a name="ln2142">             (bInChI2Structure &amp;&amp; !bAvailableProtonsForEachComponent &amp;&amp;</a>
<a name="ln2143">             !OneInput-&gt;nNumComponents[iINChI][TAUT_NON] &amp;&amp;</a>
<a name="ln2144">             OneInput-&gt;nNumComponents[iINChI][TAUT_YES]) ) {</a>
<a name="ln2145">            int nPrevLen, nLen=0;</a>
<a name="ln2146">            j = TAUT_YES;</a>
<a name="ln2147">            nPrevLen = OneInput-&gt;nNumComponents[iINChI][j];</a>
<a name="ln2148">            for ( k = 0; k &lt; nPrevLen; k ++ ) {</a>
<a name="ln2149">                nLen += !OneInput-&gt;pInpInChI[iINChI][j][k].bDeleted;    </a>
<a name="ln2150">            }</a>
<a name="ln2151">            if ( nLen == nPrevLen ) {</a>
<a name="ln2152">                /* add one more component */</a>
<a name="ln2153">                INChI *pInChI = (INChI *)inchi_calloc( nLen+1, sizeof(*pInChI) );</a>
<a name="ln2154">                if ( !pInChI ) {</a>
<a name="ln2155">                    ret2 = RI_ERR_ALLOC;</a>
<a name="ln2156">                    goto exit_error;</a>
<a name="ln2157">                }</a>
<a name="ln2158">                memcpy( pInChI, OneInput-&gt;pInpInChI[iINChI][j], nLen*sizeof(*pInChI) );</a>
<a name="ln2159">                inchi_free( OneInput-&gt;pInpInChI[iINChI][j] );</a>
<a name="ln2160">                OneInput-&gt;pInpInChI[iINChI][j] = pInChI;</a>
<a name="ln2161">            }</a>
<a name="ln2162">            OneInput-&gt;nNumComponents[iINChI][j] = nLen+1;</a>
<a name="ln2163">            </a>
<a name="ln2164">            for ( k = nLen; k &lt; nPrevLen; k ++ ) {</a>
<a name="ln2165">                Free_INChI_Members( &amp;OneInput-&gt;pInpInChI[iINChI][j][k] );</a>
<a name="ln2166">                memset( &amp;OneInput-&gt;pInpInChI[iINChI][j][k], 0, sizeof(OneInput-&gt;pInpInChI[iINChI][j][k]));</a>
<a name="ln2167">            }</a>
<a name="ln2168">            /* mark the last component as a proton */</a>
<a name="ln2169">            if ( 0 &gt; (ret2 = nFillOutProtonMobileH( OneInput-&gt;pInpInChI[iINChI][j]+nLen ) ) ) {</a>
<a name="ln2170">                goto exit_error;</a>
<a name="ln2171">            }</a>
<a name="ln2172">        }</a>
<a name="ln2173">        INCHI_HEAPCHK</a>
<a name="ln2174">       </a>
<a name="ln2175">        /* remove unneeded Stereo and/or Fixed H */</a>
<a name="ln2176">        if ( !bReqStereo ) {</a>
<a name="ln2177">            for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln2178">                for ( k = 0; k &lt; OneInput-&gt;nNumComponents[iINChI][j]; k ++ ) {</a>
<a name="ln2179">                    if ( OneInput-&gt;pInpInChI[iINChI][j][k].Stereo ) {</a>
<a name="ln2180">                        Free_INChI_Stereo(OneInput-&gt;pInpInChI[iINChI][j][k].Stereo);</a>
<a name="ln2181">                        inchi_free( OneInput-&gt;pInpInChI[iINChI][j][k].Stereo );</a>
<a name="ln2182">                        OneInput-&gt;pInpInChI[iINChI][j][k].Stereo = NULL;</a>
<a name="ln2183">                    }</a>
<a name="ln2184">                    if ( OneInput-&gt;pInpInChI[iINChI][j][k].StereoIsotopic ) {</a>
<a name="ln2185">                        Free_INChI_Stereo(OneInput-&gt;pInpInChI[iINChI][j][k].StereoIsotopic);</a>
<a name="ln2186">                        inchi_free( OneInput-&gt;pInpInChI[iINChI][j][k].StereoIsotopic );</a>
<a name="ln2187">                        OneInput-&gt;pInpInChI[iINChI][j][k].StereoIsotopic = NULL;</a>
<a name="ln2188">                    }</a>
<a name="ln2189">                    INCHI_HEAPCHK</a>
<a name="ln2190">                }</a>
<a name="ln2191">            }</a>
<a name="ln2192">        }</a>
<a name="ln2193">    }</a>
<a name="ln2194"> </a>
<a name="ln2195">    num_components[INCHI_BAS] = inchi_max( OneInput-&gt;nNumComponents[INCHI_BAS][TAUT_YES],</a>
<a name="ln2196">                                           OneInput-&gt;nNumComponents[INCHI_BAS][TAUT_NON] );</a>
<a name="ln2197">    num_components[INCHI_REC] = inchi_max( OneInput-&gt;nNumComponents[INCHI_REC][TAUT_YES],</a>
<a name="ln2198">                                           OneInput-&gt;nNumComponents[INCHI_REC][TAUT_NON] );</a>
<a name="ln2199"> </a>
<a name="ln2200">exit_error:</a>
<a name="ln2201">    return ret2;</a>
<a name="ln2202">}</a>
<a name="ln2203">/******************************************************************************************/</a>
<a name="ln2204">int GetInChIFormulaNumH( INChI *pInChI, int *nNumH )</a>
<a name="ln2205">{  /* get number of H including bridging hydrogen atoms */</a>
<a name="ln2206">    const char *p, *q;</a>
<a name="ln2207">    *nNumH = 0;</a>
<a name="ln2208">    if ( pInChI-&gt;szHillFormula ) {</a>
<a name="ln2209">        for ( p = strchr( pInChI-&gt;szHillFormula, 'H'); p; p = strchr(p, 'H') ) {</a>
<a name="ln2210">            p ++;</a>
<a name="ln2211">            if ( !islower( UCINT *p ) ) {</a>
<a name="ln2212">                /* found hydrogen in the formula */</a>
<a name="ln2213">                if ( isdigit( UCINT *p ) ) {</a>
<a name="ln2214">                    *nNumH += (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln2215">                    p = q;</a>
<a name="ln2216">                } else {</a>
<a name="ln2217">                    *nNumH += 1;</a>
<a name="ln2218">                }</a>
<a name="ln2219">            }</a>
<a name="ln2220">        }</a>
<a name="ln2221">    }</a>
<a name="ln2222">    return 0;</a>
<a name="ln2223">}</a>
<a name="ln2224">/******************************************************************************************/</a>
<a name="ln2225">int GetInChINumH( INChI *pInChI, int *nNumH )</a>
<a name="ln2226">{</a>
<a name="ln2227">    int i, j, nNumTautGroups, iTautGroup, nTautGroupLen, lenTautomer;</a>
<a name="ln2228">    *nNumH = 0;</a>
<a name="ln2229">    for ( i = 0; i &lt; pInChI-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2230">        *nNumH += ( pInChI-&gt;nAtom[i] == EL_NUMBER_H ); /* bridging H */</a>
<a name="ln2231">        *nNumH += pInChI-&gt;nNum_H[i];</a>
<a name="ln2232">    }</a>
<a name="ln2233">    /* earlier nNum_H_fixed[] should have been added to pInChI-&gt;nNum_H[] */</a>
<a name="ln2234">    /*</a>
<a name="ln2235">    if ( pInChI-&gt;nNum_H_fixed ) {</a>
<a name="ln2236">        for ( i = 0; i &lt; pInChI-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2237">            *nNumH += pInChI-&gt;nNum_H_fixed[i];</a>
<a name="ln2238">        }</a>
<a name="ln2239">    }</a>
<a name="ln2240">    */</a>
<a name="ln2241">    if ( pInChI-&gt;lenTautomer &gt; 3 &amp;&amp; pInChI-&gt;nTautomer ) {</a>
<a name="ln2242">        lenTautomer = pInChI-&gt;lenTautomer;</a>
<a name="ln2243">        j = 0;</a>
<a name="ln2244">        nNumTautGroups = pInChI-&gt;nTautomer[j ++];</a>
<a name="ln2245">        for ( iTautGroup = 0; j &lt; lenTautomer &amp;&amp; iTautGroup &lt; nNumTautGroups; iTautGroup ++, j += nTautGroupLen ) {</a>
<a name="ln2246">            nTautGroupLen = pInChI-&gt;nTautomer[j]+1;</a>
<a name="ln2247">            *nNumH += pInChI-&gt;nTautomer[j+1];</a>
<a name="ln2248">        }</a>
<a name="ln2249">        if ( iTautGroup != nNumTautGroups || j != lenTautomer ) {</a>
<a name="ln2250">            return RI_ERR_PROGR;</a>
<a name="ln2251">        }</a>
<a name="ln2252">    }</a>
<a name="ln2253">    if ( pInChI-&gt;nNum_H_fixed &amp;&amp; (pInChI-&gt;lenTautomer || pInChI-&gt;nTautomer) ) {</a>
<a name="ln2254">        return RI_ERR_PROGR;</a>
<a name="ln2255">    }</a>
<a name="ln2256">    return 0;</a>
<a name="ln2257">}</a>
<a name="ln2258">/******************************************************************************************/</a>
<a name="ln2259">int GetInChIIsoH( INChI *pInChI, int nNumIsotopicH[NUM_H_ISOTOPES] )</a>
<a name="ln2260">{</a>
<a name="ln2261">    int i;</a>
<a name="ln2262">    for ( i = 0; i &lt; NUM_H_ISOTOPES; i ++ ) {</a>
<a name="ln2263">        nNumIsotopicH[i] = 0;</a>
<a name="ln2264">    }</a>
<a name="ln2265">    for ( i = 0; i &lt; pInChI-&gt;nNumberOfIsotopicAtoms; i ++ ) {</a>
<a name="ln2266">        if ( pInChI-&gt;IsotopicAtom[i].nIsoDifference &gt; 0 &amp;&amp;</a>
<a name="ln2267">             pInChI-&gt;IsotopicAtom[i].nIsoDifference &lt;= NUM_H_ISOTOPES ) {</a>
<a name="ln2268">            if ( !pInChI-&gt;nAtom ||</a>
<a name="ln2269">                 !pInChI-&gt;IsotopicAtom[i].nAtomNumber ||</a>
<a name="ln2270">                 pInChI-&gt;IsotopicAtom[i].nAtomNumber &gt; pInChI-&gt;nNumberOfAtoms ) {</a>
<a name="ln2271">                return RI_ERR_PROGR;</a>
<a name="ln2272">            }</a>
<a name="ln2273">            if ( pInChI-&gt;nAtom[pInChI-&gt;IsotopicAtom[i].nAtomNumber-1] == EL_NUMBER_H ) {</a>
<a name="ln2274">                /* isotopic H in connection table */</a>
<a name="ln2275">                nNumIsotopicH[ pInChI-&gt;IsotopicAtom[i].nIsoDifference-1 ] ++;</a>
<a name="ln2276">            }</a>
<a name="ln2277">        }</a>
<a name="ln2278">        nNumIsotopicH[0] += pInChI-&gt;IsotopicAtom[i].nNum_H;</a>
<a name="ln2279">        nNumIsotopicH[1] += pInChI-&gt;IsotopicAtom[i].nNum_D;</a>
<a name="ln2280">        nNumIsotopicH[2] += pInChI-&gt;IsotopicAtom[i].nNum_T;</a>
<a name="ln2281">    }</a>
<a name="ln2282">    return 0;</a>
<a name="ln2283">}</a>
<a name="ln2284">/******************************************************************************************/</a>
<a name="ln2285">typedef struct tagNumElem </a>
<a name="ln2286">{</a>
<a name="ln2287">    int num;</a>
<a name="ln2288">    /*</a>
<a name="ln2289">    int iso;</a>
<a name="ln2290">    */</a>
<a name="ln2291">} NUM_ELEM;</a>
<a name="ln2292"> </a>
<a name="ln2293"> </a>
<a name="ln2294">/***************************************************************************************/</a>
<a name="ln2295">int InChILine2Data(INCHI_IOSTREAM *pInp, SEGM_LINE *pLine, </a>
<a name="ln2296">                   char **pStr, int *pState, int *nErr,</a>
<a name="ln2297">                   INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln2298">                   int nNumComponents[INCHI_NUM][TAUT_NUM],</a>
<a name="ln2299">                   REM_PROTONS nNumProtons[INCHI_NUM][TAUT_NUM],</a>
<a name="ln2300">                   int s[INCHI_NUM][TAUT_NUM][2], </a>
<a name="ln2301">                   int bReadCoord, int bInchi2Struct, INCHI_MODE nMode,</a>
<a name="ln2302">                   int *bStdFormat, int *bInputHasSaveOpt, unsigned char *inp_save_opt_bits)</a>
<a name="ln2303">{</a>
<a name="ln2304">    int iINChI, i, j, k, m, len1, len2, ret2 = 0, retAux = 0, stateAux = 0;</a>
<a name="ln2305">    int ret, tot_charge[INCHI_NUM][TAUT_NUM];</a>
<a name="ln2306">    int i1, i2, i3;</a>
<a name="ln2307">    int kc;</a>
<a name="ln2308">    NUM_ELEM *num_elem[INCHI_NUM][TAUT_NUM];</a>
<a name="ln2309"> </a>
<a name="ln2310"> </a>
<a name="ln2311">#if ( FIX_I2I_STEREOCONVERSION_BUG == 1 )</a>
<a name="ln2312">/* (2008-03-06)   1=&gt; Fix bug of i2i conversion SAbs--&gt;(SRel||Srac) */</a>
<a name="ln2313">/*                    (converter does not placed proper stereo to output) */</a>
<a name="ln2314">    </a>
<a name="ln2315">    /* set new stereo type as requested by conversion option */</a>
<a name="ln2316">    int target_stereo_type = 1;                </a>
<a name="ln2317">    if (nMode &amp; REQ_MODE_RELATIVE_STEREO)</a>
<a name="ln2318">        target_stereo_type = 2;</a>
<a name="ln2319">    else if (nMode &amp; REQ_MODE_RACEMIC_STEREO)</a>
<a name="ln2320">        target_stereo_type = 3;</a>
<a name="ln2321">#endif</a>
<a name="ln2322"> </a>
<a name="ln2323"> </a>
<a name="ln2324">    memset( num_elem, 0, sizeof(num_elem) );</a>
<a name="ln2325"> </a>
<a name="ln2326">    ret = ReadInChILine(pInp, pLine, pStr, pState, pInpInChI, </a>
<a name="ln2327">                        nNumComponents, nNumProtons, s,</a>
<a name="ln2328">                        bStdFormat, bInputHasSaveOpt, inp_save_opt_bits);</a>
<a name="ln2329"> </a>
<a name="ln2330"> </a>
<a name="ln2331">#if ( FIX_I2I_STEREOCONVERSION_BUG == 1 )</a>
<a name="ln2332">    /* modify stereo type for layers as requested */</a>
<a name="ln2333">    if (target_stereo_type &gt; 1)</a>
<a name="ln2334">        for (i1=0;i1&lt;INCHI_NUM;i1++)</a>
<a name="ln2335">            for (i2=0;i2&lt;TAUT_NUM;i2++)</a>
<a name="ln2336">                for (i3=0;i3&lt;2;i3++)</a>
<a name="ln2337">                    if (s[i1][i2][i3] != 0) </a>
<a name="ln2338">                    {</a>
<a name="ln2339">                        if ( target_stereo_type!=1) </a>
<a name="ln2340">                            /* do not allow conversion SRel=&gt;SAbs, SRac=&gt;SAbs */</a>
<a name="ln2341">                            s[i1][i2][i3] = target_stereo_type;						</a>
<a name="ln2342">                    }</a>
<a name="ln2343">#endif</a>
<a name="ln2344"> </a>
<a name="ln2345"> </a>
<a name="ln2346">    *nErr = 0;</a>
<a name="ln2347">    if ( (ret == RI_ERR_EOL) &amp;&amp;</a>
<a name="ln2348">                       nNumComponents[INCHI_BAS][TAUT_YES] </a>
<a name="ln2349">                     + nNumComponents[INCHI_BAS][TAUT_NON] &amp;&amp; bReadCoord ) {</a>
<a name="ln2350">        retAux = ReadInChICoord( pInp, pLine, &amp;stateAux, pInpInChI, nNumComponents );</a>
<a name="ln2351">    }</a>
<a name="ln2352">    if ( (ret == RI_ERR_EOL || ret == RI_ERR_EOF) &amp;&amp;</a>
<a name="ln2353">                       nNumComponents[INCHI_BAS][TAUT_YES] </a>
<a name="ln2354">                     + nNumComponents[INCHI_BAS][TAUT_NON] ) {</a>
<a name="ln2355">        /* post-processing: add omitted layers */</a>
<a name="ln2356">        *pState = IST_MATERIAL_BALANCE_ERROR;</a>
<a name="ln2357">        for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) </a>
<a name="ln2358">        {</a>
<a name="ln2359">            </a>
<a name="ln2360">            for ( j = 0; j &lt; TAUT_NUM; j ++ ) </a>
<a name="ln2361">            {</a>
<a name="ln2362">                /* for Mobile/Fixed H (j) ... */</a>
<a name="ln2363"> </a>
<a name="ln2364">                int bIsotopic, bStereoType, bStereoTypeAlt;</a>
<a name="ln2365">                int nMH2FH_AltInv=0, nFH2iFH_AltInv=0 /*, niMH2iFH_AltInv=0, nMH2iMH_AltInv=0*/;</a>
<a name="ln2366">                int jAlt = ALT_TAUT(j);</a>
<a name="ln2367">                INCHI_MODE  nFlags = 0, nFlagsAlt = 0;</a>
<a name="ln2368">                /* get stereo type: ABS, REL, RAC, or nothing */</a>
<a name="ln2369">                tot_charge[iINChI][j] = 0;</a>
<a name="ln2370">                for ( bIsotopic = bStereoType = bStereoTypeAlt = 0; bIsotopic &lt; 2; bIsotopic ++ ) {</a>
<a name="ln2371">                    if ( !bStereoType || bStereoType &lt; s[iINChI][j][bIsotopic] ) {</a>
<a name="ln2372">                        bStereoType = s[iINChI][j][bIsotopic];</a>
<a name="ln2373">                    }</a>
<a name="ln2374">                    if ( !bStereoTypeAlt || bStereoTypeAlt &lt; s[iINChI][jAlt][bIsotopic] ) {</a>
<a name="ln2375">                        bStereoTypeAlt = s[iINChI][jAlt][bIsotopic];</a>
<a name="ln2376">                    }</a>
<a name="ln2377">                    nFlags = bStereoType      ==2? INCHI_FLAG_REL_STEREO : bStereoType   ==3? INCHI_FLAG_RAC_STEREO : 0;</a>
<a name="ln2378">                    nFlagsAlt = bStereoTypeAlt==2? INCHI_FLAG_REL_STEREO : bStereoTypeAlt==3? INCHI_FLAG_RAC_STEREO : 0;</a>
<a name="ln2379">                }</a>
<a name="ln2380">                /* set stereo type to each component */</a>
<a name="ln2381">                /* add missing nNum_H and nConnTable */</a>
<a name="ln2382">                if ( nNumComponents[iINChI][j] ) {</a>
<a name="ln2383">                    num_elem[iINChI][j] = (NUM_ELEM *)inchi_calloc( nElDataLen+1, sizeof(num_elem[0][0][0]) );</a>
<a name="ln2384">                    if ( !num_elem[iINChI][j] ) {</a>
<a name="ln2385">                        ret2 = RI_ERR_ALLOC;</a>
<a name="ln2386">                        goto exit_function;</a>
<a name="ln2387">                    }</a>
<a name="ln2388">                }</a>
<a name="ln2389">                for ( k = 0; k &lt; nNumComponents[iINChI][j]; k ++ ) </a>
<a name="ln2390">                {</a>
<a name="ln2391">                    /* for each component k ... */</a>
<a name="ln2392"> </a>
<a name="ln2393">                    if ( pInpInChI[iINChI][j] ) {</a>
<a name="ln2394">                        INChI *pInChI = &amp;pInpInChI[iINChI][j][k];</a>
<a name="ln2395">                        INChI *pInChI_Alt = (k&lt;nNumComponents[iINChI][jAlt] &amp;&amp;</a>
<a name="ln2396">                                             pInpInChI[iINChI][jAlt] &amp;&amp;</a>
<a name="ln2397">                                             /*pInpInChI[iINChI][jAlt]-&gt;nNumberOfAtoms)? pInpInChI[iINChI][jAlt]:NULL;*/ /* 2007-09-25 DT */</a>
<a name="ln2398">                                             pInpInChI[iINChI][jAlt][k].nNumberOfAtoms)? &amp;pInpInChI[iINChI][jAlt][k]:NULL;</a>
<a name="ln2399">                                             </a>
<a name="ln2400">                        if ( nFlags ) {</a>
<a name="ln2401">                            pInChI-&gt;nFlags |= nFlags;</a>
<a name="ln2402">                        } else</a>
<a name="ln2403">                        if ( j == TAUT_NON &amp;&amp; !nFlags &amp;&amp; nFlagsAlt ) {</a>
<a name="ln2404">                            pInChI-&gt;nFlags |= nFlagsAlt;</a>
<a name="ln2405">                        }</a>
<a name="ln2406">                        /**** add empty immobile H (nNum_H) if it is missing ****/</a>
<a name="ln2407">                        if ( !pInChI-&gt;nNum_H &amp;&amp;</a>
<a name="ln2408">                             !(pInChI-&gt;nNum_H = (S_CHAR *)inchi_calloc( pInChI-&gt;nNumberOfAtoms+1, sizeof(pInChI-&gt;nNum_H[0]) ) ) ) {</a>
<a name="ln2409">                            ret2 = RI_ERR_ALLOC;</a>
<a name="ln2410">                            goto exit_function;</a>
<a name="ln2411">                        }</a>
<a name="ln2412">                        /**** add single atom nConnTable if it is missing ****/</a>
<a name="ln2413">                        if ( !pInChI-&gt;nConnTable ) {</a>
<a name="ln2414">                            AT_NUMB *pCT;</a>
<a name="ln2415">                            int      lenCT;</a>
<a name="ln2416">                            if ( j == TAUT_NON &amp;&amp; k &lt; nNumComponents[iINChI][TAUT_YES] &amp;&amp;</a>
<a name="ln2417">                                 (pCT = pInpInChI[iINChI][TAUT_YES][k].nConnTable) &amp;&amp;</a>
<a name="ln2418">                                 (lenCT = pInpInChI[iINChI][TAUT_YES][k].lenConnTable) &gt; 0) {</a>
<a name="ln2419">                                if ( !(pInChI-&gt;nConnTable = (AT_NUMB *)inchi_calloc( lenCT+1, sizeof(pInChI-&gt;nConnTable[0]) ) ) ) {</a>
<a name="ln2420">                                    ret2 = RI_ERR_ALLOC;</a>
<a name="ln2421">                                    goto exit_function;</a>
<a name="ln2422">                                }</a>
<a name="ln2423">                                memcpy( pInChI-&gt;nConnTable, pCT, lenCT*sizeof(pInChI-&gt;nConnTable[0]) );</a>
<a name="ln2424">                                pInChI-&gt;lenConnTable = lenCT;</a>
<a name="ln2425">                            } else {</a>
<a name="ln2426">                                if ( j == TAUT_YES &amp;&amp; pInChI-&gt;nNumberOfAtoms &gt; 1 ) {</a>
<a name="ln2427">                                    *pState = IST_MOBILE_H_CONNECTIONS + (iINChI==INCHI_REC? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln2428">                                    ret2 = RI_ERR_SYNTAX;</a>
<a name="ln2429">                                    goto exit_function;</a>
<a name="ln2430">                                }</a>
<a name="ln2431">                                if ( !(pInChI-&gt;nConnTable = (AT_NUMB *)inchi_calloc( pInChI-&gt;nNumberOfAtoms+1, sizeof(pInChI-&gt;nConnTable[0]) ) ) ) {</a>
<a name="ln2432">                                    ret2 = RI_ERR_ALLOC;</a>
<a name="ln2433">                                    goto exit_function;</a>
<a name="ln2434">                                }</a>
<a name="ln2435">                                pInChI-&gt;lenConnTable = 1;</a>
<a name="ln2436">                                pInChI-&gt;nConnTable[0] = 1;</a>
<a name="ln2437">                            }</a>
<a name="ln2438">                        } else</a>
<a name="ln2439">                        if ( pInChI-&gt;nConnTable &amp;&amp; !pInChI-&gt;lenConnTable &amp;&amp; pInChI-&gt;nNumberOfAtoms == 1 ) {</a>
<a name="ln2440">                            pInChI-&gt;nConnTable[0] = 1;</a>
<a name="ln2441">                            pInChI-&gt;lenConnTable  = 1;</a>
<a name="ln2442">                        }</a>
<a name="ln2443">                        /**** copy charge: Mobile H --&gt; Fixed H; ****/ </a>
<a name="ln2444">                        if ( j == TAUT_NON ) {</a>
<a name="ln2445">                            /*</a>
<a name="ln2446">                            if ( pInChI-&gt;nTotalCharge == NO_VALUE_INT ) {</a>
<a name="ln2447">                                pInChI-&gt;nTotalCharge = 0;</a>
<a name="ln2448">                            } else</a>
<a name="ln2449">                            */</a>
<a name="ln2450">                            if ( !pInChI-&gt;nTotalCharge &amp;&amp; k &lt; nNumComponents[iINChI][TAUT_YES] ) {</a>
<a name="ln2451">                                INChI *pAltInChI = &amp;pInpInChI[iINChI][TAUT_YES][k]; /* Mobile H InChI */</a>
<a name="ln2452">                                if ( pAltInChI-&gt;nTotalCharge &amp;&amp; pAltInChI-&gt;nTotalCharge != NO_VALUE_INT ) {</a>
<a name="ln2453">                                    pInChI-&gt;nTotalCharge = pAltInChI-&gt;nTotalCharge;</a>
<a name="ln2454">                                }</a>
<a name="ln2455">                            }</a>
<a name="ln2456">                        }</a>
<a name="ln2457">                        /***** Fixed H: add pInChI-&gt;nNum_H_fixed to pInChI-&gt;nNum_H ****/</a>
<a name="ln2458">                        if ( j == TAUT_NON &amp;&amp; pInChI-&gt;nNum_H &amp;&amp; pInChI-&gt;nNum_H_fixed ) {</a>
<a name="ln2459">                            for ( m = 0; m &lt; pInChI-&gt;nNumberOfAtoms; m ++ ) {</a>
<a name="ln2460">                                pInChI-&gt;nNum_H[m] += pInChI-&gt;nNum_H_fixed[m];</a>
<a name="ln2461">                            }</a>
<a name="ln2462">                        }</a>
<a name="ln2463">                        /***** copy isotopic atoms: Mobile H --&gt; Fixed H ******/ </a>
<a name="ln2464">                        if ( j == TAUT_YES &amp;&amp; pInChI-&gt;nNumberOfIsotopicAtoms &amp;&amp;</a>
<a name="ln2465">                             k &lt; nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln2466">                            INChI *pAltInChI = &amp;pInpInChI[iINChI][TAUT_NON][k]; /* Fixed H InChI */</a>
<a name="ln2467"> </a>
<a name="ln2468">                            if ( !pAltInChI-&gt;nNumberOfIsotopicAtoms ) {</a>
<a name="ln2469">                                ret2=CopySegment( pAltInChI, pInChI, CPY_ISO_AT, 0, 0);</a>
<a name="ln2470">                                if ( ret2 &lt; 0 ) {</a>
<a name="ln2471">                                    goto exit_function;</a>
<a name="ln2472">                                }</a>
<a name="ln2473">                            }</a>
<a name="ln2474">                        }</a>
<a name="ln2475">                        /**** copy coordinates: Mobile H --&gt; Fixed H ******/</a>
<a name="ln2476">                        if ( j == TAUT_YES &amp;&amp; pInChI-&gt;IsotopicTGroup &amp;&amp;</a>
<a name="ln2477">                             k &lt; nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln2478">                            INChI *pAltInChI = &amp;pInpInChI[iINChI][TAUT_NON][k]; /* Fixed H InChI */</a>
<a name="ln2479"> </a>
<a name="ln2480">                            if ( !pAltInChI-&gt;IsotopicTGroup ) {</a>
<a name="ln2481">                                XYZ_COORD *pxyz = (XYZ_COORD *)inchi_calloc( pInChI-&gt;nNumberOfAtoms, sizeof(pxyz[0]));</a>
<a name="ln2482">                                if ( pxyz ) {</a>
<a name="ln2483">                                    memcpy( pxyz, pInChI-&gt;IsotopicTGroup, pInChI-&gt;nNumberOfAtoms * sizeof(pxyz[0]) );</a>
<a name="ln2484">                                    pAltInChI-&gt;IsotopicTGroup = (INChI_IsotopicTGroup *)pxyz;</a>
<a name="ln2485">                                } else {</a>
<a name="ln2486">                                    ret2 = RI_ERR_ALLOC;</a>
<a name="ln2487">                                    goto exit_function;</a>
<a name="ln2488">                                }</a>
<a name="ln2489">                            }</a>
<a name="ln2490">                        }</a>
<a name="ln2491"> </a>
<a name="ln2492">                        /********************************************************</a>
<a name="ln2493">                         *                                                      *</a>
<a name="ln2494">                         *            Restore omitted stereo seqments           *</a>
<a name="ln2495">                         *                                                      *</a>
<a name="ln2496">                         * order of restoring:                                  *</a>
<a name="ln2497">                         *                                                      *</a>
<a name="ln2498">                         * 1. Fixed H            (F) -&gt; (FI) Isotopic Fixed H   *</a>
<a name="ln2499">                         * 2. Mobile H           (M) -&gt; (F)  Fixed H            *</a>
<a name="ln2500">                         * 3. Isotopic Mobile H (MI) -&gt; (FI) Isotopic Fixed H   *</a>
<a name="ln2501">                         * 4. Mobile H           (M) -&gt; (MI) Isotopic Mobile H  *</a>
<a name="ln2502">                         *                                                      *</a>
<a name="ln2503">                         ********************************************************/</a>
<a name="ln2504"> </a>
<a name="ln2505">                        /***** (4) copy stereo: Mobile H --&gt; isotopic Mobile H ******/</a>
<a name="ln2506">                        if ( j == TAUT_YES ) {</a>
<a name="ln2507">                            int bIso = pInChI-&gt;nNumberOfIsotopicAtoms || </a>
<a name="ln2508">                                   (pInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2509">                                    pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters </a>
<a name="ln2510">                                  + pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds) ||</a>
<a name="ln2511">                                  (pInChI_Alt &amp;&amp; pInChI_Alt-&gt;nNumberOfIsotopicAtoms);</a>
<a name="ln2512"> </a>
<a name="ln2513">                            /* non-isotopic Mobile H =&gt; isotopic Mobile H */</a>
<a name="ln2514">                            if ( bIso ) {</a>
<a name="ln2515">                                if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2516">                                     (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;t_parity) ) {</a>
<a name="ln2517">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3, 1, 0)) ||</a>
<a name="ln2518">                                         ((!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) &amp;&amp;</a>
<a name="ln2519">                                         0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3_M, 1, 0)))) {</a>
<a name="ln2520">                                        goto exit_function;</a>
<a name="ln2521">                                    }</a>
<a name="ln2522">                                    if ( (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2523">                                         if ( pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2524">                                             pInChI-&gt;Stereo-&gt;nCompInv2Abs = s[iINChI][j][0]&gt;0? 2 : 0;</a>
<a name="ln2525">                                         }</a>
<a name="ln2526">                                         if ( pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2527">                                             pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = s[iINChI][j][1]&gt;0? 2 : 0;</a>
<a name="ln2528">                                         }</a>
<a name="ln2529">                                    }</a>
<a name="ln2530">                                } else</a>
<a name="ln2531">                                /* copy sp3 inversion info: non-isotopic Mobile H =&gt; isotopic Mobile H  */</a>
<a name="ln2532">                                if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2533">                                     pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2534">                                     pInChI-&gt;Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln2535">                                    if ( (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln2536">                                         pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2537">                                         pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2538">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = s[iINChI][j][0]&gt;0? 2 : 0;</a>
<a name="ln2539">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = s[iINChI][j][1]&gt;0? 2 : 0;</a>
<a name="ln2540">                                    } else</a>
<a name="ln2541">                                    if (!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs ) {</a>
<a name="ln2542">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = pInChI-&gt;Stereo-&gt;nCompInv2Abs;</a>
<a name="ln2543">                                    }</a>
<a name="ln2544">                                }</a>
<a name="ln2545">                            }</a>
<a name="ln2546">                            if ( bIso &amp;&amp;</a>
<a name="ln2547">                                 pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds &amp;&amp;</a>
<a name="ln2548">                                 (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;b_parity) ) {</a>
<a name="ln2549">                                if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP2, 1, 0)) ) {</a>
<a name="ln2550">                                    goto exit_function;</a>
<a name="ln2551">                                }</a>
<a name="ln2552">                            }</a>
<a name="ln2553">                        }</a>
<a name="ln2554">                        /***** (0) set nCompInv2Abs to Fixed-H *********************************/</a>
<a name="ln2555">                        if ( j == TAUT_NON ) {</a>
<a name="ln2556">                            if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2557">                                 pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2558">                                /* case of /sN and /t... in non-isotopic Mobile-H, no /s in non-isotopic Fixed-H */</a>
<a name="ln2559">                                if ( !s[iINChI][j][0] &amp;&amp; s[iINChI][jAlt][0]&gt;0 &amp;&amp;  /* /sN is not present in F and is present in M */</a>
<a name="ln2560">                                     pInChI_Alt &amp;&amp; pInChI_Alt-&gt;Stereo &amp;&amp; pInChI_Alt-&gt;Stereo-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln2561">                                    /* inherit from Mobile-H */</a>
<a name="ln2562">                                    /* /s1 in M and MI; /m1 or /m0 in MI; /m. in M; no /m in F. Inherit MI-&gt;FI. Added 10-15-2007 */</a>
<a name="ln2563">                                    if ( pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs == 0 &amp;&amp;                    /*  M: /m. ; means no /m for this component */</a>
<a name="ln2564">                                         pInChI-&gt;Stereo-&gt;nCompInv2Abs     == NO_VALUE_INT &amp;&amp;         /*  F: no /m segment for all components */</a>
<a name="ln2565">                                         pInChI_Alt-&gt;StereoIsotopic &amp;&amp;                               /*  MI: present */</a>
<a name="ln2566">                                         pInChI_Alt-&gt;StereoIsotopic-&gt;nCompInv2Abs != 0 &amp;&amp;</a>
<a name="ln2567">                                         pInChI_Alt-&gt;StereoIsotopic-&gt;nCompInv2Abs != NO_VALUE_INT &amp;&amp; /* MI:    /m0 or /m1  */</a>
<a name="ln2568">                                         !s[iINChI][j][0] &amp;&amp; !s[iINChI][j][1] &amp;&amp;                     /* F, FI: no /s       */</a>
<a name="ln2569">                                         s[iINChI][jAlt][0] == 1 &amp;&amp; s[iINChI][jAlt][1] == 1          /* M, MI: /s1 and /s1 */</a>
<a name="ln2570">                                       ) {</a>
<a name="ln2571">                                        /* copy /m from MI to FI */</a>
<a name="ln2572">                                        if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI_Alt, CPY_SP3_M, 1, 1)) ) {</a>
<a name="ln2573">                                            goto exit_function;</a>
<a name="ln2574">                                        }</a>
<a name="ln2575">                                    } else</a>
<a name="ln2576">                                    /* the following if(){...} was added to fix m1 bug 2007-09-25 DT */</a>
<a name="ln2577">                                    if ( pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs != NO_VALUE_INT &amp;&amp; s[iINChI][jAlt][0] == 1 ) {</a>
<a name="ln2578">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs;</a>
<a name="ln2579">                                    } else</a>
<a name="ln2580">                                    /* M and MI contain /sN and /sN, N=2,3. Added 10-15-2007 */</a>
<a name="ln2581">                                    if ( pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2582">                                         pInChI-&gt;Stereo-&gt;nCompInv2Abs     == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2583">                                         !s[iINChI][j][0] &amp;&amp; !s[iINChI][j][1] &amp;&amp;</a>
<a name="ln2584">                                         (s[iINChI][jAlt][0] &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln2585">                                         (s[iINChI][jAlt][1] &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2586">                                        int bIso = pInChI-&gt;nNumberOfIsotopicAtoms || </a>
<a name="ln2587">                                               (pInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2588">                                                pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters </a>
<a name="ln2589">                                              + pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds) ||</a>
<a name="ln2590">                                               (pInChI_Alt &amp;&amp; pInChI_Alt-&gt;nNumberOfIsotopicAtoms);</a>
<a name="ln2591">                                        if ( bIso ){</a>
<a name="ln2592">                                            if ( !pInChI_Alt-&gt;StereoIsotopic &amp;&amp;  /* create zero/NULL-initialized pInChI_Alt-&gt;StereoIsotopic */</a>
<a name="ln2593">                                                 0 &gt; (ret2 = CopySegment( pInChI_Alt, pInChI_Alt, CPY_SP3_M, 1, -1))) {</a>
<a name="ln2594">                                                goto exit_function;</a>
<a name="ln2595">                                            }</a>
<a name="ln2596">                                            pInChI_Alt-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;  /* MI: /m1 or /m0 */</a>
<a name="ln2597">                                            pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs         = 0;  /* M:  /m. ; no /m for this component */</a>
<a name="ln2598">                                            pInChI-&gt;Stereo-&gt;nCompInv2Abs = NO_VALUE_INT+1; /* FI: Stereo-&gt;CompInv2Abs=0, StereoIsotopic-&gt;CompInv2Abs=1 or -1 */</a>
<a name="ln2599">                                        } else {</a>
<a name="ln2600">                                            pInChI-&gt;Stereo-&gt;nCompInv2Abs     = 2; /* F:  /m1 or /m0, omitted from InChI as a repetition */</a>
<a name="ln2601">                                            pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs = 2; /* M:  /m1 or /m0; in Srel/SRac case the value = 2 */</a>
<a name="ln2602">                                        }</a>
<a name="ln2603">                                    } else {</a>
<a name="ln2604">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = 2;         /* F:  /m1 or /m0, omitted from InChI as a repetition */</a>
<a name="ln2605">                                        pInChI_Alt-&gt;Stereo-&gt;nCompInv2Abs = 2;     /* M:  /m1 or /m0; in Srel/SRac case the value = 2 */</a>
<a name="ln2606">                                    }</a>
<a name="ln2607">                                } else</a>
<a name="ln2608">                                /* case of /sN in Isotopic Fixed-H only, /t... in Fixed-H, no /m (2007-08-27 DT) */</a>
<a name="ln2609">                                if ( !s[iINChI][j][0] &amp;&amp; !s[iINChI][jAlt][0] &amp;&amp; /* /sN in Fixed-H isotopic only */</a>
<a name="ln2610">                                     (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln2611">                                     !(pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp;</a>
<a name="ln2612">                                     /*!(pInChI_Alt &amp;&amp; pInChI_Alt-&gt;Stereo &amp;&amp; pInChI_Alt-&gt;Stereo-&gt;nNumberOfStereoCenters) &amp;&amp;*/</a>
<a name="ln2613">                                     !(pInChI_Alt &amp;&amp; pInChI_Alt-&gt;StereoIsotopic &amp;&amp; pInChI_Alt-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln2614">                                    pInChI-&gt;Stereo-&gt;nCompInv2Abs = NO_VALUE_INT+1; /* Stereo-&gt;CompInv2Abs=0, StereoIsotopic-&gt;CompInv2Abs=1 or -1 */</a>
<a name="ln2615">                                } else {</a>
<a name="ln2616">                                    pInChI-&gt;Stereo-&gt;nCompInv2Abs = s[iINChI][j][0]&gt;0? 2 : 0;</a>
<a name="ln2617">                                }</a>
<a name="ln2618">                            }</a>
<a name="ln2619">                        }</a>
<a name="ln2620">                        /***** (1) copy stereo: non-isotopic Fixed H --&gt; isotopic Fixed H ******/</a>
<a name="ln2621">                        if ( j == TAUT_NON ) {</a>
<a name="ln2622">                            int bIso = pInChI-&gt;nNumberOfIsotopicAtoms || </a>
<a name="ln2623">                                   (pInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2624">                                    pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters </a>
<a name="ln2625">                                  + pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds) ||</a>
<a name="ln2626">                                   (pInChI_Alt &amp;&amp; pInChI_Alt-&gt;nNumberOfIsotopicAtoms);</a>
<a name="ln2627">                            /* non-isotopic Fixed H =&gt; isotopic Fixed H */</a>
<a name="ln2628">                            if ( bIso ) {</a>
<a name="ln2629">                                if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2630">                                    (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;t_parity) ) {</a>
<a name="ln2631">                                    /* -- replaced 2007-08-27 by (aaa), see below -- DT</a>
<a name="ln2632">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3, 1, 0)) ||</a>
<a name="ln2633">                                         !(pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) &amp;&amp;</a>
<a name="ln2634">                                         0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3_M, 1, 0))) {</a>
<a name="ln2635">                                        goto exit_function;</a>
<a name="ln2636">                                    }</a>
<a name="ln2637">                                    */</a>
<a name="ln2638">                                    /*----------- replacement (aaa) begin 2007-08-27 DT */</a>
<a name="ln2639">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3, 1, 0)) ) {</a>
<a name="ln2640">                                        goto exit_function;</a>
<a name="ln2641">                                    }</a>
<a name="ln2642">                                    if ( pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT+1 ) {</a>
<a name="ln2643">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln2644">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;</a>
<a name="ln2645">                                    } else</a>
<a name="ln2646">                                    if ( !(pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) &amp;&amp;</a>
<a name="ln2647">                                         0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3_M, 1, 0))) {</a>
<a name="ln2648">                                        goto exit_function;</a>
<a name="ln2649">                                    }</a>
<a name="ln2650">                                    /*----------- replacement (aaa) end 2007-08-27 DT */</a>
<a name="ln2651">                                    if ( (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2652">                                         if ( pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2653">                                             pInChI-&gt;Stereo-&gt;nCompInv2Abs = s[iINChI][j][0]&gt;0? 2 : 0;</a>
<a name="ln2654">                                         }</a>
<a name="ln2655">                                         if ( pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2656">                                             pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = s[iINChI][j][1]&gt;0? 2 : 0;</a>
<a name="ln2657">                                         }</a>
<a name="ln2658">                                    }</a>
<a name="ln2659">#ifdef NEVER</a>
<a name="ln2660">                                    if ( (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln2661">                                         !s[iINChI][j][0] &amp;&amp; s[iINChI][j][0]&gt;0 ) {</a>
<a name="ln2662">                                        /* copied Rel/Rac stereo to Iso; /s is in Iso /s is not in non-Iso */</a>
<a name="ln2663">                                        /* this means all difference in stereo is in inversion */</a>
<a name="ln2664">                                        if ( pInChI-&gt;Stereo-&gt;nCompInv2Abs         == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2665">                                             pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2666">                                            pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;         /* missing */</a>
<a name="ln2667">                                            pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2; /* unusual value */</a>
<a name="ln2668">                                        }</a>
<a name="ln2669">                                    }</a>
<a name="ln2670">#endif</a>
<a name="ln2671">                                } else</a>
<a name="ln2672">                                /* copy sp3 inversion info: non-isotopic Fixed H --&gt; isotopic Fixed H  */</a>
<a name="ln2673">                                if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2674">                                     pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2675">                                     pInChI-&gt;Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln2676">                                    if ( (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln2677">                                         pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2678">                                         pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2679">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = s[iINChI][j][0]&gt;0? 2 : 0;</a>
<a name="ln2680">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = s[iINChI][j][1]&gt;0? 2 : 0;</a>
<a name="ln2681">                                    } else</a>
<a name="ln2682">                                    if (!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) {</a>
<a name="ln2683">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = pInChI-&gt;Stereo-&gt;nCompInv2Abs;</a>
<a name="ln2684">                                    }</a>
<a name="ln2685">                                }   </a>
<a name="ln2686">                            }</a>
<a name="ln2687">                            if ( bIso &amp;&amp;</a>
<a name="ln2688">                                 pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds &amp;&amp;</a>
<a name="ln2689">                                 (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;b_parity) ) {</a>
<a name="ln2690">                                if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP2, 1, 0)) ) {</a>
<a name="ln2691">                                    goto exit_function;</a>
<a name="ln2692">                                }</a>
<a name="ln2693">                            }</a>
<a name="ln2694">                        }</a>
<a name="ln2695"> </a>
<a name="ln2696">                        /***** copy stereo: Mobile H --&gt; Fixed H ******/</a>
<a name="ln2697">                        if ( j == TAUT_NON &amp;&amp; k &lt; nNumComponents[iINChI][TAUT_YES] ) {</a>
<a name="ln2698">                            INChI *pAltInChI = &amp;pInpInChI[iINChI][TAUT_YES][k]; /* Mobile H InChI */</a>
<a name="ln2699">                            int bIso = pInChI-&gt;nNumberOfIsotopicAtoms || </a>
<a name="ln2700">                                   (pInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2701">                                    pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters </a>
<a name="ln2702">                                  + pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds) ||</a>
<a name="ln2703">                                   (pAltInChI &amp;&amp; (</a>
<a name="ln2704">                                   pAltInChI-&gt;nNumberOfIsotopicAtoms || </a>
<a name="ln2705">                                   (pAltInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2706">                                    pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters </a>
<a name="ln2707">                                  + pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds)) );</a>
<a name="ln2708">                            int bNo_InChI_t = (!pInChI-&gt;Stereo || !pInChI-&gt;Stereo-&gt;t_parity);</a>
<a name="ln2709">                            int bNo_InChI_m = (!pInChI-&gt;Stereo || NO_VALUE_INT == pInChI-&gt;Stereo-&gt;nCompInv2Abs);</a>
<a name="ln2710"> </a>
<a name="ln2711">                            /* (2) non-isotopic Mobile H =&gt; non-isotopic Fixed H */</a>
<a name="ln2712">                            if ( pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2713">                                 (!pInChI-&gt;Stereo || !pInChI-&gt;Stereo-&gt;t_parity) ) </a>
<a name="ln2714">                            {</a>
<a name="ln2715">#if ( FIX_I2I_STEREOCONVERSION_BUG2 == 1 )	</a>
<a name="ln2716">                                /* (2008-04-02)   1=&gt; Fix bug of i2i conversion SAbs--&gt;(SRel||Srac) */</a>
<a name="ln2717">                                /*                    (converter skipped empty '/t' or sometimes produced an excess one */</a>
<a name="ln2718"> </a>
<a name="ln2719">                                /* check whether t stereo is actually present */</a>
<a name="ln2720">                                int bHave_t_stereo = 1;</a>
<a name="ln2721">                                if (pInChI-&gt;Stereo)</a>
<a name="ln2722">                                    bHave_t_stereo = pInChI	-&gt;Stereo-&gt;nNumberOfStereoCenters;</a>
<a name="ln2723">                                /* account for stereobonds present */</a>
<a name="ln2724">                                if ( bHave_t_stereo &lt; 1 )</a>
<a name="ln2725">                                    if ( pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds &gt; 0 )</a>
<a name="ln2726">                                        bHave_t_stereo=1;</a>
<a name="ln2727">                                /* copy stereo anyway ... */</a>
<a name="ln2728">#endif</a>
<a name="ln2729">                                if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP3, 0, 0)) ||</a>
<a name="ln2730">                                     ((!pInChI-&gt;Stereo-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;Stereo-&gt;nCompInv2Abs) &amp;&amp;</a>
<a name="ln2731">                                     0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP3_M, 0, 0))) )</a>
<a name="ln2732">                                {</a>
<a name="ln2733">                                    goto exit_function;</a>
<a name="ln2734">                                }</a>
<a name="ln2735"> </a>
<a name="ln2736">#if ( FIX_I2I_STEREOCONVERSION_BUG2 == 1 )				</a>
<a name="ln2737">                                /* ... correct just copied stereo if applicable */</a>
<a name="ln2738">                                if ( (s[iINChI][j][0] &lt; 1)	&amp;&amp;</a>
<a name="ln2739">                                     (bHave_t_stereo &lt;1 )		&amp;&amp;</a>
<a name="ln2740">                                     (pAltInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &gt; 0) &amp;&amp;</a>
<a name="ln2741">                                     (s[iINChI][jAlt][0] &lt; 1) )</a>
<a name="ln2742">                                {</a>
<a name="ln2743">                                    /* (2010-02-28) if not all stereo centers are unknown/undefined */</a>
<a name="ln2744">                                    /*  at which condition stereo still should present .. */</a>
<a name="ln2745">                                    int all_UU = 1;</a>
<a name="ln2746">                                    for (kc=0; kc&lt;pAltInChI-&gt;Stereo-&gt;nNumberOfStereoCenters; kc++)</a>
<a name="ln2747">                                    {</a>
<a name="ln2748">                                        if ( (pAltInChI-&gt;Stereo-&gt;t_parity[kc] != AB_PARITY_UNKN) &amp;&amp;</a>
<a name="ln2749">                                             (pAltInChI-&gt;Stereo-&gt;t_parity[kc] != AB_PARITY_UNDF) )</a>
<a name="ln2750">                                        {</a>
<a name="ln2751">                                            all_UU=0;</a>
<a name="ln2752">                                            break;</a>
<a name="ln2753">                                        }</a>
<a name="ln2754">                                    }</a>
<a name="ln2755">                                    if (!all_UU)</a>
<a name="ln2756">                                        pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters = 0;</a>
<a name="ln2757">                                }					</a>
<a name="ln2758">#endif</a>
<a name="ln2759"> </a>
<a name="ln2760">                                /* in case of missing nCompInv2Abs, 2005-05-10 */</a>
<a name="ln2761">                                if ( (pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT) &amp;&amp;</a>
<a name="ln2762">                                     (nFlagsAlt &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2763">                                    if ( s[iINChI][jAlt][0] &gt; 0 &amp;&amp; s[iINChI][j][0] &gt; 0 ) {</a>
<a name="ln2764">                                         /* suppose once in a while only non-taut stereo changes if inverted */</a>
<a name="ln2765">                                        pAltInChI-&gt;Stereo-&gt;nCompInv2Abs = (++nMH2FH_AltInv)%2? 2:0;</a>
<a name="ln2766">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = 2;</a>
<a name="ln2767">                                    } else</a>
<a name="ln2768">                                    /* Mobile-H: /t.. /sN; Mobile-H isotopic: /sN (n=2 or 3), not /t...; Fixed-H layer is present, has no /t, no /i/t */</a>
<a name="ln2769">                                    /* Mobile-H /sN was caused by another component that would have same /mN in all layers */</a>
<a name="ln2770">                                    /* therefore, in case of Abs. Stereo, Mobile-H stereo isotopic stereo would have /m1 */</a>
<a name="ln2771">                                    /* In case of Rel/Rac stereo, since no /m1 could occur in Mobile-H isotopic, */</a>
<a name="ln2772">                                    /* no pAltInChI-&gt;StereoIsotopic or pInChI-&gt;StereoIsotopic have been created yet. */</a>
<a name="ln2773">                                    /* added 10-11-2007 to fix i2i bug for Rel/Rac stereo */</a>
<a name="ln2774">                                    if ( nNumComponents[iINChI][j] &gt; 1 &amp;&amp;</a>
<a name="ln2775">                                         bNo_InChI_t &amp;&amp; bNo_InChI_m /* no /t... or /mN in Fixed-H  */ &amp;&amp; !nFlags &amp;&amp;</a>
<a name="ln2776">                                         !(pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;t_parity) &amp;&amp;</a>
<a name="ln2777">                                         !(pInChI-&gt;StereoIsotopic    &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;t_parity) &amp;&amp;</a>
<a name="ln2778">                                          s[iINChI][j][0]==0 &amp;&amp; s[iINChI][j][1] == 0 &amp;&amp;</a>
<a name="ln2779">                                         /* /sN, N=2 or 3 only in Mobile-H AND Mobile-H isotopic */</a>
<a name="ln2780">                                         (s[iINChI][jAlt][0] &amp; ((INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO))) &amp;&amp;</a>
<a name="ln2781">                                         (s[iINChI][jAlt][1] &amp; ((INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO))) )</a>
<a name="ln2782">                                    {</a>
<a name="ln2783">                                        if ( bIso ) {</a>
<a name="ln2784">                                            /* create two zero/NULL-initialized isotopic stereo if they do not exist */</a>
<a name="ln2785">                                            if ( (!pInChI-&gt;StereoIsotopic    &amp;&amp; 0 &gt; (ret2 = CopySegment( pInChI,    pAltInChI, CPY_SP3_M, 1, -1)))</a>
<a name="ln2786">                                                /* -- the following will be created later, in TAUT_YES part of the code -- */</a>
<a name="ln2787">                                                || (!pAltInChI-&gt;StereoIsotopic &amp;&amp; 0 &gt; (ret2 = CopySegment( pAltInChI, pAltInChI, CPY_SP3_M, 1, -1))) ) {</a>
<a name="ln2788">                                                goto exit_function;</a>
<a name="ln2789">                                            }</a>
<a name="ln2790">                                            /* same value = 2 for MI and FI; here we assign only FI */</a>
<a name="ln2791">                                            pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;</a>
<a name="ln2792">                                            pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln2793">                                            /* -- the following will NOT be assigned later, in TAUT_YES part of the code -- */</a>
<a name="ln2794">                                            pAltInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;</a>
<a name="ln2795">                                            pAltInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln2796">                                            /* */</a>
<a name="ln2797">                                        } else {</a>
<a name="ln2798">                                            if ( NO_VALUE_INT == pInChI-&gt;Stereo-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2799">                                                 NO_VALUE_INT == pAltInChI-&gt;Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln2800">                                                pInChI-&gt;Stereo-&gt;nCompInv2Abs = 2;</a>
<a name="ln2801">                                                pAltInChI-&gt;Stereo-&gt;nCompInv2Abs = 2;</a>
<a name="ln2802">                                            }</a>
<a name="ln2803">                                        }</a>
<a name="ln2804">                                    } else</a>
<a name="ln2805">                                    if ( (s[iINChI][jAlt][0] &gt; 0 || s[iINChI][j][0] &gt; 0) &amp;&amp; s[iINChI][j][0] &gt;= 0 )</a>
<a name="ln2806">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs =  2;</a>
<a name="ln2807">                                    else</a>
<a name="ln2808">                                    /* Mobile-H: /t..., no /sN; Mobile-H isotopic: /s2 or /s3, not /t; Fixed-H layer is present, has no /t, no /i/t */</a>
<a name="ln2809">                                    /* therefore, in case of Abs. Stereo, Mobile-H stereo isotopic stereo would have /m1 */</a>
<a name="ln2810">                                    /* In case of Rel/Rac stereo, since no /m1 could occur in Mobile-H isotopic, */</a>
<a name="ln2811">                                    /* no pAltInChI-&gt;StereoIsotopic or pInChI-&gt;StereoIsotopic have been created yet. */</a>
<a name="ln2812">                                    /* added 10-10-2007 to fix i2i bug for Rel/Rac stereo */</a>
<a name="ln2813">                                    if ( bIso &amp;&amp; bNo_InChI_t &amp;&amp; bNo_InChI_m /* no /t... or /mN in Fixed-H  */ &amp;&amp; !nFlags &amp;&amp;</a>
<a name="ln2814">                                         !(pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;t_parity) &amp;&amp;</a>
<a name="ln2815">                                         !(pInChI-&gt;StereoIsotopic    &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;t_parity) &amp;&amp;</a>
<a name="ln2816">                                         s[iINChI][jAlt][0]==0 &amp;&amp; s[iINChI][j][0]==0 &amp;&amp; s[iINChI][j][1] == 0 &amp;&amp;</a>
<a name="ln2817">                                         /* /sN, N=2 or 3 only in Mobile-H isotopic */</a>
<a name="ln2818">                                         (s[iINChI][jAlt][1] &amp; ((INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO))) )</a>
<a name="ln2819">                                    {</a>
<a name="ln2820">                                        /* create two zero/NULL-initialized isotopic stereo if they do not exist */</a>
<a name="ln2821">                                        if ( !pInChI-&gt;StereoIsotopic    &amp;&amp; 0 &gt; (ret2 = CopySegment( pInChI,    pAltInChI, CPY_SP3_M, 1, -1)) </a>
<a name="ln2822">                                            /* -- the following will be created later, in TAUT_YES part of the code -- */</a>
<a name="ln2823">                                            /*|| !pAltInChI-&gt;StereoIsotopic &amp;&amp; 0 &gt; (ret2 = CopySegment( pAltInChI, pAltInChI, CPY_SP3_M, 1, -1))*/ ) {</a>
<a name="ln2824">                                            goto exit_function;</a>
<a name="ln2825">                                        }</a>
<a name="ln2826">                                        /* same value = 2 for MI and FI; here we assign only FI */</a>
<a name="ln2827">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;</a>
<a name="ln2828">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln2829">                                        /* -- the following will be assigned later, in TAUT_YES part of the code -- */</a>
<a name="ln2830">                                        /*</a>
<a name="ln2831">                                        pAltInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;</a>
<a name="ln2832">                                        pAltInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln2833">                                        */</a>
<a name="ln2834">                                    } else</a>
<a name="ln2835">                                        pInChI-&gt;Stereo-&gt;nCompInv2Abs =  0;</a>
<a name="ln2836">                                    if ( !(pInChI-&gt;nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2837">                                        pInChI-&gt;nFlags |= ((nFlagsAlt|nFlags) &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO));</a>
<a name="ln2838">                                    }</a>
<a name="ln2839">                                }</a>
<a name="ln2840"> </a>
<a name="ln2841">                            } else</a>
<a name="ln2842">                            /* copy sp3 inversion info: non-isotopic Mobile H =&gt; non-isotopic Fixed H  */</a>
<a name="ln2843">                            if ( pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2844">                                 pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2845">                                 pAltInChI-&gt;Stereo-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2846">                                 (!pInChI-&gt;Stereo-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;Stereo-&gt;nCompInv2Abs) ) {</a>
<a name="ln2847">                                if ( !(nFlagsAlt &amp;&amp; !nFlags ) || NO_VALUE_INT == pInChI-&gt;Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln2848">                                     /* ??? */</a>
<a name="ln2849">                                    pInChI-&gt;Stereo-&gt;nCompInv2Abs = pAltInChI-&gt;Stereo-&gt;nCompInv2Abs;</a>
<a name="ln2850">                                }</a>
<a name="ln2851">                            }</a>
<a name="ln2852"> </a>
<a name="ln2853">                            /* use same rule to copy stereobonds */</a>
<a name="ln2854">                            if ( pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;nNumberOfStereoBonds &amp;&amp;</a>
<a name="ln2855">                                 (!pInChI-&gt;Stereo || !pInChI-&gt;Stereo-&gt;b_parity) ) {</a>
<a name="ln2856">                                if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP2, 0, 0)) ) {</a>
<a name="ln2857">                                    goto exit_function;</a>
<a name="ln2858">                                }</a>
<a name="ln2859">                            }</a>
<a name="ln2860">                            /* (3) isotopic Mobile H -&gt; isotopic Fixed H */</a>
<a name="ln2861">                            /* if !FH_Stereo &amp;&amp; !MH_Stereo &amp;&amp; MH_IsoStereo!=NULL &amp;&amp; FH_IsoStereo==NULL */</a>
<a name="ln2862">                            if ( bIso ) { </a>
<a name="ln2863">                                if ( !(pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;t_parity) &amp;&amp;                                    /* !FH_Stereo */</a>
<a name="ln2864">                                     !(pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;t_parity) &amp;&amp;                              /* !MH_Stereo */</a>
<a name="ln2865">                                     (pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp; /*  MH_IsoStereo */</a>
<a name="ln2866">                                     (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;t_parity) ) {                  /* !FH_IsoStereo */</a>
<a name="ln2867">                                    /* copy sp3 iso stereo MI-&gt;FI (/t) and, if FH nCompInv2Abs (/m) is missing, copy it, too, MI-&gt;FI */ </a>
<a name="ln2868">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP3, 1, 1)) ||</a>
<a name="ln2869">                                         ((!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) &amp;&amp;</a>
<a name="ln2870">                                         0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP3_M, 1, 1))) ) {</a>
<a name="ln2871">                                        goto exit_function;</a>
<a name="ln2872">                                    }</a>
<a name="ln2873">                                    /* in case of missing nCompInv2Abs, Relative or Racemic stereo 2005-05-10 */</a>
<a name="ln2874">                                    if ( pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2875">                                         (nFlagsAlt &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2876">                                        pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = s[iINChI][jAlt][1]&gt;0? 2 : 0;</a>
<a name="ln2877">                                        if ( !(pInChI-&gt;nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2878">                                            pInChI-&gt;nFlags |= (nFlagsAlt &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO));</a>
<a name="ln2879">                                        }</a>
<a name="ln2880">                                    }</a>
<a name="ln2881">                                } else</a>
<a name="ln2882">                                /* copy sp3 inversion info only: isotopic Mobile H -&gt; isotopic Fixed H  */</a>
<a name="ln2883">                                if ( !(pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;t_parity) &amp;&amp;                                     /* !FH_Stereo    /t */</a>
<a name="ln2884">                                     !(pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;t_parity) &amp;&amp;                               /* !MH_Stereo    /t */</a>
<a name="ln2885">                                     (pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp;  /*  MH_IsoStereo /t */</a>
<a name="ln2886">                                     (pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp;        /*  FH_IsoStereo /t */</a>
<a name="ln2887">                                     pAltInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &amp;&amp;                                           /*  MH_IsoStereo /m */</a>
<a name="ln2888">                                     (!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) ) { /*  !FH_IsoStereo /m */</a>
<a name="ln2889">                                    /* added 02-09-2006 */</a>
<a name="ln2890">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP3_M, 1, 1)) ) {</a>
<a name="ln2891">                                        goto exit_function;</a>
<a name="ln2892">                                    }</a>
<a name="ln2893">                                }</a>
<a name="ln2894">                                /* use same rule to copy stereobonds */</a>
<a name="ln2895">                                if ( !(pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;b_parity) &amp;&amp;</a>
<a name="ln2896">                                     !(pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;b_parity) &amp;&amp;</a>
<a name="ln2897">                                     (pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds) &amp;&amp;</a>
<a name="ln2898">                                     (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;b_parity) ) {</a>
<a name="ln2899">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP2, 1, 1)) ) {</a>
<a name="ln2900">                                        goto exit_function;</a>
<a name="ln2901">                                    }</a>
<a name="ln2902">                                }</a>
<a name="ln2903"> </a>
<a name="ln2904">                                /* (4) Copy Fixed-H -&gt; isotopic Fixed-H */</a>
<a name="ln2905">                                /* if FH_Stereo &amp;&amp; !MH_IsoStereo &amp;&amp; &amp;&amp; !FH_IsoStereo */</a>
<a name="ln2906">                                if ( (pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters) &amp;&amp;              /* FH_Stereo     /t */</a>
<a name="ln2907">                                     !(pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;t_parity) &amp;&amp;     /* !MH_IsoStereo /t */</a>
<a name="ln2908">                                     !(pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;t_parity) ) {          /* !FH_IsoStereo /t */</a>
<a name="ln2909"> </a>
<a name="ln2910">                                    /* added 10-10-2007 DT: copy MH_Iso /m =&gt; FH_Iso /m to fix i2i bug for Abs stereo */</a>
<a name="ln2911">                                    /* InChI string contains: MH(/t...), MH_Iso(/mN, no /t), FH(no /t /m), FH_Iso(no /t /m) */</a>
<a name="ln2912">                                    if ( pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &amp;&amp; /* MH_IsoStereo /m */</a>
<a name="ln2913">                                         bNo_InChI_t &amp;&amp;</a>
<a name="ln2914">                                         NO_VALUE_INT != pAltInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &amp;&amp;              /* undef FH_IsoStereo /m */</a>
<a name="ln2915">                                         !(pInChI-&gt;StereoIsotopic &amp;&amp; NO_VALUE_INT != pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs)) {</a>
<a name="ln2916">                                        if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP3_M, 1, 1))) {</a>
<a name="ln2917">                                            goto exit_function;</a>
<a name="ln2918">                                        }</a>
<a name="ln2919">                                    }</a>
<a name="ln2920"> </a>
<a name="ln2921">                                    /* added 05-09-2006: copy sp3 FH=&gt;FH_Iso */</a>
<a name="ln2922">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3, 1, 0)) ||</a>
<a name="ln2923">                                         ((!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) &amp;&amp;</a>
<a name="ln2924">                                         0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3_M, 1, 0))) ) {</a>
<a name="ln2925">                                        goto exit_function;</a>
<a name="ln2926">                                    }</a>
<a name="ln2927">                                    /* in case of missing nCompInv2Abs, Relative or Racemic stereo, /sN in Fixed-H, 2005-05-10 */</a>
<a name="ln2928">                                    if ( pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT &amp;&amp;</a>
<a name="ln2929">                                         (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2930">                                        if ( s[iINChI][j][0] &gt; 0 &amp;&amp; s[iINChI][j][1] &gt; 0 ) {</a>
<a name="ln2931">                                             /* suppose once in a while only non-taut stereo changes if inverted */</a>
<a name="ln2932">                                            pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 2;</a>
<a name="ln2933">                                            pInChI-&gt;Stereo-&gt;nCompInv2Abs =  (++nFH2iFH_AltInv)%2? 2:0;</a>
<a name="ln2934">                                        } else</a>
<a name="ln2935">                                        if ( (s[iINChI][j][0] &gt; 0 || s[iINChI][j][1] &gt; 0) &amp;&amp; s[iINChI][j][1] &gt;= 0 ) /* ??? != NO_VALUE_INT ??? */</a>
<a name="ln2936">                                            pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs =  2;</a>
<a name="ln2937">                                        else</a>
<a name="ln2938">                                            pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs =  0;</a>
<a name="ln2939">                                        if ( !(pInChI-&gt;nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO)) ) {</a>
<a name="ln2940">                                            pInChI-&gt;nFlags |= (nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO));</a>
<a name="ln2941">                                        }</a>
<a name="ln2942">                                    }</a>
<a name="ln2943"> </a>
<a name="ln2944">                                } else</a>
<a name="ln2945">                                /* copy sp3 inversion info only: Fixed-H -&gt; isotopic Fixed H  */</a>
<a name="ln2946">                                if ( (pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;t_parity) &amp;&amp;</a>
<a name="ln2947">                                     !(pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;t_parity) &amp;&amp;</a>
<a name="ln2948">                                     (pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp;</a>
<a name="ln2949">                                     (pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp;</a>
<a name="ln2950">                                     pInChI-&gt;Stereo-&gt;nCompInv2Abs &amp;&amp; </a>
<a name="ln2951">                                     (!pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs || NO_VALUE_INT == pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs) ) {</a>
<a name="ln2952">                                    /* added 05-09-2006 */</a>
<a name="ln2953">                                    if ( 0 &gt; (ret2 = CopySegment( pInChI, pInChI, CPY_SP3_M, 1, 0)) ) {</a>
<a name="ln2954">                                        goto exit_function;</a>
<a name="ln2955">                                    }</a>
<a name="ln2956">                                }</a>
<a name="ln2957">                            }</a>
<a name="ln2958">                            if ( bIso &amp;&amp; </a>
<a name="ln2959">                                 !(pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nNumberOfStereoBonds) &amp;&amp;</a>
<a name="ln2960">                                 !(pAltInChI-&gt;Stereo &amp;&amp; pAltInChI-&gt;Stereo-&gt;nNumberOfStereoBonds) &amp;&amp;</a>
<a name="ln2961">                                  (pAltInChI-&gt;StereoIsotopic &amp;&amp; pAltInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds) &amp;&amp;</a>
<a name="ln2962">                                 (!pInChI-&gt;StereoIsotopic || !pInChI-&gt;StereoIsotopic-&gt;b_parity) ) {</a>
<a name="ln2963">                                if ( 0 &gt; (ret2 = CopySegment( pInChI, pAltInChI, CPY_SP2, 1, 1)) ) {</a>
<a name="ln2964">                                    goto exit_function;</a>
<a name="ln2965">                                }</a>
<a name="ln2966">                            }</a>
<a name="ln2967">                        }</a>
<a name="ln2968">                    }  </a>
<a name="ln2969">                } /* end of component cycle (k) */</a>
<a name="ln2970">            } /* end of Mobile/Fixed H cycle (j) */</a>
<a name="ln2971"> </a>
<a name="ln2972">            /**** replace NO_VALUE_INT with zeroes in all Mobile &amp; Fixed H components ****/</a>
<a name="ln2973">            for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln2974">                for ( k = 0; k &lt; nNumComponents[iINChI][j]; k ++ ) {</a>
<a name="ln2975">                    if ( pInpInChI[iINChI][j] ) {</a>
<a name="ln2976">                        INChI *pInChI = &amp;pInpInChI[iINChI][j][k];</a>
<a name="ln2977">                        if ( pInChI-&gt;nTotalCharge == NO_VALUE_INT ) {</a>
<a name="ln2978">                            pInChI-&gt;nTotalCharge = 0;</a>
<a name="ln2979">                        }</a>
<a name="ln2980">                        if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2981">                             pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2982">                                 if ( pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2983">                                      pInChI-&gt;Stereo-&gt;nCompInv2Abs != NO_VALUE_INT ) {</a>
<a name="ln2984">                                 pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = pInChI-&gt;Stereo-&gt;nCompInv2Abs;</a>
<a name="ln2985">                            }</a>
<a name="ln2986">                        }</a>
<a name="ln2987">                        /* Add special nCompInv2Abs=2 to force /s2 or /s3 in InChI output */</a>
<a name="ln2988">                        if ( pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2989">                            if ( pInChI-&gt;nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO) &amp;&amp;</a>
<a name="ln2990">                                 pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln2991">                                pInChI-&gt;Stereo-&gt;nCompInv2Abs = (s[iINChI][j][0]&gt;0 /*|| s[iINChI][j][1]&gt;0*/)? 2 : 0; /* we do not know the real value */</a>
<a name="ln2992">                            } else {</a>
<a name="ln2993">                                pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln2994">                            }</a>
<a name="ln2995">                        }</a>
<a name="ln2996">                        if ( pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT ) {</a>
<a name="ln2997">                            if ( pInChI-&gt;nFlags &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO) &amp;&amp;</a>
<a name="ln2998">                                 pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln2999">                                pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = s[iINChI][j][1]&gt;0? 2 : 0; /* we do not know the real value */</a>
<a name="ln3000">                            } else {</a>
<a name="ln3001">                                pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 0;</a>
<a name="ln3002">                            }</a>
<a name="ln3003">                        }</a>
<a name="ln3004">                        /* added 02-07-2006 */</a>
<a name="ln3005">                        if ( (pInChI-&gt;Stereo &amp;&amp; pInChI-&gt;Stereo-&gt;nCompInv2Abs == NO_VALUE_INT) ||</a>
<a name="ln3006">                             (pInChI-&gt;StereoIsotopic &amp;&amp; pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs == NO_VALUE_INT) ) {</a>
<a name="ln3007">                            ret2 = RI_ERR_PROGR;</a>
<a name="ln3008">                            goto exit_function;</a>
<a name="ln3009">                        }</a>
<a name="ln3010">                        if ( !pInChI-&gt;bDeleted &amp;&amp; pInChI-&gt;nNumberOfAtoms ) {</a>
<a name="ln3011">                            tot_charge[iINChI][j] += pInChI-&gt;nTotalCharge;</a>
<a name="ln3012">                            for ( m = 0; m &lt; pInChI-&gt;nNumberOfAtoms; m ++ ) {</a>
<a name="ln3013">                                if ( pInChI-&gt;nAtom[m] &lt; EL_NUMBER_H || pInChI-&gt;nAtom[m] &gt; nElDataLen ) {</a>
<a name="ln3014">                                    ret2 = RI_ERR_PROGR;</a>
<a name="ln3015">                                    goto exit_function;</a>
<a name="ln3016">                                }</a>
<a name="ln3017">                                /* all atoms except H */</a>
<a name="ln3018">                                if ( pInChI-&gt;nAtom[m] &gt; EL_NUMBER_H ) {</a>
<a name="ln3019">                                    num_elem[iINChI][j][pInChI-&gt;nAtom[m]].num ++;</a>
<a name="ln3020">                                }</a>
<a name="ln3021">                            }</a>
<a name="ln3022">                            if ( 0 &gt; (ret2 = GetInChINumH( pInChI, &amp;m ) ) ) {</a>
<a name="ln3023">                                goto exit_function;</a>
<a name="ln3024">                            }</a>
<a name="ln3025">                            num_elem[iINChI][j][EL_NUMBER_H].num += m;</a>
<a name="ln3026">                        }</a>
<a name="ln3027">                    }</a>
<a name="ln3028">                }</a>
<a name="ln3029">            }</a>
<a name="ln3030"> </a>
<a name="ln3031"> </a>
<a name="ln3032">            for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3033">                for ( k = 0; k &lt; nNumComponents[iINChI][j]; k ++ ) </a>
<a name="ln3034">                {</a>
<a name="ln3035">                    if ( pInpInChI[iINChI][j] ) </a>
<a name="ln3036">                    {</a>
<a name="ln3037">                        INChI *pInChI = &amp;pInpInChI[iINChI][j][k];</a>
<a name="ln3038">                        if ( pInChI-&gt;Stereo &amp;&amp; !pInChI-&gt;Stereo-&gt;nNumberOfStereoCenters ) </a>
<a name="ln3039">                        {</a>
<a name="ln3040">                            pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0;</a>
<a name="ln3041">                        }</a>
<a name="ln3042">                        if ( pInChI-&gt;StereoIsotopic &amp;&amp; !pInChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters ) </a>
<a name="ln3043">                        {</a>
<a name="ln3044">                            pInChI-&gt;StereoIsotopic-&gt;nCompInv2Abs = 0;</a>
<a name="ln3045">                        }</a>
<a name="ln3046">                    }</a>
<a name="ln3047">                }</a>
<a name="ln3048">            }</a>
<a name="ln3049"> </a>
<a name="ln3050"> </a>
<a name="ln3051">#if ( FIX_I2I_STEREOCONVERSION_BUG3 == 1 )	</a>
<a name="ln3052">/* (2008-04-10)   1=&gt; Fix bug of i2i conversion */</a>
<a name="ln3053">/* (missed repeating /s in FI after F for multi-component case) */	</a>
<a name="ln3054">            if (nNumComponents[iINChI][TAUT_NON]&gt;1)					 /* if multi-component */</a>
<a name="ln3055">            if ( !s[iINChI][TAUT_YES][0] &amp;&amp; !s[iINChI][TAUT_YES][1] )/* if no /s in M, MI */</a>
<a name="ln3056">            if ( (s[iINChI][TAUT_NON][0]&gt;1) &amp;&amp; (s[iINChI][TAUT_NON][1]&gt;1) )	 /* if /srel/srac in both F, FI */			</a>
<a name="ln3057">            if ( s[iINChI][TAUT_NON][0] == s[iINChI][TAUT_NON][1] )  /* if same stereo in F and FI */</a>
<a name="ln3058">            /* we assume that at least one component in F has no actual stereo */</a>
<a name="ln3059">            /* and place deliberately 0 to appropriate place */</a>
<a name="ln3060">            for ( k = 0; k &lt; nNumComponents[iINChI][TAUT_NON]; k ++ ) </a>
<a name="ln3061">            {</a>
<a name="ln3062">                INChI *pInChI = &amp;pInpInChI[iINChI][TAUT_NON][k]; </a>
<a name="ln3063">                if (pInChI-&gt;Stereo-&gt;nCompInv2Abs!=0)</a>
<a name="ln3064">                { </a>
<a name="ln3065">                    pInChI-&gt;Stereo-&gt;nCompInv2Abs = 0; </a>
<a name="ln3066">                    goto fini; </a>
<a name="ln3067">                }</a>
<a name="ln3068">            }</a>
<a name="ln3069">fini:		;</a>
<a name="ln3070">#endif</a>
<a name="ln3071"> </a>
<a name="ln3072"> </a>
<a name="ln3073">            if ( num_elem[iINChI][TAUT_YES] ) {</a>
<a name="ln3074">                tot_charge[iINChI][TAUT_YES]  += nNumProtons[iINChI][TAUT_YES].nNumRemovedProtons;</a>
<a name="ln3075">                num_elem[iINChI][TAUT_YES][EL_NUMBER_H].num += nNumProtons[iINChI][TAUT_YES].nNumRemovedProtons;</a>
<a name="ln3076">            }</a>
<a name="ln3077"> </a>
<a name="ln3078">            /**** Count H and isotopic H in Mobile and Fixed H represntations of components */</a>
<a name="ln3079">            /* if at least one component has Fixed-H layer then all components have Fixed-H */</a>
<a name="ln3080">            /* layer; those whose Fixed-H layer is empty have Fixed-H layer same as Mobile-H layer */</a>
<a name="ln3081">            if ( nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln3082">                /* only if both Mobile and Fixed H exist */</a>
<a name="ln3083">                int nFormulaH[TAUT_NUM], nNumH[TAUT_NUM], nCharge[TAUT_NUM], nNumIsotopicH[TAUT_NUM][NUM_H_ISOTOPES];</a>
<a name="ln3084">                int nRemovedCharge, nRemovedH, nRemovedIsotopicH[NUM_H_ISOTOPES], nFoundRemovedIsoH;</a>
<a name="ln3085">                int nTotRemovedProtons, nTotRemovedIsotopicH[NUM_H_ISOTOPES], bExists[TAUT_NUM];</a>
<a name="ln3086">                INChI *pInChI[TAUT_NUM];</a>
<a name="ln3087">                nTotRemovedProtons = 0;</a>
<a name="ln3088">                memset( nTotRemovedIsotopicH, 0, sizeof(nTotRemovedIsotopicH) );</a>
<a name="ln3089">                len2 = inchi_max( nNumComponents[iINChI][TAUT_YES], nNumComponents[iINChI][TAUT_NON] );</a>
<a name="ln3090">                </a>
<a name="ln3091">                for ( k = 0; k &lt; len2; k ++ ) {</a>
<a name="ln3092">                    /* k is a component index */</a>
<a name="ln3093">                    for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3094">                        /* j is 0=TAUT_NON or 1=TAUT_YES */</a>
<a name="ln3095">                        pInChI[j]  = NULL; /* initialization 2006-03 */</a>
<a name="ln3096">                        bExists[j] = (k &lt; nNumComponents[iINChI][j]) &amp;&amp;</a>
<a name="ln3097">                                     pInpInChI[iINChI][j][k].nNumberOfAtoms &amp;&amp;</a>
<a name="ln3098">                                    !pInpInChI[iINChI][j][k].bDeleted;</a>
<a name="ln3099">                    }</a>
<a name="ln3100">                    if ( !bExists[TAUT_NON] ) {</a>
<a name="ln3101">                        /* TAUT_YES does not exist for a proton (H+) in TAUT_NON */</a>
<a name="ln3102">                        ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3103">                        goto exit_function;</a>
<a name="ln3104">                    }</a>
<a name="ln3105">                    /* at this point at least one of Mobile[k] and Fixed[k] real InChI exists */</a>
<a name="ln3106">                    /* initialize for counting removed protons and isotopic H from kth  Mobile-H component */</a>
<a name="ln3107">                    for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3108">                        if ( bExists[j] ) {</a>
<a name="ln3109">                            pInChI[j] = &amp;pInpInChI[iINChI][j][k];  /* BC: reading uninit memory (fixed?) */</a>
<a name="ln3110">                        }</a>
<a name="ln3111">                        nFormulaH[j] = 0;</a>
<a name="ln3112">                        nNumH[j]     = 0;</a>
<a name="ln3113">                        nCharge[j]   = 0;</a>
<a name="ln3114">                        for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln3115">                            nNumIsotopicH[j][m] = 0;</a>
<a name="ln3116">                        }</a>
<a name="ln3117">                    }</a>
<a name="ln3118">                    /* extract number of H, isotopic H, and charge */</a>
<a name="ln3119">                    for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3120">                        if ( !bExists[j] )</a>
<a name="ln3121">                            continue;</a>
<a name="ln3122">                        if ( 0 &gt; (ret2 = GetInChIFormulaNumH( pInChI[j], &amp;nFormulaH[j] )) ||</a>
<a name="ln3123">                             0 &gt; (ret2 = GetInChINumH( pInChI[j], &amp;nNumH[j] )) ||</a>
<a name="ln3124">                             0 &gt; (ret2 = GetInChIIsoH( pInChI[j], nNumIsotopicH[j] )) ) {</a>
<a name="ln3125">                            goto exit_function;</a>
<a name="ln3126">                        }</a>
<a name="ln3127">                        nCharge[j] = pInChI[j]-&gt;nTotalCharge;</a>
<a name="ln3128">                    }</a>
<a name="ln3129">                    for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3130">                        if ( !bExists[j] )</a>
<a name="ln3131">                            continue;</a>
<a name="ln3132">                        if ( nFormulaH[j] != nNumH[j] ) {</a>
<a name="ln3133">                            ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3134">                            goto exit_function;</a>
<a name="ln3135">                         }</a>
<a name="ln3136">                    }</a>
<a name="ln3137">                    nFoundRemovedIsoH = 0;</a>
<a name="ln3138">                    nRemovedCharge = nCharge[TAUT_NON] - nCharge[TAUT_YES];</a>
<a name="ln3139">                    nRemovedH      = nNumH[TAUT_NON]   - nNumH[TAUT_YES];</a>
<a name="ln3140">                    for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln3141">                        nFoundRemovedIsoH += 0 != (nRemovedIsotopicH[m] = nNumIsotopicH[TAUT_NON][m] -</a>
<a name="ln3142">                                                                          nNumIsotopicH[TAUT_YES][m] );</a>
<a name="ln3143">                    }</a>
<a name="ln3144">                    if ( nRemovedCharge != nRemovedH ) {</a>
<a name="ln3145">                        ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3146">                        goto exit_function;</a>
<a name="ln3147">                    }</a>
<a name="ln3148">                    if ( nRemovedCharge || nFoundRemovedIsoH ) {</a>
<a name="ln3149">                        COMPONENT_REM_PROTONS *pNumProtons;</a>
<a name="ln3150">                        if ( !nNumProtons[iINChI][TAUT_YES].pNumProtons ) {</a>
<a name="ln3151">                            /* allocate only if needed */</a>
<a name="ln3152">                            nNumProtons[iINChI][TAUT_YES].pNumProtons = </a>
<a name="ln3153">                                (COMPONENT_REM_PROTONS *) inchi_calloc(len2,</a>
<a name="ln3154">                                                     sizeof(nNumProtons[0][0].pNumProtons[0]));</a>
<a name="ln3155">                            if ( !nNumProtons[iINChI][TAUT_YES].pNumProtons ) {</a>
<a name="ln3156">                                ret2 = RI_ERR_ALLOC;</a>
<a name="ln3157">                                goto exit_function;</a>
<a name="ln3158">                            }</a>
<a name="ln3159">                        }</a>
<a name="ln3160">                        pNumProtons = nNumProtons[iINChI][TAUT_YES].pNumProtons+k;</a>
<a name="ln3161">                        pNumProtons-&gt;nNumRemovedProtons = nRemovedH;</a>
<a name="ln3162">                        nTotRemovedProtons += nRemovedH;</a>
<a name="ln3163">                        for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln3164">                            pNumProtons-&gt;nNumRemovedIsotopicH[m] = nRemovedIsotopicH[m];</a>
<a name="ln3165">                            nTotRemovedIsotopicH[m] += nRemovedIsotopicH[m];</a>
<a name="ln3166">                        }</a>
<a name="ln3167">                        /* make sure the Mobile-H InChI has nTautomer */</a>
<a name="ln3168">                        if ( pInChI[TAUT_YES] &amp;&amp; bExists[TAUT_YES] ) {</a>
<a name="ln3169">                            if ( !pInChI[TAUT_YES]-&gt;lenTautomer ) {</a>
<a name="ln3170">                                pInChI[TAUT_YES]-&gt;lenTautomer = 1;</a>
<a name="ln3171">                            }</a>
<a name="ln3172">                            if ( !pInChI[TAUT_YES]-&gt;nTautomer ) {</a>
<a name="ln3173">                                pInChI[TAUT_YES]-&gt;nTautomer = (AT_NUMB *)inchi_calloc(pInChI[TAUT_YES]-&gt;lenTautomer, sizeof(pInChI[0]-&gt;nTautomer[0]) );</a>
<a name="ln3174">                            }</a>
<a name="ln3175">                        }</a>
<a name="ln3176">                    }</a>
<a name="ln3177">                }</a>
<a name="ln3178">                if ( nNumProtons[iINChI][TAUT_YES].pNumProtons ) {</a>
<a name="ln3179">                    /* check consistency */</a>
<a name="ln3180">#if ( FIX_ISO_FIXEDH_BUG_READ == 1 )</a>
<a name="ln3181">                    int iso_diff[NUM_H_ISOTOPES], iso_diff_tot=0;</a>
<a name="ln3182">#endif</a>
<a name="ln3183">                    if ( nTotRemovedProtons != nNumProtons[iINChI][TAUT_YES].nNumRemovedProtons ) {</a>
<a name="ln3184">                        ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3185">                        goto exit_function;</a>
<a name="ln3186">                    }</a>
<a name="ln3187">#if ( FIX_ISO_FIXEDH_BUG_READ == 1 )</a>
<a name="ln3188">                    for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln3189">                        iso_diff[m] = nNumProtons[iINChI][TAUT_YES].nNumRemovedIsotopicH[m]-nTotRemovedIsotopicH[m];</a>
<a name="ln3190">                        if ( iso_diff[m] &lt; 0 )</a>
<a name="ln3191">                        {</a>
<a name="ln3192">                            ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3193">                            goto exit_function;</a>
<a name="ln3194">                        } else {</a>
<a name="ln3195">                            /* InChI-1.02b bug: nTotRemovedIsotopicH[m] &lt; nNumProtons[iINChI][TAUT_YES].nNumRemovedIsotopicH[m] */</a>
<a name="ln3196">                            /* in non-tautomeric components where D(+) or T(+) was removed from -NH(+)= or =OH(+)           */ </a>
<a name="ln3197">                            iso_diff_tot += iso_diff[m]; </a>
<a name="ln3198">                        }</a>
<a name="ln3199">                    }</a>
<a name="ln3200">                    if ( iso_diff_tot ) {</a>
<a name="ln3201">                        if ( 0 &gt; bIsoMayBeArranged( bInchi2Struct, iso_diff, nNumProtons, pInpInChI, nNumComponents, iINChI )) {</a>
<a name="ln3202">                            ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3203">                            goto exit_function;</a>
<a name="ln3204">                        }</a>
<a name="ln3205">                    }</a>
<a name="ln3206">#else</a>
<a name="ln3207">                    for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln3208">                        if ( nTotRemovedIsotopicH[m] != nNumProtons[iINChI][TAUT_YES].nNumRemovedIsotopicH[m] ) {</a>
<a name="ln3209">                            ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3210">                            goto exit_function;</a>
<a name="ln3211">                        }</a>
<a name="ln3212">                    }</a>
<a name="ln3213">#endif</a>
<a name="ln3214">                }</a>
<a name="ln3215">            }</a>
<a name="ln3216"> </a>
<a name="ln3217">            /* make Mobile H and Fixed H InChI arrays have same length */</a>
<a name="ln3218">            len2 = len1 = 0;</a>
<a name="ln3219">            if ( nNumComponents[iINChI][TAUT_YES] &lt; nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln3220">                j = TAUT_YES; /* less components in Mobile-H layer */</a>
<a name="ln3221">                len2 = nNumComponents[iINChI][TAUT_NON];</a>
<a name="ln3222">                len1 = nNumComponents[iINChI][TAUT_YES];</a>
<a name="ln3223">            } else</a>
<a name="ln3224">            if ( nNumComponents[iINChI][TAUT_YES] &gt; nNumComponents[iINChI][TAUT_NON] ) {</a>
<a name="ln3225">                j = TAUT_NON;  /* less components in Fixed-H layer */</a>
<a name="ln3226">                len2 = nNumComponents[iINChI][TAUT_YES];</a>
<a name="ln3227">                len1 = nNumComponents[iINChI][TAUT_NON];</a>
<a name="ln3228">            }</a>
<a name="ln3229">            /* always len1 &lt;= len2; if Mobile-H and Fixed-H have same number of components then len1=len2=0  */</a>
<a name="ln3230">            if ( len2 &amp;&amp; len1 ) {</a>
<a name="ln3231">                INChI *pInChI = (INChI *)inchi_calloc( len2, sizeof( pInChI[0] ) );</a>
<a name="ln3232">                if ( !pInChI ) {</a>
<a name="ln3233">                    ret2 = RI_ERR_ALLOC;</a>
<a name="ln3234">                    goto exit_function;</a>
<a name="ln3235">                }</a>
<a name="ln3236">                memcpy( pInChI, pInpInChI[iINChI][j], len1 * sizeof( pInChI[0] ) );</a>
<a name="ln3237">                inchi_free( pInpInChI[iINChI][j] );</a>
<a name="ln3238">                pInpInChI[iINChI][j] = pInChI;</a>
<a name="ln3239">                nNumComponents[iINChI][j] = len2;</a>
<a name="ln3240">                for ( ; len1 &lt; len2; len1 ++ ) {</a>
<a name="ln3241">                    if ( j == TAUT_YES ) {</a>
<a name="ln3242">                        /* mark added to Mobile H layer components as deleted protons */</a>
<a name="ln3243">                        if ( 0 &gt; (ret2 = nFillOutProtonMobileH( pInpInChI[iINChI][j]+len1 ) ) ) {</a>
<a name="ln3244">                            goto exit_function;</a>
<a name="ln3245">                        }</a>
<a name="ln3246">                        if ( 0 &gt; (ret2 = nProtonCopyIsotopicInfo( pInpInChI[iINChI][j]+len1/* to */,</a>
<a name="ln3247">                                                                  pInpInChI[iINChI][TAUT_NON]+len1/* from */ ) ) ) {</a>
<a name="ln3248">                            goto exit_function;</a>
<a name="ln3249">                        }</a>
<a name="ln3250">                    } else {</a>
<a name="ln3251">                        /* mark added to Fixed H layer components as empty deleted */</a>
<a name="ln3252">                        /* this should not happen */</a>
<a name="ln3253">                        pInChI[len1].bDeleted = 1;</a>
<a name="ln3254">                    }</a>
<a name="ln3255">                }</a>
<a name="ln3256">            }</a>
<a name="ln3257">        } /* end of iINChI cycle */</a>
<a name="ln3258">        /* check balances */</a>
<a name="ln3259">        for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) {</a>
<a name="ln3260">            for ( i = iINChI; i &lt; INCHI_NUM; i ++ ) {</a>
<a name="ln3261">                for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3262">                    for ( k = j; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln3263">                        if ( (iINChI!=i || j !=k) &amp;&amp; num_elem[iINChI][j] &amp;&amp; num_elem[i][k] ) {</a>
<a name="ln3264">                            if ( tot_charge[iINChI][j] != tot_charge[i][k] ) {</a>
<a name="ln3265">                                ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3266">                                goto exit_function;</a>
<a name="ln3267">                            }</a>
<a name="ln3268">                            for ( m = 0; m &lt;= nElDataLen; m ++ ) {</a>
<a name="ln3269">                                if ( num_elem[iINChI][j][m].num != num_elem[i][k][m].num ) {</a>
<a name="ln3270">                                    ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3271">                                    goto exit_function;</a>
<a name="ln3272">                                }</a>
<a name="ln3273">                            }</a>
<a name="ln3274">                            /*</a>
<a name="ln3275">                            if ( memcmp( num_elem[iINChI], num_elem[i][k], (nElDataLen+1)*sizeof(num_elem[0][0][0]) ) {</a>
<a name="ln3276">                                ret2 = RI_ERR_SYNTAX;</a>
<a name="ln3277">                                goto exit_function;</a>
<a name="ln3278">                            }</a>
<a name="ln3279">                            */</a>
<a name="ln3280">                        }</a>
<a name="ln3281">                    }</a>
<a name="ln3282">                }</a>
<a name="ln3283">            }</a>
<a name="ln3284">        }</a>
<a name="ln3285"> </a>
<a name="ln3286"> </a>
<a name="ln3287">    } else {</a>
<a name="ln3288">        ret2 = ret;</a>
<a name="ln3289">    }</a>
<a name="ln3290">exit_function:</a>
<a name="ln3291">    for ( i = 0; i &lt; INCHI_NUM; i ++ ) {</a>
<a name="ln3292">        for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3293">            if ( num_elem[i][j] ) {</a>
<a name="ln3294">                inchi_free( num_elem[i][j] );</a>
<a name="ln3295">                num_elem[i][j] = NULL;</a>
<a name="ln3296">            }</a>
<a name="ln3297">        }</a>
<a name="ln3298">    }</a>
<a name="ln3299">    *nErr = (ret2 &lt; 0 &amp;&amp; ret2 != RI_ERR_EOL)? ret2 : 0;</a>
<a name="ln3300">    return ret;</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303">/**************************************************************************************/</a>
<a name="ln3304">#if ( FIX_ISO_FIXEDH_BUG_READ == 1 )</a>
<a name="ln3305">#undef TAUT_YES</a>
<a name="ln3306">int bIsoMayBeArranged( int bInchi2Struct, int iso_diff[NUM_H_ISOTOPES], REM_PROTONS nNumProtons[INCHI_NUM][TAUT_NUM],</a>
<a name="ln3307">                       INChI *pInpInChI[INCHI_NUM][TAUT_NUM], int nNumComponents[INCHI_NUM][TAUT_NUM], int iINChI )</a>
<a name="ln3308">{</a>
<a name="ln3309">const int TAUT_YES = 1;</a>
<a name="ln3310">    int i, k, m, n_found=0, n_found_at_in_component, n_found_H_in_component, i_iso_at, num_iso_H=0, num_iso_H_orig, num_add_iso_H, orig_add_H;</a>
<a name="ln3311">    for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln3312">        num_iso_H += iso_diff[m];</a>
<a name="ln3313">    }</a>
<a name="ln3314">    num_iso_H_orig = num_iso_H;</a>
<a name="ln3315">    for ( k = 0; k &lt; nNumComponents[iINChI][TAUT_YES] &amp;&amp; k &lt; nNumComponents[iINChI][TAUT_NON]; k ++ ) {</a>
<a name="ln3316">        INChI *pInChI = &amp;pInpInChI[iINChI][TAUT_NON][k];</a>
<a name="ln3317">        INChI *pInChITaut = &amp;pInpInChI[iINChI][TAUT_YES][k];</a>
<a name="ln3318">        if ( pInChITaut-&gt;bDeleted || pInChI-&gt;bDeleted ||</a>
<a name="ln3319">             pInChITaut-&gt;nNumberOfIsotopicAtoms &gt; 0 ||</a>
<a name="ln3320">             pInChITaut-&gt;lenTautomer &gt; 1 &amp;&amp; pInChITaut-&gt;nTautomer &amp;&amp; pInChITaut-&gt;nTautomer[0] &gt; 0 ||</a>
<a name="ln3321">             NULL == nNumProtons[iINChI][TAUT_YES].pNumProtons ||</a>
<a name="ln3322">             nNumProtons[iINChI][TAUT_YES].pNumProtons[k].nNumRemovedProtons &lt;= 0 ||</a>
<a name="ln3323">             pInChI-&gt;nNumberOfIsotopicAtoms &gt; 0 ||</a>
<a name="ln3324">             nNumProtons[iINChI][TAUT_YES].pNumProtons[k].nNumRemovedIsotopicH[0] ||</a>
<a name="ln3325">             nNumProtons[iINChI][TAUT_YES].pNumProtons[k].nNumRemovedIsotopicH[1] ||</a>
<a name="ln3326">             nNumProtons[iINChI][TAUT_YES].pNumProtons[k].nNumRemovedIsotopicH[2]</a>
<a name="ln3327">             ) {</a>
<a name="ln3328">            continue;</a>
<a name="ln3329">        }</a>
<a name="ln3330">        /* check if fixed-H has isotopic H; count the possibilities */</a>
<a name="ln3331">        orig_add_H = nNumProtons[iINChI][TAUT_YES].pNumProtons[k].nNumRemovedProtons;</a>
<a name="ln3332">        n_found_at_in_component = 0; /* number of atoms that may accept isotopic H */</a>
<a name="ln3333">        n_found_H_in_component = 0;</a>
<a name="ln3334">        for ( i = 0; i &lt; pInChI-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln3335">            int nNumRemovedH = (int)pInChI-&gt;nNum_H[i] - (int)pInChITaut-&gt;nNum_H[i];</a>
<a name="ln3336">            if ( nNumRemovedH &gt; 0) {</a>
<a name="ln3337">                n_found_at_in_component ++;</a>
<a name="ln3338">                n_found_H_in_component += nNumRemovedH;</a>
<a name="ln3339">            }</a>
<a name="ln3340">        }</a>
<a name="ln3341">        if ( n_found_at_in_component &gt; 0 &amp;&amp; num_iso_H &gt; 0 &amp;&amp; bInchi2Struct ) {</a>
<a name="ln3342">            pInChI-&gt;IsotopicAtom = (INChI_IsotopicAtom *)calloc(inchi_min(n_found_at_in_component, num_iso_H), sizeof(pInChI-&gt;IsotopicAtom[0]));</a>
<a name="ln3343">        }</a>
<a name="ln3344">        for ( i = 0, i_iso_at = 0; i &lt; pInChI-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln3345">            int nNumRemovedH = (int)pInChI-&gt;nNum_H[i] - (int)pInChITaut-&gt;nNum_H[i];</a>
<a name="ln3346">            n_found += nNumRemovedH; /* found H removed in mobile-H layer */</a>
<a name="ln3347">            if ( nNumRemovedH &gt; 0 &amp;&amp; num_iso_H &gt; 0 &amp;&amp; orig_add_H ) {</a>
<a name="ln3348">                for ( m = 0; m &lt; NUM_H_ISOTOPES &amp;&amp; 0 &lt; num_iso_H &amp;&amp; 0 &lt; orig_add_H &amp;&amp; 0 &lt; nNumRemovedH; m ++ ) {</a>
<a name="ln3349">                    if ( iso_diff[m] &gt; 0 ) {</a>
<a name="ln3350">                        num_add_iso_H = inchi_min( iso_diff[m], nNumRemovedH ); /* atom limit */</a>
<a name="ln3351">                        if ( num_add_iso_H &gt; orig_add_H )                       /* component limit */</a>
<a name="ln3352">                            num_add_iso_H = orig_add_H;</a>
<a name="ln3353">                        iso_diff[m] -= num_add_iso_H;                           /* update tot removed single isotope H limit */</a>
<a name="ln3354">                        num_iso_H   -= num_add_iso_H;                           /* update tot removed isotopic H limit */</a>
<a name="ln3355">                        orig_add_H  -= num_add_iso_H;                           /* update component limit */</a>
<a name="ln3356">                        nNumRemovedH -= num_add_iso_H;                          /* update atom limit */</a>
<a name="ln3357">                        nNumProtons[iINChI][TAUT_YES].pNumProtons[k].nNumRemovedIsotopicH[m] += num_add_iso_H;</a>
<a name="ln3358">                        if ( pInChI-&gt;IsotopicAtom ) {</a>
<a name="ln3359">                            pInChI-&gt;IsotopicAtom[i_iso_at].nAtomNumber = i+1;</a>
<a name="ln3360">                            switch( m ) {</a>
<a name="ln3361">                            case 0:</a>
<a name="ln3362">                                pInChI-&gt;IsotopicAtom[i_iso_at].nNum_H += num_add_iso_H;</a>
<a name="ln3363">                                break;</a>
<a name="ln3364">                            case 1:</a>
<a name="ln3365">                                pInChI-&gt;IsotopicAtom[i_iso_at].nNum_D += num_add_iso_H;</a>
<a name="ln3366">                                break;</a>
<a name="ln3367">                            case 2:</a>
<a name="ln3368">                                pInChI-&gt;IsotopicAtom[i_iso_at].nNum_T += num_add_iso_H;</a>
<a name="ln3369">                                break;</a>
<a name="ln3370">                            }</a>
<a name="ln3371">                        }</a>
<a name="ln3372">                    }</a>
<a name="ln3373">                }</a>
<a name="ln3374">                if ( pInChI-&gt;IsotopicAtom ) {</a>
<a name="ln3375">                    i_iso_at ++;</a>
<a name="ln3376">                }</a>
<a name="ln3377">            }</a>
<a name="ln3378">        }</a>
<a name="ln3379">        if ( pInChI-&gt;IsotopicAtom &amp;&amp; i_iso_at ) {</a>
<a name="ln3380">            pInChI-&gt;nNumberOfIsotopicAtoms = i_iso_at;</a>
<a name="ln3381">        }</a>
<a name="ln3382">    }</a>
<a name="ln3383">    if ( n_found - num_iso_H &gt;= 0 ) {</a>
<a name="ln3384">        /* Success. Arrange isotopic H between components */</a>
<a name="ln3385"> </a>
<a name="ln3386">    }</a>
<a name="ln3387"> </a>
<a name="ln3388">    return n_found - num_iso_H_orig; /* &gt;0 =&gt; ambiguous reconstruction, 0 =&gt; unambiguous, &lt;0 =&gt; impossible */</a>
<a name="ln3389">}</a>
<a name="ln3390">#define TAUT_YES 1</a>
<a name="ln3391">#endif</a>
<a name="ln3392"> </a>
<a name="ln3393">/******************************************************************************************************/</a>
<a name="ln3394">typedef enum tagAuxInfoState {</a>
<a name="ln3395">    AST_VERSION,                         /* 0    */</a>
<a name="ln3396">    </a>
<a name="ln3397">    AST_MOBILE_H_NUMBERS,                /* 1 /N:  */</a>
<a name="ln3398">    AST_MOBILE_H_ATOM_EQ,                /* 2 /E:  */</a>
<a name="ln3399">    AST_MOBILE_H_GROUP_EQ,               /* 3 /gE: */</a>
<a name="ln3400">    AST_MOBILE_H_SP3_INV,                /* 4 /it: */</a>
<a name="ln3401">    AST_MOBILE_H_SP3_INV_NUMBERS,        /* 5 /iN: */    </a>
<a name="ln3402">    </a>
<a name="ln3403">    AST_MOBILE_H_ISO_LAYER_FORK,         /* 6 */</a>
<a name="ln3404"> </a>
<a name="ln3405">    AST_MOBILE_H_ISO_NUMBERS,            /* 7 /I:  */</a>
<a name="ln3406">    AST_MOBILE_H_ISO_ATOM_EQ,            /* 8 /E:  */</a>
<a name="ln3407">    AST_MOBILE_H_ISO_GROUP_EQ,           /* 9 /gE: */</a>
<a name="ln3408">    AST_MOBILE_H_ISO_SP3_INV,            /* 10 /it: */</a>
<a name="ln3409">    AST_MOBILE_H_ISO_SP3_INV_NUMBERS,    /* 11 /iN: */</a>
<a name="ln3410"> </a>
<a name="ln3411">    AST_FIXED_H_LAYER_FORK,              /* 12 */</a>
<a name="ln3412"> </a>
<a name="ln3413">    AST_FIXED_H_NUMBERS,                 /* 13 /F:  */</a>
<a name="ln3414">    AST_FIXED_H_ATOM_EQ,                 /* 14 /E:  */</a>
<a name="ln3415">    AST_FIXED_H_SP3_INV,                 /* 15 /it: */</a>
<a name="ln3416">    AST_FIXED_H_SP3_INV_NUMBERS,         /* 16 /iN: */</a>
<a name="ln3417"> </a>
<a name="ln3418">    AST_FIXED_H_ISO_LAYER_FORK,          /* 17 */</a>
<a name="ln3419"> </a>
<a name="ln3420">    AST_FIXED_H_ISO_NUMBERS,             /* 18 /I:  */</a>
<a name="ln3421">    AST_FIXED_H_ISO_ATOM_EQ,             /* 19 /E:  */</a>
<a name="ln3422">    AST_FIXED_H_ISO_SP3_INV,             /* 20 /it: */</a>
<a name="ln3423">    AST_FIXED_H_ISO_SP3_INV_NUMBERS,     /* 21 /iN: */</a>
<a name="ln3424"> </a>
<a name="ln3425">    AST_REVERSE_INFO_CRV,                      /* 22 /CRV: */</a>
<a name="ln3426">    AST_REVERSE_INFO_ATOMS,                    /* 23 /rA:  */</a>
<a name="ln3427">    AST_REVERSE_INFO_BONDS,                    /* 24 /rB:  */</a>
<a name="ln3428">    AST_REVERSE_INFO_XYZ,                      /* 25 /rC:  */</a>
<a name="ln3429"> </a>
<a name="ln3430">    AST_RECONNECTED_LAYER_FORK,          /* 26 /R:   */</a>
<a name="ln3431">    AST_RECONNECTED_LAYER_NUMBERS        /* 27 */</a>
<a name="ln3432"> </a>
<a name="ln3433">}AUX_INFO_STATE;</a>
<a name="ln3434"> </a>
<a name="ln3435">/************************************************************************************/</a>
<a name="ln3436">int ParseAuxSegmentVersion( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3437">{</a>
<a name="ln3438">    const char *q;</a>
<a name="ln3439">    if ( isdigit( UCINT *str ) &amp;&amp; (inchi_strtol( str, &amp;q, 10), !*q) ) {</a>
<a name="ln3440">        return 1;</a>
<a name="ln3441">    }</a>
<a name="ln3442">    return RI_ERR_SYNTAX;</a>
<a name="ln3443">}</a>
<a name="ln3444">/************************************************************************************/</a>
<a name="ln3445">int CopyAtomNumbers( INChI *pInChI_To, int bIsoTo, INChI *pInChI_From, int bIsoFrom )</a>
<a name="ln3446">{</a>
<a name="ln3447">    AT_NUMB *pTo, *pFrom;</a>
<a name="ln3448">    if ( !pInChI_To || !pInChI_From || pInChI_To-&gt;bDeleted || pInChI_From-&gt;bDeleted ||</a>
<a name="ln3449">         !pInChI_To-&gt;nNumberOfAtoms || !pInChI_From-&gt;nNumberOfAtoms ||</a>
<a name="ln3450">         pInChI_To-&gt;nNumberOfAtoms  != pInChI_From-&gt;nNumberOfAtoms ||</a>
<a name="ln3451">         !pInChI_From-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3452">        return RI_ERR_PROGR;</a>
<a name="ln3453">    }</a>
<a name="ln3454">    if ( !pInChI_To-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3455">        pInChI_To-&gt;nPossibleLocationsOfIsotopicH = (AT_NUMB *)inchi_calloc( 2*pInChI_To-&gt;nNumberOfAtoms,</a>
<a name="ln3456">                                                   sizeof(pInChI_To-&gt;nPossibleLocationsOfIsotopicH[0]));</a>
<a name="ln3457">        if ( !pInChI_To-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3458">            return RI_ERR_ALLOC;</a>
<a name="ln3459">        }</a>
<a name="ln3460">    }</a>
<a name="ln3461">    pTo   = pInChI_To-&gt;nPossibleLocationsOfIsotopicH + (bIsoTo? 0 : pInChI_To-&gt;nNumberOfAtoms );</a>
<a name="ln3462">    pFrom = pInChI_From-&gt;nPossibleLocationsOfIsotopicH + (bIsoFrom? 0 : pInChI_To-&gt;nNumberOfAtoms );</a>
<a name="ln3463">    if ( pTo == pFrom ) {</a>
<a name="ln3464">        return RI_ERR_PROGR;</a>
<a name="ln3465">    }</a>
<a name="ln3466">    memcpy( pTo, pFrom, pInChI_To-&gt;nNumberOfAtoms*sizeof(pTo[0]) );</a>
<a name="ln3467">    return 1;</a>
<a name="ln3468">}</a>
<a name="ln3469">/************************************************************************************/</a>
<a name="ln3470">int ParseAuxSegmentNumbers( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state, int *pbAbc )</a>
<a name="ln3471">{</a>
<a name="ln3472">    int bIso = 0, iComponent = 0, nNumComponents, bIso_From, bAltInChIExists;</a>
<a name="ln3473">    INChI   *pInChI = NULL, *pAltInChI = NULL, *pInChI_From = NULL;</a>
<a name="ln3474">    const char  *p, *q, *pStart, *pEnd, *t;</a>
<a name="ln3475">    static const char  mult_type[] = &quot;mnM&quot;;</a>
<a name="ln3476">    int      val, ret, k, mpy_component, num;</a>
<a name="ln3477">    AT_NUMB *pNumb;</a>
<a name="ln3478">    int      base = 10;</a>
<a name="ln3479">    /* save isotopic numbering into the first nNumberOfAtoms elements of INChI::nPossibleLocationsOfIsotopicH */</a>
<a name="ln3480">    /* save non-isotopic numbering into the second half of nNumberOfAtoms elements of INChI::nPossibleLocationsOfIsotopicH */</a>
<a name="ln3481"> </a>
<a name="ln3482">    switch( state ) {</a>
<a name="ln3483">    case AST_MOBILE_H_NUMBERS:</a>
<a name="ln3484">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3485">            return RI_ERR_PROGR;</a>
<a name="ln3486">        if ( memcmp( str, &quot;N:&quot;, 2 ) )</a>
<a name="ln3487">            return 0;</a>
<a name="ln3488">        break;</a>
<a name="ln3489">    case AST_FIXED_H_NUMBERS:</a>
<a name="ln3490">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3491">            return RI_ERR_PROGR;</a>
<a name="ln3492">        if ( memcmp( str, &quot;F:&quot;, 2 ) )</a>
<a name="ln3493">            return 0;</a>
<a name="ln3494">        break;</a>
<a name="ln3495">    case AST_MOBILE_H_ISO_NUMBERS:</a>
<a name="ln3496">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3497">            return RI_ERR_PROGR;</a>
<a name="ln3498">        if ( memcmp( str, &quot;I:&quot;, 2 ) )</a>
<a name="ln3499">            return 0;</a>
<a name="ln3500">        bIso = 1;</a>
<a name="ln3501">        break;</a>
<a name="ln3502">    case AST_FIXED_H_ISO_NUMBERS:</a>
<a name="ln3503">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3504">            return RI_ERR_PROGR;</a>
<a name="ln3505">        if ( memcmp( str, &quot;I:&quot;, 2 ) )</a>
<a name="ln3506">            return 0;</a>
<a name="ln3507">        bIso = 1;</a>
<a name="ln3508">        break;</a>
<a name="ln3509">    default:</a>
<a name="ln3510">        return RI_ERR_PROGR;</a>
<a name="ln3511">    }</a>
<a name="ln3512">    pStart = str+2;</a>
<a name="ln3513">    if ( !*pStart ) {</a>
<a name="ln3514">        return 1;</a>
<a name="ln3515">    }</a>
<a name="ln3516">    iComponent = 0;</a>
<a name="ln3517">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln3518"> </a>
<a name="ln3519">    bAltInChIExists = (NULL != pInpInChI[ALT_TAUT(bMobileH)]);</a>
<a name="ln3520">    while( 1 ) {</a>
<a name="ln3521">        /* cycle over components */</a>
<a name="ln3522">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln3523">            pEnd = pStart + strlen(pStart);</a>
<a name="ln3524">        }</a>
<a name="ln3525">        /* check */</a>
<a name="ln3526">        if ( !pInpInChI[bMobileH] ) {</a>
<a name="ln3527">            return 1; /* invalid aux info */</a>
<a name="ln3528">        }</a>
<a name="ln3529">        pInChI    = pInpInChI[bMobileH] + iComponent;</a>
<a name="ln3530">        pAltInChI = pInpInChI[ALT_TAUT(bMobileH)] + iComponent;</a>
<a name="ln3531">        if ( ((isdigit(UCINT *pStart) &amp;&amp;</a>
<a name="ln3532">             0 &lt; (val = (int)inchi_strtol( pStart, &amp;q, 10))) ||</a>
<a name="ln3533">             (q = pStart, val=1) )&amp;&amp;</a>
<a name="ln3534">             (t=strchr(mult_type, *q)) &amp;&amp; q+1 == pEnd ) {</a>
<a name="ln3535">            </a>
<a name="ln3536">            /* process the abbreviation */</a>
<a name="ln3537">            </a>
<a name="ln3538">            pInChI_From = NULL;</a>
<a name="ln3539"> </a>
<a name="ln3540">            switch( bMobileH ) {</a>
<a name="ln3541"> </a>
<a name="ln3542">            case TAUT_YES:</a>
<a name="ln3543">                switch ( bIso ) {</a>
<a name="ln3544">                case 0:</a>
<a name="ln3545">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln3546">                    goto exit_function;</a>
<a name="ln3547">                case 1:</a>
<a name="ln3548">                    if ( *q != 'm' ) {</a>
<a name="ln3549">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln3550">                        goto exit_function;</a>
<a name="ln3551">                    }</a>
<a name="ln3552">                    /* isotopic Mobile-H  &lt;-- non-isotopic Mobile H  */</a>
<a name="ln3553">                    pInChI_From = pInChI;</a>
<a name="ln3554">                    bIso_From   = 0;</a>
<a name="ln3555">                    break;</a>
<a name="ln3556">                default:</a>
<a name="ln3557">                    ret = RI_ERR_PROGR;</a>
<a name="ln3558">                    goto exit_function;</a>
<a name="ln3559">                }</a>
<a name="ln3560">                break;</a>
<a name="ln3561"> </a>
<a name="ln3562">            case TAUT_NON:</a>
<a name="ln3563">                switch ( *q ) {</a>
<a name="ln3564">                case 'm':  /* same as mobile H */</a>
<a name="ln3565">                    switch( bIso ) {</a>
<a name="ln3566">                    case 0: /* from Mobile-H not isotopic */</a>
<a name="ln3567">                        pInChI_From = bAltInChIExists? pAltInChI:NULL;</a>
<a name="ln3568">                        bIso_From   = 0;</a>
<a name="ln3569">                        break;</a>
<a name="ln3570"> </a>
<a name="ln3571">                    case 1:</a>
<a name="ln3572">                        pInChI_From = bAltInChIExists? pAltInChI:NULL;;</a>
<a name="ln3573">                        bIso_From   = 1;</a>
<a name="ln3574">                        break;</a>
<a name="ln3575">                    default:</a>
<a name="ln3576">                        ret = RI_ERR_PROGR;</a>
<a name="ln3577">                        goto exit_function;</a>
<a name="ln3578">                    }</a>
<a name="ln3579">                    break;</a>
<a name="ln3580">                case 'n': /* same as non-isotopic Fixed-H */</a>
<a name="ln3581">                    switch ( bIso ) {</a>
<a name="ln3582">                    case 0:</a>
<a name="ln3583">                        ret = 1; /*RI_ERR_SYNTAX;*/</a>
<a name="ln3584">                        goto exit_function;</a>
<a name="ln3585">                    case 1:</a>
<a name="ln3586">                        pInChI_From = pInChI;</a>
<a name="ln3587">                        bIso_From   = 0;</a>
<a name="ln3588">                    default:</a>
<a name="ln3589">                        ret = RI_ERR_PROGR;</a>
<a name="ln3590">                        goto exit_function;</a>
<a name="ln3591">                    }</a>
<a name="ln3592">                    break;</a>
<a name="ln3593">                case 'M':  /* same as isotopic Mobile-H */</a>
<a name="ln3594">                    switch ( bIso ) {</a>
<a name="ln3595">                    case 0:</a>
<a name="ln3596">                        ret = RI_ERR_SYNTAX;</a>
<a name="ln3597">                        goto exit_function;</a>
<a name="ln3598">                    case 1:</a>
<a name="ln3599">                        pInChI_From = bAltInChIExists? pAltInChI:NULL;;</a>
<a name="ln3600">                        bIso_From   = 1;</a>
<a name="ln3601">                        break;</a>
<a name="ln3602">                    default:</a>
<a name="ln3603">                        ret = RI_ERR_PROGR;</a>
<a name="ln3604">                        goto exit_function;</a>
<a name="ln3605">                    }</a>
<a name="ln3606">                    break;</a>
<a name="ln3607">                default:</a>
<a name="ln3608">                    ret = 1; /*RI_ERR_SYNTAX;*/</a>
<a name="ln3609">                    goto exit_function;</a>
<a name="ln3610">                }</a>
<a name="ln3611">                break;</a>
<a name="ln3612"> </a>
<a name="ln3613">            }</a>
<a name="ln3614">            /* copy */</a>
<a name="ln3615">            if ( pInChI_From ) {</a>
<a name="ln3616">                for ( k = 0; k &lt; val; k ++ ) {</a>
<a name="ln3617">                    CopyAtomNumbers( pInChI+k, bIso, pInChI_From+k, bIso_From );</a>
<a name="ln3618">                }</a>
<a name="ln3619">            }</a>
<a name="ln3620">            mpy_component = val;</a>
<a name="ln3621">        } else {</a>
<a name="ln3622">            mpy_component = 1;</a>
<a name="ln3623">            p = pStart;</a>
<a name="ln3624">            pNumb = pInChI-&gt;nPossibleLocationsOfIsotopicH;</a>
<a name="ln3625">            if ( !pNumb ) {</a>
<a name="ln3626">                pNumb = (AT_NUMB *)inchi_calloc( 2*pInChI-&gt;nNumberOfAtoms, sizeof(pNumb[0] ) );</a>
<a name="ln3627">                if ( !pNumb ) {</a>
<a name="ln3628">                    ret = RI_ERR_ALLOC;</a>
<a name="ln3629">                    goto exit_function;</a>
<a name="ln3630">                }</a>
<a name="ln3631">                pInChI-&gt;nPossibleLocationsOfIsotopicH = pNumb;</a>
<a name="ln3632">            }</a>
<a name="ln3633">            pNumb += bIso? 0 : pInChI-&gt;nNumberOfAtoms;</a>
<a name="ln3634">            if ( pStart &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln3635">                /* check if compressed InChI */</a>
<a name="ln3636">                *pbAbc = isupper( UCINT *pStart)? 1 : 0;</a>
<a name="ln3637">            }</a>
<a name="ln3638">            base = (*pbAbc==1)? ALPHA_BASE : 10;</a>
<a name="ln3639"> </a>
<a name="ln3640">            if ( *pbAbc == 1 ) {</a>
<a name="ln3641">                for ( k = 0, p = pStart; k &lt; pInChI-&gt;nNumberOfAtoms &amp;&amp; p &lt; pEnd; k ++, p ++ ) {</a>
<a name="ln3642">                    num = (AT_NUMB)inchi_strtol( p, &amp;q, base );</a>
<a name="ln3643">                    if ( num &lt;= 0 || p == q ) {</a>
<a name="ln3644">                        ret = RI_ERR_SYNTAX;</a>
<a name="ln3645">                        goto exit_function;</a>
<a name="ln3646">                    }</a>
<a name="ln3647">                    pNumb[k] = (AT_NUMB)num;</a>
<a name="ln3648">                    p = q;</a>
<a name="ln3649">                    if ( p == pEnd ) {</a>
<a name="ln3650">                        break; /* main end of cycle */</a>
<a name="ln3651">                    }</a>
<a name="ln3652">                }</a>
<a name="ln3653">            } else {</a>
<a name="ln3654">                for ( k = 0, p = pStart; k &lt; pInChI-&gt;nNumberOfAtoms &amp;&amp; p &lt; pEnd; k ++, p ++ ) {</a>
<a name="ln3655">                    pNumb[k] = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln3656">                    p = q;</a>
<a name="ln3657">                    if ( p == pEnd ) {</a>
<a name="ln3658">                        break; /* main end of cycle */</a>
<a name="ln3659">                    } else</a>
<a name="ln3660">                    if ( *p != ',' ) {</a>
<a name="ln3661">                        ret = RI_ERR_SYNTAX;</a>
<a name="ln3662">                        goto exit_function;</a>
<a name="ln3663">                    }</a>
<a name="ln3664">                }</a>
<a name="ln3665">            }</a>
<a name="ln3666">            if ( p != pEnd || k+1 != pInChI-&gt;nNumberOfAtoms ) {</a>
<a name="ln3667">                    ret = RI_ERR_SYNTAX;</a>
<a name="ln3668">                    goto exit_function;</a>
<a name="ln3669">            }</a>
<a name="ln3670">        }</a>
<a name="ln3671"> </a>
<a name="ln3672">        iComponent += mpy_component;</a>
<a name="ln3673">        if ( *pEnd ) {</a>
<a name="ln3674">            pStart = pEnd+1;</a>
<a name="ln3675">            continue;</a>
<a name="ln3676">        } else {</a>
<a name="ln3677">            break;</a>
<a name="ln3678">        }</a>
<a name="ln3679">    }</a>
<a name="ln3680"> </a>
<a name="ln3681">    if ( nNumComponents != iComponent ) {</a>
<a name="ln3682">        ret = 1; /*RI_ERR_SYNTAX;*/ /* syntax error */</a>
<a name="ln3683">        goto exit_function;</a>
<a name="ln3684">    }</a>
<a name="ln3685">    ret = iComponent + 1;</a>
<a name="ln3686"> </a>
<a name="ln3687">exit_function:</a>
<a name="ln3688">    return ret;   </a>
<a name="ln3689"> </a>
<a name="ln3690">}</a>
<a name="ln3691">/**********************************************************************************************************/</a>
<a name="ln3692">int ParseAuxSegmentAtomEqu( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3693">{</a>
<a name="ln3694">    switch( state ) {</a>
<a name="ln3695">    case AST_MOBILE_H_ATOM_EQ:</a>
<a name="ln3696">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3697">            return RI_ERR_PROGR;</a>
<a name="ln3698">        if ( memcmp( str, &quot;E:&quot;, 2 ) )</a>
<a name="ln3699">            return 0;</a>
<a name="ln3700">        break;</a>
<a name="ln3701">    case AST_MOBILE_H_ISO_ATOM_EQ:</a>
<a name="ln3702">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3703">            return RI_ERR_PROGR;</a>
<a name="ln3704">        if ( memcmp( str, &quot;E:&quot;, 2 ) )</a>
<a name="ln3705">            return 0;</a>
<a name="ln3706">        break;</a>
<a name="ln3707">    case AST_FIXED_H_ATOM_EQ:</a>
<a name="ln3708">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3709">            return RI_ERR_PROGR;</a>
<a name="ln3710">        if ( memcmp( str, &quot;E:&quot;, 2 ) )</a>
<a name="ln3711">            return 0;</a>
<a name="ln3712">        break;</a>
<a name="ln3713">    case AST_FIXED_H_ISO_ATOM_EQ:</a>
<a name="ln3714">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3715">            return RI_ERR_PROGR;</a>
<a name="ln3716">        if ( memcmp( str, &quot;E:&quot;, 2 ) )</a>
<a name="ln3717">            return 0;</a>
<a name="ln3718">        break;</a>
<a name="ln3719">    default:</a>
<a name="ln3720">        return RI_ERR_PROGR;</a>
<a name="ln3721">    }</a>
<a name="ln3722">    return 1;</a>
<a name="ln3723">}</a>
<a name="ln3724">/***********************************************************************************************************/</a>
<a name="ln3725">int ParseAuxSegmentGroupEqu( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3726">{</a>
<a name="ln3727">    switch( state ) {</a>
<a name="ln3728">    case AST_MOBILE_H_GROUP_EQ:</a>
<a name="ln3729">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3730">            return RI_ERR_PROGR;</a>
<a name="ln3731">        if ( memcmp( str, &quot;gE:&quot;, 3 ) )</a>
<a name="ln3732">            return 0;</a>
<a name="ln3733">        break;</a>
<a name="ln3734">    case AST_MOBILE_H_ISO_GROUP_EQ:</a>
<a name="ln3735">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3736">            return RI_ERR_PROGR;</a>
<a name="ln3737">        if ( memcmp( str, &quot;gE:&quot;, 3 ) )</a>
<a name="ln3738">            return 0;</a>
<a name="ln3739">        break;</a>
<a name="ln3740">    default:</a>
<a name="ln3741">        return RI_ERR_PROGR;</a>
<a name="ln3742">    }</a>
<a name="ln3743">    return 1;</a>
<a name="ln3744">}</a>
<a name="ln3745">/***********************************************************************************************************/</a>
<a name="ln3746">int ParseAuxSegmentSp3Inv( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3747">{</a>
<a name="ln3748">    switch( state ) {</a>
<a name="ln3749">    case AST_MOBILE_H_SP3_INV:</a>
<a name="ln3750">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3751">            return RI_ERR_PROGR;</a>
<a name="ln3752">        if ( memcmp( str, &quot;it:&quot;, 3 ) )</a>
<a name="ln3753">            return 0;</a>
<a name="ln3754">        break;</a>
<a name="ln3755">    case AST_MOBILE_H_ISO_SP3_INV:</a>
<a name="ln3756">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3757">            return RI_ERR_PROGR;</a>
<a name="ln3758">        if ( memcmp( str, &quot;it:&quot;, 3 ) )</a>
<a name="ln3759">            return 0;</a>
<a name="ln3760">        break;</a>
<a name="ln3761">    case AST_FIXED_H_SP3_INV:</a>
<a name="ln3762">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3763">            return RI_ERR_PROGR;</a>
<a name="ln3764">        if ( memcmp( str, &quot;it:&quot;, 3 ) )</a>
<a name="ln3765">            return 0;</a>
<a name="ln3766">        break;</a>
<a name="ln3767">    case AST_FIXED_H_ISO_SP3_INV:</a>
<a name="ln3768">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3769">            return RI_ERR_PROGR;</a>
<a name="ln3770">        if ( memcmp( str, &quot;it:&quot;, 3 ) )</a>
<a name="ln3771">            return 0;</a>
<a name="ln3772">        break;</a>
<a name="ln3773">    default:</a>
<a name="ln3774">        return RI_ERR_PROGR;</a>
<a name="ln3775">    }</a>
<a name="ln3776">    return 1;</a>
<a name="ln3777">}</a>
<a name="ln3778">/***********************************************************************************************************/</a>
<a name="ln3779">int ParseAuxSegmentSp3InvNumbers( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3780">{</a>
<a name="ln3781">    switch( state ) {</a>
<a name="ln3782">    case AST_MOBILE_H_SP3_INV_NUMBERS:</a>
<a name="ln3783">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3784">            return RI_ERR_PROGR;</a>
<a name="ln3785">        if ( memcmp( str, &quot;iN:&quot;, 3 ) )</a>
<a name="ln3786">            return 0;</a>
<a name="ln3787">        break;</a>
<a name="ln3788">    case AST_MOBILE_H_ISO_SP3_INV_NUMBERS:</a>
<a name="ln3789">        if ( bMobileH != TAUT_YES )</a>
<a name="ln3790">            return RI_ERR_PROGR;</a>
<a name="ln3791">        if ( memcmp( str, &quot;iN:&quot;, 3 ) )</a>
<a name="ln3792">            return 0;</a>
<a name="ln3793">        break;</a>
<a name="ln3794">    case AST_FIXED_H_SP3_INV_NUMBERS:</a>
<a name="ln3795">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3796">            return RI_ERR_PROGR;</a>
<a name="ln3797">        if ( memcmp( str, &quot;iN:&quot;, 3 ) )</a>
<a name="ln3798">            return 0;</a>
<a name="ln3799">        break;</a>
<a name="ln3800">    case AST_FIXED_H_ISO_SP3_INV_NUMBERS:</a>
<a name="ln3801">        if ( bMobileH != TAUT_NON )</a>
<a name="ln3802">            return RI_ERR_PROGR;</a>
<a name="ln3803">        if ( memcmp( str, &quot;iN:&quot;, 3 ) )</a>
<a name="ln3804">            return 0;</a>
<a name="ln3805">        break;</a>
<a name="ln3806">    default:</a>
<a name="ln3807">        return RI_ERR_PROGR;</a>
<a name="ln3808">    }</a>
<a name="ln3809">    return 1;</a>
<a name="ln3810">}</a>
<a name="ln3811">/***********************************************************************************************************/</a>
<a name="ln3812">int ParseAuxSegmentReverseCRV( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3813">{</a>
<a name="ln3814">    switch( state ) {</a>
<a name="ln3815">    case AST_REVERSE_INFO_CRV:</a>
<a name="ln3816">        if ( memcmp( str, &quot;CRV:&quot;, 4 ) )</a>
<a name="ln3817">            return 0;</a>
<a name="ln3818">        break;</a>
<a name="ln3819">    default:</a>
<a name="ln3820">        return RI_ERR_PROGR;</a>
<a name="ln3821">    }</a>
<a name="ln3822">    return 1;</a>
<a name="ln3823">}</a>
<a name="ln3824">/***********************************************************************************************************/</a>
<a name="ln3825">int ParseAuxSegmentReverseAtoms( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3826">{</a>
<a name="ln3827">    switch( state ) {</a>
<a name="ln3828">    case AST_REVERSE_INFO_ATOMS:</a>
<a name="ln3829">        if ( memcmp( str, &quot;rA:&quot;, 3 ) )</a>
<a name="ln3830">            return 0;</a>
<a name="ln3831">        break;</a>
<a name="ln3832">    default:</a>
<a name="ln3833">        return RI_ERR_PROGR;</a>
<a name="ln3834">    }</a>
<a name="ln3835">    return 1;</a>
<a name="ln3836">}</a>
<a name="ln3837">/***********************************************************************************************************/</a>
<a name="ln3838">int ParseAuxSegmentReverseBonds( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3839">{</a>
<a name="ln3840">    switch( state ) {</a>
<a name="ln3841">    case AST_REVERSE_INFO_BONDS:</a>
<a name="ln3842">        if ( memcmp( str, &quot;rB:&quot;, 3 ) )</a>
<a name="ln3843">            return 0;</a>
<a name="ln3844">        break;</a>
<a name="ln3845">    default:</a>
<a name="ln3846">        return RI_ERR_PROGR;</a>
<a name="ln3847">    }</a>
<a name="ln3848">    return 1;</a>
<a name="ln3849">}</a>
<a name="ln3850">/***********************************************************************************************************/</a>
<a name="ln3851">int ParseAuxSegmentReverseXYZ( const char *str, int bMobileH, XYZ_COORD **ppXYZ, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln3852">{</a>
<a name="ln3853">    const char *pStart, *p, *q;</a>
<a name="ln3854">    XYZ_COORD *pXYZ = NULL;</a>
<a name="ln3855">    int     nLenXYZ=0, i, j;</a>
<a name="ln3856">    switch( state ) {</a>
<a name="ln3857">    case AST_REVERSE_INFO_XYZ:</a>
<a name="ln3858">        if ( memcmp( str, &quot;rC:&quot;, 3 ) )</a>
<a name="ln3859">            return 0;</a>
<a name="ln3860">        break;</a>
<a name="ln3861">    default:</a>
<a name="ln3862">        return RI_ERR_PROGR;</a>
<a name="ln3863">    }</a>
<a name="ln3864">    pStart = str+3;</a>
<a name="ln3865">    /* count coordinates */</a>
<a name="ln3866">    for ( p = pStart, nLenXYZ = 0; *p; p ++ ) {</a>
<a name="ln3867">        nLenXYZ += ( *p == ';' );</a>
<a name="ln3868">    }</a>
<a name="ln3869">    if ( !nLenXYZ ) {</a>
<a name="ln3870">        return RI_ERR_SYNTAX;</a>
<a name="ln3871">    }</a>
<a name="ln3872">    if ( NULL == (pXYZ = (XYZ_COORD *)inchi_calloc( nLenXYZ, sizeof(pXYZ[0]) )) ) {</a>
<a name="ln3873">        return RI_ERR_ALLOC;</a>
<a name="ln3874">    }</a>
<a name="ln3875">    for ( p = pStart, i = 0; *p &amp;&amp; i &lt; nLenXYZ; p ++, i ++ ) {</a>
<a name="ln3876">        for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln3877">            pXYZ[i].xyz[j] = inchi_strtod( p, &amp;q );</a>
<a name="ln3878">            p = q + (*q == ',' );</a>
<a name="ln3879">        }</a>
<a name="ln3880">        if ( *p != ';' ) {</a>
<a name="ln3881">            break;</a>
<a name="ln3882">        }</a>
<a name="ln3883">    }</a>
<a name="ln3884">    if ( i != nLenXYZ || *p ) {</a>
<a name="ln3885">        return RI_ERR_SYNTAX;</a>
<a name="ln3886">    }</a>
<a name="ln3887">    *ppXYZ = pXYZ;</a>
<a name="ln3888">    return nLenXYZ+1;</a>
<a name="ln3889">}</a>
<a name="ln3890">/************************************************************************************/</a>
<a name="ln3891">int AddAuxSegmentCoord( int nRet, XYZ_COORD *pXYZ, int nLenXYZ, INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln3892">                        int nNumComponents[INCHI_NUM][TAUT_NUM] )</a>
<a name="ln3893">{</a>
<a name="ln3894">    int iINChI, j, k, n, m, numAt[TAUT_NUM], num_at, nNumMissingNumbers = 0, ret = 0;</a>
<a name="ln3895">    INChI *pInChI    = NULL;</a>
<a name="ln3896">    INChI *pAltInChI = NULL;</a>
<a name="ln3897">    XYZ_COORD *pxyz;</a>
<a name="ln3898"> </a>
<a name="ln3899">    /* propagate numberings */</a>
<a name="ln3900">    for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) {</a>
<a name="ln3901">        for ( j = TAUT_YES; TAUT_NON &lt;= j; j -- ) {</a>
<a name="ln3902">            for ( k = 0; k &lt; nNumComponents[iINChI][j]; k ++ ) {</a>
<a name="ln3903">                int   jj = ALT_TAUT(j);</a>
<a name="ln3904">                pInChI    = pInpInChI[iINChI][j] + k;</a>
<a name="ln3905">                pAltInChI = (k &lt; nNumComponents[iINChI][jj])? pInpInChI[iINChI][jj] + k : NULL;</a>
<a name="ln3906">                numAt[j]  = ( !pInChI-&gt;bDeleted )? pInChI-&gt;nNumberOfAtoms : 0;</a>
<a name="ln3907">                numAt[jj] = ( pAltInChI &amp;&amp; !pAltInChI-&gt;bDeleted )? pAltInChI-&gt;nNumberOfAtoms : 0;</a>
<a name="ln3908">                switch( j ) {</a>
<a name="ln3909">                case TAUT_YES:</a>
<a name="ln3910">                    if ( !numAt[j] ) {</a>
<a name="ln3911">                        break; /* component does not exist */</a>
<a name="ln3912">                    }</a>
<a name="ln3913">                    if ( !pInChI-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3914">                        nNumMissingNumbers ++;</a>
<a name="ln3915">                        break;</a>
<a name="ln3916">                    }</a>
<a name="ln3917">                    if ( !pInChI-&gt;nPossibleLocationsOfIsotopicH[0] ) {</a>
<a name="ln3918">                        if ( pInChI-&gt;nPossibleLocationsOfIsotopicH[numAt[j]] ) {</a>
<a name="ln3919">                            /* copy from non-isotopic (2nd half of the at. numbers array) to the isotopic (1st half) */</a>
<a name="ln3920">                            ret = CopyAtomNumbers( pInChI, 1, pInChI, 0 );</a>
<a name="ln3921">                            if ( ret &lt; 0 ) {</a>
<a name="ln3922">                                goto exit_function;</a>
<a name="ln3923">                            }</a>
<a name="ln3924">                        } else {</a>
<a name="ln3925">                            inchi_free( pInChI-&gt;nPossibleLocationsOfIsotopicH );</a>
<a name="ln3926">                            pInChI-&gt;nPossibleLocationsOfIsotopicH = NULL;</a>
<a name="ln3927">                            nNumMissingNumbers ++;</a>
<a name="ln3928">                        }</a>
<a name="ln3929">                    }</a>
<a name="ln3930">                    break;</a>
<a name="ln3931"> </a>
<a name="ln3932">                case TAUT_NON:</a>
<a name="ln3933">                    if ( !numAt[j] ) {</a>
<a name="ln3934">                        break; /* component does not exist */</a>
<a name="ln3935">                    }</a>
<a name="ln3936">                    if ( !pInChI-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3937">                        /* trying to get numbers from Mobile-H component */</a>
<a name="ln3938">                        if ( !numAt[jj] || !(pAltInChI-&gt;nPossibleLocationsOfIsotopicH) ) {</a>
<a name="ln3939">                            nNumMissingNumbers ++;</a>
<a name="ln3940">                            break;</a>
<a name="ln3941">                        }</a>
<a name="ln3942">                        if ( pAltInChI-&gt;nPossibleLocationsOfIsotopicH[0] ) {</a>
<a name="ln3943">                            ret = CopyAtomNumbers( pInChI, 1, pAltInChI, 1 );</a>
<a name="ln3944">                            if ( ret &lt; 0 ) {</a>
<a name="ln3945">                                goto exit_function;</a>
<a name="ln3946">                            }</a>
<a name="ln3947">                        } else</a>
<a name="ln3948">                        if ( pAltInChI-&gt;nPossibleLocationsOfIsotopicH[numAt[jj]] ) {</a>
<a name="ln3949">                            ret = CopyAtomNumbers( pInChI, 1, pAltInChI, 0 );</a>
<a name="ln3950">                            if ( ret &lt; 0 ) {</a>
<a name="ln3951">                                goto exit_function;</a>
<a name="ln3952">                            }</a>
<a name="ln3953">                        } else {</a>
<a name="ln3954">                            /* pAltInChI-&gt;nPossibleLocationsOfIsotopicH should have */</a>
<a name="ln3955">                            /* been deallocated on previous TAUT_YES pass           */</a>
<a name="ln3956">                            ret = RI_ERR_PROGR;</a>
<a name="ln3957">                            goto exit_function;</a>
<a name="ln3958">                        }</a>
<a name="ln3959">                    } else</a>
<a name="ln3960">                    if ( !pInChI-&gt;nPossibleLocationsOfIsotopicH[0] ) {</a>
<a name="ln3961">                        if ( pInChI-&gt;nPossibleLocationsOfIsotopicH[numAt[j]] ) {</a>
<a name="ln3962">                            /* copy from non-isotopic to isotopic */</a>
<a name="ln3963">                            ret = CopyAtomNumbers( pInChI, 1, pInChI, 0 );</a>
<a name="ln3964">                            if ( ret &lt; 0 ) {</a>
<a name="ln3965">                                goto exit_function;</a>
<a name="ln3966">                            }</a>
<a name="ln3967">                        } else {</a>
<a name="ln3968">                            inchi_free( pInChI-&gt;nPossibleLocationsOfIsotopicH );</a>
<a name="ln3969">                            pInChI-&gt;nPossibleLocationsOfIsotopicH = NULL;</a>
<a name="ln3970">                            nNumMissingNumbers ++;</a>
<a name="ln3971">                        }</a>
<a name="ln3972">                    }</a>
<a name="ln3973">                    break;</a>
<a name="ln3974">                }</a>
<a name="ln3975">            }</a>
<a name="ln3976">        }</a>
<a name="ln3977">    }</a>
<a name="ln3978">    /* add coordinates */</a>
<a name="ln3979">    for ( iINChI = 0; iINChI &lt; INCHI_NUM; iINChI ++ ) {</a>
<a name="ln3980">        for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3981">            for ( k = 0; k &lt; nNumComponents[iINChI][j]; k ++ ) {</a>
<a name="ln3982">                pInChI    = pInpInChI[iINChI][j] + k;</a>
<a name="ln3983">                num_at    = ( !pInChI-&gt;bDeleted )? pInChI-&gt;nNumberOfAtoms : 0;</a>
<a name="ln3984">                if ( !num_at ) {</a>
<a name="ln3985">                    if ( pInChI-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3986">                        inchi_free( pInChI-&gt;nPossibleLocationsOfIsotopicH );</a>
<a name="ln3987">                        pInChI-&gt;nPossibleLocationsOfIsotopicH = NULL;</a>
<a name="ln3988">                    }</a>
<a name="ln3989">                    continue;</a>
<a name="ln3990">                }</a>
<a name="ln3991">                if ( !pInChI-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln3992">                    continue;</a>
<a name="ln3993">                }</a>
<a name="ln3994">                if ( iINChI == INCHI_BAS &amp;&amp; num_at == 1 &amp;&amp;</a>
<a name="ln3995">                     pInChI-&gt;szHillFormula &amp;&amp; !strcmp(pInChI-&gt;szHillFormula, &quot;H&quot;) &amp;&amp;</a>
<a name="ln3996">                     (int)pInChI-&gt;nPossibleLocationsOfIsotopicH[0]-1 &gt;= nLenXYZ ) {</a>
<a name="ln3997">                    ; /* a single atom H disconnected from a metal atom has no coordinates */</a>
<a name="ln3998">                } else {</a>
<a name="ln3999">                    /* add atom coordinates */</a>
<a name="ln4000">                    pxyz = (XYZ_COORD *)inchi_calloc( num_at, sizeof(pxyz[0]));</a>
<a name="ln4001">                    if ( !pxyz ) {</a>
<a name="ln4002">                        ret = RI_ERR_ALLOC;</a>
<a name="ln4003">                        goto exit_function;</a>
<a name="ln4004">                    }</a>
<a name="ln4005">                    for ( n = 0; n &lt; num_at; n ++ ) {</a>
<a name="ln4006">                        m = (int)pInChI-&gt;nPossibleLocationsOfIsotopicH[n]-1;</a>
<a name="ln4007">                        if ( m &lt; 0 || m &gt;= nLenXYZ ) {</a>
<a name="ln4008">                            inchi_free( pxyz );</a>
<a name="ln4009">                            ret = RI_ERR_SYNTAX;</a>
<a name="ln4010">                            goto exit_function;</a>
<a name="ln4011">                        }</a>
<a name="ln4012">                        pxyz[n] = pXYZ[m];</a>
<a name="ln4013">                    }</a>
<a name="ln4014">                    pInChI-&gt;IsotopicTGroup = (INChI_IsotopicTGroup *)pxyz;</a>
<a name="ln4015">                }</a>
<a name="ln4016">                inchi_free( pInChI-&gt;nPossibleLocationsOfIsotopicH );</a>
<a name="ln4017">                pInChI-&gt;nPossibleLocationsOfIsotopicH = NULL;</a>
<a name="ln4018">            }</a>
<a name="ln4019">        }</a>
<a name="ln4020">    }</a>
<a name="ln4021">    ret = nRet; /* normal exit */</a>
<a name="ln4022"> </a>
<a name="ln4023">exit_function:</a>
<a name="ln4024">    return ret;</a>
<a name="ln4025">}</a>
<a name="ln4026">/************************************************************************************/</a>
<a name="ln4027">int ReadInChICoord( INCHI_IOSTREAM *pInp, </a>
<a name="ln4028">                    SEGM_LINE *pLine, int *pState,</a>
<a name="ln4029">                    INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln4030">                    int nNumComponents[INCHI_NUM][TAUT_NUM] )</a>
<a name="ln4031">{</a>
<a name="ln4032">    int   c, fst, ret=RI_ERR_ALLOC;</a>
<a name="ln4033">    int   bMobileH = TAUT_YES, bReconn = INCHI_BAS;</a>
<a name="ln4034">    const char szToken[] = INCHI_TOKEN;</a>
<a name="ln4035">    int  state=-1, prev_state=-1;</a>
<a name="ln4036">    XYZ_COORD *pXYZ = NULL;</a>
<a name="ln4037">    int       nLenXYZ = 0;</a>
<a name="ln4038">    int       bAbc    = -1; /* initially undefined */</a>
<a name="ln4039"> </a>
<a name="ln4040">    *pState = 0;</a>
<a name="ln4041"> </a>
<a name="ln4042">    INCHI_HEAPCHK</a>
<a name="ln4043">    /* Get &quot;InChI=1/&quot; */</a>
<a name="ln4044">    if ( pLine-&gt;len ) {</a>
<a name="ln4045">        c = pLine-&gt;c;</a>
<a name="ln4046">    } else {</a>
<a name="ln4047">        c = nGetInChISegment( pInp, pLine, szToken );</a>
<a name="ln4048">    }</a>
<a name="ln4049">    if ( c == RI_ERR_EOF &amp;&amp; !pLine-&gt;len &amp;&amp; !pLine-&gt;str[0] ) {</a>
<a name="ln4050">        ret = c;</a>
<a name="ln4051">        pLine-&gt;len = 0;</a>
<a name="ln4052">        goto exit_error;</a>
<a name="ln4053">    }</a>
<a name="ln4054">    if ( pLine-&gt;len == 0 || (c != SEG_END &amp;&amp; c != RI_ERR_EOF &amp;&amp; !INCHI_INP_EOL(c)) ) {</a>
<a name="ln4055">        *pState = -1;</a>
<a name="ln4056">        pLine-&gt;len = 0;</a>
<a name="ln4057">        ret = RI_ERR_PROGR;</a>
<a name="ln4058">        goto exit_error;</a>
<a name="ln4059">    }</a>
<a name="ln4060">    if ( memcmp(pLine-&gt;str, &quot;AuxInfo=&quot;, 8) ) {</a>
<a name="ln4061">        *pState = -1;</a>
<a name="ln4062">        return c;</a>
<a name="ln4063">    }</a>
<a name="ln4064">    state = AST_VERSION;</a>
<a name="ln4065">    ret  = 1; /* means read the next segment */</a>
<a name="ln4066">    do {</a>
<a name="ln4067">        /* read the next segment up to the '/' */</a>
<a name="ln4068">        INCHI_HEAPCHK</a>
<a name="ln4069">        if ( ret &lt; 0 ) {</a>
<a name="ln4070">            *pState = prev_state;</a>
<a name="ln4071">            break;</a>
<a name="ln4072">        }</a>
<a name="ln4073">        prev_state = state + (bReconn? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln4074">        /* prev_state = state;*/</a>
<a name="ln4075">        if ( 0 &lt; ret ) {</a>
<a name="ln4076">            /* read next segment */</a>
<a name="ln4077">            if ( c != RI_ERR_EOF &amp;&amp; c != SEG_END ) {</a>
<a name="ln4078">                /* abnormal reading result; should not happen */</a>
<a name="ln4079">                while ( c != RI_ERR_EOF &amp;&amp; !INCHI_INP_EOL(c) ) {</a>
<a name="ln4080">                    /* bypass to the end of line or file */</a>
<a name="ln4081">                    c = getInChIChar(pInp);</a>
<a name="ln4082">                }</a>
<a name="ln4083">                ret = (c == RI_ERR_EOF)? RI_ERR_EOF : RI_ERR_EOL; /* end of line */</a>
<a name="ln4084">                pLine-&gt;len = 0;</a>
<a name="ln4085">                pLine-&gt;c   = ret;</a>
<a name="ln4086">                break;</a>
<a name="ln4087">            }</a>
<a name="ln4088">            if ( c == RI_ERR_EOF ) {</a>
<a name="ln4089">                ret = RI_ERR_EOF; /* end of line */</a>
<a name="ln4090">                break;</a>
<a name="ln4091">            }</a>
<a name="ln4092">            if ( c == SEG_END ) {</a>
<a name="ln4093">                c = nGetInChISegment( pInp, pLine, szToken );</a>
<a name="ln4094">            }</a>
<a name="ln4095">            if ( c &lt; 0 ) {</a>
<a name="ln4096">                goto exit_error; /* error */</a>
<a name="ln4097">            }</a>
<a name="ln4098">            if ( !pLine-&gt;len ) {</a>
<a name="ln4099">                ret = RI_ERR_EOL; /* end of line */</a>
<a name="ln4100">                break;</a>
<a name="ln4101">            }</a>
<a name="ln4102">            fst = UCINT pLine-&gt;str[0];</a>
<a name="ln4103">        }</a>
<a name="ln4104">        /* process the seqment */</a>
<a name="ln4105">        switch ( state ) {</a>
<a name="ln4106">        case AST_VERSION:</a>
<a name="ln4107">            /* Mobile H */</a>
<a name="ln4108">            bMobileH = TAUT_YES;</a>
<a name="ln4109">            ret = ParseAuxSegmentVersion( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4110">            state = AST_MOBILE_H_NUMBERS;</a>
<a name="ln4111">            break;</a>
<a name="ln4112">        case AST_MOBILE_H_NUMBERS:</a>
<a name="ln4113">            ret = ParseAuxSegmentNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4114">            state = AST_MOBILE_H_ATOM_EQ;</a>
<a name="ln4115">            break;</a>
<a name="ln4116">        case AST_MOBILE_H_ATOM_EQ:</a>
<a name="ln4117">            ret = ParseAuxSegmentAtomEqu( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4118">            state = AST_MOBILE_H_GROUP_EQ;</a>
<a name="ln4119">            break;</a>
<a name="ln4120">        case AST_MOBILE_H_GROUP_EQ:</a>
<a name="ln4121">            ret = ParseAuxSegmentGroupEqu( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4122">            state = AST_MOBILE_H_SP3_INV;</a>
<a name="ln4123">            break;</a>
<a name="ln4124">        case AST_MOBILE_H_SP3_INV:</a>
<a name="ln4125">            ret = ParseAuxSegmentSp3Inv( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4126">            state = AST_MOBILE_H_SP3_INV_NUMBERS;</a>
<a name="ln4127">            break;</a>
<a name="ln4128">        case AST_MOBILE_H_SP3_INV_NUMBERS:</a>
<a name="ln4129">            ret = ParseAuxSegmentSp3InvNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4130">            state = AST_MOBILE_H_ISO_LAYER_FORK;</a>
<a name="ln4131">            break;</a>
<a name="ln4132">        case AST_MOBILE_H_ISO_LAYER_FORK:</a>
<a name="ln4133">            if ( !memcmp( pLine-&gt;str, &quot;I:&quot;, 2 ) ) {</a>
<a name="ln4134">                state = AST_MOBILE_H_ISO_NUMBERS;</a>
<a name="ln4135">            } else</a>
<a name="ln4136">            if ( !memicmp( pLine-&gt;str, &quot;F:&quot;, 2 ) ) { </a>
<a name="ln4137">                state = AST_FIXED_H_NUMBERS;</a>
<a name="ln4138">                bMobileH = TAUT_NON;</a>
<a name="ln4139">            } else</a>
<a name="ln4140">            if ( /*bReconn == INCHI_BAS &amp;&amp;*/ !memicmp( pLine-&gt;str, &quot;CRV:&quot;, 4 ) ) {</a>
<a name="ln4141">                state = AST_REVERSE_INFO_CRV;</a>
<a name="ln4142">            } else</a>
<a name="ln4143">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;rA:&quot;, 3 ) ) {</a>
<a name="ln4144">                state = AST_REVERSE_INFO_ATOMS;</a>
<a name="ln4145">            } else</a>
<a name="ln4146">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;R:&quot;, 3 ) ) {</a>
<a name="ln4147">                ret = 1;  /* read the next segment */</a>
<a name="ln4148">                state = AST_VERSION;</a>
<a name="ln4149">                bMobileH = TAUT_YES;</a>
<a name="ln4150">                bReconn = INCHI_REC;</a>
<a name="ln4151">            } else {</a>
<a name="ln4152">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4153">            }</a>
<a name="ln4154">            break;</a>
<a name="ln4155">        /* Mobile H, isotopic */</a>
<a name="ln4156">        case AST_MOBILE_H_ISO_NUMBERS:</a>
<a name="ln4157">            ret = ParseAuxSegmentNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4158">            state = AST_MOBILE_H_ISO_ATOM_EQ;</a>
<a name="ln4159">            break;</a>
<a name="ln4160">        case AST_MOBILE_H_ISO_ATOM_EQ:</a>
<a name="ln4161">            ret = ParseAuxSegmentAtomEqu( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4162">            state = AST_MOBILE_H_ISO_GROUP_EQ;</a>
<a name="ln4163">            break;</a>
<a name="ln4164">        case AST_MOBILE_H_ISO_GROUP_EQ:</a>
<a name="ln4165">            ret = ParseAuxSegmentGroupEqu( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4166">            state = AST_MOBILE_H_ISO_SP3_INV;</a>
<a name="ln4167">            break;</a>
<a name="ln4168">        case AST_MOBILE_H_ISO_SP3_INV:</a>
<a name="ln4169">            ret = ParseAuxSegmentSp3Inv( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4170">            state = AST_MOBILE_H_ISO_SP3_INV_NUMBERS;</a>
<a name="ln4171">            break;</a>
<a name="ln4172">        case AST_MOBILE_H_ISO_SP3_INV_NUMBERS:</a>
<a name="ln4173">            ret = ParseAuxSegmentSp3InvNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4174">            state = AST_FIXED_H_LAYER_FORK;</a>
<a name="ln4175">            break;</a>
<a name="ln4176">        case AST_FIXED_H_LAYER_FORK:</a>
<a name="ln4177">            if ( !memicmp( pLine-&gt;str, &quot;F:&quot;, 2 ) ) { </a>
<a name="ln4178">                state = AST_FIXED_H_NUMBERS;</a>
<a name="ln4179">                bMobileH = TAUT_NON;</a>
<a name="ln4180">            } else</a>
<a name="ln4181">            if ( /*bReconn == INCHI_BAS &amp;&amp;*/ !memicmp( pLine-&gt;str, &quot;CRV:&quot;, 4 ) ) {</a>
<a name="ln4182">                state = AST_REVERSE_INFO_CRV;</a>
<a name="ln4183">            } else</a>
<a name="ln4184">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;rA:&quot;, 3 ) ) {</a>
<a name="ln4185">                state = AST_REVERSE_INFO_ATOMS;</a>
<a name="ln4186">            } else</a>
<a name="ln4187">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;R:&quot;, 3 ) ) {</a>
<a name="ln4188">                ret = 1;  /* read the next segment */</a>
<a name="ln4189">                state = AST_VERSION;</a>
<a name="ln4190">                bMobileH = TAUT_YES;</a>
<a name="ln4191">                bReconn = INCHI_REC;</a>
<a name="ln4192">            } else {</a>
<a name="ln4193">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4194">            }</a>
<a name="ln4195">            break;</a>
<a name="ln4196">        case AST_FIXED_H_NUMBERS:</a>
<a name="ln4197">            ret = ParseAuxSegmentNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4198">            state = AST_FIXED_H_ATOM_EQ;</a>
<a name="ln4199">            break;</a>
<a name="ln4200">        case AST_FIXED_H_ATOM_EQ:</a>
<a name="ln4201">            ret = ParseAuxSegmentAtomEqu( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4202">            state = AST_FIXED_H_SP3_INV;</a>
<a name="ln4203">            break;</a>
<a name="ln4204">        case AST_FIXED_H_SP3_INV:</a>
<a name="ln4205">            ret = ParseAuxSegmentSp3Inv( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4206">            state = AST_FIXED_H_SP3_INV_NUMBERS;</a>
<a name="ln4207">            break;</a>
<a name="ln4208">        case AST_FIXED_H_SP3_INV_NUMBERS:</a>
<a name="ln4209">            ret = ParseAuxSegmentSp3InvNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4210">            state = AST_FIXED_H_ISO_LAYER_FORK;</a>
<a name="ln4211">            break;</a>
<a name="ln4212">        case AST_FIXED_H_ISO_LAYER_FORK:</a>
<a name="ln4213">            if ( !memcmp( pLine-&gt;str, &quot;I:&quot;, 2 ) ) {</a>
<a name="ln4214">                state = AST_FIXED_H_ISO_NUMBERS;</a>
<a name="ln4215">            } else</a>
<a name="ln4216">            if ( /*bReconn == INCHI_BAS &amp;&amp;*/ !memicmp( pLine-&gt;str, &quot;CRV:&quot;, 4 ) ) {</a>
<a name="ln4217">                state = AST_REVERSE_INFO_CRV;</a>
<a name="ln4218">            } else</a>
<a name="ln4219">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;rA:&quot;, 3 ) ) {</a>
<a name="ln4220">                state = AST_REVERSE_INFO_ATOMS;</a>
<a name="ln4221">            } else</a>
<a name="ln4222">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;R:&quot;, 3 ) ) {</a>
<a name="ln4223">                ret = 1;  /* read the next segment */</a>
<a name="ln4224">                state = AST_VERSION;</a>
<a name="ln4225">                bMobileH = TAUT_YES;</a>
<a name="ln4226">                bReconn = INCHI_REC;</a>
<a name="ln4227">            } else {</a>
<a name="ln4228">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4229">            }</a>
<a name="ln4230">            break;</a>
<a name="ln4231">        case AST_FIXED_H_ISO_NUMBERS:</a>
<a name="ln4232">            ret = ParseAuxSegmentNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4233">            state = AST_FIXED_H_ISO_ATOM_EQ;</a>
<a name="ln4234">            break;</a>
<a name="ln4235">        case AST_FIXED_H_ISO_ATOM_EQ:</a>
<a name="ln4236">            ret = ParseAuxSegmentAtomEqu( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4237">            state = AST_FIXED_H_SP3_INV;</a>
<a name="ln4238">            break;</a>
<a name="ln4239">        case AST_FIXED_H_ISO_SP3_INV:</a>
<a name="ln4240">            ret = ParseAuxSegmentSp3Inv( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4241">            state = AST_FIXED_H_ISO_SP3_INV_NUMBERS;</a>
<a name="ln4242">            break;</a>
<a name="ln4243">        case AST_FIXED_H_ISO_SP3_INV_NUMBERS:</a>
<a name="ln4244">            ret = ParseAuxSegmentSp3InvNumbers( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4245">            state = AST_REVERSE_INFO_CRV;</a>
<a name="ln4246">            break;</a>
<a name="ln4247">        case AST_REVERSE_INFO_CRV:</a>
<a name="ln4248">            ret = ParseAuxSegmentReverseCRV( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4249">            /* state = (bReconn == INCHI_BAS)? AST_REVERSE_INFO_ATOMS : AST_RECONNECTED_LAYER_FORK;*/</a>
<a name="ln4250">            state = AST_REVERSE_INFO_ATOMS;</a>
<a name="ln4251">            break;</a>
<a name="ln4252">        case AST_REVERSE_INFO_ATOMS:</a>
<a name="ln4253">            ret = ParseAuxSegmentReverseAtoms( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4254">            state = AST_REVERSE_INFO_BONDS;</a>
<a name="ln4255">            break;</a>
<a name="ln4256">        case AST_REVERSE_INFO_BONDS:</a>
<a name="ln4257">            ret = ParseAuxSegmentReverseBonds( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4258">            state = AST_REVERSE_INFO_XYZ;</a>
<a name="ln4259">            break;</a>
<a name="ln4260">        case AST_REVERSE_INFO_XYZ:</a>
<a name="ln4261">            ret = ParseAuxSegmentReverseXYZ( pLine-&gt;str, bMobileH, &amp;pXYZ, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4262">            state = AST_RECONNECTED_LAYER_FORK;</a>
<a name="ln4263">            if ( ret &gt; 0 ) {</a>
<a name="ln4264">                nLenXYZ = ret - 1;</a>
<a name="ln4265">            }</a>
<a name="ln4266">            break;</a>
<a name="ln4267">        case AST_RECONNECTED_LAYER_FORK:</a>
<a name="ln4268">            if ( bReconn == INCHI_BAS &amp;&amp; !memicmp( pLine-&gt;str, &quot;R:&quot;, 3 ) ) {</a>
<a name="ln4269">                ret = 1;  /* read the next segment */</a>
<a name="ln4270">                state = AST_VERSION;</a>
<a name="ln4271">                bMobileH = TAUT_YES;</a>
<a name="ln4272">                bReconn = INCHI_REC;</a>
<a name="ln4273">            } else {</a>
<a name="ln4274">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4275">            }</a>
<a name="ln4276">            break;</a>
<a name="ln4277">        }</a>
<a name="ln4278">    } while( c &gt;= 0 );</a>
<a name="ln4279">    </a>
<a name="ln4280">    ret = AddAuxSegmentCoord( ret, pXYZ, nLenXYZ, pInpInChI, nNumComponents );</a>
<a name="ln4281"> </a>
<a name="ln4282">exit_error:</a>
<a name="ln4283">    if ( pXYZ ) {</a>
<a name="ln4284">        inchi_free( pXYZ );</a>
<a name="ln4285">    }</a>
<a name="ln4286">    if ( ret &gt;= 0 || c == RI_ERR_EOF || c == RI_ERR_EOL ) {</a>
<a name="ln4287">        pLine-&gt;len = 0;</a>
<a name="ln4288">    }</a>
<a name="ln4289"> </a>
<a name="ln4290">    return ret;</a>
<a name="ln4291">}</a>
<a name="ln4292">/******************************************************************************************************/</a>
<a name="ln4293">int ReadInChILine(INCHI_IOSTREAM *pInp, SEGM_LINE *pLine, </a>
<a name="ln4294">                  char **pStr, int *pState,</a>
<a name="ln4295">                  INChI *pInpInChI[INCHI_NUM][TAUT_NUM],</a>
<a name="ln4296">                  int nNumComponents[INCHI_NUM][TAUT_NUM],</a>
<a name="ln4297">                  REM_PROTONS nNumProtons[INCHI_NUM][TAUT_NUM],</a>
<a name="ln4298">                  int s[INCHI_NUM][TAUT_NUM][2],</a>
<a name="ln4299">                  int *bStdFormat, </a>
<a name="ln4300">                  int *bInputHasSaveOpt, unsigned char *inp_save_opt_bits)</a>
<a name="ln4301">{</a>
<a name="ln4302">    int   c, fst, ret=RI_ERR_ALLOC, len;</a>
<a name="ln4303">    int   bMobileH = TAUT_YES, bReconn = INCHI_BAS;</a>
<a name="ln4304">    const char szToken[] = INCHI_TOKEN;</a>
<a name="ln4305">    char *p;</a>
<a name="ln4306">    int  state=-1, prev_state=-1;</a>
<a name="ln4307">    int  bAbc = -1;  /* -1=&gt; undefined, 0=&gt; decimal, 1=&gt; abc (compressed) */</a>
<a name="ln4308">    </a>
<a name="ln4309">    const int len_std_prefix=8;</a>
<a name="ln4310">    size_t k=0;</a>
<a name="ln4311">    unsigned char let1, let2;</a>
<a name="ln4312">    const char a2p[]=&quot;ABCDEFGHIJKLMNOP&quot;;</a>
<a name="ln4313"> </a>
<a name="ln4314">    /* memset( pLine, 0, sizeof( pLine[0] ) ); */</a>
<a name="ln4315">    *pState = 0;</a>
<a name="ln4316"> </a>
<a name="ln4317">next_line:</a>
<a name="ln4318">    INCHI_HEAPCHK</a>
<a name="ln4319">    /* Got &quot;InChI=1/&quot; */</a>
<a name="ln4320">    if ( pLine-&gt;len ) </a>
<a name="ln4321">    {</a>
<a name="ln4322">        c = pLine-&gt;c;</a>
<a name="ln4323">    } </a>
<a name="ln4324">    else </a>
<a name="ln4325">    {</a>
<a name="ln4326">        INCHI_HEAPCHK</a>
<a name="ln4327">        c = nGetInChISegment( pInp, pLine, szToken );</a>
<a name="ln4328">        INCHI_HEAPCHK</a>
<a name="ln4329">    }</a>
<a name="ln4330">    if ( c == RI_ERR_EOF &amp;&amp; !pLine-&gt;len &amp;&amp; !pLine-&gt;str[0] ) </a>
<a name="ln4331">    {</a>
<a name="ln4332">        ret = c;</a>
<a name="ln4333">        goto exit_function;</a>
<a name="ln4334">    }</a>
<a name="ln4335">    INCHI_HEAPCHK</a>
<a name="ln4336"> </a>
<a name="ln4337">    if ( pLine-&gt;len == 0 || (c != SEG_END &amp;&amp; c != RI_ERR_EOF) || !(p = strstr(pLine-&gt;str, &quot;InChI=1&quot;)) )</a>
<a name="ln4338">    {</a>
<a name="ln4339">        if ( pLine-&gt;str &amp;&amp; pLine-&gt;str == strstr ( pLine-&gt;str, &quot;Structure&quot; ) ) </a>
<a name="ln4340">        {</a>
<a name="ln4341">            if ( *pStr ) </a>
<a name="ln4342">            {</a>
<a name="ln4343">                INCHI_HEAPCHK</a>
<a name="ln4344">                inchi_free( *pStr );</a>
<a name="ln4345">            }</a>
<a name="ln4346">            *pStr = pLine-&gt;str;</a>
<a name="ln4347">            /* bypass to the end of the 'Structure nnn' line */</a>
<a name="ln4348">            memset( pLine, 0, sizeof( pLine[0] ) );</a>
<a name="ln4349">            while ( c &amp;&amp; !INCHI_INP_EOL(c) ) </a>
<a name="ln4350">            {</a>
<a name="ln4351">                c = getInChIChar(pInp);</a>
<a name="ln4352">            }</a>
<a name="ln4353">            goto next_line;</a>
<a name="ln4354">        }</a>
<a name="ln4355">        /* bypass to the end of unrecognized line */</a>
<a name="ln4356">        while ( c != RI_ERR_EOF &amp;&amp; !INCHI_INP_EOL(c) ) </a>
<a name="ln4357">        {</a>
<a name="ln4358">            c = getInChIChar(pInp);</a>
<a name="ln4359">        }</a>
<a name="ln4360">        pLine-&gt;len = 0;</a>
<a name="ln4361">        INCHI_HEAPCHK</a>
<a name="ln4362">        goto next_line;</a>
<a name="ln4363">    }</a>
<a name="ln4364">    </a>
<a name="ln4365"> </a>
<a name="ln4366">    /* Check if got a standard InChI */	</a>
<a name="ln4367">    if ( ( pLine-&gt;len == len_std_prefix ) &amp;&amp; (pLine-&gt;str[len_std_prefix-1]=='S') )</a>
<a name="ln4368">        *bStdFormat=1;</a>
<a name="ln4369">    else</a>
<a name="ln4370">        *bStdFormat=0;</a>
<a name="ln4371">    </a>
<a name="ln4372"> </a>
<a name="ln4373">    state=IST_MOBILE_H_FORMULA;</a>
<a name="ln4374">    ret  = 1; /* means read the next segment */</a>
<a name="ln4375">    do {</a>
<a name="ln4376">        /* read the next segment up to the '/' */</a>
<a name="ln4377">        INCHI_HEAPCHK</a>
<a name="ln4378">        if ( ret &lt; 0 ) </a>
<a name="ln4379">        {</a>
<a name="ln4380">            *pState = prev_state;</a>
<a name="ln4381">            break;</a>
<a name="ln4382">        }</a>
<a name="ln4383">        prev_state = state + (bReconn? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln4384">        if ( 0 &lt; ret ) </a>
<a name="ln4385">        {</a>
<a name="ln4386">            /* read next segment */</a>
<a name="ln4387">            if ( c != RI_ERR_EOF &amp;&amp; c != SEG_END ) </a>
<a name="ln4388">            {</a>
<a name="ln4389">                /* abnormal reading result; should not happen */</a>
<a name="ln4390">                /* unless we got backslash-SaveOpt */</a>
<a name="ln4391">                if ( c=='\\' )</a>
<a name="ln4392">                {</a>
<a name="ln4393">                    /* May be SaveOpt */</a>
<a name="ln4394">                    *bInputHasSaveOpt = 1;</a>
<a name="ln4395">                }</a>
<a name="ln4396">                k = 0;</a>
<a name="ln4397">                while ( c != RI_ERR_EOF &amp;&amp; !INCHI_INP_EOL(c) ) </a>
<a name="ln4398">                {</a>
<a name="ln4399">                    /* bypass to the end of line or file */</a>
<a name="ln4400">                    c = getInChIChar(pInp);</a>
<a name="ln4401">                    k++;</a>
<a name="ln4402">                    if ( k==1 )       let1 = c;</a>
<a name="ln4403">                    else if ( k==2 )  let2 = c;</a>
<a name="ln4404">                }</a>
<a name="ln4405">                if ( k != 3) </a>
<a name="ln4406">                {</a>
<a name="ln4407">                    /* not a valid SaveOpt which must be of two chars */</a>
<a name="ln4408">                    *bInputHasSaveOpt = 0;</a>
<a name="ln4409">                    let1 = let2 = '\0';</a>
<a name="ln4410">                }</a>
<a name="ln4411">                else        </a>
<a name="ln4412">                {</a>
<a name="ln4413">                    /* may be SaveOpt - analyze the content */</a>
<a name="ln4414">                    if  ( ( let2 &gt;= 'A') &amp;&amp; ( let2 &lt;= 'D') )        /* letter-2 OK */</a>
<a name="ln4415">                    {</a>
<a name="ln4416">                        *bInputHasSaveOpt = 0;</a>
<a name="ln4417">                        *inp_save_opt_bits = 0;</a>
<a name="ln4418">                        for (k=0; k&lt;16; k++)</a>
<a name="ln4419">                        {</a>
<a name="ln4420">                            if ( a2p[k] == let1)                    /* letter-1 OK */</a>
<a name="ln4421">                            {</a>
<a name="ln4422">                                *inp_save_opt_bits = (unsigned char) k;</a>
<a name="ln4423">                                *bInputHasSaveOpt = 1;</a>
<a name="ln4424">                                break;</a>
<a name="ln4425">                            }</a>
<a name="ln4426">                        }</a>
<a name="ln4427">                        if ( *bInputHasSaveOpt )</a>
<a name="ln4428">                        {</a>
<a name="ln4429">                            if ( let2=='B' || let2=='D' ) </a>
<a name="ln4430">                                *inp_save_opt_bits |= SAVE_OPT_15T;</a>
<a name="ln4431">                            if ( let2=='C' || let2=='D' ) </a>
<a name="ln4432">                                *inp_save_opt_bits |= SAVE_OPT_KET;</a>
<a name="ln4433">                        }</a>
<a name="ln4434">                    }</a>
<a name="ln4435">                }</a>
<a name="ln4436"> </a>
<a name="ln4437">                ret = (c == RI_ERR_EOF)? RI_ERR_EOF : RI_ERR_EOL; /* end of line */</a>
<a name="ln4438">                pLine-&gt;len = 0;</a>
<a name="ln4439">                pLine-&gt;c   = ret;</a>
<a name="ln4440">                break; /* exit */</a>
<a name="ln4441">            }</a>
<a name="ln4442">            if ( c == RI_ERR_EOF ) {</a>
<a name="ln4443">                ret = RI_ERR_EOF; /* end of line */</a>
<a name="ln4444">                break;</a>
<a name="ln4445">            }</a>
<a name="ln4446">            if ( c == SEG_END ) {</a>
<a name="ln4447">                c = nGetInChISegment( pInp, pLine, szToken );</a>
<a name="ln4448">            }</a>
<a name="ln4449">            if ( c &lt; 0 ) {</a>
<a name="ln4450">                goto exit_error; /* error */</a>
<a name="ln4451">            }</a>
<a name="ln4452">            if ( !pLine-&gt;len ) {</a>
<a name="ln4453">                ret = RI_ERR_EOL; /* end of line */</a>
<a name="ln4454">                break;</a>
<a name="ln4455">            }</a>
<a name="ln4456">            fst = UCINT pLine-&gt;str[0];</a>
<a name="ln4457">        }</a>
<a name="ln4458">        /* process the seqment */</a>
<a name="ln4459">        switch ( state ) {</a>
<a name="ln4460"> </a>
<a name="ln4461">        /* Mobile H, M */                /* /  */</a>
<a name="ln4462">        case IST_MOBILE_H_FORMULA:</a>
<a name="ln4463">            bMobileH = TAUT_YES;</a>
<a name="ln4464">            ret = ParseSegmentFormula( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn] );</a>
<a name="ln4465">            state = IST_MOBILE_H_CONNECTIONS;</a>
<a name="ln4466">            break;</a>
<a name="ln4467">        case IST_MOBILE_H_CONNECTIONS:   /* /c */</a>
<a name="ln4468">            ret = ParseSegmentConnections( pLine-&gt;str, bMobileH, &amp;pInpInChI[bReconn][bMobileH], &amp;nNumComponents[bReconn][bMobileH], &amp;bAbc );</a>
<a name="ln4469">            state = IST_MOBILE_H;</a>
<a name="ln4470">            break;</a>
<a name="ln4471">        case IST_MOBILE_H:               /* /h */</a>
<a name="ln4472">            ret = ParseSegmentMobileH( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], &amp;bAbc );</a>
<a name="ln4473">            state = IST_MOBILE_H_CHARGE;</a>
<a name="ln4474">            break;</a>
<a name="ln4475">        case IST_MOBILE_H_CHARGE:        /* /q */</a>
<a name="ln4476">            ret = ParseSegmentCharge( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn] );</a>
<a name="ln4477">            state = IST_MOBILE_H_PROTONS;</a>
<a name="ln4478">            break;</a>
<a name="ln4479">        case IST_MOBILE_H_PROTONS:       /* /p */</a>
<a name="ln4480">            ret = ParseSegmentProtons( pLine-&gt;str, bMobileH, nNumProtons[bReconn], nNumComponents[bReconn] );</a>
<a name="ln4481">            state = IST_MOBILE_H_SP2;</a>
<a name="ln4482">            break;</a>
<a name="ln4483">        case IST_MOBILE_H_SP2:           /* /b */</a>
<a name="ln4484">            ret = ParseSegmentSp2( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4485">            state = IST_MOBILE_H_SP3;</a>
<a name="ln4486">            break;</a>
<a name="ln4487">        case IST_MOBILE_H_SP3:         /* t */</a>
<a name="ln4488">            ret = ParseSegmentSp3( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4489">            state = IST_MOBILE_H_SP3_M;</a>
<a name="ln4490">            break;</a>
<a name="ln4491">        case IST_MOBILE_H_SP3_M:       /* /m */</a>
<a name="ln4492">            ret = ParseSegmentSp3m( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4493">            state = IST_MOBILE_H_SP3_S;</a>
<a name="ln4494">            break;</a>
<a name="ln4495">        case IST_MOBILE_H_SP3_S:       /* /s */ </a>
<a name="ln4496">            ret = ParseSegmentSp3s( pLine-&gt;str, bMobileH, pInpInChI[bReconn], s[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4497">            state = IST_MOBILE_H_ISO_LAYER_FORK;</a>
<a name="ln4498">            break;</a>
<a name="ln4499">        case IST_MOBILE_H_ISO_LAYER_FORK:</a>
<a name="ln4500">            /* find layer type after M */</a>
<a name="ln4501">            ret = 0;</a>
<a name="ln4502">            switch( pLine-&gt;str[0] ) {</a>
<a name="ln4503">            case 'i':</a>
<a name="ln4504">                state = IST_MOBILE_H_ISO_ATOMS;  /* MI */</a>
<a name="ln4505">                break;</a>
<a name="ln4506">            case 'f':</a>
<a name="ln4507">                state = IST_FIXED_H_FORMULA; /* F */</a>
<a name="ln4508">                break;</a>
<a name="ln4509">            case 'r':</a>
<a name="ln4510">                state = IST_RECONNECTED_FORMULA; /* reconnected */</a>
<a name="ln4511">                break;</a>
<a name="ln4512">            default:</a>
<a name="ln4513">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4514">            }</a>
<a name="ln4515">            if ( INCHI_INP_EOL(c) &amp;&amp; ret == 0 &amp;&amp; !pLine-&gt;str[1] ) {</a>
<a name="ln4516">                prev_state = state + (bReconn? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln4517">                ret = RI_ERR_SYNTAX; /* empty layer /i or /f or /r at the end of InChI line */</a>
<a name="ln4518">            } else</a>
<a name="ln4519">            if ( !ret &amp;&amp; state != IST_MOBILE_H_ISO_ATOMS ) {</a>
<a name="ln4520">                len = strlen( pLine-&gt;str );</a>
<a name="ln4521">                if ( len &gt; 1 ) {</a>
<a name="ln4522">                    memmove( pLine-&gt;str, pLine-&gt;str+1, len );</a>
<a name="ln4523">                } else {</a>
<a name="ln4524">                    ret = 1; /* read the next segment */</a>
<a name="ln4525">                }</a>
<a name="ln4526">            }</a>
<a name="ln4527">            break;</a>
<a name="ln4528">        /* Mobile H, isotopic, MI */</a>
<a name="ln4529">        case IST_MOBILE_H_ISO_ATOMS:   /* i */</a>
<a name="ln4530">            ret = ParseSegmentIsoAtoms( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4531">            state = IST_MOBILE_H_ISO_EXCH_H;</a>
<a name="ln4532">            break;</a>
<a name="ln4533">        case IST_MOBILE_H_ISO_EXCH_H:  /* /i/h */</a>
<a name="ln4534">            ret = ParseSegmentIsoExchgH( pLine-&gt;str, bMobileH, nNumProtons[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4535">            state = IST_MOBILE_H_ISO_SP2;</a>
<a name="ln4536">            break;</a>
<a name="ln4537">        case IST_MOBILE_H_ISO_SP2:         /* /i/b */</a>
<a name="ln4538">            ret = ParseSegmentSp2( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4539">            state = IST_MOBILE_H_ISO_SP3;</a>
<a name="ln4540">            break;</a>
<a name="ln4541">        case IST_MOBILE_H_ISO_SP3:         /* /i/t */</a>
<a name="ln4542">            ret = ParseSegmentSp3( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4543">            state = IST_MOBILE_H_ISO_SP3_M;</a>
<a name="ln4544">            break;</a>
<a name="ln4545">        case IST_MOBILE_H_ISO_SP3_M:       /* /i/m */</a>
<a name="ln4546">            ret = ParseSegmentSp3m( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4547">            state = IST_MOBILE_H_ISO_SP3_S;</a>
<a name="ln4548"> </a>
<a name="ln4549">            </a>
<a name="ln4550">            break;</a>
<a name="ln4551">        case IST_MOBILE_H_ISO_SP3_S:       /* /i/s */</a>
<a name="ln4552">            ret = ParseSegmentSp3s( pLine-&gt;str, bMobileH, pInpInChI[bReconn], s[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4553">            state = IST_FIXED_H_LAYER_FORK;</a>
<a name="ln4554">            break;</a>
<a name="ln4555">        case IST_FIXED_H_LAYER_FORK:</a>
<a name="ln4556">            /* find layer type after MI */</a>
<a name="ln4557">            ret = 0;</a>
<a name="ln4558">            switch( pLine-&gt;str[0] ) {</a>
<a name="ln4559">            case 'f':</a>
<a name="ln4560">                state = IST_FIXED_H_FORMULA; /* F */</a>
<a name="ln4561">                break;</a>
<a name="ln4562">            case 'r':</a>
<a name="ln4563">                state = IST_RECONNECTED_FORMULA; /* reconnected */</a>
<a name="ln4564">                break;</a>
<a name="ln4565">            default:</a>
<a name="ln4566">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4567">            }</a>
<a name="ln4568">            if ( INCHI_INP_EOL(c) &amp;&amp; ret == 0 &amp;&amp; !pLine-&gt;str[1] ) {</a>
<a name="ln4569">                prev_state = state + (bReconn? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln4570">                ret = RI_ERR_SYNTAX; /* empty layer /f or /r at the end of InChI line */</a>
<a name="ln4571">            } else</a>
<a name="ln4572">            if ( !ret ) {</a>
<a name="ln4573">                len = strlen( pLine-&gt;str );</a>
<a name="ln4574">                if ( len &gt; 1 ) {</a>
<a name="ln4575">                    memmove( pLine-&gt;str, pLine-&gt;str+1, len );</a>
<a name="ln4576">                } else {</a>
<a name="ln4577">                    ret = 1; /* read the next segment */</a>
<a name="ln4578">                }</a>
<a name="ln4579">            }</a>
<a name="ln4580">            break;</a>
<a name="ln4581"> </a>
<a name="ln4582">        /* Fixed H, F */</a>
<a name="ln4583">        case IST_FIXED_H_FORMULA:</a>
<a name="ln4584">            bMobileH = TAUT_NON;</a>
<a name="ln4585">            ret = ParseSegmentFormula( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn] );</a>
<a name="ln4586">            state = IST_FIXED_H;</a>
<a name="ln4587">            break;</a>
<a name="ln4588">        case IST_FIXED_H:               /* /f/h */</a>
<a name="ln4589">            ret = ParseSegmentMobileH( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], &amp;bAbc );</a>
<a name="ln4590">            state = IST_FIXED_H_CHARGE;</a>
<a name="ln4591">            break;</a>
<a name="ln4592">        case IST_FIXED_H_CHARGE:        /* /f/q */</a>
<a name="ln4593">            ret = ParseSegmentCharge( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn] );</a>
<a name="ln4594">            state = IST_FIXED_H_SP2;</a>
<a name="ln4595">            break;</a>
<a name="ln4596">        case IST_FIXED_H_SP2:           /* /f/b */</a>
<a name="ln4597">            ret = ParseSegmentSp2( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4598">            state = IST_FIXED_H_SP3;</a>
<a name="ln4599">            break;</a>
<a name="ln4600">        case IST_FIXED_H_SP3:         /* /f/t */</a>
<a name="ln4601">            ret = ParseSegmentSp3( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4602">            state = IST_FIXED_H_SP3_M;</a>
<a name="ln4603">            break;</a>
<a name="ln4604">        case IST_FIXED_H_SP3_M:       /* /f/m */</a>
<a name="ln4605">            ret = ParseSegmentSp3m( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4606">            state = IST_FIXED_H_SP3_S;</a>
<a name="ln4607">            break;</a>
<a name="ln4608">        case IST_FIXED_H_SP3_S:       /* /f/s */</a>
<a name="ln4609">            ret = ParseSegmentSp3s( pLine-&gt;str, bMobileH, pInpInChI[bReconn], s[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4610">            state = IST_FIXED_H_PERMUTATION;</a>
<a name="ln4611">            break;</a>
<a name="ln4612">        case IST_FIXED_H_PERMUTATION:  /* /f/o */</a>
<a name="ln4613">            ret = ParseSegmentPerm( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4614">            state = IST_FIXED_H_ISO_LAYER_FORK;</a>
<a name="ln4615">            break;</a>
<a name="ln4616">        case IST_FIXED_H_ISO_LAYER_FORK:</a>
<a name="ln4617">            /* find layer type after M */</a>
<a name="ln4618">            ret = 0;</a>
<a name="ln4619">            switch( pLine-&gt;str[0] ) {</a>
<a name="ln4620">            case 'i':</a>
<a name="ln4621">                state = IST_FIXED_H_ISO_ATOMS;  /* FI */</a>
<a name="ln4622">                break;</a>
<a name="ln4623">            case 'r':</a>
<a name="ln4624">                state = IST_RECONNECTED_FORMULA; /* reconnected */</a>
<a name="ln4625">                break;</a>
<a name="ln4626">            default:</a>
<a name="ln4627">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4628">            }</a>
<a name="ln4629">            if ( INCHI_INP_EOL(c) &amp;&amp; ret == 0 &amp;&amp; !pLine-&gt;str[1] ) {</a>
<a name="ln4630">                prev_state = state + (bReconn? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln4631">                ret = RI_ERR_SYNTAX; /* empty layer /i or /r at the end of InChI line */</a>
<a name="ln4632">            } else</a>
<a name="ln4633">            if ( !ret &amp;&amp; state != IST_FIXED_H_ISO_ATOMS ) {</a>
<a name="ln4634">                len = strlen( pLine-&gt;str );</a>
<a name="ln4635">                if ( len &gt; 1 ) {</a>
<a name="ln4636">                    memmove( pLine-&gt;str, pLine-&gt;str+1, len );</a>
<a name="ln4637">                } else {</a>
<a name="ln4638">                    ret = 1; /* read the next segment */</a>
<a name="ln4639">                }</a>
<a name="ln4640">            }</a>
<a name="ln4641">            break;</a>
<a name="ln4642"> </a>
<a name="ln4643">        /* Fixed H, isotopic, FI */</a>
<a name="ln4644">        case IST_FIXED_H_ISO_ATOMS:   /* /f/i */</a>
<a name="ln4645">            ret = ParseSegmentIsoAtoms( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4646">            state = IST_FIXED_H_ISO_SP2;</a>
<a name="ln4647">            break;</a>
<a name="ln4648">        case IST_FIXED_H_ISO_SP2:         /* /f/i/b */</a>
<a name="ln4649">            ret = ParseSegmentSp2( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4650">            state = IST_FIXED_H_ISO_SP3;</a>
<a name="ln4651">            break;</a>
<a name="ln4652">        case IST_FIXED_H_ISO_SP3:         /* /f/i/t */</a>
<a name="ln4653">            ret = ParseSegmentSp3( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4654">            state = IST_FIXED_H_ISO_SP3_M;</a>
<a name="ln4655">            break;</a>
<a name="ln4656">        case IST_FIXED_H_ISO_SP3_M:       /* /f/i/m */</a>
<a name="ln4657">            ret = ParseSegmentSp3m( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4658">            state = IST_FIXED_H_ISO_SP3_S;</a>
<a name="ln4659">            break;</a>
<a name="ln4660">        case IST_FIXED_H_ISO_SP3_S:       /* /f/i/s */</a>
<a name="ln4661">            ret = ParseSegmentSp3s( pLine-&gt;str, bMobileH, pInpInChI[bReconn], s[bReconn], nNumComponents[bReconn], state );</a>
<a name="ln4662">            state = IST_FIXED_H_ISO_PERMUTATION;</a>
<a name="ln4663">            break;</a>
<a name="ln4664">        case IST_FIXED_H_ISO_PERMUTATION:  /* /f/i/o */</a>
<a name="ln4665">            ret = ParseSegmentPerm( pLine-&gt;str, bMobileH, pInpInChI[bReconn], nNumComponents[bReconn], state, &amp;bAbc );</a>
<a name="ln4666">            state = IST_RECONNECTED_LAYER_FORK;</a>
<a name="ln4667">            break;</a>
<a name="ln4668">        case IST_RECONNECTED_LAYER_FORK:</a>
<a name="ln4669">            /* find layer type after FI */</a>
<a name="ln4670">            ret = 0;</a>
<a name="ln4671">            switch( pLine-&gt;str[0] ) {</a>
<a name="ln4672">            case 'r':</a>
<a name="ln4673">                state = IST_RECONNECTED_FORMULA; /* reconnected */</a>
<a name="ln4674">                break;</a>
<a name="ln4675">            default:</a>
<a name="ln4676">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4677">            }</a>
<a name="ln4678">            if ( INCHI_INP_EOL(c) &amp;&amp; ret == 0 &amp;&amp; !pLine-&gt;str[1] ) {</a>
<a name="ln4679">                prev_state = state + (bReconn? IST_HAPPENED_IN_RECMET : 0);</a>
<a name="ln4680">                ret = RI_ERR_SYNTAX; /* empty layer /r at the end of InChI line */</a>
<a name="ln4681">            } else</a>
<a name="ln4682">            if ( !ret ) {</a>
<a name="ln4683">                len = strlen( pLine-&gt;str );</a>
<a name="ln4684">                if ( len &gt; 1 ) {</a>
<a name="ln4685">                    memmove( pLine-&gt;str, pLine-&gt;str+1, len );</a>
<a name="ln4686">                } else {</a>
<a name="ln4687">                    ret = 1; /* read the next segment */</a>
<a name="ln4688">                }</a>
<a name="ln4689">            }</a>
<a name="ln4690">            break;</a>
<a name="ln4691">        case IST_RECONNECTED_FORMULA:</a>
<a name="ln4692">            bReconn = INCHI_REC;</a>
<a name="ln4693">            bMobileH = TAUT_YES;</a>
<a name="ln4694">            state   = IST_MOBILE_H_FORMULA;</a>
<a name="ln4695">            break;</a>
<a name="ln4696">        }</a>
<a name="ln4697"> </a>
<a name="ln4698"> </a>
<a name="ln4699">    } while( c &gt;= 0 );</a>
<a name="ln4700"> </a>
<a name="ln4701">exit_function:;</a>
<a name="ln4702">exit_error:;</a>
<a name="ln4703"> </a>
<a name="ln4704">    INCHI_HEAPCHK</a>
<a name="ln4705"> </a>
<a name="ln4706">    if ( ret &gt;= 0 || c == RI_ERR_EOF || c == RI_ERR_EOL ) {</a>
<a name="ln4707">        pLine-&gt;len = 0;</a>
<a name="ln4708">    }</a>
<a name="ln4709">    return ret;</a>
<a name="ln4710">}</a>
<a name="ln4711">/****************************************************************************************/</a>
<a name="ln4712">int ParseSegmentIsoExchgH( const char *str, int bMobileH, REM_PROTONS nNumProtons[], int pnNumComponents[], int state, int *pbAbc )</a>
<a name="ln4713">{</a>
<a name="ln4714">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln4715">    const char *p, *q, *pStart, *pEnd;</a>
<a name="ln4716">    int  ret=0, num, i, i_prev;</a>
<a name="ln4717">    static char abc_h[] = &quot;hdt&quot;;</a>
<a name="ln4718"> </a>
<a name="ln4719">    if ( str[0] != 'h' )</a>
<a name="ln4720">        return 0;</a>
<a name="ln4721"> </a>
<a name="ln4722">    pStart = str+1;</a>
<a name="ln4723"> </a>
<a name="ln4724">    if ( !(bMobileH==TAUT_YES &amp;&amp; state == IST_MOBILE_H_ISO_EXCH_H ) ) {</a>
<a name="ln4725">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln4726">    }</a>
<a name="ln4727"> </a>
<a name="ln4728">    if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln4729">        pEnd = pStart + strlen(pStart);</a>
<a name="ln4730">    } else {</a>
<a name="ln4731">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4732">        goto exit_function;</a>
<a name="ln4733">    }</a>
<a name="ln4734">    p = pStart;</a>
<a name="ln4735"> </a>
<a name="ln4736">    if ( p &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln4737">        /* check if compressed InChI */</a>
<a name="ln4738">        /* compressed:    /hNtNdNh where N is a decimal number */</a>
<a name="ln4739">        /* uncompressed:  /hT[n]D[n]H[n] where n &gt; 1 is a decimal number */ </a>
<a name="ln4740">        *pbAbc = isdigit( UCINT *p)? 1 : 0;</a>
<a name="ln4741">    }</a>
<a name="ln4742"> </a>
<a name="ln4743">    if ( *pbAbc == 1 ) {</a>
<a name="ln4744">        i_prev = (int)sizeof(abc_h);</a>
<a name="ln4745">        while ( p &lt; pEnd ) {</a>
<a name="ln4746">            num = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln4747">            if ( 0 &gt;= num  || p == q || q &gt;= pEnd ) {</a>
<a name="ln4748">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4749">                goto exit_function;</a>
<a name="ln4750">            }</a>
<a name="ln4751">            p = strchr( abc_h, *q);</a>
<a name="ln4752">            if ( p &amp;&amp; (i=p-abc_h) &lt; i_prev ) {</a>
<a name="ln4753">                nNumProtons[bMobileH].nNumRemovedIsotopicH[i] = (NUM_H)num;</a>
<a name="ln4754">                p = q+1;</a>
<a name="ln4755">                i_prev = i;</a>
<a name="ln4756">            } else {</a>
<a name="ln4757">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4758">                goto exit_function;</a>
<a name="ln4759">            }</a>
<a name="ln4760">        }</a>
<a name="ln4761">    } else {</a>
<a name="ln4762">        if ( *p == 'T' ) {</a>
<a name="ln4763">            nNumProtons[bMobileH].nNumRemovedIsotopicH[2] = 1;</a>
<a name="ln4764">            p ++;</a>
<a name="ln4765">            if ( isdigit( UCINT p[0]) ) {</a>
<a name="ln4766">                nNumProtons[bMobileH].nNumRemovedIsotopicH[2] = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln4767">                p = q;</a>
<a name="ln4768">            }</a>
<a name="ln4769">        }</a>
<a name="ln4770">        if ( *p == 'D' ) {</a>
<a name="ln4771">            nNumProtons[bMobileH].nNumRemovedIsotopicH[1] = 1;</a>
<a name="ln4772">            p ++;</a>
<a name="ln4773">            if ( isdigit( UCINT p[0]) ) {</a>
<a name="ln4774">                nNumProtons[bMobileH].nNumRemovedIsotopicH[1] = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln4775">                p = q;</a>
<a name="ln4776">            }</a>
<a name="ln4777">        }</a>
<a name="ln4778">        if ( *p == 'H' ) {</a>
<a name="ln4779">            nNumProtons[bMobileH].nNumRemovedIsotopicH[0] = 1;</a>
<a name="ln4780">            p ++;</a>
<a name="ln4781">            if ( isdigit( UCINT p[0]) ) {</a>
<a name="ln4782">                nNumProtons[bMobileH].nNumRemovedIsotopicH[0] = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln4783">                p = q;</a>
<a name="ln4784">            }</a>
<a name="ln4785">        }</a>
<a name="ln4786">    }</a>
<a name="ln4787">    if ( p != pEnd ) {</a>
<a name="ln4788">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4789">        goto exit_function;</a>
<a name="ln4790">    }</a>
<a name="ln4791">    ret = 1;</a>
<a name="ln4792"> </a>
<a name="ln4793">exit_function:</a>
<a name="ln4794">    return ret;   </a>
<a name="ln4795"> </a>
<a name="ln4796">}</a>
<a name="ln4797">/****************************************************************************************/</a>
<a name="ln4798">int ParseSegmentPerm( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state, int *pbAbc )</a>
<a name="ln4799">{</a>
<a name="ln4800">    int nNumComponents, iComponent1, iComponent2, numTrans;</a>
<a name="ln4801">    const char *p, *q, *pStart, *pEnd, *pPermStart, *pPermEnd;</a>
<a name="ln4802">    int  ret=0;</a>
<a name="ln4803">    INChI *pInChI = pInpInChI[bMobileH]; /* bMobileH should be TAUT_NON = 0 */</a>
<a name="ln4804">    INChI tmp;</a>
<a name="ln4805">    int   base = 10;</a>
<a name="ln4806"> </a>
<a name="ln4807"> </a>
<a name="ln4808">    if ( str[0] != 'o' )</a>
<a name="ln4809">        return 0;</a>
<a name="ln4810"> </a>
<a name="ln4811">    pStart = str+1;</a>
<a name="ln4812">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln4813"> </a>
<a name="ln4814">    if ( !(bMobileH==TAUT_NON &amp;&amp; ( state == IST_FIXED_H_PERMUTATION || state == IST_FIXED_H_ISO_PERMUTATION) ) ) {</a>
<a name="ln4815">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln4816">    }</a>
<a name="ln4817"> </a>
<a name="ln4818">    if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln4819">        pEnd = pStart + strlen(pStart);</a>
<a name="ln4820">    } else {</a>
<a name="ln4821">        return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4822">    }</a>
<a name="ln4823">    while( pStart &lt; pEnd ) {</a>
<a name="ln4824">        /* cycle over components; rearrange Fixed H components in order of Mobile H components */</a>
<a name="ln4825">        /* if /o(1,2,3) then reaarange Fixed H components in this way: tmp&lt;-1, 1&lt;-2, 2&lt;-3, 3&lt;-tmp */</a>
<a name="ln4826">        if ( *pStart != '(' ) {</a>
<a name="ln4827">            ret = RI_ERR_SYNTAX;</a>
<a name="ln4828">            goto exit_function;</a>
<a name="ln4829">        }</a>
<a name="ln4830">        pPermStart = pStart + 1;</a>
<a name="ln4831">        memset( &amp;tmp, 0, sizeof(tmp) );  /* initialization 2006-03 */</a>
<a name="ln4832">        if ( !(pPermEnd   = strchr( pPermStart, ')' )) || pPermEnd == pPermStart ) {</a>
<a name="ln4833">            ret = RI_ERR_SYNTAX;</a>
<a name="ln4834">            goto exit_function;</a>
<a name="ln4835">        }</a>
<a name="ln4836">        </a>
<a name="ln4837">        if ( pPermStart &lt; pPermEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln4838">            /* check if compressed InChI */</a>
<a name="ln4839">            *pbAbc = isupper( UCINT *pPermStart)? 1 : 0;</a>
<a name="ln4840">        }</a>
<a name="ln4841">        base = (*pbAbc==1)? ALPHA_BASE : 10;</a>
<a name="ln4842"> </a>
<a name="ln4843">        /* permutation cycle */</a>
<a name="ln4844">        if ( *pbAbc == 1 ) {</a>
<a name="ln4845">            for ( p = pPermStart, iComponent2 = numTrans = 0; p &lt; pPermEnd; iComponent2 = iComponent1, p = q ) {</a>
<a name="ln4846">                /* get first atom number */</a>
<a name="ln4847">                if ( 0 &gt;= (iComponent1 = (int)inchi_strtol( p, &amp;q, base )) || iComponent1 &gt; nNumComponents ) {</a>
<a name="ln4848">                    ret = RI_ERR_SYNTAX;  /* syntax error */</a>
<a name="ln4849">                    goto exit_function;</a>
<a name="ln4850">                }</a>
<a name="ln4851">                if ( iComponent2 ) {</a>
<a name="ln4852">                    pInChI[iComponent2-1] = pInChI[iComponent1-1];</a>
<a name="ln4853">                    numTrans ++;</a>
<a name="ln4854">                } else {</a>
<a name="ln4855">                    tmp = pInChI[iComponent1-1]; /* on the 1st pass save Component1 */</a>
<a name="ln4856">                }</a>
<a name="ln4857">            }</a>
<a name="ln4858">        } else {</a>
<a name="ln4859">            for ( p = pPermStart, iComponent2 = numTrans = 0; p &lt; pPermEnd; iComponent2 = iComponent1, p = q + (*q==',') ) {</a>
<a name="ln4860">                /* get first atom number */</a>
<a name="ln4861">                if ( !isdigit( UCINT *p ) ) {</a>
<a name="ln4862">                    ret = RI_ERR_SYNTAX;</a>
<a name="ln4863">                    goto exit_function;</a>
<a name="ln4864">                }</a>
<a name="ln4865">                if ( !(iComponent1 = (int)inchi_strtol( p, &amp;q, 10 )) || iComponent1 &gt; nNumComponents ) {</a>
<a name="ln4866">                    ret = RI_ERR_SYNTAX;  /* syntax error */</a>
<a name="ln4867">                    goto exit_function;</a>
<a name="ln4868">                }</a>
<a name="ln4869">                if ( iComponent2 ) {</a>
<a name="ln4870">                    pInChI[iComponent2-1] = pInChI[iComponent1-1];</a>
<a name="ln4871">                    numTrans ++;</a>
<a name="ln4872">                } else {</a>
<a name="ln4873">                    tmp = pInChI[iComponent1-1]; /* on the 1st pass save Component1 */</a>
<a name="ln4874">                }</a>
<a name="ln4875">            }</a>
<a name="ln4876">        }</a>
<a name="ln4877">        pInChI[iComponent2-1] = tmp;</a>
<a name="ln4878">        if ( !numTrans || p != pPermEnd ) {</a>
<a name="ln4879">            ret = RI_ERR_SYNTAX;</a>
<a name="ln4880">            goto exit_function;</a>
<a name="ln4881">        } else {</a>
<a name="ln4882">            pStart = p+1;</a>
<a name="ln4883">        }</a>
<a name="ln4884">    }</a>
<a name="ln4885">    ret = 1;</a>
<a name="ln4886"> </a>
<a name="ln4887">exit_function:</a>
<a name="ln4888">    return ret;   </a>
<a name="ln4889"> </a>
<a name="ln4890">}</a>
<a name="ln4891">/****************************************************************************************/</a>
<a name="ln4892">int ParseSegmentIsoAtoms( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state, int *pbAbc )</a>
<a name="ln4893">{</a>
<a name="ln4894">    int i, mpy_component, val;</a>
<a name="ln4895">    int nNumComponents, iComponent, len, iAtom;</a>
<a name="ln4896">    AT_NUMB nAtom1;</a>
<a name="ln4897">    const char *p, *q, *t, *pStart, *pEnd, *r;</a>
<a name="ln4898">    int  ret=0;</a>
<a name="ln4899">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln4900">    INChI *pInChIFrom=NULL;</a>
<a name="ln4901">    INChI_IsotopicAtom **pIsotopicAtom = NULL;</a>
<a name="ln4902">    INChI_IsotopicAtom isoAtom;</a>
<a name="ln4903"> </a>
<a name="ln4904">    const char   mult_type[]       = &quot;mnMNe&quot;;</a>
<a name="ln4905">    const char   parity_type[]     = &quot;-+TDH&quot;;</a>
<a name="ln4906">    int    bIsoFrom, nCpyType = CPY_ISO_AT;</a>
<a name="ln4907">    int    base = 10;</a>
<a name="ln4908"> </a>
<a name="ln4909">    if ( str[0] != 'i' )</a>
<a name="ln4910">        return 0;</a>
<a name="ln4911"> </a>
<a name="ln4912">    pStart = str+1;</a>
<a name="ln4913">    iComponent = 0;</a>
<a name="ln4914">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln4915"> </a>
<a name="ln4916">    if ( !((bMobileH==TAUT_YES &amp;&amp; state == IST_MOBILE_H_ISO_ATOMS) ||</a>
<a name="ln4917">           (bMobileH==TAUT_NON &amp;&amp; state == IST_FIXED_H_ISO_ATOMS) ) ) {</a>
<a name="ln4918">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln4919">    }</a>
<a name="ln4920">    if ( !*pStart ) {</a>
<a name="ln4921">        return nNumComponents+1; /* no isotopic atoms */</a>
<a name="ln4922">    }</a>
<a name="ln4923"> </a>
<a name="ln4924">    while( 1 ) {</a>
<a name="ln4925">        /* cycle over components */</a>
<a name="ln4926">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln4927">            pEnd = pStart + strlen(pStart);</a>
<a name="ln4928">        }</a>
<a name="ln4929">        if ( (p = strchr(pStart, '*')) &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln4930">            mpy_component = (int)inchi_strtol( pStart, &amp;q, 10 );</a>
<a name="ln4931">            if ( p != q ) {</a>
<a name="ln4932">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4933">                goto exit_function;</a>
<a name="ln4934">            }</a>
<a name="ln4935">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln4936">            if ( iComponent + mpy_component &gt; nNumComponents ) {</a>
<a name="ln4937">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4938">                goto exit_function;</a>
<a name="ln4939">            }</a>
<a name="ln4940">#endif</a>
<a name="ln4941">            p ++; /* move to the 1st character of the component */</a>
<a name="ln4942">        } else</a>
<a name="ln4943">        if ( ((isdigit(*pStart) &amp;&amp;</a>
<a name="ln4944">             0 &lt; (val = (int)inchi_strtol( pStart, &amp;q, 10))) ||</a>
<a name="ln4945">             (q = pStart, val=1))&amp;&amp;</a>
<a name="ln4946">             (t=strchr(mult_type, *q)) &amp;&amp; q+1 == pEnd ) {</a>
<a name="ln4947">            /* process the abbreviation */</a>
<a name="ln4948">            ret = 0;</a>
<a name="ln4949">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln4950">            if ( iComponent + val &gt; nNumComponents ) {</a>
<a name="ln4951">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4952">                goto exit_function;</a>
<a name="ln4953">            }</a>
<a name="ln4954">#endif</a>
<a name="ln4955">            bIsoFrom   = 0;</a>
<a name="ln4956">            switch( bMobileH ) {</a>
<a name="ln4957">            case TAUT_YES:</a>
<a name="ln4958">                ret = RI_ERR_SYNTAX;</a>
<a name="ln4959">                break;</a>
<a name="ln4960">            case TAUT_NON:</a>
<a name="ln4961">                if ( *q == 'm' ) {</a>
<a name="ln4962">                    /* copy from mobile H to fixed H */</a>
<a name="ln4963">                    pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln4964">                } else</a>
<a name="ln4965">                if ( *q == 'e' ) {</a>
<a name="ln4966">                    /* copy from mobile H to isotopic mobile H */</a>
<a name="ln4967">                    pInChIFrom = pInChI;</a>
<a name="ln4968">                    bIsoFrom   = -1; /* empty */</a>
<a name="ln4969">                } else {</a>
<a name="ln4970">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln4971">                }</a>
<a name="ln4972">                break;</a>
<a name="ln4973">            default:</a>
<a name="ln4974">                ret = RI_ERR_SYNTAX; </a>
<a name="ln4975">                break;</a>
<a name="ln4976">            }</a>
<a name="ln4977">            if ( ret &lt; 0 ) {</a>
<a name="ln4978">                goto exit_function;</a>
<a name="ln4979">            }</a>
<a name="ln4980">            /* copy */</a>
<a name="ln4981">            for ( i = 0; i &lt; val; i ++ ) {</a>
<a name="ln4982">                ret = CopySegment( pInChI+iComponent+i, pInChIFrom+iComponent+i, nCpyType, 0, bIsoFrom );</a>
<a name="ln4983">                if ( !ret ) {</a>
<a name="ln4984">                    ret = RI_ERR_SYNTAX;</a>
<a name="ln4985">                }</a>
<a name="ln4986">                if ( ret &lt; 0 ) {</a>
<a name="ln4987">                    goto exit_function;</a>
<a name="ln4988">                }</a>
<a name="ln4989">            }</a>
<a name="ln4990">            iComponent += val;</a>
<a name="ln4991">            /* continue to the next component(s) */</a>
<a name="ln4992">            if ( *pEnd ) {</a>
<a name="ln4993">                pStart = pEnd+1;</a>
<a name="ln4994">                continue;</a>
<a name="ln4995">            } else {</a>
<a name="ln4996">                break;</a>
<a name="ln4997">            }</a>
<a name="ln4998">        } else {</a>
<a name="ln4999">            mpy_component = 1;</a>
<a name="ln5000">            p = pStart;</a>
<a name="ln5001">        }</a>
<a name="ln5002">        pStart = p;</a>
<a name="ln5003">        pIsotopicAtom = &amp;pInChI[iComponent].IsotopicAtom;</a>
<a name="ln5004">        if ( *pIsotopicAtom ) {</a>
<a name="ln5005">            ret = RI_ERR_PROGR; /* program error */</a>
<a name="ln5006">            goto exit_function;</a>
<a name="ln5007">        }</a>
<a name="ln5008"> </a>
<a name="ln5009">        if ( p &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln5010">            /* check if compressed InChI */</a>
<a name="ln5011">            *pbAbc = isupper( UCINT *p)? 1 : 0;</a>
<a name="ln5012">        }</a>
<a name="ln5013">        base = (*pbAbc==1)? ALPHA_BASE : 10;</a>
<a name="ln5014"> </a>
<a name="ln5015"> </a>
<a name="ln5016">one_more_time:</a>
<a name="ln5017">        if ( *pbAbc == 1 ) {</a>
<a name="ln5018">            /* process the componnt: At[+/-Charge]TDH,... */</a>
<a name="ln5019">            /* pass 1: find number of stereoatoms */</a>
<a name="ln5020">            for ( p = pStart, iAtom = 0; p &lt; pEnd; iAtom ++ ) {</a>
<a name="ln5021">                nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;p, base );</a>
<a name="ln5022">                if ( !nAtom1 ||</a>
<a name="ln5023">                     nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ) {</a>
<a name="ln5024">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5025">                    goto exit_function;</a>
<a name="ln5026">                }</a>
<a name="ln5027">                memset( &amp;isoAtom, 0, sizeof(isoAtom) );</a>
<a name="ln5028">                isoAtom.nAtomNumber = nAtom1;</a>
<a name="ln5029">                isoAtom.nIsoDifference = (NUM_H)inchi_strtol( p, &amp;q, 10 ); /* alway in abc */</a>
<a name="ln5030">                if ( p == q ) {</a>
<a name="ln5031">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5032">                    goto exit_function;</a>
<a name="ln5033">                }</a>
<a name="ln5034">                p = q;</a>
<a name="ln5035">                if ( *p == 't' ) {</a>
<a name="ln5036">                    isoAtom.nNum_T = 1;</a>
<a name="ln5037">                    p ++;</a>
<a name="ln5038">                    if ( isdigit( UCINT *p) ) {</a>
<a name="ln5039">                        isoAtom.nNum_T = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5040">                        p = q;</a>
<a name="ln5041">                    }</a>
<a name="ln5042">                }</a>
<a name="ln5043">                if ( *p == 'd' ) {</a>
<a name="ln5044">                    isoAtom.nNum_D = 1;</a>
<a name="ln5045">                    p ++;</a>
<a name="ln5046">                    if ( isdigit( UCINT *p) ) {</a>
<a name="ln5047">                        isoAtom.nNum_D = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5048">                        p = q;</a>
<a name="ln5049">                    }</a>
<a name="ln5050">                }</a>
<a name="ln5051">                if ( *p == 'h' ) {</a>
<a name="ln5052">                    isoAtom.nNum_H = 1;</a>
<a name="ln5053">                    p ++;</a>
<a name="ln5054">                    if ( isdigit( UCINT *p) ) {</a>
<a name="ln5055">                        isoAtom.nNum_H = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5056">                        p = q;</a>
<a name="ln5057">                    }</a>
<a name="ln5058">                }</a>
<a name="ln5059">                if ( p &gt; pEnd || (!isoAtom.nIsoDifference &amp;&amp; !isoAtom.nNum_T &amp;&amp; !isoAtom.nNum_D &amp;&amp; !isoAtom.nNum_H) ) {</a>
<a name="ln5060">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5061">                    goto exit_function;</a>
<a name="ln5062">                }</a>
<a name="ln5063">                if ( *pIsotopicAtom ) {</a>
<a name="ln5064">                    pIsotopicAtom[0][iAtom] = isoAtom;</a>
<a name="ln5065">                }</a>
<a name="ln5066">            }</a>
<a name="ln5067">        } else {</a>
<a name="ln5068">            /* process the componnt: At[+/-Charge]TDH,... */</a>
<a name="ln5069">            /* pass 1: find number of stereoatoms */</a>
<a name="ln5070">            for ( p = pStart, iAtom = 0; p &lt; pEnd; iAtom ++ ) {</a>
<a name="ln5071">                nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5072">                p = q;</a>
<a name="ln5073">                if ( !nAtom1 ||</a>
<a name="ln5074">                     nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ||</a>
<a name="ln5075">                     !(r = strchr( parity_type, *p) ) ) {</a>
<a name="ln5076">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5077">                    goto exit_function;</a>
<a name="ln5078">                }</a>
<a name="ln5079">                memset( &amp;isoAtom, 0, sizeof(isoAtom) );</a>
<a name="ln5080">                isoAtom.nAtomNumber = nAtom1;</a>
<a name="ln5081">                if ( p[0] == '+' &amp;&amp; isdigit( UCINT p[1]) ) {</a>
<a name="ln5082">                    isoAtom.nIsoDifference = (NUM_H)inchi_strtol( p+1, &amp;q, 10 );</a>
<a name="ln5083">                    if ( isoAtom.nIsoDifference &gt;= 0 ) isoAtom.nIsoDifference ++;</a>
<a name="ln5084">                    p = q;</a>
<a name="ln5085">                } else</a>
<a name="ln5086">                if ( p[0] == '-' &amp;&amp; isdigit( UCINT p[1]) ) {</a>
<a name="ln5087">                    isoAtom.nIsoDifference = -(NUM_H)inchi_strtol( p+1, &amp;q, 10 );</a>
<a name="ln5088">                    if ( isoAtom.nIsoDifference == 0 ) isoAtom.nIsoDifference ++;</a>
<a name="ln5089">                    p = q;</a>
<a name="ln5090">                }</a>
<a name="ln5091">                if ( *p == 'T' ) {</a>
<a name="ln5092">                    isoAtom.nNum_T = 1;</a>
<a name="ln5093">                    p ++;</a>
<a name="ln5094">                    if ( isdigit( UCINT *p) ) {</a>
<a name="ln5095">                        isoAtom.nNum_T = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5096">                        p = q;</a>
<a name="ln5097">                    }</a>
<a name="ln5098">                }</a>
<a name="ln5099">                if ( *p == 'D' ) {</a>
<a name="ln5100">                    isoAtom.nNum_D = 1;</a>
<a name="ln5101">                    p ++;</a>
<a name="ln5102">                    if ( isdigit( UCINT *p) ) {</a>
<a name="ln5103">                        isoAtom.nNum_D = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5104">                        p = q;</a>
<a name="ln5105">                    }</a>
<a name="ln5106">                }</a>
<a name="ln5107">                if ( *p == 'H' ) {</a>
<a name="ln5108">                    isoAtom.nNum_H = 1;</a>
<a name="ln5109">                    p ++;</a>
<a name="ln5110">                    if ( isdigit( UCINT *p) ) {</a>
<a name="ln5111">                        isoAtom.nNum_H = (NUM_H)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5112">                        p = q;</a>
<a name="ln5113">                    }</a>
<a name="ln5114">                }</a>
<a name="ln5115">                if ( !isoAtom.nIsoDifference &amp;&amp; !isoAtom.nNum_T &amp;&amp; !isoAtom.nNum_D &amp;&amp; !isoAtom.nNum_H ) {</a>
<a name="ln5116">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5117">                    goto exit_function;</a>
<a name="ln5118">                }</a>
<a name="ln5119">                if ( p &lt; pEnd ) {</a>
<a name="ln5120">                    if ( *p == ',' ) {</a>
<a name="ln5121">                        p ++;</a>
<a name="ln5122">                    } else {</a>
<a name="ln5123">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5124">                        goto exit_function;</a>
<a name="ln5125">                    }</a>
<a name="ln5126">                }</a>
<a name="ln5127">                if ( *pIsotopicAtom ) {</a>
<a name="ln5128">                    pIsotopicAtom[0][iAtom] = isoAtom;</a>
<a name="ln5129">                }</a>
<a name="ln5130">            }</a>
<a name="ln5131">        }</a>
<a name="ln5132">        if ( p != pEnd ) {</a>
<a name="ln5133">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5134">            goto exit_function;</a>
<a name="ln5135">        }</a>
<a name="ln5136"> </a>
<a name="ln5137">        if ( !*pIsotopicAtom ) {</a>
<a name="ln5138">            /* end of the 1st pass */</a>
<a name="ln5139">            len = iAtom;</a>
<a name="ln5140">            /* memory allocation */</a>
<a name="ln5141">            if ( !(*pIsotopicAtom = (INChI_IsotopicAtom *) inchi_calloc( len+1, sizeof(**pIsotopicAtom) ) ) ) {</a>
<a name="ln5142">                ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5143">                goto exit_function;</a>
<a name="ln5144">            }</a>
<a name="ln5145">            goto one_more_time; /* goto the 2nd pass */</a>
<a name="ln5146">        } else {</a>
<a name="ln5147">            /* 2nd pass */</a>
<a name="ln5148">            if ( len != iAtom ) {</a>
<a name="ln5149">                ret = RI_ERR_PROGR; /* program error */</a>
<a name="ln5150">                goto exit_function;</a>
<a name="ln5151">            }</a>
<a name="ln5152">            pInChI[iComponent].nNumberOfIsotopicAtoms = len;</a>
<a name="ln5153">        }</a>
<a name="ln5154"> </a>
<a name="ln5155">        /* multiplier */</a>
<a name="ln5156">        for ( i = 1; i &lt; mpy_component; i ++ ) {</a>
<a name="ln5157">            ret = CopySegment( pInChI+iComponent+i, pInChI+iComponent, nCpyType, 0, 0 );</a>
<a name="ln5158">            if ( !ret ) {</a>
<a name="ln5159">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5160">            }</a>
<a name="ln5161">            if ( ret &lt; 0 ) {</a>
<a name="ln5162">                goto exit_function;</a>
<a name="ln5163">            }</a>
<a name="ln5164">        }</a>
<a name="ln5165"> </a>
<a name="ln5166">        iComponent += mpy_component;</a>
<a name="ln5167">        if ( *pEnd ) {</a>
<a name="ln5168">            pStart = pEnd+1;</a>
<a name="ln5169">            continue;</a>
<a name="ln5170">        } else {</a>
<a name="ln5171">            break;</a>
<a name="ln5172">        }</a>
<a name="ln5173">    }</a>
<a name="ln5174">    if ( nNumComponents != iComponent ) {</a>
<a name="ln5175">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5176">        goto exit_function;</a>
<a name="ln5177">    }</a>
<a name="ln5178">    ret = iComponent + 1;</a>
<a name="ln5179"> </a>
<a name="ln5180">exit_function:</a>
<a name="ln5181">    return ret;   </a>
<a name="ln5182"> </a>
<a name="ln5183">}</a>
<a name="ln5184">/****************************************************************************************/</a>
<a name="ln5185">int ParseSegmentSp3s( const char *str, int bMobileH, INChI *pInpInChI[], int s[TAUT_NUM][2], int ppnNumComponents[], int state )</a>
<a name="ln5186">{</a>
<a name="ln5187">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln5188">    int nNumComponents, iComponent, val;</a>
<a name="ln5189">    const char *p, *q, *pStart, *pEnd;</a>
<a name="ln5190">    int  ret=0;</a>
<a name="ln5191">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln5192">    INChI_Stereo **pStereo = NULL;</a>
<a name="ln5193"> </a>
<a name="ln5194">    int   bIso = (state==IST_MOBILE_H_ISO_SP3_S || state==IST_FIXED_H_ISO_SP3_S);</a>
<a name="ln5195">    </a>
<a name="ln5196">    if ( !bIso &amp;&amp; state != IST_MOBILE_H_SP3_S &amp;&amp; state != IST_FIXED_H_SP3_S ) {</a>
<a name="ln5197">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln5198">    }</a>
<a name="ln5199"> </a>
<a name="ln5200">    if ( str[0] != 's' )</a>
<a name="ln5201">        return 0;</a>
<a name="ln5202"> </a>
<a name="ln5203">    pStart = str+1;</a>
<a name="ln5204">    iComponent = 0;</a>
<a name="ln5205">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln5206"> </a>
<a name="ln5207">    /*if ( !(pEnd = strchr( pStart, ';' )) )*/ /* 2007-09-25 DT */</a>
<a name="ln5208">    if ( !(pEnd = strchr( pStart, '/' )) ){</a>
<a name="ln5209">        pEnd = pStart + strlen(pStart);</a>
<a name="ln5210">    } else {</a>
<a name="ln5211">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5212">        goto exit_function;</a>
<a name="ln5213">    }</a>
<a name="ln5214">    p = pStart;</a>
<a name="ln5215">    if ( pEnd == pStart ) {</a>
<a name="ln5216">        /* create empty sp3 segment */</a>
<a name="ln5217">        int len = 0;</a>
<a name="ln5218">        s[bMobileH][bIso] = NO_VALUE_INT; /* empty */</a>
<a name="ln5219">        /* create empty sp3 segment */</a>
<a name="ln5220">        for ( iComponent = 0; iComponent &lt; nNumComponents; iComponent ++ ) {</a>
<a name="ln5221">            pStereo = bIso? &amp;pInChI[iComponent].StereoIsotopic : &amp;pInChI[iComponent].Stereo;</a>
<a name="ln5222">            if ( !*pStereo ) {</a>
<a name="ln5223">                if ( !(*pStereo = (INChI_Stereo *) inchi_calloc( 1, sizeof(**pStereo) ) ) ) {</a>
<a name="ln5224">                    ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5225">                    goto exit_function;</a>
<a name="ln5226">                }</a>
<a name="ln5227">            }</a>
<a name="ln5228">            pStereo[0]-&gt;nCompInv2Abs = 0;  /* deliberately empty */</a>
<a name="ln5229"> </a>
<a name="ln5230">            if ( pStereo[0]-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln5231">                ret = RI_ERR_SYNTAX; /* syntax error: &quot;/s&quot; without a digit describes &quot;no stereo&quot; */</a>
<a name="ln5232">                goto exit_function;</a>
<a name="ln5233">            }</a>
<a name="ln5234">            /* allocate empty sp3 stereo */</a>
<a name="ln5235">            if ( (!pStereo[0]-&gt;t_parity &amp;&amp;</a>
<a name="ln5236">                 !(pStereo[0]-&gt;t_parity = (S_CHAR *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;b_parity[0]) ) )) ||</a>
<a name="ln5237">                 (!pStereo[0]-&gt;nNumber &amp;&amp;</a>
<a name="ln5238">                 !(pStereo[0]-&gt;nNumber = (AT_NUMB *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;nNumber[0]) ) )) ) {</a>
<a name="ln5239">                /* cleanup */</a>
<a name="ln5240">                if ( pStereo[0]-&gt;t_parity ) {</a>
<a name="ln5241">                    INCHI_HEAPCHK</a>
<a name="ln5242">                    inchi_free( pStereo[0]-&gt;t_parity );</a>
<a name="ln5243">                    pStereo[0]-&gt;t_parity = NULL;</a>
<a name="ln5244">                }</a>
<a name="ln5245">                if ( pStereo[0]-&gt;nNumber ) {</a>
<a name="ln5246">                    INCHI_HEAPCHK</a>
<a name="ln5247">                    inchi_free( pStereo[0]-&gt;nNumber );</a>
<a name="ln5248">                    pStereo[0]-&gt;nNumber = NULL;</a>
<a name="ln5249">                }</a>
<a name="ln5250">                ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5251">                goto exit_function;</a>
<a name="ln5252">            }</a>
<a name="ln5253">        }</a>
<a name="ln5254">        ret = nNumComponents+1;</a>
<a name="ln5255">    } else {</a>
<a name="ln5256">        val = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5257">        if ( q == pEnd &amp;&amp; 1 &lt;= val &amp;&amp; val &lt;= 3 ) {</a>
<a name="ln5258">            s[bMobileH][bIso] = val;</a>
<a name="ln5259">            ret = nNumComponents+1;</a>
<a name="ln5260">        } else {</a>
<a name="ln5261">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5262">        }</a>
<a name="ln5263">    }</a>
<a name="ln5264">exit_function:</a>
<a name="ln5265">    return ret;</a>
<a name="ln5266">}</a>
<a name="ln5267">/****************************************************************************************/</a>
<a name="ln5268">int bIsSp3LayerNotEmpty( INChI *pInpInChI[], int bMobileH, int bIso, int nNumComponents )</a>
<a name="ln5269">{</a>
<a name="ln5270">    INChI        *pInChI;</a>
<a name="ln5271">    INChI_Stereo *pStereo;</a>
<a name="ln5272">    int           iComponent, num_not_empty = 0;</a>
<a name="ln5273"> </a>
<a name="ln5274">    if ( pInpInChI[bMobileH] ) {</a>
<a name="ln5275">        for ( iComponent = 0; iComponent &lt; nNumComponents; iComponent ++ ) {</a>
<a name="ln5276">            pInChI  = pInpInChI[bMobileH] + iComponent;</a>
<a name="ln5277">            if ( pInChI-&gt;bDeleted || !pInChI-&gt;nNumberOfAtoms ) {</a>
<a name="ln5278">                continue;</a>
<a name="ln5279">            }</a>
<a name="ln5280">            pStereo = bIso? pInChI-&gt;StereoIsotopic : pInChI-&gt;Stereo;</a>
<a name="ln5281">            if ( pStereo &amp;&amp; pStereo-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp; pStereo-&gt;nNumber &amp;&amp; pStereo-&gt;t_parity ) {</a>
<a name="ln5282">                num_not_empty ++;</a>
<a name="ln5283">            }</a>
<a name="ln5284">        }</a>
<a name="ln5285">    }</a>
<a name="ln5286">    return num_not_empty;</a>
<a name="ln5287">}</a>
<a name="ln5288">/****************************************************************************************/</a>
<a name="ln5289">int ParseSegmentSp3m( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state )</a>
<a name="ln5290">{</a>
<a name="ln5291">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln5292">    int nNumComponents, iComponent;</a>
<a name="ln5293">    const char *p, *pStart, *pEnd;</a>
<a name="ln5294">    int  ret=0;</a>
<a name="ln5295">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln5296">    INChI_Stereo **pStereo = NULL;</a>
<a name="ln5297"> </a>
<a name="ln5298">    int   bIso = (state==IST_MOBILE_H_ISO_SP3_M || state==IST_FIXED_H_ISO_SP3_M);</a>
<a name="ln5299">    </a>
<a name="ln5300">    if ( !bIso &amp;&amp; state != IST_MOBILE_H_SP3_M &amp;&amp; state != IST_FIXED_H_SP3_M ) {</a>
<a name="ln5301">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln5302">    }</a>
<a name="ln5303">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln5304"> </a>
<a name="ln5305">    if ( str[0] != 'm' ) {</a>
<a name="ln5306">        /* /m is missing: check whether we have to inherit /m from a preceding stereo layer */</a>
<a name="ln5307">        INChI_Stereo *pStereoFrom, *pStereoTo;</a>
<a name="ln5308">        INChI        *pInChIFrom;</a>
<a name="ln5309">        int          nNumCopied = 0, bMobileHFrom=-1, bIsoFrom=-1;</a>
<a name="ln5310">        if ( bMobileH &amp;&amp; !bIso ) {</a>
<a name="ln5311">            return 0; /* Main non-isotopic cannot inherit: it has no preceding layer */</a>
<a name="ln5312">        } else</a>
<a name="ln5313">        if ( !bMobileH &amp;&amp; !bIso ) {</a>
<a name="ln5314">            /* fixed-H non-isotopic (F) inherits from Mobile-H non-isotopic (M) */</a>
<a name="ln5315">            bMobileHFrom = TAUT_YES;</a>
<a name="ln5316">            bIsoFrom     = 0;</a>
<a name="ln5317">        } else</a>
<a name="ln5318">        if ( bMobileH &amp;&amp; bIso ) {</a>
<a name="ln5319">            /* Mobile-H isotopic (MI) inherits from Mobile-H non-isotopic (M) */</a>
<a name="ln5320">            bMobileHFrom = TAUT_YES;</a>
<a name="ln5321">            bIsoFrom     = 0;</a>
<a name="ln5322">        } else</a>
<a name="ln5323">        if ( !bMobileH &amp;&amp; bIso ) {</a>
<a name="ln5324">            /* Fixed-H isotopic (FI) inherits from Fixed-H non-isotopic (F) */</a>
<a name="ln5325">            bMobileHFrom = TAUT_NON;</a>
<a name="ln5326">            bIsoFrom     = 0;</a>
<a name="ln5327">            /* if Sp3 is empty in F as well as in M, then inherit from MI */</a>
<a name="ln5328">            if ( !bIsSp3LayerNotEmpty( pInpInChI, TAUT_NON, 0, ppnNumComponents[TAUT_NON /*bMobileH*/] ) /* F */ &amp;&amp;</a>
<a name="ln5329">                 !bIsSp3LayerNotEmpty( pInpInChI, TAUT_YES, 0, ppnNumComponents[TAUT_YES /*bMobileH*/] ) /* M */ ) {</a>
<a name="ln5330">                bMobileHFrom = TAUT_YES;</a>
<a name="ln5331">                bIsoFrom     = 1;</a>
<a name="ln5332">            }</a>
<a name="ln5333">        }</a>
<a name="ln5334">        if ( bMobileHFrom &lt; 0 || bIsoFrom &lt; 0 ) {</a>
<a name="ln5335">            return RI_ERR_PROGR;</a>
<a name="ln5336">        }</a>
<a name="ln5337">        if ( !bIsSp3LayerNotEmpty( pInpInChI, bMobileHFrom, bIsoFrom, ppnNumComponents[/*bMobileH*/ bMobileHFrom] ) ) {</a>
<a name="ln5338">            /* nothing to copy; check whether it should have inherited from a preceding layer */</a>
<a name="ln5339">            if ( (!bMobileHFrom &amp;&amp; bIsoFrom) || (bMobileHFrom &amp;&amp; !bIsoFrom) ) {</a>
<a name="ln5340">                /* MI or F inherit stereo from M */</a>
<a name="ln5341">                bMobileHFrom = TAUT_YES;</a>
<a name="ln5342">                bIsoFrom     = 0;</a>
<a name="ln5343">                if ( !bIsSp3LayerNotEmpty( pInpInChI, bMobileHFrom, bIsoFrom, ppnNumComponents[bMobileHFrom /*bMobileH*/] ) ) {</a>
<a name="ln5344">                    return 0;</a>
<a name="ln5345">                }</a>
<a name="ln5346">            } else {</a>
<a name="ln5347">                return 0;</a>
<a name="ln5348">            }</a>
<a name="ln5349">        }</a>
<a name="ln5350">        nNumComponents = inchi_min( ppnNumComponents[bMobileH], ppnNumComponents[bMobileHFrom] );</a>
<a name="ln5351">        for ( iComponent = 0; iComponent &lt; nNumComponents; iComponent ++ ) {</a>
<a name="ln5352">            pInChIFrom = pInpInChI[bMobileHFrom] + iComponent;</a>
<a name="ln5353">            pInChI     = pInpInChI[bMobileH]     + iComponent;</a>
<a name="ln5354">            if ( pInChIFrom-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; !pInChIFrom-&gt;bDeleted &amp;&amp;</a>
<a name="ln5355">                 pInChI-&gt;nNumberOfAtoms &gt; 0    &amp;&amp; !pInChI-&gt;bDeleted        ) {</a>
<a name="ln5356">                pStereoFrom = bIsoFrom? pInChIFrom-&gt;StereoIsotopic : pInChIFrom-&gt;Stereo;</a>
<a name="ln5357">                pStereoTo    = bIso?     pInChI-&gt;StereoIsotopic     : pInChI-&gt;Stereo;</a>
<a name="ln5358">                if ( pStereoFrom &amp;&amp; pStereoTo ) {</a>
<a name="ln5359">                    pStereoTo-&gt;nCompInv2Abs = pStereoFrom-&gt;nCompInv2Abs;</a>
<a name="ln5360">                    nNumCopied ++;</a>
<a name="ln5361">                }</a>
<a name="ln5362">            }</a>
<a name="ln5363">        }</a>
<a name="ln5364">        return 0; /* return value &gt; 0 means the non-/m segment has been processed here */</a>
<a name="ln5365">    }</a>
<a name="ln5366"> </a>
<a name="ln5367">    pStart = str+1;</a>
<a name="ln5368">    iComponent = 0;</a>
<a name="ln5369"> </a>
<a name="ln5370">    /*if ( !(pEnd = strchr( pStart, ';' )) )*/ /* 2007-09-25 DT */</a>
<a name="ln5371">    if ( !(pEnd = strchr( pStart, '/' )) ) {</a>
<a name="ln5372">        pEnd = pStart + strlen(pStart);</a>
<a name="ln5373">    } else {</a>
<a name="ln5374">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5375">        goto exit_function;</a>
<a name="ln5376">    }</a>
<a name="ln5377">    p = pStart;</a>
<a name="ln5378">    if ( pEnd == pStart ) {</a>
<a name="ln5379">        /* create empty sp3 segment */</a>
<a name="ln5380">        int len = 0;</a>
<a name="ln5381">        for ( iComponent = 0; iComponent &lt; nNumComponents; iComponent ++ ) {</a>
<a name="ln5382">            INChI *pIsoInChI = &amp;pInChI[iComponent];</a>
<a name="ln5383">            pStereo = bIso? &amp;pIsoInChI-&gt;StereoIsotopic : &amp;pIsoInChI-&gt;Stereo;</a>
<a name="ln5384">            if ( !*pStereo ) {</a>
<a name="ln5385">                if ( !(*pStereo = (INChI_Stereo *) inchi_calloc( 1, sizeof(**pStereo) ) ) ) {</a>
<a name="ln5386">                    ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5387">                    goto exit_function;</a>
<a name="ln5388">                }</a>
<a name="ln5389">            }</a>
<a name="ln5390">            pStereo[0]-&gt;nCompInv2Abs = NO_VALUE_INT;  /* deliberately empty */</a>
<a name="ln5391">#ifdef NEVER            </a>
<a name="ln5392">            if ( pStereo[0]-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln5393">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5394">                goto exit_function;</a>
<a name="ln5395">            }</a>
<a name="ln5396">#endif</a>
<a name="ln5397">            /* allocate empty sp3 stereo */</a>
<a name="ln5398">            if ( (!pStereo[0]-&gt;t_parity &amp;&amp;</a>
<a name="ln5399">                 !(pStereo[0]-&gt;t_parity = (S_CHAR *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;b_parity[0]) ) )) ||</a>
<a name="ln5400">                 (!pStereo[0]-&gt;nNumber &amp;&amp;</a>
<a name="ln5401">                 !(pStereo[0]-&gt;nNumber = (AT_NUMB *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;nNumber[0]) ) )) ) {</a>
<a name="ln5402">                /* cleanup */</a>
<a name="ln5403">                if ( pStereo[0]-&gt;t_parity ) {</a>
<a name="ln5404">                    INCHI_HEAPCHK</a>
<a name="ln5405">                    inchi_free( pStereo[0]-&gt;t_parity );</a>
<a name="ln5406">                    pStereo[0]-&gt;t_parity = NULL;</a>
<a name="ln5407">                }</a>
<a name="ln5408">                if ( pStereo[0]-&gt;nNumber ) {</a>
<a name="ln5409">                    INCHI_HEAPCHK</a>
<a name="ln5410">                    inchi_free( pStereo[0]-&gt;nNumber );</a>
<a name="ln5411">                    pStereo[0]-&gt;nNumber = NULL;</a>
<a name="ln5412">                }</a>
<a name="ln5413">                ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5414">                goto exit_function;</a>
<a name="ln5415">            }</a>
<a name="ln5416">        }</a>
<a name="ln5417">        ret = nNumComponents+1;</a>
<a name="ln5418">    } else {</a>
<a name="ln5419">        while( p &lt; pEnd &amp;&amp; iComponent &lt; nNumComponents ) {</a>
<a name="ln5420">            /* cycle over components */</a>
<a name="ln5421">            pStereo = bIso? &amp;pInChI[iComponent].StereoIsotopic : &amp;pInChI[iComponent].Stereo;</a>
<a name="ln5422">            if ( *p != '.' &amp;&amp; !*pStereo ) {</a>
<a name="ln5423">                if ( !(*pStereo = (INChI_Stereo *) inchi_calloc( 1, sizeof(**pStereo) ) ) ) {</a>
<a name="ln5424">                    ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5425">                    goto exit_function;</a>
<a name="ln5426">                }</a>
<a name="ln5427">            }</a>
<a name="ln5428">            switch( *p ) {</a>
<a name="ln5429">            case '1':</a>
<a name="ln5430">                pStereo[0]-&gt;nCompInv2Abs = -1;</a>
<a name="ln5431">                break;</a>
<a name="ln5432">            case '0':</a>
<a name="ln5433">                pStereo[0]-&gt;nCompInv2Abs = 1;</a>
<a name="ln5434">                break;</a>
<a name="ln5435">            case '.':</a>
<a name="ln5436">                if ( *pStereo ) {</a>
<a name="ln5437">                    pStereo[0]-&gt;nCompInv2Abs = 0;</a>
<a name="ln5438">                }</a>
<a name="ln5439">                break;</a>
<a name="ln5440">            default:</a>
<a name="ln5441">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5442">                goto exit_function;</a>
<a name="ln5443">            }</a>
<a name="ln5444">            iComponent ++;</a>
<a name="ln5445">            p ++;</a>
<a name="ln5446">        }</a>
<a name="ln5447">        if ( p != pEnd || iComponent != nNumComponents ) {</a>
<a name="ln5448">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5449">            goto exit_function;</a>
<a name="ln5450">        }</a>
<a name="ln5451">        ret = nNumComponents+1;</a>
<a name="ln5452">    }</a>
<a name="ln5453">exit_function:</a>
<a name="ln5454">    return ret;</a>
<a name="ln5455">}</a>
<a name="ln5456">/****************************************************************************************/</a>
<a name="ln5457">int ParseSegmentSp3( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state, int *pbAbc )</a>
<a name="ln5458">{</a>
<a name="ln5459">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln5460">    int i, mpy_component, val;</a>
<a name="ln5461">    int nNumComponents, iComponent, len, iAtom;</a>
<a name="ln5462">    AT_NUMB nAtom1;</a>
<a name="ln5463">    int     atomParity;</a>
<a name="ln5464">    const char *p, *q, *t, *pStart, *pEnd, *r;</a>
<a name="ln5465">    int  ret=0;</a>
<a name="ln5466">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln5467">    INChI *pInChIFrom=NULL;</a>
<a name="ln5468">    /*</a>
<a name="ln5469">    INChI_Stereo *Stereo = NULL;</a>
<a name="ln5470">    INChI_Stereo *StereoOther = NULL;</a>
<a name="ln5471">    */</a>
<a name="ln5472">    INChI_Stereo **pStereo = NULL;</a>
<a name="ln5473"> </a>
<a name="ln5474">    const char   mult_type[]   = &quot;mnMNe&quot;;</a>
<a name="ln5475">    const char   parity_type[] = &quot;-+u?&quot;;</a>
<a name="ln5476">    int   bIsoTo, bIsoFrom, nCpyType = CPY_SP3;</a>
<a name="ln5477">    int   bIso = (state==IST_MOBILE_H_ISO_SP3 || state==IST_FIXED_H_ISO_SP3);</a>
<a name="ln5478">    int   base = 10;</a>
<a name="ln5479">    </a>
<a name="ln5480">    if ( !bIso &amp;&amp; state != IST_MOBILE_H_SP3 &amp;&amp; state != IST_FIXED_H_SP3 ) {</a>
<a name="ln5481">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln5482">    }</a>
<a name="ln5483"> </a>
<a name="ln5484">    if ( str[0] != 't' )</a>
<a name="ln5485">        return 0;</a>
<a name="ln5486"> </a>
<a name="ln5487">    pStart = str+1;</a>
<a name="ln5488">    iComponent = 0;</a>
<a name="ln5489">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln5490"> </a>
<a name="ln5491">    if ( !*pStart ) {</a>
<a name="ln5492">        /* create empty sp3 segment */</a>
<a name="ln5493">        int len0 = 0;</a>
<a name="ln5494">        for ( iComponent = 0; iComponent &lt; nNumComponents; iComponent ++ ) {</a>
<a name="ln5495">            INChI *pIsoInChI = &amp;pInChI[iComponent];</a>
<a name="ln5496">            pStereo = bIso? &amp;pIsoInChI-&gt;StereoIsotopic : &amp;pIsoInChI-&gt;Stereo;</a>
<a name="ln5497">            if ( !*pStereo ) {</a>
<a name="ln5498">                if ( !(*pStereo = (INChI_Stereo *) inchi_calloc( 1, sizeof(**pStereo) ) ) ) {</a>
<a name="ln5499">                    ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5500">                    goto exit_function;</a>
<a name="ln5501">                }</a>
<a name="ln5502">            }</a>
<a name="ln5503">            /* allocate empty sp3 stereo */</a>
<a name="ln5504">            if ( (!pStereo[0]-&gt;b_parity &amp;&amp;</a>
<a name="ln5505">                 !(pStereo[0]-&gt;b_parity = (S_CHAR *)inchi_calloc( len0+1, sizeof(pStereo[0]-&gt;b_parity[0]) ) )) ||</a>
<a name="ln5506">                 (!pStereo[0]-&gt;nBondAtom1 &amp;&amp;</a>
<a name="ln5507">                 !(pStereo[0]-&gt;nBondAtom1 = (AT_NUMB *)inchi_calloc( len0+1, sizeof(pStereo[0]-&gt;nBondAtom1[0]) ) )) ||</a>
<a name="ln5508">                 (!pStereo[0]-&gt;nBondAtom2 &amp;&amp;</a>
<a name="ln5509">                 !(pStereo[0]-&gt;nBondAtom2 = (AT_NUMB *)inchi_calloc( len0+1, sizeof(pStereo[0]-&gt;nBondAtom2[0]) ) )) ) {</a>
<a name="ln5510">                /* cleanup */</a>
<a name="ln5511">                if ( pStereo[0]-&gt;b_parity ) {</a>
<a name="ln5512">                    INCHI_HEAPCHK</a>
<a name="ln5513">                    inchi_free( pStereo[0]-&gt;b_parity );</a>
<a name="ln5514">                    pStereo[0]-&gt;b_parity = NULL;</a>
<a name="ln5515">                }</a>
<a name="ln5516">                if ( pStereo[0]-&gt;nBondAtom1 ) {</a>
<a name="ln5517">                    INCHI_HEAPCHK</a>
<a name="ln5518">                    inchi_free( pStereo[0]-&gt;nBondAtom1 );</a>
<a name="ln5519">                    pStereo[0]-&gt;nBondAtom1 = NULL;</a>
<a name="ln5520">                }</a>
<a name="ln5521">                if ( pStereo[0]-&gt;nBondAtom2 ) {</a>
<a name="ln5522">                    INCHI_HEAPCHK</a>
<a name="ln5523">                    inchi_free( pStereo[0]-&gt;nBondAtom2 );</a>
<a name="ln5524">                    pStereo[0]-&gt;nBondAtom2 = NULL;</a>
<a name="ln5525">                }</a>
<a name="ln5526">                ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5527">                goto exit_function;</a>
<a name="ln5528">            }</a>
<a name="ln5529">            pStereo[0]-&gt;nCompInv2Abs = NO_VALUE_INT;</a>
<a name="ln5530">        }</a>
<a name="ln5531">        ret = nNumComponents+1;</a>
<a name="ln5532">        goto exit_function;</a>
<a name="ln5533">    }</a>
<a name="ln5534"> </a>
<a name="ln5535">    while( 1 ) {</a>
<a name="ln5536">        /* cycle over components */</a>
<a name="ln5537">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln5538">            pEnd = pStart + strlen(pStart);</a>
<a name="ln5539">        }</a>
<a name="ln5540">        if ( ((isdigit(*pStart) &amp;&amp;</a>
<a name="ln5541">             0 &lt; (val = (int)inchi_strtol( pStart, &amp;q, 10))) ||</a>
<a name="ln5542">             (q = pStart, val=1))&amp;&amp;</a>
<a name="ln5543">             (t=strchr(mult_type, *q)) &amp;&amp; q+1 == pEnd ) {</a>
<a name="ln5544">            /* process the abbreviation */</a>
<a name="ln5545">            ret = 0;</a>
<a name="ln5546">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln5547">        if ( iComponent + val &gt; nNumComponents ) {</a>
<a name="ln5548">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5549">            goto exit_function;</a>
<a name="ln5550">        }</a>
<a name="ln5551">#endif</a>
<a name="ln5552">            switch( bMobileH ) {</a>
<a name="ln5553">            case TAUT_YES:</a>
<a name="ln5554">                switch( state ) {</a>
<a name="ln5555">                case IST_MOBILE_H_ISO_SP3:</a>
<a name="ln5556">                    if ( *q == 'm' ) {</a>
<a name="ln5557">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5558">                        pInChIFrom = pInChI;</a>
<a name="ln5559">                        bIsoTo     = 1;</a>
<a name="ln5560">                        bIsoFrom   = 0;</a>
<a name="ln5561">                    } else</a>
<a name="ln5562">                    if ( *q == 'e' ) {</a>
<a name="ln5563">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5564">                        pInChIFrom = pInChI;</a>
<a name="ln5565">                        bIsoTo     = 1;</a>
<a name="ln5566">                        bIsoFrom   = -1; /* empty */</a>
<a name="ln5567">                    } else {</a>
<a name="ln5568">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5569">                    }</a>
<a name="ln5570">                    break;</a>
<a name="ln5571">                default:</a>
<a name="ln5572">                    ret = RI_ERR_SYNTAX; </a>
<a name="ln5573">                    break;</a>
<a name="ln5574">                }</a>
<a name="ln5575">                break;</a>
<a name="ln5576">            case TAUT_NON:</a>
<a name="ln5577">                switch( state ) {</a>
<a name="ln5578">                case IST_FIXED_H_SP3:</a>
<a name="ln5579">                    if ( *q == 'm' ) {</a>
<a name="ln5580">                        /* copy from mobile H to fixed H */</a>
<a name="ln5581">                        pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln5582">                        bIsoTo     = 0;</a>
<a name="ln5583">                        bIsoFrom   = 0;</a>
<a name="ln5584">                    } else</a>
<a name="ln5585">                    if ( *q == 'e' ) {</a>
<a name="ln5586">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5587">                        pInChIFrom = pInChI;</a>
<a name="ln5588">                        bIsoTo     = 1;</a>
<a name="ln5589">                        bIsoFrom   = -1; /* empty */</a>
<a name="ln5590">                    } else {</a>
<a name="ln5591">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5592">                    }</a>
<a name="ln5593">                    break;</a>
<a name="ln5594">                case IST_FIXED_H_ISO_SP3:</a>
<a name="ln5595">                    if ( *q == 'm' ) {</a>
<a name="ln5596">                        /* copy from mobile H to fixed isotopic H */</a>
<a name="ln5597">                        pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln5598">                        bIsoTo     = 1;</a>
<a name="ln5599">                        bIsoFrom   = 0;</a>
<a name="ln5600">                    } else</a>
<a name="ln5601">                    if ( *q == 'M' ) {</a>
<a name="ln5602">                        /* copy from isotopic mobile H to fixed isotopic H */</a>
<a name="ln5603">                        pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln5604">                        bIsoTo     = 1;</a>
<a name="ln5605">                        bIsoFrom   = 1;</a>
<a name="ln5606">                    } else</a>
<a name="ln5607">                    if ( *q == 'n' ) {</a>
<a name="ln5608">                        /* copy from fixed H to fixed isotopic H */</a>
<a name="ln5609">                        pInChIFrom = pInChI;</a>
<a name="ln5610">                        bIsoTo     = 1;</a>
<a name="ln5611">                        bIsoFrom   = 0;</a>
<a name="ln5612">                    } else</a>
<a name="ln5613">                    if ( *q == 'e' ) {</a>
<a name="ln5614">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5615">                        pInChIFrom = pInChI;</a>
<a name="ln5616">                        bIsoTo     = 1;</a>
<a name="ln5617">                        bIsoFrom   = -1; /* empty */</a>
<a name="ln5618">                    } else {</a>
<a name="ln5619">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5620">                    }</a>
<a name="ln5621">                    break;</a>
<a name="ln5622">                default:</a>
<a name="ln5623">                    ret = RI_ERR_SYNTAX; </a>
<a name="ln5624">                    break;</a>
<a name="ln5625">                }</a>
<a name="ln5626">                break;</a>
<a name="ln5627"> </a>
<a name="ln5628">            default:</a>
<a name="ln5629">                ret = RI_ERR_SYNTAX; </a>
<a name="ln5630">                break;</a>
<a name="ln5631"> </a>
<a name="ln5632">            }</a>
<a name="ln5633">            if ( ret &lt; 0 ) {</a>
<a name="ln5634">                goto exit_function;</a>
<a name="ln5635">            }</a>
<a name="ln5636">            /* copy */</a>
<a name="ln5637">            for ( i = 0; i &lt; val; i ++ ) {</a>
<a name="ln5638">                ret = CopySegment( pInChI+iComponent+i, pInChIFrom+iComponent+i, nCpyType, bIsoTo, bIsoFrom );</a>
<a name="ln5639">                if ( !ret ) {</a>
<a name="ln5640">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5641">                }</a>
<a name="ln5642">                if ( ret &lt; 0 ) {</a>
<a name="ln5643">                    goto exit_function;</a>
<a name="ln5644">                }</a>
<a name="ln5645">                if ( bIsoFrom &gt;= 0 ) {</a>
<a name="ln5646">                    INChI_Stereo *pStereoTo = bIsoTo? pInChI[iComponent+i].StereoIsotopic : pInChI[iComponent+i].Stereo;</a>
<a name="ln5647">                    if ( pStereoTo ) {</a>
<a name="ln5648">                        pStereoTo-&gt;nCompInv2Abs = NO_VALUE_INT; /* in case there in no /m segment after this */</a>
<a name="ln5649">                    }</a>
<a name="ln5650">                }</a>
<a name="ln5651">            }</a>
<a name="ln5652">            </a>
<a name="ln5653">            mpy_component = val;</a>
<a name="ln5654">            goto end_main_cycle;</a>
<a name="ln5655"> </a>
<a name="ln5656">        } else</a>
<a name="ln5657">        /* regular multiplier */</a>
<a name="ln5658">        if ( (p = strchr(pStart, '*')) &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln5659">            mpy_component = (int)inchi_strtol( pStart, &amp;q, 10 );</a>
<a name="ln5660">            if ( p != q ) {</a>
<a name="ln5661">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5662">                goto exit_function;</a>
<a name="ln5663">            }</a>
<a name="ln5664">            p ++; /* move to the 1st character of the component */</a>
<a name="ln5665">        } else {</a>
<a name="ln5666">            mpy_component = 1;</a>
<a name="ln5667">            p = pStart;</a>
<a name="ln5668">        }</a>
<a name="ln5669">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln5670">        if ( iComponent + mpy_component &gt; nNumComponents ) {</a>
<a name="ln5671">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5672">            goto exit_function;</a>
<a name="ln5673">        }</a>
<a name="ln5674">#endif</a>
<a name="ln5675">        pStart = p;</a>
<a name="ln5676">        if ( p &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln5677">            /* check if compressed InChI */</a>
<a name="ln5678">            *pbAbc = isupper( UCINT *p)? 1 : 0;</a>
<a name="ln5679">        }</a>
<a name="ln5680">        base = (*pbAbc==1)? ALPHA_BASE : 10;</a>
<a name="ln5681">        /* process the componnt: at1p,at1p,... */</a>
<a name="ln5682">        /* pass 1: find number of stereoatoms */</a>
<a name="ln5683">        if ( *pbAbc == 1 ) {</a>
<a name="ln5684">            for ( p = pStart, iAtom = 0; p &lt; pEnd; iAtom ++ ) {</a>
<a name="ln5685">                if ( (nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;p, base ) ) &amp;&amp;</a>
<a name="ln5686">                      (atomParity = (int)inchi_strtol( p, &amp;p, 10),</a>
<a name="ln5687">                      AB_MIN_KNOWN_PARITY &lt;= atomParity &amp;&amp; atomParity &lt;= AB_MAX_KNOWN_PARITY) ) {</a>
<a name="ln5688">                    ; /* okay */</a>
<a name="ln5689">                } else {</a>
<a name="ln5690">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5691">                    goto exit_function;</a>
<a name="ln5692">                }</a>
<a name="ln5693">                if ( nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ) {</a>
<a name="ln5694">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5695">                    goto exit_function;</a>
<a name="ln5696">                }</a>
<a name="ln5697">            }</a>
<a name="ln5698">        } else {</a>
<a name="ln5699">            for ( p = pStart, iAtom = 0; p &lt; pEnd; iAtom ++, p += (*p == ',') ) {</a>
<a name="ln5700">                nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5701">                p = q+1;</a>
<a name="ln5702">                if ( !nAtom1 ||</a>
<a name="ln5703">                     nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ||</a>
<a name="ln5704">                     !(r = strchr( parity_type, *q) ) ) {</a>
<a name="ln5705">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5706">                    goto exit_function;</a>
<a name="ln5707">                }</a>
<a name="ln5708">            }</a>
<a name="ln5709">        }</a>
<a name="ln5710">        if ( p != pEnd ) {</a>
<a name="ln5711">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5712">            goto exit_function;</a>
<a name="ln5713">        }</a>
<a name="ln5714">        len = iAtom;</a>
<a name="ln5715"> </a>
<a name="ln5716">        /* memory allocation */</a>
<a name="ln5717"> </a>
<a name="ln5718">        pStereo = bIso? &amp;pInChI[iComponent].StereoIsotopic : &amp;pInChI[iComponent].Stereo;</a>
<a name="ln5719"> </a>
<a name="ln5720">        if ( !*pStereo ) {</a>
<a name="ln5721">            if ( !(*pStereo = (INChI_Stereo *) inchi_calloc( 1, sizeof(**pStereo) ) ) ) {</a>
<a name="ln5722">                ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5723">                goto exit_function;</a>
<a name="ln5724">            }</a>
<a name="ln5725">        }</a>
<a name="ln5726">        if ( pStereo[0]-&gt;t_parity || pStereo[0]-&gt;nNumberOfStereoCenters ||</a>
<a name="ln5727">             pStereo[0]-&gt;nNumber ) {</a>
<a name="ln5728">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5729">            goto exit_function;</a>
<a name="ln5730">        }</a>
<a name="ln5731">        /* allocate sp3 stereo */</a>
<a name="ln5732">        if ( !(pStereo[0]-&gt;t_parity = (S_CHAR *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;b_parity[0]) ) ) ||</a>
<a name="ln5733">             !(pStereo[0]-&gt;nNumber = (AT_NUMB *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;nNumber[0]) ) ) ) {</a>
<a name="ln5734">            /* cleanup */</a>
<a name="ln5735">            if ( pStereo[0]-&gt;t_parity ) {</a>
<a name="ln5736">                INCHI_HEAPCHK</a>
<a name="ln5737">                inchi_free( pStereo[0]-&gt;t_parity );</a>
<a name="ln5738">                pStereo[0]-&gt;t_parity = NULL;</a>
<a name="ln5739">            }</a>
<a name="ln5740">            if ( pStereo[0]-&gt;nNumber ) {</a>
<a name="ln5741">                INCHI_HEAPCHK</a>
<a name="ln5742">                inchi_free( pStereo[0]-&gt;nNumber );</a>
<a name="ln5743">                pStereo[0]-&gt;nNumber = NULL;</a>
<a name="ln5744">            }</a>
<a name="ln5745">            ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln5746">            goto exit_function;</a>
<a name="ln5747">        }</a>
<a name="ln5748"> </a>
<a name="ln5749">        /* pass 2: store stereocenters */</a>
<a name="ln5750">        if ( *pbAbc == 1 ) {</a>
<a name="ln5751">            for ( p = pStart, iAtom = 0; p &lt; pEnd; iAtom ++ ) {</a>
<a name="ln5752">                if ( (nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;p, base ) ) &amp;&amp;</a>
<a name="ln5753">                      (atomParity = (int)inchi_strtol( p, &amp;p, 10),</a>
<a name="ln5754">                      AB_MIN_KNOWN_PARITY &lt;= atomParity &amp;&amp; atomParity &lt;= AB_MAX_KNOWN_PARITY) ) {</a>
<a name="ln5755">                    ; /* okay */</a>
<a name="ln5756">                } else {</a>
<a name="ln5757">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5758">                    goto exit_function;</a>
<a name="ln5759">                }</a>
<a name="ln5760">                if ( nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ) {</a>
<a name="ln5761">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5762">                    goto exit_function;</a>
<a name="ln5763">                }</a>
<a name="ln5764">                pStereo[0]-&gt;t_parity[iAtom] = atomParity;</a>
<a name="ln5765">                pStereo[0]-&gt;nNumber[iAtom] = nAtom1;</a>
<a name="ln5766">                if ( iAtom &amp;&amp; !(pStereo[0]-&gt;nNumber[iAtom-1] &lt; nAtom1) ) {</a>
<a name="ln5767">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5768">                    goto exit_function;</a>
<a name="ln5769">                }</a>
<a name="ln5770">            }</a>
<a name="ln5771">        } else {</a>
<a name="ln5772">            for ( p = pStart, iAtom = 0; p &lt; pEnd; iAtom ++, p += (*p==',') ) {</a>
<a name="ln5773">                nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln5774">                if ( !(r = strchr( parity_type, *q) ) ) {</a>
<a name="ln5775">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5776">                    goto exit_function;</a>
<a name="ln5777">                }</a>
<a name="ln5778">                p = q+1;</a>
<a name="ln5779">                atomParity = (r - parity_type) + 1;</a>
<a name="ln5780">                pStereo[0]-&gt;t_parity[iAtom] = atomParity;</a>
<a name="ln5781">                pStereo[0]-&gt;nNumber[iAtom] = nAtom1;</a>
<a name="ln5782">                if ( iAtom &amp;&amp; !(pStereo[0]-&gt;nNumber[iAtom-1] &lt; nAtom1) ) {</a>
<a name="ln5783">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5784">                    goto exit_function;</a>
<a name="ln5785">                }</a>
<a name="ln5786">            }</a>
<a name="ln5787">        }</a>
<a name="ln5788">        pStereo[0]-&gt;nNumberOfStereoCenters = iAtom;</a>
<a name="ln5789">        /*if ( iAtom ) {*/</a>
<a name="ln5790">            pStereo[0]-&gt;nCompInv2Abs = NO_VALUE_INT; /* unknown yet */</a>
<a name="ln5791">        /*}*/</a>
<a name="ln5792"> </a>
<a name="ln5793">        if ( p != pEnd ) {</a>
<a name="ln5794">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5795">            goto exit_function;</a>
<a name="ln5796">        }</a>
<a name="ln5797"> </a>
<a name="ln5798">        /* multiplier */</a>
<a name="ln5799">        for ( i = 1; i &lt; mpy_component; i ++ ) {</a>
<a name="ln5800">            ret = CopySegment( pInChI+iComponent+i, pInChI+iComponent, nCpyType, bIso, bIso );</a>
<a name="ln5801">            if ( !ret ) {</a>
<a name="ln5802">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5803">            }</a>
<a name="ln5804">            if ( ret &lt; 0 ) {</a>
<a name="ln5805">                goto exit_function;</a>
<a name="ln5806">            }</a>
<a name="ln5807">            ret = CopySegment( pInChI+iComponent+i, pInChI+iComponent, CPY_SP3_M, bIso, bIso );</a>
<a name="ln5808">            if ( !ret ) {</a>
<a name="ln5809">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5810">            }</a>
<a name="ln5811">            if ( ret &lt; 0 ) {</a>
<a name="ln5812">                goto exit_function;</a>
<a name="ln5813">            }</a>
<a name="ln5814">        }</a>
<a name="ln5815"> </a>
<a name="ln5816">end_main_cycle:</a>
<a name="ln5817">        iComponent += mpy_component;</a>
<a name="ln5818">        if ( *pEnd ) {</a>
<a name="ln5819">            pStart = pEnd+1;</a>
<a name="ln5820">            continue;</a>
<a name="ln5821">        } else {</a>
<a name="ln5822">            break;</a>
<a name="ln5823">        }</a>
<a name="ln5824">    }</a>
<a name="ln5825">    if ( nNumComponents != iComponent ) {</a>
<a name="ln5826">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5827">        goto exit_function;</a>
<a name="ln5828">    }</a>
<a name="ln5829">    ret = iComponent + 1;</a>
<a name="ln5830"> </a>
<a name="ln5831">exit_function:</a>
<a name="ln5832">    return ret;   </a>
<a name="ln5833"> </a>
<a name="ln5834">}</a>
<a name="ln5835">/****************************************************************************************/</a>
<a name="ln5836">int ParseSegmentSp2( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[], int state, int *pbAbc )</a>
<a name="ln5837">{</a>
<a name="ln5838">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln5839">    int i, mpy_component, val;</a>
<a name="ln5840">    int nNumComponents, iComponent, len, iBond;</a>
<a name="ln5841">    AT_NUMB nAtom1, nAtom2;</a>
<a name="ln5842">    int     bondParity;</a>
<a name="ln5843">    const char *p, *q, *t, *pStart, *pEnd, *r;</a>
<a name="ln5844">    int  ret=0;</a>
<a name="ln5845">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln5846">    INChI *pInChIFrom=NULL;</a>
<a name="ln5847">    /*</a>
<a name="ln5848">    INChI_Stereo *Stereo = NULL;</a>
<a name="ln5849">    INChI_Stereo *StereoOther = NULL;</a>
<a name="ln5850">    */</a>
<a name="ln5851">    INChI_Stereo **pStereo = NULL;</a>
<a name="ln5852"> </a>
<a name="ln5853">    const char   mult_type[]   = &quot;mnMNe&quot;;</a>
<a name="ln5854">    const char   parity_type[] = &quot;-+u?&quot;;</a>
<a name="ln5855">    int   bIsoTo, bIsoFrom, nCpyType = CPY_SP2;</a>
<a name="ln5856">    int   bIso = (state==IST_MOBILE_H_ISO_SP2 || state==IST_FIXED_H_ISO_SP2);</a>
<a name="ln5857">    int   base = 10;</a>
<a name="ln5858"> </a>
<a name="ln5859">    if ( !bIso &amp;&amp; state != IST_MOBILE_H_SP2 &amp;&amp; state != IST_FIXED_H_SP2 ) {</a>
<a name="ln5860">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln5861">    }</a>
<a name="ln5862">    </a>
<a name="ln5863">    if ( str[0] != 'b' )</a>
<a name="ln5864">        return 0;</a>
<a name="ln5865"> </a>
<a name="ln5866">    pStart = str+1;</a>
<a name="ln5867">    iComponent = 0;</a>
<a name="ln5868">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln5869"> </a>
<a name="ln5870">    if ( !*pStart ) {</a>
<a name="ln5871">        /* creaste empty sp3 segment which means no sp3  */</a>
<a name="ln5872">        for ( iComponent = 0; iComponent &lt; nNumComponents; iComponent ++ ) {</a>
<a name="ln5873">            INChI *pIsoInChI = &amp;pInChI[iComponent];</a>
<a name="ln5874">            pStereo = bIso? &amp;pIsoInChI-&gt;StereoIsotopic : &amp;pIsoInChI-&gt;Stereo;</a>
<a name="ln5875">            if ( *pStereo &amp;&amp; (pStereo[0]-&gt;b_parity || pStereo[0]-&gt;nNumberOfStereoBonds ||</a>
<a name="ln5876">                 pStereo[0]-&gt;nBondAtom1 || pStereo[0]-&gt;nBondAtom2 ) ) {</a>
<a name="ln5877">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5878">                goto exit_function;</a>
<a name="ln5879">            }</a>
<a name="ln5880">            /* allocate empty sp3 stereo */</a>
<a name="ln5881">            ret = CopySegment( pIsoInChI, NULL, CPY_SP2, bIso, -1);</a>
<a name="ln5882">            if ( ret &lt; 0 ) {</a>
<a name="ln5883">                goto exit_function;</a>
<a name="ln5884">            }</a>
<a name="ln5885">        }</a>
<a name="ln5886">        ret = nNumComponents+1;</a>
<a name="ln5887">        goto exit_function;</a>
<a name="ln5888">    }</a>
<a name="ln5889"> </a>
<a name="ln5890">    while( 1 ) {</a>
<a name="ln5891">        </a>
<a name="ln5892">        /* cycle over components */</a>
<a name="ln5893">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln5894">            pEnd = pStart + strlen(pStart);</a>
<a name="ln5895">        }</a>
<a name="ln5896"> </a>
<a name="ln5897">        if ( ((isdigit(*pStart) &amp;&amp;</a>
<a name="ln5898">             0 &lt; (val = (int)inchi_strtol( pStart, &amp;q, 10))) ||</a>
<a name="ln5899">             (q = pStart, val=1))&amp;&amp;</a>
<a name="ln5900">             (t=strchr(mult_type, *q)) &amp;&amp; q+1 == pEnd ) {</a>
<a name="ln5901">            /* process the abbreviation */</a>
<a name="ln5902">            ret = 0;</a>
<a name="ln5903">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln5904">            if ( iComponent + val &gt; nNumComponents ) {</a>
<a name="ln5905">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5906">                goto exit_function;</a>
<a name="ln5907">            }</a>
<a name="ln5908">#endif</a>
<a name="ln5909">            switch( bMobileH ) {</a>
<a name="ln5910">            case TAUT_YES:</a>
<a name="ln5911">                switch( state ) {</a>
<a name="ln5912">                case IST_MOBILE_H_ISO_SP2:</a>
<a name="ln5913">                    if ( *q == 'm' ) {</a>
<a name="ln5914">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5915">                        pInChIFrom = pInChI;</a>
<a name="ln5916">                        bIsoTo     = 1;</a>
<a name="ln5917">                        bIsoFrom   = 0;</a>
<a name="ln5918">                    } else</a>
<a name="ln5919">                    if ( *q == 'e' ) {</a>
<a name="ln5920">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5921">                        pInChIFrom = pInChI;</a>
<a name="ln5922">                        bIsoTo     = 1;</a>
<a name="ln5923">                        bIsoFrom   = -1; /* empty */</a>
<a name="ln5924">                    } else {</a>
<a name="ln5925">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5926">                    }</a>
<a name="ln5927">                    break;</a>
<a name="ln5928">                default:</a>
<a name="ln5929">                    ret = RI_ERR_SYNTAX; </a>
<a name="ln5930">                    break;</a>
<a name="ln5931">                }</a>
<a name="ln5932">                break;</a>
<a name="ln5933">            case TAUT_NON:</a>
<a name="ln5934">                switch( state ) {</a>
<a name="ln5935">                case IST_FIXED_H_SP2:</a>
<a name="ln5936">                    if ( *q == 'm' ) {</a>
<a name="ln5937">                        /* copy from mobile H to fixed H */</a>
<a name="ln5938">                        pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln5939">                        bIsoTo     = 0;</a>
<a name="ln5940">                        bIsoFrom   = 0;</a>
<a name="ln5941">                    } else {</a>
<a name="ln5942">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5943">                    }</a>
<a name="ln5944">                    break;</a>
<a name="ln5945">                case IST_FIXED_H_ISO_SP2:</a>
<a name="ln5946">                    if ( *q == 'm' ) {</a>
<a name="ln5947">                        /* copy from mobile H to fixed isotopic H */</a>
<a name="ln5948">                        pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln5949">                        bIsoTo     = 1;</a>
<a name="ln5950">                        bIsoFrom   = 0;</a>
<a name="ln5951">                    } else</a>
<a name="ln5952">                    if ( *q == 'M' ) {</a>
<a name="ln5953">                        /* copy from isotopic mobile H to fixed isotopic H */</a>
<a name="ln5954">                        pInChIFrom = pInpInChI[ALT_TAUT(bMobileH)];</a>
<a name="ln5955">                        bIsoTo     = 1;</a>
<a name="ln5956">                        bIsoFrom   = 1;</a>
<a name="ln5957">                    } else</a>
<a name="ln5958">                    if ( *q == 'n' ) {</a>
<a name="ln5959">                        /* copy from fixed H to fixed isotopic H */</a>
<a name="ln5960">                        pInChIFrom = pInChI;</a>
<a name="ln5961">                        bIsoTo     = 1;</a>
<a name="ln5962">                        bIsoFrom   = 0;</a>
<a name="ln5963">                    } else</a>
<a name="ln5964">                    if ( *q == 'e' ) {</a>
<a name="ln5965">                        /* copy from mobile H to isotopic mobile H */</a>
<a name="ln5966">                        pInChIFrom = pInChI;</a>
<a name="ln5967">                        bIsoTo     = 1;</a>
<a name="ln5968">                        bIsoFrom   = -1; /* empty */</a>
<a name="ln5969">                    } else {</a>
<a name="ln5970">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5971">                    }</a>
<a name="ln5972">                    break;</a>
<a name="ln5973">                default:</a>
<a name="ln5974">                    ret = RI_ERR_SYNTAX; </a>
<a name="ln5975">                    break;</a>
<a name="ln5976">                }</a>
<a name="ln5977">                break;</a>
<a name="ln5978"> </a>
<a name="ln5979">            default:</a>
<a name="ln5980">                ret = RI_ERR_SYNTAX; </a>
<a name="ln5981">                break;</a>
<a name="ln5982"> </a>
<a name="ln5983">            }</a>
<a name="ln5984">            if ( ret &lt; 0 ) {</a>
<a name="ln5985">                goto exit_function;</a>
<a name="ln5986">            }</a>
<a name="ln5987">            /* copy */</a>
<a name="ln5988">            for ( i = 0; i &lt; val; i ++ ) {</a>
<a name="ln5989">                ret = CopySegment( pInChI+iComponent+i, pInChIFrom+iComponent+i, nCpyType, bIsoTo, bIsoFrom );</a>
<a name="ln5990">                if ( !ret ) {</a>
<a name="ln5991">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln5992">                }</a>
<a name="ln5993">                if ( ret &lt; 0 ) {</a>
<a name="ln5994">                    goto exit_function;</a>
<a name="ln5995">                }</a>
<a name="ln5996">            }</a>
<a name="ln5997">            mpy_component = val;</a>
<a name="ln5998">            goto end_main_cycle;</a>
<a name="ln5999"> </a>
<a name="ln6000">        } else</a>
<a name="ln6001">        /* regular multiplier */</a>
<a name="ln6002">        if ( (p = strchr(pStart, '*')) &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln6003">            mpy_component = (int)inchi_strtol( pStart, &amp;q, 10 );</a>
<a name="ln6004">            if ( p != q ) {</a>
<a name="ln6005">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6006">                goto exit_function;</a>
<a name="ln6007">            }</a>
<a name="ln6008"> </a>
<a name="ln6009">            p ++; /* move to the 1st character of the component */</a>
<a name="ln6010">        } else {</a>
<a name="ln6011">            mpy_component = 1;</a>
<a name="ln6012">            p = pStart;</a>
<a name="ln6013">        }</a>
<a name="ln6014">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln6015">        if ( iComponent + mpy_component &gt; nNumComponents ) {</a>
<a name="ln6016">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6017">            goto exit_function;</a>
<a name="ln6018">        }</a>
<a name="ln6019">#endif</a>
<a name="ln6020">        pStart = p;</a>
<a name="ln6021">        if ( p &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln6022">            /* check if compressed InChI */</a>
<a name="ln6023">            *pbAbc = isupper( UCINT *p)? 1 : 0;</a>
<a name="ln6024">        }</a>
<a name="ln6025">        base = (*pbAbc==1)? ALPHA_BASE : 10;</a>
<a name="ln6026">        if ( *pbAbc == 1 ) {</a>
<a name="ln6027">            /* process the componnt: at1-at2p,at1-at2p,... */</a>
<a name="ln6028">            /* pass 1: find number of stereobonds */</a>
<a name="ln6029">            for ( p = pStart, iBond = 0; p &lt; pEnd; iBond ++ ) {</a>
<a name="ln6030">                /* atoms 1, 2, and parity */</a>
<a name="ln6031">                if ( (nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;p, base ) ) &amp;&amp;</a>
<a name="ln6032">                      (nAtom2 = (AT_NUMB)inchi_strtol( p, &amp;p, base ) ) &amp;&amp;</a>
<a name="ln6033">                      (bondParity = (int)inchi_strtol( p, &amp;p, 10),</a>
<a name="ln6034">                      AB_MIN_KNOWN_PARITY &lt;= bondParity &amp;&amp; bondParity &lt;= AB_MAX_KNOWN_PARITY) ) {</a>
<a name="ln6035">                    ; /* okay */</a>
<a name="ln6036">                } else {</a>
<a name="ln6037">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6038">                    goto exit_function;</a>
<a name="ln6039">                }</a>
<a name="ln6040">                if ( nAtom1 &lt;= nAtom2   ||</a>
<a name="ln6041">                     nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ) {</a>
<a name="ln6042">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6043">                    goto exit_function;</a>
<a name="ln6044">                }</a>
<a name="ln6045">            }</a>
<a name="ln6046">        } else {</a>
<a name="ln6047">            /* process the componnt: at1-at2p,at1-at2p,... */</a>
<a name="ln6048">            /* pass 1: find number of stereobonds */</a>
<a name="ln6049">            for ( p = pStart, iBond = 0; p &lt; pEnd; iBond ++, p += (*p==',') ) {</a>
<a name="ln6050">                nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6051">                if ( *q != '-' ) {</a>
<a name="ln6052">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6053">                    goto exit_function;</a>
<a name="ln6054">                }</a>
<a name="ln6055">                p = q+1;</a>
<a name="ln6056">                nAtom2 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6057">                if ( !nAtom1 || !nAtom2 ||</a>
<a name="ln6058">                     nAtom1 &lt;= nAtom2   ||</a>
<a name="ln6059">                     nAtom1 &gt; pInChI[iComponent].nNumberOfAtoms ||</a>
<a name="ln6060">                     !(r = strchr( parity_type, *q) ) ) {</a>
<a name="ln6061">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6062">                    goto exit_function;</a>
<a name="ln6063">                }</a>
<a name="ln6064">                p = q+1;</a>
<a name="ln6065">            }</a>
<a name="ln6066">        }</a>
<a name="ln6067"> </a>
<a name="ln6068">        if ( p != pEnd ) {</a>
<a name="ln6069">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6070">            goto exit_function;</a>
<a name="ln6071">        }</a>
<a name="ln6072">        len = iBond;</a>
<a name="ln6073"> </a>
<a name="ln6074">        /* memory allocation */</a>
<a name="ln6075"> </a>
<a name="ln6076">        pStereo = bIso? &amp;pInChI[iComponent].StereoIsotopic : &amp;pInChI[iComponent].Stereo;</a>
<a name="ln6077"> </a>
<a name="ln6078">        if ( !*pStereo ) {</a>
<a name="ln6079">            if ( !(*pStereo = (INChI_Stereo *) inchi_calloc( 1, sizeof(**pStereo) ) ) ) {</a>
<a name="ln6080">                ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln6081">                goto exit_function;</a>
<a name="ln6082">            }</a>
<a name="ln6083">        }</a>
<a name="ln6084">        if ( pStereo[0]-&gt;b_parity || pStereo[0]-&gt;nNumberOfStereoBonds ||</a>
<a name="ln6085">             pStereo[0]-&gt;nBondAtom1 || pStereo[0]-&gt;nBondAtom2 ) {</a>
<a name="ln6086">            ret = RI_ERR_SYNTAX; /* syntax error: bonds have already been allocated */</a>
<a name="ln6087">            goto exit_function;</a>
<a name="ln6088">        }</a>
<a name="ln6089">        /* allocate sp2 stereo */</a>
<a name="ln6090">        if ( !(pStereo[0]-&gt;b_parity = (S_CHAR *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;b_parity[0]) ) ) ||</a>
<a name="ln6091">             !(pStereo[0]-&gt;nBondAtom1 = (AT_NUMB *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;nBondAtom1[0]) ) ) ||</a>
<a name="ln6092">             !(pStereo[0]-&gt;nBondAtom2 = (AT_NUMB *)inchi_calloc( len+1, sizeof(pStereo[0]-&gt;nBondAtom2[0]) ) ) ) {</a>
<a name="ln6093">            /* cleanup */</a>
<a name="ln6094">            if ( pStereo[0]-&gt;b_parity ) {</a>
<a name="ln6095">                INCHI_HEAPCHK</a>
<a name="ln6096">                inchi_free( pStereo[0]-&gt;b_parity );</a>
<a name="ln6097">                pStereo[0]-&gt;b_parity = NULL;</a>
<a name="ln6098">            }</a>
<a name="ln6099">            if ( pStereo[0]-&gt;nBondAtom1 ) {</a>
<a name="ln6100">                INCHI_HEAPCHK</a>
<a name="ln6101">                inchi_free( pStereo[0]-&gt;nBondAtom1 );</a>
<a name="ln6102">                pStereo[0]-&gt;nBondAtom1 = NULL;</a>
<a name="ln6103">            }</a>
<a name="ln6104">            if ( pStereo[0]-&gt;nBondAtom2 ) {</a>
<a name="ln6105">                INCHI_HEAPCHK</a>
<a name="ln6106">                inchi_free( pStereo[0]-&gt;nBondAtom2 );</a>
<a name="ln6107">                pStereo[0]-&gt;nBondAtom2 = NULL;</a>
<a name="ln6108">            }</a>
<a name="ln6109">            INCHI_HEAPCHK</a>
<a name="ln6110">            ret = RI_ERR_ALLOC; /* memory allocation failed */</a>
<a name="ln6111">            goto exit_function;</a>
<a name="ln6112">        }</a>
<a name="ln6113"> </a>
<a name="ln6114">        /* pass 2: store stereobonds */</a>
<a name="ln6115">        if ( *pbAbc == 1 ) {</a>
<a name="ln6116">            for ( p = pStart, iBond = 0; p &lt; pEnd; iBond ++ ) {</a>
<a name="ln6117">                if ( (nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;p, base ) ) &amp;&amp;</a>
<a name="ln6118">                      (nAtom2 = (AT_NUMB)inchi_strtol( p, &amp;p, base ) ) &amp;&amp;</a>
<a name="ln6119">                      (bondParity = (int)inchi_strtol( p, &amp;p, 10),</a>
<a name="ln6120">                      AB_MIN_KNOWN_PARITY &lt;= bondParity &amp;&amp; bondParity &lt;= AB_MAX_KNOWN_PARITY) ) {</a>
<a name="ln6121">                    ; /* okay */</a>
<a name="ln6122">                } else {</a>
<a name="ln6123">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6124">                    goto exit_function;</a>
<a name="ln6125">                }</a>
<a name="ln6126">                pStereo[0]-&gt;b_parity[iBond] = bondParity;</a>
<a name="ln6127">                pStereo[0]-&gt;nBondAtom1[iBond] = nAtom1;</a>
<a name="ln6128">                pStereo[0]-&gt;nBondAtom2[iBond] = nAtom2;</a>
<a name="ln6129"> </a>
<a name="ln6130">                if ( iBond &amp;&amp; </a>
<a name="ln6131">                     !(pStereo[0]-&gt;nBondAtom1[iBond-1] &lt;  nAtom1 ||</a>
<a name="ln6132">                       (pStereo[0]-&gt;nBondAtom1[iBond-1] == nAtom1 &amp;&amp;</a>
<a name="ln6133">                       pStereo[0]-&gt;nBondAtom2[iBond-1] &lt;  nAtom2) ) ) {</a>
<a name="ln6134">                    ret = RI_ERR_SYNTAX; /* syntax error: wrong bond order */</a>
<a name="ln6135">                    goto exit_function;</a>
<a name="ln6136">                }</a>
<a name="ln6137">            }</a>
<a name="ln6138">        } else {</a>
<a name="ln6139">            for ( p = pStart, iBond = 0; p &lt; pEnd; iBond ++, p += (*p==',') ) {</a>
<a name="ln6140">                nAtom1 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6141">                if ( *q != '-' ) {</a>
<a name="ln6142">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6143">                    goto exit_function;</a>
<a name="ln6144">                }</a>
<a name="ln6145">                p = q+1;</a>
<a name="ln6146">                nAtom2 = (AT_NUMB)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6147">                if ( !(r = strchr( parity_type, *q) ) ) {</a>
<a name="ln6148">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6149">                    goto exit_function;</a>
<a name="ln6150">                }</a>
<a name="ln6151">                p = q+1;</a>
<a name="ln6152">                bondParity = (r - parity_type) + 1;</a>
<a name="ln6153">                pStereo[0]-&gt;b_parity[iBond] = bondParity;</a>
<a name="ln6154">                pStereo[0]-&gt;nBondAtom1[iBond] = nAtom1;</a>
<a name="ln6155">                pStereo[0]-&gt;nBondAtom2[iBond] = nAtom2;</a>
<a name="ln6156"> </a>
<a name="ln6157">                if ( iBond &amp;&amp; </a>
<a name="ln6158">                     !(pStereo[0]-&gt;nBondAtom1[iBond-1] &lt;  nAtom1 ||</a>
<a name="ln6159">                       (pStereo[0]-&gt;nBondAtom1[iBond-1] == nAtom1 &amp;&amp;</a>
<a name="ln6160">                       pStereo[0]-&gt;nBondAtom2[iBond-1] &lt;  nAtom2) ) ) {</a>
<a name="ln6161">                    ret = RI_ERR_SYNTAX; /* syntax error: wrong bond order */</a>
<a name="ln6162">                    goto exit_function;</a>
<a name="ln6163">                }</a>
<a name="ln6164">            }</a>
<a name="ln6165">        }</a>
<a name="ln6166">        pStereo[0]-&gt;nNumberOfStereoBonds = iBond;</a>
<a name="ln6167"> </a>
<a name="ln6168">        if ( p != pEnd ) {</a>
<a name="ln6169">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6170">            goto exit_function;</a>
<a name="ln6171">        }</a>
<a name="ln6172"> </a>
<a name="ln6173">        /* multiplier */</a>
<a name="ln6174">        for ( i = 1; i &lt; mpy_component; i ++ ) {</a>
<a name="ln6175">            ret = CopySegment( pInChI+iComponent+i, pInChI+iComponent, nCpyType, bIso, bIso );</a>
<a name="ln6176">            if ( ret &lt; 0 ) {</a>
<a name="ln6177">                goto exit_function;</a>
<a name="ln6178">            }</a>
<a name="ln6179">        }</a>
<a name="ln6180"> </a>
<a name="ln6181">end_main_cycle:</a>
<a name="ln6182">        iComponent += mpy_component;</a>
<a name="ln6183">        if ( *pEnd ) {</a>
<a name="ln6184">            pStart = pEnd+1;</a>
<a name="ln6185">            continue;</a>
<a name="ln6186">        } else {</a>
<a name="ln6187">            break;</a>
<a name="ln6188">        }</a>
<a name="ln6189">    }</a>
<a name="ln6190">    if ( nNumComponents != iComponent ) {</a>
<a name="ln6191">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6192">        goto exit_function;</a>
<a name="ln6193">    }</a>
<a name="ln6194">    ret = iComponent + 1;</a>
<a name="ln6195"> </a>
<a name="ln6196">exit_function:</a>
<a name="ln6197">    return ret;   </a>
<a name="ln6198"> </a>
<a name="ln6199">}</a>
<a name="ln6200">/****************************************************************************************/</a>
<a name="ln6201">int ParseSegmentProtons( const char *str, int bMobileH, REM_PROTONS nNumProtons[], int ppnNumComponents[] )</a>
<a name="ln6202">{</a>
<a name="ln6203">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln6204">    int val;</a>
<a name="ln6205">    const char *q, *pStart, *pEnd;</a>
<a name="ln6206">    int  ret;</a>
<a name="ln6207">    </a>
<a name="ln6208">    if ( str[0] != 'p' )</a>
<a name="ln6209">        return 0;</a>
<a name="ln6210"> </a>
<a name="ln6211">    pStart = str+1;</a>
<a name="ln6212"> </a>
<a name="ln6213">    while( 1 ) {</a>
<a name="ln6214">        /* cycle over components */</a>
<a name="ln6215">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln6216">            pEnd = pStart + strlen(pStart);</a>
<a name="ln6217">        }</a>
<a name="ln6218"> </a>
<a name="ln6219">        if ( pStart[0] == '+' &amp;&amp; isdigit( UCINT pStart[1] ) ) {</a>
<a name="ln6220">            val = (int)inchi_strtol( pStart+1, &amp;q, 10 );</a>
<a name="ln6221">        } else</a>
<a name="ln6222">        if ( pStart[0] == '-' &amp;&amp; isdigit( UCINT pStart[1] ) ) {</a>
<a name="ln6223">            val = -(int)inchi_strtol( pStart+1, &amp;q, 10 );</a>
<a name="ln6224">        } else {</a>
<a name="ln6225">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6226">            goto exit_function;</a>
<a name="ln6227">        }</a>
<a name="ln6228">        if ( !val ) {</a>
<a name="ln6229">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6230">            goto exit_function;</a>
<a name="ln6231">        }</a>
<a name="ln6232">        nNumProtons[bMobileH].nNumRemovedProtons = val;</a>
<a name="ln6233">        if ( *pEnd || q != pEnd ) {</a>
<a name="ln6234">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6235">            goto exit_function;</a>
<a name="ln6236">        } else {</a>
<a name="ln6237">            break;</a>
<a name="ln6238">        }</a>
<a name="ln6239">    }</a>
<a name="ln6240">    ret = 1;</a>
<a name="ln6241"> </a>
<a name="ln6242">exit_function:</a>
<a name="ln6243">    return ret;   </a>
<a name="ln6244"> </a>
<a name="ln6245">}</a>
<a name="ln6246">/****************************************************************************************/</a>
<a name="ln6247">int ParseSegmentCharge( const char *str, int bMobileH, INChI *pInpInChI[], int ppnNumComponents[] )</a>
<a name="ln6248">{</a>
<a name="ln6249">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln6250">    int i, mpy_component, val;</a>
<a name="ln6251">    int nNumComponents, iComponent;</a>
<a name="ln6252">    const char *p, *q, *t, *pStart, *pEnd;</a>
<a name="ln6253">    int  ret;</a>
<a name="ln6254">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln6255">    const char   mult_type[] = &quot;mnMNe&quot;;</a>
<a name="ln6256">    </a>
<a name="ln6257">    if ( str[0] != 'q' ) {</a>
<a name="ln6258">        return 0;</a>
<a name="ln6259">    }</a>
<a name="ln6260"> </a>
<a name="ln6261">    pStart = str+1;</a>
<a name="ln6262">    iComponent = 0;</a>
<a name="ln6263">    nNumComponents = ppnNumComponents[bMobileH];</a>
<a name="ln6264"> </a>
<a name="ln6265">    if ( !*pStart &amp;&amp; bMobileH == TAUT_NON ) {</a>
<a name="ln6266">        for ( i = 0; i &lt; nNumComponents; i ++ ) {</a>
<a name="ln6267">            pInChI[i].nTotalCharge = NO_VALUE_INT;</a>
<a name="ln6268">        }</a>
<a name="ln6269">        return nNumComponents+1;</a>
<a name="ln6270">    }</a>
<a name="ln6271"> </a>
<a name="ln6272">    while( 1 ) {</a>
<a name="ln6273">        /* cycle over components */</a>
<a name="ln6274">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln6275">            pEnd = pStart + strlen(pStart);</a>
<a name="ln6276">        }</a>
<a name="ln6277"> </a>
<a name="ln6278">        if ( ((isdigit(UCINT *pStart) &amp;&amp;</a>
<a name="ln6279">             0 &lt; (val = (int)inchi_strtol( pStart, &amp;q, 10))) ||</a>
<a name="ln6280">             (q = pStart, val=1) )&amp;&amp;</a>
<a name="ln6281">             (t=strchr(mult_type, *q)) &amp;&amp; q+1 == pEnd ) {</a>
<a name="ln6282">            /* process the abbreviation */</a>
<a name="ln6283"> </a>
<a name="ln6284">            switch( bMobileH ) {</a>
<a name="ln6285"> </a>
<a name="ln6286">            case TAUT_YES:</a>
<a name="ln6287">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6288">                goto exit_function;</a>
<a name="ln6289"> </a>
<a name="ln6290">            case TAUT_NON:</a>
<a name="ln6291">                if ( *q != 'm' ||</a>
<a name="ln6292">                    iComponent + val &gt; nNumComponents ||</a>
<a name="ln6293">                    iComponent + val &gt; ppnNumComponents[TAUT_YES] ) {</a>
<a name="ln6294"> </a>
<a name="ln6295">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6296">                    goto exit_function;</a>
<a name="ln6297">                }</a>
<a name="ln6298">                for ( i = 0; i &lt; val; i ++ ) {</a>
<a name="ln6299">                    /* avoid 0 which means &quot;omitted&quot; */</a>
<a name="ln6300">                    pInChI[iComponent+i].nTotalCharge = pInpInChI[TAUT_YES][iComponent+i].nTotalCharge?</a>
<a name="ln6301">                                                        pInpInChI[TAUT_YES][iComponent+i].nTotalCharge :</a>
<a name="ln6302">                                                        NO_VALUE_INT;</a>
<a name="ln6303">                }</a>
<a name="ln6304">                mpy_component = val;</a>
<a name="ln6305">                goto end_main_cycle;</a>
<a name="ln6306"> </a>
<a name="ln6307">            default:</a>
<a name="ln6308">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6309">                goto exit_function;</a>
<a name="ln6310">            }</a>
<a name="ln6311">        }else</a>
<a name="ln6312">        if ( (p = strchr(pStart, '*')) &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln6313">            mpy_component = (int)inchi_strtol( pStart, &amp;q, 10 );</a>
<a name="ln6314">            if ( p != q ) {</a>
<a name="ln6315">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6316">                goto exit_function;</a>
<a name="ln6317">            }</a>
<a name="ln6318">            p ++;</a>
<a name="ln6319">        } else {</a>
<a name="ln6320">            mpy_component = 1;</a>
<a name="ln6321">            p = pStart;</a>
<a name="ln6322">        }</a>
<a name="ln6323">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln6324">        if ( mpy_component + iComponent &gt; nNumComponents || mpy_component &lt;= 0 ) {</a>
<a name="ln6325">            ret = RI_ERR_SYNTAX; /* syntax error: too many components in charge layer */</a>
<a name="ln6326">            goto exit_function;</a>
<a name="ln6327">        }</a>
<a name="ln6328">#endif</a>
<a name="ln6329">        pStart = p;</a>
<a name="ln6330"> </a>
<a name="ln6331">        if ( pStart &lt; pEnd ) {</a>
<a name="ln6332">            if ( pStart[0] == '+' &amp;&amp; isdigit( UCINT pStart[1] ) ) {</a>
<a name="ln6333">                val = (int)inchi_strtol( pStart+1, &amp;q, 10 );</a>
<a name="ln6334">                pStart = q;</a>
<a name="ln6335">            } else</a>
<a name="ln6336">            if ( pStart[0] == '-' &amp;&amp; isdigit( UCINT pStart[1] ) ) {</a>
<a name="ln6337">                val = -(int)inchi_strtol( pStart+1, &amp;q, 10 );</a>
<a name="ln6338">                pStart = q;</a>
<a name="ln6339">            } else {</a>
<a name="ln6340">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6341">                goto exit_function;</a>
<a name="ln6342">            }</a>
<a name="ln6343">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln6344">            if ( val &lt; -256 || val &gt; 256 ) {</a>
<a name="ln6345">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6346">                goto exit_function;</a>
<a name="ln6347">            }</a>
<a name="ln6348">#endif</a>
<a name="ln6349">            if ( !val ) {</a>
<a name="ln6350">                if ( pStart != pEnd ) {</a>
<a name="ln6351">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6352">                    goto exit_function;</a>
<a name="ln6353">                }</a>
<a name="ln6354">                if ( bMobileH == TAUT_NON ) {</a>
<a name="ln6355">                    val = NO_VALUE_INT;  /* avoid 0 which means &quot;omitted&quot; */</a>
<a name="ln6356">                }</a>
<a name="ln6357">            }</a>
<a name="ln6358">        } else {</a>
<a name="ln6359">            val = NO_VALUE_INT;</a>
<a name="ln6360">        }</a>
<a name="ln6361">        for ( i = 0; i &lt; mpy_component; i ++ ) {</a>
<a name="ln6362">            pInChI[iComponent+i].nTotalCharge = val;</a>
<a name="ln6363">        }</a>
<a name="ln6364"> </a>
<a name="ln6365">end_main_cycle:</a>
<a name="ln6366">        iComponent += mpy_component;</a>
<a name="ln6367">        if ( *pEnd ) {</a>
<a name="ln6368">            pStart = pEnd+1;</a>
<a name="ln6369">            continue;</a>
<a name="ln6370">        } else {</a>
<a name="ln6371">            break;</a>
<a name="ln6372">        }</a>
<a name="ln6373">    }</a>
<a name="ln6374"> </a>
<a name="ln6375">    if ( nNumComponents != iComponent ) {</a>
<a name="ln6376">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6377">        goto exit_function;</a>
<a name="ln6378">    }</a>
<a name="ln6379">    ret = iComponent + 1;</a>
<a name="ln6380"> </a>
<a name="ln6381">exit_function:</a>
<a name="ln6382">    return ret;   </a>
<a name="ln6383"> </a>
<a name="ln6384">}</a>
<a name="ln6385">/****************************************************************************************/</a>
<a name="ln6386">int ParseSegmentMobileH( const char *str, int bMobileH, INChI *pInpInChI[], int pnNumComponents[], int *pbAbc )</a>
<a name="ln6387">{</a>
<a name="ln6388">#define nNum_H( ICOMPONENT ) ((bMobileH==TAUT_YES)? pInChI[ICOMPONENT].nNum_H : pInChI[ICOMPONENT].nNum_H_fixed)    </a>
<a name="ln6389">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln6390">    int i, mpy_component, num_H, num_Minus, val, num_Atoms, numCtAtoms, tg_alloc_len, len, len2;</a>
<a name="ln6391">    int num_H_component, num_H_formula, num_taut_H_component, num_H_InChI, ret2;</a>
<a name="ln6392">    int nNumComponents, iComponent, nNumBonds, lenTautomer, tg_pos_Tautomer, iTGroup;</a>
<a name="ln6393">    const char *p, *q, *h, *t, *p1, *pTaut, *pStart, *pEnd;</a>
<a name="ln6394">    AT_NUMB curAtom, nxtAtom;</a>
<a name="ln6395">    int  num_open, state, ret, nAltMobileH = ALT_TAUT(bMobileH);</a>
<a name="ln6396">    INChI *pInChI = pInpInChI[bMobileH];</a>
<a name="ln6397">    INChI *pAltInChI = pInpInChI[nAltMobileH];</a>
<a name="ln6398">    int  base = 10;</a>
<a name="ln6399">    </a>
<a name="ln6400">    num_H = -999;          /* impossible value */</a>
<a name="ln6401">    num_Minus = -999;      /* impossible value */</a>
<a name="ln6402">    tg_pos_Tautomer = -999; /* impossible value */</a>
<a name="ln6403"> </a>
<a name="ln6404">    /* number of immobile H is always allocated; immobile H are present in M layer only */</a>
<a name="ln6405">    nNumComponents = pnNumComponents[bMobileH];</a>
<a name="ln6406">    for ( i = 0; i &lt; nNumComponents; i ++ ) {</a>
<a name="ln6407">        len = pInChI[i].nNumberOfAtoms;</a>
<a name="ln6408">        if ( bMobileH == TAUT_NON &amp;&amp; i &lt; pnNumComponents[nAltMobileH] ) {</a>
<a name="ln6409">            if ( len &lt; pAltInChI[i].nNumberOfAtoms ) {</a>
<a name="ln6410">                len = pAltInChI[i].nNumberOfAtoms;</a>
<a name="ln6411">                if ( pInChI[i].nNum_H ) {</a>
<a name="ln6412">                    inchi_free( pInChI[i].nNum_H );</a>
<a name="ln6413">                    pInChI[i].nNum_H = NULL;</a>
<a name="ln6414">                }</a>
<a name="ln6415">            }</a>
<a name="ln6416">        }</a>
<a name="ln6417">        len ++;</a>
<a name="ln6418">        if ( !pInChI[i].nNum_H &amp;&amp; /* allocate immobile H segment if it has not been allocated yet */ </a>
<a name="ln6419">             !(pInChI[i].nNum_H = (S_CHAR *)inchi_calloc( len, sizeof(pInChI[0].nNum_H[0]) )) ) {</a>
<a name="ln6420">            ret = RI_ERR_ALLOC; /* allocation error */</a>
<a name="ln6421">            goto exit_function;</a>
<a name="ln6422">        }</a>
<a name="ln6423">        /* copy immobile H from Mobile-H layer to Fixed-H layer */</a>
<a name="ln6424">        if ( bMobileH == TAUT_NON &amp;&amp; i &lt; pnNumComponents[nAltMobileH] ) {</a>
<a name="ln6425">            memcpy( pInChI[i].nNum_H, pAltInChI[i].nNum_H, (len-1) * sizeof(pInChI[0].nNum_H[0]) );</a>
<a name="ln6426">        }</a>
<a name="ln6427">    }</a>
<a name="ln6428"> </a>
<a name="ln6429">    if ( str[0] != 'h' )</a>
<a name="ln6430">        return 0;</a>
<a name="ln6431"> </a>
<a name="ln6432">    /* Read Hydrogen info in 1 pass */</a>
<a name="ln6433">    pStart = str+1;</a>
<a name="ln6434">    iComponent = 0;</a>
<a name="ln6435">    nNumComponents = pnNumComponents[bMobileH];</a>
<a name="ln6436"> </a>
<a name="ln6437">    while( 1 ) {</a>
<a name="ln6438">        /* cycle over components */</a>
<a name="ln6439">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln6440">            pEnd = pStart + strlen(pStart);</a>
<a name="ln6441">        }</a>
<a name="ln6442">        if ( (p = strchr(pStart, '*')) &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln6443">            mpy_component = (int)inchi_strtol( pStart, &amp;q, 10 );</a>
<a name="ln6444">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln6445">            if ( p != q || !isdigit(UCINT *pStart) ) /* prevent non-positive multipliers */</a>
<a name="ln6446">#else</a>
<a name="ln6447">            if ( p != q )</a>
<a name="ln6448">#endif</a>
<a name="ln6449">            {</a>
<a name="ln6450">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6451">                goto exit_function;</a>
<a name="ln6452">            }</a>
<a name="ln6453">            p ++;</a>
<a name="ln6454">        } else {</a>
<a name="ln6455">            mpy_component = 1;</a>
<a name="ln6456">            p = pStart;</a>
<a name="ln6457">        }</a>
<a name="ln6458">        pStart = p;</a>
<a name="ln6459">        /* Pass 1.1 parse a component */</a>
<a name="ln6460">        num_open = 0;</a>
<a name="ln6461">        state='\0';   /* initial state */</a>
<a name="ln6462">        nNumBonds = 0;</a>
<a name="ln6463">        curAtom   = 0;</a>
<a name="ln6464">        numCtAtoms = pInChI[iComponent].nNumberOfAtoms;</a>
<a name="ln6465">        if ( bMobileH == TAUT_NON &amp;&amp; iComponent &lt; pnNumComponents[nAltMobileH] ) {</a>
<a name="ln6466">            numCtAtoms = pAltInChI[iComponent].nNumberOfAtoms;</a>
<a name="ln6467">        }</a>
<a name="ln6468">        </a>
<a name="ln6469">        if ( p &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln6470">            /* check if compressed InChI */</a>
<a name="ln6471">            *pbAbc = (*p == ',' || isupper( UCINT *p))? 1 : 0;</a>
<a name="ln6472">        }</a>
<a name="ln6473">        base = (*pbAbc==1)? ALPHA_BASE : 10;</a>
<a name="ln6474"> </a>
<a name="ln6475">        /* immobile H */</a>
<a name="ln6476">        t = pTaut = (*pbAbc==1)? strchr( p, ',' ) : strchr( p, '(' ); /* locate the first tautomer group character */</a>
<a name="ln6477">        </a>
<a name="ln6478">        if ( t &amp;&amp; bMobileH == TAUT_NON ) {</a>
<a name="ln6479">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6480">            goto exit_function;</a>
<a name="ln6481">        }</a>
<a name="ln6482">        if ( !pTaut || pTaut &gt; pEnd ) {</a>
<a name="ln6483">            pTaut = pEnd;</a>
<a name="ln6484">            t = NULL; /* found no tautomeric group for this component */</a>
<a name="ln6485">        }</a>
<a name="ln6486">        for ( i = 0; i &lt; mpy_component; i ++ ) {</a>
<a name="ln6487">            if ( bMobileH == TAUT_NON ) {</a>
<a name="ln6488">                /* allocate nNum_H_fixed */</a>
<a name="ln6489">                if ( pInChI[iComponent+i].nNum_H_fixed ) {</a>
<a name="ln6490">                    ret = RI_ERR_PROGR; /* program error */</a>
<a name="ln6491">                    goto exit_function;</a>
<a name="ln6492">                }</a>
<a name="ln6493">                if ( iComponent+i &lt; pnNumComponents[nAltMobileH] ) {</a>
<a name="ln6494">                    len = inchi_max(pInChI[iComponent+i].nNumberOfAtoms, pAltInChI[iComponent+i].nNumberOfAtoms)+1;</a>
<a name="ln6495">                } else {</a>
<a name="ln6496">                    len = pInChI[iComponent+i].nNumberOfAtoms + 1;</a>
<a name="ln6497">                }</a>
<a name="ln6498">                pInChI[iComponent+i].nNum_H_fixed = (S_CHAR *)inchi_calloc( len, sizeof(pInChI[0].nNum_H_fixed[0]) );</a>
<a name="ln6499">                if ( !pInChI[iComponent+i].nNum_H_fixed ) {</a>
<a name="ln6500">                    ret = RI_ERR_ALLOC; /* allocation error */</a>
<a name="ln6501">                    goto exit_function;</a>
<a name="ln6502">                }</a>
<a name="ln6503">                /* compare nAtom */</a>
<a name="ln6504">                if ( iComponent+i &lt; pnNumComponents[nAltMobileH] ) {</a>
<a name="ln6505">                    len2 = inchi_min(pInChI[iComponent+i].nNumberOfAtoms, pAltInChI[iComponent+i].nNumberOfAtoms);</a>
<a name="ln6506">                    if ( pInChI[iComponent+i].nAtom &amp;&amp; len2 ) {</a>
<a name="ln6507">                        /* check */</a>
<a name="ln6508">                        if ( memcmp( pInChI[iComponent+i].nAtom, pAltInChI[iComponent+i].nAtom, len2 * sizeof(pInChI[0].nAtom[0]) ) ) {</a>
<a name="ln6509">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6510">                            goto exit_function;</a>
<a name="ln6511">                        }</a>
<a name="ln6512">                    }</a>
<a name="ln6513">                    /* allocate and copy atom if bridging H are present */</a>
<a name="ln6514">                    if ( pInChI[iComponent+i].nNumberOfAtoms &lt; pAltInChI[iComponent+i].nNumberOfAtoms ) {</a>
<a name="ln6515">                        if ( pInChI[iComponent+i].nAtom )</a>
<a name="ln6516">                            inchi_free( pInChI[iComponent+i].nAtom );</a>
<a name="ln6517">                        if ( !(pInChI[iComponent+i].nAtom = (U_CHAR *)inchi_calloc( len, sizeof(pInChI[0].nAtom[0]) ) ) ) {</a>
<a name="ln6518">                            ret = RI_ERR_ALLOC; /* allocation error */</a>
<a name="ln6519">                            goto exit_function;</a>
<a name="ln6520">                        }</a>
<a name="ln6521">                        if ( len &gt; 1 ) {</a>
<a name="ln6522">                            memcpy( pInChI[iComponent+i].nAtom, pAltInChI[iComponent+i].nAtom, (len-1) * sizeof(pInChI[0].nAtom[0]) );</a>
<a name="ln6523">                        }</a>
<a name="ln6524">                        /* correct number of atoms including bridging H */</a>
<a name="ln6525">                        pInChI[iComponent+i].nNumberOfAtoms = pAltInChI[iComponent+i].nNumberOfAtoms;</a>
<a name="ln6526">                    }</a>
<a name="ln6527">                }</a>
<a name="ln6528">            }</a>
<a name="ln6529">        }</a>
<a name="ln6530">        </a>
<a name="ln6531">        if ( *pbAbc == 1 ) {</a>
<a name="ln6532">            /* read numbers of H: XnYn... or XYn... */</a>
<a name="ln6533">            p = pStart;</a>
<a name="ln6534">            tg_alloc_len = 0;</a>
<a name="ln6535">            num_H_component = num_taut_H_component = 0;</a>
<a name="ln6536">            while ( p &lt; pTaut ) {</a>
<a name="ln6537">                /* syntax check: atom number */</a>
<a name="ln6538">                if ( !*p || !isupper( UCINT *p ) ) {</a>
<a name="ln6539">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6540">                    goto exit_function;</a>
<a name="ln6541">                }</a>
<a name="ln6542">                if ( (curAtom = nxtAtom = (int)inchi_strtol( p, &amp;q, base )) ) {</a>
<a name="ln6543">                    p = q;</a>
<a name="ln6544">                    if ( isupper( UCINT *p ) ) {</a>
<a name="ln6545">                        nxtAtom = (int)inchi_strtol( p, &amp;q, base );</a>
<a name="ln6546">                        p = q;</a>
<a name="ln6547">                    }</a>
<a name="ln6548">                }</a>
<a name="ln6549">                if ( curAtom &gt; nxtAtom || nxtAtom &gt; numCtAtoms || p &gt; pTaut ) {</a>
<a name="ln6550">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6551">                    goto exit_function;</a>
<a name="ln6552">                }</a>
<a name="ln6553">                /* number of H, may be negative */</a>
<a name="ln6554">                if ( !(num_H = (int)inchi_strtol( p, &amp;q, 10 )) || q &gt; pTaut ) {</a>
<a name="ln6555">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6556">                    goto exit_function;</a>
<a name="ln6557">                }</a>
<a name="ln6558">                p = q;</a>
<a name="ln6559">                /* set number of H */</a>
<a name="ln6560">                for ( i = curAtom; i &lt;= nxtAtom; i ++ ) {</a>
<a name="ln6561">                    nNum_H(iComponent)[i-1] = num_H;</a>
<a name="ln6562">                    num_H_component += num_H;</a>
<a name="ln6563">                }</a>
<a name="ln6564">            }</a>
<a name="ln6565">            if ( p != pTaut ) {</a>
<a name="ln6566">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6567">                goto exit_function;</a>
<a name="ln6568">            }</a>
<a name="ln6569">        } else {</a>
<a name="ln6570">            /* read numbers of H: 1-2,3H2,4,5H3 */</a>
<a name="ln6571">            p = pStart;</a>
<a name="ln6572">            tg_alloc_len = 0;</a>
<a name="ln6573">            num_H_component = num_taut_H_component = 0;</a>
<a name="ln6574">            while ( p &lt; pTaut ) {</a>
<a name="ln6575">                /* syntax check: atom number */</a>
<a name="ln6576">                if ( !*p || !isdigit( UCINT *p ) ) {</a>
<a name="ln6577">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6578">                    goto exit_function;</a>
<a name="ln6579">                }</a>
<a name="ln6580">                /* number of H */</a>
<a name="ln6581">                h = p + strcspn( p, &quot;Hh&quot; );</a>
<a name="ln6582">                /*h = strchr( p, 'H' );*/</a>
<a name="ln6583">                if ( !*h || h &gt;= pTaut ) {</a>
<a name="ln6584">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6585">                    goto exit_function;</a>
<a name="ln6586">                </a>
<a name="ln6587">                    /*</a>
<a name="ln6588">                    p = pTaut;</a>
<a name="ln6589">                    h = NULL;</a>
<a name="ln6590">                    break; */ /* no more H found */</a>
<a name="ln6591">                }</a>
<a name="ln6592">                num_H = (*h == 'H')? 1 : (*h == 'h')? -1 : 0;</a>
<a name="ln6593">                if ( !num_H ) {</a>
<a name="ln6594">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6595">                    goto exit_function;</a>
<a name="ln6596">                }</a>
<a name="ln6597">                if ( h[1] &amp;&amp; isdigit( UCINT h[1] ) ) {</a>
<a name="ln6598">                    num_H *= (int)inchi_strtol( h+1, &amp;p1, 10 );</a>
<a name="ln6599">                } else {</a>
<a name="ln6600">                    p1 = h+1; /* next set of immobile H */</a>
<a name="ln6601">                }</a>
<a name="ln6602">                if ( *p1 == ',' ) {</a>
<a name="ln6603">                    p1 ++;  /* next H-subsegment; otherwise (H or ; or end of the segment */</a>
<a name="ln6604">                }</a>
<a name="ln6605">                /* list of atoms that have num_H */</a>
<a name="ln6606">                while ( p &lt; h ) {</a>
<a name="ln6607">                    if ( !*p || !isdigit( UCINT *p ) ) {</a>
<a name="ln6608">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6609">                        goto exit_function;</a>
<a name="ln6610">                    }</a>
<a name="ln6611">                    nxtAtom = curAtom = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6612">                    if ( *q == '-' ) {</a>
<a name="ln6613">                        nxtAtom = (int)inchi_strtol( q+1, &amp;q, 10 );</a>
<a name="ln6614">                    }</a>
<a name="ln6615">                    /* consitency check */</a>
<a name="ln6616">                    if ( !curAtom || curAtom &gt; numCtAtoms ||</a>
<a name="ln6617">                         nxtAtom &lt; curAtom || nxtAtom &gt; numCtAtoms ) {</a>
<a name="ln6618">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6619">                        goto exit_function;</a>
<a name="ln6620">                    }</a>
<a name="ln6621">                    /* set number of H */</a>
<a name="ln6622">                    for ( i = curAtom; i &lt;= nxtAtom; i ++ ) {</a>
<a name="ln6623">                        nNum_H(iComponent)[i-1] = num_H;</a>
<a name="ln6624">                        num_H_component += num_H;</a>
<a name="ln6625">                    }</a>
<a name="ln6626">                    /* move to the next atom number if any */</a>
<a name="ln6627">                    p = q;</a>
<a name="ln6628">                    if ( *p == ',' ) {</a>
<a name="ln6629">                        p ++;</a>
<a name="ln6630">                    }</a>
<a name="ln6631">                }</a>
<a name="ln6632"> </a>
<a name="ln6633">                if ( p == h ) {</a>
<a name="ln6634">                    p = p1;</a>
<a name="ln6635">                } else</a>
<a name="ln6636">                if ( p == pTaut ) {</a>
<a name="ln6637">                    break;</a>
<a name="ln6638">                } else {</a>
<a name="ln6639">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6640">                    goto exit_function;</a>
<a name="ln6641">                }</a>
<a name="ln6642">            }</a>
<a name="ln6643">        }</a>
<a name="ln6644"> </a>
<a name="ln6645">        INCHI_HEAPCHK</a>
<a name="ln6646">        /* ) -&gt; (, H, N, [-, N,], AtNum,... AtNum) */ </a>
<a name="ln6647">        lenTautomer = 0;</a>
<a name="ln6648">        if ( (p = t) ) {</a>
<a name="ln6649">            if ( *pbAbc == 1 ) {</a>
<a name="ln6650">                /* tautomeric groups: pass 1 */</a>
<a name="ln6651">                iTGroup = 0;</a>
<a name="ln6652">                state   = ')';  /* init as if the prev. t-group just ended */</a>
<a name="ln6653">                num_Atoms = 0;</a>
<a name="ln6654">                /* Tautomeric info storage */</a>
<a name="ln6655">                /* NumGroups; ((NumAt+2, NumH, Num(-), At1..AtNumAt),...); {INCHI_T_NUM_MOVABLE = 2} */</a>
<a name="ln6656">                /* Allocated length: [5*nNumberOfAtoms/2+1], see Alloc_INChI(...) */</a>
<a name="ln6657">                if ( *p == ',' ) { /* start t-group */</a>
<a name="ln6658">                    p ++;</a>
<a name="ln6659">                } else {</a>
<a name="ln6660">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6661">                    goto exit_function;</a>
<a name="ln6662">                }</a>
<a name="ln6663">                while ( p &lt; pEnd ) {</a>
<a name="ln6664">                    /* start t-group */</a>
<a name="ln6665">                    if ( !isdigit( UCINT *p ) || !(num_H = (int)inchi_strtol( p, &amp;q, 10 ) ) || q &gt; pEnd ) {</a>
<a name="ln6666">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6667">                        goto exit_function;</a>
<a name="ln6668">                    }</a>
<a name="ln6669">                    p = q;</a>
<a name="ln6670">                    num_Minus = 0;</a>
<a name="ln6671">                    if ( *p == '-' ) {</a>
<a name="ln6672">                        p ++;</a>
<a name="ln6673">                        if ( isdigit( UCINT *p ) ) {</a>
<a name="ln6674">                            num_Minus = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6675">                            p = q;</a>
<a name="ln6676">                        } else {</a>
<a name="ln6677">                            num_Minus = 1;</a>
<a name="ln6678">                        }</a>
<a name="ln6679">                    }</a>
<a name="ln6680">                    if ( p &gt;= pEnd ) {</a>
<a name="ln6681">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6682">                        goto exit_function;</a>
<a name="ln6683">                    }</a>
<a name="ln6684">                    if ( !tg_alloc_len ) {</a>
<a name="ln6685">                        /* </a>
<a name="ln6686">                           --- header ---</a>
<a name="ln6687">                           [num_t_groups]</a>
<a name="ln6688">                           --- one t-group: ---</a>
<a name="ln6689">                           [len=group length no including this value]</a>
<a name="ln6690">                           [num_H]</a>
<a name="ln6691">                           [num_(-)]</a>
<a name="ln6692">                           [Endpoint(1),...,Endpoint(len-2)]</a>
<a name="ln6693">                           --- next t-group ---</a>
<a name="ln6694">                           ...</a>
<a name="ln6695"> </a>
<a name="ln6696">                           Max. size = 1 + 3*max_num_t_groups + max_num_endpoints</a>
<a name="ln6697"> </a>
<a name="ln6698">                           max_num_t_groups  = num_at/2</a>
<a name="ln6699">                           max_num_endpoints = num_at</a>
<a name="ln6700"> </a>
<a name="ln6701">                           Max. size = 1 + 3*(num_at/2) + num_at = 1 + (5*num_at)/2</a>
<a name="ln6702">                           5 = 3 + INCHI_T_NUM_MOVABLE = 3 + num_types_of_attachments</a>
<a name="ln6703"> </a>
<a name="ln6704">                           This does not include zero termination!</a>
<a name="ln6705">                       </a>
<a name="ln6706">                        */</a>
<a name="ln6707">                        tg_alloc_len = ((3+INCHI_T_NUM_MOVABLE)*pInChI[iComponent].nNumberOfAtoms)/2+1;</a>
<a name="ln6708">                        for ( i = 0; i &lt; mpy_component; i ++ ) {</a>
<a name="ln6709">                            pInChI[iComponent+i].nTautomer = (AT_NUMB*)inchi_calloc( tg_alloc_len+1, sizeof(pInChI-&gt;nTautomer[0]));</a>
<a name="ln6710">                            if ( !pInChI[iComponent+i].nTautomer ) {</a>
<a name="ln6711">                                ret = RI_ERR_ALLOC; /* allocation error */</a>
<a name="ln6712">                                goto exit_function;</a>
<a name="ln6713">                            }</a>
<a name="ln6714">                            pInChI[iComponent+i].lenTautomer = 0;</a>
<a name="ln6715">                        }</a>
<a name="ln6716">                        tg_pos_Tautomer = 1; /* number atoms (NumAt+2) position */</a>
<a name="ln6717">                    } else {</a>
<a name="ln6718">                        /* next t-group */</a>
<a name="ln6719">                        tg_pos_Tautomer = lenTautomer;</a>
<a name="ln6720">                    }</a>
<a name="ln6721">                    if ( tg_pos_Tautomer+3 &gt;= tg_alloc_len ) {</a>
<a name="ln6722">                        ret = RI_ERR_PROGR; /* wrong tautomer array length */</a>
<a name="ln6723">                        goto exit_function;</a>
<a name="ln6724">                    }</a>
<a name="ln6725">                    pInChI[iComponent].nTautomer[tg_pos_Tautomer+1] = num_H;</a>
<a name="ln6726">                    pInChI[iComponent].nTautomer[tg_pos_Tautomer+2] = num_Minus;</a>
<a name="ln6727">                    lenTautomer                = tg_pos_Tautomer+3; /* first atom number position */</a>
<a name="ln6728">                    num_taut_H_component += num_H;</a>
<a name="ln6729"> </a>
<a name="ln6730">                    while ( p &lt; pEnd &amp;&amp; isupper( UCINT *p) ) {</a>
<a name="ln6731">                        /* read list of tautomeric atoms */</a>
<a name="ln6732">                        val = (int)inchi_strtol( p, &amp;q, base );</a>
<a name="ln6733">                        if ( lenTautomer &gt;= tg_alloc_len || val &gt; numCtAtoms ) {</a>
<a name="ln6734">                            ret = RI_ERR_PROGR; /* wrong tautomer array length */</a>
<a name="ln6735">                            goto exit_function;</a>
<a name="ln6736">                        }</a>
<a name="ln6737">                        num_Atoms ++;</a>
<a name="ln6738">                        pInChI[iComponent].nTautomer[lenTautomer ++] = val;</a>
<a name="ln6739">                        p = q;</a>
<a name="ln6740">                    }</a>
<a name="ln6741">                    if ( !num_Atoms || (p &lt; pEnd &amp;&amp; !isdigit( UCINT *p))  ) {</a>
<a name="ln6742">                        ret = RI_ERR_PROGR; /* wrong tautomer array length */</a>
<a name="ln6743">                        goto exit_function;</a>
<a name="ln6744">                    }</a>
<a name="ln6745">                    iTGroup ++;</a>
<a name="ln6746">                    pInChI[iComponent].nTautomer[tg_pos_Tautomer] = lenTautomer - tg_pos_Tautomer - 1; /* length of the rest of the t-group */</a>
<a name="ln6747">                    pInChI[iComponent].lenTautomer = lenTautomer;</a>
<a name="ln6748">                }</a>
<a name="ln6749">                if ( !iTGroup || p != pEnd ) {</a>
<a name="ln6750">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6751">                    goto exit_function;</a>
<a name="ln6752">                }</a>
<a name="ln6753">                pInChI[iComponent].nTautomer[0] = iTGroup;</a>
<a name="ln6754"> </a>
<a name="ln6755">            } else {</a>
<a name="ln6756">                /* tautomeric groups: pass 1 */</a>
<a name="ln6757">                iTGroup = 0;</a>
<a name="ln6758">                state   = ')';  /* init as if the prev. t-group just ended */</a>
<a name="ln6759">                num_Atoms = 0;</a>
<a name="ln6760">                /* Tautomeric info storage */</a>
<a name="ln6761">                /* NumGroups; ((NumAt+2, NumH, Num(-), At1..AtNumAt),...); {INCHI_T_NUM_MOVABLE = 2} */</a>
<a name="ln6762">                /* Allocated length: [5*nNumberOfAtoms/2+1], see Alloc_INChI(...) */</a>
<a name="ln6763">                while ( p &lt; pEnd ) {</a>
<a name="ln6764">                    /* t-group */</a>
<a name="ln6765">                    switch ( *p ) {</a>
<a name="ln6766">                    case '(': /* start t-group */</a>
<a name="ln6767">                        switch ( state ) {</a>
<a name="ln6768">                        case ')':</a>
<a name="ln6769">                            state = *p ++;</a>
<a name="ln6770">                            num_H = 0;</a>
<a name="ln6771">                            num_Minus = 0;</a>
<a name="ln6772">                            continue;</a>
<a name="ln6773">                        default:</a>
<a name="ln6774">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6775">                            goto exit_function;</a>
<a name="ln6776">                        }</a>
<a name="ln6777">                    case ')': /* end t-group */</a>
<a name="ln6778">                        switch ( state ) {</a>
<a name="ln6779">                        case 'A': /* previuos was atom number */</a>
<a name="ln6780">                            if ( !tg_alloc_len ) {</a>
<a name="ln6781">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6782">                                goto exit_function;</a>
<a name="ln6783">                            }</a>
<a name="ln6784">                            iTGroup ++;</a>
<a name="ln6785">                            state = *p ++;</a>
<a name="ln6786">                            pInChI[iComponent].nTautomer[tg_pos_Tautomer] = lenTautomer - tg_pos_Tautomer - 1; /* length of the rest of the t-group */</a>
<a name="ln6787">                            pInChI[iComponent].lenTautomer = lenTautomer;</a>
<a name="ln6788">                            continue;</a>
<a name="ln6789">                        default:</a>
<a name="ln6790">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6791">                            goto exit_function;</a>
<a name="ln6792">                        }</a>
<a name="ln6793">                    case 'H': /* number of H */</a>
<a name="ln6794">                        switch ( state ) {</a>
<a name="ln6795">                        case '(':</a>
<a name="ln6796">                            state = *p ++;</a>
<a name="ln6797">                            num_H = 1;</a>
<a name="ln6798">                            continue;</a>
<a name="ln6799">                        default:</a>
<a name="ln6800">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6801">                            goto exit_function;</a>
<a name="ln6802">                        }</a>
<a name="ln6803">                    case '-':  /* number of (-) */</a>
<a name="ln6804">                        switch ( state ) {</a>
<a name="ln6805">                        case 'N': /* previous was number of H */</a>
<a name="ln6806">                        case 'H': /* previous was H */</a>
<a name="ln6807">                            state = *p ++;</a>
<a name="ln6808">                            num_Minus = 1;</a>
<a name="ln6809">                            continue;</a>
<a name="ln6810">                        default:</a>
<a name="ln6811">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6812">                            goto exit_function;</a>
<a name="ln6813">                        }</a>
<a name="ln6814">                    case ',':</a>
<a name="ln6815">                        switch ( state ) {</a>
<a name="ln6816">                        case 'N': /* previous was number of H */</a>
<a name="ln6817">                        case 'H': /* previous was H */</a>
<a name="ln6818">                        case '-': /* previuos was - */</a>
<a name="ln6819">                        case 'M': /* previous was number of (-) */</a>
<a name="ln6820">                            /* the next must be the first tautomeric atom number; save num_H &amp; num_Minus */</a>
<a name="ln6821">                            if ( num_H &lt;= 0 &amp;&amp; num_Minus &lt;= 0 ) {</a>
<a name="ln6822">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6823">                                goto exit_function;</a>
<a name="ln6824">                            }</a>
<a name="ln6825">                            if ( !tg_alloc_len ) {</a>
<a name="ln6826">                                /* </a>
<a name="ln6827">                                   --- header ---</a>
<a name="ln6828">                                   [num_t_groups]</a>
<a name="ln6829">                                   --- one t-group: ---</a>
<a name="ln6830">                                   [len=group length no including this value]</a>
<a name="ln6831">                                   [num_H]</a>
<a name="ln6832">                                   [num_(-)]</a>
<a name="ln6833">                                   [Endpoint(1),...,Endpoint(len-2)]</a>
<a name="ln6834">                                   --- next t-group ---</a>
<a name="ln6835">                                   ...</a>
<a name="ln6836"> </a>
<a name="ln6837">                                   Max. size = 1 + 3*max_num_t_groups + max_num_endpoints</a>
<a name="ln6838"> </a>
<a name="ln6839">                                   max_num_t_groups  = num_at/2</a>
<a name="ln6840">                                   max_num_endpoints = num_at</a>
<a name="ln6841"> </a>
<a name="ln6842">                                   Max. size = 1 + 3*(num_at/2) + num_at = 1 + (5*num_at)/2</a>
<a name="ln6843">                                   5 = 3 + INCHI_T_NUM_MOVABLE = 3 + num_types_of_attachments</a>
<a name="ln6844"> </a>
<a name="ln6845">                                   This does not include zero termination!</a>
<a name="ln6846">                               </a>
<a name="ln6847">                                */</a>
<a name="ln6848">                                tg_alloc_len = ((3+INCHI_T_NUM_MOVABLE)*pInChI[iComponent].nNumberOfAtoms)/2+1;</a>
<a name="ln6849">                                for ( i = 0; i &lt; mpy_component; i ++ ) {</a>
<a name="ln6850">                                    pInChI[iComponent+i].nTautomer = (AT_NUMB*)inchi_calloc( tg_alloc_len+1, sizeof(pInChI-&gt;nTautomer[0]));</a>
<a name="ln6851">                                    if ( !pInChI[iComponent+i].nTautomer ) {</a>
<a name="ln6852">                                        ret = RI_ERR_ALLOC; /* allocation error */</a>
<a name="ln6853">                                        goto exit_function;</a>
<a name="ln6854">                                    }</a>
<a name="ln6855">                                    pInChI[iComponent+i].lenTautomer = 0;</a>
<a name="ln6856">                                }</a>
<a name="ln6857">                                tg_pos_Tautomer = 1; /* number atoms (NumAt+2) position */</a>
<a name="ln6858">                            } else {</a>
<a name="ln6859">                                /* next t-group */</a>
<a name="ln6860">                                tg_pos_Tautomer = lenTautomer;</a>
<a name="ln6861">                            }</a>
<a name="ln6862">                            if ( tg_pos_Tautomer+3 &gt;= tg_alloc_len ) {</a>
<a name="ln6863">                                ret = RI_ERR_PROGR; /* wrong tautomer array length */</a>
<a name="ln6864">                                goto exit_function;</a>
<a name="ln6865">                            }</a>
<a name="ln6866">                            pInChI[iComponent].nTautomer[tg_pos_Tautomer+1] = num_H;</a>
<a name="ln6867">                            pInChI[iComponent].nTautomer[tg_pos_Tautomer+2] = num_Minus;</a>
<a name="ln6868">                            lenTautomer                = tg_pos_Tautomer+3; /* first atom number position */</a>
<a name="ln6869">                            num_taut_H_component += num_H;</a>
<a name="ln6870">                            state = *p ++;</a>
<a name="ln6871">                            continue;</a>
<a name="ln6872">                        case 'A':  /* previuos was atom number */</a>
<a name="ln6873">                            state = *p ++;</a>
<a name="ln6874">                            continue;</a>
<a name="ln6875">                        default:</a>
<a name="ln6876">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6877">                            goto exit_function;</a>
<a name="ln6878">                        }</a>
<a name="ln6879">                    default:</a>
<a name="ln6880">                        if ( isdigit( UCINT *p ) ) {</a>
<a name="ln6881">                            val = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln6882">                            if ( val &lt;= 0 ) {</a>
<a name="ln6883">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6884">                                goto exit_function;</a>
<a name="ln6885">                            }</a>
<a name="ln6886">                            p = q;</a>
<a name="ln6887">                            switch( state ) {</a>
<a name="ln6888">                            case 'H':</a>
<a name="ln6889">                                num_H = val;</a>
<a name="ln6890">                                state = 'N';</a>
<a name="ln6891">                                continue;</a>
<a name="ln6892">                            case '-':</a>
<a name="ln6893">                                num_Minus = val;</a>
<a name="ln6894">                                state = 'M';</a>
<a name="ln6895">                                continue;</a>
<a name="ln6896">                            case ',':</a>
<a name="ln6897">                                if ( lenTautomer &gt;= tg_alloc_len || val &gt; numCtAtoms ) {</a>
<a name="ln6898">                                    ret = RI_ERR_PROGR; /* wrong tautomer array length */</a>
<a name="ln6899">                                    goto exit_function;</a>
<a name="ln6900">                                }</a>
<a name="ln6901">                                num_Atoms ++;</a>
<a name="ln6902">                                pInChI[iComponent].nTautomer[lenTautomer ++] = val;</a>
<a name="ln6903">                                state = 'A';</a>
<a name="ln6904">                                continue;</a>
<a name="ln6905">                            default:</a>
<a name="ln6906">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6907">                                goto exit_function;</a>
<a name="ln6908"> </a>
<a name="ln6909">                            }</a>
<a name="ln6910">                        }</a>
<a name="ln6911">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6912">                        goto exit_function;</a>
<a name="ln6913">                    }</a>
<a name="ln6914">                }</a>
<a name="ln6915">                if ( !iTGroup || state != ')' ) {</a>
<a name="ln6916">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6917">                    goto exit_function;</a>
<a name="ln6918">                }</a>
<a name="ln6919">                pInChI[iComponent].nTautomer[0] = iTGroup;</a>
<a name="ln6920">            }</a>
<a name="ln6921">        }</a>
<a name="ln6922">        /* check num_H in components; for bMobileH=TAUT_NON, pInChI-&gt;nNum_H_fixed[] has not been added to pInChI-&gt;nNum_H[] yet */</a>
<a name="ln6923">        if ( 0 &gt; ( ret2 = GetInChIFormulaNumH( pInChI+iComponent, &amp;num_H_formula) ) ||</a>
<a name="ln6924">             0 &gt; ( ret2 = GetInChINumH( pInChI+iComponent, &amp;num_H_InChI ) ) ) {</a>
<a name="ln6925">            ret = ret2;</a>
<a name="ln6926">            goto exit_function;</a>
<a name="ln6927">        }</a>
<a name="ln6928">        if ( num_H_formula != num_H_InChI + (bMobileH==TAUT_NON? num_H_component:0) ) {</a>
<a name="ln6929">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6930">            goto exit_function;</a>
<a name="ln6931">        }</a>
<a name="ln6932"> </a>
<a name="ln6933">        /* duplicate according to multipolication */</a>
<a name="ln6934">        for ( i = 1; i &lt; mpy_component; i ++ ) {</a>
<a name="ln6935">            memcpy( nNum_H(iComponent+i), nNum_H(iComponent), pInChI[iComponent+i].nNumberOfAtoms * sizeof(nNum_H(0)[0]) );</a>
<a name="ln6936">            /*</a>
<a name="ln6937">            memcpy( pInChI[iComponent+i].nNum_H, pInChI[iComponent].nNum_H,</a>
<a name="ln6938">                    pInChI[iComponent+i].nNumberOfAtoms * sizeof(pInChI[0].nNum_H[0]) );</a>
<a name="ln6939">            */</a>
<a name="ln6940">            if ( pInChI[iComponent+i].nTautomer &amp;&amp; pInChI[iComponent].nTautomer &amp;&amp; pInChI[iComponent].lenTautomer ) {</a>
<a name="ln6941">                memcpy( pInChI[iComponent+i].nTautomer, pInChI[iComponent].nTautomer,</a>
<a name="ln6942">                        pInChI[iComponent].lenTautomer * sizeof(pInChI[0].nTautomer[0]) );</a>
<a name="ln6943">                pInChI[iComponent+i].lenTautomer = pInChI[iComponent].lenTautomer;</a>
<a name="ln6944">            }</a>
<a name="ln6945">            /* check num_H in components */</a>
<a name="ln6946">            if ( 0 &gt; ( ret2 = GetInChIFormulaNumH( pInChI+iComponent+i, &amp;num_H_formula) ) ||</a>
<a name="ln6947">                 0 &gt; ( ret2 = GetInChINumH( pInChI+iComponent+i, &amp;num_H_InChI ) ) ) {</a>
<a name="ln6948">                ret = ret2;</a>
<a name="ln6949">                goto exit_function;</a>
<a name="ln6950">            }</a>
<a name="ln6951">            if ( num_H_formula != num_H_InChI + (bMobileH==TAUT_NON? num_H_component:0) ) {</a>
<a name="ln6952">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6953">                goto exit_function;</a>
<a name="ln6954">            }</a>
<a name="ln6955">        }</a>
<a name="ln6956"> </a>
<a name="ln6957">        /* prepare for the next component */</a>
<a name="ln6958">        iComponent += i;</a>
<a name="ln6959">        if ( *pEnd ) {</a>
<a name="ln6960">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln6961">            /* prevent crash on extra trailing ';' */</a>
<a name="ln6962">            if ( iComponent &gt;= nNumComponents ) {</a>
<a name="ln6963">                ret = RI_ERR_SYNTAX; /* syntax error: extra component */</a>
<a name="ln6964">                goto exit_function;</a>
<a name="ln6965">            }</a>
<a name="ln6966">#endif</a>
<a name="ln6967">            pStart = pEnd+1;</a>
<a name="ln6968">        } else</a>
<a name="ln6969">            break;</a>
<a name="ln6970">    }</a>
<a name="ln6971">    if ( nNumComponents != iComponent ) {</a>
<a name="ln6972">        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln6973">        goto exit_function;</a>
<a name="ln6974">    }</a>
<a name="ln6975">    ret = iComponent + 1;</a>
<a name="ln6976"> </a>
<a name="ln6977">exit_function:</a>
<a name="ln6978">    INCHI_HEAPCHK</a>
<a name="ln6979">    return ret;   </a>
<a name="ln6980"> </a>
<a name="ln6981">}</a>
<a name="ln6982"> </a>
<a name="ln6983">/****************************************************************************************/</a>
<a name="ln6984">int ParseSegmentConnections( const char *str, int bMobileH, INChI **pInpInChI, int *pnNumComponents, int *pbAbc )</a>
<a name="ln6985">{</a>
<a name="ln6986">#define LAST_AT_LEN 256</a>
<a name="ln6987">    /* Pass 1: count bonds and find actual numbers of  atom */</a>
<a name="ln6988">    int i, j, k, m, c, mpy_component;</a>
<a name="ln6989">    int nNumComponents, iComponent, nNumAtoms, nNumBonds, lenConnTable, iBond;</a>
<a name="ln6990">    const char *p, *q, *pStart, *pEnd;</a>
<a name="ln6991">    AT_NUMB last_atom[LAST_AT_LEN], curAtom, maxAtom;</a>
<a name="ln6992">    int  num_open, state, ret, base;</a>
<a name="ln6993">    INChI *pInChI = *pInpInChI;</a>
<a name="ln6994">    LINKED_BONDS LB;</a>
<a name="ln6995">    LINKED_BONDS *pLB = &amp;LB; /* a list of linked lists of bonds, for each atom */</a>
<a name="ln6996">    AT_NUMB neighbor[MAXVAL];</a>
<a name="ln6997">    int bPrevVersion = -1;</a>
<a name="ln6998">    </a>
<a name="ln6999">    iComponent = 0;</a>
<a name="ln7000">    if ( str[0] != 'c' ) {</a>
<a name="ln7001">        if ( !pInChI &amp;&amp; !*pnNumComponents ) {</a>
<a name="ln7002">            int lenFormula = 1;</a>
<a name="ln7003">            /* component has no formula; allocate InChI */</a>
<a name="ln7004">            lenConnTable   = 0;</a>
<a name="ln7005">            nNumComponents = 1;</a>
<a name="ln7006">            /* allocate InChI */</a>
<a name="ln7007">            if ( !(pInChI = *pInpInChI = (INChI *)inchi_calloc( nNumComponents, sizeof(INChI) ) ) ) {</a>
<a name="ln7008">                return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7009">            }</a>
<a name="ln7010">            /* allocate empty formula */</a>
<a name="ln7011">            pInChI[iComponent].szHillFormula = (char *)inchi_calloc( lenFormula+1, sizeof(pInChI[0].szHillFormula[0]) );</a>
<a name="ln7012">            if ( !pInChI[iComponent].szHillFormula ) {</a>
<a name="ln7013">                ret = RI_ERR_ALLOC; /* allocation failure */</a>
<a name="ln7014">                goto exit_function;</a>
<a name="ln7015">            }</a>
<a name="ln7016">            /* allocate empty connection table */</a>
<a name="ln7017">            pInChI[iComponent].nConnTable = (AT_NUMB *)inchi_calloc( lenConnTable+1, sizeof(pInChI[0].nConnTable[0]) );</a>
<a name="ln7018">            if ( !pInChI[iComponent].nConnTable ) {</a>
<a name="ln7019">                ret = RI_ERR_ALLOC; /* allocation failure */</a>
<a name="ln7020">                goto exit_function;</a>
<a name="ln7021">            }</a>
<a name="ln7022">            pInChI[iComponent].lenConnTable = lenConnTable;</a>
<a name="ln7023">            *pnNumComponents = nNumComponents;</a>
<a name="ln7024">        } else {</a>
<a name="ln7025">            lenConnTable   = 1;</a>
<a name="ln7026">            nNumComponents = *pnNumComponents;</a>
<a name="ln7027">            for ( i = 0; i &lt; nNumComponents; i ++ ) {</a>
<a name="ln7028">                /* allocate 1 atom connection table */</a>
<a name="ln7029">                if ( pInChI[i].nConnTable ) {</a>
<a name="ln7030">                    inchi_free( pInChI[i].nConnTable );</a>
<a name="ln7031">                }</a>
<a name="ln7032">                pInChI[i].nConnTable = (AT_NUMB *)inchi_calloc( lenConnTable+1, sizeof(pInChI[0].nConnTable[0]) );</a>
<a name="ln7033">                if ( !pInChI[i].nConnTable ) {</a>
<a name="ln7034">                    ret = RI_ERR_ALLOC; /* allocation failure */</a>
<a name="ln7035">                    goto exit_function;</a>
<a name="ln7036">                }</a>
<a name="ln7037">                pInChI[i].nConnTable[0] = 1;</a>
<a name="ln7038">                pInChI[i].lenConnTable = lenConnTable;</a>
<a name="ln7039">            }</a>
<a name="ln7040">        }</a>
<a name="ln7041">        return 0;</a>
<a name="ln7042">    }</a>
<a name="ln7043"> </a>
<a name="ln7044">    /* Pass 1. Re-Count atoms, count bonds */</a>
<a name="ln7045">    pStart = str+1;</a>
<a name="ln7046">    nNumComponents = *pnNumComponents;</a>
<a name="ln7047">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln7048">    /* prevent crash on too many components */</a>
<a name="ln7049">    if ( nNumComponents &gt; MAX_ATOMS ) {</a>
<a name="ln7050">        ret = RI_ERR_SYNTAX; /* syntax error: extra component */</a>
<a name="ln7051">        goto exit_function;</a>
<a name="ln7052">    }</a>
<a name="ln7053">#endif</a>
<a name="ln7054">    memset( pLB, 0, sizeof(pLB[0]) );</a>
<a name="ln7055"> </a>
<a name="ln7056">    while( 1 ) {</a>
<a name="ln7057">        /* cycle over components */</a>
<a name="ln7058">        if ( !(pEnd = strchr( pStart, ';' )) ) {</a>
<a name="ln7059">            pEnd = pStart + strlen(pStart);</a>
<a name="ln7060">        }</a>
<a name="ln7061">        if ( (p = strchr(pStart, '*')) &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln7062">            mpy_component = (int)inchi_strtol( pStart, &amp;q, 10 );</a>
<a name="ln7063">            if ( p != q </a>
<a name="ln7064">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln7065">                || !isdigit( UCINT *pStart )</a>
<a name="ln7066">#endif</a>
<a name="ln7067">                ) {</a>
<a name="ln7068">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7069">                goto exit_function;</a>
<a name="ln7070">            }</a>
<a name="ln7071">            p ++;</a>
<a name="ln7072">        } else {</a>
<a name="ln7073">            mpy_component = 1;</a>
<a name="ln7074">            p = pStart;</a>
<a name="ln7075">        }</a>
<a name="ln7076">#if (FIX_DALKE_BUGS == 1)</a>
<a name="ln7077">        if ( iComponent + mpy_component &gt; MAX_ATOMS ) {</a>
<a name="ln7078">            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7079">            goto exit_function;</a>
<a name="ln7080">        }</a>
<a name="ln7081">#endif</a>
<a name="ln7082">        pStart = p;</a>
<a name="ln7083">        /* Pass 1.1 parse a component */</a>
<a name="ln7084">        num_open = 0;</a>
<a name="ln7085">        memset( last_atom, 0, sizeof(last_atom) );</a>
<a name="ln7086">        state='\0';   /* initial state */</a>
<a name="ln7087">        maxAtom = 0;</a>
<a name="ln7088">        nNumBonds = 0;</a>
<a name="ln7089">        curAtom   = 0;</a>
<a name="ln7090">        if ( p &lt; pEnd &amp;&amp; *pbAbc == -1 ) {</a>
<a name="ln7091">            /* check if compressed InChI */</a>
<a name="ln7092">            *pbAbc = isupper( UCINT *p)? 1 : 0;</a>
<a name="ln7093">        }</a>
<a name="ln7094">        base = *pbAbc? ALPHA_BASE : 10;</a>
<a name="ln7095"> </a>
<a name="ln7096">        if ( *pbAbc == 1 ) {</a>
<a name="ln7097">            nNumAtoms = 1;</a>
<a name="ln7098">            while ( p &lt; pEnd ) {</a>
<a name="ln7099">                if ( *p == '-' ) {</a>
<a name="ln7100">                    if ( bPrevVersion == -1 ) {</a>
<a name="ln7101">                        /* previous InChI version */</a>
<a name="ln7102">                        bPrevVersion = 1;</a>
<a name="ln7103">                    } else</a>
<a name="ln7104">                    if ( bPrevVersion != 1 ) {</a>
<a name="ln7105">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7106">                        goto exit_function;</a>
<a name="ln7107">                    }</a>
<a name="ln7108">                    nNumAtoms --;</a>
<a name="ln7109">                    p ++;</a>
<a name="ln7110">                }</a>
<a name="ln7111">                if ( isdigit( UCINT *p ) ) {</a>
<a name="ln7112">                    if ( bPrevVersion == -1 ) {</a>
<a name="ln7113">                        /* curreny InChI, version 1 */</a>
<a name="ln7114">                        bPrevVersion = 0;</a>
<a name="ln7115">                    } else</a>
<a name="ln7116">                    if ( bPrevVersion != 0 ) {</a>
<a name="ln7117">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7118">                        goto exit_function;</a>
<a name="ln7119">                    }</a>
<a name="ln7120">                    nNumAtoms -= inchi_strtol( p, &amp;p, 10 ); /* bypass digits */</a>
<a name="ln7121">                }</a>
<a name="ln7122">                if ( *p != '-' &amp;&amp;  ( curAtom = (AT_NUMB)inchi_strtol( p, &amp;q, base ) ) ) {</a>
<a name="ln7123">                    nNumAtoms ++;</a>
<a name="ln7124">                    nNumBonds ++;</a>
<a name="ln7125">                    p = q;</a>
<a name="ln7126">                    if ( maxAtom &lt; curAtom )</a>
<a name="ln7127">                        maxAtom = curAtom;</a>
<a name="ln7128">                } else {</a>
<a name="ln7129">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7130">                    goto exit_function;</a>
<a name="ln7131">                }</a>
<a name="ln7132">            }</a>
<a name="ln7133">            if ( maxAtom &lt; nNumAtoms &amp;&amp; nNumBonds ) {</a>
<a name="ln7134">                maxAtom = nNumAtoms;</a>
<a name="ln7135">            }</a>
<a name="ln7136">        } else {</a>
<a name="ln7137">            while ( p &lt; pEnd ) {</a>
<a name="ln7138">                /* atom number */</a>
<a name="ln7139">                c = UCINT *p ++;</a>
<a name="ln7140">                switch ( c ) {</a>
<a name="ln7141">                case '(':</a>
<a name="ln7142">                case ')':</a>
<a name="ln7143">                case ',':</a>
<a name="ln7144">                case '-':</a>
<a name="ln7145">                    if ( state != 'N' ) {</a>
<a name="ln7146">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7147">                        goto exit_function;</a>
<a name="ln7148">                    }</a>
<a name="ln7149">                    state = c;</a>
<a name="ln7150">                    num_open += (c=='(') - (c==')');</a>
<a name="ln7151">                    if ( num_open &lt; 0 ) {</a>
<a name="ln7152">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7153">                        goto exit_function;</a>
<a name="ln7154">                    }</a>
<a name="ln7155">                    break;</a>
<a name="ln7156">                default:</a>
<a name="ln7157">                    if ( isdigit( c ) &amp;&amp; (curAtom = (AT_NUMB)inchi_strtol( p-1, &amp;q, 10 )) ) {</a>
<a name="ln7158">                        p = q;</a>
<a name="ln7159">                        switch( state ) {</a>
<a name="ln7160">                        case '(':</a>
<a name="ln7161">                        case ')':</a>
<a name="ln7162">                        case ',':</a>
<a name="ln7163">                        case '-':</a>
<a name="ln7164">                            nNumBonds ++;</a>
<a name="ln7165">                        case '\0':</a>
<a name="ln7166">                            if ( maxAtom &lt; curAtom )</a>
<a name="ln7167">                                maxAtom = curAtom;</a>
<a name="ln7168">                            state = 'N';</a>
<a name="ln7169">                            break;</a>
<a name="ln7170">                        default:</a>
<a name="ln7171">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7172">                            goto exit_function;</a>
<a name="ln7173">                        }</a>
<a name="ln7174">                    } else {</a>
<a name="ln7175">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7176">                        goto exit_function;</a>
<a name="ln7177">                    }</a>
<a name="ln7178">                    break;</a>
<a name="ln7179">                }</a>
<a name="ln7180">            }</a>
<a name="ln7181">            if ( num_open ) {</a>
<a name="ln7182">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7183">                goto exit_function;</a>
<a name="ln7184">                /* syntax error: parentheses do not match */</a>
<a name="ln7185">            }</a>
<a name="ln7186">        }</a>
<a name="ln7187">        /* Save the results and allocate memory */</a>
<a name="ln7188">        nNumAtoms = (int)maxAtom; /* 0 if empty connection table and no bonds present */</a>
<a name="ln7189">        lenConnTable = nNumAtoms + nNumBonds;</a>
<a name="ln7190">        /* connection table format: At1[,Neigh11,Neigh12,...],At2[,Neigh21,Neigh22,...],AtN[NeighN1,NeighN2,...] */</a>
<a name="ln7191">        /* where AtK &gt; NeighK1 &gt; NeighK2,...; At(K) &lt; At(K+1); the length = num.atoms + num.bonds */</a>
<a name="ln7192">        for ( i = 0; i &lt; mpy_component; i ++ ) {</a>
<a name="ln7193">            /* check number of atoms: the difference may be due to bridging H */</a>
<a name="ln7194">            if ( (j = pInChI[iComponent+i].nNumberOfAtoms) &lt; nNumAtoms ) {</a>
<a name="ln7195">                /* reallocate */</a>
<a name="ln7196">                U_CHAR *nAtomTmp = (U_CHAR *) inchi_malloc( nNumAtoms + 1 );</a>
<a name="ln7197">                if ( !nAtomTmp ) {</a>
<a name="ln7198">                    ret = RI_ERR_ALLOC; /* allocation failure */</a>
<a name="ln7199">                    goto exit_function;</a>
<a name="ln7200">                }</a>
<a name="ln7201">                memcpy( nAtomTmp, pInChI[iComponent+i].nAtom, sizeof(nAtomTmp[0])*j);</a>
<a name="ln7202">                while ( j &lt; nNumAtoms ) {</a>
<a name="ln7203">                    nAtomTmp[j ++] = EL_NUMBER_H; /* bridging H */</a>
<a name="ln7204">                }</a>
<a name="ln7205">                nAtomTmp[j] = '\0';</a>
<a name="ln7206">                INCHI_HEAPCHK</a>
<a name="ln7207">                if ( pInChI[iComponent+i].nAtom ) {</a>
<a name="ln7208">                    inchi_free( pInChI[iComponent+i].nAtom );</a>
<a name="ln7209">                }</a>
<a name="ln7210">                pInChI[iComponent+i].nAtom = nAtomTmp;</a>
<a name="ln7211">                pInChI[iComponent+i].nNumberOfAtoms = nNumAtoms;</a>
<a name="ln7212">            } else</a>
<a name="ln7213">            if ( j &gt; nNumAtoms &amp;&amp; (lenConnTable || j != 1) ) {</a>
<a name="ln7214">                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7215">                goto exit_function;</a>
<a name="ln7216">            }</a>
<a name="ln7217">            /* allocate connection table */</a>
<a name="ln7218">            if ( pInChI[iComponent+i].nConnTable ) {</a>
<a name="ln7219">                inchi_free( pInChI[iComponent+i].nConnTable );</a>
<a name="ln7220">            }</a>
<a name="ln7221">            if ( !nNumAtoms &amp;&amp; !nNumBonds &amp;&amp; !lenConnTable ) {</a>
<a name="ln7222">                lenConnTable = 1;  /* one atom, no bonds */</a>
<a name="ln7223">            }</a>
<a name="ln7224">            pInChI[iComponent+i].nConnTable = (AT_NUMB *)inchi_calloc( lenConnTable+1, sizeof(pInChI[0].nConnTable[0]) );</a>
<a name="ln7225">            if ( !pInChI[iComponent+i].nConnTable ) {</a>
<a name="ln7226">                ret = RI_ERR_ALLOC; /* allocation failure */</a>
<a name="ln7227">                goto exit_function;</a>
<a name="ln7228">            }</a>
<a name="ln7229">            pInChI[iComponent+i].lenConnTable = lenConnTable;</a>
<a name="ln7230">        }</a>
<a name="ln7231"> </a>
<a name="ln7232">        /* Pass 1.2 parse a component and extract the bonds */</a>
<a name="ln7233">        num_open = 0;</a>
<a name="ln7234">        memset( last_atom, 0, sizeof(last_atom) );</a>
<a name="ln7235">        state='\0';   /* initial state */</a>
<a name="ln7236">        iBond = 0;</a>
<a name="ln7237">        p = pStart;</a>
<a name="ln7238">        pLB-&gt;len = 0;</a>
<a name="ln7239"> </a>
<a name="ln7240">        if ( *pbAbc == 1 ) {</a>
<a name="ln7241">            /* compressed */</a>
<a name="ln7242">            int num_neigh;</a>
<a name="ln7243">            num_open = 0;</a>
<a name="ln7244">            last_atom[num_open] = 2;</a>
<a name="ln7245">            while ( p &lt; pEnd ) {</a>
<a name="ln7246">                if ( last_atom[num_open] &gt; maxAtom ) {</a>
<a name="ln7247">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7248">                    goto exit_function;</a>
<a name="ln7249">                }</a>
<a name="ln7250">                if ( isupper( UCINT *p ) ) {</a>
<a name="ln7251">                    curAtom = (AT_NUMB)inchi_strtol( p, &amp;q, base );</a>
<a name="ln7252">                    if ( (ret = AddLinkedBond( last_atom[num_open], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7253">                        goto exit_function;</a>
<a name="ln7254">                    }</a>
<a name="ln7255">                    p = q;</a>
<a name="ln7256">                    if ( bPrevVersion == 1 ) {</a>
<a name="ln7257">                        while ( p &lt; pEnd &amp;&amp; *p == '-' ) {</a>
<a name="ln7258">                            p ++;</a>
<a name="ln7259">                            if ( (curAtom = (AT_NUMB)inchi_strtol( p, &amp;q, base )) ) {</a>
<a name="ln7260">                                if ( (ret = AddLinkedBond( last_atom[num_open], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7261">                                    goto exit_function;</a>
<a name="ln7262">                                }</a>
<a name="ln7263">                                p = q;</a>
<a name="ln7264">                            } else {</a>
<a name="ln7265">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7266">                                goto exit_function;</a>
<a name="ln7267">                            }</a>
<a name="ln7268">                        }</a>
<a name="ln7269">                    } else</a>
<a name="ln7270">                    if ( bPrevVersion == 0 &amp;&amp; isdigit( *p ) ) {</a>
<a name="ln7271">                        num_neigh = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln7272">                        p = q;</a>
<a name="ln7273">                        while( num_neigh -- &amp;&amp; p &lt; pEnd ) {</a>
<a name="ln7274">                            if ( (curAtom = (AT_NUMB)inchi_strtol( p, &amp;q, base )) ) {</a>
<a name="ln7275">                                if ( (ret = AddLinkedBond( last_atom[num_open], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7276">                                    goto exit_function;</a>
<a name="ln7277">                                }</a>
<a name="ln7278">                                p = q;</a>
<a name="ln7279">                            } else {</a>
<a name="ln7280">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7281">                                goto exit_function;</a>
<a name="ln7282">                            }</a>
<a name="ln7283">                        }</a>
<a name="ln7284">                    }</a>
<a name="ln7285">                    last_atom[num_open] ++;</a>
<a name="ln7286">                } else {</a>
<a name="ln7287">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7288">                    goto exit_function;</a>
<a name="ln7289">                }</a>
<a name="ln7290">            }</a>
<a name="ln7291">        } else {</a>
<a name="ln7292">            while ( p &lt; pEnd ) {</a>
<a name="ln7293">                /* each atom number except the first means a new bond */</a>
<a name="ln7294">                c = UCINT *p ++;</a>
<a name="ln7295">                switch ( c ) {</a>
<a name="ln7296">                case '(':</a>
<a name="ln7297">                case ')':</a>
<a name="ln7298">                case ',':</a>
<a name="ln7299">                case '-':</a>
<a name="ln7300">                    switch ( state ) {</a>
<a name="ln7301">                    case 'N':</a>
<a name="ln7302">                        state = c;</a>
<a name="ln7303">                        break;</a>
<a name="ln7304">                    default:</a>
<a name="ln7305">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7306">                        goto exit_function;</a>
<a name="ln7307">                    }</a>
<a name="ln7308">                    break;</a>
<a name="ln7309">                default:</a>
<a name="ln7310">                    if ( isdigit( c ) &amp;&amp; (curAtom = (AT_NUMB)inchi_strtol( p-1, &amp;q, 10 )) ) {</a>
<a name="ln7311">                        p = q;</a>
<a name="ln7312">                        switch( state ) {</a>
<a name="ln7313">                        case '\0':</a>
<a name="ln7314">                            last_atom[num_open] = curAtom;</a>
<a name="ln7315">                            state = 'N';</a>
<a name="ln7316">                            break;</a>
<a name="ln7317">                        case '(':</a>
<a name="ln7318">                            if ( (ret = AddLinkedBond( last_atom[num_open], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7319">                                goto exit_function;</a>
<a name="ln7320">                            }</a>
<a name="ln7321">                            if ( ++ num_open &gt;= LAST_AT_LEN ) {</a>
<a name="ln7322">                                ret = RI_ERR_PROGR; /* program error: buffer overflow */</a>
<a name="ln7323">                                goto exit_function;</a>
<a name="ln7324">                            }</a>
<a name="ln7325">                            last_atom[num_open] = curAtom;</a>
<a name="ln7326">                            state = 'N';</a>
<a name="ln7327">                            break;</a>
<a name="ln7328"> </a>
<a name="ln7329">                        case ')':</a>
<a name="ln7330">                            if ( !num_open ) {</a>
<a name="ln7331">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7332">                                goto exit_function;</a>
<a name="ln7333">                            }</a>
<a name="ln7334">                            if ( (ret = AddLinkedBond( last_atom[--num_open], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7335">                                goto exit_function;</a>
<a name="ln7336">                            }</a>
<a name="ln7337">                            last_atom[num_open] = curAtom;</a>
<a name="ln7338">                            state = 'N';</a>
<a name="ln7339">                            break;</a>
<a name="ln7340"> </a>
<a name="ln7341">                        case ',':</a>
<a name="ln7342">                            if ( !num_open ) {</a>
<a name="ln7343">                                ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7344">                                goto exit_function;</a>
<a name="ln7345">                            }</a>
<a name="ln7346">                            if ( (ret = AddLinkedBond( last_atom[num_open-1], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7347">                                goto exit_function;</a>
<a name="ln7348">                            }</a>
<a name="ln7349">                            last_atom[num_open] = curAtom;</a>
<a name="ln7350">                            state = 'N';</a>
<a name="ln7351">                            break;</a>
<a name="ln7352">                        case '-':</a>
<a name="ln7353">                            if ( (ret = AddLinkedBond( last_atom[num_open], curAtom, (AT_NUMB)nNumAtoms, pLB )) ) {</a>
<a name="ln7354">                                goto exit_function;</a>
<a name="ln7355">                            }</a>
<a name="ln7356">                            last_atom[num_open] = curAtom;</a>
<a name="ln7357">                            state = 'N';</a>
<a name="ln7358">                            break;</a>
<a name="ln7359">                        default:</a>
<a name="ln7360">                            ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7361">                            goto exit_function;</a>
<a name="ln7362">                        }</a>
<a name="ln7363">                    } else {</a>
<a name="ln7364">                        ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7365">                        goto exit_function;</a>
<a name="ln7366">                    }</a>
<a name="ln7367">                    break;</a>
<a name="ln7368">                }</a>
<a name="ln7369">            }</a>
<a name="ln7370">        }</a>
<a name="ln7371">        /* store the bonds in connection table */</a>
<a name="ln7372">        if ( lenConnTable &gt; 1 ) {</a>
<a name="ln7373">            for ( i = 0, m = 0; i &lt; nNumAtoms; i ++ ) {</a>
<a name="ln7374">                k = 0;</a>
<a name="ln7375">                if ( (j = pLB-&gt;pBond[i+1].prev) ) {</a>
<a name="ln7376">                    while( k &lt; MAXVAL ) {</a>
<a name="ln7377">                        neighbor[k++] = pLB-&gt;pBond[j].neigh;</a>
<a name="ln7378">                        if ( j == i+1 )</a>
<a name="ln7379">                            break;</a>
<a name="ln7380">                        j = pLB-&gt;pBond[j].prev;</a>
<a name="ln7381">                    }</a>
<a name="ln7382">                }</a>
<a name="ln7383">                if ( j != i+1 ) {</a>
<a name="ln7384">                    ret = RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7385">                    goto exit_function;</a>
<a name="ln7386">                }</a>
<a name="ln7387">                /* sort the neighbors */</a>
<a name="ln7388">                insertions_sort_AT_NUMB( neighbor, k );</a>
<a name="ln7389">                pInChI[iComponent].nConnTable[m ++] = i+1; /* atom number */</a>
<a name="ln7390">                for ( j = 0; j &lt; k &amp;&amp; (int)neighbor[j] &lt;= i; j ++ ) {</a>
<a name="ln7391">                    pInChI[iComponent].nConnTable[m ++] = neighbor[j];</a>
<a name="ln7392">                }</a>
<a name="ln7393">            }</a>
<a name="ln7394">            if ( m != lenConnTable ) {</a>
<a name="ln7395">                ret = RI_ERR_PROGR; /* program error */</a>
<a name="ln7396">                goto exit_function;</a>
<a name="ln7397">            }</a>
<a name="ln7398">        } else {</a>
<a name="ln7399">            pInChI[iComponent].nConnTable[0] = 1; /* single atom */</a>
<a name="ln7400">        }</a>
<a name="ln7401">        /* duplicate if needed */</a>
<a name="ln7402">        for ( i = 1; i &lt; mpy_component; i ++ ) {</a>
<a name="ln7403">            /*</a>
<a name="ln7404">            if ( pInChI[iComponent+i].nConnTable ) {</a>
<a name="ln7405">                inchi_free( pInChI[iComponent+i].nConnTable );</a>
<a name="ln7406">            }</a>
<a name="ln7407">            pInChI[iComponent+i].nConnTable = (AT_NUMB *)inchi_calloc( lenConnTable+1, sizeof(pInChI[0].nConnTable[0]) );</a>
<a name="ln7408">            if ( !pInChI[iComponent+i].nConnTable ) {</a>
<a name="ln7409">                ret = RI_ERR_ALLOC;</a>
<a name="ln7410">                goto exit_function;</a>
<a name="ln7411">            }</a>
<a name="ln7412">            */</a>
<a name="ln7413">            if ( !pInChI[iComponent+i].nConnTable || pInChI[iComponent+i].lenConnTable != lenConnTable ) {</a>
<a name="ln7414">                ret = RI_ERR_PROGR;</a>
<a name="ln7415">                goto exit_function;</a>
<a name="ln7416">            }</a>
<a name="ln7417">            memcpy ( pInChI[iComponent+i].nConnTable, pInChI[iComponent].nConnTable, lenConnTable*sizeof(pInChI[0].nConnTable[0]));</a>
<a name="ln7418">        }</a>
<a name="ln7419">        /* prepare for the next connection table */</a>
<a name="ln7420">        iComponent += i;</a>
<a name="ln7421">        if ( *pEnd )</a>
<a name="ln7422">            pStart = pEnd+1;</a>
<a name="ln7423">        else</a>
<a name="ln7424">            break;</a>
<a name="ln7425"> </a>
<a name="ln7426">    }</a>
<a name="ln7427">    ret = iComponent;</a>
<a name="ln7428"> </a>
<a name="ln7429">exit_function:</a>
<a name="ln7430">    if ( pLB-&gt;pBond ) {</a>
<a name="ln7431">        INCHI_HEAPCHK</a>
<a name="ln7432">        inchi_free( pLB-&gt;pBond ); </a>
<a name="ln7433">    }</a>
<a name="ln7434">    return ret;   </a>
<a name="ln7435"> </a>
<a name="ln7436">#undef LAST_AT_LEN</a>
<a name="ln7437">}</a>
<a name="ln7438">/****************************************************************************************/</a>
<a name="ln7439">int nFillOutProtonMobileH( INChI *pInChI )</a>
<a name="ln7440">{</a>
<a name="ln7441">    int len = 1;</a>
<a name="ln7442">    pInChI-&gt;bDeleted = 1;</a>
<a name="ln7443">    /* formula */</a>
<a name="ln7444">    if ( !pInChI-&gt;szHillFormula &amp;&amp; </a>
<a name="ln7445">         !( pInChI-&gt;szHillFormula = (char *) inchi_calloc( len+1, sizeof(pInChI-&gt;szHillFormula[0]) ) ) ) {</a>
<a name="ln7446">        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7447">    }</a>
<a name="ln7448">    strcpy( pInChI-&gt;szHillFormula, &quot;H&quot; );</a>
<a name="ln7449">    pInChI-&gt;nNumberOfAtoms = 1;</a>
<a name="ln7450"> </a>
<a name="ln7451">    /* atoms */</a>
<a name="ln7452">    if ( !pInChI-&gt;nAtom &amp;&amp;</a>
<a name="ln7453">         !(pInChI-&gt;nAtom = (U_CHAR *) inchi_calloc( len+1, sizeof(pInChI-&gt;nAtom[0]) ) ) ) {</a>
<a name="ln7454">        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7455">    }</a>
<a name="ln7456">    pInChI-&gt;nAtom[0] = 1;</a>
<a name="ln7457">    /* charge */</a>
<a name="ln7458">    pInChI-&gt;nTotalCharge = 1;</a>
<a name="ln7459">    /* connection table */</a>
<a name="ln7460">    if ( !pInChI-&gt;nConnTable &amp;&amp;</a>
<a name="ln7461">         !(pInChI-&gt;nConnTable = (AT_NUMB *) inchi_calloc( len+1, sizeof(pInChI-&gt;nConnTable[0]) ) ) ) {</a>
<a name="ln7462">        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7463">    }</a>
<a name="ln7464">    pInChI-&gt;nConnTable[0] = 1;</a>
<a name="ln7465">    pInChI-&gt;lenConnTable  = len;</a>
<a name="ln7466">    /* tautomer */</a>
<a name="ln7467">    if ( !pInChI-&gt;nTautomer &amp;&amp;</a>
<a name="ln7468">         !(pInChI-&gt;nTautomer = (AT_NUMB *) inchi_calloc( len+1, sizeof(pInChI-&gt;nTautomer[0]) ) ) ) {</a>
<a name="ln7469">        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7470">    }</a>
<a name="ln7471">    /* nNum_H */</a>
<a name="ln7472">    if ( !pInChI-&gt;nNum_H &amp;&amp;</a>
<a name="ln7473">         !(pInChI-&gt;nNum_H = (S_CHAR *) inchi_calloc( len+1, sizeof(pInChI-&gt;nNum_H[0]) ) ) ) {</a>
<a name="ln7474">        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7475">    }</a>
<a name="ln7476">    pInChI-&gt;nNum_H[0] = 0;</a>
<a name="ln7477"> </a>
<a name="ln7478">    pInChI-&gt;nTautomer[0] = 0;</a>
<a name="ln7479">    pInChI-&gt;lenTautomer  = 1;</a>
<a name="ln7480">    return 0;</a>
<a name="ln7481">}</a>
<a name="ln7482">/****************************************************************************************/</a>
<a name="ln7483">int nProtonCopyIsotopicInfo( INChI *pInChI_to, INChI *pInChI_from )</a>
<a name="ln7484">{</a>
<a name="ln7485">    if ( pInChI_from-&gt;nNumberOfIsotopicAtoms ) {</a>
<a name="ln7486">        if ( pInChI_to-&gt;nNumberOfIsotopicAtoms &amp;&amp;</a>
<a name="ln7487">             pInChI_from-&gt;nNumberOfIsotopicAtoms &gt; pInChI_to-&gt;nNumberOfIsotopicAtoms ) {</a>
<a name="ln7488"> </a>
<a name="ln7489">            inchi_free( pInChI_to-&gt;IsotopicAtom );</a>
<a name="ln7490">            pInChI_to-&gt;IsotopicAtom = NULL;</a>
<a name="ln7491">            pInChI_to-&gt;nNumberOfIsotopicAtoms = 0;</a>
<a name="ln7492">        }</a>
<a name="ln7493">        if ( !pInChI_to-&gt;IsotopicAtom &amp;&amp;</a>
<a name="ln7494">             !(pInChI_to-&gt;IsotopicAtom = </a>
<a name="ln7495">                (INChI_IsotopicAtom *)inchi_calloc(pInChI_from-&gt;nNumberOfIsotopicAtoms, </a>
<a name="ln7496">                                                sizeof(pInChI_to-&gt;IsotopicAtom[0]) ) ) ) {</a>
<a name="ln7497">            return RI_ERR_ALLOC;</a>
<a name="ln7498">        }</a>
<a name="ln7499">        pInChI_to-&gt;nNumberOfIsotopicAtoms = pInChI_from-&gt;nNumberOfIsotopicAtoms;</a>
<a name="ln7500">        memcpy( pInChI_to-&gt;IsotopicAtom, pInChI_from-&gt;IsotopicAtom,</a>
<a name="ln7501">                pInChI_from-&gt;nNumberOfIsotopicAtoms * sizeof(pInChI_to-&gt;IsotopicAtom[0]) );</a>
<a name="ln7502">    } else {</a>
<a name="ln7503">        if ( pInChI_to-&gt;IsotopicAtom ) inchi_free( pInChI_to-&gt;IsotopicAtom );</a>
<a name="ln7504">        pInChI_to-&gt;IsotopicAtom = NULL;</a>
<a name="ln7505">        pInChI_to-&gt;nNumberOfIsotopicAtoms = 0;</a>
<a name="ln7506">    }</a>
<a name="ln7507">    return 0;</a>
<a name="ln7508">}</a>
<a name="ln7509">/****************************************************************************************/</a>
<a name="ln7510">int ParseSegmentFormula( const char *str, int bMobileH, INChI *pInpInChI[], int pnNumComponents[] )</a>
<a name="ln7511">{</a>
<a name="ln7512">    int i, j, mpy_component, mpy_atom, len, el_number;</a>
<a name="ln7513">    int nNumComponents = 0, iComponent, nNumAtoms, nNumAtomsAndH, iAtom, nNumH, nAltMobileH = ALT_TAUT(bMobileH);</a>
<a name="ln7514">    const char *p, *q, *e, *pStart, *pEnd;</a>
<a name="ln7515">    INChI *pInChI;</a>
<a name="ln7516">    char szEl[3];</a>
<a name="ln7517"> </a>
<a name="ln7518">    nNumAtoms = -999; /* impossible value */</a>
<a name="ln7519"> </a>
<a name="ln7520">    /* Pass 1. Count components */</a>
<a name="ln7521">    pStart = str;</a>
<a name="ln7522">    while( 1 ) {</a>
<a name="ln7523">        if ( !(pEnd = strchr( pStart, '.' )) ) {</a>
<a name="ln7524">            pEnd = pStart + strlen(pStart);</a>
<a name="ln7525">        }</a>
<a name="ln7526">        p = pStart;</a>
<a name="ln7527">        if ( isdigit( *p ) )  {</a>
<a name="ln7528">            mpy_component = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln7529">            p = q;</a>
<a name="ln7530">        } else {</a>
<a name="ln7531">            mpy_component = 1;</a>
<a name="ln7532">        }</a>
<a name="ln7533">        if ( !mpy_component )</a>
<a name="ln7534">            break;</a>
<a name="ln7535">        if ( !isupper( UCINT *p ) ) {</a>
<a name="ln7536">            break; /* not a formula layer */</a>
<a name="ln7537">        }</a>
<a name="ln7538">        if ( pEnd == p )</a>
<a name="ln7539">            break; /* zero length formula */</a>
<a name="ln7540">        nNumComponents += mpy_component;</a>
<a name="ln7541">        if ( *pEnd )</a>
<a name="ln7542">            pStart = pEnd+1;</a>
<a name="ln7543">        else</a>
<a name="ln7544">            break;</a>
<a name="ln7545">    }</a>
<a name="ln7546">    pnNumComponents[bMobileH] = nNumComponents;</a>
<a name="ln7547"> </a>
<a name="ln7548">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln7549">    if ( nNumComponents &gt; MAX_ATOMS ) {</a>
<a name="ln7550">        return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7551">    }</a>
<a name="ln7552">#endif    </a>
<a name="ln7553">    /* exit or error check */</a>
<a name="ln7554">    if ( !nNumComponents ) {</a>
<a name="ln7555">        if ( !*pStart || islower( UCINT *pStart ) ) {</a>
<a name="ln7556">            INCHI_HEAPCHK</a>
<a name="ln7557">            if ( bMobileH == TAUT_NON &amp;&amp; 0 &lt; ( nNumComponents = pnNumComponents[nAltMobileH]) ) {</a>
<a name="ln7558">                /* allocate InChI */</a>
<a name="ln7559">                if ( !( pInChI = (INChI *)inchi_calloc( nNumComponents, sizeof(INChI) ) ) ) {</a>
<a name="ln7560">                    return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7561">                }</a>
<a name="ln7562">                pInpInChI[bMobileH] = pInChI;</a>
<a name="ln7563">                pnNumComponents[bMobileH] = nNumComponents;</a>
<a name="ln7564">                for ( i = 0; i &lt; nNumComponents; i ++ ) {</a>
<a name="ln7565">                    /* copy number of atoms */</a>
<a name="ln7566">                    len = pInpInChI[bMobileH][i].nNumberOfAtoms = pInpInChI[nAltMobileH][i].nNumberOfAtoms;</a>
<a name="ln7567">                    /* copy atoms */</a>
<a name="ln7568">                    len = (len+1)*sizeof(pInpInChI[0][0].nAtom[0]);</a>
<a name="ln7569">                    if ( pInpInChI[bMobileH][i].nAtom ) {</a>
<a name="ln7570">                        inchi_free( pInpInChI[bMobileH][i].nAtom );</a>
<a name="ln7571">                    }</a>
<a name="ln7572">                    if ( (pInpInChI[bMobileH][i].nAtom = (U_CHAR *) inchi_malloc( (len + 1) * sizeof(pInpInChI[0][0].nAtom[0]) )) ) {</a>
<a name="ln7573">                        memcpy(pInpInChI[bMobileH][i].nAtom, pInpInChI[nAltMobileH][i].nAtom, len);</a>
<a name="ln7574">                        pInpInChI[bMobileH][i].nAtom[len] = 0;</a>
<a name="ln7575">                    } else {</a>
<a name="ln7576">                        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7577">                    }</a>
<a name="ln7578">                    /* copy Hill formula */</a>
<a name="ln7579">                    len = strlen( pInpInChI[nAltMobileH][i].szHillFormula)+1;</a>
<a name="ln7580">                    if ( pInpInChI[bMobileH][i].szHillFormula ) {</a>
<a name="ln7581">                        inchi_free( pInpInChI[bMobileH][i].szHillFormula );</a>
<a name="ln7582">                    }</a>
<a name="ln7583">                    if ( (pInpInChI[bMobileH][i].szHillFormula = (char *) inchi_malloc( inchi_max(len,2) )) ) {</a>
<a name="ln7584">                        memcpy( pInpInChI[bMobileH][i].szHillFormula, pInpInChI[nAltMobileH][i].szHillFormula, len);</a>
<a name="ln7585">                    } else {</a>
<a name="ln7586">                        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7587">                    }</a>
<a name="ln7588">                }</a>
<a name="ln7589"> </a>
<a name="ln7590">            } else</a>
<a name="ln7591">            if ( bMobileH == TAUT_YES ) {</a>
<a name="ln7592">                int ret;</a>
<a name="ln7593">                /* allocate InChI */</a>
<a name="ln7594">                nNumComponents = 1;</a>
<a name="ln7595">                /* InChI */</a>
<a name="ln7596">                pnNumComponents[bMobileH] = nNumComponents;</a>
<a name="ln7597">                if ( !( pInChI = (INChI *)inchi_calloc( nNumComponents, sizeof(INChI) ) ) ) {</a>
<a name="ln7598">                    return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7599">                }</a>
<a name="ln7600">                pInpInChI[bMobileH] = pInChI;</a>
<a name="ln7601">                ret = nFillOutProtonMobileH( pInChI );</a>
<a name="ln7602">                if ( ret &lt; 0 ) {</a>
<a name="ln7603">                    return ret;</a>
<a name="ln7604">                }</a>
<a name="ln7605">            }</a>
<a name="ln7606">            return 0;</a>
<a name="ln7607">        }</a>
<a name="ln7608">        return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7609">    }</a>
<a name="ln7610">    if ( *pEnd ) {</a>
<a name="ln7611">        return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7612">    }</a>
<a name="ln7613"> </a>
<a name="ln7614">    /* allocate InChI */</a>
<a name="ln7615">    if ( !( pInpInChI[bMobileH] = (INChI *)inchi_calloc( nNumComponents, sizeof(INChI) ) ) ) {</a>
<a name="ln7616">        return RI_ERR_ALLOC; /* alloc failure */</a>
<a name="ln7617">    }</a>
<a name="ln7618">    pInChI = pInpInChI[bMobileH];</a>
<a name="ln7619"> </a>
<a name="ln7620">    /* Pass 2. Count elements, save formulas and elements */</a>
<a name="ln7621">    pStart = str;</a>
<a name="ln7622">    iComponent = 0;</a>
<a name="ln7623">    while( 1 ) {</a>
<a name="ln7624">        if ( !(pEnd = strchr( pStart, '.' )) ) {</a>
<a name="ln7625">            pEnd = pStart + strlen(pStart);</a>
<a name="ln7626">        }</a>
<a name="ln7627">        p = pStart;</a>
<a name="ln7628">        if ( isdigit( UCINT *p ) )  {</a>
<a name="ln7629">            mpy_component = (int)inchi_strtol( p, &amp;q, 10 );</a>
<a name="ln7630">            p = q;</a>
<a name="ln7631">        } else {</a>
<a name="ln7632">            mpy_component = 1;</a>
<a name="ln7633">        }</a>
<a name="ln7634">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln7635">        if ( iComponent + mpy_component &gt; MAX_ATOMS ) {</a>
<a name="ln7636">            return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7637">        }</a>
<a name="ln7638">#endif    </a>
<a name="ln7639">        len = pEnd-p;</a>
<a name="ln7640">        for ( i = 0; i &lt; mpy_component; i ++ ) {</a>
<a name="ln7641">            if ( pInChI[iComponent+i].szHillFormula ) {</a>
<a name="ln7642">                inchi_free( pInChI[iComponent+i].szHillFormula );</a>
<a name="ln7643">            }</a>
<a name="ln7644">            pInChI[iComponent+i].szHillFormula = (char*) inchi_malloc( inchi_max(len,1)+1 );</a>
<a name="ln7645">            memcpy( pInChI[iComponent].szHillFormula, p, len );</a>
<a name="ln7646">            pInChI[iComponent+i].szHillFormula[len] = '\0';</a>
<a name="ln7647">            if ( !i ) {</a>
<a name="ln7648">                /* Pass 2.1 Parse formula and count atoms except H */</a>
<a name="ln7649">                nNumAtoms = 0;</a>
<a name="ln7650">                nNumH     = 0;</a>
<a name="ln7651">                nNumAtomsAndH = 0;</a>
<a name="ln7652">                e = pInChI[iComponent].szHillFormula;</a>
<a name="ln7653">                while ( *e ) {</a>
<a name="ln7654">                    if ( !isupper( UCINT *e ) ) {</a>
<a name="ln7655">                        return RI_ERR_SYNTAX;</a>
<a name="ln7656">                    }</a>
<a name="ln7657">                    j = 0;</a>
<a name="ln7658">                    szEl[j ++] = *e ++;</a>
<a name="ln7659">                    if ( *e &amp;&amp; islower( UCINT *e ) )</a>
<a name="ln7660">                        szEl[j ++] = *e ++;</a>
<a name="ln7661">                    szEl[j ++] = '\0';</a>
<a name="ln7662">                    if ( *e &amp;&amp; isdigit( UCINT *e ) ) {</a>
<a name="ln7663">                        mpy_atom = (int)inchi_strtol( e, &amp;q, 10 );</a>
<a name="ln7664">                        e = q;</a>
<a name="ln7665">                    } else {</a>
<a name="ln7666">                        mpy_atom = 1;</a>
<a name="ln7667">                    }</a>
<a name="ln7668">                    if ( !mpy_atom ) {</a>
<a name="ln7669">                        return RI_ERR_SYNTAX;</a>
<a name="ln7670">                    }</a>
<a name="ln7671">                    if ( szEl[0] == 'H' &amp;&amp; !szEl[1] ) {</a>
<a name="ln7672">                        nNumH += mpy_atom;</a>
<a name="ln7673">                        continue; /* ignore H in counting number of atoms */</a>
<a name="ln7674">                    }</a>
<a name="ln7675"> </a>
<a name="ln7676">                    nNumAtoms += mpy_atom;</a>
<a name="ln7677">                }</a>
<a name="ln7678">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln7679">                if ( nNumAtoms &gt; MAX_ATOMS ) {</a>
<a name="ln7680">                    return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7681">                }</a>
<a name="ln7682">#endif    </a>
<a name="ln7683">                nNumAtomsAndH = nNumAtoms? nNumAtoms : (nNumH &gt; 0);</a>
<a name="ln7684">                pInChI[iComponent+i].nNumberOfAtoms = nNumAtomsAndH;</a>
<a name="ln7685">                if ( pInChI[iComponent+i].nAtom ) {</a>
<a name="ln7686">                    inchi_free( pInChI[iComponent+i].nAtom );</a>
<a name="ln7687">                }</a>
<a name="ln7688">                pInChI[iComponent+i].nAtom = (U_CHAR *) inchi_malloc((nNumAtomsAndH+1)*sizeof(pInChI[0].nAtom[0]));</a>
<a name="ln7689">                if ( !pInChI[iComponent+i].nAtom )</a>
<a name="ln7690">                    return RI_ERR_ALLOC; /* failed allocation */</a>
<a name="ln7691">                /* Pass 2.2 Store elements; this assumes no bridging H. Bridging H will be found in connection table, /c */</a>
<a name="ln7692">                iAtom = 0;</a>
<a name="ln7693">                if ( nNumAtoms &gt; 0 ) { </a>
<a name="ln7694">                    e = pInChI[iComponent+i].szHillFormula;</a>
<a name="ln7695">                    while ( *e ) {</a>
<a name="ln7696">                        if ( !isupper( UCINT *e ) ) {</a>
<a name="ln7697">                            return RI_ERR_SYNTAX;</a>
<a name="ln7698">                        }</a>
<a name="ln7699">                        j = 0;</a>
<a name="ln7700">                        szEl[j ++] = *e ++;</a>
<a name="ln7701">                        if ( *e &amp;&amp; islower( UCINT *e ) )</a>
<a name="ln7702">                            szEl[j ++] = *e ++;</a>
<a name="ln7703">                        szEl[j ++] = '\0';</a>
<a name="ln7704">                        if ( *e &amp;&amp; isdigit( UCINT *e ) ) {</a>
<a name="ln7705">                            mpy_atom = (int)inchi_strtol( e, &amp;q, 10 );</a>
<a name="ln7706">                            e = q;</a>
<a name="ln7707">                        } else {</a>
<a name="ln7708">                            mpy_atom = 1;</a>
<a name="ln7709">                        }</a>
<a name="ln7710">                        if ( !mpy_atom ) {</a>
<a name="ln7711">                            return RI_ERR_SYNTAX;</a>
<a name="ln7712">                        }</a>
<a name="ln7713">                        if ( szEl[0] == 'H' &amp;&amp; !szEl[1] )</a>
<a name="ln7714">                            continue; /* ignore H */</a>
<a name="ln7715">                        el_number = get_periodic_table_number( szEl );</a>
<a name="ln7716">                        if ( el_number == ERR_ELEM ) {</a>
<a name="ln7717">                            return RI_ERR_SYNTAX; /* wrong element */</a>
<a name="ln7718">                        }</a>
<a name="ln7719">                        while ( mpy_atom -- ) {</a>
<a name="ln7720">                            if ( iAtom &gt;= nNumAtoms ) {</a>
<a name="ln7721">                                return RI_ERR_PROGR; /* program error */</a>
<a name="ln7722">                            }</a>
<a name="ln7723">                            pInChI[iComponent+i].nAtom[iAtom ++] = (U_CHAR)el_number;</a>
<a name="ln7724">                        }</a>
<a name="ln7725">                    }</a>
<a name="ln7726">                } else</a>
<a name="ln7727">                if ( nNumH &gt; 0 ) {</a>
<a name="ln7728">                    pInChI[iComponent+i].nAtom[iAtom ++] = EL_NUMBER_H;</a>
<a name="ln7729">                    nNumAtoms = 1;</a>
<a name="ln7730">                }</a>
<a name="ln7731">                pInChI[iComponent+i].nAtom[iAtom] = '\0';</a>
<a name="ln7732">                if ( nNumAtoms != iAtom ) {</a>
<a name="ln7733">                    return RI_ERR_PROGR; /* program error */</a>
<a name="ln7734">                }</a>
<a name="ln7735">            } else {</a>
<a name="ln7736">                /* Copy duplicated formula */</a>
<a name="ln7737">                strcpy(pInChI[iComponent+i].szHillFormula, pInChI[iComponent].szHillFormula);</a>
<a name="ln7738">                /* Copy atoms in the duplicated formula */</a>
<a name="ln7739">                pInChI[iComponent+i].nNumberOfAtoms = nNumAtoms;</a>
<a name="ln7740">                if ( pInChI[iComponent+i].nAtom ) {</a>
<a name="ln7741">                    inchi_free( pInChI[iComponent+i].nAtom );</a>
<a name="ln7742">                }</a>
<a name="ln7743">                pInChI[iComponent+i].nAtom = (U_CHAR *) inchi_malloc(nNumAtoms+1);</a>
<a name="ln7744">                if ( !pInChI[iComponent+i].nAtom )</a>
<a name="ln7745">                    return RI_ERR_ALLOC; /* failed allocation */</a>
<a name="ln7746">                memcpy( pInChI[iComponent+i].nAtom, pInChI[iComponent].nAtom, nNumAtoms+1 );</a>
<a name="ln7747">            }</a>
<a name="ln7748">        }</a>
<a name="ln7749">        iComponent += i;</a>
<a name="ln7750">        if ( *pEnd ) {</a>
<a name="ln7751">            if ( *pEnd != '.' ) {</a>
<a name="ln7752">                return RI_ERR_SYNTAX; /* syntax error */</a>
<a name="ln7753">            }</a>
<a name="ln7754">            pStart = pEnd+1;</a>
<a name="ln7755">        } else</a>
<a name="ln7756">            break;</a>
<a name="ln7757">    }</a>
<a name="ln7758">                </a>
<a name="ln7759">    if ( iComponent != nNumComponents ) {</a>
<a name="ln7760">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln7761">    }</a>
<a name="ln7762">    if ( bMobileH == TAUT_NON ) {</a>
<a name="ln7763">        /* at this point the exact number of atoms including bridging H is known from TAUT_YES */</a>
<a name="ln7764">        for ( i = 0; i &lt; nNumComponents &amp;&amp; i &lt; pnNumComponents[nAltMobileH]; i ++ ) {</a>
<a name="ln7765">            if ( pInpInChI[bMobileH][i].nNumberOfAtoms &lt; (len=pInpInChI[nAltMobileH][i].nNumberOfAtoms) ) {</a>
<a name="ln7766">                /* there are bridging H in this component */</a>
<a name="ln7767">                if ( pInpInChI[nAltMobileH][i].nAtom ) {</a>
<a name="ln7768">                    U_CHAR *nAtom = (U_CHAR *) inchi_malloc( (len+1) * sizeof(nAtom[0]) );</a>
<a name="ln7769">                    if ( !nAtom ) {</a>
<a name="ln7770">                        return RI_ERR_ALLOC;</a>
<a name="ln7771">                    }</a>
<a name="ln7772">                    memcpy( nAtom, pInpInChI[nAltMobileH][i].nAtom, len*sizeof(nAtom[0]) );</a>
<a name="ln7773">                    nAtom[ len ] = 0;</a>
<a name="ln7774">                    if ( pInpInChI[bMobileH][i].nAtom ) {</a>
<a name="ln7775">                        inchi_free( pInpInChI[bMobileH][i].nAtom );</a>
<a name="ln7776">                    }</a>
<a name="ln7777">                    pInpInChI[bMobileH][i].nAtom = nAtom;</a>
<a name="ln7778">                }</a>
<a name="ln7779">                pInpInChI[bMobileH][i].nNumberOfAtoms = len;</a>
<a name="ln7780">            }</a>
<a name="ln7781">        }</a>
<a name="ln7782">    }</a>
<a name="ln7783"> </a>
<a name="ln7784">    return nNumComponents+1;</a>
<a name="ln7785">}</a>
<a name="ln7786"> </a>
<a name="ln7787">/****************************************************************************************/</a>
<a name="ln7788">int CopySegment( INChI *pInChITo, INChI *pInChIFrom, int SegmentType, int bIsotopicTo, int bIsotopicFrom)</a>
<a name="ln7789">{</a>
<a name="ln7790">    int            ret = RI_ERR_ALLOC;</a>
<a name="ln7791">    int            len;</a>
<a name="ln7792"> </a>
<a name="ln7793"> </a>
<a name="ln7794">    if ( SegmentType==CPY_SP2 ||</a>
<a name="ln7795">         SegmentType==CPY_SP3 ||</a>
<a name="ln7796">         SegmentType==CPY_SP3_M ||</a>
<a name="ln7797">         SegmentType==CPY_SP3_S ) {</a>
<a name="ln7798"> </a>
<a name="ln7799">        INChI_Stereo **pstereoTo = NULL;</a>
<a name="ln7800">        INChI_Stereo *stereoFrom = bIsotopicFrom==1? pInChIFrom-&gt;StereoIsotopic :</a>
<a name="ln7801">                                   bIsotopicFrom==0? pInChIFrom-&gt;Stereo : NULL;</a>
<a name="ln7802">        if ( stereoFrom || bIsotopicFrom &lt; 0 ) {</a>
<a name="ln7803">            if ( SegmentType==CPY_SP2 ) {</a>
<a name="ln7804">                if ( bIsotopicFrom &lt; 0 ||</a>
<a name="ln7805">                     (stereoFrom-&gt;b_parity &amp;&amp;</a>
<a name="ln7806">                     stereoFrom-&gt;nBondAtom1 &amp;&amp;</a>
<a name="ln7807">                     stereoFrom-&gt;nBondAtom2) ) {</a>
<a name="ln7808"> </a>
<a name="ln7809">                    len = (bIsotopicFrom &lt; 0)? 0 : stereoFrom-&gt;nNumberOfStereoBonds;</a>
<a name="ln7810">                    pstereoTo = bIsotopicTo? &amp;pInChITo-&gt;StereoIsotopic : &amp;pInChITo-&gt;Stereo;</a>
<a name="ln7811">                    if ( !pstereoTo[0] ) {</a>
<a name="ln7812">                        if ( !(pstereoTo[0] = (INChI_Stereo *)inchi_calloc( 1, sizeof(**pstereoTo))) ) {</a>
<a name="ln7813">                            goto exit_function;</a>
<a name="ln7814">                        }</a>
<a name="ln7815">                    }</a>
<a name="ln7816">                    if ( pstereoTo[0]-&gt;nNumberOfStereoBonds &gt; 0 || pstereoTo[0]-&gt;b_parity ||</a>
<a name="ln7817">                         pstereoTo[0]-&gt;nBondAtom1 || pstereoTo[0]-&gt;nBondAtom2 ) {</a>
<a name="ln7818">                        ret = RI_ERR_SYNTAX; /* stereo already exists */</a>
<a name="ln7819">                        goto exit_function;</a>
<a name="ln7820">                    }</a>
<a name="ln7821">                    /* allocate sp2 stereo */</a>
<a name="ln7822">                    if ( !(pstereoTo[0]-&gt;b_parity = (S_CHAR *)inchi_calloc( len+1, sizeof(pstereoTo[0]-&gt;b_parity[0]) ) ) ||</a>
<a name="ln7823">                         !(pstereoTo[0]-&gt;nBondAtom1 = (AT_NUMB *)inchi_calloc( len+1, sizeof(pstereoTo[0]-&gt;nBondAtom1[0]) ) ) ||</a>
<a name="ln7824">                         !(pstereoTo[0]-&gt;nBondAtom2 = (AT_NUMB *)inchi_calloc( len+1, sizeof(pstereoTo[0]-&gt;nBondAtom2[0]) ) ) ) {</a>
<a name="ln7825">                        /* cleanup */</a>
<a name="ln7826">                        if ( pstereoTo[0]-&gt;b_parity ) {</a>
<a name="ln7827">                            INCHI_HEAPCHK</a>
<a name="ln7828">                            inchi_free( pstereoTo[0]-&gt;b_parity );</a>
<a name="ln7829">                            pstereoTo[0]-&gt;b_parity = NULL;</a>
<a name="ln7830">                        }</a>
<a name="ln7831">                        if ( pstereoTo[0]-&gt;nBondAtom1 ) {</a>
<a name="ln7832">                            INCHI_HEAPCHK</a>
<a name="ln7833">                            inchi_free( pstereoTo[0]-&gt;nBondAtom1 );</a>
<a name="ln7834">                            pstereoTo[0]-&gt;nBondAtom1 = NULL;</a>
<a name="ln7835">                        }</a>
<a name="ln7836">                        if ( pstereoTo[0]-&gt;nBondAtom2 ) {</a>
<a name="ln7837">                            INCHI_HEAPCHK</a>
<a name="ln7838">                            inchi_free( pstereoTo[0]-&gt;nBondAtom2 );</a>
<a name="ln7839">                            pstereoTo[0]-&gt;nBondAtom2 = NULL;</a>
<a name="ln7840">                        }</a>
<a name="ln7841">                        INCHI_HEAPCHK</a>
<a name="ln7842">                        goto exit_function;</a>
<a name="ln7843">                    }</a>
<a name="ln7844">                    /* copy stereo */</a>
<a name="ln7845">                    if ( bIsotopicFrom &gt;= 0 &amp;&amp; len ) {</a>
<a name="ln7846">                        memcpy( pstereoTo[0]-&gt;b_parity, stereoFrom-&gt;b_parity, (len+1)*sizeof(pstereoTo[0]-&gt;b_parity[0]) );</a>
<a name="ln7847">                        memcpy( pstereoTo[0]-&gt;nBondAtom1, stereoFrom-&gt;nBondAtom1, (len+1)*sizeof(pstereoTo[0]-&gt;nBondAtom1[0]) );</a>
<a name="ln7848">                        memcpy( pstereoTo[0]-&gt;nBondAtom2, stereoFrom-&gt;nBondAtom2, (len+1)*sizeof(pstereoTo[0]-&gt;nBondAtom2[0]) );</a>
<a name="ln7849">                    }</a>
<a name="ln7850">                    pstereoTo[0]-&gt;nNumberOfStereoBonds = len;</a>
<a name="ln7851">                </a>
<a name="ln7852">                    return len+1;</a>
<a name="ln7853">                } else {</a>
<a name="ln7854">                    return 0;</a>
<a name="ln7855">                }</a>
<a name="ln7856">            } else</a>
<a name="ln7857">            if ( SegmentType==CPY_SP3 ) {</a>
<a name="ln7858">                if ( bIsotopicFrom &lt; 0 ||</a>
<a name="ln7859">                     (stereoFrom-&gt;t_parity &amp;&amp;</a>
<a name="ln7860">                     stereoFrom-&gt;nNumber) ) {</a>
<a name="ln7861"> </a>
<a name="ln7862">                    len = (bIsotopicFrom &lt; 0)? 0 : stereoFrom-&gt;nNumberOfStereoCenters;</a>
<a name="ln7863">                    pstereoTo = bIsotopicTo? &amp;pInChITo-&gt;StereoIsotopic : &amp;pInChITo-&gt;Stereo;</a>
<a name="ln7864">                    if ( !pstereoTo[0] ) {</a>
<a name="ln7865">                        if ( !(pstereoTo[0] = (INChI_Stereo *)inchi_calloc( 1, sizeof(**pstereoTo))) ) {</a>
<a name="ln7866">                            goto exit_function;</a>
<a name="ln7867">                        }</a>
<a name="ln7868">                    }</a>
<a name="ln7869">                    if ( pstereoTo[0]-&gt;nNumberOfStereoCenters &gt; 0 || pstereoTo[0]-&gt;t_parity ||</a>
<a name="ln7870">                         pstereoTo[0]-&gt;nNumber ) {</a>
<a name="ln7871">                        ret = RI_ERR_SYNTAX; /* stereo already exists */</a>
<a name="ln7872">                        goto exit_function;</a>
<a name="ln7873">                    }</a>
<a name="ln7874">                    /* allocate sp3 stereo */</a>
<a name="ln7875">                    if ( !(pstereoTo[0]-&gt;t_parity = (S_CHAR *)inchi_calloc( len+1, sizeof(pstereoTo[0]-&gt;b_parity[0]) ) ) ||</a>
<a name="ln7876">                         !(pstereoTo[0]-&gt;nNumber = (AT_NUMB *)inchi_calloc( len+1, sizeof(pstereoTo[0]-&gt;nBondAtom1[0]) ) ) ) {</a>
<a name="ln7877">                        /* cleanup */</a>
<a name="ln7878">                        if ( pstereoTo[0]-&gt;t_parity ) {</a>
<a name="ln7879">                            inchi_free( pstereoTo[0]-&gt;t_parity );</a>
<a name="ln7880">                            pstereoTo[0]-&gt;t_parity = NULL;</a>
<a name="ln7881">                        }</a>
<a name="ln7882">                        if ( pstereoTo[0]-&gt;nNumber ) {</a>
<a name="ln7883">                            inchi_free( pstereoTo[0]-&gt;nNumber );</a>
<a name="ln7884">                            pstereoTo[0]-&gt;nNumber = NULL;</a>
<a name="ln7885">                        }</a>
<a name="ln7886">                        goto exit_function;</a>
<a name="ln7887">                    }</a>
<a name="ln7888">                    /* copy stereo */</a>
<a name="ln7889">                    if ( bIsotopicFrom &gt;= 0 &amp;&amp; len ) {</a>
<a name="ln7890">                    memcpy( pstereoTo[0]-&gt;t_parity, stereoFrom-&gt;t_parity, (len+1)*sizeof(pstereoTo[0]-&gt;t_parity[0]) );</a>
<a name="ln7891">                    memcpy( pstereoTo[0]-&gt;nNumber, stereoFrom-&gt;nNumber, (len+1)*sizeof(pstereoTo[0]-&gt;nNumber[0]) );</a>
<a name="ln7892">                    }</a>
<a name="ln7893">                    pstereoTo[0]-&gt;nNumberOfStereoCenters = len;</a>
<a name="ln7894">                    return len+1;</a>
<a name="ln7895">                } else {</a>
<a name="ln7896">                    return 0;</a>
<a name="ln7897">                }</a>
<a name="ln7898">            } else</a>
<a name="ln7899">            if ( SegmentType==CPY_SP3_M ) {</a>
<a name="ln7900">                pstereoTo = bIsotopicTo? &amp;pInChITo-&gt;StereoIsotopic : &amp;pInChITo-&gt;Stereo;</a>
<a name="ln7901">                if ( !pstereoTo[0] ) {</a>
<a name="ln7902">                    if ( !(pstereoTo[0] = (INChI_Stereo *)inchi_calloc( 1, sizeof(**pstereoTo))) ) {</a>
<a name="ln7903">                        goto exit_function;</a>
<a name="ln7904">                    }</a>
<a name="ln7905">                }</a>
<a name="ln7906">                if ( pstereoTo[0]-&gt;nCompInv2Abs &amp;&amp; NO_VALUE_INT != pstereoTo[0]-&gt;nCompInv2Abs ) {</a>
<a name="ln7907">                    ret = RI_ERR_SYNTAX; /* stereo already exists */</a>
<a name="ln7908">                    goto exit_function;</a>
<a name="ln7909">                }</a>
<a name="ln7910">                if ( bIsotopicFrom &lt; 0 ) {</a>
<a name="ln7911">                    pstereoTo[0]-&gt;nCompInv2Abs = 0;</a>
<a name="ln7912">                } else {</a>
<a name="ln7913">                    pstereoTo[0]-&gt;nCompInv2Abs = stereoFrom-&gt;nCompInv2Abs;</a>
<a name="ln7914">                }</a>
<a name="ln7915">                return 1;</a>
<a name="ln7916">            } else</a>
<a name="ln7917">            /* use bTrivialInv to save /s1, /s2, /s3 */</a>
<a name="ln7918">            if ( SegmentType==CPY_SP3_S ) {</a>
<a name="ln7919">                pstereoTo = bIsotopicFrom? &amp;pInChITo-&gt;StereoIsotopic : &amp;pInChITo-&gt;Stereo;</a>
<a name="ln7920">                if ( !pstereoTo[0] ) {</a>
<a name="ln7921">                    if ( !(pstereoTo[0] = (INChI_Stereo *)inchi_calloc( 1, sizeof(**pstereoTo))) ) {</a>
<a name="ln7922">                        goto exit_function;</a>
<a name="ln7923">                    }</a>
<a name="ln7924">                }</a>
<a name="ln7925">                if ( pstereoTo[0]-&gt;bTrivialInv ) {</a>
<a name="ln7926">                    ret = RI_ERR_SYNTAX; /* stereo already exists */</a>
<a name="ln7927">                    goto exit_function;</a>
<a name="ln7928">                }</a>
<a name="ln7929">                pstereoTo[0]-&gt;bTrivialInv = stereoFrom-&gt;bTrivialInv;</a>
<a name="ln7930">                if ( bIsotopicFrom &lt; 0 ) {</a>
<a name="ln7931">                    pstereoTo[0]-&gt;bTrivialInv = 0;</a>
<a name="ln7932">                } else {</a>
<a name="ln7933">                    pstereoTo[0]-&gt;bTrivialInv =  stereoFrom-&gt;bTrivialInv;</a>
<a name="ln7934">                }</a>
<a name="ln7935">                return 1;</a>
<a name="ln7936">            }</a>
<a name="ln7937">        }</a>
<a name="ln7938">        return 0; /* nothing to copy */</a>
<a name="ln7939">    } else</a>
<a name="ln7940">    if ( SegmentType == CPY_ISO_AT ) {</a>
<a name="ln7941">        int                  nNumberOfIsotopicAtoms = pInChIFrom-&gt;nNumberOfIsotopicAtoms;</a>
<a name="ln7942">        INChI_IsotopicAtom   **pIsotopicAtomTo = NULL;</a>
<a name="ln7943">        INChI_IsotopicAtom    *IsotopicAtomFrom = pInChIFrom-&gt;IsotopicAtom;</a>
<a name="ln7944">        if ( bIsotopicFrom &lt; 0 || IsotopicAtomFrom ) {</a>
<a name="ln7945">            len = (bIsotopicFrom &lt; 0)? 0 : nNumberOfIsotopicAtoms;</a>
<a name="ln7946">            pIsotopicAtomTo = &amp;pInChITo-&gt;IsotopicAtom;</a>
<a name="ln7947">            if ( !*pIsotopicAtomTo ) {</a>
<a name="ln7948">                if ( !( *pIsotopicAtomTo = (INChI_IsotopicAtom *)inchi_calloc( len+1, sizeof(**pIsotopicAtomTo) ) ) ) {</a>
<a name="ln7949">                    goto exit_function;</a>
<a name="ln7950">                }</a>
<a name="ln7951">            }</a>
<a name="ln7952">            if ( pInChITo-&gt;nNumberOfIsotopicAtoms ) {</a>
<a name="ln7953">                ret = RI_ERR_SYNTAX; /* stereo already exists */</a>
<a name="ln7954">                goto exit_function;</a>
<a name="ln7955">            }</a>
<a name="ln7956">            if ( bIsotopicFrom &gt;= 0 &amp;&amp; len ) {</a>
<a name="ln7957">                memcpy( *pIsotopicAtomTo, IsotopicAtomFrom, (len+1)*sizeof(**pIsotopicAtomTo) );</a>
<a name="ln7958">            }</a>
<a name="ln7959">            pInChITo-&gt;nNumberOfIsotopicAtoms = len;</a>
<a name="ln7960">            return len+1;</a>
<a name="ln7961">        }</a>
<a name="ln7962">        return 0;</a>
<a name="ln7963">    }</a>
<a name="ln7964">    ret = RI_ERR_PROGR; /* program error */</a>
<a name="ln7965">exit_function:</a>
<a name="ln7966">    return ret;</a>
<a name="ln7967"> </a>
<a name="ln7968"> </a>
<a name="ln7969">}</a>
<a name="ln7970"> </a>
<a name="ln7971">/**********************************************************************************/</a>
<a name="ln7972">/*  Sort neighbors in ascending order */</a>
<a name="ln7973">int insertions_sort_AT_NUMB( AT_NUMB *base, int num )</a>
<a name="ln7974">{</a>
<a name="ln7975">  AT_NUMB *i, *j, *pk, tmp;</a>
<a name="ln7976">  int  k, num_trans = 0;</a>
<a name="ln7977">  for( k=1, pk = base; k &lt; num; k++, pk ++ ) {</a>
<a name="ln7978">     for( j = (i = pk) + 1, tmp = *j; j &gt; base &amp;&amp; *i &gt; tmp; j=i, i -- ) {</a>
<a name="ln7979">        *j = *i;</a>
<a name="ln7980">        num_trans ++;</a>
<a name="ln7981">     }</a>
<a name="ln7982">     *j = tmp;</a>
<a name="ln7983">  }</a>
<a name="ln7984">  return num_trans;</a>
<a name="ln7985">}</a>
<a name="ln7986"> </a>
<a name="ln7987"> </a>
<a name="ln7988">/* read */</a>
<a name="ln7989"> </a>
<a name="ln7990">int getInChIChar( INCHI_IOSTREAM *pInp )</a>
<a name="ln7991">{</a>
<a name="ln7992">    if (pInp-&gt;type==INCHI_IOSTREAM_STRING)</a>
<a name="ln7993">    {</a>
<a name="ln7994">        /* input from string */</a>
<a name="ln7995">        if ( pInp-&gt;s.nPtr &lt; pInp-&gt;s.nUsedLength ) </a>
<a name="ln7996">            return (int) pInp-&gt;s.pStr[pInp-&gt;s.nPtr++];</a>
<a name="ln7997">        return RI_ERR_EOF;</a>
<a name="ln7998">    }</a>
<a name="ln7999"> </a>
<a name="ln8000">    else</a>
<a name="ln8001">    {</a>
<a name="ln8002">        /* input from plain file */</a>
<a name="ln8003">        int c;</a>
<a name="ln8004">#if ( defined(_MSC_VER)&amp;&amp;defined(_WIN32) || defined(__BORLANDC__)&amp;&amp;defined(__WIN32__) || defined(__GNUC__)&amp;&amp;defined(__MINGW32__)&amp;&amp;defined(_WIN32) )</a>
<a name="ln8005">        do </a>
<a name="ln8006">        {</a>
<a name="ln8007">            c = getc( pInp-&gt;f );</a>
<a name="ln8008">            if ( c == EOF ) </a>
<a name="ln8009">            {</a>
<a name="ln8010">                c = RI_ERR_EOF;</a>
<a name="ln8011">                break;</a>
<a name="ln8012">            }</a>
<a name="ln8013">        } </a>
<a name="ln8014">        while( c == '\r' );</a>
<a name="ln8015">#else</a>
<a name="ln8016">        c = getc( pInp-&gt;f );</a>
<a name="ln8017">        if ( c == EOF ) </a>
<a name="ln8018">        {</a>
<a name="ln8019">            c = RI_ERR_EOF;</a>
<a name="ln8020">        }</a>
<a name="ln8021">#endif</a>
<a name="ln8022">        return c;</a>
<a name="ln8023">    }</a>
<a name="ln8024"> </a>
<a name="ln8025">    </a>
<a name="ln8026">}</a>
<a name="ln8027"> </a>
<a name="ln8028">int AddInChIChar( INCHI_IOSTREAM *pInp, SEGM_LINE *Line, const char *pszToken )</a>
<a name="ln8029">{</a>
<a name="ln8030">    int c = getInChIChar( pInp );</a>
<a name="ln8031">    /*</a>
<a name="ln8032">    while ( c == '\r' ) {</a>
<a name="ln8033">        c = getInChIChar( pInp );</a>
<a name="ln8034">    }</a>
<a name="ln8035">    */</a>
<a name="ln8036">    INCHI_HEAPCHK</a>
<a name="ln8037">    if ( Line-&gt;len + 2 &gt;= Line-&gt;len_alloc ) {</a>
<a name="ln8038">        char *str = (char *) inchi_calloc( Line-&gt;len_alloc + SEGM_LINE_ADD, sizeof(str[0]) );</a>
<a name="ln8039">        INCHI_HEAPCHK</a>
<a name="ln8040">        if ( str ) {</a>
<a name="ln8041">            if ( Line-&gt;len &gt; 0 &amp;&amp; Line-&gt;str ) {</a>
<a name="ln8042">                memcpy( str, Line-&gt;str, sizeof(str[0]) * Line-&gt;len );</a>
<a name="ln8043">                Line-&gt;len_alloc += SEGM_LINE_ADD;</a>
<a name="ln8044">                inchi_free( Line-&gt;str );</a>
<a name="ln8045">                INCHI_HEAPCHK</a>
<a name="ln8046">            } else {</a>
<a name="ln8047">                Line-&gt;len_alloc += SEGM_LINE_ADD;</a>
<a name="ln8048">            }</a>
<a name="ln8049">            Line-&gt;str = str;</a>
<a name="ln8050">        } else {</a>
<a name="ln8051">            c = RI_ERR_ALLOC; /* fatal error */</a>
<a name="ln8052">            goto exit_function;</a>
<a name="ln8053">        }</a>
<a name="ln8054">    }</a>
<a name="ln8055">    INCHI_HEAPCHK</a>
<a name="ln8056">    if ( c &lt; 0 ) {</a>
<a name="ln8057">        Line-&gt;str[Line-&gt;len] = '\0';</a>
<a name="ln8058">        INCHI_HEAPCHK</a>
<a name="ln8059">        c = RI_ERR_SYNTAX; /* fatal error: wrong char */</a>
<a name="ln8060">        goto exit_function;</a>
<a name="ln8061">    }</a>
<a name="ln8062">    if ( c &amp;&amp; strchr( pszToken, c ) ) {</a>
<a name="ln8063">        Line-&gt;str[Line-&gt;len] = '\0';</a>
<a name="ln8064">        INCHI_HEAPCHK</a>
<a name="ln8065">        c = -(c+2);</a>
<a name="ln8066">        goto exit_function;</a>
<a name="ln8067">    } else</a>
<a name="ln8068">    if ( !c &amp;&amp; !Line-&gt;len ) {</a>
<a name="ln8069">        Line-&gt;str[Line-&gt;len] = c;</a>
<a name="ln8070">        INCHI_HEAPCHK</a>
<a name="ln8071">    } else {</a>
<a name="ln8072">        Line-&gt;str[Line-&gt;len ++] = c;</a>
<a name="ln8073">        INCHI_HEAPCHK</a>
<a name="ln8074">    }</a>
<a name="ln8075">exit_function:</a>
<a name="ln8076">    INCHI_HEAPCHK</a>
<a name="ln8077">    return c;</a>
<a name="ln8078">}</a>
<a name="ln8079">int nGetInChISegment( INCHI_IOSTREAM *pInp, SEGM_LINE *Line, const char *pszToken )</a>
<a name="ln8080">{</a>
<a name="ln8081">    int c;</a>
<a name="ln8082">    Line-&gt;len = 0;</a>
<a name="ln8083">    while( 0 &lt; (c = AddInChIChar( pInp, Line, pszToken ) ) )</a>
<a name="ln8084">        ;</a>
<a name="ln8085">    if ( c &lt; - 2 ) {</a>
<a name="ln8086">        c = -(c+2);</a>
<a name="ln8087">    }</a>
<a name="ln8088">    Line-&gt;c = c;</a>
<a name="ln8089">    return c;</a>
<a name="ln8090">}</a>
<a name="ln8091">/********************************************************************************/</a>
<a name="ln8092">/* add one more bond to the linked lists for both neighbors */</a>
<a name="ln8093">int AddLinkedBond( AT_NUMB at1, AT_NUMB at2, AT_NUMB num_at, LINKED_BONDS *pLB )</a>
<a name="ln8094">{</a>
<a name="ln8095">    int nReqLen = inchi_max( 2*num_at+2, pLB-&gt;len + 2 );</a>
<a name="ln8096">    AT_NUMB prev;</a>
<a name="ln8097">    if ( pLB-&gt;len_alloc &lt;= nReqLen ) {</a>
<a name="ln8098">        /*int nNewLen = nReqLen + (nReqLen + LINKED_BOND_ADD - 1)%LINKED_BOND_ADD + LINKED_BOND_ADD;*/</a>
<a name="ln8099">        int nNewLen = nReqLen - nReqLen%LINKED_BOND_ADD + 2*LINKED_BOND_ADD;</a>
<a name="ln8100">        ONE_LINKED_BOND *pBond = (ONE_LINKED_BOND *)inchi_calloc( nNewLen, sizeof(pBond[0]) );</a>
<a name="ln8101">        if ( !pBond )</a>
<a name="ln8102">            return RI_ERR_ALLOC; /* allocation error */</a>
<a name="ln8103">        if ( pLB-&gt;pBond &amp;&amp; pLB-&gt;len ) {</a>
<a name="ln8104">            memcpy( pBond, pLB-&gt;pBond, pLB-&gt;len*sizeof(pBond[0]) );</a>
<a name="ln8105">        }</a>
<a name="ln8106">        if ( pLB-&gt;pBond )</a>
<a name="ln8107">            inchi_free( pLB-&gt;pBond );</a>
<a name="ln8108">        pLB-&gt;pBond = pBond;</a>
<a name="ln8109">        pLB-&gt;len_alloc = nNewLen;</a>
<a name="ln8110">    }</a>
<a name="ln8111">    if ( !pLB-&gt;len ) {</a>
<a name="ln8112">        pLB-&gt;len = num_at+1;</a>
<a name="ln8113">        memset( pLB-&gt;pBond, 0, (num_at+1)*sizeof(pLB-&gt;pBond[0]) );</a>
<a name="ln8114">    }</a>
<a name="ln8115">    </a>
<a name="ln8116">    prev = pLB-&gt;pBond[at1].prev; /* position of the last neighbor of at1 in the pLB-&gt;pBond */</a>
<a name="ln8117">    if ( !prev ) {</a>
<a name="ln8118">        pLB-&gt;pBond[at1].neigh = at2;</a>
<a name="ln8119">        pLB-&gt;pBond[at1].prev  = at1;</a>
<a name="ln8120">    } else {</a>
<a name="ln8121">        pLB-&gt;pBond[pLB-&gt;len].neigh = at2;</a>
<a name="ln8122">        pLB-&gt;pBond[pLB-&gt;len].prev  = prev;</a>
<a name="ln8123">        pLB-&gt;pBond[at1].prev       = pLB-&gt;len ++;</a>
<a name="ln8124">    }</a>
<a name="ln8125">    </a>
<a name="ln8126">    prev = pLB-&gt;pBond[at2].prev; /* position of the last neighbor of at2 in the pLB-&gt;pBond */</a>
<a name="ln8127">    if ( !prev ) {</a>
<a name="ln8128">        pLB-&gt;pBond[at2].neigh = at1;</a>
<a name="ln8129">        pLB-&gt;pBond[at2].prev  = at2;</a>
<a name="ln8130">    } else {</a>
<a name="ln8131">        pLB-&gt;pBond[pLB-&gt;len].neigh = at1;</a>
<a name="ln8132">        pLB-&gt;pBond[pLB-&gt;len].prev  = prev;</a>
<a name="ln8133">        pLB-&gt;pBond[at2].prev       = pLB-&gt;len ++;</a>
<a name="ln8134">    }</a>
<a name="ln8135">    return 0;</a>
<a name="ln8136">}</a>
<a name="ln8137"> </a>
<a name="ln8138">#endif /* READ_INCHI_STRING */</a>

</code></pre>
<div class="balloon" rel="582"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="728"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: ip.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'szCurHdr' is always true.</p></div>
<div class="balloon" rel="1040"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v600/" target="_blank">V600</a> Consider inspecting the condition. The 'szMessage' pointer is always not equal to NULL.</p></div>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pINChI[iINChI][k][j]' pointer was utilized before it was verified against nullptr. Check lines: 1530, 1533.</p></div>
<div class="balloon" rel="1619"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'cur_is_non_taut + cur_is_taut' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v756/" target="_blank">V756</a> The 'j' counter is not used inside a nested loop. Consider inspecting usage of 'k' counter.</p></div>
<div class="balloon" rel="1655"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'cur_is_non_taut + cur_is_taut' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1645"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v756/" target="_blank">V756</a> The 'j' counter is not used inside a nested loop. Consider inspecting usage of 'k' counter.</p></div>
<div class="balloon" rel="1799"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'pInChI' pointer was used unsafely after it was verified against nullptr. Check lines: 1780, 1799.</p></div>
<div class="balloon" rel="1770"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pInChI' pointer was utilized before it was verified against nullptr. Check lines: 1770, 1780.</p></div>
<div class="balloon" rel="1823"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1826"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2339"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'target_stereo_type != 1' is always true.</p></div>
<div class="balloon" rel="2348"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !nFlags.</p></div>
<div class="balloon" rel="2439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pInChI->nConnTable.</p></div>
<div class="balloon" rel="2458"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pInChI->nNum_H.</p></div>
<div class="balloon" rel="2509"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2564"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pInChI->Stereo->nCompInv2Abs == 9999.</p></div>
<div class="balloon" rel="2582"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pInChI->Stereo->nCompInv2Abs == 9999.</p></div>
<div class="balloon" rel="2588"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2590"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pInChI_Alt.</p></div>
<div class="balloon" rel="2563"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The '!s[iINChI][j][0]' condition was already verified in line 2559.</p></div>
<div class="balloon" rel="2607"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2624"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2646"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="2701"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2706"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2798"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 9999 == pInChI->Stereo->nCompInv2Abs.</p></div>
<div class="balloon" rel="2807"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2767"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2841"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="3260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v791/" target="_blank">V791</a> The initial value of the index in the nested loop equals 'iINChI'. Perhaps, 'iINChI + 1' should be used instead.</p></div>
<div class="balloon" rel="3708"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3708, 3714</p></div>
<div class="balloon" rel="3696"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3696, 3702</p></div>
<div class="balloon" rel="3729"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3729, 3735</p></div>
<div class="balloon" rel="3762"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3762, 3768</p></div>
<div class="balloon" rel="3750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3750, 3756</p></div>
<div class="balloon" rel="3795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3795, 3801</p></div>
<div class="balloon" rel="3783"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3783, 3789</p></div>
<div class="balloon" rel="3885"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'pXYZ' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="4051"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pLine->len' variable was assigned the same value.</p></div>
<div class="balloon" rel="4092"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'c == '/'' is always true.</p></div>
<div class="balloon" rel="4201"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 4201, 4236</p></div>
<div class="balloon" rel="4446"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'c == '/'' is always true.</p></div>
<div class="balloon" rel="4330"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pLine->str' pointer was utilized before it was verified against nullptr. Check lines: 4330, 4339.</p></div>
<div class="balloon" rel="5339"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '(A && !B) || (!A && B)' expression is equivalent to the 'bool(A) != bool(B)' expression.</p></div>
<div class="balloon" rel="5740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pStereo[0]->nNumber' is always false.</p></div>
<div class="balloon" rel="6104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pStereo[0]->nBondAtom2' is always false.</p></div>
<div class="balloon" rel="6533"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'p' variable was assigned the same value.</p></div>
<div class="balloon" rel="6571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'p' variable was assigned the same value.</p></div>
<div class="balloon" rel="6598"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1026/" target="_blank">V1026</a> The 'num_H' variable is incremented in the loop. Undefined behavior will occur in case of signed integer overflow.</p></div>
<div class="balloon" rel="7201"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pInChI[iComponent + i].nAtom' pointer was utilized before it was verified against nullptr. Check lines: 7201, 7207.</p></div>
<div class="balloon" rel="7233"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'num_open' variable was assigned the same value.</p></div>
<div class="balloon" rel="7243"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'num_open' variable was assigned the same value.</p></div>
<div class="balloon" rel="7503"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pInChI_to->IsotopicAtom' is always true.</p></div>
<div class="balloon" rel="7645"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 7645, 7644.</p></div>
<div class="balloon" rel="7653"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'e'. Check lines: 7653, 7644.</p></div>
<div class="balloon" rel="7836"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pstereoTo[0]->nBondAtom2' is always false.</p></div>
<div class="balloon" rel="7882"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pstereoTo[0]->nNumber' is always false.</p></div>
<div class="balloon" rel="7933"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pstereoTo[0]->bTrivialInv' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

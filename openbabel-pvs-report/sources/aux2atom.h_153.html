
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>aux2atom.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">/*</a>
<a name="ln41"> The code in this #include file reads InChI AuxInfo</a>
<a name="ln42">*/</a>
<a name="ln43"> </a>
<a name="ln44">/****************************************************************************/</a>
<a name="ln45">#define MIN_BOND_LENGTH   (1.0e-6)</a>
<a name="ln46">#define INCHI_LINE_LEN   512 /*1024*/ /*256*/ </a>
<a name="ln47">#define INCHI_LINE_ADD   384  /*128*/  /*64*/</a>
<a name="ln48">/* Note: (INCHI_LINE_LEN - INCHI_LINE_ADD) &gt; (length of the longest item: szCoord) = 33 */</a>
<a name="ln49">/*****************************************************************************/</a>
<a name="ln50"> </a>
<a name="ln51">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln52"> </a>
<a name="ln53">#define AB_MAX_WELL_DEFINED_PARITY inchi_max(INCHI_PARITY_ODD, INCHI_PARITY_EVEN) /* 1, 2 =&gt; well defined parities, uncluding 'unknown' */</a>
<a name="ln54">#define AB_MIN_WELL_DEFINED_PARITY inchi_min(INCHI_PARITY_ODD, INCHI_PARITY_EVEN) /* min(INCHI_PARITY_ODD, INCHI_PARITY_EVEN) */</a>
<a name="ln55">#define ATOM_PARITY_WELL_DEF(X)     (AB_MIN_WELL_DEFINED_PARITY &lt;= (X) &amp;&amp; (X) &lt;= AB_MAX_WELL_DEFINED_PARITY)</a>
<a name="ln56"> </a>
<a name="ln57">#define inchi_NUMH2(AT,CUR_AT) ((AT[CUR_AT].num_iso_H[0]&gt;0?AT[CUR_AT].num_iso_H[0]:0) +AT[CUR_AT].num_iso_H[1]+AT[CUR_AT].num_iso_H[2]+AT[CUR_AT].num_iso_H[3])</a>
<a name="ln58"> </a>
<a name="ln59">#define SB_PARITY_FLAG  0x38 /* disconnected structure has undef. parity */</a>
<a name="ln60">#define SB_PARITY_SHFT  3</a>
<a name="ln61">#define SB_PARITY_MASK  0x07</a>
<a name="ln62">#define SB_PARITY_1(X) (X &amp; SB_PARITY_MASK)  /* refers to connected structure */</a>
<a name="ln63">#define SB_PARITY_2(X) (((X) &gt;&gt; SB_PARITY_SHFT) &amp; SB_PARITY_MASK) /* refers to connected structure */</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">#endif</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">#ifdef TARGET_API_LIB</a>
<a name="ln75"> </a>
<a name="ln76">void            FreeInchi_Atom( inchi_Atom **at );</a>
<a name="ln77">inchi_Atom     *CreateInchi_Atom( int num_atoms );</a>
<a name="ln78">void            FreeInchi_Input( inchi_Input *inp_at_data );</a>
<a name="ln79">S_SHORT        *is_in_the_slist( S_SHORT *pathAtom, S_SHORT nNextAtom, int nPathLen );</a>
<a name="ln80">int             is_element_a_metal( char szEl[] );</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">#endif</a>
<a name="ln86"> </a>
<a name="ln87">#ifndef TARGET_EXE_USING_API</a>
<a name="ln88"> </a>
<a name="ln89">void            FreeInchi_Stereo0D( inchi_Stereo0D **stereo0D );</a>
<a name="ln90">inchi_Stereo0D *CreateInchi_Stereo0D( int num_stereo0D );</a>
<a name="ln91">int Extract0DParities( inp_ATOM *at, int nNumAtoms, inchi_Stereo0D *stereo0D,</a>
<a name="ln92">                       int num_stereo0D, char *pStrErr, int *err,</a>
<a name="ln93">                       int vABParityUnknown);</a>
<a name="ln94"> </a>
<a name="ln95">#endif</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln99"> </a>
<a name="ln100">/* inchi_fgets */</a>
<a name="ln101"> </a>
<a name="ln102">#endif</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">#ifdef TARGET_API_LIB</a>
<a name="ln106">/******************************************************************************************************/</a>
<a name="ln107">void FreeInchi_Atom( inchi_Atom **at )</a>
<a name="ln108">{</a>
<a name="ln109">    if ( at &amp;&amp; *at ) {</a>
<a name="ln110">        inchi_free( *at );</a>
<a name="ln111">        *at = NULL;</a>
<a name="ln112">    }</a>
<a name="ln113">}</a>
<a name="ln114">/******************************************************************************************************/</a>
<a name="ln115">inchi_Atom *CreateInchi_Atom( int num_atoms )</a>
<a name="ln116">{</a>
<a name="ln117">   inchi_Atom *p = (inchi_Atom* ) inchi_calloc(num_atoms, sizeof(inchi_Atom) );</a>
<a name="ln118">   return p;</a>
<a name="ln119">}</a>
<a name="ln120">/******************************************************************************************************/</a>
<a name="ln121">void FreeInchi_Input( inchi_Input *inp_at_data )</a>
<a name="ln122">{</a>
<a name="ln123">    FreeInchi_Atom( &amp;inp_at_data-&gt;atom );</a>
<a name="ln124">    FreeInchi_Stereo0D( &amp;inp_at_data-&gt;stereo0D );</a>
<a name="ln125">    memset( inp_at_data, 0, sizeof(*inp_at_data) );</a>
<a name="ln126">}</a>
<a name="ln127">/*************************************************************************/</a>
<a name="ln128">S_SHORT *is_in_the_slist( S_SHORT *pathAtom, S_SHORT nNextAtom, int nPathLen )</a>
<a name="ln129">{</a>
<a name="ln130">    for ( ; nPathLen &amp;&amp; *pathAtom != nNextAtom; nPathLen--,  pathAtom++ )</a>
<a name="ln131">        ;</a>
<a name="ln132">    return nPathLen? pathAtom : NULL;</a>
<a name="ln133">}</a>
<a name="ln134">/************************************************/</a>
<a name="ln135">int is_element_a_metal( char szEl[] )</a>
<a name="ln136">{</a>
<a name="ln137">    static const char szMetals[] = &quot;K;V;Y;W;U;&quot;</a>
<a name="ln138">        &quot;Li;Be;Na;Mg;Al;Ca;Sc;Ti;Cr;Mn;Fe;Co;Ni;Cu;Zn;Ga;Rb;Sr;Zr;&quot;</a>
<a name="ln139">        &quot;Nb;Mo;Tc;Ru;Rh;Pd;Ag;Cd;In;Sn;Sb;Cs;Ba;La;Ce;Pr;Nd;Pm;Sm;&quot;</a>
<a name="ln140">        &quot;Eu;Gd;Tb;Dy;Ho;Er;Tm;Yb;Lu;Hf;Ta;Re;Os;Ir;Pt;Au;Hg;Tl;Pb;&quot;</a>
<a name="ln141">        &quot;Bi;Po;Fr;Ra;Ac;Th;Pa;Np;Pu;Am;Cm;Bk;Cf;Es;Fm;Md;No;Lr;Rf;&quot;;</a>
<a name="ln142">    const int len = strlen(szEl);</a>
<a name="ln143">    const char *p;</a>
<a name="ln144"> </a>
<a name="ln145">    if ( 0 &lt; len &amp;&amp; len &lt;= 2 &amp;&amp;</a>
<a name="ln146">         isalpha( UCINT szEl[0] ) &amp;&amp; isupper( szEl[0] ) &amp;&amp;</a>
<a name="ln147">         (p = strstr(szMetals, szEl) ) &amp;&amp; p[len] == ';' ) {</a>
<a name="ln148"> </a>
<a name="ln149">            return 1; /*return AtType_Metal;*/</a>
<a name="ln150">    }</a>
<a name="ln151">    return 0;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">#endif</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157">#ifndef TARGET_EXE_USING_API</a>
<a name="ln158">/******************************************************************************************************/</a>
<a name="ln159">inchi_Stereo0D *CreateInchi_Stereo0D( int num_stereo0D )</a>
<a name="ln160">{</a>
<a name="ln161">   return (inchi_Stereo0D* ) inchi_calloc(num_stereo0D, sizeof(inchi_Stereo0D) );</a>
<a name="ln162">}</a>
<a name="ln163">/******************************************************************************************************/</a>
<a name="ln164">void FreeInchi_Stereo0D( inchi_Stereo0D **stereo0D )</a>
<a name="ln165">{</a>
<a name="ln166">    if ( stereo0D &amp;&amp; *stereo0D ) {</a>
<a name="ln167">        inchi_free( *stereo0D );</a>
<a name="ln168">        *stereo0D = NULL;</a>
<a name="ln169">    }</a>
<a name="ln170">}</a>
<a name="ln171">#endif</a>
<a name="ln172"> </a>
<a name="ln173">#define INPUT_FILE          INCHI_IOSTREAM</a>
<a name="ln174"> </a>
<a name="ln175">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln176"> </a>
<a name="ln177">#ifdef TARGET_API_LIB</a>
<a name="ln178">#define INChITo_Atom        ll_INChIToInchi_Atom</a>
<a name="ln179">#else</a>
<a name="ln180">#define INChITo_Atom        ee_INChIToIbChI_Atom</a>
<a name="ln181">#define FindToken           e_FindToken</a>
<a name="ln182">#define LoadLine            e_LoadLine</a>
<a name="ln183">#endif</a>
<a name="ln184"> </a>
<a name="ln185">#define AT_NUM_BONDS(AT)    (AT).num_bonds</a>
<a name="ln186">#define ATOM_NUMBER         AT_NUM</a>
<a name="ln187">#define IN_NEIGH_LIST       is_in_the_slist</a>
<a name="ln188">/*#define INPUT_FILE          INCHI_IOSTREAM*/</a>
<a name="ln189">#define Create_Atom         CreateInchi_Atom </a>
<a name="ln190">#define AT_BONDS_VAL(AT,I)  AT[I].num_iso_H[0]</a>
<a name="ln191">#define ISOLATED_ATOM       (-15)</a>
<a name="ln192">#define NUM_ISO_Hk(AT,I,K)  AT[I].num_iso_H[K+1]</a>
<a name="ln193">#define IS_METAL_ATOM(AT,I) is_element_a_metal( AT[I].elname )</a>
<a name="ln194"> </a>
<a name="ln195">#else </a>
<a name="ln196"> </a>
<a name="ln197">#define inchi_Atom          inp_ATOM</a>
<a name="ln198">#define AT_NUM_BONDS(AT)    (AT).valence</a>
<a name="ln199">#define ATOM_NUMBER         AT_NUMB</a>
<a name="ln200">#define IN_NEIGH_LIST       is_in_the_list</a>
<a name="ln201">#define inchi_NUMH2(AT,N)   NUMH(AT,N)</a>
<a name="ln202">#define INChITo_Atom        cc_INChIToInpAtom</a>
<a name="ln203">/*#define INPUT_FILE          FILE*/</a>
<a name="ln204">#define Create_Atom         CreateInpAtom </a>
<a name="ln205">#define AT_BONDS_VAL(AT,I)  AT[I].chem_bonds_valence</a>
<a name="ln206">#define ISOLATED_ATOM       15</a>
<a name="ln207">#define NUM_ISO_Hk(AT,I,K)  AT[I].num_iso_H[K]</a>
<a name="ln208">#define IS_METAL_ATOM(AT,I) is_el_a_metal( AT[I].el_number )</a>
<a name="ln209"> </a>
<a name="ln210">#endif</a>
<a name="ln211"> </a>
<a name="ln212">/*****************************************************************************/</a>
<a name="ln213">/* local prototypes */</a>
<a name="ln214">char *FindToken( INCHI_IOSTREAM *inp_molfile, int *bTooLongLine, const char *sToken, int lToken,</a>
<a name="ln215">                        char *szLine, int nLenLine, char *p, int *res );</a>
<a name="ln216">char *LoadLine( INPUT_FILE *inp_molfile, int *bTooLongLine, int *bItemIsOver, char **s,</a>
<a name="ln217">                        char *szLine, int nLenLine, int nMinLen2Load, char *p, int *res ); </a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">int INChITo_Atom(INPUT_FILE *inp_molfile, MOL_COORD **szCoord,</a>
<a name="ln221">                      inchi_Stereo0D **stereo0D, int *num_stereo0D,</a>
<a name="ln222">                      int bDoNotAddH, int vABParityUnknown, INPUT_TYPE nInputType, inchi_Atom **at,</a>
<a name="ln223">                      int max_num_at,</a>
<a name="ln224">                      int *num_dimensions, int *num_bonds, char *pSdfLabel, char *pSdfValue,</a>
<a name="ln225">                      long *Id, INCHI_MODE *pInpAtomFlags, int *err, char *pStrErr );</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln229">/*****************************************************************************/</a>
<a name="ln230">int INChIToInchi_Atom ( INCHI_IOSTREAM *inp_molfile, inchi_Stereo0D **stereo0D, int *num_stereo0D,</a>
<a name="ln231">                      int bDoNotAddH, int vABParityUnknown, INPUT_TYPE nInputType, </a>
<a name="ln232">                      inchi_Atom **at, int max_num_at,</a>
<a name="ln233">                      int *num_dimensions, int *num_bonds, char *pSdfLabel, char *pSdfValue,</a>
<a name="ln234">                      long *Id, INCHI_MODE *pInpAtomFlags, int *err, char *pStrErr );</a>
<a name="ln235"> </a>
<a name="ln236">int INChIToInchi_Atom ( INCHI_IOSTREAM *inp_molfile, inchi_Stereo0D **stereo0D, int *num_stereo0D,</a>
<a name="ln237">                      int bDoNotAddH, int vABParityUnknown, INPUT_TYPE nInputType, </a>
<a name="ln238">                      inchi_Atom **at, int max_num_at,</a>
<a name="ln239">                      int *num_dimensions, int *num_bonds, char *pSdfLabel, char *pSdfValue,</a>
<a name="ln240">                      long *Id, INCHI_MODE *pInpAtomFlags, int *err, char *pStrErr )</a>
<a name="ln241">{</a>
<a name="ln242">    return INChITo_Atom ( inp_molfile, NULL, stereo0D, num_stereo0D,</a>
<a name="ln243">                          bDoNotAddH, vABParityUnknown, nInputType, at, max_num_at,</a>
<a name="ln244">                          num_dimensions, num_bonds, pSdfLabel, pSdfValue,</a>
<a name="ln245">                          Id, pInpAtomFlags, err, pStrErr );</a>
<a name="ln246">}</a>
<a name="ln247">#else</a>
<a name="ln248">int INChIToInpAtom (  INCHI_IOSTREAM *inp_molfile, MOL_COORD **szCoord,</a>
<a name="ln249">                      int bDoNotAddH, int vABParityUnknown,  INPUT_TYPE nInputType, inp_ATOM **at,</a>
<a name="ln250">                      int max_num_at,</a>
<a name="ln251">                      int *num_dimensions, int *num_bonds, char *pSdfLabel, char *pSdfValue,</a>
<a name="ln252">                      long *Id, INCHI_MODE *pInpAtomFlags, int *err, char *pStrErr );</a>
<a name="ln253">int INChIToInpAtom (  INCHI_IOSTREAM *inp_molfile, MOL_COORD **szCoord,</a>
<a name="ln254">                      int bDoNotAddH, int vABParityUnknown, INPUT_TYPE nInputType, inp_ATOM **at,</a>
<a name="ln255">                      int max_num_at,</a>
<a name="ln256">                      int *num_dimensions, int *num_bonds, char *pSdfLabel, char *pSdfValue,</a>
<a name="ln257">                      long *Id, INCHI_MODE *pInpAtomFlags, int *err, char *pStrErr )</a>
<a name="ln258">{</a>
<a name="ln259">    return INChITo_Atom ( inp_molfile, szCoord, NULL, NULL,</a>
<a name="ln260">                          bDoNotAddH, vABParityUnknown, nInputType, at, max_num_at,</a>
<a name="ln261">                          num_dimensions, num_bonds, pSdfLabel, pSdfValue,</a>
<a name="ln262">                          Id, pInpAtomFlags, err, pStrErr );</a>
<a name="ln263">}</a>
<a name="ln264">#endif</a>
<a name="ln265">/*****************************************************************************/</a>
<a name="ln266">char *FindToken( INCHI_IOSTREAM *inp_molfile, int *bTooLongLine, const char *sToken, int lToken,</a>
<a name="ln267">                        char *szLine, int nLenLine, char *p, int *res )</a>
<a name="ln268">{</a>
<a name="ln269">    char *q;</a>
<a name="ln270">    int   res2;</a>
<a name="ln271">                </a>
<a name="ln272">    while ( !(q = strstr( p, sToken ) ) ) {</a>
<a name="ln273">        if ( (q = strrchr( p, '/' )) &amp;&amp; (q + lToken &gt; szLine + *res) ) {</a>
<a name="ln274">            *res -= q - szLine; /* res = the length of the szLine to be left in */</a>
<a name="ln275">            memmove( szLine, q, *res + 1);</a>
<a name="ln276">        } else {</a>
<a name="ln277">            *res = 0;</a>
<a name="ln278">        }</a>
<a name="ln279">        if ( !*bTooLongLine || </a>
<a name="ln280">             0 &gt; (res2 = inchi_ios_getsTab1( szLine + *res, nLenLine - *res - 1,</a>
<a name="ln281">                                       inp_molfile, bTooLongLine ) ) ) {</a>
<a name="ln282">            /* the line is over or end of file */</a>
<a name="ln283">            return NULL;</a>
<a name="ln284">        } else {</a>
<a name="ln285">            *res += res2;</a>
<a name="ln286">            p = szLine;</a>
<a name="ln287">        }</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">    return q + lToken;</a>
<a name="ln291">}</a>
<a name="ln292">/*****************************************************************************/</a>
<a name="ln293">char *LoadLine( INCHI_IOSTREAM *inp_molfile, int *bTooLongLine, int *bItemIsOver, char **s,</a>
<a name="ln294">                        char *szLine, int nLenLine, int nMinLen2Load, char *p, int *res ) </a>
<a name="ln295">{</a>
<a name="ln296">    int pos = p - szLine, res2;</a>
<a name="ln297">    if ( !*bItemIsOver &amp;&amp; nLenLine - (*res - pos) &gt; nMinLen2Load ) {</a>
<a name="ln298">        /* load the next portion if possible */</a>
<a name="ln299">        if ( pos ) {</a>
<a name="ln300">            *res -= pos;</a>
<a name="ln301">            memmove( szLine, p, *res+1 );</a>
<a name="ln302">            p = szLine;</a>
<a name="ln303">            if ( *s ) {</a>
<a name="ln304">                *s -= pos;</a>
<a name="ln305">            }</a>
<a name="ln306">            pos = 0;</a>
<a name="ln307">        }</a>
<a name="ln308">        res2 = inchi_ios_getsTab1( szLine + *res, nLenLine - *res - 1, inp_molfile, bTooLongLine );</a>
<a name="ln309">        if ( res2 &gt; 0 ) {</a>
<a name="ln310">            *bItemIsOver = ( (*s = strchr( p + *res, '/') ) || !*bTooLongLine );</a>
<a name="ln311">            *res += res2;</a>
<a name="ln312">        } else {</a>
<a name="ln313">            *bItemIsOver = 1;</a>
<a name="ln314">        }</a>
<a name="ln315">    }</a>
<a name="ln316">    return p;</a>
<a name="ln317">}</a>
<a name="ln318">/*****************************************************************************/</a>
<a name="ln319">int INChITo_Atom(INCHI_IOSTREAM *inp_molfile, MOL_COORD **szCoord,</a>
<a name="ln320">                      inchi_Stereo0D **stereo0D, int *num_stereo0D,</a>
<a name="ln321">                      int bDoNotAddH, int vABParityUnknown, INPUT_TYPE nInputType, inchi_Atom **at,</a>
<a name="ln322">                      int max_num_at,</a>
<a name="ln323">                      int *num_dimensions, int *num_bonds, char *pSdfLabel, char *pSdfValue,</a>
<a name="ln324">                      long *Id, INCHI_MODE *pInpAtomFlags, int *err, char *pStrErr )</a>
<a name="ln325">{</a>
<a name="ln326">    int      num_atoms = 0, bFindNext = 0, len, bHeaderRead, bItemIsOver, bErrorMsg, bRestoreInfo;</a>
<a name="ln327">    int      bFatal = 0, num_struct = 0;</a>
<a name="ln328">    int      i, k, k2, res, bond_type, bond_stereo1, bond_stereo2, bond_char, neigh, bond_parity, bond_parityNM;</a>
<a name="ln329">    int      bTooLongLine, res2, bTooLongLine2, pos, hlen, hk;</a>
<a name="ln330">    long     longID;</a>
<a name="ln331">    char     szLine[INCHI_LINE_LEN], szNextLine[INCHI_LINE_ADD], *p, *q, *s, parity;</a>
<a name="ln332">    int      b2D=0, b3D=0, b23D, nNumBonds = 0, bNonZeroXYZ, bNonMetal;</a>
<a name="ln333">    int      len_stereo0D = 0, max_len_stereo0D = 0;</a>
<a name="ln334">    inchi_Stereo0D  *atom_stereo0D = NULL;</a>
<a name="ln335">    inchi_Atom      *atom          = NULL;</a>
<a name="ln336">    MOL_COORD       *pszCoord      = NULL;</a>
<a name="ln337">    INCHI_MODE InpAtomFlags = 0; /* 0 or FLAG_INP_AT_NONCHIRAL or FLAG_INP_AT_CHIRAL */</a>
<a name="ln338">    static const char szIsoH[] = &quot;hdt&quot;;</a>
<a name="ln339">    /* plain tags */</a>
<a name="ln340">    static const char sStructHdrPln[]         = &quot;Structure:&quot;;</a>
<a name="ln341">    static const char sStructHdrPlnNoLblVal[] = &quot; is missing&quot;;</a>
<a name="ln342">    static char sStructHdrPlnAuxStart[64] =&quot;&quot;; /*&quot;$1.1Beta/&quot;;*/</a>
<a name="ln343">    static int  lenStructHdrPlnAuxStart = 0;</a>
<a name="ln344">    static const char sStructHdrPlnRevAt[]    = &quot;/rA:&quot;;</a>
<a name="ln345">    static const char sStructHdrPlnRevBn[]    = &quot;/rB:&quot;;</a>
<a name="ln346">    static const char sStructHdrPlnRevXYZ[]   = &quot;/rC:&quot;;</a>
<a name="ln347">    const  char *sToken;</a>
<a name="ln348">    int  lToken;</a>
<a name="ln349">    if ( !lenStructHdrPlnAuxStart ) {</a>
<a name="ln350">        lenStructHdrPlnAuxStart = sprintf( sStructHdrPlnAuxStart, &quot;AuxInfo=&quot; );</a>
<a name="ln351">    }</a>
<a name="ln352"> </a>
<a name="ln353">    if ( at ) {</a>
<a name="ln354">        if ( *at &amp;&amp; max_num_at ) {</a>
<a name="ln355">            memset( *at, 0, max_num_at * sizeof(**at) );</a>
<a name="ln356">        }</a>
<a name="ln357">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln358">        if ( stereo0D &amp;&amp; num_stereo0D ) {</a>
<a name="ln359">            if ( *stereo0D &amp;&amp; *num_stereo0D ) {</a>
<a name="ln360">                max_len_stereo0D = *num_stereo0D;</a>
<a name="ln361">                memset( *stereo0D, 0, max_len_stereo0D * sizeof( **stereo0D ));</a>
<a name="ln362">            } else {</a>
<a name="ln363">                max_len_stereo0D = 0;</a>
<a name="ln364">            }</a>
<a name="ln365">        }</a>
<a name="ln366">#else</a>
<a name="ln367">        if ( szCoord &amp;&amp; *szCoord ) {</a>
<a name="ln368">            inchi_free( *szCoord );</a>
<a name="ln369">            *szCoord = NULL;</a>
<a name="ln370">        }</a>
<a name="ln371">#endif</a>
<a name="ln372">    } else {</a>
<a name="ln373">        bFindNext = 1;</a>
<a name="ln374">    }</a>
<a name="ln375">    bHeaderRead = bErrorMsg = bRestoreInfo = 0;</a>
<a name="ln376">    *num_dimensions = *num_bonds = 0;</a>
<a name="ln377"> </a>
<a name="ln378">    /*************************************************************/</a>
<a name="ln379">    /*   extract reversibility info from plain text INChI format */</a>
<a name="ln380">    /*************************************************************/</a>
<a name="ln381">    if ( nInputType == INPUT_INCHI_PLAIN ) {</a>
<a name="ln382">        bHeaderRead = hk = 0;</a>
<a name="ln383">        while ( 0 &lt; (res = inchi_ios_getsTab( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine ) ) ) {</a>
<a name="ln384"> </a>
<a name="ln385">            /********************* find and interpret structure header ************/</a>
<a name="ln386">            if ( !bTooLongLine &amp;&amp;</a>
<a name="ln387">                 (hlen=sizeof(sStructHdrPln)-1, !memcmp(szLine, sStructHdrPln, hlen)) ) {</a>
<a name="ln388">                p = szLine + hlen;</a>
<a name="ln389">                longID = 0;</a>
<a name="ln390">                num_atoms = 0;</a>
<a name="ln391">                /* structure number */</a>
<a name="ln392">                longID = strtol( p, &amp;q, 10 );</a>
<a name="ln393">                if ( q &amp;&amp; q[0] == '.' &amp;&amp; q[1] == ' ' ) {</a>
<a name="ln394">                    p = q+2;</a>
<a name="ln395">                }</a>
<a name="ln396">                p = p + strspn( p, &quot; \n\r&quot; );</a>
<a name="ln397">                </a>
<a name="ln398">                if ( pSdfLabel ) {</a>
<a name="ln399">                    pSdfLabel[0] = '\0';</a>
<a name="ln400">                }</a>
<a name="ln401">                if ( pSdfValue ) {</a>
<a name="ln402">                    pSdfValue[0] = '\0';</a>
<a name="ln403">                }</a>
<a name="ln404"> </a>
<a name="ln405">                if ( *p ) {</a>
<a name="ln406">                    /* has label name */</a>
<a name="ln407">                    /*p ++;*/</a>
<a name="ln408">                    if ( (q = strchr( p, '=' )) ) {</a>
<a name="ln409">                        /* '=' separates label name from the value */</a>
<a name="ln410">                        len = inchi_min( q-p+1, MAX_SDF_HEADER-1);</a>
<a name="ln411">                        if ( pSdfLabel ) {</a>
<a name="ln412">                            mystrncpy( pSdfLabel, p, len );</a>
<a name="ln413">                            LtrimRtrim( pSdfLabel, &amp;len );</a>
<a name="ln414">                        }</a>
<a name="ln415">                        p = q+1;</a>
<a name="ln416">                        q = p + (int)strlen( p );</a>
<a name="ln417">                        if ( q-p &gt; 0 ) {</a>
<a name="ln418">                            len = inchi_min( q-p+1, MAX_SDF_VALUE-1);</a>
<a name="ln419">                            if ( pSdfValue ) {</a>
<a name="ln420">                                mystrncpy( pSdfValue, p, len );</a>
<a name="ln421">                            }</a>
<a name="ln422">                            p = q;</a>
<a name="ln423">                        }</a>
<a name="ln424"> </a>
<a name="ln425">                    } else</a>
<a name="ln426">                    if ( (q = strstr( p, sStructHdrPlnNoLblVal )) ) {</a>
<a name="ln427">                        len = inchi_min( q-p+1, MAX_SDF_HEADER-1);</a>
<a name="ln428">                        if ( pSdfLabel ) {</a>
<a name="ln429">                            mystrncpy( pSdfLabel, p, len );</a>
<a name="ln430">                        }</a>
<a name="ln431">                        p = q+1;</a>
<a name="ln432">                    }</a>
<a name="ln433">                }</a>
<a name="ln434">                if ( Id )</a>
<a name="ln435">                    *Id = longID;</a>
<a name="ln436"> </a>
<a name="ln437">                bHeaderRead = 1;</a>
<a name="ln438">                bErrorMsg = bRestoreInfo = 0;</a>
<a name="ln439">            } else</a>
<a name="ln440">            if ( !memcmp( szLine, sStructHdrPlnAuxStart, lenStructHdrPlnAuxStart) ) {</a>
<a name="ln441">                /* found the header of the AuxInfo, read AuxInfo head of the line */</a>
<a name="ln442">                if ( !bHeaderRead ) {</a>
<a name="ln443">                    longID = 0;</a>
<a name="ln444">                    if ( Id )</a>
<a name="ln445">                        *Id = longID;</a>
<a name="ln446">                    if ( pSdfLabel ) {</a>
<a name="ln447">                        pSdfLabel[0] = '\0';</a>
<a name="ln448">                    }</a>
<a name="ln449">                    if ( pSdfValue ) {</a>
<a name="ln450">                        pSdfValue[0] = '\0';</a>
<a name="ln451">                    }</a>
<a name="ln452">                }</a>
<a name="ln453">                bHeaderRead = 0;</a>
<a name="ln454">                /* check for empty &quot;AuxInfo=ver//&quot; */</a>
<a name="ln455">                p = strchr( szLine + lenStructHdrPlnAuxStart, '/' );</a>
<a name="ln456">                if ( p &amp;&amp; p[1] == '/' &amp;&amp; (!p[2] || '\n' == p[2]) ) {</a>
<a name="ln457">                    goto bypass_end_of_INChI_plain;</a>
<a name="ln458">                }</a>
<a name="ln459">                /***************** search for atoms block (plain) **********************/</a>
<a name="ln460">                p = szLine;</a>
<a name="ln461">                sToken = sStructHdrPlnRevAt;</a>
<a name="ln462">                lToken = sizeof(sStructHdrPlnRevAt)-1;</a>
<a name="ln463">                /* search for sToken in the line; load next segments of the line if sToken has not found */</a>
<a name="ln464">                p = FindToken( inp_molfile, &amp;bTooLongLine, sToken, lToken,</a>
<a name="ln465">                               szLine, sizeof(szLine), p, &amp;res );</a>
<a name="ln466">                if ( !p ) {</a>
<a name="ln467">                    *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln468">                    num_atoms = INCHI_INP_ERROR_RET;</a>
<a name="ln469">                    MOLFILE_ERR_SET (*err, 0, &quot;Missing atom data&quot;);</a>
<a name="ln470">                    goto bypass_end_of_INChI_plain;</a>
<a name="ln471">                } else {</a>
<a name="ln472">                    /* atoms block started */</a>
<a name="ln473">                    i = 0;</a>
<a name="ln474">                    res2 = bTooLongLine2 = -1;</a>
<a name="ln475">                    bItemIsOver = (s = strchr( p, '/') ) || !bTooLongLine;</a>
<a name="ln476">                    while ( 1 ) {</a>
<a name="ln477">                        p = LoadLine( inp_molfile, &amp;bTooLongLine, &amp;bItemIsOver, &amp;s,</a>
<a name="ln478">                                      szLine, sizeof(szLine), INCHI_LINE_ADD, p, &amp;res );</a>
<a name="ln479">                        if ( !i ) {</a>
<a name="ln480">                            /* allocate atom */</a>
<a name="ln481">                            num_atoms = strtol( p, &amp;q, 10 );</a>
<a name="ln482">                            if ( !num_atoms || !q || !*q ) {</a>
<a name="ln483">                                num_atoms = 0; /* no atom data */</a>
<a name="ln484">                                goto bypass_end_of_INChI_plain;</a>
<a name="ln485">                            }</a>
<a name="ln486">                            p = q;</a>
<a name="ln487">                            /* Molfile chirality flag */</a>
<a name="ln488">                            switch( *p ) {</a>
<a name="ln489">                            case 'c':</a>
<a name="ln490">                                InpAtomFlags |= FLAG_INP_AT_CHIRAL;</a>
<a name="ln491">                                p ++;</a>
<a name="ln492">                                break;</a>
<a name="ln493">                            case 'n':</a>
<a name="ln494">                                InpAtomFlags |= FLAG_INP_AT_NONCHIRAL;</a>
<a name="ln495">                                p ++;</a>
<a name="ln496">                                break;</a>
<a name="ln497">                            }</a>
<a name="ln498">                            if ( at &amp;&amp; *at ) {</a>
<a name="ln499">                                if ( num_atoms &gt; max_num_at ) {</a>
<a name="ln500">                                    inchi_free( *at );</a>
<a name="ln501">                                    *at = NULL;</a>
<a name="ln502">                                } else {</a>
<a name="ln503">                                    memset( *at, 0, max_num_at * sizeof( **at ) );</a>
<a name="ln504">                                    atom = *at;</a>
<a name="ln505">                                }</a>
<a name="ln506">                            }</a>
<a name="ln507">                            if ( !at || !*at ) {</a>
<a name="ln508">                                atom = Create_Atom( num_atoms+1 );</a>
<a name="ln509">                                if ( !atom ) {</a>
<a name="ln510">                                    num_atoms = INCHI_INP_FATAL_RET; /* was -1; error */</a>
<a name="ln511">                                    *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln512">                                    MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln513">                                    goto bypass_end_of_INChI_plain;</a>
<a name="ln514">                                }</a>
<a name="ln515">                            }</a>
<a name="ln516">                            if ( stereo0D &amp;&amp; *stereo0D ) {</a>
<a name="ln517">                                if ( num_atoms &gt; max_len_stereo0D ) {</a>
<a name="ln518">                                    FreeInchi_Stereo0D( stereo0D );</a>
<a name="ln519">                                } else {</a>
<a name="ln520">                                    memset( *stereo0D, 0, max_len_stereo0D * sizeof( **stereo0D ) );</a>
<a name="ln521">                                    atom_stereo0D = *stereo0D;</a>
<a name="ln522">                                }</a>
<a name="ln523">                            }</a>
<a name="ln524">                            if ( !stereo0D || !*stereo0D ) {</a>
<a name="ln525">                                max_len_stereo0D = num_atoms+1;</a>
<a name="ln526">                                atom_stereo0D = CreateInchi_Stereo0D( max_len_stereo0D );</a>
<a name="ln527">                                if ( !atom_stereo0D ) {</a>
<a name="ln528">                                    num_atoms = INCHI_INP_FATAL_RET; /* fatal error: cannot allocate */</a>
<a name="ln529">                                    *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln530">                                    MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln531">                                    goto bypass_end_of_INChI_plain;</a>
<a name="ln532">                                }</a>
<a name="ln533">                            }</a>
<a name="ln534">                        }</a>
<a name="ln535">                        /* element, first char */</a>
<a name="ln536">                        if ( !isalpha( UCINT *p ) || !isupper( UCINT *p ) || i &gt;= num_atoms ) {</a>
<a name="ln537">                            break; /* end of atoms block */</a>
<a name="ln538">                        }</a>
<a name="ln539">                        atom[i].elname[0] = *p ++;</a>
<a name="ln540">                        /* element, second char */</a>
<a name="ln541">                        if ( isalpha( UCINT *p ) &amp;&amp; islower( UCINT *p ) ) {</a>
<a name="ln542">                            atom[i].elname[1] = *p ++;</a>
<a name="ln543">                        }</a>
<a name="ln544">    #if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln545">    #else</a>
<a name="ln546">                        atom[i].el_number = get_periodic_table_number( atom[i].elname );</a>
<a name="ln547">    #endif</a>
<a name="ln548">                        /* bonds' valence + number of non-isotopic H */</a>
<a name="ln549">                        if ( isdigit( UCINT *p ) ) {</a>
<a name="ln550">                            AT_BONDS_VAL(atom,i) = (char)strtol( p, &amp;q, 10 );</a>
<a name="ln551">                            if ( !AT_BONDS_VAL(atom,i) )</a>
<a name="ln552">                                AT_BONDS_VAL(atom,i) = ISOLATED_ATOM; /* same convention as in MOLfile, found zero bonds valence */</a>
<a name="ln553">                            p = q;</a>
<a name="ln554">                        }</a>
<a name="ln555">                        /* charge */</a>
<a name="ln556">                        atom[i].charge = (*p == '+')? 1 : (*p == '-')? -1 : 0;</a>
<a name="ln557">                        if ( atom[i].charge ) {</a>
<a name="ln558">                            p ++;</a>
<a name="ln559">                            if ( isdigit( UCINT *p ) ) {</a>
<a name="ln560">                                atom[i].charge *= (S_CHAR)(strtol( p, &amp;q, 10 ) &amp; CHAR_MASK);</a>
<a name="ln561">                                p = q;</a>
<a name="ln562">                            }</a>
<a name="ln563">                        }</a>
<a name="ln564">                        /* radical */</a>
<a name="ln565">                        if ( *p == '.' ) {</a>
<a name="ln566">                            p ++;</a>
<a name="ln567">                            if ( isdigit( UCINT *p ) ) {</a>
<a name="ln568">                                atom[i].radical = (S_CHAR)strtol( p, &amp;q, 10 );</a>
<a name="ln569">                                p = q;</a>
<a name="ln570">                            }</a>
<a name="ln571">                        }</a>
<a name="ln572">                        /* isotopic mass */</a>
<a name="ln573">                        if ( *p == 'i' ) {</a>
<a name="ln574">                            p ++;</a>
<a name="ln575">                            if ( isdigit( UCINT *p ) ) {</a>
<a name="ln576">                                int mw = strtol( p, &amp;q, 10 );</a>
<a name="ln577">                                p = q;</a>
<a name="ln578">    #if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln579">                                atom[i].isotopic_mass = mw;</a>
<a name="ln580">    #else</a>
<a name="ln581">                                mw -= get_atw_from_elnum( atom[i].el_number );</a>
<a name="ln582">                                if ( mw &gt;= 0 )</a>
<a name="ln583">                                    mw ++;</a>
<a name="ln584">                                atom[i].iso_atw_diff = mw;</a>
<a name="ln585">    #endif</a>
<a name="ln586">                            }</a>
<a name="ln587">                        }</a>
<a name="ln588">                        /* parity */</a>
<a name="ln589">                        switch( *p ) {</a>
<a name="ln590">                        case 'o':</a>
<a name="ln591">                            parity = INCHI_PARITY_ODD;</a>
<a name="ln592">                            p ++;</a>
<a name="ln593">                            break;</a>
<a name="ln594">                        case 'e':</a>
<a name="ln595">                            parity = INCHI_PARITY_EVEN;</a>
<a name="ln596">                            p ++;</a>
<a name="ln597">                            break;</a>
<a name="ln598">                        case 'u':</a>
<a name="ln599">                            parity = INCHI_PARITY_UNKNOWN;</a>
<a name="ln600">                            p ++;</a>
<a name="ln601">                            break;</a>
<a name="ln602">                        case '?':</a>
<a name="ln603">                            parity = INCHI_PARITY_UNDEFINED;</a>
<a name="ln604">                            p ++;</a>
<a name="ln605">                            break;</a>
<a name="ln606">                        default:</a>
<a name="ln607">                            parity = 0;</a>
<a name="ln608">                            break;</a>
<a name="ln609">                        }</a>
<a name="ln610">                        if ( parity ) {</a>
<a name="ln611">                            atom_stereo0D[len_stereo0D].central_atom = i;</a>
<a name="ln612">                            atom_stereo0D[len_stereo0D].parity       = parity;</a>
<a name="ln613">                            atom_stereo0D[len_stereo0D].type         = INCHI_StereoType_Tetrahedral;</a>
<a name="ln614">                            len_stereo0D ++;</a>
<a name="ln615">                        }</a>
<a name="ln616">                        /* isotopic h, d, t */</a>
<a name="ln617">                        for ( k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln618">                            if ( *p == szIsoH[k] ) {</a>
<a name="ln619">                                NUM_ISO_Hk(atom,i,k) = 1;</a>
<a name="ln620">                                p ++;</a>
<a name="ln621">                                if ( isdigit( UCINT *p ) ) {</a>
<a name="ln622">                                    NUM_ISO_Hk(atom,i,k) = (char)strtol( p, &amp;q, 10 );</a>
<a name="ln623">                                    p = q;</a>
<a name="ln624">                                }</a>
<a name="ln625">                            }</a>
<a name="ln626">                        }</a>
<a name="ln627">                        i ++;</a>
<a name="ln628">                    }</a>
<a name="ln629">                    if ( !bItemIsOver || i != num_atoms || (s &amp;&amp; p != s) ) {</a>
<a name="ln630">                        num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln631">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln632">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong number of atoms&quot;);</a>
<a name="ln633">                        goto bypass_end_of_INChI_plain;</a>
<a name="ln634">                    }</a>
<a name="ln635">                }</a>
<a name="ln636">                /***************** search for bonds block (plain) and read it *****************/</a>
<a name="ln637">                /*p = szLine;*/</a>
<a name="ln638">                sToken = sStructHdrPlnRevBn;</a>
<a name="ln639">                lToken = sizeof(sStructHdrPlnRevBn)-1;</a>
<a name="ln640">                /* search for sToken in the line; load next segments of the line if sToken has not found */</a>
<a name="ln641">                p = FindToken( inp_molfile, &amp;bTooLongLine, sToken, lToken,</a>
<a name="ln642">                               szLine, sizeof(szLine), p, &amp;res );</a>
<a name="ln643">                if ( !p ) {</a>
<a name="ln644">                    num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln645">                    *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln646">                    MOLFILE_ERR_SET (*err, 0, &quot;Missing bonds data&quot;);</a>
<a name="ln647">                    goto bypass_end_of_INChI_plain;</a>
<a name="ln648">                } else {</a>
<a name="ln649">                    /* bonds block started */</a>
<a name="ln650">                    i = 1;</a>
<a name="ln651">                    res2 = bTooLongLine2 = -1;</a>
<a name="ln652">                    bItemIsOver = (s = strchr( p, '/') ) || !bTooLongLine;</a>
<a name="ln653">                    if ( 1 == num_atoms ) {</a>
<a name="ln654">                        /* needed because the next '/' may be still out of szLine */</a>
<a name="ln655">                        p = LoadLine( inp_molfile, &amp;bTooLongLine, &amp;bItemIsOver, &amp;s,</a>
<a name="ln656">                                      szLine, sizeof(szLine), INCHI_LINE_ADD, p, &amp;res );</a>
<a name="ln657">                    }</a>
<a name="ln658">                    while ( i &lt; num_atoms ) {</a>
<a name="ln659">                        p = LoadLine( inp_molfile, &amp;bTooLongLine, &amp;bItemIsOver, &amp;s,</a>
<a name="ln660">                                      szLine, sizeof(szLine), INCHI_LINE_ADD, p, &amp;res );</a>
<a name="ln661">                        if ( i &gt;= num_atoms || (s &amp;&amp; p &gt;= s) ) {</a>
<a name="ln662">                            break; /* end of bonds (plain) */</a>
<a name="ln663">                        }</a>
<a name="ln664">                        /* bond, first char */</a>
<a name="ln665">                        if ( *p == ';' ) {</a>
<a name="ln666">                            p ++;</a>
<a name="ln667">                            i ++;</a>
<a name="ln668">                            continue;</a>
<a name="ln669">                        }</a>
<a name="ln670">                        if ( !isalpha( UCINT *p ) ) {</a>
<a name="ln671">                            num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln672">                            *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln673">                            MOLFILE_ERR_SET (*err, 0, &quot;Wrong bonds data&quot;);</a>
<a name="ln674">                            goto bypass_end_of_INChI_plain;</a>
<a name="ln675">                        }</a>
<a name="ln676">                        bond_char = *p ++;</a>
<a name="ln677">                        /* bond parity */</a>
<a name="ln678">                        switch( *p ) {</a>
<a name="ln679">                        case '-':</a>
<a name="ln680">                            bond_parity = INCHI_PARITY_ODD;</a>
<a name="ln681">                            p ++;</a>
<a name="ln682">                            break;</a>
<a name="ln683">                        case '+':</a>
<a name="ln684">                            bond_parity = INCHI_PARITY_EVEN;</a>
<a name="ln685">                            p ++;</a>
<a name="ln686">                            break;</a>
<a name="ln687">                        case 'u':</a>
<a name="ln688">                            bond_parity = INCHI_PARITY_UNKNOWN;</a>
<a name="ln689">                            p ++;</a>
<a name="ln690">                            break;</a>
<a name="ln691">                        case '?':</a>
<a name="ln692">                            bond_parity = INCHI_PARITY_UNDEFINED;</a>
<a name="ln693">                            p ++;</a>
<a name="ln694">                            break;</a>
<a name="ln695">                        default:</a>
<a name="ln696">                            bond_parity = 0;</a>
<a name="ln697">                            break;</a>
<a name="ln698">                        }</a>
<a name="ln699">                        if ( bond_parity ) {</a>
<a name="ln700">                            switch( *p ) {</a>
<a name="ln701">                            case '-':</a>
<a name="ln702">                                bond_parityNM = INCHI_PARITY_ODD;</a>
<a name="ln703">                                p ++;</a>
<a name="ln704">                                break;</a>
<a name="ln705">                            case '+':</a>
<a name="ln706">                                bond_parityNM = INCHI_PARITY_EVEN;</a>
<a name="ln707">                                p ++;</a>
<a name="ln708">                                break;</a>
<a name="ln709">                            case 'u':</a>
<a name="ln710">                                bond_parityNM = INCHI_PARITY_UNKNOWN;</a>
<a name="ln711">                                p ++;</a>
<a name="ln712">                                break;</a>
<a name="ln713">                            case '?':</a>
<a name="ln714">                                bond_parityNM = INCHI_PARITY_UNDEFINED;</a>
<a name="ln715">                                p ++;</a>
<a name="ln716">                                break;</a>
<a name="ln717">                            default:</a>
<a name="ln718">                                bond_parityNM = 0;</a>
<a name="ln719">                                break;</a>
<a name="ln720">                            }</a>
<a name="ln721">                        } else {</a>
<a name="ln722">                            bond_parityNM = 0;</a>
<a name="ln723">                        }</a>
<a name="ln724"> </a>
<a name="ln725">                        /* neighbor of the current atom */</a>
<a name="ln726">                        if ( !isdigit( UCINT *p ) ) {</a>
<a name="ln727">                            num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln728">                            *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln729">                            MOLFILE_ERR_SET (*err, 0, &quot;Wrong bonds data&quot;);</a>
<a name="ln730">                            goto bypass_end_of_INChI_plain;</a>
<a name="ln731">                        }</a>
<a name="ln732">                        neigh = (int)strtol( p, &amp;q, 10 )-1;</a>
<a name="ln733"> </a>
<a name="ln734">                        if ( i &gt;= num_atoms || neigh &gt;= num_atoms ) {</a>
<a name="ln735">                            num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln736">                            *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln737">                            MOLFILE_ERR_SET (*err, 0, &quot;Bond to nonexistent atom&quot;);</a>
<a name="ln738">                            goto bypass_end_of_INChI_plain;</a>
<a name="ln739">                        }</a>
<a name="ln740">                        p = q;</a>
<a name="ln741">                        bond_stereo1 = bond_stereo2 = 0;</a>
<a name="ln742"> </a>
<a name="ln743">                        /* bond type &amp; 2D stereo */</a>
<a name="ln744">                        switch( bond_char ) {</a>
<a name="ln745">                        case 'v':</a>
<a name="ln746">                            bond_type    = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln747">                            bond_stereo1 = INCHI_BOND_STEREO_SINGLE_1EITHER;</a>
<a name="ln748">                            bond_stereo2 = INCHI_BOND_STEREO_SINGLE_2EITHER;</a>
<a name="ln749">                            break;</a>
<a name="ln750">                        case 'V':</a>
<a name="ln751">                            bond_type    = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln752">                            bond_stereo1 = INCHI_BOND_STEREO_SINGLE_2EITHER;</a>
<a name="ln753">                            bond_stereo2 = INCHI_BOND_STEREO_SINGLE_1EITHER;</a>
<a name="ln754">                            break;</a>
<a name="ln755">                        case 'w':</a>
<a name="ln756">                            bond_type    = INCHI_BOND_TYPE_DOUBLE;</a>
<a name="ln757">                            bond_stereo1 = </a>
<a name="ln758">                            bond_stereo2 = INCHI_BOND_STEREO_DOUBLE_EITHER;</a>
<a name="ln759">                            break;</a>
<a name="ln760">                        case 's':</a>
<a name="ln761">                            bond_type    = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln762">                            break;</a>
<a name="ln763">                        case 'd':</a>
<a name="ln764">                            bond_type    = INCHI_BOND_TYPE_DOUBLE;</a>
<a name="ln765">                            break;</a>
<a name="ln766">                        case 't':</a>
<a name="ln767">                            bond_type    = INCHI_BOND_TYPE_TRIPLE;</a>
<a name="ln768">                            break;</a>
<a name="ln769">                        case 'a':</a>
<a name="ln770">                            bond_type    = INCHI_BOND_TYPE_ALTERN;</a>
<a name="ln771">                            break;</a>
<a name="ln772">                        case 'p':</a>
<a name="ln773">                            bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln774">                            bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_1UP;</a>
<a name="ln775">                            bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_2UP;</a>
<a name="ln776">                            break;</a>
<a name="ln777">                        case 'P':</a>
<a name="ln778">                            bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln779">                            bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_2UP;</a>
<a name="ln780">                            bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_1UP;</a>
<a name="ln781">                            break;</a>
<a name="ln782">                        case 'n':</a>
<a name="ln783">                            bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln784">                            bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_1DOWN;</a>
<a name="ln785">                            bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_2DOWN;</a>
<a name="ln786">                            break;</a>
<a name="ln787">                        case 'N':</a>
<a name="ln788">                            bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln789">                            bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_2DOWN;</a>
<a name="ln790">                            bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_1DOWN;</a>
<a name="ln791">                            break;</a>
<a name="ln792">                        default:</a>
<a name="ln793">                            num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln794">                            *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln795">                            MOLFILE_ERR_SET (*err, 0, &quot;Wrong bond type&quot;);</a>
<a name="ln796">                            goto bypass_end_of_INChI_plain;</a>
<a name="ln797">                        }</a>
<a name="ln798">                        k = AT_NUM_BONDS(atom[i]) ++;</a>
<a name="ln799">                        atom[i].bond_type[k]   = bond_type;</a>
<a name="ln800">                        atom[i].bond_stereo[k] = bond_stereo1;</a>
<a name="ln801">                        atom[i].neighbor[k]    = (ATOM_NUMBER)neigh;</a>
<a name="ln802">                        k2 = AT_NUM_BONDS(atom[neigh]) ++;</a>
<a name="ln803">                        atom[neigh].bond_type[k2]   = bond_type;</a>
<a name="ln804">                        atom[neigh].bond_stereo[k2] = bond_stereo2;</a>
<a name="ln805">                        atom[neigh].neighbor[k2]    = (ATOM_NUMBER)i;</a>
<a name="ln806">                        bond_parity |= (bond_parityNM &lt;&lt; SB_PARITY_SHFT);</a>
<a name="ln807"> </a>
<a name="ln808">                        if ( bond_parity ) {</a>
<a name="ln809">                            if ( max_len_stereo0D &lt;= len_stereo0D ) {</a>
<a name="ln810">                                /* realloc atom_Stereo0D */</a>
<a name="ln811">                                inchi_Stereo0D *new_atom_stereo0D = CreateInchi_Stereo0D( max_len_stereo0D+num_atoms );</a>
<a name="ln812">                                if ( !new_atom_stereo0D ) {</a>
<a name="ln813">                                    num_atoms = INCHI_INP_FATAL_RET; /* fatal error: cannot allocate */</a>
<a name="ln814">                                    *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln815">                                    MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln816">                                    goto bypass_end_of_INChI_plain;</a>
<a name="ln817">                                }</a>
<a name="ln818">                                memcpy( new_atom_stereo0D, atom_stereo0D, len_stereo0D * sizeof(*atom_stereo0D) );</a>
<a name="ln819">                                FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln820">                                atom_stereo0D = new_atom_stereo0D;</a>
<a name="ln821">                                max_len_stereo0D += num_atoms;</a>
<a name="ln822">                            }</a>
<a name="ln823">                            /* (a) i may be allene endpoint and     neigh = allene middle point or</a>
<a name="ln824">                               (b) i may be allene middle point and neigh = allene endpoint</a>
<a name="ln825">                               !!!!! CURRENTLY ONLY (b) IS ALLOWED !!!!!</a>
<a name="ln826">                            */</a>
<a name="ln827">                            atom_stereo0D[len_stereo0D].neighbor[1] = neigh; /* neigh &lt; i */</a>
<a name="ln828">                            atom_stereo0D[len_stereo0D].neighbor[2] = i;</a>
<a name="ln829">                            atom_stereo0D[len_stereo0D].parity      = bond_parity;</a>
<a name="ln830">                            atom_stereo0D[len_stereo0D].type        = INCHI_StereoType_DoubleBond; /* incl allenes &amp; cumulenes */</a>
<a name="ln831">                            len_stereo0D ++;</a>
<a name="ln832">                        }</a>
<a name="ln833">                    }</a>
<a name="ln834">                    if ( !bItemIsOver || i != num_atoms || (s &amp;&amp; p != s) ) {</a>
<a name="ln835">                        num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln836">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln837">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong number of bonds&quot;);</a>
<a name="ln838">                        goto bypass_end_of_INChI_plain;</a>
<a name="ln839">                    }</a>
<a name="ln840">                }</a>
<a name="ln841">                /***************** search for coordinates block (plain) **********************/</a>
<a name="ln842">                /*p = szLine;*/</a>
<a name="ln843">                sToken = sStructHdrPlnRevXYZ;</a>
<a name="ln844">                lToken = sizeof(sStructHdrPlnRevXYZ)-1;</a>
<a name="ln845">                /* search for sToken in the line; load next segments of the line if sToken has not found */</a>
<a name="ln846">                p = FindToken( inp_molfile, &amp;bTooLongLine, sToken, lToken,</a>
<a name="ln847">                               szLine, sizeof(szLine), p, &amp;res );</a>
<a name="ln848">                if ( !p ) {</a>
<a name="ln849">                    num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln850">                    *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln851">                    MOLFILE_ERR_SET (*err, 0, &quot;Missing atom coordinates data&quot;);</a>
<a name="ln852">                    goto bypass_end_of_INChI_plain;</a>
<a name="ln853">                } else {</a>
<a name="ln854">                    /* coordinates block started */</a>
<a name="ln855">                    if ( (pszCoord = (MOL_COORD*) inchi_malloc(inchi_max(num_atoms,1) * sizeof(MOL_COORD))) ) {</a>
<a name="ln856">                        memset( pszCoord, ' ', inchi_max(num_atoms,1) * sizeof(MOL_COORD));</a>
<a name="ln857">                    } else {</a>
<a name="ln858">                        num_atoms = INCHI_INP_FATAL_RET; /* allocation error */</a>
<a name="ln859">                        *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln860">                        MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln861">                        goto bypass_end_of_INChI_plain;</a>
<a name="ln862">                    }</a>
<a name="ln863">                    i = 0;</a>
<a name="ln864">                    res2 = bTooLongLine2 = -1;</a>
<a name="ln865">                    bItemIsOver = (s = strchr( p, '/') ) || !bTooLongLine;</a>
<a name="ln866">                    while ( i &lt; num_atoms ) {</a>
<a name="ln867">                        p = LoadLine( inp_molfile, &amp;bTooLongLine, &amp;bItemIsOver, &amp;s,</a>
<a name="ln868">                                      szLine, sizeof(szLine), INCHI_LINE_ADD, p, &amp;res );</a>
<a name="ln869">                        if ( i &gt;= num_atoms || (s &amp;&amp; p &gt;= s) ) {</a>
<a name="ln870">                            break; /* end of bonds (plain) */</a>
<a name="ln871">                        }</a>
<a name="ln872"> </a>
<a name="ln873">                        /* coord, first char */</a>
<a name="ln874">                        if ( *p == ';' ) {</a>
<a name="ln875">                            for ( k = 0; k &lt; NUM_COORD; k ++ ) {</a>
<a name="ln876">                                pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln877">                            }</a>
<a name="ln878">                            p ++;</a>
<a name="ln879">                            i ++;</a>
<a name="ln880">                            continue;</a>
<a name="ln881">                        }</a>
<a name="ln882">                        for ( k = 0; k &lt; 3; k ++ ) {</a>
<a name="ln883">                            double xyz;</a>
<a name="ln884">                            bNonZeroXYZ = 0;</a>
<a name="ln885">                            if ( *p == ';' ) {</a>
<a name="ln886">                                pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln887">                                xyz = 0.0;</a>
<a name="ln888">                            } else</a>
<a name="ln889">                            if ( *p == ',' ) {</a>
<a name="ln890">                                /* empty */</a>
<a name="ln891">                                pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln892">                                xyz = 0.0;</a>
<a name="ln893">                                p ++;</a>
<a name="ln894">                            } else {</a>
<a name="ln895">                                xyz = strtod( p, &amp;q );</a>
<a name="ln896">                                bNonZeroXYZ = fabs(xyz) &gt; MIN_BOND_LENGTH;</a>
<a name="ln897">                                if ( q != NULL ) {</a>
<a name="ln898">                                    memcpy( pszCoord[i]+LEN_COORD*k, p, q-p );</a>
<a name="ln899">                                    if ( *q == ',' )</a>
<a name="ln900">                                        q ++;</a>
<a name="ln901">                                    p = q;</a>
<a name="ln902">                                } else {</a>
<a name="ln903">                                    pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln904">                                }</a>
<a name="ln905">                            }</a>
<a name="ln906">                            switch( k ) {</a>
<a name="ln907">                            case 0:</a>
<a name="ln908">                                atom[i].x = xyz;</a>
<a name="ln909">                                b2D |= bNonZeroXYZ;</a>
<a name="ln910">                                break;</a>
<a name="ln911">                            case 1:</a>
<a name="ln912">                                atom[i].y = xyz;</a>
<a name="ln913">                                b2D |= bNonZeroXYZ;</a>
<a name="ln914">                                break;</a>
<a name="ln915">                            case 2:</a>
<a name="ln916">                                b3D |= bNonZeroXYZ;</a>
<a name="ln917">                                atom[i].z = xyz;</a>
<a name="ln918">                                break;</a>
<a name="ln919">                            }</a>
<a name="ln920">                        }</a>
<a name="ln921">                        if ( *p == ';' ) {</a>
<a name="ln922">                            p ++; /* end of this triple of coordinates */</a>
<a name="ln923">                            i ++;</a>
<a name="ln924">                        } else {</a>
<a name="ln925">                            num_atoms = INCHI_INP_ERROR_RET; /* error in input data: atoms, bonds &amp; coord must be present together */</a>
<a name="ln926">                            *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln927">                            MOLFILE_ERR_SET (*err, 0, &quot;Wrong atom coordinates data&quot;);</a>
<a name="ln928">                            goto bypass_end_of_INChI_plain;</a>
<a name="ln929">                        }</a>
<a name="ln930">                    }</a>
<a name="ln931">                    if ( !bItemIsOver || (s &amp;&amp; p != s) || i != num_atoms ) {</a>
<a name="ln932">                        num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln933">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln934">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong number of coordinates&quot;);</a>
<a name="ln935">                        goto bypass_end_of_INChI_plain;</a>
<a name="ln936">                    }</a>
<a name="ln937">                } /* end of coordinates */</a>
<a name="ln938">                /* set special valences and implicit H (xml) */</a>
<a name="ln939">                b23D = b2D | b3D;</a>
<a name="ln940">                b2D = b3D = 0;</a>
<a name="ln941">                if ( at ) {</a>
<a name="ln942">                    if ( !*at ) {</a>
<a name="ln943">                        int a1, a2, n1, n2, valence;</a>
<a name="ln944">                        int chem_bonds_valence;</a>
<a name="ln945">                        int    nX=0, nY=0, nZ=0, nXYZ;</a>
<a name="ln946">                        *at = atom;</a>
<a name="ln947">                        /* special valences */</a>
<a name="ln948">                        for ( bNonMetal = 0; bNonMetal &lt; 1; bNonMetal ++ ) {</a>
<a name="ln949">                            for ( a1 = 0; a1 &lt; num_atoms; a1 ++ ) {</a>
<a name="ln950">                                int num_bond_type[MAX_INPUT_BOND_TYPE - MIN_INPUT_BOND_TYPE + 1];</a>
<a name="ln951">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln952">#else</a>
<a name="ln953">                                int bHasMetalNeighbor=0;</a>
<a name="ln954">#endif</a>
<a name="ln955">                                memset( num_bond_type, 0, sizeof(num_bond_type) );</a>
<a name="ln956"> </a>
<a name="ln957">                                valence = AT_BONDS_VAL(atom, a1); /*  save atom valence if available */</a>
<a name="ln958">                                AT_BONDS_VAL(atom, a1) = 0;</a>
<a name="ln959">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln960">#else</a>
<a name="ln961">                                atom[a1].orig_at_number = a1+1;</a>
<a name="ln962">#endif</a>
<a name="ln963">                                nX = nY = nZ = 0;</a>
<a name="ln964">                                for ( n1 = 0; n1 &lt; AT_NUM_BONDS(atom[a1]); n1 ++ ) {</a>
<a name="ln965">                                    bond_type = atom[a1].bond_type[n1] - MIN_INPUT_BOND_TYPE;</a>
<a name="ln966">                                    if ( bond_type &lt; 0 || bond_type &gt; MAX_INPUT_BOND_TYPE - MIN_INPUT_BOND_TYPE ) {</a>
<a name="ln967">                                        bond_type = 0;</a>
<a name="ln968">                                        MOLFILE_ERR_SET (*err, 0, &quot;Unknown bond type in InChI aux assigned as a single bond&quot;);</a>
<a name="ln969">                                    }</a>
<a name="ln970"> </a>
<a name="ln971">                                    num_bond_type[ bond_type ] ++;</a>
<a name="ln972">                                    nNumBonds ++;</a>
<a name="ln973">                                    if ( b23D ) {</a>
<a name="ln974">                                        neigh = atom[a1].neighbor[n1];</a>
<a name="ln975">                                        nX |= (fabs(atom[a1].x - atom[neigh].x) &gt; MIN_BOND_LENGTH);</a>
<a name="ln976">                                        nY |= (fabs(atom[a1].y - atom[neigh].y) &gt; MIN_BOND_LENGTH);</a>
<a name="ln977">                                        nZ |= (fabs(atom[a1].z - atom[neigh].z) &gt; MIN_BOND_LENGTH);</a>
<a name="ln978">                                    }</a>
<a name="ln979">                                }</a>
<a name="ln980">                                chem_bonds_valence = 0;</a>
<a name="ln981">                                for ( n1 = 0; MIN_INPUT_BOND_TYPE + n1 &lt;= 3 &amp;&amp; MIN_INPUT_BOND_TYPE + n1 &lt;= MAX_INPUT_BOND_TYPE; n1 ++ ) {</a>
<a name="ln982">                                    chem_bonds_valence += (MIN_INPUT_BOND_TYPE + n1) * num_bond_type[n1];</a>
<a name="ln983">                                }</a>
<a name="ln984">                                if ( MIN_INPUT_BOND_TYPE &lt;= INCHI_BOND_TYPE_ALTERN &amp;&amp; INCHI_BOND_TYPE_ALTERN &lt;= MAX_INPUT_BOND_TYPE &amp;&amp;</a>
<a name="ln985">                                     ( n2 = num_bond_type[INCHI_BOND_TYPE_ALTERN-MIN_INPUT_BOND_TYPE] ) ) {</a>
<a name="ln986">                                    /* accept input aromatic bonds for now */</a>
<a name="ln987">                                    switch ( n2 ) {</a>
<a name="ln988">                                    case 2:</a>
<a name="ln989">                                        chem_bonds_valence += 3;  /* =A- */</a>
<a name="ln990">                                        break;</a>
<a name="ln991">                                    case 3:</a>
<a name="ln992">                                        chem_bonds_valence += 4;  /* =A&lt; */</a>
<a name="ln993">                                        break;</a>
<a name="ln994">                                    default:</a>
<a name="ln995">                                        /*  if 1 or &gt;= 4 aromatic bonds then replace such bonds with single bonds */</a>
<a name="ln996">                                        for ( n1 = 0; n1 &lt; AT_NUM_BONDS(atom[a1]); n1 ++ ) {</a>
<a name="ln997">                                            if ( atom[a1].bond_type[n1] == INCHI_BOND_TYPE_ALTERN ) {</a>
<a name="ln998">                                                ATOM_NUMBER *p1;</a>
<a name="ln999">                                                a2 = atom[a1].neighbor[n1];</a>
<a name="ln1000">                                                p1 = IN_NEIGH_LIST( atom[a2].neighbor, (ATOM_NUMBER)a1, AT_NUM_BONDS(atom[a2]) );</a>
<a name="ln1001">                                                if ( p1 ) {</a>
<a name="ln1002">                                                    atom[a1].bond_type[n1] = </a>
<a name="ln1003">                                                    atom[a2].bond_type[p1-atom[a2].neighbor] = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1004">                                                } else {</a>
<a name="ln1005">                                                    *err = -2;  /*  Program error */</a>
<a name="ln1006">                                                    MOLFILE_ERR_SET (*err, 0, &quot;Program error interpreting InChI aux&quot;);</a>
<a name="ln1007">                                                    num_atoms = 0;</a>
<a name="ln1008">                                                    goto bypass_end_of_INChI_plain; /*  no structure */</a>
<a name="ln1009">                                                }</a>
<a name="ln1010">                                            }</a>
<a name="ln1011">                                        }</a>
<a name="ln1012">                                        chem_bonds_valence += n2;</a>
<a name="ln1013">                                        *err |= 32; /*  Unrecognized aromatic bond(s) replaced with single */</a>
<a name="ln1014">                                        MOLFILE_ERR_SET (*err, 0, &quot;Atom has 1 or more than 3 aromatic bonds&quot;);</a>
<a name="ln1015">                                        break;</a>
<a name="ln1016">                                    }</a>
<a name="ln1017">                                }</a>
<a name="ln1018">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1019">                                /*************************************************************************************</a>
<a name="ln1020">                                 *</a>
<a name="ln1021">                                 *  Set number of hydrogen atoms</a>
<a name="ln1022">                                 */</a>
<a name="ln1023">                                {</a>
<a name="ln1024">                                    int num_iso_H;</a>
<a name="ln1025">                                    num_iso_H = atom[a1].num_iso_H[1] + atom[a1].num_iso_H[2] + atom[a1].num_iso_H[3];</a>
<a name="ln1026">                                    if ( valence == ISOLATED_ATOM ) {</a>
<a name="ln1027">                                        atom[a1].num_iso_H[0] = 0;</a>
<a name="ln1028">                                    } else</a>
<a name="ln1029">                                    if ( valence &amp;&amp; valence &gt;= chem_bonds_valence ) {</a>
<a name="ln1030">                                        atom[a1].num_iso_H[0] = valence - chem_bonds_valence;</a>
<a name="ln1031">                                    } else</a>
<a name="ln1032">                                    if ( valence || bDoNotAddH ) {</a>
<a name="ln1033">                                        atom[a1].num_iso_H[0] = 0;</a>
<a name="ln1034">                                    } else</a>
<a name="ln1035">                                    if ( !bDoNotAddH ) {</a>
<a name="ln1036">                                        atom[a1].num_iso_H[0] = -1; /* auto add H */</a>
<a name="ln1037">                                    }</a>
<a name="ln1038">                                }</a>
<a name="ln1039">#else                                </a>
<a name="ln1040">                                /* added 2006-07-19 to process aromatic bonds same way as from molfile */</a>
<a name="ln1041">                                if ( n2 &amp;&amp; !valence ) {</a>
<a name="ln1042">                                    int num_H = NUMH(atom, a1); /* only isotopic */</a>
<a name="ln1043">                                    int chem_valence = chem_bonds_valence;</a>
<a name="ln1044">                                    int bUnusualValenceArom = </a>
<a name="ln1045">                                        detect_unusual_el_valence( (int)atom[a1].el_number, atom[a1].charge,</a>
<a name="ln1046">                                                                    atom[a1].radical, chem_valence,</a>
<a name="ln1047">                                                                    num_H, atom[a1].valence );</a>
<a name="ln1048">                                    int bUnusualValenceNoArom = </a>
<a name="ln1049">                                        detect_unusual_el_valence( (int)atom[a1].el_number, atom[a1].charge,</a>
<a name="ln1050">                                                                    atom[a1].radical, chem_valence-1,</a>
<a name="ln1051">                                                                    num_H, atom[a1].valence );</a>
<a name="ln1052">#if ( CHECK_AROMBOND2ALT == 1 )</a>
<a name="ln1053">                                    if ( bUnusualValenceArom &amp;&amp; !bUnusualValenceNoArom &amp;&amp; 0 == nBondsValToMetal( atom, a1) )</a>
<a name="ln1054">#else</a>
<a name="ln1055">                                    if ( bUnusualValenceArom &amp;&amp; !bUnusualValenceNoArom )</a>
<a name="ln1056">#endif                     </a>
<a name="ln1057">                                    {</a>
<a name="ln1058">                                        /* typically NH in 5-member aromatic ring */</a>
<a name="ln1059">                                        chem_bonds_valence --;</a>
<a name="ln1060">                                    }</a>
<a name="ln1061">                                } else</a>
<a name="ln1062">                                if ( n2 &amp;&amp; valence ) {</a>
<a name="ln1063">                                    /* atom has aromatic bonds AND the chemical valence is known */</a>
<a name="ln1064">                                    int num_H = NUMH(atom, a1);</a>
<a name="ln1065">                                    int chem_valence = chem_bonds_valence + num_H;</a>
<a name="ln1066">                                    if ( valence == chem_valence-1 ) {</a>
<a name="ln1067">                                        /* typically NH in 5-member aromatic ring */</a>
<a name="ln1068">                                        chem_bonds_valence --;</a>
<a name="ln1069">                                    }</a>
<a name="ln1070">                                }</a>
<a name="ln1071"> </a>
<a name="ln1072">                                atom[a1].chem_bonds_valence = chem_bonds_valence;</a>
<a name="ln1073">                                atom[a1].num_H = get_num_H( atom[a1].elname, atom[a1].num_H, atom[a1].num_iso_H, atom[a1].charge, atom[a1].radical,</a>
<a name="ln1074">                                                          atom[a1].chem_bonds_valence,</a>
<a name="ln1075">                                                          valence,</a>
<a name="ln1076">                                                          0, bDoNotAddH, bHasMetalNeighbor );</a>
<a name="ln1077">#endif</a>
<a name="ln1078">                            }</a>
<a name="ln1079">                        }</a>
<a name="ln1080">                        nNumBonds /= 2;</a>
<a name="ln1081">                        if ( b23D &amp;&amp; nNumBonds ) {</a>
<a name="ln1082">                            nXYZ = nX+nY+nZ;</a>
<a name="ln1083">                            b2D  = (nXYZ &gt; 0);</a>
<a name="ln1084">                            b3D  = (nXYZ == 3);</a>
<a name="ln1085">                            *num_dimensions = b3D? 3 : b2D? 2 : 0;</a>
<a name="ln1086">                            *num_bonds = nNumBonds;</a>
<a name="ln1087">                        }</a>
<a name="ln1088">                        /*======= 0D parities =================================*/</a>
<a name="ln1089">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1090">                        if ( len_stereo0D &gt; 0 &amp;&amp; atom_stereo0D &amp;&amp; stereo0D ) {</a>
<a name="ln1091">                            *stereo0D     = atom_stereo0D;</a>
<a name="ln1092">                            *num_stereo0D = len_stereo0D;</a>
<a name="ln1093">                        } else {</a>
<a name="ln1094">                            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln1095">                            *num_stereo0D = len_stereo0D = 0;</a>
<a name="ln1096">                        }</a>
<a name="ln1097">#endif</a>
<a name="ln1098">                        for ( i = 0; i &lt; len_stereo0D; i ++ ) {</a>
<a name="ln1099">                            ATOM_NUMBER *p1, *p2;</a>
<a name="ln1100">                            int     sb_ord_from_a1 = -1, sb_ord_from_a2 = -1, bEnd1 = 0, bEnd2 = 0;</a>
<a name="ln1101">                            switch( atom_stereo0D[i].type ) {</a>
<a name="ln1102"> </a>
<a name="ln1103">                            case INCHI_StereoType_Tetrahedral:</a>
<a name="ln1104">                                a1 = atom_stereo0D[i].central_atom;</a>
<a name="ln1105">                                if ( atom_stereo0D[i].parity &amp;&amp; (AT_NUM_BONDS(atom[a1]) == 3 || AT_NUM_BONDS(atom[a1]) == 4) ) {</a>
<a name="ln1106">                                    int ii, kk = 0;</a>
<a name="ln1107">                                    if ( AT_NUM_BONDS(atom[a1]) == 3 ) {</a>
<a name="ln1108">                                        atom_stereo0D[i].neighbor[kk++] = a1;</a>
<a name="ln1109">                                    }</a>
<a name="ln1110">                                    for ( ii = 0; ii &lt; AT_NUM_BONDS(atom[a1]); ii ++ ) {</a>
<a name="ln1111">                                        atom_stereo0D[i].neighbor[kk++] = atom[a1].neighbor[ii];</a>
<a name="ln1112">                                    }</a>
<a name="ln1113">                                }</a>
<a name="ln1114">                            </a>
<a name="ln1115">                            break;</a>
<a name="ln1116"> </a>
<a name="ln1117">                            case INCHI_StereoType_DoubleBond:</a>
<a name="ln1118">#define MAX_CHAIN_LEN 20</a>
<a name="ln1119">                                a1 = atom_stereo0D[i].neighbor[1];</a>
<a name="ln1120">                                a2 = atom_stereo0D[i].neighbor[2];</a>
<a name="ln1121">                                p1 = IN_NEIGH_LIST( atom[a1].neighbor, (ATOM_NUMBER)a2, AT_NUM_BONDS(atom[a1]) );</a>
<a name="ln1122">                                p2 = IN_NEIGH_LIST( atom[a2].neighbor, (ATOM_NUMBER)a1, AT_NUM_BONDS(atom[a2]) );</a>
<a name="ln1123">                                if ( !p1 || !p2 ) {</a>
<a name="ln1124">                                    atom_stereo0D[i].type = INCHI_StereoType_None;</a>
<a name="ln1125">                                    atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln1126">                                    atom_stereo0D[i].neighbor[0] =</a>
<a name="ln1127">                                    atom_stereo0D[i].neighbor[3] = -1;</a>
<a name="ln1128">                                    *err |= 64; /* Error in cumulene stereo */</a>
<a name="ln1129">                                    MOLFILE_ERR_SET (*err, 0, &quot;0D stereobond not recognized&quot;);</a>
<a name="ln1130">                                    break;</a>
<a name="ln1131">                                }</a>
<a name="ln1132">                                /* streobond, allene, or cumulene */</a>
<a name="ln1133"> </a>
<a name="ln1134">                                sb_ord_from_a1 = p1 - atom[a1].neighbor;</a>
<a name="ln1135">                                sb_ord_from_a2 = p2 - atom[a2].neighbor;</a>
<a name="ln1136">                                </a>
<a name="ln1137">                                if ( AT_NUM_BONDS(atom[a1]) == 2 &amp;&amp;</a>
<a name="ln1138">                                      atom[a1].bond_type[0] + atom[a1].bond_type[1] == 2*INCHI_BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1139">                                      0 == inchi_NUMH2(atom, a1) &amp;&amp;</a>
<a name="ln1140">                                     (AT_NUM_BONDS(atom[a2]) != 2 ||</a>
<a name="ln1141">                                      atom[a2].bond_type[0] + atom[a2].bond_type[1] != 2*INCHI_BOND_TYPE_DOUBLE ) ) {</a>
<a name="ln1142">                                    bEnd2 = 1; /* a2 is the end-atom, a1 is middle atom */   </a>
<a name="ln1143">                                }</a>
<a name="ln1144">                                if ( AT_NUM_BONDS(atom[a2]) == 2 &amp;&amp;</a>
<a name="ln1145">                                      atom[a2].bond_type[0] + atom[a2].bond_type[1] == 2*INCHI_BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1146">                                      0 == inchi_NUMH2(atom, a2) &amp;&amp;</a>
<a name="ln1147">                                     (AT_NUM_BONDS(atom[a1]) != 2 ||</a>
<a name="ln1148">                                      atom[a1].bond_type[0] + atom[a1].bond_type[1] != 2*INCHI_BOND_TYPE_DOUBLE ) ) {</a>
<a name="ln1149">                                    bEnd1 = 1; /* a1 is the end-atom, a2 is middle atom */   </a>
<a name="ln1150">                                }</a>
<a name="ln1151">                                </a>
<a name="ln1152">                                if ( bEnd2 + bEnd1 == 1 ) {</a>
<a name="ln1153">                                    /* allene or cumulene */</a>
<a name="ln1154">                                    ATOM_NUMBER  chain[MAX_CHAIN_LEN+1], prev, cur, next;</a>
<a name="ln1155">                                    if ( bEnd2 &amp;&amp; !bEnd1 ) {</a>
<a name="ln1156">                                        cur = a1;</a>
<a name="ln1157">                                        a1 = a2;</a>
<a name="ln1158">                                        a2 = cur;</a>
<a name="ln1159">                                        sb_ord_from_a1 = sb_ord_from_a2;</a>
<a name="ln1160">                                    }</a>
<a name="ln1161">                                    sb_ord_from_a2 = -1;</a>
<a name="ln1162">                                    cur  = a1;</a>
<a name="ln1163">                                    next = a2;</a>
<a name="ln1164">                                    len = 0;</a>
<a name="ln1165">                                    chain[len++] = cur;</a>
<a name="ln1166">                                    chain[len++] = next;</a>
<a name="ln1167">                                    while ( len &lt; MAX_CHAIN_LEN ) { /* arbitrary very high upper limit to prevent infinite loop */</a>
<a name="ln1168">                                        prev = cur;</a>
<a name="ln1169">                                        cur  = next;</a>
<a name="ln1170">                                            /* follow double bond path &amp;&amp; avoid going back */</a>
<a name="ln1171">                                        if ( AT_NUM_BONDS(atom[cur]) == 2 &amp;&amp;</a>
<a name="ln1172">                                             atom[cur].bond_type[0]+atom[cur].bond_type[1] == 2*INCHI_BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1173">                                             0 == inchi_NUMH2(atom, cur) ) {</a>
<a name="ln1174">                                            next     = atom[cur].neighbor[atom[cur].neighbor[0] == prev];</a>
<a name="ln1175">                                            chain[len++] = next;</a>
<a name="ln1176">                                        } else {</a>
<a name="ln1177">                                            break;</a>
<a name="ln1178">                                        }</a>
<a name="ln1179">                                    }</a>
<a name="ln1180">                                    if ( len &gt; 2 &amp;&amp;</a>
<a name="ln1181">                                         (p2 = IN_NEIGH_LIST( atom[cur].neighbor, (ATOM_NUMBER)prev, AT_NUM_BONDS(atom[cur]))) ) {</a>
<a name="ln1182">                                        sb_ord_from_a2 = p2 - atom[cur].neighbor;</a>
<a name="ln1183">                                        a2 = cur;</a>
<a name="ln1184">                                        /* by design we need to pick up the first non-stereo-bond-neighbor as &quot;sn&quot;-atom */</a>
<a name="ln1185">                                        atom_stereo0D[i].neighbor[0] = atom[a1].neighbor[sb_ord_from_a1 == 0];</a>
<a name="ln1186">                                        atom_stereo0D[i].neighbor[1] = a1;</a>
<a name="ln1187">                                        atom_stereo0D[i].neighbor[2] = a2;</a>
<a name="ln1188">                                        atom_stereo0D[i].neighbor[3] = atom[a2].neighbor[sb_ord_from_a2 == 0];</a>
<a name="ln1189">                                        if ( len % 2 ) {</a>
<a name="ln1190">                                            atom_stereo0D[i].central_atom = chain[len/2];</a>
<a name="ln1191">                                            atom_stereo0D[i].type         = INCHI_StereoType_Allene; </a>
<a name="ln1192">                                        } else {</a>
<a name="ln1193">                                            atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln1194">                                        }</a>
<a name="ln1195">                                    } else {</a>
<a name="ln1196">                                        /* error */</a>
<a name="ln1197">                                        atom_stereo0D[i].type = INCHI_StereoType_None;</a>
<a name="ln1198">                                        atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln1199">                                        atom_stereo0D[i].neighbor[0] =</a>
<a name="ln1200">                                        atom_stereo0D[i].neighbor[3] = -1;</a>
<a name="ln1201">                                        *err |= 64; /* Error in cumulene stereo */</a>
<a name="ln1202">                                        MOLFILE_ERR_SET (*err, 0, &quot;Cumulene stereo not recognized (0D)&quot;);</a>
<a name="ln1203"> </a>
<a name="ln1204">                                    }</a>
<a name="ln1205">#undef MAX_CHAIN_LEN </a>
<a name="ln1206">                                } else {</a>
<a name="ln1207">                                    /****** a normal possibly stereogenic bond -- not an allene or cumulene *******/</a>
<a name="ln1208">                                    /* by design we need to pick up the first non-stereo-bond-neighbor as &quot;sn&quot;-atom */</a>
<a name="ln1209">                                    sb_ord_from_a1 = p1 - atom[a1].neighbor;</a>
<a name="ln1210">                                    sb_ord_from_a2 = p2 - atom[a2].neighbor;</a>
<a name="ln1211">                                    atom_stereo0D[i].neighbor[0] = atom[a1].neighbor[p1 == atom[a1].neighbor];</a>
<a name="ln1212">                                    atom_stereo0D[i].neighbor[3] = atom[a2].neighbor[p2 == atom[a2].neighbor];</a>
<a name="ln1213">                                    atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln1214">                                }</a>
<a name="ln1215">                                if ( atom_stereo0D[i].type != INCHI_StereoType_None &amp;&amp;</a>
<a name="ln1216">                                     sb_ord_from_a1 &gt;= 0 &amp;&amp; sb_ord_from_a2 &gt;= 0 &amp;&amp;</a>
<a name="ln1217">                                     ATOM_PARITY_WELL_DEF( SB_PARITY_2(atom_stereo0D[i].parity) ) ) {</a>
<a name="ln1218">                                    /* Detected well-defined disconnected stereo</a>
<a name="ln1219">                                     * locate first non-metal neighbors */</a>
<a name="ln1220">                                    int    a, n, j, /* k,*/ sb_ord, cur_neigh, min_neigh;</a>
<a name="ln1221">                                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1222">                                        a      = k? atom_stereo0D[i].neighbor[2] : atom_stereo0D[i].neighbor[1];</a>
<a name="ln1223">                                        sb_ord = k? sb_ord_from_a2 : sb_ord_from_a1;</a>
<a name="ln1224">                                        min_neigh = num_atoms;</a>
<a name="ln1225">                                        for ( n  = j = 0; j &lt; AT_NUM_BONDS(atom[a]); j ++ ) {</a>
<a name="ln1226">                                            cur_neigh = atom[a].neighbor[j];</a>
<a name="ln1227">                                            if ( j != sb_ord &amp;&amp; !IS_METAL_ATOM(atom, cur_neigh) ) {</a>
<a name="ln1228">                                                min_neigh = inchi_min( cur_neigh, min_neigh );</a>
<a name="ln1229">                                            }</a>
<a name="ln1230">                                        }</a>
<a name="ln1231">                                        if ( min_neigh &lt; num_atoms ) {</a>
<a name="ln1232">                                            atom_stereo0D[i].neighbor[k?3:0] = min_neigh;</a>
<a name="ln1233">                                        } else {</a>
<a name="ln1234">                                            MOLFILE_ERR_SET (*err, 0, &quot;Cannot find non-metal stereobond neighor (0D)&quot;);</a>
<a name="ln1235">                                        }</a>
<a name="ln1236">                                    }</a>
<a name="ln1237">                                }</a>
<a name="ln1238"> </a>
<a name="ln1239">                                break;</a>
<a name="ln1240">                            }</a>
<a name="ln1241">                        }</a>
<a name="ln1242">                        /* end of 0D parities extraction */</a>
<a name="ln1243">/*exit_cycle:;*/</a>
<a name="ln1244">                    }</a>
<a name="ln1245">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1246">#else</a>
<a name="ln1247">                    /* transfer atom_stereo0D[] to atom[] */</a>
<a name="ln1248">                    if ( len_stereo0D ) {</a>
<a name="ln1249">                        Extract0DParities( atom, num_atoms, atom_stereo0D, len_stereo0D, </a>
<a name="ln1250">                            pStrErr, err, vABParityUnknown );</a>
<a name="ln1251">                    }</a>
<a name="ln1252">#endif</a>
<a name="ln1253">                    if ( pInpAtomFlags ) {</a>
<a name="ln1254">                        /* save chirality flag */</a>
<a name="ln1255">                        *pInpAtomFlags |= InpAtomFlags;</a>
<a name="ln1256">                    }</a>
<a name="ln1257">                } else</a>
<a name="ln1258">                if ( atom ) {</a>
<a name="ln1259">                    inchi_free( atom );</a>
<a name="ln1260">                    atom = NULL;</a>
<a name="ln1261">                }</a>
<a name="ln1262">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1263">#else</a>
<a name="ln1264">#if ( FIX_READ_AUX_MEM_LEAK == 1 )</a>
<a name="ln1265">                /* 2005-08-04 avoid memory leak */</a>
<a name="ln1266">                if ( atom_stereo0D &amp;&amp; !(stereo0D &amp;&amp; *stereo0D == atom_stereo0D) ) {</a>
<a name="ln1267">                    FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln1268">                }</a>
<a name="ln1269">#endif</a>
<a name="ln1270">                if ( szCoord ) {</a>
<a name="ln1271">                    *szCoord = pszCoord;</a>
<a name="ln1272">                    pszCoord = NULL;</a>
<a name="ln1273">                } else</a>
<a name="ln1274">#endif</a>
<a name="ln1275">                if ( pszCoord ) {</a>
<a name="ln1276">                    inchi_free( pszCoord );</a>
<a name="ln1277">                    pszCoord = NULL;</a>
<a name="ln1278">                }</a>
<a name="ln1279">                goto bypass_end_of_INChI_plain;</a>
<a name="ln1280">                /*return num_atoms;*/</a>
<a name="ln1281">            }</a>
<a name="ln1282">        }</a>
<a name="ln1283">        if ( atom_stereo0D ) {</a>
<a name="ln1284">            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln1285">        }</a>
<a name="ln1286">        /* end of struct. reading cycle */</a>
<a name="ln1287">        if ( res &lt;= 0 ) {</a>
<a name="ln1288">            if ( *err == INCHI_INP_ERROR_ERR ) {</a>
<a name="ln1289">                return num_atoms;</a>
<a name="ln1290">            }</a>
<a name="ln1291">            *err = INCHI_INP_EOF_ERR;</a>
<a name="ln1292">            return INCHI_INP_EOF_RET; /* no more data */</a>
<a name="ln1293">        }</a>
<a name="ln1294">bypass_end_of_INChI_plain:</a>
<a name="ln1295">        /* cleanup */</a>
<a name="ln1296">        if ( num_atoms == INCHI_INP_ERROR_RET &amp;&amp; atom_stereo0D ) {</a>
<a name="ln1297">            if ( stereo0D &amp;&amp; *stereo0D == atom_stereo0D ) {</a>
<a name="ln1298">                *stereo0D     = NULL;</a>
<a name="ln1299">                *num_stereo0D = 0;</a>
<a name="ln1300">            }</a>
<a name="ln1301">            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln1302">        }</a>
<a name="ln1303">        while ( bTooLongLine &amp;&amp; </a>
<a name="ln1304">                0 &lt; inchi_ios_getsTab1( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine ) ) {</a>
<a name="ln1305">            ;</a>
<a name="ln1306">        }</a>
<a name="ln1307">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1308">        /* cleanup */</a>
<a name="ln1309">        if ( !*at ) {</a>
<a name="ln1310">            if ( atom ) {</a>
<a name="ln1311">                inchi_free( atom );</a>
<a name="ln1312">                atom = NULL;</a>
<a name="ln1313">            }</a>
<a name="ln1314">            if ( pszCoord ) {</a>
<a name="ln1315">                inchi_free( pszCoord );</a>
<a name="ln1316">                pszCoord = NULL;</a>
<a name="ln1317">            }</a>
<a name="ln1318">        }</a>
<a name="ln1319">#endif</a>
<a name="ln1320"> </a>
<a name="ln1321">        return num_atoms;</a>
<a name="ln1322">    }</a>
<a name="ln1323">    </a>
<a name="ln1324">    /***********************************************************/</a>
<a name="ln1325">    /*   extract reversibility info from xml text INChI format */</a>
<a name="ln1326">    /*                                                         */</a>
<a name="ln1327">    /*   OBSOLETE CODE because InChI output in XML             */</a>
<a name="ln1328">    /*      does not exist anymore. Unsupported.               */</a>
<a name="ln1329">    /*                                                         */</a>
<a name="ln1330">    /***********************************************************/</a>
<a name="ln1331">    if ( nInputType == INPUT_INCHI_XML ) {</a>
<a name="ln1332">        /* xml tags */</a>
<a name="ln1333">        static const char sStructHdrXml[]         = &quot;&lt;structure&quot;;</a>
<a name="ln1334">        static const char sStructHdrXmlEnd[]      = &quot;&lt;/structure&quot;;</a>
<a name="ln1335">        static const char sStructHdrXmlNumber[]   = &quot;number=\&quot;&quot;;</a>
<a name="ln1336">        static const char sStructHdrXmlIdName[]   = &quot;id.name=\&quot;&quot;;</a>
<a name="ln1337">        static const char sStructHdrXmlIdValue[]  = &quot;id.value=\&quot;&quot;;</a>
<a name="ln1338">        static const char sStructMsgXmlErr[]      = &quot;&lt;message type=\&quot;error (no InChI)\&quot; value=\&quot;&quot;;</a>
<a name="ln1339">        static const char sStructMsgXmlErrFatal[] = &quot;&lt;message type=\&quot;fatal (aborted)\&quot; value=\&quot;&quot;;</a>
<a name="ln1340">        static const char sStructRevXmlRevHdr[]   = &quot;&lt;reversibility&gt;&quot;;</a>
<a name="ln1341">        static const char sStructRevXmlRevAt[]    = &quot;&lt;atoms&gt;&quot;;</a>
<a name="ln1342">        static const char sStructRevXmlRevAtEnd[] = &quot;&lt;/atoms&gt;&quot;;</a>
<a name="ln1343">        static const char sStructRevXmlRevBn[]    = &quot;&lt;bonds&gt;&quot;;</a>
<a name="ln1344">        static const char sStructRevXmlRevBnEnd[] = &quot;&lt;/bonds&gt;&quot;;</a>
<a name="ln1345">        static const char sStructRevXmlRevXYZ[]   = &quot;&lt;xyz&gt;&quot;;</a>
<a name="ln1346">        static const char sStructRevXmlRevXYZEnd[]= &quot;&lt;/xyz&gt;&quot;;</a>
<a name="ln1347">        static const char sStructAuxXml[]         = &quot;&lt;identifier.auxiliary-info&quot;;</a>
<a name="ln1348">        static const char sStructAuxXmlEnd[]      = &quot;&lt;/identifier.auxiliary-info&quot;;</a>
<a name="ln1349">        int         bInTheAuxInfo           = 0;</a>
<a name="ln1350"> </a>
<a name="ln1351">        while ( 0 &lt; (res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine ) ) ) {</a>
<a name="ln1352">        </a>
<a name="ln1353">            /********************* find and interpret structure header ************/</a>
<a name="ln1354">            if ( !memcmp(szLine, sStructHdrXml, sizeof(sStructHdrXml)-1) ) {</a>
<a name="ln1355">                num_struct = 1;</a>
<a name="ln1356">                p = szLine + sizeof(sStructHdrXml)-1;</a>
<a name="ln1357">                longID = 0;</a>
<a name="ln1358">                num_atoms = 0;</a>
<a name="ln1359">                /* structure number */</a>
<a name="ln1360">                if ( (q = strstr( p, sStructHdrXmlNumber )) ) {</a>
<a name="ln1361">                    p = q + sizeof(sStructHdrXmlNumber)-1;</a>
<a name="ln1362">                    longID = strtol( p, &amp;q, 10);</a>
<a name="ln1363">                    if ( q &amp;&amp; *q == '\&quot;' )</a>
<a name="ln1364">                        p = q+1;</a>
<a name="ln1365">                }</a>
<a name="ln1366">                if ( pSdfLabel ) {</a>
<a name="ln1367">                    pSdfLabel[0] = '\0';</a>
<a name="ln1368">                }</a>
<a name="ln1369">                if ( pSdfValue ) {</a>
<a name="ln1370">                    pSdfValue[0] = '\0';</a>
<a name="ln1371">                }</a>
<a name="ln1372">                /* pSdfLabel */</a>
<a name="ln1373">                if ( (q = strstr( p, sStructHdrXmlIdName )) ) {</a>
<a name="ln1374">                    p = q + sizeof(sStructHdrXmlIdName)-1;</a>
<a name="ln1375">                    q = strchr( p, '\&quot;' );</a>
<a name="ln1376">                    if ( q ) {</a>
<a name="ln1377">                        len = inchi_min( q-p+1, MAX_SDF_HEADER-1);</a>
<a name="ln1378">                        if ( pSdfLabel ) {</a>
<a name="ln1379">                            mystrncpy( pSdfLabel, p, len );</a>
<a name="ln1380">                        }</a>
<a name="ln1381">                        p = q+1;</a>
<a name="ln1382">                    }</a>
<a name="ln1383">                }</a>
<a name="ln1384">                /* pSdfValue */</a>
<a name="ln1385">                if ( (q = strstr( p, sStructHdrXmlIdValue )) ) {</a>
<a name="ln1386">                    p = q + sizeof(sStructHdrXmlIdValue)-1;</a>
<a name="ln1387">                    q = strchr( p, '\&quot;' );</a>
<a name="ln1388">                    if ( q ) {</a>
<a name="ln1389">                        len = inchi_min( q-p+1, MAX_SDF_VALUE-1);</a>
<a name="ln1390">                        if ( pSdfValue ) {</a>
<a name="ln1391">                            mystrncpy( pSdfValue, p, len );</a>
<a name="ln1392">                        }</a>
<a name="ln1393">                        p = q+1;</a>
<a name="ln1394">                    }</a>
<a name="ln1395">                }</a>
<a name="ln1396">                if ( Id )</a>
<a name="ln1397">                    *Id = longID;</a>
<a name="ln1398">                bHeaderRead = 1;</a>
<a name="ln1399">                bErrorMsg = bRestoreInfo = 0;</a>
<a name="ln1400">            } else</a>
<a name="ln1401">            if ( (bHeaderRead &amp;&amp; (bFatal=0, len=sizeof(sStructMsgXmlErr)-1,      !memcmp(szLine, sStructMsgXmlErr, len))) ||</a>
<a name="ln1402">                 (bHeaderRead &amp;&amp; (len=sizeof(sStructMsgXmlErrFatal)-1, !memcmp(szLine, sStructMsgXmlErrFatal, len))&amp;&amp;(bFatal=1))) {</a>
<a name="ln1403">                p = szLine+len;</a>
<a name="ln1404">                q = strchr( p, '\&quot;' );</a>
<a name="ln1405">                if ( q &amp;&amp; !bFindNext ) {</a>
<a name="ln1406">                    int c;</a>
<a name="ln1407">                    bErrorMsg = 1;</a>
<a name="ln1408">                    pStrErr[0] = '\0';</a>
<a name="ln1409">                    c = *q;</a>
<a name="ln1410">                    *q = '\0';</a>
<a name="ln1411">                    MOLFILE_ERR_SET (*err, 0, p);</a>
<a name="ln1412">                    *q = c;</a>
<a name="ln1413">                }</a>
<a name="ln1414">                *err      = bFatal? INCHI_INP_FATAL_ERR : INCHI_INP_ERROR_ERR;</a>
<a name="ln1415">                num_atoms = bFatal? INCHI_INP_FATAL_RET : INCHI_INP_ERROR_RET;</a>
<a name="ln1416">                goto bypass_end_of_INChI;</a>
<a name="ln1417">            } else</a>
<a name="ln1418">            if ( bHeaderRead &amp;&amp; !memcmp(szLine, sStructAuxXml, sizeof(sStructAuxXml)-1) ) {</a>
<a name="ln1419">                bInTheAuxInfo = 1;</a>
<a name="ln1420">            } else</a>
<a name="ln1421">            if ( bHeaderRead &amp;&amp; !memcmp(szLine, sStructAuxXmlEnd, sizeof(sStructAuxXmlEnd)-1) ) {</a>
<a name="ln1422">                *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1423">                num_atoms = INCHI_INP_ERROR_RET;</a>
<a name="ln1424">                MOLFILE_ERR_SET (*err, 0, &quot;Missing reversibility info&quot; );</a>
<a name="ln1425">                goto bypass_end_of_INChI; /* reversibility info not found */</a>
<a name="ln1426">            } else</a>
<a name="ln1427">            if ( bHeaderRead &amp;&amp; bInTheAuxInfo &amp;&amp; !memcmp(szLine, sStructRevXmlRevHdr, sizeof(sStructRevXmlRevHdr)-1) ) {</a>
<a name="ln1428">                /***********************  atoms xml ***************************/</a>
<a name="ln1429">                num_struct = 1;</a>
<a name="ln1430">                res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine );</a>
<a name="ln1431">                if ( res &lt;= 0 ) {</a>
<a name="ln1432">                    num_atoms = INCHI_INP_EOF_RET; /* no data, probably end of file */</a>
<a name="ln1433">                    *err      = INCHI_INP_EOF_ERR;</a>
<a name="ln1434">                    goto bypass_end_of_INChI;</a>
<a name="ln1435">                }</a>
<a name="ln1436">                if ( memcmp(szLine, sStructRevXmlRevAt, sizeof(sStructRevXmlRevAt)-1) ) {</a>
<a name="ln1437">                    bHeaderRead = 0; /* invalid reversibility info; look for another header */</a>
<a name="ln1438">                    continue;</a>
<a name="ln1439">                }</a>
<a name="ln1440">                /* read (the head of) the atoms line */</a>
<a name="ln1441">                res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine );</a>
<a name="ln1442">                if ( res &lt;= 0 ) {</a>
<a name="ln1443">                    num_atoms = INCHI_INP_EOF_RET; /* no data */</a>
<a name="ln1444">                    *err      = INCHI_INP_EOF_ERR;</a>
<a name="ln1445">                    goto bypass_end_of_INChI;</a>
<a name="ln1446">                }</a>
<a name="ln1447">                p = szLine;</a>
<a name="ln1448">                num_atoms = strtol( p, &amp;q, 10 );</a>
<a name="ln1449">                if ( !num_atoms || !q || !*q ) {</a>
<a name="ln1450">                    num_atoms = INCHI_INP_EOF_RET; /* no atom data */</a>
<a name="ln1451">                    *err      = INCHI_INP_EOF_ERR;</a>
<a name="ln1452">                    goto bypass_end_of_INChI;</a>
<a name="ln1453">                }</a>
<a name="ln1454">                p = q;</a>
<a name="ln1455">                /* Molfile chirality flag */</a>
<a name="ln1456">                switch( *p ) {</a>
<a name="ln1457">                case 'c':</a>
<a name="ln1458">                    InpAtomFlags |= FLAG_INP_AT_CHIRAL;</a>
<a name="ln1459">                    p ++;</a>
<a name="ln1460">                    break;</a>
<a name="ln1461">                case 'n':</a>
<a name="ln1462">                    InpAtomFlags |= FLAG_INP_AT_NONCHIRAL;</a>
<a name="ln1463">                    p ++;</a>
<a name="ln1464">                    break;</a>
<a name="ln1465">                }</a>
<a name="ln1466">                if ( at &amp;&amp; *at ) {</a>
<a name="ln1467">                    if ( num_atoms &gt; max_num_at ) {</a>
<a name="ln1468">                        inchi_free( *at );</a>
<a name="ln1469">                        *at = NULL;</a>
<a name="ln1470">                    } else {</a>
<a name="ln1471">                        memset( *at, 0, max_num_at * sizeof( **at ) );</a>
<a name="ln1472">                        atom = *at;</a>
<a name="ln1473">                    }</a>
<a name="ln1474">                }</a>
<a name="ln1475">                if ( !at || !*at ) {</a>
<a name="ln1476">                    atom = Create_Atom( num_atoms+1 );</a>
<a name="ln1477">                    if ( !atom ) {</a>
<a name="ln1478">                        num_atoms = INCHI_INP_FATAL_RET; /* fatal error: cannot allocate */</a>
<a name="ln1479">                        *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln1480">                        MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln1481">                        goto bypass_end_of_INChI;</a>
<a name="ln1482">                    }</a>
<a name="ln1483">                }</a>
<a name="ln1484">                if ( stereo0D &amp;&amp; *stereo0D ) {</a>
<a name="ln1485">                    if ( num_atoms &gt; max_len_stereo0D ) {</a>
<a name="ln1486">                        FreeInchi_Stereo0D( stereo0D );</a>
<a name="ln1487">                    } else {</a>
<a name="ln1488">                        memset( *stereo0D, 0, max_len_stereo0D * sizeof( **stereo0D ) );</a>
<a name="ln1489">                        atom_stereo0D = *stereo0D;</a>
<a name="ln1490">                    }</a>
<a name="ln1491">                }</a>
<a name="ln1492">                if ( !stereo0D || !*stereo0D ) {</a>
<a name="ln1493">                    max_len_stereo0D = num_atoms+1;</a>
<a name="ln1494">                    atom_stereo0D = CreateInchi_Stereo0D( max_len_stereo0D );</a>
<a name="ln1495">                    if ( !atom_stereo0D ) {</a>
<a name="ln1496">                        num_atoms = INCHI_INP_FATAL_RET; /* fatal error: cannot allocate */</a>
<a name="ln1497">                        *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln1498">                        MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln1499">                        goto bypass_end_of_INChI;</a>
<a name="ln1500">                    }</a>
<a name="ln1501">                }</a>
<a name="ln1502"> </a>
<a name="ln1503">                i = 0;</a>
<a name="ln1504">                bItemIsOver = 0;</a>
<a name="ln1505">                res2 = bTooLongLine2 = -1;</a>
<a name="ln1506">                </a>
<a name="ln1507">                /* read all atoms xml */</a>
<a name="ln1508">                while ( i &lt; num_atoms ) {</a>
<a name="ln1509">                    pos = p - szLine;</a>
<a name="ln1510">                    if ( !bItemIsOver &amp;&amp; (int)sizeof(szLine)-res + pos &gt; (int)sizeof(szNextLine) ) {</a>
<a name="ln1511">                        /* load next line if possible */</a>
<a name="ln1512">                        res2 = inchi_ios_gets( szNextLine, sizeof(szNextLine)-1, inp_molfile, &amp;bTooLongLine2 );</a>
<a name="ln1513">                        if ( res2 &gt; 0 &amp;&amp; memcmp(szNextLine, sStructRevXmlRevAtEnd, sizeof(sStructRevXmlRevAtEnd)-1) ) {</a>
<a name="ln1514">                            if ( pos ) {</a>
<a name="ln1515">                                res -= pos;  /* number of chars left to process in szLine */</a>
<a name="ln1516">                                memmove( szLine, p, res*sizeof(szLine[0]) ); /* move them to the start of the line */</a>
<a name="ln1517">                            }</a>
<a name="ln1518">                            memcpy( szLine+res, szNextLine, (res2+1)*sizeof(szNextLine[0]) );</a>
<a name="ln1519">                            res += res2;</a>
<a name="ln1520">                            szLine[res] = '\0';</a>
<a name="ln1521">                            bTooLongLine = bTooLongLine2;</a>
<a name="ln1522">                            p = szLine;</a>
<a name="ln1523">                        } else {</a>
<a name="ln1524">                            bItemIsOver = 1;</a>
<a name="ln1525">                        }</a>
<a name="ln1526">                    }</a>
<a name="ln1527">                    /* element, first char */</a>
<a name="ln1528">                    if ( !isalpha( UCINT *p ) || !isupper( UCINT *p ) || i &gt;= num_atoms ) {</a>
<a name="ln1529">                        bHeaderRead = 0; /* wrong atom data */</a>
<a name="ln1530">                        num_atoms = INCHI_INP_ERROR_RET; /* was 0, error */</a>
<a name="ln1531">                        *err      = INCHI_INP_ERROR_ERR;     /* 40 */</a>
<a name="ln1532">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong atoms data&quot;);</a>
<a name="ln1533">                        goto bypass_end_of_INChI;</a>
<a name="ln1534">                    }</a>
<a name="ln1535">                    atom[i].elname[0] = *p ++;</a>
<a name="ln1536">                    /* element, second char */</a>
<a name="ln1537">                    if ( isalpha( UCINT *p ) &amp;&amp; islower( UCINT *p ) ) {</a>
<a name="ln1538">                        atom[i].elname[1] = *p ++;</a>
<a name="ln1539">                    }</a>
<a name="ln1540">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1541">#else</a>
<a name="ln1542">                    atom[i].el_number = get_periodic_table_number( atom[i].elname );</a>
<a name="ln1543">#endif</a>
<a name="ln1544">                    /* bonds' valence */</a>
<a name="ln1545">                    if ( isdigit( UCINT *p ) ) {</a>
<a name="ln1546">                        AT_BONDS_VAL(atom,i) = (char)strtol( p, &amp;q, 10 );</a>
<a name="ln1547">                        if ( !AT_BONDS_VAL(atom,i) )</a>
<a name="ln1548">                            AT_BONDS_VAL(atom,i) = ISOLATED_ATOM; /* same convention as in MOLfile, found zero bonds valence */</a>
<a name="ln1549">                        p = q;</a>
<a name="ln1550">                    }</a>
<a name="ln1551">                    /* charge */</a>
<a name="ln1552">                    atom[i].charge = (*p == '+')? 1 : (*p == '-')? -1 : 0;</a>
<a name="ln1553">                    if ( atom[i].charge ) {</a>
<a name="ln1554">                        p ++;</a>
<a name="ln1555">                        if ( isdigit( UCINT *p ) ) {</a>
<a name="ln1556">                            atom[i].charge *= (S_CHAR)(strtol( p, &amp;q, 10 ) &amp; CHAR_MASK);</a>
<a name="ln1557">                            p = q;</a>
<a name="ln1558">                        }</a>
<a name="ln1559">                    }</a>
<a name="ln1560">                    /* radical */</a>
<a name="ln1561">                    if ( *p == '.' ) {</a>
<a name="ln1562">                        p ++;</a>
<a name="ln1563">                        if ( isdigit( UCINT *p ) ) {</a>
<a name="ln1564">                            atom[i].radical = (S_CHAR)strtol( p, &amp;q, 10 );</a>
<a name="ln1565">                            p = q;</a>
<a name="ln1566">                        }</a>
<a name="ln1567">                    }</a>
<a name="ln1568">                    /* isotopic mass */</a>
<a name="ln1569">                    if ( *p == 'i' ) {</a>
<a name="ln1570">                        p ++;</a>
<a name="ln1571">                        if ( isdigit( UCINT *p ) ) {</a>
<a name="ln1572">                            int mw = strtol( p, &amp;q, 10 );</a>
<a name="ln1573">                            p = q;</a>
<a name="ln1574">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1575">                            atom[i].isotopic_mass = mw;</a>
<a name="ln1576">#else</a>
<a name="ln1577">                            mw -= get_atw_from_elnum( atom[i].el_number );</a>
<a name="ln1578">                            if ( mw &gt;= 0 )</a>
<a name="ln1579">                                mw ++;</a>
<a name="ln1580">                            atom[i].iso_atw_diff = mw;</a>
<a name="ln1581">#endif</a>
<a name="ln1582">                        }</a>
<a name="ln1583">                    }</a>
<a name="ln1584">                    /* parity */</a>
<a name="ln1585">                    switch( *p ) {</a>
<a name="ln1586">                    case 'o':</a>
<a name="ln1587">                        parity = INCHI_PARITY_ODD;</a>
<a name="ln1588">                        p ++;</a>
<a name="ln1589">                        break;</a>
<a name="ln1590">                    case 'e':</a>
<a name="ln1591">                        parity = INCHI_PARITY_EVEN;</a>
<a name="ln1592">                        p ++;</a>
<a name="ln1593">                        break;</a>
<a name="ln1594">                    case 'u':</a>
<a name="ln1595">                        parity = INCHI_PARITY_UNKNOWN;</a>
<a name="ln1596">                        p ++;</a>
<a name="ln1597">                        break;</a>
<a name="ln1598">                    case '?':</a>
<a name="ln1599">                        parity = INCHI_PARITY_UNDEFINED;</a>
<a name="ln1600">                        p ++;</a>
<a name="ln1601">                        break;</a>
<a name="ln1602">                    default:</a>
<a name="ln1603">                        parity = 0;</a>
<a name="ln1604">                        break;</a>
<a name="ln1605">                    }</a>
<a name="ln1606">                    if ( parity ) {</a>
<a name="ln1607">                        atom_stereo0D[len_stereo0D].central_atom = i;</a>
<a name="ln1608">                        atom_stereo0D[len_stereo0D].parity       = parity;</a>
<a name="ln1609">                        atom_stereo0D[len_stereo0D].type         = INCHI_StereoType_Tetrahedral;</a>
<a name="ln1610">                        len_stereo0D ++;</a>
<a name="ln1611">                    }</a>
<a name="ln1612">                    /* isotopic h, d, t */</a>
<a name="ln1613">                    for ( k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln1614">                        if ( *p == szIsoH[k] ) {</a>
<a name="ln1615">                            NUM_ISO_Hk(atom,i,k) = 1;</a>
<a name="ln1616">                            p ++;</a>
<a name="ln1617">                            if ( isdigit( UCINT *p ) ) {</a>
<a name="ln1618">                                NUM_ISO_Hk(atom,i,k) = (char)strtol( p, &amp;q, 10 );</a>
<a name="ln1619">                                p = q;</a>
<a name="ln1620">                            }</a>
<a name="ln1621">                        }</a>
<a name="ln1622">                    }</a>
<a name="ln1623">                    i ++;</a>
<a name="ln1624">                }</a>
<a name="ln1625">                if ( !bItemIsOver || p - szLine != res || i != num_atoms ) {</a>
<a name="ln1626">                    num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln1627">                    *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1628">                    MOLFILE_ERR_SET (*err, 0, &quot;Wrong number of atoms&quot;);</a>
<a name="ln1629">                    goto bypass_end_of_INChI;</a>
<a name="ln1630">                }</a>
<a name="ln1631">                /********************** bonds xml ****************************/</a>
<a name="ln1632">                res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine );</a>
<a name="ln1633">                if ( res &lt;= 0 ) {</a>
<a name="ln1634">                    num_atoms = 0; /* no data */</a>
<a name="ln1635">                    goto bypass_end_of_INChI;</a>
<a name="ln1636">                }</a>
<a name="ln1637">                if ( memcmp(szLine, sStructRevXmlRevBn, sizeof(sStructRevXmlRevBn)-1) ) {</a>
<a name="ln1638">                    bHeaderRead = 0; /* invalid reversibility info; look for another header */</a>
<a name="ln1639">                    continue;</a>
<a name="ln1640">                }</a>
<a name="ln1641">                /* read (the head of) the xml bonds line */</a>
<a name="ln1642">                res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine );</a>
<a name="ln1643">                if ( res &lt;= 0 ) {</a>
<a name="ln1644">                    num_atoms = INCHI_INP_ERROR_RET; /* was 0; error: no data -- eof? */</a>
<a name="ln1645">                    *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1646">                    goto bypass_end_of_INChI;</a>
<a name="ln1647">                }</a>
<a name="ln1648">                i = 1;</a>
<a name="ln1649">                bItemIsOver = 0;</a>
<a name="ln1650">                res2 = bTooLongLine2 = -1;</a>
<a name="ln1651">                p = szLine;</a>
<a name="ln1652">                if ( !memcmp(szLine, sStructRevXmlRevBnEnd, sizeof(sStructRevXmlRevBnEnd)-1) ) {</a>
<a name="ln1653">                    /* empty bonds section */</a>
<a name="ln1654">                    res = 0;</a>
<a name="ln1655">                    bItemIsOver = 1;</a>
<a name="ln1656">                }</a>
<a name="ln1657">                /* read all bonds (xml), starting from atom 1 (not 0) */</a>
<a name="ln1658">                while ( i &lt; num_atoms ) {</a>
<a name="ln1659">                    pos = p - szLine;</a>
<a name="ln1660">                    if ( !bItemIsOver &amp;&amp; (int)sizeof(szLine)-res + pos &gt; (int)sizeof(szNextLine) ) {</a>
<a name="ln1661">                        /* load next line if possible */</a>
<a name="ln1662">                        res2 = inchi_ios_gets( szNextLine, sizeof(szNextLine)-1, inp_molfile, &amp;bTooLongLine2 );</a>
<a name="ln1663">                        if ( res2 &gt; 0 &amp;&amp; memcmp(szNextLine, sStructRevXmlRevBnEnd, sizeof(sStructRevXmlRevBnEnd)-1) ) {</a>
<a name="ln1664">                            if ( pos ) {</a>
<a name="ln1665">                                res -= pos;  /* number of chars left to process in szLine */</a>
<a name="ln1666">                                memmove( szLine, p, res*sizeof(szLine[0]) ); /* move them to the start of the line */</a>
<a name="ln1667">                            }</a>
<a name="ln1668">                            memcpy( szLine+res, szNextLine, (res2+1)*sizeof(szNextLine[0]) );</a>
<a name="ln1669">                            res += res2;</a>
<a name="ln1670">                            szLine[res] = '\0';</a>
<a name="ln1671">                            bTooLongLine = bTooLongLine2;</a>
<a name="ln1672">                            p = szLine;</a>
<a name="ln1673">                        } else {</a>
<a name="ln1674">                            bItemIsOver = 1;</a>
<a name="ln1675">                        }</a>
<a name="ln1676">                    }</a>
<a name="ln1677">                    if ( i &gt;= num_atoms ) {</a>
<a name="ln1678">                        break;</a>
<a name="ln1679">                    }</a>
<a name="ln1680">                    /* bond, first char */</a>
<a name="ln1681">                    if ( *p == ';' ) {</a>
<a name="ln1682">                        p ++;</a>
<a name="ln1683">                        i ++;</a>
<a name="ln1684">                        continue;</a>
<a name="ln1685">                    }</a>
<a name="ln1686">                    if ( !isalpha( UCINT *p ) ) {</a>
<a name="ln1687">                        num_atoms = INCHI_INP_ERROR_RET; /* error in input data */</a>
<a name="ln1688">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1689">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong bonds data&quot;);</a>
<a name="ln1690">                        goto bypass_end_of_INChI;</a>
<a name="ln1691">                    }</a>
<a name="ln1692">                    bond_char = *p ++;</a>
<a name="ln1693">                    /* bond parity */</a>
<a name="ln1694">                    switch( *p ) {</a>
<a name="ln1695">                    case '-':</a>
<a name="ln1696">                        bond_parity = INCHI_PARITY_ODD;</a>
<a name="ln1697">                        p ++;</a>
<a name="ln1698">                        break;</a>
<a name="ln1699">                    case '+':</a>
<a name="ln1700">                        bond_parity = INCHI_PARITY_EVEN;</a>
<a name="ln1701">                        p ++;</a>
<a name="ln1702">                        break;</a>
<a name="ln1703">                    case 'u':</a>
<a name="ln1704">                        bond_parity = INCHI_PARITY_UNKNOWN;</a>
<a name="ln1705">                        p ++;</a>
<a name="ln1706">                        break;</a>
<a name="ln1707">                    case '?':</a>
<a name="ln1708">                        bond_parity = INCHI_PARITY_UNDEFINED;</a>
<a name="ln1709">                        p ++;</a>
<a name="ln1710">                        break;</a>
<a name="ln1711">                    default:</a>
<a name="ln1712">                        bond_parity = 0;</a>
<a name="ln1713">                        break;</a>
<a name="ln1714">                    }</a>
<a name="ln1715">                    if ( bond_parity ) {</a>
<a name="ln1716">                        switch( *p ) {</a>
<a name="ln1717">                        case '-':</a>
<a name="ln1718">                            bond_parityNM = INCHI_PARITY_ODD;</a>
<a name="ln1719">                            p ++;</a>
<a name="ln1720">                            break;</a>
<a name="ln1721">                        case '+':</a>
<a name="ln1722">                            bond_parityNM = INCHI_PARITY_EVEN;</a>
<a name="ln1723">                            p ++;</a>
<a name="ln1724">                            break;</a>
<a name="ln1725">                        case 'u':</a>
<a name="ln1726">                            bond_parityNM = INCHI_PARITY_UNKNOWN;</a>
<a name="ln1727">                            p ++;</a>
<a name="ln1728">                            break;</a>
<a name="ln1729">                        case '?':</a>
<a name="ln1730">                            bond_parityNM = INCHI_PARITY_UNDEFINED;</a>
<a name="ln1731">                            p ++;</a>
<a name="ln1732">                            break;</a>
<a name="ln1733">                        default:</a>
<a name="ln1734">                            bond_parityNM = 0;</a>
<a name="ln1735">                            break;</a>
<a name="ln1736">                        }</a>
<a name="ln1737">                    } else {</a>
<a name="ln1738">                        bond_parityNM = 0;</a>
<a name="ln1739">                    }</a>
<a name="ln1740"> </a>
<a name="ln1741">                    /* neighbor of the current atom */</a>
<a name="ln1742">                    if ( !isdigit( UCINT *p ) ) {</a>
<a name="ln1743">                        num_atoms = INCHI_INP_ERROR_RET; /* error in input data */</a>
<a name="ln1744">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1745">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong bonds data&quot;);</a>
<a name="ln1746">                        goto bypass_end_of_INChI;</a>
<a name="ln1747">                    }</a>
<a name="ln1748">                    neigh = (int)strtol( p, &amp;q, 10 )-1;</a>
<a name="ln1749"> </a>
<a name="ln1750">                    if ( i &gt;= num_atoms || neigh &gt;= num_atoms ) {</a>
<a name="ln1751">                        num_atoms = INCHI_INP_ERROR_RET; /* error in input data */</a>
<a name="ln1752">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1753">                        MOLFILE_ERR_SET (*err, 0, &quot;Bond to nonexistent atom&quot;);</a>
<a name="ln1754">                        goto bypass_end_of_INChI;</a>
<a name="ln1755">                    }</a>
<a name="ln1756">                    p = q;</a>
<a name="ln1757">                    bond_stereo1 = bond_stereo2 = 0;</a>
<a name="ln1758"> </a>
<a name="ln1759">                    /* bond type &amp; 2D stereo */</a>
<a name="ln1760">                    switch( bond_char ) {</a>
<a name="ln1761">                    case 'v':</a>
<a name="ln1762">                        bond_type    = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1763">                        bond_stereo1 = INCHI_BOND_STEREO_SINGLE_1EITHER;</a>
<a name="ln1764">                        bond_stereo2 = INCHI_BOND_STEREO_SINGLE_2EITHER;</a>
<a name="ln1765">                        break;</a>
<a name="ln1766">                    case 'V':</a>
<a name="ln1767">                        bond_type    = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1768">                        bond_stereo1 = INCHI_BOND_STEREO_SINGLE_2EITHER;</a>
<a name="ln1769">                        bond_stereo2 = INCHI_BOND_STEREO_SINGLE_1EITHER;</a>
<a name="ln1770">                        break;</a>
<a name="ln1771">                    case 'w':</a>
<a name="ln1772">                        bond_type    = INCHI_BOND_TYPE_DOUBLE;</a>
<a name="ln1773">                        bond_stereo1 = </a>
<a name="ln1774">                        bond_stereo2 = INCHI_BOND_STEREO_DOUBLE_EITHER;</a>
<a name="ln1775">                        break;</a>
<a name="ln1776">                    case 's':</a>
<a name="ln1777">                        bond_type    = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1778">                        break;</a>
<a name="ln1779">                    case 'd':</a>
<a name="ln1780">                        bond_type    = INCHI_BOND_TYPE_DOUBLE;</a>
<a name="ln1781">                        break;</a>
<a name="ln1782">                    case 't':</a>
<a name="ln1783">                        bond_type    = INCHI_BOND_TYPE_TRIPLE;</a>
<a name="ln1784">                        break;</a>
<a name="ln1785">                    case 'a':</a>
<a name="ln1786">                        bond_type    = INCHI_BOND_TYPE_ALTERN;</a>
<a name="ln1787">                        break;</a>
<a name="ln1788">                    case 'p':</a>
<a name="ln1789">                        bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1790">                        bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_1UP;</a>
<a name="ln1791">                        bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_2UP;</a>
<a name="ln1792">                        break;</a>
<a name="ln1793">                    case 'P':</a>
<a name="ln1794">                        bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1795">                        bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_2UP;</a>
<a name="ln1796">                        bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_1UP;</a>
<a name="ln1797">                        break;</a>
<a name="ln1798">                    case 'n':</a>
<a name="ln1799">                        bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1800">                        bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_1DOWN;</a>
<a name="ln1801">                        bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_2DOWN;</a>
<a name="ln1802">                        break;</a>
<a name="ln1803">                    case 'N':</a>
<a name="ln1804">                        bond_type    =  INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln1805">                        bond_stereo1 =  INCHI_BOND_STEREO_SINGLE_2DOWN;</a>
<a name="ln1806">                        bond_stereo2 =  INCHI_BOND_STEREO_SINGLE_1DOWN;</a>
<a name="ln1807">                        break;</a>
<a name="ln1808">                    default:</a>
<a name="ln1809">                        num_atoms = INCHI_INP_ERROR_RET; /* error */</a>
<a name="ln1810">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1811">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong bond type&quot;);</a>
<a name="ln1812">                        goto bypass_end_of_INChI;</a>
<a name="ln1813">                    }</a>
<a name="ln1814">                    k = AT_NUM_BONDS(atom[i]) ++;</a>
<a name="ln1815">                    atom[i].bond_type[k]   = bond_type;</a>
<a name="ln1816">                    atom[i].bond_stereo[k] = bond_stereo1;</a>
<a name="ln1817">                    atom[i].neighbor[k]    = (ATOM_NUMBER)neigh;</a>
<a name="ln1818">                    k2 = AT_NUM_BONDS(atom[neigh]) ++;</a>
<a name="ln1819">                    atom[neigh].bond_type[k2]   = bond_type;</a>
<a name="ln1820">                    atom[neigh].bond_stereo[k2] = bond_stereo2;</a>
<a name="ln1821">                    atom[neigh].neighbor[k2]    = (ATOM_NUMBER)i;</a>
<a name="ln1822">                    bond_parity |= (bond_parityNM &lt;&lt; SB_PARITY_SHFT);</a>
<a name="ln1823"> </a>
<a name="ln1824">                    if ( bond_parity ) {</a>
<a name="ln1825">                        if ( max_len_stereo0D &lt;= len_stereo0D ) {</a>
<a name="ln1826">                            /* realloc atom_Stereo0D */</a>
<a name="ln1827">                            inchi_Stereo0D *new_atom_stereo0D = CreateInchi_Stereo0D( max_len_stereo0D+num_atoms );</a>
<a name="ln1828">                            if ( !new_atom_stereo0D ) {</a>
<a name="ln1829">                                num_atoms = INCHI_INP_FATAL_RET; /* fatal error: cannot allocate */</a>
<a name="ln1830">                                *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln1831">                                MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln1832">                                goto bypass_end_of_INChI;</a>
<a name="ln1833">                            }</a>
<a name="ln1834">                            memcpy( new_atom_stereo0D, atom_stereo0D, len_stereo0D * sizeof(*atom_stereo0D) );</a>
<a name="ln1835">                            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln1836">                            atom_stereo0D = new_atom_stereo0D;</a>
<a name="ln1837">                            max_len_stereo0D += num_atoms;</a>
<a name="ln1838">                        }</a>
<a name="ln1839">                        /* (a) i may be allene endpoint and     neigh = allene middle point or</a>
<a name="ln1840">                           (b) i may be allene middle point and neigh = allene endpoint</a>
<a name="ln1841">                           !!!!! CURRENTLY ONLY (b) IS ALLOWED !!!!!</a>
<a name="ln1842">                        */</a>
<a name="ln1843">                        atom_stereo0D[len_stereo0D].neighbor[1] = neigh; /* neigh &lt; i */</a>
<a name="ln1844">                        atom_stereo0D[len_stereo0D].neighbor[2] = i;</a>
<a name="ln1845">                        atom_stereo0D[len_stereo0D].parity      = bond_parity;</a>
<a name="ln1846">                        atom_stereo0D[len_stereo0D].type        = INCHI_StereoType_DoubleBond; /* incl allenes &amp; cumulenes */</a>
<a name="ln1847">                        len_stereo0D ++;</a>
<a name="ln1848">                    }</a>
<a name="ln1849">                }</a>
<a name="ln1850">                if ( !bItemIsOver || p - szLine != res || i != num_atoms ) {</a>
<a name="ln1851">                    num_atoms = INCHI_INP_ERROR_RET; /* error in input data */</a>
<a name="ln1852">                    *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1853">                    MOLFILE_ERR_SET (*err, 0, &quot;Wrong number of bonds&quot;);</a>
<a name="ln1854">                    goto bypass_end_of_INChI;</a>
<a name="ln1855">                }</a>
<a name="ln1856">                /********************** coordinates xml ****************************/</a>
<a name="ln1857">                if ( (pszCoord = (MOL_COORD*) inchi_malloc(inchi_max(num_atoms,1) * sizeof(MOL_COORD))) ) {</a>
<a name="ln1858">                    memset( pszCoord, ' ', inchi_max(num_atoms,1) * sizeof(MOL_COORD));</a>
<a name="ln1859">                    res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine );</a>
<a name="ln1860">                    if ( res &lt;= 0  ||</a>
<a name="ln1861">                         /* compare the header */</a>
<a name="ln1862">                         memcmp(szLine, sStructRevXmlRevXYZ, sizeof(sStructRevXmlRevXYZ)-1) ||</a>
<a name="ln1863">                         /* read (the head of) the coordinates (xml) line */</a>
<a name="ln1864">                         0 &gt;= (res = inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine ))) {</a>
<a name="ln1865">                        num_atoms = INCHI_INP_ERROR_RET; /* error in input data: atoms, bonds &amp; coord must be present together */</a>
<a name="ln1866">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1867">                        MOLFILE_ERR_SET (*err, 0, &quot;Missing atom coordinates data&quot;);</a>
<a name="ln1868">                        goto bypass_end_of_INChI;</a>
<a name="ln1869">                    }</a>
<a name="ln1870">                    i = 0;</a>
<a name="ln1871">                    bItemIsOver = 0;</a>
<a name="ln1872">                    res2 = bTooLongLine2 = -1;</a>
<a name="ln1873">                    p = szLine;</a>
<a name="ln1874">                    if ( !memcmp(szLine, sStructRevXmlRevXYZEnd, sizeof(sStructRevXmlRevXYZEnd)-1) ) {</a>
<a name="ln1875">                        /* empty bonds section */</a>
<a name="ln1876">                        res = 0;</a>
<a name="ln1877">                        bItemIsOver = 1;</a>
<a name="ln1878">                    }</a>
<a name="ln1879">                    /* read all coordinates (xml), starting from atom 1 (not 0) */</a>
<a name="ln1880">                    while ( i &lt; num_atoms ) {</a>
<a name="ln1881">                        pos = p - szLine;</a>
<a name="ln1882">                        if ( !bItemIsOver &amp;&amp; (int)sizeof(szLine)-res + pos &gt; (int)sizeof(szNextLine) ) {</a>
<a name="ln1883">                            /* load next line if possible */</a>
<a name="ln1884">                            res2 = inchi_ios_gets( szNextLine, sizeof(szNextLine)-1, inp_molfile, &amp;bTooLongLine2 );</a>
<a name="ln1885">                            if ( res2 &gt; 0 &amp;&amp; memcmp(szNextLine, sStructRevXmlRevXYZEnd, sizeof(sStructRevXmlRevXYZEnd)-1) ) {</a>
<a name="ln1886">                                if ( pos ) {</a>
<a name="ln1887">                                    res -= pos;  /* number of chars left to process in szLine */</a>
<a name="ln1888">                                    memmove( szLine, p, res*sizeof(szLine[0]) ); /* move them to the start of the line */</a>
<a name="ln1889">                                }</a>
<a name="ln1890">                                memcpy( szLine+res, szNextLine, (res2+1)*sizeof(szNextLine[0]) );</a>
<a name="ln1891">                                res += res2;</a>
<a name="ln1892">                                szLine[res] = '\0';</a>
<a name="ln1893">                                bTooLongLine = bTooLongLine2;</a>
<a name="ln1894">                                p = szLine;</a>
<a name="ln1895">                            } else {</a>
<a name="ln1896">                                bItemIsOver = 1;</a>
<a name="ln1897">                            }</a>
<a name="ln1898">                        }</a>
<a name="ln1899">                        /* coord, first char */</a>
<a name="ln1900">                        if ( *p == ';' ) {</a>
<a name="ln1901">                            for ( k = 0; k &lt; NUM_COORD; k ++ ) {</a>
<a name="ln1902">                                pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln1903">                            }</a>
<a name="ln1904">                            p ++;</a>
<a name="ln1905">                            i ++;</a>
<a name="ln1906">                            continue;</a>
<a name="ln1907">                        }</a>
<a name="ln1908">                        for ( k = 0; k &lt; 3; k ++ ) {</a>
<a name="ln1909">                            double xyz;</a>
<a name="ln1910">                            bNonZeroXYZ = 0;</a>
<a name="ln1911">                            if ( *p == ';' ) {</a>
<a name="ln1912">                                pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln1913">                                xyz = 0.0;</a>
<a name="ln1914">                            } else</a>
<a name="ln1915">                            if ( *p == ',' ) {</a>
<a name="ln1916">                                /* empty */</a>
<a name="ln1917">                                pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln1918">                                xyz = 0.0;</a>
<a name="ln1919">                                p ++;</a>
<a name="ln1920">                            } else {</a>
<a name="ln1921">                                xyz = strtod( p, &amp;q );</a>
<a name="ln1922">                                bNonZeroXYZ = fabs(xyz) &gt; MIN_BOND_LENGTH;</a>
<a name="ln1923">                                if ( q != NULL ) {</a>
<a name="ln1924">                                    memcpy( pszCoord[i]+LEN_COORD*k, p, q-p );</a>
<a name="ln1925">                                    if ( *q == ',' )</a>
<a name="ln1926">                                        q ++;</a>
<a name="ln1927">                                    p = q;</a>
<a name="ln1928">                                } else {</a>
<a name="ln1929">                                    pszCoord[i][LEN_COORD*k + 4] = '0';</a>
<a name="ln1930">                                }</a>
<a name="ln1931">                            }</a>
<a name="ln1932">                            switch( k ) {</a>
<a name="ln1933">                            case 0:</a>
<a name="ln1934">                                atom[i].x = xyz;</a>
<a name="ln1935">                                b2D |= bNonZeroXYZ;</a>
<a name="ln1936">                                break;</a>
<a name="ln1937">                            case 1:</a>
<a name="ln1938">                                atom[i].y = xyz;</a>
<a name="ln1939">                                b2D |= bNonZeroXYZ;</a>
<a name="ln1940">                                break;</a>
<a name="ln1941">                            case 2:</a>
<a name="ln1942">                                b3D |= bNonZeroXYZ;</a>
<a name="ln1943">                                atom[i].z = xyz;</a>
<a name="ln1944">                                break;</a>
<a name="ln1945">                            }</a>
<a name="ln1946">                        }</a>
<a name="ln1947">                        if ( *p == ';' ) {</a>
<a name="ln1948">                            p ++;  /* end of this triple of coordinates */</a>
<a name="ln1949">                            i ++;</a>
<a name="ln1950">                        } else {</a>
<a name="ln1951">                            num_atoms = INCHI_INP_ERROR_RET; /* error in input data: atoms, bonds &amp; coord must be present together */</a>
<a name="ln1952">                            *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1953">                            MOLFILE_ERR_SET (*err, 0, &quot;Wrong atom coordinates data&quot;);</a>
<a name="ln1954">                            goto bypass_end_of_INChI;</a>
<a name="ln1955">                        }</a>
<a name="ln1956">                    }</a>
<a name="ln1957">                    if ( !bItemIsOver || p - szLine != res || i != num_atoms ) {</a>
<a name="ln1958">                        num_atoms = INCHI_INP_ERROR_RET; /* error in input data: atoms, bonds &amp; coord must be present together */</a>
<a name="ln1959">                        *err      = INCHI_INP_ERROR_ERR;</a>
<a name="ln1960">                        MOLFILE_ERR_SET (*err, 0, &quot;Wrong number of coordinates&quot;);</a>
<a name="ln1961">                        goto bypass_end_of_INChI;</a>
<a name="ln1962">                    }</a>
<a name="ln1963">                } else { /* allocation failed */</a>
<a name="ln1964">                    num_atoms = INCHI_INP_FATAL_RET; </a>
<a name="ln1965">                    *err      = INCHI_INP_FATAL_ERR;</a>
<a name="ln1966">                    MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln1967">                    goto bypass_end_of_INChI;</a>
<a name="ln1968">                }</a>
<a name="ln1969">                /* set special valences and implicit H (xml) */</a>
<a name="ln1970">                b23D = b2D | b3D;</a>
<a name="ln1971">                b2D = b3D = 0;</a>
<a name="ln1972">                if ( at ) {</a>
<a name="ln1973">                    if ( !*at ) {</a>
<a name="ln1974">                        int a1, a2, n1, n2, valence;</a>
<a name="ln1975">                        int chem_bonds_valence;</a>
<a name="ln1976">                        int    nX=0, nY=0, nZ=0, nXYZ;</a>
<a name="ln1977">                        *at = atom;</a>
<a name="ln1978">                        /* special valences */</a>
<a name="ln1979">                        for ( bNonMetal = 0; bNonMetal &lt; 1 /*2*/; bNonMetal ++ ) {</a>
<a name="ln1980">                            for ( a1 = 0; a1 &lt; num_atoms; a1 ++ ) {</a>
<a name="ln1981">                                int num_bond_type[MAX_INPUT_BOND_TYPE - MIN_INPUT_BOND_TYPE + 1];</a>
<a name="ln1982">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1983">#else</a>
<a name="ln1984">                                int bHasMetalNeighbor=0;</a>
<a name="ln1985">#endif</a>
<a name="ln1986">                                memset( num_bond_type, 0, sizeof(num_bond_type) );</a>
<a name="ln1987"> </a>
<a name="ln1988">                                valence = AT_BONDS_VAL(atom, a1); /*  save atom valence if available */</a>
<a name="ln1989">                                AT_BONDS_VAL(atom, a1) = 0;</a>
<a name="ln1990">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln1991">#else</a>
<a name="ln1992">                                atom[a1].orig_at_number = a1+1;</a>
<a name="ln1993">#endif</a>
<a name="ln1994">                                nX = nY = nZ = 0;</a>
<a name="ln1995">                                for ( n1 = 0; n1 &lt; AT_NUM_BONDS(atom[a1]); n1 ++ ) {</a>
<a name="ln1996">                                    bond_type = atom[a1].bond_type[n1] - MIN_INPUT_BOND_TYPE;</a>
<a name="ln1997">                                    if ( bond_type &lt; 0 || bond_type &gt; MAX_INPUT_BOND_TYPE - MIN_INPUT_BOND_TYPE ) {</a>
<a name="ln1998">                                        bond_type = 0; /* cannot happen */</a>
<a name="ln1999">                                        MOLFILE_ERR_SET (*err, 0, &quot;Unknown bond type in InChI aux assigned as a single bond&quot;);</a>
<a name="ln2000">                                    }</a>
<a name="ln2001"> </a>
<a name="ln2002">                                    num_bond_type[ bond_type ] ++;</a>
<a name="ln2003">                                    nNumBonds ++;</a>
<a name="ln2004">                                    if ( b23D ) {</a>
<a name="ln2005">                                        neigh = atom[a1].neighbor[n1];</a>
<a name="ln2006">                                        nX |= (fabs(atom[a1].x - atom[neigh].x) &gt; MIN_BOND_LENGTH);</a>
<a name="ln2007">                                        nY |= (fabs(atom[a1].y - atom[neigh].y) &gt; MIN_BOND_LENGTH);</a>
<a name="ln2008">                                        nZ |= (fabs(atom[a1].z - atom[neigh].z) &gt; MIN_BOND_LENGTH);</a>
<a name="ln2009">                                    }</a>
<a name="ln2010">                                }</a>
<a name="ln2011">                                chem_bonds_valence = 0;</a>
<a name="ln2012">                                for ( n1 = 0; MIN_INPUT_BOND_TYPE + n1 &lt;= 3 &amp;&amp; MIN_INPUT_BOND_TYPE + n1 &lt;= MAX_INPUT_BOND_TYPE; n1 ++ ) {</a>
<a name="ln2013">                                    chem_bonds_valence += (MIN_INPUT_BOND_TYPE + n1) * num_bond_type[n1];</a>
<a name="ln2014">                                }</a>
<a name="ln2015">                                if ( MIN_INPUT_BOND_TYPE &lt;= INCHI_BOND_TYPE_ALTERN &amp;&amp; INCHI_BOND_TYPE_ALTERN &lt;= MAX_INPUT_BOND_TYPE &amp;&amp;</a>
<a name="ln2016">                                     ( n2 = num_bond_type[INCHI_BOND_TYPE_ALTERN-MIN_INPUT_BOND_TYPE] ) ) {</a>
<a name="ln2017">                                    /* accept input aromatic bonds for now */</a>
<a name="ln2018">                                    switch ( n2 ) {</a>
<a name="ln2019">                                    case 2:</a>
<a name="ln2020">                                        chem_bonds_valence += 3;  /* =A- */</a>
<a name="ln2021">                                        break;</a>
<a name="ln2022">                                    case 3:</a>
<a name="ln2023">                                        chem_bonds_valence += 4;  /* =A&lt; */</a>
<a name="ln2024">                                        break;</a>
<a name="ln2025">                                    default:</a>
<a name="ln2026">                                        /*  if 1 or &gt;= 4 aromatic bonds then replace such bonds with single bonds */</a>
<a name="ln2027">                                        for ( n1 = 0; n1 &lt; AT_NUM_BONDS(atom[a1]); n1 ++ ) {</a>
<a name="ln2028">                                            if ( atom[a1].bond_type[n1] == INCHI_BOND_TYPE_ALTERN ) {</a>
<a name="ln2029">                                                ATOM_NUMBER *p1;</a>
<a name="ln2030">                                                a2 = atom[a1].neighbor[n1];</a>
<a name="ln2031">                                                p1 = IN_NEIGH_LIST( atom[a2].neighbor, (ATOM_NUMBER)a1, AT_NUM_BONDS(atom[a2]) );</a>
<a name="ln2032">                                                if ( p1 ) {</a>
<a name="ln2033">                                                    atom[a1].bond_type[n1] = </a>
<a name="ln2034">                                                    atom[a2].bond_type[p1-atom[a2].neighbor] = INCHI_BOND_TYPE_SINGLE;</a>
<a name="ln2035">                                                } else {</a>
<a name="ln2036">                                                    *err = -2;  /*  Program error */</a>
<a name="ln2037">                                                    MOLFILE_ERR_SET (*err, 0, &quot;Program error interpreting InChI aux&quot;);</a>
<a name="ln2038">                                                    num_atoms = 0;</a>
<a name="ln2039">                                                    goto bypass_end_of_INChI; /*  no structure */</a>
<a name="ln2040">                                                }</a>
<a name="ln2041">                                            }</a>
<a name="ln2042">                                        }</a>
<a name="ln2043">                                        chem_bonds_valence += n2;</a>
<a name="ln2044">                                        *err |= 32; /*  Unrecognized aromatic bond(s) replaced with single */</a>
<a name="ln2045">                                        MOLFILE_ERR_SET (*err, 0, &quot;Atom has 1 or more than 3 aromatic bonds&quot;);</a>
<a name="ln2046">                                        break;</a>
<a name="ln2047">                                    }</a>
<a name="ln2048">                                }</a>
<a name="ln2049"> </a>
<a name="ln2050">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln2051">                                /*************************************************************************************</a>
<a name="ln2052">                                 *</a>
<a name="ln2053">                                 *  Set number of hydrogen atoms</a>
<a name="ln2054">                                 */</a>
<a name="ln2055">                                {</a>
<a name="ln2056">                                    int num_iso_H;</a>
<a name="ln2057">                                    num_iso_H = atom[a1].num_iso_H[1] + atom[a1].num_iso_H[2] + atom[a1].num_iso_H[3];</a>
<a name="ln2058">                                    if ( valence == ISOLATED_ATOM ) {</a>
<a name="ln2059">                                        atom[a1].num_iso_H[0] = 0;</a>
<a name="ln2060">                                    } else</a>
<a name="ln2061">                                    if ( valence &amp;&amp; valence &gt;= chem_bonds_valence ) {</a>
<a name="ln2062">                                        atom[a1].num_iso_H[0] = valence - chem_bonds_valence;</a>
<a name="ln2063">                                    } else</a>
<a name="ln2064">                                    if ( valence || bDoNotAddH ) {</a>
<a name="ln2065">                                        atom[a1].num_iso_H[0] = 0;</a>
<a name="ln2066">                                    } else</a>
<a name="ln2067">                                    if ( !bDoNotAddH ) {</a>
<a name="ln2068">                                        atom[a1].num_iso_H[0] = -1; /* auto add H */</a>
<a name="ln2069">                                    }</a>
<a name="ln2070">                                }</a>
<a name="ln2071">#else                                </a>
<a name="ln2072">                                /* added 2006-07-19 to process aromatic bonds same way as from molfile */</a>
<a name="ln2073">                                if ( n2 &amp;&amp; !valence ) {</a>
<a name="ln2074">                                    int num_H = NUMH(atom, a1); /* only isotopic */</a>
<a name="ln2075">                                    int chem_valence = chem_bonds_valence;</a>
<a name="ln2076">                                    int bUnusualValenceArom = </a>
<a name="ln2077">                                        detect_unusual_el_valence( (int)atom[a1].el_number, atom[a1].charge,</a>
<a name="ln2078">                                                                    atom[a1].radical, chem_valence,</a>
<a name="ln2079">                                                                    num_H, atom[a1].valence );</a>
<a name="ln2080">                                    int bUnusualValenceNoArom = </a>
<a name="ln2081">                                        detect_unusual_el_valence( (int)atom[a1].el_number, atom[a1].charge,</a>
<a name="ln2082">                                                                    atom[a1].radical, chem_valence-1,</a>
<a name="ln2083">                                                                    num_H, atom[a1].valence );</a>
<a name="ln2084">#if ( CHECK_AROMBOND2ALT == 1 )</a>
<a name="ln2085">                                    if ( bUnusualValenceArom &amp;&amp; !bUnusualValenceNoArom &amp;&amp; 0 == nBondsValToMetal( atom, a1) )</a>
<a name="ln2086">#else</a>
<a name="ln2087">                                    if ( bUnusualValenceArom &amp;&amp; !bUnusualValenceNoArom )</a>
<a name="ln2088">#endif                     </a>
<a name="ln2089">                                    {</a>
<a name="ln2090">                                        /* typically NH in 5-member aromatic ring */</a>
<a name="ln2091">                                        chem_bonds_valence --;</a>
<a name="ln2092">                                    }</a>
<a name="ln2093">                                } else</a>
<a name="ln2094">                                if ( n2 &amp;&amp; valence ) {</a>
<a name="ln2095">                                    /* atom has aromatic bonds AND the chemical valence is known */</a>
<a name="ln2096">                                    int num_H = NUMH(atom, a1);</a>
<a name="ln2097">                                    int chem_valence = chem_bonds_valence + num_H;</a>
<a name="ln2098">                                    if ( valence == chem_valence-1 ) {</a>
<a name="ln2099">                                        /* typically NH in 5-member aromatic ring */</a>
<a name="ln2100">                                        chem_bonds_valence --;</a>
<a name="ln2101">                                    }</a>
<a name="ln2102">                                }</a>
<a name="ln2103"> </a>
<a name="ln2104">                                atom[a1].chem_bonds_valence = chem_bonds_valence;</a>
<a name="ln2105">                                atom[a1].num_H = get_num_H( atom[a1].elname, atom[a1].num_H, atom[a1].num_iso_H, atom[a1].charge, atom[a1].radical,</a>
<a name="ln2106">                                                          atom[a1].chem_bonds_valence,</a>
<a name="ln2107">                                                          valence,</a>
<a name="ln2108">                                                          0, bDoNotAddH, bHasMetalNeighbor );</a>
<a name="ln2109">#endif</a>
<a name="ln2110">                            }</a>
<a name="ln2111">                        }</a>
<a name="ln2112">                        nNumBonds /= 2;</a>
<a name="ln2113">                        if ( b23D &amp;&amp; nNumBonds ) {</a>
<a name="ln2114">                            nXYZ = nX+nY+nZ;</a>
<a name="ln2115">                            b2D  = (nXYZ &gt; 0);</a>
<a name="ln2116">                            b3D  = (nXYZ == 3);</a>
<a name="ln2117">                            *num_dimensions = b3D? 3 : b2D? 2 : 0;</a>
<a name="ln2118">                            *num_bonds = nNumBonds;</a>
<a name="ln2119">                        }</a>
<a name="ln2120">                        /*======= 0D parities =================================*/</a>
<a name="ln2121">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln2122">                        if ( len_stereo0D &gt; 0 &amp;&amp; atom_stereo0D &amp;&amp; stereo0D ) {</a>
<a name="ln2123">                            *stereo0D     = atom_stereo0D;</a>
<a name="ln2124">                            *num_stereo0D = len_stereo0D;</a>
<a name="ln2125">                        } else {</a>
<a name="ln2126">                            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln2127">                            *num_stereo0D = len_stereo0D = 0;</a>
<a name="ln2128">                        }</a>
<a name="ln2129">#endif</a>
<a name="ln2130">                        for ( i = 0; i &lt; len_stereo0D; i ++ ) {</a>
<a name="ln2131">                            ATOM_NUMBER *p1, *p2;</a>
<a name="ln2132">                            int     sb_ord_from_a1 = -1, sb_ord_from_a2 = -1, bEnd1 = 0, bEnd2 = 0;</a>
<a name="ln2133">                            switch( atom_stereo0D[i].type ) {</a>
<a name="ln2134"> </a>
<a name="ln2135">                            case INCHI_StereoType_Tetrahedral:</a>
<a name="ln2136">                                a1 = atom_stereo0D[i].central_atom;</a>
<a name="ln2137">                                if ( atom_stereo0D[i].parity &amp;&amp; (AT_NUM_BONDS(atom[a1]) == 3 || AT_NUM_BONDS(atom[a1]) == 4) ) {</a>
<a name="ln2138">                                    int ii, kk = 0;</a>
<a name="ln2139">                                    if ( AT_NUM_BONDS(atom[a1]) == 3 ) {</a>
<a name="ln2140">                                        atom_stereo0D[i].neighbor[kk++] = a1;</a>
<a name="ln2141">                                    }</a>
<a name="ln2142">                                    for ( ii = 0; ii &lt; AT_NUM_BONDS(atom[a1]); ii ++ ) {</a>
<a name="ln2143">                                        atom_stereo0D[i].neighbor[kk++] = atom[a1].neighbor[ii];</a>
<a name="ln2144">                                    }</a>
<a name="ln2145">                                }</a>
<a name="ln2146">                            </a>
<a name="ln2147">                            break;</a>
<a name="ln2148"> </a>
<a name="ln2149">                            case INCHI_StereoType_DoubleBond:</a>
<a name="ln2150">#define MAX_CHAIN_LEN 20</a>
<a name="ln2151">                                a1 = atom_stereo0D[i].neighbor[1];</a>
<a name="ln2152">                                a2 = atom_stereo0D[i].neighbor[2];</a>
<a name="ln2153">                                p1 = IN_NEIGH_LIST( atom[a1].neighbor, (ATOM_NUMBER)a2, AT_NUM_BONDS(atom[a1]) );</a>
<a name="ln2154">                                p2 = IN_NEIGH_LIST( atom[a2].neighbor, (ATOM_NUMBER)a1, AT_NUM_BONDS(atom[a2]) );</a>
<a name="ln2155">                                if ( !p1 || !p2 ) {</a>
<a name="ln2156">                                    atom_stereo0D[i].type = INCHI_StereoType_None;</a>
<a name="ln2157">                                    atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln2158">                                    atom_stereo0D[i].neighbor[0] =</a>
<a name="ln2159">                                    atom_stereo0D[i].neighbor[3] = -1;</a>
<a name="ln2160">                                    *err |= 64; /* Error in cumulene stereo */</a>
<a name="ln2161">                                    MOLFILE_ERR_SET (*err, 0, &quot;0D stereobond not recognized&quot;);</a>
<a name="ln2162">                                    break;</a>
<a name="ln2163">                                }</a>
<a name="ln2164">                                /* streobond, allene, or cumulene */</a>
<a name="ln2165"> </a>
<a name="ln2166">                                sb_ord_from_a1 = p1 - atom[a1].neighbor;</a>
<a name="ln2167">                                sb_ord_from_a2 = p2 - atom[a2].neighbor;</a>
<a name="ln2168">                                </a>
<a name="ln2169">                                if ( AT_NUM_BONDS(atom[a1]) == 2 &amp;&amp;</a>
<a name="ln2170">                                      atom[a1].bond_type[0] + atom[a1].bond_type[1] == 2*INCHI_BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2171">                                      0 == inchi_NUMH2(atom, a1) &amp;&amp;</a>
<a name="ln2172">                                     (AT_NUM_BONDS(atom[a2]) != 2 ||</a>
<a name="ln2173">                                      atom[a2].bond_type[0] + atom[a2].bond_type[1] != 2*INCHI_BOND_TYPE_DOUBLE ) ) {</a>
<a name="ln2174">                                    bEnd2 = 1; /* a2 is the end-atom, a1 is middle atom */   </a>
<a name="ln2175">                                }</a>
<a name="ln2176">                                if ( AT_NUM_BONDS(atom[a2]) == 2 &amp;&amp;</a>
<a name="ln2177">                                      atom[a2].bond_type[0] + atom[a2].bond_type[1] == 2*INCHI_BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2178">                                      0 == inchi_NUMH2(atom, a2) &amp;&amp;</a>
<a name="ln2179">                                     (AT_NUM_BONDS(atom[a1]) != 2 ||</a>
<a name="ln2180">                                      atom[a1].bond_type[0] + atom[a1].bond_type[1] != 2*INCHI_BOND_TYPE_DOUBLE ) ) {</a>
<a name="ln2181">                                    bEnd1 = 1; /* a1 is the end-atom, a2 is middle atom */   </a>
<a name="ln2182">                                }</a>
<a name="ln2183">                                </a>
<a name="ln2184">                                if ( bEnd2 + bEnd1 == 1 ) {</a>
<a name="ln2185">                                    /* allene or cumulene */</a>
<a name="ln2186">                                    ATOM_NUMBER  chain[MAX_CHAIN_LEN+1], prev, cur, next;</a>
<a name="ln2187">                                    if ( bEnd2 &amp;&amp; !bEnd1 ) {</a>
<a name="ln2188">                                        cur = a1;</a>
<a name="ln2189">                                        a1 = a2;</a>
<a name="ln2190">                                        a2 = cur;</a>
<a name="ln2191">                                        sb_ord_from_a1 = sb_ord_from_a2;</a>
<a name="ln2192">                                    }</a>
<a name="ln2193">                                    sb_ord_from_a2 = -1;</a>
<a name="ln2194">                                    cur  = a1;</a>
<a name="ln2195">                                    next = a2;</a>
<a name="ln2196">                                    len = 0;</a>
<a name="ln2197">                                    chain[len++] = cur;</a>
<a name="ln2198">                                    chain[len++] = next;</a>
<a name="ln2199">                                    while ( len &lt; MAX_CHAIN_LEN ) { /* arbitrary very high upper limit to prevent infinite loop */</a>
<a name="ln2200">                                        prev = cur;</a>
<a name="ln2201">                                        cur  = next;</a>
<a name="ln2202">                                            /* follow double bond path &amp;&amp; avoid going back */</a>
<a name="ln2203">                                        if ( AT_NUM_BONDS(atom[cur]) == 2 &amp;&amp;</a>
<a name="ln2204">                                             atom[cur].bond_type[0]+atom[cur].bond_type[1] == 2*INCHI_BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2205">                                             0 == inchi_NUMH2(atom, cur) ) {</a>
<a name="ln2206">                                            next     = atom[cur].neighbor[atom[cur].neighbor[0] == prev];</a>
<a name="ln2207">                                            chain[len++] = next;</a>
<a name="ln2208">                                        } else {</a>
<a name="ln2209">                                            break;</a>
<a name="ln2210">                                        }</a>
<a name="ln2211">                                    }</a>
<a name="ln2212">                                    if ( len &gt; 2 &amp;&amp;</a>
<a name="ln2213">                                         (p2 = IN_NEIGH_LIST( atom[cur].neighbor, (ATOM_NUMBER)prev, AT_NUM_BONDS(atom[cur]))) ) {</a>
<a name="ln2214">                                        sb_ord_from_a2 = p2 - atom[cur].neighbor;</a>
<a name="ln2215">                                        a2 = cur;</a>
<a name="ln2216">                                        /* by design we need to pick up the first non-stereo-bond-neighbor as &quot;sn&quot;-atom */</a>
<a name="ln2217">                                        atom_stereo0D[i].neighbor[0] = atom[a1].neighbor[sb_ord_from_a1 == 0];</a>
<a name="ln2218">                                        atom_stereo0D[i].neighbor[1] = a1;</a>
<a name="ln2219">                                        atom_stereo0D[i].neighbor[2] = a2;</a>
<a name="ln2220">                                        atom_stereo0D[i].neighbor[3] = atom[a2].neighbor[sb_ord_from_a2 == 0];</a>
<a name="ln2221">                                        if ( len % 2 ) {</a>
<a name="ln2222">                                            atom_stereo0D[i].central_atom = chain[len/2];</a>
<a name="ln2223">                                            atom_stereo0D[i].type         = INCHI_StereoType_Allene; </a>
<a name="ln2224">                                        } else {</a>
<a name="ln2225">                                            atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln2226">                                        }</a>
<a name="ln2227">                                    } else {</a>
<a name="ln2228">                                        /* error */</a>
<a name="ln2229">                                        atom_stereo0D[i].type = INCHI_StereoType_None;</a>
<a name="ln2230">                                        atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln2231">                                        atom_stereo0D[i].neighbor[0] =</a>
<a name="ln2232">                                        atom_stereo0D[i].neighbor[3] = -1;</a>
<a name="ln2233">                                        *err |= 64; /* Error in cumulene stereo */</a>
<a name="ln2234">                                        MOLFILE_ERR_SET (*err, 0, &quot;Cumulene stereo not recognized (0D)&quot;);</a>
<a name="ln2235"> </a>
<a name="ln2236">                                    }</a>
<a name="ln2237">#undef MAX_CHAIN_LEN </a>
<a name="ln2238">                                } else {</a>
<a name="ln2239">                                    /****** a normal possibly stereogenic bond -- not an allene or cumulene *******/</a>
<a name="ln2240">                                    /* by design we need to pick up the first non-stereo-bond-neighbor as &quot;sn&quot;-atom */</a>
<a name="ln2241">                                    sb_ord_from_a1 = p1 - atom[a1].neighbor;</a>
<a name="ln2242">                                    sb_ord_from_a2 = p2 - atom[a2].neighbor;</a>
<a name="ln2243">                                    atom_stereo0D[i].neighbor[0] = atom[a1].neighbor[p1 == atom[a1].neighbor];</a>
<a name="ln2244">                                    atom_stereo0D[i].neighbor[3] = atom[a2].neighbor[p2 == atom[a2].neighbor];</a>
<a name="ln2245">                                    atom_stereo0D[i].central_atom = NO_ATOM;</a>
<a name="ln2246">                                }</a>
<a name="ln2247">                                if ( atom_stereo0D[i].type != INCHI_StereoType_None &amp;&amp;</a>
<a name="ln2248">                                     sb_ord_from_a1 &gt;= 0 &amp;&amp; sb_ord_from_a2 &gt;= 0 &amp;&amp;</a>
<a name="ln2249">                                     ATOM_PARITY_WELL_DEF( SB_PARITY_2(atom_stereo0D[i].parity) ) ) {</a>
<a name="ln2250">                                    /* Detected well-defined disconnected stereo</a>
<a name="ln2251">                                     * locate first non-metal neighbors */</a>
<a name="ln2252">                                    int    a, n, j, /* k,*/ sb_ord, cur_neigh, min_neigh;</a>
<a name="ln2253">                                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln2254">                                        a      = k? atom_stereo0D[i].neighbor[2] : atom_stereo0D[i].neighbor[1];</a>
<a name="ln2255">                                        sb_ord = k? sb_ord_from_a2 : sb_ord_from_a1;</a>
<a name="ln2256">                                        min_neigh = num_atoms;</a>
<a name="ln2257">                                        for ( n  = j = 0; j &lt; AT_NUM_BONDS(atom[a]); j ++ ) {</a>
<a name="ln2258">                                            cur_neigh = atom[a].neighbor[j];</a>
<a name="ln2259">                                            if ( j != sb_ord &amp;&amp; !IS_METAL_ATOM(atom, cur_neigh) ) {</a>
<a name="ln2260">                                                min_neigh = inchi_min( cur_neigh, min_neigh );</a>
<a name="ln2261">                                            }</a>
<a name="ln2262">                                        }</a>
<a name="ln2263">                                        if ( min_neigh &lt; num_atoms ) {</a>
<a name="ln2264">                                            atom_stereo0D[i].neighbor[k?3:0] = min_neigh;</a>
<a name="ln2265">                                        } else {</a>
<a name="ln2266">                                            MOLFILE_ERR_SET (*err, 0, &quot;Cannot find non-metal stereobond neighor (0D)&quot;);</a>
<a name="ln2267">                                        }</a>
<a name="ln2268">                                    }</a>
<a name="ln2269">                                }</a>
<a name="ln2270"> </a>
<a name="ln2271">                                break;</a>
<a name="ln2272">                            }</a>
<a name="ln2273">                        }</a>
<a name="ln2274">                        /* end of 0D parities extraction */</a>
<a name="ln2275">/*exit_cycle:;*/</a>
<a name="ln2276">                    }</a>
<a name="ln2277">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln2278">#else</a>
<a name="ln2279">                    /* transfer atom_stereo0D[] to atom[] */</a>
<a name="ln2280">                    if ( len_stereo0D ) {</a>
<a name="ln2281">                        Extract0DParities( atom, num_atoms, atom_stereo0D, len_stereo0D, </a>
<a name="ln2282">                            pStrErr, err, vABParityUnknown );</a>
<a name="ln2283">                    }</a>
<a name="ln2284">#endif</a>
<a name="ln2285">                    if ( pInpAtomFlags ) {</a>
<a name="ln2286">                        /* save chirality flag */</a>
<a name="ln2287">                        *pInpAtomFlags |= InpAtomFlags;</a>
<a name="ln2288">                    }</a>
<a name="ln2289">                } else</a>
<a name="ln2290">                if ( atom ) {</a>
<a name="ln2291">                    inchi_free( atom );</a>
<a name="ln2292">                    atom = NULL;</a>
<a name="ln2293">                }</a>
<a name="ln2294">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln2295">#else</a>
<a name="ln2296">                if ( szCoord ) {</a>
<a name="ln2297">                    *szCoord = pszCoord;</a>
<a name="ln2298">                    pszCoord = NULL;</a>
<a name="ln2299">                } else</a>
<a name="ln2300">#endif</a>
<a name="ln2301">                if ( pszCoord ) {</a>
<a name="ln2302">                    inchi_free( pszCoord );</a>
<a name="ln2303">                }</a>
<a name="ln2304">                goto bypass_end_of_INChI;</a>
<a name="ln2305">                /*return num_atoms;*/</a>
<a name="ln2306">            }</a>
<a name="ln2307">        }</a>
<a name="ln2308">        if ( atom_stereo0D ) {</a>
<a name="ln2309">            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln2310">        }</a>
<a name="ln2311">        /* end of struct. reading cycle, code never used? */</a>
<a name="ln2312">        if ( res &lt;= 0 ) {</a>
<a name="ln2313">            if ( *err == INCHI_INP_ERROR_ERR ) {</a>
<a name="ln2314">                return num_atoms;</a>
<a name="ln2315">            }</a>
<a name="ln2316">            *err = INCHI_INP_EOF_ERR;</a>
<a name="ln2317">            return INCHI_INP_EOF_RET; /* no more data */</a>
<a name="ln2318">        }</a>
<a name="ln2319">bypass_end_of_INChI:</a>
<a name="ln2320">        /* cleanup */</a>
<a name="ln2321">        if ( num_atoms == INCHI_INP_ERROR_RET &amp;&amp; atom_stereo0D ) {</a>
<a name="ln2322">            if ( stereo0D &amp;&amp; *stereo0D == atom_stereo0D ) {</a>
<a name="ln2323">                *stereo0D     = NULL;</a>
<a name="ln2324">                *num_stereo0D = 0;</a>
<a name="ln2325">            }</a>
<a name="ln2326">            FreeInchi_Stereo0D( &amp;atom_stereo0D );</a>
<a name="ln2327">        }</a>
<a name="ln2328">        if ( !memcmp(szLine, sStructHdrXmlEnd, sizeof(sStructHdrXmlEnd)-1) )</a>
<a name="ln2329">            num_struct --;</a>
<a name="ln2330">        if ( !memcmp(szLine, sStructHdrXml, sizeof(sStructHdrXml)-1) )</a>
<a name="ln2331">            num_struct ++;</a>
<a name="ln2332"> </a>
<a name="ln2333">        while ( num_struct &gt; 0 &amp;&amp; 0 &lt; inchi_ios_gets( szLine, sizeof(szLine)-1, inp_molfile, &amp;bTooLongLine ) ) {</a>
<a name="ln2334">            if ( !memcmp(szLine, sStructHdrXmlEnd, sizeof(sStructHdrXmlEnd)-1) )</a>
<a name="ln2335">                num_struct --;</a>
<a name="ln2336">            else</a>
<a name="ln2337">            if ( !memcmp(szLine, sStructHdrXml, sizeof(sStructHdrXml)-1) )</a>
<a name="ln2338">                num_struct ++;</a>
<a name="ln2339">        }</a>
<a name="ln2340">        return num_atoms;</a>
<a name="ln2341"> </a>
<a name="ln2342">    }</a>
<a name="ln2343">    </a>
<a name="ln2344">    return num_atoms;</a>
<a name="ln2345"> </a>
<a name="ln2346">#undef AT_NUM_BONDS</a>
<a name="ln2347">#undef ATOM_NUMBER</a>
<a name="ln2348">#undef IN_NEIGH_LIST</a>
<a name="ln2349">#undef inchi_NUMH2</a>
<a name="ln2350"> </a>
<a name="ln2351">#if ( defined(TARGET_API_LIB) || defined(TARGET_EXE_USING_API) )</a>
<a name="ln2352">#else </a>
<a name="ln2353">#undef inchi_Atom</a>
<a name="ln2354">#endif</a>
<a name="ln2355"> </a>
<a name="ln2356">#undef AT_NUM_BONDS </a>
<a name="ln2357">#undef ATOM_NUMBER        </a>
<a name="ln2358">#undef IN_NEIGH_LIST      </a>
<a name="ln2359">#undef inchi_NUMH2 </a>
<a name="ln2360">#undef INChITo_Atom       </a>
<a name="ln2361">#undef MoreParms          </a>
<a name="ln2362">#undef INPUT_FILE         </a>
<a name="ln2363">#undef Create_Atom        </a>
<a name="ln2364">#undef AT_BONDS_VAL</a>
<a name="ln2365">#undef ISOLATED_ATOM      </a>
<a name="ln2366">#undef NUM_ISO_Hk</a>
<a name="ln2367">#undef IS_METAL_ATOM</a>
<a name="ln2368"> </a>
<a name="ln2369"> </a>
<a name="ln2370">}</a>
<a name="ln2371">#ifdef TARGET_EXE_USING_API</a>
<a name="ln2372"> </a>
<a name="ln2373">/**********************************************************************************/</a>
<a name="ln2374">int INChIToInchi_Input( INCHI_IOSTREAM *inp_molfile, inchi_Input *orig_at_data, int bMergeAllInputStructures,</a>
<a name="ln2375">                       int bDoNotAddH, int vABParityUnknown, INPUT_TYPE nInputType,</a>
<a name="ln2376">                       char *pSdfLabel, char *pSdfValue, long *lSdfId, INCHI_MODE *pInpAtomFlags,</a>
<a name="ln2377">                       int *err, char *pStrErr )</a>
<a name="ln2378">{</a>
<a name="ln2379">    /* inp_ATOM       *at = NULL; */</a>
<a name="ln2380">    int             num_dimensions_new;</a>
<a name="ln2381">    int             num_inp_bonds_new;</a>
<a name="ln2382">    int             num_inp_atoms_new;</a>
<a name="ln2383">    int             num_inp_0D_new;</a>
<a name="ln2384">    inchi_Atom     *at_new     = NULL;</a>
<a name="ln2385">    inchi_Atom     *at_old     = NULL;</a>
<a name="ln2386">    inchi_Stereo0D *stereo0D_new = NULL;</a>
<a name="ln2387">    inchi_Stereo0D *stereo0D_old = NULL;</a>
<a name="ln2388">    int             nNumAtoms  = 0, nNumStereo0D = 0;</a>
<a name="ln2389">    MOL_COORD      *szCoordNew = NULL;</a>
<a name="ln2390">    MOL_COORD      *szCoordOld = NULL;</a>
<a name="ln2391">    int            i, j;</a>
<a name="ln2392"> </a>
<a name="ln2393">    if ( pStrErr ) {</a>
<a name="ln2394">        pStrErr[0] = '\0';</a>
<a name="ln2395">    }</a>
<a name="ln2396"> </a>
<a name="ln2397">    /*FreeOrigAtData( orig_at_data );*/</a>
<a name="ln2398">    if ( lSdfId )</a>
<a name="ln2399">        *lSdfId = 0;</a>
<a name="ln2400">    do {</a>
<a name="ln2401">        </a>
<a name="ln2402">        at_old       = orig_at_data? orig_at_data-&gt;atom      : NULL; /*  save pointer to the previous allocation */</a>
<a name="ln2403">        stereo0D_old = orig_at_data? orig_at_data-&gt;stereo0D  : NULL;</a>
<a name="ln2404">        szCoordOld = NULL;</a>
<a name="ln2405">        num_inp_atoms_new =</a>
<a name="ln2406">            INChIToInchi_Atom( inp_molfile, orig_at_data? &amp;stereo0D_new:NULL, &amp;num_inp_0D_new,</a>
<a name="ln2407">                          bDoNotAddH, vABParityUnknown, nInputType, </a>
<a name="ln2408">                          orig_at_data? &amp;at_new:NULL, MAX_ATOMS,</a>
<a name="ln2409">                          &amp;num_dimensions_new, &amp;num_inp_bonds_new,</a>
<a name="ln2410">                          pSdfLabel, pSdfValue, lSdfId, pInpAtomFlags, err, pStrErr );</a>
<a name="ln2411">        if ( num_inp_atoms_new &lt;= 0 &amp;&amp; !*err ) {</a>
<a name="ln2412">            MOLFILE_ERR_SET (*err, 0, &quot;Empty structure&quot;);</a>
<a name="ln2413">            *err = 98;</a>
<a name="ln2414">        } else</a>
<a name="ln2415">        if ( orig_at_data &amp;&amp; !num_inp_atoms_new &amp;&amp; 10 &lt; *err &amp;&amp; *err &lt; 20 &amp;&amp; orig_at_data-&gt;num_atoms &gt; 0 &amp;&amp; bMergeAllInputStructures ) {</a>
<a name="ln2416">            *err = 0; /* end of file */</a>
<a name="ln2417">            break;</a>
<a name="ln2418">        } else</a>
<a name="ln2419">        if ( num_inp_atoms_new &gt; 0 &amp;&amp; orig_at_data ) {</a>
<a name="ln2420">            /*  merge pOrigDataTmp + orig_at_data =&gt; pOrigDataTmp; */</a>
<a name="ln2421">            nNumAtoms    = num_inp_atoms_new + orig_at_data-&gt;num_atoms;</a>
<a name="ln2422">            nNumStereo0D = num_inp_0D_new    + orig_at_data-&gt;num_stereo0D;</a>
<a name="ln2423">            if ( nNumAtoms &gt;= MAX_ATOMS ) {</a>
<a name="ln2424">                MOLFILE_ERR_SET (*err, 0, &quot;Too many atoms&quot;);</a>
<a name="ln2425">                *err = 70;</a>
<a name="ln2426">                orig_at_data-&gt;num_atoms = -1;</a>
<a name="ln2427">            } else</a>
<a name="ln2428">            if ( !at_old ) {</a>
<a name="ln2429">                /* the first structure */</a>
<a name="ln2430">                orig_at_data-&gt;atom         = at_new;            at_new            = NULL;</a>
<a name="ln2431">                orig_at_data-&gt;num_atoms    = num_inp_atoms_new; num_inp_atoms_new = 0;</a>
<a name="ln2432">                orig_at_data-&gt;stereo0D     = stereo0D_new;      stereo0D_new      = NULL;</a>
<a name="ln2433">                orig_at_data-&gt;num_stereo0D = num_inp_0D_new;    num_inp_0D_new    = 0;</a>
<a name="ln2434">            } else</a>
<a name="ln2435">            if ( orig_at_data-&gt;atom = CreateInchi_Atom( nNumAtoms ) ) {</a>
<a name="ln2436">                /*  switch at_new &lt;--&gt; orig_at_data-&gt;at; */</a>
<a name="ln2437">                if ( orig_at_data-&gt;num_atoms ) {</a>
<a name="ln2438">                    memcpy( orig_at_data-&gt;atom, at_old, orig_at_data-&gt;num_atoms * sizeof(orig_at_data-&gt;atom[0]) );</a>
<a name="ln2439">                    /*  adjust numbering in the newly read structure */</a>
<a name="ln2440">                    for ( i = 0; i &lt; num_inp_atoms_new; i ++ ) {</a>
<a name="ln2441">                        for ( j = 0; j &lt; at_new[i].num_bonds; j ++ ) {</a>
<a name="ln2442">                            at_new[i].neighbor[j] += orig_at_data-&gt;num_atoms;</a>
<a name="ln2443">                        }</a>
<a name="ln2444">                    }</a>
<a name="ln2445">                }</a>
<a name="ln2446">                FreeInchi_Atom( &amp;at_old );</a>
<a name="ln2447">                /*  copy newly read structure */</a>
<a name="ln2448">                memcpy( orig_at_data-&gt;atom + orig_at_data-&gt;num_atoms,</a>
<a name="ln2449">                        at_new,</a>
<a name="ln2450">                        num_inp_atoms_new * sizeof(orig_at_data-&gt;atom[0]) );</a>
<a name="ln2451">                /*  cpy newly read 0D stereo */</a>
<a name="ln2452">                if ( num_inp_0D_new &gt; 0 &amp;&amp; stereo0D_new ) {</a>
<a name="ln2453">                    if ( orig_at_data-&gt;stereo0D = CreateInchi_Stereo0D( nNumStereo0D ) ) {</a>
<a name="ln2454">                        memcpy( orig_at_data-&gt;stereo0D, stereo0D_old, orig_at_data-&gt;num_stereo0D * sizeof(orig_at_data-&gt;stereo0D[0]) );</a>
<a name="ln2455">                        /*  adjust numbering in the newly read structure */</a>
<a name="ln2456">                        for ( i = 0; i &lt; num_inp_0D_new; i ++ ) {</a>
<a name="ln2457">                            if ( stereo0D_new[i].central_atom &gt;= 0 ) {</a>
<a name="ln2458">                                stereo0D_new[i].central_atom += orig_at_data-&gt;num_atoms;</a>
<a name="ln2459">                            }</a>
<a name="ln2460">                            for ( j = 0; j &lt; 4; j ++ ) {</a>
<a name="ln2461">                                stereo0D_new[i].neighbor[j] += orig_at_data-&gt;num_atoms;</a>
<a name="ln2462">                            }</a>
<a name="ln2463">                        }</a>
<a name="ln2464">                        FreeInchi_Stereo0D( &amp;stereo0D_old );</a>
<a name="ln2465">                        memcpy( orig_at_data-&gt;stereo0D+orig_at_data-&gt;num_stereo0D,</a>
<a name="ln2466">                                stereo0D_new,</a>
<a name="ln2467">                                num_inp_0D_new * sizeof(orig_at_data-&gt;stereo0D[0]) );</a>
<a name="ln2468">                    } else {</a>
<a name="ln2469">                        num_inp_0D_new = 0;</a>
<a name="ln2470">                        MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln2471">                        *err = -1;</a>
<a name="ln2472">                    }</a>
<a name="ln2473">                } else {</a>
<a name="ln2474">                    num_inp_0D_new = 0;</a>
<a name="ln2475">                }</a>
<a name="ln2476">                /* update lengths */</a>
<a name="ln2477">                orig_at_data-&gt;num_atoms    += num_inp_atoms_new;</a>
<a name="ln2478">                orig_at_data-&gt;num_stereo0D += num_inp_0D_new;</a>
<a name="ln2479">            } else {</a>
<a name="ln2480">                MOLFILE_ERR_SET (*err, 0, &quot;Out of RAM&quot;);</a>
<a name="ln2481">                *err = -1;</a>
<a name="ln2482">            }</a>
<a name="ln2483">        } else</a>
<a name="ln2484">        if ( num_inp_atoms_new &gt; 0 ) {</a>
<a name="ln2485">            nNumAtoms += num_inp_atoms_new;</a>
<a name="ln2486">        }</a>
<a name="ln2487">        FreeInchi_Atom( &amp;at_new );</a>
<a name="ln2488">        num_inp_atoms_new = 0;</a>
<a name="ln2489">        FreeInchi_Stereo0D( &amp;stereo0D_new );</a>
<a name="ln2490">        num_inp_0D_new = 0;</a>
<a name="ln2491"> </a>
<a name="ln2492">    } while ( !*err &amp;&amp; bMergeAllInputStructures );</a>
<a name="ln2493">    /*</a>
<a name="ln2494">    if ( !*err ) {</a>
<a name="ln2495">        orig_at_data-&gt;num_components =</a>
<a name="ln2496">            MarkDisconnectedComponents( orig_at_data );</a>
<a name="ln2497">        if ( orig_at_data-&gt;num_components == 0 ) {</a>
<a name="ln2498">            MOLFILE_ERR_SET (*err, 0, &quot;No components found&quot;);</a>
<a name="ln2499">            *err = 99;</a>
<a name="ln2500">        }</a>
<a name="ln2501">        if ( orig_at_data-&gt;num_components &lt; 0 ) {</a>
<a name="ln2502">            MOLFILE_ERR_SET (*err, 0, &quot;Too many components&quot;);</a>
<a name="ln2503">            *err = 99;</a>
<a name="ln2504">        }</a>
<a name="ln2505">    }</a>
<a name="ln2506">    */</a>
<a name="ln2507">    if ( szCoordNew ) {</a>
<a name="ln2508">        inchi_free( szCoordNew );</a>
<a name="ln2509">    }</a>
<a name="ln2510">    if ( at_new ) {</a>
<a name="ln2511">        inchi_free( at_new );</a>
<a name="ln2512">    }</a>
<a name="ln2513">    /*</a>
<a name="ln2514">    if ( !*err ) {</a>
<a name="ln2515">        if ( ReconcileAllCmlBondParities( orig_at_data-&gt;atom, orig_at_data-&gt;num_atoms ) ) {</a>
<a name="ln2516">            MOLFILE_ERR_SET (*err, 0, &quot;Cannot reconcile stereobond parities&quot;);</a>
<a name="ln2517">            if (!orig_at_data-&gt;num_atoms) {</a>
<a name="ln2518">                *err = 1;</a>
<a name="ln2519">            }</a>
<a name="ln2520">        }</a>
<a name="ln2521">    }</a>
<a name="ln2522">    */</a>
<a name="ln2523">    if ( *err ) {</a>
<a name="ln2524">        FreeInchi_Input( orig_at_data );</a>
<a name="ln2525">    }</a>
<a name="ln2526">    if ( *err &amp;&amp; !(10 &lt; *err &amp;&amp; *err &lt; 20) &amp;&amp; pStrErr &amp;&amp; !pStrErr[0] ) {</a>
<a name="ln2527">        MOLFILE_ERR_SET (*err, 0, &quot;Unknown error&quot;);  /*   &lt;BRKPT&gt; */</a>
<a name="ln2528">    }</a>
<a name="ln2529">    return orig_at_data? orig_at_data-&gt;num_atoms : nNumAtoms;</a>
<a name="ln2530">}</a>
<a name="ln2531"> </a>
<a name="ln2532">#endif</a>
<a name="ln2533"> </a>
<a name="ln2534">#ifndef TARGET_EXE_USING_API</a>
<a name="ln2535">#undef AB_MAX_WELL_DEFINED_PARITY</a>
<a name="ln2536">#undef AB_MIN_WELL_DEFINED_PARITY</a>
<a name="ln2537">#include &quot;extr_ct.h&quot;</a>
<a name="ln2538">/****************************************************************************************/</a>
<a name="ln2539">int Extract0DParities( inp_ATOM *at, int nNumAtoms, inchi_Stereo0D *stereo0D,</a>
<a name="ln2540">                       int num_stereo0D, char *pStrErr, int *err,</a>
<a name="ln2541">                       int vABParityUnknown)</a>
<a name="ln2542">{</a>
<a name="ln2543">    /* vABParityUnknown holds actual value of an internal constant signifying       */</a>
<a name="ln2544">    /* unknown parity: either the same as for undefined parity (default==standard)  */</a>
<a name="ln2545">    /*  or a specific one (non-std; requested by SLUUD switch).                     */</a>
<a name="ln2546"> </a>
<a name="ln2547">    if ( stereo0D &amp;&amp; num_stereo0D &gt; 0 ) {</a>
<a name="ln2548">        int i0D, a2, k, k_prev, type, j, j1, j2, len, parity, parityNM;</a>
<a name="ln2549">        int sb_ord_from_i1, sb_ord_from_i2, sn_ord_from_i1, sn_ord_from_i2;</a>
<a name="ln2550">        AT_NUMB i1n, i2n, i1, i2;</a>
<a name="ln2551">        for ( i0D = 0; i0D &lt; num_stereo0D; i0D ++ ) {</a>
<a name="ln2552">            parity   = (stereo0D[i0D].parity &amp; SB_PARITY_MASK);</a>
<a name="ln2553">            parityNM = (stereo0D[i0D].parity &amp; SB_PARITY_FLAG) &gt;&gt; SB_PARITY_SHFT;</a>
<a name="ln2554">            if ( parity == INCHI_PARITY_NONE ||</a>
<a name="ln2555">                 (parity != INCHI_PARITY_ODD &amp;&amp; parity != INCHI_PARITY_EVEN &amp;&amp;</a>
<a name="ln2556">                 parity != INCHI_PARITY_UNKNOWN &amp;&amp; parity != INCHI_PARITY_UNDEFINED) ) {</a>
<a name="ln2557">                char szTemp[16];</a>
<a name="ln2558">                sprintf( szTemp, &quot;#%d&quot;, i0D+1 );</a>
<a name="ln2559">                MOLFILE_ERR_SET (*err, 0, &quot;Wrong 0D stereo descriptor(s):&quot;);</a>
<a name="ln2560">                MOLFILE_ERR_SET (*err, 0, szTemp);</a>
<a name="ln2561">                continue; /* warning */</a>
<a name="ln2562">            }</a>
<a name="ln2563">            type   = stereo0D[i0D].type;</a>
<a name="ln2564">            a2     = stereo0D[i0D].central_atom; /* central atom or -1 */</a>
<a name="ln2565">            j   = -1;</a>
<a name="ln2566">            len =  0;</a>
<a name="ln2567">            sb_ord_from_i1 = sb_ord_from_i2 = sn_ord_from_i1 = sn_ord_from_i2 = -1;</a>
<a name="ln2568">            i1n = i2n = i1 = i2 = MAX_ATOMS+1;</a>
<a name="ln2569"> </a>
<a name="ln2570">            if ( ((type == INCHI_StereoType_Tetrahedral ||</a>
<a name="ln2571">                  type == INCHI_StereoType_Allene ) &amp;&amp;</a>
<a name="ln2572">                  0 &lt;= a2 &amp;&amp; a2 &lt; nNumAtoms) ||</a>
<a name="ln2573">                  (type == INCHI_StereoType_DoubleBond &amp;&amp;</a>
<a name="ln2574">                  a2 == NO_ATOM)) {</a>
<a name="ln2575">                /* test the quadruplet */</a>
<a name="ln2576">                for ( j = 0, k_prev = -1; j &lt; 4; j ++, k_prev = k ) {</a>
<a name="ln2577">                    k = stereo0D[i0D].neighbor[j];</a>
<a name="ln2578">                    if ( k &lt; 0 || k &gt;= nNumAtoms || k_prev == k )</a>
<a name="ln2579">                        break;</a>
<a name="ln2580">                    /* tetrahedral atom connectivity test */</a>
<a name="ln2581">                    if ( type == INCHI_StereoType_Tetrahedral &amp;&amp;</a>
<a name="ln2582">                         k != a2 &amp;&amp;</a>
<a name="ln2583">                         !is_in_the_list( at[a2].neighbor, (AT_NUMB)k, at[a2].valence) ) {</a>
<a name="ln2584">                        break;</a>
<a name="ln2585">                    }</a>
<a name="ln2586">                    /* Double bond, Cumulene and allene are tested in the next if() */</a>
<a name="ln2587">                }</a>
<a name="ln2588">            }</a>
<a name="ln2589">            /* find in the adjacency lists the double bond neighbor that leads to the opposite atom */</a>
<a name="ln2590">            if ( j == 4 &amp;&amp; (type == INCHI_StereoType_Allene ||</a>
<a name="ln2591">                            type == INCHI_StereoType_DoubleBond) ) {</a>
<a name="ln2592">                AT_NUMB *p1 = NULL, *p2 = NULL, *q1 = NULL, *q2 = NULL;</a>
<a name="ln2593">                i1n = (AT_NUMB)stereo0D[i0D].neighbor[0];</a>
<a name="ln2594">                i1  = (AT_NUMB)stereo0D[i0D].neighbor[1];</a>
<a name="ln2595">                i2  = (AT_NUMB)stereo0D[i0D].neighbor[2];</a>
<a name="ln2596">                i2n = (AT_NUMB)stereo0D[i0D].neighbor[3];</a>
<a name="ln2597">                /* find q1 and q2 */</a>
<a name="ln2598">                if ( !(q1 = is_in_the_list( at[i1].neighbor, i1n, at[i1].valence)) ||</a>
<a name="ln2599">                     !(q2 = is_in_the_list( at[i2].neighbor, i2n, at[i2].valence)) ) {</a>
<a name="ln2600">                    j = -2; /* error flag */</a>
<a name="ln2601">                } else</a>
<a name="ln2602">                /* allene or cumulene; follow double bonds from i1 to i2 */</a>
<a name="ln2603">                if ( !(p1 = is_in_the_list( at[i1].neighbor, i2, at[i1].valence)) ) {</a>
<a name="ln2604">                    /* at[i1] and at[i2] are not connected: can be only allene or cumulene */</a>
<a name="ln2605">                    AT_NUMB prev, cur, next;</a>
<a name="ln2606">                    int     num_dbond, i, next_ord, half_len;</a>
<a name="ln2607"> </a>
<a name="ln2608">                    cur = next = i1;</a>
<a name="ln2609">                    len = half_len = 0;</a>
<a name="ln2610">                    while ( len &lt; 20 ) { /* arbitrary very high upper limit to prevent infinite loop */</a>
<a name="ln2611">                        prev = cur;</a>
<a name="ln2612">                        cur  = next;</a>
<a name="ln2613">                        for ( i = 0, num_dbond = 0; i &lt; at[cur].valence; i ++ ) {</a>
<a name="ln2614">                            /* follow double bond path &amp;&amp; avoid going back */</a>
<a name="ln2615">                            if ( at[cur].bond_type[i] == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln2616">                                 prev != at[cur].neighbor[i] ) {</a>
<a name="ln2617">                                next = at[cur].neighbor[i];</a>
<a name="ln2618">                                next_ord = i;</a>
<a name="ln2619">                                num_dbond ++;</a>
<a name="ln2620">                            }</a>
<a name="ln2621">                        }</a>
<a name="ln2622">                        if ( num_dbond == 1 &amp;&amp; next != i1 ) {</a>
<a name="ln2623">                            len ++;</a>
<a name="ln2624">                            if ( len == 1 ) {</a>
<a name="ln2625">                                sb_ord_from_i1 = next_ord;</a>
<a name="ln2626">                            }</a>
<a name="ln2627">                            if ( type == INCHI_StereoType_Allene &amp;&amp; next == (AT_NUMB)a2 ) {</a>
<a name="ln2628">                                half_len = len;</a>
<a name="ln2629">                            }</a>
<a name="ln2630">                        } else {</a>
<a name="ln2631">                            break;</a>
<a name="ln2632">                        }</a>
<a name="ln2633">                    }</a>
<a name="ln2634">                    if ( cur == i2 &amp;&amp; prev != cur &amp;&amp; 0 == num_dbond &amp;&amp; len &gt; 1 &amp;&amp;</a>
<a name="ln2635">                         (p2 = is_in_the_list( at[i2].neighbor, prev, at[i2].valence)) &amp;&amp;</a>
<a name="ln2636">                         (type != INCHI_StereoType_Allene || len == 2*half_len )) {</a>
<a name="ln2637">                        sb_ord_from_i2 = p2 - at[i2].neighbor;</a>
<a name="ln2638">                        sn_ord_from_i1 = q1 - at[i1].neighbor;</a>
<a name="ln2639">                        sn_ord_from_i2 = q2 - at[i2].neighbor;</a>
<a name="ln2640">                    } else {</a>
<a name="ln2641">                        j = -5; /* error flag */</a>
<a name="ln2642">                    }</a>
<a name="ln2643">                } else</a>
<a name="ln2644">                /* allene must have been already processed, otherwise error */</a>
<a name="ln2645">                if ( type == INCHI_StereoType_Allene ) {</a>
<a name="ln2646">                    /* error: atoms #1 and #2 of allene are connected */</a>
<a name="ln2647">                    j = -3; /* error flag */</a>
<a name="ln2648">                } else</a>
<a name="ln2649">                /* double bond only; the bond type is not checked because at the end</a>
<a name="ln2650">                   of the normalization it may happen to be alternating */</a>
<a name="ln2651">                if ( type == INCHI_StereoType_DoubleBond &amp;&amp;</a>
<a name="ln2652">                     (p2 = is_in_the_list( at[i2].neighbor, i1, at[i2].valence) ) ) {</a>
<a name="ln2653">                    sb_ord_from_i1 = p1 - at[i1].neighbor;</a>
<a name="ln2654">                    sb_ord_from_i2 = p2 - at[i2].neighbor;</a>
<a name="ln2655">                    sn_ord_from_i1 = q1 - at[i1].neighbor;</a>
<a name="ln2656">                    sn_ord_from_i2 = q2 - at[i2].neighbor;</a>
<a name="ln2657">                } else {</a>
<a name="ln2658">                    j = -4; /* error flag */</a>
<a name="ln2659">                }</a>
<a name="ln2660">            }</a>
<a name="ln2661">            if ( j != 4 ) {</a>
<a name="ln2662">                char szTemp[16];</a>
<a name="ln2663">                sprintf( szTemp, &quot;#%d&quot;, i0D+1 );</a>
<a name="ln2664">                MOLFILE_ERR_SET (*err, 0, &quot;Wrong 0D stereo descriptor(s):&quot;);</a>
<a name="ln2665">                MOLFILE_ERR_SET (*err, 0, szTemp);</a>
<a name="ln2666">                continue; /* error */</a>
<a name="ln2667">            }</a>
<a name="ln2668"> </a>
<a name="ln2669">            switch ( type ) {</a>
<a name="ln2670">            case INCHI_StereoType_None:</a>
<a name="ln2671">                continue;</a>
<a name="ln2672">            case INCHI_StereoType_DoubleBond:</a>
<a name="ln2673">            case INCHI_StereoType_Allene:</a>
<a name="ln2674">                for ( j1 = 0; j1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i1].sb_parity[j1]; j1 ++ )</a>
<a name="ln2675">                    ;</a>
<a name="ln2676">                for ( j2 = 0; j2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i2].sb_parity[j2]; j2 ++ )</a>
<a name="ln2677">                    ;</a>
<a name="ln2678">                if ( j1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; j2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp;</a>
<a name="ln2679">                     sb_ord_from_i1 &gt;= 0 &amp;&amp; sb_ord_from_i2 &gt;= 0 &amp;&amp;</a>
<a name="ln2680">                     sn_ord_from_i1 &gt;= 0 &amp;&amp; sn_ord_from_i2 &gt;= 0) {</a>
<a name="ln2681"> </a>
<a name="ln2682">                    switch( parity ) {</a>
<a name="ln2683">                    case INCHI_PARITY_ODD:</a>
<a name="ln2684">                        at[i1].sb_parity[j1] = AB_PARITY_ODD;</a>
<a name="ln2685">                        at[i2].sb_parity[j2] = AB_PARITY_EVEN;</a>
<a name="ln2686">                        break;</a>
<a name="ln2687">                    case INCHI_PARITY_EVEN:</a>
<a name="ln2688">                        at[i1].sb_parity[j1] = AB_PARITY_ODD;</a>
<a name="ln2689">                        at[i2].sb_parity[j2] = AB_PARITY_ODD;</a>
<a name="ln2690">                        break;                    </a>
<a name="ln2691">                    case INCHI_PARITY_UNDEFINED:</a>
<a name="ln2692">                        at[i1].sb_parity[j1] = AB_PARITY_UNDF;</a>
<a name="ln2693">                        at[i2].sb_parity[j2] = AB_PARITY_UNDF;</a>
<a name="ln2694">                        break;</a>
<a name="ln2695">                    default:</a>
<a name="ln2696">                        if ( parity == INCHI_PARITY_UNKNOWN )</a>
<a name="ln2697">                        {</a>
<a name="ln2698">                            at[i1].sb_parity[j1] = vABParityUnknown;</a>
<a name="ln2699">                            at[i2].sb_parity[j2] = vABParityUnknown;</a>
<a name="ln2700">                        }</a>
<a name="ln2701">                        else</a>
<a name="ln2702">                        {</a>
<a name="ln2703">                        at[i1].sb_parity[j1] = AB_PARITY_NONE;</a>
<a name="ln2704">                        at[i2].sb_parity[j2] = AB_PARITY_NONE;</a>
<a name="ln2705">                        }</a>
<a name="ln2706">                        break;</a>
<a name="ln2707">                    }</a>
<a name="ln2708"> </a>
<a name="ln2709">                    switch( parityNM ) {</a>
<a name="ln2710">                    case INCHI_PARITY_ODD:</a>
<a name="ln2711">                        at[i1].sb_parity[j1] |= AB_PARITY_ODD &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2712">                        at[i2].sb_parity[j2] |= AB_PARITY_EVEN &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2713">                        break;</a>
<a name="ln2714">                    case INCHI_PARITY_EVEN:</a>
<a name="ln2715">                        at[i1].sb_parity[j1] |= AB_PARITY_ODD &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2716">                        at[i2].sb_parity[j2] |= AB_PARITY_ODD &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2717">                        break;</a>
<a name="ln2718">                    case INCHI_PARITY_UNDEFINED:</a>
<a name="ln2719">                        at[i1].sb_parity[j1] |= AB_PARITY_UNDF &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2720">                        at[i2].sb_parity[j2] |= AB_PARITY_UNDF &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2721">                        break;</a>
<a name="ln2722">                    default:</a>
<a name="ln2723">                        if ( parityNM == INCHI_PARITY_UNKNOWN )</a>
<a name="ln2724">                        {</a>
<a name="ln2725">                            at[i1].sb_parity[j1] |= vABParityUnknown &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2726">                            at[i2].sb_parity[j2] |= vABParityUnknown &lt;&lt; SB_PARITY_SHFT;</a>
<a name="ln2727">                        }</a>
<a name="ln2728">                        break;</a>
<a name="ln2729">                    }</a>
<a name="ln2730"> </a>
<a name="ln2731">                    at[i1].sb_ord[j1]         = sb_ord_from_i1;</a>
<a name="ln2732">                    at[i1].sn_ord[j1]         = sn_ord_from_i1;</a>
<a name="ln2733">                    at[i1].sn_orig_at_num[j1] = at[i1n].orig_at_number;</a>
<a name="ln2734"> </a>
<a name="ln2735">                    at[i2].sb_ord[j2]         = sb_ord_from_i2;</a>
<a name="ln2736">                    at[i2].sn_ord[j2]         = sn_ord_from_i2;</a>
<a name="ln2737">                    at[i2].sn_orig_at_num[j2] = at[i2n].orig_at_number;</a>
<a name="ln2738">                }</a>
<a name="ln2739">                break;</a>
<a name="ln2740">            case INCHI_StereoType_Tetrahedral:</a>
<a name="ln2741">                    switch( parity ) {</a>
<a name="ln2742">                    case INCHI_PARITY_ODD:</a>
<a name="ln2743">                        at[a2].p_parity = AB_PARITY_ODD;</a>
<a name="ln2744">                        break;</a>
<a name="ln2745">                    case INCHI_PARITY_EVEN:</a>
<a name="ln2746">                        at[a2].p_parity = AB_PARITY_EVEN;</a>
<a name="ln2747">                        break;</a>
<a name="ln2748">                    case INCHI_PARITY_UNDEFINED:</a>
<a name="ln2749">                        at[a2].p_parity = AB_PARITY_UNDF;</a>
<a name="ln2750">                        break;</a>
<a name="ln2751">                    default:</a>
<a name="ln2752">                        if (parity == INCHI_PARITY_UNKNOWN )</a>
<a name="ln2753">                        {</a>
<a name="ln2754">                            at[a2].p_parity = vABParityUnknown;</a>
<a name="ln2755">                            break;</a>
<a name="ln2756">                        }</a>
<a name="ln2757">                        else</a>
<a name="ln2758">                            continue;</a>
<a name="ln2759">                    }</a>
<a name="ln2760">                for ( j = 0; j &lt; 4; j ++ ) {</a>
<a name="ln2761">                    k = stereo0D[i0D].neighbor[j];</a>
<a name="ln2762">                    at[a2].p_orig_at_num[j] = at[k].orig_at_number;</a>
<a name="ln2763">                }</a>
<a name="ln2764">                break;</a>
<a name="ln2765">            default:</a>
<a name="ln2766">                break;</a>
<a name="ln2767">            }</a>
<a name="ln2768">        }</a>
<a name="ln2769">        /* take care of Unknown stereobonds:                                     */</a>
<a name="ln2770">        /* copy their Unknown stereo descriptors to at-&gt;bond_stereo (2005-03-01) */</a>
<a name="ln2771">        /* Note: to this stage, unk/undef set to what was requested              */</a>
<a name="ln2772">        /*( through vABParityUnknown )  (2009-12-12)                             */</a>
<a name="ln2773">        FixUnkn0DStereoBonds(at, nNumAtoms);</a>
<a name="ln2774"> </a>
<a name="ln2775">#ifdef TARGET_API_LIB</a>
<a name="ln2776"> </a>
<a name="ln2777">        if ( (k = ReconcileAllCmlBondParities( at, nNumAtoms, 0 )) ) {</a>
<a name="ln2778">            char szErrCode[16];</a>
<a name="ln2779">            sprintf( szErrCode, &quot;%d&quot;, k);</a>
<a name="ln2780">            AddMOLfileError( pStrErr, &quot;0D Parities Reconciliation failed:&quot; );</a>
<a name="ln2781">            AddMOLfileError( pStrErr, szErrCode );</a>
<a name="ln2782">        }</a>
<a name="ln2783"> </a>
<a name="ln2784">#endif</a>
<a name="ln2785"> </a>
<a name="ln2786">    }</a>
<a name="ln2787">    return 0;</a>
<a name="ln2788">}</a>
<a name="ln2789"> </a>
<a name="ln2790">#endif</a>

</code></pre>
<div class="balloon" rel="382"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'bHeaderRead' variable was assigned the same value.</p></div>
<div class="balloon" rel="392"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'longID' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 389, 392.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'lToken' variable was assigned the same value.</p></div>
<div class="balloon" rel="651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'bTooLongLine2' variable was assigned the same value.</p></div>
<div class="balloon" rel="651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'res2' variable was assigned the same value.</p></div>
<div class="balloon" rel="661"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: i >= num_atoms.</p></div>
<div class="balloon" rel="844"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'lToken' variable was assigned the same value.</p></div>
<div class="balloon" rel="864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'bTooLongLine2' variable was assigned the same value.</p></div>
<div class="balloon" rel="864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'res2' variable was assigned the same value.</p></div>
<div class="balloon" rel="869"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: i >= num_atoms.</p></div>
<div class="balloon" rel="984"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 1 <= INCHI_BOND_TYPE_ALTERN.</p></div>
<div class="balloon" rel="984"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: INCHI_BOND_TYPE_ALTERN <= 4.</p></div>
<div class="balloon" rel="1174"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="1185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="1188"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="1275"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pszCoord' is always true.</p></div>
<div class="balloon" rel="1283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'atom_stereo0D' is always false.</p></div>
<div class="balloon" rel="1287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'res <= 0' is always true.</p></div>
<div class="balloon" rel="1402"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (bFatal = 1).</p></div>
<div class="balloon" rel="1528"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: i >= num_atoms.</p></div>
<div class="balloon" rel="1677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'i >= num_atoms' is always false.</p></div>
<div class="balloon" rel="2015"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 1 <= INCHI_BOND_TYPE_ALTERN.</p></div>
<div class="balloon" rel="2015"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: INCHI_BOND_TYPE_ALTERN <= 4.</p></div>
<div class="balloon" rel="2206"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="2217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="2220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="2301"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pszCoord' is always true.</p></div>
<div class="balloon" rel="2312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'res <= 0' is always true.</p></div>
<div class="balloon" rel="2609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'len' variable was assigned the same value.</p></div>
<div class="balloon" rel="2651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: type == INCHI_StereoType_DoubleBond.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

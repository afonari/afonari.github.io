
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichimake.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln49">#include &quot;ichitime.h&quot;</a>
<a name="ln50">#endif</a>
<a name="ln51">#include &quot;inpdef.h&quot;</a>
<a name="ln52">#include &quot;ichi.h&quot;</a>
<a name="ln53">#include &quot;strutil.h&quot;</a>
<a name="ln54">#include &quot;util.h&quot;</a>
<a name="ln55">#include &quot;extr_ct.h&quot;</a>
<a name="ln56">#include &quot;ichitaut.h&quot;</a>
<a name="ln57">#include &quot;ichinorm.h&quot;</a>
<a name="ln58">#include &quot;ichicant.h&quot;</a>
<a name="ln59">#include &quot;ichicano.h&quot;</a>
<a name="ln60">#include &quot;ichicomn.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;ichicomp.h&quot;</a>
<a name="ln63">#include &quot;ichimain.h&quot;</a>
<a name="ln64">#include &quot;ichimake.h&quot;</a>
<a name="ln65">#include &quot;ichister.h&quot;</a>
<a name="ln66">#include &quot;ichi_io.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">int inp2spATOM( inp_ATOM *inp_at, int num_inp_at, sp_ATOM *at );</a>
<a name="ln69">int GetElementAndCount( const char **f, char *szEl, int *count );</a>
<a name="ln70">int CompareHillFormulas( const char *f1, const char *f2 );</a>
<a name="ln71">int CompareInchiStereo( INChI_Stereo *Stereo1, INCHI_MODE nFlags1, INChI_Stereo *Stereo2, INCHI_MODE nFlags2 );</a>
<a name="ln72">int CompareReversedStereoINChI( INChI_Stereo *s1/* InChI from reversed struct */, INChI_Stereo *s2 /* input InChI */);</a>
<a name="ln73">int GetAtomOrdNbrInCanonOrd( inp_ATOM *norm_at, AT_NUMB *nAtomOrdNbr,</a>
<a name="ln74">                            AT_NUMB *nOrigAtNosInCanonOrd, int num_at );</a>
<a name="ln75">int FillOutCanonInfAtom(inp_ATOM *norm_at, INF_ATOM_DATA *inf_norm_at_data, int init_num_at, int bIsotopic,</a>
<a name="ln76">                        INChI *pINChI, INChI_Aux *pINChI_Aux, int bAbcNumbers, INCHI_MODE nMode);</a>
<a name="ln77">int FillOutOneCanonInfAtom(inp_ATOM *inp_norm_at, INF_ATOM_DATA *inf_norm_at_data,</a>
<a name="ln78">                           AT_NUMB *pStereoFlags, int init_num_at, int offset, int offset_H, int bIsotopic,</a>
<a name="ln79">                           INChI *pINChI, INChI_Aux *pINChI_Aux, int bAbcNumbers, INCHI_MODE nMode);</a>
<a name="ln80">int FillOutInputInfAtom(inp_ATOM *inp_at, INF_ATOM_DATA *inf_at_data, int init_num_at, int num_removed_H,</a>
<a name="ln81">                        int bAdd_DT_to_num_H, int nNumRemovedProtons, NUM_H *nNumRemovedProtonsIsotopic, int bIsotopic, int bAbcNumbers);</a>
<a name="ln82"> </a>
<a name="ln83">int CheckCanonNumberingCorrectness(</a>
<a name="ln84">                 int num_atoms, int num_at_tg,</a>
<a name="ln85">                 sp_ATOM *at, CANON_STAT *pCS, int bTautomeric,</a>
<a name="ln86">                 char *pStrErrStruct );</a>
<a name="ln87"> </a>
<a name="ln88">static int CompareDfsDescendants4CT( const void *a1, const void *a2 );</a>
<a name="ln89">int GetSp3RelRacAbs( const INChI *pINChI, INChI_Stereo *Stereo );</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">#if ( TEST_RENUMB_ATOMS == 1 || READ_INCHI_STRING == 1 ) /*  { */</a>
<a name="ln93">int CompareStereoINChI( INChI_Stereo *s1, INChI_Stereo *s2 );</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96">#if ( READ_INCHI_STRING == 1 ) /*  { */</a>
<a name="ln97">/*************************************************************************************/</a>
<a name="ln98"> </a>
<a name="ln99">int CompareReversedStereoINChI2( INChI_Stereo *s1, INChI_Stereo *s2, ICR *picr);</a>
<a name="ln100"> </a>
<a name="ln101">#endif</a>
<a name="ln102">/**********************************************************************************************/</a>
<a name="ln103">int inp2spATOM( inp_ATOM *inp_at, int num_inp_at, sp_ATOM *at )</a>
<a name="ln104">{</a>
<a name="ln105">    int i, j, val;</a>
<a name="ln106">    memset( at, 0, sizeof(at[0])*num_inp_at );</a>
<a name="ln107">    for ( i = 0; i &lt; num_inp_at; i ++ ) {</a>
<a name="ln108">        strncpy( at[i].elname, inp_at[i].elname, sizeof(at[0].elname) );</a>
<a name="ln109">        at[i].el_number = (U_CHAR)get_periodic_table_number( at[i].elname );</a>
<a name="ln110">        val = at[i].valence = inp_at[i].valence;</a>
<a name="ln111">        for ( j = 0; j &lt; val; j ++ ) {</a>
<a name="ln112">            at[i].neighbor[j]  = inp_at[i].neighbor[j];</a>
<a name="ln113">            at[i].bond_type[j] = inp_at[i].bond_type[j];</a>
<a name="ln114">        }</a>
<a name="ln115">        at[i].chem_bonds_valence = inp_at[i].chem_bonds_valence;</a>
<a name="ln116">        at[i].orig_at_number     = inp_at[i].orig_at_number;</a>
<a name="ln117">        at[i].orig_compt_at_numb= inp_at[i].orig_compt_at_numb;</a>
<a name="ln118">        at[i].endpoint           = inp_at[i].endpoint;</a>
<a name="ln119">        at[i].iso_atw_diff       = inp_at[i].iso_atw_diff;</a>
<a name="ln120">        at[i].num_H              = inp_at[i].num_H;</a>
<a name="ln121">        at[i].cFlags             = inp_at[i].cFlags;</a>
<a name="ln122">        for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln123">            at[i].num_iso_H[j]       = inp_at[i].num_iso_H[j];</a>
<a name="ln124">        }</a>
<a name="ln125">        at[i].charge             = inp_at[i].charge;</a>
<a name="ln126">        at[i].radical            = inp_at[i].radical;</a>
<a name="ln127"> </a>
<a name="ln128">#if ( FIND_RING_SYSTEMS == 1 )</a>
<a name="ln129">        at[i].nBlockSystem       = inp_at[i].nBlockSystem;</a>
<a name="ln130">        at[i].bCutVertex         = inp_at[i].bCutVertex;</a>
<a name="ln131">        at[i].nRingSystem        = inp_at[i].nRingSystem;</a>
<a name="ln132">        at[i].nNumAtInRingSystem = inp_at[i].nNumAtInRingSystem;</a>
<a name="ln133">#if ( FIND_RINS_SYSTEMS_DISTANCES == 1 )</a>
<a name="ln134">        at[i].nDistanceFromTerminal = inp_at[i].nDistanceFromTerminal;</a>
<a name="ln135">#endif</a>
<a name="ln136">#endif</a>
<a name="ln137"> </a>
<a name="ln138">/*</a>
<a name="ln139">        at[i].x                  = inp_at[i].x;</a>
<a name="ln140">        at[i].y                  = inp_at[i].y;</a>
<a name="ln141">        at[i].z                  = inp_at[i].z;</a>
<a name="ln142">*/</a>
<a name="ln143">    }</a>
<a name="ln144">    return 0;</a>
<a name="ln145">}</a>
<a name="ln146">/**********************************************************************************************/</a>
<a name="ln147">int GetElementAndCount( const char **f, char *szEl, int *count )</a>
<a name="ln148">{</a>
<a name="ln149">    const char *p = *f;</a>
<a name="ln150">    char       *q;</a>
<a name="ln151">    int   i = 0;</a>
<a name="ln152">    if ( *p ) {</a>
<a name="ln153">        if ( isupper( UCINT *p ) ) {</a>
<a name="ln154">            szEl[i++] = *p++;</a>
<a name="ln155">            if ( *p &amp;&amp; islower( UCINT *p ) ) {</a>
<a name="ln156">                szEl[i++] = *p++;</a>
<a name="ln157">            }</a>
<a name="ln158">            szEl[i] = '\0';</a>
<a name="ln159">            if ( 1 == i &amp;&amp; szEl[0] == 'C' ) {</a>
<a name="ln160">                szEl[0] = 'A'; /*  less than any element: */</a>
<a name="ln161">                               /*  carbon-containing compounds should be first */</a>
<a name="ln162">            }</a>
<a name="ln163">            if ( *p &amp;&amp; isdigit( UCINT *p ) ) {</a>
<a name="ln164">                *count = strtol( p, &amp;q, 10 );</a>
<a name="ln165">                p = q;</a>
<a name="ln166">            } else {</a>
<a name="ln167">                *count = 1;</a>
<a name="ln168">            }</a>
<a name="ln169">            *f = p; /*  next element; */</a>
<a name="ln170">            return 1;</a>
<a name="ln171">        }</a>
<a name="ln172">        return -1; /*  not a chemical formula */</a>
<a name="ln173">    }</a>
<a name="ln174">    strcpy( szEl, &quot;Zz&quot; ); /*  zero termination 'element' is larger than any other element */</a>
<a name="ln175">    *count = 9999;        /*  zero termination 'element count' is larger than any other count */</a>
<a name="ln176">    return 0;</a>
<a name="ln177">}</a>
<a name="ln178">/**********************************************************************************************</a>
<a name="ln179"> </a>
<a name="ln180">   E1 &lt; E2 if strcmp( E1, E2) &lt; 0  OR E2 is empty and E1 is not</a>
<a name="ln181">   n1 &lt; n2 if value n1 &gt; n2</a>
<a name="ln182"> </a>
<a name="ln183">   Sorting order:</a>
<a name="ln184"> </a>
<a name="ln185">   C10H22N</a>
<a name="ln186">   C10H22</a>
<a name="ln187">   C2</a>
<a name="ln188">   Ag2Cl2</a>
<a name="ln189">   Ag2Cl</a>
<a name="ln190">   Ag2F2</a>
<a name="ln191">   Ag2</a>
<a name="ln192">   AgCl</a>
<a name="ln193">   AgF</a>
<a name="ln194">   F6S</a>
<a name="ln195">   F2S</a>
<a name="ln196"> </a>
<a name="ln197">**********************************************************************************************/</a>
<a name="ln198">int CompareHillFormulas( const char *f1, const char *f2 )</a>
<a name="ln199">{</a>
<a name="ln200">    char szEl1[4], szEl2[4];</a>
<a name="ln201">    int  count1, count2, ret1, ret2, ret;</a>
<a name="ln202"> </a>
<a name="ln203">    do {</a>
<a name="ln204">        ret1 = GetElementAndCount( &amp;f1, szEl1, &amp;count1 );</a>
<a name="ln205">        ret2 = GetElementAndCount( &amp;f2, szEl2, &amp;count2 );</a>
<a name="ln206">        if ( 0 &lt;= ret1 &amp;&amp; 0 &lt;= ret2 ) {</a>
<a name="ln207">            if ( (ret = strcmp( szEl1, szEl2 )) ) {</a>
<a name="ln208">                return ret; /*  lexicographic order, string termination &gt; any character */</a>
<a name="ln209">            }</a>
<a name="ln210">            if ( (ret = count2 - count1) ) {</a>
<a name="ln211">                return ret; /*  inverse atom count order */</a>
<a name="ln212">            }</a>
<a name="ln213">        } else {</a>
<a name="ln214">            return 0; /*  program error &lt;BRKPT&gt; */</a>
<a name="ln215">        }</a>
<a name="ln216"> </a>
<a name="ln217">    } while ( 0 &lt; ret1 &amp;&amp; 0 &lt; ret2 );</a>
<a name="ln218"> </a>
<a name="ln219">    return 0;</a>
<a name="ln220">}</a>
<a name="ln221">/**********************************************************************************************/</a>
<a name="ln222">int CompareHillFormulasNoH( const char *f1, const char *f2, int *num_H1, int *num_H2 )</a>
<a name="ln223">{</a>
<a name="ln224">    char szEl1[4], szEl2[4];</a>
<a name="ln225">    int  count1, count2, ret1, ret2, ret;</a>
<a name="ln226"> </a>
<a name="ln227">    do {</a>
<a name="ln228">        ret1 = GetElementAndCount( &amp;f1, szEl1, &amp;count1 );</a>
<a name="ln229">        if ( 0 &lt; ret1 &amp;&amp; szEl1[0] == 'H' &amp;&amp; !szEl1[1] ) {</a>
<a name="ln230">            *num_H1 += count1;</a>
<a name="ln231">            ret1 = GetElementAndCount( &amp;f1, szEl1, &amp;count1 );</a>
<a name="ln232">        }</a>
<a name="ln233">        ret2 = GetElementAndCount( &amp;f2, szEl2, &amp;count2 );</a>
<a name="ln234">        if ( 0 &lt; ret2 &amp;&amp; szEl2[0] == 'H' &amp;&amp; !szEl2[1] ) {</a>
<a name="ln235">            *num_H2 += count2;</a>
<a name="ln236">            ret2 = GetElementAndCount( &amp;f2, szEl2, &amp;count2 );</a>
<a name="ln237">        }</a>
<a name="ln238">        if ( 0 &lt;= ret1 &amp;&amp; 0 &lt;= ret2 ) {</a>
<a name="ln239">            if ( (ret = strcmp( szEl1, szEl2 )) ) {</a>
<a name="ln240">                return ret; /*  lexicographic order, string termination &gt; any character */</a>
<a name="ln241">            }</a>
<a name="ln242">            if ( (ret = count2 - count1) ) {</a>
<a name="ln243">                return ret; /*  inverse atom count order */</a>
<a name="ln244">            }</a>
<a name="ln245">        } else {</a>
<a name="ln246">            return 0; /*  program error &lt;BRKPT&gt; */</a>
<a name="ln247">        }</a>
<a name="ln248"> </a>
<a name="ln249">    } while ( 0 &lt; ret1 &amp;&amp; 0 &lt; ret2 );</a>
<a name="ln250"> </a>
<a name="ln251">    return 0;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">/**************************************************************/</a>
<a name="ln255">int CompareTautNonIsoPartOfINChI( const INChI *i1, const INChI *i2 )</a>
<a name="ln256">{</a>
<a name="ln257">    int len1, len2, ret, i;</a>
<a name="ln258"> </a>
<a name="ln259">    len1 = i1-&gt;lenTautomer &gt; 0 &amp;&amp; i1-&gt;nTautomer[0]? i1-&gt;lenTautomer:0;</a>
<a name="ln260">    len2 = i2-&gt;lenTautomer &gt; 0 &amp;&amp; i2-&gt;nTautomer[0]? i2-&gt;lenTautomer:0;</a>
<a name="ln261">    if ( (ret  = len2 - len1) ) {</a>
<a name="ln262">        return ret;</a>
<a name="ln263">    }</a>
<a name="ln264">    for ( i = 0; i &lt; len1; i ++ ) {</a>
<a name="ln265">        if ( (ret = (int)i2-&gt;nTautomer[i] - (int)i1-&gt;nTautomer[i]) )</a>
<a name="ln266">            return ret;</a>
<a name="ln267">    }</a>
<a name="ln268">    return 0;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">/**********************************************************************************************/</a>
<a name="ln272">/*  sorting in descending order: return -1 if *p1 &gt; *p2, return +1 if *p1 &lt; *p2               */</a>
<a name="ln273">/**********************************************************************************************/</a>
<a name="ln274">int CompINChITautVsNonTaut(const INCHI_SORT *p1, const INCHI_SORT *p2, int bCompareIsotopic)</a>
<a name="ln275">{</a>
<a name="ln276">    int ret, num, i, num_H1, num_H2;</a>
<a name="ln277">    </a>
<a name="ln278">    const INChI *i1  = NULL; /* Mobile-H layers in Mobile-H sorting order */</a>
<a name="ln279">    const INChI *i2  = NULL; /* Fixed-H  layers in Fixed-H  sorting order */</a>
<a name="ln280">    </a>
<a name="ln281">    int   n1;               /* TAUT_YES if tautomeric i1 exists, otherwise TAUT_NON */</a>
<a name="ln282">    </a>
<a name="ln283">    /* INChI_Stereo *Stereo1, *Stereo2; */</a>
<a name="ln284"> </a>
<a name="ln285">    n1 = ( p1-&gt;pINChI[TAUT_YES] &amp;&amp; p1-&gt;pINChI[TAUT_YES]-&gt;nNumberOfAtoms )? TAUT_YES : TAUT_NON;</a>
<a name="ln286"> </a>
<a name="ln287">    i1  = p1-&gt;pINChI[n1];</a>
<a name="ln288">    i2 = (n1 == TAUT_YES &amp;&amp; p2-&gt;pINChI[TAUT_NON] &amp;&amp;</a>
<a name="ln289">           p2-&gt;pINChI[TAUT_NON]-&gt;nNumberOfAtoms)? p2-&gt;pINChI[TAUT_NON] : (const INChI *)NULL;</a>
<a name="ln290"> </a>
<a name="ln291"> </a>
<a name="ln292">    /* non-deleted-non-empty &lt; deleted &lt; empty */</a>
<a name="ln293">    if ( i1 &amp;&amp; !i2 )</a>
<a name="ln294">        return 0;   /* non-empty is the smallest (first) */</a>
<a name="ln295">    if ( !i1 &amp;&amp; i2 )</a>
<a name="ln296">        return 0;</a>
<a name="ln297">    if ( !i1 &amp;&amp; !i2 )</a>
<a name="ln298">        return 0;</a>
<a name="ln299">    if ( i1-&gt;bDeleted )</a>
<a name="ln300">        return 1;    /* deleted is the largest (last) among non-empty */</a>
<a name="ln301">    if ( i2-&gt;bDeleted )</a>
<a name="ln302">        return -1;</a>
<a name="ln303"> </a>
<a name="ln304">    if ( i1-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; !i2-&gt;nNumberOfAtoms )</a>
<a name="ln305">        return 0;</a>
<a name="ln306"> </a>
<a name="ln307">    i2 = i2;</a>
<a name="ln308"> </a>
<a name="ln309">    num_H1 = num_H2 = 0;</a>
<a name="ln310">    </a>
<a name="ln311">    /* do not compare terminal H */</a>
<a name="ln312">    if ( (ret = CompareHillFormulasNoH( i1-&gt;szHillFormula, i2-&gt;szHillFormula, &amp;num_H1, &amp;num_H2 )) ) {</a>
<a name="ln313">        return ret;  /* lexicographic order except the shorter one is greater (last): CH2O &lt; CH2; C3XX &lt; C2XX */</a>
<a name="ln314">    }</a>
<a name="ln315"> </a>
<a name="ln316">    /*********************************************************</a>
<a name="ln317">            compare non-isotopic non-tautomeric part</a>
<a name="ln318">     *********************************************************/</a>
<a name="ln319"> </a>
<a name="ln320">    /* compare number of atoms (excluding terminal H) */</a>
<a name="ln321">    if ( (ret = i2-&gt;nNumberOfAtoms - i1-&gt;nNumberOfAtoms) )</a>
<a name="ln322">        return ret; /*  more atoms first */</a>
<a name="ln323">    </a>
<a name="ln324">    /*  compare elements  (excluding terminal H) */</a>
<a name="ln325">    num = i1-&gt;nNumberOfAtoms;</a>
<a name="ln326">    for ( i = 0; i &lt; num; i ++ ) { /* should always be equal if Hill formulas are same */</a>
<a name="ln327">        if ( (ret = (int)i2-&gt;nAtom[i] - (int)i1-&gt;nAtom[i]) )</a>
<a name="ln328">            return ret; /* greater periodic number first */</a>
<a name="ln329">    }</a>
<a name="ln330">    /**********************************************************</a>
<a name="ln331">        compare connection tables</a>
<a name="ln332">    ***********************************************************/</a>
<a name="ln333">    if ( (ret = i2-&gt;lenConnTable - i1-&gt;lenConnTable) )</a>
<a name="ln334">        return ret; /* longer connection table first */</a>
<a name="ln335">    num = i2-&gt;lenConnTable; </a>
<a name="ln336">    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln337">        if ( (ret = (int)i2-&gt;nConnTable[i] - (int)i1-&gt;nConnTable[i]) )</a>
<a name="ln338">            return ret; /* greater connection table first */</a>
<a name="ln339">    }</a>
<a name="ln340">    /*********************************************************</a>
<a name="ln341">      compare compare total number of H (inverse: H3 &lt; H2 )</a>
<a name="ln342">    **********************************************************/</a>
<a name="ln343">    if ( (ret = num_H2 - num_H1) )</a>
<a name="ln344">        return ret;</a>
<a name="ln345">    /*********************************************************</a>
<a name="ln346">      compare non-tautomeric num_H: N &lt; NH3 &lt; NH2 &lt; NH</a>
<a name="ln347">    **********************************************************/</a>
<a name="ln348">    num = i1-&gt;nNumberOfAtoms;</a>
<a name="ln349">    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln350">        if ( i2-&gt;nNum_H[i] != i1-&gt;nNum_H[i] ) {</a>
<a name="ln351">            return !i2-&gt;nNum_H[i]?  1 :  /* no H first */</a>
<a name="ln352">                   !i1-&gt;nNum_H[i]? -1 :</a>
<a name="ln353">                   (int)i2-&gt;nNum_H[i] - (int)i1-&gt;nNum_H[i];</a>
<a name="ln354">        }</a>
<a name="ln355">    }</a>
<a name="ln356">    /*********************************************************</a>
<a name="ln357">         compare non-isotopic tautomeric part</a>
<a name="ln358">     *********************************************************/</a>
<a name="ln359">    if ( (ret = CompareTautNonIsoPartOfINChI( i1, i2)) ) {</a>
<a name="ln360">        return ret;</a>
<a name="ln361">    }</a>
<a name="ln362">    /*</a>
<a name="ln363">    if ( ret = i2-&gt;lenTautomer - i1-&gt;lenTautomer )</a>
<a name="ln364">        return ret;</a>
<a name="ln365">    num = inchi_min( i2-&gt;lenTautomer, i1-&gt;lenTautomer );</a>
<a name="ln366">    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln367">        if ( ret = (int)i2-&gt;nTautomer[i] - (int)i1-&gt;nTautomer[i] )</a>
<a name="ln368">            return ret;</a>
<a name="ln369">    }</a>
<a name="ln370">    */</a>
<a name="ln371">    /*********************************************************</a>
<a name="ln372">     *                                                       *</a>
<a name="ln373">     *  at this point both components are either tautomeric  *</a>
<a name="ln374">     *  or non-tautomeric                                    *</a>
<a name="ln375">     *                                                       *</a>
<a name="ln376">     *********************************************************/</a>
<a name="ln377"> </a>
<a name="ln378">    /*********************************************************</a>
<a name="ln379">       non-tautomeric &quot;fixed H&quot; specific</a>
<a name="ln380">     *********************************************************/</a>
<a name="ln381">    if ( /*TAUT_NON == bTaut &amp;&amp;*/ (i2 &amp;&amp; i2-&gt;nNum_H_fixed ) ) {</a>
<a name="ln382">        /* first, compare non-tautomeric chem. formulas -- they may be different */</a>
<a name="ln383">        /* secondly, compare fixed-H distribution */</a>
<a name="ln384">        if ( i2-&gt;nNum_H_fixed ) {</a>
<a name="ln385">            num = i2-&gt;nNumberOfAtoms;</a>
<a name="ln386">            for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln387">                if ( i2-&gt;nNum_H_fixed[i] != 0 ) {</a>
<a name="ln388">                    return 1;</a>
<a name="ln389">                }</a>
<a name="ln390">            }</a>
<a name="ln391">        }</a>
<a name="ln392">    }</a>
<a name="ln393">    /*********************************************************</a>
<a name="ln394">        compare non-isotopic stereo</a>
<a name="ln395">     *********************************************************/</a>
<a name="ln396">    ret = CompareInchiStereo( i1-&gt;Stereo, i1-&gt;nFlags, i2-&gt;Stereo, i2-&gt;nFlags );</a>
<a name="ln397">    if ( ret ) {</a>
<a name="ln398">        return ret;</a>
<a name="ln399">    }</a>
<a name="ln400">    /*******************************************************</a>
<a name="ln401">        do not switch back to tautomeric i1, i2</a>
<a name="ln402">     *******************************************************/</a>
<a name="ln403">    /* -- how to switch back --</a>
<a name="ln404">    if ( i1t ) {</a>
<a name="ln405">        i1  = i1t;</a>
<a name="ln406">        i1t = NULL;</a>
<a name="ln407">    }</a>
<a name="ln408">    if ( i2t ) {</a>
<a name="ln409">        i2  = i2t;</a>
<a name="ln410">        i2t = NULL;</a>
<a name="ln411">    }</a>
<a name="ln412">    */</a>
<a name="ln413">    /******************************************************</a>
<a name="ln414">         compare isotopic non-tautomeric part</a>
<a name="ln415">     ******************************************************/</a>
<a name="ln416">    if ( bCompareIsotopic ) {</a>
<a name="ln417">        if ( (ret = i2-&gt;nNumberOfIsotopicAtoms - i1-&gt;nNumberOfIsotopicAtoms) )</a>
<a name="ln418">            return ret;</a>
<a name="ln419">        num = i1-&gt;nNumberOfIsotopicAtoms;</a>
<a name="ln420">        /*  compare isotopic atoms */</a>
<a name="ln421">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln422">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nAtomNumber - (int)i1-&gt;IsotopicAtom[i].nAtomNumber) )</a>
<a name="ln423">                return ret;</a>
<a name="ln424">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nIsoDifference - (int)i1-&gt;IsotopicAtom[i].nIsoDifference) )</a>
<a name="ln425">                return ret;</a>
<a name="ln426">        }</a>
<a name="ln427">        /* compare isotopic H */</a>
<a name="ln428">        /* if tautomeric comparison mode then here are compared only non-tautomeric H */</a>
<a name="ln429">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln430">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nNum_T - (int)i1-&gt;IsotopicAtom[i].nNum_T) )</a>
<a name="ln431">                return ret;</a>
<a name="ln432">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nNum_D - (int)i1-&gt;IsotopicAtom[i].nNum_D) )</a>
<a name="ln433">                return ret;</a>
<a name="ln434">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nNum_H - (int)i1-&gt;IsotopicAtom[i].nNum_H) )</a>
<a name="ln435">                return ret;</a>
<a name="ln436">        }</a>
<a name="ln437">        /*****************************************************</a>
<a name="ln438">             compare isotopic tautomeric part</a>
<a name="ln439">         *****************************************************/</a>
<a name="ln440">        if ( (ret = i2-&gt;nNumberOfIsotopicTGroups || i1-&gt;nNumberOfIsotopicTGroups) )</a>
<a name="ln441">            return ret;</a>
<a name="ln442">        /*</a>
<a name="ln443">        num = i1-&gt;nNumberOfIsotopicTGroups;</a>
<a name="ln444">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln445">            if ( ret = (int)i2-&gt;IsotopicTGroup[i].nTGroupNumber - (int)i1-&gt;IsotopicTGroup[i].nTGroupNumber )</a>
<a name="ln446">                return ret;</a>
<a name="ln447">            if ( ret = (int)i2-&gt;IsotopicTGroup[i].nNum_T - (int)i1-&gt;IsotopicTGroup[i].nNum_T )</a>
<a name="ln448">                return ret;</a>
<a name="ln449">            if ( ret = (int)i2-&gt;IsotopicTGroup[i].nNum_D - (int)i1-&gt;IsotopicTGroup[i].nNum_D )</a>
<a name="ln450">                return ret;</a>
<a name="ln451">            if ( ret = (int)i2-&gt;IsotopicTGroup[i].nNum_H - (int)i1-&gt;IsotopicTGroup[i].nNum_H )</a>
<a name="ln452">                return ret;</a>
<a name="ln453">        }</a>
<a name="ln454">        */</a>
<a name="ln455">        /****************************************************</a>
<a name="ln456">            compare isotopic stereo</a>
<a name="ln457">         ****************************************************/</a>
<a name="ln458">        ret = CompareInchiStereo( i1-&gt;StereoIsotopic, i1-&gt;nFlags, i2-&gt;StereoIsotopic, i2-&gt;nFlags );</a>
<a name="ln459">        if ( ret ) {</a>
<a name="ln460">            return ret;</a>
<a name="ln461">        }</a>
<a name="ln462"> </a>
<a name="ln463">    }</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">    /**********************************************************</a>
<a name="ln467">        compare charges: non-charged first, then in order of</a>
<a name="ln468">        ascending charges (negative first) </a>
<a name="ln469">    ***********************************************************/</a>
<a name="ln470">    if ( i2-&gt;nTotalCharge &amp;&amp; i1-&gt;nTotalCharge ) {</a>
<a name="ln471">        /*  both are charged; smaller charges first */</a>
<a name="ln472">        ret = (int)i1-&gt;nTotalCharge - (int)i2-&gt;nTotalCharge;</a>
<a name="ln473">        return ret;</a>
<a name="ln474">    }</a>
<a name="ln475">    if ( (ret = (i1-&gt;nTotalCharge? 1:0) - (i2-&gt;nTotalCharge? 1:0)) ) {</a>
<a name="ln476">        /*  only one is charged; uncharged first */</a>
<a name="ln477">        return ret;</a>
<a name="ln478">    }</a>
<a name="ln479">    /* stable sort */</a>
<a name="ln480">    /*ret = p1-&gt;ord_number - p2-&gt;ord_number;*/</a>
<a name="ln481"> </a>
<a name="ln482">    return ret;</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">/*************************** stereo ***********************************************************/</a>
<a name="ln486">typedef enum tagSp3StereoTypeTmp {</a>
<a name="ln487">    SP3_NONE = 0,  /* no sp3 stereo: no /t, /m, /s segments */</a>
<a name="ln488">    /* /t is present: */</a>
<a name="ln489">    SP3_ONLY = 1,  /* no /s or /m segment: inversion leaves the structure unchanged */</a>
<a name="ln490">    SP3_ABS  = 2,  /* abs stereo: both /m and /s are present */</a>
<a name="ln491">    SP3_REL  = 4,  /* rel stereo: /s is present, /m is not */</a>
<a name="ln492">    SP3_RAC  = 8,  /* racemic stereo: /s is presen, /m is nott */</a>
<a name="ln493">    SP3_TYPE = (SP3_ABS|SP3_REL|SP3_RAC),          /* bitmap for checking the presence of /m */</a>
<a name="ln494">    SP3_ANY  = (SP3_ABS|SP3_REL|SP3_RAC|SP3_ONLY)  /* bitmap for checking the presence of /t */</a>
<a name="ln495">} SP3_TYPE_TMP;</a>
<a name="ln496"> </a>
<a name="ln497">/**********************************************************************************************/</a>
<a name="ln498">int GetSp3RelRacAbs( const INChI *pINChI, INChI_Stereo *Stereo )</a>
<a name="ln499">{</a>
<a name="ln500">    int nRet = SP3_NONE;</a>
<a name="ln501">    if ( pINChI &amp;&amp; !pINChI-&gt;bDeleted &amp;&amp; Stereo &amp;&amp; 0 &lt; Stereo-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln502">        if ( 0 != Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln503">            if ( pINChI-&gt;nFlags &amp; INCHI_FLAG_REL_STEREO ) {</a>
<a name="ln504">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln505">                if ( 1 &lt;  Stereo-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln506">                    nRet = SP3_REL;</a>
<a name="ln507">                }</a>
<a name="ln508">#else</a>
<a name="ln509">                nRet = SP3_REL;</a>
<a name="ln510">#endif</a>
<a name="ln511">            } else</a>
<a name="ln512">            if ( pINChI-&gt;nFlags &amp; INCHI_FLAG_RAC_STEREO ) {</a>
<a name="ln513">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln514">                if ( 1 &lt;  Stereo-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln515">                    nRet = SP3_REL;</a>
<a name="ln516">                }</a>
<a name="ln517">#else</a>
<a name="ln518">                nRet = SP3_RAC;</a>
<a name="ln519">#endif</a>
<a name="ln520">            } else {</a>
<a name="ln521">                nRet = SP3_ABS;</a>
<a name="ln522">            }</a>
<a name="ln523">        } else</a>
<a name="ln524">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln525">        if ( !(( pINChI-&gt;nFlags &amp; (INCHI_FLAG_REL_STEREO|INCHI_FLAG_RAC_STEREO) ) &amp;&amp; 1 == Stereo-&gt;nNumberOfStereoCenters) )</a>
<a name="ln526">#endif</a>
<a name="ln527">        {</a>
<a name="ln528">            nRet = SP3_ONLY; /*  SP3_NONE if relative stereo and 1 stereocenter */</a>
<a name="ln529">        }</a>
<a name="ln530">    }</a>
<a name="ln531">    return nRet;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">/* char sDifSegs[DIFL_LENGTH][DIFS_LENGTH]; */</a>
<a name="ln535"> </a>
<a name="ln536">/**********************************************************************************************/</a>
<a name="ln537">/*  sorting in descending order: return -1 if *p1 &gt; *p2, return +1 if *p1 &lt; *p2               */</a>
<a name="ln538">/**********************************************************************************************/</a>
<a name="ln539">int CompINChILayers(const INCHI_SORT *p1, const INCHI_SORT *p2, </a>
<a name="ln540">                    char sDifSegs[][DIFS_LENGTH], int bFixTranspChargeBug )</a>
<a name="ln541">{</a>
<a name="ln542">    int ret = 0, num, i, num_H1, num_H2;</a>
<a name="ln543">    </a>
<a name="ln544">    const INChI *i1  = NULL; /* Mobile-H layers in Mobile-H sorting order */</a>
<a name="ln545">    const INChI *i2  = NULL; /* Fixed-H  layers in Fixed-H  sorting order */</a>
<a name="ln546">    </a>
<a name="ln547">    int   n1;               /* TAUT_YES if tautomeric i1 exists, otherwise TAUT_NON */</a>
<a name="ln548">    </a>
<a name="ln549">    INChI_Stereo *Stereo1, *Stereo2;</a>
<a name="ln550">    INChI_Stereo *IsoStereo1, *IsoStereo2;</a>
<a name="ln551">    int bRelRac[DIFL_LENGTH];</a>
<a name="ln552">    char *psDifSegs;</a>
<a name="ln553"> </a>
<a name="ln554">    n1 = ( p1-&gt;pINChI[TAUT_YES] &amp;&amp; p1-&gt;pINChI[TAUT_YES]-&gt;nNumberOfAtoms )? TAUT_YES : TAUT_NON;</a>
<a name="ln555"> </a>
<a name="ln556">    i1  = p1-&gt;pINChI[n1];</a>
<a name="ln557">    i2 = (n1 == TAUT_YES &amp;&amp; p2-&gt;pINChI[TAUT_NON] &amp;&amp;</a>
<a name="ln558">           p2-&gt;pINChI[TAUT_NON]-&gt;nNumberOfAtoms)? p2-&gt;pINChI[TAUT_NON] : (const INChI *)NULL;</a>
<a name="ln559"> </a>
<a name="ln560">    num_H1 = num_H2 = 0;</a>
<a name="ln561">    memset( bRelRac, DIFV_BOTH_EMPTY, sizeof(bRelRac) );</a>
<a name="ln562">    /*=====================*/</a>
<a name="ln563">    /*====     /f    ======*/</a>
<a name="ln564">    /*=====================*/</a>
<a name="ln565">    if ( i1 &amp;&amp; !i1-&gt;bDeleted &amp;&amp; i1-&gt;szHillFormula &amp;&amp; i1-&gt;szHillFormula[0] ) {</a>
<a name="ln566">        sDifSegs[DIFL_M][DIFS_f_FORMULA] |= DIFV_NEQ2PRECED;</a>
<a name="ln567">        if ( i2 &amp;&amp; !i2-&gt;bDeleted &amp;&amp; i2-&gt;szHillFormula &amp;&amp; i2-&gt;szHillFormula[0] ) {</a>
<a name="ln568">            if ( !CompareHillFormulasNoH( i1-&gt;szHillFormula, i2-&gt;szHillFormula, &amp;num_H1, &amp;num_H2 ) &amp;&amp;</a>
<a name="ln569">                  num_H1 == num_H2 ) {</a>
<a name="ln570">                sDifSegs[DIFL_F][DIFS_f_FORMULA] |= DIFV_EQL2PRECED;</a>
<a name="ln571">            } else {</a>
<a name="ln572">                sDifSegs[DIFL_F][DIFS_f_FORMULA] |= DIFV_NEQ2PRECED;</a>
<a name="ln573">            }</a>
<a name="ln574">        } else {</a>
<a name="ln575">            sDifSegs[DIFL_F][DIFS_f_FORMULA] |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln576">        }</a>
<a name="ln577">    } else {</a>
<a name="ln578">        sDifSegs[DIFL_M][DIFS_f_FORMULA] |= DIFV_BOTH_EMPTY;</a>
<a name="ln579">        if ( i2 &amp;&amp; !i2-&gt;bDeleted &amp;&amp; i2-&gt;szHillFormula &amp;&amp; i2-&gt;szHillFormula[0] ) {</a>
<a name="ln580">            sDifSegs[DIFL_F][DIFS_f_FORMULA] |= DIFV_NEQ2PRECED;</a>
<a name="ln581">        } else {</a>
<a name="ln582">            sDifSegs[DIFL_F][DIFS_f_FORMULA] |= DIFV_BOTH_EMPTY;</a>
<a name="ln583">        }</a>
<a name="ln584">    }</a>
<a name="ln585">    /*=====================*/</a>
<a name="ln586">    /*====     /c    ======*/</a>
<a name="ln587">    /*=====================*/</a>
<a name="ln588">    if ( i1 &amp;&amp; !i1-&gt;bDeleted &amp;&amp; i1-&gt;lenConnTable &gt; 1 ) {</a>
<a name="ln589">        sDifSegs[DIFL_M][DIFS_f_FORMULA] |= DIFV_NEQ2PRECED;</a>
<a name="ln590">    } else {</a>
<a name="ln591">        sDifSegs[DIFL_M][DIFS_f_FORMULA] |= DIFV_BOTH_EMPTY;</a>
<a name="ln592">    }</a>
<a name="ln593">    /*=====================*/</a>
<a name="ln594">    /*====     /h    ======*/</a>
<a name="ln595">    /*=====================*/</a>
<a name="ln596">    /* M: H atoms */</a>
<a name="ln597">    if ( i1 &amp;&amp; !i1-&gt;bDeleted ) {</a>
<a name="ln598">        num_H1 = (i1-&gt;lenTautomer &gt; 0 &amp;&amp; i1-&gt;nTautomer &amp;&amp; i1-&gt;nTautomer[0])? 1 : 0; /* number of t-groups */</a>
<a name="ln599">        if ( !num_H1 &amp;&amp; i1-&gt;nNum_H ) {</a>
<a name="ln600">            for ( i = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) { /* immobile H */</a>
<a name="ln601">                if ( i1-&gt;nNum_H[i] ) {</a>
<a name="ln602">                    num_H1 = 1;</a>
<a name="ln603">                    break;</a>
<a name="ln604">                }</a>
<a name="ln605">            }</a>
<a name="ln606">        }</a>
<a name="ln607">        sDifSegs[DIFL_M][DIFS_h_H_ATOMS] |= num_H1? DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln608">    } else {</a>
<a name="ln609">        sDifSegs[DIFL_M][DIFS_h_H_ATOMS] |= DIFV_BOTH_EMPTY;</a>
<a name="ln610">    }</a>
<a name="ln611">    /* F: fixed mobile H */</a>
<a name="ln612">    if ( i2 &amp;&amp; !i2-&gt;bDeleted &amp;&amp; i2-&gt;nNum_H_fixed ) {</a>
<a name="ln613">        num_H2 = 0;</a>
<a name="ln614">        if ( i1 &amp;&amp; !i1-&gt;bDeleted ) {</a>
<a name="ln615">            for ( i = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln616">                if ( i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln617">                    num_H2 = 1;</a>
<a name="ln618">                    break;</a>
<a name="ln619">                }</a>
<a name="ln620">            }</a>
<a name="ln621">        }</a>
<a name="ln622">        sDifSegs[DIFL_F][DIFS_h_H_ATOMS] |= num_H2? DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln623">    } else {</a>
<a name="ln624">        sDifSegs[DIFL_F][DIFS_h_H_ATOMS] |= DIFV_BOTH_EMPTY;</a>
<a name="ln625">    }</a>
<a name="ln626">    /* MI: exchangable isotopic H: see OutputINChI1(), num_iso_H[] */</a>
<a name="ln627"> </a>
<a name="ln628">    /*=====================*/</a>
<a name="ln629">    /*====     /q    ======*/</a>
<a name="ln630">    /*=====================*/</a>
<a name="ln631">    psDifSegs = &amp;sDifSegs[DIFL_F][DIFS_q_CHARGE];</a>
<a name="ln632">    if ( i1 &amp;&amp; !i1-&gt;bDeleted ) {</a>
<a name="ln633">        if ( i1-&gt;nTotalCharge ) {</a>
<a name="ln634">            sDifSegs[DIFL_M][DIFS_q_CHARGE] |= DIFV_NEQ2PRECED;</a>
<a name="ln635">        } else {</a>
<a name="ln636">            sDifSegs[DIFL_M][DIFS_q_CHARGE] |= DIFV_BOTH_EMPTY;</a>
<a name="ln637">        }</a>
<a name="ln638">        if ( i2 &amp;&amp; !i2-&gt;bDeleted ) {</a>
<a name="ln639">            if ( i1-&gt;nTotalCharge ) {</a>
<a name="ln640">                if ( i1-&gt;nTotalCharge == i2-&gt;nTotalCharge ) {</a>
<a name="ln641">                    *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln642">                } else</a>
<a name="ln643">                if ( i2-&gt;nTotalCharge ) {</a>
<a name="ln644">                    *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln645">                } else {</a>
<a name="ln646">                    *psDifSegs |= DIFV_IS_EMPTY;</a>
<a name="ln647">                }</a>
<a name="ln648">            } else {</a>
<a name="ln649">                if ( i2-&gt;nTotalCharge ) {</a>
<a name="ln650">                    *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln651">                } else {</a>
<a name="ln652">                    *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln653">                }</a>
<a name="ln654">            }</a>
<a name="ln655">        } else</a>
<a name="ln656">        if ( !i2 ) {</a>
<a name="ln657">            if (bFixTranspChargeBug==1) </a>
<a name="ln658">            {</a>
<a name="ln659">            /* bug explanation:</a>
<a name="ln660"> </a>
<a name="ln661">            component #1 is tautomeric, component #2 is not</a>
<a name="ln662">            Mobile-H(#2) &gt; Mobile-H(#1)</a>
<a name="ln663">            Fixed-H(#2) = Mobile-H(#2) &lt; Fixed-H(#1)</a>
<a name="ln664"> </a>
<a name="ln665">            Layer       first_charge   second_charge</a>
<a name="ln666"> </a>
<a name="ln667">            Mobile-H    0    (comp#1)  -1 (comp#2)</a>
<a name="ln668">            Fixed-H     none (comp#2)  -1 (comp#1)</a>
<a name="ln669"> </a>
<a name="ln670">            v1.01 charge compared decided that charge layers are same and omitted Fixed-H /q layer</a>
<a name="ln671"> </a>
<a name="ln672">            Solution: when component permutation is detected AND fixed-H component does not exist,</a>
<a name="ln673">            compare Mobile-H charge [0 (comp#1) in the example] to the charge of Mobile-H [-1 (comp#2)]</a>
<a name="ln674">            of the component that has none Fixed-H charge</a>
<a name="ln675">            */</a>
<a name="ln676"> </a>
<a name="ln677">            /* Fixed-H i2 is empty because Fixed-H struct is same as Mobile-H */</a>
<a name="ln678">                if ( p1-&gt;ord_number != p2-&gt;ord_number &amp;&amp; /* component order in Fixed-H is different from Mobile-H */</a>
<a name="ln679">                     n1 == TAUT_YES &amp;&amp; p2-&gt;pINChI[TAUT_YES] &amp;&amp; !p2-&gt;pINChI[TAUT_YES]-&gt;bDeleted &amp;&amp;</a>
<a name="ln680">                    p2-&gt;pINChI[TAUT_YES]-&gt;nNumberOfAtoms ) {</a>
<a name="ln681">                    int i2_nTotalCharge = p2-&gt;pINChI[TAUT_YES]-&gt;nTotalCharge;</a>
<a name="ln682"> </a>
<a name="ln683">                    if ( i1-&gt;nTotalCharge ) {</a>
<a name="ln684">                        if ( i1-&gt;nTotalCharge == i2_nTotalCharge ) {</a>
<a name="ln685">                            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln686">                        } else</a>
<a name="ln687">                        if ( i2_nTotalCharge ) {</a>
<a name="ln688">                            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln689">                        } else {</a>
<a name="ln690">                            *psDifSegs |= DIFV_IS_EMPTY;</a>
<a name="ln691">                        }</a>
<a name="ln692">                    } else {</a>
<a name="ln693">                        if ( i2_nTotalCharge ) {</a>
<a name="ln694">                            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln695">                        } else {</a>
<a name="ln696">                            *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln697">                        }</a>
<a name="ln698">                    }</a>
<a name="ln699">                } else {</a>
<a name="ln700">                    *psDifSegs |= i1-&gt;nTotalCharge? DIFV_EQL2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln701">                }</a>
<a name="ln702">            } </a>
<a name="ln703">            else /* if (bFixTranspChargeBug==1) */</a>
<a name="ln704">            {</a>
<a name="ln705">                *psDifSegs |= i1-&gt;nTotalCharge? DIFV_EQL2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln706">            } </a>
<a name="ln707">        } </a>
<a name="ln708"> </a>
<a name="ln709">        else /* if ( !i2 ) { */</a>
<a name="ln710">        {</a>
<a name="ln711">            /* i2 &amp;&amp; i2-&gt;bDeleted */</a>
<a name="ln712">            *psDifSegs |= i1-&gt;nTotalCharge? DIFV_IS_EMPTY : DIFV_BOTH_EMPTY;</a>
<a name="ln713">        }</a>
<a name="ln714"> </a>
<a name="ln715">    } else {</a>
<a name="ln716">        sDifSegs[DIFL_M][DIFS_q_CHARGE] |= DIFV_BOTH_EMPTY;</a>
<a name="ln717">        if ( i2 &amp;&amp; !i2-&gt;bDeleted ) {</a>
<a name="ln718">            if ( i2-&gt;nTotalCharge ) {</a>
<a name="ln719">                sDifSegs[DIFL_F][DIFS_q_CHARGE] |= DIFV_NEQ2PRECED;</a>
<a name="ln720">            } else {</a>
<a name="ln721">                sDifSegs[DIFL_F][DIFS_q_CHARGE] |= DIFV_BOTH_EMPTY;</a>
<a name="ln722">            }</a>
<a name="ln723">        }</a>
<a name="ln724">    }</a>
<a name="ln725">    /*************** stereo *****************/</a>
<a name="ln726">    if ( i1 &amp;&amp; !i1-&gt;bDeleted ) {</a>
<a name="ln727">        Stereo1    = i1-&gt;Stereo;</a>
<a name="ln728">        IsoStereo1 = i1-&gt;StereoIsotopic;</a>
<a name="ln729">    } else {</a>
<a name="ln730">        Stereo1    = NULL;</a>
<a name="ln731">        IsoStereo1 = NULL;</a>
<a name="ln732">    }</a>
<a name="ln733">    if ( i2 &amp;&amp; !i2-&gt;bDeleted ) {</a>
<a name="ln734">        Stereo2    = i2-&gt;Stereo;</a>
<a name="ln735">        IsoStereo2 = i2-&gt;StereoIsotopic;</a>
<a name="ln736">    } else {</a>
<a name="ln737">        Stereo2    = NULL;</a>
<a name="ln738">        IsoStereo2 = NULL;</a>
<a name="ln739">    }</a>
<a name="ln740">    /*=====================*/</a>
<a name="ln741">    /*====     /b    ======*/</a>
<a name="ln742">    /*=====================*/</a>
<a name="ln743">    /* M double bond stereo */</a>
<a name="ln744">    psDifSegs = &amp;sDifSegs[DIFL_M][DIFS_b_SBONDS];</a>
<a name="ln745">    if ( Stereo1 &amp;&amp; Stereo1-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln746">        *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln747">    } else {</a>
<a name="ln748">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln749">    }</a>
<a name="ln750">    /* F double bond stereo */</a>
<a name="ln751">    psDifSegs = &amp;sDifSegs[DIFL_F][DIFS_b_SBONDS];</a>
<a name="ln752">    if ( Stereo2 &amp;&amp; Stereo2-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln753">        if ( Stereo1 &amp;&amp; Stereo1-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln754">            if ( Eql_INChI_Stereo( Stereo1, EQL_SP2, Stereo2, EQL_SP2, 0 ) ) {</a>
<a name="ln755">                *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln756">            } else {</a>
<a name="ln757">                *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln758">            }</a>
<a name="ln759">        } else {</a>
<a name="ln760">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln761">        }</a>
<a name="ln762">    } else {</a>
<a name="ln763">        if ( Stereo1 &amp;&amp; Stereo1-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln764">            *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln765">        } else {</a>
<a name="ln766">            *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln767">        }</a>
<a name="ln768">    }</a>
<a name="ln769">    /* MI double bond stereo */</a>
<a name="ln770">    psDifSegs = &amp;sDifSegs[DIFL_MI][DIFS_b_SBONDS];</a>
<a name="ln771">    if ( IsoStereo1 &amp;&amp; IsoStereo1-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln772">        if ( Eql_INChI_Stereo( IsoStereo1, EQL_SP2, Stereo1, EQL_SP2, 0 ) ) {</a>
<a name="ln773">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln774">        } else {</a>
<a name="ln775">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln776">        }</a>
<a name="ln777">    } else {</a>
<a name="ln778">        if ( Stereo1 &amp;&amp; Stereo1-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln779">            *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln780">        } else {</a>
<a name="ln781">            *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln782">        }</a>
<a name="ln783">    }</a>
<a name="ln784">    /* FI double bond stereo */</a>
<a name="ln785">    psDifSegs = &amp;sDifSegs[DIFL_FI][DIFS_b_SBONDS];</a>
<a name="ln786">    if ( IsoStereo2 &amp;&amp; IsoStereo2-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln787">        if ( Eql_INChI_Stereo( IsoStereo2, EQL_SP2, Stereo2, EQL_SP2, 0 ) ) {</a>
<a name="ln788">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln789">        } else {</a>
<a name="ln790">            if ( !(Stereo1 &amp;&amp; Stereo1-&gt;nNumberOfStereoBonds) &amp;&amp;</a>
<a name="ln791">                 !(Stereo2 &amp;&amp; Stereo2-&gt;nNumberOfStereoBonds) &amp;&amp;</a>
<a name="ln792">                 Eql_INChI_Stereo( IsoStereo2, EQL_SP2, IsoStereo1, EQL_SP2, 0 ) ) {</a>
<a name="ln793">                *psDifSegs |= DIFV_FI_EQ_MI;</a>
<a name="ln794">            } else {</a>
<a name="ln795">                *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln796">            }</a>
<a name="ln797">        }</a>
<a name="ln798">    } else {</a>
<a name="ln799">        /* the solution table for FI stereo,</a>
<a name="ln800">           in case of FI stereo is empty</a>
<a name="ln801">           E = segment is empty, NE = not empty</a>
<a name="ln802">           +==============================+</a>
<a name="ln803">           | M   | MI  | F   |  result    |</a>
<a name="ln804">           +=====+=====+=====+============+</a>
<a name="ln805">           | E   | E   | E   | both empty |</a>
<a name="ln806">           +-----+-----+-----+------------+</a>
<a name="ln807">           | NE  | E   | E   | both empty |</a>
<a name="ln808">           +-----+-----+-----+------------+</a>
<a name="ln809">           | E   | NE  | E   | is empty   |</a>
<a name="ln810">           +-----+-----+-----+------------+</a>
<a name="ln811">           | NE  | NE  | E   | both empty |</a>
<a name="ln812">           +-----+-----+-----+------------+</a>
<a name="ln813">           | E   | E   | NE  | is empty   |</a>
<a name="ln814">           +-----+-----+-----+------------+</a>
<a name="ln815">           | NE  | E   | NE  | is empty   |</a>
<a name="ln816">           +-----+-----+-----+------------+</a>
<a name="ln817">           | E   | NE  | NE  | is empty   |</a>
<a name="ln818">           +-----+-----+-----+------------+</a>
<a name="ln819">           | NE  | NE  | ME  | is empty   |</a>
<a name="ln820">           +==============================+</a>
<a name="ln821">        */</a>
<a name="ln822">        if ( Stereo2    &amp;&amp; Stereo2-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln823">            *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln824">        } else</a>
<a name="ln825">        if ( IsoStereo1 &amp;&amp; IsoStereo1-&gt;nNumberOfStereoBonds &amp;&amp;</a>
<a name="ln826">             !(Stereo1 &amp;&amp; Stereo1-&gt;nNumberOfStereoBonds)</a>
<a name="ln827">            ) {</a>
<a name="ln828">            *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln829">        } else {</a>
<a name="ln830">            *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln831">        }</a>
<a name="ln832">    }</a>
<a name="ln833">    /*==================================*/</a>
<a name="ln834">    /*====     /t, /m, /s for M   ======*/</a>
<a name="ln835">    /*==================================*/</a>
<a name="ln836">    /* M sp3 stereo */</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">    bRelRac[DIFL_M ] = GetSp3RelRacAbs( i1, Stereo1 );       /* Mobile-H */</a>
<a name="ln840">    bRelRac[DIFL_MI] = GetSp3RelRacAbs( i1, IsoStereo1 );</a>
<a name="ln841">    bRelRac[DIFL_F ] = GetSp3RelRacAbs( i2, Stereo2 );       /* Fixed-H */</a>
<a name="ln842">    bRelRac[DIFL_FI] = GetSp3RelRacAbs( i2, IsoStereo2 );</a>
<a name="ln843">    if ( SP3_NONE != bRelRac[DIFL_M] ) {</a>
<a name="ln844">        sDifSegs[DIFL_M][DIFS_t_SATOMS] |= (bRelRac[DIFL_M] &amp; SP3_ANY)?  DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln845">        sDifSegs[DIFL_M][DIFS_m_SP3INV] |= (bRelRac[DIFL_M] &amp; SP3_ABS)?  DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln846">        sDifSegs[DIFL_M][DIFS_s_STYPE]  |= (bRelRac[DIFL_M] &amp; SP3_TYPE)? DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln847">    } else {</a>
<a name="ln848">        sDifSegs[DIFL_M][DIFS_t_SATOMS] |= DIFV_BOTH_EMPTY;</a>
<a name="ln849">        sDifSegs[DIFL_M][DIFS_m_SP3INV] |= DIFV_BOTH_EMPTY;</a>
<a name="ln850">        sDifSegs[DIFL_M][DIFS_s_STYPE]  |= DIFV_BOTH_EMPTY;</a>
<a name="ln851">    }</a>
<a name="ln852">    /*=====================*/</a>
<a name="ln853">    /*====     /t    ======*/</a>
<a name="ln854">    /*=====================*/</a>
<a name="ln855">    /* F sp3 stereo */</a>
<a name="ln856">    psDifSegs = &amp;sDifSegs[DIFL_F][DIFS_t_SATOMS];</a>
<a name="ln857">    if ( SP3_ANY &amp; bRelRac[DIFL_F] ) {</a>
<a name="ln858">        if ( Eql_INChI_Stereo( Stereo2, EQL_SP3, Stereo1, EQL_SP3, 0 ) ) {</a>
<a name="ln859">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln860">        } else {</a>
<a name="ln861">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln862">        }</a>
<a name="ln863">    } else</a>
<a name="ln864">    if ( SP3_ANY &amp; bRelRac[DIFL_M] ) {</a>
<a name="ln865">        *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln866">    } else {</a>
<a name="ln867">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln868">    }</a>
<a name="ln869">    /* MI sp3 stereo */</a>
<a name="ln870">    psDifSegs = &amp;sDifSegs[DIFL_MI][DIFS_t_SATOMS];</a>
<a name="ln871">    if ( SP3_ANY &amp; bRelRac[DIFL_MI] ) {</a>
<a name="ln872">        if ( Eql_INChI_Stereo( IsoStereo1, EQL_SP3, Stereo1, EQL_SP3, 0 ) ) {</a>
<a name="ln873">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln874">        } else {</a>
<a name="ln875">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln876">        }</a>
<a name="ln877">    } else</a>
<a name="ln878">    if ( SP3_ANY &amp; bRelRac[DIFL_M] ) {</a>
<a name="ln879">        *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln880">    } else {</a>
<a name="ln881">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln882">    }</a>
<a name="ln883">    /* FI sp3 stereo */</a>
<a name="ln884">    psDifSegs = &amp;sDifSegs[DIFL_FI][DIFS_t_SATOMS];</a>
<a name="ln885">    if ( SP3_ANY &amp; bRelRac[DIFL_FI] ) {</a>
<a name="ln886">        if ( Eql_INChI_Stereo( IsoStereo2, EQL_SP3, Stereo2, EQL_SP3, 0 ) ) {</a>
<a name="ln887">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln888">        } else</a>
<a name="ln889">        if ( !(SP3_ANY &amp; bRelRac[DIFL_M]) &amp;&amp;</a>
<a name="ln890">             !(SP3_ANY &amp; bRelRac[DIFL_F]) &amp;&amp;</a>
<a name="ln891">             Eql_INChI_Stereo( IsoStereo2, EQL_SP3, IsoStereo1, EQL_SP3, 0 ) ) {</a>
<a name="ln892">            *psDifSegs |= DIFV_FI_EQ_MI;</a>
<a name="ln893">        } else {</a>
<a name="ln894">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln895">        }</a>
<a name="ln896">    } else /* similar to /b */</a>
<a name="ln897">    if ( (SP3_ANY &amp; bRelRac[DIFL_F]) ) {</a>
<a name="ln898">        *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln899">    } else</a>
<a name="ln900">    if ( (SP3_ANY &amp; bRelRac[DIFL_MI]) &amp;&amp; !(SP3_ANY &amp; bRelRac[DIFL_M]) ) {</a>
<a name="ln901">        *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln902">    } else {</a>
<a name="ln903">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln904">    }</a>
<a name="ln905">    /*=====================*/</a>
<a name="ln906">    /*====     /m    ======*/</a>
<a name="ln907">    /*=====================*/</a>
<a name="ln908">    /* F sp3 abs stereo inversion */</a>
<a name="ln909">    psDifSegs = &amp;sDifSegs[DIFL_F][DIFS_m_SP3INV];</a>
<a name="ln910">    if ( bRelRac[DIFL_F] &amp; SP3_ABS ) {</a>
<a name="ln911">        /* the order of || operands below is critically important: || is not a commutative operation */</a>
<a name="ln912">        if ( !(bRelRac[DIFL_M] &amp; SP3_ABS) || Stereo2-&gt;nCompInv2Abs != Stereo1-&gt;nCompInv2Abs ) {</a>
<a name="ln913">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln914">        } else {</a>
<a name="ln915">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln916">        }</a>
<a name="ln917">    } else</a>
<a name="ln918">    if ( bRelRac[DIFL_M] &amp; SP3_ABS ) {</a>
<a name="ln919">        *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln920">    } else {</a>
<a name="ln921">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln922">    }</a>
<a name="ln923">    /* MI sp3 abs stereo inversion */</a>
<a name="ln924">    psDifSegs = &amp;sDifSegs[DIFL_MI][DIFS_m_SP3INV];</a>
<a name="ln925">    if ( SP3_ABS &amp; bRelRac[DIFL_MI] ) {</a>
<a name="ln926">        if ( (SP3_ABS &amp; bRelRac[DIFL_M]) &amp;&amp; IsoStereo1-&gt;nCompInv2Abs == Stereo1-&gt;nCompInv2Abs ) {</a>
<a name="ln927">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln928">        } else {</a>
<a name="ln929">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln930">        }</a>
<a name="ln931">    } else</a>
<a name="ln932">    if ( SP3_ABS &amp; bRelRac[DIFL_M] ) {</a>
<a name="ln933">        *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln934">    } else {</a>
<a name="ln935">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln936">    }</a>
<a name="ln937">    /* FI sp3 abs stereo inversion */</a>
<a name="ln938">    psDifSegs = &amp;sDifSegs[DIFL_FI][DIFS_m_SP3INV];</a>
<a name="ln939">    if ( SP3_ABS &amp; bRelRac[DIFL_FI] ) {</a>
<a name="ln940">        if ( (SP3_ABS &amp; bRelRac[DIFL_F]) &amp;&amp; IsoStereo2-&gt;nCompInv2Abs == Stereo2-&gt;nCompInv2Abs ) {</a>
<a name="ln941">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln942">        } else</a>
<a name="ln943">        if ( !(SP3_ABS &amp; bRelRac[DIFL_M]) &amp;&amp;</a>
<a name="ln944">             !(SP3_ABS &amp; bRelRac[DIFL_F]) &amp;&amp;</a>
<a name="ln945">             (SP3_ABS &amp; bRelRac[DIFL_MI]) &amp;&amp; /* make sure IsoStereo1 != NULL */</a>
<a name="ln946">             IsoStereo2-&gt;nCompInv2Abs == IsoStereo1-&gt;nCompInv2Abs ) {</a>
<a name="ln947">            *psDifSegs |= DIFV_FI_EQ_MI;</a>
<a name="ln948">        } else {</a>
<a name="ln949">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln950">        }</a>
<a name="ln951">    } else /* similar to /b */</a>
<a name="ln952">    /* the order of || operands below is critically important: || is no a commutative operation */</a>
<a name="ln953">    if ( (SP3_ABS &amp; bRelRac[DIFL_F]) ) {</a>
<a name="ln954">        *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln955">    } else</a>
<a name="ln956">    if ( (SP3_ABS &amp; bRelRac[DIFL_MI]) &amp;&amp; !(SP3_ABS &amp; bRelRac[DIFL_M]) ) {</a>
<a name="ln957">        *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln958">    } else {</a>
<a name="ln959">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln960">    }</a>
<a name="ln961">    /*=====================*/</a>
<a name="ln962">    /*====     /s    ======*/</a>
<a name="ln963">    /*=====================*/</a>
<a name="ln964">    /* F sp3 stereo type */</a>
<a name="ln965">    psDifSegs = &amp;sDifSegs[DIFL_F][DIFS_s_STYPE];</a>
<a name="ln966">    if ( bRelRac[DIFL_F] &amp; SP3_TYPE ) {</a>
<a name="ln967">        if ( (bRelRac[DIFL_F] &amp; SP3_TYPE) == (bRelRac[DIFL_M] &amp; SP3_TYPE) ) {</a>
<a name="ln968">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln969">        } else {</a>
<a name="ln970">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln971">        }</a>
<a name="ln972">    } else</a>
<a name="ln973">    if ( bRelRac[DIFL_M] &amp; SP3_TYPE ) {</a>
<a name="ln974">        *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln975">    } else {</a>
<a name="ln976">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln977">    }</a>
<a name="ln978">    /* MI sp3 stereo type */</a>
<a name="ln979">    psDifSegs = &amp;sDifSegs[DIFL_MI][DIFS_s_STYPE];</a>
<a name="ln980">    if ( SP3_TYPE &amp; bRelRac[DIFL_MI] ) {</a>
<a name="ln981">        if ( (SP3_TYPE &amp; bRelRac[DIFL_MI]) == (SP3_TYPE &amp; bRelRac[DIFL_M]) ) {</a>
<a name="ln982">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln983">        } else {</a>
<a name="ln984">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln985">        }</a>
<a name="ln986">    } else</a>
<a name="ln987">    if ( SP3_TYPE &amp; bRelRac[DIFL_M] ) {</a>
<a name="ln988">        *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln989">    } else {</a>
<a name="ln990">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln991">    }</a>
<a name="ln992">    /* FI sp3 stereo type */</a>
<a name="ln993">    psDifSegs = &amp;sDifSegs[DIFL_FI][DIFS_s_STYPE];</a>
<a name="ln994">    if ( SP3_TYPE &amp; bRelRac[DIFL_FI] ) {</a>
<a name="ln995">        if ( (SP3_TYPE &amp; bRelRac[DIFL_FI]) == (SP3_TYPE &amp; bRelRac[DIFL_F]) ) {</a>
<a name="ln996">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln997">        } else</a>
<a name="ln998">        if ( !(SP3_TYPE &amp; bRelRac[DIFL_M]) &amp;&amp;</a>
<a name="ln999">             !(SP3_TYPE &amp; bRelRac[DIFL_F]) &amp;&amp;</a>
<a name="ln1000">             (SP3_TYPE &amp; bRelRac[DIFL_MI]) ) {</a>
<a name="ln1001">            *psDifSegs |= DIFV_FI_EQ_MI;</a>
<a name="ln1002">        } else {</a>
<a name="ln1003">            *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln1004">        }</a>
<a name="ln1005">    } else /* similar to /b */</a>
<a name="ln1006">    /* the order of || operands below is critically important: || is not a commutative operation */</a>
<a name="ln1007">    if ( (SP3_TYPE &amp; bRelRac[DIFL_F]) ) {</a>
<a name="ln1008">        *psDifSegs |= DIFV_EQL2PRECED; /* isotopic is missing because there is no isotopes */</a>
<a name="ln1009">    } else</a>
<a name="ln1010">    if ( (SP3_TYPE &amp; bRelRac[DIFL_MI]) &amp;&amp; !(SP3_TYPE &amp; bRelRac[DIFL_M]) ) {</a>
<a name="ln1011">        *psDifSegs |= i2? DIFV_IS_EMPTY : DIFV_EQL2PRECED;</a>
<a name="ln1012">    } else {</a>
<a name="ln1013">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln1014">    }</a>
<a name="ln1015">    /*=====================*/</a>
<a name="ln1016">    /*====     /o    ======*/</a>
<a name="ln1017">    /*=====================*/</a>
<a name="ln1018">    if ( p1 &amp;&amp; p2 &amp;&amp; p1-&gt;ord_number != p2-&gt;ord_number ) {</a>
<a name="ln1019">        sDifSegs[DIFL_F][DIFS_o_TRANSP] |= DIFV_NEQ2PRECED;</a>
<a name="ln1020">    }</a>
<a name="ln1021">    /*=====================*/</a>
<a name="ln1022">    /*====     /i    ======*/</a>
<a name="ln1023">    /*=====================*/</a>
<a name="ln1024">    /* M isotopic atoms */</a>
<a name="ln1025">    psDifSegs = &amp;sDifSegs[DIFL_MI][DIFS_i_IATOMS];</a>
<a name="ln1026">    if ( i1 &amp;&amp; !i1-&gt;bDeleted &amp;&amp; (i1-&gt;nNumberOfIsotopicAtoms || i1-&gt;nNumberOfIsotopicTGroups) ) {</a>
<a name="ln1027">        *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln1028">    } else {</a>
<a name="ln1029">        *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln1030">    }</a>
<a name="ln1031">    /* F isotopic atoms */</a>
<a name="ln1032">    psDifSegs = &amp;sDifSegs[DIFL_FI][DIFS_i_IATOMS];</a>
<a name="ln1033">    if ( i2 &amp;&amp; !i2-&gt;bDeleted ) {</a>
<a name="ln1034">        if ( i2-&gt;nNumberOfIsotopicAtoms || i2-&gt;nNumberOfIsotopicTGroups ) {</a>
<a name="ln1035">            if ( !i1 || i1-&gt;bDeleted ||</a>
<a name="ln1036">                 i2-&gt;nNumberOfIsotopicAtoms   != i1-&gt;nNumberOfIsotopicAtoms ||</a>
<a name="ln1037">                 i2-&gt;nNumberOfIsotopicTGroups != i1-&gt;nNumberOfIsotopicTGroups ) {</a>
<a name="ln1038">                *psDifSegs |= DIFV_NEQ2PRECED;</a>
<a name="ln1039">            } else {</a>
<a name="ln1040">                int diff;</a>
<a name="ln1041">                num  = i1-&gt;nNumberOfIsotopicAtoms;</a>
<a name="ln1042">                diff = 0;</a>
<a name="ln1043">                for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1044">                    /* compare isotopic atoms */</a>
<a name="ln1045">                    if ( (diff = (int)i2-&gt;IsotopicAtom[i].nAtomNumber - (int)i1-&gt;IsotopicAtom[i].nAtomNumber) )</a>
<a name="ln1046">                        break;</a>
<a name="ln1047">                    if ( (diff = (int)i2-&gt;IsotopicAtom[i].nIsoDifference - (int)i1-&gt;IsotopicAtom[i].nIsoDifference) )</a>
<a name="ln1048">                        break;</a>
<a name="ln1049">                    /* compare isotopic H */</a>
<a name="ln1050">                    if ( (diff = (int)i2-&gt;IsotopicAtom[i].nNum_T - (int)i1-&gt;IsotopicAtom[i].nNum_T) )</a>
<a name="ln1051">                        break;</a>
<a name="ln1052">                    if ( (diff = (int)i2-&gt;IsotopicAtom[i].nNum_D - (int)i1-&gt;IsotopicAtom[i].nNum_D) )</a>
<a name="ln1053">                        break;</a>
<a name="ln1054">                    if ( (diff = (int)i2-&gt;IsotopicAtom[i].nNum_H - (int)i1-&gt;IsotopicAtom[i].nNum_H) )</a>
<a name="ln1055">                        break;</a>
<a name="ln1056">                }</a>
<a name="ln1057">                if ( !diff ) {</a>
<a name="ln1058">                    num = i1-&gt;nNumberOfIsotopicTGroups;</a>
<a name="ln1059">                    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1060">                        if ( (diff = (int)i2-&gt;IsotopicTGroup[i].nTGroupNumber - (int)i1-&gt;IsotopicTGroup[i].nTGroupNumber) )</a>
<a name="ln1061">                            break;</a>
<a name="ln1062">                        if ( (diff = (int)i2-&gt;IsotopicTGroup[i].nNum_T - (int)i1-&gt;IsotopicTGroup[i].nNum_T) )</a>
<a name="ln1063">                            break;</a>
<a name="ln1064">                        if ( (diff = (int)i2-&gt;IsotopicTGroup[i].nNum_D - (int)i1-&gt;IsotopicTGroup[i].nNum_D) )</a>
<a name="ln1065">                            return diff;</a>
<a name="ln1066">                        if ( (diff = (int)i2-&gt;IsotopicTGroup[i].nNum_H - (int)i1-&gt;IsotopicTGroup[i].nNum_H) )</a>
<a name="ln1067">                            break;</a>
<a name="ln1068">                    }</a>
<a name="ln1069">                }</a>
<a name="ln1070">                *psDifSegs |= diff? DIFV_NEQ2PRECED : DIFV_FI_EQ_MI;</a>
<a name="ln1071"> </a>
<a name="ln1072">            }</a>
<a name="ln1073">        } else</a>
<a name="ln1074">        if ( i1 &amp;&amp; !i1-&gt;bDeleted &amp;&amp; (i1-&gt;nNumberOfIsotopicAtoms || i1-&gt;nNumberOfIsotopicTGroups) ) {</a>
<a name="ln1075">            *psDifSegs |= DIFV_IS_EMPTY;</a>
<a name="ln1076">        }</a>
<a name="ln1077">    } else</a>
<a name="ln1078">    if ( !i2 ) {</a>
<a name="ln1079">        if ( i1 &amp;&amp; !i1-&gt;bDeleted &amp;&amp; (i1-&gt;nNumberOfIsotopicAtoms || i1-&gt;nNumberOfIsotopicTGroups) ) {</a>
<a name="ln1080">            *psDifSegs |= DIFV_EQL2PRECED;</a>
<a name="ln1081">        } else {</a>
<a name="ln1082">            *psDifSegs |= DIFV_BOTH_EMPTY;</a>
<a name="ln1083">        }</a>
<a name="ln1084">    }</a>
<a name="ln1085"> </a>
<a name="ln1086">    return ret;</a>
<a name="ln1087">}</a>
<a name="ln1088">/**********************************************************************************************/</a>
<a name="ln1089">int INChI_SegmentAction( char cDifSegs )</a>
<a name="ln1090">{</a>
<a name="ln1091">    if ( !(cDifSegs &amp; DIFV_OUTPUT_OMIT_F) ) {</a>
<a name="ln1092">        return INCHI_SEGM_OMIT;</a>
<a name="ln1093">    }</a>
<a name="ln1094">    if ( (cDifSegs &amp; DIFV_OUTPUT_EMPTY_T) &amp;&amp; !(cDifSegs &amp; DIFV_OUTPUT_EMPTY_F) ) {</a>
<a name="ln1095">        return INCHI_SEGM_EMPTY;</a>
<a name="ln1096">    }</a>
<a name="ln1097">    if ( (cDifSegs &amp; DIFV_OUTPUT_FILL_T) ) {</a>
<a name="ln1098">        return INCHI_SEGM_FILL;</a>
<a name="ln1099">    }</a>
<a name="ln1100">    return INCHI_SEGM_OMIT; /* the control flow shoul never reach this point */</a>
<a name="ln1101">}</a>
<a name="ln1102">/**********************************************************************************************/</a>
<a name="ln1103">int MarkUnusedAndEmptyLayers( char sDifSegs[][DIFS_LENGTH] )</a>
<a name="ln1104">{</a>
<a name="ln1105">    /****************************************************</a>
<a name="ln1106">     1. If all elements of a layer are DIFV_IS_EMPTY and/or DIFV_BOTH_EMPTY</a>
<a name="ln1107">        and/or DIFV_EQL2PRECED and/or DIFV_FI_EQ_MI</a>
<a name="ln1108">        and there is NO succeeding non-empty layer then mark the 1st element</a>
<a name="ln1109">        of the layer DIFV_BOTH_EMPTY; this layerr will be omitted.</a>
<a name="ln1110">     </a>
<a name="ln1111">     2. If all elements of a layer are DIFV_IS_EMPTY and/or DIFV_BOTH_EMPTY</a>
<a name="ln1112">        and/or DIFV_EQL2PRECED and/or DIFV_FI_EQ_MI</a>
<a name="ln1113">        and there IS a succeeding non-empty layer then mark the 1st element</a>
<a name="ln1114">        of the layer DIFV_IS_EMPTY and all other elements DIFV_BOTH_EMPTY;</a>
<a name="ln1115">        only the first empty segment of this layerr will be output.</a>
<a name="ln1116"> </a>
<a name="ln1117">     3. If NOT all elements of a layer are DIFV_IS_EMPTY and/or DIFV_BOTH_EMPTY</a>
<a name="ln1118">        and/or DIFV_EQL2PRECED and/or DIFV_FI_EQ_MI</a>
<a name="ln1119">        and the 1st element of the layer is DIFV_BOTH_EMPTY then mark it</a>
<a name="ln1120">        DIFV_IS_EMPTY; it will be output as empty (except M layer).</a>
<a name="ln1121">     */</a>
<a name="ln1122"> </a>
<a name="ln1123">    int i, nLayer, sBits, nFirstSegm;</a>
<a name="ln1124">#define nFirstFmlSegm   DIFS_f_FORMULA</a>
<a name="ln1125">#define nFirstIsoSegm   DIFS_i_IATOMS</a>
<a name="ln1126">     /* FI */</a>
<a name="ln1127">    nLayer = DIFL_FI;</a>
<a name="ln1128">    nFirstSegm = nFirstIsoSegm;</a>
<a name="ln1129">    sBits  = 0;</a>
<a name="ln1130">    for ( i = 0; i &lt; DIFS_idf_LENGTH; i ++ ) {</a>
<a name="ln1131">        sBits |= sDifSegs[nLayer][i];</a>
<a name="ln1132">    }</a>
<a name="ln1133">    if ( !(sBits &amp; DIFV_OUTPUT_OMIT_F) ) {</a>
<a name="ln1134">        /* Omit the FI layer */</a>
<a name="ln1135">        memset( sDifSegs[nLayer], DIFV_BOTH_EMPTY, DIFS_idf_LENGTH);</a>
<a name="ln1136">    } else</a>
<a name="ln1137">    if ( sDifSegs[nLayer][nFirstSegm] == DIFV_BOTH_EMPTY ||</a>
<a name="ln1138">         !(sDifSegs[nLayer][nFirstSegm] &amp; DIFV_OUTPUT_OMIT_F) ) {</a>
<a name="ln1139">        sDifSegs[nLayer][nFirstSegm] = DIFV_IS_EMPTY;</a>
<a name="ln1140">    }</a>
<a name="ln1141"> </a>
<a name="ln1142">    /* MI */</a>
<a name="ln1143">    nLayer = DIFL_MI;</a>
<a name="ln1144">    nFirstSegm = nFirstIsoSegm;</a>
<a name="ln1145">    sBits  = 0;</a>
<a name="ln1146">    for ( i = 0; i &lt; DIFS_idf_LENGTH; i ++ ) {</a>
<a name="ln1147">        sBits |= sDifSegs[nLayer][i];</a>
<a name="ln1148">    }</a>
<a name="ln1149">    if ( !(sBits &amp; DIFV_OUTPUT_OMIT_F) ) {</a>
<a name="ln1150">        /* Omit the MI layer */</a>
<a name="ln1151">        memset( sDifSegs[nLayer], DIFV_BOTH_EMPTY, DIFS_idf_LENGTH);</a>
<a name="ln1152">    } else</a>
<a name="ln1153">    if ( sDifSegs[nLayer][nFirstSegm] == DIFV_BOTH_EMPTY ||</a>
<a name="ln1154">         !(sDifSegs[nLayer][nFirstSegm] &amp; DIFV_OUTPUT_OMIT_F) ) {</a>
<a name="ln1155">        sDifSegs[nLayer][nFirstSegm] = DIFV_IS_EMPTY;</a>
<a name="ln1156">    }</a>
<a name="ln1157"> </a>
<a name="ln1158">    /* F */</a>
<a name="ln1159">    nLayer = DIFL_F;</a>
<a name="ln1160">    nFirstSegm = nFirstFmlSegm;</a>
<a name="ln1161">    sBits  = 0;</a>
<a name="ln1162">    for ( i = 0; i &lt; DIFS_idf_LENGTH; i ++ ) {</a>
<a name="ln1163">        sBits |= sDifSegs[nLayer][i];</a>
<a name="ln1164">    }</a>
<a name="ln1165">    if ( !(sBits &amp; DIFV_OUTPUT_OMIT_F) &amp;&amp;</a>
<a name="ln1166">         sDifSegs[DIFL_FI][nFirstIsoSegm] == DIFV_BOTH_EMPTY ) {</a>
<a name="ln1167">        /* Omit the F layer: no non-iotopic and no isotopic segments */</a>
<a name="ln1168">        memset( sDifSegs[nLayer], DIFV_BOTH_EMPTY, DIFS_idf_LENGTH);</a>
<a name="ln1169">    } else</a>
<a name="ln1170">    /* do not omit fixed-H layer */</a>
<a name="ln1171">    if ( sDifSegs[nLayer][nFirstSegm] == DIFV_BOTH_EMPTY ||</a>
<a name="ln1172">         !(sDifSegs[nLayer][nFirstSegm] &amp; DIFV_OUTPUT_OMIT_F) ) {</a>
<a name="ln1173">        sDifSegs[nLayer][nFirstSegm] = DIFV_IS_EMPTY;</a>
<a name="ln1174">    }</a>
<a name="ln1175">     </a>
<a name="ln1176">    /* M -- leave as it is */</a>
<a name="ln1177">    return 0;</a>
<a name="ln1178">#undef nFirstFmlSegm</a>
<a name="ln1179">#undef nFirstIsoSegm</a>
<a name="ln1180">}</a>
<a name="ln1181">/*********************************************************************************************/</a>
<a name="ln1182">int CompareInchiStereo( INChI_Stereo *Stereo1, INCHI_MODE nFlags1, INChI_Stereo *Stereo2, INCHI_MODE nFlags2 )</a>
<a name="ln1183">{</a>
<a name="ln1184">    int i, num, ret;</a>
<a name="ln1185">    if ( Stereo2 &amp;&amp; Stereo1 ) {</a>
<a name="ln1186">        /*  compare stereogenic bonds */</a>
<a name="ln1187">        num = inchi_min( Stereo2-&gt;nNumberOfStereoBonds, Stereo1-&gt;nNumberOfStereoBonds );</a>
<a name="ln1188">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1189">            if ( (ret = (int)Stereo2-&gt;nBondAtom1[i] - (int)Stereo1-&gt;nBondAtom1[i]) )</a>
<a name="ln1190">                return ret;</a>
<a name="ln1191">            if ( (ret = (int)Stereo2-&gt;nBondAtom2[i] - (int)Stereo1-&gt;nBondAtom2[i]) )</a>
<a name="ln1192">                return ret;</a>
<a name="ln1193">            if ( (ret = (int)Stereo2-&gt;b_parity[i] - (int)Stereo1-&gt;b_parity[i]) )</a>
<a name="ln1194">                return ret;</a>
<a name="ln1195">        }</a>
<a name="ln1196">        if ( (ret = (int)Stereo2-&gt;nNumberOfStereoBonds - (int)Stereo1-&gt;nNumberOfStereoBonds) )</a>
<a name="ln1197">            return ret;</a>
<a name="ln1198">        /*  compare stereogenic atoms */</a>
<a name="ln1199">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1200">        if ( ((nFlags1 | nFlags2) &amp; (INCHI_FLAG_REL_STEREO | INCHI_FLAG_RAC_STEREO) ) &amp;&amp;</a>
<a name="ln1201">             1 == Stereo2-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln1202">             1 == Stereo1-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln1203">            ; /*  do not compare single stereocenters in case of relative stereo */</a>
<a name="ln1204">        } else</a>
<a name="ln1205">#endif</a>
<a name="ln1206">        {</a>
<a name="ln1207">            num = inchi_min( Stereo2-&gt;nNumberOfStereoCenters, Stereo1-&gt;nNumberOfStereoCenters );</a>
<a name="ln1208">            for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1209">                if ( (ret = (int)Stereo2-&gt;nNumber[i] - (int)Stereo1-&gt;nNumber[i]) )</a>
<a name="ln1210">                    return ret;</a>
<a name="ln1211">                if ( (ret = (int)Stereo2-&gt;t_parity[i] - (int)Stereo1-&gt;t_parity[i]) )</a>
<a name="ln1212">                    return ret;</a>
<a name="ln1213">            }</a>
<a name="ln1214">            if ( (ret = (int)Stereo2-&gt;nNumberOfStereoCenters - (int)Stereo1-&gt;nNumberOfStereoCenters) )</a>
<a name="ln1215">                return ret;</a>
<a name="ln1216">            /*  compare stereo-abs-is-inverted flags  for non-relative, non-racemic */</a>
<a name="ln1217">            if ( !((nFlags1 | nFlags2) &amp; (INCHI_FLAG_RAC_STEREO | INCHI_FLAG_REL_STEREO)) ) {</a>
<a name="ln1218">                if ( (ret = (Stereo2-&gt;nCompInv2Abs &lt; 0) - (Stereo1-&gt;nCompInv2Abs &lt; 0)) ) {</a>
<a name="ln1219">                    return ret;</a>
<a name="ln1220">                }</a>
<a name="ln1221">            }</a>
<a name="ln1222">        }</a>
<a name="ln1223">    } else</a>
<a name="ln1224">    if ( Stereo2 &amp;&amp; ( Stereo2-&gt;nNumberOfStereoBonds &gt; 0 ||</a>
<a name="ln1225">                      Stereo2-&gt;nNumberOfStereoCenters &gt; 0</a>
<a name="ln1226">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1227">                      &amp;&amp; /*  do not compare single stereocenters in case of relative stereo */</a>
<a name="ln1228">                      !((nFlags2 &amp; (INCHI_FLAG_REL_STEREO|INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln1229">                       1 == Stereo2-&gt;nNumberOfStereoCenters</a>
<a name="ln1230">                       )</a>
<a name="ln1231">#endif</a>
<a name="ln1232">       ) ) {</a>
<a name="ln1233">        return 1;</a>
<a name="ln1234">    }else</a>
<a name="ln1235">    if ( Stereo1 &amp;&amp; ( Stereo1-&gt;nNumberOfStereoBonds &gt; 0 || </a>
<a name="ln1236">                      Stereo1-&gt;nNumberOfStereoCenters &gt; 0</a>
<a name="ln1237">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1238">                      &amp;&amp; /*  do not compare single stereocenters in case of relative stereo */</a>
<a name="ln1239">                      !((nFlags1 &amp; (INCHI_FLAG_REL_STEREO|INCHI_FLAG_RAC_STEREO)) &amp;&amp;</a>
<a name="ln1240">                       1 == Stereo1-&gt;nNumberOfStereoCenters</a>
<a name="ln1241">                       )</a>
<a name="ln1242">#endif</a>
<a name="ln1243">       ) ) {</a>
<a name="ln1244">        return -1;</a>
<a name="ln1245">    }</a>
<a name="ln1246">    return 0;</a>
<a name="ln1247">}</a>
<a name="ln1248">/**********************************************************************************************/</a>
<a name="ln1249">/*  sorting in descending order: return -1 if *p1 &gt; *p2, return +1 if *p1 &lt; *p2               */</a>
<a name="ln1250">/**********************************************************************************************/</a>
<a name="ln1251">int CompINChI2(const INCHI_SORT *p1, const INCHI_SORT *p2, int bTaut, int bCompareIsotopic)</a>
<a name="ln1252">{</a>
<a name="ln1253">    int ret, num, i, num_H1, num_H2;</a>
<a name="ln1254">    </a>
<a name="ln1255">    const INChI *i1  = NULL; /* tautomeric if exists, otherwise non-tautomeric */</a>
<a name="ln1256">    const INChI *i2  = NULL; /* tautomeric if exists, otherwise non-tautomeric */</a>
<a name="ln1257">    </a>
<a name="ln1258">    int   n1;               /* TAUT_YES if tautomeric i1 exists, otherwise TAUT_NON */</a>
<a name="ln1259">    int   n2;               /* TAUT_YES if tautomeric i2 exists, otherwise TAUT_NON */</a>
<a name="ln1260">    </a>
<a name="ln1261">    const INChI *i1n = NULL; /* non-tautomeric if both tautomeric AND non-tautomeric exist */</a>
<a name="ln1262">    const INChI *i2n = NULL; /* non-tautomeric if both tautomeric AND non-tautomeric exist */</a>
<a name="ln1263"> </a>
<a name="ln1264">    /*const INChI *i1t = NULL;*/ /* temp for i1 if both tautomeric AND non-tautomeric exist */</a>
<a name="ln1265">    /*const INChI *i2t = NULL;*/ /* temp for i2 if both tautomeric AND non-tautomeric exist */</a>
<a name="ln1266"> </a>
<a name="ln1267"> </a>
<a name="ln1268">    /* INChI_Stereo *Stereo1, *Stereo2; */</a>
<a name="ln1269"> </a>
<a name="ln1270">    n1 = ( p1-&gt;pINChI[TAUT_YES] &amp;&amp; p1-&gt;pINChI[TAUT_YES]-&gt;nNumberOfAtoms )? TAUT_YES : TAUT_NON;</a>
<a name="ln1271">    n2 = ( p2-&gt;pINChI[TAUT_YES] &amp;&amp; p2-&gt;pINChI[TAUT_YES]-&gt;nNumberOfAtoms )? TAUT_YES : TAUT_NON;</a>
<a name="ln1272"> </a>
<a name="ln1273">    i1  = p1-&gt;pINChI[n1];</a>
<a name="ln1274">    i1n = (n1 == TAUT_YES &amp;&amp; p1-&gt;pINChI[TAUT_NON] &amp;&amp;</a>
<a name="ln1275">           p1-&gt;pINChI[TAUT_NON]-&gt;nNumberOfAtoms)? p1-&gt;pINChI[TAUT_NON] : (const INChI *)NULL;</a>
<a name="ln1276"> </a>
<a name="ln1277">    i2  = p2-&gt;pINChI[n2];</a>
<a name="ln1278">    i2n = (n2 == TAUT_YES &amp;&amp; p2-&gt;pINChI[TAUT_NON] &amp;&amp;</a>
<a name="ln1279">          p2-&gt;pINChI[TAUT_NON]-&gt;nNumberOfAtoms)? p2-&gt;pINChI[TAUT_NON] : (const INChI *)NULL;</a>
<a name="ln1280"> </a>
<a name="ln1281">    /* non-deleted-non-empty &lt; deleted &lt; empty */</a>
<a name="ln1282">    if ( i1 &amp;&amp; !i2 )</a>
<a name="ln1283">        return -1;   /* non-empty is the smallest (first) */</a>
<a name="ln1284">    if ( !i1 &amp;&amp; i2 )</a>
<a name="ln1285">        return 1;</a>
<a name="ln1286">    if ( !i1 &amp;&amp; !i2 )</a>
<a name="ln1287">        return 0;</a>
<a name="ln1288">    if ( i1-&gt;bDeleted &amp;&amp; !i2-&gt;bDeleted )</a>
<a name="ln1289">        return 1;    /* deleted is the largest (last) among non-empty */</a>
<a name="ln1290">    if ( !i1-&gt;bDeleted &amp;&amp; i2-&gt;bDeleted )</a>
<a name="ln1291">        return -1;</a>
<a name="ln1292"> </a>
<a name="ln1293">    num_H1 = num_H2 = 0;</a>
<a name="ln1294">    </a>
<a name="ln1295">    /* do not compare terminal H */</a>
<a name="ln1296">    if ( (ret = CompareHillFormulasNoH( i1-&gt;szHillFormula, i2-&gt;szHillFormula, &amp;num_H1, &amp;num_H2 )) ) {</a>
<a name="ln1297">        return ret;  /* lexicographic order except the shorter one is greater (last): CH2O &lt; CH2; C3XX &lt; C2XX */</a>
<a name="ln1298">    }</a>
<a name="ln1299"> </a>
<a name="ln1300">    /*********************************************************</a>
<a name="ln1301">            compare non-isotopic non-tautomeric part</a>
<a name="ln1302">     *********************************************************/</a>
<a name="ln1303"> </a>
<a name="ln1304">    /* compare number of atoms (excluding terminal H) */</a>
<a name="ln1305">    if ( (ret = i2-&gt;nNumberOfAtoms - i1-&gt;nNumberOfAtoms) )</a>
<a name="ln1306">        return ret; /*  more atoms first */</a>
<a name="ln1307">    </a>
<a name="ln1308">    /*  compare elements  (excluding terminal H) */</a>
<a name="ln1309">    num = i1-&gt;nNumberOfAtoms;</a>
<a name="ln1310">    for ( i = 0; i &lt; num; i ++ ) { /* should always be equal if Hill formulas are same */</a>
<a name="ln1311">        if ( (ret = (int)i2-&gt;nAtom[i] - (int)i1-&gt;nAtom[i]) )</a>
<a name="ln1312">            return ret; /* greater periodic number first */</a>
<a name="ln1313">    }</a>
<a name="ln1314">    /**********************************************************</a>
<a name="ln1315">        compare connection tables</a>
<a name="ln1316">    ***********************************************************/</a>
<a name="ln1317">    if ( (ret = i2-&gt;lenConnTable - i1-&gt;lenConnTable) )</a>
<a name="ln1318">        return ret; /* longer connection table first */</a>
<a name="ln1319">    num = i2-&gt;lenConnTable; </a>
<a name="ln1320">    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1321">        if ( (ret = (int)i2-&gt;nConnTable[i] - (int)i1-&gt;nConnTable[i]) )</a>
<a name="ln1322">            return ret; /* greater connection table first */</a>
<a name="ln1323">    }</a>
<a name="ln1324">    /*********************************************************</a>
<a name="ln1325">      compare compare total number of H (inverse: H3 &lt; H2 )</a>
<a name="ln1326">    **********************************************************/</a>
<a name="ln1327">    if ( (ret = num_H2 - num_H1) )</a>
<a name="ln1328">        return ret;</a>
<a name="ln1329">    /*********************************************************</a>
<a name="ln1330">      compare non-tautomeric num_H: N &lt; NH3 &lt; NH2 &lt; NH</a>
<a name="ln1331">    **********************************************************/</a>
<a name="ln1332">    num = i1-&gt;nNumberOfAtoms;</a>
<a name="ln1333">    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1334">        if ( i2-&gt;nNum_H[i] != i1-&gt;nNum_H[i] ) {</a>
<a name="ln1335">            return !i2-&gt;nNum_H[i]?  1 :  /* no H first */</a>
<a name="ln1336">                   !i1-&gt;nNum_H[i]? -1 :</a>
<a name="ln1337">                   (int)i2-&gt;nNum_H[i] - (int)i1-&gt;nNum_H[i];</a>
<a name="ln1338">        }</a>
<a name="ln1339">    }</a>
<a name="ln1340">    /*********************************************************</a>
<a name="ln1341">         compare non-isotopic tautomeric part</a>
<a name="ln1342">     *********************************************************/</a>
<a name="ln1343">    if ( (ret = CompareTautNonIsoPartOfINChI( i1, i2)) ) {</a>
<a name="ln1344">        return ret;</a>
<a name="ln1345">    }</a>
<a name="ln1346">    /*</a>
<a name="ln1347">    if ( ret = i2-&gt;lenTautomer - i1-&gt;lenTautomer )</a>
<a name="ln1348">        return ret;</a>
<a name="ln1349">    num = inchi_min( i2-&gt;lenTautomer, i1-&gt;lenTautomer );</a>
<a name="ln1350">    for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1351">        if ( ret = (int)i2-&gt;nTautomer[i] - (int)i1-&gt;nTautomer[i] )</a>
<a name="ln1352">            return ret;</a>
<a name="ln1353">    }</a>
<a name="ln1354">    */</a>
<a name="ln1355">    /*********************************************************</a>
<a name="ln1356">     *                                                       *</a>
<a name="ln1357">     *  at this point both components are either tautomeric  *</a>
<a name="ln1358">     *  or non-tautomeric                                    *</a>
<a name="ln1359">     *                                                       *</a>
<a name="ln1360">     *********************************************************/</a>
<a name="ln1361"> </a>
<a name="ln1362">    /*********************************************************</a>
<a name="ln1363">       non-tautomeric &quot;fixed H&quot; specific</a>
<a name="ln1364">     *********************************************************/</a>
<a name="ln1365">    if ( TAUT_NON == bTaut &amp;&amp; ((i1n &amp;&amp; i1n-&gt;nNum_H_fixed) || (i2n &amp;&amp; i2n-&gt;nNum_H_fixed)) ) {</a>
<a name="ln1366">        /* first, compare non-tautomeric chem. formulas -- they may be different */</a>
<a name="ln1367">        const char *f1 = (i1n /*&amp;&amp; i1n-&gt;nNum_H_fixed*/)? i1n-&gt;szHillFormula : i1-&gt;szHillFormula;</a>
<a name="ln1368">        const char *f2 = (i2n /*&amp;&amp; i2n-&gt;nNum_H_fixed*/)? i2n-&gt;szHillFormula : i2-&gt;szHillFormula;</a>
<a name="ln1369">        if ( f1 &amp;&amp; f2 &amp;&amp;(ret = CompareHillFormulas( f1, f2 ))) {</a>
<a name="ln1370">            return ret;</a>
<a name="ln1371">        }</a>
<a name="ln1372">        /* secondly, compare fixed-H distribution */</a>
<a name="ln1373">        if ( i1n &amp;&amp; i1n-&gt;nNum_H_fixed &amp;&amp; i2n &amp;&amp; i2n-&gt;nNum_H_fixed ) {</a>
<a name="ln1374">            num = inchi_min( i1n-&gt;nNumberOfAtoms, i2n-&gt;nNumberOfAtoms);</a>
<a name="ln1375">            for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1376">                if ( i2n-&gt;nNum_H_fixed[i] != i1n-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln1377">                    return !i2n-&gt;nNum_H_fixed[i]?  1 : /* no fixed H first */</a>
<a name="ln1378">                           !i1n-&gt;nNum_H_fixed[i]? -1 :</a>
<a name="ln1379">                           (int)i2n-&gt;nNum_H_fixed[i] - (int)i1n-&gt;nNum_H_fixed[i];</a>
<a name="ln1380">                }</a>
<a name="ln1381">            }</a>
<a name="ln1382">            if ( (ret = (int)i2n-&gt;nNumberOfAtoms - (int)i1n-&gt;nNumberOfAtoms )) {</a>
<a name="ln1383">                return ret; /* should not happen &lt;BRKPT&gt; */</a>
<a name="ln1384">            }</a>
<a name="ln1385">        } else</a>
<a name="ln1386">        if ( i1n &amp;&amp; i1n-&gt;nNum_H_fixed ) {</a>
<a name="ln1387">            num = i1n-&gt;nNumberOfAtoms;</a>
<a name="ln1388">            for ( i = 0; i &lt; num; i ++ ) {  /* added 2004-05-04 */</a>
<a name="ln1389">                if ( i1n-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln1390">                    return -1; /* i1n-&gt;nNum_H_fixed[i] &gt; 0? -1:1;*/</a>
<a name="ln1391">                }</a>
<a name="ln1392">            }</a>
<a name="ln1393">            /* p1 is tautomeric, p2 is not tautomeric; this must have been detected earlier */</a>
<a name="ln1394">            /*return -1;*/ /* has fixed H first *//* &lt;BRKPT&gt; */ /* removed 2004-05-04 */</a>
<a name="ln1395">        } else {</a>
<a name="ln1396">            num = i2n-&gt;nNumberOfAtoms;</a>
<a name="ln1397">            for ( i = 0; i &lt; num; i ++ ) {  /* added 2004-05-04 */</a>
<a name="ln1398">                if ( i2n-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln1399">                    return 1; /* i2n-&gt;nNum_H_fixed[i] &gt; 0? 1:-1;*/</a>
<a name="ln1400">                }</a>
<a name="ln1401">            }</a>
<a name="ln1402">            /* p2 is tautomeric, p1 is not tautomeric; this must have been detected earlier */</a>
<a name="ln1403">            /*return 1; */ /* has fixed H first *//* &lt;BRKPT&gt; */ /* removed 2004-05-04 */</a>
<a name="ln1404">        }</a>
<a name="ln1405">    }</a>
<a name="ln1406">    </a>
<a name="ln1407">    /*************************************************************************</a>
<a name="ln1408">              if requested non-tautomeric comparison then</a>
<a name="ln1409">              prepare to compare non-taut non-isotopic stereo, etc. </a>
<a name="ln1410">     *************************************************************************/</a>
<a name="ln1411">    if ( TAUT_NON == bTaut ) {</a>
<a name="ln1412">        if ( i1n ) {</a>
<a name="ln1413">            /*i1t = i1;*/</a>
<a name="ln1414">            i1  = i1n;</a>
<a name="ln1415">        }</a>
<a name="ln1416">        if ( i2n ) {</a>
<a name="ln1417">            /*i2t = i2;*/</a>
<a name="ln1418">            i2  = i2n;</a>
<a name="ln1419">        }</a>
<a name="ln1420">    }</a>
<a name="ln1421"> </a>
<a name="ln1422">    /*********************************************************</a>
<a name="ln1423">        compare non-isotopic stereo</a>
<a name="ln1424">     *********************************************************/</a>
<a name="ln1425">    ret = CompareInchiStereo( i1-&gt;Stereo, i1-&gt;nFlags, i2-&gt;Stereo, i2-&gt;nFlags );</a>
<a name="ln1426">    if ( ret ) {</a>
<a name="ln1427">        return ret;</a>
<a name="ln1428">    }</a>
<a name="ln1429">    /*******************************************************</a>
<a name="ln1430">        do not switch back to tautomeric i1, i2</a>
<a name="ln1431">     *******************************************************/</a>
<a name="ln1432">    /* -- how to switch back --</a>
<a name="ln1433">    if ( i1t ) {</a>
<a name="ln1434">        i1  = i1t;</a>
<a name="ln1435">        i1t = NULL;</a>
<a name="ln1436">    }</a>
<a name="ln1437">    if ( i2t ) {</a>
<a name="ln1438">        i2  = i2t;</a>
<a name="ln1439">        i2t = NULL;</a>
<a name="ln1440">    }</a>
<a name="ln1441">    */</a>
<a name="ln1442">    /******************************************************</a>
<a name="ln1443">         compare isotopic non-tautomeric part</a>
<a name="ln1444">     ******************************************************/</a>
<a name="ln1445">    if ( bCompareIsotopic ) {</a>
<a name="ln1446">        if ( (ret = i2-&gt;nNumberOfIsotopicAtoms - i1-&gt;nNumberOfIsotopicAtoms) )</a>
<a name="ln1447">            return ret;</a>
<a name="ln1448">        num = i1-&gt;nNumberOfIsotopicAtoms;</a>
<a name="ln1449">        /*  compare isotopic atoms */</a>
<a name="ln1450">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1451">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nAtomNumber - (int)i1-&gt;IsotopicAtom[i].nAtomNumber) )</a>
<a name="ln1452">                return ret;</a>
<a name="ln1453">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nIsoDifference - (int)i1-&gt;IsotopicAtom[i].nIsoDifference) )</a>
<a name="ln1454">                return ret;</a>
<a name="ln1455">        }</a>
<a name="ln1456">        /* compare isotopic H */</a>
<a name="ln1457">        /* if tautomeric comparison mode then here are compared only non-tautomeric H */</a>
<a name="ln1458">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1459">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nNum_T - (int)i1-&gt;IsotopicAtom[i].nNum_T) )</a>
<a name="ln1460">                return ret;</a>
<a name="ln1461">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nNum_D - (int)i1-&gt;IsotopicAtom[i].nNum_D) )</a>
<a name="ln1462">                return ret;</a>
<a name="ln1463">            if ( (ret = (int)i2-&gt;IsotopicAtom[i].nNum_H - (int)i1-&gt;IsotopicAtom[i].nNum_H) )</a>
<a name="ln1464">                return ret;</a>
<a name="ln1465">        }</a>
<a name="ln1466">        /*****************************************************</a>
<a name="ln1467">             compare isotopic tautomeric part</a>
<a name="ln1468">         *****************************************************/</a>
<a name="ln1469">        if ( (ret = i2-&gt;nNumberOfIsotopicTGroups - i1-&gt;nNumberOfIsotopicTGroups) )</a>
<a name="ln1470">            return ret;</a>
<a name="ln1471">        num = i1-&gt;nNumberOfIsotopicTGroups;</a>
<a name="ln1472">        for ( i = 0; i &lt; num; i ++ ) {</a>
<a name="ln1473">            if ( (ret = (int)i2-&gt;IsotopicTGroup[i].nTGroupNumber - (int)i1-&gt;IsotopicTGroup[i].nTGroupNumber) )</a>
<a name="ln1474">                return ret;</a>
<a name="ln1475">            if ( (ret = (int)i2-&gt;IsotopicTGroup[i].nNum_T - (int)i1-&gt;IsotopicTGroup[i].nNum_T) )</a>
<a name="ln1476">                return ret;</a>
<a name="ln1477">            if ( (ret = (int)i2-&gt;IsotopicTGroup[i].nNum_D - (int)i1-&gt;IsotopicTGroup[i].nNum_D) )</a>
<a name="ln1478">                return ret;</a>
<a name="ln1479">            if ( (ret = (int)i2-&gt;IsotopicTGroup[i].nNum_H - (int)i1-&gt;IsotopicTGroup[i].nNum_H) )</a>
<a name="ln1480">                return ret;</a>
<a name="ln1481">        }</a>
<a name="ln1482">    </a>
<a name="ln1483">        /****************************************************</a>
<a name="ln1484">            compare isotopic stereo</a>
<a name="ln1485">         ****************************************************/</a>
<a name="ln1486">        ret = CompareInchiStereo( i1-&gt;StereoIsotopic, i1-&gt;nFlags, i2-&gt;StereoIsotopic, i2-&gt;nFlags );</a>
<a name="ln1487">        if ( ret ) {</a>
<a name="ln1488">            return ret;</a>
<a name="ln1489">        }</a>
<a name="ln1490">    }</a>
<a name="ln1491"> </a>
<a name="ln1492">    /**********************************************************</a>
<a name="ln1493">        compare charges: non-charged first, then in order of</a>
<a name="ln1494">        ascending charges (negative first) </a>
<a name="ln1495">    ***********************************************************/</a>
<a name="ln1496">    if ( i2-&gt;nTotalCharge &amp;&amp; i1-&gt;nTotalCharge ) {</a>
<a name="ln1497">        /*  both are charged; smaller charges first */</a>
<a name="ln1498">        ret = (int)i1-&gt;nTotalCharge - (int)i2-&gt;nTotalCharge;</a>
<a name="ln1499">        return ret;</a>
<a name="ln1500">    }</a>
<a name="ln1501">    if ( (ret = (i1-&gt;nTotalCharge? 1:0) - (i2-&gt;nTotalCharge? 1:0)) ) {</a>
<a name="ln1502">        /*  only one is charged; uncharged first */</a>
<a name="ln1503">        return ret;</a>
<a name="ln1504">    }</a>
<a name="ln1505">    /* stable sort */</a>
<a name="ln1506">    /*ret = p1-&gt;ord_number - p2-&gt;ord_number;*/</a>
<a name="ln1507"> </a>
<a name="ln1508">    return ret;</a>
<a name="ln1509">}</a>
<a name="ln1510">/***********************************************************************/</a>
<a name="ln1511">int CompINChINonTaut2(const void *p1, const void *p2)</a>
<a name="ln1512">{</a>
<a name="ln1513">    int ret;</a>
<a name="ln1514">    ret = CompINChI2( (const INCHI_SORT *)p1, (const INCHI_SORT *)p2, TAUT_NON, 1 );</a>
<a name="ln1515">#if ( CANON_FIXH_TRANS == 1 )</a>
<a name="ln1516">    if ( !ret ) {</a>
<a name="ln1517">        /* to obtain canonical transposition 2004-05-10 */</a>
<a name="ln1518">        ret = CompINChI2( (const INCHI_SORT *)p1, (const INCHI_SORT *)p2, TAUT_YES, 1 );</a>
<a name="ln1519">    }</a>
<a name="ln1520">#endif</a>
<a name="ln1521">    if ( !ret ) {</a>
<a name="ln1522">        /* stable sort */</a>
<a name="ln1523">        ret = ((const INCHI_SORT *)p1)-&gt;ord_number - ((const INCHI_SORT *)p2)-&gt;ord_number;</a>
<a name="ln1524">    }</a>
<a name="ln1525">    return ret;</a>
<a name="ln1526">}</a>
<a name="ln1527">/***********************************************************************/</a>
<a name="ln1528">int CompINChITaut2(const void *p1, const void *p2)</a>
<a name="ln1529">{</a>
<a name="ln1530">    int ret;</a>
<a name="ln1531">    ret = CompINChI2( (const INCHI_SORT *)p1, (const INCHI_SORT *)p2, TAUT_YES, 1 );</a>
<a name="ln1532">#if ( CANON_FIXH_TRANS == 1 )</a>
<a name="ln1533">    if ( !ret ) {</a>
<a name="ln1534">        /* to obtain canonical transposition 2004-05-10 */</a>
<a name="ln1535">        ret = CompINChI2( (const INCHI_SORT *)p1, (const INCHI_SORT *)p2, TAUT_NON, 1 );</a>
<a name="ln1536">    }</a>
<a name="ln1537">#endif</a>
<a name="ln1538">    if ( !ret ) {</a>
<a name="ln1539">        /* stable sort */</a>
<a name="ln1540">        ret = ((const INCHI_SORT *)p1)-&gt;ord_number - ((const INCHI_SORT *)p2)-&gt;ord_number;</a>
<a name="ln1541">    }</a>
<a name="ln1542">    return ret;</a>
<a name="ln1543">}</a>
<a name="ln1544">/**********************************************************************************************/</a>
<a name="ln1545">/*  strrev from K&amp;R is not in ANSI-compatible C library */</a>
<a name="ln1546">void mystrrev( char *p )</a>
<a name="ln1547">{</a>
<a name="ln1548">    char c, *q = p;</a>
<a name="ln1549">    while( *q++ )</a>
<a name="ln1550">        ;</a>
<a name="ln1551">    q -= 2; /*  pointer to the last character */</a>
<a name="ln1552">    while ( p &lt; q ) {</a>
<a name="ln1553">        c    = *q;  /*  swap */</a>
<a name="ln1554">        *q-- = *p;</a>
<a name="ln1555">        *p++ = c;</a>
<a name="ln1556">    }</a>
<a name="ln1557">}</a>
<a name="ln1558">/*****************************************************************************************/</a>
<a name="ln1559">/*                Find DFS order for CT(canon. numbers and Hs) output                    */</a>
<a name="ln1560">/*****************************************************************************************/</a>
<a name="ln1561"> </a>
<a name="ln1562">static AT_NUMB   *gDfs4CT_nDfsNumber;</a>
<a name="ln1563">static AT_NUMB   *gDfs4CT_nNumDescendants;</a>
<a name="ln1564">static int        gDfs4CT_nCurrentAtom;</a>
<a name="ln1565"> </a>
<a name="ln1566">/**********************************************************************************************/</a>
<a name="ln1567">static int CompareDfsDescendants4CT( const void *a1, const void *a2 )</a>
<a name="ln1568">{</a>
<a name="ln1569">    int neigh1 = (int)*(const AT_RANK*)a1;</a>
<a name="ln1570">    int neigh2 = (int)*(const AT_RANK*)a2;</a>
<a name="ln1571">    if ( neigh1 &gt; MAX_ATOMS ) {</a>
<a name="ln1572">        if ( neigh2 &gt; MAX_ATOMS ) {</a>
<a name="ln1573">            return 0;</a>
<a name="ln1574">        }</a>
<a name="ln1575">        return 1;</a>
<a name="ln1576">    } else</a>
<a name="ln1577">    if ( neigh2 &gt; MAX_ATOMS ) {</a>
<a name="ln1578">        return -1;</a>
<a name="ln1579">    } else {</a>
<a name="ln1580">        AT_RANK nCurDfsNumber = gDfs4CT_nDfsNumber[gDfs4CT_nCurrentAtom];</a>
<a name="ln1581">        int nDesc1 = nCurDfsNumber &gt; gDfs4CT_nDfsNumber[neigh1]?</a>
<a name="ln1582">                         0 : (int)gDfs4CT_nNumDescendants[neigh1];</a>
<a name="ln1583">        int nDesc2 = nCurDfsNumber &gt; gDfs4CT_nDfsNumber[neigh2]?</a>
<a name="ln1584">                         0 : (int)gDfs4CT_nNumDescendants[neigh2];</a>
<a name="ln1585">        int ret;</a>
<a name="ln1586">        if ( (ret = nDesc1 - nDesc2) ) {</a>
<a name="ln1587">            return ret;</a>
<a name="ln1588">        }</a>
<a name="ln1589">        return  (int)neigh1 - (int)neigh2; /*  canon. numbers difference */</a>
<a name="ln1590">    }</a>
<a name="ln1591">}</a>
<a name="ln1592">/**********************************************************************************************/</a>
<a name="ln1593">/*  sp_ATOM *at, AT_RANK *nRank, int num_atoms */</a>
<a name="ln1594">AT_NUMB *GetDfsOrder4CT( AT_NUMB *LinearCT, int nLenCT, S_CHAR *nNum_H, int num_atoms, int nCtMode )</a>
<a name="ln1595">{</a>
<a name="ln1596">    AT_NUMB    *nStackAtom = NULL;</a>
<a name="ln1597">    int         nTopStackAtom=-1;</a>
<a name="ln1598">    AT_NUMB    *nNumDescendants = NULL; /*  number of descendants incl. closures and the atom itself */</a>
<a name="ln1599">    AT_NUMB    *nDfsNumber = NULL;</a>
<a name="ln1600">    S_CHAR     *cNeighNumb = NULL;</a>
<a name="ln1601">    NEIGH_LIST *nl = NULL;</a>
<a name="ln1602">    AT_NUMB     nDfs;</a>
<a name="ln1603">    int         i, j, u, k, start, num_rings, nTotOutputStringLen;</a>
<a name="ln1604">    AT_NUMB    *nOutputString = NULL, cDelim;</a>
<a name="ln1605">    int         bCtPredecessors = (nCtMode &amp; CT_MODE_PREDECESSORS);</a>
<a name="ln1606"> </a>
<a name="ln1607">    /* int nNumStartChildren; */</a>
<a name="ln1608"> </a>
<a name="ln1609"> </a>
<a name="ln1610">    /*  allocate arrays */</a>
<a name="ln1611">    nStackAtom      = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nStackAtom[0]));</a>
<a name="ln1612">    nNumDescendants = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nNumDescendants[0]));</a>
<a name="ln1613">    nDfsNumber      = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nDfsNumber[0]));</a>
<a name="ln1614">    cNeighNumb      = (S_CHAR  *) inchi_malloc(num_atoms*sizeof(cNeighNumb[0]));</a>
<a name="ln1615">    nl              = CreateNeighListFromLinearCT( LinearCT, nLenCT, num_atoms );</a>
<a name="ln1616">    /*  check allocation */</a>
<a name="ln1617">    if ( !nStackAtom || !nNumDescendants || !nDfsNumber || !cNeighNumb || !nl ) {</a>
<a name="ln1618">        /* ret = CT_OUT_OF_RAM; */ /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1619">        goto exit_function;</a>
<a name="ln1620">    }</a>
<a name="ln1621">    if ( bCtPredecessors ) {</a>
<a name="ln1622">        start = 0;</a>
<a name="ln1623">    } else {</a>
<a name="ln1624">        /*  find DFS start vertex (atom) */</a>
<a name="ln1625">        for ( i = 1, start = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1626">            if ( nl[i][0] &lt;  nl[start][0] ) { /*  index = nRank-1 */</a>
<a name="ln1627">                start = i;</a>
<a name="ln1628">            }</a>
<a name="ln1629">        }</a>
<a name="ln1630">    }</a>
<a name="ln1631">    /*</a>
<a name="ln1632">      vertex information:</a>
<a name="ln1633">        1. Number of (forward edges) + (back edges, first visit -- ring closures): nl[i][0]</a>
<a name="ln1634">        2. Number of vertices traversed from this vertex, including the vertex:    nNumDescendants[i]</a>
<a name="ln1635">        3. Each edge information:</a>
<a name="ln1636">           a. forward edge (0) or back edge (1) indicator: nDfsNumber[i] &gt; nDfsNumber[neigh]</a>
<a name="ln1637">           b. neighbor at another end of the edge neigh = nl[i][k+1], k &lt; i</a>
<a name="ln1638"> </a>
<a name="ln1639">        Total per edge: 2 + 2*(number of edges)</a>
<a name="ln1640">    */</a>
<a name="ln1641"> </a>
<a name="ln1642">    /* DFS initiation */</a>
<a name="ln1643">    u               = start; /* start atom */</a>
<a name="ln1644">    nDfs            = 0;</a>
<a name="ln1645">    nTopStackAtom   =-1;</a>
<a name="ln1646">    memset( nDfsNumber,      0, num_atoms*sizeof(nDfsNumber[0]));</a>
<a name="ln1647">    memset( nNumDescendants, 0, num_atoms*sizeof(nNumDescendants[0]));</a>
<a name="ln1648">    memset( cNeighNumb,      0, num_atoms*sizeof(cNeighNumb[0]));</a>
<a name="ln1649">    /*  push the start atom on the stack */</a>
<a name="ln1650">    nDfsNumber[u] = ++nDfs;</a>
<a name="ln1651">    if ( bCtPredecessors ) {</a>
<a name="ln1652">        nNumDescendants[u] = 0; /* atom #1 has no predecessor */</a>
<a name="ln1653">    } else {</a>
<a name="ln1654">        nNumDescendants[u] = 1; /* count itself as a descendant */</a>
<a name="ln1655">    }</a>
<a name="ln1656">    nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln1657">    /* nNumStartChildren = 0; */</a>
<a name="ln1658">    num_rings = 0;</a>
<a name="ln1659"> </a>
<a name="ln1660">    /* DFS */</a>
<a name="ln1661">    </a>
<a name="ln1662">    do {</a>
<a name="ln1663">        /* advance */</a>
<a name="ln1664">        while ( i=(int)nStackAtom[nTopStackAtom], j = (int)cNeighNumb[i]+1,  (int)nl[i][0] &gt;= j )</a>
<a name="ln1665">        /*while ( (int)nl[i=nStackAtom[nTopStackAtom]][0] &gt;= (j = (int)cNeighNumb[i]+1) )*/</a>
<a name="ln1666">        /* replaced due to missing sequence point; undefined behavior, pointed by Geoffrey Hutchison */</a>
<a name="ln1667">        {</a>
<a name="ln1668">            cNeighNumb[i] ++;</a>
<a name="ln1669">            u = (int)nl[i][j]; /*  jth neighbor of the vertex i */</a>
<a name="ln1670">            if ( !nDfsNumber[u] ) {</a>
<a name="ln1671">                /* tree edge, 1st visit -- advance */</a>
<a name="ln1672">                /* put unexplored vertex u on the stack for further examination */</a>
<a name="ln1673">                nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln1674">                nDfsNumber[u] = ++nDfs;</a>
<a name="ln1675">                if ( bCtPredecessors ) {</a>
<a name="ln1676">                    nNumDescendants[u] = i+1; /* predecessor's rank */</a>
<a name="ln1677">                } else {</a>
<a name="ln1678">                    nNumDescendants[u] ++; /* count atom u as its descendant */</a>
<a name="ln1679">                }</a>
<a name="ln1680">            } else</a>
<a name="ln1681">            if ( nTopStackAtom &amp;&amp; u != (int)nStackAtom[nTopStackAtom-1] &amp;&amp;</a>
<a name="ln1682">                 /* back edge: u is not a predecessor of i */</a>
<a name="ln1683">                 nDfsNumber[u] &lt; nDfsNumber[i] ) {</a>
<a name="ln1684">                /* Back edge, 1st visit: u is an ancestor of i (ring closure) */</a>
<a name="ln1685">                if ( !bCtPredecessors ) {</a>
<a name="ln1686">                    nNumDescendants[i] ++; /* count closures as descendants */</a>
<a name="ln1687">                }</a>
<a name="ln1688">                num_rings ++;          /* count ring closures */</a>
<a name="ln1689">            } else {</a>
<a name="ln1690">                nl[i][j] = MAX_ATOMS+1; /* back edge, 2nd visit: mark as deleted */</a>
<a name="ln1691">            }</a>
<a name="ln1692">        }</a>
<a name="ln1693">        cNeighNumb[i] = 0; /* all neighbors of the ith atom have been</a>
<a name="ln1694">                              traversed; resore the neighbor counter */</a>
<a name="ln1695">        /* back up */</a>
<a name="ln1696">        if ( !bCtPredecessors &amp;&amp; nTopStackAtom /* that is, i != start */) {</a>
<a name="ln1697">            u = (int)nStackAtom[nTopStackAtom-1]; /* predecessor of i */</a>
<a name="ln1698">            nNumDescendants[u] += nNumDescendants[i]; /* add descendants */</a>
<a name="ln1699">        }</a>
<a name="ln1700">    } while ( --nTopStackAtom &gt;= 0 );</a>
<a name="ln1701"> </a>
<a name="ln1702">    /* Sort the neighbors in ascending order so that:</a>
<a name="ln1703">       primary key   = number of descendants in the DFS tree; closure neighbor is 0</a>
<a name="ln1704">       secondary key = canonical number (here vertex number = canonical number - 1)</a>
<a name="ln1705">     */</a>
<a name="ln1706"> </a>
<a name="ln1707">    /* set static globals for the sorting: */</a>
<a name="ln1708">    gDfs4CT_nDfsNumber      = nDfsNumber;     </a>
<a name="ln1709">    gDfs4CT_nNumDescendants = nNumDescendants;</a>
<a name="ln1710">    gDfs4CT_nCurrentAtom    = -1;   </a>
<a name="ln1711"> </a>
<a name="ln1712">    /* sorting; deleted will be the last neighbors */</a>
<a name="ln1713">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1714">        if ( nl[i][0] &gt; 1 ) {</a>
<a name="ln1715">            gDfs4CT_nCurrentAtom = i;</a>
<a name="ln1716">            insertions_sort( &amp;nl[i][1], nl[i][0], sizeof(nl[i][1]), CompareDfsDescendants4CT );</a>
<a name="ln1717">        }</a>
<a name="ln1718">        /* reduce number of neighbors to exclude deleted */</a>
<a name="ln1719">        for ( k = 0; k &lt; nl[i][0] &amp;&amp; nl[i][k+1] &lt;= MAX_ATOMS; k ++ )</a>
<a name="ln1720">            ;</a>
<a name="ln1721">        nl[i][0] = k;</a>
<a name="ln1722">    }</a>
<a name="ln1723"> </a>
<a name="ln1724">    nTotOutputStringLen = 3*(num_atoms+num_rings+1); /*  last 3 elements are a 'zero termination' */</a>
<a name="ln1725"> </a>
<a name="ln1726">    if ( bCtPredecessors ) {</a>
<a name="ln1727">        if ( (nOutputString = (AT_RANK *)inchi_calloc( nTotOutputStringLen, sizeof(nOutputString[0]) )) ) {</a>
<a name="ln1728">            cDelim = '-';</a>
<a name="ln1729">            for ( u = 0, k = -3 ; u &lt; num_atoms; u ++ ) {</a>
<a name="ln1730">                k += 3;</a>
<a name="ln1731">                if ( k+6 &gt; nTotOutputStringLen ) {</a>
<a name="ln1732">                    goto exit_error;  /* program error */</a>
<a name="ln1733">                }</a>
<a name="ln1734">                nOutputString[k]   = nNumDescendants[u]? nNumDescendants[u] : MAX_ATOMS+1;</a>
<a name="ln1735">                nOutputString[k+1] = nNum_H? 16+nNum_H[u]:0;</a>
<a name="ln1736">                nOutputString[k+2] = k? ',' : '\0';</a>
<a name="ln1737">                for ( j = 1; j &lt;= nl[u][0] &amp;&amp; nDfsNumber[u] &gt; nDfsNumber[i=nl[u][j]]; j ++ ) {</a>
<a name="ln1738">                    /* closures */</a>
<a name="ln1739">                    k += 3;</a>
<a name="ln1740">                    if ( k+6 &gt; nTotOutputStringLen ) {</a>
<a name="ln1741">                        goto exit_error;  /* program error */</a>
<a name="ln1742">                    }</a>
<a name="ln1743">                    nOutputString[k]   = i+1;  /* closure */</a>
<a name="ln1744">                    nOutputString[k+1] = 0;</a>
<a name="ln1745">                    nOutputString[k+2] = cDelim;</a>
<a name="ln1746">                }</a>
<a name="ln1747">            }</a>
<a name="ln1748">        }</a>
<a name="ln1749">    } else {</a>
<a name="ln1750">        if ( nNumDescendants ) {  /* do not need anymore */</a>
<a name="ln1751">            inchi_free( nNumDescendants );</a>
<a name="ln1752">            nNumDescendants = NULL;</a>
<a name="ln1753">        }</a>
<a name="ln1754">        /* </a>
<a name="ln1755">            the output string contains:</a>
<a name="ln1756">              (num_atoms) atoms for the DFS (spanning) tree</a>
<a name="ln1757">              (num_atoms-1) delimiters for the DFS (spanning) tree</a>
<a name="ln1758">              1 character for each atom that has 1 terminal hydrogen atoms</a>
<a name="ln1759">              2 characters  for each atom that has 2-9 terminal hydrogen atoms</a>
<a name="ln1760">              3 characters  for each atom that has 10-99 terminal hydrogen atoms, etc.</a>
<a name="ln1761">              (num_rings) atoms for the ring closures</a>
<a name="ln1762">              (num_rings) delimiters for the ring closures</a>
<a name="ln1763">        */</a>
<a name="ln1764"> </a>
<a name="ln1765">        if ( (nOutputString = (AT_RANK *)inchi_calloc( nTotOutputStringLen, sizeof(nOutputString[0]) )) ) {</a>
<a name="ln1766">            u               = start; /*  start atom */</a>
<a name="ln1767">            nTopStackAtom   =-1;</a>
<a name="ln1768">            memset( cNeighNumb, 0, num_atoms*sizeof(cNeighNumb[0]));</a>
<a name="ln1769">            /*  push the start atom on the stack */</a>
<a name="ln1770">            nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln1771">            /*  output the starting atom */</a>
<a name="ln1772">            k = 0;</a>
<a name="ln1773">            nOutputString[k]   = u+1;</a>
<a name="ln1774">            nOutputString[k+1] = nNum_H? 16+nNum_H[u]:0;</a>
<a name="ln1775">            nOutputString[k+2] = '\0';</a>
<a name="ln1776"> </a>
<a name="ln1777">            do {</a>
<a name="ln1778">                /* advance */</a>
<a name="ln1779">                while ( i=(int)nStackAtom[nTopStackAtom], j = (int)cNeighNumb[i]+1,  (int)nl[i][0] &gt;= j )</a>
<a name="ln1780">                /*while ( (int)nl[i=nStackAtom[nTopStackAtom]][0] &gt;= (j = (int)cNeighNumb[i]+1) )*/</a>
<a name="ln1781">                /* replaced due to missing sequence point; undefined behavior, reported by Geoffrey Hutchison */</a>
<a name="ln1782">                {</a>
<a name="ln1783">                    k += 3;</a>
<a name="ln1784">                    if ( k+6 &gt; nTotOutputStringLen ) {</a>
<a name="ln1785">                        goto exit_error;  /* program error */</a>
<a name="ln1786">                    }</a>
<a name="ln1787">                    cNeighNumb[i] ++;</a>
<a name="ln1788">                    u = (int)nl[i][j]; /* neighbor */</a>
<a name="ln1789"> </a>
<a name="ln1790">                    /* output neighbor's canonical number */</a>
<a name="ln1791">                    nOutputString[k] = u+1;</a>
<a name="ln1792"> </a>
<a name="ln1793">                    if ( nDfsNumber[u] &gt; nDfsNumber[i] ) {</a>
<a name="ln1794">                        /* tree edge, 1st visit -- advance */</a>
<a name="ln1795">                        /* put 'unexplored' vertex u on the stack */</a>
<a name="ln1796">                        nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln1797"> </a>
<a name="ln1798">                        /* output neighbor's number of H */</a>
<a name="ln1799">                        nOutputString[k+1] = nNum_H? 16+nNum_H[u]:0;</a>
<a name="ln1800">                    } else {</a>
<a name="ln1801">                        nOutputString[k+1] = 0;</a>
<a name="ln1802">                    }</a>
<a name="ln1803">                    /* output a delimiter preceding the neighbor */</a>
<a name="ln1804">                    if ( 1 &lt; nl[i][0] ) {</a>
<a name="ln1805">                        if ( j == 1 ) {</a>
<a name="ln1806">                            cDelim = '(';</a>
<a name="ln1807">                        } else</a>
<a name="ln1808">                        if ( j == nl[i][0] ) {</a>
<a name="ln1809">                            cDelim = ')';</a>
<a name="ln1810">                        } else {</a>
<a name="ln1811">                            cDelim = ',';</a>
<a name="ln1812">                        }</a>
<a name="ln1813">                    } else {</a>
<a name="ln1814">                        cDelim = '-';</a>
<a name="ln1815">                    }</a>
<a name="ln1816">                    nOutputString[k+2] = cDelim;</a>
<a name="ln1817">                }</a>
<a name="ln1818">                cNeighNumb[i] = 0;</a>
<a name="ln1819"> </a>
<a name="ln1820">                /* back up: nothing else to do */</a>
<a name="ln1821">            } while ( --nTopStackAtom &gt;= 0 );</a>
<a name="ln1822">        }</a>
<a name="ln1823">    }</a>
<a name="ln1824">    goto exit_function;</a>
<a name="ln1825"> </a>
<a name="ln1826">exit_error:</a>
<a name="ln1827">    if ( nOutputString ) {</a>
<a name="ln1828">        inchi_free( nOutputString );</a>
<a name="ln1829">        nOutputString = NULL;</a>
<a name="ln1830">    }</a>
<a name="ln1831"> </a>
<a name="ln1832">exit_function:</a>
<a name="ln1833">    if ( nStackAtom )</a>
<a name="ln1834">        inchi_free( nStackAtom );</a>
<a name="ln1835">    if ( nNumDescendants )</a>
<a name="ln1836">        inchi_free( nNumDescendants );</a>
<a name="ln1837">    if ( nDfsNumber )</a>
<a name="ln1838">        inchi_free( nDfsNumber );</a>
<a name="ln1839">    if ( cNeighNumb )</a>
<a name="ln1840">        inchi_free( cNeighNumb );</a>
<a name="ln1841">    if ( nl )</a>
<a name="ln1842">        FreeNeighList( nl );</a>
<a name="ln1843">    return nOutputString;</a>
<a name="ln1844">}</a>
<a name="ln1845">/**********************************************************************************************/</a>
<a name="ln1846">int GetInpStructErrorType( INPUT_PARMS *ip, int err, char *pStrErrStruct, int num_inp_atoms )</a>
<a name="ln1847">{</a>
<a name="ln1848">    if ( err &amp;&amp; err == 9 )</a>
<a name="ln1849">        return _IS_ERROR; /*  sdfile bypassed to $$$$ */</a>
<a name="ln1850">    if ( err &amp;&amp; err &lt; 30 )</a>
<a name="ln1851">        return _IS_FATAL;</a>
<a name="ln1852">    if ( num_inp_atoms &lt;= 0 || err ) {</a>
<a name="ln1853">        if ( 98 == err &amp;&amp; 0 == num_inp_atoms &amp;&amp; ip-&gt;bAllowEmptyStructure )</a>
<a name="ln1854">            return _IS_WARNING;</a>
<a name="ln1855">        return _IS_ERROR;</a>
<a name="ln1856">    }</a>
<a name="ln1857">    if ( pStrErrStruct[0] )</a>
<a name="ln1858">        return _IS_WARNING;</a>
<a name="ln1859">    return _IS_OKAY;</a>
<a name="ln1860">}</a>
<a name="ln1861">/**********************************************************************************************/</a>
<a name="ln1862">int ProcessStructError( INCHI_IOSTREAM *output_file, INCHI_IOSTREAM *log_file, /*int err,*/ </a>
<a name="ln1863">                        char *pStrErrStruct, int nErrorType,</a>
<a name="ln1864">                        int *bXmlStructStarted, long num_inp, INPUT_PARMS *ip, char *pStr, int nStrLen )</a>
<a name="ln1865">{</a>
<a name="ln1866">    int b_ok;</a>
<a name="ln1867">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln1868">    int bPlainText = (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT) &amp;&amp;</a>
<a name="ln1869">                     (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW ) &amp;&amp;</a>
<a name="ln1870">                    !(ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML);</a>
<a name="ln1871">#else</a>
<a name="ln1872">    int bPlainText = 0;</a>
<a name="ln1873">#endif</a>
<a name="ln1874">    if ( !bPlainText &amp;&amp; *bXmlStructStarted &lt;= 0 ) {</a>
<a name="ln1875">        return nErrorType;</a>
<a name="ln1876">    }</a>
<a name="ln1877">    /*  Fatal error, Error, Warning */</a>
<a name="ln1878">    if ( nErrorType ) {</a>
<a name="ln1879">        if ( bPlainText ) {</a>
<a name="ln1880">            if ( !(b_ok=OutputINChIPlainError( output_file, pStr, nStrLen, pStrErrStruct, nErrorType ) ) ) {</a>
<a name="ln1881">                inchi_ios_eprint( log_file, &quot;Cannot create message for error (structure #%ld.%s%s%s%s) Terminating.\n&quot;,</a>
<a name="ln1882">                                                            num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1883">            } else {</a>
<a name="ln1884">                inchi_ios_print( output_file, &quot;\n&quot; ); /* add a blank line after the WINCHI Window message */</a>
<a name="ln1885">            }</a>
<a name="ln1886">        } else {</a>
<a name="ln1887">            if ( !(b_ok=OutputINChIXmlError( output_file, pStr, nStrLen, 2, /*err,*/ pStrErrStruct, nErrorType ) ) ) {</a>
<a name="ln1888">                inchi_ios_eprint( log_file, &quot;Cannot create xml tag for error (structure #%ld.%s%s%s%s) Terminating.\n&quot;,</a>
<a name="ln1889">                                                            num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1890">            }</a>
<a name="ln1891">            if ( !b_ok || nErrorType == _IS_FATAL || nErrorType == _IS_ERROR ) {</a>
<a name="ln1892">                /*  close current structure output */</a>
<a name="ln1893">                if ( !OutputINChIXmlStructEndTag( output_file, pStr, nStrLen, 1 ) ) {</a>
<a name="ln1894">                    inchi_ios_eprint( log_file, &quot;Cannot create end xml tag for structure #%ld.%s%s%s%s Terminating.\n&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1895">                    *bXmlStructStarted = -1;</a>
<a name="ln1896">                    b_ok = 0;</a>
<a name="ln1897">                } else {</a>
<a name="ln1898">                    *bXmlStructStarted = 0;</a>
<a name="ln1899">                }</a>
<a name="ln1900">            }</a>
<a name="ln1901">        }</a>
<a name="ln1902">        return b_ok? nErrorType : _IS_FATAL;</a>
<a name="ln1903">    }</a>
<a name="ln1904">    return nErrorType;</a>
<a name="ln1905">    </a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908">#if ( TEST_RENUMB_ATOMS == 1 ) /*  { */</a>
<a name="ln1909">/***************************************************************************************/</a>
<a name="ln1910">int CompareStereoINChI( INChI_Stereo *s1, INChI_Stereo *s2 )</a>
<a name="ln1911">{</a>
<a name="ln1912">    if ( s1 == NULL &amp;&amp; s2 == NULL )</a>
<a name="ln1913">        return 0;</a>
<a name="ln1914">    if ( (s1 == NULL) ^ (s2 == NULL) )</a>
<a name="ln1915">        return 20;</a>
<a name="ln1916"> </a>
<a name="ln1917">    if ( s1-&gt;nNumberOfStereoCenters != s2-&gt;nNumberOfStereoCenters )</a>
<a name="ln1918">        return 21;</a>
<a name="ln1919">    if ( s1-&gt;nNumberOfStereoCenters &gt; 0 ) {</a>
<a name="ln1920">        if ( memcmp( s1-&gt;nNumber, s2-&gt;nNumber, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;nNumber[0]) ) )</a>
<a name="ln1921">            return 22;</a>
<a name="ln1922">        if ( memcmp( s1-&gt;t_parity, s2-&gt;t_parity, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;t_parity[0]) ) )</a>
<a name="ln1923">            return 23;</a>
<a name="ln1924">        if ( s1-&gt;nNumberInv &amp;&amp; s2-&gt;nNumberInv ) {</a>
<a name="ln1925">            if ( memcmp( s1-&gt;nNumberInv, s2-&gt;nNumberInv, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;nNumber[0]) ) )</a>
<a name="ln1926">                return 28;</a>
<a name="ln1927">            if ( memcmp( s1-&gt;t_parityInv, s2-&gt;t_parityInv, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;t_parity[0]) ) )</a>
<a name="ln1928">                return 29;</a>
<a name="ln1929">            if ( s1-&gt;nCompInv2Abs != s2-&gt;nCompInv2Abs ||</a>
<a name="ln1930">                 s1-&gt;bTrivialInv  != s2-&gt;bTrivialInv ) {</a>
<a name="ln1931">                return 30;</a>
<a name="ln1932">            }</a>
<a name="ln1933">        } else</a>
<a name="ln1934">        if ( s1-&gt;nNumberInv || s2-&gt;nNumberInv ) {</a>
<a name="ln1935">            return 31;</a>
<a name="ln1936">        }</a>
<a name="ln1937">    }</a>
<a name="ln1938">    if ( s1-&gt;nNumberOfStereoBonds != s2-&gt;nNumberOfStereoBonds )</a>
<a name="ln1939">        return 24;</a>
<a name="ln1940">    if ( s1-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln1941">        if ( memcmp( s1-&gt;nBondAtom1, s2-&gt;nBondAtom1, s1-&gt;nNumberOfStereoBonds*sizeof(s1-&gt;nBondAtom1[0]) ) )</a>
<a name="ln1942">            return 25;</a>
<a name="ln1943">        if ( memcmp( s1-&gt;nBondAtom2, s2-&gt;nBondAtom2, s1-&gt;nNumberOfStereoBonds*sizeof(s1-&gt;nBondAtom2[0]) ) )</a>
<a name="ln1944">            return 26;</a>
<a name="ln1945">        if ( memcmp( s1-&gt;b_parity, s2-&gt;b_parity, s1-&gt;nNumberOfStereoBonds*sizeof(s1-&gt;b_parity[0]) ) )</a>
<a name="ln1946">            return 27;</a>
<a name="ln1947">    }</a>
<a name="ln1948">    return 0;</a>
<a name="ln1949">}</a>
<a name="ln1950">/***************************************************************************************/</a>
<a name="ln1951">int CompareINChI( INChI *i1, INChI *i2, INChI_Aux *a1, INChI_Aux *a2 )</a>
<a name="ln1952">{</a>
<a name="ln1953">    int ret;</a>
<a name="ln1954">    if ( i1 == NULL &amp;&amp; i2 == NULL )</a>
<a name="ln1955">        return 0;</a>
<a name="ln1956">    if ( (i1 == NULL) ^ (i2 == NULL) )</a>
<a name="ln1957">        return 1;</a>
<a name="ln1958">    </a>
<a name="ln1959">    if ( i1-&gt;nErrorCode == i2-&gt;nErrorCode ) {</a>
<a name="ln1960">        if ( i1-&gt;nErrorCode )</a>
<a name="ln1961">            return 0;</a>
<a name="ln1962">    } else {</a>
<a name="ln1963">        return 2;</a>
<a name="ln1964">    }</a>
<a name="ln1965">    </a>
<a name="ln1966">    if ( i1-&gt;nNumberOfAtoms != i2-&gt;nNumberOfAtoms )</a>
<a name="ln1967">        return 3;</a>
<a name="ln1968">    if ( i1-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln1969">        if ( memcmp( i1-&gt;nAtom, i2-&gt;nAtom, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nAtom[0]) ) )</a>
<a name="ln1970">            return 4;</a>
<a name="ln1971">        if ( memcmp( i1-&gt;nNum_H, i2-&gt;nNum_H, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nNum_H[0]) ) )</a>
<a name="ln1972">            return 5;</a>
<a name="ln1973">        if ( i1-&gt;nNum_H_fixed &amp;&amp; i2-&gt;nNum_H_fixed &amp;&amp; </a>
<a name="ln1974">             memcmp( i1-&gt;nNum_H_fixed, i2-&gt;nNum_H_fixed, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nNum_H_fixed[0]) ) ) {</a>
<a name="ln1975">            return 6;</a>
<a name="ln1976">        }</a>
<a name="ln1977">        if ( strcmp( i1-&gt;szHillFormula, i2-&gt;szHillFormula ) )</a>
<a name="ln1978">            return 7;</a>
<a name="ln1979">    }</a>
<a name="ln1980"> </a>
<a name="ln1981">    if ( i1-&gt;lenConnTable != i2-&gt;lenConnTable )</a>
<a name="ln1982">        return 8;</a>
<a name="ln1983">    if ( i1-&gt;lenConnTable &gt; 0 &amp;&amp; memcmp( i1-&gt;nConnTable, i2-&gt;nConnTable, i1-&gt;lenConnTable*sizeof(i1-&gt;nConnTable[0]) ) )</a>
<a name="ln1984">        return 9;</a>
<a name="ln1985"> </a>
<a name="ln1986">    if ( i1-&gt;lenTautomer != i2-&gt;lenTautomer )</a>
<a name="ln1987">        return 10;</a>
<a name="ln1988">    if ( i1-&gt;lenTautomer &gt; 0 &amp;&amp; memcmp( i1-&gt;nTautomer, i2-&gt;nTautomer, i1-&gt;lenTautomer*sizeof(i1-&gt;nTautomer[0]) ) )</a>
<a name="ln1989">        return 11;</a>
<a name="ln1990"> </a>
<a name="ln1991">    if ( i1-&gt;nNumberOfIsotopicAtoms != i2-&gt;nNumberOfIsotopicAtoms )</a>
<a name="ln1992">        return 12;</a>
<a name="ln1993">    if ( i1-&gt;nNumberOfIsotopicAtoms &gt; 0 &amp;&amp; memcmp( i1-&gt;IsotopicAtom, i2-&gt;IsotopicAtom, i1-&gt;nNumberOfIsotopicAtoms*sizeof(i1-&gt;IsotopicAtom[0]) ) )</a>
<a name="ln1994">        return 13;</a>
<a name="ln1995"> </a>
<a name="ln1996">    if ( i1-&gt;nNumberOfIsotopicTGroups != i2-&gt;nNumberOfIsotopicTGroups )</a>
<a name="ln1997">        return 14;</a>
<a name="ln1998">    if ( i1-&gt;nNumberOfIsotopicTGroups &gt; 0 &amp;&amp; memcmp( i1-&gt;IsotopicTGroup, i2-&gt;IsotopicTGroup, i1-&gt;nNumberOfIsotopicTGroups*sizeof(i1-&gt;IsotopicTGroup[0]) ) )</a>
<a name="ln1999">        return 15;</a>
<a name="ln2000">    if ( a1-&gt;nNumRemovedProtons != a2-&gt;nNumRemovedProtons )</a>
<a name="ln2001">        return 16;</a>
<a name="ln2002">    if ( memcmp( a1-&gt;nNumRemovedIsotopicH, a2-&gt;nNumRemovedIsotopicH, sizeof(a1-&gt;nNumRemovedIsotopicH) ) )</a>
<a name="ln2003">        return 17;</a>
<a name="ln2004">    if ( i1-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; i2-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln2005">        if ( i1-&gt;nPossibleLocationsOfIsotopicH[0] != i2-&gt;nPossibleLocationsOfIsotopicH[0] ||</a>
<a name="ln2006">             memcmp(i1-&gt;nPossibleLocationsOfIsotopicH, i2-&gt;nPossibleLocationsOfIsotopicH,</a>
<a name="ln2007">                    sizeof(i1-&gt;nPossibleLocationsOfIsotopicH[0])*i1-&gt;nPossibleLocationsOfIsotopicH[0]) )</a>
<a name="ln2008">            return 18;</a>
<a name="ln2009">    } else</a>
<a name="ln2010">    if ( !i1-&gt;nPossibleLocationsOfIsotopicH != !i2-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln2011">        return 19;</a>
<a name="ln2012">    }</a>
<a name="ln2013">    /* ret = 20..31 */</a>
<a name="ln2014">    if ( ret = CompareStereoINChI( i1-&gt;Stereo, i2-&gt;Stereo ) )</a>
<a name="ln2015">        return ret;</a>
<a name="ln2016">    /* ret = 40..51 */</a>
<a name="ln2017">    if ( ret = CompareStereoINChI( i1-&gt;StereoIsotopic, i2-&gt;StereoIsotopic ) )</a>
<a name="ln2018">        return ret+20;</a>
<a name="ln2019"> </a>
<a name="ln2020">    return 0;</a>
<a name="ln2021">}</a>
<a name="ln2022">#endif /*  } TEST_RENUMB_ATOMS == 1 */</a>
<a name="ln2023">#if ( READ_INCHI_STRING == 1 ) /*  { */</a>
<a name="ln2024">/*************************************************************************************/</a>
<a name="ln2025">int CompareReversedStereoINChI( INChI_Stereo *s1/* InChI from reversed struct */, INChI_Stereo *s2 /* input InChI */)</a>
<a name="ln2026">{</a>
<a name="ln2027">    if ( s1 == NULL &amp;&amp; s2 == NULL )</a>
<a name="ln2028">        return 0;</a>
<a name="ln2029">    if ( (s1 == NULL) ^ (s2 == NULL) ) {</a>
<a name="ln2030">        INChI_Stereo *s = s1? s1 : s2;</a>
<a name="ln2031">        if ( s-&gt;nNumberOfStereoCenters || s-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln2032">            return 20; /* Diff: Missing Stereo */</a>
<a name="ln2033">        } else {</a>
<a name="ln2034">            return 0;</a>
<a name="ln2035">        }</a>
<a name="ln2036">    }</a>
<a name="ln2037"> </a>
<a name="ln2038">    if ( s1-&gt;nNumberOfStereoCenters != s2-&gt;nNumberOfStereoCenters )</a>
<a name="ln2039">        return 21;      /* Diff: Number of sp3 stereocenters */</a>
<a name="ln2040">    if ( s1-&gt;nNumberOfStereoCenters &gt; 0 ) {</a>
<a name="ln2041">        if ( memcmp( s1-&gt;nNumber, s2-&gt;nNumber, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;nNumber[0]) ) )</a>
<a name="ln2042">            return 22;  /* Diff: sp3 stereocenter locations */</a>
<a name="ln2043">        if ( memcmp( s1-&gt;t_parity, s2-&gt;t_parity, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;t_parity[0]) ) )</a>
<a name="ln2044">            return 23;  /* Diff: sp3 stereocenter parities */</a>
<a name="ln2045">        if ( s1-&gt;nCompInv2Abs != s2-&gt;nCompInv2Abs &amp;&amp; s1-&gt;nCompInv2Abs &amp;&amp; s2-&gt;nCompInv2Abs )</a>
<a name="ln2046">            return 24;  /* Diff: sp3 inversion */</a>
<a name="ln2047">        /*</a>
<a name="ln2048">        if ( s1-&gt;nNumberInv &amp;&amp; s2-&gt;nNumberInv ) {</a>
<a name="ln2049">            if ( memcmp( s1-&gt;nNumberInv, s2-&gt;nNumberInv, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;nNumber[0]) ) )</a>
<a name="ln2050">                return 25;</a>
<a name="ln2051">            if ( memcmp( s1-&gt;t_parityInv, s2-&gt;t_parityInv, s1-&gt;nNumberOfStereoCenters*sizeof(s1-&gt;t_parity[0]) ) )</a>
<a name="ln2052">                return 26;</a>
<a name="ln2053">            if ( s1-&gt;nCompInv2Abs != s2-&gt;nCompInv2Abs ||</a>
<a name="ln2054">                 s1-&gt;bTrivialInv  != s2-&gt;bTrivialInv ) {</a>
<a name="ln2055">                return 27;</a>
<a name="ln2056">            }</a>
<a name="ln2057">        } else</a>
<a name="ln2058">        if ( s1-&gt;nNumberInv || s2-&gt;nNumberInv ) {</a>
<a name="ln2059">            return 28;</a>
<a name="ln2060">        }</a>
<a name="ln2061">        */</a>
<a name="ln2062">    }</a>
<a name="ln2063">    if ( s1-&gt;nNumberOfStereoBonds != s2-&gt;nNumberOfStereoBonds )</a>
<a name="ln2064">        return 25;      /* Diff: Number of stereobonds */</a>
<a name="ln2065">    if ( s1-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln2066">        if ( memcmp( s1-&gt;nBondAtom1, s2-&gt;nBondAtom1, s1-&gt;nNumberOfStereoBonds*sizeof(s1-&gt;nBondAtom1[0]) ) )</a>
<a name="ln2067">            return 26; /* Diff: Stereobond 1st atom locations */</a>
<a name="ln2068">        if ( memcmp( s1-&gt;nBondAtom2, s2-&gt;nBondAtom2, s1-&gt;nNumberOfStereoBonds*sizeof(s1-&gt;nBondAtom2[0]) ) )</a>
<a name="ln2069">            return 27; /* Diff: Stereobond 2nd atom locations */</a>
<a name="ln2070">        if ( memcmp( s1-&gt;b_parity, s2-&gt;b_parity, s1-&gt;nNumberOfStereoBonds*sizeof(s1-&gt;b_parity[0]) ) )</a>
<a name="ln2071">            return 28; /* Diff: Stereobond parities */</a>
<a name="ln2072">    }</a>
<a name="ln2073">    return 0;</a>
<a name="ln2074">}</a>
<a name="ln2075">/*************************************************************************************/</a>
<a name="ln2076">int CompareReversedStereoINChI2( INChI_Stereo *s1/* InChI from reversed struct */, INChI_Stereo *s2 /* input InChI */, ICR *picr)</a>
<a name="ln2077">{</a>
<a name="ln2078">    int ret = 0;</a>
<a name="ln2079">    int j1, j2, num_eq, num_dif, num_extra_undf, num_miss_undf, num_in1_only, num_in2_only;</a>
<a name="ln2080">    int bAddSb = !(picr-&gt;num_sb_undef_in1_only + picr-&gt;num_sb_in1_only + picr-&gt;num_sb_in2_only);</a>
<a name="ln2081">    int bAddSc = !(picr-&gt;num_sc_undef_in1_only + picr-&gt;num_sc_in1_only + picr-&gt;num_sc_in2_only);</a>
<a name="ln2082">    </a>
<a name="ln2083">    int nNumSc1 = s1? s1-&gt;nNumberOfStereoCenters : 0;</a>
<a name="ln2084">    int nNumSc2 = s2? s2-&gt;nNumberOfStereoCenters : 0;</a>
<a name="ln2085">    int nNumSb1 = s1? s1-&gt;nNumberOfStereoBonds   : 0;</a>
<a name="ln2086">    int nNumSb2 = s2? s2-&gt;nNumberOfStereoBonds   : 0;</a>
<a name="ln2087">    </a>
<a name="ln2088">    if ( (nNumSc1 || nNumSc2) &amp;&amp;</a>
<a name="ln2089">         ( nNumSc1 != nNumSc2 ||</a>
<a name="ln2090">           memcmp( s1-&gt;nNumber,  s2-&gt;nNumber,  nNumSc1*sizeof(s1-&gt;nNumber[0] ) ) ||</a>
<a name="ln2091">           memcmp( s1-&gt;t_parity, s2-&gt;t_parity, nNumSc1*sizeof(s1-&gt;t_parity[0]) ) ) ) {</a>
<a name="ln2092"> </a>
<a name="ln2093">        num_eq = num_dif = num_extra_undf = num_miss_undf = num_in1_only = num_in2_only = 0;</a>
<a name="ln2094">        for ( j1 = j2 = 0; j1 &lt; nNumSc1 &amp;&amp; j2 &lt; nNumSc2; ) {</a>
<a name="ln2095">            if ( s1-&gt;nNumber[j1] ==  s2-&gt;nNumber[j2] ) {</a>
<a name="ln2096">                if ( s1-&gt;t_parity[j1] == s2-&gt;t_parity[j2] ) {</a>
<a name="ln2097">                    num_eq ++;</a>
<a name="ln2098">                } else {</a>
<a name="ln2099">                    num_dif ++;</a>
<a name="ln2100">                }</a>
<a name="ln2101">                j1 ++;</a>
<a name="ln2102">                j2 ++;</a>
<a name="ln2103">            } else</a>
<a name="ln2104">            if ( s1-&gt;nNumber[j1] &lt; s2-&gt;nNumber[j2] ) {</a>
<a name="ln2105">                num_in1_only ++;</a>
<a name="ln2106">                if ( s1-&gt;t_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2107">                    num_extra_undf ++;</a>
<a name="ln2108">                }</a>
<a name="ln2109">                if ( bAddSc ) {</a>
<a name="ln2110">                    if ( picr-&gt;num_sc_in1_only &lt; ICR_MAX_SC_IN1_ONLY )</a>
<a name="ln2111">                        picr-&gt;sc_in1_only[picr-&gt;num_sc_in1_only ++] = j1;</a>
<a name="ln2112">                    if ( s1-&gt;t_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2113">                        if ( picr-&gt;num_sc_undef_in1_only &lt; ICR_MAX_SC_UNDF )</a>
<a name="ln2114">                            picr-&gt;sc_undef_in1_only[picr-&gt;num_sc_undef_in1_only ++] = j1;</a>
<a name="ln2115">                    }</a>
<a name="ln2116">                }</a>
<a name="ln2117">                j1 ++;</a>
<a name="ln2118">            } else {</a>
<a name="ln2119">                num_in2_only ++;</a>
<a name="ln2120">                if ( s2-&gt;t_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2121">                    num_miss_undf ++;</a>
<a name="ln2122">                }</a>
<a name="ln2123">                if ( bAddSc ) {</a>
<a name="ln2124">                    if ( picr-&gt;num_sc_in2_only &lt; ICR_MAX_SC_IN2_ONLY )</a>
<a name="ln2125">                        picr-&gt;sc_in2_only[picr-&gt;num_sc_in2_only ++] = j2;</a>
<a name="ln2126">                    if ( s2-&gt;t_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2127">                        if ( picr-&gt;num_sc_undef_in2_only &lt; ICR_MAX_SC_UNDF )</a>
<a name="ln2128">                            picr-&gt;sc_undef_in2_only[picr-&gt;num_sc_undef_in2_only ++] = j1;</a>
<a name="ln2129">                    }</a>
<a name="ln2130">                }</a>
<a name="ln2131">                j2 ++;</a>
<a name="ln2132">            }</a>
<a name="ln2133">        }</a>
<a name="ln2134">        while ( j1 &lt; nNumSc1 ) {</a>
<a name="ln2135">            if ( s1-&gt;t_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2136">                num_extra_undf ++;</a>
<a name="ln2137">            }</a>
<a name="ln2138">            num_in1_only ++;</a>
<a name="ln2139">            if ( bAddSc ) {</a>
<a name="ln2140">                if ( picr-&gt;num_sc_in1_only &lt; ICR_MAX_SC_IN1_ONLY )</a>
<a name="ln2141">                    picr-&gt;sc_in1_only[picr-&gt;num_sc_in1_only ++] = j1;</a>
<a name="ln2142">                if ( s1-&gt;t_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2143">                    if ( picr-&gt;num_sc_undef_in1_only &lt; ICR_MAX_SC_UNDF )</a>
<a name="ln2144">                        picr-&gt;sc_undef_in1_only[picr-&gt;num_sc_undef_in1_only ++] = j1;</a>
<a name="ln2145">                }</a>
<a name="ln2146">            }</a>
<a name="ln2147">            j1 ++;</a>
<a name="ln2148">        }</a>
<a name="ln2149">        while ( j2 &lt; nNumSc2 ) {</a>
<a name="ln2150">            if ( s2-&gt;t_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2151">                num_miss_undf ++;</a>
<a name="ln2152">            }</a>
<a name="ln2153">            num_in2_only ++;</a>
<a name="ln2154">            if ( bAddSc ) {</a>
<a name="ln2155">                if ( picr-&gt;num_sc_in2_only &lt; ICR_MAX_SC_IN2_ONLY )</a>
<a name="ln2156">                    picr-&gt;sc_in2_only[picr-&gt;num_sc_in2_only ++] = j2;</a>
<a name="ln2157">            }</a>
<a name="ln2158">            j2 ++;</a>
<a name="ln2159">        }</a>
<a name="ln2160">        if ( num_dif ) {</a>
<a name="ln2161">            ret |= IDIF_SC_PARITY; </a>
<a name="ln2162">        }</a>
<a name="ln2163">        if ( num_in1_only ) {</a>
<a name="ln2164">            if ( num_extra_undf ) {</a>
<a name="ln2165">                ret |= IDIF_SC_EXTRA_UNDF;</a>
<a name="ln2166">            }</a>
<a name="ln2167">            if ( num_in1_only != num_extra_undf ) {</a>
<a name="ln2168">                ret |= IDIF_SC_EXTRA;</a>
<a name="ln2169">            }</a>
<a name="ln2170">        }</a>
<a name="ln2171">        if ( num_in2_only ) {</a>
<a name="ln2172">            if ( num_miss_undf ) {</a>
<a name="ln2173">                ret |= IDIF_SC_MISS_UNDF;</a>
<a name="ln2174">            }</a>
<a name="ln2175">            if ( num_in2_only != num_miss_undf ) {</a>
<a name="ln2176">                ret |= IDIF_SC_MISS;</a>
<a name="ln2177">            }</a>
<a name="ln2178">        }</a>
<a name="ln2179">    }</a>
<a name="ln2180">    if ( s1 &amp;&amp; s2 &amp;&amp; s1-&gt;nCompInv2Abs != s2-&gt;nCompInv2Abs &amp;&amp; s1-&gt;nCompInv2Abs &amp;&amp; s2-&gt;nCompInv2Abs ) {</a>
<a name="ln2181">        ret |= IDIF_SC_INV;</a>
<a name="ln2182">    }</a>
<a name="ln2183"> </a>
<a name="ln2184">    if ( (nNumSb1 || nNumSb2 ) &amp;&amp;</a>
<a name="ln2185">         (nNumSb1 != nNumSb2 ||</a>
<a name="ln2186">          memcmp( s1-&gt;nBondAtom1, s2-&gt;nBondAtom1, nNumSb1*sizeof(s1-&gt;nBondAtom1[0]) ) ||</a>
<a name="ln2187">          memcmp( s1-&gt;nBondAtom2, s2-&gt;nBondAtom2, nNumSb1*sizeof(s1-&gt;nBondAtom2[0]) ) ||</a>
<a name="ln2188">          memcmp( s1-&gt;b_parity,   s2-&gt;b_parity,   nNumSb1*sizeof(s1-&gt;b_parity[0]) ) ) ) {</a>
<a name="ln2189"> </a>
<a name="ln2190">        num_eq = num_dif = num_extra_undf = num_miss_undf = num_in1_only = num_in2_only = 0;</a>
<a name="ln2191">        for ( j1 = j2 = 0; j1 &lt; nNumSb1 &amp;&amp; j2 &lt; nNumSb2; ) {</a>
<a name="ln2192">            if ( s1-&gt;nBondAtom1[j1] ==  s2-&gt;nBondAtom1[j2] &amp;&amp;</a>
<a name="ln2193">                 s1-&gt;nBondAtom2[j1] ==  s2-&gt;nBondAtom2[j2] ) {</a>
<a name="ln2194">                if ( s1-&gt;b_parity[j1] == s2-&gt;b_parity[j2] ) {</a>
<a name="ln2195">                    num_eq ++;</a>
<a name="ln2196">                } else {</a>
<a name="ln2197">                    num_dif ++;</a>
<a name="ln2198">                }</a>
<a name="ln2199">                j1 ++;</a>
<a name="ln2200">                j2 ++;</a>
<a name="ln2201">            } else</a>
<a name="ln2202">            if ( s1-&gt;nBondAtom1[j1] &lt;  s2-&gt;nBondAtom1[j2] ||</a>
<a name="ln2203">                 (s1-&gt;nBondAtom1[j1] == s2-&gt;nBondAtom1[j2] &amp;&amp; s1-&gt;nBondAtom2[j1] &lt;  s2-&gt;nBondAtom2[j2])) {</a>
<a name="ln2204">                num_in1_only ++;</a>
<a name="ln2205">                if ( s1-&gt;b_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2206">                    num_extra_undf ++;</a>
<a name="ln2207">                }</a>
<a name="ln2208">                if ( bAddSb ) {</a>
<a name="ln2209">                    if ( picr-&gt;num_sb_in1_only &lt; ICR_MAX_SB_IN1_ONLY )</a>
<a name="ln2210">                        picr-&gt;sb_in1_only[picr-&gt;num_sb_in1_only ++] = j1;</a>
<a name="ln2211">                    if ( s1-&gt;b_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2212">                        if ( picr-&gt;num_sb_undef_in1_only &lt; ICR_MAX_SB_UNDF )</a>
<a name="ln2213">                            picr-&gt;sb_undef_in1_only[picr-&gt;num_sb_undef_in1_only ++] = j1;</a>
<a name="ln2214">                    }</a>
<a name="ln2215">                }</a>
<a name="ln2216">                j1 ++;</a>
<a name="ln2217">            } else {</a>
<a name="ln2218">                num_in2_only ++;</a>
<a name="ln2219">                if ( s2-&gt;b_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2220">                    num_miss_undf ++;</a>
<a name="ln2221">                }</a>
<a name="ln2222">                if ( bAddSb ) {</a>
<a name="ln2223">                    if ( picr-&gt;num_sb_in2_only &lt; ICR_MAX_SB_IN2_ONLY )</a>
<a name="ln2224">                        picr-&gt;sb_in2_only[picr-&gt;num_sb_in2_only ++] = j2;</a>
<a name="ln2225">                    if ( s2-&gt;b_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2226">                        if ( picr-&gt;num_sb_undef_in2_only &lt; ICR_MAX_SB_UNDF )</a>
<a name="ln2227">                            picr-&gt;sb_undef_in2_only[picr-&gt;num_sb_undef_in2_only ++] = j1;</a>
<a name="ln2228">                    }</a>
<a name="ln2229">                }</a>
<a name="ln2230">                j2 ++;</a>
<a name="ln2231">            }</a>
<a name="ln2232">        }</a>
<a name="ln2233">        while ( j1 &lt; nNumSb1 ) {</a>
<a name="ln2234">            num_in1_only ++;</a>
<a name="ln2235">            if ( s1-&gt;b_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2236">                num_extra_undf ++;</a>
<a name="ln2237">            }</a>
<a name="ln2238">            if ( bAddSb ) {</a>
<a name="ln2239">                if ( picr-&gt;num_sb_in1_only &lt; ICR_MAX_SB_IN1_ONLY )</a>
<a name="ln2240">                    picr-&gt;sb_in1_only[picr-&gt;num_sb_in1_only ++] = j1;</a>
<a name="ln2241">                if ( s1-&gt;b_parity[j1] == AB_PARITY_UNDF ) {</a>
<a name="ln2242">                    if ( picr-&gt;num_sb_undef_in1_only &lt; ICR_MAX_SB_UNDF )</a>
<a name="ln2243">                        picr-&gt;sb_undef_in1_only[picr-&gt;num_sb_undef_in1_only ++] = j1;</a>
<a name="ln2244">                }</a>
<a name="ln2245">            }</a>
<a name="ln2246">            j1 ++;</a>
<a name="ln2247">        }</a>
<a name="ln2248">        while ( j2 &lt; nNumSb2 ) {</a>
<a name="ln2249">            num_in2_only ++;</a>
<a name="ln2250">            if ( s2-&gt;b_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2251">                num_miss_undf ++;</a>
<a name="ln2252">            }</a>
<a name="ln2253">            if ( bAddSb ) {</a>
<a name="ln2254">                if ( picr-&gt;num_sb_in2_only &lt; ICR_MAX_SB_IN2_ONLY )</a>
<a name="ln2255">                    picr-&gt;sb_in2_only[picr-&gt;num_sb_in2_only ++] = j2;</a>
<a name="ln2256">                if ( s2-&gt;b_parity[j2] == AB_PARITY_UNDF ) {</a>
<a name="ln2257">                    if ( picr-&gt;num_sb_undef_in2_only &lt; ICR_MAX_SB_UNDF )</a>
<a name="ln2258">                        picr-&gt;sb_undef_in2_only[picr-&gt;num_sb_undef_in2_only ++] = j1;</a>
<a name="ln2259">                }</a>
<a name="ln2260">            }</a>
<a name="ln2261">            j2 ++;</a>
<a name="ln2262">        }</a>
<a name="ln2263">        if ( num_dif ) {</a>
<a name="ln2264">            ret |= IDIF_SB_PARITY; </a>
<a name="ln2265">        }</a>
<a name="ln2266">        if ( num_in1_only ) {</a>
<a name="ln2267">            if ( num_extra_undf ) {</a>
<a name="ln2268">                ret |= IDIF_SB_EXTRA_UNDF;</a>
<a name="ln2269">            }</a>
<a name="ln2270">            if ( num_in1_only != num_extra_undf ) {</a>
<a name="ln2271">                ret |= IDIF_SB_EXTRA;</a>
<a name="ln2272">            }</a>
<a name="ln2273">        }</a>
<a name="ln2274">        if ( num_in2_only ) {</a>
<a name="ln2275">            if ( num_miss_undf ) {</a>
<a name="ln2276">                ret |= IDIF_SB_MISS_UNDF;</a>
<a name="ln2277">            }</a>
<a name="ln2278">            if ( num_in2_only != num_miss_undf ) {</a>
<a name="ln2279">                ret |= IDIF_SB_MISS;</a>
<a name="ln2280">            }</a>
<a name="ln2281">        }</a>
<a name="ln2282">    }</a>
<a name="ln2283"> </a>
<a name="ln2284">    return ret;</a>
<a name="ln2285">}</a>
<a name="ln2286">/*************************************************************************************/</a>
<a name="ln2287">int CompareReversedINChI( INChI *i1 /* InChI from reversed struct */, INChI *i2 /* input InChI */, INChI_Aux *a1, INChI_Aux *a2 )</a>
<a name="ln2288">{</a>
<a name="ln2289">    int ret;</a>
<a name="ln2290">    if ( i1 == NULL &amp;&amp; i2 == NULL )</a>
<a name="ln2291">        return 0;</a>
<a name="ln2292">    if ( (i1 == NULL) ^ (i2 == NULL) )</a>
<a name="ln2293">        return 1; /* Diff: Missing InChI */</a>
<a name="ln2294">    </a>
<a name="ln2295">    if ( i1-&gt;nErrorCode == i2-&gt;nErrorCode ) {</a>
<a name="ln2296">        if ( i1-&gt;nErrorCode )</a>
<a name="ln2297">            return 0;</a>
<a name="ln2298">    } else {</a>
<a name="ln2299">        return 2; /* Diff: Error codes */</a>
<a name="ln2300">    }</a>
<a name="ln2301">    if ( i1-&gt;bDeleted != i2-&gt;bDeleted ) {</a>
<a name="ln2302">        return 1; /* Diff: Missing InChI */</a>
<a name="ln2303">    }</a>
<a name="ln2304">    if ( i1-&gt;nNumberOfAtoms != i2-&gt;nNumberOfAtoms )</a>
<a name="ln2305">        return 3;  /* Diff: Num. atoms */</a>
<a name="ln2306">    if ( i1-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln2307">        if ( memcmp( i1-&gt;nAtom, i2-&gt;nAtom, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nAtom[0]) ) )</a>
<a name="ln2308">            return 4; /* Diff: Elements */</a>
<a name="ln2309">        if ( strcmp( i1-&gt;szHillFormula, i2-&gt;szHillFormula ) )</a>
<a name="ln2310">            return 7; /* Diff: Hill Formulas */</a>
<a name="ln2311">        if ( memcmp( i1-&gt;nNum_H, i2-&gt;nNum_H, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nNum_H[0]) ) ) {</a>
<a name="ln2312">            if ( i1-&gt;lenConnTable &gt; 1 || i2-&gt;lenConnTable &gt; 1 ) {</a>
<a name="ln2313">                return 5; /* Diff: H Locations (mobile H present) */</a>
<a name="ln2314">            } else {</a>
<a name="ln2315">                return 6; /* Diff: H Locations (no mobile H) */</a>
<a name="ln2316">            }</a>
<a name="ln2317">        }</a>
<a name="ln2318">        /* fixed H */</a>
<a name="ln2319">        if ( i1-&gt;nNum_H_fixed || i2-&gt;nNum_H_fixed ) {</a>
<a name="ln2320">            int bHasFixedH1 = 0, bHasFixedH2 = 0, i, j1, j2;</a>
<a name="ln2321">            if ( i1-&gt;nNum_H_fixed ) {</a>
<a name="ln2322">                for ( i = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2323">                    if ( i1-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2324">                        bHasFixedH1 ++;</a>
<a name="ln2325">                    }</a>
<a name="ln2326">                }</a>
<a name="ln2327">            }</a>
<a name="ln2328">            if ( i2-&gt;nNum_H_fixed ) {</a>
<a name="ln2329">                for ( i = 0; i &lt; i2-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2330">                    if ( i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2331">                        bHasFixedH2 ++;</a>
<a name="ln2332">                    }</a>
<a name="ln2333">                }</a>
<a name="ln2334">            }</a>
<a name="ln2335">            /* count the differences */</a>
<a name="ln2336">            j1 = j2 = 0;</a>
<a name="ln2337">            if ( bHasFixedH1 &amp;&amp; !bHasFixedH2 ) {</a>
<a name="ln2338">                for ( i = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2339">                    if ( i1-&gt;nNum_H_fixed[i] &gt; 0 ) {</a>
<a name="ln2340">                        j1 ++;</a>
<a name="ln2341">                    } else</a>
<a name="ln2342">                    if ( i1-&gt;nNum_H_fixed[i] &lt; 0 ) {</a>
<a name="ln2343">                        j2 ++;</a>
<a name="ln2344">                    }</a>
<a name="ln2345">                }</a>
<a name="ln2346"> </a>
<a name="ln2347">                return 18; /* Diff: Extra Fixed-H */</a>
<a name="ln2348">            } else</a>
<a name="ln2349">            if ( !bHasFixedH1 &amp;&amp; bHasFixedH2 ) {</a>
<a name="ln2350">                for ( i = j1 = j2 = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2351">                    if ( 0 &gt; i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2352">                        j1 ++;</a>
<a name="ln2353">                    } else</a>
<a name="ln2354">                    if ( 0 &lt; i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2355">                        j2 ++;</a>
<a name="ln2356">                    }</a>
<a name="ln2357">                }</a>
<a name="ln2358">                return 19; /* Diff: Missed Fixed-H */</a>
<a name="ln2359">            } else</a>
<a name="ln2360">            if ( bHasFixedH1 &amp;&amp; bHasFixedH2 &amp;&amp;</a>
<a name="ln2361">                 memcmp( i1-&gt;nNum_H_fixed, i2-&gt;nNum_H_fixed, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nNum_H_fixed[0]) ) ) {</a>
<a name="ln2362">                for ( i = j1 = j2 = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2363">                    if ( i1-&gt;nNum_H_fixed[i] &gt; i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2364">                        j1 ++;</a>
<a name="ln2365">                    } else</a>
<a name="ln2366">                    if ( i1-&gt;nNum_H_fixed[i] &lt; i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2367">                        j2 ++;</a>
<a name="ln2368">                    }</a>
<a name="ln2369">                }</a>
<a name="ln2370">            }</a>
<a name="ln2371">            ret = (j1 &amp;&amp; j2)? 20 : j1? 18 : j2? 19 : 0;</a>
<a name="ln2372">            if ( ret ) {</a>
<a name="ln2373">                return ret; /* 20 =&gt; Diff: NotEql Fixed-H */</a>
<a name="ln2374">                            /* 19 =&gt; Diff: Missed Fixed-H (i1 has less) */</a>
<a name="ln2375">                            /* 18 =&gt; Diff: Extra Fixed-H  (i1 has more) */</a>
<a name="ln2376">            }</a>
<a name="ln2377">        }</a>
<a name="ln2378">    }</a>
<a name="ln2379"> </a>
<a name="ln2380">    if ( i1-&gt;lenConnTable != i2-&gt;lenConnTable )</a>
<a name="ln2381">        return 8; /* Diff: Connections length */</a>
<a name="ln2382">    if ( i1-&gt;lenConnTable &gt; 0 &amp;&amp; memcmp( i1-&gt;nConnTable, i2-&gt;nConnTable, i1-&gt;lenConnTable*sizeof(i1-&gt;nConnTable[0]) ) )</a>
<a name="ln2383">        return 9; /* Diff: Connections */</a>
<a name="ln2384">    /* output special cases: different number of t-groups, different sizes of t-groups, different endpoints */</a>
<a name="ln2385">    if ( i1-&gt;lenTautomer != i2-&gt;lenTautomer &amp;&amp; (i1-&gt;lenTautomer &gt; 1 || i2-&gt;lenTautomer &gt; 1) )</a>
<a name="ln2386">        return 10; /* Diff: Mobile groups length */ /* in isotopic or deprotonated cases i1-&gt;lenTautomer == 1 &amp;&amp; i1-&gt;nTautomer[0] = 0 */</a>
<a name="ln2387">    if ( (i1-&gt;lenTautomer &gt; 1 &amp;&amp; i2-&gt;lenTautomer &gt; 1) &amp;&amp;</a>
<a name="ln2388">         memcmp( i1-&gt;nTautomer, i2-&gt;nTautomer, i1-&gt;lenTautomer*sizeof(i1-&gt;nTautomer[0]) ) )</a>
<a name="ln2389">        return 11; /* Diff: Mobile groups */</a>
<a name="ln2390"> </a>
<a name="ln2391">    if ( i1-&gt;nNumberOfIsotopicAtoms != i2-&gt;nNumberOfIsotopicAtoms )</a>
<a name="ln2392">        return 12; /* Diff: Isotopic atoms number */</a>
<a name="ln2393">    if ( i1-&gt;nNumberOfIsotopicAtoms &gt; 0 &amp;&amp; memcmp( i1-&gt;IsotopicAtom, i2-&gt;IsotopicAtom, i1-&gt;nNumberOfIsotopicAtoms*sizeof(i1-&gt;IsotopicAtom[0]) ) )</a>
<a name="ln2394">        return 13; /* Diff: Isotopic atoms */</a>
<a name="ln2395">    if ( i1-&gt;nTotalCharge != i2-&gt;nTotalCharge )</a>
<a name="ln2396">        return 14; /* Diff: Charge */</a>
<a name="ln2397">/*</a>
<a name="ln2398">    if ( i1-&gt;nNumberOfIsotopicTGroups != i2-&gt;nNumberOfIsotopicTGroups )</a>
<a name="ln2399">        return 14;</a>
<a name="ln2400">    if ( i1-&gt;nNumberOfIsotopicTGroups &gt; 0 &amp;&amp; memcmp( i1-&gt;IsotopicTGroup, i2-&gt;IsotopicTGroup, i1-&gt;nNumberOfIsotopicTGroups*sizeof(i1-&gt;IsotopicTGroup[0]) ) )</a>
<a name="ln2401">        return 15;</a>
<a name="ln2402">*/</a>
<a name="ln2403">    if ( a1 &amp;&amp; a2 ) {</a>
<a name="ln2404">        if ( a1-&gt;nNumRemovedProtons != a2-&gt;nNumRemovedProtons )</a>
<a name="ln2405">            return 16; /* Diff: Number of removed protons */</a>
<a name="ln2406">        if ( memcmp( a1-&gt;nNumRemovedIsotopicH, a2-&gt;nNumRemovedIsotopicH, sizeof(a1-&gt;nNumRemovedIsotopicH) ) )</a>
<a name="ln2407">            return 17; /* Diff: Removed isotopic H */</a>
<a name="ln2408">    }</a>
<a name="ln2409">/*</a>
<a name="ln2410">    if ( i1-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; i2-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln2411">        if ( i1-&gt;nPossibleLocationsOfIsotopicH[0] != i2-&gt;nPossibleLocationsOfIsotopicH[0] ||</a>
<a name="ln2412">             memcmp(i1-&gt;nPossibleLocationsOfIsotopicH, i2-&gt;nPossibleLocationsOfIsotopicH,</a>
<a name="ln2413">                    sizeof(i1-&gt;nPossibleLocationsOfIsotopicH[0])*i1-&gt;nPossibleLocationsOfIsotopicH[0]) )</a>
<a name="ln2414">            return 18;</a>
<a name="ln2415">    } else</a>
<a name="ln2416">    if ( !i1-&gt;nPossibleLocationsOfIsotopicH != !i2-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln2417">        return 19;</a>
<a name="ln2418">    }</a>
<a name="ln2419">*/</a>
<a name="ln2420">    /* ret = 20..31 =&gt; 40..51 */</a>
<a name="ln2421">    if ( (ret = CompareReversedStereoINChI( i1-&gt;Stereo, i2-&gt;Stereo )) )</a>
<a name="ln2422">        return ret+20;</a>
<a name="ln2423">    /* ret = 40..51 =&gt; 60..71 */</a>
<a name="ln2424"> </a>
<a name="ln2425">    if ( !i2-&gt;StereoIsotopic &amp;&amp; i2-&gt;Stereo &amp;&amp; i1-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2426">         0 &lt; (i1-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds + i1-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) &amp;&amp;</a>
<a name="ln2427">         0 == CompareReversedStereoINChI( i1-&gt;StereoIsotopic, i2-&gt;Stereo ) ) {</a>
<a name="ln2428">        /* InChI from reversed structure does not contain fully duplicated isotopic stereo */</a>
<a name="ln2429">        ;</a>
<a name="ln2430">    } else</a>
<a name="ln2431"> </a>
<a name="ln2432">    if ( (ret = CompareReversedStereoINChI( i1-&gt;StereoIsotopic, i2-&gt;StereoIsotopic )) ) {</a>
<a name="ln2433">        return ret+40;</a>
<a name="ln2434">    }</a>
<a name="ln2435"> </a>
<a name="ln2436">    return 0;</a>
<a name="ln2437">}</a>
<a name="ln2438"> </a>
<a name="ln2439">/*******************************************************************************/</a>
<a name="ln2440">int CompareIcr( ICR *picr1, ICR *picr2, INCHI_MODE *pin1, INCHI_MODE *pin2, INCHI_MODE mask )</a>
<a name="ln2441">{</a>
<a name="ln2442">    int nNumExtraBits1 = 0, nNumExtraBits2 = 0, bit1, bit2;</a>
<a name="ln2443">    INCHI_MODE Flg1=picr1-&gt;flags, Flg2 = picr2-&gt;flags, cur_bit = 1, in1, in2;</a>
<a name="ln2444">    int i, ret;</a>
<a name="ln2445"> </a>
<a name="ln2446">    /* compare flags */</a>
<a name="ln2447">    in1 = in2 = 0;</a>
<a name="ln2448">    for ( i = 0; Flg1 || Flg2; i ++, Flg1 &gt;&gt;= 1, Flg2 &gt;&gt;= 1, cur_bit &lt;&lt;= 1 ) {</a>
<a name="ln2449">        if ( !(mask &amp; cur_bit) ) {</a>
<a name="ln2450">            continue;</a>
<a name="ln2451">        }</a>
<a name="ln2452">        bit1 = Flg1 &amp; 1;</a>
<a name="ln2453">        bit2 = Flg2 &amp; 1;</a>
<a name="ln2454">        if ( bit1 &amp;&amp; !bit2 ) {</a>
<a name="ln2455">            in1 |= 1 &lt;&lt; i;</a>
<a name="ln2456">            nNumExtraBits1 ++;</a>
<a name="ln2457">        } else</a>
<a name="ln2458">        if ( !bit1 &amp;&amp; bit2 ) {</a>
<a name="ln2459">            in2 |= 1 &lt;&lt; i;</a>
<a name="ln2460">            nNumExtraBits2 ++;</a>
<a name="ln2461">        }</a>
<a name="ln2462">    }</a>
<a name="ln2463">    if ( nNumExtraBits1 &amp;&amp; !nNumExtraBits2 ) {</a>
<a name="ln2464">        ret = 1;</a>
<a name="ln2465">    } else</a>
<a name="ln2466">    if ( !nNumExtraBits1 &amp;&amp; nNumExtraBits2 ) {</a>
<a name="ln2467">        ret = -1;</a>
<a name="ln2468">    } else</a>
<a name="ln2469">    if ( !in1 &amp;&amp; !in2 ) {</a>
<a name="ln2470">        ret = 0;</a>
<a name="ln2471">    } else {</a>
<a name="ln2472">        ret = 2; /* compare produced undefined results */</a>
<a name="ln2473">    }</a>
<a name="ln2474">    if ( pin1 ) *pin1 = in1;</a>
<a name="ln2475">    if ( pin2 ) *pin2 = in2;</a>
<a name="ln2476">    /* more detailed compare not implemented */</a>
<a name="ln2477">    return ret;</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480">/*********************************************************************************************************/</a>
<a name="ln2481">INCHI_MODE CompareReversedINChI2( INChI *i1 /* InChI from reversed struct */, INChI *i2 /* input InChI */,</a>
<a name="ln2482">                                  INChI_Aux *a1, INChI_Aux *a2, ICR *picr, int *err )</a>
<a name="ln2483">{</a>
<a name="ln2484">    INCHI_MODE ret = 0;</a>
<a name="ln2485">    INChI_Stereo *Stereo1=NULL, *Stereo2=NULL;</a>
<a name="ln2486">    int  n1, n2, m, j, j1, j2, ret2, num_H1, num_H2;</a>
<a name="ln2487">    </a>
<a name="ln2488">    *err = 0;</a>
<a name="ln2489"> </a>
<a name="ln2490">    memset( picr, 0, sizeof(*picr) );</a>
<a name="ln2491"> </a>
<a name="ln2492">    if ( i1 == NULL &amp;&amp; i2 == NULL )</a>
<a name="ln2493">        return 0;</a>
<a name="ln2494">    if ( (i1 == NULL) ^ (i2 == NULL) ) {</a>
<a name="ln2495">        ret |= IDIF_PROBLEM; /* one InChI exists while another doesn't */</a>
<a name="ln2496">        goto exit_function;</a>
<a name="ln2497">    }</a>
<a name="ln2498">    </a>
<a name="ln2499">    if ( i1-&gt;nErrorCode == i2-&gt;nErrorCode ) {</a>
<a name="ln2500">        if ( i1-&gt;nErrorCode ) {</a>
<a name="ln2501">            ret |= IDIF_PROBLEM; /* both InChI have same error codes */</a>
<a name="ln2502">            goto exit_function;</a>
<a name="ln2503">        }</a>
<a name="ln2504">    } else {</a>
<a name="ln2505">        ret |= IDIF_PROBLEM; /* at least one InChI has an error code */</a>
<a name="ln2506">        goto exit_function;</a>
<a name="ln2507">    }</a>
<a name="ln2508">    </a>
<a name="ln2509">    if ( i1-&gt;nNumberOfAtoms != i2-&gt;nNumberOfAtoms ) {</a>
<a name="ln2510">        ret |= IDIF_NUM_AT;</a>
<a name="ln2511">        goto exit_function;</a>
<a name="ln2512">    }</a>
<a name="ln2513">    if ( i1-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln2514">        if ( memcmp( i1-&gt;nAtom, i2-&gt;nAtom, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nAtom[0]) ) ) {</a>
<a name="ln2515">            ret |= IDIF_ATOMS;</a>
<a name="ln2516">            goto exit_function;</a>
<a name="ln2517">        }</a>
<a name="ln2518">        /* IDIF_NON_TAUT_H,  IDIF_MORE_FH, IDIF_LESS_FH */</a>
<a name="ln2519">        if ( memcmp( i1-&gt;nNum_H, i2-&gt;nNum_H, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nNum_H[0]) ) ) {</a>
<a name="ln2520">            ret |= IDIF_POSITION_H;</a>
<a name="ln2521">            for ( j1 = 0; j1 &lt; i1-&gt;nNumberOfAtoms; j1 ++ ) {</a>
<a name="ln2522">                if ( i1-&gt;nNum_H[j1] != i2-&gt;nNum_H[j1] &amp;&amp; picr-&gt;num_diff_pos_H &lt; ICR_MAX_DIFF_FIXED_H ) {</a>
<a name="ln2523">                    picr-&gt;diff_pos_H_at[picr-&gt;num_diff_pos_H] = j1;</a>
<a name="ln2524">                    picr-&gt;diff_pos_H_nH[picr-&gt;num_diff_pos_H] = i1-&gt;nNum_H[j1] - i2-&gt;nNum_H[j1];</a>
<a name="ln2525">                    picr-&gt;num_diff_pos_H ++;</a>
<a name="ln2526">                }</a>
<a name="ln2527">            }</a>
<a name="ln2528">        }</a>
<a name="ln2529">        /* fixed H */</a>
<a name="ln2530">        if ( i1-&gt;nNum_H_fixed || i2-&gt;nNum_H_fixed ) {</a>
<a name="ln2531">            int bHasFixedH1 = 0, bHasFixedH2 = 0, i;</a>
<a name="ln2532">            if ( i1-&gt;nNum_H_fixed ) {</a>
<a name="ln2533">                for ( i = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2534">                    if ( i1-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2535">                        bHasFixedH1 ++;</a>
<a name="ln2536">                    }</a>
<a name="ln2537">                }</a>
<a name="ln2538">            }</a>
<a name="ln2539">            if ( i2-&gt;nNum_H_fixed ) {</a>
<a name="ln2540">                for ( i = 0; i &lt; i2-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2541">                    if ( i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2542">                        bHasFixedH2 ++;</a>
<a name="ln2543">                    }</a>
<a name="ln2544">                }</a>
<a name="ln2545">            }</a>
<a name="ln2546">            if ( bHasFixedH1 &amp;&amp; !bHasFixedH2 ) {</a>
<a name="ln2547">                for ( i = j = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2548">                    if ( i1-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2549">                        if ( j &lt; ICR_MAX_DIFF_FIXED_H ) {</a>
<a name="ln2550">                            picr-&gt;fixed_H_at1_more[j] = i;</a>
<a name="ln2551">                            picr-&gt;fixed_H_nH1_more[j] = i1-&gt;nNum_H_fixed[i];</a>
<a name="ln2552">                            j ++;</a>
<a name="ln2553">                        }</a>
<a name="ln2554">                    }</a>
<a name="ln2555">                }</a>
<a name="ln2556">                picr-&gt;num_fixed_H1_more = j;</a>
<a name="ln2557">                ret |= IDIF_MORE_FH; /* Extra Fixed-H */</a>
<a name="ln2558">            } else</a>
<a name="ln2559">            if ( !bHasFixedH1 &amp;&amp; bHasFixedH2 ) {</a>
<a name="ln2560">                for ( i = j = 0; i &lt; i2-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2561">                    if ( i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2562">                        if ( j &lt; ICR_MAX_DIFF_FIXED_H ) {</a>
<a name="ln2563">                            picr-&gt;fixed_H_at2_more[j] = i;</a>
<a name="ln2564">                            picr-&gt;fixed_H_nH2_more[j] = i2-&gt;nNum_H_fixed[i];</a>
<a name="ln2565">                            j ++;</a>
<a name="ln2566">                        }</a>
<a name="ln2567">                    }</a>
<a name="ln2568">                }</a>
<a name="ln2569">                picr-&gt;num_fixed_H2_more = j;</a>
<a name="ln2570">                ret |= IDIF_LESS_FH; /* Missed Fixed-H */</a>
<a name="ln2571">            } else</a>
<a name="ln2572">            if ( bHasFixedH1 &amp;&amp; bHasFixedH2 &amp;&amp;</a>
<a name="ln2573">                 memcmp( i1-&gt;nNum_H_fixed, i2-&gt;nNum_H_fixed, i1-&gt;nNumberOfAtoms*sizeof(i1-&gt;nNum_H_fixed[0]) ) ) {</a>
<a name="ln2574">                for ( i = j1 = j2 = 0; i &lt; i1-&gt;nNumberOfAtoms; i ++ ) {</a>
<a name="ln2575">                    if ( i1-&gt;nNum_H_fixed[i] &gt; i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2576">                        if ( j1 &lt; ICR_MAX_DIFF_FIXED_H ) {</a>
<a name="ln2577">                            picr-&gt;fixed_H_at1_more[j1] = i;</a>
<a name="ln2578">                            picr-&gt;fixed_H_nH1_more[j1] = i1-&gt;nNum_H_fixed[i] - i2-&gt;nNum_H_fixed[i];</a>
<a name="ln2579">                            j1 ++;</a>
<a name="ln2580">                        }</a>
<a name="ln2581">                    } else</a>
<a name="ln2582">                    if ( i1-&gt;nNum_H_fixed[i] &lt; i2-&gt;nNum_H_fixed[i] ) {</a>
<a name="ln2583">                        if ( j2 &lt; ICR_MAX_DIFF_FIXED_H ) {</a>
<a name="ln2584">                            picr-&gt;fixed_H_at2_more[j2] = i;</a>
<a name="ln2585">                            picr-&gt;fixed_H_nH2_more[j2] = i2-&gt;nNum_H_fixed[i] - i1-&gt;nNum_H_fixed[i];</a>
<a name="ln2586">                            j2 ++;</a>
<a name="ln2587">                        }</a>
<a name="ln2588">                    }</a>
<a name="ln2589">                }</a>
<a name="ln2590">                ret |= (j1? IDIF_MORE_FH:0) | (j2? IDIF_LESS_FH:0);</a>
<a name="ln2591">                picr-&gt;num_fixed_H1_more = j1;</a>
<a name="ln2592">                picr-&gt;num_fixed_H2_more = j2;</a>
<a name="ln2593">            }</a>
<a name="ln2594">        }</a>
<a name="ln2595">    }</a>
<a name="ln2596">    /* compare formulas and H */</a>
<a name="ln2597">    num_H1 = 0;</a>
<a name="ln2598">    num_H2 = 0;</a>
<a name="ln2599">    ret2 = CompareHillFormulasNoH( i1-&gt;szHillFormula, i2-&gt;szHillFormula, &amp;num_H1, &amp;num_H2 );</a>
<a name="ln2600">    picr-&gt;tot_num_H1 = num_H1;</a>
<a name="ln2601">    picr-&gt;tot_num_H2 = num_H2;</a>
<a name="ln2602">    if ( ret2 ) {</a>
<a name="ln2603">        ret |= IDIF_NUM_EL;</a>
<a name="ln2604">        goto exit_function;</a>
<a name="ln2605">    }</a>
<a name="ln2606">    if ( num_H1 &gt; num_H2 ) {</a>
<a name="ln2607">        ret |= IDIF_MORE_H;</a>
<a name="ln2608">    }</a>
<a name="ln2609">    if ( num_H1 &lt; num_H2 ) {</a>
<a name="ln2610">        ret |= IDIF_LESS_H;</a>
<a name="ln2611">    }</a>
<a name="ln2612"> </a>
<a name="ln2613">    if ( i1-&gt;lenConnTable != i2-&gt;lenConnTable ) {</a>
<a name="ln2614">        ret |= IDIF_CON_LEN;</a>
<a name="ln2615">        goto exit_function;</a>
<a name="ln2616">    } else</a>
<a name="ln2617">    if ( i1-&gt;lenConnTable &gt; 0 &amp;&amp; memcmp( i1-&gt;nConnTable, i2-&gt;nConnTable, i1-&gt;lenConnTable*sizeof(i1-&gt;nConnTable[0]) ) ) {</a>
<a name="ln2618">        ret |= IDIF_CON_TBL;</a>
<a name="ln2619">        goto exit_function;</a>
<a name="ln2620">    }</a>
<a name="ln2621">    /* output special cases: different number of t-groups, different sizes of t-groups, different endpoints */</a>
<a name="ln2622">    /* in isotopic or deprotonated cases i1-&gt;lenTautomer == 1 &amp;&amp; i1-&gt;nTautomer[0] = 0 */</a>
<a name="ln2623">/*</a>
<a name="ln2624">    if ( i1-&gt;lenTautomer != i2-&gt;lenTautomer &amp;&amp; (i1-&gt;lenTautomer &gt; 1 || i2-&gt;lenTautomer &gt; 1) ) {</a>
<a name="ln2625">        ret |=  IDIF_TAUT_LEN; </a>
<a name="ln2626">    }</a>
<a name="ln2627">*/</a>
<a name="ln2628">    /* compare number of t-groups */</a>
<a name="ln2629">    n1 = i1-&gt;lenTautomer? i1-&gt;nTautomer[0] : 0;</a>
<a name="ln2630">    n2 = i2-&gt;lenTautomer? i2-&gt;nTautomer[0] : 0;</a>
<a name="ln2631">    if ( !n1 &amp;&amp; n2 ) {</a>
<a name="ln2632">        ret |= IDIF_NO_TAUT;</a>
<a name="ln2633">    } else</a>
<a name="ln2634">    if ( n1 &amp;&amp; !n2 ) {</a>
<a name="ln2635">        ret |= IDIF_WRONG_TAUT;</a>
<a name="ln2636">    } else</a>
<a name="ln2637">    if ( n1 == 1 &amp;&amp; n2 &gt; 1 ) {</a>
<a name="ln2638">        ret |= IDIF_SINGLE_TG;</a>
<a name="ln2639">    } else</a>
<a name="ln2640">    if ( n1 &gt; 1 &amp;&amp; n2 == 1 ) {</a>
<a name="ln2641">        ret |= IDIF_MULTIPLE_TG;</a>
<a name="ln2642">    } else</a>
<a name="ln2643">    if ( n1 != n2 ) {</a>
<a name="ln2644">        ret |= IDIF_NUM_TG;</a>
<a name="ln2645">    }</a>
<a name="ln2646">    if ( n1 || n2 ) {</a>
<a name="ln2647">        /* number of endpoints */</a>
<a name="ln2648">        int num1 = 0, num2 = 0, num_M1=0, num_M2=0;</a>
<a name="ln2649">        int len, num_eq, num_in1_only, num_in2_only;</a>
<a name="ln2650">        AT_NUMB *pe1 = (AT_NUMB *) inchi_malloc( (i1-&gt;lenTautomer+1) * sizeof(pe1[0]) );</a>
<a name="ln2651">        AT_NUMB *pe2 = (AT_NUMB *) inchi_malloc( (i2-&gt;lenTautomer+1) * sizeof(pe2[0]) );</a>
<a name="ln2652">        num_H1 = num_H2=0;</a>
<a name="ln2653">        /* collect endpoints, H, (-) */</a>
<a name="ln2654">        if ( !pe1 || !pe2 ) {</a>
<a name="ln2655">            if ( pe1 ) inchi_free( pe1 );</a>
<a name="ln2656">            if ( pe2 ) inchi_free( pe2 );</a>
<a name="ln2657">            *err = -1; /* allocation error */</a>
<a name="ln2658">            goto exit_function;</a>
<a name="ln2659">        }</a>
<a name="ln2660">        for ( m = 1; m &lt; i1-&gt;lenTautomer; m += len ) {</a>
<a name="ln2661">            len = i1-&gt;nTautomer[m ++];</a>
<a name="ln2662">            num_H1 += i1-&gt;nTautomer[m];</a>
<a name="ln2663">            num_M1 += i1-&gt;nTautomer[m+1];</a>
<a name="ln2664">            for ( j = 2; j &lt; len; j ++ ) {</a>
<a name="ln2665">                pe1[num1 ++] = i1-&gt;nTautomer[m + j];</a>
<a name="ln2666">            }</a>
<a name="ln2667">        }</a>
<a name="ln2668">        for ( m = 1; m &lt; i2-&gt;lenTautomer; m += len ) {</a>
<a name="ln2669">            len = i2-&gt;nTautomer[m ++];</a>
<a name="ln2670">            num_H2 += i2-&gt;nTautomer[m];</a>
<a name="ln2671">            num_M2 += i2-&gt;nTautomer[m+1];</a>
<a name="ln2672">            for ( j = 2; j &lt; len; j ++ ) {</a>
<a name="ln2673">                pe2[num2 ++] = i2-&gt;nTautomer[m + j];</a>
<a name="ln2674">            }</a>
<a name="ln2675">        }</a>
<a name="ln2676">        picr-&gt;num_taut_H1 = num_H1;</a>
<a name="ln2677">        picr-&gt;num_taut_H2 = num_H2;</a>
<a name="ln2678">        picr-&gt;num_taut_M1 = num_M1;</a>
<a name="ln2679">        picr-&gt;num_taut_M2 = num_M2;</a>
<a name="ln2680">        /* sort endpoints */</a>
<a name="ln2681">        insertions_sort_AT_RANK( pe1, num1 );</a>
<a name="ln2682">        insertions_sort_AT_RANK( pe2, num2 );</a>
<a name="ln2683">        /* compare */</a>
<a name="ln2684">        /*</a>
<a name="ln2685">        if ( num1 &lt; num2 ) {</a>
<a name="ln2686">            ret |= IDIF_LESS_TG_ENDP;</a>
<a name="ln2687">        } else</a>
<a name="ln2688">        if ( num1 &gt; num2 ) {</a>
<a name="ln2689">            ret |= IDIF_MORE_TG_ENDP;</a>
<a name="ln2690">        }</a>
<a name="ln2691">        */</a>
<a name="ln2692">        /* compare all */</a>
<a name="ln2693">        num_eq = num_in1_only = num_in2_only = 0;</a>
<a name="ln2694">        for ( j1 = j2 = 0; j1 &lt; num1 &amp;&amp; j2 &lt; num2; ) {</a>
<a name="ln2695">            if( pe1[j1] == pe2[j2] ) {</a>
<a name="ln2696">                j1 ++;</a>
<a name="ln2697">                j2 ++;</a>
<a name="ln2698">                num_eq ++;</a>
<a name="ln2699">            } else</a>
<a name="ln2700">            if ( pe1[j1] &lt; pe2[j2] ) { /* BC: fixed, was pe2[j1] 2006-03-27 */</a>
<a name="ln2701">                if ( picr-&gt;num_endp_in1_only &lt; ICR_MAX_ENDP_IN1_ONLY ) {</a>
<a name="ln2702">                    picr-&gt;endp_in1_only[picr-&gt;num_endp_in1_only ++] = pe1[j1];</a>
<a name="ln2703">                }</a>
<a name="ln2704">                j1 ++;</a>
<a name="ln2705">                num_in1_only ++;</a>
<a name="ln2706">            } else {</a>
<a name="ln2707">                if ( picr-&gt;num_endp_in2_only &lt; ICR_MAX_ENDP_IN2_ONLY ) {</a>
<a name="ln2708">                    picr-&gt;endp_in2_only[picr-&gt;num_endp_in2_only ++] = pe2[j2];</a>
<a name="ln2709">                }</a>
<a name="ln2710">                j2 ++;</a>
<a name="ln2711">                num_in2_only ++;</a>
<a name="ln2712">            }</a>
<a name="ln2713">        }</a>
<a name="ln2714">        while ( j1 &lt; num1 ) {</a>
<a name="ln2715">            if ( picr-&gt;num_endp_in1_only &lt; ICR_MAX_ENDP_IN1_ONLY ) {</a>
<a name="ln2716">                picr-&gt;endp_in1_only[picr-&gt;num_endp_in1_only ++] = pe1[j1];</a>
<a name="ln2717">            }</a>
<a name="ln2718">            j1 ++;</a>
<a name="ln2719">            num_in1_only ++;</a>
<a name="ln2720">        }</a>
<a name="ln2721">        while ( j2 &lt; num2 ) {</a>
<a name="ln2722">            if ( picr-&gt;num_endp_in2_only &lt; ICR_MAX_ENDP_IN2_ONLY ) {</a>
<a name="ln2723">                picr-&gt;endp_in2_only[picr-&gt;num_endp_in2_only ++] = pe2[j2];</a>
<a name="ln2724">            }</a>
<a name="ln2725">            j2 ++;</a>
<a name="ln2726">            num_in2_only ++;</a>
<a name="ln2727">        }</a>
<a name="ln2728">        if ( num_in1_only ) {</a>
<a name="ln2729">            ret |= IDIF_EXTRA_TG_ENDP;</a>
<a name="ln2730">        }</a>
<a name="ln2731">        if ( num_in2_only ) {</a>
<a name="ln2732">            ret |= IDIF_MISS_TG_ENDP;</a>
<a name="ln2733">        }</a>
<a name="ln2734">        if ( !num_in1_only &amp;&amp; !num_in2_only &amp;&amp; num_eq ) {</a>
<a name="ln2735">           ; /* same t-groups endpoints */</a>
<a name="ln2736">        } else {</a>
<a name="ln2737">           ret |= IDIF_DIFF_TG_ENDP;</a>
<a name="ln2738">        }</a>
<a name="ln2739">        inchi_free( pe1 );</a>
<a name="ln2740">        inchi_free( pe2 );</a>
<a name="ln2741"> </a>
<a name="ln2742">    }</a>
<a name="ln2743"> </a>
<a name="ln2744">    if ( (i1-&gt;lenTautomer &gt; 1 &amp;&amp; i2-&gt;lenTautomer &gt; 1) &amp;&amp;</a>
<a name="ln2745">         ( i1-&gt;lenTautomer != i2-&gt;lenTautomer ||</a>
<a name="ln2746">         memcmp( i1-&gt;nTautomer, i2-&gt;nTautomer, i1-&gt;lenTautomer*sizeof(i1-&gt;nTautomer[0]) ) ) )</a>
<a name="ln2747">        ret |= IDIF_TG;</a>
<a name="ln2748"> </a>
<a name="ln2749">    if ( i1-&gt;nNumberOfIsotopicAtoms != i2-&gt;nNumberOfIsotopicAtoms ) {</a>
<a name="ln2750">        ret |= IDIF_NUM_ISO_AT;</a>
<a name="ln2751">    } else</a>
<a name="ln2752">    if ( i1-&gt;nNumberOfIsotopicAtoms &gt; 0 &amp;&amp; memcmp( i1-&gt;IsotopicAtom, i2-&gt;IsotopicAtom, i1-&gt;nNumberOfIsotopicAtoms*sizeof(i1-&gt;IsotopicAtom[0]) ) )</a>
<a name="ln2753">        ret |= IDIF_ISO_AT;</a>
<a name="ln2754">    if ( i1-&gt;nTotalCharge != i2-&gt;nTotalCharge )</a>
<a name="ln2755">        ret |= IDIF_CHARGE;</a>
<a name="ln2756">    if ( a1 &amp;&amp; a1-&gt;nNumRemovedProtons &amp;&amp; (!a2 || a2-&gt;nNumRemovedProtons != a1-&gt;nNumRemovedProtons) ) {</a>
<a name="ln2757">        ret |= IDIF_REM_PROT;</a>
<a name="ln2758">    }</a>
<a name="ln2759">    if ( a1 &amp;&amp; (!a2 || </a>
<a name="ln2760">         a2-&gt;nNumRemovedIsotopicH[0] != a1-&gt;nNumRemovedIsotopicH[0] ||</a>
<a name="ln2761">         a2-&gt;nNumRemovedIsotopicH[1] != a1-&gt;nNumRemovedIsotopicH[1] ||</a>
<a name="ln2762">         a2-&gt;nNumRemovedIsotopicH[2] != a1-&gt;nNumRemovedIsotopicH[2]) ) {</a>
<a name="ln2763">        ret |= IDIF_REM_ISO_H;</a>
<a name="ln2764">    }</a>
<a name="ln2765"> </a>
<a name="ln2766">/*</a>
<a name="ln2767">    if ( i1-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; i2-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln2768">        if ( i1-&gt;nPossibleLocationsOfIsotopicH[0] != i2-&gt;nPossibleLocationsOfIsotopicH[0] ||</a>
<a name="ln2769">             memcmp(i1-&gt;nPossibleLocationsOfIsotopicH, i2-&gt;nPossibleLocationsOfIsotopicH,</a>
<a name="ln2770">                    sizeof(i1-&gt;nPossibleLocationsOfIsotopicH[0])*i1-&gt;nPossibleLocationsOfIsotopicH[0]) )</a>
<a name="ln2771">            return 18;</a>
<a name="ln2772">    } else</a>
<a name="ln2773">    if ( !i1-&gt;nPossibleLocationsOfIsotopicH != !i2-&gt;nPossibleLocationsOfIsotopicH ) {</a>
<a name="ln2774">        return 19;</a>
<a name="ln2775">    }</a>
<a name="ln2776">*/</a>
<a name="ln2777">    if ( i1-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2778">         i1-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds + i1-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln2779">        Stereo1 = i1-&gt;StereoIsotopic;</a>
<a name="ln2780">    } else {</a>
<a name="ln2781">        Stereo1 = i1-&gt;Stereo;</a>
<a name="ln2782">    }</a>
<a name="ln2783">    if ( i2-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln2784">         i2-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds + i2-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters ) {</a>
<a name="ln2785">        Stereo2 = i2-&gt;StereoIsotopic;</a>
<a name="ln2786">    } else {</a>
<a name="ln2787">        Stereo2 = i2-&gt;Stereo;</a>
<a name="ln2788">    }</a>
<a name="ln2789">    ret |= CompareReversedStereoINChI2( Stereo1, Stereo2, picr );</a>
<a name="ln2790"> </a>
<a name="ln2791">exit_function:</a>
<a name="ln2792"> </a>
<a name="ln2793">    picr-&gt;flags = ret;</a>
<a name="ln2794"> </a>
<a name="ln2795">    return ret;</a>
<a name="ln2796">}</a>
<a name="ln2797">#endif  /* } READ_INCHI_STRING */</a>
<a name="ln2798">/***************************************************************************************/</a>
<a name="ln2799">int  Create_INChI( INChI **ppINChI, INChI_Aux **ppINChI_Aux, ORIG_ATOM_DATA *orig_inp_data, /* not used */</a>
<a name="ln2800">                  inp_ATOM *inp_at, INP_ATOM_DATA *out_norm_data[2],</a>
<a name="ln2801">                  int num_inp_at, INCHI_MODE nUserMode,</a>
<a name="ln2802">                  INCHI_MODE *pbTautFlags, INCHI_MODE *pbTautFlagsDone,</a>
<a name="ln2803">                  struct tagInchiTime *ulMaxTime, T_GROUP_INFO *ti_out, char *pStrErrStruct)</a>
<a name="ln2804">{</a>
<a name="ln2805">/*</a>
<a name="ln2806">#define NON_TAUT 0</a>
<a name="ln2807">#define TAUT     1    </a>
<a name="ln2808">*/</a>
<a name="ln2809">    sp_ATOM  *at[TAUT_NUM]; /* at[0]=&gt;non-tautomeric, at[1]=&gt;tautomeric */</a>
<a name="ln2810">    /* inp_ATOM *out_norm_taut_at, *out_norm_nontaut_at; */</a>
<a name="ln2811">    int                       i, n1, n2, num_atoms, num_at_tg, num_removed_H, num_removed_H_taut=0, ret=0, ret2=0;</a>
<a name="ln2812">    INCHI_MODE                 nMode=0;</a>
<a name="ln2813">    T_GROUP_INFO              vt_group_info;</a>
<a name="ln2814">    T_GROUP_INFO              vt_group_info_orig;</a>
<a name="ln2815">    T_GROUP_INFO * /*const*/  t_group_info        = &amp;vt_group_info;                </a>
<a name="ln2816">    T_GROUP_INFO * /*const*/  t_group_info_orig   = &amp;vt_group_info_orig;</a>
<a name="ln2817">    </a>
<a name="ln2818">    CANON_STAT  CS, CS2;</a>
<a name="ln2819">    CANON_STAT *pCS  = &amp;CS;</a>
<a name="ln2820">    CANON_STAT *pCS2 = &amp;CS2;  /*  save all allocations to avoid memory leaks in case Canon_INChI() removes the pointer */</a>
<a name="ln2821">    </a>
<a name="ln2822">    ATOM_SIZES  s[TAUT_NUM];</a>
<a name="ln2823"> </a>
<a name="ln2824">    BCN Bcn;</a>
<a name="ln2825">    BCN *pBCN = &amp;Bcn;</a>
<a name="ln2826"> </a>
<a name="ln2827">    int bHasIsotopicAtoms  = 0;</a>
<a name="ln2828">    int bMayHaveStereo     = 0;</a>
<a name="ln2829">    int num_taut_at        = 0;</a>
<a name="ln2830"> </a>
<a name="ln2831">    inp_ATOM *out_at = NULL; /*, *norm_at_fixed_bonds[TAUT_NUM]; */ /*  = {out_norm_nontaut_at, out_norm_taut_at} ; */</a>
<a name="ln2832">    INChI     *pINChI=NULL;      /* added initialization 2006-03 */</a>
<a name="ln2833">    INChI_Aux *pINChI_Aux=NULL;  /* added initialization 2006-03 */</a>
<a name="ln2834">    int        bPointedEdgeStereo = ((TG_FLAG_POINTED_EDGE_STEREO &amp; *pbTautFlags)? PES_BIT_POINT_EDGE_STEREO:0)</a>
<a name="ln2835">                                  | ((TG_FLAG_PHOSPHINE_STEREO    &amp; *pbTautFlags)? PES_BIT_PHOSPHINE_STEREO :0)</a>
<a name="ln2836">                                  | ((TG_FLAG_ARSINE_STEREO       &amp; *pbTautFlags)? PES_BIT_ARSINE_STEREO    :0)</a>
<a name="ln2837">                                  | ((TG_FLAG_FIX_SP3_BUG         &amp; *pbTautFlags)? PES_BIT_FIX_SP3_BUG      :0);</a>
<a name="ln2838">    INCHI_MODE bTautFlags         = (*pbTautFlags     &amp; (~(INCHI_MODE)TG_FLAG_ALL_TAUTOMERIC) );</a>
<a name="ln2839">    INCHI_MODE bTautFlagsDone     = (*pbTautFlagsDone /*&amp; (~(INCHI_MODE)TG_FLAG_ALL_TAUTOMERIC) */);</a>
<a name="ln2840">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2841">    int bExtract = 0; /*  EXTR_HAS_ATOM_WITH_DEFINED_PARITY; */</a>
<a name="ln2842">#endif</a>
<a name="ln2843"> </a>
<a name="ln2844">/*^^^ */</a>
<a name="ln2845">    int bFixIsoFixedH = 0;</a>
<a name="ln2846">    int bFixTermHChrg = 0;</a>
<a name="ln2847"> </a>
<a name="ln2848">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln2849">    long ulNormTime=0;</a>
<a name="ln2850">    long ulCanonTime=0, ulCanonTime2=0;</a>
<a name="ln2851"> </a>
<a name="ln2852">    inchiTime ulNormTimeStart;</a>
<a name="ln2853">    inchiTime ulCanonTimeStart;</a>
<a name="ln2854"> </a>
<a name="ln2855">    InchiTimeGet( &amp;ulNormTimeStart );</a>
<a name="ln2856">#endif</a>
<a name="ln2857"> </a>
<a name="ln2858">    /* vABParityUnknown holds actual value of an internal constant signifying       */</a>
<a name="ln2859">    /* unknown parity: either the same as for undefined parity (default==standard)  */</a>
<a name="ln2860">    /*  or a specific one (non-std; requested by SLUUD switch).                     */</a>
<a name="ln2861">    int vABParityUnknown = AB_PARITY_UNDF;</a>
<a name="ln2862">    if ( 0 != ( nUserMode &amp; REQ_MODE_DIFF_UU_STEREO) ) </a>
<a name="ln2863">    {</a>
<a name="ln2864">        /* Make labels for unknown and undefined stereo different */</a>
<a name="ln2865">        vABParityUnknown = AB_PARITY_UNKN;</a>
<a name="ln2866">    }</a>
<a name="ln2867"> </a>
<a name="ln2868">    </a>
<a name="ln2869"> </a>
<a name="ln2870">/*^^^ */</a>
<a name="ln2871">#if ( FIX_ISO_FIXEDH_BUG == 1 )</a>
<a name="ln2872">    if (TG_FLAG_FIX_ISO_FIXEDH_BUG &amp; *pbTautFlags)</a>
<a name="ln2873">        bFixIsoFixedH = 1;</a>
<a name="ln2874">#endif</a>
<a name="ln2875">#if ( FIX_TERM_H_CHRG_BUG == 1 )</a>
<a name="ln2876">    if (TG_FLAG_FIX_TERM_H_CHRG_BUG &amp; *pbTautFlags)</a>
<a name="ln2877">        bFixTermHChrg = 1;</a>
<a name="ln2878">#endif</a>
<a name="ln2879">/*^^^ */</a>
<a name="ln2880"> </a>
<a name="ln2881">    memset( s, 0, sizeof(s) );</a>
<a name="ln2882">    if ( pBCN ) {</a>
<a name="ln2883">        memset( pBCN, 0, sizeof( pBCN[0] ) );</a>
<a name="ln2884">    }</a>
<a name="ln2885">    memset( t_group_info, 0, sizeof(*t_group_info) );</a>
<a name="ln2886">    memset( t_group_info_orig, 0, sizeof(*t_group_info_orig) );</a>
<a name="ln2887">    /*norm_at[TAUT_NON] = out_norm_data[TAUT_NON]-&gt;at; *//* output normalized non-tautomeric component */</a>
<a name="ln2888">    /*norm_at[TAUT_YES] = out_norm_data[TAUT_YES]-&gt;at; *//* output normalized tautomeric component */</a>
<a name="ln2889">    /*norm_at_fixed_bonds[TAUT_NON] = NULL;*/</a>
<a name="ln2890">    /*norm_at_fixed_bonds[TAUT_YES] = out_norm_data[TAUT_YES]-&gt;at_fixed_bonds;*/</a>
<a name="ln2891">    for ( i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln2892">        if ( out_norm_data[i]-&gt;at ) {</a>
<a name="ln2893">            if ( !(at[i] = (sp_ATOM  *) inchi_malloc( num_inp_at * sizeof(*at[0]) ) ) ) {</a>
<a name="ln2894">                ret = -1;</a>
<a name="ln2895">            }</a>
<a name="ln2896">        } else {</a>
<a name="ln2897">            at[i] = NULL;</a>
<a name="ln2898">        }</a>
<a name="ln2899">    }</a>
<a name="ln2900">    if ( (!out_norm_data[TAUT_NON]-&gt;at &amp;&amp; !out_norm_data[TAUT_YES]-&gt;at) || !inp_at || ret ) {</a>
<a name="ln2901">        ret = -1;</a>
<a name="ln2902">        goto exit_function;</a>
<a name="ln2903">    }</a>
<a name="ln2904">    /* the first struct to process: tautomeric if exists else non-tautomeric */</a>
<a name="ln2905">    out_at = out_norm_data[TAUT_YES]-&gt;at? out_norm_data[TAUT_YES]-&gt;at : out_norm_data[TAUT_NON]-&gt;at;</a>
<a name="ln2906">    /* copy the input structure to be normalized to the buffer for the normalization data */</a>
<a name="ln2907">    memcpy( out_at, inp_at, num_inp_at*sizeof(out_at[0]) );</a>
<a name="ln2908"> </a>
<a name="ln2909">    /*  tautomeric groups setting */</a>
<a name="ln2910">    t_group_info-&gt;bIgnoreIsotopic = 0;   /*  include tautomeric group isotopic info in MarkTautomerGroups() */</a>
<a name="ln2911">    t_group_info-&gt;bTautFlags      = *pbTautFlags;</a>
<a name="ln2912">    t_group_info-&gt;bTautFlagsDone  = *pbTautFlagsDone;</a>
<a name="ln2913"> </a>
<a name="ln2914">    /*  Preprocess the structure; here THE NUMBER OF ATOMS MAY BE REDUCED */</a>
<a name="ln2915">    /*  ??? Ambiguity: H-D may become HD or DH (that is, H+implicit D or D+implicit H) */</a>
<a name="ln2916">    if ( TG_FLAG_H_ALREADY_REMOVED &amp; bTautFlags ) {</a>
<a name="ln2917">        INP_ATOM_DATA *out_norm_data1 = out_norm_data[TAUT_YES]-&gt;at? out_norm_data[TAUT_YES] :</a>
<a name="ln2918">                                        out_norm_data[TAUT_NON]-&gt;at? out_norm_data[TAUT_NON] : NULL;</a>
<a name="ln2919">        if ( out_norm_data1 ) {</a>
<a name="ln2920">            num_at_tg     =</a>
<a name="ln2921">            num_atoms     = out_norm_data1-&gt;num_at - out_norm_data1-&gt;num_removed_H;</a>
<a name="ln2922">            num_removed_H = out_norm_data1-&gt;num_removed_H;</a>
<a name="ln2923">            t_group_info-&gt;tni.nNumRemovedExplicitH = num_removed_H;</a>
<a name="ln2924">        } else {</a>
<a name="ln2925">            ret = -1;</a>
<a name="ln2926">            goto exit_function;</a>
<a name="ln2927">        }</a>
<a name="ln2928">    } else {</a>
<a name="ln2929">        num_at_tg =</a>
<a name="ln2930">        num_atoms = remove_terminal_HDT( num_inp_at, out_at, bFixTermHChrg );</a>
<a name="ln2931">        num_removed_H = num_inp_at - num_atoms;</a>
<a name="ln2932">        t_group_info-&gt;tni.nNumRemovedExplicitH = num_removed_H;</a>
<a name="ln2933">        add_DT_to_num_H( num_atoms, out_at );</a>
<a name="ln2934">    }</a>
<a name="ln2935">    /*fix_odd_things( num_atoms, out_at );*/</a>
<a name="ln2936">#if ( FIND_RING_SYSTEMS == 1 )</a>
<a name="ln2937">    MarkRingSystemsInp( out_at, num_atoms, 0 );</a>
<a name="ln2938">#endif</a>
<a name="ln2939">    /*  duplicate the preprocessed structure so that all supplied out_norm_data[]-&gt;at buffers are filled */</a>
<a name="ln2940">    if ( out_at != out_norm_data[TAUT_YES]-&gt;at &amp;&amp; out_norm_data[TAUT_YES]-&gt;at ) {</a>
<a name="ln2941">        memcpy( out_norm_data[TAUT_YES]-&gt;at, out_at, num_inp_at*sizeof(out_at[0]) );</a>
<a name="ln2942">    }</a>
<a name="ln2943">    if ( out_norm_data[TAUT_YES]-&gt;at_fixed_bonds &amp;&amp; out_norm_data[TAUT_YES]-&gt;at ) {</a>
<a name="ln2944">        memcpy( out_norm_data[TAUT_YES]-&gt;at_fixed_bonds, out_at, num_inp_at*sizeof(out_at[0]) );</a>
<a name="ln2945">    }</a>
<a name="ln2946">    if ( out_at != out_norm_data[TAUT_NON]-&gt;at &amp;&amp; out_norm_data[TAUT_NON]-&gt;at ) {</a>
<a name="ln2947">        memcpy( out_norm_data[TAUT_NON]-&gt;at, out_at, num_inp_at*sizeof(out_at[0]) );</a>
<a name="ln2948">    }</a>
<a name="ln2949"> </a>
<a name="ln2950">    /*******************************************************************************</a>
<a name="ln2951">     * ??? not true ??? duplicate inp_at and keep inp_at[] unchanged after terminal hydrogens removal</a>
<a name="ln2952">     * set stereo parities in taut_at[], non_taut_at[]</a>
<a name="ln2953">     * obtain max. lenghts of the name stereo parts</a>
<a name="ln2954">     * Ignore absence/presence of isotopic stereo for now</a>
<a name="ln2955">     * mark isotopic atoms</a>
<a name="ln2956">     *******************************************************************************/</a>
<a name="ln2957">    if ( out_norm_data[TAUT_YES]-&gt;at &amp;&amp; at[TAUT_YES] ) {</a>
<a name="ln2958">        /* final normalization of possibly tautomeric structure */</a>
<a name="ln2959">        ret = mark_alt_bonds_and_taut_groups ( out_norm_data[TAUT_YES]-&gt;at, out_norm_data[TAUT_YES]-&gt;at_fixed_bonds, num_atoms,</a>
<a name="ln2960">                                               t_group_info, NULL, NULL );</a>
<a name="ln2961">        if ( ret &lt; 0 ) {</a>
<a name="ln2962">            goto exit_function;/*  out of RAM or other normalization problem */</a>
<a name="ln2963">        }</a>
<a name="ln2964">        num_taut_at = ret; /* number of atoms without removed H? */</a>
<a name="ln2965">        num_removed_H_taut = t_group_info-&gt;tni.nNumRemovedExplicitH;</a>
<a name="ln2966">        out_norm_data[TAUT_YES]-&gt;num_at              = num_atoms + num_removed_H_taut; /* protons might have been removed */</a>
<a name="ln2967">        out_norm_data[TAUT_YES]-&gt;num_removed_H       = num_removed_H_taut;</a>
<a name="ln2968">        out_norm_data[TAUT_YES]-&gt;nNumRemovedProtons += t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln2969">        for ( i = 0; i &lt; NUM_H_ISOTOPES; i ++ ) {</a>
<a name="ln2970">            out_norm_data[TAUT_YES]-&gt;nNumRemovedProtonsIsotopic[i] += t_group_info-&gt;tni.nNumRemovedProtonsIsotopic[i] /*+ t_group_info-&gt;num_iso_H[i]*/;</a>
<a name="ln2971">            out_norm_data[TAUT_YES]-&gt;num_iso_H[i]                  += t_group_info-&gt;num_iso_H[i];</a>
<a name="ln2972">        }</a>
<a name="ln2973">        /* mark deleted isolated tautomeric H(+) */</a>
<a name="ln2974">        if ( num_taut_at == 1 &amp;&amp; out_norm_data[TAUT_YES]-&gt;at[0].at_type == ATT_PROTON &amp;&amp;</a>
<a name="ln2975">             t_group_info &amp;&amp; t_group_info-&gt;tni.nNumRemovedProtons == 1 ) {</a>
<a name="ln2976">            out_norm_data[TAUT_YES]-&gt;bDeleted = 1;</a>
<a name="ln2977">            FreeInpAtom( &amp;out_norm_data[TAUT_YES]-&gt;at_fixed_bonds );</a>
<a name="ln2978">        } else</a>
<a name="ln2979">        if ( (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_NORM_CONSIDER_TAUT) &amp;&amp;</a>
<a name="ln2980">             out_norm_data[TAUT_YES]-&gt;at_fixed_bonds) {</a>
<a name="ln2981">             out_norm_data[TAUT_YES]-&gt;bTautPreprocessed = 1;</a>
<a name="ln2982">        }</a>
<a name="ln2983">        /*</a>
<a name="ln2984">        if ( !(t_group_info-&gt;tni.bNormalizationFlags &amp; (FLAG_NORM_CONSIDER_TAUT &amp; ~FLAG_PROTON_SINGLE_REMOVED)) &amp;&amp;</a>
<a name="ln2985">             out_norm_data[TAUT_YES]-&gt;at_fixed_bonds) {</a>
<a name="ln2986">             FreeInpAtom( &amp;out_norm_data[TAUT_YES]-&gt;at_fixed_bonds );</a>
<a name="ln2987">        }</a>
<a name="ln2988">        */</a>
<a name="ln2989">        /*out_norm_data[TAUT_YES]-&gt;num_removed_H = num_removed_H_taut;*/</a>
<a name="ln2990">        out_norm_data[TAUT_YES]-&gt;bTautFlags     = *pbTautFlags     = t_group_info-&gt;bTautFlags;</a>
<a name="ln2991">        out_norm_data[TAUT_YES]-&gt;bTautFlagsDone = *pbTautFlagsDone = t_group_info-&gt;bTautFlagsDone;</a>
<a name="ln2992">        out_norm_data[TAUT_YES]-&gt;bNormalizationFlags = t_group_info-&gt;tni.bNormalizationFlags;</a>
<a name="ln2993">        /* create internal sp_ATOM at[] out of out_norm_data[]-&gt;at */</a>
<a name="ln2994">        inp2spATOM( out_norm_data[TAUT_YES]-&gt;at, num_inp_at, at[TAUT_YES] );</a>
<a name="ln2995">        /* set stereo parities to at[]; nUserMode: accept alt. stereo bonds, min ring size */</a>
<a name="ln2996">        ret = set_stereo_parity( out_norm_data[TAUT_YES]-&gt;at, at[TAUT_YES], num_taut_at, num_removed_H_taut,</a>
<a name="ln2997">                                 &amp;s[TAUT_YES].nMaxNumStereoAtoms, &amp;s[TAUT_YES].nMaxNumStereoBonds, nUserMode,</a>
<a name="ln2998">                                 bPointedEdgeStereo, vABParityUnknown );</a>
<a name="ln2999">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln3000">        if ( 0 &lt; ret ) {</a>
<a name="ln3001">            bExtract |= EXTR_HAS_ATOM_WITH_DEFINED_PARITY;</a>
<a name="ln3002">        }</a>
<a name="ln3003">        if ( t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_NORM_CONSIDER_TAUT ) {</a>
<a name="ln3004">            bExtract |= EXTR_TAUT_TREATMENT_CHARGES;</a>
<a name="ln3005">        }</a>
<a name="ln3006">#endif</a>
<a name="ln3007">        if ( RETURNED_ERROR( ret ) ) {</a>
<a name="ln3008">            goto exit_function; /*  stereo bond error */</a>
<a name="ln3009">        }</a>
<a name="ln3010">        s[TAUT_YES].bMayHaveStereo    = (s[TAUT_YES].nMaxNumStereoAtoms || s[TAUT_YES].nMaxNumStereoBonds);</a>
<a name="ln3011">        /* </a>
<a name="ln3012">         * mark isotopic atoms and atoms that have non-tautomeric</a>
<a name="ln3013">         * isotopic terminal hydrogen atoms 1H, 2H(D), 3H(T)</a>
<a name="ln3014">         */</a>
<a name="ln3015">        s[TAUT_YES].num_isotopic_atoms = set_atom_iso_sort_keys( num_taut_at, at[TAUT_YES], t_group_info,</a>
<a name="ln3016">                                                          &amp;s[TAUT_YES].bHasIsotopicTautGroups );</a>
<a name="ln3017">        /**************************************************************************</a>
<a name="ln3018">         *  prepare tautomeric (if no tautomerism found then prepare non-tautomeric)</a>
<a name="ln3019">         *  structure for canonicalizaton:</a>
<a name="ln3020">         **************************************************************************</a>
<a name="ln3021">         *   remove t-groups that have no H,</a>
<a name="ln3022">         *   remove charges from t-groups if requested</a>
<a name="ln3023">         *   renumber t-groups and find final t_group_info-&gt;num_t_groups</a>
<a name="ln3024">         *   add to t-groups lists of endpoints tgroup-&gt;nEndpointAtomNumber[]</a>
<a name="ln3025">         *   calculate length of the t-group part of the connection table</a>
<a name="ln3026">         **************************************************************************/</a>
<a name="ln3027">        s[TAUT_YES].nLenLinearCTTautomer = CountTautomerGroups( at[TAUT_YES], num_taut_at, t_group_info );</a>
<a name="ln3028">        if ( RETURNED_ERROR(s[TAUT_YES].nLenLinearCTTautomer) ) { /* added error treatment 9-11-2003 */</a>
<a name="ln3029">            ret = s[TAUT_YES].nLenLinearCTTautomer;</a>
<a name="ln3030">            goto exit_function;</a>
<a name="ln3031">            /*  error has happened; no breakpoint here</a>
<a name="ln3032">            s[TAUT_YES].nLenLinearCTTautomer = 0;</a>
<a name="ln3033">            */</a>
<a name="ln3034">        } else</a>
<a name="ln3035">        if ( s[TAUT_YES].nLenLinearCTTautomer &gt; 0 ) {</a>
<a name="ln3036">            num_at_tg = num_taut_at+t_group_info-&gt;num_t_groups;</a>
<a name="ln3037">            /*  ??? -not true- create t_group_info_orig for multiple calls with atom renumbering */</a>
<a name="ln3038">            make_a_copy_of_t_group_info( t_group_info_orig /* dest*/, t_group_info /* source*/ );</a>
<a name="ln3039">            /*  mark isotopic tautomer groups: calculate t_group-&gt;iWeight */</a>
<a name="ln3040">            s[TAUT_YES].nLenLinearCTIsotopicTautomer=set_tautomer_iso_sort_keys( t_group_info );</a>
<a name="ln3041">            if ( s[TAUT_YES].nLenLinearCTIsotopicTautomer &lt; 0 ) {</a>
<a name="ln3042">                /* ??? -error cannot happen- error has happened; no breakpoint here */</a>
<a name="ln3043">                s[TAUT_YES].nLenLinearCTIsotopicTautomer = 0;</a>
<a name="ln3044">            }</a>
<a name="ln3045">            out_norm_data[TAUT_YES]-&gt;bTautomeric = s[TAUT_YES].nLenLinearCTTautomer;</a>
<a name="ln3046">        }</a>
<a name="ln3047">        /*  new variable: s[TAUT_YES].nLenCT introduced 7-22-2002 */</a>
<a name="ln3048">        GetCanonLengths( num_taut_at, at[TAUT_YES], &amp;s[TAUT_YES], t_group_info );</a>
<a name="ln3049">    }</a>
<a name="ln3050">    if ( out_norm_data[TAUT_NON]-&gt;at &amp;&amp; out_norm_data[TAUT_YES]-&gt;at &amp;&amp; at[TAUT_NON] &amp;&amp; !s[TAUT_YES].nLenLinearCTTautomer ) {</a>
<a name="ln3051">        /* the structure is non-tautomeric: use tautomeric treatment results only for it */</a>
<a name="ln3052">        inchi_free( at[TAUT_NON] );</a>
<a name="ln3053">        at[TAUT_NON] = NULL;</a>
<a name="ln3054">    } else</a>
<a name="ln3055">    if ( !out_norm_data[TAUT_NON]-&gt;at &amp;&amp; out_norm_data[TAUT_YES]-&gt;at &amp;&amp;</a>
<a name="ln3056">         !at[TAUT_NON] &amp;&amp; at[TAUT_YES] &amp;&amp; !s[TAUT_YES].nLenLinearCTTautomer ) {</a>
<a name="ln3057">        /* requested tautomeric; found non-tautomeric; it is located in out_norm_data[TAUT_YES]-&gt;at */</a>
<a name="ln3058">        out_norm_data[TAUT_YES]-&gt;bTautomeric = 0;</a>
<a name="ln3059">    } else</a>
<a name="ln3060">    if ( out_norm_data[TAUT_NON]-&gt;at &amp;&amp; at[TAUT_NON] ) {</a>
<a name="ln3061">        /* the structure needs non-tautomeric treatment: final normalization of non-tautomeric structure */</a>
<a name="ln3062">        ret = mark_alt_bonds_and_taut_groups ( out_norm_data[TAUT_NON]-&gt;at, NULL, num_atoms, NULL, &amp;bTautFlags, &amp;bTautFlagsDone );</a>
<a name="ln3063">        if ( ret &lt; 0 ) {</a>
<a name="ln3064">            goto exit_function;  /*  out of RAM or other normalization problem */</a>
<a name="ln3065">        }</a>
<a name="ln3066">        out_norm_data[TAUT_NON]-&gt;num_at        = num_atoms + num_removed_H;</a>
<a name="ln3067">        out_norm_data[TAUT_NON]-&gt;num_removed_H = num_removed_H;</a>
<a name="ln3068">        out_norm_data[TAUT_NON]-&gt;bTautFlags     = *pbTautFlags;</a>
<a name="ln3069">        out_norm_data[TAUT_NON]-&gt;bTautFlagsDone = *pbTautFlagsDone;</a>
<a name="ln3070">        out_norm_data[TAUT_NON]-&gt;bNormalizationFlags = 0;</a>
<a name="ln3071">        /* create internal sp_ATOM at[] out of out_norm_data[]-&gt;at */</a>
<a name="ln3072">        inp2spATOM( out_norm_data[TAUT_NON]-&gt;at, num_inp_at, at[TAUT_NON] );</a>
<a name="ln3073">        /* set stereo parities to at[]; nUserMode: accept alt. stereo bonds, min ring size */</a>
<a name="ln3074">        ret = set_stereo_parity( out_norm_data[TAUT_NON]-&gt;at, at[TAUT_NON], num_atoms, num_removed_H,</a>
<a name="ln3075">                                 &amp;s[TAUT_NON].nMaxNumStereoAtoms, &amp;s[TAUT_NON].nMaxNumStereoBonds, nUserMode,</a>
<a name="ln3076">                                 bPointedEdgeStereo, vABParityUnknown );</a>
<a name="ln3077">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln3078">        if ( 0 &lt; ret ) {</a>
<a name="ln3079">            bExtract |= EXTR_HAS_ATOM_WITH_DEFINED_PARITY;</a>
<a name="ln3080">        }</a>
<a name="ln3081">#endif</a>
<a name="ln3082">        if ( RETURNED_ERROR( ret ) ) {</a>
<a name="ln3083">            goto exit_function; /*  stereo bond error */</a>
<a name="ln3084">        }</a>
<a name="ln3085">        s[TAUT_NON].bMayHaveStereo = (s[TAUT_NON].nMaxNumStereoAtoms || s[TAUT_NON].nMaxNumStereoBonds);</a>
<a name="ln3086">        /* </a>
<a name="ln3087">         * mark isotopic atoms and atoms that have non-tautomeric</a>
<a name="ln3088">         * isotopic terminal hydrogen atoms 1H, 2H(D), 3H(T)</a>
<a name="ln3089">         */</a>
<a name="ln3090">        s[TAUT_NON].num_isotopic_atoms = set_atom_iso_sort_keys( num_atoms, at[TAUT_NON], NULL, NULL );</a>
<a name="ln3091">        GetCanonLengths( num_atoms, at[TAUT_NON], &amp;s[TAUT_NON], NULL);</a>
<a name="ln3092">        out_norm_data[TAUT_NON]-&gt;bTautomeric = 0;</a>
<a name="ln3093">    }</a>
<a name="ln3094"> </a>
<a name="ln3095">    /**********************************************************/</a>
<a name="ln3096">    /*  common */</a>
<a name="ln3097">    bMayHaveStereo        = s[TAUT_YES].bMayHaveStereo || s[TAUT_NON].bMayHaveStereo;</a>
<a name="ln3098">    bHasIsotopicAtoms     = s[TAUT_NON].num_isotopic_atoms &gt; 0 || s[TAUT_NON].bHasIsotopicTautGroups &gt; 0 ||</a>
<a name="ln3099">                            s[TAUT_YES].num_isotopic_atoms &gt; 0 || s[TAUT_YES].bHasIsotopicTautGroups &gt; 0 ;</a>
<a name="ln3100">/*^^^ */</a>
<a name="ln3101">    if (bFixIsoFixedH)  /* 2008-03-21 DT */</a>
<a name="ln3102">        bHasIsotopicAtoms     = bHasIsotopicAtoms   || </a>
<a name="ln3103">                                (s[TAUT_YES].nLenLinearCTTautomer &gt; 0 &amp;&amp; t_group_info &amp;&amp;</a>
<a name="ln3104">                                ((0 &lt; NUM_H_ISOTOPES &amp;&amp; t_group_info-&gt;tni.nNumRemovedProtonsIsotopic[0]) ||</a>
<a name="ln3105">                                 (1 &lt; NUM_H_ISOTOPES &amp;&amp; t_group_info-&gt;tni.nNumRemovedProtonsIsotopic[1]) ||</a>
<a name="ln3106">                                 (2 &lt; NUM_H_ISOTOPES &amp;&amp; t_group_info-&gt;tni.nNumRemovedProtonsIsotopic[2]))) ;</a>
<a name="ln3107">/*^^^ */</a>
<a name="ln3108">    bHasIsotopicAtoms   =   bHasIsotopicAtoms || </a>
<a name="ln3109">                            (s[TAUT_YES].nLenIsotopicEndpoints &gt; 1 &amp;&amp; t_group_info &amp;&amp;</a>
<a name="ln3110">                            (t_group_info-&gt;bTautFlagsDone &amp; (TG_FLAG_FOUND_ISOTOPIC_H_DONE|TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE)));</a>
<a name="ln3111"> </a>
<a name="ln3112">    /*  default mode */</a>
<a name="ln3113">    if ( !(nUserMode &amp; REQ_MODE_DEFAULT) ) {</a>
<a name="ln3114">        /*  default */</a>
<a name="ln3115">        nUserMode |= REQ_MODE_DEFAULT;</a>
<a name="ln3116">    }</a>
<a name="ln3117">    </a>
<a name="ln3118">    /*  adjust the mode to the reality */</a>
<a name="ln3119">    if ( ( nUserMode &amp; REQ_MODE_ISO ) &amp;&amp; !bHasIsotopicAtoms ) {</a>
<a name="ln3120">        nUserMode ^= REQ_MODE_ISO;</a>
<a name="ln3121">        nUserMode |= REQ_MODE_NON_ISO;  /*  at least one is needed */</a>
<a name="ln3122">    }</a>
<a name="ln3123">    if ( (nUserMode &amp; REQ_MODE_STEREO) &amp;&amp; ( nUserMode &amp; REQ_MODE_ISO ) ) {</a>
<a name="ln3124">        nUserMode |= REQ_MODE_ISO_STEREO;</a>
<a name="ln3125">    }</a>
<a name="ln3126">    if ( (nUserMode &amp; REQ_MODE_STEREO) &amp;&amp; !( nUserMode &amp; REQ_MODE_NON_ISO ) ) {</a>
<a name="ln3127">        nUserMode ^= REQ_MODE_STEREO;</a>
<a name="ln3128">    }</a>
<a name="ln3129">    if ( !bMayHaveStereo ) {</a>
<a name="ln3130">        if ( nUserMode &amp; REQ_MODE_STEREO )</a>
<a name="ln3131">            nUserMode ^= REQ_MODE_STEREO;</a>
<a name="ln3132">        if ( nUserMode &amp; REQ_MODE_ISO_STEREO )</a>
<a name="ln3133">            nUserMode ^= REQ_MODE_ISO_STEREO;</a>
<a name="ln3134">    }</a>
<a name="ln3135"> </a>
<a name="ln3136">    if ( (nUserMode &amp; REQ_MODE_BASIC) &amp;&amp; (!out_norm_data[TAUT_NON]-&gt;at || !ppINChI[TAUT_NON] || !ppINChI_Aux[TAUT_NON] || !at[TAUT_NON]) ) {</a>
<a name="ln3137">        nUserMode ^= REQ_MODE_BASIC;</a>
<a name="ln3138">    }</a>
<a name="ln3139">    if ( (nUserMode &amp; REQ_MODE_TAUT) &amp;&amp; (!out_norm_data[TAUT_YES]-&gt;at || !ppINChI[TAUT_YES] || !ppINChI_Aux[TAUT_YES] || !at[TAUT_YES]) ) {</a>
<a name="ln3140">        nUserMode ^= REQ_MODE_TAUT;</a>
<a name="ln3141">    }</a>
<a name="ln3142">        </a>
<a name="ln3143"> </a>
<a name="ln3144">    switch ((int)nUserMode &amp; (REQ_MODE_BASIC | REQ_MODE_TAUT)) {</a>
<a name="ln3145">    case REQ_MODE_BASIC:</a>
<a name="ln3146">        n1 = TAUT_NON;</a>
<a name="ln3147">        n2 = TAUT_NON;</a>
<a name="ln3148">        break;</a>
<a name="ln3149">    case REQ_MODE_TAUT:</a>
<a name="ln3150">        n1 = TAUT_YES;</a>
<a name="ln3151">        n2 = TAUT_YES;</a>
<a name="ln3152">        break;</a>
<a name="ln3153">    case (REQ_MODE_BASIC | REQ_MODE_TAUT):</a>
<a name="ln3154">        n1 = TAUT_NON;</a>
<a name="ln3155">        n2 = TAUT_YES;</a>
<a name="ln3156">        break;</a>
<a name="ln3157">    default:</a>
<a name="ln3158">        ret = -3;</a>
<a name="ln3159">        goto exit_function; /*  program error: inconsistent nUserMode or missing taut/non-taut allocation */ /*   &lt;BRKPT&gt; */</a>
<a name="ln3160">    }</a>
<a name="ln3161">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3162">    ulNormTime = InchiTimeElapsed( &amp;ulNormTimeStart);</a>
<a name="ln3163">#endif</a>
<a name="ln3164">    /************************************************************</a>
<a name="ln3165">     *                                                          *</a>
<a name="ln3166">     *       Obtain all non-stereo canonical numberings         *</a>
<a name="ln3167">     *                                                          *</a>
<a name="ln3168">     ************************************************************/</a>
<a name="ln3169">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3170">        InchiTimeGet( &amp;ulCanonTimeStart );</a>
<a name="ln3171">#endif</a>
<a name="ln3172">    if ( (nUserMode &amp; REQ_MODE_NON_ISO) &amp;&amp; !(nUserMode &amp; REQ_MODE_ISO) ) {</a>
<a name="ln3173">        /* added for special non-isotopic test mode 2004-10-04 */</a>
<a name="ln3174">        if ( t_group_info ) {</a>
<a name="ln3175">            t_group_info-&gt;bIgnoreIsotopic = 1;</a>
<a name="ln3176">            if ( t_group_info-&gt;nIsotopicEndpointAtomNumber ) {</a>
<a name="ln3177">                t_group_info-&gt;nIsotopicEndpointAtomNumber[0] = inchi_min(1, t_group_info-&gt;nIsotopicEndpointAtomNumber[0]);</a>
<a name="ln3178">            }</a>
<a name="ln3179">            memset( t_group_info-&gt;num_iso_H, 0, sizeof(t_group_info-&gt;num_iso_H) );</a>
<a name="ln3180">            memset ( t_group_info-&gt;tni.nNumRemovedProtonsIsotopic, 0, sizeof(t_group_info-&gt;tni.nNumRemovedProtonsIsotopic));</a>
<a name="ln3181">            t_group_info-&gt;bTautFlagsDone &amp;= ~(TG_FLAG_FOUND_ISOTOPIC_H_DONE|TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE);</a>
<a name="ln3182">        }</a>
<a name="ln3183">        for ( i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln3184">            s[i].bHasIsotopicTautGroups = 0;</a>
<a name="ln3185">            s[i].bIgnoreIsotopic = 1;</a>
<a name="ln3186">            s[i].nLenIsotopic = 0;</a>
<a name="ln3187">            s[i].nLenIsotopicEndpoints = 0;</a>
<a name="ln3188">            s[i].nLenLinearCTIsotopicTautomer = 0;</a>
<a name="ln3189">            s[i].num_isotopic_atoms = 0;</a>
<a name="ln3190">        }</a>
<a name="ln3191">        bHasIsotopicAtoms = 0;</a>
<a name="ln3192">    }</a>
<a name="ln3193">    ret = GetBaseCanonRanking( num_atoms, num_at_tg, at, t_group_info, s, pBCN, ulMaxTime, bFixIsoFixedH );</a>
<a name="ln3194">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3195">        ulCanonTime = InchiTimeElapsed( &amp;ulCanonTimeStart );</a>
<a name="ln3196">#endif</a>
<a name="ln3197">    if ( ret &lt; 0 ) {</a>
<a name="ln3198">        goto exit_function; /*  program error */</a>
<a name="ln3199">    }</a>
<a name="ln3200">#if ( bRELEASE_VERSION == 0 &amp;&amp; FIND_CANON_NE_EQUITABLE == 1 )</a>
<a name="ln3201">    /* Debug only: find whether canonical equivalence is different from equitable partition */</a>
<a name="ln3202">    if ( bCanonIsFinerThanEquitablePartition( num_atoms, at[n1], pBCN-&gt;ftcn[TAUT_NON].nSymmRankCt ) ) {</a>
<a name="ln3203">        bExtract |= EXTR_CANON_NE_EQUITABLE;</a>
<a name="ln3204">    }</a>
<a name="ln3205">#endif</a>
<a name="ln3206">    /* added for special non-isotopic test mode 2004-10-04 */</a>
<a name="ln3207">    if ( !pBCN-&gt;ftcn[n1].PartitionCt.Rank ) {</a>
<a name="ln3208">        n1 = ALT_TAUT(n1);</a>
<a name="ln3209">    }</a>
<a name="ln3210">    if ( !pBCN-&gt;ftcn[n2].PartitionCt.Rank ) {</a>
<a name="ln3211">        n2 = ALT_TAUT(n2);</a>
<a name="ln3212">    }</a>
<a name="ln3213">    if ( n1 &gt; n2 ) {</a>
<a name="ln3214">        ret = CT_TAUCOUNT_ERR;</a>
<a name="ln3215">        goto exit_function; /*  program error */</a>
<a name="ln3216">    }</a>
<a name="ln3217"> </a>
<a name="ln3218">    /************************************************************</a>
<a name="ln3219">     *                                                          *</a>
<a name="ln3220">     *       Obtain stereo canonical numberings                 *</a>
<a name="ln3221">     *                                                          *</a>
<a name="ln3222">     ************************************************************/</a>
<a name="ln3223"> </a>
<a name="ln3224">    for ( i = n2; i &gt;= n1 &amp;&amp; !RETURNED_ERROR( ret ); i -- ) {</a>
<a name="ln3225"> </a>
<a name="ln3226">        memset( pCS, 0, sizeof(*pCS) );</a>
<a name="ln3227"> </a>
<a name="ln3228">        switch( i ) {</a>
<a name="ln3229">        case TAUT_NON: /*  non-tautomeric */</a>
<a name="ln3230">            nMode  = 0;</a>
<a name="ln3231">            nMode  = (s[i].nLenLinearCTTautomer == 0)? CANON_MODE_CT:CANON_MODE_TAUT;</a>
<a name="ln3232">            nMode |= (bHasIsotopicAtoms &amp;&amp; (nUserMode &amp; REQ_MODE_ISO))? CANON_MODE_ISO:0;</a>
<a name="ln3233">            nMode |= (s[TAUT_NON].bMayHaveStereo &amp;&amp; (nUserMode &amp; REQ_MODE_STEREO) )? CANON_MODE_STEREO:0;</a>
<a name="ln3234">            nMode |= (bHasIsotopicAtoms &amp;&amp; s[TAUT_NON].bMayHaveStereo &amp;&amp; (nUserMode &amp; REQ_MODE_ISO_STEREO))? CANON_MODE_ISO_STEREO:0;</a>
<a name="ln3235">            nMode |= (nUserMode &amp; REQ_MODE_NOEQ_STEREO   )? CMODE_NOEQ_STEREO    : 0;</a>
<a name="ln3236">            nMode |= (nUserMode &amp; REQ_MODE_REDNDNT_STEREO)? CMODE_REDNDNT_STEREO : 0;</a>
<a name="ln3237">            nMode |= (nUserMode &amp; REQ_MODE_NO_ALT_SBONDS )? CMODE_NO_ALT_SBONDS  : 0;</a>
<a name="ln3238">            if ( (nMode &amp; CANON_MODE_STEREO)     == CANON_MODE_STEREO ||</a>
<a name="ln3239">                 (nMode &amp; CANON_MODE_ISO_STEREO) == CANON_MODE_ISO_STEREO ) {</a>
<a name="ln3240">                nMode |= (nUserMode &amp; REQ_MODE_RELATIVE_STEREO)? CMODE_RELATIVE_STEREO: 0;</a>
<a name="ln3241">                nMode |= (nUserMode &amp; REQ_MODE_RACEMIC_STEREO )? CMODE_RACEMIC_STEREO : 0;</a>
<a name="ln3242">                nMode |= (nUserMode &amp; REQ_MODE_SC_IGN_ALL_UU  )? CMODE_SC_IGN_ALL_UU  : 0;</a>
<a name="ln3243">                nMode |= (nUserMode &amp; REQ_MODE_SB_IGN_ALL_UU  )? CMODE_SB_IGN_ALL_UU  : 0;</a>
<a name="ln3244">            }</a>
<a name="ln3245">            if ( (ret= AllocateCS( pCS, num_atoms, num_atoms, s[TAUT_NON].nLenCT, s[TAUT_NON].nLenCTAtOnly,</a>
<a name="ln3246">                             s[TAUT_NON].nLenLinearCTStereoDble, s[TAUT_NON].nMaxNumStereoBonds,</a>
<a name="ln3247">                             s[TAUT_NON].nLenLinearCTStereoCarb, s[TAUT_NON].nMaxNumStereoAtoms,</a>
<a name="ln3248">                             0, 0, s[TAUT_NON].nLenIsotopic, nMode, pBCN )) ) {</a>
<a name="ln3249">                goto exit_function;</a>
<a name="ln3250">            }</a>
<a name="ln3251">            *pCS2 = *pCS;</a>
<a name="ln3252">            break;</a>
<a name="ln3253">        case TAUT_YES: /*  tautomeric */</a>
<a name="ln3254">            nMode  = 0;</a>
<a name="ln3255">            nMode  = (s[i].nLenLinearCTTautomer == 0)? CANON_MODE_CT:CANON_MODE_TAUT;</a>
<a name="ln3256">            nMode |= (bHasIsotopicAtoms &amp;&amp; (nUserMode &amp; REQ_MODE_ISO) )? CANON_MODE_ISO:0;</a>
<a name="ln3257">            nMode |= (s[TAUT_YES].bMayHaveStereo &amp;&amp; (nUserMode &amp; REQ_MODE_STEREO) )? CANON_MODE_STEREO:0;</a>
<a name="ln3258">            nMode |= (bHasIsotopicAtoms &amp;&amp; s[TAUT_YES].bMayHaveStereo &amp;&amp; (nUserMode &amp; REQ_MODE_ISO_STEREO))? CANON_MODE_ISO_STEREO:0;</a>
<a name="ln3259">            nMode |= (nUserMode &amp; REQ_MODE_NOEQ_STEREO   )? CMODE_NOEQ_STEREO    : 0;</a>
<a name="ln3260">            nMode |= (nUserMode &amp; REQ_MODE_REDNDNT_STEREO)? CMODE_REDNDNT_STEREO : 0;</a>
<a name="ln3261">            nMode |= (nUserMode &amp; REQ_MODE_NO_ALT_SBONDS )? CMODE_NO_ALT_SBONDS  : 0;</a>
<a name="ln3262">            if ( (nMode &amp; CANON_MODE_STEREO)     == CANON_MODE_STEREO ||</a>
<a name="ln3263">                 (nMode &amp; CANON_MODE_ISO_STEREO) == CANON_MODE_ISO_STEREO ) {</a>
<a name="ln3264">                nMode |= (nUserMode &amp; REQ_MODE_RELATIVE_STEREO)? CMODE_RELATIVE_STEREO: 0;</a>
<a name="ln3265">                nMode |= (nUserMode &amp; REQ_MODE_RACEMIC_STEREO )? CMODE_RACEMIC_STEREO : 0;</a>
<a name="ln3266">                nMode |= (nUserMode &amp; REQ_MODE_SC_IGN_ALL_UU  )? CMODE_SC_IGN_ALL_UU  : 0;</a>
<a name="ln3267">                nMode |= (nUserMode &amp; REQ_MODE_SB_IGN_ALL_UU  )? CMODE_SB_IGN_ALL_UU  : 0;</a>
<a name="ln3268">            }</a>
<a name="ln3269">            if ( (ret= AllocateCS( pCS, num_atoms, num_at_tg, s[TAUT_YES].nLenCT, s[TAUT_YES].nLenCTAtOnly,</a>
<a name="ln3270">                             s[TAUT_YES].nLenLinearCTStereoDble, s[TAUT_YES].nMaxNumStereoBonds,</a>
<a name="ln3271">                             s[TAUT_YES].nLenLinearCTStereoCarb, s[TAUT_YES].nMaxNumStereoAtoms,</a>
<a name="ln3272">                             s[TAUT_YES].nLenLinearCTTautomer, s[TAUT_YES].nLenLinearCTIsotopicTautomer,</a>
<a name="ln3273">                             s[TAUT_YES].nLenIsotopic, nMode, pBCN )) ) {</a>
<a name="ln3274">                goto exit_function;</a>
<a name="ln3275">            }</a>
<a name="ln3276">            *pCS2 = *pCS;</a>
<a name="ln3277">            break;</a>
<a name="ln3278">        }</a>
<a name="ln3279"> </a>
<a name="ln3280">    </a>
<a name="ln3281">        /*^^^ 2009-12-05 */</a>
<a name="ln3282">        nMode |= (nUserMode &amp; REQ_MODE_DIFF_UU_STEREO)? REQ_MODE_DIFF_UU_STEREO : 0;</a>
<a name="ln3283">        /*^^^ 2009-12-05 */</a>
<a name="ln3284"> </a>
<a name="ln3285"> </a>
<a name="ln3286">        /*  settings */</a>
<a name="ln3287">        pCS-&gt;lNumDecreasedCT               = -1;                             </a>
<a name="ln3288">        pCS-&gt;bDoubleBondSquare             =  DOUBLE_BOND_NEIGH_LIST? 2:0;  /*  2 =&gt; special mode */</a>
<a name="ln3289">        pCS-&gt;bIgnoreIsotopic               =  !((s[TAUT_NON].num_isotopic_atoms ||        </a>
<a name="ln3290">                                                s[TAUT_YES].num_isotopic_atoms ||    </a>
<a name="ln3291">                                                s[TAUT_YES].bHasIsotopicTautGroups) ||</a>
<a name="ln3292">                                               (nUserMode &amp; REQ_MODE_NON_ISO) ||</a>
<a name="ln3293">                                               !(nUserMode &amp; REQ_MODE_ISO));</a>
<a name="ln3294">        </a>
<a name="ln3295">        if ( (nUserMode &amp; REQ_MODE_NON_ISO) &amp;&amp; !(nUserMode &amp; REQ_MODE_ISO) ) {</a>
<a name="ln3296">            pCS-&gt;bIgnoreIsotopic = 1; /* 10-04-2004 */</a>
<a name="ln3297">        }</a>
<a name="ln3298">        </a>
<a name="ln3299">        if ( i == TAUT_YES ) {  /* tautomeric */</a>
<a name="ln3300">            pCS-&gt;t_group_info                  = t_group_info; /*  ??? make a copy or reuse ???  */</a>
<a name="ln3301">            pCS-&gt;t_group_info-&gt;bIgnoreIsotopic = !(s[TAUT_YES].bHasIsotopicTautGroups ||</a>
<a name="ln3302">                                                   (nUserMode &amp; REQ_MODE_NON_ISO) ||</a>
<a name="ln3303">                                                   !(nUserMode &amp; REQ_MODE_ISO));</a>
<a name="ln3304">            if ( (nUserMode &amp; REQ_MODE_NON_ISO) &amp;&amp; !(nUserMode &amp; REQ_MODE_ISO) ) {</a>
<a name="ln3305">                pCS-&gt;t_group_info-&gt;bIgnoreIsotopic = 1; /* 10-04-2004 */</a>
<a name="ln3306">            }</a>
<a name="ln3307">        }</a>
<a name="ln3308">        pCS-&gt;ulTimeOutTime  = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln3309">        /*=========== Obsolete Mode Bits (bit 0 is Least Significant Bit) ===========</a>
<a name="ln3310">         *</a>
<a name="ln3311">         *  Mode      Bits       Description                                </a>
<a name="ln3312">         *   '0' c    0          Only one connection table canonicalization </a>
<a name="ln3313">         *   '1' C    1          Recalculate CT using fixed nSymmRank       </a>
<a name="ln3314">         *   '2' i    1|2        Isotopic canonicalization (internal)       </a>
<a name="ln3315">         *   '3' I    1|2|4      Isotopic canonicalization (output)</a>
<a name="ln3316">         *   '4' s    1|8        Stereo canonicalization                    </a>
<a name="ln3317">         *   '5' S    1|2|4|16   Stereo isotopic canonicalization           </a>
<a name="ln3318">         *   '6' A    1|2|4|8|16 Output All</a>
<a name="ln3319">         */</a>
<a name="ln3320">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3321">        InchiTimeGet( &amp;ulCanonTimeStart );</a>
<a name="ln3322">#endif</a>
<a name="ln3323">        /***************************************</a>
<a name="ln3324">           The last canonicalization step</a>
<a name="ln3325">         ***************************************/</a>
<a name="ln3326">        if ( pBCN ) {</a>
<a name="ln3327">            /* USE_CANON2 == 1 */</a>
<a name="ln3328">            pCS-&gt;NeighList  = NULL;</a>
<a name="ln3329">            pCS-&gt;pBCN       = pBCN;</a>
<a name="ln3330">            ret = Canon_INChI( num_atoms, i?num_at_tg:num_atoms, at[i], pCS, nMode, i);</a>
<a name="ln3331">        } else {</a>
<a name="ln3332">            /* old way */</a>
<a name="ln3333">            pCS-&gt;NeighList  = CreateNeighList( num_atoms, i?num_at_tg:num_atoms, at[i], pCS-&gt;bDoubleBondSquare, pCS-&gt;t_group_info );</a>
<a name="ln3334">            pCS-&gt;pBCN       = NULL;</a>
<a name="ln3335">            ret = Canon_INChI( num_atoms, i?num_at_tg:num_atoms, at[i], pCS, nMode, i);</a>
<a name="ln3336">        }</a>
<a name="ln3337"> </a>
<a name="ln3338">        pINChI     = ppINChI[i];      /* pointers to already allocated still empty InChI */</a>
<a name="ln3339">        pINChI_Aux = ppINChI_Aux[i];</a>
<a name="ln3340">        if ( ret &lt;= 0 ) {</a>
<a name="ln3341">            /***************************************/</a>
<a name="ln3342">            /*  failure in Canon_INChI()            */</a>
<a name="ln3343">            /***************************************/</a>
<a name="ln3344">            pINChI-&gt;nErrorCode     = ret;</a>
<a name="ln3345">            pINChI_Aux-&gt;nErrorCode = ret;</a>
<a name="ln3346">        } else {</a>
<a name="ln3347">            /***************************************/</a>
<a name="ln3348">            /*  success Canon_INChI()               */</a>
<a name="ln3349">            /*  save canonicalization results in   */</a>
<a name="ln3350">            /*  pINChI and pINChI_Aux                */</a>
<a name="ln3351">            /***************************************/</a>
<a name="ln3352">            pINChI-&gt;nErrorCode     = 0;</a>
<a name="ln3353">            pINChI_Aux-&gt;nErrorCode = 0;</a>
<a name="ln3354">            pINChI-&gt;bDeleted = pINChI_Aux-&gt;bDeleted = out_norm_data[i]-&gt;bDeleted;</a>
<a name="ln3355">            pINChI_Aux-&gt;nCanonFlags         = pCS-&gt;nCanonFlags;</a>
<a name="ln3356">            pINChI_Aux-&gt;bTautFlags          = out_norm_data[i]-&gt;bTautFlags;</a>
<a name="ln3357">            pINChI_Aux-&gt;bTautFlagsDone      = out_norm_data[i]-&gt;bTautFlagsDone;</a>
<a name="ln3358">            pINChI_Aux-&gt;bNormalizationFlags = out_norm_data[i]-&gt;bNormalizationFlags;</a>
<a name="ln3359">            /*  may return an error or a warning */</a>
<a name="ln3360">            ret = FillOutINChI( pINChI, pINChI_Aux,</a>
<a name="ln3361">                               num_atoms, i?num_at_tg:num_atoms,</a>
<a name="ln3362">                               i?num_removed_H_taut:num_removed_H, at[i], </a>
<a name="ln3363">                               out_norm_data[i]-&gt;at, pCS, i, nUserMode, </a>
<a name="ln3364">                               pStrErrStruct );</a>
<a name="ln3365">            if ( RETURNED_ERROR( ret ) ) {</a>
<a name="ln3366">                /* failure in FillOutINChI() */</a>
<a name="ln3367">                pINChI-&gt;nErrorCode      = ret;</a>
<a name="ln3368">                pINChI_Aux-&gt;nErrorCode  = ret;</a>
<a name="ln3369">            } else {</a>
<a name="ln3370">                /****************************/</a>
<a name="ln3371">                /* success in FillOutINChI() */</a>
<a name="ln3372">                /****************************/</a>
<a name="ln3373">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln3374">                if ( pINChI-&gt;Stereo &amp;&amp;</a>
<a name="ln3375">                     (pINChI-&gt;Stereo-&gt;nCompInv2Abs &amp;&amp; !pINChI-&gt;Stereo-&gt;bTrivialInv) ||</a>
<a name="ln3376">                     pINChI-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln3377">                     (pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &amp;&amp; !pINChI-&gt;StereoIsotopic-&gt;bTrivialInv) ) {</a>
<a name="ln3378">                    bExtract |= EXTR_NON_TRIVIAL_STEREO;</a>
<a name="ln3379">                }</a>
<a name="ln3380">#endif</a>
<a name="ln3381">                /* mark non-tautomeric representation as having another, tautomeric representation */</a>
<a name="ln3382">                if ( pINChI_Aux &amp;&amp; s[TAUT_YES].nLenLinearCTTautomer ) {</a>
<a name="ln3383">                    pINChI_Aux-&gt;bIsTautomeric = s[TAUT_YES].nLenLinearCTTautomer;</a>
<a name="ln3384">                }</a>
<a name="ln3385">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln3386">                pCS-&gt;bExtract   |= bExtract;</a>
<a name="ln3387">                pINChI-&gt;bExtract |= pCS-&gt;bExtract;</a>
<a name="ln3388">#endif</a>
<a name="ln3389">                ret2 = CheckCanonNumberingCorrectness(</a>
<a name="ln3390">                                num_atoms, i?num_at_tg:num_atoms,</a>
<a name="ln3391">                                at[i], pCS, i, pStrErrStruct );</a>
<a name="ln3392">                if ( ret2 ) {</a>
<a name="ln3393">                    pINChI-&gt;nErrorCode      = ret2;</a>
<a name="ln3394">                    pINChI_Aux-&gt;nErrorCode  = ret2;</a>
<a name="ln3395">                    ret = ret2;</a>
<a name="ln3396">                }</a>
<a name="ln3397">            }</a>
<a name="ln3398">        }</a>
<a name="ln3399">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3400">        ulCanonTime2 = InchiTimeElapsed( &amp;ulCanonTimeStart );</a>
<a name="ln3401">        pINChI_Aux-&gt;ulCanonTime = ulCanonTime+ulCanonTime2;</a>
<a name="ln3402">        pINChI_Aux-&gt;ulNormTime  = ulNormTime;</a>
<a name="ln3403">#endif</a>
<a name="ln3404">        FreeNeighList( pCS-&gt;NeighList );</a>
<a name="ln3405">        DeAllocateCS( pCS2 );</a>
<a name="ln3406"> </a>
<a name="ln3407">        pINChI = NULL;      /* avoid dangling pointers */</a>
<a name="ln3408">        pINChI_Aux = NULL;  /* avoid dangling pointers */</a>
<a name="ln3409">    }</a>
<a name="ln3410">    if ( ret == 0 ) {</a>
<a name="ln3411">        ret = num_atoms;</a>
<a name="ln3412">    }</a>
<a name="ln3413">    /*  treat the results later */</a>
<a name="ln3414"> </a>
<a name="ln3415">exit_function:</a>
<a name="ln3416">    DeAllocBCN( pBCN );</a>
<a name="ln3417">    if ( at[TAUT_YES] )</a>
<a name="ln3418">        inchi_free( at[TAUT_YES] );</a>
<a name="ln3419">    if ( at[TAUT_NON] )</a>
<a name="ln3420">        inchi_free( at[TAUT_NON] );</a>
<a name="ln3421">    if ( ti_out ) {</a>
<a name="ln3422">        *ti_out = *t_group_info;</a>
<a name="ln3423">    } else {</a>
<a name="ln3424">        free_t_group_info( t_group_info );</a>
<a name="ln3425">    }</a>
<a name="ln3426">    free_t_group_info( t_group_info_orig );</a>
<a name="ln3427">    return ret;</a>
<a name="ln3428">}</a>
<a name="ln3429">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln3430">/***************************************************************************************/</a>
<a name="ln3431">int GetAtomOrdNbrInCanonOrd( inp_ATOM *norm_at, AT_NUMB *nAtomOrdNbr,</a>
<a name="ln3432">                            AT_NUMB *nOrigAtNosInCanonOrd, int num_at )</a>
<a name="ln3433">{</a>
<a name="ln3434">    AT_NUMB   *nCanonNbr, *nOrigAtNos, *nOrigAtNosOrd;</a>
<a name="ln3435">    int          i, ret;</a>
<a name="ln3436"> </a>
<a name="ln3437">    ret = 0;</a>
<a name="ln3438"> </a>
<a name="ln3439">    nCanonNbr     = (AT_NUMB *)inchi_calloc( num_at, sizeof(nCanonNbr[0]) );</a>
<a name="ln3440">    nOrigAtNos    = (AT_NUMB *)inchi_calloc( num_at, sizeof(nOrigAtNos[0]) );</a>
<a name="ln3441">    nOrigAtNosOrd = (AT_NUMB *)inchi_calloc( num_at, sizeof(nOrigAtNosOrd[0]) );</a>
<a name="ln3442"> </a>
<a name="ln3443">    if ( !nCanonNbr || !nOrigAtNos || !nAtomOrdNbr || !nOrigAtNosOrd ) {</a>
<a name="ln3444">        ret = CT_OUT_OF_RAM;  /*   &lt;BRKPT&gt; */</a>
<a name="ln3445">        goto exit_function;</a>
<a name="ln3446">    }</a>
<a name="ln3447">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3448">        nCanonNbr[i] = nAtomOrdNbr[i] = nOrigAtNosOrd[i] = (AT_NUMB)i;</a>
<a name="ln3449">        nOrigAtNos[i] = norm_at[i].orig_at_number;</a>
<a name="ln3450">    }</a>
<a name="ln3451">    /*  get nCanonNbr[]: canon. numbers-1 in order of increasing original atom numbers */</a>
<a name="ln3452">    pn_RankForSort = nOrigAtNosInCanonOrd;</a>
<a name="ln3453">    qsort( nCanonNbr, num_at, sizeof(nCanonNbr[0]), CompRank );</a>
<a name="ln3454">    /*  get nOrigAtNosOrd[]: norm_atom ord. numbers the same order of increasing original atom numbers */</a>
<a name="ln3455">    pn_RankForSort = nOrigAtNos;</a>
<a name="ln3456">    qsort( nOrigAtNosOrd, num_at, sizeof(nOrigAtNosOrd[0]), CompRank ); </a>
<a name="ln3457">    /*  check whether the 2 sets of origiginal atom numbers have identical elements */</a>
<a name="ln3458">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3459">        if ( nOrigAtNosInCanonOrd[nCanonNbr[i]] != nOrigAtNos[nOrigAtNosOrd[i]] ) {</a>
<a name="ln3460">            ret = CT_RANKING_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln3461">            goto exit_function;</a>
<a name="ln3462">        }</a>
<a name="ln3463">    }</a>
<a name="ln3464">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3465">        nAtomOrdNbr[(int)nCanonNbr[i]] = nOrigAtNosOrd[i];</a>
<a name="ln3466">    }</a>
<a name="ln3467"> </a>
<a name="ln3468">/*</a>
<a name="ln3469">    pn_RankForSort = nCanonNbr;</a>
<a name="ln3470">    qsort( nAtomOrdNbr, num_at, sizeof(nCanonNbr[0]), CompRank );</a>
<a name="ln3471">*/</a>
<a name="ln3472"> </a>
<a name="ln3473">exit_function:</a>
<a name="ln3474">    if ( nCanonNbr )</a>
<a name="ln3475">        inchi_free( nCanonNbr );</a>
<a name="ln3476">    if ( nOrigAtNos )</a>
<a name="ln3477">        inchi_free( nOrigAtNos );</a>
<a name="ln3478">    if ( nOrigAtNosOrd )</a>
<a name="ln3479">        inchi_free( nOrigAtNosOrd );</a>
<a name="ln3480">    return ret;</a>
<a name="ln3481">}</a>
<a name="ln3482">/***************************************************************************************/</a>
<a name="ln3483">int FillOutCanonInfAtom(inp_ATOM *norm_at, INF_ATOM_DATA *inf_norm_at_data, int init_num_at, int bIsotopic,</a>
<a name="ln3484">                        INChI *pINChI, INChI_Aux *pINChI_Aux, int bAbcNumbers, INCHI_MODE nMode)</a>
<a name="ln3485">{</a>
<a name="ln3486">    int          i, j, m, n, num_stereo, k, c, ret, len_str, len, atw, num_err;</a>
<a name="ln3487">    int          next_atom[MAX_CUMULENE_LEN+1], best_next_atom[MAX_CUMULENE_LEN+1], cur_atom;</a>
<a name="ln3488">    int          next_neigh[MAX_CUMULENE_LEN+1], best_next_neigh[MAX_CUMULENE_LEN+1], best_len;</a>
<a name="ln3489">    int          num_iso_H[NUM_H_ISOTOPES];</a>
<a name="ln3490">    char        *str;</a>
<a name="ln3491">    AT_NUMB      g, e;</a>
<a name="ln3492">    int          num_at           = pINChI-&gt;nNumberOfAtoms;</a>
<a name="ln3493">    int          nNumberOfTGroups = (pINChI-&gt;lenTautomer &amp;&amp; pINChI-&gt;nTautomer &amp;&amp; pINChI-&gt;nTautomer[0])? (int)pINChI-&gt;nTautomer[0] : 0;</a>
<a name="ln3494">    AT_NUMB     *nOrigAtNosInCanonOrd;</a>
<a name="ln3495">    INChI_Stereo *Stereo;</a>
<a name="ln3496">    AT_NUMB     *nConstitEquNumbers;</a>
<a name="ln3497">    AT_NUMB     *nConstitEquTGroupNumbers;</a>
<a name="ln3498">    S_CHAR      *t_parity = NULL;</a>
<a name="ln3499">    AT_NUMB     *nNumber = NULL;</a>
<a name="ln3500">    int          bIncludeIsotopicH;</a>
<a name="ln3501"> </a>
<a name="ln3502">    AT_NUMB     *nNormAtNosInCanonOrd;</a>
<a name="ln3503">    int (*MakeNumber)(char*, int, const char*, int) = bAbcNumbers? MakeAbcNumber:MakeDecNumber;</a>
<a name="ln3504">    int bRel= (0 != (nMode &amp; ( REQ_MODE_RELATIVE_STEREO)));</a>
<a name="ln3505">    int bRac= (0 != (nMode &amp; ( REQ_MODE_RACEMIC_STEREO)));</a>
<a name="ln3506">    int bRelRac= bRel || bRac;</a>
<a name="ln3507">    int bDoDisplaySp3 = 1;</a>
<a name="ln3508"> </a>
<a name="ln3509">    inf_ATOM *inf_norm_at = inf_norm_at_data? inf_norm_at_data-&gt;at : NULL;</a>
<a name="ln3510"> </a>
<a name="ln3511">    ret = 0;</a>
<a name="ln3512">    num_err = 0;</a>
<a name="ln3513"> </a>
<a name="ln3514">    if ( !inf_norm_at )</a>
<a name="ln3515">        return ret;</a>
<a name="ln3516">    /* prepare removeable protons and H info */</a>
<a name="ln3517">    inf_norm_at_data-&gt;nNumRemovedProtons = pINChI_Aux-&gt;nNumRemovedProtons;</a>
<a name="ln3518">    MakeRemovedProtonsString( pINChI_Aux-&gt;nNumRemovedProtons, pINChI_Aux-&gt;nNumRemovedIsotopicH, NULL, bIsotopic,</a>
<a name="ln3519">                              inf_norm_at_data-&gt;szRemovedProtons, &amp;inf_norm_at_data-&gt;num_removed_iso_H );</a>
<a name="ln3520">    /* fill out info atom */</a>
<a name="ln3521">    if ( bIsotopic &amp;&amp; !(pINChI-&gt;nNumberOfIsotopicAtoms || pINChI-&gt;nNumberOfIsotopicTGroups ||</a>
<a name="ln3522">                        pINChI-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; pINChI-&gt;nPossibleLocationsOfIsotopicH[0]&gt;1) )</a>
<a name="ln3523">        bIsotopic = 0;</a>
<a name="ln3524">    </a>
<a name="ln3525">    Stereo                   = bIsotopic? pINChI-&gt;StereoIsotopic :</a>
<a name="ln3526">                                          pINChI-&gt;Stereo;</a>
<a name="ln3527">    bDoDisplaySp3 = (NULL != Stereo) &amp;&amp; (Stereo-&gt;nNumberOfStereoCenters &gt; 0); </a>
<a name="ln3528"> </a>
<a name="ln3529">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln3530">    if ( bDoDisplaySp3 &amp;&amp; bRelRac &amp;&amp; Stereo-&gt;nNumberOfStereoCenters &lt; 2 &amp;&amp;</a>
<a name="ln3531">         (Stereo-&gt;nCompInv2Abs || ATOM_PARITY_ILL_DEF(Stereo-&gt;t_parity[0]) ) ) {</a>
<a name="ln3532">        bDoDisplaySp3 = 0;</a>
<a name="ln3533">        if ( Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln3534">            inf_norm_at_data-&gt;StereoFlags |= bRel? INF_STEREO_REL : bRac? INF_STEREO_RAC : 0;</a>
<a name="ln3535">        }</a>
<a name="ln3536">    }</a>
<a name="ln3537">#endif    </a>
<a name="ln3538">    /* flag has stereo */</a>
<a name="ln3539">    if ( (NULL != Stereo) &amp;&amp; (bDoDisplaySp3 || Stereo-&gt;nNumberOfStereoBonds &gt; 0) ) {</a>
<a name="ln3540">        inf_norm_at_data-&gt;StereoFlags |= INF_STEREO;</a>
<a name="ln3541">    }</a>
<a name="ln3542"> </a>
<a name="ln3543">    /*</a>
<a name="ln3544">    if ( bDoDisplaySp3 &amp;&amp; bRelRac &amp;&amp; Stereo-&gt;nNumberOfStereoCenters &lt; 2 &amp;&amp;</a>
<a name="ln3545">         (Stereo-&gt;nCompInv2Abs || ATOM_PARITY_ILL_DEF(Stereo-&gt;t_parity[0]) ) ) {</a>
<a name="ln3546">        bDoDisplaySp3 = 0;</a>
<a name="ln3547">    }</a>
<a name="ln3548">    */</a>
<a name="ln3549">    if ( bDoDisplaySp3 &amp;&amp; Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln3550">        /* inversion changes stereo */</a>
<a name="ln3551">        if ( bRel ) {</a>
<a name="ln3552">            inf_norm_at_data-&gt;StereoFlags |= INF_STEREO_REL;</a>
<a name="ln3553">        } else</a>
<a name="ln3554">        if ( bRac ) {</a>
<a name="ln3555">            inf_norm_at_data-&gt;StereoFlags |= INF_STEREO_RAC;</a>
<a name="ln3556">        } else {</a>
<a name="ln3557">            inf_norm_at_data-&gt;StereoFlags |= INF_STEREO_ABS;</a>
<a name="ln3558">        }</a>
<a name="ln3559">        if ( bRelRac ) {</a>
<a name="ln3560">            inf_norm_at_data-&gt;StereoFlags |= (Stereo-&gt;nCompInv2Abs &gt; 0)? INF_STEREO_NORM : INF_STEREO_INV;</a>
<a name="ln3561">        }</a>
<a name="ln3562">    }</a>
<a name="ln3563">    if ( bDoDisplaySp3 &amp;&amp; Stereo-&gt;nCompInv2Abs &lt; 0 &amp;&amp; !bRelRac ) {</a>
<a name="ln3564">       /* display Inv stereo which is Absolute Stereo */</a>
<a name="ln3565">        nNumber  = Stereo-&gt;nNumberInv;</a>
<a name="ln3566">        t_parity = Stereo-&gt;t_parityInv;</a>
<a name="ln3567">        nOrigAtNosInCanonOrd     = bIsotopic? pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv :</a>
<a name="ln3568">                                              pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv;</a>
<a name="ln3569">    } else {</a>
<a name="ln3570">       /* display Inv stereo which is Absolute Stereo */</a>
<a name="ln3571">        if ( bDoDisplaySp3 ) {</a>
<a name="ln3572">            nNumber  = Stereo-&gt;nNumber;</a>
<a name="ln3573">            t_parity = Stereo-&gt;t_parity;</a>
<a name="ln3574">        }</a>
<a name="ln3575">        nOrigAtNosInCanonOrd     = bIsotopic? pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd :</a>
<a name="ln3576">                                              pINChI_Aux-&gt;nOrigAtNosInCanonOrd;</a>
<a name="ln3577">    }</a>
<a name="ln3578"> </a>
<a name="ln3579">    nConstitEquNumbers       = bIsotopic? pINChI_Aux-&gt;nConstitEquIsotopicNumbers :</a>
<a name="ln3580">                                          pINChI_Aux-&gt;nConstitEquNumbers;</a>
<a name="ln3581">    nConstitEquTGroupNumbers = bIsotopic? pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers :</a>
<a name="ln3582">                                          pINChI_Aux-&gt;nConstitEquTGroupNumbers;</a>
<a name="ln3583">    memset( inf_norm_at, 0, init_num_at*sizeof(inf_norm_at[0]) );</a>
<a name="ln3584"> </a>
<a name="ln3585">    /*  obtain norm_at[] atom numbers (from zero) in order of canonical numbers */</a>
<a name="ln3586">    nNormAtNosInCanonOrd = (AT_NUMB *)inchi_calloc( num_at, sizeof(nNormAtNosInCanonOrd[0]) );</a>
<a name="ln3587">    if ( ret = GetAtomOrdNbrInCanonOrd( norm_at, nNormAtNosInCanonOrd, nOrigAtNosInCanonOrd, num_at ) ) {</a>
<a name="ln3588">        goto exit_function;</a>
<a name="ln3589">    }</a>
<a name="ln3590">    </a>
<a name="ln3591">    /*  atom canonical and equivalence numbers &gt; 0 */</a>
<a name="ln3592">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3593">        j = (int)nNormAtNosInCanonOrd[i];</a>
<a name="ln3594">        if ( j &lt; 0 || j &gt;= num_at )</a>
<a name="ln3595">            continue;</a>
<a name="ln3596">        inf_norm_at[j].nCanonNbr = (AT_NUMB)(i+1);</a>
<a name="ln3597">        inf_norm_at[j].nCanonEquNbr = nConstitEquNumbers[i];</a>
<a name="ln3598">#ifdef DISPLAY_DEBUG_DATA</a>
<a name="ln3599">        inf_norm_at[j].nDebugData = 0;</a>
<a name="ln3600">#if ( DISPLAY_DEBUG_DATA == DISPLAY_DEBUG_DATA_C_POINT )</a>
<a name="ln3601">        inf_norm_at[j].nDebugData = norm_at[j].c_point;</a>
<a name="ln3602">#endif</a>
<a name="ln3603">#endif</a>
<a name="ln3604">    }</a>
<a name="ln3605">    /*  tautomeric groups */</a>
<a name="ln3606">    if ( nNumberOfTGroups ) {</a>
<a name="ln3607">        /*</a>
<a name="ln3608">         :   start from 1: bypass number of t-groups</a>
<a name="ln3609">         :   j is a counter within the current t-group</a>
<a name="ln3610">         :   g is a tautomeric group canonical number</a>
<a name="ln3611">         :   e is a tautomeric group equivalence</a>
<a name="ln3612">         */</a>
<a name="ln3613">        for ( g = 1, i = 1; g &lt;= nNumberOfTGroups; g ++ ) {</a>
<a name="ln3614">            n = (int)pINChI-&gt;nTautomer[i] - INCHI_T_NUM_MOVABLE; /*  number of atoms in t-group */</a>
<a name="ln3615">            e = nConstitEquTGroupNumbers[(int)g - 1];</a>
<a name="ln3616">            /*  bypass number of hydrogen atoms, negative charges, ... */</a>
<a name="ln3617">            for ( i += INCHI_T_NUM_MOVABLE+1, j = 0; j &lt; n &amp;&amp; i &lt; pINChI-&gt;lenTautomer; j ++, i ++ ) {</a>
<a name="ln3618">                /*  scan canonical numbers of atoms within the atom t-group */</a>
<a name="ln3619">                k = (int)nNormAtNosInCanonOrd[(int)pINChI-&gt;nTautomer[i]-1];</a>
<a name="ln3620">                inf_norm_at[k].nTautGroupCanonNbr = g;</a>
<a name="ln3621">                inf_norm_at[k].nTautGroupEquNbr   = e;</a>
<a name="ln3622">            }</a>
<a name="ln3623">        }</a>
<a name="ln3624">        if ( i != pINChI-&gt;lenTautomer || g != nNumberOfTGroups+1 ) {</a>
<a name="ln3625">            ret = CT_TAUCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln3626">            goto exit_function;</a>
<a name="ln3627">        }</a>
<a name="ln3628">    }</a>
<a name="ln3629">    /* atoms that may exchange isotopic H */</a>
<a name="ln3630">    if ( bIsotopic &amp;&amp; pINChI-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; (n = (int)pINChI-&gt;nPossibleLocationsOfIsotopicH[0]) ) {</a>
<a name="ln3631">        for ( i = 1; i &lt; n; i ++ ) {</a>
<a name="ln3632">            j = (int)pINChI-&gt;nPossibleLocationsOfIsotopicH[i];</a>
<a name="ln3633">            k = (int)nNormAtNosInCanonOrd[j - 1];</a>
<a name="ln3634">            if ( !inf_norm_at[k].nTautGroupCanonNbr ) {</a>
<a name="ln3635">                inf_norm_at[k].cFlags |= AT_FLAG_ISO_H_POINT;</a>
<a name="ln3636">            }</a>
<a name="ln3637">        }</a>
<a name="ln3638">    }</a>
<a name="ln3639"> </a>
<a name="ln3640">#if ( DISPLAY_RING_SYSTEMS == 1 )</a>
<a name="ln3641">    /*  debug only */</a>
<a name="ln3642">    for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln3643">        inf_norm_at[j].nCanonNbr          = norm_at[j].nBlockSystem;</a>
<a name="ln3644">        inf_norm_at[j].nCanonEquNbr       = norm_at[j].nRingSystem;</a>
<a name="ln3645">#if ( USE_DISTANCES_FOR_RANKING == 1 )</a>
<a name="ln3646">        inf_norm_at[j].nTautGroupCanonNbr   = norm_at[j].nDistanceFromTerminal;</a>
<a name="ln3647">        inf_norm_at[j].nTautGroupEquNbr     = norm_at[j].bCutVertex;</a>
<a name="ln3648">#else</a>
<a name="ln3649">        inf_norm_at[j].nTautGroupCanonNbr   = norm_at[j].bCutVertex;</a>
<a name="ln3650">        inf_norm_at[j].nTautGroupEquNbr   = 0;</a>
<a name="ln3651">#endif</a>
<a name="ln3652">    }</a>
<a name="ln3653">#endif</a>
<a name="ln3654"> </a>
<a name="ln3655"> </a>
<a name="ln3656"> </a>
<a name="ln3657">    /*  Write isotopic mass, chemical element symbols and hydrogens, charge, radical, canon. numbers */</a>
<a name="ln3658">    len_str = sizeof(inf_norm_at[0].at_string);</a>
<a name="ln3659">    for ( i = 0; i &lt; init_num_at; i ++ ) {</a>
<a name="ln3660">        str = inf_norm_at[i].at_string;</a>
<a name="ln3661">        len = 0;</a>
<a name="ln3662">        bIncludeIsotopicH = bIsotopic &amp;&amp; !inf_norm_at[i].nTautGroupCanonNbr &amp;&amp; !(inf_norm_at[i].cFlags &amp; AT_FLAG_ISO_H_POINT);</a>
<a name="ln3663">        /*  isotopic mass */</a>
<a name="ln3664">        atw = 0;</a>
<a name="ln3665">        if ( norm_at[i].iso_atw_diff &amp;&amp; bIsotopic ) {</a>
<a name="ln3666">            if ( norm_at[i].at_type == ATT_PROTON ) {</a>
<a name="ln3667">                ; /* do not set isotopic mass of a tautomeric proton */</a>
<a name="ln3668">            } else</a>
<a name="ln3669">            if ( norm_at[i].el_number == PERIODIC_NUMBER_H &amp;&amp; norm_at[i].chem_bonds_valence == 1 &amp;&amp;</a>
<a name="ln3670">                 !norm_at[i].charge &amp;&amp; !norm_at[i].radical &amp;&amp; !norm_at[i].num_H &amp;&amp;</a>
<a name="ln3671">                 (inf_norm_at[j=(int)norm_at[i].neighbor[0]].nTautGroupCanonNbr || (inf_norm_at[j].cFlags &amp; AT_FLAG_ISO_H_POINT) ) ) {</a>
<a name="ln3672">                ; /* do not set isotopic mass of an exchangeable proton */</a>
<a name="ln3673">            } else {</a>
<a name="ln3674">                atw = get_atw(norm_at[i].elname);</a>
<a name="ln3675">                atw += (norm_at[i].iso_atw_diff&gt;0)? norm_at[i].iso_atw_diff-1:norm_at[i].iso_atw_diff;</a>
<a name="ln3676">                /*len += sprintf( str+len, &quot;^%d&quot;, atw );*/</a>
<a name="ln3677">            }</a>
<a name="ln3678">        }</a>
<a name="ln3679">        /*  element name */</a>
<a name="ln3680">        if ( norm_at[i].el_number == PERIODIC_NUMBER_H &amp;&amp; 2 &lt;= atw &amp;&amp; atw &lt;= 3 ) {</a>
<a name="ln3681">            len += sprintf( str+len, &quot;%s&quot;, atw==2? &quot;D&quot; : &quot;T&quot; );</a>
<a name="ln3682">        } else {</a>
<a name="ln3683">            if ( atw ) {</a>
<a name="ln3684">                len += sprintf( str+len, &quot;^%d&quot;, atw );</a>
<a name="ln3685">            }</a>
<a name="ln3686">            len += sprintf( str+len, &quot;%s&quot;, norm_at[i].elname );</a>
<a name="ln3687">        }</a>
<a name="ln3688">        /*  hydrogens */</a>
<a name="ln3689">        /*  find number of previuosly removed terminal hydrogen atoms because these terminal H will be displayed */</a>
<a name="ln3690">        for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln3691">            num_iso_H[j] = norm_at[i].num_iso_H[j];</a>
<a name="ln3692">        }</a>
<a name="ln3693">        /* n = number of implicit H to display */</a>
<a name="ln3694">        for ( j = num_at, n = (int)norm_at[i].num_H; j &lt; init_num_at; j ++ ) {</a>
<a name="ln3695">            /*  subtract number of removed terminal */</a>
<a name="ln3696">            /*  H atoms from the total number of H atoms */</a>
<a name="ln3697">            if ( i == (int)norm_at[j].neighbor[0] ) {</a>
<a name="ln3698">                n -= 1; /* found explicit H =&gt; decrement number of implicit H */</a>
<a name="ln3699">                m = (int)norm_at[j].iso_atw_diff-1;</a>
<a name="ln3700">                if ( 0 &lt;= m &amp;&amp; m &lt; NUM_H_ISOTOPES ) {</a>
<a name="ln3701">                    /*  subtract number of removed terminal isotopic H */</a>
<a name="ln3702">                    /*  atoms from the total number of isotopic H atoms */</a>
<a name="ln3703">                    num_iso_H[m] -= 1;</a>
<a name="ln3704">                }</a>
<a name="ln3705">            }</a>
<a name="ln3706">        }</a>
<a name="ln3707">        /* at this point n = number of implicit H to display, </a>
<a name="ln3708">           num_iso_H[] contains number of implicit isotopic H among n */</a>
<a name="ln3709">        if ( bIncludeIsotopicH ) {</a>
<a name="ln3710">            /*  subtract number of isotopic H atoms from the total number of H atoms */</a>
<a name="ln3711">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln3712">                n -= num_iso_H[j];</a>
<a name="ln3713">            }</a>
<a name="ln3714">        }</a>
<a name="ln3715">        /*  non-isotopic hydrogen atoms */</a>
<a name="ln3716">        if ( n &gt; 1 ) {</a>
<a name="ln3717">            len += sprintf( str+len, &quot;H%d&quot;, n );</a>
<a name="ln3718">        } else</a>
<a name="ln3719">        if ( n == 1 ) {</a>
<a name="ln3720">            len += sprintf( str+len, &quot;H&quot; );</a>
<a name="ln3721">        }</a>
<a name="ln3722">        /*  isotopic hydrogen atoms */</a>
<a name="ln3723">        if ( bIncludeIsotopicH ) {</a>
<a name="ln3724">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln3725">                if ( num_iso_H[j] ) {</a>
<a name="ln3726">                    if ( j == 0 || j != 1 &amp;&amp; j != 2 ) {</a>
<a name="ln3727">                        len += sprintf( str+len, &quot;^%dH&quot;, j+1 );</a>
<a name="ln3728">                    } else {</a>
<a name="ln3729">                        len += sprintf( str+len, j == 1? &quot;D&quot; : &quot;T&quot; );</a>
<a name="ln3730">                    }</a>
<a name="ln3731">                    if ( num_iso_H[j] != 1 ) {</a>
<a name="ln3732">                        len += sprintf( str+len, &quot;%d&quot;, (int)num_iso_H[j] );</a>
<a name="ln3733">                    }</a>
<a name="ln3734">                }</a>
<a name="ln3735">            }</a>
<a name="ln3736">        }</a>
<a name="ln3737">        if ( norm_at[i].el_number == PERIODIC_NUMBER_H &amp;&amp; str[0] == str[1] ) {</a>
<a name="ln3738">            char *q;</a>
<a name="ln3739">            if ( !str[2] ) {</a>
<a name="ln3740">                str[1] = '2';  /* quick fix: replace HH with H2 */</a>
<a name="ln3741">            } else</a>
<a name="ln3742">            if ( isdigit( UCINT str[2] ) &amp;&amp; (n = strtol( str+2, &amp;q, 10 )) &amp;&amp; !q[0] ) {</a>
<a name="ln3743">                len = 1 + sprintf( str+1, &quot;%d&quot;, n+1 );</a>
<a name="ln3744">            }</a>
<a name="ln3745">        }</a>
<a name="ln3746">        /*</a>
<a name="ln3747">        if ( str[0] == 'H' &amp;&amp; str[1] == 'H' &amp;&amp; !str[2] ) {</a>
<a name="ln3748">            str[1] = '2';</a>
<a name="ln3749">        }</a>
<a name="ln3750">        */</a>
<a name="ln3751">        /*  charge */</a>
<a name="ln3752">        if ( abs(norm_at[i].charge) &gt; 1 )</a>
<a name="ln3753">            len += sprintf( str+len, &quot;%+d&quot;, norm_at[i].charge );</a>
<a name="ln3754">        else</a>
<a name="ln3755">        if ( abs(norm_at[i].charge) == 1 )</a>
<a name="ln3756">            len += sprintf( str+len, &quot;%s&quot;, norm_at[i].charge&gt;0? &quot;+&quot; : &quot;-&quot; );</a>
<a name="ln3757">        /*  radical */</a>
<a name="ln3758">        if ( norm_at[i].radical )</a>
<a name="ln3759">            len += sprintf( str+len, &quot;%s&quot;, norm_at[i].radical==RADICAL_SINGLET? &quot;:&quot; :</a>
<a name="ln3760">                                           norm_at[i].radical==RADICAL_DOUBLET? &quot;.&quot; :</a>
<a name="ln3761">                                           norm_at[i].radical==RADICAL_TRIPLET? &quot;..&quot; : &quot;?&quot;);</a>
<a name="ln3762">    }</a>
<a name="ln3763"> </a>
<a name="ln3764">    /*  stereogenic centers */</a>
<a name="ln3765">    if ( bDoDisplaySp3 &amp;&amp; Stereo &amp;&amp; 0 &lt; (num_stereo = Stereo-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln3766">        for ( i = 0; i &lt; num_stereo; i ++ ) {</a>
<a name="ln3767">            j = (int)nNormAtNosInCanonOrd[(int)nNumber[i]-1];</a>
<a name="ln3768">            c = t_parity[i];</a>
<a name="ln3769">            c = c==1? '-' : c==2? '+' : c==3? 'u' : c== 4? '?' : '*';</a>
<a name="ln3770">            inf_norm_at[j].cStereoCenterParity = c;</a>
<a name="ln3771">            str=inf_norm_at[j].at_string;</a>
<a name="ln3772">            len = strlen(str);</a>
<a name="ln3773">            if ( len + 3 &lt; (int)sizeof(inf_norm_at[0].at_string) ) {</a>
<a name="ln3774">                str[len++] = '(';</a>
<a name="ln3775">                str[len++] = inf_norm_at[j].cStereoCenterParity;</a>
<a name="ln3776">                str[len++] = ')';</a>
<a name="ln3777">                str[len] = '\0';</a>
<a name="ln3778">                /*  mark ambuguous stereo center */</a>
<a name="ln3779">                if ( norm_at[j].bAmbiguousStereo &amp;&amp; (c=='+' || c=='-' || c=='?') &amp;&amp;  str[0] != '!' &amp;&amp;</a>
<a name="ln3780">                     len+1 &lt; (int)sizeof(inf_norm_at[0].at_string) ) {</a>
<a name="ln3781">                    memmove( str+1, str, len+1 );</a>
<a name="ln3782">                    str[0] = '!'; /* output the atom in red color */</a>
<a name="ln3783">                }</a>
<a name="ln3784">            }</a>
<a name="ln3785">        }</a>
<a name="ln3786">    }</a>
<a name="ln3787">    </a>
<a name="ln3788">    /*  stereogenic bonds */</a>
<a name="ln3789">    /*  (cumulenes with odd number of double bonds are stereocenters, */</a>
<a name="ln3790">    /*   and atom parity should be set) */</a>
<a name="ln3791">    if ( Stereo &amp;&amp; 0 &lt; (num_stereo = Stereo-&gt;nNumberOfStereoBonds) ) {</a>
<a name="ln3792">        for ( i = 0; i &lt; num_stereo; i ++ ) {</a>
<a name="ln3793">            int start_at, num_eql=0, bAmbiguousStereoBond = 0;</a>
<a name="ln3794">            j = (int)nNormAtNosInCanonOrd[(int)Stereo-&gt;nBondAtom1[i]-1];</a>
<a name="ln3795">            k = (int)nNormAtNosInCanonOrd[(int)Stereo-&gt;nBondAtom2[i]-1];</a>
<a name="ln3796">            start_at = j;</a>
<a name="ln3797">            c = Stereo-&gt;b_parity[i];</a>
<a name="ln3798">                                </a>
<a name="ln3799">            c = c==1? '-' : c==2? '+' : c==3? 'u' : c== 4? '?' : '*';</a>
<a name="ln3800"> </a>
<a name="ln3801">            /*  mark ambuguous stereo bond atom(s) */</a>
<a name="ln3802">            if ( norm_at[j].bAmbiguousStereo &amp;&amp; (c=='+' || c=='-' ) &amp;&amp;</a>
<a name="ln3803">                 (len=strlen(str=inf_norm_at[j].at_string)+1) &lt; (int)sizeof(inf_norm_at[0].at_string) &amp;&amp;</a>
<a name="ln3804">                  str[0] != '!' ) {</a>
<a name="ln3805">                memmove( str+1, str, len );</a>
<a name="ln3806">                str[0] = '!'; /* output the atom in red color */</a>
<a name="ln3807">                bAmbiguousStereoBond ++;</a>
<a name="ln3808">            }</a>
<a name="ln3809">            if ( norm_at[k].bAmbiguousStereo &amp;&amp; (c=='+' || c=='-') &amp;&amp;</a>
<a name="ln3810">                 (len=strlen(str=inf_norm_at[k].at_string)+1) &lt; (int)sizeof(inf_norm_at[0].at_string) &amp;&amp;</a>
<a name="ln3811">                  str[0] != '!' ) {</a>
<a name="ln3812">                memmove( str+1, str, len );</a>
<a name="ln3813">                str[0] = '!'; /* output the atom in red color */</a>
<a name="ln3814">                bAmbiguousStereoBond ++;</a>
<a name="ln3815">            }</a>
<a name="ln3816"> </a>
<a name="ln3817">            /*  find the opposite atom k. */</a>
<a name="ln3818">            /*  Note: since it may be a cumulene, find the shortest(best) path */</a>
<a name="ln3819">            /*  to atom number k to avoid confusion in case of, for example, */</a>
<a name="ln3820">            /*  4-member aromatic rings. */</a>
<a name="ln3821">            best_len = MAX_CUMULENE_LEN+1; /* moved here from inside the cycle 1-8-2003 */</a>
<a name="ln3822">            for ( n = 0; n &lt; norm_at[j].valence; n ++ ) {</a>
<a name="ln3823">                if ( norm_at[j].bond_type[n] == BOND_SINGLE ) {</a>
<a name="ln3824">                    /*  single bond cannot be stereogenic. */</a>
<a name="ln3825">                    continue;</a>
<a name="ln3826">                }</a>
<a name="ln3827">                /* best_len = MAX_CUMULENE_LEN+1; */</a>
<a name="ln3828">                len = 0; /*  number of bonds in cumulene - 1 */</a>
<a name="ln3829">                next_atom[len]  = (int)norm_at[j].neighbor[n];</a>
<a name="ln3830">                next_neigh[len] = n;</a>
<a name="ln3831">                cur_atom = j;</a>
<a name="ln3832">                while ( len &lt; MAX_CUMULENE_LEN &amp;&amp; next_atom[len] != k &amp;&amp; 2 == norm_at[next_atom[len]].valence ) {</a>
<a name="ln3833">                    next_neigh[len+1] = ((int)norm_at[next_atom[len]].neighbor[0] == cur_atom);</a>
<a name="ln3834">                    next_atom[len+1]  =  (int)norm_at[next_atom[len]].neighbor[next_neigh[len+1]];</a>
<a name="ln3835">                    cur_atom = next_atom[len];</a>
<a name="ln3836">                    len ++;</a>
<a name="ln3837">                }</a>
<a name="ln3838">                if ( next_atom[len] == k ) {</a>
<a name="ln3839">                    if ( len &lt; best_len ) {</a>
<a name="ln3840">                        memcpy( best_next_neigh, next_neigh, sizeof(best_next_neigh) );</a>
<a name="ln3841">                        memcpy( best_next_atom,  next_atom,  sizeof(best_next_atom) );</a>
<a name="ln3842">                        best_len = len;</a>
<a name="ln3843">                        num_eql = 0;</a>
<a name="ln3844">                        if ( len == 0 ) {</a>
<a name="ln3845">                            break; /*  path length cannot be smaller than 1 */</a>
<a name="ln3846">                        }</a>
<a name="ln3847">                    } else</a>
<a name="ln3848">                    if ( len == best_len ) {</a>
<a name="ln3849">                        num_eql ++;</a>
<a name="ln3850">                    }</a>
<a name="ln3851">                }</a>
<a name="ln3852">            }</a>
<a name="ln3853">            if ( best_len &lt;= MAX_CUMULENE_LEN &amp;&amp; best_next_atom[best_len] == k ) {</a>
<a name="ln3854">                if ( num_eql ) {</a>
<a name="ln3855">                    num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln3856">                }</a>
<a name="ln3857">                if ( best_len % 2 ) {</a>
<a name="ln3858">                    /*  even number of bonds: chiral atom, draw parity on the cenrtal atom */</a>
<a name="ln3859">                    j = best_next_atom[best_len/2];</a>
<a name="ln3860">                    inf_norm_at[j].cStereoCenterParity = c;</a>
<a name="ln3861">                    str=inf_norm_at[j].at_string;</a>
<a name="ln3862">                    len = strlen(str);</a>
<a name="ln3863">                    if ( len + 3 &lt; (int)sizeof(inf_norm_at[0].at_string) ) {</a>
<a name="ln3864">                        str[len++] = '(';</a>
<a name="ln3865">                        str[len++] = inf_norm_at[j].cStereoCenterParity;</a>
<a name="ln3866">                        str[len++] = ')';</a>
<a name="ln3867">                        str[len] = '\0';</a>
<a name="ln3868">                    }</a>
<a name="ln3869">                } else {</a>
<a name="ln3870">                    /*  odd number of bonds: draw parity on the central bond */</a>
<a name="ln3871">                    if ( best_len == 0 ) {</a>
<a name="ln3872">                        /*  double bond */</a>
<a name="ln3873">                        j = start_at;</a>
<a name="ln3874">                        k = best_next_neigh[0];</a>
<a name="ln3875">                    } else {</a>
<a name="ln3876">                        /*  cumulene */</a>
<a name="ln3877">                        best_len = best_len/2-1;</a>
<a name="ln3878">                        j = best_next_atom[best_len];</a>
<a name="ln3879">                        k = best_next_neigh[best_len+1]; /*  added +1 to display cumulene parity on the middle bond (6-24-2002) */</a>
<a name="ln3880">                    }</a>
<a name="ln3881">                    /*  mark &quot;forward&quot; bond */</a>
<a name="ln3882">                    for ( m = 0; m &lt; MAX_STEREO_BONDS &amp;&amp; inf_norm_at[j].cStereoBondParity[m]; m ++ )</a>
<a name="ln3883">                        ;</a>
<a name="ln3884">                    if ( m &lt; MAX_STEREO_BONDS ) {</a>
<a name="ln3885">                        inf_norm_at[j].cStereoBondParity[m] = c;</a>
<a name="ln3886">                        inf_norm_at[j].cStereoBondNumber[m] = k;</a>
<a name="ln3887">                        inf_norm_at[j].cStereoBondWarning[m]   = bAmbiguousStereoBond;</a>
<a name="ln3888">                    } else {</a>
<a name="ln3889">                        num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln3890">                    }</a>
<a name="ln3891">                    /*  mark &quot;backward&quot; bond */</a>
<a name="ln3892">                    n = norm_at[j].neighbor[k];</a>
<a name="ln3893">                    for ( k = 0; k &lt; norm_at[n].valence &amp;&amp; j != (int)norm_at[n].neighbor[k]; k ++ )</a>
<a name="ln3894">                        ;</a>
<a name="ln3895">                    if ( k &lt; norm_at[n].valence ) {</a>
<a name="ln3896">                        j = n;</a>
<a name="ln3897">                        for ( m = 0; m &lt; MAX_STEREO_BONDS &amp;&amp; inf_norm_at[j].cStereoBondParity[m]; m ++ )</a>
<a name="ln3898">                            ;</a>
<a name="ln3899">                        if ( m &lt; MAX_STEREO_BONDS ) {</a>
<a name="ln3900">                            inf_norm_at[j].cStereoBondParity[m] = c;</a>
<a name="ln3901">                            inf_norm_at[j].cStereoBondNumber[m] = k;</a>
<a name="ln3902">                            inf_norm_at[j].cStereoBondWarning[m]   = bAmbiguousStereoBond;</a>
<a name="ln3903">                        } else {</a>
<a name="ln3904">                            num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln3905">                        }</a>
<a name="ln3906">                    } else {</a>
<a name="ln3907">                        num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln3908">                    }</a>
<a name="ln3909">                }</a>
<a name="ln3910">            } else {</a>
<a name="ln3911">                num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln3912">            }</a>
<a name="ln3913">        }</a>
<a name="ln3914">    }</a>
<a name="ln3915"> </a>
<a name="ln3916">    for ( i = 0; i &lt; init_num_at; i ++ ) {</a>
<a name="ln3917">        /*  canonical numbers */</a>
<a name="ln3918">        if ( inf_norm_at[i].nCanonNbr ) {</a>
<a name="ln3919">            str = inf_norm_at[i].at_string;</a>
<a name="ln3920">            len = strlen(str);</a>
<a name="ln3921">            len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nCanonNbr );</a>
<a name="ln3922">            if ( inf_norm_at[i].nCanonEquNbr || inf_norm_at[i].nTautGroupCanonNbr || (inf_norm_at[i].cFlags &amp; AT_FLAG_ISO_H_POINT) ) {</a>
<a name="ln3923">                if ( inf_norm_at[i].nCanonEquNbr ) {</a>
<a name="ln3924">                    len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nCanonEquNbr );</a>
<a name="ln3925">                } else </a>
<a name="ln3926">                if ( len + 1 &lt; len_str ) {</a>
<a name="ln3927">                    len += 1;</a>
<a name="ln3928">                    strcat( str, &quot;/&quot; );</a>
<a name="ln3929">                }</a>
<a name="ln3930">            }</a>
<a name="ln3931">            /*  tautomeric groups */</a>
<a name="ln3932">            if ( inf_norm_at[i].nTautGroupCanonNbr ) {</a>
<a name="ln3933">                len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nTautGroupCanonNbr );</a>
<a name="ln3934">                if ( inf_norm_at[i].nTautGroupEquNbr ) {</a>
<a name="ln3935">                    len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nTautGroupEquNbr );</a>
<a name="ln3936">                }</a>
<a name="ln3937">            }</a>
<a name="ln3938">            if ( (inf_norm_at[i].cFlags &amp; AT_FLAG_ISO_H_POINT) &amp;&amp; len+2 &lt;= len_str ) {</a>
<a name="ln3939">                str[len++] = '/';</a>
<a name="ln3940">                str[len++] = '*';</a>
<a name="ln3941">                str[len]   = '\0';</a>
<a name="ln3942">            }</a>
<a name="ln3943">#ifdef DISPLAY_DEBUG_DATA</a>
<a name="ln3944">            if ( inf_norm_at[i].nDebugData ) {</a>
<a name="ln3945">                len += (*MakeNumber)( str+len, len_str-len, &quot;`&quot;, (int)inf_norm_at[i].nDebugData );</a>
<a name="ln3946">            }</a>
<a name="ln3947">#endif</a>
<a name="ln3948">        }</a>
<a name="ln3949">    }</a>
<a name="ln3950"> </a>
<a name="ln3951"> </a>
<a name="ln3952">exit_function:</a>
<a name="ln3953"> </a>
<a name="ln3954">    if ( nNormAtNosInCanonOrd )</a>
<a name="ln3955">        inchi_free( nNormAtNosInCanonOrd );</a>
<a name="ln3956"> </a>
<a name="ln3957"> </a>
<a name="ln3958">    return ret;</a>
<a name="ln3959">}                              </a>
<a name="ln3960">/***************************************************************************************/</a>
<a name="ln3961">int FillOutOneCanonInfAtom(inp_ATOM *inp_norm_at, INF_ATOM_DATA *inf_norm_at_data,</a>
<a name="ln3962">                           AT_NUMB *pStereoFlags, int init_num_at, int offset, int offset_H, int bIsotopic,</a>
<a name="ln3963">                           INChI *pINChI, INChI_Aux *pINChI_Aux, int bAbcNumbers, INCHI_MODE nMode)</a>
<a name="ln3964">{</a>
<a name="ln3965">    int          i, j, m, n, num_stereo, k, c, ret, len_str, len, atw, num_err;</a>
<a name="ln3966">    int          next_atom[MAX_CUMULENE_LEN+1], best_next_atom[MAX_CUMULENE_LEN+1], cur_atom;</a>
<a name="ln3967">    int          next_neigh[MAX_CUMULENE_LEN+1], best_next_neigh[MAX_CUMULENE_LEN+1], best_len, bIncludeIsotopicH;</a>
<a name="ln3968">    int          num_iso_H[NUM_H_ISOTOPES];</a>
<a name="ln3969">    char        *str;</a>
<a name="ln3970">    AT_NUMB      g, e;</a>
<a name="ln3971">    int          num_at           = pINChI-&gt;nNumberOfAtoms;</a>
<a name="ln3972">    int          num_H            = init_num_at - num_at; /* number of removed H */</a>
<a name="ln3973">    int          nNumberOfTGroups = (pINChI-&gt;lenTautomer &amp;&amp; pINChI-&gt;nTautomer &amp;&amp; pINChI-&gt;nTautomer[0])? (int)pINChI-&gt;nTautomer[0] : 0;</a>
<a name="ln3974">    AT_NUMB     *nOrigAtNosInCanonOrd;</a>
<a name="ln3975">    INChI_Stereo *Stereo;</a>
<a name="ln3976">    AT_NUMB     *nConstitEquNumbers;</a>
<a name="ln3977">    AT_NUMB     *nConstitEquTGroupNumbers;</a>
<a name="ln3978">    S_CHAR      *t_parity = NULL;</a>
<a name="ln3979">    AT_NUMB     *nNumber = NULL;</a>
<a name="ln3980"> </a>
<a name="ln3981">    AT_NUMB     *nNormAtNosInCanonOrd;</a>
<a name="ln3982">    int (*MakeNumber)(char*, int, const char*, int) = bAbcNumbers? MakeAbcNumber:MakeDecNumber;</a>
<a name="ln3983">    int bRel= (0 != (nMode &amp; ( REQ_MODE_RELATIVE_STEREO)));</a>
<a name="ln3984">    int bRac= (0 != (nMode &amp; ( REQ_MODE_RACEMIC_STEREO)));</a>
<a name="ln3985">    int bRelRac= bRel || bRac;</a>
<a name="ln3986">    int bDoDisplaySp3 = 1;</a>
<a name="ln3987"> </a>
<a name="ln3988">    inf_ATOM *inf_norm_at   = (inf_norm_at_data &amp;&amp; inf_norm_at_data-&gt;at)? inf_norm_at_data-&gt;at+offset : NULL;</a>
<a name="ln3989">    inp_ATOM *norm_at       = inp_norm_at? inp_norm_at + offset : NULL;</a>
<a name="ln3990">    inf_ATOM *inf_norm_at_H = (inf_norm_at_data &amp;&amp; inf_norm_at_data-&gt;at)? inf_norm_at_data-&gt;at+offset_H : NULL;</a>
<a name="ln3991">    inp_ATOM *norm_at_H     = inp_norm_at? inp_norm_at + offset_H : NULL;</a>
<a name="ln3992"> </a>
<a name="ln3993">    ret = 0;</a>
<a name="ln3994">    num_err = 0;</a>
<a name="ln3995"> </a>
<a name="ln3996">    if ( !inf_norm_at )</a>
<a name="ln3997">        return ret;</a>
<a name="ln3998">    /* -- already added in FillOutCompositeCanonInfAtom() --</a>
<a name="ln3999">    if ( bIsotopic ) {</a>
<a name="ln4000">        for ( i = 0, j = 0; i &lt; NUM_H_ISOTOPES; i ++ ) {</a>
<a name="ln4001">            if ( pINChI_Aux-&gt;nNumRemovedIsotopicH[i] ) {</a>
<a name="ln4002">                inf_norm_at_data-&gt;num_iso_H[i] += pINChI_Aux-&gt;nNumRemovedIsotopicH[i];</a>
<a name="ln4003">                inf_norm_at_data-&gt;num_removed_iso_H ++;</a>
<a name="ln4004">            }</a>
<a name="ln4005">        }</a>
<a name="ln4006">    }</a>
<a name="ln4007">    */</a>
<a name="ln4008"> </a>
<a name="ln4009">    if ( bIsotopic &amp;&amp; !(pINChI-&gt;nNumberOfIsotopicAtoms || pINChI-&gt;nNumberOfIsotopicTGroups ||</a>
<a name="ln4010">                        pINChI-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; pINChI-&gt;nPossibleLocationsOfIsotopicH[0]&gt;1) )</a>
<a name="ln4011">        bIsotopic = 0;</a>
<a name="ln4012">    </a>
<a name="ln4013">    Stereo                   = bIsotopic? pINChI-&gt;StereoIsotopic :</a>
<a name="ln4014">                                          pINChI-&gt;Stereo;</a>
<a name="ln4015">    bDoDisplaySp3 = (NULL != Stereo) &amp;&amp; (Stereo-&gt;nNumberOfStereoCenters &gt; 0);</a>
<a name="ln4016"> </a>
<a name="ln4017">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln4018">    if ( bDoDisplaySp3 &amp;&amp; bRelRac &amp;&amp; Stereo-&gt;nNumberOfStereoCenters &lt; 2 &amp;&amp;</a>
<a name="ln4019">         (Stereo-&gt;nCompInv2Abs || ATOM_PARITY_ILL_DEF(Stereo-&gt;t_parity[0]) ) ) {</a>
<a name="ln4020">        bDoDisplaySp3 = 0;</a>
<a name="ln4021">        if ( Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln4022">            inf_norm_at_data-&gt;StereoFlags |= bRel? INF_STEREO_REL : bRac? INF_STEREO_RAC : 0;</a>
<a name="ln4023">        }</a>
<a name="ln4024">    }</a>
<a name="ln4025">#endif    </a>
<a name="ln4026">    /* flag has stereo */</a>
<a name="ln4027">    if ( (NULL != Stereo) &amp;&amp; (bDoDisplaySp3 || Stereo-&gt;nNumberOfStereoBonds &gt; 0) ) {</a>
<a name="ln4028">        (*pStereoFlags) |= INF_STEREO;</a>
<a name="ln4029">    }</a>
<a name="ln4030"> </a>
<a name="ln4031">    /*</a>
<a name="ln4032">    if ( bDoDisplaySp3 &amp;&amp; bRelRac &amp;&amp; Stereo-&gt;nCompInv2Abs &amp;&amp; Stereo-&gt;nNumberOfStereoCenters &lt; 2 ) {</a>
<a name="ln4033">        bDoDisplaySp3 = 0;</a>
<a name="ln4034">    }</a>
<a name="ln4035">    */</a>
<a name="ln4036">    if ( bDoDisplaySp3 &amp;&amp; Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln4037">        /* inversion changes stereo */</a>
<a name="ln4038">        if ( bRel ) {</a>
<a name="ln4039">            (*pStereoFlags) |= INF_STEREO_REL;</a>
<a name="ln4040">        } else</a>
<a name="ln4041">        if ( bRac ) {</a>
<a name="ln4042">            (*pStereoFlags) |= INF_STEREO_RAC;</a>
<a name="ln4043">        } else {</a>
<a name="ln4044">            (*pStereoFlags) |= INF_STEREO_ABS;</a>
<a name="ln4045">        }</a>
<a name="ln4046">        if ( bRelRac ) {</a>
<a name="ln4047">            (*pStereoFlags) |= (Stereo-&gt;nCompInv2Abs &gt; 0)? INF_STEREO_NORM : INF_STEREO_INV;</a>
<a name="ln4048">        }</a>
<a name="ln4049">    }</a>
<a name="ln4050">    if ( bDoDisplaySp3 &amp;&amp; Stereo-&gt;nCompInv2Abs &lt; 0 &amp;&amp; !bRelRac ) {</a>
<a name="ln4051">       /* display Inv stereo which is Absolute Stereo */</a>
<a name="ln4052">        nNumber  = Stereo-&gt;nNumberInv;</a>
<a name="ln4053">        t_parity = Stereo-&gt;t_parityInv;</a>
<a name="ln4054">        nOrigAtNosInCanonOrd     = bIsotopic? pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv :</a>
<a name="ln4055">                                              pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv;</a>
<a name="ln4056">    } else {</a>
<a name="ln4057">       /* display Output stereo which is Absolute Stereo */</a>
<a name="ln4058">        if ( bDoDisplaySp3 ) {</a>
<a name="ln4059">            nNumber  = Stereo-&gt;nNumber;</a>
<a name="ln4060">            t_parity = Stereo-&gt;t_parity;</a>
<a name="ln4061">        }</a>
<a name="ln4062">        nOrigAtNosInCanonOrd     = bIsotopic? pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd :</a>
<a name="ln4063">                                              pINChI_Aux-&gt;nOrigAtNosInCanonOrd;</a>
<a name="ln4064">    }</a>
<a name="ln4065"> </a>
<a name="ln4066">    nConstitEquNumbers       = bIsotopic? pINChI_Aux-&gt;nConstitEquIsotopicNumbers :</a>
<a name="ln4067">                                          pINChI_Aux-&gt;nConstitEquNumbers;</a>
<a name="ln4068">    nConstitEquTGroupNumbers = bIsotopic? pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers :</a>
<a name="ln4069">                                          pINChI_Aux-&gt;nConstitEquTGroupNumbers;</a>
<a name="ln4070">    memset( inf_norm_at,   0, num_at*sizeof(inf_norm_at[0]) );</a>
<a name="ln4071">    if ( num_H &gt; 0 ) {</a>
<a name="ln4072">        memset( inf_norm_at_H, 0, num_H*sizeof(inf_norm_at[0]) );</a>
<a name="ln4073">    }</a>
<a name="ln4074"> </a>
<a name="ln4075">    /*  obtain norm_at[] atom numbers (from zero) in order of canonical numbers */</a>
<a name="ln4076">    nNormAtNosInCanonOrd = (AT_NUMB *)inchi_calloc( num_at, sizeof(nNormAtNosInCanonOrd[0]) );</a>
<a name="ln4077">    if ( ret = GetAtomOrdNbrInCanonOrd( norm_at, nNormAtNosInCanonOrd, nOrigAtNosInCanonOrd, num_at ) ) {</a>
<a name="ln4078">        goto exit_function;</a>
<a name="ln4079">    }</a>
<a name="ln4080">    </a>
<a name="ln4081">    /*  atom canonical and equivalence numbers &gt; 0 */</a>
<a name="ln4082">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4083">        j = (int)nNormAtNosInCanonOrd[i];</a>
<a name="ln4084">        if ( j &lt; 0 || j &gt;= num_at )</a>
<a name="ln4085">            continue;</a>
<a name="ln4086">        inf_norm_at[j].nCanonNbr = (AT_NUMB)(i+1);</a>
<a name="ln4087">        inf_norm_at[j].nCanonEquNbr = nConstitEquNumbers[i];</a>
<a name="ln4088">#ifdef DISPLAY_DEBUG_DATA</a>
<a name="ln4089">        inf_norm_at[j].nDebugData = 0;</a>
<a name="ln4090">#if ( DISPLAY_DEBUG_DATA == DISPLAY_DEBUG_DATA_C_POINT )</a>
<a name="ln4091">        inf_norm_at[j].nDebugData = norm_at[j].c_point;</a>
<a name="ln4092">#endif</a>
<a name="ln4093">#endif</a>
<a name="ln4094">    }</a>
<a name="ln4095">    /*  tautomeric groups */</a>
<a name="ln4096">    if ( nNumberOfTGroups ) {</a>
<a name="ln4097">        /*</a>
<a name="ln4098">         :   start from 1: bypass number of t-groups</a>
<a name="ln4099">         :   j is a counter within the current t-group</a>
<a name="ln4100">         :   g is a tautomeric group canonical number</a>
<a name="ln4101">         :   e is a tautomeric group equivalence</a>
<a name="ln4102">         */</a>
<a name="ln4103">        for ( g = 1, i = 1; g &lt;= nNumberOfTGroups; g ++ ) {</a>
<a name="ln4104">            n = (int)pINChI-&gt;nTautomer[i] - INCHI_T_NUM_MOVABLE; /*  number of atoms in t-group */</a>
<a name="ln4105">            e = nConstitEquTGroupNumbers[(int)g - 1];</a>
<a name="ln4106">            /*  bypass number of hydrogen atoms, negative charges, ... */</a>
<a name="ln4107">            for ( i += INCHI_T_NUM_MOVABLE+1, j = 0; j &lt; n &amp;&amp; i &lt; pINChI-&gt;lenTautomer; j ++, i ++ ) {</a>
<a name="ln4108">                /*  scan canonical numbers of atoms within the atom t-group */</a>
<a name="ln4109">                k = (int)nNormAtNosInCanonOrd[(int)pINChI-&gt;nTautomer[i]-1];</a>
<a name="ln4110">                inf_norm_at[k].nTautGroupCanonNbr = g;</a>
<a name="ln4111">                inf_norm_at[k].nTautGroupEquNbr   = e;</a>
<a name="ln4112">            }</a>
<a name="ln4113">        }</a>
<a name="ln4114">        if ( i != pINChI-&gt;lenTautomer || g != nNumberOfTGroups+1 ) {</a>
<a name="ln4115">            ret = CT_TAUCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln4116">            goto exit_function;</a>
<a name="ln4117">        }</a>
<a name="ln4118">    }</a>
<a name="ln4119">    /* atoms that may exchange isotopic H */</a>
<a name="ln4120">    if ( bIsotopic &amp;&amp; pINChI-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; (n = (int)pINChI-&gt;nPossibleLocationsOfIsotopicH[0]) ) {</a>
<a name="ln4121">        for ( i = 1; i &lt; n; i ++ ) {</a>
<a name="ln4122">            j = (int)pINChI-&gt;nPossibleLocationsOfIsotopicH[i];</a>
<a name="ln4123">            k = (int)nNormAtNosInCanonOrd[j - 1];</a>
<a name="ln4124">            if ( !inf_norm_at[k].nTautGroupCanonNbr ) {</a>
<a name="ln4125">                inf_norm_at[k].cFlags |= AT_FLAG_ISO_H_POINT;</a>
<a name="ln4126">            }</a>
<a name="ln4127">        }</a>
<a name="ln4128">    }</a>
<a name="ln4129">#if ( DISPLAY_RING_SYSTEMS == 1 )</a>
<a name="ln4130">    /*  debug only */</a>
<a name="ln4131">    for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln4132">        inf_norm_at[j].nCanonNbr          = norm_at[j].nBlockSystem;</a>
<a name="ln4133">        inf_norm_at[j].nCanonEquNbr       = norm_at[j].nRingSystem;</a>
<a name="ln4134">#if ( USE_DISTANCES_FOR_RANKING == 1 )</a>
<a name="ln4135">        inf_norm_at[j].nTautGroupCanonNbr   = norm_at[j].nDistanceFromTerminal;</a>
<a name="ln4136">        inf_norm_at[j].nTautGroupEquNbr     = norm_at[j].bCutVertex;</a>
<a name="ln4137">#else</a>
<a name="ln4138">        inf_norm_at[j].nTautGroupCanonNbr   = norm_at[j].bCutVertex;</a>
<a name="ln4139">        inf_norm_at[j].nTautGroupEquNbr   = 0;</a>
<a name="ln4140">#endif</a>
<a name="ln4141">    }</a>
<a name="ln4142">#endif</a>
<a name="ln4143"> </a>
<a name="ln4144"> </a>
<a name="ln4145"> </a>
<a name="ln4146">    /*  Write isotopic mass, chemical element symbols and hydrogens, charge, radical, canon. numbers */</a>
<a name="ln4147">    len_str = sizeof(inf_norm_at[0].at_string);</a>
<a name="ln4148">    for ( i = 0; i &lt; init_num_at; i ++ ) {</a>
<a name="ln4149">        inf_ATOM *cur_inf_norm_at = (i &lt; num_at)? inf_norm_at+i : inf_norm_at_H+i-num_at;</a>
<a name="ln4150">        inp_ATOM *cur_norm_at     = (i &lt; num_at)? norm_at    +i : norm_at_H    +i-num_at;</a>
<a name="ln4151">        str = cur_inf_norm_at-&gt;at_string;</a>
<a name="ln4152">        len = 0;</a>
<a name="ln4153">        bIncludeIsotopicH = bIsotopic &amp;&amp; (i &gt;= num_at || !inf_norm_at[i].nTautGroupCanonNbr &amp;&amp; !(inf_norm_at[i].cFlags &amp; AT_FLAG_ISO_H_POINT));</a>
<a name="ln4154">        /*  isotopic mass */</a>
<a name="ln4155">        atw = 0;</a>
<a name="ln4156">        if ( cur_norm_at-&gt;iso_atw_diff &amp;&amp; bIsotopic ) {</a>
<a name="ln4157">            if ( cur_norm_at-&gt;at_type == ATT_PROTON ) {</a>
<a name="ln4158">                ; /* do not set isotopic mass of a tautomeric proton */</a>
<a name="ln4159">            } else</a>
<a name="ln4160">            if ( num_at &lt;= i &amp;&amp; cur_norm_at-&gt;el_number == PERIODIC_NUMBER_H &amp;&amp; cur_norm_at-&gt;chem_bonds_valence == 1 &amp;&amp;</a>
<a name="ln4161">                 !cur_norm_at-&gt;charge &amp;&amp; !cur_norm_at-&gt;radical &amp;&amp; !cur_norm_at-&gt;num_H &amp;&amp;</a>
<a name="ln4162">                 0 &lt;= (j=(int)cur_norm_at-&gt;neighbor[0]-offset) &amp;&amp; j &lt; num_at &amp;&amp;</a>
<a name="ln4163">                 (inf_norm_at[j].nTautGroupCanonNbr || (inf_norm_at[j].cFlags &amp; AT_FLAG_ISO_H_POINT) ) ) {</a>
<a name="ln4164">                ; /* do not set isotopic mass of an exchangeable proton */</a>
<a name="ln4165">            } else {</a>
<a name="ln4166">                atw = get_atw(cur_norm_at-&gt;elname);</a>
<a name="ln4167">                atw += (cur_norm_at-&gt;iso_atw_diff&gt;0)? cur_norm_at-&gt;iso_atw_diff-1:cur_norm_at-&gt;iso_atw_diff;</a>
<a name="ln4168">                /*len += sprintf( str+len, &quot;^%d&quot;, atw );*/</a>
<a name="ln4169">            }</a>
<a name="ln4170">        }</a>
<a name="ln4171">        /*  element name */</a>
<a name="ln4172">        if ( cur_norm_at-&gt;el_number == PERIODIC_NUMBER_H &amp;&amp; 2 &lt;= atw &amp;&amp; atw &lt;= 3 ) {</a>
<a name="ln4173">            len += sprintf( str+len, &quot;%s&quot;, atw==2? &quot;D&quot; : &quot;T&quot; );</a>
<a name="ln4174">        } else {</a>
<a name="ln4175">            if ( atw ) {</a>
<a name="ln4176">                len += sprintf( str+len, &quot;^%d&quot;, atw );</a>
<a name="ln4177">            }</a>
<a name="ln4178">            len += sprintf( str+len, &quot;%s&quot;, cur_norm_at-&gt;elname );</a>
<a name="ln4179">        }</a>
<a name="ln4180">        /*  hydrogens */</a>
<a name="ln4181">        /*  find number of previuosly removed terminal hydrogen atoms */</a>
<a name="ln4182">        for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln4183">            num_iso_H[j] = cur_norm_at-&gt;num_iso_H[j];</a>
<a name="ln4184">        }</a>
<a name="ln4185">        for ( j = 0, n = (int)cur_norm_at-&gt;num_H; j &lt; num_H; j ++ ) {</a>
<a name="ln4186">            /*  subtract number of removed terminal */</a>
<a name="ln4187">            /*  H atoms from the total number of H atoms */</a>
<a name="ln4188">            if ( i == (int)norm_at_H[j].neighbor[0]-offset ) {</a>
<a name="ln4189">                n -= 1;</a>
<a name="ln4190">                m = (int)norm_at_H[j].iso_atw_diff-1;</a>
<a name="ln4191">                if ( 0 &lt;= m &amp;&amp; m &lt; NUM_H_ISOTOPES ) {</a>
<a name="ln4192">                    /*  subtract number of removed terminal isotopic */</a>
<a name="ln4193">                    /*  H atoms from the total number of isotopic H atoms */</a>
<a name="ln4194">                    num_iso_H[m] -= 1;</a>
<a name="ln4195">                }</a>
<a name="ln4196">            }</a>
<a name="ln4197">        }</a>
<a name="ln4198">        if ( bIncludeIsotopicH ) {</a>
<a name="ln4199">            /*  subtract number of isotopic H atoms from the total number of H atoms */</a>
<a name="ln4200">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln4201">                n -= num_iso_H[j];</a>
<a name="ln4202">            }</a>
<a name="ln4203">        }</a>
<a name="ln4204">        /*  non-isotopic hydrogen atoms */</a>
<a name="ln4205">        if ( n &gt; 1 ) {</a>
<a name="ln4206">            len += sprintf( str+len, &quot;H%d&quot;, n );</a>
<a name="ln4207">        } else</a>
<a name="ln4208">        if ( n == 1 ) {</a>
<a name="ln4209">            len += sprintf( str+len, &quot;H&quot; );</a>
<a name="ln4210">        }</a>
<a name="ln4211">        /*  isotopic hydrogen atoms */</a>
<a name="ln4212">        if ( bIncludeIsotopicH ) {</a>
<a name="ln4213">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln4214">                if ( num_iso_H[j] ) {</a>
<a name="ln4215">                    if ( j == 0 || j != 1 &amp;&amp; j != 2 ) {</a>
<a name="ln4216">                        len += sprintf( str+len, &quot;^%dH&quot;, j+1 );</a>
<a name="ln4217">                    } else {</a>
<a name="ln4218">                        len += sprintf( str+len, j == 1? &quot;D&quot; : &quot;T&quot; );</a>
<a name="ln4219">                    }</a>
<a name="ln4220">                    if ( num_iso_H[j] != 1 ) {</a>
<a name="ln4221">                        len += sprintf( str+len, &quot;%d&quot;, (int)num_iso_H[j] );</a>
<a name="ln4222">                    }</a>
<a name="ln4223">                }</a>
<a name="ln4224">            }</a>
<a name="ln4225">        }</a>
<a name="ln4226">        if ( cur_norm_at-&gt;el_number == PERIODIC_NUMBER_H &amp;&amp; str[0] == str[1] ) {</a>
<a name="ln4227">            char *q;</a>
<a name="ln4228">            if ( !str[2] ) {</a>
<a name="ln4229">                str[1] = '2';  /* quick fix: replace HH with H2 */</a>
<a name="ln4230">            } else</a>
<a name="ln4231">            if ( isdigit( UCINT str[2] ) &amp;&amp; (n = strtol( str+2, &amp;q, 10 )) &amp;&amp; !q[0] ) {</a>
<a name="ln4232">                len = 1 + sprintf( str+1, &quot;%d&quot;, n+1 );</a>
<a name="ln4233">            }</a>
<a name="ln4234">        }</a>
<a name="ln4235">        /*  charge */</a>
<a name="ln4236">        if ( abs(cur_norm_at-&gt;charge) &gt; 1 )</a>
<a name="ln4237">            len += sprintf( str+len, &quot;%+d&quot;, cur_norm_at-&gt;charge );</a>
<a name="ln4238">        else</a>
<a name="ln4239">        if ( abs(cur_norm_at-&gt;charge) == 1 )</a>
<a name="ln4240">            len += sprintf( str+len, &quot;%s&quot;, cur_norm_at-&gt;charge&gt;0? &quot;+&quot; : &quot;-&quot; );</a>
<a name="ln4241">        /*  radical */</a>
<a name="ln4242">        if ( cur_norm_at-&gt;radical )</a>
<a name="ln4243">            len += sprintf( str+len, &quot;%s&quot;, cur_norm_at-&gt;radical==RADICAL_SINGLET? &quot;:&quot; :</a>
<a name="ln4244">                                           cur_norm_at-&gt;radical==RADICAL_DOUBLET? &quot;.&quot; :</a>
<a name="ln4245">                                           cur_norm_at-&gt;radical==RADICAL_TRIPLET? &quot;..&quot; : &quot;?&quot;);</a>
<a name="ln4246">    }</a>
<a name="ln4247"> </a>
<a name="ln4248">    /*  stereogenic centers */</a>
<a name="ln4249">    if ( bDoDisplaySp3 &amp;&amp; Stereo &amp;&amp; 0 &lt; (num_stereo = Stereo-&gt;nNumberOfStereoCenters) ) {</a>
<a name="ln4250">        for ( i = 0; i &lt; num_stereo; i ++ ) {</a>
<a name="ln4251">            j = (int)nNormAtNosInCanonOrd[(int)nNumber[i]-1];</a>
<a name="ln4252">            c = t_parity[i];</a>
<a name="ln4253">            c = c==1? '-' : c==2? '+' : c==3? 'u' : c== 4? '?' : '*';</a>
<a name="ln4254">            inf_norm_at[j].cStereoCenterParity = c;</a>
<a name="ln4255">            str=inf_norm_at[j].at_string;</a>
<a name="ln4256">            len = strlen(str);</a>
<a name="ln4257">            if ( len + 3 &lt; (int)sizeof(inf_norm_at[0].at_string) ) {</a>
<a name="ln4258">                str[len++] = '(';</a>
<a name="ln4259">                str[len++] = inf_norm_at[j].cStereoCenterParity;</a>
<a name="ln4260">                str[len++] = ')';</a>
<a name="ln4261">                str[len] = '\0';</a>
<a name="ln4262">                /*  mark ambuguous stereo center */</a>
<a name="ln4263">                if ( norm_at[j].bAmbiguousStereo &amp;&amp; (c=='+' || c=='-' || c=='?') &amp;&amp;  str[0] != '!' &amp;&amp;</a>
<a name="ln4264">                     len+1 &lt; (int)sizeof(inf_norm_at[0].at_string) ) {</a>
<a name="ln4265">                    memmove( str+1, str, len+1 );</a>
<a name="ln4266">                    str[0] = '!'; /* output the atom in red color */</a>
<a name="ln4267">                }</a>
<a name="ln4268">            }</a>
<a name="ln4269">        }</a>
<a name="ln4270">    }</a>
<a name="ln4271">    </a>
<a name="ln4272">    /*  stereogenic bonds */</a>
<a name="ln4273">    /*  (cumulenes with odd number of double bonds are stereocenters, */</a>
<a name="ln4274">    /*   and atom parity should be set) */</a>
<a name="ln4275">    if ( Stereo &amp;&amp; 0 &lt; (num_stereo = Stereo-&gt;nNumberOfStereoBonds) ) {</a>
<a name="ln4276">        for ( i = 0; i &lt; num_stereo; i ++ ) {</a>
<a name="ln4277">            int start_at, num_eql=0, bAmbiguousStereoBond = 0;</a>
<a name="ln4278">            j = (int)nNormAtNosInCanonOrd[(int)Stereo-&gt;nBondAtom1[i]-1];</a>
<a name="ln4279">            k = (int)nNormAtNosInCanonOrd[(int)Stereo-&gt;nBondAtom2[i]-1];</a>
<a name="ln4280">            start_at = j;</a>
<a name="ln4281">            c = Stereo-&gt;b_parity[i];</a>
<a name="ln4282">                                </a>
<a name="ln4283">            c = c==1? '-' : c==2? '+' : c==3? 'u' : c== 4? '?' : '*';</a>
<a name="ln4284"> </a>
<a name="ln4285">            /*  mark ambuguous stereo bond atom(s) */</a>
<a name="ln4286">            if ( norm_at[j].bAmbiguousStereo &amp;&amp; (c=='+' || c=='-' ) &amp;&amp;</a>
<a name="ln4287">                 (len=strlen(str=inf_norm_at[j].at_string)+1) &lt; (int)sizeof(inf_norm_at[0].at_string) &amp;&amp;</a>
<a name="ln4288">                  str[0] != '!' ) {</a>
<a name="ln4289">                memmove( str+1, str, len );</a>
<a name="ln4290">                str[0] = '!'; /* output the atom in red color */</a>
<a name="ln4291">                bAmbiguousStereoBond ++;</a>
<a name="ln4292">            }</a>
<a name="ln4293">            if ( norm_at[k].bAmbiguousStereo &amp;&amp; (c=='+' || c=='-') &amp;&amp;</a>
<a name="ln4294">                 (len=strlen(str=inf_norm_at[k].at_string)+1) &lt; (int)sizeof(inf_norm_at[0].at_string) &amp;&amp;</a>
<a name="ln4295">                  str[0] != '!' ) {</a>
<a name="ln4296">                memmove( str+1, str, len );</a>
<a name="ln4297">                str[0] = '!'; /* output the atom in red color */</a>
<a name="ln4298">                bAmbiguousStereoBond ++;</a>
<a name="ln4299">            }</a>
<a name="ln4300"> </a>
<a name="ln4301">            /*  find the opposite atom k. */</a>
<a name="ln4302">            /*  Note: since it may be a cumulene, find the shortest(best) path */</a>
<a name="ln4303">            /*  to atom number k to avoid confusion in case of, for example, */</a>
<a name="ln4304">            /*  4-member aromatic rings. */</a>
<a name="ln4305">            best_len = MAX_CUMULENE_LEN+1; /* moved here from inside the cycle 1-8-2003 */</a>
<a name="ln4306">            for ( n = 0; n &lt; norm_at[j].valence; n ++ ) {</a>
<a name="ln4307">                if ( norm_at[j].bond_type[n] == BOND_SINGLE ) {</a>
<a name="ln4308">                    /*  single bond cannot be stereogenic. */</a>
<a name="ln4309">                    continue;</a>
<a name="ln4310">                }</a>
<a name="ln4311">                /* best_len = MAX_CUMULENE_LEN+1; */</a>
<a name="ln4312">                len = 0; /*  number of bonds in cumulene - 1 */</a>
<a name="ln4313">                next_atom[len]  = (int)norm_at[j].neighbor[n]-offset;</a>
<a name="ln4314">                next_neigh[len] = n;</a>
<a name="ln4315">                cur_atom = j;</a>
<a name="ln4316">                while ( len &lt; MAX_CUMULENE_LEN &amp;&amp; next_atom[len] != k &amp;&amp; 2 == norm_at[next_atom[len]].valence ) {</a>
<a name="ln4317">                    next_neigh[len+1] = ((int)norm_at[next_atom[len]].neighbor[0]-offset == cur_atom);</a>
<a name="ln4318">                    next_atom[len+1]  =  (int)norm_at[next_atom[len]].neighbor[next_neigh[len+1]]-offset;</a>
<a name="ln4319">                    cur_atom = next_atom[len];</a>
<a name="ln4320">                    len ++;</a>
<a name="ln4321">                }</a>
<a name="ln4322">                if ( next_atom[len] == k ) {</a>
<a name="ln4323">                    if ( len &lt; best_len ) {</a>
<a name="ln4324">                        memcpy( best_next_neigh, next_neigh, sizeof(best_next_neigh) );</a>
<a name="ln4325">                        memcpy( best_next_atom,  next_atom,  sizeof(best_next_atom) );</a>
<a name="ln4326">                        best_len = len;</a>
<a name="ln4327">                        num_eql = 0;</a>
<a name="ln4328">                        if ( len == 0 ) {</a>
<a name="ln4329">                            break; /*  path length cannot be smaller than 1 */</a>
<a name="ln4330">                        }</a>
<a name="ln4331">                    } else</a>
<a name="ln4332">                    if ( len == best_len ) {</a>
<a name="ln4333">                        num_eql ++;</a>
<a name="ln4334">                    }</a>
<a name="ln4335">                }</a>
<a name="ln4336">            }</a>
<a name="ln4337">            if ( best_len &lt;= MAX_CUMULENE_LEN &amp;&amp; best_next_atom[best_len] == k ) {</a>
<a name="ln4338">                if ( num_eql ) {</a>
<a name="ln4339">                    num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln4340">                }</a>
<a name="ln4341">                if ( best_len % 2 ) {</a>
<a name="ln4342">                    /*  even number of bonds: chiral atom, draw parity on the cenrtal atom */</a>
<a name="ln4343">                    j = best_next_atom[best_len/2];</a>
<a name="ln4344">                    inf_norm_at[j].cStereoCenterParity = c;</a>
<a name="ln4345">                    str=inf_norm_at[j].at_string;</a>
<a name="ln4346">                    len = strlen(str);</a>
<a name="ln4347">                    if ( len + 3 &lt; (int)sizeof(inf_norm_at[0].at_string) ) {</a>
<a name="ln4348">                        str[len++] = '(';</a>
<a name="ln4349">                        str[len++] = inf_norm_at[j].cStereoCenterParity;</a>
<a name="ln4350">                        str[len++] = ')';</a>
<a name="ln4351">                        str[len] = '\0';</a>
<a name="ln4352">                    }</a>
<a name="ln4353">                } else {</a>
<a name="ln4354">                    /*  odd number of bonds: draw parity on the central bond */</a>
<a name="ln4355">                    if ( best_len == 0 ) {</a>
<a name="ln4356">                        /*  double bond */</a>
<a name="ln4357">                        j = start_at;</a>
<a name="ln4358">                        k = best_next_neigh[0];</a>
<a name="ln4359">                    } else {</a>
<a name="ln4360">                        /*  cumulene */</a>
<a name="ln4361">                        best_len = best_len/2-1;</a>
<a name="ln4362">                        j = best_next_atom[best_len];</a>
<a name="ln4363">                        k = best_next_neigh[best_len+1]; /*  added +1 to display cumulene parity on the middle bond (6-24-2002) */</a>
<a name="ln4364">                    }</a>
<a name="ln4365">                    /*  mark &quot;forward&quot; bond */</a>
<a name="ln4366">                    for ( m = 0; m &lt; MAX_STEREO_BONDS &amp;&amp; inf_norm_at[j].cStereoBondParity[m]; m ++ )</a>
<a name="ln4367">                        ;</a>
<a name="ln4368">                    if ( m &lt; MAX_STEREO_BONDS ) {</a>
<a name="ln4369">                        inf_norm_at[j].cStereoBondParity[m] = c;</a>
<a name="ln4370">                        inf_norm_at[j].cStereoBondNumber[m] = k;</a>
<a name="ln4371">                        inf_norm_at[j].cStereoBondWarning[m]  = bAmbiguousStereoBond;</a>
<a name="ln4372">                    } else {</a>
<a name="ln4373">                        num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln4374">                    }</a>
<a name="ln4375">                    /*  mark &quot;backward&quot; bond */</a>
<a name="ln4376">                    n = norm_at[j].neighbor[k]-offset;</a>
<a name="ln4377">                    for ( k = 0; k &lt; norm_at[n].valence &amp;&amp; j != (int)norm_at[n].neighbor[k]-offset; k ++ )</a>
<a name="ln4378">                        ;</a>
<a name="ln4379">                    if ( k &lt; norm_at[n].valence ) {</a>
<a name="ln4380">                        j = n;</a>
<a name="ln4381">                        for ( m = 0; m &lt; MAX_STEREO_BONDS &amp;&amp; inf_norm_at[j].cStereoBondParity[m]; m ++ )</a>
<a name="ln4382">                            ;</a>
<a name="ln4383">                        if ( m &lt; MAX_STEREO_BONDS ) {</a>
<a name="ln4384">                            inf_norm_at[j].cStereoBondParity[m] = c;</a>
<a name="ln4385">                            inf_norm_at[j].cStereoBondNumber[m] = k;</a>
<a name="ln4386">                            inf_norm_at[j].cStereoBondWarning[m]   = bAmbiguousStereoBond;</a>
<a name="ln4387">                        } else {</a>
<a name="ln4388">                            num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln4389">                        }</a>
<a name="ln4390">                    } else {</a>
<a name="ln4391">                        num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln4392">                    }</a>
<a name="ln4393">                }</a>
<a name="ln4394">            } else {</a>
<a name="ln4395">                num_err ++;  /*  program error; no breakpoint here */</a>
<a name="ln4396">            }</a>
<a name="ln4397">        }</a>
<a name="ln4398">    }</a>
<a name="ln4399"> </a>
<a name="ln4400">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4401">        /*  canonical numbers */</a>
<a name="ln4402">        if ( inf_norm_at[i].nCanonNbr ) {</a>
<a name="ln4403">            str = inf_norm_at[i].at_string;</a>
<a name="ln4404">            len = strlen(str);</a>
<a name="ln4405">            len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nCanonNbr );</a>
<a name="ln4406">            if ( inf_norm_at[i].nCanonEquNbr || inf_norm_at[i].nTautGroupCanonNbr || (inf_norm_at[i].cFlags &amp; AT_FLAG_ISO_H_POINT) ) {</a>
<a name="ln4407">                if ( inf_norm_at[i].nCanonEquNbr ) {</a>
<a name="ln4408">                    len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nCanonEquNbr );</a>
<a name="ln4409">                } else </a>
<a name="ln4410">                if ( len + 1 &lt; len_str ) {</a>
<a name="ln4411">                    len += 1;</a>
<a name="ln4412">                    strcat( str, &quot;/&quot; );</a>
<a name="ln4413">                }</a>
<a name="ln4414">            }</a>
<a name="ln4415">            /*  tautomeric groups */</a>
<a name="ln4416">            if ( inf_norm_at[i].nTautGroupCanonNbr ) {</a>
<a name="ln4417">                len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nTautGroupCanonNbr );</a>
<a name="ln4418">                if ( inf_norm_at[i].nTautGroupEquNbr ) {</a>
<a name="ln4419">                    len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_norm_at[i].nTautGroupEquNbr );</a>
<a name="ln4420">                }</a>
<a name="ln4421">            }</a>
<a name="ln4422">            if ( (inf_norm_at[i].cFlags &amp; AT_FLAG_ISO_H_POINT) &amp;&amp; len+2 &lt;= len_str ) {</a>
<a name="ln4423">                str[len++] = '/';</a>
<a name="ln4424">                str[len++] = '*';</a>
<a name="ln4425">                str[len]   = '\0';</a>
<a name="ln4426">            }</a>
<a name="ln4427">#ifdef DISPLAY_DEBUG_DATA</a>
<a name="ln4428">            if ( inf_norm_at[i].nDebugData ) {</a>
<a name="ln4429">                len += (*MakeNumber)( str+len, len_str-len, &quot;`&quot;, (int)inf_norm_at[i].nDebugData );</a>
<a name="ln4430">            }</a>
<a name="ln4431">#endif</a>
<a name="ln4432">        }</a>
<a name="ln4433">    }</a>
<a name="ln4434"> </a>
<a name="ln4435"> </a>
<a name="ln4436">exit_function:</a>
<a name="ln4437"> </a>
<a name="ln4438">    if ( nNormAtNosInCanonOrd )</a>
<a name="ln4439">        inchi_free( nNormAtNosInCanonOrd );</a>
<a name="ln4440"> </a>
<a name="ln4441">    return ret;</a>
<a name="ln4442">}</a>
<a name="ln4443"> </a>
<a name="ln4444">/***************************************************************************************/</a>
<a name="ln4445">int FillOutInputInfAtom(inp_ATOM *inp_at, INF_ATOM_DATA *inf_at_data, int init_num_at, int num_removed_H,</a>
<a name="ln4446">                        int bAdd_DT_to_num_H, int nNumRemovedProtons, NUM_H *nNumRemovedProtonsIsotopic, int bIsotopic, int bAbcNumbers)</a>
<a name="ln4447">{</a>
<a name="ln4448">    int          i, j, m, n, ret, len_str, len, atw;</a>
<a name="ln4449">    int          num_iso_H[NUM_H_ISOTOPES];</a>
<a name="ln4450">    char        *str;</a>
<a name="ln4451">    int          num_at           = init_num_at - num_removed_H;</a>
<a name="ln4452">    int (*MakeNumber)(char*, int, const char*, int) = MakeDecNumber;</a>
<a name="ln4453"> </a>
<a name="ln4454">    inf_ATOM *inf_at = inf_at_data? inf_at_data-&gt;at : NULL;</a>
<a name="ln4455"> </a>
<a name="ln4456"> </a>
<a name="ln4457">    ret = 0;</a>
<a name="ln4458">    </a>
<a name="ln4459"> </a>
<a name="ln4460">    if ( !inf_at )</a>
<a name="ln4461">        return ret;</a>
<a name="ln4462"> </a>
<a name="ln4463">    memset( inf_at, 0, init_num_at*sizeof(inf_at[0]) );</a>
<a name="ln4464"> </a>
<a name="ln4465">    inf_at_data-&gt;nNumRemovedProtons = nNumRemovedProtons;</a>
<a name="ln4466">    MakeRemovedProtonsString( nNumRemovedProtons, nNumRemovedProtonsIsotopic, NULL, bIsotopic, inf_at_data-&gt;szRemovedProtons, NULL );</a>
<a name="ln4467">    /*  atom canonical and equivalence numbers &gt; 0 */</a>
<a name="ln4468">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4469">#if ( DISPLAY_ORIG_AT_NUMBERS == 1 )</a>
<a name="ln4470">        inf_at[i].nCanonNbr = inp_at[i].orig_at_number;</a>
<a name="ln4471">#else</a>
<a name="ln4472">        inf_at[i].nCanonNbr = (AT_NUMB)(i+1);</a>
<a name="ln4473">#endif</a>
<a name="ln4474">    }</a>
<a name="ln4475">    /*  Write isotopic mass, chemical element symbols and hydrogens, charge, radical, canon. numbers */</a>
<a name="ln4476">    len_str = sizeof(inf_at[0].at_string);</a>
<a name="ln4477">    for ( i = 0; i &lt; init_num_at; i ++ ) {</a>
<a name="ln4478">        str = inf_at[i].at_string;</a>
<a name="ln4479">        len = 0;</a>
<a name="ln4480">        /*  isotopic mass */</a>
<a name="ln4481">        atw = 0;</a>
<a name="ln4482">        if ( inp_at[i].iso_atw_diff &amp;&amp; bIsotopic ) {</a>
<a name="ln4483">            atw = get_atw(inp_at[i].elname);</a>
<a name="ln4484">            atw += (inp_at[i].iso_atw_diff&gt;0)? inp_at[i].iso_atw_diff-1:inp_at[i].iso_atw_diff;</a>
<a name="ln4485">            /*len += sprintf( str+len, &quot;^%d&quot;, atw );*/</a>
<a name="ln4486">        }</a>
<a name="ln4487">        /*  element name */</a>
<a name="ln4488">        if ( inp_at[i].el_number == PERIODIC_NUMBER_H &amp;&amp; 2 &lt;= atw &amp;&amp; atw &lt;= 3 ) {</a>
<a name="ln4489">            len += sprintf( str+len, &quot;%s&quot;, atw==2? &quot;D&quot; : &quot;T&quot; );</a>
<a name="ln4490">        } else {</a>
<a name="ln4491">            if ( atw ) {</a>
<a name="ln4492">                len += sprintf( str+len, &quot;^%d&quot;, atw );</a>
<a name="ln4493">            }</a>
<a name="ln4494">            len += sprintf( str+len, &quot;%s&quot;, inp_at[i].elname );</a>
<a name="ln4495">        }</a>
<a name="ln4496">        /*  hydrogens */</a>
<a name="ln4497">        /*  find number of previuosly removed terminal hydrogen atoms */</a>
<a name="ln4498">        for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln4499">            num_iso_H[j] = inp_at[i].num_iso_H[j];</a>
<a name="ln4500">        }</a>
<a name="ln4501">        for ( j = num_at, n = (int)inp_at[i].num_H; j &lt; init_num_at; j ++ ) {</a>
<a name="ln4502">            /*  subtract number of removed terminal */</a>
<a name="ln4503">            /*  H atoms from the total number of H atoms */</a>
<a name="ln4504">            if ( i == (int)inp_at[j].neighbor[0] ) {</a>
<a name="ln4505">                n -= 1;</a>
<a name="ln4506">                m = (int)inp_at[j].iso_atw_diff-1;</a>
<a name="ln4507">                if ( 0 &lt;= m &amp;&amp; m &lt; NUM_H_ISOTOPES ) {</a>
<a name="ln4508">                    /*  subtract number of removed terminal isotopic */</a>
<a name="ln4509">                    /*  H atoms from the total number of isotopic H atoms */</a>
<a name="ln4510">                    num_iso_H[m] -= 1;</a>
<a name="ln4511">                }</a>
<a name="ln4512">            }</a>
<a name="ln4513">        }</a>
<a name="ln4514">        if ( bIsotopic &amp;&amp; !bAdd_DT_to_num_H ) {</a>
<a name="ln4515">            /*  subtract number of isotopic H atoms from the total number of H atoms */</a>
<a name="ln4516">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln4517">                n -= num_iso_H[j];</a>
<a name="ln4518">            }</a>
<a name="ln4519">        }</a>
<a name="ln4520">        /*  non-isotopic hydrogen atoms */</a>
<a name="ln4521">        if ( n &gt; 1 ) {</a>
<a name="ln4522">            len += sprintf( str+len, &quot;H%d&quot;, n );</a>
<a name="ln4523">        } else</a>
<a name="ln4524">        if ( n == 1 ) {</a>
<a name="ln4525">            len += sprintf( str+len, &quot;H&quot; ); /* fixed 12-21-2002: removed 3rd argument */</a>
<a name="ln4526">        }</a>
<a name="ln4527">        if ( bIsotopic ) {</a>
<a name="ln4528">            /*  isotopic hydrogen atoms */</a>
<a name="ln4529">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln4530">                if ( num_iso_H[j] ) {</a>
<a name="ln4531">                    if ( j == 0 || j != 1 &amp;&amp; j != 2 ) {</a>
<a name="ln4532">                        len += sprintf( str+len, &quot;^%dH&quot;, j+1 );</a>
<a name="ln4533">                    } else {</a>
<a name="ln4534">                        len += sprintf( str+len, j == 1? &quot;D&quot; : &quot;T&quot; );</a>
<a name="ln4535">                    }</a>
<a name="ln4536">                    if ( num_iso_H[j] != 1 ) {</a>
<a name="ln4537">                        len += sprintf( str+len, &quot;%d&quot;, (int)num_iso_H[j] );</a>
<a name="ln4538">                    }</a>
<a name="ln4539">                }</a>
<a name="ln4540">            }</a>
<a name="ln4541">        }</a>
<a name="ln4542">        if ( inp_at[i].el_number == PERIODIC_NUMBER_H &amp;&amp; str[0] == str[1] ) {</a>
<a name="ln4543">            char *q;</a>
<a name="ln4544">            if ( !str[2] ) {</a>
<a name="ln4545">                str[1] = '2';  /* quick fix: replace HH with H2 */</a>
<a name="ln4546">            } else</a>
<a name="ln4547">            if ( isdigit( UCINT str[2] ) &amp;&amp; (n = strtol( str+2, &amp;q, 10 )) &amp;&amp; !q[0] ) {</a>
<a name="ln4548">                len = 1 + sprintf( str+1, &quot;%d&quot;, n+1 );</a>
<a name="ln4549">            }</a>
<a name="ln4550">        }</a>
<a name="ln4551">        /*</a>
<a name="ln4552">        if ( str[0] == 'H' &amp;&amp; str[1] == 'H' &amp;&amp; !str[2] ) {</a>
<a name="ln4553">            str[1] = '2';</a>
<a name="ln4554">        }</a>
<a name="ln4555">        */</a>
<a name="ln4556">        /*  charge */</a>
<a name="ln4557">        if ( abs(inp_at[i].charge) &gt; 1 )</a>
<a name="ln4558">            len += sprintf( str+len, &quot;%+d&quot;, inp_at[i].charge );</a>
<a name="ln4559">        else</a>
<a name="ln4560">        if ( abs(inp_at[i].charge) == 1 )</a>
<a name="ln4561">            len += sprintf( str+len, &quot;%s&quot;, inp_at[i].charge&gt;0? &quot;+&quot; : &quot;-&quot; );</a>
<a name="ln4562">        /*  radical */</a>
<a name="ln4563">        if ( inp_at[i].radical )</a>
<a name="ln4564">            len += sprintf( str+len, &quot;%s&quot;, inp_at[i].radical==RADICAL_SINGLET? &quot;:&quot; :</a>
<a name="ln4565">                                           inp_at[i].radical==RADICAL_DOUBLET? &quot;.&quot; :</a>
<a name="ln4566">                                           inp_at[i].radical==RADICAL_TRIPLET? &quot;..&quot; : &quot;?&quot;);</a>
<a name="ln4567">    }</a>
<a name="ln4568"> </a>
<a name="ln4569">    for ( i = 0; i &lt; init_num_at; i ++ ) {</a>
<a name="ln4570">        /*  canonical numbers */</a>
<a name="ln4571">        if ( inf_at[i].nCanonNbr ) {</a>
<a name="ln4572">            str = inf_at[i].at_string;</a>
<a name="ln4573">            len = strlen(str);</a>
<a name="ln4574">            len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_at[i].nCanonNbr );</a>
<a name="ln4575">            if ( inf_at[i].nCanonEquNbr || inf_at[i].nTautGroupCanonNbr ) {</a>
<a name="ln4576">                len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_at[i].nCanonEquNbr );</a>
<a name="ln4577">            }</a>
<a name="ln4578">            /*  tautomeric groups */</a>
<a name="ln4579">            if ( inf_at[i].nTautGroupCanonNbr ) {</a>
<a name="ln4580">                len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_at[i].nTautGroupCanonNbr );</a>
<a name="ln4581">                if ( inf_at[i].nTautGroupEquNbr ) {</a>
<a name="ln4582">                    len += (*MakeNumber)( str+len, len_str-len, &quot;/&quot;, (int)inf_at[i].nTautGroupEquNbr );</a>
<a name="ln4583">                }</a>
<a name="ln4584">            }</a>
<a name="ln4585">        }</a>
<a name="ln4586">    }</a>
<a name="ln4587">    ret = init_num_at;</a>
<a name="ln4588"> </a>
<a name="ln4589">    return ret;</a>
<a name="ln4590">}</a>
<a name="ln4591">/**********************************************************************************************/</a>
<a name="ln4592">int FillOutInfAtom(inp_ATOM *norm_at, INF_ATOM_DATA *inf_norm_at_data, int init_num_at, int num_removed_H,</a>
<a name="ln4593">                   int bAdd_DT_to_num_H, int nNumRemovedProtons, NUM_H *nNumRemovedProtonsIsotopic, int bIsotopic,</a>
<a name="ln4594">                   INChI *pINChI, INChI_Aux *pINChI_Aux, int bAbcNumbers, INCHI_MODE nMode )</a>
<a name="ln4595">{</a>
<a name="ln4596">    if ( norm_at &amp;&amp; inf_norm_at_data &amp;&amp; inf_norm_at_data-&gt;at ) {</a>
<a name="ln4597">        if ( pINChI &amp;&amp; pINChI_Aux ) {</a>
<a name="ln4598">            return FillOutCanonInfAtom( norm_at, inf_norm_at_data, init_num_at, bIsotopic, pINChI,</a>
<a name="ln4599">                                        pINChI_Aux, bAbcNumbers, nMode);</a>
<a name="ln4600">        } else {</a>
<a name="ln4601">            return FillOutInputInfAtom( norm_at, inf_norm_at_data, init_num_at, num_removed_H, bAdd_DT_to_num_H,</a>
<a name="ln4602">                                        nNumRemovedProtons, nNumRemovedProtonsIsotopic, bIsotopic, bAbcNumbers);</a>
<a name="ln4603">        }</a>
<a name="ln4604">    }</a>
<a name="ln4605">    return 0;</a>
<a name="ln4606">}</a>
<a name="ln4607">/***************************************************************************************/</a>
<a name="ln4608">int FillOutCompositeCanonInfAtom(COMP_ATOM_DATA *composite_norm_data, INF_ATOM_DATA *inf_norm_at_data,</a>
<a name="ln4609">                                 int bIsotopic, int bTautomeric,</a>
<a name="ln4610">                                 PINChI2 *pINChI2, PINChI_Aux2 *pINChI_Aux2, int bAbcNumbers, INCHI_MODE nMode)</a>
<a name="ln4611">{</a>
<a name="ln4612">    int i, num_components, j, k, ret;</a>
<a name="ln4613">    inp_ATOM *inp_norm_at;</a>
<a name="ln4614">    INChI     *pINChI;</a>
<a name="ln4615">    INChI_Aux *pINChI_Aux;</a>
<a name="ln4616">    int      num_inp_at, num_at, num_H, offset, offset_H, next_offset, next_offset_H;</a>
<a name="ln4617"> </a>
<a name="ln4618">    if ( composite_norm_data &amp;&amp; inf_norm_at_data &amp;&amp; (bTautomeric == TAUT_INI || pINChI2 &amp;&amp; pINChI_Aux2) ) {</a>
<a name="ln4619">        composite_norm_data += bTautomeric;</a>
<a name="ln4620">        inp_norm_at          = composite_norm_data-&gt;at;</a>
<a name="ln4621">        num_components       = composite_norm_data-&gt;num_components;</a>
<a name="ln4622">        offset   = 0;</a>
<a name="ln4623">        offset_H = composite_norm_data-&gt;num_at - composite_norm_data-&gt;num_removed_H;</a>
<a name="ln4624">        if ( bTautomeric == TAUT_INI ) {</a>
<a name="ln4625">            ret = FillOutInputInfAtom( composite_norm_data-&gt;at, inf_norm_at_data, composite_norm_data-&gt;num_at,</a>
<a name="ln4626">                                       composite_norm_data-&gt;num_removed_H, 0 /*bAdd_DT_to_num_H*/,</a>
<a name="ln4627">                                       composite_norm_data-&gt;nNumRemovedProtons,</a>
<a name="ln4628">                                       composite_norm_data-&gt;nNumRemovedProtonsIsotopic,</a>
<a name="ln4629">                                       bIsotopic, bAbcNumbers);</a>
<a name="ln4630">            return ret;</a>
<a name="ln4631">        } else {</a>
<a name="ln4632">            for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln4633">                j = inchi_min(bTautomeric, TAUT_YES);</a>
<a name="ln4634">                /* count isotopic H on removed atoms -- isolated H(+) cations */</a>
<a name="ln4635">                inf_norm_at_data-&gt;nNumRemovedProtons += pINChI_Aux2[i][j]-&gt;nNumRemovedProtons;</a>
<a name="ln4636">                if ( bIsotopic &amp;&amp; bTautomeric == TAUT_YES ) {</a>
<a name="ln4637">                    for ( k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln4638">                        if ( pINChI_Aux2[i][j]-&gt;nNumRemovedIsotopicH[k] ) {</a>
<a name="ln4639">                            inf_norm_at_data-&gt;num_iso_H[k] += pINChI_Aux2[i][j]-&gt;nNumRemovedIsotopicH[k];</a>
<a name="ln4640">                            inf_norm_at_data-&gt;num_removed_iso_H += pINChI_Aux2[i][j]-&gt;nNumRemovedIsotopicH[k];</a>
<a name="ln4641">                        }</a>
<a name="ln4642">                    }</a>
<a name="ln4643">                }</a>
<a name="ln4644">                /* ignore deleted components */</a>
<a name="ln4645">                if ( pINChI2[i][j] &amp;&amp; pINChI2[i][j]-&gt;bDeleted ) {</a>
<a name="ln4646">                    continue;</a>
<a name="ln4647">                }</a>
<a name="ln4648">                if ( !pINChI2[i][j] || !pINChI2[i][j]-&gt;nNumberOfAtoms ) {</a>
<a name="ln4649">                    j = ALT_TAUT(j);</a>
<a name="ln4650">                    if ( !pINChI2[i][j] || !pINChI2[i][j]-&gt;nNumberOfAtoms ) {</a>
<a name="ln4651">                        continue; /* error ??? */</a>
<a name="ln4652">                    }</a>
<a name="ln4653">                }</a>
<a name="ln4654">                pINChI     = pINChI2[i][j];</a>
<a name="ln4655">                pINChI_Aux = pINChI_Aux2[i][j];</a>
<a name="ln4656">                next_offset   = composite_norm_data-&gt;nOffsetAtAndH[2*i];</a>
<a name="ln4657">                next_offset_H = composite_norm_data-&gt;nOffsetAtAndH[2*i+1];</a>
<a name="ln4658">                num_at   = next_offset - offset;</a>
<a name="ln4659">                if ( num_at &lt;= 0 )</a>
<a name="ln4660">                    continue;</a>
<a name="ln4661">                num_H    = next_offset_H - offset_H;</a>
<a name="ln4662">                num_inp_at = num_at + num_H;</a>
<a name="ln4663">                if ( num_at != pINChI-&gt;nNumberOfAtoms || num_at != pINChI_Aux-&gt;nNumberOfAtoms ) {</a>
<a name="ln4664">                    return 0; /* error */</a>
<a name="ln4665">                }</a>
<a name="ln4666">                ret =  FillOutOneCanonInfAtom(inp_norm_at, inf_norm_at_data,</a>
<a name="ln4667">                               inf_norm_at_data-&gt;pStereoFlags+i+1, num_inp_at,</a>
<a name="ln4668">                               offset, offset_H, bIsotopic, pINChI, pINChI_Aux, bAbcNumbers, nMode);</a>
<a name="ln4669">                if ( ret )</a>
<a name="ln4670">                    return 0; /* error */</a>
<a name="ln4671"> </a>
<a name="ln4672">                inf_norm_at_data-&gt;StereoFlags |= inf_norm_at_data-&gt;pStereoFlags[i+1];</a>
<a name="ln4673">                offset   = next_offset;</a>
<a name="ln4674">                offset_H = next_offset_H;</a>
<a name="ln4675">            }</a>
<a name="ln4676">        }</a>
<a name="ln4677">        MakeRemovedProtonsString( inf_norm_at_data-&gt;nNumRemovedProtons, inf_norm_at_data-&gt;num_iso_H, NULL, bIsotopic,</a>
<a name="ln4678">                                  inf_norm_at_data-&gt;szRemovedProtons, &amp;inf_norm_at_data-&gt;num_removed_iso_H );</a>
<a name="ln4679">    }</a>
<a name="ln4680">    return 1;</a>
<a name="ln4681">}</a>
<a name="ln4682">#endif /* } ifndef COMPILE_ANSI_ONLY */</a>
<a name="ln4683">/**********************************************************************************************/</a>
<a name="ln4684">int CheckCanonNumberingCorrectness(int num_atoms, int num_at_tg,</a>
<a name="ln4685">                 sp_ATOM *at, CANON_STAT *pCS, int bTautomeric,</a>
<a name="ln4686">                 char *pStrErrStruct )</a>
<a name="ln4687">{</a>
<a name="ln4688">    int i, ret=0;</a>
<a name="ln4689">    AT_NUMB *pCanonOrd=NULL;</a>
<a name="ln4690">    int nErrorCode = 0;</a>
<a name="ln4691">    AT_NUMB *pCanonRank; /* canonical ranks of the atoms or tautomeric groups */</a>
<a name="ln4692">    AT_NUMB *pCanonRankAtoms=NULL;</a>
<a name="ln4693">    </a>
<a name="ln4694">    static int count=0; /* for debug only */</a>
<a name="ln4695">    count ++;</a>
<a name="ln4696"> </a>
<a name="ln4697">    pCanonRankAtoms = (AT_NUMB *)inchi_calloc( num_at_tg+1, sizeof(pCanonRankAtoms[0]) );</a>
<a name="ln4698">    </a>
<a name="ln4699">    /**********************************************************************************************</a>
<a name="ln4700">     *</a>
<a name="ln4701">     *  non-isotopic part</a>
<a name="ln4702">     */</a>
<a name="ln4703">    pCanonOrd            = pCS-&gt;nLenCanonOrdStereo &gt; 0? pCS-&gt;nCanonOrdStereo :</a>
<a name="ln4704">                           pCS-&gt;nLenCanonOrd       &gt; 0? pCS-&gt;nCanonOrd : NULL;</a>
<a name="ln4705">    pCanonRank           = pCanonRankAtoms;</a>
<a name="ln4706">    if ( pCanonOrd &amp;&amp; pCanonRank ) {</a>
<a name="ln4707">        for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4708">            pCanonRank[pCanonOrd[i]] = (AT_NUMB)(i+1);</a>
<a name="ln4709">        }</a>
<a name="ln4710">        ret = UpdateFullLinearCT( num_atoms, num_at_tg, at, pCanonRank, pCanonOrd, pCS, 0 );</a>
<a name="ln4711">        if ( ret /*|| memcmp(pCS-&gt;LinearCT, pCS-&gt;LinearCT2, sizeof(AT_RANK) * pCS-&gt;nLenLinearCT )*/ ) {</a>
<a name="ln4712">            nErrorCode     |= WARN_FAILED_STEREO;</a>
<a name="ln4713">        }</a>
<a name="ln4714"> </a>
<a name="ln4715">    } else {</a>
<a name="ln4716">        nErrorCode  |= ERR_NO_CANON_RESULTS;</a>
<a name="ln4717">        goto exit_function;</a>
<a name="ln4718">    }</a>
<a name="ln4719">    /**********************************************************************************************</a>
<a name="ln4720">     *</a>
<a name="ln4721">     *  isotopic part</a>
<a name="ln4722">     */</a>
<a name="ln4723">    pCanonOrd   = pCS-&gt;nLenCanonOrdIsotopicStereo &gt; 0? pCS-&gt;nCanonOrdIsotopicStereo :</a>
<a name="ln4724">                  pCS-&gt;nLenCanonOrdIsotopic       &gt; 0? pCS-&gt;nCanonOrdIsotopic : NULL;</a>
<a name="ln4725">    pCanonRank  = pCanonRankAtoms;</a>
<a name="ln4726"> </a>
<a name="ln4727">    if ( pCanonOrd &amp;&amp; pCanonRank ) {</a>
<a name="ln4728">        for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4729">            pCanonRank[pCanonOrd[i]] = (AT_NUMB)(i+1);</a>
<a name="ln4730">        }</a>
<a name="ln4731">        ret = UpdateFullLinearCT( num_atoms, num_at_tg, at, pCanonRank, pCanonOrd, pCS, 0 );</a>
<a name="ln4732">        if ( ret /*|| memcmp(pCS-&gt;LinearCT, pCS-&gt;LinearCT2, sizeof(AT_RANK) * pCS-&gt;nLenLinearCT )*/ ) {</a>
<a name="ln4733">            nErrorCode     |= (pCS-&gt;nLenCanonOrdIsotopicStereo? WARN_FAILED_ISOTOPIC_STEREO : WARN_FAILED_ISOTOPIC);</a>
<a name="ln4734">        }</a>
<a name="ln4735"> </a>
<a name="ln4736">    }</a>
<a name="ln4737"> </a>
<a name="ln4738">exit_function:</a>
<a name="ln4739">    if ( pCanonRankAtoms )</a>
<a name="ln4740">        inchi_free( pCanonRankAtoms );</a>
<a name="ln4741"> </a>
<a name="ln4742">    if ( nErrorCode ) {</a>
<a name="ln4743">        return CT_CANON_ERR;</a>
<a name="ln4744">    }</a>
<a name="ln4745">    return 0;</a>
<a name="ln4746">}</a>

</code></pre>
<div class="balloon" rel="307"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'i2' variable is assigned to itself.</p></div>
<div class="balloon" rel="384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'i2->nNum_H_fixed' is always true.</p></div>
<div class="balloon" rel="384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'i2->nNum_H_fixed' condition was already verified in line 381.</p></div>
<div class="balloon" rel="396"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'i2' pointer was used unsafely after it was verified against nullptr. Check lines: 381, 396.</p></div>
<div class="balloon" rel="359"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'i2' pointer was utilized before it was verified against nullptr. Check lines: 359, 381.</p></div>
<div class="balloon" rel="1750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nNumDescendants' is always true.</p></div>
<div class="balloon" rel="1827"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nOutputString' is always true.</p></div>
<div class="balloon" rel="1874"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !bPlainText.</p></div>
<div class="balloon" rel="1879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'bPlainText' is always false.</p></div>
<div class="balloon" rel="2090"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 's1' pointer was used unsafely after it was verified against nullptr. Check lines: 2083, 2090.</p></div>
<div class="balloon" rel="2090"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 's2' pointer was used unsafely after it was verified against nullptr. Check lines: 2084, 2090.</p></div>
<div class="balloon" rel="2150"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 's2' pointer was utilized before it was verified against nullptr. Check lines: 2150, 2180.</p></div>
<div class="balloon" rel="2430"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2455"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << i' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="2459"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << i' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="2655"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pe1' is always true.</p></div>
<div class="balloon" rel="2656"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pe2' is always true.</p></div>
<div class="balloon" rel="2778"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2784"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2882"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pBCN' is always true.</p></div>
<div class="balloon" rel="2975"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: t_group_info.</p></div>
<div class="balloon" rel="3103"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: t_group_info.</p></div>
<div class="balloon" rel="3104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 0 < 3.</p></div>
<div class="balloon" rel="3105"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 1 < 3.</p></div>
<div class="balloon" rel="3106"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 2 < 3.</p></div>
<div class="balloon" rel="3109"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: t_group_info.</p></div>
<div class="balloon" rel="3174"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't_group_info' is always true.</p></div>
<div class="balloon" rel="3353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pINChI_Aux' pointer was utilized before it was verified against nullptr. Check lines: 3353, 3382.</p></div>
<div class="balloon" rel="3326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pBCN' is always true.</p></div>
<div class="balloon" rel="4725"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pCanonRank' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

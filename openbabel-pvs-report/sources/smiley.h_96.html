
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>smiley.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * Copyright (c) 2012, Tim Vandermeersch</a>
<a name="ln3"> * All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions are met:</a>
<a name="ln7"> *     * Redistributions of source code must retain the above copyright</a>
<a name="ln8"> *       notice, this list of conditions and the following disclaimer.</a>
<a name="ln9"> *     * Redistributions in binary form must reproduce the above copyright</a>
<a name="ln10"> *       notice, this list of conditions and the following disclaimer in the</a>
<a name="ln11"> *       documentation and/or other materials provided with the distribution.</a>
<a name="ln12"> *     * Neither the name of the &lt;organization&gt; nor the</a>
<a name="ln13"> *       names of its contributors may be used to endorse or promote products</a>
<a name="ln14"> *       derived from this software without specific prior written permission.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</a>
<a name="ln17"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</a>
<a name="ln18"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</a>
<a name="ln19"> * DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY</a>
<a name="ln20"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln21"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</a>
<a name="ln22"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</a>
<a name="ln23"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln24"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</a>
<a name="ln25"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln26"> */</a>
<a name="ln27">#ifndef SMILEY_SMILEY_H</a>
<a name="ln28">#define SMILEY_SMILEY_H</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;string&gt;</a>
<a name="ln31">#include &lt;vector&gt;</a>
<a name="ln32">#include &lt;map&gt;</a>
<a name="ln33">#include &lt;sstream&gt;</a>
<a name="ln34">#include &lt;limits&gt;</a>
<a name="ln35">#include &lt;iostream&gt;</a>
<a name="ln36">#include &lt;cctype&gt;</a>
<a name="ln37"> </a>
<a name="ln38">//#include &lt;cassert&gt;</a>
<a name="ln39">#define DEBUG 0</a>
<a name="ln40"> </a>
<a name="ln41">namespace Smiley {</a>
<a name="ln42"> </a>
<a name="ln43">  /**</a>
<a name="ln44">   * @mainpage</a>
<a name="ln45">   *</a>
<a name="ln46">   * Smiley is a SMILES/SMARTS parser that is OpenSMILES (http://www.opensmiles.org)</a>
<a name="ln47">   * compliant (draft 2007-11-13).</a>
<a name="ln48">   *</a>
<a name="ln49">   * @section usage Usage</a>
<a name="ln50">   *</a>
<a name="ln51">   * Smiley is a single header file which contains the Parser class in the</a>
<a name="ln52">   * Smiley namespace. User actions are invoked using a functor object that is</a>
<a name="ln53">   * specified when a Parser is instantiated. Below is a simple example which</a>
<a name="ln54">   * uses the PrintCallback to print the events as they occur. The example below</a>
<a name="ln55">   * also shows how to handle exceptions and print useful error reports.</a>
<a name="ln56">   *</a>
<a name="ln57">   * @code</a>
<a name="ln58">   * #include &quot;smiley.h&quot;</a>
<a name="ln59">   *</a>
<a name="ln60">   * using namespace Smiley;</a>
<a name="ln61">   *</a>
<a name="ln62">   * int main(int argc, char **argv)</a>
<a name="ln63">   * {</a>
<a name="ln64">   *   PrintCallback callback;</a>
<a name="ln65">   *   Parser&lt;PrintCallback&gt; parser(callback);</a>
<a name="ln66">   *</a>
<a name="ln67">   *   try {</a>
<a name="ln68">   *     parser.parse(argv[1]);</a>
<a name="ln69">   *   } catch (Exception &amp;e) {</a>
<a name="ln70">   *     if (e.type() == Exception::SyntaxError)</a>
<a name="ln71">   *       std::cerr &lt;&lt; &quot;Syntax&quot;;</a>
<a name="ln72">   *     else</a>
<a name="ln73">   *       std::cerr &lt;&lt; &quot;Semantics&quot;;</a>
<a name="ln74">   *     std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</a>
<a name="ln75">   *     std::cerr &lt;&lt; argv[1] &lt;&lt; std::endl;</a>
<a name="ln76">   *     for (std::size_t i = 0; i &lt; e.pos(); ++i)</a>
<a name="ln77">   *       std::cerr &lt;&lt; &quot; &quot;;</a>
<a name="ln78">   *     for (std::size_t i = 0; i &lt; e.length(); ++i)</a>
<a name="ln79">   *       std::cerr &lt;&lt; &quot;^&quot;;</a>
<a name="ln80">   *     std::cerr &lt;&lt; std::endl;</a>
<a name="ln81">   *   }</a>
<a name="ln82">   * }</a>
<a name="ln83">   * @endcode</a>
<a name="ln84">   *</a>
<a name="ln85">   * Example of errors:</a>
<a name="ln86">   * @code</a>
<a name="ln87">   * SyntaxError: Bracket atom expression contains invalid trailing characters.</a>
<a name="ln88">   * F.FB(F)F.[NH2+251][C@@H](CP(c1ccccc1)c1ccccc1)C(C)(C)C 31586112</a>
<a name="ln89">   *                ^^</a>
<a name="ln90">   * SyntaxError: Unmatched branch opening.</a>
<a name="ln91">   * CC(CC</a>
<a name="ln92">   *   ^^^</a>
<a name="ln93">   * SyntaxError: Unmatched branch closing.</a>
<a name="ln94">   * CC)CC</a>
<a name="ln95">   * ^^^</a>
<a name="ln96">   * SemanticsError: Unmatched ring bond.</a>
<a name="ln97">   * C1CCC</a>
<a name="ln98">   *  ^</a>
<a name="ln99">   * SemanticsError: Conflicing ring bonds.</a>
<a name="ln100">   * C-1CCCCC=1</a>
<a name="ln101">   *          ^</a>
<a name="ln102">   * @endcode</a>
<a name="ln103">   *</a>
<a name="ln104">   * Although this is useful for debugging, using Smiley in an application</a>
<a name="ln105">   * requires a custom callback function object.</a>
<a name="ln106">   *</a>
<a name="ln107">   * @subsection callback Callback</a>
<a name="ln108">   * The callback function object type is a template parameter to the Parser</a>
<a name="ln109">   * class. The should be derived publicly from CallbackBase so unneeded methods</a>
<a name="ln110">   * do not have to be specified. For SMILES, the class may contain 4 methods:</a>
<a name="ln111">   *</a>
<a name="ln112">   * @code</a>
<a name="ln113">   * struct MyCustomCallback</a>
<a name="ln114">   * {</a>
<a name="ln115">   *   void clear()</a>
<a name="ln116">   *   {</a>
<a name="ln117">   *     // prepare for new SMILES</a>
<a name="ln118">   *   }</a>
<a name="ln119">   *</a>
<a name="ln120">   *   void addAtom(int element, bool aromatic, int isotope, int hCount, int charge, int atomClass)</a>
<a name="ln121">   *   {</a>
<a name="ln122">   *     // invoked when an atom is completely parsed</a>
<a name="ln123">   *</a>
<a name="ln124">   *     // element: 0, 1, 2, ... (0 is '*' in SMILES)</a>
<a name="ln125">   *     // aromatic: true if the atom was lower case c, n, ...</a>
<a name="ln126">   *     // isotope: -1, 0, 1, 2, 3, 4 ... (-1 means no isotope specified and is not the same as 0)</a>
<a name="ln127">   *     // hCount: -1, 0, 1, 2, ..., 9 (-1 means default valence and is only for unbracketed atoms)</a>
<a name="ln128">   *     // charge: -9, -8, ..., -1, 0, 1, ..., 8, 9</a>
<a name="ln129">   *     // atomClass: 0, 1, 2, 3, 4, ... (0 means no atom class, specified atom classes should start from 1)</a>
<a name="ln130">   *   }</a>
<a name="ln131">   *</a>
<a name="ln132">   *   void addBond(int source, int target, int order, bool isUp, bool isDown)</a>
<a name="ln133">   *   {</a>
<a name="ln134">   *     // invoked for each bond once both of it's atoms have been added by</a>
<a name="ln135">   *     // calling addAtom(). This ensures that the bond's atom indexes are always valid.</a>
<a name="ln136">   *</a>
<a name="ln137">   *     // source: source atom index starting from 0 (order from addAtom() calls)</a>
<a name="ln138">   *     // target: target atom index starting from 0 (order from addAtom() calls)</a>
<a name="ln139">   *     // order: 1, 2, 3, 4, 5 (5 means aromatic)</a>
<a name="ln140">   *     // isUp: true if bond is single order up bond '/'</a>
<a name="ln141">   *     // isDown: true if bond is single order down bond '\'</a>
<a name="ln142">   *   }</a>
<a name="ln143">   *</a>
<a name="ln144">   *   void setChiral(int index, Chirality chirality, const std::vector&lt;int&gt; &amp;chiralNbrs)</a>
<a name="ln145">   *   {</a>
<a name="ln146">   *     // invoked at the end of parsing for each chiral atom</a>
<a name="ln147">   *</a>
<a name="ln148">   *     // index: atom index starting from 0</a>
<a name="ln149">   *     // chirality: Clockwise, AntiClockwise, TH1, AL2, SP3, TB14, OH26, ...</a>
<a name="ln150">   *     // chiralNbrs: atom indices of neighbors, size 4 for TH, AL and SP, size 5 for TB and 6 for OH</a>
<a name="ln151">   *   }</a>
<a name="ln152">   * };</a>
<a name="ln153">   * @endcode</a>
<a name="ln154">   *</a>
<a name="ln155">   * @section smiles_semantics SMILES Semantics</a>
<a name="ln156">   *</a>
<a name="ln157">   * For a detailed description of the OpenSMILES semantics, the specification</a>
<a name="ln158">   * should be consulted. Apart for syntactical and grammatical correctness,</a>
<a name="ln159">   * Smiley als verifies some basic semantics. When a semantics error is found,</a>
<a name="ln160">   * an Exception is thrown with the corresponding ErrorCode. Some of these</a>
<a name="ln161">   * exceptions (UnmatchedRingBond, ConflictingRingBond, InvalidRingBond,</a>
<a name="ln162">   * InvalidChiralValence and InvalidChiralHydrogenCount) can be disabled using</a>
<a name="ln163">   * Parser::disableExceptions(). By default, all exceptions are enabled to</a>
<a name="ln164">   * ensure OpenSMILES compliance. The effect of disabling these exceptions is</a>
<a name="ln165">   * specified in subsequent subsections.</a>
<a name="ln166">   *</a>
<a name="ln167">   * @subsection semantics_HH Hydrogen with Hydrogen Count</a>
<a name="ln168">   * Hydrogen atoms can not have a hydrogen count. Hydrogen bound to a hydrogen</a>
<a name="ln169">   * atom should be specified by two bracket atom expressions. If such an</a>
<a name="ln170">   * expression is found during parsing, an Exception with ErrorCode</a>
<a name="ln171">   * HydrogenHydrogenCount is thrown.</a>
<a name="ln172">   *</a>
<a name="ln173">   * Eamples:</a>
<a name="ln174">   * @code</a>
<a name="ln175">   * [HH]        invalid</a>
<a name="ln176">   * [HH1]       invalid (same as [HH]</a>
<a name="ln177">   * [HH3]       invalid</a>
<a name="ln178">   * [HH0]       valid (same as [H])</a>
<a name="ln179">   * [H][H]      valid</a>
<a name="ln180">   * @endcode</a>
<a name="ln181">   *</a>
<a name="ln182">   * @subsection semantics_unmatched_ringbond Unmatched Ring Bond</a>
<a name="ln183">   * When there is an unmatched ring bond, an Exception with ErrorCode</a>
<a name="ln184">   * UnmatchedRingBond will be thrown. Disabling this exception will</a>
<a name="ln185">   * ignore the ring bond(s).</a>
<a name="ln186">   *</a>
<a name="ln187">   * Example:</a>
<a name="ln188">   * @code</a>
<a name="ln189">   * C1CCC</a>
<a name="ln190">   * @endcode</a>
<a name="ln191">   *</a>
<a name="ln192">   * @subsection semantics_conflicing_ringbond Conflicting Ring Bonds</a>
<a name="ln193">   * When the bond type for ring bonds are explicitly specified at both ends,</a>
<a name="ln194">   * these should be the same. If not, an Exception with ErrorCode</a>
<a name="ln195">   * ConflictingRingBonds is thrown. Disabling this exception will use the</a>
<a name="ln196">   * first bond specification (i.e. a single bond in the example below).</a>
<a name="ln197">   *</a>
<a name="ln198">   * Example:</a>
<a name="ln199">   * @code</a>
<a name="ln200">   * C-1CCCCCC=1</a>
<a name="ln201">   * @endcode</a>
<a name="ln202">   *</a>
<a name="ln203">   * @subsection semantics_invalid_ringbond Invalid Ring Bonds</a>
<a name="ln204">   * There are two types of invalid ring bonds. The first is when two atoms both</a>
<a name="ln205">   * have the same two ring bonds. This would mean adding a parallel edge in the</a>
<a name="ln206">   * graph which is not allowed. The second type is similar but results in a</a>
<a name="ln207">   * self-loop by having a ring bond number twice. An Exception with ErrorCode</a>
<a name="ln208">   * InvalidRingBond is thrown when such a bond is encountered. Disabling this</a>
<a name="ln209">   * exception will ignore the invalid ring bonds.</a>
<a name="ln210">   *</a>
<a name="ln211">   * Eamples:</a>
<a name="ln212">   * @code</a>
<a name="ln213">   * C12CCCC12      parallel bond</a>
<a name="ln214">   * C11            self-loop bond</a>
<a name="ln215">   * @endcode</a>
<a name="ln216">   *</a>
<a name="ln217">   * @subsection semantics_chiral_valence Invalid Chiral Valence</a>
<a name="ln218">   * When an atom is specified as being chiral, it should have the correct</a>
<a name="ln219">   * number of neighboring atoms (possibly including an implicit H inside the</a>
<a name="ln220">   * bracket. An Exception with ErrorCode InvalidChiralValence is thrown when</a>
<a name="ln221">   * a valence is incorrect. Disabling this exception will result in no</a>
<a name="ln222">   * verification and leaves this to the Callback functor.</a>
<a name="ln223">   *</a>
<a name="ln224">   * The valid valences are:</a>
<a name="ln225">   * @code</a>
<a name="ln226">   * Tetrahedral (TH)          : 4</a>
<a name="ln227">   * Allene (AL)               : 4 (*)</a>
<a name="ln228">   * Square Planar (SP)        : 4</a>
<a name="ln229">   * Trigonal Bypiramidal (TB) : 5</a>
<a name="ln230">   * Octahedral(OH)            : 6</a>
<a name="ln231">   *</a>
<a name="ln232">   * (*) The chiral atom has only 2 bonds but the neighbor's neighbors are</a>
<a name="ln233">   *     counted: NC(Br)=[C@AL1]=C(F)I</a>
<a name="ln234">   * @endcode</a>
<a name="ln235">   *</a>
<a name="ln236">   * @subsection semantics_chiral_hydrogens Invalid Chiral Hydrogen Count</a>
<a name="ln237">   * Chiral atoms can only have one hydrogen in their bracket since multiple</a>
<a name="ln238">   * hydrogens would make them not chiral. An Exception with ErrorCode</a>
<a name="ln239">   * InvalidChiralHydrogenCount is thrown when such an atom is encountered.</a>
<a name="ln240">   * Disabling this exception allows a chiral specification with a hydrogen</a>
<a name="ln241">   * count higher than 2. Note: only 1 implcitHydrogen() is added to nbrs.</a>
<a name="ln242">   *</a>
<a name="ln243">   * Example:</a>
<a name="ln244">   * @code</a>
<a name="ln245">   * C[C@H2]F</a>
<a name="ln246">   * @endcode</a>
<a name="ln247">   *</a>
<a name="ln248">   *</a>
<a name="ln249">   *</a>
<a name="ln250">   *</a>
<a name="ln251">   *</a>
<a name="ln252">   *</a>
<a name="ln253">   *</a>
<a name="ln254">   *</a>
<a name="ln255">   *</a>
<a name="ln256">   *</a>
<a name="ln257">   *</a>
<a name="ln258">   *</a>
<a name="ln259">   *</a>
<a name="ln260">   *</a>
<a name="ln261">   *</a>
<a name="ln262">   *</a>
<a name="ln263">   *</a>
<a name="ln264">   *</a>
<a name="ln265">   *</a>
<a name="ln266">   *</a>
<a name="ln267">   *</a>
<a name="ln268">   *</a>
<a name="ln269">   *</a>
<a name="ln270">   *</a>
<a name="ln271">   *</a>
<a name="ln272">   *</a>
<a name="ln273">   *</a>
<a name="ln274">   * @section license License</a>
<a name="ln275">   * @code</a>
<a name="ln276">   * Copyright (c) 2012, Tim Vandermeersch</a>
<a name="ln277">   * All rights reserved.</a>
<a name="ln278">   *</a>
<a name="ln279">   * Redistribution and use in source and binary forms, with or without</a>
<a name="ln280">   * modification, are permitted provided that the following conditions are met:</a>
<a name="ln281">   *     * Redistributions of source code must retain the above copyright</a>
<a name="ln282">   *       notice, this list of conditions and the following disclaimer.</a>
<a name="ln283">   *     * Redistributions in binary form must reproduce the above copyright</a>
<a name="ln284">   *       notice, this list of conditions and the following disclaimer in the</a>
<a name="ln285">   *       documentation and/or other materials provided with the distribution.</a>
<a name="ln286">   *     * Neither the name of the &lt;organization&gt; nor the</a>
<a name="ln287">   *       names of its contributors may be used to endorse or promote products</a>
<a name="ln288">   *       derived from this software without specific prior written permission.</a>
<a name="ln289">   *</a>
<a name="ln290">   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</a>
<a name="ln291">   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</a>
<a name="ln292">   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</a>
<a name="ln293">   * DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY</a>
<a name="ln294">   * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln295">   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</a>
<a name="ln296">   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</a>
<a name="ln297">   * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln298">   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</a>
<a name="ln299">   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln300">   * @endcode</a>
<a name="ln301">   */</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">  /**</a>
<a name="ln305">   * The elements.</a>
<a name="ln306">   */</a>
<a name="ln307">  enum Elements {</a>
<a name="ln308">    H = 1,                                                                                                                      He,</a>
<a name="ln309">    Li, Be,                                                                                                  B,  C,  N,  O,  F, Ne,</a>
<a name="ln310">    Na, Mg,                                                                                                 Al, Si,  P,  S, Cl, Ar,</a>
<a name="ln311">     K, Ca,                                                         Sc, Ti,  V, Cr, Mn, Fe, Co, Ni, Cu, Zn, Ga, Ge, As, Se, Br, Kr,</a>
<a name="ln312">    Rb, Sr,                                                          Y, Zr, Nb, Mo, Tc, Ru, Rh, Pd, Ag, Cd, In, Sn, Sb, Te,  I, Xe,</a>
<a name="ln313">    Cs, Ba, La, Ce, Pr, Nd, Pm, Sm, Eu, Gd, Tb, Dy, Ho, Er, Tm, Yb, Lu, Hf, Ta,  W, Re, Os, Ir, Pt, Au, Hg, Tl, Pb, Bi, Po, At, Rn,</a>
<a name="ln314">    Fr, Ra, Ac, Th, Pa,  U, Np, Pu, Am, Cm, Bk, Cf, Es, Fm, Md, No, Lr, Rf, Db, Sg, Bh, Hs, Mt, Ds, Rg, Cn, Fl = 114, Lv = 116</a>
<a name="ln315">  };</a>
<a name="ln316"> </a>
<a name="ln317">  /**</a>
<a name="ln318">   * Chirality classes.</a>
<a name="ln319">   */</a>
<a name="ln320">  enum Chirality {</a>
<a name="ln321">    NotChiral = 0,</a>
<a name="ln322">    AntiClockwise, Clockwise,</a>
<a name="ln323">    TH1, TH2,</a>
<a name="ln324">    AL1, AL2,</a>
<a name="ln325">    SP1, SP2, SP3,</a>
<a name="ln326">    TB1, TB2, TB3, TB4, TB5, TB6, TB7, TB8, TB9, TB10,</a>
<a name="ln327">    TB11, TB12, TB13, TB14, TB15, TB16, TB17, TB18, TB19, TB20,</a>
<a name="ln328">    OH1, OH2, OH3, OH4, OH5, OH6, OH7, OH8, OH9, OH10,</a>
<a name="ln329">    OH11, OH12, OH13, OH14, OH15, OH16, OH17, OH18, OH19, OH20,</a>
<a name="ln330">    OH21, OH22, OH23, OH24, OH25, OH26, OH27, OH28, OH29, OH30</a>
<a name="ln331">  };</a>
<a name="ln332"> </a>
<a name="ln333">  /**</a>
<a name="ln334">   * Error codes for Exception exceptions.</a>
<a name="ln335">   */</a>
<a name="ln336">  enum ErrorCode {</a>
<a name="ln337">    ////////////////////////////////////////</a>
<a name="ln338">    //</a>
<a name="ln339">    // SyntaxError</a>
<a name="ln340">    //</a>
<a name="ln341">    ////////////////////////////////////////</a>
<a name="ln342">    /**</a>
<a name="ln343">     * Example: &quot;[C&quot;</a>
<a name="ln344">     */</a>
<a name="ln345">    NoClosingAtomBracket = 1,</a>
<a name="ln346">    /**</a>
<a name="ln347">     * Examples: &quot;[]&quot;, &quot;[13]&quot;, &quot;[+]&quot;</a>
<a name="ln348">     */</a>
<a name="ln349">    NoSymbolInBracketAtom = 2,</a>
<a name="ln350">    /**</a>
<a name="ln351">     * Examples: &quot;[C@@T]&quot;, &quot;[C@@A]&quot;, &quot;[C@@TB]&quot;, &quot;[C@@TH99]&quot;, &quot;[C@@OH0]&quot;</a>
<a name="ln352">     */</a>
<a name="ln353">    InvalidChirality = 3,</a>
<a name="ln354">    /**</a>
<a name="ln355">     * Example: &quot;[C:]&quot;</a>
<a name="ln356">     */</a>
<a name="ln357">    NoAtomClass = 4,</a>
<a name="ln358">    /**</a>
<a name="ln359">     * Example: &quot;CC(C&quot;</a>
<a name="ln360">     */</a>
<a name="ln361">    UnmatchedBranchOpening = 5,</a>
<a name="ln362">    /**</a>
<a name="ln363">     * Example: &quot;CC)C&quot;</a>
<a name="ln364">     */</a>
<a name="ln365">    UnmatchedBranchClosing = 6,</a>
<a name="ln366">    /**</a>
<a name="ln367">     * Examples: &quot;Q&quot;, &quot;!&quot;, &quot;&amp;&quot;, &quot;Mm&quot;, &quot;r&quot;</a>
<a name="ln368">     */</a>
<a name="ln369">    InvalidAtomExpr = 7,</a>
<a name="ln370">    /**</a>
<a name="ln371">     * Example: &quot;[13C$]&quot;, &quot;[NP]&quot;</a>
<a name="ln372">     */</a>
<a name="ln373">    TrailingCharInBracketAtom = 8,</a>
<a name="ln374">    /**</a>
<a name="ln375">     * Example: &quot;.C&quot;</a>
<a name="ln376">     */</a>
<a name="ln377">    LeadingDot = 9,</a>
<a name="ln378">    /**</a>
<a name="ln379">     * Example: &quot;C.&quot;</a>
<a name="ln380">     */</a>
<a name="ln381">    TrailingDot = 10,</a>
<a name="ln382">    /**</a>
<a name="ln383">     * Example: &quot;C%123CC%123&quot;, &quot;C%CC%&quot;</a>
<a name="ln384">     */</a>
<a name="ln385">    InvalidRingBondNumber = 11,</a>
<a name="ln386">    //////////////////</a>
<a name="ln387">    // SMARTS</a>
<a name="ln388">    //////////////////</a>
<a name="ln389">    /**</a>
<a name="ln390">     * Example: &quot;[&amp;C]&quot;</a>
<a name="ln391">     */</a>
<a name="ln392">    BinaryOpWithoutLeftOperand = 12,</a>
<a name="ln393">    /**</a>
<a name="ln394">     * Example: &quot;[C&amp;]&quot;</a>
<a name="ln395">     */</a>
<a name="ln396">    BinaryOpWithoutRightOperand = 13,</a>
<a name="ln397">    /**</a>
<a name="ln398">     * Example: &quot;[C!]&quot;</a>
<a name="ln399">     */</a>
<a name="ln400">    UnaryOpWithoutArgument = 14,</a>
<a name="ln401">    /**</a>
<a name="ln402">     * Example: &quot;[Q]&quot;</a>
<a name="ln403">     */</a>
<a name="ln404">    InvalidAtomPrimitive = 15,</a>
<a name="ln405">    /**</a>
<a name="ln406">     * Example: &quot;C^C&quot;</a>
<a name="ln407">     */</a>
<a name="ln408">    InvalidBondPrimitive = 16,</a>
<a name="ln409">    ////////////////////////////////////////</a>
<a name="ln410">    //</a>
<a name="ln411">    // SemanticsError</a>
<a name="ln412">    //</a>
<a name="ln413">    ////////////////////////////////////////</a>
<a name="ln414">    /**</a>
<a name="ln415">     * Example: &quot;[HH1]&quot;</a>
<a name="ln416">     */</a>
<a name="ln417">    HydrogenHydrogenCount = 32,</a>
<a name="ln418">    /**</a>
<a name="ln419">     * Example: &quot;C1CC&quot;</a>
<a name="ln420">     */</a>
<a name="ln421">    UnmatchedRingBond = 64,</a>
<a name="ln422">    /**</a>
<a name="ln423">     * Example: &quot;C-1CCCC=1&quot;</a>
<a name="ln424">     */</a>
<a name="ln425">    ConflictingRingBonds = 128,</a>
<a name="ln426">    /**</a>
<a name="ln427">     * Example: &quot;C12CCCCC12&quot;, &quot;C11&quot;</a>
<a name="ln428">     */</a>
<a name="ln429">    InvalidRingBond = 256,</a>
<a name="ln430">    /**</a>
<a name="ln431">     * Example: &quot;C[C@H](F)(Cl)(Br)I&quot;, &quot;O[C@]&quot;</a>
<a name="ln432">     */</a>
<a name="ln433">    InvalidChiralValence = 512,</a>
<a name="ln434">    /**</a>
<a name="ln435">     * Example: &quot;N[C@H2](F)I&quot;</a>
<a name="ln436">     */</a>
<a name="ln437">    InvalidChiralHydrogenCount = 1024</a>
<a name="ln438">  };</a>
<a name="ln439"> </a>
<a name="ln440">  /**</a>
<a name="ln441">   * Exception class.</a>
<a name="ln442">   */</a>
<a name="ln443">  class Exception</a>
<a name="ln444">  {</a>
<a name="ln445">    public:</a>
<a name="ln446">      /**</a>
<a name="ln447">       * Exception type.</a>
<a name="ln448">       */</a>
<a name="ln449">      enum Type { SyntaxError, SemanticsError };</a>
<a name="ln450"> </a>
<a name="ln451">      /**</a>
<a name="ln452">       * Constructor.</a>
<a name="ln453">       *</a>
<a name="ln454">       * @param type The exception type.</a>
<a name="ln455">       * @param errorCode The numeric error code.</a>
<a name="ln456">       * @param what Details of the exception.</a>
<a name="ln457">       * @param pos The position in the SMILES/SMARTS string.</a>
<a name="ln458">       * @param length The length of the error in the SMILES/SMARTS string.</a>
<a name="ln459">       */</a>
<a name="ln460">      Exception(Type type, ErrorCode errorCode, const std::string &amp;what, std::size_t pos, std::size_t length = 1)</a>
<a name="ln461">          : m_type(type), m_errorCode(errorCode), m_what(what), m_pos(pos), m_length(length)</a>
<a name="ln462">      {</a>
<a name="ln463">      }</a>
<a name="ln464"> </a>
<a name="ln465">      /**</a>
<a name="ln466">       * The type of the exception.</a>
<a name="ln467">       */</a>
<a name="ln468">      Type type() const</a>
<a name="ln469">      {</a>
<a name="ln470">        return m_type;</a>
<a name="ln471">      }</a>
<a name="ln472"> </a>
<a name="ln473">      /**</a>
<a name="ln474">       * The ErrorCode for the exception.</a>
<a name="ln475">       */</a>
<a name="ln476">      ErrorCode errorCode() const</a>
<a name="ln477">      {</a>
<a name="ln478">        return m_errorCode;</a>
<a name="ln479">      }</a>
<a name="ln480"> </a>
<a name="ln481">      /**</a>
<a name="ln482">       * Details concerning the exception.</a>
<a name="ln483">       */</a>
<a name="ln484">      const std::string&amp; what() const</a>
<a name="ln485">      {</a>
<a name="ln486">        return m_what;</a>
<a name="ln487">      }</a>
<a name="ln488"> </a>
<a name="ln489">      /**</a>
<a name="ln490">       * The position in the specified string where the error starts.</a>
<a name="ln491">       */</a>
<a name="ln492">      std::size_t pos() const</a>
<a name="ln493">      {</a>
<a name="ln494">        return m_pos;</a>
<a name="ln495">      }</a>
<a name="ln496"> </a>
<a name="ln497">      /**</a>
<a name="ln498">       * The length of the error.</a>
<a name="ln499">       */</a>
<a name="ln500">      std::size_t length() const</a>
<a name="ln501">      {</a>
<a name="ln502">        return m_length;</a>
<a name="ln503">      }</a>
<a name="ln504"> </a>
<a name="ln505">    private:</a>
<a name="ln506">      Type m_type;</a>
<a name="ln507">      ErrorCode m_errorCode;</a>
<a name="ln508">      std::string m_what;</a>
<a name="ln509">      std::size_t m_pos;</a>
<a name="ln510">      std::size_t m_length;</a>
<a name="ln511">  };</a>
<a name="ln512"> </a>
<a name="ln513">  /**</a>
<a name="ln514">   * Value for implicit hydrogen in chiral nbrs.</a>
<a name="ln515">   */</a>
<a name="ln516">  inline int implicitHydrogen()</a>
<a name="ln517">  {</a>
<a name="ln518">    return std::numeric_limits&lt;int&gt;::max();</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  enum SmartsLogicalOpType</a>
<a name="ln522">  {</a>
<a name="ln523">    OP_Not = 1,</a>
<a name="ln524">    OP_AndHi = 2,</a>
<a name="ln525">    OP_AndLo = 4,</a>
<a name="ln526">    OP_And = OP_AndHi | OP_AndLo, // 6</a>
<a name="ln527">    OP_Or = 7</a>
<a name="ln528">  };</a>
<a name="ln529"> </a>
<a name="ln530">  enum SmartsAtomExprType</a>
<a name="ln531">  {</a>
<a name="ln532">    AE_True = 8,</a>
<a name="ln533">    AE_False,</a>
<a name="ln534">    AE_Aromatic,</a>
<a name="ln535">    AE_Aliphatic,</a>
<a name="ln536">    AE_Cyclic,</a>
<a name="ln537">    AE_Acyclic,</a>
<a name="ln538">    AE_Isotope,</a>
<a name="ln539">    AE_AtomicNumber,</a>
<a name="ln540">    AE_AromaticElement,</a>
<a name="ln541">    AE_AliphaticElement,</a>
<a name="ln542">    AE_Degree,</a>
<a name="ln543">    AE_Valence,</a>
<a name="ln544">    AE_Connectivity,</a>
<a name="ln545">    AE_TotalH,</a>
<a name="ln546">    AE_ImplicitH,</a>
<a name="ln547">    AE_RingMembership,</a>
<a name="ln548">    AE_RingSize,</a>
<a name="ln549">    AE_RingConnectivity,</a>
<a name="ln550">    AE_Charge,</a>
<a name="ln551">    AE_Chirality,</a>
<a name="ln552">    AE_AtomClass</a>
<a name="ln553">  };</a>
<a name="ln554"> </a>
<a name="ln555">  enum SmartsBondExprType</a>
<a name="ln556">  {</a>
<a name="ln557">    BE_True = AE_AtomClass + 1,</a>
<a name="ln558">    BE_False,</a>
<a name="ln559">    BE_Single,</a>
<a name="ln560">    BE_Double,</a>
<a name="ln561">    BE_Triple,</a>
<a name="ln562">    BE_Quadriple,</a>
<a name="ln563">    BE_Aromatic,</a>
<a name="ln564">    BE_Up,</a>
<a name="ln565">    BE_Down,</a>
<a name="ln566">    BE_Ring,</a>
<a name="ln567">    BE_Any = BE_True</a>
<a name="ln568">  };</a>
<a name="ln569"> </a>
<a name="ln570">  struct SmartsAtomExpr</a>
<a name="ln571">  {</a>
<a name="ln572">    SmartsAtomExpr(int typ) : type(typ) {}</a>
<a name="ln573">    int type;</a>
<a name="ln574">    union {</a>
<a name="ln575">      struct {</a>
<a name="ln576">        int value;</a>
<a name="ln577">      } leaf;</a>
<a name="ln578">      struct {</a>
<a name="ln579">        void *recursive;</a>
<a name="ln580">      } recursive;</a>
<a name="ln581">      struct {</a>
<a name="ln582">        SmartsAtomExpr *arg;</a>
<a name="ln583">      } unary;</a>
<a name="ln584">      struct {</a>
<a name="ln585">        SmartsAtomExpr *lft;</a>
<a name="ln586">        SmartsAtomExpr *rgt;</a>
<a name="ln587">      } binary;</a>
<a name="ln588">    };</a>
<a name="ln589">  };</a>
<a name="ln590"> </a>
<a name="ln591">  struct SmartsBondExpr</a>
<a name="ln592">  {</a>
<a name="ln593">    SmartsBondExpr(int typ) : type(typ) {}</a>
<a name="ln594">    int type;</a>
<a name="ln595">    struct {</a>
<a name="ln596">      SmartsBondExpr *arg;</a>
<a name="ln597">    } unary;</a>
<a name="ln598">    struct {</a>
<a name="ln599">      SmartsBondExpr *lft;</a>
<a name="ln600">      SmartsBondExpr *rgt;</a>
<a name="ln601">    } binary;</a>
<a name="ln602">  };</a>
<a name="ln603"> </a>
<a name="ln604">  struct SmartsAtom</a>
<a name="ln605">  {</a>
<a name="ln606">    SmartsAtom() : expr(nullptr), atomClass(0), chiral(0) {}</a>
<a name="ln607">    SmartsAtom(SmartsAtomExpr *expr_, int ac, bool chrl)</a>
<a name="ln608">        : expr(expr_), atomClass(ac), chiral(chrl) {}</a>
<a name="ln609">    SmartsAtomExpr *expr;</a>
<a name="ln610">    int atomClass;</a>
<a name="ln611">    bool chiral;</a>
<a name="ln612">  };</a>
<a name="ln613"> </a>
<a name="ln614">  struct SmartsBond</a>
<a name="ln615">  {</a>
<a name="ln616">    SmartsBond() : source(0), target(0), grow(false) {}</a>
<a name="ln617">    SmartsBond(int src, int trg, bool grw = false)</a>
<a name="ln618">        : source(src), target(trg), grow(grw) {}</a>
<a name="ln619">    SmartsBondExpr *expr;</a>
<a name="ln620">    int source;</a>
<a name="ln621">    int target;</a>
<a name="ln622">    bool grow;</a>
<a name="ln623">  };</a>
<a name="ln624"> </a>
<a name="ln625">  struct Smarts</a>
<a name="ln626">  {</a>
<a name="ln627">    Smarts() : chiral(false) {}</a>
<a name="ln628">    std::vector&lt;SmartsAtom&gt; atoms;</a>
<a name="ln629">    std::vector&lt;SmartsBond&gt; bonds;</a>
<a name="ln630">    bool chiral;</a>
<a name="ln631">  };</a>
<a name="ln632"> </a>
<a name="ln633">  /**</a>
<a name="ln634">   * Base class for Callback function objects.</a>
<a name="ln635">   */</a>
<a name="ln636">  struct CallbackBase</a>
<a name="ln637">  {</a>
<a name="ln638">    //@name SMILES/SMARTS</a>
<a name="ln639">    //@{</a>
<a name="ln640">    /**</a>
<a name="ln641">     * Prepare the callback functor for a new SMILES/SMARTS. This method is</a>
<a name="ln642">     * always invoked at the start of parsing before any of the other methods.</a>
<a name="ln643">     */</a>
<a name="ln644">    void clear() {}</a>
<a name="ln645">    /**</a>
<a name="ln646">     * Set the chirality for an atom. This method is invoked when the entire</a>
<a name="ln647">     * SMILES/SMARTS is parsed.</a>
<a name="ln648">     */</a>
<a name="ln649">    void setChiral(int index, Chirality chirality, const std::vector&lt;int&gt; &amp;chiralNbrs) {}</a>
<a name="ln650">    //@}</a>
<a name="ln651">    //@name SMILES</a>
<a name="ln652">    /**</a>
<a name="ln653">     * Invoked when an atom is completly parsed.</a>
<a name="ln654">     */</a>
<a name="ln655">    void addAtom(int element, bool aromatic, int isotope, int hCount, int charge, int atomClass) {}</a>
<a name="ln656">    /**</a>
<a name="ln657">     * Invoked once both bon atom are added using addAtom().</a>
<a name="ln658">     */</a>
<a name="ln659">    void addBond(int source, int target, int order, bool isUp, bool isDown) {}</a>
<a name="ln660">    //@}</a>
<a name="ln661">    //@name SMARTS</a>
<a name="ln662">    //@{</a>
<a name="ln663">    /**</a>
<a name="ln664">     * Invoked when a unary or binary logical operator is parsed</a>
<a name="ln665">     * (i.e. '&amp;', ';' or ','). This method is also invoked for implicit AND.</a>
<a name="ln666">     */</a>
<a name="ln667">    void operation(int type) {}</a>
<a name="ln668">    /**</a>
<a name="ln669">     * Invoked when an unbracketed atom (i.e. organic subset) is parsed.</a>
<a name="ln670">     */</a>
<a name="ln671">    void addOrganicSubsetAtom(int element, bool aromatic) {}</a>
<a name="ln672">    /**</a>
<a name="ln673">     * Invoked when an atom primitive is parsed.</a>
<a name="ln674">     */</a>
<a name="ln675">    void atomPrimitive(int type, int value) {}</a>
<a name="ln676">    /**</a>
<a name="ln677">     * Invoked when a bond primitive is parsed. This method is also invoked for</a>
<a name="ln678">     * implicit bonds.</a>
<a name="ln679">     */</a>
<a name="ln680">    void bondPrimitive(int type) {}</a>
<a name="ln681">    /**</a>
<a name="ln682">     * Invoked when a branch ends and the next bond should start from a</a>
<a name="ln683">     * previously parsed atom expression with specified @p index.</a>
<a name="ln684">     */</a>
<a name="ln685">    void setPrevious(int index) {}</a>
<a name="ln686">    /**</a>
<a name="ln687">     * Invoked when a new ring bond number is parsed.</a>
<a name="ln688">     */</a>
<a name="ln689">    void startRingBond(int number) {}</a>
<a name="ln690">    /**</a>
<a name="ln691">     * Invoked when a prviously found ring bond number is parsed to add the bond.</a>
<a name="ln692">     */</a>
<a name="ln693">    void endRingBond(int number, int index) {}</a>
<a name="ln694">    //@}</a>
<a name="ln695">  };</a>
<a name="ln696"> </a>
<a name="ln697">  /**</a>
<a name="ln698">   * Example Callback implementation to print the parsed results.</a>
<a name="ln699">   */</a>
<a name="ln700">  struct PrintCallback : public CallbackBase</a>
<a name="ln701">  {</a>
<a name="ln702">    /**</a>
<a name="ln703">     * The clear() method is invoked when Parser::parse() is called and should</a>
<a name="ln704">     * be used to initialize the callback function object to receive events for</a>
<a name="ln705">     * a new SMILES/SMARTS.</a>
<a name="ln706">     */</a>
<a name="ln707">    void clear()</a>
<a name="ln708">    {</a>
<a name="ln709">      str.clear();</a>
<a name="ln710">    }</a>
<a name="ln711"> </a>
<a name="ln712">    /**</a>
<a name="ln713">     * The addAtom() method is invoked when an atom is completly parsed.</a>
<a name="ln714">     */</a>
<a name="ln715">    void addAtom(int element, bool aromatic, int isotope, int hCount, int charge, int atomClass)</a>
<a name="ln716">    {</a>
<a name="ln717">      std::cout &lt;&lt; &quot;addAtom:&quot; &lt;&lt; std::endl</a>
<a name="ln718">        &lt;&lt; &quot;    element: &quot; &lt;&lt; element &lt;&lt; std::endl</a>
<a name="ln719">        &lt;&lt; &quot;    aromatic: &quot; &lt;&lt; aromatic &lt;&lt; std::endl</a>
<a name="ln720">        &lt;&lt; &quot;    isotope: &quot; &lt;&lt; isotope &lt;&lt; std::endl</a>
<a name="ln721">        &lt;&lt; &quot;    hCount: &quot; &lt;&lt; hCount &lt;&lt; std::endl</a>
<a name="ln722">        &lt;&lt; &quot;    charge: &quot; &lt;&lt; charge &lt;&lt; std::endl</a>
<a name="ln723">        &lt;&lt; &quot;    atomClass: &quot; &lt;&lt; atomClass &lt;&lt; std::endl;</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    /**</a>
<a name="ln727">     * The addBond() method is invoked once both of the bond's atoms have been</a>
<a name="ln728">     * added (by calling addAtom()). Therefore are the bond indices always</a>
<a name="ln729">     * valid.</a>
<a name="ln730">     */</a>
<a name="ln731">    void addBond(int source, int target, int order, bool isUp, bool isDown)</a>
<a name="ln732">    {</a>
<a name="ln733">      std::cout &lt;&lt; &quot;addBond:&quot; &lt;&lt; std::endl</a>
<a name="ln734">        &lt;&lt; &quot;    source: &quot; &lt;&lt; source &lt;&lt; std::endl</a>
<a name="ln735">        &lt;&lt; &quot;    target: &quot; &lt;&lt; target &lt;&lt; std::endl</a>
<a name="ln736">        &lt;&lt; &quot;    order: &quot; &lt;&lt; order &lt;&lt; std::endl</a>
<a name="ln737">        &lt;&lt; &quot;    siUp: &quot; &lt;&lt; isUp &lt;&lt; std::endl</a>
<a name="ln738">        &lt;&lt; &quot;    isDown: &quot; &lt;&lt; isDown &lt;&lt; std::endl;</a>
<a name="ln739">    }</a>
<a name="ln740"> </a>
<a name="ln741">    /**</a>
<a name="ln742">     * The setChiral() method is invoked at the end of parsing for each atom</a>
<a name="ln743">     * that has a chirality specified.</a>
<a name="ln744">     */</a>
<a name="ln745">    void setChiral(int index, Chirality chirality, const std::vector&lt;int&gt; &amp;nbrs)</a>
<a name="ln746">    {</a>
<a name="ln747">      std::cout &lt;&lt; &quot;setChiral:&quot; &lt;&lt; std::endl</a>
<a name="ln748">                &lt;&lt; &quot;    index: &quot; &lt;&lt; index &lt;&lt; std::endl</a>
<a name="ln749">                &lt;&lt; &quot;    chirality: &quot; &lt;&lt; chirality &lt;&lt; std::endl</a>
<a name="ln750">                &lt;&lt; &quot;    nbrs: &quot;;</a>
<a name="ln751">      for (std::size_t i = 0; i &lt; nbrs.size(); ++i)</a>
<a name="ln752">        std::cout &lt;&lt; nbrs[i] &lt;&lt; &quot; &quot;;</a>
<a name="ln753">      std::cout &lt;&lt; std::endl;</a>
<a name="ln754">    }</a>
<a name="ln755"> </a>
<a name="ln756">    void operation(int type)</a>
<a name="ln757">    {</a>
<a name="ln758">      switch (type) {</a>
<a name="ln759">        case OP_Not:</a>
<a name="ln760">          str += &quot;!&quot;;</a>
<a name="ln761">          break;</a>
<a name="ln762">        case OP_AndHi:</a>
<a name="ln763">          str += &quot;&amp;&quot;;</a>
<a name="ln764">          break;</a>
<a name="ln765">        case OP_AndLo:</a>
<a name="ln766">          str += &quot;;&quot;;</a>
<a name="ln767">          break;</a>
<a name="ln768">        case OP_Or:</a>
<a name="ln769">          str += &quot;,&quot;;</a>
<a name="ln770">          break;</a>
<a name="ln771">      }</a>
<a name="ln772">      std::cout &lt;&lt; &quot;operation: &quot; &lt;&lt; str[str.size() - 1] &lt;&lt; std::endl;</a>
<a name="ln773">    }</a>
<a name="ln774"> </a>
<a name="ln775">    void addOrganicSubsetAtom(int element, bool aromatic)</a>
<a name="ln776">    {</a>
<a name="ln777">      std::size_t pos = str.size();</a>
<a name="ln778">      if (element == 0)</a>
<a name="ln779">        str+= &quot;*&quot;;</a>
<a name="ln780">      else if (aromatic)</a>
<a name="ln781">        str += &quot;&lt;a&quot; + number2string(element) + &quot;&gt;&quot;;</a>
<a name="ln782">      else</a>
<a name="ln783">        str += &quot;&lt;A&quot; + number2string(element) + &quot;&gt;&quot;;</a>
<a name="ln784">      std::cout &lt;&lt; &quot;addOrganicSubsetAtom: &quot; &lt;&lt; str.substr(pos) &lt;&lt; std::endl;</a>
<a name="ln785">    }</a>
<a name="ln786"> </a>
<a name="ln787">    std::string number2string(int value)</a>
<a name="ln788">    {</a>
<a name="ln789">      std::stringstream ss;</a>
<a name="ln790">      ss &lt;&lt; value;</a>
<a name="ln791">      return ss.str();</a>
<a name="ln792">    }</a>
<a name="ln793"> </a>
<a name="ln794">    void atomPrimitive(int type, int value)</a>
<a name="ln795">    {</a>
<a name="ln796">      std::size_t pos = str.size();</a>
<a name="ln797">      switch (type) {</a>
<a name="ln798">        case AE_True:</a>
<a name="ln799">          str += &quot;*&quot;;</a>
<a name="ln800">          break;</a>
<a name="ln801">        case AE_False:</a>
<a name="ln802">          str += &quot;!*&quot;;</a>
<a name="ln803">          break;</a>
<a name="ln804">        case AE_Aromatic:</a>
<a name="ln805">          str += &quot;a&quot;;</a>
<a name="ln806">          break;</a>
<a name="ln807">        case AE_Aliphatic:</a>
<a name="ln808">          str += &quot;A&quot;;</a>
<a name="ln809">          break;</a>
<a name="ln810">        case AE_Cyclic:</a>
<a name="ln811">          str += &quot;R&quot;;</a>
<a name="ln812">          break;</a>
<a name="ln813">        case AE_Acyclic:</a>
<a name="ln814">          str += &quot;R0&quot;;</a>
<a name="ln815">          break;</a>
<a name="ln816">        case AE_Isotope:</a>
<a name="ln817">          str += number2string(value);</a>
<a name="ln818">          break;</a>
<a name="ln819">        case AE_AtomicNumber:</a>
<a name="ln820">          str += &quot;#&quot; + number2string(value);</a>
<a name="ln821">          break;</a>
<a name="ln822">        case AE_AromaticElement:</a>
<a name="ln823">          str += &quot;&lt;a&quot; + number2string(value) + &quot;&gt;&quot;;</a>
<a name="ln824">          break;</a>
<a name="ln825">        case AE_AliphaticElement:</a>
<a name="ln826">          str += &quot;&lt;A&quot; + number2string(value) + &quot;&gt;&quot;;</a>
<a name="ln827">          break;</a>
<a name="ln828">        case AE_Degree:</a>
<a name="ln829">          str += &quot;D&quot; + number2string(value);</a>
<a name="ln830">          break;</a>
<a name="ln831">        case AE_Valence:</a>
<a name="ln832">          str += &quot;v&quot; + number2string(value);</a>
<a name="ln833">          break;</a>
<a name="ln834">        case AE_Connectivity:</a>
<a name="ln835">          str += &quot;X&quot; + number2string(value);</a>
<a name="ln836">          break;</a>
<a name="ln837">        case AE_TotalH:</a>
<a name="ln838">          str += &quot;H&quot; + number2string(value);</a>
<a name="ln839">          break;</a>
<a name="ln840">        case AE_ImplicitH:</a>
<a name="ln841">          str += &quot;h&quot; + number2string(value);</a>
<a name="ln842">          break;</a>
<a name="ln843">        case AE_RingMembership:</a>
<a name="ln844">          str += &quot;R&quot; + number2string(value);</a>
<a name="ln845">          break;</a>
<a name="ln846">        case AE_RingSize:</a>
<a name="ln847">          str += &quot;r&quot; + number2string(value);</a>
<a name="ln848">          break;</a>
<a name="ln849">        case AE_RingConnectivity:</a>
<a name="ln850">          str += &quot;x&quot; + number2string(value);</a>
<a name="ln851">          break;</a>
<a name="ln852">        case AE_Charge:</a>
<a name="ln853">          if (value &gt; 0)</a>
<a name="ln854">            str += &quot;+&quot;;</a>
<a name="ln855">          str += number2string(value);</a>
<a name="ln856">          break;</a>
<a name="ln857">        case AE_Chirality:</a>
<a name="ln858">          str += &quot;@&quot; + number2string(value);</a>
<a name="ln859">          break;</a>
<a name="ln860">        case AE_AtomClass:</a>
<a name="ln861">          str += &quot;:&quot; + number2string(value);</a>
<a name="ln862">          break;</a>
<a name="ln863">        default:</a>
<a name="ln864">          return;</a>
<a name="ln865">      }</a>
<a name="ln866">      std::cout &lt;&lt; &quot;atomPrimitive: &quot; &lt;&lt; str.substr(pos) &lt;&lt; std::endl;</a>
<a name="ln867">    }</a>
<a name="ln868"> </a>
<a name="ln869">    void bondPrimitive(int type)</a>
<a name="ln870">    {</a>
<a name="ln871">      switch (type) {</a>
<a name="ln872">        case BE_Single:</a>
<a name="ln873">          str += &quot;-&quot;;</a>
<a name="ln874">          break;</a>
<a name="ln875">        case BE_Double:</a>
<a name="ln876">          str += &quot;=&quot;;</a>
<a name="ln877">          break;</a>
<a name="ln878">        case BE_Triple:</a>
<a name="ln879">          str += &quot;#&quot;;</a>
<a name="ln880">          break;</a>
<a name="ln881">        case BE_Quadriple:</a>
<a name="ln882">          str += &quot;$&quot;;</a>
<a name="ln883">          break;</a>
<a name="ln884">        case BE_Aromatic:</a>
<a name="ln885">          str += &quot;:&quot;;</a>
<a name="ln886">          break;</a>
<a name="ln887">        case BE_Up:</a>
<a name="ln888">          str += &quot;/&quot;;</a>
<a name="ln889">          break;</a>
<a name="ln890">        case BE_Down:</a>
<a name="ln891">          str += &quot;\\&quot;;</a>
<a name="ln892">          break;</a>
<a name="ln893">        case BE_Any:</a>
<a name="ln894">          str += &quot;~&quot;;</a>
<a name="ln895">          break;</a>
<a name="ln896">        case BE_Ring:</a>
<a name="ln897">          str += &quot;@&quot;;</a>
<a name="ln898">          break;</a>
<a name="ln899">        default:</a>
<a name="ln900">          return;</a>
<a name="ln901">      }</a>
<a name="ln902">      std::cout &lt;&lt; &quot;bondPrimitive: &quot; &lt;&lt; str[str.size() - 1] &lt;&lt; std::endl;</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">    void setPrevious(int index)</a>
<a name="ln906">    {</a>
<a name="ln907">      str += number2string(index);</a>
<a name="ln908">      std::cout &lt;&lt; &quot;setPrevious: &quot; &lt;&lt; index &lt;&lt; std::endl;</a>
<a name="ln909">    }</a>
<a name="ln910"> </a>
<a name="ln911">    void startRingBond(int number)</a>
<a name="ln912">    {</a>
<a name="ln913">      str += number2string(number);</a>
<a name="ln914">      std::cout &lt;&lt; &quot;startRingBond: &quot; &lt;&lt; number &lt;&lt; std::endl;</a>
<a name="ln915">    }</a>
<a name="ln916"> </a>
<a name="ln917">    void startRingBond(int number, int index)</a>
<a name="ln918">    {</a>
<a name="ln919">      str += number2string(number);</a>
<a name="ln920">      std::cout &lt;&lt; &quot;startRingBond: &quot; &lt;&lt; number &lt;&lt; std::endl</a>
<a name="ln921">                &lt;&lt; &quot;    index: &quot; &lt;&lt; index &lt;&lt; std::endl;</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">    std::string str;</a>
<a name="ln925">  };</a>
<a name="ln926"> </a>
<a name="ln927">  /**</a>
<a name="ln928">   * @class Parser smiley.h &lt;smiley.h&gt;</a>
<a name="ln929">   *</a>
<a name="ln930">   * This is the main class for the Smiley SMILES/SMARTS parser.</a>
<a name="ln931">   *</a>
<a name="ln932">   * @code</a>
<a name="ln933">   * #include &quot;smiley.h&quot;</a>
<a name="ln934">   *</a>
<a name="ln935">   * using namespace Smiley;</a>
<a name="ln936">   *</a>
<a name="ln937">   * int main(int argc, char **argv)</a>
<a name="ln938">   * {</a>
<a name="ln939">   *   PrintCallback callback;</a>
<a name="ln940">   *   Parser&lt;PrintCallback&gt; parser(callback);</a>
<a name="ln941">   *</a>
<a name="ln942">   *   try {</a>
<a name="ln943">   *     parser.parse(argv[1]);</a>
<a name="ln944">   *   } catch (Exception &amp;e) {</a>
<a name="ln945">   *     if (e.type() == Exception::SyntaxError)</a>
<a name="ln946">   *       std::cerr &lt;&lt; &quot;Syntax&quot;;</a>
<a name="ln947">   *     else</a>
<a name="ln948">   *       std::cerr &lt;&lt; &quot;Semantics&quot;;</a>
<a name="ln949">   *     std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</a>
<a name="ln950">   *     std::cerr &lt;&lt; argv[1] &lt;&lt; std::endl;</a>
<a name="ln951">   *     for (std::size_t i = 0; i &lt; e.pos(); ++i)</a>
<a name="ln952">   *       std::cerr &lt;&lt; &quot; &quot;;</a>
<a name="ln953">   *     for (std::size_t i = 0; i &lt; e.length(); ++i)</a>
<a name="ln954">   *       std::cerr &lt;&lt; &quot;^&quot;;</a>
<a name="ln955">   *     std::cerr &lt;&lt; std::endl;</a>
<a name="ln956">   *   }</a>
<a name="ln957">   * }</a>
<a name="ln958">   * @endcode</a>
<a name="ln959">   */</a>
<a name="ln960">  template&lt;typename Callback&gt;</a>
<a name="ln961">  class Parser</a>
<a name="ln962">  {</a>
<a name="ln963">    private:</a>
<a name="ln964">      /**</a>
<a name="ln965">       * Internal structure to hold ring bond information.</a>
<a name="ln966">       */</a>
<a name="ln967">      struct RingBondInfo</a>
<a name="ln968">      {</a>
<a name="ln969">        RingBondInfo() : number(-1), order(-1), isUp(false), isDown(false),</a>
<a name="ln970">            pos(std::string::npos)</a>
<a name="ln971">        {</a>
<a name="ln972">        }</a>
<a name="ln973"> </a>
<a name="ln974">        RingBondInfo(int number_, int order_, bool isUp_, bool isDown_,</a>
<a name="ln975">            bool isExplicit_, std::size_t pos_) : number(number_),</a>
<a name="ln976">            order(order_), isUp(isUp_), isDown(isDown_),</a>
<a name="ln977">            isExplicit(isExplicit_), pos(pos_)</a>
<a name="ln978">        {</a>
<a name="ln979">        }</a>
<a name="ln980"> </a>
<a name="ln981">        std::size_t pos;</a>
<a name="ln982">        int number;</a>
<a name="ln983">        int order;</a>
<a name="ln984">        bool isUp;</a>
<a name="ln985">        bool isDown;</a>
<a name="ln986">        bool isExplicit;</a>
<a name="ln987">      };</a>
<a name="ln988"> </a>
<a name="ln989">      /**</a>
<a name="ln990">       * Internal structure to hold branch information.</a>
<a name="ln991">       */</a>
<a name="ln992">      struct BranchInfo</a>
<a name="ln993">      {</a>
<a name="ln994">        BranchInfo() : pos(std::string::npos), index(-1)</a>
<a name="ln995">        {</a>
<a name="ln996">        }</a>
<a name="ln997"> </a>
<a name="ln998">        BranchInfo(int index_, std::size_t pos_) : pos(pos_), index(index_)</a>
<a name="ln999">        {</a>
<a name="ln1000">        }</a>
<a name="ln1001"> </a>
<a name="ln1002">        std::size_t pos;</a>
<a name="ln1003">        int index;</a>
<a name="ln1004">      };</a>
<a name="ln1005"> </a>
<a name="ln1006">      /**</a>
<a name="ln1007">       * Internal structure to hold chiral information</a>
<a name="ln1008">       */</a>
<a name="ln1009">      struct ChiralInfo</a>
<a name="ln1010">      {</a>
<a name="ln1011">        ChiralInfo() : pos(std::string::npos), chiral(NotChiral)</a>
<a name="ln1012">        {</a>
<a name="ln1013">        }</a>
<a name="ln1014"> </a>
<a name="ln1015">        ChiralInfo(Chirality chirality, std::size_t pos_) : pos(pos_), chiral(chirality)</a>
<a name="ln1016">        {</a>
<a name="ln1017">        }</a>
<a name="ln1018"> </a>
<a name="ln1019">        std::size_t pos;</a>
<a name="ln1020">        std::vector&lt;int&gt; nbrs;</a>
<a name="ln1021">        Chirality chiral;</a>
<a name="ln1022">      };</a>
<a name="ln1023"> </a>
<a name="ln1024">      /**</a>
<a name="ln1025">       * find a matching bracket with the open bracket at position @p pos.</a>
<a name="ln1026">       *</a>
<a name="ln1027">       * @param open Open bracket symbol (e.g. &quot;[&quot; or &quot;(&quot;).</a>
<a name="ln1028">       * @param close Close bracket symbol (e.g. &quot;]&quot; or &quot;)&quot;).</a>
<a name="ln1029">       * @param pos Position of the opening bracket.</a>
<a name="ln1030">       * @return The position of the matching closing bracket. Throws SyntaxError</a>
<a name="ln1031">       *         exception if there is no matching bracket.</a>
<a name="ln1032">       *</a>
<a name="ln1033">       * Examples:</a>
<a name="ln1034">       * @verbatim</a>
<a name="ln1035">       * findMatchingBracket(&quot;[&quot;, &quot;]&quot;, 2) -&gt; 6, 15</a>
<a name="ln1036">       *</a>
<a name="ln1037">       * str: &quot;CC[13C]CC&quot;     str: &quot;CC[N$(CC[NH3+])]CC&quot;</a>
<a name="ln1038">       *         ^   ^                ^            ^</a>
<a name="ln1039">       *         2   6                2            15</a>
<a name="ln1040">       * @endverbatim</a>
<a name="ln1041">       */</a>
<a name="ln1042">      std::size_t findMatchingBracket(const std::string &amp;open, const std::string &amp;close, std::size_t pos = 0)</a>
<a name="ln1043">      {</a>
<a name="ln1044">        std::size_t indent = 1;</a>
<a name="ln1045">        while (indent) {</a>
<a name="ln1046">          std::size_t open_pos = m_str.find(open, pos + 1);</a>
<a name="ln1047">          std::size_t close_pos = m_str.find(close, pos + 1);</a>
<a name="ln1048">          // syntax error when there is no closing bracket</a>
<a name="ln1049">          if (close_pos == std::string::npos)</a>
<a name="ln1050">            throw Exception(Exception::SyntaxError, NoClosingAtomBracket,</a>
<a name="ln1051">                &quot;Could not find matching bracket&quot;, pos, m_str.size() - pos);</a>
<a name="ln1052">          if (open_pos &gt; close_pos) {</a>
<a name="ln1053">            --indent;</a>
<a name="ln1054">            pos = close_pos;</a>
<a name="ln1055">          } else {</a>
<a name="ln1056">            ++indent;</a>
<a name="ln1057">            pos = open_pos;</a>
<a name="ln1058">          }</a>
<a name="ln1059">        }</a>
<a name="ln1060">        return pos;</a>
<a name="ln1061">      }</a>
<a name="ln1062"> </a>
<a name="ln1063">      /**</a>
<a name="ln1064">       * Check the character at position @p m_pos. If the next character matches</a>
<a name="ln1065">       * @p chr, position @p m_pos is incremeneted.</a>
<a name="ln1066">       *</a>
<a name="ln1067">       * @param chr The character to check for.</a>
<a name="ln1068">       * @return True if the character matches.</a>
<a name="ln1069">       */</a>
<a name="ln1070">      bool checkNextChar(char chr)</a>
<a name="ln1071">      {</a>
<a name="ln1072">        if (m_pos + 1 &gt;= m_str.size())</a>
<a name="ln1073">          return false;</a>
<a name="ln1074">        bool match = m_str[m_pos + 1] == chr;</a>
<a name="ln1075">        if (match)</a>
<a name="ln1076">          ++m_pos;</a>
<a name="ln1077">        return match;</a>
<a name="ln1078">      }</a>
<a name="ln1079"> </a>
<a name="ln1080">      void print_chiralNbrs()</a>
<a name="ln1081">      {</a>
<a name="ln1082">        for (std::size_t i = 0; i &lt; m_chiralInfo.size(); ++i) {</a>
<a name="ln1083">          std::cout &lt;&lt; &quot;chiralNbrs for &quot; &lt;&lt; i &lt;&lt; &quot;: &quot;;</a>
<a name="ln1084">          for (std::size_t j = 0; j &lt; m_chiralInfo[i].nbrs.size(); ++j)</a>
<a name="ln1085">            std::cout &lt;&lt; m_chiralInfo[i].nbrs[j] &lt;&lt; &quot; &quot;;</a>
<a name="ln1086">          std::cout &lt;&lt; std::endl;</a>
<a name="ln1087">        }</a>
<a name="ln1088">      }</a>
<a name="ln1089"> </a>
<a name="ln1090">      /**</a>
<a name="ln1091">       * Add a bond by calling the callback's addBond() member function.</a>
<a name="ln1092">       *</a>
<a name="ln1093">       * @param source Bond source atom index (0...N)</a>
<a name="ln1094">       * @param target Bond target atom index (0...N)</a>
<a name="ln1095">       * @param order The bond order.</a>
<a name="ln1096">       */</a>
<a name="ln1097">      void addBond(int source, int target, int order, bool isUp, bool isDown, int rnum = 0)</a>
<a name="ln1098">      {</a>
<a name="ln1099">        //std::cout &lt;&lt; &quot;addBond(&quot; &lt;&lt; source &lt;&lt; &quot;, &quot; &lt;&lt; target &lt;&lt; &quot;, rnum = &quot; &lt;&lt; rnum &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1100">        //print_chiralNbrs();</a>
<a name="ln1101"> </a>
<a name="ln1102">        // check for parallel ring bonds</a>
<a name="ln1103">        for (std::size_t i = 0; i &lt; m_chiralInfo[source].nbrs.size(); i++) {</a>
<a name="ln1104">          int nbr = m_chiralInfo[source].nbrs[i];</a>
<a name="ln1105">          if (nbr == target) {</a>
<a name="ln1106">            if (m_exceptions &amp; InvalidRingBond)</a>
<a name="ln1107">              throw Exception(Exception::SemanticsError, InvalidRingBond,</a>
<a name="ln1108">                  &quot;Parallel ring bond&quot;, 0, 0);</a>
<a name="ln1109">            else</a>
<a name="ln1110">              return; // ignore parallel bond</a>
<a name="ln1111">          }</a>
<a name="ln1112">        }</a>
<a name="ln1113">        // check for self-loop ring bonds</a>
<a name="ln1114">        if (source == target) {</a>
<a name="ln1115">          if (m_exceptions &amp; InvalidRingBond)</a>
<a name="ln1116">            throw Exception(Exception::SemanticsError, InvalidRingBond,</a>
<a name="ln1117">                &quot;Self-loop ring bond&quot;, 0, 0);</a>
<a name="ln1118">          else</a>
<a name="ln1119">            return; // ignore self-loop</a>
<a name="ln1120">        }</a>
<a name="ln1121"> </a>
<a name="ln1122">        if (rnum)</a>
<a name="ln1123">          m_callback.addBond(target, source, order, isUp, isDown);</a>
<a name="ln1124">        else</a>
<a name="ln1125">          m_callback.addBond(source, target, order, isUp, isDown);</a>
<a name="ln1126"> </a>
<a name="ln1127">        if (!rnum) {</a>
<a name="ln1128">          m_chiralInfo[source].nbrs.push_back(target);</a>
<a name="ln1129">        } else {</a>
<a name="ln1130">          for (std::size_t i = 0; i &lt; m_chiralInfo.size(); ++i)</a>
<a name="ln1131">            for (std::size_t j = 0; j &lt; m_chiralInfo[i].nbrs.size(); ++j)</a>
<a name="ln1132">              if (m_chiralInfo[i].nbrs[j] == -rnum)</a>
<a name="ln1133">                m_chiralInfo[i].nbrs[j] = target;</a>
<a name="ln1134">        }</a>
<a name="ln1135"> </a>
<a name="ln1136">        if (m_chiralInfo[target].nbrs.size() &amp;&amp; m_chiralInfo[target].nbrs.front() == implicitHydrogen())</a>
<a name="ln1137">          m_chiralInfo[target].nbrs.insert(m_chiralInfo[target].nbrs.begin(), source);</a>
<a name="ln1138">        else</a>
<a name="ln1139">          m_chiralInfo[target].nbrs.push_back(source);</a>
<a name="ln1140">      }</a>
<a name="ln1141"> </a>
<a name="ln1142">      /**</a>
<a name="ln1143">       * Add an atom by calling the callback's addAtom() member function. If</a>
<a name="ln1144">       * there is a previous atom (i.e. @p m_prev != -1) then the bond between</a>
<a name="ln1145">       * the new atom and the previous atom will by added by calling addBond()</a>
<a name="ln1146">       * after adding the new atom.</a>
<a name="ln1147">       */</a>
<a name="ln1148">      void addAtom(int element, bool aromatic = false, int isotope = -1, int hCount = -1, int charge = 0, int atomClass = 0)</a>
<a name="ln1149">      {</a>
<a name="ln1150">        // check for [HH1]</a>
<a name="ln1151">        if (element == H &amp;&amp; hCount != 0)</a>
<a name="ln1152">          throw Exception(Exception::SemanticsError, HydrogenHydrogenCount,</a>
<a name="ln1153">              &quot;Hydrogen atoms can not have a hydrogen count&quot;, 0, 0);</a>
<a name="ln1154"> </a>
<a name="ln1155">        if (m_mode == SmilesMode)</a>
<a name="ln1156">          m_callback.addAtom(element, aromatic, isotope, hCount, charge, atomClass);</a>
<a name="ln1157">        else</a>
<a name="ln1158">          m_callback.addOrganicSubsetAtom(element, aromatic);</a>
<a name="ln1159"> </a>
<a name="ln1160">        if (m_prev != -1)</a>
<a name="ln1161">          addBond(m_prev, m_index, m_bondOrder, m_isUp, m_isDown);</a>
<a name="ln1162"> </a>
<a name="ln1163">        m_prev = m_index;</a>
<a name="ln1164">        ++m_index;</a>
<a name="ln1165">        m_chiralInfo.push_back(ChiralInfo());</a>
<a name="ln1166">      }</a>
<a name="ln1167"> </a>
<a name="ln1168">      /**</a>
<a name="ln1169">       * Reset the bond information.</a>
<a name="ln1170">       */</a>
<a name="ln1171">      void resetBondInfo()</a>
<a name="ln1172">      {</a>
<a name="ln1173">        // reset bond info</a>
<a name="ln1174">        m_bondOrder = 1;</a>
<a name="ln1175">        m_isUp = false;</a>
<a name="ln1176">        m_isDown = false;</a>
<a name="ln1177">        m_explicitBond = false;</a>
<a name="ln1178">      }</a>
<a name="ln1179"> </a>
<a name="ln1180">      /**</a>
<a name="ln1181">       * @code</a>
<a name="ln1182">       * isotope ::= NUMBER</a>
<a name="ln1183">       * @endcode</a>
<a name="ln1184">       */</a>
<a name="ln1185">      void parseIsotope()</a>
<a name="ln1186">      {</a>
<a name="ln1187">        m_isotope = 0;</a>
<a name="ln1188">        bool found_isotope = false;</a>
<a name="ln1189">        while (std::isdigit(m_str[m_pos])) {</a>
<a name="ln1190">          m_isotope *= 10;</a>
<a name="ln1191">          m_isotope += m_str[m_pos] - '0';</a>
<a name="ln1192">          ++m_pos;</a>
<a name="ln1193">          found_isotope = true;</a>
<a name="ln1194">        }</a>
<a name="ln1195">        if (!found_isotope)</a>
<a name="ln1196">          m_isotope = -1;</a>
<a name="ln1197">      }</a>
<a name="ln1198"> </a>
<a name="ln1199">      /**</a>
<a name="ln1200">       * @code</a>
<a name="ln1201">       * symbol ::= element_symbols | aromatic_symbols | '*'</a>
<a name="ln1202">       * element_symbols ::= 'H' | 'He' | 'Li' | ... | 'No' | 'Lr'</a>
<a name="ln1203">       * aromatic_symbols ::= 'c' | 'n' | 'o' | 'p' | 's' | 'se' | 'as'</a>
<a name="ln1204">       * @endcode</a>
<a name="ln1205">       *</a>
<a name="ln1206">       * @return std::pair with element in first and aromatic in second.</a>
<a name="ln1207">       */</a>
<a name="ln1208">      std::pair&lt;int, bool&gt; parseSymbol(bool ignoreHydrogen = false)</a>
<a name="ln1209">      {</a>
<a name="ln1210">        switch (m_str[m_pos]) {</a>
<a name="ln1211">          case 'H':</a>
<a name="ln1212">            if (checkNextChar('e'))</a>
<a name="ln1213">              m_element = He;</a>
<a name="ln1214">            else if (checkNextChar('f'))</a>
<a name="ln1215">              m_element = Hf;</a>
<a name="ln1216">            else if (checkNextChar('g'))</a>
<a name="ln1217">              m_element = Hg;</a>
<a name="ln1218">            else if (checkNextChar('s'))</a>
<a name="ln1219">              m_element = Hs;</a>
<a name="ln1220">            else if (checkNextChar('o'))</a>
<a name="ln1221">              m_element = Ho;</a>
<a name="ln1222">            else if (!ignoreHydrogen)</a>
<a name="ln1223">              m_element = H;</a>
<a name="ln1224">            break;</a>
<a name="ln1225">          case 'L':</a>
<a name="ln1226">            if (checkNextChar('i'))</a>
<a name="ln1227">              m_element = Li;</a>
<a name="ln1228">            else if (checkNextChar('a'))</a>
<a name="ln1229">              m_element = La;</a>
<a name="ln1230">            else if (checkNextChar('u'))</a>
<a name="ln1231">              m_element = Lu;</a>
<a name="ln1232">            else if (checkNextChar('r'))</a>
<a name="ln1233">              m_element = Lr;</a>
<a name="ln1234">            else if (checkNextChar('v'))</a>
<a name="ln1235">              m_element = Lv;</a>
<a name="ln1236">            break;</a>
<a name="ln1237">          case 'B':</a>
<a name="ln1238">            if (checkNextChar('e'))</a>
<a name="ln1239">              m_element = Be;</a>
<a name="ln1240">            else if (checkNextChar('r'))</a>
<a name="ln1241">              m_element = Br;</a>
<a name="ln1242">            else if (checkNextChar('a'))</a>
<a name="ln1243">              m_element = Ba;</a>
<a name="ln1244">            else if (checkNextChar('i'))</a>
<a name="ln1245">              m_element = Bi;</a>
<a name="ln1246">            else if (checkNextChar('h'))</a>
<a name="ln1247">              m_element = Bh;</a>
<a name="ln1248">            else if (checkNextChar('k'))</a>
<a name="ln1249">              m_element = Bk;</a>
<a name="ln1250">            else</a>
<a name="ln1251">              m_element = B;</a>
<a name="ln1252">            break;</a>
<a name="ln1253">          case 'C':</a>
<a name="ln1254">            if (checkNextChar('l'))</a>
<a name="ln1255">              m_element = Cl;</a>
<a name="ln1256">            else if (checkNextChar('a'))</a>
<a name="ln1257">              m_element = Ca;</a>
<a name="ln1258">            else if (checkNextChar('r'))</a>
<a name="ln1259">              m_element = Cr;</a>
<a name="ln1260">            else if (checkNextChar('o'))</a>
<a name="ln1261">              m_element = Co;</a>
<a name="ln1262">            else if (checkNextChar('u'))</a>
<a name="ln1263">              m_element = Cu;</a>
<a name="ln1264">            else if (checkNextChar('d'))</a>
<a name="ln1265">              m_element = Cd;</a>
<a name="ln1266">            else if (checkNextChar('s'))</a>
<a name="ln1267">              m_element = Cs;</a>
<a name="ln1268">            else if (checkNextChar('e'))</a>
<a name="ln1269">              m_element = Ce;</a>
<a name="ln1270">            else if (checkNextChar('m'))</a>
<a name="ln1271">              m_element = Cm;</a>
<a name="ln1272">            else if (checkNextChar('f'))</a>
<a name="ln1273">              m_element = Cf;</a>
<a name="ln1274">            else if (checkNextChar('n'))</a>
<a name="ln1275">              m_element = Cn;</a>
<a name="ln1276">            else</a>
<a name="ln1277">              m_element = C;</a>
<a name="ln1278">            break;</a>
<a name="ln1279">          case 'N':</a>
<a name="ln1280">            if (checkNextChar('e'))</a>
<a name="ln1281">              m_element = Ne;</a>
<a name="ln1282">            else if (checkNextChar('a'))</a>
<a name="ln1283">              m_element = Na;</a>
<a name="ln1284">            else if (checkNextChar('i'))</a>
<a name="ln1285">              m_element = Ni;</a>
<a name="ln1286">            else if (checkNextChar('b'))</a>
<a name="ln1287">              m_element = Nb;</a>
<a name="ln1288">            else if (checkNextChar('d'))</a>
<a name="ln1289">              m_element = Nd;</a>
<a name="ln1290">            else if (checkNextChar('p'))</a>
<a name="ln1291">              m_element = Np;</a>
<a name="ln1292">            else if (checkNextChar('o'))</a>
<a name="ln1293">              m_element = No;</a>
<a name="ln1294">            else</a>
<a name="ln1295">              m_element = N;</a>
<a name="ln1296">            break;</a>
<a name="ln1297">          case 'O':</a>
<a name="ln1298">            if (checkNextChar('s'))</a>
<a name="ln1299">              m_element = Os;</a>
<a name="ln1300">            else</a>
<a name="ln1301">              m_element = O;</a>
<a name="ln1302">            break;</a>
<a name="ln1303">          case 'F':</a>
<a name="ln1304">            if (checkNextChar('e'))</a>
<a name="ln1305">              m_element = Fe;</a>
<a name="ln1306">            else if (checkNextChar('r'))</a>
<a name="ln1307">              m_element = Fr;</a>
<a name="ln1308">            else if (checkNextChar('m'))</a>
<a name="ln1309">              m_element = Fm;</a>
<a name="ln1310">            else if (checkNextChar('l'))</a>
<a name="ln1311">              m_element = Fl;</a>
<a name="ln1312">            else</a>
<a name="ln1313">              m_element = F;</a>
<a name="ln1314">            break;</a>
<a name="ln1315">          case 'M':</a>
<a name="ln1316">            if (checkNextChar('n'))</a>
<a name="ln1317">              m_element = Mn;</a>
<a name="ln1318">            else if (checkNextChar('o'))</a>
<a name="ln1319">              m_element = Mo;</a>
<a name="ln1320">            else if (checkNextChar('t'))</a>
<a name="ln1321">              m_element = Mt;</a>
<a name="ln1322">            else if (checkNextChar('d'))</a>
<a name="ln1323">              m_element = Md;</a>
<a name="ln1324">            else if (checkNextChar('g'))</a>
<a name="ln1325">              m_element = Mg;</a>
<a name="ln1326">            break;</a>
<a name="ln1327">          case 'A':</a>
<a name="ln1328">            if (checkNextChar('l'))</a>
<a name="ln1329">              m_element = Al;</a>
<a name="ln1330">            else if (checkNextChar('r'))</a>
<a name="ln1331">              m_element = Ar;</a>
<a name="ln1332">            else if (checkNextChar('s'))</a>
<a name="ln1333">              m_element = As;</a>
<a name="ln1334">            else if (checkNextChar('g'))</a>
<a name="ln1335">              m_element = Ag;</a>
<a name="ln1336">            else if (checkNextChar('u'))</a>
<a name="ln1337">              m_element = Au;</a>
<a name="ln1338">            else if (checkNextChar('t'))</a>
<a name="ln1339">              m_element = At;</a>
<a name="ln1340">            else if (checkNextChar('c'))</a>
<a name="ln1341">              m_element = Ac;</a>
<a name="ln1342">            else if (checkNextChar('m'))</a>
<a name="ln1343">              m_element = Am;</a>
<a name="ln1344">            break;</a>
<a name="ln1345">          case 'S':</a>
<a name="ln1346">            if (checkNextChar('i'))</a>
<a name="ln1347">              m_element = Si;</a>
<a name="ln1348">            else if (checkNextChar('c'))</a>
<a name="ln1349">              m_element = Sc;</a>
<a name="ln1350">            else if (checkNextChar('e'))</a>
<a name="ln1351">              m_element = Se;</a>
<a name="ln1352">            else if (checkNextChar('r'))</a>
<a name="ln1353">              m_element = Sr;</a>
<a name="ln1354">            else if (checkNextChar('n'))</a>
<a name="ln1355">              m_element = Sn;</a>
<a name="ln1356">            else if (checkNextChar('b'))</a>
<a name="ln1357">              m_element = Sb;</a>
<a name="ln1358">            else if (checkNextChar('g'))</a>
<a name="ln1359">              m_element = Sg;</a>
<a name="ln1360">            else if (checkNextChar('m'))</a>
<a name="ln1361">              m_element = Sm;</a>
<a name="ln1362">            else</a>
<a name="ln1363">              m_element = S;</a>
<a name="ln1364">            break;</a>
<a name="ln1365">          case 'P':</a>
<a name="ln1366">            if (checkNextChar('d'))</a>
<a name="ln1367">              m_element = Pd;</a>
<a name="ln1368">            else if (checkNextChar('t'))</a>
<a name="ln1369">              m_element = Pt;</a>
<a name="ln1370">            else if (checkNextChar('b'))</a>
<a name="ln1371">              m_element = Pb;</a>
<a name="ln1372">            else if (checkNextChar('o'))</a>
<a name="ln1373">              m_element = Po;</a>
<a name="ln1374">            else if (checkNextChar('r'))</a>
<a name="ln1375">              m_element = Pr;</a>
<a name="ln1376">            else if (checkNextChar('m'))</a>
<a name="ln1377">              m_element = Pm;</a>
<a name="ln1378">            else if (checkNextChar('a'))</a>
<a name="ln1379">              m_element = Pa;</a>
<a name="ln1380">            else if (checkNextChar('u'))</a>
<a name="ln1381">              m_element = Pu;</a>
<a name="ln1382">            else</a>
<a name="ln1383">              m_element = P;</a>
<a name="ln1384">            break;</a>
<a name="ln1385">          case 'K':</a>
<a name="ln1386">            if (checkNextChar('r'))</a>
<a name="ln1387">              m_element = Kr;</a>
<a name="ln1388">            else</a>
<a name="ln1389">              m_element = K;</a>
<a name="ln1390">            break;</a>
<a name="ln1391">          case 'T':</a>
<a name="ln1392">            if (checkNextChar('i'))</a>
<a name="ln1393">              m_element = Ti;</a>
<a name="ln1394">            else if (checkNextChar('c'))</a>
<a name="ln1395">              m_element = Tc;</a>
<a name="ln1396">            else if (checkNextChar('e'))</a>
<a name="ln1397">              m_element = Te;</a>
<a name="ln1398">            else if (checkNextChar('a'))</a>
<a name="ln1399">              m_element = Ta;</a>
<a name="ln1400">            else if (checkNextChar('l'))</a>
<a name="ln1401">              m_element = Tl;</a>
<a name="ln1402">            else if (checkNextChar('b'))</a>
<a name="ln1403">              m_element = Tb;</a>
<a name="ln1404">            else if (checkNextChar('m'))</a>
<a name="ln1405">              m_element = Tm;</a>
<a name="ln1406">            else if (checkNextChar('h'))</a>
<a name="ln1407">              m_element = Th;</a>
<a name="ln1408">            break;</a>
<a name="ln1409">          case 'V':</a>
<a name="ln1410">            m_element = V;</a>
<a name="ln1411">            break;</a>
<a name="ln1412">          case 'Z':</a>
<a name="ln1413">            if (checkNextChar('n'))</a>
<a name="ln1414">              m_element = Zn;</a>
<a name="ln1415">            else if (checkNextChar('r'))</a>
<a name="ln1416">              m_element = Zr;</a>
<a name="ln1417">            break;</a>
<a name="ln1418">          case 'G':</a>
<a name="ln1419">            if (checkNextChar('a'))</a>
<a name="ln1420">              m_element = Ga;</a>
<a name="ln1421">            else if (checkNextChar('e'))</a>
<a name="ln1422">              m_element = Ge;</a>
<a name="ln1423">            else if (checkNextChar('d'))</a>
<a name="ln1424">              m_element = Gd;</a>
<a name="ln1425">            break;</a>
<a name="ln1426">          case 'R':</a>
<a name="ln1427">            if (checkNextChar('b'))</a>
<a name="ln1428">              m_element = Rb;</a>
<a name="ln1429">            else if (checkNextChar('u'))</a>
<a name="ln1430">              m_element = Ru;</a>
<a name="ln1431">            else if (checkNextChar('h'))</a>
<a name="ln1432">              m_element = Rh;</a>
<a name="ln1433">            else if (checkNextChar('e'))</a>
<a name="ln1434">              m_element = Re;</a>
<a name="ln1435">            else if (checkNextChar('n'))</a>
<a name="ln1436">              m_element = Rn;</a>
<a name="ln1437">            else if (checkNextChar('a'))</a>
<a name="ln1438">              m_element = Ra;</a>
<a name="ln1439">            else if (checkNextChar('f'))</a>
<a name="ln1440">              m_element = Rf;</a>
<a name="ln1441">            else if (checkNextChar('g'))</a>
<a name="ln1442">              m_element = Rg;</a>
<a name="ln1443">            break;</a>
<a name="ln1444">          case 'Y':</a>
<a name="ln1445">            if (checkNextChar('b'))</a>
<a name="ln1446">              m_element = Yb;</a>
<a name="ln1447">            else</a>
<a name="ln1448">              m_element = Y;</a>
<a name="ln1449">            break;</a>
<a name="ln1450">          case 'I':</a>
<a name="ln1451">            if (checkNextChar('n'))</a>
<a name="ln1452">              m_element = In;</a>
<a name="ln1453">            else if (checkNextChar('r'))</a>
<a name="ln1454">              m_element = Ir;</a>
<a name="ln1455">            else</a>
<a name="ln1456">              m_element = I;</a>
<a name="ln1457">            break;</a>
<a name="ln1458">          case 'X':</a>
<a name="ln1459">            if (checkNextChar('e'))</a>
<a name="ln1460">              m_element = Xe;</a>
<a name="ln1461">            break;</a>
<a name="ln1462">          case 'W':</a>
<a name="ln1463">            m_element = W;</a>
<a name="ln1464">            break;</a>
<a name="ln1465">          case 'D':</a>
<a name="ln1466">            if (checkNextChar('b'))</a>
<a name="ln1467">              m_element = Db;</a>
<a name="ln1468">            else if (checkNextChar('s'))</a>
<a name="ln1469">              m_element = Ds;</a>
<a name="ln1470">            else if (checkNextChar('y'))</a>
<a name="ln1471">              m_element = Dy;</a>
<a name="ln1472">            break;</a>
<a name="ln1473">          case 'E':</a>
<a name="ln1474">            if (checkNextChar('u'))</a>
<a name="ln1475">              m_element = Eu;</a>
<a name="ln1476">            else if (checkNextChar('r'))</a>
<a name="ln1477">              m_element = Er;</a>
<a name="ln1478">            else if (checkNextChar('s'))</a>
<a name="ln1479">              m_element = Es;</a>
<a name="ln1480">            break;</a>
<a name="ln1481">          case 'U':</a>
<a name="ln1482">            m_element = U;</a>
<a name="ln1483">            break;</a>
<a name="ln1484">          case 'b':</a>
<a name="ln1485">            m_element = B;</a>
<a name="ln1486">            m_aromatic = true;</a>
<a name="ln1487">            break;</a>
<a name="ln1488">          case 'c':</a>
<a name="ln1489">            m_element = C;</a>
<a name="ln1490">            m_aromatic = true;</a>
<a name="ln1491">            break;</a>
<a name="ln1492">          case 'n':</a>
<a name="ln1493">            m_element = N;</a>
<a name="ln1494">            m_aromatic = true;</a>
<a name="ln1495">            break;</a>
<a name="ln1496">          case 'o':</a>
<a name="ln1497">            m_element = O;</a>
<a name="ln1498">            m_aromatic = true;</a>
<a name="ln1499">            break;</a>
<a name="ln1500">          case 'p':</a>
<a name="ln1501">            m_element = P;</a>
<a name="ln1502">            m_aromatic = true;</a>
<a name="ln1503">            break;</a>
<a name="ln1504">          case 's':</a>
<a name="ln1505">            if (checkNextChar('e'))</a>
<a name="ln1506">              m_element = Se;</a>
<a name="ln1507">            else</a>
<a name="ln1508">              m_element = S;</a>
<a name="ln1509">            m_aromatic = true;</a>
<a name="ln1510">            break;</a>
<a name="ln1511">          case 'a':</a>
<a name="ln1512">            if (checkNextChar('s')) {</a>
<a name="ln1513">              m_element = As;</a>
<a name="ln1514">              m_aromatic = true;</a>
<a name="ln1515">            }</a>
<a name="ln1516">            break;</a>
<a name="ln1517">          case '*':</a>
<a name="ln1518">            m_element = 0;</a>
<a name="ln1519">            break;</a>
<a name="ln1520">        }</a>
<a name="ln1521"> </a>
<a name="ln1522">        int elem = m_element;</a>
<a name="ln1523">        bool arom = m_aromatic;</a>
<a name="ln1524">        if (m_element != -1)</a>
<a name="ln1525">          ++m_pos;</a>
<a name="ln1526">        else if (m_mode == SmilesMode)</a>
<a name="ln1527">            throw Exception(Exception::SyntaxError, NoSymbolInBracketAtom,</a>
<a name="ln1528">                &quot;Bracket atom expression does not contain element symbol&quot;, m_pos, 1);</a>
<a name="ln1529">        else if (m_mode == SmartsMode) {</a>
<a name="ln1530">          m_element = -1;</a>
<a name="ln1531">          m_aromatic = false;</a>
<a name="ln1532">        }</a>
<a name="ln1533"> </a>
<a name="ln1534">        return std::make_pair(elem, arom);</a>
<a name="ln1535">      }</a>
<a name="ln1536"> </a>
<a name="ln1537">      /**</a>
<a name="ln1538">       * @code</a>
<a name="ln1539">       * chiral ::= '@@' | '@@@@' | '@@TH1' | '@@TH2' | '@@AL1' | '@@AL2'</a>
<a name="ln1540">       *     | '@@SP1' | '@@SP2' | '@@SP3'</a>
<a name="ln1541">       *     | '@@TB1' | '@@TB2' | ... | '@@TB20'</a>
<a name="ln1542">       *     | '@@OH1' | '@@OH2' | ... | '@@OH30'</a>
<a name="ln1543">       * @endcode</a>
<a name="ln1544">       */</a>
<a name="ln1545">      void parseChiral()</a>
<a name="ln1546">      {</a>
<a name="ln1547">        m_chiralInfo.back().pos = m_pos;</a>
<a name="ln1548"> </a>
<a name="ln1549">        if (m_str[m_pos] != '@')</a>
<a name="ln1550">          return;</a>
<a name="ln1551"> </a>
<a name="ln1552">        // @@</a>
<a name="ln1553">        if (checkNextChar('@')) {</a>
<a name="ln1554">          m_chiral = Clockwise;</a>
<a name="ln1555">          ++m_pos;</a>
<a name="ln1556">          return;</a>
<a name="ln1557">        }</a>
<a name="ln1558">        if (checkNextChar('T')) {</a>
<a name="ln1559">          // @TH1 &amp; @TH2</a>
<a name="ln1560">          if (checkNextChar('H')) {</a>
<a name="ln1561">            if (checkNextChar('1'))</a>
<a name="ln1562">              m_chiral = TH1;</a>
<a name="ln1563">            else if (checkNextChar('2'))</a>
<a name="ln1564">              m_chiral = TH2;</a>
<a name="ln1565">            else</a>
<a name="ln1566">              throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1567">                  &quot;Invalid chiral specified, expected 1 or 2&quot;, m_pos + 1, 1);</a>
<a name="ln1568">            ++m_pos;</a>
<a name="ln1569">            return;</a>
<a name="ln1570">          }</a>
<a name="ln1571">          // @TB1 ... @TB20</a>
<a name="ln1572">          if (checkNextChar('B')) {</a>
<a name="ln1573">            std::size_t pos = m_pos;</a>
<a name="ln1574">            int tb = 0;</a>
<a name="ln1575">            if (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1576">              tb = m_str[m_pos + 1] - '0';</a>
<a name="ln1577">              ++m_pos;</a>
<a name="ln1578">            }</a>
<a name="ln1579">            if (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1580">              tb *= 10;</a>
<a name="ln1581">              tb += m_str[m_pos + 1] - '0';</a>
<a name="ln1582">              ++m_pos;</a>
<a name="ln1583">            }</a>
<a name="ln1584">            if (tb &lt; 1 || tb &gt; 20)</a>
<a name="ln1585">              throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1586">                  &quot;Invalid chiral class specified, expected 1-20&quot;, pos + 1, m_pos == pos ? 1 : m_pos - pos);</a>
<a name="ln1587"> </a>
<a name="ln1588">            m_chiral = static_cast&lt;Chirality&gt;(tb + TB1 - 1);</a>
<a name="ln1589">            ++m_pos;</a>
<a name="ln1590">            return;</a>
<a name="ln1591">          }</a>
<a name="ln1592"> </a>
<a name="ln1593">          throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1594">              &quot;Invalid chiral specifier, expected H or B&quot;, m_pos + 1, 1);</a>
<a name="ln1595">        }</a>
<a name="ln1596">        // @AL1 &amp; @AL2</a>
<a name="ln1597">        if (checkNextChar('A')) {</a>
<a name="ln1598">          if (!checkNextChar('L'))</a>
<a name="ln1599">            throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1600">                &quot;Invalid chiral specifier, expected L&quot;, m_pos + 1, 1);</a>
<a name="ln1601">          if (checkNextChar('1'))</a>
<a name="ln1602">            m_chiral = AL1;</a>
<a name="ln1603">          else if (checkNextChar('2'))</a>
<a name="ln1604">            m_chiral = AL2;</a>
<a name="ln1605">          else</a>
<a name="ln1606">            throw Exception(Exception::SyntaxError,  InvalidChirality,</a>
<a name="ln1607">                &quot;Invalid chiral specified, expected 1 or 2&quot;, m_pos + 1, 1);</a>
<a name="ln1608">          ++m_pos;</a>
<a name="ln1609">          return;</a>
<a name="ln1610">        }</a>
<a name="ln1611">        // @SP1, @SP2 &amp; @SP3</a>
<a name="ln1612">        if (checkNextChar('S')) {</a>
<a name="ln1613">          if (!checkNextChar('P'))</a>
<a name="ln1614">            throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1615">                &quot;Invalid chiral specifier, expected P&quot;, m_pos + 1, 1);</a>
<a name="ln1616">          if (checkNextChar('1'))</a>
<a name="ln1617">            m_chiral = SP1;</a>
<a name="ln1618">          else if (checkNextChar('2'))</a>
<a name="ln1619">            m_chiral = SP2;</a>
<a name="ln1620">          else if (checkNextChar('3'))</a>
<a name="ln1621">            m_chiral = SP3;</a>
<a name="ln1622">          else</a>
<a name="ln1623">            throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1624">                &quot;Invalid chiral specified, expected 1, 2 or 3&quot;, m_pos + 1, 1);</a>
<a name="ln1625">          ++m_pos;</a>
<a name="ln1626">          return;</a>
<a name="ln1627">        }</a>
<a name="ln1628">        // @OH1 ... @OH30</a>
<a name="ln1629">        if (checkNextChar('O')) {</a>
<a name="ln1630">          if (!checkNextChar('H'))</a>
<a name="ln1631">            throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1632">                &quot;Invalid chiral specifier, expected H&quot;, m_pos + 1, 1);</a>
<a name="ln1633"> </a>
<a name="ln1634">          std::size_t pos = m_pos;</a>
<a name="ln1635">          int oh = 0;</a>
<a name="ln1636">          if (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1637">            oh = m_str[m_pos + 1] - '0';</a>
<a name="ln1638">            ++m_pos;</a>
<a name="ln1639">          }</a>
<a name="ln1640">          if (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1641">            oh *= 10;</a>
<a name="ln1642">            oh += m_str[m_pos + 1] - '0';</a>
<a name="ln1643">            ++m_pos;</a>
<a name="ln1644">          }</a>
<a name="ln1645">          if (oh &lt; 1 || oh &gt; 30)</a>
<a name="ln1646">            throw Exception(Exception::SyntaxError, InvalidChirality,</a>
<a name="ln1647">                &quot;Invalid chiral class specified, expected 1-30&quot;, pos + 1, m_pos == pos ? 1 : m_pos - pos);</a>
<a name="ln1648"> </a>
<a name="ln1649">          m_chiral = static_cast&lt;Chirality&gt;(oh + OH1 - 1);</a>
<a name="ln1650">          ++m_pos;</a>
<a name="ln1651">          return;</a>
<a name="ln1652">        }</a>
<a name="ln1653"> </a>
<a name="ln1654">        m_chiral = AntiClockwise;</a>
<a name="ln1655">        ++m_pos;</a>
<a name="ln1656">      }</a>
<a name="ln1657"> </a>
<a name="ln1658">      /**</a>
<a name="ln1659">       * @code</a>
<a name="ln1660">       * hcount ::= 'H' | 'H' DIGIT</a>
<a name="ln1661">       * @endcode</a>
<a name="ln1662">       */</a>
<a name="ln1663">      void parseHydrogenCount()</a>
<a name="ln1664">      {</a>
<a name="ln1665">        if (DEBUG)</a>
<a name="ln1666">          std::cout &lt;&lt; &quot;parseHydrogenCount(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1667"> </a>
<a name="ln1668">        // [C] = [CH0]</a>
<a name="ln1669">        m_hCount = 0;</a>
<a name="ln1670">        if (m_str[m_pos] != 'H')</a>
<a name="ln1671">          return;</a>
<a name="ln1672">        ++m_pos;</a>
<a name="ln1673">        if (std::isdigit(m_str[m_pos])) {</a>
<a name="ln1674">          m_hCount = m_str[m_pos] - '0';</a>
<a name="ln1675">          ++m_pos;</a>
<a name="ln1676">          return;</a>
<a name="ln1677">        }</a>
<a name="ln1678">        m_hCount = 1;</a>
<a name="ln1679">      }</a>
<a name="ln1680"> </a>
<a name="ln1681">      /**</a>
<a name="ln1682">       * @code</a>
<a name="ln1683">       * charge ::= '-' | '+' | '-' DIGIT | '+' DIGIT | '--' | '++'</a>
<a name="ln1684">       * @endcode</a>
<a name="ln1685">       *</a>
<a name="ln1686">       * Deprecated: '--' and '++'</a>
<a name="ln1687">       */</a>
<a name="ln1688">      void parseCharge()</a>
<a name="ln1689">      {</a>
<a name="ln1690">        if (DEBUG)</a>
<a name="ln1691">          std::cout &lt;&lt; &quot;parseCharge(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1692"> </a>
<a name="ln1693">        if (m_str[m_pos] == '-') {</a>
<a name="ln1694">          if (checkNextChar('-')) {</a>
<a name="ln1695">            m_charge = -2;</a>
<a name="ln1696">            ++m_pos;</a>
<a name="ln1697">            return;</a>
<a name="ln1698">          }</a>
<a name="ln1699">          if (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1700">            m_charge = - (m_str[m_pos + 1] - '0');</a>
<a name="ln1701">            m_pos += 2;</a>
<a name="ln1702">            if (std::isdigit(m_str[m_pos])) {</a>
<a name="ln1703">              m_charge = 10 * m_charge - (m_str[m_pos] - '0');</a>
<a name="ln1704">              ++m_pos;</a>
<a name="ln1705">            }</a>
<a name="ln1706">            return;</a>
<a name="ln1707">          }</a>
<a name="ln1708">          ++m_pos;</a>
<a name="ln1709">          m_charge = -1;</a>
<a name="ln1710">        } else if (m_str[m_pos] == '+') {</a>
<a name="ln1711">          if (checkNextChar('+')) {</a>
<a name="ln1712">            m_charge = 2;</a>
<a name="ln1713">            ++m_pos;</a>
<a name="ln1714">            return;</a>
<a name="ln1715">          }</a>
<a name="ln1716">          if (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1717">            m_charge = m_str[m_pos + 1] - '0';</a>
<a name="ln1718">            m_pos += 2;</a>
<a name="ln1719">            if (std::isdigit(m_str[m_pos])) {</a>
<a name="ln1720">              m_charge = 10 * m_charge + (m_str[m_pos] - '0');</a>
<a name="ln1721">              ++m_pos;</a>
<a name="ln1722">            }</a>
<a name="ln1723">            return;</a>
<a name="ln1724">          }</a>
<a name="ln1725">          ++m_pos;</a>
<a name="ln1726">          m_charge = 1;</a>
<a name="ln1727">        }</a>
<a name="ln1728">      }</a>
<a name="ln1729"> </a>
<a name="ln1730">      /**</a>
<a name="ln1731">       * @code</a>
<a name="ln1732">       * class ::= ':' NUMBER</a>
<a name="ln1733">       * @endcode</a>
<a name="ln1734">       */</a>
<a name="ln1735">      void parseClass()</a>
<a name="ln1736">      {</a>
<a name="ln1737">        if (DEBUG)</a>
<a name="ln1738">          std::cout &lt;&lt; &quot;parseClass(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1739"> </a>
<a name="ln1740">        if (m_str[m_pos] != ':')</a>
<a name="ln1741">          return;</a>
<a name="ln1742">        bool found_number = false;</a>
<a name="ln1743">        while (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1744">          m_class *= 10;</a>
<a name="ln1745">          m_class += m_str[m_pos + 1] - '0';</a>
<a name="ln1746">          ++m_pos;</a>
<a name="ln1747">          found_number = true;</a>
<a name="ln1748">        }</a>
<a name="ln1749">        ++m_pos;</a>
<a name="ln1750">        if (!found_number)</a>
<a name="ln1751">          throw Exception(Exception::SyntaxError, NoAtomClass,</a>
<a name="ln1752">              &quot;No atom class, expected number&quot;, m_pos + 1, 1);</a>
<a name="ln1753">      }</a>
<a name="ln1754"> </a>
<a name="ln1755">      bool parseCharDigit(char chr, int type, int defaultValue, int &amp;parsedOp,</a>
<a name="ln1756">          bool firstPrimitive)</a>
<a name="ln1757">      {</a>
<a name="ln1758">        if (DEBUG)</a>
<a name="ln1759">          std::cout &lt;&lt; &quot;parseCharDigit(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1760"> </a>
<a name="ln1761">        if (m_str[m_pos] != chr)</a>
<a name="ln1762">          return false;</a>
<a name="ln1763">        ++m_pos;</a>
<a name="ln1764">        if (std::isdigit(m_str[m_pos])) {</a>
<a name="ln1765">          defaultValue = m_str[m_pos] - '0';</a>
<a name="ln1766">          ++m_pos;</a>
<a name="ln1767">        }</a>
<a name="ln1768">        processImplicitAnd(parsedOp, firstPrimitive);</a>
<a name="ln1769">        m_callback.atomPrimitive(type, defaultValue);</a>
<a name="ln1770">        return true;</a>
<a name="ln1771">      }</a>
<a name="ln1772"> </a>
<a name="ln1773">      bool parseCharNumber(char chr, int type, int &amp;parsedOp,</a>
<a name="ln1774">          bool firstPrimitive, bool noDefault = false)</a>
<a name="ln1775">      {</a>
<a name="ln1776">        if (DEBUG)</a>
<a name="ln1777">          std::cout &lt;&lt; &quot;parseCharNumber(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1778"> </a>
<a name="ln1779">        if (m_str[m_pos] != chr)</a>
<a name="ln1780">          return false;</a>
<a name="ln1781"> </a>
<a name="ln1782">        // check for element symbols</a>
<a name="ln1783">        if (chr == 'D')</a>
<a name="ln1784">          switch (m_str[m_pos + 1]) {</a>
<a name="ln1785">            case 'b':</a>
<a name="ln1786">            case 's':</a>
<a name="ln1787">            case 'y':</a>
<a name="ln1788">              return false;</a>
<a name="ln1789">            default:</a>
<a name="ln1790">              break;</a>
<a name="ln1791">          }</a>
<a name="ln1792">        if (chr == 'H')</a>
<a name="ln1793">          switch (m_str[m_pos + 1]) {</a>
<a name="ln1794">            case 'e':</a>
<a name="ln1795">            case 'f':</a>
<a name="ln1796">            case 'g':</a>
<a name="ln1797">            case 'o':</a>
<a name="ln1798">            case 's':</a>
<a name="ln1799">              return false;</a>
<a name="ln1800">            default:</a>
<a name="ln1801">              break;</a>
<a name="ln1802">          }</a>
<a name="ln1803">        if (chr == 'X' &amp;&amp; m_str[m_pos + 1] == 'e')</a>
<a name="ln1804">          return false;</a>
<a name="ln1805"> </a>
<a name="ln1806">        //++m_pos;</a>
<a name="ln1807">        bool found_number = false;</a>
<a name="ln1808">        // parse NUMBER</a>
<a name="ln1809">        int value = 0;</a>
<a name="ln1810">        while (std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1811">          value *= 10;</a>
<a name="ln1812">          value += m_str[m_pos + 1] - '0';</a>
<a name="ln1813">          ++m_pos;</a>
<a name="ln1814">          found_number = true;</a>
<a name="ln1815">        }</a>
<a name="ln1816">        ++m_pos;</a>
<a name="ln1817"> </a>
<a name="ln1818">        //if (!found_number &amp;&amp; noDefault); // throw   example: [#]</a>
<a name="ln1819">        if (!found_number)</a>
<a name="ln1820">          value = 1;</a>
<a name="ln1821"> </a>
<a name="ln1822">        processImplicitAnd(parsedOp, firstPrimitive);</a>
<a name="ln1823">        m_callback.atomPrimitive(type, value);</a>
<a name="ln1824">        return true;</a>
<a name="ln1825">      }</a>
<a name="ln1826"> </a>
<a name="ln1827">      bool atomPrimitiveCallback(int type, int &amp;value, int defaultValue,</a>
<a name="ln1828">          int &amp;parsedOp, bool firstPrimitive)</a>
<a name="ln1829">      {</a>
<a name="ln1830">        if (value != defaultValue) {</a>
<a name="ln1831">          processImplicitAnd(parsedOp, firstPrimitive);</a>
<a name="ln1832">          m_callback.atomPrimitive(type, value);</a>
<a name="ln1833">          value = defaultValue;</a>
<a name="ln1834">          return true;</a>
<a name="ln1835">        }</a>
<a name="ln1836">        return false;</a>
<a name="ln1837">      }</a>
<a name="ln1838"> </a>
<a name="ln1839">      void processImplicitAnd(int &amp;parsedOp, bool firstPrimitive)</a>
<a name="ln1840">      {</a>
<a name="ln1841">        if (!parsedOp &amp;&amp; !firstPrimitive)</a>
<a name="ln1842">          m_callback.operation(OP_AndHi);</a>
<a name="ln1843">        parsedOp = 0;</a>
<a name="ln1844">      }</a>
<a name="ln1845"> </a>
<a name="ln1846">      void isValidAtomExprChar()</a>
<a name="ln1847">      {</a>
<a name="ln1848">        switch (m_str[m_pos]) {</a>
<a name="ln1849">          case '*':</a>
<a name="ln1850">          case '&amp;':</a>
<a name="ln1851">          case ';':</a>
<a name="ln1852">          case ',':</a>
<a name="ln1853">          case '!':</a>
<a name="ln1854">          case '@':</a>
<a name="ln1855">          case '#':</a>
<a name="ln1856">          case ':':</a>
<a name="ln1857">          //case '$':</a>
<a name="ln1858">          //case '(':</a>
<a name="ln1859">          //case ')':</a>
<a name="ln1860">          case '+':</a>
<a name="ln1861">          case '-':</a>
<a name="ln1862">          // chack ranges?</a>
<a name="ln1863">          // no J, Q, j, q, w</a>
<a name="ln1864">          case '0': case '1': case '2': case '3': case '4':</a>
<a name="ln1865">          case '5': case '6': case '7': case '8': case '9':</a>
<a name="ln1866">          case 'A': case 'B': case 'C': case 'D': case 'E':</a>
<a name="ln1867">          case 'F': case 'G': case 'H': case 'I': case 'K':</a>
<a name="ln1868">          case 'L': case 'M': case 'N': case 'O': case 'P':</a>
<a name="ln1869">          case 'R': case 'S': case 'T': case 'U': case 'V':</a>
<a name="ln1870">          case 'W': case 'X': case 'Y': case 'Z':</a>
<a name="ln1871">          case 'a': case 'b': case 'c': case 'd': case 'e':</a>
<a name="ln1872">          case 'f': case 'g': case 'h': case 'i': case 'k':</a>
<a name="ln1873">          case 'l': case 'm': case 'n': case 'o': case 'p':</a>
<a name="ln1874">          case 'r': case 's': case 't': case 'u': case 'v':</a>
<a name="ln1875">          case 'x': case 'y': case 'z':</a>
<a name="ln1876">            return;</a>
<a name="ln1877">          default:</a>
<a name="ln1878">            throw Exception(Exception::SyntaxError, InvalidAtomPrimitive,</a>
<a name="ln1879">                &quot;Invalid character inside bracketed atom expression&quot;, m_pos, 1);</a>
<a name="ln1880">            break;</a>
<a name="ln1881">        }</a>
<a name="ln1882">      }</a>
<a name="ln1883"> </a>
<a name="ln1884"> </a>
<a name="ln1885">      void parseAtomExpr()</a>
<a name="ln1886">      {</a>
<a name="ln1887">        bool first_primitive = true;</a>
<a name="ln1888">        int parsedOp = 0;</a>
<a name="ln1889">        std::size_t lastPos = std::string::npos;</a>
<a name="ln1890"> </a>
<a name="ln1891">        while (m_str[m_pos] != ']') {</a>
<a name="ln1892">          if (lastPos == m_pos)</a>
<a name="ln1893">            throw Exception(Exception::SyntaxError, InvalidAtomPrimitive,</a>
<a name="ln1894">                &quot;Invalid atom primitive&quot;, m_pos, 1);</a>
<a name="ln1895">          isValidAtomExprChar();</a>
<a name="ln1896">          lastPos = m_pos;</a>
<a name="ln1897"> </a>
<a name="ln1898">          int chr = m_str[m_pos];</a>
<a name="ln1899">          switch (chr) {</a>
<a name="ln1900">            case '&amp;':</a>
<a name="ln1901">              if (first_primitive)</a>
<a name="ln1902">                throw Exception(Exception::SyntaxError, BinaryOpWithoutLeftOperand,</a>
<a name="ln1903">                    &quot;Binary '&amp;' without left operand&quot;, m_pos, 1);</a>
<a name="ln1904">              m_callback.operation(OP_AndHi);</a>
<a name="ln1905">              ++m_pos;</a>
<a name="ln1906">              parsedOp = OP_AndHi;</a>
<a name="ln1907">              continue;</a>
<a name="ln1908">            case ';':</a>
<a name="ln1909">              if (first_primitive)</a>
<a name="ln1910">                throw Exception(Exception::SyntaxError, BinaryOpWithoutLeftOperand,</a>
<a name="ln1911">                    &quot;Binary ';' without left operand&quot;, m_pos, 1);</a>
<a name="ln1912">              m_callback.operation(OP_AndLo);</a>
<a name="ln1913">              ++m_pos;</a>
<a name="ln1914">              parsedOp = OP_AndLo;</a>
<a name="ln1915">              continue;</a>
<a name="ln1916">            case ',':</a>
<a name="ln1917">              if (first_primitive)</a>
<a name="ln1918">                throw Exception(Exception::SyntaxError, BinaryOpWithoutLeftOperand,</a>
<a name="ln1919">                    &quot;Binary ',' without left operand&quot;, m_pos, 1);</a>
<a name="ln1920">              m_callback.operation(OP_Or);</a>
<a name="ln1921">              ++m_pos;</a>
<a name="ln1922">              parsedOp = OP_Or;</a>
<a name="ln1923">              continue;</a>
<a name="ln1924">            case '!':</a>
<a name="ln1925">              m_callback.operation(OP_Not);</a>
<a name="ln1926">              ++m_pos;</a>
<a name="ln1927">              parsedOp = OP_Not;</a>
<a name="ln1928">              continue;</a>
<a name="ln1929">            case 'a':</a>
<a name="ln1930">              processImplicitAnd(parsedOp, first_primitive);</a>
<a name="ln1931">              m_callback.atomPrimitive(AE_Aromatic, 1);</a>
<a name="ln1932">              first_primitive = false;</a>
<a name="ln1933">              ++m_pos;</a>
<a name="ln1934">              continue;</a>
<a name="ln1935">            case 'A':</a>
<a name="ln1936">              switch (m_str[m_pos + 1]) {</a>
<a name="ln1937">                case 'l':</a>
<a name="ln1938">                case 'r':</a>
<a name="ln1939">                case 's':</a>
<a name="ln1940">                case 'g':</a>
<a name="ln1941">                case 'u':</a>
<a name="ln1942">                case 't':</a>
<a name="ln1943">                case 'c':</a>
<a name="ln1944">                case 'm':</a>
<a name="ln1945">                  break;</a>
<a name="ln1946">                default:</a>
<a name="ln1947">                  processImplicitAnd(parsedOp, first_primitive);</a>
<a name="ln1948">                  m_callback.atomPrimitive(AE_Aliphatic, 1);</a>
<a name="ln1949">                  first_primitive = false;</a>
<a name="ln1950">                  ++m_pos;</a>
<a name="ln1951">                  break;</a>
<a name="ln1952">              }</a>
<a name="ln1953">              break;</a>
<a name="ln1954">            case 'R':</a>
<a name="ln1955">              if (m_str[m_pos + 1] == '0') {</a>
<a name="ln1956">                processImplicitAnd(parsedOp, first_primitive);</a>
<a name="ln1957">                m_callback.atomPrimitive(AE_Acyclic, 1);</a>
<a name="ln1958">                first_primitive = false;</a>
<a name="ln1959">                m_pos += 2;</a>
<a name="ln1960">                continue;</a>
<a name="ln1961">              } else if (!std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1962">                processImplicitAnd(parsedOp, first_primitive);</a>
<a name="ln1963">                m_callback.atomPrimitive(AE_Cyclic, 1);</a>
<a name="ln1964">                first_primitive = false;</a>
<a name="ln1965">                ++m_pos;</a>
<a name="ln1966">                continue;</a>
<a name="ln1967">              }</a>
<a name="ln1968">              break;</a>
<a name="ln1969">            case 'r':</a>
<a name="ln1970">              if (!std::isdigit(m_str[m_pos + 1])) {</a>
<a name="ln1971">                processImplicitAnd(parsedOp, first_primitive);</a>
<a name="ln1972">                m_callback.atomPrimitive(AE_Cyclic, 1);</a>
<a name="ln1973">                first_primitive = false;</a>
<a name="ln1974">                ++m_pos;</a>
<a name="ln1975">              }</a>
<a name="ln1976">              break;</a>
<a name="ln1977">            default:</a>
<a name="ln1978">              break;</a>
<a name="ln1979">          }</a>
<a name="ln1980"> </a>
<a name="ln1981">          // isotope ::= NUMBER</a>
<a name="ln1982">          parseIsotope();</a>
<a name="ln1983">          if (atomPrimitiveCallback(AE_Isotope, m_isotope, -1, parsedOp, first_primitive)) {</a>
<a name="ln1984">            first_primitive = false;</a>
<a name="ln1985">            continue;</a>
<a name="ln1986">          }</a>
<a name="ln1987">          // atomic_number ::= '#' NUMBER</a>
<a name="ln1988">          if (parseCharNumber('#', AE_AtomicNumber, parsedOp, first_primitive, true)) { // true = no default value of 1</a>
<a name="ln1989">            first_primitive = false;</a>
<a name="ln1990">            continue;</a>
<a name="ln1991">          }</a>
<a name="ln1992">          // symbol</a>
<a name="ln1993">          std::pair&lt;int, bool&gt; symbol = parseSymbol(true);</a>
<a name="ln1994">          if (symbol.first != -1) {</a>
<a name="ln1995">            processImplicitAnd(parsedOp, first_primitive);</a>
<a name="ln1996">            if (symbol.first == 0)</a>
<a name="ln1997">              m_callback.atomPrimitive(AE_True, 1); // '*'</a>
<a name="ln1998">            else if (symbol.second)</a>
<a name="ln1999">              m_callback.atomPrimitive(AE_AromaticElement, m_element);</a>
<a name="ln2000">            else</a>
<a name="ln2001">              m_callback.atomPrimitive(AE_AliphaticElement, m_element);</a>
<a name="ln2002">            first_primitive = false;</a>
<a name="ln2003">          }</a>
<a name="ln2004">          // degree ::= 'D' | 'D' NUMBER</a>
<a name="ln2005">          if (parseCharNumber('D', AE_Degree, parsedOp, first_primitive)) {</a>
<a name="ln2006">            first_primitive = false;</a>
<a name="ln2007">            continue;</a>
<a name="ln2008">          }</a>
<a name="ln2009">          // valence ::= 'v' | 'v' NUMBER</a>
<a name="ln2010">          if (parseCharNumber('v', AE_Valence, parsedOp, first_primitive)) {</a>
<a name="ln2011">            first_primitive = false;</a>
<a name="ln2012">            continue;</a>
<a name="ln2013">          }</a>
<a name="ln2014">          // connectivity ::= 'X' | 'X' NUMBER</a>
<a name="ln2015">          if (parseCharNumber('X', AE_Connectivity, parsedOp, first_primitive)) {</a>
<a name="ln2016">            first_primitive = false;</a>
<a name="ln2017">            continue;</a>
<a name="ln2018">          }</a>
<a name="ln2019">          // hcount ::= 'H' | 'H' NUMBER</a>
<a name="ln2020">          if (parseCharDigit('H', AE_TotalH, 1, parsedOp, first_primitive)) {</a>
<a name="ln2021">            first_primitive = false;</a>
<a name="ln2022">            continue;</a>
<a name="ln2023">          }</a>
<a name="ln2024">          // implicit_hcount ::= 'h' | 'h' NUMBER</a>
<a name="ln2025">          if (parseCharDigit('h', AE_ImplicitH, 1, parsedOp, first_primitive)) {</a>
<a name="ln2026">            first_primitive = false;</a>
<a name="ln2027">            continue;</a>
<a name="ln2028">          }</a>
<a name="ln2029">          // ring_membership ::= 'R' | 'R' NUMBER</a>
<a name="ln2030">          if (parseCharNumber('R', AE_RingMembership, parsedOp, first_primitive)) {</a>
<a name="ln2031">            first_primitive = false;</a>
<a name="ln2032">            continue;</a>
<a name="ln2033">          }</a>
<a name="ln2034">          // ring_size ::= 'r' | 'r' NUMBER</a>
<a name="ln2035">          if (parseCharNumber('r', AE_RingSize, parsedOp, first_primitive)) {</a>
<a name="ln2036">            first_primitive = false;</a>
<a name="ln2037">            continue;</a>
<a name="ln2038">          }</a>
<a name="ln2039">          // ring_connectivity ::= 'x' | 'x' NUMBER</a>
<a name="ln2040">          if (parseCharNumber('x', AE_RingConnectivity, parsedOp, first_primitive)) {</a>
<a name="ln2041">            first_primitive = false;</a>
<a name="ln2042">            continue;</a>
<a name="ln2043">          }</a>
<a name="ln2044">          // complex...</a>
<a name="ln2045">          parseCharge();</a>
<a name="ln2046">          if (atomPrimitiveCallback(AE_Charge, m_charge, 0, parsedOp, first_primitive)) {</a>
<a name="ln2047">            first_primitive = false;</a>
<a name="ln2048">            continue;</a>
<a name="ln2049">          }</a>
<a name="ln2050">          // complex...</a>
<a name="ln2051">          parseChiral();</a>
<a name="ln2052">          if (atomPrimitiveCallback(AE_Chirality, m_chiral, 0, parsedOp, first_primitive)) {</a>
<a name="ln2053">            first_primitive = false;</a>
<a name="ln2054">            continue;</a>
<a name="ln2055">          }</a>
<a name="ln2056">          // valence ::= ':' NUMBER</a>
<a name="ln2057">          parseClass();</a>
<a name="ln2058">          if (atomPrimitiveCallback(AE_AtomClass, m_class, 0, parsedOp, first_primitive)) {</a>
<a name="ln2059">            first_primitive = false;</a>
<a name="ln2060">            continue;</a>
<a name="ln2061">          }</a>
<a name="ln2062">        }</a>
<a name="ln2063"> </a>
<a name="ln2064">        switch (parsedOp) {</a>
<a name="ln2065">          case OP_AndHi:</a>
<a name="ln2066">          case OP_AndLo:</a>
<a name="ln2067">          case OP_Or:</a>
<a name="ln2068">            throw Exception(Exception::SyntaxError, BinaryOpWithoutRightOperand,</a>
<a name="ln2069">                &quot;Binary operator inside bracket atom without right operand&quot;, m_pos - 1, 1);</a>
<a name="ln2070">          case OP_Not:</a>
<a name="ln2071">            throw Exception(Exception::SyntaxError, UnaryOpWithoutArgument,</a>
<a name="ln2072">                &quot;Unary operator inside bracket atom without argument&quot;, m_pos - 1, 1);</a>
<a name="ln2073">          default:</a>
<a name="ln2074">            break;</a>
<a name="ln2075">        }</a>
<a name="ln2076">      }</a>
<a name="ln2077"> </a>
<a name="ln2078">      /**</a>
<a name="ln2079">       * @code</a>
<a name="ln2080">       * bracket_atom ::= '[' isotope? symbol chiral? hcount? charge? class? ']'</a>
<a name="ln2081">       * @endcode</a>
<a name="ln2082">       */</a>
<a name="ln2083">      void parseBracketAtom()</a>
<a name="ln2084">      {</a>
<a name="ln2085">        if (DEBUG)</a>
<a name="ln2086">          std::cout &lt;&lt; &quot;parseBracketAtom(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2087"> </a>
<a name="ln2088">        std::size_t close = findMatchingBracket(&quot;[&quot;, &quot;]&quot;, m_pos);</a>
<a name="ln2089">        ++m_pos;</a>
<a name="ln2090"> </a>
<a name="ln2091">        if (m_mode == SmartsMode) {</a>
<a name="ln2092">          parseAtomExpr();</a>
<a name="ln2093">          return;</a>
<a name="ln2094">        }</a>
<a name="ln2095"> </a>
<a name="ln2096">        parseIsotope();</a>
<a name="ln2097">        parseSymbol();</a>
<a name="ln2098">        parseChiral();</a>
<a name="ln2099">        parseHydrogenCount();</a>
<a name="ln2100">        parseCharge();</a>
<a name="ln2101">        parseClass();</a>
<a name="ln2102"> </a>
<a name="ln2103">        m_chiralInfo.back().chiral = static_cast&lt;Chirality&gt;(m_chiral);</a>
<a name="ln2104">        if (m_hCount &gt;= 1)</a>
<a name="ln2105">          m_chiralInfo.back().nbrs.push_back(implicitHydrogen());</a>
<a name="ln2106">        if (m_hCount &gt; 1 &amp;&amp; m_chiral &amp;&amp; m_exceptions &amp; InvalidChiralHydrogenCount) {</a>
<a name="ln2107">          throw Exception(Exception::SemanticsError, InvalidChiralHydrogenCount,</a>
<a name="ln2108">              &quot;Chiral atoms can only have one hydrogen&quot;, m_chiralInfo.back().pos, 1);</a>
<a name="ln2109">        }</a>
<a name="ln2110"> </a>
<a name="ln2111">        if (m_str[m_pos] != ']')</a>
<a name="ln2112">          throw Exception(Exception::SyntaxError, TrailingCharInBracketAtom,</a>
<a name="ln2113">              &quot;Bracket atom expression contains invalid trailing characters&quot;, m_pos, close - m_pos);</a>
<a name="ln2114"> </a>
<a name="ln2115">        addAtom(m_element, m_aromatic, m_isotope, m_hCount, m_charge, m_class);</a>
<a name="ln2116">      }</a>
<a name="ln2117"> </a>
<a name="ln2118">      /**</a>
<a name="ln2119">       * @code</a>
<a name="ln2120">       * aliphatic_organic ::= 'B' | 'C' | 'N' | 'O' | 'P' | 'S' | 'F' | 'Cl' | 'Br' | 'I'</a>
<a name="ln2121">       * aromatic_organic ::= 'b' | 'c' | 'n' | 'o' | 'p' | 's'</a>
<a name="ln2122">       * @endcode</a>
<a name="ln2123">       */</a>
<a name="ln2124">      bool parseOrganicSubsetAtom()</a>
<a name="ln2125">      {</a>
<a name="ln2126">        if (DEBUG)</a>
<a name="ln2127">          std::cout &lt;&lt; &quot;parseOrganicSubsetAtom(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2128"> </a>
<a name="ln2129">        switch (m_str[m_pos]) {</a>
<a name="ln2130">          case 'B':</a>
<a name="ln2131">            if (checkNextChar('r'))</a>
<a name="ln2132">              addAtom(Br);</a>
<a name="ln2133">            else</a>
<a name="ln2134">              addAtom(B);</a>
<a name="ln2135">            ++m_pos;</a>
<a name="ln2136">            return true;</a>
<a name="ln2137">          case 'C':</a>
<a name="ln2138">            if (checkNextChar('l'))</a>
<a name="ln2139">              addAtom(Cl);</a>
<a name="ln2140">            else</a>
<a name="ln2141">              addAtom(C);</a>
<a name="ln2142">            ++m_pos;</a>
<a name="ln2143">            return true;</a>
<a name="ln2144">          case 'N':</a>
<a name="ln2145">            addAtom(N);</a>
<a name="ln2146">            ++m_pos;</a>
<a name="ln2147">            return true;</a>
<a name="ln2148">          case 'O':</a>
<a name="ln2149">            addAtom(O);</a>
<a name="ln2150">            ++m_pos;</a>
<a name="ln2151">            return true;</a>
<a name="ln2152">          case 'S':</a>
<a name="ln2153">            addAtom(S);</a>
<a name="ln2154">            ++m_pos;</a>
<a name="ln2155">            return true;</a>
<a name="ln2156">          case 'P':</a>
<a name="ln2157">            addAtom(P);</a>
<a name="ln2158">            ++m_pos;</a>
<a name="ln2159">            return true;</a>
<a name="ln2160">          case 'F':</a>
<a name="ln2161">            addAtom(F);</a>
<a name="ln2162">            ++m_pos;</a>
<a name="ln2163">            return true;</a>
<a name="ln2164">          case 'I':</a>
<a name="ln2165">            addAtom(I);</a>
<a name="ln2166">            ++m_pos;</a>
<a name="ln2167">            return true;</a>
<a name="ln2168">          case 'b':</a>
<a name="ln2169">            addAtom(B, true);</a>
<a name="ln2170">            ++m_pos;</a>
<a name="ln2171">            return true;</a>
<a name="ln2172">          case 'c':</a>
<a name="ln2173">            addAtom(C, true);</a>
<a name="ln2174">            ++m_pos;</a>
<a name="ln2175">            return true;</a>
<a name="ln2176">          case 'n':</a>
<a name="ln2177">            addAtom(N, true);</a>
<a name="ln2178">            ++m_pos;</a>
<a name="ln2179">            return true;</a>
<a name="ln2180">          case 'o':</a>
<a name="ln2181">            addAtom(O, true);</a>
<a name="ln2182">            ++m_pos;</a>
<a name="ln2183">            return true;</a>
<a name="ln2184">          case 's':</a>
<a name="ln2185">            addAtom(S, true);</a>
<a name="ln2186">            ++m_pos;</a>
<a name="ln2187">            return true;</a>
<a name="ln2188">          case 'p':</a>
<a name="ln2189">            addAtom(P, true);</a>
<a name="ln2190">            ++m_pos;</a>
<a name="ln2191">            return true;</a>
<a name="ln2192">        }</a>
<a name="ln2193"> </a>
<a name="ln2194">        return false;</a>
<a name="ln2195">      }</a>
<a name="ln2196"> </a>
<a name="ln2197">      /**</a>
<a name="ln2198">       * @code</a>
<a name="ln2199">       * atom ::= bracket_atom | aliphatic_organic | aromatic_organic | '*'</a>
<a name="ln2200">       * @endcode</a>
<a name="ln2201">       */</a>
<a name="ln2202">      bool parseAtom()</a>
<a name="ln2203">      {</a>
<a name="ln2204">        if (DEBUG)</a>
<a name="ln2205">          std::cout &lt;&lt; &quot;parseAtom(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2206"> </a>
<a name="ln2207">        m_element = -1;</a>
<a name="ln2208">        m_isotope = -1;</a>
<a name="ln2209">        m_charge = 0;</a>
<a name="ln2210">        m_chiral = NotChiral;</a>
<a name="ln2211">        m_hCount = -1;</a>
<a name="ln2212">        m_class = 0;</a>
<a name="ln2213">        m_aromatic = false;</a>
<a name="ln2214"> </a>
<a name="ln2215">        switch (m_str[m_pos]) {</a>
<a name="ln2216">          case '[':</a>
<a name="ln2217">            parseBracketAtom();</a>
<a name="ln2218">            ++m_pos;</a>
<a name="ln2219">            return true;</a>
<a name="ln2220">          case '*':</a>
<a name="ln2221">            addAtom(0);</a>
<a name="ln2222">            ++m_pos;</a>
<a name="ln2223">            return true;</a>
<a name="ln2224">        }</a>
<a name="ln2225"> </a>
<a name="ln2226">        return parseOrganicSubsetAtom();</a>
<a name="ln2227">      }</a>
<a name="ln2228"> </a>
<a name="ln2229">      void processBondPrimitive(int type, bool &amp;firstPrimitive, int &amp;parsedOp)</a>
<a name="ln2230">      {</a>
<a name="ln2231">        if (DEBUG)</a>
<a name="ln2232">          std::cout &lt;&lt; &quot;processBondPrimitive(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2233">        m_explicitBond = true;</a>
<a name="ln2234">        ++m_pos;</a>
<a name="ln2235">        if (m_mode == SmilesMode)</a>
<a name="ln2236">          return;</a>
<a name="ln2237">        // implicit OR for bonds</a>
<a name="ln2238">        if (!firstPrimitive &amp;&amp; !parsedOp)</a>
<a name="ln2239">          m_callback.operation(OP_Or);</a>
<a name="ln2240">        m_callback.bondPrimitive(type);</a>
<a name="ln2241">        firstPrimitive = false;</a>
<a name="ln2242">        parsedOp = 0;</a>
<a name="ln2243">      }</a>
<a name="ln2244"> </a>
<a name="ln2245">      /**</a>
<a name="ln2246">       * @code</a>
<a name="ln2247">       * bond ::= '-' | '=' | '#' | '$' | ':' | '/' | '\'</a>
<a name="ln2248">       * @endcode</a>
<a name="ln2249">       */</a>
<a name="ln2250">      void parseBond()</a>
<a name="ln2251">      {</a>
<a name="ln2252">        if (DEBUG)</a>
<a name="ln2253">          std::cout &lt;&lt; &quot;parseBond(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2254"> </a>
<a name="ln2255">        bool firstPrimitive = true;</a>
<a name="ln2256">        int parsedOp = 0;</a>
<a name="ln2257">        std::size_t lastPos = std::string::npos;</a>
<a name="ln2258"> </a>
<a name="ln2259">        while (lastPos != m_pos) {</a>
<a name="ln2260">          if (m_pos &gt;= m_str.size())</a>
<a name="ln2261">            return;</a>
<a name="ln2262">          lastPos = m_pos;</a>
<a name="ln2263"> </a>
<a name="ln2264">          switch (m_str[m_pos]) {</a>
<a name="ln2265">            case '-':</a>
<a name="ln2266">              m_bondOrder = 1;</a>
<a name="ln2267">              processBondPrimitive(BE_Single, firstPrimitive, parsedOp);</a>
<a name="ln2268">              break;</a>
<a name="ln2269">            case '=':</a>
<a name="ln2270">              m_bondOrder = 2;</a>
<a name="ln2271">              processBondPrimitive(BE_Double, firstPrimitive, parsedOp);</a>
<a name="ln2272">              break;</a>
<a name="ln2273">            case '#':</a>
<a name="ln2274">              m_bondOrder = 3;</a>
<a name="ln2275">              processBondPrimitive(BE_Triple, firstPrimitive, parsedOp);</a>
<a name="ln2276">              break;</a>
<a name="ln2277">            case '$':</a>
<a name="ln2278">              m_bondOrder = 4;</a>
<a name="ln2279">              processBondPrimitive(BE_Quadriple, firstPrimitive, parsedOp);</a>
<a name="ln2280">              break;</a>
<a name="ln2281">            case ':':</a>
<a name="ln2282">              m_bondOrder = 5;</a>
<a name="ln2283">              processBondPrimitive(BE_Aromatic, firstPrimitive, parsedOp);</a>
<a name="ln2284">              break;</a>
<a name="ln2285">            case '/':</a>
<a name="ln2286">              m_isUp = true;</a>
<a name="ln2287">              processBondPrimitive(BE_Up, firstPrimitive, parsedOp);</a>
<a name="ln2288">              break;</a>
<a name="ln2289">            case '\\':</a>
<a name="ln2290">              m_isDown = true;</a>
<a name="ln2291">              processBondPrimitive(BE_Down, firstPrimitive, parsedOp);</a>
<a name="ln2292">              break;</a>
<a name="ln2293">            case '~':</a>
<a name="ln2294">              if (m_mode == SmilesMode)</a>
<a name="ln2295">                break;</a>
<a name="ln2296">              processBondPrimitive(BE_Any, firstPrimitive, parsedOp);</a>
<a name="ln2297">              break;</a>
<a name="ln2298">            case '@':</a>
<a name="ln2299">              if (m_mode == SmilesMode)</a>
<a name="ln2300">                break;</a>
<a name="ln2301">              processBondPrimitive(BE_Ring, firstPrimitive, parsedOp);</a>
<a name="ln2302">              break;</a>
<a name="ln2303">            case '&amp;': // legal?</a>
<a name="ln2304">              if (m_mode == SmilesMode)</a>
<a name="ln2305">                break;</a>
<a name="ln2306">              if (firstPrimitive)</a>
<a name="ln2307">                throw Exception(Exception::SyntaxError, BinaryOpWithoutLeftOperand,</a>
<a name="ln2308">                    &quot;Binary '&amp;' in bond expression without left operand&quot;, m_pos, 1);</a>
<a name="ln2309">              m_callback.operation(OP_AndHi);</a>
<a name="ln2310">              parsedOp = OP_AndHi;</a>
<a name="ln2311">              ++m_pos;</a>
<a name="ln2312">              break;</a>
<a name="ln2313">            case ';': // legal?</a>
<a name="ln2314">              if (m_mode == SmilesMode)</a>
<a name="ln2315">                break;</a>
<a name="ln2316">              if (firstPrimitive)</a>
<a name="ln2317">                throw Exception(Exception::SyntaxError, BinaryOpWithoutLeftOperand,</a>
<a name="ln2318">                    &quot;Binary ';' in bond expression without left operand&quot;, m_pos, 1);</a>
<a name="ln2319">              m_callback.operation(OP_AndLo);</a>
<a name="ln2320">              parsedOp = OP_AndLo;</a>
<a name="ln2321">              ++m_pos;</a>
<a name="ln2322">              break;</a>
<a name="ln2323">            case ',':</a>
<a name="ln2324">              if (m_mode == SmilesMode)</a>
<a name="ln2325">                break;</a>
<a name="ln2326">              if (firstPrimitive)</a>
<a name="ln2327">                throw Exception(Exception::SyntaxError, BinaryOpWithoutLeftOperand,</a>
<a name="ln2328">                    &quot;Binary ',' in bond expression without left operand&quot;, m_pos, 1);</a>
<a name="ln2329">              m_callback.operation(OP_Or);</a>
<a name="ln2330">              parsedOp = OP_Or;</a>
<a name="ln2331">              ++m_pos;</a>
<a name="ln2332">              break;</a>
<a name="ln2333">            case '!':</a>
<a name="ln2334">              if (m_mode == SmilesMode)</a>
<a name="ln2335">                break;</a>
<a name="ln2336">              m_callback.operation(OP_Not);</a>
<a name="ln2337">              parsedOp = OP_Not;</a>
<a name="ln2338">              ++m_pos;</a>
<a name="ln2339">              break;</a>
<a name="ln2340">          }</a>
<a name="ln2341">        }</a>
<a name="ln2342"> </a>
<a name="ln2343">        switch (parsedOp) {</a>
<a name="ln2344">          case OP_AndHi:</a>
<a name="ln2345">          case OP_AndLo:</a>
<a name="ln2346">          case OP_Or:</a>
<a name="ln2347">            throw Exception(Exception::SyntaxError, BinaryOpWithoutRightOperand,</a>
<a name="ln2348">                &quot;Binary operator in bond expression without right operand&quot;, m_pos - 1, 1);</a>
<a name="ln2349">          case OP_Not:</a>
<a name="ln2350">            throw Exception(Exception::SyntaxError, UnaryOpWithoutArgument,</a>
<a name="ln2351">                &quot;Unary operator in bond expression without argument&quot;, m_pos - 1, 1);</a>
<a name="ln2352">          default:</a>
<a name="ln2353">            break;</a>
<a name="ln2354">        }</a>
<a name="ln2355">      }</a>
<a name="ln2356"> </a>
<a name="ln2357">      /**</a>
<a name="ln2358">       * Used for debugging.</a>
<a name="ln2359">       */</a>
<a name="ln2360">      void printRingBonds()</a>
<a name="ln2361">      {</a>
<a name="ln2362">        for (typename std::map&lt;int, std::vector&lt;RingBondInfo&gt; &gt;::iterator i = m_ringBonds.begin(); i != m_ringBonds.end(); ++i) {</a>
<a name="ln2363">          std::cout &lt;&lt; &quot;    RingBond: index = &quot; &lt;&lt; i-&gt;first &lt;&lt; std::endl;</a>
<a name="ln2364">          for (std::size_t j = 0; j &lt; i-&gt;second.size(); ++j)</a>
<a name="ln2365">            std::cout &lt;&lt; &quot;        &quot; &lt;&lt; i-&gt;second[j].number &lt;&lt; std::endl;</a>
<a name="ln2366">        }</a>
<a name="ln2367">      }</a>
<a name="ln2368"> </a>
<a name="ln2369">      /**</a>
<a name="ln2370">       * Helper function for parseRingBond().</a>
<a name="ln2371">       */</a>
<a name="ln2372">      void processRingBond(int rnum, std::size_t pos)</a>
<a name="ln2373">      {</a>
<a name="ln2374">        //std::cout &lt;&lt; &quot;BEFORE processing &quot; &lt;&lt; rnum &lt;&lt; std::endl; printRingBonds();</a>
<a name="ln2375"> </a>
<a name="ln2376">        // check if this ringbond is the second of a pair</a>
<a name="ln2377">        typename std::map&lt;int, std::vector&lt;RingBondInfo&gt; &gt;::iterator ringBond = m_ringBonds.begin();</a>
<a name="ln2378">        std::size_t j;</a>
<a name="ln2379">        bool found = false;</a>
<a name="ln2380">        for (; ringBond != m_ringBonds.end(); ++ringBond) {</a>
<a name="ln2381">          for (j = 0; j &lt; ringBond-&gt;second.size(); ++j)</a>
<a name="ln2382">            if (ringBond-&gt;second[j].number == rnum) {</a>
<a name="ln2383">              found = true;</a>
<a name="ln2384">              break;</a>
<a name="ln2385">            }</a>
<a name="ln2386">          if (found)</a>
<a name="ln2387">            break;</a>
<a name="ln2388">        }</a>
<a name="ln2389">        if (ringBond != m_ringBonds.end()) {</a>
<a name="ln2390">          // this is the second ringbond of a pair, make the bond</a>
<a name="ln2391">          if (ringBond-&gt;second[j].isExplicit) {</a>
<a name="ln2392">            // check if the bond types match</a>
<a name="ln2393">            if (m_explicitBond &amp;&amp; m_exceptions &amp; ConflictingRingBonds) {</a>
<a name="ln2394">              if (ringBond-&gt;second[j].order != m_bondOrder ||</a>
<a name="ln2395">                  ringBond-&gt;second[j].isUp != m_isUp ||</a>
<a name="ln2396">                  ringBond-&gt;second[j].isDown != m_isDown)</a>
<a name="ln2397">                throw Exception(Exception::SemanticsError, ConflictingRingBonds,</a>
<a name="ln2398">                    &quot;Conflicing ring bonds&quot;, pos, 1);</a>
<a name="ln2399">            }</a>
<a name="ln2400">            addBond(ringBond-&gt;first, m_prev, ringBond-&gt;second[j].order, ringBond-&gt;second[j].isUp, ringBond-&gt;second[j].isDown, rnum);</a>
<a name="ln2401">          } else</a>
<a name="ln2402">            addBond(ringBond-&gt;first, m_prev, m_bondOrder, m_isUp, m_isDown, rnum);</a>
<a name="ln2403">          // remove the ringbond from the list so it can be reused</a>
<a name="ln2404">          ringBond-&gt;second.erase(ringBond-&gt;second.begin() + j);</a>
<a name="ln2405">          if (ringBond-&gt;second.empty())</a>
<a name="ln2406">            m_ringBonds.erase(ringBond);</a>
<a name="ln2407">        } else {</a>
<a name="ln2408">          // add the ringbond to the list</a>
<a name="ln2409">          m_ringBonds[m_prev].push_back(RingBondInfo(rnum, m_bondOrder, m_isUp, m_isDown, m_explicitBond, pos));</a>
<a name="ln2410">          m_chiralInfo[m_prev].nbrs.push_back(-rnum);</a>
<a name="ln2411">        }</a>
<a name="ln2412"> </a>
<a name="ln2413">        //std::cout &lt;&lt; &quot;AFTER processing &quot; &lt;&lt; rnum &lt;&lt; std::endl; printRingBonds();</a>
<a name="ln2414">        resetBondInfo();</a>
<a name="ln2415">      }</a>
<a name="ln2416"> </a>
<a name="ln2417">      /**</a>
<a name="ln2418">       * @code</a>
<a name="ln2419">       * ringbond ::= bond? DIGIT | bond? '%' DIGIT DIGIT</a>
<a name="ln2420">       * @endcode</a>
<a name="ln2421">       */</a>
<a name="ln2422">      void parseRingBond()</a>
<a name="ln2423">      {</a>
<a name="ln2424">        if (DEBUG)</a>
<a name="ln2425">          std::cout &lt;&lt; &quot;parseRingBond(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2426"> </a>
<a name="ln2427">        parseBond();</a>
<a name="ln2428">        if (std::isdigit(m_str[m_pos])) {</a>
<a name="ln2429">          processRingBond(m_str[m_pos] - '0', m_pos);</a>
<a name="ln2430">          ++m_pos;</a>
<a name="ln2431">        } else if (m_str[m_pos] == '%') {</a>
<a name="ln2432">          std::size_t bond_pos = m_pos - 1;</a>
<a name="ln2433">          if (m_pos + 2 &gt;= m_str.size())</a>
<a name="ln2434">            throw Exception(Exception::SyntaxError, InvalidRingBondNumber,</a>
<a name="ln2435">                &quot;Invalid ring bond, expected number&quot;, m_pos + 1, 2);</a>
<a name="ln2436">          if (!std::isdigit(m_str[m_pos + 1]) || !std::isdigit(m_str[m_pos + 2]))</a>
<a name="ln2437">            throw Exception(Exception::SyntaxError, InvalidRingBondNumber,</a>
<a name="ln2438">                &quot;Expected ring bond number&quot;, m_pos + 1, 2);</a>
<a name="ln2439">          int r = 10 * (m_str[m_pos + 1] - '0') + m_str[m_pos + 2] - '0';</a>
<a name="ln2440">          processRingBond(r, bond_pos);</a>
<a name="ln2441">          m_pos += 3;</a>
<a name="ln2442">        }</a>
<a name="ln2443">      }</a>
<a name="ln2444"> </a>
<a name="ln2445">      /**</a>
<a name="ln2446">       * @code</a>
<a name="ln2447">       * dot ::= '.'</a>
<a name="ln2448">       * terminator ::= SPACE TAB | LINEFEED | CARRIAGE_RETURN | END_OF_STRING</a>
<a name="ln2449">       * branched_atom ::= atom ringbond* branch*</a>
<a name="ln2450">       * branch ::= '(' chain ')' | '(' bond chain ')' | '(' dot chain ')'</a>
<a name="ln2451">       * chain ::= branched_atom | chain branched_atom | chain bond branched_atom | chain dot branched_atom</a>
<a name="ln2452">       * smiles ::= chain terminator</a>
<a name="ln2453">       * @endcode</a>
<a name="ln2454">       */</a>
<a name="ln2455">      void parseChain()</a>
<a name="ln2456">      {</a>
<a name="ln2457">        if (DEBUG)</a>
<a name="ln2458">          std::cout &lt;&lt; &quot;parseChain(&quot; &lt;&lt; m_str.substr(m_pos) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2459"> </a>
<a name="ln2460">        while (true) {</a>
<a name="ln2461">          // check for dot ::= '.'?</a>
<a name="ln2462">          if (m_str[m_pos] == '.') {</a>
<a name="ln2463">            if (m_index == 0)</a>
<a name="ln2464">              throw Exception(Exception::SyntaxError, LeadingDot,</a>
<a name="ln2465">                  &quot;Found dot '.' at beginning of pattern&quot;, 0, 1);</a>
<a name="ln2466">            if (m_pos + 1 &gt;= m_str.size())</a>
<a name="ln2467">              throw Exception(Exception::SyntaxError, TrailingDot,</a>
<a name="ln2468">                  &quot;Found dor '.' at ending of pattern&quot;, m_pos - 1, 1);</a>
<a name="ln2469">            ++m_pos;</a>
<a name="ln2470">            m_prev = -1;</a>
<a name="ln2471">          }</a>
<a name="ln2472"> </a>
<a name="ln2473">          // check for closing branch ::= ')'*</a>
<a name="ln2474">          while (m_str[m_pos] == ')') {</a>
<a name="ln2475">            if (m_branches.size()) {</a>
<a name="ln2476">              if (DEBUG)</a>
<a name="ln2477">                std::cout &lt;&lt; &quot;    close branch: &quot; &lt;&lt; m_branches.back().index &lt;&lt; &quot; @pos &quot; &lt;&lt; m_pos &lt;&lt; std::endl;</a>
<a name="ln2478">              m_prev = m_branches.back().index;</a>
<a name="ln2479">              m_branches.pop_back();</a>
<a name="ln2480">              ++m_pos;</a>
<a name="ln2481">            } else</a>
<a name="ln2482">              throw Exception(Exception::SyntaxError, UnmatchedBranchClosing,</a>
<a name="ln2483">                  &quot;Unmatched branch closing&quot;, 0, m_pos + 1);</a>
<a name="ln2484">            if (m_pos &gt;= m_str.size())</a>
<a name="ln2485">              break;</a>
<a name="ln2486">          }</a>
<a name="ln2487"> </a>
<a name="ln2488">          // if there is a previous atom, check for bond ::= bond?</a>
<a name="ln2489">          if (m_prev != -1)</a>
<a name="ln2490">            parseBond();</a>
<a name="ln2491">          if (m_pos &gt;= m_str.size())</a>
<a name="ln2492">            break;</a>
<a name="ln2493"> </a>
<a name="ln2494">          // check atom ::= atom</a>
<a name="ln2495">          if (!parseAtom() &amp;&amp; m_str[m_pos] != '(')</a>
<a name="ln2496">            throw Exception(Exception::SyntaxError, InvalidAtomExpr,</a>
<a name="ln2497">                &quot;Could not parse atom expression&quot;, m_pos);</a>
<a name="ln2498">          else</a>
<a name="ln2499">            resetBondInfo();</a>
<a name="ln2500">          if (m_pos &gt;= m_str.size())</a>
<a name="ln2501">            break;</a>
<a name="ln2502"> </a>
<a name="ln2503">          // check for ring bond ::= ring_bond*</a>
<a name="ln2504">          std::size_t pos = std::string::npos;</a>
<a name="ln2505">          while (pos != m_pos &amp;&amp; m_pos &lt; m_str.size()) {</a>
<a name="ln2506">            pos = m_pos;</a>
<a name="ln2507">            parseRingBond();</a>
<a name="ln2508">          }</a>
<a name="ln2509">          if (m_pos &gt;= m_str.size())</a>
<a name="ln2510">            break;</a>
<a name="ln2511"> </a>
<a name="ln2512">          // check for branch opening ::= '('?</a>
<a name="ln2513">          pos = std::string::npos;</a>
<a name="ln2514">		  while (pos != m_pos &amp;&amp; m_pos &lt; m_str.size()) {</a>
<a name="ln2515">            pos = m_pos;</a>
<a name="ln2516">            if (m_str[m_pos] == '(') {</a>
<a name="ln2517">              if (DEBUG)</a>
<a name="ln2518">                std::cout &lt;&lt; &quot;    open branch: &quot; &lt;&lt; m_prev &lt;&lt; &quot; @pos &quot; &lt;&lt; m_pos &lt;&lt; std::endl;</a>
<a name="ln2519">              m_branches.push_back(BranchInfo(m_prev, m_pos));</a>
<a name="ln2520">              ++m_pos;</a>
<a name="ln2521">              parseChain();</a>
<a name="ln2522">            }</a>
<a name="ln2523">          }</a>
<a name="ln2524"> </a>
<a name="ln2525">          if (m_pos &gt;= m_str.size())</a>
<a name="ln2526">            break;</a>
<a name="ln2527"> </a>
<a name="ln2528">          // check for termination</a>
<a name="ln2529">          bool terminate = false;</a>
<a name="ln2530">          switch (m_str[m_pos]) {</a>
<a name="ln2531">            case ' ':</a>
<a name="ln2532">            case '\t':</a>
<a name="ln2533">            case '\n':</a>
<a name="ln2534">            case '\r':</a>
<a name="ln2535">              terminate = true;</a>
<a name="ln2536">              break;</a>
<a name="ln2537">            default:</a>
<a name="ln2538">              break;</a>
<a name="ln2539">          }</a>
<a name="ln2540">          if (terminate)</a>
<a name="ln2541">            break;</a>
<a name="ln2542">        }</a>
<a name="ln2543">      }</a>
<a name="ln2544"> </a>
<a name="ln2545">      /**</a>
<a name="ln2546">       * @return Expected valence.</a>
<a name="ln2547">       */</a>
<a name="ln2548">      int processAlleneStereochemistry(ChiralInfo &amp;chiralInfo)</a>
<a name="ln2549">      {</a>
<a name="ln2550">        if (chiralInfo.nbrs.size() != 2)</a>
<a name="ln2551">          return -1;</a>
<a name="ln2552">        std::vector&lt;int&gt; &amp;nbrs = chiralInfo.nbrs;</a>
<a name="ln2553">        int lft = nbrs[0];</a>
<a name="ln2554">        int rgt = nbrs[1];</a>
<a name="ln2555">        if (m_chiralInfo[lft].nbrs.size() != 3 || m_chiralInfo[rgt].nbrs.size() != 3)</a>
<a name="ln2556">          return -1;</a>
<a name="ln2557">        // NC(F)=[C@AL1]=C(Cl)I     nbrs[1] = [ 0 2 3 ]  &lt;-----------+</a>
<a name="ln2558">        // ^  ^   ^        ^  ^     nbrs[3] = [ 1 4 ]    &lt;- chiral   +-- neigbors</a>
<a name="ln2559">        // 0  2   3        5  6     nbrs[4] = [ 3 5 6 ]  &lt;-----------+</a>
<a name="ln2560">        nbrs.clear();</a>
<a name="ln2561">        // copy [ 0 2 ] to nbrs[3]</a>
<a name="ln2562">        nbrs.insert(nbrs.end(), m_chiralInfo[lft].nbrs.begin(), m_chiralInfo[lft].nbrs.end() - 1);</a>
<a name="ln2563">        // copy [ 5 6 ] to nbrs[3]</a>
<a name="ln2564">        nbrs.insert(nbrs.end(), m_chiralInfo[rgt].nbrs.begin() + 1, m_chiralInfo[rgt].nbrs.end());</a>
<a name="ln2565">        if (chiralInfo.chiral == AntiClockwise)</a>
<a name="ln2566">          chiralInfo.chiral = AL1;</a>
<a name="ln2567">        else if (chiralInfo.chiral == Clockwise)</a>
<a name="ln2568">          chiralInfo.chiral = AL2;</a>
<a name="ln2569">        return 4;</a>
<a name="ln2570">      }</a>
<a name="ln2571"> </a>
<a name="ln2572">      /**</a>
<a name="ln2573">       * Handle stereochemistry by calling Callback::setChiral() for each chiral atom.</a>
<a name="ln2574">       */</a>
<a name="ln2575">      void processStereochemistry()</a>
<a name="ln2576">      {</a>
<a name="ln2577">        for (std::size_t i = 0; i &lt; m_chiralInfo.size(); ++i) {</a>
<a name="ln2578">          if (!m_chiralInfo[i].chiral)</a>
<a name="ln2579">            continue;</a>
<a name="ln2580">          int expectedValence = -1;</a>
<a name="ln2581">          switch (m_chiralInfo[i].chiral) {</a>
<a name="ln2582">            case Clockwise:</a>
<a name="ln2583">              switch (m_chiralInfo[i].nbrs.size()) {</a>
<a name="ln2584">                case 2:</a>
<a name="ln2585">                  // Allene</a>
<a name="ln2586">                  expectedValence = processAlleneStereochemistry(m_chiralInfo[i]);</a>
<a name="ln2587">                  break;</a>
<a name="ln2588">                case 4:</a>
<a name="ln2589">                  // Tetrahedral</a>
<a name="ln2590">                  // Square Planar</a>
<a name="ln2591">                  expectedValence = 4;</a>
<a name="ln2592">                  // determining correct class requires knowledge of atom (TH vs. SP)</a>
<a name="ln2593">                  break;</a>
<a name="ln2594">                case 5:</a>
<a name="ln2595">                  m_chiralInfo[i].chiral = TB1;</a>
<a name="ln2596">                  expectedValence = 5;</a>
<a name="ln2597">                  break;</a>
<a name="ln2598">                case 6:</a>
<a name="ln2599">                  m_chiralInfo[i].chiral = OH1;</a>
<a name="ln2600">                  expectedValence = 6;</a>
<a name="ln2601">                  break;</a>
<a name="ln2602">              }</a>
<a name="ln2603">              break;</a>
<a name="ln2604">            case AntiClockwise:</a>
<a name="ln2605">              switch (m_chiralInfo[i].nbrs.size()) {</a>
<a name="ln2606">                case 2:</a>
<a name="ln2607">                  // Allene</a>
<a name="ln2608">                  expectedValence = processAlleneStereochemistry(m_chiralInfo[i]);</a>
<a name="ln2609">                  break;</a>
<a name="ln2610">                case 4:</a>
<a name="ln2611">                  expectedValence = 4;</a>
<a name="ln2612">                  break;</a>
<a name="ln2613">                case 5:</a>
<a name="ln2614">                  m_chiralInfo[i].chiral = TB2;</a>
<a name="ln2615">                  expectedValence = 5;</a>
<a name="ln2616">                  break;</a>
<a name="ln2617">                case 6:</a>
<a name="ln2618">                  m_chiralInfo[i].chiral = OH2;</a>
<a name="ln2619">                  expectedValence = 6;</a>
<a name="ln2620">                  break;</a>
<a name="ln2621">              }</a>
<a name="ln2622">              break;</a>
<a name="ln2623">            case TH1:</a>
<a name="ln2624">            case TH2:</a>
<a name="ln2625">            case SP1:</a>
<a name="ln2626">            case SP2:</a>
<a name="ln2627">            case SP3:</a>
<a name="ln2628">              expectedValence = 4;</a>
<a name="ln2629">              break;</a>
<a name="ln2630">            case AL1:</a>
<a name="ln2631">            case AL2:</a>
<a name="ln2632">              expectedValence = processAlleneStereochemistry(m_chiralInfo[i]);</a>
<a name="ln2633">              break;</a>
<a name="ln2634">            default:</a>
<a name="ln2635">              if (m_chiralInfo[i].chiral &gt;= TB1 &amp;&amp; m_chiralInfo[i].chiral &lt;= TB20)</a>
<a name="ln2636">                expectedValence = 5;</a>
<a name="ln2637">              else if (m_chiralInfo[i].chiral &gt;= OH1 &amp;&amp; m_chiralInfo[i].chiral &lt;= OH30)</a>
<a name="ln2638">                expectedValence = 6;</a>
<a name="ln2639">              break;</a>
<a name="ln2640">          }</a>
<a name="ln2641"> </a>
<a name="ln2642">          if (m_chiralInfo[i].nbrs.size() != expectedValence &amp;&amp; m_exceptions &amp; InvalidChiralValence)</a>
<a name="ln2643">            throw Exception(Exception::SemanticsError, InvalidChiralValence,</a>
<a name="ln2644">                &quot;Invalid chiral valence&quot;, m_chiralInfo[i].pos, 1);</a>
<a name="ln2645"> </a>
<a name="ln2646">          m_callback.setChiral(i, static_cast&lt;Chirality&gt;(m_chiralInfo[i].chiral), m_chiralInfo[i].nbrs);</a>
<a name="ln2647">        }</a>
<a name="ln2648">      }</a>
<a name="ln2649"> </a>
<a name="ln2650">    public:</a>
<a name="ln2651">      enum Mode {</a>
<a name="ln2652">        SmilesMode,</a>
<a name="ln2653">        SmartsMode</a>
<a name="ln2654">      };</a>
<a name="ln2655"> </a>
<a name="ln2656">      /**</a>
<a name="ln2657">       * Constructor.</a>
<a name="ln2658">       *</a>
<a name="ln2659">       * @param callback The callback function object to handle the information</a>
<a name="ln2660">       * resulting from parsing. By default, all exceptions are enabled and the</a>
<a name="ln2661">       * parser is in SMILES mode.</a>
<a name="ln2662">       */</a>
<a name="ln2663">      Parser(Callback &amp;callback, Mode mode = SmilesMode) : m_callback(callback),</a>
<a name="ln2664">          m_mode(mode), m_exceptions(~0)</a>
<a name="ln2665">      {</a>
<a name="ln2666">      }</a>
<a name="ln2667"> </a>
<a name="ln2668">      /**</a>
<a name="ln2669">       * Set the parser mode.</a>
<a name="ln2670">       */</a>
<a name="ln2671">      void setMode(Mode mode)</a>
<a name="ln2672">      {</a>
<a name="ln2673">        m_mode = mode;</a>
<a name="ln2674">      }</a>
<a name="ln2675"> </a>
<a name="ln2676">      /**</a>
<a name="ln2677">       * Parse a SMILES/SMARTS string.</a>
<a name="ln2678">       *</a>
<a name="ln2679">       * @param str The SMILES/SMARTS string.</a>
<a name="ln2680">       */</a>
<a name="ln2681">      void parse(const std::string &amp;str)</a>
<a name="ln2682">      {</a>
<a name="ln2683">        m_callback.clear();</a>
<a name="ln2684"> </a>
<a name="ln2685">        if (str.empty())</a>
<a name="ln2686">          return;</a>
<a name="ln2687"> </a>
<a name="ln2688">        m_str = str;</a>
<a name="ln2689">        m_pos = 0;</a>
<a name="ln2690"> </a>
<a name="ln2691">        m_index = 0;</a>
<a name="ln2692">        m_prev = -1;</a>
<a name="ln2693">        m_branches.clear();</a>
<a name="ln2694">        m_ringBonds.clear();</a>
<a name="ln2695">        m_chiralInfo.clear();</a>
<a name="ln2696">        m_chiralInfo.push_back(ChiralInfo());</a>
<a name="ln2697"> </a>
<a name="ln2698">        parseChain();</a>
<a name="ln2699"> </a>
<a name="ln2700">        if (m_branches.size())</a>
<a name="ln2701">          throw Exception(Exception::SyntaxError, UnmatchedBranchOpening,</a>
<a name="ln2702">              &quot;Unmatched branch opening&quot;, m_branches.back().pos, m_str.size() - m_branches.back().pos);</a>
<a name="ln2703">        if (m_ringBonds.size() &amp;&amp; m_exceptions &amp; UnmatchedRingBond)</a>
<a name="ln2704">          throw Exception(Exception::SemanticsError, UnmatchedRingBond,</a>
<a name="ln2705">              &quot;Unmatched ring bond&quot;, m_ringBonds.begin()-&gt;second[0].pos, 1);</a>
<a name="ln2706"> </a>
<a name="ln2707">        processStereochemistry();</a>
<a name="ln2708">      }</a>
<a name="ln2709"> </a>
<a name="ln2710">      /**</a>
<a name="ln2711">       * Disable the specified @p exceptions.</a>
<a name="ln2712">       *</a>
<a name="ln2713">       * @param exceptions Exception ErrorCode (may be OR-ed).</a>
<a name="ln2714">       */</a>
<a name="ln2715">      void disableExceptions(ErrorCode exceptions)</a>
<a name="ln2716">      {</a>
<a name="ln2717">        m_exceptions &amp;= ~exceptions;</a>
<a name="ln2718">      }</a>
<a name="ln2719"> </a>
<a name="ln2720">      /**</a>
<a name="ln2721">       * Enable specified exceptions.</a>
<a name="ln2722">       *</a>
<a name="ln2723">       * @param exceptions Exceptions to enable (may be OR-ed).</a>
<a name="ln2724">       */</a>
<a name="ln2725">      void enableExceptions(ErrorCode exceptions)</a>
<a name="ln2726">      {</a>
<a name="ln2727">        m_exceptions |= exceptions;</a>
<a name="ln2728">      }</a>
<a name="ln2729"> </a>
<a name="ln2730">      /**</a>
<a name="ln2731">       * Disable all disableable exceptions.</a>
<a name="ln2732">       */</a>
<a name="ln2733">      void disableAllExceptions()</a>
<a name="ln2734">      {</a>
<a name="ln2735">        m_exceptions = 0;</a>
<a name="ln2736">      }</a>
<a name="ln2737"> </a>
<a name="ln2738">      /**</a>
<a name="ln2739">       * Enable all exceptions.</a>
<a name="ln2740">       */</a>
<a name="ln2741">      void enableAllExceptions()</a>
<a name="ln2742">      {</a>
<a name="ln2743">        m_exceptions = ~0;</a>
<a name="ln2744">      }</a>
<a name="ln2745"> </a>
<a name="ln2746">    private:</a>
<a name="ln2747">      Callback &amp;m_callback; //!&lt; callback for handling events</a>
<a name="ln2748"> </a>
<a name="ln2749">      std::string m_str; //!&lt; the SMILES/SMARTS string</a>
<a name="ln2750">      std::size_t m_pos; //!&lt; current position in m_str</a>
<a name="ln2751">      Mode m_mode; // SMILES/SMARTS mode</a>
<a name="ln2752"> </a>
<a name="ln2753">      // atom</a>
<a name="ln2754">      int m_element; //!&lt; atom element</a>
<a name="ln2755">      int m_isotope; //!&lt; atom isotope</a>
<a name="ln2756">      int m_charge; //!&lt; atom charge</a>
<a name="ln2757">      int m_chiral; //!&lt; atom chirality</a>
<a name="ln2758">      int m_hCount; //!&lt; atom hydrogran count</a>
<a name="ln2759">      int m_class; //!&lt; atom class</a>
<a name="ln2760">      bool m_aromatic; //!&lt; is atom aromatic</a>
<a name="ln2761">      // bond</a>
<a name="ln2762">      int m_bondOrder; //!&lt; last bond's order (1, 2, 3, 4 and 5 for aromatic</a>
<a name="ln2763">      bool m_isUp; //!&lt; is last bond '/'</a>
<a name="ln2764">      bool m_isDown; //!&lt; is last bond '\'</a>
<a name="ln2765">      bool m_explicitBond; //!&lt; is last bond explicit</a>
<a name="ln2766">      // branches &amp; other state</a>
<a name="ln2767">      std::vector&lt;BranchInfo&gt; m_branches; //!&lt; used as stack</a>
<a name="ln2768">      std::map&lt;int, std::vector&lt;RingBondInfo&gt; &gt; m_ringBonds; //!&lt; atom index -&gt; RingBondInfo</a>
<a name="ln2769">      std::vector&lt;ChiralInfo&gt; m_chiralInfo; //!&lt; atom index -&gt; ChiralInfo</a>
<a name="ln2770">      int m_index; //!&lt; current atom index</a>
<a name="ln2771">      int m_prev; // !&lt; previous atom index (-1 for none)</a>
<a name="ln2772">      int m_exceptions;</a>
<a name="ln2773">  };</a>
<a name="ln2774"> </a>
<a name="ln2775">}</a>
<a name="ln2776"> </a>
<a name="ln2777">#endif</a>

</code></pre>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'm_element' variable was assigned the same value.</p></div>
<div class="balloon" rel="593"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: unary, binary.</p></div>
<div class="balloon" rel="616"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: expr.</p></div>
<div class="balloon" rel="617"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: expr.</p></div>
<div class="balloon" rel="969"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: isExplicit.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

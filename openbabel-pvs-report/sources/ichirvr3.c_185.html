
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichirvr3.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">/*#define CHECK_WIN32_VC_HEAP*/</a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;ichi.h&quot;</a>
<a name="ln50">#include &quot;ichitime.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">#include &quot;inpdef.h&quot;</a>
<a name="ln53">#include &quot;ichimain.h&quot;</a>
<a name="ln54">#include &quot;ichierr.h&quot;</a>
<a name="ln55">#include &quot;incomdef.h&quot;</a>
<a name="ln56">#include &quot;ichiring.h&quot;</a>
<a name="ln57">#include &quot;extr_ct.h&quot;</a>
<a name="ln58">#include &quot;ichitaut.h&quot;</a>
<a name="ln59">#include &quot;ichinorm.h&quot;</a>
<a name="ln60">#include &quot;util.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;ichicomp.h&quot;</a>
<a name="ln63">#include &quot;ichister.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;ichi_bns.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;strutil.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">#include &quot;ichirvrs.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">#define INC_ADD_EDGE 64</a>
<a name="ln72"> </a>
<a name="ln73">/* local types */</a>
<a name="ln74"> </a>
<a name="ln75">/* types for TgDiffHChgFH */</a>
<a name="ln76">#define fNumRPosChgH 0 /* number of positive charges on endpoints that have H in at2[] */</a>
<a name="ln77">#define fNumRPosChgU 1 /* number of positive charges on endpoints that have no H in at2[] */</a>
<a name="ln78">#define fNumRNegChgO 2 /* number of negative charges on O endpoints */</a>
<a name="ln79">#define fNumRNegChgN 3 /* number of negative charges on N endpoints */</a>
<a name="ln80">#define fNumRNeutrlH 4 /* number of neutral endp that have H in at2[] */</a>
<a name="ln81"> </a>
<a name="ln82">#define fNumNPosChgH 5 /* number of positive charges on endpoints that have H in atf[] */</a>
<a name="ln83">#define fNumNPosChgU 6 /* number of positive charges on endpoints that have no H in atf[] */</a>
<a name="ln84">#define fNumNNegChgO 7 /* number of negative charges on O endpoints */</a>
<a name="ln85">#define fNumNNegChgN 8 /* number of negative charges on N endpoints */</a>
<a name="ln86">#define fNumNNeutrlH 9 /* number of neutral endp that have H in atf[] */</a>
<a name="ln87"> </a>
<a name="ln88">#define fNumAllChgT 10 /* total  number of fNum... */</a>
<a name="ln89"> </a>
<a name="ln90">typedef struct tagTgDiffHChgFH {</a>
<a name="ln91">    short  itg; /* t-group index; endpoint = itg+1 */</a>
<a name="ln92">    short  nNumHInchi;  /* number of H in t-group from orig. InChI */</a>
<a name="ln93">    short  nNumHRevrs;  /* number of H in at2[] */</a>
<a name="ln94">    short  nNumHNorml;  /* number of H in Normalized atfMobile_H_Revrs[] */</a>
<a name="ln95">    short  nNumMInchi;  /* number of (-) in InChI */</a>
<a name="ln96">    short  nNumMRevrs;  /* number of (-) in at2[] */</a>
<a name="ln97">    short  nNumMNorml;  /* number of (-) in atf[] */</a>
<a name="ln98">    short  nNumPRevrs;  /* number of (+) in at2[] */</a>
<a name="ln99">    short  nNumPNorml;  /* number of (+) in Normalized atfMobile_H_Revrs[] */</a>
<a name="ln100">    short n[fNumAllChgT]; /* all numbers */</a>
<a name="ln101">    short i[fNumAllChgT]; /* all indices */</a>
<a name="ln102">} TgDiffHChgFH;</a>
<a name="ln103"> </a>
<a name="ln104">/* local prototypes */</a>
<a name="ln105">static int FillTgDiffHChgFH( TgDiffHChgFH tdhc[], int max_tdhc, inp_ATOM at2[], inp_ATOM atf[],</a>
<a name="ln106">                            AT_NUMB  *nCanon2AtnoRevrs, VAL_AT *pVA, T_GROUP_INFO *ti, EDGE_LIST *pAtomIndList );</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">/************************************************************/</a>
<a name="ln110">int bHas_N_V( inp_ATOM *at2, int num_atoms )</a>
<a name="ln111">{</a>
<a name="ln112">    static U_CHAR el_number_N;</a>
<a name="ln113">    int i, num_found = 0;</a>
<a name="ln114">    if ( !el_number_N ) {</a>
<a name="ln115">        el_number_N = get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln116">    }</a>
<a name="ln117">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln118">        if ( at2[i].el_number == el_number_N &amp;&amp; !at2[i].charge &amp;&amp;</a>
<a name="ln119">             !at2[i].num_H &amp;&amp; !at2[i].radical &amp;&amp;</a>
<a name="ln120">             at2[i].chem_bonds_valence == 5 &amp;&amp;</a>
<a name="ln121">             (at2[i].valence==3) ) {</a>
<a name="ln122">            num_found ++;</a>
<a name="ln123">        }</a>
<a name="ln124">    }</a>
<a name="ln125">    return num_found;</a>
<a name="ln126">}</a>
<a name="ln127">/*************************************************************************************/</a>
<a name="ln128">int FillTgDiffHChgFH( TgDiffHChgFH tdhc[], int max_tdhc, inp_ATOM at2[],</a>
<a name="ln129">                      inp_ATOM atf[], AT_NUMB  *nCanon2AtnoRevrs, VAL_AT *pVA,</a>
<a name="ln130">                      T_GROUP_INFO *ti, EDGE_LIST *pAtomIndList )</a>
<a name="ln131">{</a>
<a name="ln132"> </a>
<a name="ln133">    int i, j, iat, itg, itg_prev, num, itg_out, bOverflow;</a>
<a name="ln134">    EDGE_LIST IndList;   /* type, itg */</a>
<a name="ln135">    TgDiffHChgFH cur_tdhc;</a>
<a name="ln136">    AT_NUMB    *pEndp0;</a>
<a name="ln137">    inp_ATOM   *at2i, *atfi;</a>
<a name="ln138">    int         typeR, typeN, type, ret = 0, nCurIndListLen;</a>
<a name="ln139"> </a>
<a name="ln140">    AllocEdgeList( &amp;IndList, EDGE_LIST_CLEAR );</a>
<a name="ln141">    pAtomIndList-&gt;num_edges = 0;</a>
<a name="ln142">    itg_out = 0;</a>
<a name="ln143">    bOverflow = 0;</a>
<a name="ln144">    memset( tdhc, 0, max_tdhc * sizeof(tdhc[0]) );</a>
<a name="ln145"> </a>
<a name="ln146">    for ( itg = 0; itg &lt; ti-&gt;num_t_groups; itg ++ ) {</a>
<a name="ln147">        memset( &amp;cur_tdhc, 0, sizeof(cur_tdhc) );</a>
<a name="ln148"> </a>
<a name="ln149">        cur_tdhc.itg = itg;</a>
<a name="ln150">        cur_tdhc.nNumHInchi = ti-&gt;t_group[itg].num[0] - ti-&gt;t_group[itg].num[1];</a>
<a name="ln151">        cur_tdhc.nNumMInchi = ti-&gt;t_group[itg].num[1];</a>
<a name="ln152">        </a>
<a name="ln153">        pEndp0 = ti-&gt;nEndpointAtomNumber + ti-&gt;t_group[itg].nFirstEndpointAtNoPos;</a>
<a name="ln154">        nCurIndListLen = IndList.num_edges;</a>
<a name="ln155">        for ( j = 0; j &lt; ti-&gt;t_group[itg].nNumEndpoints; j ++ ) {</a>
<a name="ln156">            i = pEndp0[j];</a>
<a name="ln157">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln158">            </a>
<a name="ln159">            at2i = at2 + iat;</a>
<a name="ln160">            atfi = atf + iat;</a>
<a name="ln161">            </a>
<a name="ln162">            typeR = typeN = -1;</a>
<a name="ln163">            if ( at2i-&gt;charge == 1 ) {</a>
<a name="ln164">                if ( at2i-&gt;num_H ) {</a>
<a name="ln165">                    typeR = fNumRPosChgH;</a>
<a name="ln166">                } else {</a>
<a name="ln167">                    typeR = fNumRPosChgU;</a>
<a name="ln168">                }</a>
<a name="ln169">                cur_tdhc.nNumPRevrs ++;</a>
<a name="ln170">            } else</a>
<a name="ln171">            if ( at2i-&gt;charge == -1 ) {</a>
<a name="ln172">                if ( pVA[iat].cNumValenceElectrons == 6) {</a>
<a name="ln173">                    typeR = fNumRNegChgO;</a>
<a name="ln174">                } else</a>
<a name="ln175">                if ( pVA[iat].cNumValenceElectrons == 5) {</a>
<a name="ln176">                    typeR = fNumRNegChgN;</a>
<a name="ln177">                }</a>
<a name="ln178">                cur_tdhc.nNumMRevrs ++;</a>
<a name="ln179">            } else</a>
<a name="ln180">            if ( at2i-&gt;num_H &amp;&amp; at2i-&gt;valence == at2i-&gt;chem_bonds_valence ) {</a>
<a name="ln181">                typeR = fNumRNeutrlH;</a>
<a name="ln182">            }</a>
<a name="ln183">            cur_tdhc.nNumHRevrs += at2i-&gt;num_H;</a>
<a name="ln184"> </a>
<a name="ln185">            if ( atfi-&gt;charge == 1 ) {</a>
<a name="ln186">                if ( atfi-&gt;num_H ) {</a>
<a name="ln187">                    typeN = fNumNPosChgH;</a>
<a name="ln188">                } else {</a>
<a name="ln189">                    typeN = fNumNPosChgU;</a>
<a name="ln190">                }</a>
<a name="ln191">                cur_tdhc.nNumPNorml ++;</a>
<a name="ln192">            } else</a>
<a name="ln193">            if ( atfi-&gt;charge == -1 ) {</a>
<a name="ln194">                if ( pVA[iat].cNumValenceElectrons == 6) {</a>
<a name="ln195">                    typeN = fNumNNegChgO;</a>
<a name="ln196">                } else</a>
<a name="ln197">                if ( pVA[iat].cNumValenceElectrons == 5) {</a>
<a name="ln198">                    typeN = fNumNNegChgN;</a>
<a name="ln199">                }</a>
<a name="ln200">                cur_tdhc.nNumMNorml ++;</a>
<a name="ln201">            } else</a>
<a name="ln202">            if ( atfi-&gt;num_H &amp;&amp; atfi-&gt;valence == atfi-&gt;chem_bonds_valence ) {</a>
<a name="ln203">                typeN = fNumNNeutrlH;</a>
<a name="ln204">            }</a>
<a name="ln205">            cur_tdhc.nNumHNorml += atfi-&gt;num_H;</a>
<a name="ln206">            if ( at2[iat].charge &lt; 0 || 0 &lt; pVA[iat].nCPlusGroupEdge ) {</a>
<a name="ln207">                if ( typeR &gt;= 0 &amp;&amp; (</a>
<a name="ln208">                     (ret = AddToEdgeList( &amp;IndList, typeR, INC_ADD_EDGE )) ||</a>
<a name="ln209">                     (ret = AddToEdgeList( &amp;IndList, itg, INC_ADD_EDGE )) ||</a>
<a name="ln210">                     (ret = AddToEdgeList( &amp;IndList, iat, INC_ADD_EDGE )) ) ) {</a>
<a name="ln211">                    goto exit_function;</a>
<a name="ln212">                }</a>
<a name="ln213">                if ( typeN &gt;= 0 &amp;&amp; (</a>
<a name="ln214">                     (ret = AddToEdgeList( &amp;IndList, typeN, INC_ADD_EDGE )) ||</a>
<a name="ln215">                     (ret = AddToEdgeList( &amp;IndList, itg, INC_ADD_EDGE )) ||</a>
<a name="ln216">                     (ret = AddToEdgeList( &amp;IndList, iat, INC_ADD_EDGE )) ) ) {</a>
<a name="ln217">                    goto exit_function;</a>
<a name="ln218">                }</a>
<a name="ln219">            }</a>
<a name="ln220"> </a>
<a name="ln221">        }</a>
<a name="ln222">        if ( cur_tdhc.nNumHNorml == cur_tdhc.nNumHInchi &amp;&amp;</a>
<a name="ln223">             cur_tdhc.nNumMNorml == cur_tdhc.nNumMInchi ) {</a>
<a name="ln224">            IndList.num_edges = nCurIndListLen; /* t-group seems to be correct */</a>
<a name="ln225">            continue;</a>
<a name="ln226">        }</a>
<a name="ln227">        if ( itg_out &lt; max_tdhc ) {</a>
<a name="ln228">            tdhc[itg_out ++] = cur_tdhc;</a>
<a name="ln229">        } else {</a>
<a name="ln230">            bOverflow |= 1;</a>
<a name="ln231">            IndList.num_edges = nCurIndListLen;</a>
<a name="ln232">            break;</a>
<a name="ln233">        }</a>
<a name="ln234">    }</a>
<a name="ln235">    /* fill out atom index list */</a>
<a name="ln236">    if ( itg_out ) {</a>
<a name="ln237">        itg_prev = IndList.pnEdges[1]; /* the 1st saved t-group number */</a>
<a name="ln238">        for ( type = 0; type &lt; fNumAllChgT; type ++ ) {</a>
<a name="ln239">            j = 0;</a>
<a name="ln240">            for ( i = 0; i &lt; itg_out; i ++ ) {</a>
<a name="ln241">                num = 0;</a>
<a name="ln242">                itg = tdhc[i].itg;</a>
<a name="ln243">                tdhc[i].i[type] = -999; /* empty */</a>
<a name="ln244">                while( IndList.pnEdges[j+1] == itg ) {</a>
<a name="ln245">                    if ( IndList.pnEdges[j] == type ) {</a>
<a name="ln246">                        if ( !num ++ ) {</a>
<a name="ln247">                            tdhc[i].i[type] = pAtomIndList-&gt;num_edges;</a>
<a name="ln248">                        }</a>
<a name="ln249">                        if ( (ret = AddToEdgeList( pAtomIndList, IndList.pnEdges[j+2], INC_ADD_EDGE )) ) {</a>
<a name="ln250">                            goto exit_function;</a>
<a name="ln251">                        }</a>
<a name="ln252">                    }</a>
<a name="ln253">                    j += 3;</a>
<a name="ln254">                }</a>
<a name="ln255">                tdhc[i].n[type] = num;</a>
<a name="ln256">            }</a>
<a name="ln257">        }</a>
<a name="ln258">    }</a>
<a name="ln259">    ret = itg_out;</a>
<a name="ln260">exit_function:</a>
<a name="ln261">    AllocEdgeList( &amp;IndList, EDGE_LIST_FREE );</a>
<a name="ln262">    return ret;</a>
<a name="ln263"> </a>
<a name="ln264">/*</a>
<a name="ln265">#undef fNumRPosChgH</a>
<a name="ln266">#undef fNumRPosChgU</a>
<a name="ln267">#undef fNumRNegChgO</a>
<a name="ln268">#undef fNumRNegChgN</a>
<a name="ln269"> </a>
<a name="ln270">#undef fNumNPosChgH</a>
<a name="ln271">#undef fNumNPosChgU</a>
<a name="ln272">#undef fNumNNegChgO</a>
<a name="ln273">#undef fNumNNegChgN</a>
<a name="ln274"> </a>
<a name="ln275">#undef fNumAllChgT    </a>
<a name="ln276">*/</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">/***********************************************************************************************/</a>
<a name="ln280">int FixFixedHRestoredStructure(ICHICONST INPUT_PARMS *ip, STRUCT_DATA *sd, BN_STRUCT *pBNS, BN_DATA *pBD,</a>
<a name="ln281">                        StrFromINChI *pStruct, inp_ATOM *at, inp_ATOM *at2, inp_ATOM *at3, VAL_AT *pVA,</a>
<a name="ln282">                        ALL_TC_GROUPS *pTCGroups, T_GROUP_INFO **ppt_group_info, inp_ATOM **ppat_norm,</a>
<a name="ln283">                        inp_ATOM **ppat_prep, INChI *pInChI[], long num_inp, int bHasSomeFixedH,</a>
<a name="ln284">                        int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask, int forbidden_stereo_edge_mask)</a>
<a name="ln285">{</a>
<a name="ln286">    /*--------- process extra or missing Fixed-H on non-tautomeric atoms ------*/</a>
<a name="ln287">    /* at2 should be the most recently restored atom, Fixed-H */</a>
<a name="ln288">    int i, j, k, delta, num_try, tot_succes, cur_success, ret = 0, bAllowedNFlowerEdges=0, num_zero_ret;</a>
<a name="ln289">    CMP2FHINCHI c2i;</a>
<a name="ln290">    CMP2FHINCHI *pc2i = &amp;c2i;</a>
<a name="ln291"> </a>
<a name="ln292">    EDGE_LIST AllChargeEdges, CurrEdges, SFlowerEdges, NFlowerEdges, OtherNFlowerEdges, FixedLargeRingStereoEdges;</a>
<a name="ln293">    EDGE_LIST AllBondEdges;</a>
<a name="ln294">    </a>
<a name="ln295">    EdgeIndex e;</a>
<a name="ln296">    BNS_EDGE  *pe;</a>
<a name="ln297">    Vertex v1, v2;</a>
<a name="ln298">    BNS_VERTEX *pv1, *pv2;</a>
<a name="ln299"> </a>
<a name="ln300">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln301">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln302"> </a>
<a name="ln303">    int        nNumRunBNS = 0, forbidden_edge_mask_inv = ~forbidden_edge_mask;</a>
<a name="ln304"> </a>
<a name="ln305">    INCHI_HEAPCHK</a>
<a name="ln306"> </a>
<a name="ln307">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln308">    AllocEdgeList( &amp;CurrEdges, EDGE_LIST_CLEAR );</a>
<a name="ln309">    AllocEdgeList( &amp;NFlowerEdges, EDGE_LIST_CLEAR );</a>
<a name="ln310">    AllocEdgeList( &amp;SFlowerEdges, EDGE_LIST_CLEAR );</a>
<a name="ln311">    AllocEdgeList( &amp;OtherNFlowerEdges, EDGE_LIST_CLEAR );</a>
<a name="ln312">    AllocEdgeList( &amp;FixedLargeRingStereoEdges, EDGE_LIST_CLEAR );</a>
<a name="ln313">    AllocEdgeList( &amp;AllBondEdges, EDGE_LIST_CLEAR );</a>
<a name="ln314"> </a>
<a name="ln315">    tot_succes = 0;</a>
<a name="ln316">    </a>
<a name="ln317">    if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln318">        goto exit_function;  /* no fixed-H found */</a>
<a name="ln319">    }</a>
<a name="ln320"> </a>
<a name="ln321">    for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln322">        if ( (e=pVA[i].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln323">             (ret = AddToEdgeList( &amp;AllChargeEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln324">            goto exit_function;</a>
<a name="ln325">        }</a>
<a name="ln326">        if ( (e=pVA[i].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln327">            if ( (ret = AddToEdgeList( &amp;AllChargeEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln328">                goto exit_function;</a>
<a name="ln329">            }</a>
<a name="ln330"> </a>
<a name="ln331">            /* in addition, disallow N(V) creation by forbidding charge flower edge that has flow=1 */</a>
<a name="ln332">            if ( pVA[i].cNumValenceElectrons == 5 &amp;&amp; !pVA[i].cMetal &amp;&amp; /* N, P, As */</a>
<a name="ln333">                 NO_VERTEX != (j = GetChargeFlowerUpperEdge( pBNS, pVA, e ))) {</a>
<a name="ln334"> </a>
<a name="ln335">                if ( pBNS-&gt;edge[j].forbidden ) {</a>
<a name="ln336">                    continue;</a>
<a name="ln337">                }</a>
<a name="ln338"> </a>
<a name="ln339">                if ( pBNS-&gt;edge[j].flow ) {</a>
<a name="ln340">                    if ( (ret = AddToEdgeList( &amp;AllChargeEdges, j, INC_ADD_EDGE )) ) {</a>
<a name="ln341">                        goto exit_function;</a>
<a name="ln342">                    }</a>
<a name="ln343">                    if ( (ret = AddToEdgeList( &amp;NFlowerEdges, j, INC_ADD_EDGE )) ) {</a>
<a name="ln344">                        goto exit_function;</a>
<a name="ln345">                    }</a>
<a name="ln346">                } else {</a>
<a name="ln347">                    if ( (ret = AddToEdgeList( &amp;OtherNFlowerEdges, j, INC_ADD_EDGE )) ) {</a>
<a name="ln348">                        goto exit_function;</a>
<a name="ln349">                    }</a>
<a name="ln350">                }</a>
<a name="ln351">            } else</a>
<a name="ln352">            /* in addition, disallow N(V) creation by forbidding charge flower edge that has flow=1 */</a>
<a name="ln353">            if ( pVA[i].cNumValenceElectrons == 6 &amp;&amp; !pVA[i].cMetal &amp;&amp; /* N, P, As */</a>
<a name="ln354">                 NO_VERTEX != (j = GetChargeFlowerUpperEdge( pBNS, pVA, e ))) {</a>
<a name="ln355"> </a>
<a name="ln356">                if ( pBNS-&gt;edge[j].forbidden ) {</a>
<a name="ln357">                    continue;</a>
<a name="ln358">                }</a>
<a name="ln359"> </a>
<a name="ln360">                if ( pBNS-&gt;edge[j].flow ) {</a>
<a name="ln361">                    if ( (ret = AddToEdgeList( &amp;SFlowerEdges, j, INC_ADD_EDGE )) ) {</a>
<a name="ln362">                        goto exit_function;</a>
<a name="ln363">                    }</a>
<a name="ln364">                }</a>
<a name="ln365">            }</a>
<a name="ln366"> </a>
<a name="ln367">        }</a>
<a name="ln368">        for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln369">            k = at2[i].neighbor[j];</a>
<a name="ln370">            if ( k &lt; i &amp;&amp; !pBNS-&gt;edge[e=pBNS-&gt;vert[i].iedge[j]].forbidden ) {</a>
<a name="ln371">                if ( (ret = AddToEdgeList( &amp;AllBondEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln372">                    goto exit_function;</a>
<a name="ln373">                }</a>
<a name="ln374">            }</a>
<a name="ln375">        }</a>
<a name="ln376">    }</a>
<a name="ln377">    if ( forbidden_stereo_edge_mask ) {</a>
<a name="ln378">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln379">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln380">                if ( pBNS-&gt;edge[k = pBNS-&gt;vert[i].iedge[j]].forbidden == forbidden_stereo_edge_mask ) {</a>
<a name="ln381">                    int nMinRingSize = is_bond_in_Nmax_memb_ring( at2, i, j, pStruct-&gt;pbfsq-&gt;q,</a>
<a name="ln382">                                                             pStruct-&gt;pbfsq-&gt;nAtomLevel,</a>
<a name="ln383">                                                             pStruct-&gt;pbfsq-&gt;cSource, 99 /* max ring size */ );</a>
<a name="ln384">                    if ( 0 &lt; nMinRingSize &amp;&amp; (ret = AddToEdgeList( &amp;FixedLargeRingStereoEdges, k, INC_ADD_EDGE ))) {</a>
<a name="ln385">                        goto exit_function;</a>
<a name="ln386">                    }</a>
<a name="ln387">                }</a>
<a name="ln388">            }</a>
<a name="ln389">        }</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">    INCHI_HEAPCHK</a>
<a name="ln393">    if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln394">        goto exit_function;</a>
<a name="ln395">    }</a>
<a name="ln396">    INCHI_HEAPCHK</a>
<a name="ln397">    if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln398">        goto exit_function;</a>
<a name="ln399">    }</a>
<a name="ln400"> </a>
<a name="ln401">    INCHI_HEAPCHK</a>
<a name="ln402"> </a>
<a name="ln403">    if ( !pc2i-&gt;bHasDifference ||</a>
<a name="ln404">         (!pc2i-&gt;len_c2at &amp;&amp; pc2i-&gt;nNumTgRevrs == pc2i-&gt;nNumTgInChI &amp;&amp;</a>
<a name="ln405">         pc2i-&gt;nNumEndpRevrs == pc2i-&gt;nNumRemHInChI &amp;&amp;</a>
<a name="ln406">         pc2i-&gt;nNumEndpRevrs == pc2i-&gt;nNumEndpInChI &amp;&amp;</a>
<a name="ln407">         !pc2i-&gt;nNumTgDiffMinus &amp;&amp; !pc2i-&gt;nNumTgDiffH) ) {</a>
<a name="ln408">        goto exit_function; /* nothing to do */</a>
<a name="ln409">    }</a>
<a name="ln410"> </a>
<a name="ln411">    /*goto exit_function;*/ /* debug only*/</a>
<a name="ln412"> </a>
<a name="ln413">    if ( pc2i-&gt;len_c2at &gt;= 2 ) {</a>
<a name="ln414">        /*----------------------------------------------------*/</a>
<a name="ln415">        /* case 01: restored: O=AB-O(-)  original:  (-)O-AB=O */</a>
<a name="ln416">        /* FixH:              0    -1                 -1    0 */</a>
<a name="ln417">        /* MobH:              0     1                  1    0 */</a>
<a name="ln418">        /*                         non-taut      non-taut     */</a>
<a name="ln419">        /* O = O, S, Se; charged atoms O are not tautomeric   */</a>
<a name="ln420">        /* Solution: move (-) from B-O(-) to O=A              */</a>
<a name="ln421">        /*----------------------------------------------------*/</a>
<a name="ln422">        int num_DB_O = 0, num_SB_O_Minus = 0, iat;</a>
<a name="ln423">        short iat_DB_O[MAX_DIFF_FIXH], iat_SB_O_Minus[MAX_DIFF_FIXH];</a>
<a name="ln424">        cur_success = 0;</a>
<a name="ln425">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln426">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln427">            if ( pc2i-&gt;c2at[i].nValElectr == 6 /* &amp;&amp; !pc2i-&gt;c2at[i].endptInChI -- mod#1*/ &amp;&amp;</a>
<a name="ln428">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln429">                if ( /* orig. InChI info: */</a>
<a name="ln430">                     num_SB_O_Minus &lt; MAX_DIFF_FIXH &amp;&amp; </a>
<a name="ln431">                     pc2i-&gt;c2at[i].nFixHInChI ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln432">                     /* reversed structure info: */</a>
<a name="ln433">                     pc2i-&gt;c2at[i].nFixHRevrs == -1 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 1 &amp;&amp;</a>
<a name="ln434">                     pc2i-&gt;c2at[i].nAtChargeRevrs == -1 &amp;&amp; !at2[iat].num_H &amp;&amp; /* at2 is Fixed-H */</a>
<a name="ln435">                     at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 1 ) {</a>
<a name="ln436">                    iat_SB_O_Minus[num_SB_O_Minus ++] = iat;</a>
<a name="ln437">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln438">                        goto exit_function;</a>
<a name="ln439">                    }</a>
<a name="ln440">                } else</a>
<a name="ln441">                if ( /* orig. InChI info: */</a>
<a name="ln442">                     num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln443">                     pc2i-&gt;c2at[i].nFixHInChI == -1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;</a>
<a name="ln444">                     /* reversed structure info: */</a>
<a name="ln445">                     pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs ==  0 &amp;&amp;</a>
<a name="ln446">                     pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln447">                     at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 ) {</a>
<a name="ln448">                    iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln449">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln450">                        goto exit_function;</a>
<a name="ln451">                    }</a>
<a name="ln452">                }</a>
<a name="ln453">            }</a>
<a name="ln454">        }</a>
<a name="ln455">        if ( (num_try = inchi_min( num_SB_O_Minus, num_DB_O )) ) {</a>
<a name="ln456">            /* detected; attempt to fix */</a>
<a name="ln457">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln458">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln459">            delta = 1;</a>
<a name="ln460">            for ( i = 0; i &lt; num_SB_O_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln461">                iat = iat_SB_O_Minus[i];</a>
<a name="ln462">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln463">                if ( !pe-&gt;flow )</a>
<a name="ln464">                    continue;</a>
<a name="ln465">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln466">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln467"> </a>
<a name="ln468">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln469">                pe-&gt;flow -= delta; /* remove (-) from AB-O(-) */</a>
<a name="ln470">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln471">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln472">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln473"> </a>
<a name="ln474">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln475">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln476"> </a>
<a name="ln477">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln478">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln479">                    /* Added (-)charge to O=AB =&gt; nDeltaCharge == -1 */</a>
<a name="ln480">                    /* Flow change on pe (-)charge edge (atom B-O(-)) is not known to RunBnsTestOnce()) */</a>
<a name="ln481">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln482">                    if ( ret &gt; 0 ) {</a>
<a name="ln483">                        nNumRunBNS ++;</a>
<a name="ln484">                        cur_success ++; /* 01 */</a>
<a name="ln485">                    }</a>
<a name="ln486">                } else {</a>
<a name="ln487">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln488">                    pe-&gt;flow += delta;</a>
<a name="ln489">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln490">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln491">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln492">                }</a>
<a name="ln493">                INCHI_HEAPCHK</a>
<a name="ln494">            }</a>
<a name="ln495">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln496">            CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln497">        }</a>
<a name="ln498">        if ( cur_success ) {</a>
<a name="ln499">            tot_succes += cur_success;</a>
<a name="ln500">            /* recalculate InChI from the structure */</a>
<a name="ln501">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln502">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln503">                goto exit_function;</a>
<a name="ln504">            }</a>
<a name="ln505">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln506">                goto exit_function;</a>
<a name="ln507">            }</a>
<a name="ln508">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln509">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln510">            }</a>
<a name="ln511">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln512">                goto exit_function;</a>
<a name="ln513">            }</a>
<a name="ln514">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln515">                goto exit_function; /* nothing to do */</a>
<a name="ln516">            }</a>
<a name="ln517">        }</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    if ( pc2i-&gt;len_c2at &gt;= 1 ) {</a>
<a name="ln521">        /*--------------------------------------------------------------*/</a>
<a name="ln522">        /* case 02: restored: -O(+)=AB-NH2  original:  -O-AB=NH2(+)     */</a>
<a name="ln523">        /* FixH:               0        0               0      1        */</a>
<a name="ln524">        /* MobH:               0        2               0      1        */</a>
<a name="ln525">        /* O = P, As, Sb, O, S, Se, F, Cl, Br, I; not taut. in InChI    */</a>
<a name="ln526">        /* N = N, O, S, Se, Te; has H; tautomeric or not tautomeric     */</a>
<a name="ln527">        /* Solution: move (+) from O(+) to NH2                          */</a>
<a name="ln528">        /*--------------------------------------------------------------*/</a>
<a name="ln529">        int num_DB_O_Plus = 0, num_SB_NH = 0, iat;</a>
<a name="ln530">        short iat_DB_O_Plus[MAX_DIFF_FIXH], iat_SB_NH[MAX_DIFF_FIXH];</a>
<a name="ln531">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln532">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln533">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln534">        cur_success = 0;</a>
<a name="ln535">        num_zero_ret = 0;</a>
<a name="ln536">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln537">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln538">            if ( /* orig. InChI info: =NH2(+), =OH(+) */</a>
<a name="ln539">                 num_SB_NH &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln540">                 ((pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[i].nPeriodNum == 1) ||</a>
<a name="ln541">                  pc2i-&gt;c2at[i].nValElectr == 6 ) /* N, O, S, Se, Te */ &amp;&amp;</a>
<a name="ln542">                 /*!pc2i-&gt;c2at[i].endptInChI &amp;&amp;*/ /* &lt;=== relaxation */</a>
<a name="ln543">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln544">                 pc2i-&gt;c2at[i].nFixHInChI&gt;0 /*== 1 --modification#2*/ &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;*/</a>
<a name="ln545">                 /* reversed structure info: */</a>
<a name="ln546">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; /* pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;*/</a>
<a name="ln547">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln548">                 at2[iat].valence == at2[iat].chem_bonds_valence ) {</a>
<a name="ln549">                iat_SB_NH[num_SB_NH ++] = iat;</a>
<a name="ln550">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln551">                    goto exit_function;</a>
<a name="ln552">                }</a>
<a name="ln553">            }</a>
<a name="ln554">        }</a>
<a name="ln555">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln556">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln557">            if ( /* in restored atom: charge=+1, no H, has double bond, P, As, O, S, Se, Te, F, Cl, Br, I */</a>
<a name="ln558">                 num_DB_O_Plus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln559">                 at2[iat].charge == 1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln560">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln561">                 (pVA[iat].cNumValenceElectrons == 6 || pVA[iat].cNumValenceElectrons == 7 ||</a>
<a name="ln562">                  (pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber &gt; 1)) &amp;&amp;</a>
<a name="ln563">                 /* in orig.InChI: not an endpoint, has no H */</a>
<a name="ln564">                 !pStruct-&gt;endpoint[i] &amp;&amp; </a>
<a name="ln565">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln566">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln567">                 /* has (+) edge */</a>
<a name="ln568">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln569">                iat_DB_O_Plus[num_DB_O_Plus ++] = iat;</a>
<a name="ln570">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln571">                    goto exit_function;</a>
<a name="ln572">                }</a>
<a name="ln573">            }</a>
<a name="ln574">        }</a>
<a name="ln575">        if ( (num_try = inchi_min( num_DB_O_Plus, num_SB_NH )) ) {</a>
<a name="ln576">            /* detected; attempt to fix */</a>
<a name="ln577">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln578">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln579">            delta = 1;</a>
<a name="ln580">repeat_02_allow_NV:</a>
<a name="ln581">            for ( i = 0; i &lt; num_SB_NH &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln582">                iat = iat_SB_NH[i];</a>
<a name="ln583">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln584">                if ( !pe-&gt;flow )</a>
<a name="ln585">                    continue;</a>
<a name="ln586">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln587">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln588"> </a>
<a name="ln589">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln590">                pe-&gt;flow -= delta;</a>
<a name="ln591">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln592">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln593">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln594"> </a>
<a name="ln595">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln596">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln597">                </a>
<a name="ln598">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln599">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln600">                    /* Removed charge from O(+) =&gt; nDeltaCharge == -1 */</a>
<a name="ln601">                    /* Flow change on pe (+)charge edge (atom NH2) is not known to RunBnsTestOnce()) */</a>
<a name="ln602">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln603">                    if ( ret &gt; 0 ) {</a>
<a name="ln604">                        nNumRunBNS ++;</a>
<a name="ln605">                        cur_success ++; /* 02 */</a>
<a name="ln606">                    }</a>
<a name="ln607">                } else {</a>
<a name="ln608">                    num_zero_ret += !ret;</a>
<a name="ln609">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln610">                    pe-&gt;flow += delta;</a>
<a name="ln611">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln612">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln613">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln614">                }</a>
<a name="ln615">                INCHI_HEAPCHK</a>
<a name="ln616">            }</a>
<a name="ln617">            if ( num_zero_ret == num_try &amp;&amp; !bAllowedNFlowerEdges &amp;&amp; NFlowerEdges.num_edges ) {</a>
<a name="ln618">                RemoveForbiddenEdgeMask( pBNS, &amp;NFlowerEdges, forbidden_edge_mask  );</a>
<a name="ln619">                bAllowedNFlowerEdges = 1;</a>
<a name="ln620">                goto repeat_02_allow_NV;</a>
<a name="ln621">            }</a>
<a name="ln622">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln623">            bAllowedNFlowerEdges = 0;</a>
<a name="ln624">        }</a>
<a name="ln625">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln626">        if ( cur_success ) {</a>
<a name="ln627">            tot_succes += cur_success;</a>
<a name="ln628">            /* recalculate InChI from the structure */</a>
<a name="ln629">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln630">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln631">                goto exit_function;</a>
<a name="ln632">            }</a>
<a name="ln633">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln634">                goto exit_function;</a>
<a name="ln635">            }</a>
<a name="ln636">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln637">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln638">            }</a>
<a name="ln639">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln640">                goto exit_function;</a>
<a name="ln641">            }</a>
<a name="ln642">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln643">                goto exit_function; /* nothing to do */</a>
<a name="ln644">            }</a>
<a name="ln645">        }</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    if ( pc2i-&gt;len_c2at &gt;= 1 &amp;&amp; pc2i-&gt;nNumTgRevrs == 1 &amp;&amp;</a>
<a name="ln649">         (pc2i-&gt;nNumEndpRevrs &gt; pc2i-&gt;nNumEndpInChI || pc2i-&gt;nNumTgInChI &gt; 1) /* ADP in Revrs */ ) {</a>
<a name="ln650">        /*--------------------------------------------------------------*/</a>
<a name="ln651">        /* case 03: restored: -N(-)-AB=O    original:  -N=AB-O(-)       */</a>
<a name="ln652">        /* FixH:               0       0                0     -1        */</a>
<a name="ln653">        /* MobH:               0       0                0      1        */</a>
<a name="ln654">        /* O = O, S, Se; N = N;                                         */</a>
<a name="ln655">        /* restored atoms are tautomeric; original atoms are not taut.  */</a>
<a name="ln656">        /* restored struct has 1 t-group; original has less endpoints   */</a>
<a name="ln657">        /*                                and possibly &gt;1 t-groups      */  </a>
<a name="ln658">        /* Solution: move (-) from N(-) to =O                           */</a>
<a name="ln659">        /*           these atoms are tautomeric in restored structure   */</a>
<a name="ln660">        /*--------------------------------------------------------------*/</a>
<a name="ln661">        int num_SB_N_Minus = 0, num_DB_O = 0, iat;</a>
<a name="ln662">        short iat_SB_N_Minus[MAX_DIFF_FIXH], iat_DB_O[MAX_DIFF_FIXH];</a>
<a name="ln663">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln664">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln665">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln666">        /*</a>
<a name="ln667">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln668">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln669">        */</a>
<a name="ln670">        cur_success = 0;</a>
<a name="ln671">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln672">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln673">            if ( /* orig. InChI info: -O(-) */</a>
<a name="ln674">                 num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln675">                 pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln676">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln677">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln678">                 pc2i-&gt;c2at[i].nFixHInChI == -1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;</a>
<a name="ln679">                 /* reversed structure info: */</a>
<a name="ln680">                 pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln681">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;</a>
<a name="ln682">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln683">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 ) {</a>
<a name="ln684">                iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln685">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln686">                    goto exit_function;</a>
<a name="ln687">                }</a>
<a name="ln688">            }</a>
<a name="ln689">        }</a>
<a name="ln690">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln691">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln692">            if ( /* in restored atom N: charge=-1, no H, has no double bond, endpoint */</a>
<a name="ln693">                 num_SB_N_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln694">                 at2[iat].charge == -1 &amp;&amp; /*!at2[iat].num_H &amp;&amp;*/</a>
<a name="ln695">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln696">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln697">                 at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint &amp;&amp;</a>
<a name="ln698">                 /* in orig.InChI: not an endpoint, has no H */</a>
<a name="ln699">                 /* !pStruct-&gt;endpoint[i] &amp;&amp; */</a>
<a name="ln700">               /*  </a>
<a name="ln701">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln702">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln703">                */</a>
<a name="ln704">                 /* has (-) edge */</a>
<a name="ln705">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln706">                iat_SB_N_Minus[num_SB_N_Minus ++] = iat;</a>
<a name="ln707">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln708">                    goto exit_function;</a>
<a name="ln709">                }</a>
<a name="ln710">            }</a>
<a name="ln711">        }</a>
<a name="ln712">        if ( (num_try = inchi_min( num_SB_N_Minus, num_DB_O )) ) {</a>
<a name="ln713">            /* detected; attempt to fix */</a>
<a name="ln714">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln715">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln716">            delta = 1;</a>
<a name="ln717">            for ( i = 0; i &lt; num_SB_N_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln718">                iat = iat_SB_N_Minus[i];</a>
<a name="ln719">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1; /* 2006-03-03: changed from CPlusGroupEdge */</a>
<a name="ln720">                if ( !pe-&gt;flow )</a>
<a name="ln721">                    continue;</a>
<a name="ln722">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln723">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln724"> </a>
<a name="ln725">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln726">                pe-&gt;flow -= delta;</a>
<a name="ln727">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln728">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln729">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln730"> </a>
<a name="ln731">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln732">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln733"> </a>
<a name="ln734">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln735">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln736">                    /* Added (-) charge to =O =&gt; nDeltaCharge == 1 */</a>
<a name="ln737">                    /* Flow change on pe (-)charge edge (atom -N(-)-) is not known to RunBnsTestOnce()) */</a>
<a name="ln738">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln739">                    if ( ret &gt; 0 ) {</a>
<a name="ln740">                        nNumRunBNS ++;</a>
<a name="ln741">                        cur_success ++; /* 03 */</a>
<a name="ln742">                    }</a>
<a name="ln743">                } else {</a>
<a name="ln744">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln745">                    pe-&gt;flow += delta;</a>
<a name="ln746">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln747">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln748">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln749">                }</a>
<a name="ln750">                INCHI_HEAPCHK</a>
<a name="ln751">            }</a>
<a name="ln752">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln753">        }</a>
<a name="ln754">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln755">        if ( cur_success ) {</a>
<a name="ln756">            tot_succes += cur_success;</a>
<a name="ln757">            /* recalculate InChI from the structure */</a>
<a name="ln758">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln759">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln760">                goto exit_function;</a>
<a name="ln761">            }</a>
<a name="ln762">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln763">                goto exit_function;</a>
<a name="ln764">            }</a>
<a name="ln765">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln766">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln767">            }</a>
<a name="ln768">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln769">                goto exit_function;</a>
<a name="ln770">            }</a>
<a name="ln771">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln772">                goto exit_function; /* nothing to do */</a>
<a name="ln773">            }</a>
<a name="ln774">        }</a>
<a name="ln775">    }</a>
<a name="ln776">    </a>
<a name="ln777">    if ( pc2i-&gt;nNumTgRevrs == 1 &amp;&amp; /* pc2i-&gt;nNumRemHInChI &lt; 0 &amp;&amp;*/</a>
<a name="ln778">         (pc2i-&gt;nNumEndpRevrs &gt; pc2i-&gt;nNumEndpInChI || pc2i-&gt;nNumTgInChI &gt; 1) /* ADP in Revrs */ ) {</a>
<a name="ln779">        /*--------------------------------------------------------------*/</a>
<a name="ln780">        /* case 03a:restored: -N(-)-AB=O    original:  -N=AB-O(-)       */</a>
<a name="ln781">        /* FixH:               0       0                0      0        */</a>
<a name="ln782">        /* MobH:               0       0                0      0        */</a>
<a name="ln783">        /* O = O, S, Se; N = N;                              taut       */</a>
<a name="ln784">        /* restored atoms are tautomeric; original atom is; N may be.   */</a>
<a name="ln785">        /* restored struct has 1 t-group; original has less endpoints   */</a>
<a name="ln786">        /*                                and possibly &gt;1 t-groups      */  </a>
<a name="ln787">        /* Solution: move (-) from N(-) to =O                           */</a>
<a name="ln788">        /*           these atoms are tautomeric in restored structure   */</a>
<a name="ln789">        /*--------------------------------------------------------------*/</a>
<a name="ln790">        int num_SB_N_Minus = 0, num_DB_O = 0, iat;</a>
<a name="ln791">        short iat_SB_N_Minus[MAX_DIFF_FIXH], iat_DB_O[MAX_DIFF_FIXH];</a>
<a name="ln792">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln793">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln794">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln795">        S_CHAR   *pnMobHInChI = (pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H)? pInChI[1]-&gt;nNum_H :</a>
<a name="ln796">                                (pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H)? pInChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln797">        S_CHAR   *pnFixHInChI = pStruct-&gt;fixed_H;</a>
<a name="ln798"> </a>
<a name="ln799">        cur_success = 0;</a>
<a name="ln800">        CurrEdges.num_edges = 0;</a>
<a name="ln801">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln802">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln803">            if ( /* in restored atom N: charge=-1, no H, has no double bond, endpoint */</a>
<a name="ln804">                 num_SB_N_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln805">                 at2[iat].charge == -1 &amp;&amp; /*!at2[iat].num_H &amp;&amp;*/</a>
<a name="ln806">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln807">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln808">                 at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint &amp;&amp;</a>
<a name="ln809">                 /* in orig.InChI: may be an endpoint, has no H */</a>
<a name="ln810">                 /* has (-) edge */</a>
<a name="ln811">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln812">                iat_SB_N_Minus[num_SB_N_Minus ++] = iat;</a>
<a name="ln813">            } else</a>
<a name="ln814">            if ( num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln815">                 at2[iat].charge == 0 &amp;&amp; /*!at2[iat].num_H &amp;&amp;*/</a>
<a name="ln816">                 at2[iat].valence+1 == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln817">                 pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln818">                 at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint &amp;&amp; /* endpoint in Reconstructed */</a>
<a name="ln819">                 (pStruct-&gt;endpoint[i] || /* endpoint or H(+) acceptor in original */</a>
<a name="ln820">                  (pnMobHInChI &amp;&amp; pnMobHInChI[i] == 1 &amp;&amp; pnFixHInChI &amp;&amp; pnFixHInChI[i] == -1) ) &amp;&amp;</a>
<a name="ln821">                 /* has (-) edge */</a>
<a name="ln822">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln823">                iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln824">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln825">                    goto exit_function;</a>
<a name="ln826">                }</a>
<a name="ln827">            }    </a>
<a name="ln828">        }</a>
<a name="ln829">        if ( (num_try = inchi_min( num_SB_N_Minus, num_DB_O )) ) {</a>
<a name="ln830">            /* detected; attempt to fix */</a>
<a name="ln831">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln832">            /* allow charge transfer to all found =O */</a>
<a name="ln833">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln834">            delta = 1;</a>
<a name="ln835">            for ( i = 0; i &lt; num_SB_N_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln836">                iat = iat_SB_N_Minus[i];</a>
<a name="ln837">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln838">                if ( !pe-&gt;flow )</a>
<a name="ln839">                    continue;</a>
<a name="ln840">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln841">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln842"> </a>
<a name="ln843">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln844">                pe-&gt;flow -= delta;</a>
<a name="ln845">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln846">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln847">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln848"> </a>
<a name="ln849">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln850">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln851"> </a>
<a name="ln852">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln853">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln854">                    /* Added (-) charge to =O =&gt; nDeltaCharge == 1 */</a>
<a name="ln855">                    /* Flow change on pe (-)charge edge (atom -N(-)-) is not known to RunBnsTestOnce()) */</a>
<a name="ln856">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln857">                    if ( ret &gt; 0 ) {</a>
<a name="ln858">                        nNumRunBNS ++;</a>
<a name="ln859">                        cur_success ++; /* 03a */</a>
<a name="ln860">                    }</a>
<a name="ln861">                } else {</a>
<a name="ln862">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln863">                    pe-&gt;flow += delta;</a>
<a name="ln864">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln865">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln866">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln867">                }</a>
<a name="ln868">                INCHI_HEAPCHK</a>
<a name="ln869">            }</a>
<a name="ln870">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln871">        }</a>
<a name="ln872">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln873">        if ( cur_success ) {</a>
<a name="ln874">            tot_succes += cur_success;</a>
<a name="ln875">            /* recalculate InChI from the structure */</a>
<a name="ln876">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln877">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln878">                goto exit_function;</a>
<a name="ln879">            }</a>
<a name="ln880">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln881">                goto exit_function;</a>
<a name="ln882">            }</a>
<a name="ln883">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln884">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln885">            }</a>
<a name="ln886">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln887">                goto exit_function;</a>
<a name="ln888">            }</a>
<a name="ln889">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln890">                goto exit_function; /* nothing to do */</a>
<a name="ln891">            }</a>
<a name="ln892">        }</a>
<a name="ln893">    }</a>
<a name="ln894"> </a>
<a name="ln895">    if ( pc2i-&gt;len_c2at &gt;= 1 &amp;&amp; pc2i-&gt;nNumTgInChI == 1 &amp;&amp; /* ADP in InChI */</a>
<a name="ln896">         (pc2i-&gt;nNumEndpRevrs &lt; pc2i-&gt;nNumEndpInChI || pc2i-&gt;nNumTgRevrs &gt; 1) ) {</a>
<a name="ln897">        /*--------------------------------------------------------------*/</a>
<a name="ln898">        /* case 04: restored: OH(+)=AB-O- OH- orig.  HO-AB=O(+)- OH-    */</a>
<a name="ln899">        /* FixH:               1       0   0          1      0   1      */</a>
<a name="ln900">        /* MobH:               0       0   1          0      0   0      */</a>
<a name="ln901">        /*                 non-taut.                taut        taut    */</a>
<a name="ln902">        /*                                    ADP: one t-group or more endpoints */</a>
<a name="ln903">        /* O(+) = N, P, As, As, O, S, Se; OH = N, O, S, Se, Te          */</a>
<a name="ln904">        /* Solution: move (+) from O(+) to NH2                          */</a>
<a name="ln905">        /*--------------------------------------------------------------*/</a>
<a name="ln906">        int num_SB_Neutr = 0, num_DB_Charged = 0, iat;</a>
<a name="ln907">        short iat_SB_Neutr[MAX_DIFF_FIXH], iat_DB_Charged[MAX_DIFF_FIXH];</a>
<a name="ln908">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln909">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln910">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln911">        cur_success = 0;</a>
<a name="ln912">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln913">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln914">            if ( /* in restored atom: charge=+1, has H, has double bond, N, O, S, Se, Te */</a>
<a name="ln915">                 num_DB_Charged &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln916">                 at2[iat].charge == 1 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln917">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln918">                 (pVA[iat].cNumValenceElectrons == 6 ||</a>
<a name="ln919">                  (pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1)) &amp;&amp;</a>
<a name="ln920">                 /* in orig.InChI: an endpoint, has fixed-H */</a>
<a name="ln921">                 pStruct-&gt;endpoint[i] &amp;&amp; </a>
<a name="ln922">                 (pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln923">                 /*!(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;*/</a>
<a name="ln924">                 /* has (+) edge */</a>
<a name="ln925">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln926"> </a>
<a name="ln927">                iat_DB_Charged[num_DB_Charged ++] = iat;</a>
<a name="ln928">                </a>
<a name="ln929">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln930">                    goto exit_function;</a>
<a name="ln931">                }</a>
<a name="ln932">            } else</a>
<a name="ln933">            if ( /* in restored atom: charge=0, has no H, has no double bond, N, P, O, S, Se, Te */</a>
<a name="ln934">                 num_SB_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln935">                 at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln936">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln937">                 (pVA[iat].cNumValenceElectrons == 6 ||</a>
<a name="ln938">                  pVA[iat].cNumValenceElectrons == 5 ) &amp;&amp;</a>
<a name="ln939">                 /* in orig.InChI: an endpoint, has fixed-H */</a>
<a name="ln940">                 /* pStruct-&gt;endpoint[i] &amp;&amp; */</a>
<a name="ln941">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln942">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln943">                 /* has (+) edge */</a>
<a name="ln944">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln945">                 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln946"> </a>
<a name="ln947">                iat_SB_Neutr[num_SB_Neutr ++] = iat;</a>
<a name="ln948">                </a>
<a name="ln949">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln950">                    goto exit_function;</a>
<a name="ln951">                }</a>
<a name="ln952">            }</a>
<a name="ln953">        }</a>
<a name="ln954">        if ( (num_try = inchi_min( num_SB_Neutr, num_DB_Charged )) ) {</a>
<a name="ln955">            /* detected; attempt to fix */</a>
<a name="ln956">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln957">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln958">            delta = 1;</a>
<a name="ln959">            for ( i = 0; i &lt; num_SB_Neutr &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln960">                iat = iat_SB_Neutr[i];</a>
<a name="ln961">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln962">                if ( !pe-&gt;flow )</a>
<a name="ln963">                    continue;</a>
<a name="ln964">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln965">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln966"> </a>
<a name="ln967">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln968">                pe-&gt;flow -= delta;</a>
<a name="ln969">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln970">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln971">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln972"> </a>
<a name="ln973">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln974">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln975"> </a>
<a name="ln976">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln977">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln978">                    /* Removed charge from O(+) =&gt; nDeltaCharge == -1 */</a>
<a name="ln979">                    /* Flow change on pe (+)charge edge (atom NH2) is not known to RunBnsTestOnce()) */</a>
<a name="ln980">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln981">                    if ( ret &gt; 0 ) {</a>
<a name="ln982">                        nNumRunBNS ++;</a>
<a name="ln983">                        cur_success ++; /* 04 */</a>
<a name="ln984">                    }</a>
<a name="ln985">                } else {</a>
<a name="ln986">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln987">                    pe-&gt;flow += delta;</a>
<a name="ln988">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln989">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln990">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln991">                }</a>
<a name="ln992">                INCHI_HEAPCHK</a>
<a name="ln993">            }</a>
<a name="ln994">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln995">        }</a>
<a name="ln996">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln997">        if ( cur_success ) {</a>
<a name="ln998">            tot_succes += cur_success;</a>
<a name="ln999">            /* recalculate InChI from the structure */</a>
<a name="ln1000">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1001">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1002">                goto exit_function;</a>
<a name="ln1003">            }</a>
<a name="ln1004">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1005">                goto exit_function;</a>
<a name="ln1006">            }</a>
<a name="ln1007">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1008">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1009">            }</a>
<a name="ln1010">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1011">                goto exit_function;</a>
<a name="ln1012">            }</a>
<a name="ln1013">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1014">                goto exit_function; /* nothing to do */</a>
<a name="ln1015">            }</a>
<a name="ln1016">        }</a>
<a name="ln1017">    }</a>
<a name="ln1018"> </a>
<a name="ln1019">    if ( pc2i-&gt;len_c2at &gt; 1 ) {</a>
<a name="ln1020">        /*--------------------------------------------------------------*/</a>
<a name="ln1021">        /* case 05: restored:  O=AB-NH      original:(-)O-AB=NH(+)      */</a>
<a name="ln1022">        /* FixH:               0     0                 -1     1         */</a>
<a name="ln1023">        /* MobH:               0     1                  1     0         */</a>
<a name="ln1024">        /* O = O, S, Se; N = N, O, S, Se, Te; all atoms not tautomeric  */</a>
<a name="ln1025">        /* Solution: Separate charges                                   */</a>
<a name="ln1026">        /*--------------------------------------------------------------*/</a>
<a name="ln1027">        int num_DB_O = 0, num_SB_NH = 0, iat;</a>
<a name="ln1028">        short iat_DB_O[MAX_DIFF_FIXH], iat_SB_NH[MAX_DIFF_FIXH];</a>
<a name="ln1029">        cur_success = 0;</a>
<a name="ln1030">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln1031">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln1032">            if ( /* orig. InChI info: =NH2(+), =OH(+) */</a>
<a name="ln1033">                 num_SB_NH &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln1034">                 ((pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[i].nPeriodNum == 1) ||</a>
<a name="ln1035">                  pc2i-&gt;c2at[i].nValElectr == 6 ) /* N, O, S, Se, Te */ &amp;&amp;</a>
<a name="ln1036">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln1037">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln1038">                 pc2i-&gt;c2at[i].nFixHInChI == 1 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;*/</a>
<a name="ln1039">                 /* reversed structure info: */</a>
<a name="ln1040">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs &amp;&amp;</a>
<a name="ln1041">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln1042">                 !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln1043">                 at2[iat].valence == at2[iat].chem_bonds_valence ) {</a>
<a name="ln1044">                iat_SB_NH[num_SB_NH ++] = iat;</a>
<a name="ln1045">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1046">                    goto exit_function;</a>
<a name="ln1047">                }</a>
<a name="ln1048">            } else</a>
<a name="ln1049">            if ( /* orig. InChI info: -O(-) */</a>
<a name="ln1050">                 num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln1051">                 (pc2i-&gt;c2at[i].nValElectr == 6 ) /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln1052">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln1053">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln1054">                 pc2i-&gt;c2at[i].nFixHInChI == -1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;</a>
<a name="ln1055">                 /* reversed structure info: */</a>
<a name="ln1056">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;</a>
<a name="ln1057">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln1058">                 !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln1059">                 at2[iat].valence + 1 == at2[iat].chem_bonds_valence ) {</a>
<a name="ln1060">                iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln1061">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1062">                    goto exit_function;</a>
<a name="ln1063">                }</a>
<a name="ln1064">            }</a>
<a name="ln1065">        }</a>
<a name="ln1066">        if ( (num_try = inchi_min( num_DB_O, num_SB_NH )) ) {</a>
<a name="ln1067">            /* detected; attempt to fix */</a>
<a name="ln1068">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln1069">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln1070">            delta = 1;</a>
<a name="ln1071">            for ( i = 0; i &lt; num_SB_NH &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln1072">                iat = iat_SB_NH[i];</a>
<a name="ln1073">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln1074">                if ( !pe-&gt;flow )</a>
<a name="ln1075">                    continue;</a>
<a name="ln1076">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1077">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1078"> </a>
<a name="ln1079">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln1080">                pe-&gt;flow -= delta;</a>
<a name="ln1081">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln1082">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln1083">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1084"> </a>
<a name="ln1085">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1086">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1087"> </a>
<a name="ln1088">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln1089">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln1090">                    /* Added charge to =O =&gt; nDeltaCharge == 1 */</a>
<a name="ln1091">                    /* Flow change on pe (+)charge edge (atom NH2) is not known to RunBnsTestOnce()) */</a>
<a name="ln1092">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1093">                    if ( ret &gt; 0 ) {</a>
<a name="ln1094">                        nNumRunBNS ++;</a>
<a name="ln1095">                        cur_success ++; /* 05 */</a>
<a name="ln1096">                    }</a>
<a name="ln1097">                } else {</a>
<a name="ln1098">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln1099">                    pe-&gt;flow += delta;</a>
<a name="ln1100">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln1101">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln1102">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1103">                }</a>
<a name="ln1104">                INCHI_HEAPCHK</a>
<a name="ln1105">            }</a>
<a name="ln1106">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1107">        }</a>
<a name="ln1108">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1109">        if ( cur_success ) {</a>
<a name="ln1110">            tot_succes += cur_success;</a>
<a name="ln1111">            /* recalculate InChI from the structure */</a>
<a name="ln1112">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1113">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1114">                goto exit_function;</a>
<a name="ln1115">            }</a>
<a name="ln1116">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1117">                goto exit_function;</a>
<a name="ln1118">            }</a>
<a name="ln1119">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1120">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1121">            }</a>
<a name="ln1122">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1123">                goto exit_function;</a>
<a name="ln1124">            }</a>
<a name="ln1125">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1126">                goto exit_function; /* nothing to do */</a>
<a name="ln1127">            }</a>
<a name="ln1128">        }</a>
<a name="ln1129">    }</a>
<a name="ln1130"> </a>
<a name="ln1131">    if ( pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;endpoint &amp;&amp; pc2i-&gt;nChargeFixHInChI &gt; 0 &amp;&amp; pc2i-&gt;nChargeFixHInChI &gt; pc2i-&gt;nChargeMobHInChI ) {</a>
<a name="ln1132">        /*----------------------------------------------------------*/</a>
<a name="ln1133">        /* case 06c: restored -NH- or -NH(+)  orig: -NH-            */</a>
<a name="ln1134">        /*  Fixed-H            1       1             0              */</a>
<a name="ln1135">        /*  Mobile-H           0       0             1              */</a>
<a name="ln1136">        /*                     not tautomeric    not tautomeric     */</a>
<a name="ln1137">        /*           has adjacent (+)                               */</a>
<a name="ln1138">        /*           charges                                        */</a>
<a name="ln1139">        /*  Solution: move (+) charges to the -NH- unless it already*/</a>
<a name="ln1140">        /*            N = N, O, S, Se, Te                           */</a>
<a name="ln1141">        /*            has (+) charge blocked by adjacent (+)        */</a>
<a name="ln1142">        /*----------------------------------------------------------*/</a>
<a name="ln1143">        int iat;</a>
<a name="ln1144">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln1145">        /*</a>
<a name="ln1146">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln1147">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln1148">        inp_ATOM *atfMobile_H_Revrs = pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp;</a>
<a name="ln1149">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds?</a>
<a name="ln1150">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds : NULL;</a>
<a name="ln1151">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln1152">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln1153">        */</a>
<a name="ln1154">        EDGE_LIST CurChargeEdges;</a>
<a name="ln1155">        EdgeIndex e2;</a>
<a name="ln1156">        cur_success = 0;</a>
<a name="ln1157">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1158">        CurrEdges.num_edges = 0;</a>
<a name="ln1159">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln1160">            /* atoms -NH- from which H(+) were removed by the Normalization in orig. InChI */</a>
<a name="ln1161">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln1162">            if ( (pc2i-&gt;c2at[i].nValElectr == 6 ||</a>
<a name="ln1163">                  (pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[i].nPeriodNum == 1)) &amp;&amp;</a>
<a name="ln1164">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln1165">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln1166">                if ( /* orig. InChI info: -NH- */</a>
<a name="ln1167">                     pc2i-&gt;c2at[i].nFixHInChI == 1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln1168">                     /* reversed structure info: */</a>
<a name="ln1169">                     pc2i-&gt;c2at[i].nFixHRevrs == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 1 &amp;&amp; /* was not removed */</a>
<a name="ln1170">                     /*pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp;*/ at2[iat].num_H &amp;&amp; /* at2 is Fixed-H */</a>
<a name="ln1171">                     at2[iat].valence == at2[iat].chem_bonds_valence ) {</a>
<a name="ln1172">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1173">                        goto exit_function;</a>
<a name="ln1174">                    }</a>
<a name="ln1175">                }</a>
<a name="ln1176">            }</a>
<a name="ln1177">        }</a>
<a name="ln1178">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln1179">            /* find adjacent charged atoms */</a>
<a name="ln1180">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln1181">            if ( pStruct-&gt;endpoint[i] || at2[iat].charge != 1 || at2[iat].radical || pVA[iat].cMetal ) {</a>
<a name="ln1182">                continue;</a>
<a name="ln1183">            }</a>
<a name="ln1184">            if ( 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; !pBNS-&gt;edge[e].flow &amp;&amp; pVA[iat].cNumValenceElectrons &gt;= 5 ) {</a>
<a name="ln1185">                /* positively charged atom */</a>
<a name="ln1186">                for ( j = 0; j &lt; at2[iat].valence; j ++ ) {</a>
<a name="ln1187">                    if ( at2[k=(int)at2[iat].neighbor[j]].charge == 1 &amp;&amp; !pVA[k].cMetal &amp;&amp;</a>
<a name="ln1188">                         0 &lt;= (e2=pVA[k].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e2].forbidden &amp;&amp; !pBNS-&gt;edge[e2].flow) {</a>
<a name="ln1189">                        if ( 0 &gt; FindInEdgeList( &amp;CurrEdges, e ) &amp;&amp;</a>
<a name="ln1190">                             0 &gt; FindInEdgeList( &amp;CurChargeEdges, e ) &amp;&amp;</a>
<a name="ln1191">                             ( ret = AddToEdgeList( &amp;CurChargeEdges, e, INC_ADD_EDGE ) ) ) {</a>
<a name="ln1192">                            goto exit_case_06c;</a>
<a name="ln1193">                        }</a>
<a name="ln1194">                        if ( 0 &gt; FindInEdgeList( &amp;CurrEdges, e2 ) &amp;&amp;</a>
<a name="ln1195">                             0 &gt; FindInEdgeList( &amp;CurChargeEdges, e2 ) &amp;&amp;</a>
<a name="ln1196">                             ( ret = AddToEdgeList( &amp;CurChargeEdges, e2, INC_ADD_EDGE ) ) ) {</a>
<a name="ln1197">                            goto exit_case_06c;</a>
<a name="ln1198">                        }</a>
<a name="ln1199">                    }</a>
<a name="ln1200">                }</a>
<a name="ln1201">            }</a>
<a name="ln1202">        }</a>
<a name="ln1203">        if ( (num_try = inchi_min( CurrEdges.num_edges, CurChargeEdges.num_edges )) ) {</a>
<a name="ln1204">            /* detected; attempt to fix */</a>
<a name="ln1205">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln1206">            RemoveForbiddenEdgeMask( pBNS, &amp;CurChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1207">            delta = 1;</a>
<a name="ln1208">            for ( i = 0; i &lt; CurrEdges.num_edges &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln1209">                e = CurrEdges.pnEdges[i];</a>
<a name="ln1210">                pe   = pBNS-&gt;edge + e; /* (+)charge edge of -NH- or -OH */</a>
<a name="ln1211">                if ( !pe-&gt;flow )</a>
<a name="ln1212">                    continue;</a>
<a name="ln1213">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1214">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1215"> </a>
<a name="ln1216">                pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln1217">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln1218">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln1219">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1220"> </a>
<a name="ln1221">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1222">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1223"> </a>
<a name="ln1224">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln1225">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln1226">                    /* Removed (+)charge from -NH- =&gt; nDeltaCharge == -1 */</a>
<a name="ln1227">                    /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln1228">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1229">                    if ( ret &gt; 0 ) {</a>
<a name="ln1230">                        nNumRunBNS ++;</a>
<a name="ln1231">                        cur_success ++; /* 06c */</a>
<a name="ln1232">                    }</a>
<a name="ln1233">                } else {</a>
<a name="ln1234">                    pe-&gt;flow += delta;</a>
<a name="ln1235">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln1236">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln1237">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1238">                }</a>
<a name="ln1239">                INCHI_HEAPCHK</a>
<a name="ln1240">            }</a>
<a name="ln1241">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1242">        }</a>
<a name="ln1243">exit_case_06c:</a>
<a name="ln1244">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1245">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln1246">        if ( ret &lt; 0 ) {</a>
<a name="ln1247">            goto exit_function;</a>
<a name="ln1248">        }</a>
<a name="ln1249">        if ( cur_success ) {</a>
<a name="ln1250">            tot_succes += cur_success;</a>
<a name="ln1251">            /* recalculate InChI from the structure */</a>
<a name="ln1252">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1253">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1254">                goto exit_function;</a>
<a name="ln1255">            }</a>
<a name="ln1256">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1257">                goto exit_function;</a>
<a name="ln1258">            }</a>
<a name="ln1259">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1260">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1261">            }</a>
<a name="ln1262">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1263">                goto exit_function;</a>
<a name="ln1264">            }</a>
<a name="ln1265">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1266">                goto exit_function; /* nothing to do */</a>
<a name="ln1267">            }</a>
<a name="ln1268">        }</a>
<a name="ln1269">    }</a>
<a name="ln1270"> </a>
<a name="ln1271">    if ( pc2i-&gt;len_c2at &gt;= 2 ) {</a>
<a name="ln1272">        /*------------------------------------------------------------*/</a>
<a name="ln1273">        /* case 06d: restored: XH(+)=-AB-NH    orig.: XH-=AB=NH(+)    */</a>
<a name="ln1274">        /* FixH:                1       1 0          0 1      1       */</a>
<a name="ln1275">        /* MobH:                0    taut 1          1 taut   0       */</a>
<a name="ln1276">        /*                                                            */</a>
<a name="ln1277">        /*                                                            */</a>
<a name="ln1278">        /* N  = N, O, S, Se; atoms N are not tautomeric in orig InChI */</a>
<a name="ln1279">        /* X  = N, O, S, Se, Te, F, Cl, Br, I; atom X is non-taut     */</a>
<a name="ln1280">        /* Solution: move (+) from X  to NH                           */</a>
<a name="ln1281">        /*------------------------------------------------------------*/</a>
<a name="ln1282">        int iat;</a>
<a name="ln1283">        /*</a>
<a name="ln1284">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln1285">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln1286">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln1287">        inp_ATOM *atfMobile_H_Revrs = pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp;</a>
<a name="ln1288">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds?</a>
<a name="ln1289">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds : </a>
<a name="ln1290">                                      pStruct-&gt;pOne_norm_data[TAUT_NON]-&gt;at;</a>
<a name="ln1291">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln1292">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln1293">        */</a>
<a name="ln1294">        EDGE_LIST CurChargeEdges;</a>
<a name="ln1295">        cur_success = 0;</a>
<a name="ln1296">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1297">        CurrEdges.num_edges = 0;</a>
<a name="ln1298">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln1299">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln1300">            /* XH(+) */</a>
<a name="ln1301">            if ( /* reconstructed: non-taut and (+) */</a>
<a name="ln1302">                 (pc2i-&gt;c2at[i].nMobHRevrs+1 == pc2i-&gt;c2at[i].nFixHRevrs &amp;&amp;</a>
<a name="ln1303">                 pc2i-&gt;c2at[i].nFixHRevrs &gt; 0 &amp;&amp; !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln1304">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 1 &amp;&amp;</a>
<a name="ln1305">                 /* original InChI: non-taut &amp; has H or an endpoint, has Fixed H */</a>
<a name="ln1306">                 ((!pc2i-&gt;c2at[i].nFixHInChI &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == pc2i-&gt;c2at[i].nFixHRevrs) ||</a>
<a name="ln1307">                 (pc2i-&gt;c2at[i].nFixHInChI == pc2i-&gt;c2at[i].nFixHRevrs &amp;&amp; pc2i-&gt;c2at[i].endptInChI) ))  &amp;&amp;</a>
<a name="ln1308">                 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; !pBNS-&gt;edge[e].flow) {</a>
<a name="ln1309"> </a>
<a name="ln1310">                if ( (ret = AddToEdgeList( &amp;CurChargeEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1311">                    goto exit_case_06d;</a>
<a name="ln1312">                }</a>
<a name="ln1313">            } else</a>
<a name="ln1314">            /* -NH- */</a>
<a name="ln1315">            if ( /* original InChI: has H and is not an endpoint */</a>
<a name="ln1316">                (pc2i-&gt;c2at[i].nMobHInChI+1 == pc2i-&gt;c2at[i].nFixHInChI &amp;&amp; </a>
<a name="ln1317">                 pc2i-&gt;c2at[i].nFixHInChI &gt; 0 &amp;&amp; !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln1318">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp;</a>
<a name="ln1319">                 /* reconstructed InChI: non-taut &amp; has H or an endpoint, has Fixed H */</a>
<a name="ln1320">                 ((!pc2i-&gt;c2at[i].nFixHRevrs &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == pc2i-&gt;c2at[i].nFixHInChI) ||</a>
<a name="ln1321">                 (pc2i-&gt;c2at[i].nFixHRevrs == pc2i-&gt;c2at[i].nFixHInChI &amp;&amp; pc2i-&gt;c2at[i].endptRevrs) ))  &amp;&amp;</a>
<a name="ln1322">                 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; </a>
<a name="ln1323">                 pBNS-&gt;edge[e].flow) {</a>
<a name="ln1324"> </a>
<a name="ln1325">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1326">                    goto exit_case_06d;</a>
<a name="ln1327">                }</a>
<a name="ln1328">            }</a>
<a name="ln1329">        }</a>
<a name="ln1330">        if ( (num_try = inchi_min( CurrEdges.num_edges, CurChargeEdges.num_edges )) ) {</a>
<a name="ln1331">            /* detected; attempt to fix */</a>
<a name="ln1332">            int bSFlowerEdgesMayBeForbidden = (SFlowerEdges.num_edges &gt; 0);</a>
<a name="ln1333">            int bSFlowerEdgesIsForbidden;</a>
<a name="ln1334">            for ( bSFlowerEdgesIsForbidden = bSFlowerEdgesMayBeForbidden;</a>
<a name="ln1335">                     0 &lt;= bSFlowerEdgesIsForbidden; bSFlowerEdgesIsForbidden -- ) {</a>
<a name="ln1336">                if ( bSFlowerEdgesIsForbidden ) {</a>
<a name="ln1337">                    /* on the 1st pass disallow -S(+)= =&gt; =S=, allow only -S(+)= =&gt; -S- */</a>
<a name="ln1338">                    SetForbiddenEdgeMask( pBNS, &amp;SFlowerEdges, forbidden_edge_mask );</a>
<a name="ln1339">                }</a>
<a name="ln1340">                SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln1341">                RemoveForbiddenEdgeMask( pBNS, &amp;CurChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1342">                delta = 1;</a>
<a name="ln1343">                for ( i = 0; i &lt; CurrEdges.num_edges &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln1344">                    e = CurrEdges.pnEdges[i];</a>
<a name="ln1345">                    pe   = pBNS-&gt;edge + e; /* (+)charge edge of -NH- or -OH */</a>
<a name="ln1346">                    if ( !pe-&gt;flow )</a>
<a name="ln1347">                        continue;</a>
<a name="ln1348">                    pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1349">                    pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1350"> </a>
<a name="ln1351">                    pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln1352">                    pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln1353">                    pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln1354">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1355"> </a>
<a name="ln1356">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1357">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1358"> </a>
<a name="ln1359">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln1360">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln1361">                        /* Removed (+)charge from -NH- =&gt; nDeltaCharge == -1 */</a>
<a name="ln1362">                        /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln1363">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1364">                        if ( ret &gt; 0 ) {</a>
<a name="ln1365">                            nNumRunBNS ++;</a>
<a name="ln1366">                            cur_success ++; /* 06d */</a>
<a name="ln1367">                        }</a>
<a name="ln1368">                    } else {</a>
<a name="ln1369">                        pe-&gt;flow += delta;</a>
<a name="ln1370">                        pv1-&gt;st_edge.flow += delta;</a>
<a name="ln1371">                        pv2-&gt;st_edge.flow += delta;</a>
<a name="ln1372">                        pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1373">                    }</a>
<a name="ln1374">                    INCHI_HEAPCHK</a>
<a name="ln1375">                }</a>
<a name="ln1376">                RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1377">                RemoveForbiddenEdgeMask( pBNS, &amp;SFlowerEdges, forbidden_edge_mask );</a>
<a name="ln1378">            }</a>
<a name="ln1379"> </a>
<a name="ln1380">        }</a>
<a name="ln1381">exit_case_06d:</a>
<a name="ln1382">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1383">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln1384">        if ( cur_success ) {</a>
<a name="ln1385">            tot_succes += cur_success;</a>
<a name="ln1386">            /* recalculate InChI from the structure */</a>
<a name="ln1387">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1388">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1389">                goto exit_function;</a>
<a name="ln1390">            }</a>
<a name="ln1391">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1392">                goto exit_function;</a>
<a name="ln1393">            }</a>
<a name="ln1394">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1395">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1396">            }</a>
<a name="ln1397">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1398">                goto exit_function;</a>
<a name="ln1399">            }</a>
<a name="ln1400">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1401">                goto exit_function; /* nothing to do */</a>
<a name="ln1402">            }</a>
<a name="ln1403">        }</a>
<a name="ln1404">    }</a>
<a name="ln1405"> </a>
<a name="ln1406"> </a>
<a name="ln1407">    if ( pc2i-&gt;len_c2at &gt;= 2 ) {</a>
<a name="ln1408">        /*--------------------------------------------------------*/</a>
<a name="ln1409">        /* case 06: restored: NHn(+)=AB-NHm  orig.: NHn-AB=NHm(+) */</a>
<a name="ln1410">        /* FixH:               1        0            0     1      */</a>
<a name="ln1411">        /* MobH:              n-1       m            n    m-1     */</a>
<a name="ln1412">        /* N = N, O, S, Se; atoms N are not tautomeric            */</a>
<a name="ln1413">        /* Solution: move (+) from NHn(+) to NHn                  */</a>
<a name="ln1414">        /*--------------------------------------------------------*/</a>
<a name="ln1415">        int num_DB_NHn_Plus = 0, num_SB_NHm_Neutr = 0, iat;</a>
<a name="ln1416">        short iat_DB_NHn_Plus[MAX_DIFF_FIXH], iat_SB_NHm_Neutr[MAX_DIFF_FIXH];</a>
<a name="ln1417">        cur_success = 0;</a>
<a name="ln1418">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln1419">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln1420">            if ( (pc2i-&gt;c2at[i].nValElectr == 6 ||</a>
<a name="ln1421">                  (pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[i].nPeriodNum == 1)) &amp;&amp;</a>
<a name="ln1422">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln1423">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln1424">                if ( /* orig. InChI info: NHm */</a>
<a name="ln1425">                     num_SB_NHm_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln1426">                     pc2i-&gt;c2at[i].nFixHInChI == 1 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;*/</a>
<a name="ln1427">                     /* reversed structure info: */</a>
<a name="ln1428">                     pc2i-&gt;c2at[i].nFixHRevrs == 0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHRevrs == 1 &amp;&amp;*/</a>
<a name="ln1429">                     pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; at2[iat].num_H &amp;&amp; /* at2 is Fixed-H */</a>
<a name="ln1430">                     at2[iat].valence == at2[iat].chem_bonds_valence ) {</a>
<a name="ln1431">                    iat_SB_NHm_Neutr[num_SB_NHm_Neutr ++] = iat;</a>
<a name="ln1432">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1433">                        goto exit_function;</a>
<a name="ln1434">                    }</a>
<a name="ln1435">                } else</a>
<a name="ln1436">                if ( /* orig. InChI info: */</a>
<a name="ln1437">                     num_DB_NHn_Plus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln1438">                     pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI &amp;&amp;*/</a>
<a name="ln1439">                     /* reversed structure info: */</a>
<a name="ln1440">                     pc2i-&gt;c2at[i].nFixHRevrs ==  1 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHRevrs ==  0 &amp;&amp;*/</a>
<a name="ln1441">                     pc2i-&gt;c2at[i].nAtChargeRevrs == 1 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln1442">                     at2[iat].valence &lt; at2[iat].chem_bonds_valence ) {</a>
<a name="ln1443">                    iat_DB_NHn_Plus[num_DB_NHn_Plus ++] = iat;</a>
<a name="ln1444">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1445">                        goto exit_function;</a>
<a name="ln1446">                    }</a>
<a name="ln1447">                }</a>
<a name="ln1448">            }</a>
<a name="ln1449">        }</a>
<a name="ln1450">        if ( (num_try = inchi_min( num_SB_NHm_Neutr, num_DB_NHn_Plus )) ) {</a>
<a name="ln1451">            /* detected; attempt to fix */</a>
<a name="ln1452">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln1453">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln1454">            delta = 1;</a>
<a name="ln1455">            for ( i = 0; i &lt; num_SB_NHm_Neutr &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln1456">                iat = iat_SB_NHm_Neutr[i];</a>
<a name="ln1457">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln1458">                if ( !pe-&gt;flow )</a>
<a name="ln1459">                    continue;</a>
<a name="ln1460">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1461">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1462"> </a>
<a name="ln1463">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln1464">                pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln1465">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln1466">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln1467">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1468"> </a>
<a name="ln1469">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1470">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1471"> </a>
<a name="ln1472">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln1473">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln1474">                    /* Removed (+)charge from -NHn =&gt; nDeltaCharge == -1 */</a>
<a name="ln1475">                    /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln1476">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1477">                    if ( ret &gt; 0 ) {</a>
<a name="ln1478">                        nNumRunBNS ++;</a>
<a name="ln1479">                        cur_success ++; /* 06 */</a>
<a name="ln1480">                    }</a>
<a name="ln1481">                } else {</a>
<a name="ln1482">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln1483">                    pe-&gt;flow += delta;</a>
<a name="ln1484">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln1485">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln1486">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1487">                }</a>
<a name="ln1488">                INCHI_HEAPCHK</a>
<a name="ln1489">            }</a>
<a name="ln1490">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1491">        }</a>
<a name="ln1492">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1493">        if ( cur_success ) {</a>
<a name="ln1494">            tot_succes += cur_success;</a>
<a name="ln1495">            /* recalculate InChI from the structure */</a>
<a name="ln1496">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1497">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1498">                goto exit_function;</a>
<a name="ln1499">            }</a>
<a name="ln1500">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1501">                goto exit_function;</a>
<a name="ln1502">            }</a>
<a name="ln1503">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1504">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1505">            }</a>
<a name="ln1506">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1507">                goto exit_function;</a>
<a name="ln1508">            }</a>
<a name="ln1509">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1510">                goto exit_function; /* nothing to do */</a>
<a name="ln1511">            }</a>
<a name="ln1512">        }</a>
<a name="ln1513">    }</a>
<a name="ln1514"> </a>
<a name="ln1515">    if ( ((pc2i-&gt;nNumTgInChI &gt; pc2i-&gt;nNumTgRevrs &amp;&amp; pc2i-&gt;nNumTgRevrs == 1) ||</a>
<a name="ln1516">          pc2i-&gt;nNumEndpInChI &lt; pc2i-&gt;nNumEndpRevrs ) &amp;&amp;</a>
<a name="ln1517">          pStruct-&gt;nNumRemovedProtonsMobHInChI == pStruct-&gt;One_ti.tni.nNumRemovedProtons &amp;&amp;</a>
<a name="ln1518">          pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds ) {</a>
<a name="ln1519">        /*----------------------------------------------------------*/</a>
<a name="ln1520">        /* case 06a: restored: N'(+)=-AB-NH    orig.: N'-=AB=NH(+)  */</a>
<a name="ln1521">        /* FixH:               0         1            0      1      */</a>
<a name="ln1522">        /* MobH:               0         0            0      0      */</a>
<a name="ln1523">        /*                    single t-group      multiple t-groups */</a>
<a name="ln1524">        /* N  = N, O, S, Se; atoms N are not tautomeric             */</a>
<a name="ln1525">        /* N' = N            atom N' is not tautomeric              */</a>
<a name="ln1526">        /* Solution: move (+) from N' to NH                         */</a>
<a name="ln1527">        /*----------------------------------------------------------*/</a>
<a name="ln1528">        int iat;</a>
<a name="ln1529">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln1530">        /*</a>
<a name="ln1531">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln1532">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln1533">        */</a>
<a name="ln1534">        inp_ATOM *atfMobile_H_Revrs = pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp;</a>
<a name="ln1535">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds?</a>
<a name="ln1536">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds : NULL;</a>
<a name="ln1537">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln1538">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln1539">        EDGE_LIST CurChargeEdges;</a>
<a name="ln1540">        cur_success = 0;</a>
<a name="ln1541">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1542">        CurrEdges.num_edges = 0;</a>
<a name="ln1543">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln1544">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln1545">            if ( pStruct-&gt;endpoint[i] ) {</a>
<a name="ln1546">                continue;</a>
<a name="ln1547">            }</a>
<a name="ln1548">            /* -NH-, -OH */</a>
<a name="ln1549">            if ( pStruct-&gt;fixed_H[i] &amp;&amp; !nMobHInChI[i] &amp;&amp;</a>
<a name="ln1550">                 at2[iat].charge == 0 &amp;&amp; at2[iat].radical == 0 &amp;&amp;</a>
<a name="ln1551">                 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln1552">                 (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ))) {</a>
<a name="ln1553">                goto exit_case_06a;</a>
<a name="ln1554">            } else</a>
<a name="ln1555">            /* &gt;N(+)= */</a>
<a name="ln1556">            if ( at2[iat].charge == 1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln1557">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln1558">                 atfMobile_H_Revrs &amp;&amp; atfMobile_H_Revrs[iat].charge == 0 &amp;&amp;</a>
<a name="ln1559">                 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; !pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln1560">                 (ret = AddToEdgeList( &amp;CurChargeEdges, e, INC_ADD_EDGE ))) {</a>
<a name="ln1561">                goto exit_case_06a;</a>
<a name="ln1562">            }</a>
<a name="ln1563">        }</a>
<a name="ln1564">        if ( (num_try = inchi_min( CurrEdges.num_edges, CurChargeEdges.num_edges )) ) {</a>
<a name="ln1565">            /* detected; attempt to fix */</a>
<a name="ln1566">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln1567">            RemoveForbiddenEdgeMask( pBNS, &amp;CurChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1568">            delta = 1;</a>
<a name="ln1569">            for ( i = 0; i &lt; CurrEdges.num_edges &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln1570">                e = CurrEdges.pnEdges[i];</a>
<a name="ln1571">                pe   = pBNS-&gt;edge + e; /* (+)charge edge of -NH- or -OH */</a>
<a name="ln1572">                if ( !pe-&gt;flow )</a>
<a name="ln1573">                    continue;</a>
<a name="ln1574">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1575">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1576"> </a>
<a name="ln1577">                pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln1578">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln1579">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln1580">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1581"> </a>
<a name="ln1582">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1583">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1584"> </a>
<a name="ln1585">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln1586">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln1587">                    /* Removed (+)charge from -NH- =&gt; nDeltaCharge == -1 */</a>
<a name="ln1588">                    /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln1589">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1590">                    if ( ret &gt; 0 ) {</a>
<a name="ln1591">                        nNumRunBNS ++;</a>
<a name="ln1592">                        cur_success ++; /* 06a */</a>
<a name="ln1593">                    }</a>
<a name="ln1594">                } else {</a>
<a name="ln1595">                    pe-&gt;flow += delta;</a>
<a name="ln1596">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln1597">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln1598">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1599">                }</a>
<a name="ln1600">                INCHI_HEAPCHK</a>
<a name="ln1601">            }</a>
<a name="ln1602">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1603">        }</a>
<a name="ln1604">exit_case_06a:</a>
<a name="ln1605">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1606">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln1607">        if ( cur_success ) {</a>
<a name="ln1608">            tot_succes += cur_success;</a>
<a name="ln1609">            /* recalculate InChI from the structure */</a>
<a name="ln1610">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1611">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1612">                goto exit_function;</a>
<a name="ln1613">            }</a>
<a name="ln1614">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1615">                goto exit_function;</a>
<a name="ln1616">            }</a>
<a name="ln1617">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1618">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1619">            }</a>
<a name="ln1620">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1621">                goto exit_function;</a>
<a name="ln1622">            }</a>
<a name="ln1623">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1624">                goto exit_function; /* nothing to do */</a>
<a name="ln1625">            }</a>
<a name="ln1626">        }</a>
<a name="ln1627">    }</a>
<a name="ln1628">    if ( ((pc2i-&gt;nNumTgInChI &gt; pc2i-&gt;nNumTgRevrs &amp;&amp; pc2i-&gt;nNumTgRevrs == 1) ||</a>
<a name="ln1629">          pc2i-&gt;nNumEndpInChI &lt; pc2i-&gt;nNumEndpRevrs ) &amp;&amp;</a>
<a name="ln1630">          (pStruct-&gt;nNumRemovedProtonsMobHInChI == pStruct-&gt;One_ti.tni.nNumRemovedProtons ||</a>
<a name="ln1631">           pStruct-&gt;nNumRemovedProtonsMobHInChI &gt; pStruct-&gt;One_ti.tni.nNumRemovedProtons ) &amp;&amp;</a>
<a name="ln1632">          pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds ) {</a>
<a name="ln1633">        /*----------------------------------------------------------*/</a>
<a name="ln1634">        /* case 06b: restored: X(+)=-AB-NH    orig.: X-=AB=NH(+)    */</a>
<a name="ln1635">        /* FixH:               0        1 1          0      1       */</a>
<a name="ln1636">        /* MobH:               0        0 t          0      0       */</a>
<a name="ln1637">        /*                    single t-group      multiple t-groups */</a>
<a name="ln1638">        /*                                        or no t-groupd    */</a>
<a name="ln1639">        /* N  = N, O, S, Se; atoms N are not tautomeric             */</a>
<a name="ln1640">        /* X  = O, S, Se, Te, F, Cl, Br, I; atom X is not tautomeric*/</a>
<a name="ln1641">        /* Solution: move (+) from X  to NH                         */</a>
<a name="ln1642">        /*----------------------------------------------------------*/</a>
<a name="ln1643">        int iat;</a>
<a name="ln1644">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln1645">        /*</a>
<a name="ln1646">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln1647">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln1648">        */</a>
<a name="ln1649">        inp_ATOM *atfMobile_H_Revrs = pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp;</a>
<a name="ln1650">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds?</a>
<a name="ln1651">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds : NULL;</a>
<a name="ln1652">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln1653">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln1654">        EDGE_LIST CurChargeEdges;</a>
<a name="ln1655">        cur_success = 0;</a>
<a name="ln1656">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1657">        CurrEdges.num_edges = 0;</a>
<a name="ln1658">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln1659">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln1660">            if ( pStruct-&gt;endpoint[i] ) {</a>
<a name="ln1661">                continue;</a>
<a name="ln1662">            }</a>
<a name="ln1663">            /* -NH-, -OH */</a>
<a name="ln1664">            if ( pStruct-&gt;fixed_H[i] &amp;&amp; !nMobHInChI[i] &amp;&amp;</a>
<a name="ln1665">                 at2[iat].charge == 0 &amp;&amp; at2[iat].radical == 0 &amp;&amp;</a>
<a name="ln1666">                 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln1667">                 (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ))) {</a>
<a name="ln1668">                goto exit_case_06b;</a>
<a name="ln1669">            } else</a>
<a name="ln1670">            /* X(+)= */</a>
<a name="ln1671">            if ( at2[iat].charge == 1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln1672">                 (pVA[iat].cNumValenceElectrons == 6 || pVA[iat].cPeriodicRowNumber == 7) &amp;&amp;</a>
<a name="ln1673">                 atfMobile_H_Revrs &amp;&amp; atfMobile_H_Revrs[iat].charge == 1 &amp;&amp;</a>
<a name="ln1674">                 0 &lt;= (e=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; !pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln1675">                 (ret = AddToEdgeList( &amp;CurChargeEdges, e, INC_ADD_EDGE ))) {</a>
<a name="ln1676">                goto exit_case_06b;</a>
<a name="ln1677">            }</a>
<a name="ln1678">        }</a>
<a name="ln1679">        if ( (num_try = inchi_min( CurrEdges.num_edges, CurChargeEdges.num_edges )) ) {</a>
<a name="ln1680">            /* detected; attempt to fix */</a>
<a name="ln1681">            int bSFlowerEdgesMayBeForbidden = (SFlowerEdges.num_edges &gt; 0);</a>
<a name="ln1682">            int bSFlowerEdgesIsForbidden;</a>
<a name="ln1683">            for ( bSFlowerEdgesIsForbidden = bSFlowerEdgesMayBeForbidden;</a>
<a name="ln1684">                     0 &lt;= bSFlowerEdgesIsForbidden; bSFlowerEdgesIsForbidden -- ) {</a>
<a name="ln1685">                if ( bSFlowerEdgesIsForbidden ) {</a>
<a name="ln1686">                    /* on the 1st pass disallow -S(+)= =&gt; =S=, allow only -S(+)= =&gt; -S- */</a>
<a name="ln1687">                    SetForbiddenEdgeMask( pBNS, &amp;SFlowerEdges, forbidden_edge_mask );</a>
<a name="ln1688">                }</a>
<a name="ln1689">                SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln1690">                RemoveForbiddenEdgeMask( pBNS, &amp;CurChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1691">                delta = 1;</a>
<a name="ln1692">                for ( i = 0; i &lt; CurrEdges.num_edges &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln1693">                    e = CurrEdges.pnEdges[i];</a>
<a name="ln1694">                    pe   = pBNS-&gt;edge + e; /* (+)charge edge of -NH- or -OH */</a>
<a name="ln1695">                    if ( !pe-&gt;flow )</a>
<a name="ln1696">                        continue;</a>
<a name="ln1697">                    pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1698">                    pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1699"> </a>
<a name="ln1700">                    pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln1701">                    pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln1702">                    pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln1703">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1704"> </a>
<a name="ln1705">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1706">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1707"> </a>
<a name="ln1708">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln1709">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln1710">                        /* Removed (+)charge from -NH- =&gt; nDeltaCharge == -1 */</a>
<a name="ln1711">                        /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln1712">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1713">                        if ( ret &gt; 0 ) {</a>
<a name="ln1714">                            nNumRunBNS ++;</a>
<a name="ln1715">                            cur_success ++; /* 06b */</a>
<a name="ln1716">                        }</a>
<a name="ln1717">                    } else {</a>
<a name="ln1718">                        pe-&gt;flow += delta;</a>
<a name="ln1719">                        pv1-&gt;st_edge.flow += delta;</a>
<a name="ln1720">                        pv2-&gt;st_edge.flow += delta;</a>
<a name="ln1721">                        pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1722">                    }</a>
<a name="ln1723">                    INCHI_HEAPCHK</a>
<a name="ln1724">                }</a>
<a name="ln1725">                RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1726">                RemoveForbiddenEdgeMask( pBNS, &amp;SFlowerEdges, forbidden_edge_mask );</a>
<a name="ln1727">            }</a>
<a name="ln1728"> </a>
<a name="ln1729">        }</a>
<a name="ln1730">exit_case_06b:</a>
<a name="ln1731">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1732">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln1733">        if ( cur_success ) {</a>
<a name="ln1734">            tot_succes += cur_success;</a>
<a name="ln1735">            /* recalculate InChI from the structure */</a>
<a name="ln1736">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1737">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1738">                goto exit_function;</a>
<a name="ln1739">            }</a>
<a name="ln1740">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1741">                goto exit_function;</a>
<a name="ln1742">            }</a>
<a name="ln1743">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1744">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1745">            }</a>
<a name="ln1746">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1747">                goto exit_function;</a>
<a name="ln1748">            }</a>
<a name="ln1749">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1750">                goto exit_function; /* nothing to do */</a>
<a name="ln1751">            }</a>
<a name="ln1752">        }</a>
<a name="ln1753">    }</a>
<a name="ln1754"> </a>
<a name="ln1755"> </a>
<a name="ln1756"> </a>
<a name="ln1757">    if ( pc2i-&gt;nNumTgInChI &gt; 1 &amp;&amp;</a>
<a name="ln1758">          (pStruct-&gt;nNumRemovedProtonsMobHInChI &gt; 0 || pStruct-&gt;ti.tni.nNumRemovedProtons &gt; 0 ) &amp;&amp;</a>
<a name="ln1759">          pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;endpoint &amp;&amp; </a>
<a name="ln1760">          pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp; pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds ) {</a>
<a name="ln1761">        /*----------------------------------------------------------*/</a>
<a name="ln1762">        /* case 06e:restored: XHn(+)=-AB-YHm  orig.: XHn-=AB=YHm(+) */</a>
<a name="ln1763">        /* FixH:               1          0           1      1      */</a>
<a name="ln1764">        /* MobH:               0          1           t      t      */</a>
<a name="ln1765">        /*                   non-taut atoms       multiple t-groups */</a>
<a name="ln1766">        /*                                                          */</a>
<a name="ln1767">        /* 1. orig. t-group has more H on its endpoints counted     */</a>
<a name="ln1768">        /*          in atf and has no (+) on endpoint that has H    */</a>
<a name="ln1769">        /* 2. orig. t-group has less H on its endpoints counted     */</a>
<a name="ln1770">        /*          in atf and has (+) on endpoint that has H       */</a>
<a name="ln1771">        /*          in reconstructed struct and less H in atf       */</a>
<a name="ln1772">        /* Solution: move (+) from (2) to atom in (1) that has H    */</a>
<a name="ln1773">        /*                                                          */</a>
<a name="ln1774">        /*   tg1  reconstr:   XHn and more H than in orig t-group   */</a>
<a name="ln1775">        /*             atf:   XHn                                   */</a>
<a name="ln1776">        /*   tg2  reconstr:   XHm(+) and less H than in             */</a>
<a name="ln1777">        /*             atf:   XH(m-1)           orig in t-group     */</a>
<a name="ln1778">        /*                                                          */</a>
<a name="ln1779">        /* N  = N, O, S, Se; atoms N are not tautomeric             */</a>
<a name="ln1780">        /* X  = O, S, Se, Te, F, Cl, Br, I; atom X is not tautomeric*/</a>
<a name="ln1781">        /* Solution: move (+) from X  to NH                         */</a>
<a name="ln1782">        /*----------------------------------------------------------*/</a>
<a name="ln1783"> </a>
<a name="ln1784">        int iat, nNumWrongTg, jjoffs, jj, nNum2RemovePlus, nNum2AddPlus, nNum2MovePlus;</a>
<a name="ln1785">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln1786">        /*</a>
<a name="ln1787">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln1788">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln1789">        */</a>
<a name="ln1790">        inp_ATOM *atfMobile_H_Revrs = pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp;</a>
<a name="ln1791">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds?</a>
<a name="ln1792">                                            pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at_fixed_bonds :</a>
<a name="ln1793">                                      pStruct-&gt;pOne_norm_data[TAUT_YES] &amp;&amp;</a>
<a name="ln1794">                                      pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at?</a>
<a name="ln1795">                                            pStruct-&gt;pOne_norm_data[TAUT_YES]-&gt;at : NULL;</a>
<a name="ln1796">        /*</a>
<a name="ln1797">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln1798">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln1799">        */</a>
<a name="ln1800">        EDGE_LIST CurChargeEdges /* source of (+)*/, EndpList;</a>
<a name="ln1801">        TgDiffHChgFH tdhc[MAX_DIFF_FIXH];</a>
<a name="ln1802">        BNS_VERTEX *pv1n, *pv2n;</a>
<a name="ln1803">        BNS_EDGE   *pe1n, *pe2n;</a>
<a name="ln1804">        Vertex      v1n, v2n;</a>
<a name="ln1805"> </a>
<a name="ln1806">        cur_success = 0;</a>
<a name="ln1807">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1808">        AllocEdgeList( &amp;EndpList, EDGE_LIST_CLEAR );</a>
<a name="ln1809">        CurrEdges.num_edges = 0; /* receptors of (+) */</a>
<a name="ln1810">        if ( !atfMobile_H_Revrs ) {</a>
<a name="ln1811">            goto exit_case_06e;</a>
<a name="ln1812">        }</a>
<a name="ln1813">        nNumWrongTg = FillTgDiffHChgFH( tdhc, MAX_DIFF_FIXH, at2, atfMobile_H_Revrs,</a>
<a name="ln1814">                                       nCanon2AtnoRevrs, pVA, &amp;pStruct-&gt;ti, &amp;EndpList );</a>
<a name="ln1815">        if ( nNumWrongTg &lt; 1 ) {</a>
<a name="ln1816">            goto exit_case_06e; /* for now only transfer (+) from one Mobile-H group to another */</a>
<a name="ln1817">        }</a>
<a name="ln1818">        nNum2RemovePlus = nNum2AddPlus = nNum2MovePlus = 0;</a>
<a name="ln1819">        for ( i = 0; i &lt; nNumWrongTg; i ++ ) {</a>
<a name="ln1820">            /* detect t-group that has extra (+) on H */</a>
<a name="ln1821">            if ( tdhc[i].nNumHInchi &gt; tdhc[i].nNumHNorml &amp;&amp;</a>
<a name="ln1822">                 tdhc[i].nNumPRevrs &gt; tdhc[i].nNumPNorml &amp;&amp; tdhc[i].n[fNumRPosChgH] ) {</a>
<a name="ln1823">                /* count how many (+) to remove */</a>
<a name="ln1824">                /* store XH(+) atom numbers */</a>
<a name="ln1825">                int nNumNeeded = inchi_min( tdhc[i].nNumHInchi-tdhc[i].nNumHNorml, tdhc[i].n[fNumRPosChgH]);</a>
<a name="ln1826">                nNum2RemovePlus += nNumNeeded;</a>
<a name="ln1827">                jjoffs = tdhc[i].i[ fNumRPosChgH ];</a>
<a name="ln1828">                for ( jj = 0; jj &lt; tdhc[i].n[fNumRPosChgH]; jj ++ ) {</a>
<a name="ln1829">                    iat = EndpList.pnEdges[ jjoffs + jj ];</a>
<a name="ln1830">                    e = pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln1831">                    if ( (ret = AddToEdgeList( &amp;CurChargeEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1832">                        goto exit_case_06e;</a>
<a name="ln1833">                    }</a>
<a name="ln1834">                }</a>
<a name="ln1835">            } else</a>
<a name="ln1836">            /* detect t-group that needs (+) on XH to reduce number of H */</a>
<a name="ln1837">            if ( tdhc[i].nNumHInchi &lt; tdhc[i].nNumHNorml &amp;&amp; tdhc[i].n[fNumRNeutrlH] ) {</a>
<a name="ln1838">                /* store XH atom numbers */</a>
<a name="ln1839">                int nNumNeeded = inchi_min( tdhc[i].nNumHNorml-tdhc[i].nNumHInchi, tdhc[i].n[fNumRNeutrlH]);</a>
<a name="ln1840">                nNum2AddPlus += nNumNeeded;</a>
<a name="ln1841">                jjoffs = tdhc[i].i[ fNumRNeutrlH ];</a>
<a name="ln1842">                for ( jj = 0; jj &lt; tdhc[i].n[fNumRNeutrlH]; jj ++ ) {</a>
<a name="ln1843">                    iat = EndpList.pnEdges[ jjoffs + jj ];</a>
<a name="ln1844">                    e = pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln1845">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1846">                        goto exit_case_06e;</a>
<a name="ln1847">                    }</a>
<a name="ln1848">                }</a>
<a name="ln1849">            }</a>
<a name="ln1850">        }</a>
<a name="ln1851">        nNum2MovePlus = inchi_min( nNum2RemovePlus, nNum2AddPlus );</a>
<a name="ln1852">        if ( CurrEdges.num_edges &gt; 0 &amp;&amp; CurChargeEdges.num_edges &gt; 0 ) {</a>
<a name="ln1853">            for ( i = 0; 0 &lt; nNum2MovePlus &amp;&amp; i &lt; nNumWrongTg; i ++ ) {</a>
<a name="ln1854">                /* detect t-group that has extra (+) on H */</a>
<a name="ln1855">                if ( tdhc[i].nNumHInchi &gt; tdhc[i].nNumHNorml &amp;&amp;</a>
<a name="ln1856">                     tdhc[i].nNumPRevrs &gt; tdhc[i].nNumPNorml &amp;&amp; tdhc[i].n[fNumRPosChgH] ) {</a>
<a name="ln1857">                    int nNum2Remove = tdhc[i].nNumHInchi - tdhc[i].nNumHNorml;</a>
<a name="ln1858">                    if ( nNum2Remove &lt; tdhc[i].n[fNumRPosChgH] ) {</a>
<a name="ln1859">                        nNum2Remove = tdhc[i].n[fNumRPosChgH];</a>
<a name="ln1860">                    }</a>
<a name="ln1861">                    /* store XH(+) atom numbers */</a>
<a name="ln1862">                    jjoffs = tdhc[i].i[ fNumRPosChgH ];</a>
<a name="ln1863">                    SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1864">                    RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln1865">                    for ( jj = 0; 0 &lt; nNum2MovePlus &amp;&amp; 0 &lt; nNum2Remove &amp;&amp; jj &lt; tdhc[i].n[fNumRPosChgH]; jj ++ ) {</a>
<a name="ln1866">                        iat = EndpList.pnEdges[ jjoffs + jj ];</a>
<a name="ln1867">                        e = pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln1868">                        pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln1869">                        if ( pe-&gt;flow )</a>
<a name="ln1870">                            continue;</a>
<a name="ln1871">                        pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln1872">                        pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln1873"> </a>
<a name="ln1874">                        for ( j = pv1-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln1875">                            pe1n = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln1876">                            if ( pe1n-&gt;flow &amp;&amp; !pe1n-&gt;forbidden ) {</a>
<a name="ln1877">                                pv1n = pBNS-&gt;vert + (v1n = pe1n-&gt;neighbor12 ^ v1);</a>
<a name="ln1878">                                break;</a>
<a name="ln1879">                            }</a>
<a name="ln1880">                        }</a>
<a name="ln1881">                        if ( j &lt; 0 )</a>
<a name="ln1882">                            continue; /* not found */</a>
<a name="ln1883">                        </a>
<a name="ln1884">                        for ( j = pv2-&gt;num_adj_edges-2; 0 &lt;= j; j -- ) {</a>
<a name="ln1885">                            pe2n = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln1886">                            if ( pe2n-&gt;flow &amp;&amp; !pe2n-&gt;forbidden ) {</a>
<a name="ln1887">                                pv2n = pBNS-&gt;vert + (v2n = pe2n-&gt;neighbor12 ^ v2);</a>
<a name="ln1888">                                break;</a>
<a name="ln1889">                            }</a>
<a name="ln1890">                        }</a>
<a name="ln1891">                        if ( j &lt; 0 )</a>
<a name="ln1892">                            continue; /* not found */</a>
<a name="ln1893">                        delta = 1;</a>
<a name="ln1894">                        pe-&gt;flow   += delta;</a>
<a name="ln1895">                        pe1n-&gt;flow -= delta;</a>
<a name="ln1896">                        pe2n-&gt;flow -= delta;</a>
<a name="ln1897">                        pv1n-&gt;st_edge.flow -= delta;</a>
<a name="ln1898">                        pv2n-&gt;st_edge.flow -= delta;</a>
<a name="ln1899">                        pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1900"> </a>
<a name="ln1901">                        ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1902">                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1903"> </a>
<a name="ln1904">                        if ( ret == 1 &amp;&amp; ((vPathEnd == v1n &amp;&amp; vPathStart == v2n) ||</a>
<a name="ln1905">                                          (vPathEnd == v2n &amp;&amp; vPathStart == v1n)) &amp;&amp;</a>
<a name="ln1906">                                          (nDeltaCharge == 0 || nDeltaCharge == 1) ) {</a>
<a name="ln1907">                            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1908">                            if ( ret &gt; 0 ) {</a>
<a name="ln1909">                                nNumRunBNS ++;</a>
<a name="ln1910">                                nNum2Remove --;</a>
<a name="ln1911">                                nNum2MovePlus --;</a>
<a name="ln1912">                                cur_success ++; /* 06e */</a>
<a name="ln1913">                            }</a>
<a name="ln1914">                        } else {</a>
<a name="ln1915">                            pe-&gt;flow   -= delta;</a>
<a name="ln1916">                            pe1n-&gt;flow += delta;</a>
<a name="ln1917">                            pe2n-&gt;flow += delta;</a>
<a name="ln1918">                            pv1n-&gt;st_edge.flow += delta;</a>
<a name="ln1919">                            pv2n-&gt;st_edge.flow += delta;</a>
<a name="ln1920">                            pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln1921">                        }</a>
<a name="ln1922">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1923">                            goto exit_case_06e;</a>
<a name="ln1924">                        }</a>
<a name="ln1925">                    }</a>
<a name="ln1926">                    RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln1927">                }</a>
<a name="ln1928">            }</a>
<a name="ln1929">        }</a>
<a name="ln1930">exit_case_06e:</a>
<a name="ln1931">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln1932">        AllocEdgeList( &amp;CurChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln1933">        AllocEdgeList( &amp;EndpList, EDGE_LIST_FREE );</a>
<a name="ln1934">        if ( cur_success ) {</a>
<a name="ln1935">            tot_succes += cur_success;</a>
<a name="ln1936">            /* recalculate InChI from the structure */</a>
<a name="ln1937">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1938">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln1939">                goto exit_function;</a>
<a name="ln1940">            }</a>
<a name="ln1941">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1942">                goto exit_function;</a>
<a name="ln1943">            }</a>
<a name="ln1944">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln1945">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln1946">            }</a>
<a name="ln1947">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln1948">                goto exit_function;</a>
<a name="ln1949">            }</a>
<a name="ln1950">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln1951">                goto exit_function; /* nothing to do */</a>
<a name="ln1952">            }</a>
<a name="ln1953">        }</a>
<a name="ln1954">    }</a>
<a name="ln1955"> </a>
<a name="ln1956"> </a>
<a name="ln1957"> </a>
<a name="ln1958">    if ( pc2i-&gt;len_c2at &gt;= 1 ) {</a>
<a name="ln1959">        /*--------------------------------------------------------------*/</a>
<a name="ln1960">        /* case 07: restored:  O(-)-AB=O  original:  O=AB-O(-)          */</a>
<a name="ln1961">        /* FixH:               0       0             0     -1           */</a>
<a name="ln1962">        /* MobH:               0       0             0      1           */</a>
<a name="ln1963">        /*                    taut  (non-taut)     (taut) non-taut      */</a>
<a name="ln1964">        /*                    taut  (taut)     (non-taut) non-taut      */   </a>
<a name="ln1965">        /* O = O, S, Se, Te                                             */</a>
<a name="ln1966">        /* Solution: move (-) from O(-)-AB to AB=O                      */</a>
<a name="ln1967">        /*--------------------------------------------------------------*/</a>
<a name="ln1968">        int num_SB_O_Minus = 0, num_DB_O_Neutr = 0, iat;</a>
<a name="ln1969">        short iat_SB_O_Minus[MAX_DIFF_FIXH], iat_DB_O_Neutr[MAX_DIFF_FIXH];</a>
<a name="ln1970">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln1971">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln1972">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln1973">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln1974">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln1975">        cur_success = 0;</a>
<a name="ln1976">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln1977">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln1978">            if ( /* orig. InChI info: -O(-), non-taut */</a>
<a name="ln1979">                 num_DB_O_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln1980">                 pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln1981">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln1982">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln1983">                 pc2i-&gt;c2at[i].nFixHInChI == -1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;</a>
<a name="ln1984">                 /* reversed structure info: */</a>
<a name="ln1985">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;</a>
<a name="ln1986">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln1987">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence ) {</a>
<a name="ln1988">                iat_DB_O_Neutr[num_DB_O_Neutr ++] = iat;</a>
<a name="ln1989">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln1990">                    goto exit_function;</a>
<a name="ln1991">                }</a>
<a name="ln1992">            }</a>
<a name="ln1993">        }</a>
<a name="ln1994">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln1995">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln1996">            if ( /* in restored atom: charge=-1, no H, has single bond, O, S, Se, Te */</a>
<a name="ln1997">                 num_SB_O_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln1998">                 at2[iat].charge == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln1999">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2000">                 pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln2001">                 at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint &amp;&amp;</a>
<a name="ln2002">                 /* in orig.InChI: not an endpoint, has no H */</a>
<a name="ln2003">                 /*pStruct-&gt;endpoint[i] &amp;&amp; -- modificatuion#1 */</a>
<a name="ln2004">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln2005">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln2006">                 /* has (-) edge */</a>
<a name="ln2007">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2008">                iat_SB_O_Minus[num_SB_O_Minus ++] = iat;</a>
<a name="ln2009">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2010">                    goto exit_function;</a>
<a name="ln2011">                }</a>
<a name="ln2012">            }</a>
<a name="ln2013">        }</a>
<a name="ln2014">        if ( (num_try = inchi_min( num_SB_O_Minus, num_DB_O_Neutr )) ) {</a>
<a name="ln2015">            /* detected; attempt to fix */</a>
<a name="ln2016">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2017">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2018">            delta = 1;</a>
<a name="ln2019">            for ( i = 0; i &lt; num_SB_O_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln2020">                iat = iat_SB_O_Minus[i];</a>
<a name="ln2021">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln2022">                if ( !pe-&gt;flow )</a>
<a name="ln2023">                    continue;</a>
<a name="ln2024">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2025">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2026"> </a>
<a name="ln2027">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2028">                pe-&gt;flow -= delta;</a>
<a name="ln2029">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2030">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2031">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2032"> </a>
<a name="ln2033">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2034">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2035"> </a>
<a name="ln2036">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2037">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln2038">                    /* Moved (-) charge to AB=O =&gt; nDeltaCharge == 1 */</a>
<a name="ln2039">                    /* Flow change on pe (-)charge edge (O(-)-AB) is not known to RunBnsTestOnce()) */</a>
<a name="ln2040">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2041">                    if ( ret &gt; 0 ) {</a>
<a name="ln2042">                        nNumRunBNS ++;</a>
<a name="ln2043">                        cur_success ++; /* 07 */</a>
<a name="ln2044">                    }</a>
<a name="ln2045">                } else {</a>
<a name="ln2046">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln2047">                    pe-&gt;flow += delta;</a>
<a name="ln2048">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2049">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2050">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2051">                }</a>
<a name="ln2052">                INCHI_HEAPCHK</a>
<a name="ln2053">            }</a>
<a name="ln2054">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2055">        }</a>
<a name="ln2056">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2057">        if ( cur_success ) {</a>
<a name="ln2058">            tot_succes += cur_success;</a>
<a name="ln2059">            /* recalculate InChI from the structure */</a>
<a name="ln2060">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2061">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2062">                goto exit_function;</a>
<a name="ln2063">            }</a>
<a name="ln2064">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2065">                goto exit_function;</a>
<a name="ln2066">            }</a>
<a name="ln2067">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2068">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln2069">            }</a>
<a name="ln2070">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2071">                goto exit_function;</a>
<a name="ln2072">            }</a>
<a name="ln2073">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2074">                goto exit_function; /* nothing to do */</a>
<a name="ln2075">            }</a>
<a name="ln2076">        }</a>
<a name="ln2077">    }</a>
<a name="ln2078"> </a>
<a name="ln2079">    if ( pc2i-&gt;len_c2at &gt;= 1 ) {</a>
<a name="ln2080">        /*--------------------------------------------------------------*/</a>
<a name="ln2081">        /* case 07a: restored: O(-)-N(V)B=O  original:  O=N(V)B-O(-)    */</a>
<a name="ln2082">        /* FixH:               0          0             0      -1       */</a>
<a name="ln2083">        /* MobH:               0          0             0       1       */</a>
<a name="ln2084">        /*                non-taut  (non-taut)  non-taut  non-taut      */</a>
<a name="ln2085">        /*                non-taut  (taut)      non-taut  non-taut      */   </a>
<a name="ln2086">        /* O = O, S, Se, Te                                             */</a>
<a name="ln2087">        /* Solution: move (-) from O(-)-AB to AB=O                      */</a>
<a name="ln2088">        /*--------------------------------------------------------------*/</a>
<a name="ln2089">        int num_SB_O_Minus = 0, num_DB_O_Neutr = 0, iat, iN;</a>
<a name="ln2090">        short iat_SB_O_Minus[MAX_DIFF_FIXH], iat_DB_O_Neutr[MAX_DIFF_FIXH];</a>
<a name="ln2091">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln2092">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln2093">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln2094">        cur_success = 0;</a>
<a name="ln2095">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln2096">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln2097">            if ( /* orig. InChI info: -O(-), non-taut */</a>
<a name="ln2098">                 num_DB_O_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2099">                 pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln2100">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln2101">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln2102">                 pc2i-&gt;c2at[i].nFixHInChI == -1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;</a>
<a name="ln2103">                 /* reversed structure info: */</a>
<a name="ln2104">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;</a>
<a name="ln2105">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln2106">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence ) {</a>
<a name="ln2107">                iat_DB_O_Neutr[num_DB_O_Neutr ++] = iat;</a>
<a name="ln2108">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2109">                    goto exit_function;</a>
<a name="ln2110">                }</a>
<a name="ln2111">            }</a>
<a name="ln2112">        }</a>
<a name="ln2113">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln2114">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln2115">            if ( /* in restored atom: charge=-1, no H, has single bond, O, S, Se, Te */</a>
<a name="ln2116">                 num_SB_O_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2117">                 at2[iat].charge == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln2118">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2119">                 pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln2120">                 /*at_Mobile_H_Revrs &amp;&amp; !at_Mobile_H_Revrs[iat].endpoint &amp;&amp;*/</a>
<a name="ln2121">                 /* in orig.InChI: not an endpoint, has no H */</a>
<a name="ln2122">                 !pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln2123">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln2124">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln2125">                 /* has N(V) neighbor */</a>
<a name="ln2126">                 1 == at2[iat].valence &amp;&amp; at2[iN=at2[iat].neighbor[0]].chem_bonds_valence==5 &amp;&amp;</a>
<a name="ln2127">                 !at2[iN].charge &amp;&amp; pVA[iN].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln2128">                 /* has (-) edge */</a>
<a name="ln2129">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2130">                iat_SB_O_Minus[num_SB_O_Minus ++] = iat;</a>
<a name="ln2131">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2132">                    goto exit_function;</a>
<a name="ln2133">                }</a>
<a name="ln2134">            }</a>
<a name="ln2135">        }</a>
<a name="ln2136">        if ( (num_try = inchi_min( num_SB_O_Minus, num_DB_O_Neutr )) ) {</a>
<a name="ln2137">            /* detected; attempt to fix */</a>
<a name="ln2138">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2139">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2140">            delta = 1;</a>
<a name="ln2141">            for ( i = 0; i &lt; num_SB_O_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln2142">                iat = iat_SB_O_Minus[i];</a>
<a name="ln2143">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln2144">                if ( !pe-&gt;flow )</a>
<a name="ln2145">                    continue;</a>
<a name="ln2146">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2147">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2148"> </a>
<a name="ln2149">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2150">                pe-&gt;flow -= delta;</a>
<a name="ln2151">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2152">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2153">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2154"> </a>
<a name="ln2155">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2156">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2157"> </a>
<a name="ln2158">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2159">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln2160">                    /* Moved (-) charge to AB=O =&gt; nDeltaCharge == 1 */</a>
<a name="ln2161">                    /* Flow change on pe (-)charge edge (O(-)-AB) is not known to RunBnsTestOnce()) */</a>
<a name="ln2162">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2163">                    if ( ret &gt; 0 ) {</a>
<a name="ln2164">                        nNumRunBNS ++;</a>
<a name="ln2165">                        cur_success ++; /* 07 */</a>
<a name="ln2166">                    }</a>
<a name="ln2167">                } else {</a>
<a name="ln2168">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln2169">                    pe-&gt;flow += delta;</a>
<a name="ln2170">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2171">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2172">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2173">                }</a>
<a name="ln2174">                INCHI_HEAPCHK</a>
<a name="ln2175">            }</a>
<a name="ln2176">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2177">        }</a>
<a name="ln2178">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2179">        if ( cur_success ) {</a>
<a name="ln2180">            tot_succes += cur_success;</a>
<a name="ln2181">            /* recalculate InChI from the structure */</a>
<a name="ln2182">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2183">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2184">                goto exit_function;</a>
<a name="ln2185">            }</a>
<a name="ln2186">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2187">                goto exit_function;</a>
<a name="ln2188">            }</a>
<a name="ln2189">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2190">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln2191">            }</a>
<a name="ln2192">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2193">                goto exit_function;</a>
<a name="ln2194">            }</a>
<a name="ln2195">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2196">                goto exit_function; /* nothing to do */</a>
<a name="ln2197">            }</a>
<a name="ln2198">        }</a>
<a name="ln2199">    }</a>
<a name="ln2200">    if ( /*(pc2i-&gt;len_c2at &gt;= 1 || pc2i-&gt;nNumRemHRevrs) &amp;&amp;*/ pc2i-&gt;nNumTgInChI == 1 &amp;&amp; /* ADP in InChI */</a>
<a name="ln2201">         (pc2i-&gt;nNumEndpRevrs &lt; pc2i-&gt;nNumEndpInChI || pc2i-&gt;nNumTgRevrs &gt; 1) ) {</a>
<a name="ln2202">        /*----------------------------------------------------------------*/</a>
<a name="ln2203">        /* case 08: restored: O(-)-AB=N- OH- orig.   O=AB-N(-)- OH-       */</a>
<a name="ln2204">        /* FixH:               1      0   0          0      0   1         */</a>
<a name="ln2205">        /* MobH:               0      0   1          0      0   0         */</a>
<a name="ln2206">        /*           may be taut or not  non-taut   taut  taut taut       */</a>
<a name="ln2207">        /*                                    ADP: one t-group or more endpoints */</a>
<a name="ln2208">        /* O(-) = S, Se, Te; N = N;                                       */</a>
<a name="ln2209">        /* Solution: move (-) from O(-) to =N-; avoid stereogenic DB on N */</a>
<a name="ln2210">        /*----------------------------------------------------------------*/</a>
<a name="ln2211">        int num_DB_N_Neutr = 0, num_SB_O_Minus = 0, iat;</a>
<a name="ln2212">        short iat_DB_N_Neutr[MAX_DIFF_FIXH], iat_SB_O_Minus[MAX_DIFF_FIXH];</a>
<a name="ln2213">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln2214">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln2215">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln2216">        cur_success = 0;</a>
<a name="ln2217">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln2218">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln2219">            if ( /* in restored atom: charge=-1, has no H, has single bond, O, S, Se, Te */</a>
<a name="ln2220">                 num_SB_O_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2221">                 at2[iat].charge == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln2222">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2223">                 pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln2224">                 /* in orig.InChI: an endpoint, may have fixed-H */</a>
<a name="ln2225">                 pStruct-&gt;endpoint[i] &amp;&amp; </a>
<a name="ln2226">                 /*!(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;*/</a>
<a name="ln2227">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln2228">                 /* has (-) edge */</a>
<a name="ln2229">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2230"> </a>
<a name="ln2231">                iat_SB_O_Minus[num_SB_O_Minus ++] = iat;</a>
<a name="ln2232">                </a>
<a name="ln2233">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2234">                    goto exit_function;</a>
<a name="ln2235">                }</a>
<a name="ln2236">            } else</a>
<a name="ln2237">            if ( /* in restored atom: charge=0, has no H, has double non-stereogenic bond, N */</a>
<a name="ln2238">                 num_DB_N_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2239">                 at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp; !at2[iat].sb_parity[0] &amp;&amp;</a>
<a name="ln2240">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2241">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln2242">                 /* in orig.InChI: an endpoint, has no fixed-H */</a>
<a name="ln2243">                 pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln2244">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln2245">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln2246">                 /* has (-) edge */</a>
<a name="ln2247">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln2248">                 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2249"> </a>
<a name="ln2250">                iat_DB_N_Neutr[num_DB_N_Neutr ++] = iat;</a>
<a name="ln2251">                </a>
<a name="ln2252">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2253">                    goto exit_function;</a>
<a name="ln2254">                }</a>
<a name="ln2255">            }</a>
<a name="ln2256">        }</a>
<a name="ln2257">        if ( (num_try = inchi_min( num_DB_N_Neutr, num_SB_O_Minus )) ) {</a>
<a name="ln2258">            /* detected; attempt to fix */</a>
<a name="ln2259">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2260">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2261">            /* allow stereobonds in rings change */</a>
<a name="ln2262">            if ( forbidden_stereo_edge_mask )</a>
<a name="ln2263">                RemoveForbiddenEdgeMask( pBNS, &amp;FixedLargeRingStereoEdges, forbidden_stereo_edge_mask );</a>
<a name="ln2264"> </a>
<a name="ln2265">            delta = 1;</a>
<a name="ln2266">            for ( i = 0; i &lt; num_SB_O_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln2267">                iat = iat_SB_O_Minus[i];</a>
<a name="ln2268">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln2269">                if ( !pe-&gt;flow )</a>
<a name="ln2270">                    continue;</a>
<a name="ln2271">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2272">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2273"> </a>
<a name="ln2274">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2275">                pe-&gt;flow -= delta;</a>
<a name="ln2276">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2277">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2278">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2279"> </a>
<a name="ln2280">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2281">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2282"> </a>
<a name="ln2283">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2284">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln2285">                    /* Moved (-) charge to =N- =&gt; nDeltaCharge == 1 */</a>
<a name="ln2286">                    /* Flow change on pe (-)charge edge (atom (-)O-) is not known to RunBnsTestOnce()) */</a>
<a name="ln2287">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2288">                    if ( ret &gt; 0 ) {</a>
<a name="ln2289">                        nNumRunBNS ++;</a>
<a name="ln2290">                        cur_success ++; /* 08 */</a>
<a name="ln2291">                    }</a>
<a name="ln2292">                } else {</a>
<a name="ln2293">                    pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln2294">                    pe-&gt;flow += delta;</a>
<a name="ln2295">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2296">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2297">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2298">                }</a>
<a name="ln2299">                INCHI_HEAPCHK</a>
<a name="ln2300">            }</a>
<a name="ln2301">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2302">            if ( forbidden_stereo_edge_mask )</a>
<a name="ln2303">                SetForbiddenEdgeMask( pBNS, &amp;FixedLargeRingStereoEdges, forbidden_stereo_edge_mask );</a>
<a name="ln2304">        }</a>
<a name="ln2305">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2306">        if ( cur_success ) {</a>
<a name="ln2307">            tot_succes += cur_success;</a>
<a name="ln2308">            /* recalculate InChI from the structure */</a>
<a name="ln2309">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2310">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2311">                goto exit_function;</a>
<a name="ln2312">            }</a>
<a name="ln2313">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2314">                goto exit_function;</a>
<a name="ln2315">            }</a>
<a name="ln2316">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2317">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln2318">            }</a>
<a name="ln2319">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2320">                goto exit_function;</a>
<a name="ln2321">            }</a>
<a name="ln2322">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2323">                goto exit_function; /* nothing to do */</a>
<a name="ln2324">            }</a>
<a name="ln2325">        }</a>
<a name="ln2326">    }</a>
<a name="ln2327"> </a>
<a name="ln2328">    if ( pc2i-&gt;len_c2at &gt;= 2 ) {</a>
<a name="ln2329">        /*--------------------------------------------------------*/</a>
<a name="ln2330">        /* case 09: restored: NH2(+)=C--NH2 orig.: NH2-C(+)-NH2   */</a>
<a name="ln2331">        /* FixH:               2     |  2            0  |   0     */</a>
<a name="ln2332">        /* MobH:               0        0            2      2     */</a>
<a name="ln2333">        /* N = N,            taut      taut     non-taut  non-taut*/</a>
<a name="ln2334">        /* Solution: move (+) from NH2(+) to C                    */</a>
<a name="ln2335">        /*--------------------------------------------------------*/</a>
<a name="ln2336">        int iat;</a>
<a name="ln2337">        cur_success = 0;</a>
<a name="ln2338">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln2339">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln2340">            if ( (pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[i].nPeriodNum == 1) &amp;&amp;</a>
<a name="ln2341">                 /* orig. InChI info: */</a>
<a name="ln2342">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln2343">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI &amp;&amp;</a>
<a name="ln2344">                 /* reversed structure info: */</a>
<a name="ln2345">                 pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln2346">                 pc2i-&gt;c2at[i].nFixHRevrs &amp;&amp; !pc2i-&gt;c2at[i].nMobHRevrs &amp;&amp;</a>
<a name="ln2347">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 1 &amp;&amp;</a>
<a name="ln2348">                 at2[iat].valence + 1 == at2[iat].chem_bonds_valence &amp;&amp;</a>
<a name="ln2349">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2350">                EdgeIndex eNC = NO_VERTEX, eCPlusC;</a>
<a name="ln2351">                int       iNH2, iatC, iatNH2, icNH2;</a>
<a name="ln2352">                /* found NH2(+)=; locate =C&lt; and find whether it has -NH2 neighbor */</a>
<a name="ln2353">                for ( j = 0; j &lt; at2[iat].valence; j ++ ) {</a>
<a name="ln2354">                    if ( at2[iat].bond_type[j] == BOND_TYPE_DOUBLE )</a>
<a name="ln2355">                        break;</a>
<a name="ln2356">                }</a>
<a name="ln2357">                if ( j == at2[iat].valence )</a>
<a name="ln2358">                    continue;</a>
<a name="ln2359">                eNC = pBNS-&gt;vert[iat].iedge[j]; /* edge NH2(+)=C */</a>
<a name="ln2360">                iatC = at2[iat].neighbor[j];</a>
<a name="ln2361">                if ( pVA[iatC].cNumValenceElectrons != 4 || pVA[iatC].cMetal || at2[iatC].charge ||</a>
<a name="ln2362">                     at2[iatC].valence != 3 || at2[iatC].valence+1 != at2[iatC].chem_bonds_valence ||</a>
<a name="ln2363">                     (eCPlusC=pVA[iatC].nCPlusGroupEdge-1) &lt; 0 || pBNS-&gt;edge[eCPlusC].forbidden)</a>
<a name="ln2364">                    continue;</a>
<a name="ln2365">                for ( j = 0; j &lt; at2[iatC].valence; j ++ ) {</a>
<a name="ln2366">                    iatNH2 = at2[iatC].neighbor[j];</a>
<a name="ln2367">                    if ( iatNH2 == iat || pVA[iatNH2].cNumValenceElectrons != 5 ||</a>
<a name="ln2368">                         pVA[iatNH2].cPeriodicRowNumber != 1 || !at2[iatNH2].num_H || at2[iatNH2].charge)</a>
<a name="ln2369">                        continue;</a>
<a name="ln2370">                    icNH2 = pStruct-&gt;nAtno2Canon[0][iatNH2];</a>
<a name="ln2371">                    for ( iNH2 = 0; iNH2 &lt; pc2i-&gt;len_c2at; iNH2 ++ ) {</a>
<a name="ln2372">                        if ( iatNH2 == pc2i-&gt;c2at[iNH2].atomNumber )</a>
<a name="ln2373">                            break;</a>
<a name="ln2374">                    }</a>
<a name="ln2375">                    if ( iNH2 == pc2i-&gt;len_c2at )</a>
<a name="ln2376">                        continue;</a>
<a name="ln2377"> </a>
<a name="ln2378">                    if ( (pc2i-&gt;c2at[iNH2].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[iNH2].nPeriodNum == 1) &amp;&amp;</a>
<a name="ln2379">                         /* orig. InChI info: */</a>
<a name="ln2380">                         !pc2i-&gt;c2at[iNH2].endptInChI &amp;&amp;</a>
<a name="ln2381">                         pc2i-&gt;c2at[iNH2].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[iNH2].nMobHInChI &amp;&amp;</a>
<a name="ln2382">                         /* reversed structure info: */</a>
<a name="ln2383">                         pc2i-&gt;c2at[iNH2].endptRevrs &amp;&amp;</a>
<a name="ln2384">                         pc2i-&gt;c2at[iNH2].nFixHRevrs &amp;&amp; !pc2i-&gt;c2at[iNH2].nMobHRevrs &amp;&amp;</a>
<a name="ln2385">                         pc2i-&gt;c2at[iNH2].nAtChargeRevrs == 0 &amp;&amp;</a>
<a name="ln2386">                         at2[iatNH2].valence == at2[iatNH2].chem_bonds_valence ) {</a>
<a name="ln2387">                        /* we have found NH2(+)=, =C&lt;, and bond between them */</a>
<a name="ln2388"> </a>
<a name="ln2389">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2390">                            goto exit_function;</a>
<a name="ln2391">                        }</a>
<a name="ln2392">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, eCPlusC, INC_ADD_EDGE )) ) {</a>
<a name="ln2393">                            goto exit_function;</a>
<a name="ln2394">                        }</a>
<a name="ln2395">                        SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2396">                        RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2397">                        delta = 1;</a>
<a name="ln2398"> </a>
<a name="ln2399">                        pe   = pBNS-&gt;edge + eNC;</a>
<a name="ln2400">                        if ( !pe-&gt;flow )</a>
<a name="ln2401">                            continue;</a>
<a name="ln2402">                        pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2403">                        pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2404"> </a>
<a name="ln2405">                        pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2406">                        pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln2407">                        pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2408">                        pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2409">                        pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2410"> </a>
<a name="ln2411">                        ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2412">                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2413"> </a>
<a name="ln2414">                        if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2415">                                          (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 0 ) {</a>
<a name="ln2416">                            /* Removed (+)charge from -NHn =&gt; nDeltaCharge == -1 */</a>
<a name="ln2417">                            /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln2418">                            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2419">                            if ( ret &gt; 0 ) {</a>
<a name="ln2420">                                nNumRunBNS ++;</a>
<a name="ln2421">                                cur_success ++; /* 09 */</a>
<a name="ln2422">                            }</a>
<a name="ln2423">                        } else {</a>
<a name="ln2424">                            pe-&gt;flow += delta;</a>
<a name="ln2425">                            pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2426">                            pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2427">                            pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2428">                        }</a>
<a name="ln2429">                        INCHI_HEAPCHK</a>
<a name="ln2430">                        pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln2431">                        RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2432">                        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2433">                        break;</a>
<a name="ln2434">                    }</a>
<a name="ln2435">                }</a>
<a name="ln2436">            }</a>
<a name="ln2437">        }</a>
<a name="ln2438">        if ( cur_success ) {</a>
<a name="ln2439">            tot_succes += cur_success;</a>
<a name="ln2440">            /* recalculate InChI from the structure */</a>
<a name="ln2441">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2442">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2443">                goto exit_function;</a>
<a name="ln2444">            }</a>
<a name="ln2445">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2446">                goto exit_function;</a>
<a name="ln2447">            }</a>
<a name="ln2448">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2449">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln2450">            }</a>
<a name="ln2451">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2452">                goto exit_function;</a>
<a name="ln2453">            }</a>
<a name="ln2454">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2455">                goto exit_function; /* nothing to do */</a>
<a name="ln2456">            }</a>
<a name="ln2457">        }</a>
<a name="ln2458">    }</a>
<a name="ln2459"> </a>
<a name="ln2460"> </a>
<a name="ln2461">    if ( pc2i-&gt;len_c2at &gt;= 2 ) {</a>
<a name="ln2462">        /*--------------------------------------------------------*/</a>
<a name="ln2463">        /* case 10: restored: NH2-X(+)-NH-  orig.: NH2(+)=X-NH-   */</a>
<a name="ln2464">        /* FixH:               0        0            2      1     */</a>
<a name="ln2465">        /* MobH:               2        1            0      0     */</a>
<a name="ln2466">        /* N = N,O,S,Se,Te non-taut  non-taut       taut   taut   */</a>
<a name="ln2467">        /* Solution: move (+) from X(+) to NH2 or NH              */</a>
<a name="ln2468">        /*--------------------------------------------------------*/</a>
<a name="ln2469">        int iat;</a>
<a name="ln2470">        cur_success = 0;</a>
<a name="ln2471">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln2472">            if ( pc2i-&gt;c2at[i].nValue )</a>
<a name="ln2473">                continue;</a>
<a name="ln2474">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln2475">            if ( (pc2i-&gt;c2at[i].nValElectr == 6 ||</a>
<a name="ln2476">                  (pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp; pc2i-&gt;c2at[i].nPeriodNum == 1)) &amp;&amp;</a>
<a name="ln2477">                 /* orig. InChI info: */</a>
<a name="ln2478">                 pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln2479">                 pc2i-&gt;c2at[i].nFixHInChI &amp;&amp; !pc2i-&gt;c2at[i].nMobHInChI &amp;&amp;</a>
<a name="ln2480">                 /* reversed structure info: */</a>
<a name="ln2481">                 !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln2482">                 !pc2i-&gt;c2at[i].nFixHRevrs &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs &amp;&amp;</a>
<a name="ln2483">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp;</a>
<a name="ln2484">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp;</a>
<a name="ln2485">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2486"> </a>
<a name="ln2487">                EdgeIndex eCPlusC, eCPlusNH2, bContinue=1;</a>
<a name="ln2488">                int       iNH2, iatC, iatNH2, icNH2, j1, j2;</a>
<a name="ln2489">                BNS_EDGE *pe_iat, *pe_iNH2;</a>
<a name="ln2490">                /* found NH2- locate -X(+) and find whether it has another -NH2 neighbor */</a>
<a name="ln2491">                for ( j1 = 0; j1 &lt; at2[iat].valence &amp;&amp; bContinue; j1 ++ ) {</a>
<a name="ln2492">                    if ( at2[iat].bond_type[j1] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2493">                         at2[iatC = at2[iat].neighbor[j1]].charge == 1 &amp;&amp;</a>
<a name="ln2494">                         (4 &lt;= pVA[iatC].cNumValenceElectrons &amp;&amp; pVA[iatC].cNumValenceElectrons &lt;= 6) &amp;&amp;</a>
<a name="ln2495">                         at2[iatC].valence == at2[iatC].chem_bonds_valence &amp;&amp;</a>
<a name="ln2496">                         (eCPlusC=pVA[iatC].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[eCPlusC].forbidden) {</a>
<a name="ln2497">                        /* found a candidate for X; find another NH2 */</a>
<a name="ln2498">                        for ( j2 = 0; j2 &lt; at2[iatC].valence &amp;&amp; bContinue; j2 ++ ) {</a>
<a name="ln2499">                            if ( at2[iatC].bond_type[j2] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln2500">                                 iat != (iatNH2 = at2[iatC].neighbor[j2]) &amp;&amp;</a>
<a name="ln2501">                                 at2[iatNH2].charge == 0 &amp;&amp; at2[iatNH2].num_H &amp;&amp;</a>
<a name="ln2502">                                 (pVA[iatNH2].cNumValenceElectrons==5 || pVA[iatNH2].cNumValenceElectrons==6) &amp;&amp;</a>
<a name="ln2503">                                 at2[iatNH2].valence == at2[iatNH2].chem_bonds_valence &amp;&amp;</a>
<a name="ln2504">                                 (eCPlusNH2=pVA[iatNH2].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[eCPlusNH2].forbidden) {</a>
<a name="ln2505">                                for ( iNH2 = 0; iNH2 &lt; pc2i-&gt;len_c2at; iNH2 ++ ) {</a>
<a name="ln2506">                                    if ( iatNH2 != pc2i-&gt;c2at[iNH2].atomNumber || pc2i-&gt;c2at[iNH2].nValue )</a>
<a name="ln2507">                                        continue;</a>
<a name="ln2508">                                    /* check the second -NH */</a>
<a name="ln2509">                                    icNH2 = pStruct-&gt;nAtno2Canon[0][iatNH2]; /* canon number -1 */</a>
<a name="ln2510">                                    if ( /* orig. InChI info: */</a>
<a name="ln2511">                                         pc2i-&gt;c2at[iNH2].endptInChI &amp;&amp;</a>
<a name="ln2512">                                         pc2i-&gt;c2at[iNH2].nFixHInChI &amp;&amp; !pc2i-&gt;c2at[iNH2].nMobHInChI &amp;&amp;</a>
<a name="ln2513">                                         /* reversed structure info: */</a>
<a name="ln2514">                                         !pc2i-&gt;c2at[iNH2].endptRevrs &amp;&amp;</a>
<a name="ln2515">                                         !pc2i-&gt;c2at[iNH2].nFixHRevrs &amp;&amp; pc2i-&gt;c2at[iNH2].nMobHRevrs &amp;&amp;</a>
<a name="ln2516">                                         pc2i-&gt;c2at[iNH2].nAtChargeRevrs == 0 ) {</a>
<a name="ln2517">                                        /* we have found NH-X(+)-NH; remove charge from X(+) */</a>
<a name="ln2518">                                        pe_iat  = pBNS-&gt;edge + pBNS-&gt;vert[iat].iedge[j1];</a>
<a name="ln2519">                                        pe_iNH2 = pBNS-&gt;edge + pBNS-&gt;vert[iatC].iedge[j2];</a>
<a name="ln2520">                                        /* pick up one of -NH to move (+) to it */</a>
<a name="ln2521">                                        if ( !pe_iat-&gt;forbidden &amp;&amp; pBNS-&gt;edge[e].flow ) {</a>
<a name="ln2522">                                            pe = pBNS-&gt;edge + e;</a>
<a name="ln2523">                                        } else</a>
<a name="ln2524">                                        if ( !pe_iNH2-&gt;forbidden &amp;&amp; pBNS-&gt;edge[eCPlusNH2].flow ) {</a>
<a name="ln2525">                                            pe = pBNS-&gt;edge + eCPlusNH2;</a>
<a name="ln2526">                                        } else {</a>
<a name="ln2527">                                            continue; /* none of the two -X(+)- bonds may be changed */</a>
<a name="ln2528">                                        }</a>
<a name="ln2529">                                        if ( (ret = AddToEdgeList( &amp;CurrEdges, eCPlusC, INC_ADD_EDGE )) ) {</a>
<a name="ln2530">                                            goto exit_function;</a>
<a name="ln2531">                                        }</a>
<a name="ln2532">                                        SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2533">                                        RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2534">                                        delta = 1;</a>
<a name="ln2535"> </a>
<a name="ln2536">                                        pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2537">                                        pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2538"> </a>
<a name="ln2539">                                        /*pe-&gt;forbidden |= forbidden_edge_mask;*/</a>
<a name="ln2540">                                        pe-&gt;flow -= delta; /* add (+) to -NHm */</a>
<a name="ln2541">                                        pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2542">                                        pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2543">                                        pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2544"> </a>
<a name="ln2545">                                        ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2546">                                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2547"> </a>
<a name="ln2548">                                        if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2549">                                                          (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == -1 ) {</a>
<a name="ln2550">                                            /* Removed (+)charge from -NHn =&gt; nDeltaCharge == -1 */</a>
<a name="ln2551">                                            /* Flow change on pe (+)charge edge (atom NHm(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln2552">                                            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2553">                                            if ( ret &gt; 0 ) {</a>
<a name="ln2554">                                                nNumRunBNS ++;</a>
<a name="ln2555">                                                cur_success ++; /* 10 */</a>
<a name="ln2556">                                                bContinue = 0;</a>
<a name="ln2557">                                                pc2i-&gt;c2at[i].nValue    = 1;    /* mark as used */</a>
<a name="ln2558">                                                pc2i-&gt;c2at[iNH2].nValue = 1; /* mark as used */</a>
<a name="ln2559">                                            }</a>
<a name="ln2560">                                        } else {</a>
<a name="ln2561">                                            pe-&gt;flow += delta;</a>
<a name="ln2562">                                            pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2563">                                            pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2564">                                            pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2565">                                        }</a>
<a name="ln2566">                                        INCHI_HEAPCHK</a>
<a name="ln2567"> </a>
<a name="ln2568">                                        /*pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;*/</a>
<a name="ln2569">                                        RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2570">                                        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2571">                                        break;</a>
<a name="ln2572">                                    }</a>
<a name="ln2573">                                } /* iNH2: pc2i-&gt;c2at[iNH2] cycle */</a>
<a name="ln2574">                            }</a>
<a name="ln2575">                        } /* j2: iatC neighbors cycle */</a>
<a name="ln2576">                    }</a>
<a name="ln2577">                } /* j1: iat neighbors cycle */</a>
<a name="ln2578">            }</a>
<a name="ln2579">        } /* i: pc2i-&gt;c2at[i] cycle */</a>
<a name="ln2580">        if ( cur_success ) {</a>
<a name="ln2581">            /*</a>
<a name="ln2582">            for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln2583">                pc2i-&gt;c2at[i].nValue = 0;</a>
<a name="ln2584">            }</a>
<a name="ln2585">            */</a>
<a name="ln2586">            tot_succes += cur_success;</a>
<a name="ln2587">            /* recalculate InChI from the structure */</a>
<a name="ln2588">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2589">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2590">                goto exit_function;</a>
<a name="ln2591">            }</a>
<a name="ln2592">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2593">                goto exit_function;</a>
<a name="ln2594">            }</a>
<a name="ln2595">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2596">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln2597">            }</a>
<a name="ln2598">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2599">                goto exit_function;</a>
<a name="ln2600">            }</a>
<a name="ln2601">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2602">                goto exit_function; /* nothing to do */</a>
<a name="ln2603">            }</a>
<a name="ln2604">        }</a>
<a name="ln2605">    }</a>
<a name="ln2606"> </a>
<a name="ln2607">    if ( /*pc2i-&gt;len_c2at &gt;= 1 &amp;&amp;*/ pc2i-&gt;nNumTgInChI == 1 &amp;&amp; /* ADP in InChI */</a>
<a name="ln2608">         (pc2i-&gt;nNumEndpRevrs &lt; pc2i-&gt;nNumEndpInChI || pc2i-&gt;nNumTgRevrs &gt; 1) ) {</a>
<a name="ln2609">        /*--------------------------------------------------------------*/</a>
<a name="ln2610">        /* case 11: restored: NH(+)=AB-N&lt; OH- orig.  NH-AB=N(+)&lt; OH-    */</a>
<a name="ln2611">        /* FixH:               0       0   0          1      0   1      */</a>
<a name="ln2612">        /* MobH:               1       0   1          0      0   0      */</a>
<a name="ln2613">        /*                 non-taut.                taut        taut    */</a>
<a name="ln2614">        /*                                    ADP: one t-group or more endpoints */</a>
<a name="ln2615">        /* NH(+)= =&gt; N, O, S, Se; -N&lt; =&gt; N                              */</a>
<a name="ln2616">        /* Solution: move (+) from NH(+) to -N&lt;                         */</a>
<a name="ln2617">        /*--------------------------------------------------------------*/</a>
<a name="ln2618">        int num_SB_Neutr = 0, num_DB_Charged = 0, iat;</a>
<a name="ln2619">        short iat_SB_Neutr[MAX_DIFF_FIXH], iat_DB_Charged[MAX_DIFF_FIXH];</a>
<a name="ln2620">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln2621">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln2622">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln2623">        cur_success = 0;</a>
<a name="ln2624">        /* search for NH(+)= */</a>
<a name="ln2625">        /* search for -N&lt; */</a>
<a name="ln2626">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln2627">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln2628">            if ( /* in restored atom: charge=0, has no H, has no double bond, N only */</a>
<a name="ln2629">                 num_DB_Charged &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2630">                 at2[iat].charge == 1 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln2631">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2632">                 ((pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1) ||</a>
<a name="ln2633">                  pVA[iat].cNumValenceElectrons == 6 ) &amp;&amp;</a>
<a name="ln2634">                 /* in orig.InChI: an endpoint, has fixed-H */</a>
<a name="ln2635">                 /*pStruct-&gt;endpoint[i] &amp;&amp;*/</a>
<a name="ln2636">                 (pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln2637">                 /*!(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;*/</a>
<a name="ln2638">                 /* has (+) edge */</a>
<a name="ln2639">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2640"> </a>
<a name="ln2641">                iat_DB_Charged[num_DB_Charged ++] = iat;</a>
<a name="ln2642">                /*</a>
<a name="ln2643">                if ( ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ) ) {</a>
<a name="ln2644">                    goto exit_function;</a>
<a name="ln2645">                }</a>
<a name="ln2646">                */</a>
<a name="ln2647">            } else</a>
<a name="ln2648">            if ( /* in restored atom: charge=0, has no H, has no double bond, N only */</a>
<a name="ln2649">                 num_SB_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2650">                 at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln2651">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2652">                 (pVA[iat].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln2653">                  pVA[iat].cPeriodicRowNumber == 1 ) &amp;&amp;</a>
<a name="ln2654">                 /* in orig.InChI: an endpoint, has fixed-H */</a>
<a name="ln2655">                 /*pStruct-&gt;endpoint[i] &amp;&amp;*/</a>
<a name="ln2656">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln2657">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln2658">                 /* has (+) edge */</a>
<a name="ln2659">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2660"> </a>
<a name="ln2661">                iat_SB_Neutr[num_SB_Neutr ++] = iat;</a>
<a name="ln2662">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2663">                    goto exit_function;</a>
<a name="ln2664">                }</a>
<a name="ln2665">            }</a>
<a name="ln2666">        }</a>
<a name="ln2667">        if ( (num_try = inchi_min( num_SB_Neutr, num_DB_Charged )) ) {</a>
<a name="ln2668">            /* detected; attempt to fix */</a>
<a name="ln2669">            BNS_VERTEX *pv1n, *pv2n;</a>
<a name="ln2670">            BNS_EDGE   *pe1n, *pe2n;</a>
<a name="ln2671">            Vertex      v1n, v2n;</a>
<a name="ln2672">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2673">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2674">            delta = 1;</a>
<a name="ln2675">            for ( i = 0; i &lt; num_DB_Charged &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln2676">                iat = iat_DB_Charged[i];</a>
<a name="ln2677">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln2678">                if ( pe-&gt;flow )</a>
<a name="ln2679">                    continue;</a>
<a name="ln2680">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2681">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2682"> </a>
<a name="ln2683">                for ( j = pv1-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln2684">                    pe1n = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln2685">                    if ( pe1n-&gt;flow &amp;&amp; !pe1n-&gt;forbidden ) {</a>
<a name="ln2686">                        pv1n = pBNS-&gt;vert + (v1n = pe1n-&gt;neighbor12 ^ v1);</a>
<a name="ln2687">                        break;</a>
<a name="ln2688">                    }</a>
<a name="ln2689">                }</a>
<a name="ln2690">                if ( j &lt; 0 )</a>
<a name="ln2691">                    continue; /* not found */</a>
<a name="ln2692">                </a>
<a name="ln2693">                for ( j = pv2-&gt;num_adj_edges-2; 0 &lt;= j; j -- ) {</a>
<a name="ln2694">                    pe2n = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln2695">                    if ( pe2n-&gt;flow &amp;&amp; !pe2n-&gt;forbidden ) {</a>
<a name="ln2696">                        pv2n = pBNS-&gt;vert + (v2n = pe2n-&gt;neighbor12 ^ v2);</a>
<a name="ln2697">                        break;</a>
<a name="ln2698">                    }</a>
<a name="ln2699">                }</a>
<a name="ln2700">                if ( j &lt; 0 )</a>
<a name="ln2701">                    continue; /* not found */</a>
<a name="ln2702"> </a>
<a name="ln2703">                pe-&gt;flow   += delta;</a>
<a name="ln2704">                pe1n-&gt;flow -= delta;</a>
<a name="ln2705">                pe2n-&gt;flow -= delta;</a>
<a name="ln2706">                pv1n-&gt;st_edge.flow -= delta;</a>
<a name="ln2707">                pv2n-&gt;st_edge.flow -= delta;</a>
<a name="ln2708">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2709"> </a>
<a name="ln2710">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2711">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2712"> </a>
<a name="ln2713">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1n &amp;&amp; vPathStart == v2n) ||</a>
<a name="ln2714">                                  (vPathEnd == v2n &amp;&amp; vPathStart == v1n)) &amp;&amp;</a>
<a name="ln2715">                                  (nDeltaCharge == 0 || nDeltaCharge == 1) ) {</a>
<a name="ln2716">                    /* before setting flows the structure could be:</a>
<a name="ln2717">                       [NH+ neigh, v1n]=e1n=[NH+,v1]-pe-[+,v2]=e2n=[another at or its chargeStruct]</a>
<a name="ln2718">                       or</a>
<a name="ln2719">                        </a>
<a name="ln2720">                         [NH+ or ChStr, v1n]=pe1n=[NH+ or ChStr, v1]-pe-[+,v2]=pe2n=[at2 or ChStr, v2n]</a>
<a name="ln2721">                                                                     ^    ^    ^</a>
<a name="ln2722">                                                               NH+(+)edge |  N (+) edge: only</a>
<a name="ln2723">                                                                          |  these are not forbidden</a>
<a name="ln2724">                                                                          |</a>
<a name="ln2725">                                                                   hetero (+) vertex</a>
<a name="ln2726"> </a>
<a name="ln2727">                        After setting flows (* mark radicals, =pe= is forbidden):</a>
<a name="ln2728">                       </a>
<a name="ln2729">                       *[NH+ or ChStr, v1n]-pe1n-[NH+ or ChStr, v1]=pe=[+,v2]-pe2n-[at2 or ChStr, v2n]*</a>
<a name="ln2730">                                                                     ^    ^    ^</a>
<a name="ln2731">                                                               NH+(+)edge |  N (+) edge: only</a>
<a name="ln2732">                                                                          |  these are not forbidden</a>
<a name="ln2733">                                                                          |</a>
<a name="ln2734">                                                                   hetero (+) vertex</a>
<a name="ln2735"> </a>
<a name="ln2736">                        Flow in</a>
<a name="ln2737">                        pe1n and pe2n will or will not change, depending on the structure.</a>
<a name="ln2738"> </a>
<a name="ln2739">                        Consider what happens if pe2n changes. It may only increment.</a>
<a name="ln2740">                        If pe2n flow increments then another (+)edge flow dectrements. If</a>
<a name="ln2741">                        [at2 or ChStr, v2n] is at2 then at2 charge would change from (+) to 0,</a>
<a name="ln2742">                        and another N charge would change from 0 to (+), giving tot. change of</a>
<a name="ln2743">                        number of charges  (-1)+(+1)=0. However, if [at2 or ChStr, v2n] is</a>
<a name="ln2744">                        ChargeStruct then at2 will not be on the alt path and only the creation</a>
<a name="ln2745">                        of another (+) will be detected.</a>
<a name="ln2746">                    */</a>
<a name="ln2747">                    /* Removed charge from O(+) =&gt; nDeltaCharge == -1 */</a>
<a name="ln2748">                    /* Flow change on pe (+)charge edge (atom NH2) is not known to RunBnsTestOnce()) */</a>
<a name="ln2749">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2750">                    if ( ret &gt; 0 ) {</a>
<a name="ln2751">                        nNumRunBNS ++;</a>
<a name="ln2752">                        cur_success ++; /* 11 */</a>
<a name="ln2753">                    }</a>
<a name="ln2754">                } else {</a>
<a name="ln2755">                    pe-&gt;flow   -= delta;</a>
<a name="ln2756">                    pe1n-&gt;flow += delta;</a>
<a name="ln2757">                    pe2n-&gt;flow += delta;</a>
<a name="ln2758">                    pv1n-&gt;st_edge.flow += delta;</a>
<a name="ln2759">                    pv2n-&gt;st_edge.flow += delta;</a>
<a name="ln2760">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2761">                }</a>
<a name="ln2762">                INCHI_HEAPCHK</a>
<a name="ln2763">            }</a>
<a name="ln2764">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2765">        }</a>
<a name="ln2766">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2767">        if ( cur_success ) {</a>
<a name="ln2768">            tot_succes += cur_success;</a>
<a name="ln2769">            /* recalculate InChI from the structure */</a>
<a name="ln2770">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2771">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2772">                goto exit_function;</a>
<a name="ln2773">            }</a>
<a name="ln2774">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2775">                goto exit_function;</a>
<a name="ln2776">            }</a>
<a name="ln2777">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2778">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln2779">            }</a>
<a name="ln2780">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2781">                goto exit_function;</a>
<a name="ln2782">            }</a>
<a name="ln2783">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2784">                goto exit_function; /* nothing to do */</a>
<a name="ln2785">            }</a>
<a name="ln2786">        }</a>
<a name="ln2787">    }</a>
<a name="ln2788"> </a>
<a name="ln2789">    if ( pc2i-&gt;len_c2at &gt;= 1 &amp;&amp; pc2i-&gt;nNumTgInChI == 1 &amp;&amp;</a>
<a name="ln2790">         pc2i-&gt;nNumRemHInChI &gt;= -1 &amp;&amp; /* 2006-03-03 */</a>
<a name="ln2791">         (pc2i-&gt;nNumEndpInChI &gt; pc2i-&gt;nNumEndpRevrs || pc2i-&gt;nNumTgRevrs &gt; 1) /* ADP in InChI */ ) {</a>
<a name="ln2792">        /*--------------------------------------------------------------*/</a>
<a name="ln2793">        /* case 12: restored: O=AB-N&lt;         original: (-)O-AB=N(+)&lt;   */</a>
<a name="ln2794">        /* FixH:              0    0                     0        0     */</a>
<a name="ln2795">        /* MobH:              0    0                     0        0     */</a>
<a name="ln2796">        /*                   non-taut                   taut            */</a>
<a name="ln2797">        /* O = O, S, Se, N; N = N;                                         */</a>
<a name="ln2798">        /* restored atom O is not tautomeric; original atom O is taut.  */</a>
<a name="ln2799">        /* original struct has 1 t-group; restored has less endpoints   */</a>
<a name="ln2800">        /*                             and/or possibly &gt;1 t-groups      */  </a>
<a name="ln2801">        /* Solution: separate charges between O= and -N&lt;                */</a>
<a name="ln2802">        /*           allow moving charge to N(V) to make it N(IV)(+)    */</a>
<a name="ln2803">        /*--------------------------------------------------------------*/</a>
<a name="ln2804">        int bOnly_N_V = 1;</a>
<a name="ln2805">        cur_success = 0;</a>
<a name="ln2806">        while( 1 ) {</a>
<a name="ln2807">            int num_SB_N_Neutr = 0, num_DB_O = 0, iat, num_N_V=0, bN_V;</a>
<a name="ln2808">            short iat_SB_N_Neutr[MAX_DIFF_FIXH], iat_DB_O[MAX_DIFF_FIXH];</a>
<a name="ln2809">            AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln2810">            inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln2811">                                 pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln2812">            S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln2813">                                   pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln2814">            cur_success = 0;</a>
<a name="ln2815">            for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln2816">                iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln2817">                if ( /* orig. InChI info: -O(-) */</a>
<a name="ln2818">                     num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2819">                     (pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ ||</a>
<a name="ln2820">                      (pc2i-&gt;c2at[i].nValElectr == 5 &amp;&amp;</a>
<a name="ln2821">                      pc2i-&gt;c2at[i].nPeriodNum == 1) /* N */ ) &amp;&amp;</a>
<a name="ln2822">                     pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln2823">                     (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln2824">                     pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln2825">                     /* reversed structure info: */</a>
<a name="ln2826">                     !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln2827">                     pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;</a>
<a name="ln2828">                     pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln2829">                     ((pc2i-&gt;c2at[i].nValElectr == 6)? </a>
<a name="ln2830">                           (at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2):</a>
<a name="ln2831">                      (pc2i-&gt;c2at[i].nValElectr == 5)?</a>
<a name="ln2832">                           (at2[iat].valence == 2 &amp;&amp; at2[iat].chem_bonds_valence == 3):</a>
<a name="ln2833">                           0)) {</a>
<a name="ln2834">                </a>
<a name="ln2835">                    iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln2836">                    /*</a>
<a name="ln2837">                    if ( ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ) ) {</a>
<a name="ln2838">                        goto exit_function;</a>
<a name="ln2839">                    }</a>
<a name="ln2840">                    */</a>
<a name="ln2841">                }</a>
<a name="ln2842">            }</a>
<a name="ln2843">            for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln2844">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln2845">                bN_V = 0;</a>
<a name="ln2846">                if ( /* in restored atom N: charge=0, no H, has no double bond, not an endpoint */</a>
<a name="ln2847">                     num_SB_N_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln2848">                     at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln2849">                     (at2[iat].valence == at2[iat].chem_bonds_valence ||</a>
<a name="ln2850">                     (bN_V = at2[iat].valence+2 == at2[iat].chem_bonds_valence)) &amp;&amp;</a>
<a name="ln2851">                     !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln2852">                     pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln2853">                     !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint) &amp;&amp;</a>
<a name="ln2854">                     /* in orig.InChI: not an endpoint, has no H */</a>
<a name="ln2855">                     !pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln2856">                     !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln2857">                     !(nMobHInChI &amp;&amp; nMobHInChI[i]) &amp;&amp;</a>
<a name="ln2858">                     /* has (+) edge */</a>
<a name="ln2859">                     (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln2860"> </a>
<a name="ln2861">                    if ( bOnly_N_V &amp;&amp; bN_V &amp;&amp;</a>
<a name="ln2862">                         NO_VERTEX != (j = GetChargeFlowerUpperEdge( pBNS, pVA, e )) &amp;&amp;</a>
<a name="ln2863">                         !pBNS-&gt;edge[j].forbidden &amp;&amp; !pBNS-&gt;edge[j].flow ) {</a>
<a name="ln2864">                        if ( !num_N_V ) {</a>
<a name="ln2865">                            /* switch to N(V) only mode */</a>
<a name="ln2866">                            CurrEdges.num_edges = 0;</a>
<a name="ln2867">                            num_SB_N_Neutr = 0;</a>
<a name="ln2868">                        }</a>
<a name="ln2869">                        iat_SB_N_Neutr[num_SB_N_Neutr ++] = iat;</a>
<a name="ln2870">                        num_N_V ++;</a>
<a name="ln2871">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2872">                            goto exit_function;</a>
<a name="ln2873">                        }</a>
<a name="ln2874">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, j, INC_ADD_EDGE )) ) {</a>
<a name="ln2875">                            goto exit_function;</a>
<a name="ln2876">                        }</a>
<a name="ln2877">                    } else</a>
<a name="ln2878">                    if ( !num_N_V ) {</a>
<a name="ln2879">                        iat_SB_N_Neutr[num_SB_N_Neutr ++] = iat;</a>
<a name="ln2880">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln2881">                            goto exit_function;</a>
<a name="ln2882">                        }</a>
<a name="ln2883">                        /* in addition, permit N(V)=&gt;N(IV)(+) change by allowing charge flower edge change flow */</a>
<a name="ln2884">                        if ( bN_V &amp;&amp; NO_VERTEX != (j = GetChargeFlowerUpperEdge( pBNS, pVA, e )) &amp;&amp;</a>
<a name="ln2885">                             !pBNS-&gt;edge[j].forbidden &amp;&amp; !pBNS-&gt;edge[j].flow ) {</a>
<a name="ln2886">                            if ( (ret = AddToEdgeList( &amp;CurrEdges, j, INC_ADD_EDGE )) ) {</a>
<a name="ln2887">                                goto exit_function;</a>
<a name="ln2888">                            }</a>
<a name="ln2889">                        }</a>
<a name="ln2890">                    }</a>
<a name="ln2891">                }</a>
<a name="ln2892">            }</a>
<a name="ln2893">            if ( (num_try = inchi_min( num_SB_N_Neutr, num_DB_O )) ) {</a>
<a name="ln2894">                /* detected; attempt to fix */</a>
<a name="ln2895">                BNS_EDGE *pe_CMinus;</a>
<a name="ln2896">                SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln2897">                RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln2898">                delta = 1;</a>
<a name="ln2899">                for ( i = 0; i &lt; num_DB_O &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln2900">                    iat = iat_DB_O[i];</a>
<a name="ln2901">                    pe_CMinus = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln2902">                    pe_CMinus-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln2903"> </a>
<a name="ln2904">                    pe   = pBNS-&gt;edge + pBNS-&gt;vert[iat].iedge[0]; /* double bond O=...*/</a>
<a name="ln2905">                    if ( !pe-&gt;flow )</a>
<a name="ln2906">                        continue;</a>
<a name="ln2907">                    pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2908">                    pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2909"> </a>
<a name="ln2910">                    pe-&gt;forbidden |= forbidden_edge_mask; /* change bond O=X to O(rad)-X(rad) */</a>
<a name="ln2911">                    pe-&gt;flow -= delta;</a>
<a name="ln2912">                    pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2913">                    pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2914">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2915"> </a>
<a name="ln2916">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2917">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2918"> </a>
<a name="ln2919">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2920">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 2 ) {</a>
<a name="ln2921">                        /* Added (-) charge to =O and (+) charge to N =&gt; nDeltaCharge == 2 */</a>
<a name="ln2922">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2923">                        if ( ret &gt; 0 ) {</a>
<a name="ln2924">                            nNumRunBNS ++;</a>
<a name="ln2925">                            cur_success ++; /* 12 */</a>
<a name="ln2926">                        }</a>
<a name="ln2927">                    } else {</a>
<a name="ln2928">                        pe-&gt;flow += delta;</a>
<a name="ln2929">                        pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2930">                        pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2931">                        pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2932">                    }</a>
<a name="ln2933">                    pe-&gt;forbidden        &amp;= forbidden_edge_mask_inv; /* allow changes to O=X bond */</a>
<a name="ln2934">                    INCHI_HEAPCHK</a>
<a name="ln2935">                }</a>
<a name="ln2936">                RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2937">            }</a>
<a name="ln2938">            CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln2939">            if ( cur_success ) {</a>
<a name="ln2940">                tot_succes += cur_success;</a>
<a name="ln2941">                /* recalculate InChI from the structure */</a>
<a name="ln2942">                if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln2943">                                                                ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln2944">                    goto exit_function;</a>
<a name="ln2945">                }</a>
<a name="ln2946">                if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln2947">                    goto exit_function;</a>
<a name="ln2948">                }</a>
<a name="ln2949">                if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln2950">                    goto exit_function;  /* no fixed-H found */</a>
<a name="ln2951">                }</a>
<a name="ln2952">                if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln2953">                    goto exit_function;</a>
<a name="ln2954">                }</a>
<a name="ln2955">                if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln2956">                    goto exit_function; /* nothing to do */</a>
<a name="ln2957">                }</a>
<a name="ln2958">                break;</a>
<a name="ln2959">            } else</a>
<a name="ln2960">            if ( bOnly_N_V ) {</a>
<a name="ln2961">                bOnly_N_V = 0;</a>
<a name="ln2962">            } else {</a>
<a name="ln2963">                break;</a>
<a name="ln2964">            }</a>
<a name="ln2965">        }</a>
<a name="ln2966">    }</a>
<a name="ln2967"> </a>
<a name="ln2968">    if ( pc2i-&gt;nNumTgDiffMinus /*|| pc2i-&gt;nNumTgDiffH */ /* no ADP in InChI needed */ ) {</a>
<a name="ln2969">        /*--------------------------------------------------------------*/</a>
<a name="ln2970">        /*                         |                            |       */</a>
<a name="ln2971">        /* case 13: restored: O=AB=N=         original: (-)O-AB-N(+)=   */</a>
<a name="ln2972">        /* FixH:              0    0                     0        0     */</a>
<a name="ln2973">        /* MobH:              0    0                     0        0     */</a>
<a name="ln2974">        /*                        non-taut              taut   non-taut */</a>
<a name="ln2975">        /* O = O, S, Se, N; N = N, P, ...                               */</a>
<a name="ln2976">        /* t-group in original has same num. endpoints                  */</a>
<a name="ln2977">        /*       same num_H and less (-) than in the restored structure */</a>
<a name="ln2978">        /* original atom O is tautomeric, N is not taut in both         */</a>
<a name="ln2979">        /* original struct has 1 t-group; restored has less endpoints   */</a>
<a name="ln2980">        /*                             and/or possibly &gt;1 t-groups      */  </a>
<a name="ln2981">        /* Solution: separate charges between O= and -N&lt;                */</a>
<a name="ln2982">        /*           allow moving charge to N(V) to make it N(IV)(+)    */</a>
<a name="ln2983">        /*--------------------------------------------------------------*/</a>
<a name="ln2984">        int itg;</a>
<a name="ln2985">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln2986">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln2987">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln2988"> </a>
<a name="ln2989">        S_CHAR   *num_Fixed_H_Revrs = pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed? pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed : NULL;</a>
<a name="ln2990">        S_CHAR   *pnMobHRevrs = (pStruct-&gt;pOneINChI[1] &amp;&amp; pStruct-&gt;pOneINChI[1]-&gt;nNum_H)?</a>
<a name="ln2991">                                   pStruct-&gt;pOneINChI[1]-&gt;nNum_H : </a>
<a name="ln2992">                                (pStruct-&gt;pOneINChI[0] &amp;&amp; pStruct-&gt;pOneINChI[0]-&gt;nNum_H)?</a>
<a name="ln2993">                                   pStruct-&gt;pOneINChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln2994">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln2995">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln2996">        cur_success = 0;</a>
<a name="ln2997">        /* find whether this may help */</a>
<a name="ln2998">        for ( itg = 0; itg &lt; pStruct-&gt;ti.num_t_groups &amp;&amp; itg &lt; pStruct-&gt;One_ti.num_t_groups; itg ++ ) {</a>
<a name="ln2999">            if ( pStruct-&gt;ti.t_group[itg].nNumEndpoints == pStruct-&gt;One_ti.t_group[itg].nNumEndpoints &amp;&amp;</a>
<a name="ln3000">                 pStruct-&gt;ti.t_group[itg].num[0] - pStruct-&gt;ti.t_group[itg].num[1] == </a>
<a name="ln3001">                 pStruct-&gt;One_ti.t_group[itg].num[0] - pStruct-&gt;One_ti.t_group[itg].num[1] &amp;&amp;</a>
<a name="ln3002">                 pStruct-&gt;ti.t_group[itg].num[1] &gt; pStruct-&gt;One_ti.t_group[itg].num[1]) {</a>
<a name="ln3003">                /* restored InChI t-group has more (-) and same number of H */</a>
<a name="ln3004"> </a>
<a name="ln3005">                int num_SB_N_Neutr = 0, num_DB_O = 0, iat;</a>
<a name="ln3006">                short iat_SB_N_Neutr[MAX_DIFF_FIXH], iat_DB_O[MAX_DIFF_FIXH];</a>
<a name="ln3007">                cur_success = 0;</a>
<a name="ln3008">                for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln3009">                    iat = nCanon2AtnoRevrs[i];</a>
<a name="ln3010">                    if ( /* orig. InChI info: -O(-) */</a>
<a name="ln3011">                         num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3012">                         (pVA[i].cNumValenceElectrons == 6 /* O, S, Se, Te */ ) &amp;&amp;</a>
<a name="ln3013">                         pStruct-&gt;endpoint[i] == itg+1 &amp;&amp;</a>
<a name="ln3014">                         (e=pVA[i].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln3015">                         !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln3016">                         !(nMobHInChI &amp;&amp; nMobHInChI[i]) &amp;&amp;</a>
<a name="ln3017">                         /* reversed structure info: */</a>
<a name="ln3018">                         /*!pc2i-&gt;c2at[i].endptRevrs &amp;&amp;*/</a>
<a name="ln3019">                         !(num_Fixed_H_Revrs &amp;&amp; num_Fixed_H_Revrs[iat]) &amp;&amp;</a>
<a name="ln3020">                         !(pnMobHRevrs &amp;&amp; pnMobHRevrs[iat]) &amp;&amp;</a>
<a name="ln3021">                         at2[iat].charge == 0 &amp;&amp; at2[iat].num_H == 0 &amp;&amp;</a>
<a name="ln3022">                         at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 ) {</a>
<a name="ln3023">            </a>
<a name="ln3024">                        iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln3025">                        /*</a>
<a name="ln3026">                        if ( ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ) ) {</a>
<a name="ln3027">                            goto exit_function;</a>
<a name="ln3028">                        }</a>
<a name="ln3029">                        */</a>
<a name="ln3030">                    } else</a>
<a name="ln3031">                    if ( /* in restored atom N: charge=0, no H, has no double bond, not an endpoint */</a>
<a name="ln3032">                         num_SB_N_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3033">                         at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln3034">                         /*at2[iat].valence == at2[iat].chem_bonds_valence ||*/</a>
<a name="ln3035">                         (at2[iat].valence==4 &amp;&amp; at2[iat].chem_bonds_valence==5) &amp;&amp;</a>
<a name="ln3036">                         !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3037">                         pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber &gt;= 1 &amp;&amp;</a>
<a name="ln3038">                         !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint) &amp;&amp;</a>
<a name="ln3039">                         /* in orig.InChI: not an endpoint, has no H */</a>
<a name="ln3040">                         !pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln3041">                         !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln3042">                         !(nMobHInChI &amp;&amp; nMobHInChI[i]) &amp;&amp;</a>
<a name="ln3043">                         /* has (+) edge */</a>
<a name="ln3044">                         (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3045"> </a>
<a name="ln3046">                        iat_SB_N_Neutr[num_SB_N_Neutr ++] = iat;</a>
<a name="ln3047">                        if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln3048">                            goto exit_function;</a>
<a name="ln3049">                        }</a>
<a name="ln3050">                    }</a>
<a name="ln3051">                }</a>
<a name="ln3052">                if ( (num_try = inchi_min( num_SB_N_Neutr, num_DB_O )) ) {</a>
<a name="ln3053">                    /* detected; attempt to fix */</a>
<a name="ln3054">                    BNS_EDGE *pe_CMinus;</a>
<a name="ln3055">                    SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3056">                    RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln3057">                    delta = 1;</a>
<a name="ln3058">                    for ( i = 0; i &lt; num_DB_O &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln3059">                        iat = iat_DB_O[i];</a>
<a name="ln3060">                        pe_CMinus = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln3061">                        pe_CMinus-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln3062"> </a>
<a name="ln3063">                        pe   = pBNS-&gt;edge + pBNS-&gt;vert[iat].iedge[0]; /* double bond O=...*/</a>
<a name="ln3064">                        if ( !pe-&gt;flow )</a>
<a name="ln3065">                            continue;</a>
<a name="ln3066">                        pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3067">                        pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3068"> </a>
<a name="ln3069">                        pe-&gt;forbidden |= forbidden_edge_mask; /* change bond O=X to O(rad)-X(rad) */</a>
<a name="ln3070">                        pe-&gt;flow -= delta;</a>
<a name="ln3071">                        pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln3072">                        pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln3073">                        pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln3074"> </a>
<a name="ln3075">                        ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3076">                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3077"> </a>
<a name="ln3078">                        if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3079">                                          (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 2 ) {</a>
<a name="ln3080">                            /* Added (-) charge to =O and (+) charge to N =&gt; nDeltaCharge == 2 */</a>
<a name="ln3081">                            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3082">                            if ( ret &gt; 0 ) {</a>
<a name="ln3083">                                nNumRunBNS ++;</a>
<a name="ln3084">                                cur_success ++; /* 13 */</a>
<a name="ln3085">                            }</a>
<a name="ln3086">                        } else {</a>
<a name="ln3087">                            pe-&gt;flow += delta;</a>
<a name="ln3088">                            pv1-&gt;st_edge.flow += delta;</a>
<a name="ln3089">                            pv2-&gt;st_edge.flow += delta;</a>
<a name="ln3090">                            pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln3091">                        }</a>
<a name="ln3092">                        pe-&gt;forbidden        &amp;= forbidden_edge_mask_inv; /* allow changes to O=X bond */</a>
<a name="ln3093">                        INCHI_HEAPCHK</a>
<a name="ln3094">                    }</a>
<a name="ln3095">                    RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln3096">                }</a>
<a name="ln3097">                CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln3098">                if ( cur_success ) {</a>
<a name="ln3099">                    tot_succes += cur_success;</a>
<a name="ln3100">                    /* recalculate InChI from the structure */</a>
<a name="ln3101">                    if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln3102">                                                                    ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln3103">                        goto exit_function;</a>
<a name="ln3104">                    }</a>
<a name="ln3105">                    if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln3106">                        goto exit_function;</a>
<a name="ln3107">                    }</a>
<a name="ln3108">                    if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln3109">                        goto exit_function;  /* no fixed-H found */</a>
<a name="ln3110">                    }</a>
<a name="ln3111">                    if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln3112">                        goto exit_function;</a>
<a name="ln3113">                    }</a>
<a name="ln3114">                    if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln3115">                        goto exit_function; /* nothing to do */</a>
<a name="ln3116">                    }</a>
<a name="ln3117">                    break;</a>
<a name="ln3118">                }/* else</a>
<a name="ln3119">                if ( bOnly_N_V ) {</a>
<a name="ln3120">                    bOnly_N_V = 0;</a>
<a name="ln3121">                }</a>
<a name="ln3122">                */</a>
<a name="ln3123">                break;</a>
<a name="ln3124">            }</a>
<a name="ln3125">        }</a>
<a name="ln3126">    }</a>
<a name="ln3127"> </a>
<a name="ln3128">    if ( ((pc2i-&gt;nNumTgInChI &lt;= 1 &amp;&amp;</a>
<a name="ln3129">        pc2i-&gt;nNumRemHInChI &gt; pc2i-&gt;nNumRemHRevrs) || pc2i-&gt;len_c2at) &amp;&amp;</a>
<a name="ln3130">         bHas_N_V( at2, pStruct-&gt;num_atoms) ) {</a>
<a name="ln3131">        /*-----------------------------------------------------------------*/</a>
<a name="ln3132">        /*                         |                         |             */</a>
<a name="ln3133">        /* case 14: restored:-N=AB=N=CD-XH original: (-)N-AB-N(+)=CD-XH    */</a>
<a name="ln3134">        /* FixH:              0    0   0/1              0            1     */</a>
<a name="ln3135">        /* MobH:              0    0   1/0              0            0     */</a>
<a name="ln3136">        /*                   non-taut  n/t             any  non     any    */</a>
<a name="ln3137">        /*                                                  taut           */</a>
<a name="ln3138">        /* X = O, S, Se, N; N = N                                          */</a>
<a name="ln3139">        /* t-group in original may have more (-) than in restored          */</a>
<a name="ln3140">        /*       same num_H and less (-) than in the restored structure    */</a>
<a name="ln3141">        /* atom N(V)/N(IV)(+) is not taut in both                          */</a>
<a name="ln3142">        /* The following transformation should be possible:                */</a>
<a name="ln3143">        /*        |                         |                              */</a>
<a name="ln3144">        /*   N=AB=N=CD-XH    -&gt;     (-)N-AB-N-CD=XH(+)                     */</a>
<a name="ln3145">        /* This allows ADP to remove H(+) from -XH                         */</a>
<a name="ln3146">        /* As the result, the original structure has 0 or 1 t-group        */</a>
<a name="ln3147">        /* Solution: separate charges between -N(III)= and  N(V)           */</a>
<a name="ln3148">        /*-----------------------------------------------------------------*/</a>
<a name="ln3149">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln3150">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln3151">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln3152"> </a>
<a name="ln3153">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln3154">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln3155">        int num_N_V = 0, iat, i1, i2, i3, e1Flower, e1Plus, e2Plus, e2Minus, e3Plus;</a>
<a name="ln3156">        int max_success = pc2i-&gt;nNumRemHInChI - pc2i-&gt;nNumRemHRevrs;</a>
<a name="ln3157">        short iat_N_V_Array[MAX_DIFF_FIXH];</a>
<a name="ln3158">        EDGE_LIST iat_X_List, iat_N_III_List;</a>
<a name="ln3159">        AllocEdgeList( &amp;iat_X_List, EDGE_LIST_CLEAR );</a>
<a name="ln3160">        AllocEdgeList( &amp;iat_N_III_List, EDGE_LIST_CLEAR );</a>
<a name="ln3161">        cur_success = 0;</a>
<a name="ln3162">        ret = 0;</a>
<a name="ln3163">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln3164">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln3165">            /* search for N(V), 3 bonds */</a>
<a name="ln3166">            if ( /* restored structure */</a>
<a name="ln3167">                 num_N_V &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3168">                 at2[iat].chem_bonds_valence == 5 &amp;&amp; at2[iat].valence == 3 &amp;&amp;</a>
<a name="ln3169">                 !at2[iat].charge &amp;&amp; !at2[iat].radical &amp;&amp;</a>
<a name="ln3170">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln3171">                 !( at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[i].endpoint ) &amp;&amp;</a>
<a name="ln3172">                 !at2[iat].num_H &amp;&amp;</a>
<a name="ln3173">                 (e = pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln3174">                 pBNS-&gt;edge[e].flow /* no charge */ &amp;&amp;</a>
<a name="ln3175">                 NO_VERTEX != (j = GetChargeFlowerUpperEdge( pBNS, pVA, e )) &amp;&amp; !pBNS-&gt;edge[j].forbidden &amp;&amp;</a>
<a name="ln3176">                 !pBNS-&gt;edge[j].flow /* neutral, valence=5 */ &amp;&amp;</a>
<a name="ln3177">                 /* orig. InChI */</a>
<a name="ln3178">                 !pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln3179">                 !(nMobHInChI &amp;&amp; nMobHInChI[i]) &amp;&amp; !pStruct-&gt;fixed_H[i] ) {</a>
<a name="ln3180">                iat_N_V_Array[num_N_V ++] = iat;</a>
<a name="ln3181">            } else</a>
<a name="ln3182">            /* search for -N= */</a>
<a name="ln3183">            if ( /* restored structure */</a>
<a name="ln3184">                 at2[iat].chem_bonds_valence == 3 &amp;&amp; at2[iat].valence == 2 &amp;&amp;</a>
<a name="ln3185">                 !at2[iat].charge &amp;&amp; !at2[iat].radical &amp;&amp;</a>
<a name="ln3186">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln3187">                 !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[i].endpoint ) &amp;&amp;</a>
<a name="ln3188">                 !at2[iat].num_H &amp;&amp;</a>
<a name="ln3189">                 (e = pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln3190">                 !pBNS-&gt;edge[e].flow /* no charge */ &amp;&amp;</a>
<a name="ln3191">                 /* orig. InChI */</a>
<a name="ln3192">                 /*!pStruct-&gt;endpoint[i] &amp;&amp;*/</a>
<a name="ln3193">                 !(nMobHInChI &amp;&amp; nMobHInChI[i]) &amp;&amp; !pStruct-&gt;fixed_H[i] ) {</a>
<a name="ln3194"> </a>
<a name="ln3195">                if ( (ret = AddToEdgeList( &amp;iat_N_III_List, iat, 32 )) ) {</a>
<a name="ln3196">                    goto exit_case_14;</a>
<a name="ln3197">                }</a>
<a name="ln3198">            } else</a>
<a name="ln3199">            /* search for -OH -NH-, -NH2 */</a>
<a name="ln3200">            if ( /* restored structure */</a>
<a name="ln3201">                 at2[iat].chem_bonds_valence == at2[iat].valence &amp;&amp;</a>
<a name="ln3202">                 !at2[iat].charge &amp;&amp; !at2[iat].radical &amp;&amp;</a>
<a name="ln3203">                 ((pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1) ||</a>
<a name="ln3204">                 pVA[iat].cNumValenceElectrons == 6 ) &amp;&amp;</a>
<a name="ln3205">                 at2[iat].num_H &amp;&amp;</a>
<a name="ln3206">                 (e = pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln3207">                 pBNS-&gt;edge[e].flow /* no charge */ &amp;&amp;</a>
<a name="ln3208">                 /* orig. InChI */</a>
<a name="ln3209">                 !(nMobHInChI &amp;&amp; nMobHInChI[i]) &amp;&amp; pStruct-&gt;fixed_H[i] ) {</a>
<a name="ln3210"> </a>
<a name="ln3211">                if ( (ret = AddToEdgeList( &amp;iat_X_List, iat, 32 )) ) {</a>
<a name="ln3212">                    goto exit_case_14;</a>
<a name="ln3213">                }</a>
<a name="ln3214">            }</a>
<a name="ln3215">        }</a>
<a name="ln3216">        if ( !max_success ) {</a>
<a name="ln3217">            max_success = inchi_min( num_N_V, iat_N_III_List.num_edges );</a>
<a name="ln3218">            max_success = inchi_min( max_success, iat_X_List.num_edges );</a>
<a name="ln3219">        }</a>
<a name="ln3220">        if ( num_N_V &amp;&amp; iat_N_III_List.num_edges &amp;&amp; iat_X_List.num_edges ) {</a>
<a name="ln3221">            for ( i1 = 0; i1 &lt; num_N_V &amp;&amp; cur_success &lt; max_success; i1 ++ ) {</a>
<a name="ln3222">                int iat_N_V = iat_N_V_Array[i1];</a>
<a name="ln3223">                if ( NO_VERTEX == iat_N_V ||</a>
<a name="ln3224">                     0 &gt;= (e1Plus = pVA[iat_N_V].nCPlusGroupEdge-1) ||</a>
<a name="ln3225">                     NO_VERTEX == (e1Flower = GetChargeFlowerUpperEdge( pBNS, pVA, e1Plus )) ||</a>
<a name="ln3226">                     1 != pBNS-&gt;edge[e1Plus].flow ||</a>
<a name="ln3227">                     0 != pBNS-&gt;edge[e1Flower].flow ) {</a>
<a name="ln3228">                    continue;</a>
<a name="ln3229">                }</a>
<a name="ln3230">                for ( i2 = iat_N_III_List.num_edges-1; 0 &lt;= i2 &amp;&amp; cur_success &lt; max_success; i2 -- ) {</a>
<a name="ln3231">                    int iat_N_III = iat_N_III_List.pnEdges[i2];</a>
<a name="ln3232">                    if ( NO_VERTEX == iat_N_III ||</a>
<a name="ln3233">                         0 &gt;= (e2Minus = pVA[iat_N_III].nCMinusGroupEdge-1) ||</a>
<a name="ln3234">                         0 &gt;= (e2Plus  = pVA[iat_N_III].nCPlusGroupEdge-1) ||</a>
<a name="ln3235">                         0 != pBNS-&gt;edge[e2Minus].flow ||</a>
<a name="ln3236">                         1 != pBNS-&gt;edge[e2Plus].flow ) {</a>
<a name="ln3237">                        /* do not consider this atom anymore */</a>
<a name="ln3238">                        iat_N_III_List.pnEdges[i2] = NO_VERTEX;</a>
<a name="ln3239">                        continue;</a>
<a name="ln3240">                    }</a>
<a name="ln3241">                    for ( i3 = iat_X_List.num_edges-1; 0 &lt;= i3 &amp;&amp; cur_success &lt; max_success; i3 -- ) {</a>
<a name="ln3242">                        int iat_X = iat_X_List.pnEdges[i3];</a>
<a name="ln3243">                        BNS_VERTEX *pv1n, *pv2n;</a>
<a name="ln3244">                        BNS_EDGE   *pe1n, *pe2n, *pe1Plus, *pe2Minus, *pe3Plus;</a>
<a name="ln3245">                        Vertex      v1n, v2n;</a>
<a name="ln3246">                        ret = 0;</a>
<a name="ln3247">                        if ( NO_VERTEX == iat_X ||</a>
<a name="ln3248">                             0 &gt;= (e3Plus  = pVA[iat_X].nCPlusGroupEdge-1) ||</a>
<a name="ln3249">                             1 != pBNS-&gt;edge[e3Plus].flow ) {</a>
<a name="ln3250">                            /* do not consider this atom anymore */</a>
<a name="ln3251">                            iat_X_List.pnEdges[i3] = NO_VERTEX;</a>
<a name="ln3252">                            continue;</a>
<a name="ln3253">                        }</a>
<a name="ln3254">                        /* all is ready to check whether the following applies:</a>
<a name="ln3255">                           forbid changes of all charges and N,P,... flowers</a>
<a name="ln3256">                           allow to change edges: e2Minus, e3Plus</a>
<a name="ln3257">                           Increment flow in e1Flower</a>
<a name="ln3258">                           The result should be: increase in number of charges by 2</a>
<a name="ln3259">                        */</a>
<a name="ln3260">                        pe1Plus  = pBNS-&gt;edge + e1Plus;  /* N(V) positive charge edge */</a>
<a name="ln3261">                        pe2Minus = pBNS-&gt;edge + e2Minus; /* =N- negative charge edge */</a>
<a name="ln3262">                        pe3Plus  = pBNS-&gt;edge + e3Plus;  /* -XH positive charge edge */</a>
<a name="ln3263">                        pe       = pBNS-&gt;edge + e1Flower; /* N(V) flower edge */</a>
<a name="ln3264">                        pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3265">                        pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3266">                        for ( j = pv1-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln3267">                            pe1n = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln3268">                            if ( pe1n-&gt;flow &amp;&amp; !pe1n-&gt;forbidden &amp;&amp; pe1n != pe1Plus ) {</a>
<a name="ln3269">                                pv1n = pBNS-&gt;vert + (v1n = pe1n-&gt;neighbor12 ^ v1);</a>
<a name="ln3270">                                break;</a>
<a name="ln3271">                            }</a>
<a name="ln3272">                        }</a>
<a name="ln3273">                        if ( j &lt; 0 )</a>
<a name="ln3274">                            continue; /* not found -- should not happen */</a>
<a name="ln3275">                        for ( j = pv2-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) { /* was -2; changed 2006-2-28 12:35pm*/</a>
<a name="ln3276">                            pe2n = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln3277">                            if ( pe2n-&gt;flow &amp;&amp; !pe2n-&gt;forbidden &amp;&amp; pe2n != pe1Plus ) {</a>
<a name="ln3278">                                pv2n = pBNS-&gt;vert + (v2n = pe2n-&gt;neighbor12 ^ v2);</a>
<a name="ln3279">                                break;</a>
<a name="ln3280">                            }</a>
<a name="ln3281">                        }</a>
<a name="ln3282">                        if ( j &lt; 0 )</a>
<a name="ln3283">                            continue; /* not found -- should not happen */</a>
<a name="ln3284">                        delta = 1;</a>
<a name="ln3285">                        pe-&gt;flow           += delta;</a>
<a name="ln3286">                        pe1n-&gt;flow         -= delta;</a>
<a name="ln3287">                        pe2n-&gt;flow         -= delta;</a>
<a name="ln3288">                        pv1n-&gt;st_edge.flow -= delta;</a>
<a name="ln3289">                        pv2n-&gt;st_edge.flow -= delta;</a>
<a name="ln3290">                        pBNS-&gt;tot_st_flow  -= 2*delta;</a>
<a name="ln3291">                        </a>
<a name="ln3292">                        SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3293">                        SetForbiddenEdgeMask( pBNS, &amp;OtherNFlowerEdges, forbidden_edge_mask );</a>
<a name="ln3294"> </a>
<a name="ln3295">                        /* allow two charges to change */</a>
<a name="ln3296">                        pe2Minus-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln3297">                        pe3Plus-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln3298">                        /* test #1 */</a>
<a name="ln3299">                        ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3300">                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3301">                        INCHI_HEAPCHK</a>
<a name="ln3302">                        if ( ret &lt; 0 ) {</a>
<a name="ln3303">                            goto exit_case_14;</a>
<a name="ln3304">                        } else</a>
<a name="ln3305">                        if ( ret == 1 &amp;&amp; ((vPathEnd == v1n &amp;&amp; vPathStart == v2n) ||</a>
<a name="ln3306">                                          (vPathEnd == v2n &amp;&amp; vPathStart == v1n)) &amp;&amp;</a>
<a name="ln3307">                                          nDeltaCharge == 2 ) {</a>
<a name="ln3308">                            ; /* success */</a>
<a name="ln3309">                        } else {</a>
<a name="ln3310">                            ret = 0;</a>
<a name="ln3311">                        }</a>
<a name="ln3312">                        /* restore BNS */</a>
<a name="ln3313">                        pe2Minus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln3314">                        pe3Plus-&gt;forbidden  |= forbidden_edge_mask;</a>
<a name="ln3315">                        pe-&gt;flow           -= delta;</a>
<a name="ln3316">                        pe1n-&gt;flow         += delta;</a>
<a name="ln3317">                        pe2n-&gt;flow         += delta;</a>
<a name="ln3318">                        pv1n-&gt;st_edge.flow += delta;</a>
<a name="ln3319">                        pv2n-&gt;st_edge.flow += delta;</a>
<a name="ln3320">                        pBNS-&gt;tot_st_flow  += 2*delta;</a>
<a name="ln3321">                        if ( ret == 1 ) {</a>
<a name="ln3322">                            /* test #2: check if charge separation is possible */</a>
<a name="ln3323">                            pe-&gt;flow           += delta;</a>
<a name="ln3324">                            pe1n-&gt;flow         -= delta;</a>
<a name="ln3325">                            pe2n-&gt;flow         -= delta;</a>
<a name="ln3326">                            pv1n-&gt;st_edge.flow -= delta;</a>
<a name="ln3327">                            pv2n-&gt;st_edge.flow -= delta;</a>
<a name="ln3328">                            pBNS-&gt;tot_st_flow  -= 2*delta;</a>
<a name="ln3329"> </a>
<a name="ln3330">                            /* allow two charges (N(V) and N(III)) to change */</a>
<a name="ln3331">                            pe2Minus-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln3332">                            pe1Plus-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln3333">                            /* test #2 */</a>
<a name="ln3334">                            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3335">                                              &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3336">                            if ( ret == 1 &amp;&amp; ((vPathEnd == v1n &amp;&amp; vPathStart == v2n) ||</a>
<a name="ln3337">                                              (vPathEnd == v2n &amp;&amp; vPathStart == v1n)) &amp;&amp;</a>
<a name="ln3338">                                              nDeltaCharge == 2 ) {</a>
<a name="ln3339">                                /* success; actually change charges */</a>
<a name="ln3340">                                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3341">                                if ( ret &gt; 0 ) {</a>
<a name="ln3342">                                    nNumRunBNS ++;</a>
<a name="ln3343">                                    cur_success ++; /* 14 */</a>
<a name="ln3344">                                }</a>
<a name="ln3345">                            }</a>
<a name="ln3346">                            if ( ret &lt;= 0 ) {</a>
<a name="ln3347">                                /* failed: restore BNS flow */</a>
<a name="ln3348">                                pe-&gt;flow           -= delta;</a>
<a name="ln3349">                                pe1n-&gt;flow         += delta;</a>
<a name="ln3350">                                pe2n-&gt;flow         += delta;</a>
<a name="ln3351">                                pv1n-&gt;st_edge.flow += delta;</a>
<a name="ln3352">                                pv2n-&gt;st_edge.flow += delta;</a>
<a name="ln3353">                                pBNS-&gt;tot_st_flow  += 2*delta;</a>
<a name="ln3354">                            }</a>
<a name="ln3355">                            INCHI_HEAPCHK</a>
<a name="ln3356">                        }</a>
<a name="ln3357">                        RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln3358">                        RemoveForbiddenEdgeMask( pBNS, &amp;OtherNFlowerEdges, forbidden_edge_mask  );</a>
<a name="ln3359">                        if ( ret &gt; 0 ) {</a>
<a name="ln3360">                            /* do not repeat for the same atoms */</a>
<a name="ln3361">                            iat_N_V_Array[i1] = NO_VERTEX;</a>
<a name="ln3362">                            iat_N_III_List.pnEdges[i2] = NO_VERTEX;</a>
<a name="ln3363">                            iat_X_List.pnEdges[i3] = NO_VERTEX;</a>
<a name="ln3364">                        }</a>
<a name="ln3365">                        if ( ret &lt; 0 ) {</a>
<a name="ln3366">                            goto exit_case_14;</a>
<a name="ln3367">                        }</a>
<a name="ln3368">                        if ( ret &gt; 0 ) {</a>
<a name="ln3369">                            break;</a>
<a name="ln3370">                        }</a>
<a name="ln3371">                    } /* i3 cycle */</a>
<a name="ln3372">                    if ( ret &gt; 0 ) {</a>
<a name="ln3373">                        break;</a>
<a name="ln3374">                    }</a>
<a name="ln3375">                } /* i2 cycle */</a>
<a name="ln3376">            }</a>
<a name="ln3377">        }</a>
<a name="ln3378">exit_case_14:</a>
<a name="ln3379">        AllocEdgeList( &amp;iat_X_List, EDGE_LIST_FREE );</a>
<a name="ln3380">        AllocEdgeList( &amp;iat_N_III_List, EDGE_LIST_FREE );</a>
<a name="ln3381">        RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln3382">        RemoveForbiddenEdgeMask( pBNS, &amp;OtherNFlowerEdges, forbidden_edge_mask  );</a>
<a name="ln3383">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln3384">        if ( ret &lt; 0 ) {</a>
<a name="ln3385">            goto exit_function;</a>
<a name="ln3386">        }</a>
<a name="ln3387">        if ( cur_success ) {</a>
<a name="ln3388">            tot_succes += cur_success;</a>
<a name="ln3389">            /* recalculate InChI from the structure */</a>
<a name="ln3390">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln3391">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln3392">                goto exit_function;</a>
<a name="ln3393">            }</a>
<a name="ln3394">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln3395">                goto exit_function;</a>
<a name="ln3396">            }</a>
<a name="ln3397">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln3398">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln3399">            }</a>
<a name="ln3400">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln3401">                goto exit_function;</a>
<a name="ln3402">            }</a>
<a name="ln3403">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln3404">                goto exit_function; /* nothing to do */</a>
<a name="ln3405">            }</a>
<a name="ln3406">        }</a>
<a name="ln3407">    }</a>
<a name="ln3408"> </a>
<a name="ln3409"> </a>
<a name="ln3410">    if ( pc2i-&gt;nNumTgMRevrs &gt; pc2i-&gt;nNumTgMInChI ||</a>
<a name="ln3411">         pc2i-&gt;nNumRemHRevrs &lt; pc2i-&gt;nNumRemHInChI ||</a>
<a name="ln3412">         pc2i-&gt;nNumEndpRevrs &lt; pc2i-&gt;nNumEndpInChI ||</a>
<a name="ln3413">         (pc2i-&gt;nNumTgInChI &lt;= 1 &amp;&amp; pc2i-&gt;nNumTgRevrs &gt; pc2i-&gt;nNumTgInChI) ) {</a>
<a name="ln3414">        /*--------------------------------------------------------------*/</a>
<a name="ln3415">        /* case 15: restored: -(+)O=AB-N&lt;  orig: -O-AB=N(+)&lt;            */</a>
<a name="ln3416">        /* (a) restored t-groups have more (-) than in original InChI   */</a>
<a name="ln3417">        /* (b) Mobile-H    charge: restored &gt; original InChI *and*      */</a>
<a name="ln3418">        /*              removed H: restored &lt; original InChI            */</a>
<a name="ln3419">        /* (c) restored t-groups have less endpnoits than in orig InChI */</a>
<a name="ln3420">        /* O = O, S, Se, Te; N = N                                      */</a>
<a name="ln3421">        /* Solution: move (+) from -O(+)= to -N&lt;                        */</a>
<a name="ln3422">        /*--------------------------------------------------------------*/</a>
<a name="ln3423">        int num_SB_Neutr = 0, num_DB_Charged = 0, iat;</a>
<a name="ln3424">        short iat_SB_Neutr[MAX_DIFF_FIXH], iat_DB_Charged[MAX_DIFF_FIXH];</a>
<a name="ln3425">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln3426">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln3427">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln3428">        cur_success = 0;</a>
<a name="ln3429">        /* search for -O(+)= */</a>
<a name="ln3430">        /* search for -N&lt; */</a>
<a name="ln3431">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln3432">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln3433">            if ( /* -O(+)= in restored atom: charge=1, has no H, a double bond */</a>
<a name="ln3434">                 num_DB_Charged &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3435">                 at2[iat].charge == 1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln3436">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3437">                 (pVA[iat].cNumValenceElectrons == 6 ) &amp;&amp;</a>
<a name="ln3438">                 /* in orig.InChI: an endpoint, has fixed-H */</a>
<a name="ln3439">                 /*pStruct-&gt;endpoint[i] &amp;&amp;*/</a>
<a name="ln3440">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln3441">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln3442">                 /* has (+) edge */</a>
<a name="ln3443">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3444"> </a>
<a name="ln3445">                iat_DB_Charged[num_DB_Charged ++] = iat;</a>
<a name="ln3446">                /*</a>
<a name="ln3447">                if ( ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ) ) {</a>
<a name="ln3448">                    goto exit_function;</a>
<a name="ln3449">                }</a>
<a name="ln3450">                */</a>
<a name="ln3451">            } else</a>
<a name="ln3452">            if ( /* -N&lt; in restored atom: charge=0, has no H, has no double bond, N only */</a>
<a name="ln3453">                 num_SB_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3454">                 at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln3455">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3456">                 (pVA[iat].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln3457">                  pVA[iat].cPeriodicRowNumber == 1 ) &amp;&amp;</a>
<a name="ln3458">                 /* in orig.InChI: an endpoint, has fixed-H */</a>
<a name="ln3459">                 /*pStruct-&gt;endpoint[i] &amp;&amp;*/</a>
<a name="ln3460">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln3461">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln3462">                 /* has (+) edge */</a>
<a name="ln3463">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3464"> </a>
<a name="ln3465">                iat_SB_Neutr[num_SB_Neutr ++] = iat;</a>
<a name="ln3466">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln3467">                    goto exit_function;</a>
<a name="ln3468">                }</a>
<a name="ln3469">            }</a>
<a name="ln3470">        }</a>
<a name="ln3471">        if ( (num_try = inchi_min( num_SB_Neutr, num_DB_Charged )) ) {</a>
<a name="ln3472">            /* detected; attempt to fix */</a>
<a name="ln3473">            BNS_VERTEX *pv1n, *pv2n;</a>
<a name="ln3474">            BNS_EDGE   *pe1n, *pe2n;</a>
<a name="ln3475">            Vertex      v1n, v2n;</a>
<a name="ln3476">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3477">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln3478">            delta = 1;</a>
<a name="ln3479">            for ( i = 0; i &lt; num_DB_Charged &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln3480">                iat = iat_DB_Charged[i];</a>
<a name="ln3481">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln3482">                if ( pe-&gt;flow )</a>
<a name="ln3483">                    continue;</a>
<a name="ln3484">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3485">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3486"> </a>
<a name="ln3487">                for ( j = pv1-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln3488">                    pe1n = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln3489">                    if ( pe1n-&gt;flow &amp;&amp; !pe1n-&gt;forbidden ) {</a>
<a name="ln3490">                        pv1n = pBNS-&gt;vert + (v1n = pe1n-&gt;neighbor12 ^ v1);</a>
<a name="ln3491">                        break;</a>
<a name="ln3492">                    }</a>
<a name="ln3493">                }</a>
<a name="ln3494">                if ( j &lt; 0 )</a>
<a name="ln3495">                    continue; /* not found */</a>
<a name="ln3496">                </a>
<a name="ln3497">                for ( j = pv2-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) { /* was -2; changed 2006-2-28 12:35pm*/</a>
<a name="ln3498">                    pe2n = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln3499">                    if ( pe2n-&gt;flow &amp;&amp; !pe2n-&gt;forbidden ) {</a>
<a name="ln3500">                        pv2n = pBNS-&gt;vert + (v2n = pe2n-&gt;neighbor12 ^ v2);</a>
<a name="ln3501">                        break;</a>
<a name="ln3502">                    }</a>
<a name="ln3503">                }</a>
<a name="ln3504">                if ( j &lt; 0 )</a>
<a name="ln3505">                    continue; /* not found */</a>
<a name="ln3506"> </a>
<a name="ln3507">                pe-&gt;flow   += delta;</a>
<a name="ln3508">                pe1n-&gt;flow -= delta;</a>
<a name="ln3509">                pe2n-&gt;flow -= delta;</a>
<a name="ln3510">                pv1n-&gt;st_edge.flow -= delta;</a>
<a name="ln3511">                pv2n-&gt;st_edge.flow -= delta;</a>
<a name="ln3512">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln3513"> </a>
<a name="ln3514">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3515">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3516"> </a>
<a name="ln3517">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1n &amp;&amp; vPathStart == v2n) ||</a>
<a name="ln3518">                                  (vPathEnd == v2n &amp;&amp; vPathStart == v1n)) &amp;&amp;</a>
<a name="ln3519">                                  (nDeltaCharge == 0 || nDeltaCharge == 1) ) {</a>
<a name="ln3520">                    /* Moved charge from O(+) to -N&lt; =&gt; nDeltaCharge == 1 or 0 if pe2n = -N&lt; charge edge */</a>
<a name="ln3521">                    /* Flow change on pe (+)charge edge (atom NH2) is not known to RunBnsTestOnce()) */</a>
<a name="ln3522">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3523">                    if ( ret &gt; 0 ) {</a>
<a name="ln3524">                        nNumRunBNS ++;</a>
<a name="ln3525">                        cur_success ++; /* 15 */</a>
<a name="ln3526">                    }</a>
<a name="ln3527">                } else {</a>
<a name="ln3528">                    pe-&gt;flow   -= delta;</a>
<a name="ln3529">                    pe1n-&gt;flow += delta;</a>
<a name="ln3530">                    pe2n-&gt;flow += delta;</a>
<a name="ln3531">                    pv1n-&gt;st_edge.flow += delta;</a>
<a name="ln3532">                    pv2n-&gt;st_edge.flow += delta;</a>
<a name="ln3533">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln3534">                }</a>
<a name="ln3535">                INCHI_HEAPCHK</a>
<a name="ln3536">            }</a>
<a name="ln3537">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln3538">        }</a>
<a name="ln3539">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln3540">        if ( cur_success ) {</a>
<a name="ln3541">            tot_succes += cur_success;</a>
<a name="ln3542">            /* recalculate InChI from the structure */</a>
<a name="ln3543">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln3544">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln3545">                goto exit_function;</a>
<a name="ln3546">            }</a>
<a name="ln3547">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln3548">                goto exit_function;</a>
<a name="ln3549">            }</a>
<a name="ln3550">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln3551">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln3552">            }</a>
<a name="ln3553">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln3554">                goto exit_function;</a>
<a name="ln3555">            }</a>
<a name="ln3556">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln3557">                goto exit_function; /* nothing to do */</a>
<a name="ln3558">            }</a>
<a name="ln3559">        }</a>
<a name="ln3560">    }</a>
<a name="ln3561"> </a>
<a name="ln3562">    if ( pc2i-&gt;nNumTgDiffMinus ) {</a>
<a name="ln3563">        /*----------------------------------------------------------------*/</a>
<a name="ln3564">        /* case 16: restored: O=X-NH(-)      orig.:  O(-)-X=NH            */</a>
<a name="ln3565">        /*            t-group: (H,-)                  (2H)                */</a>
<a name="ln3566">        /* O(-) = S, Se, Te; N = N;                                       */</a>
<a name="ln3567">        /* Solution: move (-) from O(-) to -NH(-)                         */</a>
<a name="ln3568">        /*----------------------------------------------------------------*/</a>
<a name="ln3569">        int num_SB_N_Minus = 0, num_DB_O_Neutr = 0, iat, itg;</a>
<a name="ln3570">        short iat_SB_N_Minus[MAX_DIFF_FIXH], iat_DB_O_Neutr[MAX_DIFF_FIXH];</a>
<a name="ln3571">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln3572">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln3573">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln3574">        cur_success = 0;</a>
<a name="ln3575">        for ( itg = 0; itg &lt; pStruct-&gt;ti.num_t_groups &amp;&amp; itg &lt; pStruct-&gt;One_ti.num_t_groups; itg ++ ) {</a>
<a name="ln3576">            if ( pStruct-&gt;ti.t_group[itg].nNumEndpoints != pStruct-&gt;One_ti.t_group[itg].nNumEndpoints ||</a>
<a name="ln3577">                 pStruct-&gt;ti.t_group[itg].num[1]  &gt;= pStruct-&gt;One_ti.t_group[itg].num[1] ) {</a>
<a name="ln3578">                continue;</a>
<a name="ln3579">            }</a>
<a name="ln3580">            CurrEdges.num_edges = num_SB_N_Minus = num_DB_O_Neutr = 0;</a>
<a name="ln3581">            cur_success = 0;</a>
<a name="ln3582">            for ( j = 0, k = pStruct-&gt;One_ti.t_group[itg].nFirstEndpointAtNoPos;</a>
<a name="ln3583">                    j &lt; pStruct-&gt;One_ti.t_group[itg].nNumEndpoints; j ++ ) {</a>
<a name="ln3584">                i = pStruct-&gt;One_ti.nEndpointAtomNumber[k+j]; /* canonical number in restored struct. */</a>
<a name="ln3585">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln3586">                if ( /* in restored atom: charge=0, has no H, has double bond, O, S, Se, Te */</a>
<a name="ln3587">                     num_DB_O_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3588">                     at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln3589">                     at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3590">                     pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln3591">                     /* in orig.InChI: an endpoint, may have fixed-H */</a>
<a name="ln3592">                     pStruct-&gt;endpoint[i] &amp;&amp; </a>
<a name="ln3593">                     /*!(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;*/</a>
<a name="ln3594">                     !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln3595">                     /* has (-) edge */</a>
<a name="ln3596">                     (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3597"> </a>
<a name="ln3598">                    iat_DB_O_Neutr[num_DB_O_Neutr ++] = iat;</a>
<a name="ln3599">                    </a>
<a name="ln3600">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln3601">                        goto exit_function;</a>
<a name="ln3602">                    }</a>
<a name="ln3603">                    </a>
<a name="ln3604">                } else</a>
<a name="ln3605">                if ( /* in restored atom: charge=-1, has H, has double bond, N */</a>
<a name="ln3606">                     num_SB_N_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3607">                     at2[iat].charge == -1 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln3608">                     at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3609">                     pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln3610">                     /* in orig.InChI: an endpoint, has no fixed-H */</a>
<a name="ln3611">                     pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln3612">                     (pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln3613">                     !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln3614">                     /* has (-) edge */</a>
<a name="ln3615">                     (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln3616">                     0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3617"> </a>
<a name="ln3618">                    iat_SB_N_Minus[num_SB_N_Minus ++] = iat;</a>
<a name="ln3619">                    /*</a>
<a name="ln3620">                    if ( ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ) ) {</a>
<a name="ln3621">                        goto exit_function;</a>
<a name="ln3622">                    }</a>
<a name="ln3623">                    */</a>
<a name="ln3624">                }</a>
<a name="ln3625">            }</a>
<a name="ln3626">            if ( (num_try = inchi_min( num_SB_N_Minus, num_DB_O_Neutr )) ) {</a>
<a name="ln3627">                /* detected; attempt to fix */</a>
<a name="ln3628">                SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3629">                RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln3630">                /* allow stereobonds in rings change */</a>
<a name="ln3631">                /*</a>
<a name="ln3632">                if ( forbidden_stereo_edge_mask )</a>
<a name="ln3633">                    RemoveForbiddenEdgeMask( pBNS, &amp;FixedLargeRingStereoEdges, forbidden_stereo_edge_mask );</a>
<a name="ln3634">                */</a>
<a name="ln3635">                delta = 1;</a>
<a name="ln3636">                for ( i = 0; i &lt; num_SB_N_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln3637">                    iat = iat_SB_N_Minus[i];</a>
<a name="ln3638">                    pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln3639">                    if ( !pe-&gt;flow )</a>
<a name="ln3640">                        continue;</a>
<a name="ln3641">                    pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3642">                    pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3643"> </a>
<a name="ln3644">                    /*pe-&gt;forbidden |= forbidden_edge_mask;*/</a>
<a name="ln3645">                    pe-&gt;flow -= delta;</a>
<a name="ln3646">                    pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln3647">                    pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln3648">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln3649"> </a>
<a name="ln3650">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3651">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3652"> </a>
<a name="ln3653">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3654">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln3655">                        /* Moved (-) charge to =O =&gt; nDeltaCharge == 1 */</a>
<a name="ln3656">                        /* Flow change on pe (-)charge edge (atom -NH(-)) is not known to RunBnsTestOnce()) */</a>
<a name="ln3657">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3658">                        if ( ret &gt; 0 ) {</a>
<a name="ln3659">                            nNumRunBNS ++;</a>
<a name="ln3660">                            cur_success ++; /* 16 */</a>
<a name="ln3661">                        }</a>
<a name="ln3662">                    } else {</a>
<a name="ln3663">                        pe-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln3664">                        pe-&gt;flow += delta;</a>
<a name="ln3665">                        pv1-&gt;st_edge.flow += delta;</a>
<a name="ln3666">                        pv2-&gt;st_edge.flow += delta;</a>
<a name="ln3667">                        pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln3668">                    }</a>
<a name="ln3669">                    INCHI_HEAPCHK</a>
<a name="ln3670">                }</a>
<a name="ln3671">                RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3672">                /*</a>
<a name="ln3673">                if ( forbidden_stereo_edge_mask )</a>
<a name="ln3674">                    SetForbiddenEdgeMask( pBNS, &amp;FixedLargeRingStereoEdges, forbidden_stereo_edge_mask );</a>
<a name="ln3675">                */</a>
<a name="ln3676">            }</a>
<a name="ln3677">            CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln3678">            if ( cur_success ) {</a>
<a name="ln3679">                tot_succes += cur_success;</a>
<a name="ln3680">                /* recalculate InChI from the structure */</a>
<a name="ln3681">                if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln3682">                                                                ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln3683">                    goto exit_function;</a>
<a name="ln3684">                }</a>
<a name="ln3685">                if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln3686">                    goto exit_function;</a>
<a name="ln3687">                }</a>
<a name="ln3688">                if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln3689">                    goto exit_function;  /* no fixed-H found */</a>
<a name="ln3690">                }</a>
<a name="ln3691">                if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln3692">                    goto exit_function;</a>
<a name="ln3693">                }</a>
<a name="ln3694">                if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln3695">                    goto exit_function; /* nothing to do */</a>
<a name="ln3696">                }</a>
<a name="ln3697">            }</a>
<a name="ln3698">        }</a>
<a name="ln3699">    }</a>
<a name="ln3700"> </a>
<a name="ln3701">    if ( pc2i-&gt;nNumRemHInChI &lt; pc2i-&gt;nNumRemHRevrs ) {</a>
<a name="ln3702">        /*--------------------------------------------------------------*/</a>
<a name="ln3703">        /* case 17: restored: OH(+)=AB-O-     orig.  HO-AB=O(+)-        */</a>
<a name="ln3704">        /* number of removed H:  n+m                     n              */</a>
<a name="ln3705">        /* OH(+) = N, O, S, Se; -O- = P,As,O,S,Se,Te,F,Cl,Br,I          */</a>
<a name="ln3706">        /* Solution: move (+) from OH(+) to -O-                         */</a>
<a name="ln3707">        /*--------------------------------------------------------------*/</a>
<a name="ln3708">        int num_SB_Neutr = 0, num_DB_Charged = 0, iat;</a>
<a name="ln3709">        short iat_SB_Neutr[MAX_DIFF_FIXH], iat_DB_Charged[MAX_DIFF_FIXH];</a>
<a name="ln3710">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln3711">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln3712">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln3713">        cur_success = 0;</a>
<a name="ln3714">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln3715">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln3716">            if ( /* in restored atom: charge=+1, has H, has double bond, N, O, S, Se, Te */</a>
<a name="ln3717">                 num_DB_Charged &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3718">                 at2[iat].charge == 1 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln3719">                 at2[iat].valence &lt; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3720">                 (pVA[iat].cNumValenceElectrons == 6 ||</a>
<a name="ln3721">                  (pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1)) &amp;&amp;</a>
<a name="ln3722">                 /* has (+) edge */</a>
<a name="ln3723">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3724"> </a>
<a name="ln3725">                iat_DB_Charged[num_DB_Charged ++] = iat;</a>
<a name="ln3726">                /*</a>
<a name="ln3727">                if ( ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE ) ) {</a>
<a name="ln3728">                    goto exit_function;</a>
<a name="ln3729">                }</a>
<a name="ln3730">                */</a>
<a name="ln3731">            } else</a>
<a name="ln3732">            if ( /* in restored atom: charge=0, has no H, has no double bond, N, P, O, S, Se, Te */</a>
<a name="ln3733">                 num_SB_Neutr &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln3734">                 at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln3735">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln3736">                 (pVA[iat].cNumValenceElectrons == 6 || pVA[iat].cNumValenceElectrons == 7 ||</a>
<a name="ln3737">                  (pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber &gt; 1) ) &amp;&amp;</a>
<a name="ln3738">                 /* in orig.InChI: not an endpoint */</a>
<a name="ln3739">                 !pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln3740">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln3741">                 !(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;</a>
<a name="ln3742">                 /* has (+) edge */</a>
<a name="ln3743">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln3744">                 0 == pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln3745"> </a>
<a name="ln3746">                iat_SB_Neutr[num_SB_Neutr ++] = iat;</a>
<a name="ln3747">                </a>
<a name="ln3748">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln3749">                    goto exit_function;</a>
<a name="ln3750">                }</a>
<a name="ln3751">            }</a>
<a name="ln3752">        }</a>
<a name="ln3753">        if ( (num_try = inchi_min( num_SB_Neutr, num_DB_Charged )) ) {</a>
<a name="ln3754">            BNS_VERTEX *pv1n, *pv2n;</a>
<a name="ln3755">            BNS_EDGE   *pe1n, *pe2n;</a>
<a name="ln3756">            Vertex      v1n, v2n;</a>
<a name="ln3757"> </a>
<a name="ln3758">            num_try = inchi_min( num_try, pc2i-&gt;nNumRemHRevrs-pc2i-&gt;nNumRemHInChI);</a>
<a name="ln3759">            /* detected; attempt to fix */</a>
<a name="ln3760">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3761">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln3762">            delta = 1;</a>
<a name="ln3763">            for ( i = 0; i &lt; num_DB_Charged &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln3764">                iat = iat_DB_Charged[i];</a>
<a name="ln3765">                pe   = pBNS-&gt;edge + pVA[iat].nCPlusGroupEdge-1;</a>
<a name="ln3766">                if ( pe-&gt;flow )</a>
<a name="ln3767">                    continue;</a>
<a name="ln3768">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3769">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3770"> </a>
<a name="ln3771">                for ( j = pv1-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln3772">                    pe1n = pBNS-&gt;edge + pv1-&gt;iedge[j];</a>
<a name="ln3773">                    if ( pe1n-&gt;flow &amp;&amp; !pe1n-&gt;forbidden ) {</a>
<a name="ln3774">                        pv1n = pBNS-&gt;vert + (v1n = pe1n-&gt;neighbor12 ^ v1);</a>
<a name="ln3775">                        break;</a>
<a name="ln3776">                    }</a>
<a name="ln3777">                }</a>
<a name="ln3778">                if ( j &lt; 0 )</a>
<a name="ln3779">                    continue; /* not found */</a>
<a name="ln3780">                </a>
<a name="ln3781">                for ( j = pv2-&gt;num_adj_edges-1; 0 &lt;= j; j -- ) { /* was -2; changed 2006-2-28 12:35pm*/</a>
<a name="ln3782">                    pe2n = pBNS-&gt;edge + pv2-&gt;iedge[j];</a>
<a name="ln3783">                    if ( pe2n-&gt;flow &amp;&amp; !pe2n-&gt;forbidden ) {</a>
<a name="ln3784">                        pv2n = pBNS-&gt;vert + (v2n = pe2n-&gt;neighbor12 ^ v2);</a>
<a name="ln3785">                        break;</a>
<a name="ln3786">                    }</a>
<a name="ln3787">                }</a>
<a name="ln3788">                if ( j &lt; 0 )</a>
<a name="ln3789">                    continue; /* not found */</a>
<a name="ln3790"> </a>
<a name="ln3791">                pe-&gt;flow   += delta;</a>
<a name="ln3792">                pe1n-&gt;flow -= delta;</a>
<a name="ln3793">                pe2n-&gt;flow -= delta;</a>
<a name="ln3794">                pv1n-&gt;st_edge.flow -= delta;</a>
<a name="ln3795">                pv2n-&gt;st_edge.flow -= delta;</a>
<a name="ln3796">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln3797"> </a>
<a name="ln3798">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3799">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3800"> </a>
<a name="ln3801">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1n &amp;&amp; vPathStart == v2n) ||</a>
<a name="ln3802">                                  (vPathEnd == v2n &amp;&amp; vPathStart == v1n)) &amp;&amp;</a>
<a name="ln3803">                                  (nDeltaCharge == 0 || nDeltaCharge == 1) ) {</a>
<a name="ln3804">                    /* Moved charge from OH(+) to -O- =&gt; nDeltaCharge == 1 or 0 if pe2n = -O- charge edge */</a>
<a name="ln3805">                    /* Flow change on pe (+)charge edge (atom OH(+)) is not known to RunBnsTestOnce()) */</a>
<a name="ln3806">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3807">                    if ( ret &gt; 0 ) {</a>
<a name="ln3808">                        nNumRunBNS ++;</a>
<a name="ln3809">                        cur_success ++; /* 17 */</a>
<a name="ln3810">                    }</a>
<a name="ln3811">                } else {</a>
<a name="ln3812">                    pe-&gt;flow   -= delta;</a>
<a name="ln3813">                    pe1n-&gt;flow += delta;</a>
<a name="ln3814">                    pe2n-&gt;flow += delta;</a>
<a name="ln3815">                    pv1n-&gt;st_edge.flow += delta;</a>
<a name="ln3816">                    pv2n-&gt;st_edge.flow += delta;</a>
<a name="ln3817">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln3818">                }</a>
<a name="ln3819">                INCHI_HEAPCHK</a>
<a name="ln3820">            }</a>
<a name="ln3821">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln3822">        }</a>
<a name="ln3823">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln3824">        if ( cur_success ) {</a>
<a name="ln3825">            tot_succes += cur_success;</a>
<a name="ln3826">            /* recalculate InChI from the structure */</a>
<a name="ln3827">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln3828">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln3829">                goto exit_function;</a>
<a name="ln3830">            }</a>
<a name="ln3831">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln3832">                goto exit_function;</a>
<a name="ln3833">            }</a>
<a name="ln3834">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln3835">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln3836">            }</a>
<a name="ln3837">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln3838">                goto exit_function;</a>
<a name="ln3839">            }</a>
<a name="ln3840">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln3841">                goto exit_function; /* nothing to do */</a>
<a name="ln3842">            }</a>
<a name="ln3843">        }</a>
<a name="ln3844">    }</a>
<a name="ln3845"> </a>
<a name="ln3846">    if ( (pc2i-&gt;nNumTgInChI &amp;&amp; pStruct-&gt;endpoint &amp;&amp;</a>
<a name="ln3847">         pc2i-&gt;nNumTgMInChI &gt; pc2i-&gt;nNumTgMRevrs &amp;&amp; pc2i-&gt;nNumEndpInChI &gt; pc2i-&gt;nNumEndpRevrs ) ) {</a>
<a name="ln3848">        /*-----------------------------------------------------------------*/</a>
<a name="ln3849">        /*                                                                 */</a>
<a name="ln3850">        /* case 18: restored:-N=AB-X                -(-)N-AB-X(+)          */</a>
<a name="ln3851">        /* FixH:              0    0                    0    0             */</a>
<a name="ln3852">        /* MobH:              0    0                    0    0             */</a>
<a name="ln3853">        /*                   non  non                 taut  non            */</a>
<a name="ln3854">        /*                  taut  taut                      taut           */</a>
<a name="ln3855">        /* X = any heteroatom   N=N                                        */</a>
<a name="ln3856">        /* t-group in original has (Hn,-m) in the restored: (Hn,-m+1)      */</a>
<a name="ln3857">        /*       same num_H and more (-) than in the restored structure    */</a>
<a name="ln3858">        /* atom X is not taut in both                                      */</a>
<a name="ln3859">        /* Solution: separate charges between -N(III)= and  X              */</a>
<a name="ln3860">        /*-----------------------------------------------------------------*/</a>
<a name="ln3861">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln3862">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln3863">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln3864">        int iat, e1, itg, max_success;</a>
<a name="ln3865">        CurrEdges.num_edges = 0;</a>
<a name="ln3866">        cur_success = 0;</a>
<a name="ln3867">        ret = 0;</a>
<a name="ln3868">        /* search for -N= */</a>
<a name="ln3869">        for ( itg = 0; itg &lt; pStruct-&gt;ti.num_t_groups &amp;&amp; itg &lt; pStruct-&gt;One_ti.num_t_groups; itg ++ ) {</a>
<a name="ln3870">            if ( pStruct-&gt;ti.t_group[itg].nNumEndpoints &lt;= pStruct-&gt;One_ti.t_group[itg].nNumEndpoints ||</a>
<a name="ln3871">                 pStruct-&gt;ti.t_group[itg].num[1]  &lt;= pStruct-&gt;One_ti.t_group[itg].num[1] ) {</a>
<a name="ln3872">                     continue;</a>
<a name="ln3873">            }</a>
<a name="ln3874">            CurrEdges.num_edges = 0;</a>
<a name="ln3875">            cur_success = 0;</a>
<a name="ln3876">            for ( j = 0, k = pStruct-&gt;ti.t_group[itg].nFirstEndpointAtNoPos;</a>
<a name="ln3877">                    j &lt; pStruct-&gt;ti.t_group[itg].nNumEndpoints; j ++ ) {</a>
<a name="ln3878">                i = pStruct-&gt;ti.nEndpointAtomNumber[k+j]; /* canonical number in restored struct. */</a>
<a name="ln3879">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln3880">                if ( !pStruct-&gt;endpoint[i] || !at_Mobile_H_Revrs || at_Mobile_H_Revrs[iat].endpoint ||</a>
<a name="ln3881">                     pVA[i].cNumValenceElectrons != 5 || pVA[i].cPeriodicRowNumber != 1 ||</a>
<a name="ln3882">                     2 != at2[iat].valence || at2[iat].num_H || at2[iat].radical ||</a>
<a name="ln3883">                     (0 &lt;= (e1=pVA[iat].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e1].flow) ||</a>
<a name="ln3884">                     0 &gt; (e=pVA[iat].nCMinusGroupEdge-1) || pBNS-&gt;edge[e].forbidden || pBNS-&gt;edge[e].flow ) {</a>
<a name="ln3885">                    continue;</a>
<a name="ln3886">                }</a>
<a name="ln3887">                /* found -N= */</a>
<a name="ln3888">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln3889">                    goto exit_function;</a>
<a name="ln3890">                }</a>
<a name="ln3891">            }</a>
<a name="ln3892">        }</a>
<a name="ln3893">        if ( !(max_success = CurrEdges.num_edges) ) {</a>
<a name="ln3894">            goto exit_case_18;</a>
<a name="ln3895">        }</a>
<a name="ln3896">        /* search for X */</a>
<a name="ln3897">        for ( i = 0; i &lt; pStruct-&gt;num_atoms &amp;&amp; cur_success &lt; max_success; i ++ ) {</a>
<a name="ln3898">            iat =  nCanon2AtnoRevrs[i];</a>
<a name="ln3899">            if ( pStruct-&gt;endpoint[i] || !pVA[i].cNumValenceElectrons || pVA[i].cNumValenceElectrons == 4 ||</a>
<a name="ln3900">                 at2[iat].num_H || at2[iat].radical ||</a>
<a name="ln3901">                 (0 &lt;= (e1=pVA[iat].nCMinusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e1].flow) ||</a>
<a name="ln3902">                 0 &gt; (e=pVA[iat].nCPlusGroupEdge-1) || pBNS-&gt;edge[e].forbidden || pBNS-&gt;edge[e].flow != 1 ) {</a>
<a name="ln3903">                continue;</a>
<a name="ln3904">            }</a>
<a name="ln3905">            /* try to move the charge */</a>
<a name="ln3906">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln3907">            SetForbiddenEdgeMask( pBNS, &amp;OtherNFlowerEdges, forbidden_edge_mask );</a>
<a name="ln3908">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask );</a>
<a name="ln3909"> </a>
<a name="ln3910">            pe   = pBNS-&gt;edge + e;</a>
<a name="ln3911">            if ( !pe-&gt;flow )</a>
<a name="ln3912">                continue;</a>
<a name="ln3913">            pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln3914">            pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln3915"> </a>
<a name="ln3916">            delta = 1;</a>
<a name="ln3917">            pe-&gt;flow -= delta;</a>
<a name="ln3918">            pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln3919">            pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln3920">            pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln3921"> </a>
<a name="ln3922">            ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln3923">                                  &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln3924"> </a>
<a name="ln3925">            if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln3926">                              (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln3927">                /* Created (-) charge on -N= =&gt; nDeltaCharge == 1 */</a>
<a name="ln3928">                /* Flow change on pe (+)charge edge (atom X) is not known to RunBnsTestOnce()) */</a>
<a name="ln3929">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln3930">                if ( ret &gt; 0 ) {</a>
<a name="ln3931">                    nNumRunBNS ++;</a>
<a name="ln3932">                    cur_success ++; /* 18 */</a>
<a name="ln3933">                }</a>
<a name="ln3934">            } else {</a>
<a name="ln3935">                pe-&gt;flow += delta;</a>
<a name="ln3936">                pv1-&gt;st_edge.flow += delta;</a>
<a name="ln3937">                pv2-&gt;st_edge.flow += delta;</a>
<a name="ln3938">                pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln3939">            }</a>
<a name="ln3940">            INCHI_HEAPCHK</a>
<a name="ln3941">        }</a>
<a name="ln3942">exit_case_18:</a>
<a name="ln3943">        RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln3944">        RemoveForbiddenEdgeMask( pBNS, &amp;OtherNFlowerEdges, forbidden_edge_mask  );</a>
<a name="ln3945">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln3946">        if ( ret &lt; 0 ) {</a>
<a name="ln3947">            goto exit_function;</a>
<a name="ln3948">        }</a>
<a name="ln3949">        if ( cur_success ) {</a>
<a name="ln3950">            tot_succes += cur_success;</a>
<a name="ln3951">            /* recalculate InChI from the structure */</a>
<a name="ln3952">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln3953">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln3954">                goto exit_function;</a>
<a name="ln3955">            }</a>
<a name="ln3956">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln3957">                goto exit_function;</a>
<a name="ln3958">            }</a>
<a name="ln3959">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln3960">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln3961">            }</a>
<a name="ln3962">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln3963">                goto exit_function;</a>
<a name="ln3964">            }</a>
<a name="ln3965">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln3966">                goto exit_function; /* nothing to do */</a>
<a name="ln3967">            }</a>
<a name="ln3968">        }</a>
<a name="ln3969">    }</a>
<a name="ln3970">    if ( pc2i-&gt;len_c2at &gt;= 1 ) {</a>
<a name="ln3971">        /*--------------------------------------------------------------*/</a>
<a name="ln3972">        /* case 19 restored:       M--OH   original:  M(-)==OH(+)       */</a>
<a name="ln3973">        /* FixH:               metal  0                      1          */</a>
<a name="ln3974">        /* MobH:                      1                      0          */</a>
<a name="ln3975">        /* O =  O, S, Se, Te; not taut. in InChI                        */</a>
<a name="ln3976">        /* In restored structure has H; tautomeric or not tautomeric    */</a>
<a name="ln3977">        /* Solution: move (+) from -OH to M; charhe on M may vary       */</a>
<a name="ln3978">        /*--------------------------------------------------------------*/</a>
<a name="ln3979">        int iat;</a>
<a name="ln3980">        EdgeIndex eOHPlus, eMPlus, eMMinus, eOMBond;</a>
<a name="ln3981">        BNS_EDGE  *peOHPlus, *peMPlus, *peMMinus, *peOMBond;</a>
<a name="ln3982">        int       iatMetal, ChargeOnMetal, DeltaChargeExpected;</a>
<a name="ln3983">        cur_success = 0;</a>
<a name="ln3984">        num_zero_ret = 0;</a>
<a name="ln3985">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln3986">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln3987">            if ( /* orig. InChI info: =NH2(+), =OH(+) */</a>
<a name="ln3988">                 (pc2i-&gt;c2at[i].nValElectr == 6 ) /* N, O, S, Se, Te */ &amp;&amp;</a>
<a name="ln3989">                 /*!pc2i-&gt;c2at[i].endptInChI &amp;&amp;*/ /* &lt;=== relaxation */</a>
<a name="ln3990">                 (e=pVA[iat].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln3991">                 pc2i-&gt;c2at[i].nFixHInChI == 1 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln3992">                 /* reversed structure info: */</a>
<a name="ln3993">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 1 &amp;&amp;</a>
<a name="ln3994">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; at2[iat].num_H &amp;&amp;</a>
<a name="ln3995">                 at2[iat].valence == 1 &amp;&amp;</a>
<a name="ln3996">                 at2[iat].valence == at2[iat].chem_bonds_valence &amp;&amp;</a>
<a name="ln3997">                 /* metal atom */</a>
<a name="ln3998">                 pVA[iatMetal=at2[iat].neighbor[0]].cMetal &amp;&amp; </a>
<a name="ln3999">                 (eMPlus=pVA[iatMetal].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[eMPlus].forbidden &amp;&amp;</a>
<a name="ln4000">                 (eMMinus=pVA[iatMetal].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[eMMinus].forbidden &amp;&amp;</a>
<a name="ln4001">                 !pBNS-&gt;edge[eOMBond=pBNS-&gt;vert[iat].iedge[0]].forbidden</a>
<a name="ln4002">                 ) {</a>
<a name="ln4003"> </a>
<a name="ln4004">                /* -OH charge edges */</a>
<a name="ln4005">                if ( (ret = AddToEdgeList( &amp;CurrEdges, iat, INC_ADD_EDGE )) ) {</a>
<a name="ln4006">                    goto exit_function;</a>
<a name="ln4007">                }</a>
<a name="ln4008">            }</a>
<a name="ln4009">        }</a>
<a name="ln4010">        if ( CurrEdges.num_edges ) {</a>
<a name="ln4011">            /* detected; fix */</a>
<a name="ln4012">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4013">            SetForbiddenEdgeMask( pBNS, &amp;NFlowerEdges, forbidden_edge_mask );</a>
<a name="ln4014">            SetForbiddenEdgeMask( pBNS, &amp;AllBondEdges, forbidden_edge_mask );</a>
<a name="ln4015">            for ( i = 0; i &lt; CurrEdges.num_edges; i ++ ) {</a>
<a name="ln4016">                /* v1 is -OH, v2 is adjacent to it Metal */</a>
<a name="ln4017">                iat      = CurrEdges.pnEdges[i];</a>
<a name="ln4018">                iatMetal = at2[iat].neighbor[0];</a>
<a name="ln4019">                peOHPlus = pBNS-&gt;edge + (eOHPlus = pVA[iat].nCPlusGroupEdge-1);</a>
<a name="ln4020">                peMPlus  = pBNS-&gt;edge + (eMPlus  = pVA[iatMetal].nCPlusGroupEdge-1);</a>
<a name="ln4021">                peMMinus = pBNS-&gt;edge + (eMMinus = pVA[iatMetal].nCMinusGroupEdge-1);</a>
<a name="ln4022">                peOMBond = pBNS-&gt;edge + (eOMBond =pBNS-&gt;vert[iat].iedge[0]);</a>
<a name="ln4023">                /* remove forbidden edge masks */</a>
<a name="ln4024">                peMPlus-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln4025">                peMMinus-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln4026">                peOMBond-&gt;forbidden &amp;= forbidden_edge_mask_inv;</a>
<a name="ln4027"> </a>
<a name="ln4028">                ChargeOnMetal = (peMPlus-&gt;cap - peMPlus-&gt;flow) - peMMinus-&gt;flow;</a>
<a name="ln4029">                if ( 1 == ChargeOnMetal ) {</a>
<a name="ln4030">                    /* We are going to subtract 1 from the charge on Metal */</a>
<a name="ln4031">                    /* Added (+)charge to -OH is not known to RunBnsTestOnce() */</a>
<a name="ln4032">                    DeltaChargeExpected = -1; /* charge will become = 0 */</a>
<a name="ln4033">                } else</a>
<a name="ln4034">                if ( 0 == ChargeOnMetal ) {</a>
<a name="ln4035">                    DeltaChargeExpected = 1; /* charge on Metal will be created */</a>
<a name="ln4036">                } else {</a>
<a name="ln4037">                    DeltaChargeExpected = 0;</a>
<a name="ln4038">                }</a>
<a name="ln4039"> </a>
<a name="ln4040">                delta = 1;</a>
<a name="ln4041">                pe   = peOHPlus;</a>
<a name="ln4042">                if ( !pe-&gt;flow )</a>
<a name="ln4043">                    continue;</a>
<a name="ln4044">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln4045">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln4046"> </a>
<a name="ln4047">                pe-&gt;flow -= delta; /* remove (-) from AB-O(-) */</a>
<a name="ln4048">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln4049">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln4050">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln4051"> </a>
<a name="ln4052">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4053">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4054"> </a>
<a name="ln4055">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4056">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == DeltaChargeExpected ) {</a>
<a name="ln4057">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4058">                    if ( ret &gt; 0 ) {</a>
<a name="ln4059">                        nNumRunBNS ++;</a>
<a name="ln4060">                        cur_success ++; /* 19 */</a>
<a name="ln4061">                    }</a>
<a name="ln4062">                } else {</a>
<a name="ln4063">                    pe-&gt;flow += delta;</a>
<a name="ln4064">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln4065">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln4066">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln4067">                }</a>
<a name="ln4068">                INCHI_HEAPCHK</a>
<a name="ln4069">                /* set forbidden edge masks back */</a>
<a name="ln4070">                peMPlus-&gt;forbidden  |= forbidden_edge_mask;</a>
<a name="ln4071">                peMMinus-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln4072">                peOMBond-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln4073">            }</a>
<a name="ln4074">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4075">            RemoveForbiddenEdgeMask( pBNS, &amp;NFlowerEdges, forbidden_edge_mask );</a>
<a name="ln4076">            RemoveForbiddenEdgeMask( pBNS, &amp;AllBondEdges, forbidden_edge_mask );</a>
<a name="ln4077"> </a>
<a name="ln4078">            CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4079">            if ( cur_success ) {</a>
<a name="ln4080">                tot_succes += cur_success;</a>
<a name="ln4081">                /* recalculate InChI from the structure */</a>
<a name="ln4082">                if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln4083">                                                                ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln4084">                    goto exit_function;</a>
<a name="ln4085">                }</a>
<a name="ln4086">                if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln4087">                    goto exit_function;</a>
<a name="ln4088">                }</a>
<a name="ln4089">                if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln4090">                    goto exit_function;  /* no fixed-H found */</a>
<a name="ln4091">                }</a>
<a name="ln4092">                if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln4093">                    goto exit_function;</a>
<a name="ln4094">                }</a>
<a name="ln4095">                if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln4096">                    goto exit_function; /* nothing to do */</a>
<a name="ln4097">                }</a>
<a name="ln4098">            }</a>
<a name="ln4099">        }</a>
<a name="ln4100">    }</a>
<a name="ln4101">    if ( pc2i-&gt;len_c2at &gt; 1 &amp;&amp; pc2i-&gt;nNumTgRevrs &amp;&amp; pc2i-&gt;nNumTgInChI) {</a>
<a name="ln4102">        /*--------------------------------------------------------------*/</a>
<a name="ln4103">        /* case 20: restored:  O(-)-AB=N-   original:   O=AB-N(-)-      */</a>
<a name="ln4104">        /* FixH:               0       0                0     -1        */</a>
<a name="ln4105">        /* MobH:               0       0                0      1        */</a>
<a name="ln4106">        /*                   taut    non-taut       non-taut taut       */</a>
<a name="ln4107">        /*                           or taut                  no H      */</a>
<a name="ln4108">        /*                           no H                               */</a>
<a name="ln4109">        /* O = O, S, Se; N = N, O, S, Se, Te;                           */</a>
<a name="ln4110">        /* restored atoms are taut/non-taut; original are opposite.     */</a>
<a name="ln4111">        /* Solution: move (-) from O(-) to =N-                          */</a>
<a name="ln4112">        /*--------------------------------------------------------------*/</a>
<a name="ln4113">        int num_SB_O_Minus = 0, num_DB_N = 0, iat;</a>
<a name="ln4114">        short iat_SB_O_Minus[MAX_DIFF_FIXH], iat_DB_N[MAX_DIFF_FIXH];</a>
<a name="ln4115">        </a>
<a name="ln4116">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln4117">        /*</a>
<a name="ln4118">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln4119">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln4120">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln4121">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln4122">        */</a>
<a name="ln4123">        cur_success = 0;</a>
<a name="ln4124">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4125">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln4126">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln4127">            if ( /* orig. InChI info: =O or -N= */</a>
<a name="ln4128">                 num_DB_N &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4129">                 pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln4130">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4131">                 pBNS-&gt;edge[e].flow == 0 &amp;&amp;</a>
<a name="ln4132">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln4133">                 /* if  more than 1 t-group are in orig. InChI then do not move (-) to N */</a>
<a name="ln4134">                 (pc2i-&gt;nNumTgInChI == 1 || pc2i-&gt;c2at[i].nValElectr == 6) &amp;&amp;</a>
<a name="ln4135">                 /* reversed structure info: */</a>
<a name="ln4136">                 !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln4137">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;*/</a>
<a name="ln4138">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4139">                 at2[iat].valence + 1 == at2[iat].chem_bonds_valence ) {</a>
<a name="ln4140">                iat_DB_N[num_DB_N ++] = iat;</a>
<a name="ln4141">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4142">                    goto exit_function;</a>
<a name="ln4143">                }</a>
<a name="ln4144">            } else</a>
<a name="ln4145">            if ( /* orig. InChI info: -O(-) */</a>
<a name="ln4146">                 num_SB_O_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4147">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln4148">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4149">                 pBNS-&gt;edge[e].flow == 1 &amp;&amp;</a>
<a name="ln4150">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln4151">                 pc2i-&gt;c2at[i].nValElectr == 6 &amp;&amp;</a>
<a name="ln4152">                 /* reversed structure info: */</a>
<a name="ln4153">                 pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln4154">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp; pc2i-&gt;c2at[i].nMobHRevrs == 0 &amp;&amp;</a>
<a name="ln4155">                 pc2i-&gt;c2at[i].nAtChargeRevrs == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4156">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 1 ) {</a>
<a name="ln4157">                iat_SB_O_Minus[num_SB_O_Minus ++] = iat;</a>
<a name="ln4158">            }</a>
<a name="ln4159">        }</a>
<a name="ln4160">        if ( !num_DB_N ) {</a>
<a name="ln4161">            /* search among N that are tautomeric in both cases */</a>
<a name="ln4162">            for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln4163">                if ( !pStruct-&gt;endpoint[i] ) {</a>
<a name="ln4164">                    continue;</a>
<a name="ln4165">                }</a>
<a name="ln4166">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln4167">                if ( /* in restored atom O: charge=-1, no H, has no double bond, endpoint */</a>
<a name="ln4168">                     num_DB_N &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4169">                     at2[iat].charge == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4170">                     at2[iat].valence + 1 == at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln4171">                     /* in orig.InChI: an endpoint, has no H */</a>
<a name="ln4172">                     !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln4173">                     /*!(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;*/</a>
<a name="ln4174">                     /* has (-) edge */</a>
<a name="ln4175">                     (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4176">                     !pBNS-&gt;edge[e].flow ) {</a>
<a name="ln4177"> </a>
<a name="ln4178">                    iat_DB_N[num_DB_N ++] = iat;</a>
<a name="ln4179">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4180">                        goto exit_function;</a>
<a name="ln4181">                    }</a>
<a name="ln4182">                }</a>
<a name="ln4183">            }</a>
<a name="ln4184">        }</a>
<a name="ln4185">        if ( (num_try = inchi_min( num_SB_O_Minus, num_DB_N )) ) {</a>
<a name="ln4186">            /* detected; attempt to fix */</a>
<a name="ln4187">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4188">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln4189">            delta = 1;</a>
<a name="ln4190">            for ( i = 0; i &lt; num_SB_O_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln4191">                iat = iat_SB_O_Minus[i];</a>
<a name="ln4192">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln4193">                if ( !pe-&gt;flow )</a>
<a name="ln4194">                    continue;</a>
<a name="ln4195">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln4196">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln4197"> </a>
<a name="ln4198">                pe-&gt;flow -= delta;</a>
<a name="ln4199">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln4200">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln4201">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln4202"> </a>
<a name="ln4203">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4204">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4205"> </a>
<a name="ln4206">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4207">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln4208">                    /* Added (-) charge to =N- =&gt; nDeltaCharge == 1 */</a>
<a name="ln4209">                    /* Flow change on pe (-)charge edge (atom -O(-)) is not known to RunBnsTestOnce()) */</a>
<a name="ln4210">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4211">                    if ( ret &gt; 0 ) {</a>
<a name="ln4212">                        nNumRunBNS ++;</a>
<a name="ln4213">                        cur_success ++; /* 20 */</a>
<a name="ln4214">                    }</a>
<a name="ln4215">                } else {</a>
<a name="ln4216">                    pe-&gt;flow += delta;</a>
<a name="ln4217">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln4218">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln4219">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln4220">                }</a>
<a name="ln4221">                INCHI_HEAPCHK</a>
<a name="ln4222">            }</a>
<a name="ln4223">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln4224">        }</a>
<a name="ln4225">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4226">        if ( cur_success ) {</a>
<a name="ln4227">            tot_succes += cur_success;</a>
<a name="ln4228">            /* recalculate InChI from the structure */</a>
<a name="ln4229">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln4230">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln4231">                goto exit_function;</a>
<a name="ln4232">            }</a>
<a name="ln4233">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln4234">                goto exit_function;</a>
<a name="ln4235">            }</a>
<a name="ln4236">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln4237">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln4238">            }</a>
<a name="ln4239">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln4240">                goto exit_function;</a>
<a name="ln4241">            }</a>
<a name="ln4242">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln4243">                goto exit_function; /* nothing to do */</a>
<a name="ln4244">            }</a>
<a name="ln4245">        }</a>
<a name="ln4246">    }</a>
<a name="ln4247">    if ( pc2i-&gt;len_c2at &amp;&amp; pc2i-&gt;nNumTgRevrs &amp;&amp; pc2i-&gt;nNumTgHInChI &amp;&amp; pStruct-&gt;endpoint ) {</a>
<a name="ln4248">        /*--------------------------------------------------------------*/</a>
<a name="ln4249">        /*                      O(-)                      O             */</a>
<a name="ln4250">        /*                      |                         ||            */</a>
<a name="ln4251">        /* case 21: restored: R=S=O         original:   R-S=O           */</a>
<a name="ln4252">        /*                      |                         |             */</a>
<a name="ln4253">        /*                      O(-)                      O(-)          */</a>
<a name="ln4254">        /*                           All O are taut     R is not taut   */</a>
<a name="ln4255">        /*                                                              */</a>
<a name="ln4256">        /* In addition, another atom O that should have been tautomeric */</a>
<a name="ln4257">        /* or has H(+) added in Mobile-H layer is not like that         */</a>
<a name="ln4258">        /* O = O, S, Se;  S=S, Se, Te                                  */</a>
<a name="ln4259">        /* Solution: move (-) from O(-) to =O                           */</a>
<a name="ln4260">        /*           these atoms are tautomeric in restored structure   */</a>
<a name="ln4261">        /*--------------------------------------------------------------*/</a>
<a name="ln4262">        int num_SB_O_Minus = 0, num_DB_O = 0, iat, iS;</a>
<a name="ln4263">        short iat_SB_O_Minus[MAX_DIFF_FIXH], iat_Central[MAX_DIFF_FIXH], iat_DB_O[MAX_DIFF_FIXH];</a>
<a name="ln4264">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln4265">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln4266">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln4267">        /*</a>
<a name="ln4268">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln4269">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln4270">        */</a>
<a name="ln4271">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4272">        cur_success = 0;</a>
<a name="ln4273">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln4274">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln4275">            if ( /* orig. InChI info: =O    */</a>
<a name="ln4276">                 num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4277">                 pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln4278">                 (pc2i-&gt;c2at[i].endptInChI || pc2i-&gt;c2at[i].nMobHInChI) &amp;&amp;</a>
<a name="ln4279">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4280">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;*/</a>
<a name="ln4281">                 /* reversed structure info: */</a>
<a name="ln4282">                 !(pc2i-&gt;c2at[i].endptRevrs || pc2i-&gt;c2at[i].nMobHRevrs) &amp;&amp;</a>
<a name="ln4283">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp;</a>
<a name="ln4284">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4285">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 ) {</a>
<a name="ln4286">                iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln4287">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4288">                    goto exit_function;</a>
<a name="ln4289">                }</a>
<a name="ln4290">            }</a>
<a name="ln4291">        }</a>
<a name="ln4292">        for ( i = 0; num_DB_O &amp;&amp; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln4293">            if ( !pStruct-&gt;endpoint[i] ) {</a>
<a name="ln4294">                continue;</a>
<a name="ln4295">            }</a>
<a name="ln4296">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln4297">            if ( /* in restored atom O: charge=-1, no H, has no double bond, endpoint */</a>
<a name="ln4298">                 num_SB_O_Minus &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4299">                 at2[iat].charge == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4300">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln4301">                 pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln4302">                 (at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint) &amp;&amp;</a>
<a name="ln4303">                 /* in orig.InChI: an endpoint, has no H */</a>
<a name="ln4304">                 !(pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[i]) &amp;&amp;</a>
<a name="ln4305">                 /*!(nMobHInChI &amp;&amp; nMobHInChI[i] ) &amp;&amp;*/</a>
<a name="ln4306">                 /* has (-) edge */</a>
<a name="ln4307">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4308">                 pBNS-&gt;edge[e].flow ) {</a>
<a name="ln4309">                int nNumTautSB = 0, nNumTautDB = 0, nNumOtherDB = 0, nNumOtherSB = 0, nNumOthers = 0, nNumNegEndp = 0;</a>
<a name="ln4310">                /* traverse neighbors of the centerpoint iS */</a>
<a name="ln4311">                iS = at2[i].neighbor[0];</a>
<a name="ln4312">                for ( j = 0; j &lt; num_SB_O_Minus; j ++ ) {</a>
<a name="ln4313">                    if ( iat_Central[j] == iS )</a>
<a name="ln4314">                        break;</a>
<a name="ln4315">                }</a>
<a name="ln4316">                if ( j &lt; num_SB_O_Minus ) {</a>
<a name="ln4317">                    continue;  /* have already been there */</a>
<a name="ln4318">                }</a>
<a name="ln4319">                for ( j = 0; j &lt; at[iS].valence; j ++ ) {</a>
<a name="ln4320">                    int bond_type = at2[iS].bond_type[j];</a>
<a name="ln4321">                    k = at2[iS].neighbor[j];</a>
<a name="ln4322">                    if ( k == i ) {</a>
<a name="ln4323">                        continue;</a>
<a name="ln4324">                    }</a>
<a name="ln4325">                    if ( pStruct-&gt;endpoint[k] == pStruct-&gt;endpoint[i] ) {</a>
<a name="ln4326">                        nNumTautSB += ( bond_type == BOND_TYPE_SINGLE );</a>
<a name="ln4327">                        nNumTautDB += ( bond_type == BOND_TYPE_DOUBLE );</a>
<a name="ln4328">                    } else</a>
<a name="ln4329">                    if ( bond_type == BOND_TYPE_DOUBLE ) {</a>
<a name="ln4330">                        nNumOtherDB ++;</a>
<a name="ln4331">                    } else</a>
<a name="ln4332">                    if ( bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln4333">                        nNumOtherSB ++;</a>
<a name="ln4334">                    } else {</a>
<a name="ln4335">                        nNumOthers ++;</a>
<a name="ln4336">                    }</a>
<a name="ln4337">                    if ( at2[k].endpoint == at2[i].endpoint &amp;&amp; at2[k].valence == 1 &amp;&amp;</a>
<a name="ln4338">                         at2[k].charge    == -1 &amp;&amp; pVA[k].cNumValenceElectrons == 6 ) {</a>
<a name="ln4339">                        nNumNegEndp ++;</a>
<a name="ln4340">                    }</a>
<a name="ln4341">                }</a>
<a name="ln4342">                if ( !nNumTautSB ) {</a>
<a name="ln4343">                    continue;</a>
<a name="ln4344">                }</a>
<a name="ln4345">                if ( !( nNumOtherDB &amp;&amp; nNumTautDB ) ) {</a>
<a name="ln4346">                    continue; /* ignore */</a>
<a name="ln4347">                }</a>
<a name="ln4348">                </a>
<a name="ln4349">                iat_SB_O_Minus[num_SB_O_Minus] = iat;</a>
<a name="ln4350">                iat_Central[num_SB_O_Minus ++] = iS;</a>
<a name="ln4351">            }</a>
<a name="ln4352">        }</a>
<a name="ln4353">        if ( (num_try = inchi_min( num_SB_O_Minus, num_DB_O )) ) {</a>
<a name="ln4354">            /* detected; attempt to fix */</a>
<a name="ln4355">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4356">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln4357">            delta = 1;</a>
<a name="ln4358">            for ( i = 0; i &lt; num_SB_O_Minus &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln4359">                iat = iat_SB_O_Minus[i];</a>
<a name="ln4360">                pe   = pBNS-&gt;edge + pVA[iat].nCMinusGroupEdge-1;</a>
<a name="ln4361">                if ( !pe-&gt;flow )</a>
<a name="ln4362">                    continue;</a>
<a name="ln4363">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln4364">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln4365"> </a>
<a name="ln4366">                pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln4367">                pe-&gt;flow -= delta;</a>
<a name="ln4368">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln4369">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln4370">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln4371"> </a>
<a name="ln4372">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4373">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4374"> </a>
<a name="ln4375">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4376">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln4377">                    /* Added (-) charge to =O =&gt; nDeltaCharge == 1 */</a>
<a name="ln4378">                    /* Flow change on pe (-)charge edge (atom -N(-)-) is not known to RunBnsTestOnce()) */</a>
<a name="ln4379">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4380">                    if ( ret &gt; 0 ) {</a>
<a name="ln4381">                        nNumRunBNS ++;</a>
<a name="ln4382">                        cur_success ++; /* 21 */</a>
<a name="ln4383">                    }</a>
<a name="ln4384">                } else {</a>
<a name="ln4385">                    pe-&gt;flow += delta;</a>
<a name="ln4386">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln4387">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln4388">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln4389">                }</a>
<a name="ln4390">                INCHI_HEAPCHK</a>
<a name="ln4391">            }</a>
<a name="ln4392">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln4393">        }</a>
<a name="ln4394">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4395">        if ( cur_success ) {</a>
<a name="ln4396">            tot_succes += cur_success;</a>
<a name="ln4397">            /* recalculate InChI from the structure */</a>
<a name="ln4398">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln4399">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln4400">                goto exit_function;</a>
<a name="ln4401">            }</a>
<a name="ln4402">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln4403">                goto exit_function;</a>
<a name="ln4404">            }</a>
<a name="ln4405">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln4406">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln4407">            }</a>
<a name="ln4408">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln4409">                goto exit_function;</a>
<a name="ln4410">            }</a>
<a name="ln4411">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln4412">                goto exit_function; /* nothing to do */</a>
<a name="ln4413">            }</a>
<a name="ln4414">        }</a>
<a name="ln4415">    }</a>
<a name="ln4416"> </a>
<a name="ln4417">    if ( pc2i-&gt;len_c2at &amp;&amp; pc2i-&gt;nNumTgRevrs &amp;&amp; pc2i-&gt;nNumEndpInChI &lt; pc2i-&gt;nNumEndpRevrs ) {</a>
<a name="ln4418">        /*--------------------------------------------------------------*/</a>
<a name="ln4419">        /*                      O                         O             */</a>
<a name="ln4420">        /*                      ||                        ||            */</a>
<a name="ln4421">        /* case 21a:restored: R=S-R' =X     original:   R-S-R' -X(-)    */</a>
<a name="ln4422">        /*                      |                         ||            */</a>
<a name="ln4423">        /*                      O(-)                      O(-)          */</a>
<a name="ln4424">        /*             All O and X are taut      O and X are not taut   */</a>
<a name="ln4425">        /*             it is possible that X is R                       */</a>
<a name="ln4426">        /*                                                              */</a>
<a name="ln4427">        /* O = O, S, Se;  S=S, Se, Te; X = N, O, S, Se, Te              */</a>
<a name="ln4428">        /* Solution: move (-) from O(-) to =X                           */</a>
<a name="ln4429">        /*           these atoms are tautomeric in restored structure   */</a>
<a name="ln4430">        /*--------------------------------------------------------------*/</a>
<a name="ln4431">        int iat, iS;</a>
<a name="ln4432">        /*</a>
<a name="ln4433">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln4434">        */</a>
<a name="ln4435">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln4436">                    pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln4437">        /*</a>
<a name="ln4438">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln4439">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln4440">        */</a>
<a name="ln4441">        EDGE_LIST  OtherSO, CentralS, SOMinus, MinusAcceptord;</a>
<a name="ln4442">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4443">        AllocEdgeList( &amp;OtherSO, EDGE_LIST_CLEAR );</a>
<a name="ln4444">        AllocEdgeList( &amp;CentralS, EDGE_LIST_CLEAR );</a>
<a name="ln4445">        AllocEdgeList( &amp;SOMinus, EDGE_LIST_CLEAR );</a>
<a name="ln4446">        AllocEdgeList( &amp;MinusAcceptord, EDGE_LIST_CLEAR );</a>
<a name="ln4447">        cur_success = 0;</a>
<a name="ln4448">        if ( !at_Mobile_H_Revrs ) {</a>
<a name="ln4449">            goto exit_case_21a;</a>
<a name="ln4450">        }</a>
<a name="ln4451">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln4452">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln4453">            if ( /* orig. InChI info: -X(-)    */</a>
<a name="ln4454">                 /*num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;*/</a>
<a name="ln4455">                 /*pc2i-&gt;c2at[i].nValElectr == 6 */ /* O, S, Se, Te */</a>
<a name="ln4456">                 !pc2i-&gt;c2at[i].endptInChI &amp;&amp;</a>
<a name="ln4457">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4458">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;*/</a>
<a name="ln4459">                 /* reversed structure info: */</a>
<a name="ln4460">                 (pc2i-&gt;c2at[i].endptRevrs || pc2i-&gt;c2at[i].nMobHRevrs) &amp;&amp;</a>
<a name="ln4461">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp;</a>
<a name="ln4462">                 /*pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp;*/ !at2[iat].num_H ) {</a>
<a name="ln4463">                if ( pVA[iat].cNumValenceElectrons == 6 &amp;&amp; at2[iat].charge == -1 &amp;&amp;</a>
<a name="ln4464">                     pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln4465">                     at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 1 &amp;&amp;</a>
<a name="ln4466">                     pVA[iS=(int)at2[iat].neighbor[0]].cNumValenceElectrons == 6 &amp;&amp; pVA[iS].cPeriodicRowNumber &gt; 1 &amp;&amp;</a>
<a name="ln4467">                     at2[iS].valence &gt;= 4 ) {</a>
<a name="ln4468">                    /* a candidate for S in -SO2- */</a>
<a name="ln4469">                    int nNumTautSB = 0, nNumTautDB = 0, nNumOtherDB = 0, nNumOtherSB = 0;</a>
<a name="ln4470">                    int nNumOthers = 0, nNumNegEndp = 0, nNumEndpO = 0;</a>
<a name="ln4471">                    /* check whether we have already found it */</a>
<a name="ln4472">                    if ( 0 &lt;= FindInEdgeList( &amp;CentralS, iS ) ) {</a>
<a name="ln4473">                        continue;</a>
<a name="ln4474">                    }</a>
<a name="ln4475">                    for ( j = 0; j &lt; at[iS].valence; j ++ ) {</a>
<a name="ln4476">                        int bond_type = at2[iS].bond_type[j];</a>
<a name="ln4477">                        k = at2[iS].neighbor[j];</a>
<a name="ln4478">                        if ( k == iat ) {</a>
<a name="ln4479">                            continue;</a>
<a name="ln4480">                        }</a>
<a name="ln4481">                        if ( pc2i-&gt;c2at[i].endptRevrs == at_Mobile_H_Revrs[k].endpoint &amp;&amp; !at2[k].endpoint ) {</a>
<a name="ln4482">                            nNumTautSB += ( bond_type == BOND_TYPE_SINGLE );</a>
<a name="ln4483">                            nNumTautDB += ( bond_type == BOND_TYPE_DOUBLE );</a>
<a name="ln4484">                            nNumEndpO  += (pVA[k].cNumValenceElectrons == 6 &amp;&amp; at2[k].valence == 1);</a>
<a name="ln4485">                        } else</a>
<a name="ln4486">                        if ( bond_type == BOND_TYPE_DOUBLE ) {</a>
<a name="ln4487">                            nNumOtherDB ++;</a>
<a name="ln4488">                        } else</a>
<a name="ln4489">                        if ( bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln4490">                            nNumOtherSB ++;</a>
<a name="ln4491">                        } else {</a>
<a name="ln4492">                            nNumOthers ++;</a>
<a name="ln4493">                        }</a>
<a name="ln4494">                        if ( at2[k].endpoint == at2[i].endpoint &amp;&amp; at2[k].valence == 1 &amp;&amp;</a>
<a name="ln4495">                             at2[k].charge    == -1 &amp;&amp; pVA[k].cNumValenceElectrons == 6 ) {</a>
<a name="ln4496">                            nNumNegEndp ++;</a>
<a name="ln4497">                        }</a>
<a name="ln4498">                    }</a>
<a name="ln4499">                    if ( !nNumEndpO ) {</a>
<a name="ln4500">                        continue;</a>
<a name="ln4501">                    }</a>
<a name="ln4502">                    if ( nNumTautSB + nNumTautDB + nNumOtherDB &lt;= nNumEndpO  ) {</a>
<a name="ln4503">                        continue; /* ignore */</a>
<a name="ln4504">                    }</a>
<a name="ln4505">                    /* collect double bond taut =O */</a>
<a name="ln4506">                    for ( j = 0; j &lt; at[iS].valence; j ++ ) {</a>
<a name="ln4507">                        int bond_type = at2[iS].bond_type[j];</a>
<a name="ln4508">                        k = at2[iS].neighbor[j];</a>
<a name="ln4509">                        if ( pc2i-&gt;c2at[i].endptRevrs == at_Mobile_H_Revrs[k].endpoint &amp;&amp;</a>
<a name="ln4510">                             !at2[k].endpoint &amp;&amp; pVA[k].cNumValenceElectrons == 6 &amp;&amp; at2[k].valence == 1 &amp;&amp;</a>
<a name="ln4511">                             0 &lt;= (e=pVA[k].nCMinusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden ) {</a>
<a name="ln4512">                            if ( bond_type == BOND_TYPE_DOUBLE &amp;&amp; !at2[k].charge &amp;&amp; !pBNS-&gt;edge[e].flow) {</a>
<a name="ln4513">                                /* charges to be unchanged */</a>
<a name="ln4514">                                if ( (ret = AddToEdgeList( &amp;OtherSO, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4515">                                    goto exit_case_21a;</a>
<a name="ln4516">                                }</a>
<a name="ln4517">                            } else</a>
<a name="ln4518">                            if ( bond_type == BOND_TYPE_SINGLE &amp;&amp; at2[k].charge == -1 &amp;&amp; pBNS-&gt;edge[e].flow ) {</a>
<a name="ln4519">                                /* charges to be removed */</a>
<a name="ln4520">                                if ( (ret = AddToEdgeList( &amp;SOMinus, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4521">                                    goto exit_case_21a;</a>
<a name="ln4522">                                }</a>
<a name="ln4523">                            }</a>
<a name="ln4524">                        }</a>
<a name="ln4525">                    }</a>
<a name="ln4526">                    if ( (ret = AddToEdgeList( &amp;CentralS, iS, INC_ADD_EDGE )) ) {</a>
<a name="ln4527">                        goto exit_case_21a;</a>
<a name="ln4528">                    }</a>
<a name="ln4529">                } else</a>
<a name="ln4530">                if ( at2[iat].charge == 0 &amp;&amp; !pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln4531">                     at2[iat].valence + 1 == at2[iat].chem_bonds_valence ) {</a>
<a name="ln4532">                    /* changeable charges */</a>
<a name="ln4533">                    if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4534">                        goto exit_function;</a>
<a name="ln4535">                    }</a>
<a name="ln4536">                }</a>
<a name="ln4537">            }</a>
<a name="ln4538">        }</a>
<a name="ln4539">        /* remove unchangeable from changeable */</a>
<a name="ln4540">        for ( i = 0; i &lt; OtherSO.num_edges; i ++ ) {</a>
<a name="ln4541">            RemoveFromEdgeListByValue( &amp;CurrEdges, OtherSO.pnEdges[i] );</a>
<a name="ln4542">        }</a>
<a name="ln4543"> </a>
<a name="ln4544">        if ( (num_try = inchi_min( SOMinus.num_edges, CurrEdges.num_edges )) ) {</a>
<a name="ln4545">            /* detected; attempt to fix */</a>
<a name="ln4546">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4547">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln4548">            delta = 1;</a>
<a name="ln4549">            for ( i = 0; i &lt; SOMinus.num_edges &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln4550">                pe   = pBNS-&gt;edge + SOMinus.pnEdges[i];</a>
<a name="ln4551">                if ( !pe-&gt;flow )</a>
<a name="ln4552">                    continue;</a>
<a name="ln4553">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln4554">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln4555"> </a>
<a name="ln4556">                /*pe-&gt;forbidden |= forbidden_edge_mask;*/</a>
<a name="ln4557">                pe-&gt;flow -= delta;</a>
<a name="ln4558">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln4559">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln4560">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln4561"> </a>
<a name="ln4562">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4563">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4564"> </a>
<a name="ln4565">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4566">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 1 ) {</a>
<a name="ln4567">                    /* Added (-) charge to =O =&gt; nDeltaCharge == 1 */</a>
<a name="ln4568">                    /* Flow change on pe (-)charge edge (atom -N(-)-) is not known to RunBnsTestOnce()) */</a>
<a name="ln4569">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4570">                    if ( ret &gt; 0 ) {</a>
<a name="ln4571">                        nNumRunBNS ++;</a>
<a name="ln4572">                        cur_success ++; /* 21a */</a>
<a name="ln4573">                    }</a>
<a name="ln4574">                } else {</a>
<a name="ln4575">                    pe-&gt;flow += delta;</a>
<a name="ln4576">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln4577">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln4578">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln4579">                }</a>
<a name="ln4580">                INCHI_HEAPCHK</a>
<a name="ln4581">            }</a>
<a name="ln4582">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln4583">        }</a>
<a name="ln4584">exit_case_21a:</a>
<a name="ln4585">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4586">        AllocEdgeList( &amp;OtherSO, EDGE_LIST_FREE );</a>
<a name="ln4587">        AllocEdgeList( &amp;CentralS, EDGE_LIST_FREE );</a>
<a name="ln4588">        AllocEdgeList( &amp;SOMinus, EDGE_LIST_FREE );</a>
<a name="ln4589">        AllocEdgeList( &amp;MinusAcceptord, EDGE_LIST_FREE );</a>
<a name="ln4590">        if ( cur_success ) {</a>
<a name="ln4591">            tot_succes += cur_success;</a>
<a name="ln4592">            /* recalculate InChI from the structure */</a>
<a name="ln4593">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln4594">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln4595">                goto exit_function;</a>
<a name="ln4596">            }</a>
<a name="ln4597">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln4598">                goto exit_function;</a>
<a name="ln4599">            }</a>
<a name="ln4600">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln4601">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln4602">            }</a>
<a name="ln4603">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln4604">                goto exit_function;</a>
<a name="ln4605">            }</a>
<a name="ln4606">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln4607">                goto exit_function; /* nothing to do */</a>
<a name="ln4608">            }</a>
<a name="ln4609">        }</a>
<a name="ln4610">    }</a>
<a name="ln4611"> </a>
<a name="ln4612">    if ( pc2i-&gt;len_c2at ) {</a>
<a name="ln4613">        /*------------------------------------------------------------------*/</a>
<a name="ln4614">        /* case 22: restored: N(-)=N(+)=C...=O orig: N#N-N=...-O(-)         */</a>
<a name="ln4615">        /*     im InChI        -O(-) may have H(+) added by Normalization   */</a>
<a name="ln4616">        /*                           or may be tautomeric                   */</a>
<a name="ln4617">        /* Solution: move (-) from N(-) to =O                               */</a>
<a name="ln4618">        /*                                                                  */</a>
<a name="ln4619">        /*------------------------------------------------------------------*/</a>
<a name="ln4620">        int num_DB_O = 0, iat;</a>
<a name="ln4621">        short iat_DB_O[MAX_DIFF_FIXH];</a>
<a name="ln4622">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln4623">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln4624">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln4625">        int iN2, iC;</a>
<a name="ln4626">        BNS_EDGE *peDB_O_Minus;</a>
<a name="ln4627">        /*</a>
<a name="ln4628">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln4629">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln4630">        */</a>
<a name="ln4631">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4632">        cur_success = 0;</a>
<a name="ln4633">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln4634">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln4635">            if ( /* orig. InChI info: =O    */</a>
<a name="ln4636">                 num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4637">                 pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln4638">                 (pc2i-&gt;c2at[i].endptInChI || pc2i-&gt;c2at[i].nMobHInChI) &amp;&amp;</a>
<a name="ln4639">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4640">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;*/</a>
<a name="ln4641">                 /* reversed structure info: */</a>
<a name="ln4642">                 !(pc2i-&gt;c2at[i].endptRevrs || pc2i-&gt;c2at[i].nMobHRevrs) &amp;&amp;</a>
<a name="ln4643">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp;</a>
<a name="ln4644">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4645">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 ) {</a>
<a name="ln4646">                iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln4647">            }</a>
<a name="ln4648">        }</a>
<a name="ln4649">        for ( i = 0; num_DB_O &amp;&amp; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln4650">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln4651">            if ( /* in restored atom O: charge=-1, no H, has no double bond, endpoint */</a>
<a name="ln4652">                 at2[iat].charge == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4653">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 &amp;&amp; !pVA[iat].cMetal &amp;&amp;</a>
<a name="ln4654">                 pVA[iat].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4655">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4656">                 pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln4657">                 !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint) &amp;&amp;</a>
<a name="ln4658">                 pVA[iN2=at2[iat].neighbor[0]].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4659">                 at2[iat].bond_type[0] == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln4660">                 at2[iN2].charge == 1 &amp;&amp; at2[iN2].valence == 2 &amp;&amp; at2[iN2].chem_bonds_valence == 4 &amp;&amp;</a>
<a name="ln4661">                 pVA[iC=at2[iN2].neighbor[at2[iN2].neighbor[0]==iN2]].cNumValenceElectrons == 4 ) {</a>
<a name="ln4662">                </a>
<a name="ln4663">                if ( (ret = AddToEdgeList( &amp;CurrEdges, e, INC_ADD_EDGE )) ) {</a>
<a name="ln4664">                    goto exit_function;</a>
<a name="ln4665">                }</a>
<a name="ln4666">            }</a>
<a name="ln4667">        }</a>
<a name="ln4668">        if ( (num_try = inchi_min( CurrEdges.num_edges, num_DB_O )) ) {</a>
<a name="ln4669">            /* detected; attempt to fix */</a>
<a name="ln4670">            SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4671">            RemoveForbiddenEdgeMask( pBNS, &amp;CurrEdges, forbidden_edge_mask  );</a>
<a name="ln4672">            delta = 1;</a>
<a name="ln4673">            for ( i = 0; i &lt; num_DB_O &amp;&amp; cur_success &lt; num_try; i ++ ) {</a>
<a name="ln4674">                iat = iat_DB_O[i];</a>
<a name="ln4675"> </a>
<a name="ln4676">                peDB_O_Minus = pBNS-&gt;edge + (pVA[iat].nCMinusGroupEdge-1);</a>
<a name="ln4677">                pe           = pBNS-&gt;edge + pBNS-&gt;vert[iat].iedge[0];</a>
<a name="ln4678">                if ( !pe-&gt;flow )</a>
<a name="ln4679">                    continue;</a>
<a name="ln4680">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln4681">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln4682"> </a>
<a name="ln4683">                pe-&gt;forbidden            |= forbidden_edge_mask;</a>
<a name="ln4684">                peDB_O_Minus-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln4685"> </a>
<a name="ln4686">                pe-&gt;flow -= delta;</a>
<a name="ln4687">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln4688">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln4689">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln4690"> </a>
<a name="ln4691">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4692">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4693"> </a>
<a name="ln4694">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4695">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp; nDeltaCharge == 0 ) {</a>
<a name="ln4696">                    /* Added (-) charge to =O and removed from =N(-) =&gt; nDeltaCharge == 0 */</a>
<a name="ln4697">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4698">                    if ( ret &gt; 0 ) {</a>
<a name="ln4699">                        nNumRunBNS ++;</a>
<a name="ln4700">                        cur_success ++; /* 22 */</a>
<a name="ln4701">                    }</a>
<a name="ln4702">                } else {</a>
<a name="ln4703">                    pe-&gt;flow += delta;</a>
<a name="ln4704">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln4705">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln4706">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln4707">                }</a>
<a name="ln4708">                INCHI_HEAPCHK</a>
<a name="ln4709">                pe-&gt;forbidden            &amp;= forbidden_edge_mask_inv;</a>
<a name="ln4710">                peDB_O_Minus-&gt;forbidden  |= forbidden_edge_mask;</a>
<a name="ln4711">            }</a>
<a name="ln4712">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln4713">        }</a>
<a name="ln4714">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4715">        if ( cur_success ) {</a>
<a name="ln4716">            tot_succes += cur_success;</a>
<a name="ln4717">            /* recalculate InChI from the structure */</a>
<a name="ln4718">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln4719">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln4720">                goto exit_function;</a>
<a name="ln4721">            }</a>
<a name="ln4722">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln4723">                goto exit_function;</a>
<a name="ln4724">            }</a>
<a name="ln4725">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln4726">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln4727">            }</a>
<a name="ln4728">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln4729">                goto exit_function;</a>
<a name="ln4730">            }</a>
<a name="ln4731">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln4732">                goto exit_function; /* nothing to do */</a>
<a name="ln4733">            }</a>
<a name="ln4734">        }</a>
<a name="ln4735">    }</a>
<a name="ln4736">    if ( pc2i-&gt;len_c2at &amp;&amp; pc2i-&gt;nNumTgInChI == 1 ) {</a>
<a name="ln4737">        /*------------------------------------------------------------------*/</a>
<a name="ln4738">        /* case 23: -NO2 are to be tautomeric but they are not AND          */</a>
<a name="ln4739">        /*          InChI has a SINGLE tautomeric group                     */</a>
<a name="ln4740">        /*                                                                  */</a>
<a name="ln4741">        /*                   (-)O                   (-)O                    */</a>
<a name="ln4742">        /* Solution: convert     \                      \                   */</a>
<a name="ln4743">        /*                        N-X=...-Z(-)   =&gt;      N(+)=X- ...=Z      */</a>
<a name="ln4744">        /*                      //                      /                   */</a>
<a name="ln4745">        /*                     O                    (-)O                    */</a>
<a name="ln4746">        /*                                                                  */</a>
<a name="ln4747">        /*                     O                       O                    */</a>
<a name="ln4748">        /*        or            \\                      \\                  */</a>
<a name="ln4749">        /*                        N-X=...-Z(-)    =&gt;      N=X-  ...=Z       */</a>
<a name="ln4750">        /*                      //                       /                  */</a>
<a name="ln4751">        /*                     O                     (-)O                   */</a>
<a name="ln4752">        /*                                                                  */</a>
<a name="ln4753">        /*                                                                  */</a>
<a name="ln4754">        /*  (a) move (-) from other tautomeric atom to O in O=N-X           */</a>
<a name="ln4755">        /*          or   from other atom that has to be tautomeric          */</a>
<a name="ln4756">        /*               but is not                                         */</a>
<a name="ln4757">        /*  (b) create (+) [ion pair creation] on N as in                   */</a>
<a name="ln4758">        /*                                                                  */</a>
<a name="ln4759">        /*       OH             OH                                          */</a>
<a name="ln4760">        /*      /              /                                            */</a>
<a name="ln4761">        /*  -C=N     =&gt;  =C-N(+)                                            */</a>
<a name="ln4762">        /*     \\             \\                                            */</a>
<a name="ln4763">        /*       O              O                                           */</a>
<a name="ln4764">        /*                                                                  */</a>
<a name="ln4765">        /*------------------------------------------------------------------*/</a>
<a name="ln4766">        int num_DB_O = 0, iat;</a>
<a name="ln4767">        short iat_DB_O[MAX_DIFF_FIXH], iat_NO2[MAX_DIFF_FIXH];</a>
<a name="ln4768">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln4769">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln4770">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln4771">        /*</a>
<a name="ln4772">        inp_ATOM *atfMobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln4773">                             pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds)?</a>
<a name="ln4774">                             pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds : NULL;</a>
<a name="ln4775">        */</a>
<a name="ln4776">        S_CHAR   *num_Fixed_H_Revrs = pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed? pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed : NULL;</a>
<a name="ln4777">        S_CHAR   *pnMobHRevrs = (pStruct-&gt;pOneINChI[1] &amp;&amp; pStruct-&gt;pOneINChI[1]-&gt;nNum_H)?</a>
<a name="ln4778">                               pStruct-&gt;pOneINChI[1]-&gt;nNum_H : </a>
<a name="ln4779">                            (pStruct-&gt;pOneINChI[0] &amp;&amp; pStruct-&gt;pOneINChI[0]-&gt;nNum_H)?</a>
<a name="ln4780">                               pStruct-&gt;pOneINChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln4781">        int iN, one_success;</a>
<a name="ln4782">        BNS_EDGE *peDB_O_Minus;</a>
<a name="ln4783">        int neigh, nNumO, nNumOthers;</a>
<a name="ln4784">#define CHG_SET_NOOH         0</a>
<a name="ln4785">#define CHG_SET_WRONG_TAUT   1</a>
<a name="ln4786">#define CHG_SET_TAUT         2</a>
<a name="ln4787">#define CHG_LAST_SET         2 /* the last index in trying */</a>
<a name="ln4788">#define CHG_SET_O_FIXED      3</a>
<a name="ln4789">#define CHG_SET_NUM          4</a>
<a name="ln4790">        EDGE_LIST ChangeableEdges[CHG_SET_NUM];</a>
<a name="ln4791">        memset( ChangeableEdges, 0, sizeof(ChangeableEdges) );</a>
<a name="ln4792">        /* equivalent to AllocEdgeList( &amp;EdgeList, EDGE_LIST_CLEAR ); */</a>
<a name="ln4793">        /*</a>
<a name="ln4794">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln4795">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln4796">        */</a>
<a name="ln4797">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln4798">        cur_success = 0;</a>
<a name="ln4799">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln4800">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln4801">            if ( /* orig. InChI info: taut in orig. InChI =O located in -NO2 that is not taut in Reconstructed InChI */</a>
<a name="ln4802">                 num_DB_O &lt; MAX_DIFF_FIXH &amp;&amp;</a>
<a name="ln4803">                 pc2i-&gt;c2at[i].nValElectr == 6 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln4804">                 (pc2i-&gt;c2at[i].endptInChI /*|| pc2i-&gt;c2at[i].nMobHInChI*/) &amp;&amp;</a>
<a name="ln4805">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln4806">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; /*pc2i-&gt;c2at[i].nMobHInChI ==  1 &amp;&amp;*/</a>
<a name="ln4807">                 /* reversed structure info: */</a>
<a name="ln4808">                 !(pc2i-&gt;c2at[i].endptRevrs /*|| pc2i-&gt;c2at[i].nMobHRevrs*/) &amp;&amp;</a>
<a name="ln4809">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp;</a>
<a name="ln4810">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln4811">                 at2[iat].valence == 1 &amp;&amp; at2[iat].chem_bonds_valence == 2 &amp;&amp;</a>
<a name="ln4812">                 /* find whether it belongs to NO2 */</a>
<a name="ln4813">                 pVA[iN=at2[iat].neighbor[0]].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln4814">                 at2[iN].valence == 3 &amp;&amp; (at2[iN].charge == 0 || at2[iN].charge == 1) &amp;&amp;</a>
<a name="ln4815">                 at2[iN].chem_bonds_valence == 5 - at2[iN].charge ) {</a>
<a name="ln4816">                /* find the second O */</a>
<a name="ln4817">                nNumO = nNumOthers = 0;</a>
<a name="ln4818">                for ( k = 0; k &lt; at2[iN].valence; k ++ ) {</a>
<a name="ln4819">                    neigh = at2[iN].neighbor[k];</a>
<a name="ln4820">                    if ( neigh == iat ) {</a>
<a name="ln4821">                        continue;</a>
<a name="ln4822">                    }</a>
<a name="ln4823">                    if ( pVA[neigh].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln4824">                         pStruct-&gt;endpoint[neigh] &amp;&amp;</a>
<a name="ln4825">                         !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[neigh].endpoint) &amp;&amp;</a>
<a name="ln4826">                         at2[neigh].valence == 1 &amp;&amp; at2[neigh].num_H == 0 &amp;&amp;</a>
<a name="ln4827">                         at2[neigh].radical == 0 &amp;&amp; (at2[neigh].charge == 0 || at2[neigh].charge == -1) &amp;&amp;</a>
<a name="ln4828">                         at2[neigh].chem_bonds_valence - at2[neigh].charge == 2) {</a>
<a name="ln4829">                        nNumO ++;</a>
<a name="ln4830">                    } else</a>
<a name="ln4831">                    if ( at2[iN].bond_type[k] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln4832">                         at2[neigh].valence &gt; 1 &amp;&amp;</a>
<a name="ln4833">                         at2[neigh].valence &lt; at2[neigh].chem_bonds_valence ) {</a>
<a name="ln4834">                        nNumOthers ++;</a>
<a name="ln4835">                    }</a>
<a name="ln4836">                }</a>
<a name="ln4837">                if ( nNumO != 1 || nNumOthers != 1 ) {</a>
<a name="ln4838">                    continue;</a>
<a name="ln4839">                }</a>
<a name="ln4840">                for ( k = 0; k &lt; num_DB_O; k ++ ) {</a>
<a name="ln4841">                    if ( iat_NO2[k] == iN ) {</a>
<a name="ln4842">                        break;</a>
<a name="ln4843">                    }</a>
<a name="ln4844">                }</a>
<a name="ln4845">                if ( k == num_DB_O ) {</a>
<a name="ln4846">                    iat_NO2[num_DB_O]     = iN;</a>
<a name="ln4847">                    iat_DB_O[num_DB_O ++] = iat;</a>
<a name="ln4848">                }</a>
<a name="ln4849">                /* save the edge to avoid interference */</a>
<a name="ln4850">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e, INC_ADD_EDGE )) ) {</a>
<a name="ln4851">                    goto exit_case_23;</a>
<a name="ln4852">                }</a>
<a name="ln4853">            }</a>
<a name="ln4854">        }</a>
<a name="ln4855">        if ( num_DB_O ) {</a>
<a name="ln4856">            /* 1. search for =N(=O)-OH; assume =N(+)(-O(-))(-OH) does not happen */</a>
<a name="ln4857">            for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln4858">                /* find O=N(V) */</a>
<a name="ln4859">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln4860">                if ( !pStruct-&gt;endpoint[i] || pVA[i].cNumValenceElectrons != 6 ||</a>
<a name="ln4861">                     at2[iat].valence != 1 || at2[iat].charge ||</a>
<a name="ln4862">                     0 &gt; (e = pVA[iat].nCMinusGroupEdge-1) ||</a>
<a name="ln4863">                     at2[iat].num_H + at2[iat].chem_bonds_valence != 2 ||</a>
<a name="ln4864">                     pVA[iN=at2[iat].neighbor[0]].cNumValenceElectrons != 5 ||</a>
<a name="ln4865">                     0 &gt; (e = pVA[iN].nCPlusGroupEdge-1) ||</a>
<a name="ln4866">                     pBNS-&gt;edge[e].forbidden || !pBNS-&gt;edge[e].flow ||</a>
<a name="ln4867">                     at2[iN].charge || at2[iN].valence != 3 || at2[iN].chem_bonds_valence != 5) {</a>
<a name="ln4868">                    continue;</a>
<a name="ln4869">                }</a>
<a name="ln4870">                /* find the second O, -OH */</a>
<a name="ln4871">                nNumO = nNumOthers = 0;</a>
<a name="ln4872">                for ( k = 0; k &lt; at2[iN].valence; k ++ ) {</a>
<a name="ln4873">                    neigh = at2[iN].neighbor[k];</a>
<a name="ln4874">                    if ( neigh == iat ) {</a>
<a name="ln4875">                        continue;</a>
<a name="ln4876">                    }</a>
<a name="ln4877">                    if ( pVA[neigh].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln4878">                         pStruct-&gt;endpoint[neigh] &amp;&amp;</a>
<a name="ln4879">                         at2[neigh].valence == 1 &amp;&amp; at2[neigh].num_H == 1 &amp;&amp;</a>
<a name="ln4880">                         at2[neigh].radical == 0 &amp;&amp; (at2[neigh].charge == 0 ) ) {</a>
<a name="ln4881">                        nNumO ++;</a>
<a name="ln4882">                    } else</a>
<a name="ln4883">                    if ( at2[iN].bond_type[k] == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln4884">                         at2[neigh].valence &gt;= 2 &amp;&amp;</a>
<a name="ln4885">                         at2[neigh].valence &lt; at2[neigh].chem_bonds_valence ) {</a>
<a name="ln4886">                        nNumOthers ++;</a>
<a name="ln4887">                    }</a>
<a name="ln4888">                }</a>
<a name="ln4889">                if ( nNumO != 1 || nNumOthers != 1 ) {</a>
<a name="ln4890">                    continue;</a>
<a name="ln4891">                }</a>
<a name="ln4892">                /* save edges to be changed */</a>
<a name="ln4893">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NOOH], e, INC_ADD_EDGE )) ||</a>
<a name="ln4894">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e, INC_ADD_EDGE ))) {</a>
<a name="ln4895">                    goto exit_case_23;</a>
<a name="ln4896">                }</a>
<a name="ln4897">                if ( NO_VERTEX != (j = GetChargeFlowerUpperEdge( pBNS, pVA, e )) &amp;&amp;</a>
<a name="ln4898">                     (( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NOOH], j, INC_ADD_EDGE ) ) ||</a>
<a name="ln4899">                      ( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e, INC_ADD_EDGE ) ))) {</a>
<a name="ln4900">                    goto exit_case_23;</a>
<a name="ln4901">                }</a>
<a name="ln4902">            }</a>
<a name="ln4903">            /* 2. search for (-) atoms that are tautomeric but should not be  */</a>
<a name="ln4904">            /*           or that got H from Normalization but they shouldn't  */</a>
<a name="ln4905">            for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln4906">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln4907">                if ( at2[iat].charge == -1 &amp;&amp;</a>
<a name="ln4908">                     !pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln4909">                     (at_Mobile_H_Revrs &amp;&amp; </a>
<a name="ln4910">                     (at_Mobile_H_Revrs[i].endpoint || at2[iat].num_H &lt; at_Mobile_H_Revrs[i].num_H )) )  {</a>
<a name="ln4911"> </a>
<a name="ln4912">                    if ( 0 &lt;= (e = pVA[iat].nCMinusGroupEdge-1) &amp;&amp;</a>
<a name="ln4913">                         0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e ) &amp;&amp;</a>
<a name="ln4914">                         !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln4915">                         (</a>
<a name="ln4916">                          ( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_WRONG_TAUT], e, INC_ADD_EDGE ) ) ||</a>
<a name="ln4917">                          ( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e, INC_ADD_EDGE ) )</a>
<a name="ln4918">                         ) ) {</a>
<a name="ln4919">                        goto exit_case_23;</a>
<a name="ln4920">                    }</a>
<a name="ln4921">                } else</a>
<a name="ln4922">                /* negatively charged atom in Reconstructed structure got H(+) from Normalization */</a>
<a name="ln4923">                /* and is not tautomeric; in the original structure it is tautomeric */    </a>
<a name="ln4924">                if ( at2[iat].charge == -1 &amp;&amp;</a>
<a name="ln4925">                     pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln4926">                     !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[i].endpoint) &amp;&amp;</a>
<a name="ln4927">                     (num_Fixed_H_Revrs &amp;&amp; num_Fixed_H_Revrs[i] == -1) &amp;&amp;</a>
<a name="ln4928">                     (pnMobHRevrs       &amp;&amp; pnMobHRevrs[i]       ==  1) &amp;&amp; </a>
<a name="ln4929">                     pStruct-&gt;fixed_H[i] == 0 ) {</a>
<a name="ln4930"> </a>
<a name="ln4931">                    if ( 0 &lt;= (e = pVA[iat].nCMinusGroupEdge-1) &amp;&amp;</a>
<a name="ln4932">                         0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e ) &amp;&amp;</a>
<a name="ln4933">                         !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln4934">                         (</a>
<a name="ln4935">                          ( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_WRONG_TAUT], e, INC_ADD_EDGE ) ) ||</a>
<a name="ln4936">                          ( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e, INC_ADD_EDGE ) )</a>
<a name="ln4937">                         ) ) {</a>
<a name="ln4938">                        goto exit_case_23;</a>
<a name="ln4939">                    }</a>
<a name="ln4940">                }</a>
<a name="ln4941">            }</a>
<a name="ln4942">            /* 3. Search for (-) atoms that are tautomeric */</a>
<a name="ln4943">            for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln4944">                iat = nCanon2AtnoRevrs[i];</a>
<a name="ln4945">                if ( pStruct-&gt;endpoint[i] &amp;&amp;</a>
<a name="ln4946">                     (at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[i].endpoint) &amp;&amp;</a>
<a name="ln4947">                     at2[iat].charge == -1</a>
<a name="ln4948">                    /*&amp;&amp; pVA[i].cNumValenceElectrons == 6*/ ) {</a>
<a name="ln4949">                    if ( 0 &lt;= (e = pVA[iat].nCMinusGroupEdge-1) &amp;&amp;</a>
<a name="ln4950">                         !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln4951">                         0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_O_FIXED], e )  &amp;&amp;</a>
<a name="ln4952">                         ( ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_TAUT], e, INC_ADD_EDGE ) ) ) {</a>
<a name="ln4953">                        goto exit_case_23;</a>
<a name="ln4954">                    }</a>
<a name="ln4955">                }</a>
<a name="ln4956">            }</a>
<a name="ln4957">            /* ------- finally, try to move charges from O=N --------------*/</a>
<a name="ln4958">            for ( i = 0; i &lt; num_DB_O; i ++ ) {</a>
<a name="ln4959">                int nDeltaChargeExpected;</a>
<a name="ln4960">                one_success = 0;</a>
<a name="ln4961">                delta = 1;</a>
<a name="ln4962">                iat = iat_DB_O[i];</a>
<a name="ln4963">                peDB_O_Minus = pBNS-&gt;edge + (pVA[iat].nCMinusGroupEdge-1);</a>
<a name="ln4964">                pe =           pBNS-&gt;edge + pBNS-&gt;vert[iat].iedge[0];</a>
<a name="ln4965">                </a>
<a name="ln4966">                if ( !pe-&gt;flow )</a>
<a name="ln4967">                    continue;</a>
<a name="ln4968">                pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln4969">                pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln4970"> </a>
<a name="ln4971">                pe-&gt;forbidden            |= forbidden_edge_mask;</a>
<a name="ln4972"> </a>
<a name="ln4973">                pe-&gt;flow -= delta;</a>
<a name="ln4974">                pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln4975">                pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln4976">                pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln4977"> </a>
<a name="ln4978">                for ( k = 0; !one_success &amp;&amp; k &lt;= CHG_LAST_SET; k ++ ) {</a>
<a name="ln4979">                    if ( !ChangeableEdges[k].num_edges ) {</a>
<a name="ln4980">                        continue;</a>
<a name="ln4981">                    }</a>
<a name="ln4982">                    nDeltaChargeExpected = (k==CHG_SET_NOOH)? 2 : 0;</a>
<a name="ln4983">                    </a>
<a name="ln4984">                    SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln4985">                    RemoveForbiddenEdgeMask( pBNS, &amp;ChangeableEdges[k], forbidden_edge_mask  );</a>
<a name="ln4986">                    /* allow (-) charge to move to N=O */</a>
<a name="ln4987">                    peDB_O_Minus-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln4988">                    </a>
<a name="ln4989">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln4990">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln4991"> </a>
<a name="ln4992">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln4993">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln4994">                                      nDeltaCharge == nDeltaChargeExpected ) {</a>
<a name="ln4995">                        /* Move (-) charge to =O and remove it an endpoint =&gt; nDeltaCharge == 0 */</a>
<a name="ln4996">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln4997">                        if ( ret &gt; 0 ) {</a>
<a name="ln4998">                            nNumRunBNS ++;</a>
<a name="ln4999">                            one_success ++; /* 23 */</a>
<a name="ln5000">                        }</a>
<a name="ln5001">                    }</a>
<a name="ln5002">                    INCHI_HEAPCHK</a>
<a name="ln5003">                }</a>
<a name="ln5004">                cur_success += one_success;</a>
<a name="ln5005">                </a>
<a name="ln5006">                RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln5007">                pe-&gt;forbidden            &amp;= forbidden_edge_mask_inv;</a>
<a name="ln5008"> </a>
<a name="ln5009">                if ( !one_success ) {</a>
<a name="ln5010">                    pe-&gt;flow += delta;</a>
<a name="ln5011">                    pv1-&gt;st_edge.flow += delta;</a>
<a name="ln5012">                    pv2-&gt;st_edge.flow += delta;</a>
<a name="ln5013">                    pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln5014">                }</a>
<a name="ln5015">            }</a>
<a name="ln5016">        }</a>
<a name="ln5017">exit_case_23:</a>
<a name="ln5018">        for ( i = 0; i &lt; CHG_SET_NUM; i ++ ) {</a>
<a name="ln5019">            AllocEdgeList( &amp;ChangeableEdges[i], EDGE_LIST_FREE );</a>
<a name="ln5020">        }</a>
<a name="ln5021"> </a>
<a name="ln5022">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln5023">        if ( cur_success ) {</a>
<a name="ln5024">            tot_succes += cur_success;</a>
<a name="ln5025">            /* recalculate InChI from the structure */</a>
<a name="ln5026">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln5027">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln5028">                goto exit_function;</a>
<a name="ln5029">            }</a>
<a name="ln5030">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln5031">                goto exit_function;</a>
<a name="ln5032">            }</a>
<a name="ln5033">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln5034">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln5035">            }</a>
<a name="ln5036">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln5037">                goto exit_function;</a>
<a name="ln5038">            }</a>
<a name="ln5039">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln5040">                goto exit_function; /* nothing to do */</a>
<a name="ln5041">            }</a>
<a name="ln5042">        }</a>
<a name="ln5043">#undef CHG_SET_NOOH</a>
<a name="ln5044">#undef CHG_SET_WRONG_TAUT</a>
<a name="ln5045">#undef CHG_SET_TAUT</a>
<a name="ln5046">#undef CHG_LAST_SET</a>
<a name="ln5047">#undef CHG_SET_O_FIXED</a>
<a name="ln5048">#undef CHG_SET_NUM</a>
<a name="ln5049">    }</a>
<a name="ln5050"> </a>
<a name="ln5051">    if ( pc2i-&gt;len_c2at &amp;&amp; pc2i-&gt;nNumTgInChI == 1 ) {</a>
<a name="ln5052">        /*------------------------------------------------------------------*/</a>
<a name="ln5053">        /* case 24: InChI norm. -N(-)-N(+)(IV) =&gt; -N=N(V) prevents tauto-   */</a>
<a name="ln5054">        /*          merism on -N(-)- in case of ADP                         */</a>
<a name="ln5055">        /*                                                                  */</a>
<a name="ln5056">        /* Solution: convert       N(V)=N-   ...=X    -&gt; N(IV)(+)-N=...-X(-)*/</a>
<a name="ln5057">        /*                     N(IV)(+)-N(-)-...=X                          */</a>
<a name="ln5058">        /*                                                                  */</a>
<a name="ln5059">        /*      Orig InChI            taut      taut, 1 t-group only(ADP?)  */</a>
<a name="ln5060">        /*   Reconstructed struct   non-taut    possibly not taut           */</a>
<a name="ln5061">        /*                                                                  */</a>
<a name="ln5062">        /*   Details: 1a. store next to N(V) (+)edge its flower edge        */</a>
<a name="ln5063">        /*            1b. store next to N(-) edge NO_VERTEX                 */</a>
<a name="ln5064">        /*            2.  Release (-) edges of other missing endpoints or   */</a>
<a name="ln5065">        /*                all endpoints if no other is missing              */</a>
<a name="ln5066">        /*            3.  Decrement flow on (+) edge                        */</a>
<a name="ln5067">        /*                if flower edge is stored then expect DeltaCharge=2*/</a>
<a name="ln5068">        /*                otherwise DeltaCharge = 0                         */</a>
<a name="ln5069">        /*------------------------------------------------------------------*/</a>
<a name="ln5070">        int iat;</a>
<a name="ln5071">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln5072">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln5073">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln5074">        inp_ATOM *atf  = (pStruct-&gt;pOne_norm_data[1] &amp;&amp; pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds)?</a>
<a name="ln5075">                            pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds : NULL;</a>
<a name="ln5076">        int iN, one_success;</a>
<a name="ln5077">        EdgeIndex  ef, e1;</a>
<a name="ln5078">        BNS_EDGE *pef;</a>
<a name="ln5079">#define CHG_SET_MISSED_TAUT   0</a>
<a name="ln5080">#define CHG_SET_OTHER_TAUT_O  1</a>
<a name="ln5081">#define CHG_SET_OTHER_TAUT_N  2</a>
<a name="ln5082">#define CHG_LAST_SET          2 /* the last index in trying */</a>
<a name="ln5083">#define CHG_SET_NN            3</a>
<a name="ln5084">#define CHG_SET_AVOID         4</a>
<a name="ln5085">#define CHG_SET_NUM           5</a>
<a name="ln5086">        EDGE_LIST ChangeableEdges[CHG_SET_NUM];</a>
<a name="ln5087">        memset( ChangeableEdges, 0, sizeof(ChangeableEdges) );</a>
<a name="ln5088">        /* equivalent to AllocEdgeList( &amp;EdgeList, EDGE_LIST_CLEAR ); */</a>
<a name="ln5089">        /*</a>
<a name="ln5090">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln5091">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln5092">        */</a>
<a name="ln5093">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln5094">        cur_success = 0;</a>
<a name="ln5095">        for ( i = 0; i &lt; pc2i-&gt;len_c2at; i ++ ) {</a>
<a name="ln5096">            iat = pc2i-&gt;c2at[i].atomNumber;</a>
<a name="ln5097">            if ( /* orig. InChI info: -N=N(V)    */</a>
<a name="ln5098">                 pc2i-&gt;c2at[i].nValElectr == 5 /* N or P */ &amp;&amp;</a>
<a name="ln5099">                 (pc2i-&gt;c2at[i].endptInChI /* only N */) &amp;&amp;</a>
<a name="ln5100">                 (e1=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e1].forbidden &amp;&amp;</a>
<a name="ln5101">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln5102">                 /* reversed structure info: */</a>
<a name="ln5103">                 !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln5104">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp;</a>
<a name="ln5105">                 pc2i-&gt;c2at[i].nAtChargeRevrs == 0 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln5106">                 at2[iat].valence == 2 &amp;&amp; at2[iat].chem_bonds_valence == 3 &amp;&amp;</a>
<a name="ln5107">                 /* find whether -N= has =N(V) neighbor; Note: operator comma: (A,B) returns B */</a>
<a name="ln5108">                 (iN = at2[iat].neighbor[at2[iat].bond_type[0] != BOND_TYPE_DOUBLE],</a>
<a name="ln5109">                  pVA[iN].cNumValenceElectrons == 5) &amp;&amp;</a>
<a name="ln5110">                 at2[iN].chem_bonds_valence == 5  &amp;&amp; </a>
<a name="ln5111">                 at2[iN].charge == 0 &amp;&amp; !at2[iN].num_H &amp;&amp; !at2[iN].radical &amp;&amp;</a>
<a name="ln5112">                 0 &lt;= (e=pVA[iN].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln5113">                 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e )) {</a>
<a name="ln5114"> </a>
<a name="ln5115">                ef = GetChargeFlowerUpperEdge( pBNS, pVA, e ); /* == NO_VERTEX if N(V) has 4 bonds */</a>
<a name="ln5116">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NN], e, INC_ADD_EDGE ))    ||</a>
<a name="ln5117">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NN], ef, INC_ADD_EDGE ))   ||</a>
<a name="ln5118">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NN], 1, INC_ADD_EDGE ))    || /* expected nDeltaCharge */</a>
<a name="ln5119">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e1, INC_ADD_EDGE )) ||</a>
<a name="ln5120">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE )) ||</a>
<a name="ln5121">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], ef, INC_ADD_EDGE ))) {</a>
<a name="ln5122">                    goto exit_case_24;</a>
<a name="ln5123">                }</a>
<a name="ln5124">                /* mark -N= so that (-) will not be moved to it */</a>
<a name="ln5125">                if ( 0 &lt;= (e = pVA[iat].nCMinusGroupEdge) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln5126">                     0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) &amp;&amp;</a>
<a name="ln5127">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE ))) {</a>
<a name="ln5128">                    goto exit_case_24;</a>
<a name="ln5129">                }</a>
<a name="ln5130">            } else</a>
<a name="ln5131">            if ( /* orig. InChI info: -N(-)N(IV)(+)    */</a>
<a name="ln5132">                 atf &amp;&amp;</a>
<a name="ln5133">                 pc2i-&gt;c2at[i].nValElectr == 5 /* N or P */ &amp;&amp;</a>
<a name="ln5134">                 pc2i-&gt;c2at[i].endptInChI /* only N */ &amp;&amp;</a>
<a name="ln5135">                 (e=pVA[iat].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln5136">                 pc2i-&gt;c2at[i].nFixHInChI == 0 &amp;&amp; pc2i-&gt;c2at[i].nMobHInChI == 0 &amp;&amp;</a>
<a name="ln5137">                 /* reversed structure info: */</a>
<a name="ln5138">                 !pc2i-&gt;c2at[i].endptRevrs &amp;&amp;</a>
<a name="ln5139">                 pc2i-&gt;c2at[i].nFixHRevrs ==  0 &amp;&amp;</a>
<a name="ln5140">                 pc2i-&gt;c2at[i].nAtChargeRevrs == -1 &amp;&amp; !at2[iat].num_H &amp;&amp;</a>
<a name="ln5141">                 at2[iat].valence == 2 &amp;&amp; at2[iat].chem_bonds_valence == 2 &amp;&amp;</a>
<a name="ln5142">                 atf[iat].valence == 2 &amp;&amp; atf[iat].chem_bonds_valence == 3 &amp;&amp; </a>
<a name="ln5143">                 /* find whether -N= has =N(V) neighbor; Note: operator comma: (A,B) returns B */</a>
<a name="ln5144">                 (iN=atf[iat].neighbor[atf[iat].bond_type[0] != BOND_TYPE_DOUBLE],</a>
<a name="ln5145">                  pVA[iN].cNumValenceElectrons == 5) &amp;&amp;</a>
<a name="ln5146">                 at2[iN].charge == 1 &amp;&amp; /* double bond neighbor */</a>
<a name="ln5147">                 at2[iN].chem_bonds_valence == 4 &amp;&amp;</a>
<a name="ln5148">                 atf[iN].charge == 0 &amp;&amp;</a>
<a name="ln5149">                 atf[iN].chem_bonds_valence == 5  &amp;&amp;  /* InChI normalization created N(V)=N- out of N(IV)(+)-N(-)- */</a>
<a name="ln5150">                 !at2[iN].num_H &amp;&amp; !at2[iN].radical &amp;&amp;</a>
<a name="ln5151">                 0 &lt;= (e=pVA[iat].nCMinusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp; pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln5152">                 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) ) {</a>
<a name="ln5153">                /* save (-) edge */</a>
<a name="ln5154">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NN], e, INC_ADD_EDGE ))    ||</a>
<a name="ln5155">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NN], NO_VERTEX, INC_ADD_EDGE ))   ||</a>
<a name="ln5156">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NN], 1, INC_ADD_EDGE ))   || /* expected nDeltaCharge */</a>
<a name="ln5157">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE ))) {</a>
<a name="ln5158">                    goto exit_case_24;</a>
<a name="ln5159">                }</a>
<a name="ln5160">            }</a>
<a name="ln5161">        }</a>
<a name="ln5162">        if ( !ChangeableEdges[CHG_SET_NN].num_edges ) {</a>
<a name="ln5163">            goto  exit_case_24;</a>
<a name="ln5164">        }</a>
<a name="ln5165">        /* Collect all relevant tautomeric atoms */</a>
<a name="ln5166">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) { /* i = canonical number - 1 */</a>
<a name="ln5167">            if ( !pStruct-&gt;endpoint[i] ) {</a>
<a name="ln5168">                continue;</a>
<a name="ln5169">            }</a>
<a name="ln5170">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln5171">            if ( at2[iat].charge || at2[iat].radical || at2[iat].valence == at2[iat].chem_bonds_valence ) {</a>
<a name="ln5172">                continue; /* cannot be an acceptor of (-) */</a>
<a name="ln5173">            }</a>
<a name="ln5174">            if ( 0 &gt; (e=pVA[iat].nCMinusGroupEdge-1) || pBNS-&gt;edge[e].forbidden || pBNS-&gt;edge[e].flow ) {</a>
<a name="ln5175">                continue;</a>
<a name="ln5176">            }</a>
<a name="ln5177">            if ( 0 &lt;= FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) ) {</a>
<a name="ln5178">                continue; /* has already been used */</a>
<a name="ln5179">            }</a>
<a name="ln5180">            /* missing endpoint */ </a>
<a name="ln5181">            if ( !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[iat].endpoint) ) {</a>
<a name="ln5182">                if ( 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) &amp;&amp; (</a>
<a name="ln5183">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_MISSED_TAUT], e, INC_ADD_EDGE ))   ||</a>
<a name="ln5184">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE )))) {</a>
<a name="ln5185">                    goto exit_case_24;</a>
<a name="ln5186">                }</a>
<a name="ln5187">            } else</a>
<a name="ln5188">            /* endpoint O */</a>
<a name="ln5189">            if ( pVA[iat].cNumValenceElectrons == 6 ) {</a>
<a name="ln5190">                 if ( 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) &amp;&amp; (</a>
<a name="ln5191">                      (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_OTHER_TAUT_O], e, INC_ADD_EDGE ))   ||</a>
<a name="ln5192">                      (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE )))){</a>
<a name="ln5193">                    goto exit_case_24;</a>
<a name="ln5194">                 }</a>
<a name="ln5195">            } else</a>
<a name="ln5196">            /* endpoint N */</a>
<a name="ln5197">            if ( pVA[iat].cNumValenceElectrons == 5 ) {</a>
<a name="ln5198">                if ( 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) &amp;&amp; ( </a>
<a name="ln5199">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_OTHER_TAUT_N], e, INC_ADD_EDGE ))   ||</a>
<a name="ln5200">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE )))){</a>
<a name="ln5201">                    goto exit_case_24;</a>
<a name="ln5202">                }</a>
<a name="ln5203">            }</a>
<a name="ln5204">        }</a>
<a name="ln5205">        /* ------- finally, try to move charges from -N(-)-N(+) or to N(V) --------------*/</a>
<a name="ln5206">        for ( i = 0; i &lt; ChangeableEdges[CHG_SET_NN].num_edges; i += 3 ) {</a>
<a name="ln5207">            int nDeltaChargeExpected;</a>
<a name="ln5208">            one_success = 0;</a>
<a name="ln5209">            delta = 1;</a>
<a name="ln5210">            pe  = pBNS-&gt;edge + ChangeableEdges[CHG_SET_NN].pnEdges[i];</a>
<a name="ln5211">            pef = (NO_VERTEX != ChangeableEdges[CHG_SET_NN].pnEdges[i+1])?</a>
<a name="ln5212">                  pBNS-&gt;edge + ChangeableEdges[CHG_SET_NN].pnEdges[i+1] : NULL;</a>
<a name="ln5213">            nDeltaChargeExpected = ChangeableEdges[CHG_SET_NN].pnEdges[i+2];</a>
<a name="ln5214"> </a>
<a name="ln5215">            if ( !pe-&gt;flow )</a>
<a name="ln5216">                continue;</a>
<a name="ln5217">            pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln5218">            pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln5219"> </a>
<a name="ln5220">            pe-&gt;flow -= delta;</a>
<a name="ln5221">            pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln5222">            pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln5223">            pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln5224"> </a>
<a name="ln5225">            for ( k = 0; !one_success &amp;&amp; k &lt;= CHG_LAST_SET; k ++ ) {</a>
<a name="ln5226">                if ( !ChangeableEdges[k].num_edges ) {</a>
<a name="ln5227">                    continue;</a>
<a name="ln5228">                }</a>
<a name="ln5229">                SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln5230">                RemoveForbiddenEdgeMask( pBNS, &amp;ChangeableEdges[k], forbidden_edge_mask  );</a>
<a name="ln5231">                /* allow change of N(V) flower edge */</a>
<a name="ln5232">                if ( pef ) {</a>
<a name="ln5233">                    pef-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln5234">                }</a>
<a name="ln5235">                </a>
<a name="ln5236">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln5237">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln5238"> </a>
<a name="ln5239">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln5240">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln5241">                                  nDeltaCharge == nDeltaChargeExpected ) {</a>
<a name="ln5242">                    /* Move (-) charge to =O and remove it an endpoint =&gt; nDeltaCharge == 0 */</a>
<a name="ln5243">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5244">                    if ( ret &gt; 0 ) {</a>
<a name="ln5245">                        nNumRunBNS ++;</a>
<a name="ln5246">                        one_success ++; /* 24 */</a>
<a name="ln5247">                    }</a>
<a name="ln5248">                }</a>
<a name="ln5249">                INCHI_HEAPCHK</a>
<a name="ln5250">            }</a>
<a name="ln5251">            cur_success += one_success;</a>
<a name="ln5252">            </a>
<a name="ln5253">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln5254"> </a>
<a name="ln5255">            if ( !one_success ) {</a>
<a name="ln5256">                pe-&gt;flow += delta;</a>
<a name="ln5257">                pv1-&gt;st_edge.flow += delta;</a>
<a name="ln5258">                pv2-&gt;st_edge.flow += delta;</a>
<a name="ln5259">                pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln5260">            }</a>
<a name="ln5261">        }</a>
<a name="ln5262">exit_case_24:</a>
<a name="ln5263">        for ( i = 0; i &lt; CHG_SET_NUM; i ++ ) {</a>
<a name="ln5264">            AllocEdgeList( &amp;ChangeableEdges[i], EDGE_LIST_FREE );</a>
<a name="ln5265">        }</a>
<a name="ln5266"> </a>
<a name="ln5267">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln5268">        if ( cur_success ) {</a>
<a name="ln5269">            tot_succes += cur_success;</a>
<a name="ln5270">            /* recalculate InChI from the structure */</a>
<a name="ln5271">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln5272">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln5273">                goto exit_function;</a>
<a name="ln5274">            }</a>
<a name="ln5275">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln5276">                goto exit_function;</a>
<a name="ln5277">            }</a>
<a name="ln5278">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln5279">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln5280">            }</a>
<a name="ln5281">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln5282">                goto exit_function;</a>
<a name="ln5283">            }</a>
<a name="ln5284">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln5285">                goto exit_function; /* nothing to do */</a>
<a name="ln5286">            }</a>
<a name="ln5287">        }</a>
<a name="ln5288">#undef CHG_SET_NN</a>
<a name="ln5289">#undef CHG_SET_MISSED_TAUT</a>
<a name="ln5290">#undef CHG_SET_OTHER_TAUT_O</a>
<a name="ln5291">#undef CHG_SET_OTHER_TAUT_N</a>
<a name="ln5292">#undef CHG_LAST_SET</a>
<a name="ln5293">#undef CHG_SET_AVOID</a>
<a name="ln5294">#undef CHG_SET_NUM</a>
<a name="ln5295">    }</a>
<a name="ln5296"> </a>
<a name="ln5297">    /* pStruct-&gt;nNumRemovedProtonsMobHInChI == pc2i-&gt;nNumRemHInChI */</a>
<a name="ln5298"> </a>
<a name="ln5299">    if ( pc2i-&gt;len_c2at &amp;&amp; pc2i-&gt;nNumTgInChI == 1 &amp;&amp;</a>
<a name="ln5300">         pc2i-&gt;nNumRemHRevrs &gt; pc2i-&gt;nNumRemHInChI &amp;&amp; 0 &gt; pc2i-&gt;nNumRemHInChI &amp;&amp;</a>
<a name="ln5301">         (pc2i-&gt;nNumEndpRevrs &lt; pc2i-&gt;nNumEndpInChI ||</a>
<a name="ln5302">          pc2i-&gt;nNumTgRevrs &gt; pc2i-&gt;nNumTgInChI ) ) {</a>
<a name="ln5303">        /*------------------------------------------------------------------*/</a>
<a name="ln5304">        /* case 25: Restored InChI does not have 2 or more added protons    */</a>
<a name="ln5305">        /*                         possibly taut. endpoints are missing     */</a>
<a name="ln5306">        /*                         has -N(-O(-))-O(-) group(s)              */</a>
<a name="ln5307">        /*          Original InChI has only one t-group                     */</a>
<a name="ln5308">        /*                                                                  */</a>
<a name="ln5309">        /* Solution: convert       -N(-O(-))-O(-) -&gt; -N(+)(=O)-O(-)         */</a>
<a name="ln5310">        /*                         and direct 2(-) to the missing taut atoms*/</a>
<a name="ln5311">        /*           at first attempt try to move (-) to N only             */</a>
<a name="ln5312">        /*                                                                  */</a>
<a name="ln5313">        /*------------------------------------------------------------------*/</a>
<a name="ln5314">        int iat;</a>
<a name="ln5315">        AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln5316">        AT_NUMB  *nAtno2CanonRevrs = pStruct-&gt;nAtno2Canon[0];</a>
<a name="ln5317">        inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln5318">                             pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln5319">        /*</a>
<a name="ln5320">        inp_ATOM *atf  = (pStruct-&gt;pOne_norm_data[1] &amp;&amp; pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds)?</a>
<a name="ln5321">                            pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds : NULL;</a>
<a name="ln5322">        */</a>
<a name="ln5323">        int iN, neigh, one_success;</a>
<a name="ln5324">        EdgeIndex  e1, bFirst;</a>
<a name="ln5325">        BNS_EDGE *pef;</a>
<a name="ln5326">#define CHG_SET_MISSED_TAUT_1   0</a>
<a name="ln5327">#define CHG_SET_MISSED_TAUT_ALL 1</a>
<a name="ln5328">#define CHG_SET_OTHER_TAUT_1    2</a>
<a name="ln5329">#define CHG_SET_OTHER_TAUT_ALL  3</a>
<a name="ln5330">#define CHG_LAST_SET            3 /* the last index in trying */</a>
<a name="ln5331">#define CHG_SET_NO_IN_NO2M2     4</a>
<a name="ln5332">#define CHG_SET_AVOID           5</a>
<a name="ln5333">#define CHG_SET_NUM             6</a>
<a name="ln5334">        EDGE_LIST ChangeableEdges[CHG_SET_NUM];</a>
<a name="ln5335">        memset( ChangeableEdges, 0, sizeof(ChangeableEdges) );</a>
<a name="ln5336">        /* equivalent to AllocEdgeList( &amp;EdgeList, EDGE_LIST_CLEAR ); */</a>
<a name="ln5337">        /*</a>
<a name="ln5338">        S_CHAR   *nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H :</a>
<a name="ln5339">                               pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H : 0;</a>
<a name="ln5340">        */</a>
<a name="ln5341">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln5342">        cur_success = 0;</a>
<a name="ln5343">        /* find all -N(-O(-))-O(-) */</a>
<a name="ln5344">        for ( i = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln5345">            iat = nCanon2AtnoRevrs[i];</a>
<a name="ln5346">            if ( pStruct-&gt;endpoint[i] ) {</a>
<a name="ln5347">                if ( 0 &gt; (e=pVA[iat].nCMinusGroupEdge-1) || pBNS-&gt;edge[e].forbidden ||</a>
<a name="ln5348">                     0 &lt;= FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) ) {</a>
<a name="ln5349">                    continue;</a>
<a name="ln5350">                }</a>
<a name="ln5351">                bFirst = ( (pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pc2i-&gt;nNumTgInChI == 1) ||</a>
<a name="ln5352">                           (pVA[iat].cNumValenceElectrons == 6 &amp;&amp; pc2i-&gt;nNumTgInChI != 1)  );</a>
<a name="ln5353">                    /* many or no t-groups -&gt; try O only first */</a>
<a name="ln5354">                    /* single t-group -&gt; try only N first */</a>
<a name="ln5355">                if ( !(at_Mobile_H_Revrs &amp;&amp; at_Mobile_H_Revrs[i].endpoint) ) {</a>
<a name="ln5356">                    /* missed tautomeric endpoint */</a>
<a name="ln5357">                    if ( bFirst &amp;&amp; </a>
<a name="ln5358">                         (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_MISSED_TAUT_1], e, INC_ADD_EDGE ))) {</a>
<a name="ln5359">                        goto exit_case_25;</a>
<a name="ln5360">                    }</a>
<a name="ln5361">                    if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_MISSED_TAUT_ALL], e, INC_ADD_EDGE )) ) {</a>
<a name="ln5362">                        goto exit_case_25;</a>
<a name="ln5363">                    }</a>
<a name="ln5364">                }</a>
<a name="ln5365">                if ( bFirst &amp;&amp; </a>
<a name="ln5366">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_OTHER_TAUT_1], e, INC_ADD_EDGE ))) {</a>
<a name="ln5367">                    goto exit_case_25;</a>
<a name="ln5368">                }</a>
<a name="ln5369">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_OTHER_TAUT_ALL], e, INC_ADD_EDGE )) ) {</a>
<a name="ln5370">                    goto exit_case_25;</a>
<a name="ln5371">                }</a>
<a name="ln5372">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE )) ) {</a>
<a name="ln5373">                    goto exit_case_25;</a>
<a name="ln5374">                }</a>
<a name="ln5375">            } else</a>
<a name="ln5376">            if ( at2[iat].valence == 1 &amp;&amp; at2[iat].charge == -1 &amp;&amp;</a>
<a name="ln5377">                 pVA[iat].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln5378">                 pVA[iN=at2[iat].neighbor[0]].cNumValenceElectrons == 5 &amp;&amp; /* -O(-) */</a>
<a name="ln5379">                 !pStruct-&gt;endpoint[nAtno2CanonRevrs[iN]] &amp;&amp;</a>
<a name="ln5380">                 at2[iN].valence == 3 &amp;&amp; at2[iN].chem_bonds_valence == 3 &amp;&amp;</a>
<a name="ln5381">                 !at2[iN].charge &amp;&amp; !at2[iN].radical &amp;&amp; </a>
<a name="ln5382">                 0 &lt;= (e=pVA[iN].nCPlusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln5383">                 pBNS-&gt;edge[e].flow &amp;&amp; /* NPlus edge */</a>
<a name="ln5384">                 0 &lt;= (e1 = pVA[iat].nCMinusGroupEdge-1) &amp;&amp; !pBNS-&gt;edge[e1].forbidden &amp;&amp;</a>
<a name="ln5385">                 pBNS-&gt;edge[e1].flow &amp;&amp;  /* OMinus edge */</a>
<a name="ln5386">                 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e ) &amp;&amp;</a>
<a name="ln5387">                 0 &gt; FindInEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e1 )) {</a>
<a name="ln5388">                /* found &gt;N-O(-) */</a>
<a name="ln5389">                int nNumO = 0, nNumOthers = 0;</a>
<a name="ln5390">                for ( k = 0; k &lt; at2[iN].valence; k ++ ) {</a>
<a name="ln5391">                    neigh = at2[iN].neighbor[k];</a>
<a name="ln5392">                    if ( neigh == iat ) {</a>
<a name="ln5393">                        continue;</a>
<a name="ln5394">                    }</a>
<a name="ln5395">                    if ( pVA[neigh].cNumValenceElectrons == 6 &amp;&amp;</a>
<a name="ln5396">                         !pStruct-&gt;endpoint[neigh] &amp;&amp;</a>
<a name="ln5397">                         at2[neigh].valence == 1 &amp;&amp; at2[neigh].num_H == 0 &amp;&amp;</a>
<a name="ln5398">                         at2[neigh].radical == 0 &amp;&amp; at2[neigh].charge == -1 &amp;&amp;</a>
<a name="ln5399">                         at2[neigh].chem_bonds_valence == 1 ) {</a>
<a name="ln5400">                        nNumO ++;</a>
<a name="ln5401">                    } else</a>
<a name="ln5402">                    if ( at2[iN].bond_type[k] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln5403">                         at2[neigh].valence &gt; 1 &amp;&amp;</a>
<a name="ln5404">                         at2[neigh].valence &lt; at2[neigh].chem_bonds_valence ) {</a>
<a name="ln5405">                        nNumOthers ++;</a>
<a name="ln5406">                    }</a>
<a name="ln5407">                }</a>
<a name="ln5408">                if ( nNumO != 1 &amp;&amp; nNumOthers != 1 ) {</a>
<a name="ln5409">                    continue;</a>
<a name="ln5410">                }</a>
<a name="ln5411">                /* save charge edges: NPlus first, OMinus second */</a>
<a name="ln5412">                if ( (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NO_IN_NO2M2], e, INC_ADD_EDGE )) ||</a>
<a name="ln5413">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_NO_IN_NO2M2], e1, INC_ADD_EDGE ))   ||</a>
<a name="ln5414">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e, INC_ADD_EDGE )) ||</a>
<a name="ln5415">                     (ret = AddToEdgeList( &amp;ChangeableEdges[CHG_SET_AVOID], e1, INC_ADD_EDGE ))) {</a>
<a name="ln5416">                    goto exit_case_25;</a>
<a name="ln5417">                }</a>
<a name="ln5418">            }</a>
<a name="ln5419">        }</a>
<a name="ln5420">        if ( !ChangeableEdges[CHG_SET_NO_IN_NO2M2].num_edges ||</a>
<a name="ln5421">             !ChangeableEdges[CHG_SET_OTHER_TAUT_ALL].num_edges ) {</a>
<a name="ln5422">            goto exit_case_25;</a>
<a name="ln5423">        }</a>
<a name="ln5424">        /* ------- finally, try to move charges from -NO2(2-) or to tautomeric endpoints ----*/</a>
<a name="ln5425">        for ( i = 0; i &lt; ChangeableEdges[CHG_SET_NO_IN_NO2M2].num_edges; i += 2 ) {</a>
<a name="ln5426">            int nDeltaChargeExpected = 3; </a>
<a name="ln5427">            /* change flow on O(-) to make it neutral; 3 new charges will be created:</a>
<a name="ln5428">               N(+), and two (-) on InChI endpoints</a>
<a name="ln5429">               alternatively, if we change flow on N to make N(+) then O(-) will</a>
<a name="ln5430">               be nutralized (-1 charge) and two (-) charges on taut. endpoints will be</a>
<a name="ln5431">               created (+2); the total change in this case would be (-1)+(+2) = +1</a>
<a name="ln5432">            */</a>
<a name="ln5433">            one_success = 0;</a>
<a name="ln5434">            delta = 1;</a>
<a name="ln5435">            pe  = pBNS-&gt;edge + ChangeableEdges[CHG_SET_NO_IN_NO2M2].pnEdges[i+1]; /* O(-) edge */</a>
<a name="ln5436">            pef = pBNS-&gt;edge + ChangeableEdges[CHG_SET_NO_IN_NO2M2].pnEdges[i]; /* &gt;N- (+) edge */</a>
<a name="ln5437"> </a>
<a name="ln5438">            if ( !pe-&gt;flow )</a>
<a name="ln5439">                continue;</a>
<a name="ln5440">            pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln5441">            pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln5442"> </a>
<a name="ln5443">            pe-&gt;flow -= delta;</a>
<a name="ln5444">            pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln5445">            pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln5446">            pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln5447"> </a>
<a name="ln5448">            for ( k = 0; !one_success &amp;&amp; k &lt;= CHG_LAST_SET; k ++ ) {</a>
<a name="ln5449">                if ( !ChangeableEdges[k].num_edges ) {</a>
<a name="ln5450">                    continue;</a>
<a name="ln5451">                }</a>
<a name="ln5452">                SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln5453">                RemoveForbiddenEdgeMask( pBNS, &amp;ChangeableEdges[k], forbidden_edge_mask  );</a>
<a name="ln5454">                /* allow change of N(V) flower edge */</a>
<a name="ln5455">                pef-&gt;forbidden  &amp;= forbidden_edge_mask_inv;</a>
<a name="ln5456">                </a>
<a name="ln5457">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln5458">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln5459"> </a>
<a name="ln5460">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln5461">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln5462">                                  nDeltaCharge == nDeltaChargeExpected ) {</a>
<a name="ln5463">                    /* Move (-) charge to =O and remove it an endpoint =&gt; nDeltaCharge == 0 */</a>
<a name="ln5464">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln5465">                    if ( ret &gt; 0 ) {</a>
<a name="ln5466">                        nNumRunBNS ++;</a>
<a name="ln5467">                        one_success ++; /* 24 */</a>
<a name="ln5468">                    }</a>
<a name="ln5469">                }</a>
<a name="ln5470">                INCHI_HEAPCHK</a>
<a name="ln5471">            }</a>
<a name="ln5472">            cur_success += one_success;</a>
<a name="ln5473">            </a>
<a name="ln5474">            RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask );</a>
<a name="ln5475"> </a>
<a name="ln5476">            if ( !one_success ) {</a>
<a name="ln5477">                pe-&gt;flow += delta;</a>
<a name="ln5478">                pv1-&gt;st_edge.flow += delta;</a>
<a name="ln5479">                pv2-&gt;st_edge.flow += delta;</a>
<a name="ln5480">                pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln5481">            }</a>
<a name="ln5482">        }</a>
<a name="ln5483">exit_case_25:</a>
<a name="ln5484">        for ( i = 0; i &lt; CHG_SET_NUM; i ++ ) {</a>
<a name="ln5485">            AllocEdgeList( &amp;ChangeableEdges[i], EDGE_LIST_FREE );</a>
<a name="ln5486">        }</a>
<a name="ln5487"> </a>
<a name="ln5488">        CurrEdges.num_edges = 0; /* clear current edge list */</a>
<a name="ln5489">        if ( cur_success ) {</a>
<a name="ln5490">            tot_succes += cur_success;</a>
<a name="ln5491">            /* recalculate InChI from the structure */</a>
<a name="ln5492">            if ( 0 &gt; (ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln5493">                                                            ppt_group_info, ppat_norm, ppat_prep ) ) ) {</a>
<a name="ln5494">                goto exit_function;</a>
<a name="ln5495">            }</a>
<a name="ln5496">            if ( (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln5497">                goto exit_function;</a>
<a name="ln5498">            }</a>
<a name="ln5499">            if ( !pInChI[0]-&gt;nNum_H_fixed &amp;&amp; !pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln5500">                goto exit_function;  /* no fixed-H found */</a>
<a name="ln5501">            }</a>
<a name="ln5502">            if ( (ret = FillOutCMP2FHINCHI( pStruct, at2, pVA, pInChI, pc2i )) ) {</a>
<a name="ln5503">                goto exit_function;</a>
<a name="ln5504">            }</a>
<a name="ln5505">            if ( !pc2i-&gt;bHasDifference ) {</a>
<a name="ln5506">                goto exit_function; /* nothing to do */</a>
<a name="ln5507">            }</a>
<a name="ln5508">        }</a>
<a name="ln5509">#undef CHG_SET_NN</a>
<a name="ln5510">#undef CHG_SET_MISSED_TAUT</a>
<a name="ln5511">#undef CHG_SET_OTHER_TAUT_O</a>
<a name="ln5512">#undef CHG_SET_OTHER_TAUT_N</a>
<a name="ln5513">#undef CHG_LAST_SET</a>
<a name="ln5514">#undef CHG_SET_AVOID</a>
<a name="ln5515">#undef CHG_SET_NUM</a>
<a name="ln5516">    }</a>
<a name="ln5517"> </a>
<a name="ln5518"> </a>
<a name="ln5519">exit_function:</a>
<a name="ln5520">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln5521">    AllocEdgeList( &amp;CurrEdges, EDGE_LIST_FREE );</a>
<a name="ln5522">    AllocEdgeList( &amp;NFlowerEdges, EDGE_LIST_FREE );</a>
<a name="ln5523">    AllocEdgeList( &amp;SFlowerEdges, EDGE_LIST_FREE );</a>
<a name="ln5524">    AllocEdgeList( &amp;OtherNFlowerEdges, EDGE_LIST_FREE );</a>
<a name="ln5525">    AllocEdgeList( &amp;FixedLargeRingStereoEdges, EDGE_LIST_FREE );</a>
<a name="ln5526">    AllocEdgeList( &amp;AllBondEdges, EDGE_LIST_FREE );</a>
<a name="ln5527">    return ret &lt; 0? ret : (pc2i-&gt;bHasDifference &amp;&amp; tot_succes);</a>
<a name="ln5528">}</a>
<a name="ln5529">#endif</a>

</code></pre>
<div class="balloon" rel="351"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1535"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="1554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1650"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="1669"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1790"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pStruct->pOne_norm_data[1].</p></div>
<div class="balloon" rel="1791"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="1810"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!atfMobile_H_Revrs' is always false.</p></div>
<div class="balloon" rel="1835"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1897"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv1n' used.</p></div>
<div class="balloon" rel="1898"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv2n' used.</p></div>
<div class="balloon" rel="1904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v1n' used.</p></div>
<div class="balloon" rel="1904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v2n' used.</p></div>
<div class="balloon" rel="2706"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv1n' used.</p></div>
<div class="balloon" rel="2707"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv2n' used.</p></div>
<div class="balloon" rel="2713"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v1n' used.</p></div>
<div class="balloon" rel="2713"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v2n' used.</p></div>
<div class="balloon" rel="2850"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B == C' kind. The expression is calculated as following: 'A = (B == C)'.</p></div>
<div class="balloon" rel="3007"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'cur_success' variable was assigned the same value.</p></div>
<div class="balloon" rel="2989"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pStruct->pOneINChI[0]' pointer was utilized before it was verified against nullptr. Check lines: 2989, 2992.</p></div>
<div class="balloon" rel="3288"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv1n' used.</p></div>
<div class="balloon" rel="3289"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv2n' used.</p></div>
<div class="balloon" rel="3305"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v1n' used.</p></div>
<div class="balloon" rel="3305"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v2n' used.</p></div>
<div class="balloon" rel="3510"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv1n' used.</p></div>
<div class="balloon" rel="3511"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv2n' used.</p></div>
<div class="balloon" rel="3517"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v1n' used.</p></div>
<div class="balloon" rel="3517"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v2n' used.</p></div>
<div class="balloon" rel="3794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv1n' used.</p></div>
<div class="balloon" rel="3795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'pv2n' used.</p></div>
<div class="balloon" rel="3801"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v1n' used.</p></div>
<div class="balloon" rel="3801"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'v2n' used.</p></div>
<div class="balloon" rel="4661"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="4921"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="5022"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'CurrEdges.num_edges' variable was assigned the same value.</p></div>
<div class="balloon" rel="4776"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pStruct->pOneINChI[0]' pointer was utilized before it was verified against nullptr. Check lines: 4776, 4779.</p></div>
<div class="balloon" rel="5108"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B != C]'. Probably meant 'A[B] != C'.</p></div>
<div class="balloon" rel="5144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B != C]'. Probably meant 'A[B] != C'.</p></div>
<div class="balloon" rel="5267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'CurrEdges.num_edges' variable was assigned the same value.</p></div>
<div class="balloon" rel="5351"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pc2i->nNumTgInChI == 1.</p></div>
<div class="balloon" rel="5352"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: pc2i->nNumTgInChI != 1.</p></div>
<div class="balloon" rel="5488"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'CurrEdges.num_edges' variable was assigned the same value.</p></div>
<div class="balloon" rel="508"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pInChI[0]' pointer was utilized before it was verified against nullptr. Check lines: 508, 533.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichiprt3.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;inpdef.h&quot;</a>
<a name="ln48">#include &quot;ichi.h&quot;</a>
<a name="ln49">#include &quot;strutil.h&quot;</a>
<a name="ln50">#include &quot;util.h&quot;</a>
<a name="ln51">#include &quot;extr_ct.h&quot;</a>
<a name="ln52">#include &quot;ichitaut.h&quot;</a>
<a name="ln53">#include &quot;ichinorm.h&quot;</a>
<a name="ln54">#include &quot;ichicant.h&quot;</a>
<a name="ln55">#include &quot;ichicano.h&quot;</a>
<a name="ln56">#include &quot;ichicomn.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ichicomp.h&quot;</a>
<a name="ln59">#include &quot;ichimain.h&quot;</a>
<a name="ln60">#include &quot;ichimake.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">/***************************************************************************/</a>
<a name="ln64">int str_Sp2(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln65">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln66">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln67">{</a>
<a name="ln68">    int          i, ii, ii2;</a>
<a name="ln69">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln70">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln71">    INChI_Stereo *Stereo, *Stereo_Prev, *Stereo_Taut, *Stereo_Taut_Prev;</a>
<a name="ln72">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln73">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln74">    int         multPrevEquStr;        </a>
<a name="ln75"> </a>
<a name="ln76">    pINChI_Taut      = NULL;</a>
<a name="ln77">    pINChI_Prev      = NULL;</a>
<a name="ln78">    pINChI_Taut_Prev = NULL;</a>
<a name="ln79">    mult        = 0;</a>
<a name="ln80">    bNext       = 0;</a>
<a name="ln81">    is          = NULL;</a>
<a name="ln82">    is2         = NULL;</a>
<a name="ln83">    is0         = pINChISort;</a>
<a name="ln84">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln85">    eq2taut     = 0; /* may be non-zero only on the 2nd (non-taut) pass */</a>
<a name="ln86">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln87">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln88">    multPrevEquStr = 0;        </a>
<a name="ln89">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln90">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln91">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln92">        /*================ compare sp2 to previous =====================*/</a>
<a name="ln93">        if ( bSecondNonTautPass ) {</a>
<a name="ln94">            /* component that was output on the 1st pass */</a>
<a name="ln95">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln96">        }</a>
<a name="ln97">        /*========= if bSecondNonTautPass then compare non-iso non-taut stereo to non-iso taut ========*/</a>
<a name="ln98">        eq2taut = 0;</a>
<a name="ln99">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln100">        if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp; pINChI_Taut ) {</a>
<a name="ln101">            Stereo = pINChI-&gt;Stereo;</a>
<a name="ln102">            Stereo_Taut = pINChI_Taut-&gt;Stereo;</a>
<a name="ln103">            eq2taut = Stereo &amp;&amp; Stereo_Taut &amp;&amp;</a>
<a name="ln104">                      Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Taut, EQL_SP2, 0 );</a>
<a name="ln105">            eq2taut = eq2taut? (iiSTEREO | iitNONTAUT) : 0;</a>
<a name="ln106"> </a>
<a name="ln107">            if ( !eq2taut &amp;&amp;</a>
<a name="ln108">                 !Eql_INChI_Stereo( Stereo, EQL_SP2, NULL, EQL_EXISTS, 0 ) &amp;&amp;</a>
<a name="ln109">                  Eql_INChI_Stereo( Stereo_Taut, EQL_SP2, NULL, EQL_EXISTS, 0 ) ) {</a>
<a name="ln110">                eq2taut = iiEmpty; /* the current is empty while the preceding (taut) is not */</a>
<a name="ln111">            }</a>
<a name="ln112">        }</a>
<a name="ln113">#else</a>
<a name="ln114">        if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln115">            eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln116">                      (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln117">                      Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Taut, EQL_SP2, 0 );</a>
<a name="ln118">            eq2taut = eq2taut? (iiSTEREO | iitNONTAUT) : 0;</a>
<a name="ln119">        }</a>
<a name="ln120">#endif</a>
<a name="ln121">        if ( eq2taut ) {</a>
<a name="ln122">            /* we may be here only in case of the second (non-taut) pass */</a>
<a name="ln123">            /* current non-taut stereo has been found to be same as tautomeric */</a>
<a name="ln124">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln125">                /* previous component exists; output it */</a>
<a name="ln126">                if ( bNext ++ ) {</a>
<a name="ln127">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln128">                }</a>
<a name="ln129">                if ( (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln130">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln131"> </a>
<a name="ln132">                    tot_len += MakeStereoString( Stereo_Prev-&gt;nBondAtom1, Stereo_Prev-&gt;nBondAtom2,</a>
<a name="ln133">                                                 Stereo_Prev-&gt;b_parity,</a>
<a name="ln134">                                                 0, Stereo_Prev-&gt;nNumberOfStereoBonds,</a>
<a name="ln135">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln136">                }</a>
<a name="ln137">            } else</a>
<a name="ln138">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln139">                /* previous non-taut component exists only in taut list */</a>
<a name="ln140">                if ( bNext ++ ) {</a>
<a name="ln141">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln142">                }</a>
<a name="ln143">            }</a>
<a name="ln144">            /* we have found pINChI-&gt;Stereo sp2 same as in pINChI_Taut */</a>
<a name="ln145">            /* output this (current) equivalence as '*', that is, same as tautomeric */</a>
<a name="ln146">            /* that was printed on the 1st pass. */</a>
<a name="ln147">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln148">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln149">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln150">                    multPrevEquStr ++;</a>
<a name="ln151">                } else {</a>
<a name="ln152">                    /* new EqStr is different; output the previous one */</a>
<a name="ln153">                    if ( bNext ++ ) {</a>
<a name="ln154">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln155">                    }</a>
<a name="ln156">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln157">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln158">                    multPrevEquStr = 1;</a>
<a name="ln159">                }</a>
<a name="ln160">            } else {</a>
<a name="ln161">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln162">                multPrevEquStr = 1;</a>
<a name="ln163">            }</a>
<a name="ln164">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln165">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln166">            mult           = 0;</a>
<a name="ln167">            eq2tautPrev    = 1;     /* pINChI_Prev sp2 does not exist */</a>
<a name="ln168">        } else </a>
<a name="ln169">        if ( eq2tautPrev ) {</a>
<a name="ln170">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln171">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln172">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln173">                /* new EqStr is different; output it */</a>
<a name="ln174">                if ( bNext ++ ) {</a>
<a name="ln175">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln176">                }</a>
<a name="ln177">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln178">                pPrevEquStr = NULL;</a>
<a name="ln179">                multPrevEquStr = 0;</a>
<a name="ln180">            }</a>
<a name="ln181">            eq2tautPrev = 0;</a>
<a name="ln182">            pINChI_Prev      = pINChI;</a>
<a name="ln183">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln184">            mult = 0;</a>
<a name="ln185">        } else {</a>
<a name="ln186">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp2 */</a>
<a name="ln187">            eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln188">                     pINChI &amp;&amp; pINChI_Prev &amp;&amp;</a>
<a name="ln189">                     (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp;</a>
<a name="ln190">                     Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Prev, EQL_SP2, 0 );</a>
<a name="ln191">            if ( eq2prev ) {</a>
<a name="ln192">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln193">                continue;</a>
<a name="ln194">            } else {</a>
<a name="ln195">                /* pINChI sp2 info is either different or trivial. Output pINChI_Prev anyway */</a>
<a name="ln196">                if ( bNext ++ ) {</a>
<a name="ln197">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln198">                }</a>
<a name="ln199">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln200">                    if ( (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln201">                        /* pINChI_Prev exists and has sp2 info */</a>
<a name="ln202">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln203"> </a>
<a name="ln204">                        tot_len += MakeStereoString( Stereo_Prev-&gt;nBondAtom1, Stereo_Prev-&gt;nBondAtom2,</a>
<a name="ln205">                                                     Stereo_Prev-&gt;b_parity,</a>
<a name="ln206">                                                     0, Stereo_Prev-&gt;nNumberOfStereoBonds,</a>
<a name="ln207">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln208">                    }</a>
<a name="ln209">                    /* else sp2 info is not present in pINChI_Prev */</a>
<a name="ln210">                } else</a>
<a name="ln211">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln212">                     if ( (Stereo_Taut_Prev = pINChI_Taut_Prev-&gt;Stereo) &amp;&amp; Stereo_Taut_Prev-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln213">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln214">                        /* and it has non-trivial sp2 info */</a>
<a name="ln215">                        /*</a>
<a name="ln216">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln217">                        */</a>
<a name="ln218">                        ;/* pINChI_Taut_Prev sp2 info was output in the main stereo section */</a>
<a name="ln219">                     } else {</a>
<a name="ln220">                        ; /* pINChI_Taut_Prev exists and has not sp2 info */</a>
<a name="ln221">                     }</a>
<a name="ln222">                }</a>
<a name="ln223">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln224">                else {</a>
<a name="ln225">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln226">                }</a>
<a name="ln227">#endif</a>
<a name="ln228">            }</a>
<a name="ln229">            pINChI_Prev = pINChI;</a>
<a name="ln230">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln231">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln232">        }</a>
<a name="ln233">    }</a>
<a name="ln234">    return tot_len;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">/***************************************************************************/</a>
<a name="ln238">int str_Sp3(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln239">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components, int bRelRac,</a>
<a name="ln240">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln241">{</a>
<a name="ln242">    int          i, ii, ii2;</a>
<a name="ln243">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln244">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln245">    INChI_Stereo *Stereo, *Stereo_Prev, *Stereo_Taut, *Stereo_Taut_Prev;</a>
<a name="ln246">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln247">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln248">    int         multPrevEquStr;        </a>
<a name="ln249">    pINChI_Taut      = NULL;</a>
<a name="ln250">    pINChI_Prev      = NULL;</a>
<a name="ln251">    pINChI_Taut_Prev = NULL;</a>
<a name="ln252">    mult        = 0;</a>
<a name="ln253">    bNext       = 0;</a>
<a name="ln254">    is          = NULL;</a>
<a name="ln255">    is2         = NULL;</a>
<a name="ln256">    is0         = pINChISort;</a>
<a name="ln257">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln258">    eq2taut     = 0; /* may be non-zero only on the 2nd (non-taut) pass */</a>
<a name="ln259">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln260">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln261">    multPrevEquStr = 0;        </a>
<a name="ln262">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln263">#else</a>
<a name="ln264">    bRelRac = 0;</a>
<a name="ln265">#endif</a>
<a name="ln266">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln267">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln268">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln269">        /*================ compare sp3 to previous =====================*/</a>
<a name="ln270">        if ( bSecondNonTautPass ) {</a>
<a name="ln271">            /* component that was output on the 1st pass */</a>
<a name="ln272">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln273">        }</a>
<a name="ln274">        /*========= if bSecondNonTautPass then compare non-iso non-taut stereo to non-iso taut ========*/</a>
<a name="ln275">        eq2taut = 0;</a>
<a name="ln276">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln277">        if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp; pINChI_Taut ) {</a>
<a name="ln278">            Stereo = pINChI-&gt;Stereo;</a>
<a name="ln279">            Stereo_Taut = pINChI_Taut-&gt;Stereo;</a>
<a name="ln280">            eq2taut = Stereo &amp;&amp; Stereo_Taut &amp;&amp;</a>
<a name="ln281">                      Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Taut, EQL_SP3, bRelRac );</a>
<a name="ln282">            eq2taut = eq2taut? (iiSTEREO | iitNONTAUT) : 0;</a>
<a name="ln283">            if ( !eq2taut &amp;&amp;</a>
<a name="ln284">                 !Eql_INChI_Stereo( Stereo, EQL_SP3, NULL, EQL_EXISTS, 0 ) &amp;&amp;</a>
<a name="ln285">                  Eql_INChI_Stereo( Stereo_Taut, EQL_SP3, NULL, EQL_EXISTS, 0 ) ) {</a>
<a name="ln286">                eq2taut = iiEmpty; /* the current is empty while the preceding (taut) is not */</a>
<a name="ln287">            }</a>
<a name="ln288">        }</a>
<a name="ln289">#else</a>
<a name="ln290">        if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln291">            eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln292">                      (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln293">                      Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Taut, EQL_SP3, bRelRac );</a>
<a name="ln294">            eq2taut = eq2taut? (iiSTEREO | iitNONTAUT) : 0;</a>
<a name="ln295">        }</a>
<a name="ln296">#endif</a>
<a name="ln297">        if ( eq2taut ) {</a>
<a name="ln298">            /* we may be here only in case of the second (non-taut) pass */</a>
<a name="ln299">            /* current non-taut stereo has been found to be same as tautomeric */</a>
<a name="ln300">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln301">                /* previous component exists; output it */</a>
<a name="ln302">                if ( bNext ++ ) {</a>
<a name="ln303">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln304">                }</a>
<a name="ln305">                if ( (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoCenters &gt; 0 ) {</a>
<a name="ln306">                    /* non-empty item */</a>
<a name="ln307">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln308"> </a>
<a name="ln309">                    tot_len += MakeStereoString( Stereo_Prev-&gt;nNumber, NULL,</a>
<a name="ln310">                                                 Stereo_Prev-&gt;t_parity,</a>
<a name="ln311">                                                 0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln312">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln313">                }</a>
<a name="ln314">            } else</a>
<a name="ln315">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln316">                /* previous non-taut component exists only in taut list */</a>
<a name="ln317">                if ( bNext ++ ) {</a>
<a name="ln318">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln319">                }</a>
<a name="ln320">            } </a>
<a name="ln321">            /* we have found pINChI-&gt;Stereo sp3 same as in pINChI_Taut */</a>
<a name="ln322">            /* output this (current) equivalence as '*', that is, same as tautomeric */</a>
<a name="ln323">            /* that was printed on the 1st pass. */</a>
<a name="ln324"> </a>
<a name="ln325">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln326">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln327">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln328">                    multPrevEquStr ++;</a>
<a name="ln329">                } else {</a>
<a name="ln330">                    /* new EqStr is different; output it */</a>
<a name="ln331">                    if ( bNext ++ ) {</a>
<a name="ln332">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln333">                    }</a>
<a name="ln334">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln335">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln336">                    multPrevEquStr = 1;</a>
<a name="ln337">                }</a>
<a name="ln338">            } else {</a>
<a name="ln339">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln340">                multPrevEquStr = 1;</a>
<a name="ln341">            }</a>
<a name="ln342"> </a>
<a name="ln343">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln344">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln345">            mult           = 0;</a>
<a name="ln346">            eq2tautPrev    = 1;     /* pINChI_Prev sp2 does not exist */</a>
<a name="ln347">        } else </a>
<a name="ln348">        if ( eq2tautPrev ) {</a>
<a name="ln349">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln350">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln351">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln352">                /* new EqStr is different; output it */</a>
<a name="ln353">                if ( bNext ++ ) {</a>
<a name="ln354">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln355">                }</a>
<a name="ln356">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln357">                pPrevEquStr = NULL;</a>
<a name="ln358">                multPrevEquStr = 0;</a>
<a name="ln359">            }</a>
<a name="ln360">            eq2tautPrev = 0;</a>
<a name="ln361">            pINChI_Prev      = pINChI;</a>
<a name="ln362">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln363">            mult = 0;</a>
<a name="ln364">        } else {</a>
<a name="ln365">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp3 */</a>
<a name="ln366">            /*================ compare sp3 to previous =====================*/</a>
<a name="ln367">            eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln368">                     pINChI &amp;&amp; pINChI_Prev &amp;&amp;</a>
<a name="ln369">                     (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp;</a>
<a name="ln370">                     Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Prev, EQL_SP3, bRelRac );</a>
<a name="ln371">            if ( eq2prev ) {</a>
<a name="ln372">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln373">                continue;</a>
<a name="ln374">            } else {</a>
<a name="ln375">                if ( bNext ++ ) {</a>
<a name="ln376">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln377">                }</a>
<a name="ln378">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln379">                    if ( (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoCenters &gt; bRelRac ) {</a>
<a name="ln380">                        /* pINChI_Prev exists and has sp3 info */</a>
<a name="ln381">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln382"> </a>
<a name="ln383">                        tot_len += MakeStereoString( Stereo_Prev-&gt;nNumber, NULL, Stereo_Prev-&gt;t_parity,</a>
<a name="ln384">                                                     0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln385">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln386">                    }</a>
<a name="ln387">                    /* else sp3 info is not present in pINChI_Prev */</a>
<a name="ln388">                } else</a>
<a name="ln389">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln390">                     if ( (Stereo_Taut_Prev = pINChI_Taut_Prev-&gt;Stereo) &amp;&amp; Stereo_Taut_Prev-&gt;nNumberOfStereoCenters &gt; bRelRac ) {</a>
<a name="ln391">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln392">                        /* and it has non-trivial sp3 info. This info has already been printed in the main section */</a>
<a name="ln393">                        /*</a>
<a name="ln394">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln395">                        */</a>
<a name="ln396">                        ; /* pINChI_Taut_Prev sp3 info was output in the main stereo section */</a>
<a name="ln397">                     } else {</a>
<a name="ln398">                        ; /* pINChI_Taut_Prev exists and has not sp3 info */</a>
<a name="ln399">                     }</a>
<a name="ln400">                }</a>
<a name="ln401">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln402">                else {</a>
<a name="ln403">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln404">                }</a>
<a name="ln405">#endif</a>
<a name="ln406">            }</a>
<a name="ln407">            pINChI_Prev = pINChI;</a>
<a name="ln408">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln409">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln410">        }</a>
<a name="ln411">    }</a>
<a name="ln412">    return tot_len;</a>
<a name="ln413">}</a>
<a name="ln414">/***************************************************************************/</a>
<a name="ln415">int str_IsoAtoms(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln416">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components, int bAbcNumbers,</a>
<a name="ln417">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln418">{</a>
<a name="ln419">    int          i, ii, ii2;</a>
<a name="ln420">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln421">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln422">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln423">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln424">    int         multPrevEquStr;        </a>
<a name="ln425">    pINChI_Taut      = NULL;</a>
<a name="ln426">    pINChI_Prev      = NULL;</a>
<a name="ln427">    pINChI_Taut_Prev = NULL;</a>
<a name="ln428">    mult        = 0;</a>
<a name="ln429">    bNext       = 0;</a>
<a name="ln430">    is          = NULL;</a>
<a name="ln431">    is2         = NULL;</a>
<a name="ln432">    is0         = pINChISort;</a>
<a name="ln433">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln434">    eq2taut     = 0; /* may be non-zero only on the 2nd (non-taut) pass */</a>
<a name="ln435">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln436">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln437">    multPrevEquStr = 0;        </a>
<a name="ln438">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln439">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln440">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln441">        /*================ compare isotopic info to previous component =====================*/</a>
<a name="ln442">        if ( bSecondNonTautPass ) {</a>
<a name="ln443">            /* component that was output on the 1st pass */</a>
<a name="ln444">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln445">        }</a>
<a name="ln446">        /*========= if bSecondNonTautPass then compare iso non-taut to taut non-iso ========*/</a>
<a name="ln447">        eq2taut = 0;</a>
<a name="ln448">        if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln449">            eq2taut = Eql_INChI_Isotopic( pINChI, pINChI_Taut );</a>
<a name="ln450">            eq2taut = eq2taut? (iiNUMB | iitNONTAUT) : 0;</a>
<a name="ln451">        }</a>
<a name="ln452">        if ( eq2taut ) {</a>
<a name="ln453">            /* we may be here only in case of the second (non-taut) pass */</a>
<a name="ln454">            /* current non-taut isotopic info has been found to be same as current tautomeric */</a>
<a name="ln455">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln456">                /* previous component exists; output it */</a>
<a name="ln457">                if ( bNext ++ ) {</a>
<a name="ln458">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln459">                }</a>
<a name="ln460">                if ( pINChI_Prev &amp;&amp; (pINChI_Prev-&gt;nNumberOfIsotopicAtoms   &gt; 0 ||</a>
<a name="ln461">                                    pINChI_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0) ) {</a>
<a name="ln462">                    /* non-empty item */</a>
<a name="ln463">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln464">                    /*  Isotopic atoms */</a>
<a name="ln465">                    if ( pINChI_Prev-&gt;nNumberOfIsotopicAtoms &gt; 0 &amp;&amp; nStrLen-tot_len &gt; 2 &amp;&amp; !*bOverflow ) { /* dereferenced bOverflow 2004-06-07 */</a>
<a name="ln466">                        tot_len += MakeIsoAtomString( pINChI_Prev-&gt;IsotopicAtom, pINChI_Prev-&gt;nNumberOfIsotopicAtoms,</a>
<a name="ln467">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln468">                    }</a>
<a name="ln469">                    /*  Isotopic tautomeric groups */</a>
<a name="ln470">                    if ( pINChI_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0 &amp;&amp; nStrLen-tot_len &gt; 3 &amp;&amp; !*bOverflow ) {</a>
<a name="ln471">                        tot_len += MakeDelim( bAbcNumbers? ITEM_DELIMETER : &quot;(&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln472">                        tot_len += MakeIsoTautString( pINChI_Prev-&gt;IsotopicTGroup, pINChI_Prev-&gt;nNumberOfIsotopicTGroups,</a>
<a name="ln473">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln474">                        if ( !bAbcNumbers ) {</a>
<a name="ln475">                            tot_len += MakeDelim( &quot;)&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln476">                        }</a>
<a name="ln477">                    }</a>
<a name="ln478">                }</a>
<a name="ln479">            } else</a>
<a name="ln480">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln481">                /* previous non-taut component exists only in taut list */</a>
<a name="ln482">                if ( bNext ++ ) {</a>
<a name="ln483">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln484">                }</a>
<a name="ln485">            }</a>
<a name="ln486">            /* we have found pINChI isotopic info to be same as in pINChI_Taut */</a>
<a name="ln487">            /* output this (current) equivalence as '*', that is, same as tautomeric */</a>
<a name="ln488">            /* that was printed on the 1st pass. */</a>
<a name="ln489">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln490">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln491">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln492">                    multPrevEquStr ++;</a>
<a name="ln493">                } else {</a>
<a name="ln494">                    /* new EqStr is different; output it */</a>
<a name="ln495">                    if ( bNext ++ ) {</a>
<a name="ln496">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln497">                    }</a>
<a name="ln498">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln499">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln500">                    multPrevEquStr = 1;</a>
<a name="ln501">                }</a>
<a name="ln502">            } else {</a>
<a name="ln503">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln504">                multPrevEquStr = 1;</a>
<a name="ln505">            }</a>
<a name="ln506">            pINChI_Prev      = NULL; /* pINChI_Prev isotopic info does not exist since */</a>
<a name="ln507">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln508">            mult           = 0;</a>
<a name="ln509">            eq2tautPrev    = 1;     /* pINChI_Prev isotopic info does not exist */</a>
<a name="ln510">        } else </a>
<a name="ln511">        if ( eq2tautPrev ) {</a>
<a name="ln512">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln513">            /* might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln514">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln515">                /* new EqStr is different; output it */</a>
<a name="ln516">                if ( bNext ++ ) {</a>
<a name="ln517">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln518">                }</a>
<a name="ln519">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln520">                pPrevEquStr = NULL;</a>
<a name="ln521">                multPrevEquStr = 0;</a>
<a name="ln522">            }</a>
<a name="ln523">            eq2tautPrev = 0;</a>
<a name="ln524">            pINChI_Prev      = pINChI;</a>
<a name="ln525">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln526">            mult = 0;</a>
<a name="ln527">        } else {</a>
<a name="ln528">            /*================ compare iso composition to previous =====================*/</a>
<a name="ln529">            /* check whether pINChI and pINChI_Prev have non-zero identical isotopic info */</a>
<a name="ln530">            eq2prev =bUseMulipliers &amp;&amp; Eql_INChI_Isotopic( pINChI, pINChI_Prev );</a>
<a name="ln531">            if ( eq2prev ) {</a>
<a name="ln532">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln533">                continue;</a>
<a name="ln534">            } else {</a>
<a name="ln535">                /* pINChI isotopic info is either different or empty. Output pINChI_Prev anyway */</a>
<a name="ln536">                if ( bNext ++ ) {</a>
<a name="ln537">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln538">                }</a>
<a name="ln539">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln540">                    if ( (pINChI_Prev-&gt;nNumberOfIsotopicAtoms   &gt; 0 ||</a>
<a name="ln541">                          pINChI_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0) ) {</a>
<a name="ln542">                        /* pINChI_Prev exists and has isotopic info */</a>
<a name="ln543">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln544">                        /*  Isotopic atoms */</a>
<a name="ln545">                        if ( pINChI_Prev-&gt;nNumberOfIsotopicAtoms &gt; 0 &amp;&amp; nStrLen-tot_len &gt; 2 &amp;&amp; !*bOverflow ) {</a>
<a name="ln546">                            tot_len += MakeIsoAtomString( pINChI_Prev-&gt;IsotopicAtom, pINChI_Prev-&gt;nNumberOfIsotopicAtoms,</a>
<a name="ln547">                                                         pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln548">                        }</a>
<a name="ln549">                        /*  Isotopic tautomeric groups */</a>
<a name="ln550">                        if ( pINChI_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0 &amp;&amp; nStrLen-tot_len &gt; 3 &amp;&amp; !*bOverflow ) {</a>
<a name="ln551">                            tot_len += MakeDelim( bAbcNumbers? ITEM_DELIMETER : &quot;(&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln552">                            tot_len += MakeIsoTautString( pINChI_Prev-&gt;IsotopicTGroup, pINChI_Prev-&gt;nNumberOfIsotopicTGroups,</a>
<a name="ln553">                                                         pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln554">                            if ( !bAbcNumbers ) {</a>
<a name="ln555">                                tot_len += MakeDelim( &quot;)&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln556">                            }</a>
<a name="ln557">                        }</a>
<a name="ln558">                    }</a>
<a name="ln559">                    /* else isotopic info is not present in pINChI_Prev */</a>
<a name="ln560">                }  else</a>
<a name="ln561">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln562">                    if ( (pINChI_Taut_Prev-&gt;nNumberOfIsotopicAtoms   &gt; 0 ||</a>
<a name="ln563">                          pINChI_Taut_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0) ) {</a>
<a name="ln564">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln565">                        /* and it has non-trivial isotopic info */</a>
<a name="ln566">                        /*</a>
<a name="ln567">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln568">                        */</a>
<a name="ln569">                        ;/* pINChI_Taut_Prev isotopic info was output in the main isotopic section */</a>
<a name="ln570">                     } else {</a>
<a name="ln571">                        ; /* pINChI_Taut_Prev exists and has not isotopic info */</a>
<a name="ln572">                     }</a>
<a name="ln573">                }</a>
<a name="ln574">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln575">                else {</a>
<a name="ln576">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln577">                }</a>
<a name="ln578">#endif</a>
<a name="ln579">            }</a>
<a name="ln580">            /* Fix17: moved here 2004-10-08 */</a>
<a name="ln581">            pINChI_Prev = pINChI;</a>
<a name="ln582">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln583">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln584">        }</a>
<a name="ln585">        /* Fix17: moved from here 2004-10-08</a>
<a name="ln586">        pINChI_Prev = pINChI;</a>
<a name="ln587">        pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln588">        mult = 0;</a>
<a name="ln589">        */</a>
<a name="ln590">    }</a>
<a name="ln591">    return tot_len;</a>
<a name="ln592">}</a>
<a name="ln593">/***************************************************************************/</a>
<a name="ln594">int str_IsoSp2(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln595">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln596">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln597">{</a>
<a name="ln598">    int          i, ii, ii2;</a>
<a name="ln599">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln600">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln601">    INChI_Stereo *Stereo, *Stereo_Prev, *Stereo_Taut, *Stereo_Taut_Prev;</a>
<a name="ln602">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln603">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln604">    int         multPrevEquStr;        </a>
<a name="ln605">    pINChI_Taut      = NULL;</a>
<a name="ln606">    pINChI_Prev      = NULL;</a>
<a name="ln607">    pINChI_Taut_Prev = NULL;</a>
<a name="ln608">    mult        = 0;</a>
<a name="ln609">    bNext       = 0;</a>
<a name="ln610">    is          = NULL;</a>
<a name="ln611">    is2         = NULL;</a>
<a name="ln612">    is0         = pINChISort;</a>
<a name="ln613">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln614">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln615">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln616">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln617">    multPrevEquStr = 0;        </a>
<a name="ln618">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln619">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln620">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln621">        /*================ compare sp2 to previous =====================*/</a>
<a name="ln622">        if ( bSecondNonTautPass ) {</a>
<a name="ln623">            /* component that was output on the 1st pass */</a>
<a name="ln624">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln625">        }</a>
<a name="ln626">        eq2taut = 0;</a>
<a name="ln627">        /*========= if bSecondNonTautPass then compare iso non-taut stereo to other stereo ========*/</a>
<a name="ln628">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln629">            /* compare non-tautomeric isotopic to:</a>
<a name="ln630">             *   a) non-tautomeric non-isotopic</a>
<a name="ln631">             *   b) tautomeric non-isotopic</a>
<a name="ln632">             *   c) tautomeric isotopic</a>
<a name="ln633">             */</a>
<a name="ln634">            /* a) compare non-tautomeric isotopic to non-tautomeric non-isotopic */</a>
<a name="ln635">            if ( !eq2taut ) {</a>
<a name="ln636">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln637">                                    /* non-taut isotopic */                  /* non-taut non-isotopic */</a>
<a name="ln638">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln639">                          Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Taut, EQL_SP2, 0 );</a>
<a name="ln640">                                 /* stereo     isotopic non-taut =  non-taut (stereo) */</a>
<a name="ln641">                eq2taut = eq2taut? (iiSTEREO | iitISO | iitNONTAUT | iiEq2NONTAUT ) : 0;</a>
<a name="ln642">            }</a>
<a name="ln643">            /* b) compare non-tautomeric isotopic to tautomeric non-isotopic */</a>
<a name="ln644">            if ( !eq2taut ) {</a>
<a name="ln645">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln646">                                    /* non-taut isotopic */                  /* taut non-isotopic */</a>
<a name="ln647">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln648">                          Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Taut, EQL_SP2, 0 );</a>
<a name="ln649">                                 /* stereo     isotopic non-taut =  taut (stereo) */</a>
<a name="ln650">                eq2taut = eq2taut? (iiSTEREO | iitISO | iitNONTAUT ) : 0;</a>
<a name="ln651">            }</a>
<a name="ln652">            /* c) compare non-tautomeric isotopic to tautomeric isotopic */</a>
<a name="ln653">            if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln654">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln655">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln656">                          Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Taut, EQL_SP2, 0 );</a>
<a name="ln657">                                 /* stereo     isotopic non-taut =  isotopic taut (stereo) */</a>
<a name="ln658">                eq2taut = eq2taut? (iiSTEREO | iitISO | iitNONTAUT | iiEq2ISO) : 0;</a>
<a name="ln659">            }</a>
<a name="ln660">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln661">            if ( !eq2taut &amp;&amp; pINChI &amp;&amp; !((Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln662">                Eql_INChI_Stereo( Stereo, EQL_SP2, NULL, EQL_EXISTS, 0 )) ) {</a>
<a name="ln663">                 /* component has no stereo; check whether it has stereo in the preceding layers */</a>
<a name="ln664">                if ( pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp; /* F is not empty */</a>
<a name="ln665">                     Eql_INChI_Stereo( Stereo_Taut, EQL_SP2, NULL, EQL_EXISTS, 0 ) ||</a>
<a name="ln666">                    !(pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;  /* M is empty and ... */</a>
<a name="ln667">                       Eql_INChI_Stereo( Stereo_Taut, EQL_SP2, NULL, EQL_EXISTS, 0 )) &amp;&amp;</a>
<a name="ln668">                     (pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;  /* ... MI is not empty */</a>
<a name="ln669">                       Eql_INChI_Stereo( Stereo_Taut, EQL_SP2, NULL, EQL_EXISTS, 0 )) ) {</a>
<a name="ln670"> </a>
<a name="ln671">                    eq2taut = iiEmpty; /* the component has stereo in the preceding layer  */</a>
<a name="ln672">                }</a>
<a name="ln673">            }</a>
<a name="ln674">#endif</a>
<a name="ln675">        } else</a>
<a name="ln676">        /*========= if not bSecondNonTautPass then compare iso taut stereo to non-iso taut ========*/</a>
<a name="ln677">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln678">            /* compare tautomeric isotopic to tautomeric non-isotopic */</a>
<a name="ln679">            if ( !eq2taut ) {</a>
<a name="ln680">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln681">                                    /* taut isotopic */                  /* taut non-isotopic */</a>
<a name="ln682">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln683">                          Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Taut, EQL_SP2, 0 );</a>
<a name="ln684">                                 /* stereo     isotopic taut =  taut (stereo) */</a>
<a name="ln685">                eq2taut = eq2taut? (iiSTEREO | iitISO ) : 0;</a>
<a name="ln686">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln687">                if ( !eq2taut &amp;&amp; pINChI &amp;&amp; !((Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln688">                     Eql_INChI_Stereo( Stereo, EQL_SP2, NULL, EQL_EXISTS, 0 ) ) ) {</a>
<a name="ln689">                    /* component has no MI stereo; check whether it has stereo in the preceding layer M */</a>
<a name="ln690">                    if ( (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln691">                         Eql_INChI_Stereo( Stereo_Taut, EQL_SP2, NULL, EQL_EXISTS, 0 ) ) {</a>
<a name="ln692">                        eq2taut = iiEmpty; /* the component has stereo in the preceding layer  */</a>
<a name="ln693">                    }</a>
<a name="ln694">                }</a>
<a name="ln695">#endif</a>
<a name="ln696">            }</a>
<a name="ln697">        }</a>
<a name="ln698">        if ( eq2taut ) {</a>
<a name="ln699">            /* we may be here only in case of the current layer found equal in another layer the same component */</a>
<a name="ln700">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln701">                /* previous component exists; output it before output the current component */</a>
<a name="ln702">                if ( bNext ++ ) {</a>
<a name="ln703">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln704">                }</a>
<a name="ln705">                if ( (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln706">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln707"> </a>
<a name="ln708">                    tot_len += MakeStereoString( Stereo_Prev-&gt;nBondAtom1, Stereo_Prev-&gt;nBondAtom2,</a>
<a name="ln709">                                                 Stereo_Prev-&gt;b_parity,</a>
<a name="ln710">                                                 0, Stereo_Prev-&gt;nNumberOfStereoBonds,</a>
<a name="ln711">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln712">                }</a>
<a name="ln713">            } else</a>
<a name="ln714">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln715">                /* previous non-taut component exists only in taut list */</a>
<a name="ln716">                if ( bNext ++ ) {</a>
<a name="ln717">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln718">                }</a>
<a name="ln719">                /* do not output stereo of non-tautomeric in non-taut layer: it has been output in the main layer */</a>
<a name="ln720">            }</a>
<a name="ln721">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln722">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln723">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln724">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln725">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln726">                    multPrevEquStr ++;</a>
<a name="ln727">                } else {</a>
<a name="ln728">                    /* new EqStr is different; output it */</a>
<a name="ln729">                    if ( bNext ++ ) {</a>
<a name="ln730">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln731">                    }</a>
<a name="ln732">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln733">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln734">                    multPrevEquStr = 1;</a>
<a name="ln735">                }</a>
<a name="ln736">            } else {</a>
<a name="ln737">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln738">                multPrevEquStr = 1;</a>
<a name="ln739">            }</a>
<a name="ln740">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln741">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln742">            mult           = 0;</a>
<a name="ln743">            eq2tautPrev    = 1;     /* pINChI_Prev and pINChI_Taut_Prev have already been output */</a>
<a name="ln744">        } else </a>
<a name="ln745">        if ( eq2tautPrev ) {</a>
<a name="ln746">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln747">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln748">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln749">                /* new EqStr is different; output it */</a>
<a name="ln750">                if ( bNext ++ ) {</a>
<a name="ln751">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln752">                }</a>
<a name="ln753">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln754">                pPrevEquStr = NULL;</a>
<a name="ln755">                multPrevEquStr = 0;</a>
<a name="ln756">            }</a>
<a name="ln757">            eq2tautPrev = 0;</a>
<a name="ln758">            pINChI_Prev      = pINChI;</a>
<a name="ln759">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln760">            mult = 0;</a>
<a name="ln761">        } else {</a>
<a name="ln762">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln763">            /* compare the current layer to this layer of the previous component: */</a>
<a name="ln764">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp2 */</a>
<a name="ln765">            /*================ compare iso sp2 to previous =====================*/</a>
<a name="ln766">            eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln767">                     pINChI &amp;&amp; pINChI_Prev &amp;&amp;</a>
<a name="ln768">                     (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln769">                     Eql_INChI_Stereo( Stereo, EQL_SP2, Stereo_Prev, EQL_SP2, 0 );</a>
<a name="ln770">            if ( eq2prev ) {</a>
<a name="ln771">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln772">                continue;</a>
<a name="ln773">            } else {</a>
<a name="ln774">                /* the current layer is different from this layer of the previous component */</a>
<a name="ln775">                /* therefore print the current layer */</a>
<a name="ln776">                if ( bNext ++ ) {</a>
<a name="ln777">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln778">                }</a>
<a name="ln779">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln780">                    if ( (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln781">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln782"> </a>
<a name="ln783">                        tot_len += MakeStereoString( Stereo_Prev-&gt;nBondAtom1, Stereo_Prev-&gt;nBondAtom2,</a>
<a name="ln784">                                                     Stereo_Prev-&gt;b_parity,</a>
<a name="ln785">                                                     0, Stereo_Prev-&gt;nNumberOfStereoBonds,</a>
<a name="ln786">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln787">                    }</a>
<a name="ln788">                    /* else sp2 info is not present in pINChI_Prev */</a>
<a name="ln789">                } else</a>
<a name="ln790">                /* do not print pINChI_Prev because it either do not exist of have already been printed */</a>
<a name="ln791">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln792">                     if ( (Stereo_Taut_Prev = pINChI_Taut_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Taut_Prev-&gt;nNumberOfStereoBonds &gt; 0 ) {</a>
<a name="ln793">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln794">                        /* and it has non-trivial sp2 info */</a>
<a name="ln795">                        /*</a>
<a name="ln796">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln797">                        */</a>
<a name="ln798">                        ;/* pINChI_Taut_Prev sp3 info was output in the main stereo section */</a>
<a name="ln799">                     } else {</a>
<a name="ln800">                        ; /* pINChI_Taut_Prev exists and has not sp2 info */</a>
<a name="ln801">                     }</a>
<a name="ln802">                }</a>
<a name="ln803">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln804">                else {</a>
<a name="ln805">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln806">                }</a>
<a name="ln807">#endif</a>
<a name="ln808">            }</a>
<a name="ln809">            pINChI_Prev = pINChI;</a>
<a name="ln810">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln811">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln812">        }</a>
<a name="ln813">    }</a>
<a name="ln814">    return tot_len;</a>
<a name="ln815">}</a>
<a name="ln816">/******************************************************************************************/</a>
<a name="ln817">int str_IsoSp3(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln818">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components, int bRelRac,</a>
<a name="ln819">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln820">{</a>
<a name="ln821">    int          i, ii, ii2;</a>
<a name="ln822">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln823">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln824">    INChI_Stereo *Stereo, *Stereo_Prev, *Stereo_Taut, *Stereo_Taut_Prev;</a>
<a name="ln825">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln826">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln827">    int         multPrevEquStr;        </a>
<a name="ln828">    pINChI_Taut      = NULL;</a>
<a name="ln829">    pINChI_Prev      = NULL;</a>
<a name="ln830">    pINChI_Taut_Prev = NULL;</a>
<a name="ln831">    mult        = 0;</a>
<a name="ln832">    bNext       = 0;</a>
<a name="ln833">    is          = NULL;</a>
<a name="ln834">    is2         = NULL;</a>
<a name="ln835">    is0         = pINChISort;</a>
<a name="ln836">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln837">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln838">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln839">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln840">    multPrevEquStr = 0;        </a>
<a name="ln841">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln842">#else</a>
<a name="ln843">    bRelRac = 0;</a>
<a name="ln844">#endif</a>
<a name="ln845">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln846">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln847">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln848">        /*================ compare sp2 to previous =====================*/</a>
<a name="ln849">        if ( bSecondNonTautPass ) {</a>
<a name="ln850">            /* component that was output on the 1st pass */</a>
<a name="ln851">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln852">        }</a>
<a name="ln853">        eq2taut = 0;</a>
<a name="ln854">        /*========= if bSecondNonTautPass then compare iso non-taut stereo to other stereo ========*/</a>
<a name="ln855">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln856">            /* compare non-tautomeric isotopic to:</a>
<a name="ln857">             *   a) non-tautomeric non-isotopic</a>
<a name="ln858">             *   b) tautomeric non-isotopic</a>
<a name="ln859">             *   c) tautomeric isotopic</a>
<a name="ln860">             */</a>
<a name="ln861">            /* a) compare non-tautomeric isotopic to non-tautomeric non-isotopic */</a>
<a name="ln862">            if ( !eq2taut ) {</a>
<a name="ln863">                eq2taut = pINChI &amp;&amp; /* non-taut isotopic */                  /* non-taut non-isotopic */</a>
<a name="ln864">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln865">                          Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Taut, EQL_SP3, bRelRac );</a>
<a name="ln866">                                 /* stereo     isotopic non-taut =  non-taut (stereo) */</a>
<a name="ln867">                eq2taut = eq2taut? (iiSTEREO | iitISO | iitNONTAUT | iiEq2NONTAUT ) : 0;</a>
<a name="ln868">            }</a>
<a name="ln869">            /* b) compare non-tautomeric isotopic to tautomeric non-isotopic */</a>
<a name="ln870">            if ( !eq2taut ) {</a>
<a name="ln871">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln872">                                    /* non-taut isotopic */                  /* taut non-isotopic */</a>
<a name="ln873">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln874">                          Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Taut, EQL_SP3, bRelRac );</a>
<a name="ln875">                                 /* stereo     isotopic non-taut =  taut (stereo) */</a>
<a name="ln876">                eq2taut = eq2taut? (iiSTEREO | iitISO | iitNONTAUT ) : 0;</a>
<a name="ln877">            }</a>
<a name="ln878">            /* c) compare non-tautomeric isotopic to tautomeric isotopic */</a>
<a name="ln879">            if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln880">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln881">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln882">                          Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Taut, EQL_SP3, bRelRac );</a>
<a name="ln883">                                 /* stereo     isotopic non-taut =  isotopic taut (stereo) */</a>
<a name="ln884">                eq2taut = eq2taut? (iiSTEREO | iitISO | iitNONTAUT | iiEq2ISO) : 0;</a>
<a name="ln885">            }</a>
<a name="ln886">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln887">            if ( !eq2taut &amp;&amp; pINChI &amp;&amp; !((Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln888">                Eql_INChI_Stereo( Stereo, EQL_SP3, NULL, EQL_EXISTS, 0 )) ) {</a>
<a name="ln889">                 /* component has no stereo; check whether it has stereo in the preceding layers */</a>
<a name="ln890">                if ( pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp; /* F is not empty */</a>
<a name="ln891">                     Eql_INChI_Stereo( Stereo_Taut, EQL_SP3, NULL, EQL_EXISTS, 0 ) ||</a>
<a name="ln892">                    !(pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;  /* M is empty and ... */</a>
<a name="ln893">                       Eql_INChI_Stereo( Stereo_Taut, EQL_SP3, NULL, EQL_EXISTS, 0 )) &amp;&amp;</a>
<a name="ln894">                     (pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;  /* ... MI is not empty */</a>
<a name="ln895">                       Eql_INChI_Stereo( Stereo_Taut, EQL_SP3, NULL, EQL_EXISTS, 0 )) ) {</a>
<a name="ln896"> </a>
<a name="ln897">                    eq2taut = iiEmpty; /* the component has stereo in the preceding layer  */</a>
<a name="ln898">                }</a>
<a name="ln899">            }</a>
<a name="ln900">#endif</a>
<a name="ln901">        } else</a>
<a name="ln902">        /*========= if not bSecondNonTautPass then compare iso taut stereo to non-iso taut ========*/</a>
<a name="ln903">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln904">            /* compare tautomeric isotopic to tautomeric non-isotopic */</a>
<a name="ln905">            if ( !eq2taut ) {</a>
<a name="ln906">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln907">                                    /* taut isotopic */                  /* taut non-isotopic */</a>
<a name="ln908">                          (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln909">                          Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Taut, EQL_SP3, bRelRac );</a>
<a name="ln910">                                 /* stereo     isotopic taut =  taut (stereo) */</a>
<a name="ln911">                eq2taut = eq2taut? (iiSTEREO | iitISO ) : 0;</a>
<a name="ln912">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln913">                if ( !eq2taut &amp;&amp; pINChI &amp;&amp; !((Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln914">                     Eql_INChI_Stereo( Stereo, EQL_SP3, NULL, EQL_EXISTS, 0 ) ) ) {</a>
<a name="ln915">                    /* component has no MI stereo; check whether it has stereo in the preceding layer M */</a>
<a name="ln916">                    if ( (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln917">                         Eql_INChI_Stereo( Stereo_Taut, EQL_SP3, NULL, EQL_EXISTS, 0 ) ) {</a>
<a name="ln918">                        eq2taut = iiEmpty; /* the component has stereo in the preceding layer  */</a>
<a name="ln919">                    }</a>
<a name="ln920">                }</a>
<a name="ln921">#endif</a>
<a name="ln922">            }</a>
<a name="ln923">        }</a>
<a name="ln924">        if ( eq2taut ) {</a>
<a name="ln925">            /* we may be here only in case of the current layer found equal in another layer the same component */</a>
<a name="ln926">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln927">                /* previous component exists; output it before output the current component */</a>
<a name="ln928">                if ( bNext ++ ) {</a>
<a name="ln929">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln930">                }</a>
<a name="ln931">                if ( (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoCenters &gt; bRelRac ) {</a>
<a name="ln932">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln933"> </a>
<a name="ln934">                    tot_len += MakeStereoString( Stereo_Prev-&gt;nNumber, NULL, Stereo_Prev-&gt;t_parity,</a>
<a name="ln935">                                                 0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln936">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln937">                }</a>
<a name="ln938">            } else</a>
<a name="ln939">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln940">                /* previous non-taut component exists only in taut list */</a>
<a name="ln941">                if ( bNext ++ ) {</a>
<a name="ln942">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln943">                }</a>
<a name="ln944">                /* do not output stereo of non-tautomeric in non-taut layer: it has been output in the main layer */</a>
<a name="ln945">            }</a>
<a name="ln946">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln947">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln948">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln949">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln950">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln951">                    multPrevEquStr ++;</a>
<a name="ln952">                } else {</a>
<a name="ln953">                    /* new EqStr is different; output it */</a>
<a name="ln954">                    if ( bNext ++ ) {</a>
<a name="ln955">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln956">                    }</a>
<a name="ln957">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln958">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln959">                    multPrevEquStr = 1;</a>
<a name="ln960">                }</a>
<a name="ln961">            } else {</a>
<a name="ln962">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln963">                multPrevEquStr = 1;</a>
<a name="ln964">            }</a>
<a name="ln965">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln966">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln967">            mult           = 0;</a>
<a name="ln968">            eq2tautPrev    = 1;     /* pINChI_Prev and pINChI_Taut_Prev have already been output */</a>
<a name="ln969">        } else </a>
<a name="ln970">        if ( eq2tautPrev ) {</a>
<a name="ln971">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln972">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln973">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln974">                /* new EqStr is different; output it */</a>
<a name="ln975">                if ( bNext ++ ) {</a>
<a name="ln976">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln977">                }</a>
<a name="ln978">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln979">                pPrevEquStr = NULL;</a>
<a name="ln980">                multPrevEquStr = 0;</a>
<a name="ln981">            }</a>
<a name="ln982">            eq2tautPrev = 0;</a>
<a name="ln983">            pINChI_Prev      = pINChI;</a>
<a name="ln984">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln985">            mult = 0;</a>
<a name="ln986">        } else {</a>
<a name="ln987">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln988">            /* compare the current layer to this layer of the previous component: */</a>
<a name="ln989">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp2 */</a>
<a name="ln990">            /*================ compare iso sp3 to previous =====================*/</a>
<a name="ln991">            eq2prev =bUseMulipliers &amp;&amp; pINChI &amp;&amp; pINChI_Prev &amp;&amp;</a>
<a name="ln992">                     (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln993">                     Eql_INChI_Stereo( Stereo, EQL_SP3, Stereo_Prev, EQL_SP3, bRelRac );</a>
<a name="ln994">            if ( eq2prev ) {</a>
<a name="ln995">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln996">                continue;</a>
<a name="ln997">            } else {</a>
<a name="ln998">                if ( bNext ++ ) {</a>
<a name="ln999">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1000">                }</a>
<a name="ln1001">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1002">                    if ( (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoCenters &gt; bRelRac ) {</a>
<a name="ln1003">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1004"> </a>
<a name="ln1005">                        tot_len += MakeStereoString( Stereo_Prev-&gt;nNumber, NULL, Stereo_Prev-&gt;t_parity,</a>
<a name="ln1006">                                                     0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln1007">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1008">                    }</a>
<a name="ln1009">                    /* else sp3 info is not present in pINChI_Prev */</a>
<a name="ln1010">                } else</a>
<a name="ln1011">                /* do not print pINChI_Prev because it either do not exist of have already been printed */</a>
<a name="ln1012">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1013">                     if ( (Stereo_Taut_Prev = pINChI_Taut_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Taut_Prev-&gt;nNumberOfStereoCenters &gt; bRelRac ) {</a>
<a name="ln1014">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln1015">                        /* and it has non-trivial sp2 info */</a>
<a name="ln1016">                        /*</a>
<a name="ln1017">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1018">                        */</a>
<a name="ln1019">                        ;/* pINChI_Taut_Prev sp3 info was output in the main stereo section */</a>
<a name="ln1020">                     } else {</a>
<a name="ln1021">                        ; /* pINChI_Taut_Prev exists and has not sp3 info */</a>
<a name="ln1022">                     }</a>
<a name="ln1023">                }</a>
<a name="ln1024">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1025">                else {</a>
<a name="ln1026">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln1027">                }</a>
<a name="ln1028">#endif</a>
<a name="ln1029">            }</a>
<a name="ln1030">            pINChI_Prev = pINChI;</a>
<a name="ln1031">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln1032">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln1033">        }</a>
<a name="ln1034">    }</a>
<a name="ln1035">    return tot_len;</a>
<a name="ln1036">}</a>
<a name="ln1037">/***************************************************************************/</a>
<a name="ln1038">int str_AuxEqu(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln1039">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln1040">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln1041">{</a>
<a name="ln1042">    int          i, ii, ii2;</a>
<a name="ln1043">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln1044">    INChI_Aux    *pINChI_Aux = NULL, *pINChI_Aux_Prev, *pINChI_Aux_Taut, *pINChI_Aux_Taut_Prev;</a>
<a name="ln1045">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln1046">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln1047">    int         multPrevEquStr;        </a>
<a name="ln1048">    pINChI_Aux_Prev      = NULL;</a>
<a name="ln1049">    pINChI_Aux_Taut      = NULL;</a>
<a name="ln1050">    pINChI_Aux_Taut_Prev = NULL;</a>
<a name="ln1051"> </a>
<a name="ln1052">    mult        = 0;</a>
<a name="ln1053">    bNext       = 0;</a>
<a name="ln1054">    is          = NULL;</a>
<a name="ln1055">    is2         = NULL;</a>
<a name="ln1056">    is0         = pINChISort;</a>
<a name="ln1057">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln1058">    eq2taut     = 0; /* may be non-zero only on the 2nd (non-taut) pass */</a>
<a name="ln1059">    eq2tautPrev = 1; /* pINChI_Aux_Prev (previous pINChI_Aux) does not exist */</a>
<a name="ln1060">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln1061">    multPrevEquStr = 0;        </a>
<a name="ln1062">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln1063">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln1064">        pINChI_Aux = (i &lt; num_components &amp;&amp; (is = is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln1065">        if ( bSecondNonTautPass ) {</a>
<a name="ln1066">            /* component that was output on the 1st pass */</a>
<a name="ln1067">            pINChI_Aux_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI_Aux[ii2] : NULL;</a>
<a name="ln1068">        }</a>
<a name="ln1069">        /*================ compare non-iso non-taut equivalence info to non-iso taut ========*/</a>
<a name="ln1070">        eq2taut = bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp;</a>
<a name="ln1071">                  Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU, pINChI_Aux_Taut, EQL_EQU );</a>
<a name="ln1072">        eq2taut = eq2taut? (iiEQU | iitNONTAUT) : 0;</a>
<a name="ln1073">        if ( eq2taut ) {</a>
<a name="ln1074">            /* we may be here only in case of the second (non-taut) pass */</a>
<a name="ln1075">            /* current non-taut equivalence has been found to be same as tautomeric */</a>
<a name="ln1076">            if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1077">                /* previous component exists */</a>
<a name="ln1078">                if ( bNext ++ ) {</a>
<a name="ln1079">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1080">                }</a>
<a name="ln1081">                if ( bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms) ) {</a>
<a name="ln1082">                    /* output previous component(s) equivalence since it was found to be non-trivial */</a>
<a name="ln1083">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1084">                    tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms, 0,</a>
<a name="ln1085">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1086">                } else {</a>
<a name="ln1087">                    ; /* pINChI_Aux_Prev exists and has only trivial equivalence info */</a>
<a name="ln1088">                }</a>
<a name="ln1089">            } else</a>
<a name="ln1090">            if ( pINChI_Aux_Taut_Prev &amp;&amp; pINChI_Aux_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1091">                /* previous non-taut component exists only in taut list */</a>
<a name="ln1092">                if ( bNext ++ ) {</a>
<a name="ln1093">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1094">                }</a>
<a name="ln1095">            }</a>
<a name="ln1096">            /* we have found pINChI_Aux-&gt;nConstitEquNumbers same as in pINChI_Aux_Taut */</a>
<a name="ln1097">            /* output this (current) equivalence as '*', that is, same as tautomeric */</a>
<a name="ln1098">            /* that was printed on the 1st pass. */</a>
<a name="ln1099">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln1100">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1101">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln1102">                    multPrevEquStr ++;</a>
<a name="ln1103">                } else {</a>
<a name="ln1104">                    /* new EqStr is different; output it */</a>
<a name="ln1105">                    if ( bNext ++ ) {</a>
<a name="ln1106">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1107">                    }</a>
<a name="ln1108">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1109">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln1110">                    multPrevEquStr = 1;</a>
<a name="ln1111">                }</a>
<a name="ln1112">            } else {</a>
<a name="ln1113">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln1114">                multPrevEquStr = 1;</a>
<a name="ln1115">            }</a>
<a name="ln1116">            pINChI_Aux_Prev      = NULL; /* pINChI_Aux_Prev does not exist since */</a>
<a name="ln1117">            pINChI_Aux_Taut_Prev = NULL; /* pINChI_Aux has just been printed */</a>
<a name="ln1118">            mult           = 0;</a>
<a name="ln1119">            eq2tautPrev    = 1;</a>
<a name="ln1120">        } else</a>
<a name="ln1121">        if ( eq2tautPrev ) {</a>
<a name="ln1122">            /* at this point pINChI_Aux_Prev does not exist; however, pINChI_Aux */</a>
<a name="ln1123">             /*might have been discovered and it is different from pINChI_Aux_Taut */</a>
<a name="ln1124">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1125">                /* new EqStr is different; output it */</a>
<a name="ln1126">                if ( bNext ++ ) {</a>
<a name="ln1127">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1128">                }</a>
<a name="ln1129">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1130">                pPrevEquStr = NULL;</a>
<a name="ln1131">                multPrevEquStr = 0;</a>
<a name="ln1132">            }</a>
<a name="ln1133">            eq2tautPrev = 0;</a>
<a name="ln1134">            pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln1135">            pINChI_Aux_Taut_Prev = pINChI_Aux_Taut;</a>
<a name="ln1136">            mult = 0;</a>
<a name="ln1137">        } else {</a>
<a name="ln1138">            /* check whether pINChI_Aux and pINChI_Aux_Prev have identical non-trivial equivalence info */</a>
<a name="ln1139">            eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln1140">                      Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU, pINChI_Aux_Prev, EQL_EQU );</a>
<a name="ln1141">            if ( eq2prev ) {</a>
<a name="ln1142">                /* eq. info is same and non-trivial */</a>
<a name="ln1143">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln1144">                continue;</a>
<a name="ln1145">            } else {</a>
<a name="ln1146">                /* pINChI_Aux eq. info is either different or trivial. Output pINChI_Aux_Prev anyway */</a>
<a name="ln1147">                if ( bNext ++ ) {</a>
<a name="ln1148">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1149">                }</a>
<a name="ln1150">                if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1151">                     if ( bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms) ) {</a>
<a name="ln1152">                        /* pINChI_Aux_Prev exists and has equivalence info */</a>
<a name="ln1153">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1154">                        tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms, 0,</a>
<a name="ln1155">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1156">                     } else {</a>
<a name="ln1157">                        ; /* pINChI_Aux_Prev exists and has only trivial equivalence info */</a>
<a name="ln1158">                     }</a>
<a name="ln1159">                } else</a>
<a name="ln1160">                if ( bSecondNonTautPass &amp;&amp; pINChI_Aux_Taut_Prev &amp;&amp; pINChI_Aux_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1161">                     if ( bHasEquString( pINChI_Aux_Taut_Prev-&gt;nConstitEquNumbers, pINChI_Aux_Taut_Prev-&gt;nNumberOfAtoms) ) {</a>
<a name="ln1162">                        /* since pINChI_Aux_Prev does not exist, pINChI_Aux_Taut_Prev is non-tautomeric */</a>
<a name="ln1163">                        /* and it has non-trivial equivalence info. This info has already been printed in the main section  */</a>
<a name="ln1164">                        /*</a>
<a name="ln1165">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1166">                        */</a>
<a name="ln1167">                     } else {</a>
<a name="ln1168">                         ; /* pINChI_Aux_Taut_Prev exists and has only trivial equivalence info */</a>
<a name="ln1169">                     }</a>
<a name="ln1170">                }</a>
<a name="ln1171">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1172">                else {</a>
<a name="ln1173">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln1174">                }</a>
<a name="ln1175">#endif</a>
<a name="ln1176">            }</a>
<a name="ln1177">            pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln1178">            pINChI_Aux_Taut_Prev = pINChI_Aux_Taut;</a>
<a name="ln1179">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln1180">        }</a>
<a name="ln1181">    }</a>
<a name="ln1182">    return tot_len;</a>
<a name="ln1183">}</a>
<a name="ln1184">/******************************************************************************************/</a>
<a name="ln1185">int str_AuxInvSp3(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln1186">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln1187">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln1188">{</a>
<a name="ln1189">    int          i, ii, ii2;</a>
<a name="ln1190">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln1191">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln1192">    INChI_Stereo *Stereo, *Stereo_Prev, *Stereo_Taut, *Stereo_Taut_Prev;</a>
<a name="ln1193">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln1194">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln1195">    int         multPrevEquStr;        </a>
<a name="ln1196">    /***************</a>
<a name="ln1197">      inverted sp3</a>
<a name="ln1198">    ****************/</a>
<a name="ln1199">    pINChI_Taut      = NULL;</a>
<a name="ln1200">    pINChI_Prev      = NULL;</a>
<a name="ln1201">    pINChI_Taut_Prev = NULL;</a>
<a name="ln1202">    mult        = 0;</a>
<a name="ln1203">    bNext       = 0;</a>
<a name="ln1204">    is          = NULL;</a>
<a name="ln1205">    is2         = NULL;</a>
<a name="ln1206">    is0         = pINChISort;</a>
<a name="ln1207">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln1208">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln1209">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln1210">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln1211">    multPrevEquStr = 0;        </a>
<a name="ln1212">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln1213">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln1214">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln1215">        /*================ compare sp2 to previous =====================*/</a>
<a name="ln1216">        if ( bSecondNonTautPass ) {</a>
<a name="ln1217">            /* component that was output on the 1st pass */</a>
<a name="ln1218">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln1219">        }</a>
<a name="ln1220">        eq2taut = 0;</a>
<a name="ln1221">        /*========= if bSecondNonTautPass then compare iso non-taut stereo to other stereo ========*/</a>
<a name="ln1222">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln1223">            /* compare non-tautomeric inverted to:</a>
<a name="ln1224">             *   a) tautomeric inverted</a>
<a name="ln1225">             *   b) Inverted(tautomeric)</a>
<a name="ln1226">             *   c) Inverted(non-tautomeric)</a>
<a name="ln1227">             */</a>
<a name="ln1228">            /* a) compare non-tautomeric inverted to tautomeric inverted */</a>
<a name="ln1229">            if ( !eq2taut ) {</a>
<a name="ln1230">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1231">                          /* non-taut inverted */          /* taut invertedc */</a>
<a name="ln1232">                  (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln1233">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3_INV, 0 );</a>
<a name="ln1234">                                 /* stereo-inv      non-taut =  taut (stereo-inv) */</a>
<a name="ln1235">                eq2taut = eq2taut? (iiSTEREO_INV | iitNONTAUT ) : 0;</a>
<a name="ln1236">            }</a>
<a name="ln1237">            /* b) compare non-tautomeric inverted to Inverted(tautomeric stereo) */</a>
<a name="ln1238">            if ( !eq2taut ) {</a>
<a name="ln1239">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1240">                  (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln1241">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3, 0 );</a>
<a name="ln1242">                                 /* stereo-inv    non-taut =  Inv(taut stereo) */</a>
<a name="ln1243">                eq2taut = eq2taut? (iiSTEREO_INV | iitNONTAUT | iiEq2INV) : 0;</a>
<a name="ln1244">            }</a>
<a name="ln1245">            /* c) compare non-tautomeric inverted to Inverted(non-tautomeric stereo) */</a>
<a name="ln1246">            if ( !eq2taut ) {</a>
<a name="ln1247">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln1248">                  (Stereo = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln1249">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo, EQL_SP3, 0 );</a>
<a name="ln1250">                                 /* stereo-inv    non-taut =  Inv(non-taut stereo) */</a>
<a name="ln1251">                eq2taut = eq2taut? (iiSTEREO_INV | iitNONTAUT | iiEq2INV | iiEq2NONTAUT) : 0;</a>
<a name="ln1252">            }</a>
<a name="ln1253">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln1254">            if ( !eq2taut &amp;&amp; pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1255">                 !((Stereo = pINChI-&gt;Stereo) &amp;&amp; Eql_INChI_Stereo( Stereo, EQL_SP3_INV, NULL, EQL_EXISTS, 0 ))) {</a>
<a name="ln1256">                if ( (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln1257">                     Eql_INChI_Stereo( Stereo_Taut, EQL_SP3, NULL, EQL_EXISTS, 0 ) ) {</a>
<a name="ln1258"> </a>
<a name="ln1259">                    eq2taut = iiEmpty; /* the current is empty while the preceding (taut) is not */</a>
<a name="ln1260">                }</a>
<a name="ln1261">            }</a>
<a name="ln1262">#endif</a>
<a name="ln1263">        } else</a>
<a name="ln1264">        /*========= if not bSecondNonTautPass then compare inv taut stereo to various taut stereo ========*/</a>
<a name="ln1265">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln1266">            /* compare tautomeric inverted to Invetred(tautomeric) */</a>
<a name="ln1267">            if ( !eq2taut ) {</a>
<a name="ln1268">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln1269">                  (Stereo = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln1270">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo, EQL_SP3, 0 );</a>
<a name="ln1271">                                 /* stereo     isotopic taut =  taut (stereo) */</a>
<a name="ln1272">                eq2taut = eq2taut? (iiSTEREO_INV | iiEq2INV ) : 0;</a>
<a name="ln1273">            }</a>
<a name="ln1274">        }</a>
<a name="ln1275">        if ( eq2taut ) {</a>
<a name="ln1276">            /* we may be here only in case of the current layer found equal in another layer the same component */</a>
<a name="ln1277">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1278">                /* previous component exists; output it before output the current component */</a>
<a name="ln1279">                if ( bNext ++ ) {</a>
<a name="ln1280">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1281">                }</a>
<a name="ln1282">                if ( (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoCenters &gt; 0 ) {</a>
<a name="ln1283">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1284"> </a>
<a name="ln1285">                    tot_len += MakeStereoString( Stereo_Prev-&gt;nNumber, NULL, Stereo_Prev-&gt;t_parityInv,</a>
<a name="ln1286">                                                 0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln1287">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1288">                }</a>
<a name="ln1289">            } else</a>
<a name="ln1290">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1291">                /* previous non-taut component exists only in taut list */</a>
<a name="ln1292">                if ( bNext ++ ) {</a>
<a name="ln1293">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1294">                }</a>
<a name="ln1295">                /* do not output stereo of non-tautomeric in non-taut layer: it has been output in the main layer */</a>
<a name="ln1296">            }</a>
<a name="ln1297">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln1298">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln1299">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln1300">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1301">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln1302">                    multPrevEquStr ++;</a>
<a name="ln1303">                } else {</a>
<a name="ln1304">                    /* new EqStr is different; output it */</a>
<a name="ln1305">                    if ( bNext ++ ) {</a>
<a name="ln1306">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1307">                    }</a>
<a name="ln1308">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1309">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln1310">                    multPrevEquStr = 1;</a>
<a name="ln1311">                }</a>
<a name="ln1312">            } else {</a>
<a name="ln1313">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln1314">                multPrevEquStr = 1;</a>
<a name="ln1315">            }</a>
<a name="ln1316">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln1317">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln1318">            mult           = 0;</a>
<a name="ln1319">            eq2tautPrev    = 1;     /* pINChI_Prev and pINChI_Taut_Prev have already been output */</a>
<a name="ln1320">        } else </a>
<a name="ln1321">        if ( eq2tautPrev ) {</a>
<a name="ln1322">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln1323">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln1324">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1325">                /* new EqStr is different; output it */</a>
<a name="ln1326">                if ( bNext ++ ) {</a>
<a name="ln1327">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1328">                }</a>
<a name="ln1329">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1330">                pPrevEquStr = NULL;</a>
<a name="ln1331">                multPrevEquStr = 0;</a>
<a name="ln1332">            }</a>
<a name="ln1333">            eq2tautPrev = 0;</a>
<a name="ln1334">            pINChI_Prev      = pINChI;</a>
<a name="ln1335">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln1336">            mult = 0;</a>
<a name="ln1337">        } else {</a>
<a name="ln1338">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln1339">            /* compare the current layer to this layer of the previous component: */</a>
<a name="ln1340">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp2 */</a>
<a name="ln1341">            /*================ compare iso sp3 to previous =====================*/</a>
<a name="ln1342">            eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln1343">                     pINChI &amp;&amp; pINChI_Prev &amp;&amp;</a>
<a name="ln1344">                     /* do both have stereo? */</a>
<a name="ln1345">                     (Stereo = pINChI-&gt;Stereo) &amp;&amp; (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp;</a>
<a name="ln1346">                     /* is their inverted stereo same? */</a>
<a name="ln1347">                     Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Prev, EQL_SP3_INV, 0 );</a>
<a name="ln1348">            if ( eq2prev ) {</a>
<a name="ln1349">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln1350">                continue;</a>
<a name="ln1351">            } else {</a>
<a name="ln1352">                if ( bNext ++ ) {</a>
<a name="ln1353">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1354">                }</a>
<a name="ln1355">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1356">                    if ( (Stereo_Prev = pINChI_Prev-&gt;Stereo) &amp;&amp;</a>
<a name="ln1357">                          Stereo_Prev-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp; Stereo_Prev-&gt;nCompInv2Abs ) {</a>
<a name="ln1358">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1359"> </a>
<a name="ln1360">                        tot_len += MakeStereoString( Stereo_Prev-&gt;nNumberInv, NULL, Stereo_Prev-&gt;t_parityInv,</a>
<a name="ln1361">                                                     0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln1362">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1363">                    }</a>
<a name="ln1364">                    /* else sp3 info is not present in pINChI_Prev */</a>
<a name="ln1365">                } else</a>
<a name="ln1366">                /* do not print pINChI_Prev because it either do not exist of have already been printed */</a>
<a name="ln1367">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1368">                     if ( (Stereo_Taut_Prev = pINChI_Taut_Prev-&gt;Stereo) &amp;&amp;</a>
<a name="ln1369">                           Stereo_Taut_Prev-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp; Stereo_Taut_Prev-&gt;nCompInv2Abs ) {</a>
<a name="ln1370">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln1371">                        /* and it has non-trivial inv sp3 info. It has already been printed in the main section */</a>
<a name="ln1372">                        /*</a>
<a name="ln1373">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1374">                        */</a>
<a name="ln1375">                        ;/* pINChI_Taut_Prev sp3 info was output in the main stereo section */</a>
<a name="ln1376">                     } else {</a>
<a name="ln1377">                        ; /* pINChI_Taut_Prev exists and has not sp3 info */</a>
<a name="ln1378">                     }</a>
<a name="ln1379">                }</a>
<a name="ln1380">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1381">                else {</a>
<a name="ln1382">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln1383">                }</a>
<a name="ln1384">#endif</a>
<a name="ln1385">            }</a>
<a name="ln1386">            pINChI_Prev = pINChI;</a>
<a name="ln1387">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln1388">        }</a>
<a name="ln1389">    }</a>
<a name="ln1390">    return tot_len;</a>
<a name="ln1391">}</a>
<a name="ln1392">/***************************************************************************/</a>
<a name="ln1393">int str_AuxInvSp3Numb(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln1394">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln1395">              int bSecondNonTautPass, int bOmitRepetitions)</a>
<a name="ln1396">{</a>
<a name="ln1397">    int          i, ii, ii2;</a>
<a name="ln1398">    INCHI_SORT   *is, *is0 /*, *is2*/;</a>
<a name="ln1399">    INChI        *pINChI,  *pINChI_Taut;</a>
<a name="ln1400">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev, *pINChI_Aux_Taut;</a>
<a name="ln1401">    INChI_Stereo *Stereo, *Stereo_Taut;</a>
<a name="ln1402">    int          eq2taut, bNext;</a>
<a name="ln1403">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln1404">    int         multPrevEquStr;        </a>
<a name="ln1405">    /**************************************************</a>
<a name="ln1406">     * specificity of numbering: there is no previous *</a>
<a name="ln1407">     * component because no repetition is possible    *</a>
<a name="ln1408">     **************************************************/</a>
<a name="ln1409">    pINChI          = NULL;</a>
<a name="ln1410">    pINChI_Taut     = NULL;</a>
<a name="ln1411">    pINChI_Aux      = NULL;</a>
<a name="ln1412">    pINChI_Aux_Taut = NULL;</a>
<a name="ln1413">    pINChI_Aux_Prev = NULL;</a>
<a name="ln1414">    bNext       = 0;</a>
<a name="ln1415">    is          = NULL;</a>
<a name="ln1416">    is0         = pINChISort;</a>
<a name="ln1417">    /*is2         = bSecondNonTautPass? pINChISort2 : NULL;*/</a>
<a name="ln1418">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln1419">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln1420">    multPrevEquStr = 0;        </a>
<a name="ln1421">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln1422">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln1423">        is=is0+i;</a>
<a name="ln1424">        pINChI = (0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln1425">        pINChI_Aux = pINChI? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln1426">        /*================ to compare to previously printed =====================*/</a>
<a name="ln1427">        if ( bSecondNonTautPass ) {</a>
<a name="ln1428">            /* component that was printed on the 1st pass */</a>
<a name="ln1429">            pINChI_Taut     = (0 &lt;= (ii2=GET_II(OUT_T1,is)))? is-&gt;pINChI[ii2] : NULL;</a>
<a name="ln1430">            pINChI_Aux_Taut = pINChI_Taut? is-&gt;pINChI_Aux[ii2] : NULL;</a>
<a name="ln1431">        }</a>
<a name="ln1432"> </a>
<a name="ln1433">        eq2taut = 0;</a>
<a name="ln1434">        /*========= if bSecondNonTautPass then compare inv non-taut stereo to other stereo ========*/</a>
<a name="ln1435">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp;</a>
<a name="ln1436">             pINChI &amp;&amp; (Stereo = pINChI-&gt;Stereo) &amp;&amp; Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln1437">            /* compare non-tautomeric inverted stereo numbering to:</a>
<a name="ln1438">             *   a) tautomeric numbering</a>
<a name="ln1439">             *   b) non-tautomeric numbering</a>
<a name="ln1440">             *   c) tautomeric inverted stereo numbering</a>
<a name="ln1441">             */</a>
<a name="ln1442">            /* a) compare non-tautomeric inverted stereo numbering to tautomeric numbering */</a>
<a name="ln1443">            if ( !eq2taut ) {</a>
<a name="ln1444">                eq2taut = pINChI_Taut &amp;&amp;</a>
<a name="ln1445">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV, pINChI_Aux_Taut, EQL_NUM );</a>
<a name="ln1446">                                 /* stereo-inv     numbering  non-taut =  taut numbering */</a>
<a name="ln1447">                eq2taut = eq2taut? (iiSTEREO_INV | iiNUMB | iitNONTAUT ) : 0;</a>
<a name="ln1448">            }</a>
<a name="ln1449">            /* b) compare non-tautomeric inverted stereo numbering to non-tautomeric numbering */</a>
<a name="ln1450">            if ( !eq2taut ) {</a>
<a name="ln1451">                eq2taut =</a>
<a name="ln1452">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV, pINChI_Aux, EQL_NUM );</a>
<a name="ln1453">                                 /* stereo-inv     numb.     non-taut =  non-taut numbering */</a>
<a name="ln1454">                eq2taut = eq2taut? (iiSTEREO_INV | iiNUMB | iitNONTAUT | iiEq2NONTAUT ) : 0;</a>
<a name="ln1455">            }</a>
<a name="ln1456">            /* c) compare non-tautomeric inverted stereo numbering to tautomeric inverted stereo numbering */</a>
<a name="ln1457">            if ( !eq2taut ) {</a>
<a name="ln1458">                eq2taut = pINChI_Taut &amp;&amp;</a>
<a name="ln1459">                  (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp; Stereo_Taut-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln1460">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV, pINChI_Aux_Taut, EQL_NUM_INV );</a>
<a name="ln1461">                                 /* stereo-inv     numb.     non-taut =  taut inv stereo numbering */</a>
<a name="ln1462">                eq2taut = eq2taut? (iiSTEREO_INV | iiNUMB | iitNONTAUT | iiEq2INV ) : 0;</a>
<a name="ln1463">            }</a>
<a name="ln1464">        } else</a>
<a name="ln1465">        /*========= if not bSecondNonTautPass then compare inv taut stereo numb to taut numb ========*/</a>
<a name="ln1466">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp;</a>
<a name="ln1467">             pINChI &amp;&amp;  (Stereo = pINChI-&gt;Stereo) &amp;&amp; Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln1468">            /* compare tautomeric inverted stereo numbering to tautomeric numbering */</a>
<a name="ln1469">            if ( !eq2taut ) {</a>
<a name="ln1470">                eq2taut = </a>
<a name="ln1471">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV, pINChI_Aux, EQL_NUM );</a>
<a name="ln1472">                                 /* stereo-inv     numbering  (taut) =  taut numbering */</a>
<a name="ln1473">                eq2taut = eq2taut? (iiSTEREO_INV | iiNUMB ) : 0;</a>
<a name="ln1474">            }</a>
<a name="ln1475">        }</a>
<a name="ln1476">        if ( eq2taut ) {</a>
<a name="ln1477">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln1478">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln1479">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln1480">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1481">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln1482">                    multPrevEquStr ++;</a>
<a name="ln1483">                } else {</a>
<a name="ln1484">                    /* new EqStr is different; output it */</a>
<a name="ln1485">                    if ( bNext ++ ) {</a>
<a name="ln1486">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1487">                    }</a>
<a name="ln1488">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1489">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln1490">                    multPrevEquStr = 1;</a>
<a name="ln1491">                }</a>
<a name="ln1492">            } else {</a>
<a name="ln1493">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln1494">                multPrevEquStr = 1;</a>
<a name="ln1495">            }</a>
<a name="ln1496">        } else {</a>
<a name="ln1497">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln1498">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1499">                /* new EqStr is different; output it */</a>
<a name="ln1500">                if ( bNext ++ ) {</a>
<a name="ln1501">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1502">                }</a>
<a name="ln1503">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1504">                pPrevEquStr = NULL;</a>
<a name="ln1505">                multPrevEquStr = 0;</a>
<a name="ln1506">            }</a>
<a name="ln1507">            if ( bNext ++ ) {</a>
<a name="ln1508">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1509">            }</a>
<a name="ln1510">            if ( pINChI &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln1511">                 (Stereo = pINChI-&gt;Stereo) &amp;&amp; Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln1512">                 Stereo-&gt;nCompInv2Abs &amp;&amp; pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv ) {</a>
<a name="ln1513">                    tot_len += MakeCtString( pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv,</a>
<a name="ln1514">                                             pINChI_Aux-&gt;nNumberOfAtoms, 0, NULL, 0,</a>
<a name="ln1515">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1516">            }</a>
<a name="ln1517">            /* else inv stereo info is not present in pINChI */</a>
<a name="ln1518">        }</a>
<a name="ln1519">    }</a>
<a name="ln1520">    if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1521">        /* the new EqStr of the last item has not been printed; output it now */</a>
<a name="ln1522">        if ( bNext ++ ) {</a>
<a name="ln1523">            tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1524">        }</a>
<a name="ln1525">        tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1526">        pPrevEquStr = NULL;</a>
<a name="ln1527">        multPrevEquStr = 0;</a>
<a name="ln1528">    }</a>
<a name="ln1529">    return tot_len;</a>
<a name="ln1530">}</a>
<a name="ln1531">/***************************************************************************/</a>
<a name="ln1532">int str_AuxIsoNumb(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln1533">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln1534">              int bSecondNonTautPass, int bOmitRepetitions)</a>
<a name="ln1535">{</a>
<a name="ln1536">    int          i, ii, ii2;</a>
<a name="ln1537">    INCHI_SORT   *is, *is0 /*, *is2*/;</a>
<a name="ln1538">    INChI        *pINChI,  *pINChI_Taut;</a>
<a name="ln1539">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev, *pINChI_Aux_Taut;</a>
<a name="ln1540">    int          eq2taut, bNext;</a>
<a name="ln1541">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln1542">    int         multPrevEquStr;        </a>
<a name="ln1543">    /**************************************************</a>
<a name="ln1544">     * specificity of numbering: there is no previous *</a>
<a name="ln1545">     * component because no repetition is possible    *</a>
<a name="ln1546">     **************************************************/</a>
<a name="ln1547">    pINChI          = NULL;  /* not used here, for debug only */</a>
<a name="ln1548">    pINChI_Taut     = NULL;  /* not used here, for debug only */</a>
<a name="ln1549">    pINChI_Aux      = NULL;</a>
<a name="ln1550">    pINChI_Aux_Taut = NULL;</a>
<a name="ln1551">    pINChI_Aux_Prev = NULL;</a>
<a name="ln1552">    bNext       = 0;</a>
<a name="ln1553">    is          = NULL;</a>
<a name="ln1554">    is0         = pINChISort;</a>
<a name="ln1555">    /*is2         = bSecondNonTautPass? pINChISort2 : NULL;*/</a>
<a name="ln1556">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln1557">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln1558">    multPrevEquStr = 0;        </a>
<a name="ln1559">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln1560">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln1561">        is=is0+i;</a>
<a name="ln1562">        pINChI_Aux = (i &lt; num_components &amp;&amp; 0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln1563">        /*================ to compare to previously printed =====================*/</a>
<a name="ln1564">        if ( bSecondNonTautPass ) {</a>
<a name="ln1565">            pINChI_Aux_Taut = (0 &lt;= (ii2=GET_II(OUT_T1,is)))? is-&gt;pINChI_Aux[ii2] : NULL;</a>
<a name="ln1566">        }</a>
<a name="ln1567">        eq2taut = 0;</a>
<a name="ln1568">        /*========= if bSecondNonTautPass then compare iso non-taut numb to other numb ========*/</a>
<a name="ln1569">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic ) {</a>
<a name="ln1570">            /* compare non-tautomeric isotopic numbering to:</a>
<a name="ln1571">             *   a) tautomeric numbering</a>
<a name="ln1572">             *   b) non-tautomeric numbering</a>
<a name="ln1573">             *   c) tautomeric isotopic numbering</a>
<a name="ln1574">             */</a>
<a name="ln1575">            /* a) compare non-tautomeric isotopic numbering to tautomeric numbering */</a>
<a name="ln1576">            if ( !eq2taut ) {</a>
<a name="ln1577">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_ISO, pINChI_Aux_Taut, EQL_NUM );</a>
<a name="ln1578">                                 /* numbering  non-taut isotopic =  taut numbering */</a>
<a name="ln1579">                eq2taut = eq2taut? ( iiNUMB | iitNONTAUT | iitISO ) : 0;</a>
<a name="ln1580">            }</a>
<a name="ln1581">            /* b) compare non-tautomeric isotopic numbering to non-tautomeric numbering */</a>
<a name="ln1582">            if ( !eq2taut ) {</a>
<a name="ln1583">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_ISO, pINChI_Aux, EQL_NUM );</a>
<a name="ln1584">                                 /* numbering  non-taut isotopic =  non-taut numbering */</a>
<a name="ln1585">                eq2taut = eq2taut? ( iiNUMB | iitNONTAUT | iitISO | iiEq2NONTAUT ) : 0;</a>
<a name="ln1586">            }</a>
<a name="ln1587">            /* c) compare non-tautomeric isotopic numbering to tautomeric isotopic numbering */</a>
<a name="ln1588">            if ( !eq2taut ) {</a>
<a name="ln1589">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_ISO, pINChI_Aux_Taut, EQL_NUM_ISO );</a>
<a name="ln1590">                                 /* numbering  non-taut isotopic =  taut isotopic numbering */</a>
<a name="ln1591">                eq2taut = eq2taut? ( iiNUMB | iitNONTAUT | iitISO | iiEq2ISO ) : 0;</a>
<a name="ln1592">            }</a>
<a name="ln1593">        } else</a>
<a name="ln1594">        /*========= if not bSecondNonTautPass then compare inv taut stereo numb to taut numb ========*/</a>
<a name="ln1595">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic ) {</a>
<a name="ln1596">            /* compare tautomeric isotopic numbering to tautomeric non-isotopic numbering */</a>
<a name="ln1597">            if ( !eq2taut ) {</a>
<a name="ln1598">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_ISO, pINChI_Aux, EQL_NUM_ISO );</a>
<a name="ln1599">                                 /* stereo-inv     numbering  (taut) =  taut numbering */</a>
<a name="ln1600">                eq2taut = eq2taut? (iiSTEREO_INV | iiNUMB ) : 0;</a>
<a name="ln1601">            }</a>
<a name="ln1602">        }</a>
<a name="ln1603">        if ( eq2taut ) {</a>
<a name="ln1604">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln1605">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln1606">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln1607">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1608">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln1609">                    multPrevEquStr ++;</a>
<a name="ln1610">                } else {</a>
<a name="ln1611">                    /* new EqStr is different; output it */</a>
<a name="ln1612">                    if ( bNext ++ ) {</a>
<a name="ln1613">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1614">                    }</a>
<a name="ln1615">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1616">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln1617">                    multPrevEquStr = 1;</a>
<a name="ln1618">                }</a>
<a name="ln1619">            } else {</a>
<a name="ln1620">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln1621">                multPrevEquStr = 1;</a>
<a name="ln1622">            }</a>
<a name="ln1623">        } else {</a>
<a name="ln1624">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln1625">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1626">                /* new EqStr is different; output it */</a>
<a name="ln1627">                if ( bNext ++ ) {</a>
<a name="ln1628">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1629">                }</a>
<a name="ln1630">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1631">                pPrevEquStr = NULL;</a>
<a name="ln1632">                multPrevEquStr = 0;</a>
<a name="ln1633">            }</a>
<a name="ln1634">            if ( bNext ++ ) {</a>
<a name="ln1635">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1636">            }</a>
<a name="ln1637">            if ( pINChI_Aux &amp;&amp; pINChI_Aux-&gt;nNumberOfAtoms &amp;&amp; pINChI_Aux-&gt;bIsIsotopic &amp;&amp;</a>
<a name="ln1638">                 pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd ) {</a>
<a name="ln1639">                    tot_len += MakeCtString( pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd,</a>
<a name="ln1640">                                             pINChI_Aux-&gt;nNumberOfAtoms, 0, NULL, 0,</a>
<a name="ln1641">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1642">            }</a>
<a name="ln1643">            /* else isotopic numbering is not present in pINChI */</a>
<a name="ln1644">        }</a>
<a name="ln1645">    }</a>
<a name="ln1646">    if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1647">        /* the new EqStr of the last item has not been printed; output it now */</a>
<a name="ln1648">        if ( bNext ++ ) {</a>
<a name="ln1649">            tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1650">        }</a>
<a name="ln1651">        tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1652">        pPrevEquStr = NULL;</a>
<a name="ln1653">        multPrevEquStr = 0;</a>
<a name="ln1654">    }</a>
<a name="ln1655">    return tot_len;</a>
<a name="ln1656">}</a>
<a name="ln1657">/***************************************************************************/</a>
<a name="ln1658">int str_AuxIsoEqu(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln1659">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln1660">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln1661">{</a>
<a name="ln1662">    int          i, ii, ii2;</a>
<a name="ln1663">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln1664">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev, *pINChI_Aux_Taut, *pINChI_Aux_Taut_Prev;</a>
<a name="ln1665">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln1666">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln1667">    int         multPrevEquStr;        </a>
<a name="ln1668">    pINChI_Aux           = NULL;</a>
<a name="ln1669">    pINChI_Aux_Prev      = NULL;</a>
<a name="ln1670">    pINChI_Aux_Taut      = NULL;</a>
<a name="ln1671">    pINChI_Aux_Taut_Prev = NULL;</a>
<a name="ln1672">    mult        = 0;</a>
<a name="ln1673">    bNext       = 0;</a>
<a name="ln1674">    is          = NULL;</a>
<a name="ln1675">    is2         = NULL;</a>
<a name="ln1676">    is0         = pINChISort;</a>
<a name="ln1677">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln1678">    eq2taut     = 0; /* may be non-zero only on the 2nd (non-taut) pass */</a>
<a name="ln1679">    eq2tautPrev = 1; /* pINChI_Aux_Prev (previous pINChI_Aux) does not exist */</a>
<a name="ln1680">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln1681">    multPrevEquStr = 0;        </a>
<a name="ln1682">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln1683">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln1684">        pINChI_Aux = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln1685">        if ( bSecondNonTautPass ) {</a>
<a name="ln1686">            /* component that was output on the 1st pass */</a>
<a name="ln1687">            pINChI_Aux_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI_Aux[ii2] : NULL;</a>
<a name="ln1688">        }</a>
<a name="ln1689">        /*================ compare iso non-taut equivalence info to non-iso taut ========*/</a>
<a name="ln1690">        eq2taut = 0;</a>
<a name="ln1691">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic ) {</a>
<a name="ln1692">            /**************************************************</a>
<a name="ln1693">             * compare isotopic non-tautomeric equivalence to:</a>
<a name="ln1694">             *    a) tautomeric</a>
<a name="ln1695">             *    b) non-tautomeric</a>
<a name="ln1696">             *    c) isotopic tautomeric</a>
<a name="ln1697">             */</a>
<a name="ln1698">            if ( !eq2taut ) {</a>
<a name="ln1699">                /* compare isotopic non-tautomeric equivalence to tautomeric */</a>
<a name="ln1700">                eq2taut = Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_ISO, pINChI_Aux_Taut, EQL_EQU );</a>
<a name="ln1701">                                   /* equ   non-taut     isotopic = tautomeric*/</a>
<a name="ln1702">                eq2taut = eq2taut? (iiEQU | iitNONTAUT | iitISO) : 0;</a>
<a name="ln1703">            }</a>
<a name="ln1704">            if ( !eq2taut ) {</a>
<a name="ln1705">                /* compare isotopic non-tautomeric equivalence to non-tautomeric */</a>
<a name="ln1706">                eq2taut = Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_ISO, pINChI_Aux, EQL_EQU );</a>
<a name="ln1707">                                   /* equ  non-taut    isotopic = non-tautomeric*/</a>
<a name="ln1708">                eq2taut = eq2taut? (iiEQU | iitNONTAUT | iitISO | iiEq2NONTAUT) : 0;</a>
<a name="ln1709">            }</a>
<a name="ln1710">            if ( !eq2taut ) {</a>
<a name="ln1711">                /* compare isotopic non-tautomeric equivalence to isotopic tautomeric */</a>
<a name="ln1712">                eq2taut = Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_ISO, pINChI_Aux_Taut, EQL_EQU_ISO );</a>
<a name="ln1713">                                 /* equ   non-taut     isotopic = isotopic tautomeric*/</a>
<a name="ln1714">                eq2taut = eq2taut? (iiEQU | iitNONTAUT | iitISO | iiEq2ISO) : 0;</a>
<a name="ln1715">            }</a>
<a name="ln1716">        } else</a>
<a name="ln1717">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic ) {</a>
<a name="ln1718">            /**************************************************</a>
<a name="ln1719">             * compare isotopic tautomeric equivalence to:</a>
<a name="ln1720">             *    a) non-isotopic tautomeric</a>
<a name="ln1721">             */</a>
<a name="ln1722">            if ( !eq2taut ) {</a>
<a name="ln1723">                /* compare isotopic tautomeric equivalence to tautomeric */</a>
<a name="ln1724">                eq2taut = Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_ISO, pINChI_Aux, EQL_EQU );</a>
<a name="ln1725">                                   /* equ   taut-isotopic = tautomeric*/</a>
<a name="ln1726">                eq2taut = eq2taut? (iiEQU | iitISO) : 0;</a>
<a name="ln1727">            }</a>
<a name="ln1728">        }</a>
<a name="ln1729">        if ( eq2taut ) {</a>
<a name="ln1730">            /* we may be here only in case of the second (non-taut) pass */</a>
<a name="ln1731">            /* current non-taut equivalence has been found to be same as tautomeric */</a>
<a name="ln1732">            if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1733">                /* previous component exists */</a>
<a name="ln1734">                if ( bNext ++ ) {</a>
<a name="ln1735">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1736">                }</a>
<a name="ln1737">                if ( bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms) ) {</a>
<a name="ln1738">                    /* output previous component(s) equivalence since it was found to be non-trivial */</a>
<a name="ln1739">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1740">                    tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms, 0,</a>
<a name="ln1741">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1742">                } else {</a>
<a name="ln1743">                    ; /* pINChI_Aux_Prev exists and has only trivial equivalence info */</a>
<a name="ln1744">                }</a>
<a name="ln1745">            } else</a>
<a name="ln1746">            if ( pINChI_Aux_Taut_Prev &amp;&amp; pINChI_Aux_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1747">                /* previous non-taut component exists only in taut list */</a>
<a name="ln1748">                if ( bNext ++ ) {</a>
<a name="ln1749">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1750">                }</a>
<a name="ln1751">            }</a>
<a name="ln1752">            /* we have found pINChI_Aux-&gt;pINChI_Aux-&gt;nConstitEquIsotopicNumbers same as in pINChI_Aux_Taut */</a>
<a name="ln1753">            /* output this (current) equivalence as '*', that is, same as tautomeric */</a>
<a name="ln1754">            /* that was printed on the 1st pass. */</a>
<a name="ln1755">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln1756">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1757">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln1758">                    multPrevEquStr ++;</a>
<a name="ln1759">                } else {</a>
<a name="ln1760">                    /* new EqStr is different; output it */</a>
<a name="ln1761">                    if ( bNext ++ ) {</a>
<a name="ln1762">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1763">                    }</a>
<a name="ln1764">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1765">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln1766">                    multPrevEquStr = 1;</a>
<a name="ln1767">                }</a>
<a name="ln1768">            } else {</a>
<a name="ln1769">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln1770">                multPrevEquStr = 1;</a>
<a name="ln1771">            }</a>
<a name="ln1772">            pINChI_Aux_Prev      = NULL; /* pINChI_Aux_Prev does not exist since */</a>
<a name="ln1773">            pINChI_Aux_Taut_Prev = NULL; /* pINChI_Aux has just been printed */</a>
<a name="ln1774">            mult           = 0;</a>
<a name="ln1775">            eq2tautPrev    = 1;</a>
<a name="ln1776">        } else</a>
<a name="ln1777">        if ( eq2tautPrev ) {</a>
<a name="ln1778">            /* at this point pINChI_Aux_Prev does not exist; however, pINChI_Aux */</a>
<a name="ln1779">             /*might have been discovered and it is different from pINChI_Aux_Taut */</a>
<a name="ln1780">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln1781">                /* new EqStr is different; output it */</a>
<a name="ln1782">                if ( bNext ++ ) {</a>
<a name="ln1783">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1784">                }</a>
<a name="ln1785">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1786">                pPrevEquStr = NULL;</a>
<a name="ln1787">                multPrevEquStr = 0;</a>
<a name="ln1788">            }</a>
<a name="ln1789">            eq2tautPrev = 0;</a>
<a name="ln1790">            pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln1791">            pINChI_Aux_Taut_Prev = pINChI_Aux_Taut;</a>
<a name="ln1792">            mult = 0;</a>
<a name="ln1793">        } else {</a>
<a name="ln1794">            /* check whether pINChI_Aux and pINChI_Aux_Prev have identical non-trivial equivalence info */</a>
<a name="ln1795">            eq2prev = bUseMulipliers &amp;&amp; Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_ISO, pINChI_Aux_Prev, EQL_EQU_ISO );</a>
<a name="ln1796">            if ( eq2prev ) {</a>
<a name="ln1797">                /* eq. info is same and non-trivial */</a>
<a name="ln1798">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln1799">                continue;</a>
<a name="ln1800">            } else {</a>
<a name="ln1801">                /* pINChI_Aux eq. info is either different or trivial. Output pINChI_Aux_Prev anyway */</a>
<a name="ln1802">                if ( bNext ++ ) {</a>
<a name="ln1803">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1804">                }</a>
<a name="ln1805">                if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1806">                     if ( bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms) ) {</a>
<a name="ln1807">                        /* pINChI_Aux_Prev exists and has equivalence info */</a>
<a name="ln1808">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln1809">                        tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicNumbers, pINChI_Aux_Prev-&gt;nNumberOfAtoms, 0,</a>
<a name="ln1810">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln1811">                     } else {</a>
<a name="ln1812">                        ; /* pINChI_Aux_Prev exists and has only trivial equivalence info */</a>
<a name="ln1813">                     }</a>
<a name="ln1814">                } else</a>
<a name="ln1815">                if ( bSecondNonTautPass &amp;&amp; pINChI_Aux_Taut_Prev &amp;&amp; pINChI_Aux_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln1816">                     if ( bHasEquString( pINChI_Aux_Taut_Prev-&gt;nConstitEquIsotopicNumbers, pINChI_Aux_Taut_Prev-&gt;nNumberOfAtoms) ) {</a>
<a name="ln1817">                        /* since pINChI_Aux_Prev does not exist, pINChI_Aux_Taut_Prev is non-tautomeric */</a>
<a name="ln1818">                        /* and it has non-trivial equivalence info. This info has already been printed in the main section  */</a>
<a name="ln1819">                        /*</a>
<a name="ln1820">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln1821">                        */</a>
<a name="ln1822">                     } else {</a>
<a name="ln1823">                         ; /* pINChI_Aux_Taut_Prev exists and has only trivial equivalence info */</a>
<a name="ln1824">                     }</a>
<a name="ln1825">                }</a>
<a name="ln1826">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1827">                else {</a>
<a name="ln1828">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln1829">                }</a>
<a name="ln1830">#endif</a>
<a name="ln1831">            }</a>
<a name="ln1832">            pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln1833">            pINChI_Aux_Taut_Prev = pINChI_Aux_Taut;</a>
<a name="ln1834">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln1835">        }</a>
<a name="ln1836">    }</a>
<a name="ln1837">    return tot_len;</a>
<a name="ln1838">}</a>
<a name="ln1839">/******************************************************************************************/</a>
<a name="ln1840">int str_AuxInvIsoSp3(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln1841">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln1842">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln1843">{</a>
<a name="ln1844">    int          i, ii, ii2;</a>
<a name="ln1845">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln1846">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln1847">    INChI_Stereo *Stereo, *Stereo_Prev, *Stereo_Taut, *Stereo_Taut_Prev;</a>
<a name="ln1848">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln1849">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln1850">    int         multPrevEquStr;        </a>
<a name="ln1851">    /********************************</a>
<a name="ln1852">         inverted isotopic sp3</a>
<a name="ln1853">    *********************************/</a>
<a name="ln1854">    pINChI_Taut      = NULL;</a>
<a name="ln1855">    pINChI_Prev      = NULL;</a>
<a name="ln1856">    pINChI_Taut_Prev = NULL;</a>
<a name="ln1857">    mult        = 0;</a>
<a name="ln1858">    bNext       = 0;</a>
<a name="ln1859">    is          = NULL;</a>
<a name="ln1860">    is2         = NULL;</a>
<a name="ln1861">    is0         = pINChISort;</a>
<a name="ln1862">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln1863">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln1864">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln1865">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln1866">    multPrevEquStr = 0;        </a>
<a name="ln1867">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln1868">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln1869">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln1870">        /*================ compare sp2 to previous =====================*/</a>
<a name="ln1871">        if ( bSecondNonTautPass ) {</a>
<a name="ln1872">            /* component that was output on the 1st pass */</a>
<a name="ln1873">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln1874">        }</a>
<a name="ln1875">        eq2taut = 0;</a>
<a name="ln1876">        /*========= if bSecondNonTautPass then compare iso non-taut stereo to other stereo ========*/</a>
<a name="ln1877">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp; pINChI-&gt;nNumberOfIsotopicAtoms+pINChI-&gt;nNumberOfIsotopicTGroups &gt; 0 ) {</a>
<a name="ln1878">            /* compare non-tautomeric isotopic inverted to:</a>
<a name="ln1879">             *   a) tautomeric inverted</a>
<a name="ln1880">             *   b) *non-tautomeric inverted</a>
<a name="ln1881">             *   c) *isotopic tautomeric inverted</a>
<a name="ln1882">             *   d) Inverted(tautomeric)</a>
<a name="ln1883">             *   e) *Inverted(tautomeric isotopic)</a>
<a name="ln1884">             *   f) Inverted(non-tautomeric)</a>
<a name="ln1885">             *   g) *Inverted(non-tautomeric isotopic)</a>
<a name="ln1886">             */</a>
<a name="ln1887">            /* a) compare non-tautomeric isotopic inverted to tautomeric inverted */</a>
<a name="ln1888">            if ( !eq2taut ) {</a>
<a name="ln1889">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1890">                          /* non-taut inverted */          /* taut invertedc */</a>
<a name="ln1891">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln1892">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3_INV, 0 );</a>
<a name="ln1893">                                 /* stereo-inv    isotopic  non-taut =  taut (stereo-inv) */</a>
<a name="ln1894">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT ) : 0;</a>
<a name="ln1895">            }</a>
<a name="ln1896">            /* b) compare non-tautomeric isotopic inverted to non-tautomeric inverted */</a>
<a name="ln1897">            if ( !eq2taut ) {</a>
<a name="ln1898">                eq2taut = pINChI &amp;&amp;                    /* it is non-taut non-iso stereo */</a>
<a name="ln1899">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln1900">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3_INV, 0 );</a>
<a name="ln1901">                                 /* stereo-inv    isotopic non-taut =  non-taut stereo-inv */</a>
<a name="ln1902">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT | iiEq2NONTAUT) : 0;</a>
<a name="ln1903">            }</a>
<a name="ln1904">            /* c) compare non-tautomeric isotopic inverted to isotopic tautomeric inverted */</a>
<a name="ln1905">            if ( !eq2taut ) {</a>
<a name="ln1906">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1907">                          /* non-taut iso. inverted */             /* taut iso. inverted */</a>
<a name="ln1908">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln1909">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3_INV, 0 );</a>
<a name="ln1910">                                 /* stereo-inv    isotopic  non-taut =  taut iso. stereo-inv */</a>
<a name="ln1911">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT | iiEq2ISO ) : 0;</a>
<a name="ln1912">            }</a>
<a name="ln1913">            /* d) compare non-tautomeric inverted to Inverted(tautomeric stereo) */</a>
<a name="ln1914">            if ( !eq2taut ) {</a>
<a name="ln1915">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1916">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;</a>
<a name="ln1917">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3_INV, 0 );</a>
<a name="ln1918">                                 /* stereo-inv   isotopic  non-taut =  Inv(non-iso taut stereo) */</a>
<a name="ln1919">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT | iiEq2INV) : 0;</a>
<a name="ln1920">            }</a>
<a name="ln1921">            /* e) compare non-tautomeric inverted to Inverted(isotopic tautomeric stereo) */</a>
<a name="ln1922">            if ( !eq2taut ) {</a>
<a name="ln1923">                eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp;</a>
<a name="ln1924">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln1925">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3, 0 );</a>
<a name="ln1926">                                 /* stereo-inv   isotopic  non-taut =  Inv(iso taut stereo) */</a>
<a name="ln1927">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT | iiEq2INV | iiEq2ISO) : 0;</a>
<a name="ln1928">            }</a>
<a name="ln1929">            /* f) compare non-tautomeric isotopic inverted to Inverted(non-tautomeric stereo) */</a>
<a name="ln1930">            if ( !eq2taut ) {</a>
<a name="ln1931">                eq2taut = pINChI &amp;&amp;                    /* it is non-taut non-iso stereo */</a>
<a name="ln1932">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln1933">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3, 0 );</a>
<a name="ln1934">                                 /* stereo-inv   isotopic    non-taut =  Inv(non-taut stereo) */</a>
<a name="ln1935">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT | iiEq2INV | iiEq2NONTAUT) : 0;</a>
<a name="ln1936">            }</a>
<a name="ln1937">            /* g) compare non-tautomeric isotopic inverted to Inverted(non-tautomeric isotopic stereo) */</a>
<a name="ln1938">            if ( !eq2taut ) {</a>
<a name="ln1939">                eq2taut = pINChI &amp;&amp;                    /* it is non-taut non-iso stereo */</a>
<a name="ln1940">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln1941">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo, EQL_SP3, 0 );</a>
<a name="ln1942">                                 /* stereo-inv    isotopic  non-taut =   Inv( iso non-taut stereo) */</a>
<a name="ln1943">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iitNONTAUT | iiEq2INV | iiEq2ISO | iiEq2NONTAUT) : 0;</a>
<a name="ln1944">            }</a>
<a name="ln1945">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln1946">            if ( !eq2taut &amp;&amp; pINChI &amp;&amp; !((Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln1947">                Eql_INChI_Stereo( Stereo, EQL_SP3_INV, NULL, EQL_EXISTS, 0 )) ) {</a>
<a name="ln1948">                 /* component has no stereo; check whether it has stereo in the preceding layers */</a>
<a name="ln1949">                if ( pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp; /* F is not empty */</a>
<a name="ln1950">                     Eql_INChI_Stereo( Stereo_Taut, EQL_SP3_INV, NULL, EQL_EXISTS, 0 ) ||</a>
<a name="ln1951">                    !(pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp;  /* M is empty and ... */</a>
<a name="ln1952">                       Eql_INChI_Stereo( Stereo_Taut, EQL_SP3_INV, NULL, EQL_EXISTS, 0 )) &amp;&amp;</a>
<a name="ln1953">                     (pINChI_Taut &amp;&amp; (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp;  /* ... MI is not empty */</a>
<a name="ln1954">                       Eql_INChI_Stereo( Stereo_Taut, EQL_SP3_INV, NULL, EQL_EXISTS, 0 )) ) {</a>
<a name="ln1955"> </a>
<a name="ln1956">                    eq2taut = iiEmpty; /* the component has stereo in the preceding layer  */</a>
<a name="ln1957">                }</a>
<a name="ln1958">            }</a>
<a name="ln1959">#endif</a>
<a name="ln1960">        } else</a>
<a name="ln1961">        /*========= if not bSecondNonTautPass then compare inv taut stereo to various stereo ========*/</a>
<a name="ln1962">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp;</a>
<a name="ln1963">               (pINChI-&gt;nNumberOfIsotopicAtoms &gt; 0 ||</a>
<a name="ln1964">                pINChI-&gt;nNumberOfIsotopicTGroups &gt; 0 ||</a>
<a name="ln1965">                (pINChI-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; pINChI-&gt;nPossibleLocationsOfIsotopicH[0] &gt; 1)) ) {</a>
<a name="ln1966">            /* compare tautomeric isotopic stereo-inverted to:</a>
<a name="ln1967">             *    a) tautomeric stereo-inverted</a>
<a name="ln1968">             *    b) Inverted(tautomeric stereo)</a>
<a name="ln1969">             *    c) Inverted(tautomeric isotopic stereo)</a>
<a name="ln1970">             */</a>
<a name="ln1971">            /* a) compare tautomeric isotopic stereo-inverted to tautomeric stereo-inverted */</a>
<a name="ln1972">            if ( !eq2taut ) {</a>
<a name="ln1973">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln1974">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln1975">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3_INV, 0 );</a>
<a name="ln1976">                                 /* stereo-inv  isotopic taut =  taut stereo-inv */</a>
<a name="ln1977">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO  ) : 0;</a>
<a name="ln1978">            }</a>
<a name="ln1979">            /* b) compare tautomeric isotopic stereo-inverted to Inverted(tautomeric stereo) */</a>
<a name="ln1980">            if ( !eq2taut ) {</a>
<a name="ln1981">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln1982">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln1983">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Taut, EQL_SP3, 0 );</a>
<a name="ln1984">                                 /* stereo-inv   isotopic taut =  Inv(taut stereo) */</a>
<a name="ln1985">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiEq2INV ) : 0;</a>
<a name="ln1986">            }</a>
<a name="ln1987">            /* c) compare tautomeric isotopic stereo-inverted to Inverted(tautomeric isotopic stereo) */</a>
<a name="ln1988">            if ( !eq2taut ) {</a>
<a name="ln1989">                eq2taut = pINChI &amp;&amp;</a>
<a name="ln1990">                  (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln1991">                  Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo, EQL_SP3, 0 );</a>
<a name="ln1992">                                 /* stereo-inv   isotopic taut =  Inv(taut iso stereo) */</a>
<a name="ln1993">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiEq2INV | iiEq2ISO ) : 0;</a>
<a name="ln1994">            }</a>
<a name="ln1995">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln1996">            if ( !eq2taut &amp;&amp; pINChI &amp;&amp; !((Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln1997">                 Eql_INChI_Stereo( Stereo, EQL_SP3_INV, NULL, EQL_EXISTS, 0 ) ) ) {</a>
<a name="ln1998">                /* component has no MI stereo; check whether it has stereo in the preceding layer M */</a>
<a name="ln1999">                if ( (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln2000">                     Eql_INChI_Stereo( Stereo_Taut, EQL_SP3_INV, NULL, EQL_EXISTS, 0 ) ) {</a>
<a name="ln2001">                    eq2taut = iiEmpty; /* the component has stereo in the preceding layer  */</a>
<a name="ln2002">                }</a>
<a name="ln2003">            }</a>
<a name="ln2004">#endif</a>
<a name="ln2005">        }</a>
<a name="ln2006">        if ( eq2taut ) {</a>
<a name="ln2007">            /* we may be here only in case of the current layer found equal in another layer the same component */</a>
<a name="ln2008">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln2009">                /* previous component exists; output it before output the current component */</a>
<a name="ln2010">                if ( bNext ++ ) {</a>
<a name="ln2011">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2012">                }</a>
<a name="ln2013">                if ( (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp; Stereo_Prev-&gt;nNumberOfStereoCenters &gt; 0 ) {</a>
<a name="ln2014">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2015"> </a>
<a name="ln2016">                    tot_len += MakeStereoString( Stereo_Prev-&gt;nNumber, NULL, Stereo_Prev-&gt;t_parityInv,</a>
<a name="ln2017">                                                 0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln2018">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2019">                }</a>
<a name="ln2020">            } else</a>
<a name="ln2021">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln2022">                /* previous non-taut component exists only in taut list */</a>
<a name="ln2023">                if ( bNext ++ ) {</a>
<a name="ln2024">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2025">                }</a>
<a name="ln2026">                /* do not output stereo of non-tautomeric in non-taut layer: it has been output in the main layer */</a>
<a name="ln2027">            }</a>
<a name="ln2028">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln2029">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln2030">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln2031">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2032">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln2033">                    multPrevEquStr ++;</a>
<a name="ln2034">                } else {</a>
<a name="ln2035">                    /* new EqStr is different; output it */</a>
<a name="ln2036">                    if ( bNext ++ ) {</a>
<a name="ln2037">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2038">                    }</a>
<a name="ln2039">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2040">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln2041">                    multPrevEquStr = 1;</a>
<a name="ln2042">                }</a>
<a name="ln2043">            } else {</a>
<a name="ln2044">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln2045">                multPrevEquStr = 1;</a>
<a name="ln2046">            }</a>
<a name="ln2047">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln2048">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln2049">            mult           = 0;</a>
<a name="ln2050">            eq2tautPrev    = 1;     /* pINChI_Prev and pINChI_Taut_Prev have already been output */</a>
<a name="ln2051">        } else </a>
<a name="ln2052">        if ( eq2tautPrev ) {</a>
<a name="ln2053">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln2054">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln2055">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2056">                /* new EqStr is different; output it */</a>
<a name="ln2057">                if ( bNext ++ ) {</a>
<a name="ln2058">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2059">                }</a>
<a name="ln2060">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2061">                pPrevEquStr = NULL;</a>
<a name="ln2062">                multPrevEquStr = 0;</a>
<a name="ln2063">            }</a>
<a name="ln2064">            eq2tautPrev = 0;</a>
<a name="ln2065">            pINChI_Prev      = pINChI;</a>
<a name="ln2066">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln2067">            mult = 0;</a>
<a name="ln2068">        } else {</a>
<a name="ln2069">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln2070">            /* compare the current layer to this layer of the previous component: */</a>
<a name="ln2071">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp2 */</a>
<a name="ln2072">            /*================ compare iso sp3 to previous =====================*/</a>
<a name="ln2073">            eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln2074">                     pINChI &amp;&amp; pINChI-&gt;nNumberOfIsotopicAtoms + pINChI-&gt;nNumberOfIsotopicTGroups &gt; 0 &amp;&amp;</a>
<a name="ln2075">                     pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfIsotopicAtoms + pINChI_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0 &amp;&amp;</a>
<a name="ln2076">                     /* do both have stereo? */</a>
<a name="ln2077">                     (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln2078">                     /* is their inverted stereo same? */</a>
<a name="ln2079">                     Eql_INChI_Stereo( Stereo, EQL_SP3_INV, Stereo_Prev, EQL_SP3_INV, 0 );</a>
<a name="ln2080">            if ( eq2prev ) {</a>
<a name="ln2081">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2082">                continue;</a>
<a name="ln2083">            } else {</a>
<a name="ln2084">                if ( bNext ++ ) {</a>
<a name="ln2085">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2086">                }</a>
<a name="ln2087">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms &amp;&amp; pINChI_Prev-&gt;nNumberOfIsotopicAtoms + pINChI_Prev-&gt;nNumberOfIsotopicTGroups &gt; 0 ) {</a>
<a name="ln2088">                    if ( (Stereo_Prev = pINChI_Prev-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln2089">                          Stereo_Prev-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp; Stereo_Prev-&gt;nCompInv2Abs ) {</a>
<a name="ln2090">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2091"> </a>
<a name="ln2092">                        tot_len += MakeStereoString( Stereo_Prev-&gt;nNumberInv, NULL, Stereo_Prev-&gt;t_parityInv,</a>
<a name="ln2093">                                                     0, Stereo_Prev-&gt;nNumberOfStereoCenters,</a>
<a name="ln2094">                                                     pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2095">                    }</a>
<a name="ln2096">                    /* else sp3 info is not present in pINChI_Prev */</a>
<a name="ln2097">                } else</a>
<a name="ln2098">                /* do not print pINChI_Prev because it either do not exist of have already been printed */</a>
<a name="ln2099">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln2100">                     if ( (Stereo_Taut_Prev = pINChI_Taut_Prev-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln2101">                           Stereo_Taut_Prev-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp; Stereo_Taut_Prev-&gt;nCompInv2Abs ) {</a>
<a name="ln2102">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln2103">                        /* and it has non-trivial inv sp3 info. It has already been printed in the main section */</a>
<a name="ln2104">                        /*</a>
<a name="ln2105">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2106">                        */</a>
<a name="ln2107">                        ;/* pINChI_Taut_Prev sp3 info was output in the main stereo section */</a>
<a name="ln2108">                     } else {</a>
<a name="ln2109">                        ; /* pINChI_Taut_Prev exists and has not sp3 info */</a>
<a name="ln2110">                     }</a>
<a name="ln2111">                }</a>
<a name="ln2112">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2113">                else {</a>
<a name="ln2114">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln2115">                }</a>
<a name="ln2116">#endif</a>
<a name="ln2117">            }</a>
<a name="ln2118">            pINChI_Prev = pINChI;</a>
<a name="ln2119">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2120">        }</a>
<a name="ln2121">    }</a>
<a name="ln2122">    return tot_len;</a>
<a name="ln2123">}</a>
<a name="ln2124">/***************************************************************************/</a>
<a name="ln2125">int str_AuxInvIsoSp3Numb(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2126">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln2127">              int bSecondNonTautPass, int bOmitRepetitions)</a>
<a name="ln2128">{</a>
<a name="ln2129">    int          i, ii, ii2;</a>
<a name="ln2130">    INCHI_SORT   *is, *is0 /*, *is2*/;</a>
<a name="ln2131">    INChI        *pINChI,  *pINChI_Taut;</a>
<a name="ln2132">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev, *pINChI_Aux_Taut;</a>
<a name="ln2133">    INChI_Stereo *Stereo, *Stereo_Taut;</a>
<a name="ln2134">    int          eq2taut, bNext;</a>
<a name="ln2135">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln2136">    int         multPrevEquStr;        </a>
<a name="ln2137">    /**************************************************</a>
<a name="ln2138">     * specificity of numbering: there is no previous *</a>
<a name="ln2139">     * component because no repetition is possible    *</a>
<a name="ln2140">     **************************************************/</a>
<a name="ln2141">    pINChI          = NULL;</a>
<a name="ln2142">    pINChI_Taut     = NULL;</a>
<a name="ln2143">    pINChI_Aux      = NULL;</a>
<a name="ln2144">    pINChI_Aux_Taut = NULL;</a>
<a name="ln2145">    pINChI_Aux_Prev = NULL;</a>
<a name="ln2146">    bNext       = 0;</a>
<a name="ln2147">    is          = NULL;</a>
<a name="ln2148">   /* is2         = NULL;*/</a>
<a name="ln2149">    is0         = pINChISort;</a>
<a name="ln2150">   /* is20        = bSecondNonTautPass? pINChISort2 : NULL;*/</a>
<a name="ln2151">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln2152">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln2153">    multPrevEquStr = 0;        </a>
<a name="ln2154">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln2155">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln2156">        is=is0+i;</a>
<a name="ln2157">        pINChI     = (0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2158">        pINChI_Aux = pINChI? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln2159">        /*================ to compare to previously printed =====================*/</a>
<a name="ln2160">        if ( bSecondNonTautPass ) {</a>
<a name="ln2161">            /* component that was printed on the 1st pass */</a>
<a name="ln2162">            pINChI_Taut     = (0 &lt;= (ii2=GET_II(OUT_T1,is)))? is-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2163">            pINChI_Aux_Taut = pINChI_Taut? is-&gt;pINChI_Aux[ii2] : NULL;</a>
<a name="ln2164">        }</a>
<a name="ln2165">        eq2taut = 0;</a>
<a name="ln2166">        /*========= if bSecondNonTautPass then compare iso non-taut stereo to other stereo ========*/</a>
<a name="ln2167">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic &amp;&amp;</a>
<a name="ln2168">             (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; Stereo-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2169">             pINChI_Aux-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv ) {</a>
<a name="ln2170">            /* compare isotopic non-tautomeric inverted stereo numbering to:</a>
<a name="ln2171">             *   a) tautomeric numbering</a>
<a name="ln2172">             *   b) non-tautomeric numbering</a>
<a name="ln2173">             *   c) *tautomeric isotopic numbering</a>
<a name="ln2174">             *   d) *non-tautomeric isotopic numbering</a>
<a name="ln2175">             *   e) tautomeric inverted stereo numbering</a>
<a name="ln2176">             *   f) *non-tautomeric inverted stereo numbering</a>
<a name="ln2177">             *   g) tautomeric isotopic inverted stereo numbering</a>
<a name="ln2178">             */</a>
<a name="ln2179">            /* a) compare isotopic non-tautomeric inverted stereo numbering to tautomeric numbering */</a>
<a name="ln2180">            if ( !eq2taut ) {</a>
<a name="ln2181">                eq2taut = pINChI_Taut &amp;&amp;</a>
<a name="ln2182">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux_Taut, EQL_NUM );</a>
<a name="ln2183">                                 /* stereo-inv   isotopic numbering  non-taut =  taut numbering */</a>
<a name="ln2184">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iitNONTAUT ) : 0;</a>
<a name="ln2185">            }</a>
<a name="ln2186">            /* b) compare isotopic non-tautomeric inverted stereo numbering to non-tautomeric numbering */</a>
<a name="ln2187">            if ( !eq2taut ) {</a>
<a name="ln2188">                eq2taut =</a>
<a name="ln2189">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux, EQL_NUM );</a>
<a name="ln2190">                                 /* stereo-inv    isotopic   numb.    non-taut =  non-taut numbering */</a>
<a name="ln2191">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO  | iiNUMB | iitNONTAUT | iiEq2NONTAUT ) : 0;</a>
<a name="ln2192">            }</a>
<a name="ln2193">            /* c) compare isotopic non-tautomeric inverted stereo numbering to tautomeric isotopic numbering */</a>
<a name="ln2194">            if ( !eq2taut ) {</a>
<a name="ln2195">                eq2taut = pINChI_Taut &amp;&amp;</a>
<a name="ln2196">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux_Taut, EQL_NUM_ISO );</a>
<a name="ln2197">                                 /* stereo-inv   isotopic   numb.     non-taut =  taut iso numbering */</a>
<a name="ln2198">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iitNONTAUT | iiEq2ISO ) : 0;</a>
<a name="ln2199">            }</a>
<a name="ln2200">            /* d) compare isotopic non-tautomeric inverted stereo numbering to non-tautomeric isotopic numbering */</a>
<a name="ln2201">            if ( !eq2taut ) {</a>
<a name="ln2202">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux, EQL_NUM_ISO );</a>
<a name="ln2203">                                 /* stereo-inv   isotopic   numb.     non-taut =  non-taut isotopic numbering */</a>
<a name="ln2204">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iitNONTAUT | iiEq2NONTAUT | iiEq2ISO) : 0;</a>
<a name="ln2205">            }</a>
<a name="ln2206">            /* e) compare isotopic non-tautomeric inverted stereo numbering to tautomeric inverted stereo numbering */</a>
<a name="ln2207">            if ( !eq2taut ) {</a>
<a name="ln2208">                eq2taut = pINChI_Taut &amp;&amp; pINChI_Aux_Taut &amp;&amp;</a>
<a name="ln2209">                  (Stereo_Taut = pINChI_Taut-&gt;Stereo) &amp;&amp; Stereo_Taut-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2210">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux_Taut, EQL_NUM_INV );</a>
<a name="ln2211">                                 /* stereo-inv   isotopic numbering  non-taut =  stereo-inv taut numbering */</a>
<a name="ln2212">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iitNONTAUT | iiEq2INV) : 0;</a>
<a name="ln2213">            }</a>
<a name="ln2214">            /* f) compare isotopic non-tautomeric inverted stereo numbering to non-tautomeric inverted stereo numbering */</a>
<a name="ln2215">            if ( !eq2taut ) {</a>
<a name="ln2216">                eq2taut =</a>
<a name="ln2217">                  (Stereo_Taut = pINChI-&gt;StereoIsotopic) &amp;&amp; Stereo_Taut-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2218">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux, EQL_NUM_INV );</a>
<a name="ln2219">                                 /* stereo-inv   isotopic numbering  non-taut =  stereo-inv non-taut numbering */</a>
<a name="ln2220">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iitNONTAUT | iiEq2INV | iiEq2NONTAUT) : 0;</a>
<a name="ln2221">            }</a>
<a name="ln2222">            </a>
<a name="ln2223">            /* g) compare isotopic non-tautomeric inverted stereo numbering to tautomeric isotopic inverted stereo numbering */</a>
<a name="ln2224">            if ( !eq2taut ) {</a>
<a name="ln2225">                eq2taut = pINChI_Taut &amp;&amp;</a>
<a name="ln2226">                  (Stereo_Taut = pINChI_Taut-&gt;StereoIsotopic) &amp;&amp; Stereo_Taut-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2227">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux_Taut, EQL_NUM_INV | EQL_NUM_ISO );</a>
<a name="ln2228">                                 /* stereo-inv   isotopic numbering  non-taut =  stereo-inv iso taut numbering */</a>
<a name="ln2229">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iitNONTAUT | iiEq2INV | iiEq2ISO) : 0;</a>
<a name="ln2230">            }</a>
<a name="ln2231">        } else</a>
<a name="ln2232">        /*========= if not bSecondNonTautPass then compare inv taut stereo numb to taut numb ========*/</a>
<a name="ln2233">        if ( !bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic &amp;&amp;</a>
<a name="ln2234">             (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; Stereo-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2235">             pINChI_Aux-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv ) {</a>
<a name="ln2236">            /* compare isotopic tautomeric inverted stereo numbering to:</a>
<a name="ln2237">             *   a) tautomeric numbering</a>
<a name="ln2238">             *   b) tautomeric isotopic numbering</a>
<a name="ln2239">             *   c) tautomeric inverted stereo numbering</a>
<a name="ln2240">             */</a>
<a name="ln2241">            /* a) compare isotopic tautomeric inverted stereo numbering to tautomeric numbering */</a>
<a name="ln2242">            if ( !eq2taut ) {</a>
<a name="ln2243">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux, EQL_NUM );</a>
<a name="ln2244">                                 /* stereo-inv   isotopic numbering  (taut) =  taut numbering */</a>
<a name="ln2245">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB ) : 0;</a>
<a name="ln2246">            }</a>
<a name="ln2247">            /* b) compare isotopic tautomeric inverted stereo numbering to tautomeric isotopic numbering */</a>
<a name="ln2248">            if ( !eq2taut ) {</a>
<a name="ln2249">                eq2taut = Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux, EQL_NUM_ISO );</a>
<a name="ln2250">                                 /* stereo-inv   isotopic numbering(taut) =  isotopic taut numbering */</a>
<a name="ln2251">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iiEq2ISO ) : 0;</a>
<a name="ln2252">            }</a>
<a name="ln2253">            /* b) compare isotopic tautomeric inverted stereo numbering to tautomeric inverted stereo numbering */</a>
<a name="ln2254">            if ( !eq2taut ) {</a>
<a name="ln2255">                eq2taut = (Stereo_Taut = pINChI-&gt;Stereo) &amp;&amp; Stereo-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln2256">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM_INV | EQL_NUM_ISO, pINChI_Aux, EQL_NUM_INV );</a>
<a name="ln2257">                                 /* stereo-inv   isotopic numbering  (taut) =  taut stereo-inv numbering */</a>
<a name="ln2258">                eq2taut = eq2taut? (iiSTEREO_INV | iitISO | iiNUMB | iiEq2INV ) : 0;</a>
<a name="ln2259">            }</a>
<a name="ln2260">        }</a>
<a name="ln2261">        if ( eq2taut ) {</a>
<a name="ln2262">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln2263">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln2264">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln2265">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2266">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln2267">                    multPrevEquStr ++;</a>
<a name="ln2268">                } else {</a>
<a name="ln2269">                    /* new EqStr is different; output it */</a>
<a name="ln2270">                    if ( bNext ++ ) {</a>
<a name="ln2271">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2272">                    }</a>
<a name="ln2273">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2274">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln2275">                    multPrevEquStr = 1;</a>
<a name="ln2276">                }</a>
<a name="ln2277">            } else {</a>
<a name="ln2278">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln2279">                multPrevEquStr = 1;</a>
<a name="ln2280">            }</a>
<a name="ln2281">        } else {</a>
<a name="ln2282">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln2283">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2284">                /* new EqStr is different; output it */</a>
<a name="ln2285">                if ( bNext ++ ) {</a>
<a name="ln2286">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2287">                }</a>
<a name="ln2288">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2289">                pPrevEquStr = NULL;</a>
<a name="ln2290">                multPrevEquStr = 0;</a>
<a name="ln2291">            }</a>
<a name="ln2292">            if ( bNext ++ ) {</a>
<a name="ln2293">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2294">            }</a>
<a name="ln2295">            if ( pINChI &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic &amp;&amp; pINChI_Aux-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln2296">                 (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; Stereo-&gt;nNumberOfStereoCenters &amp;&amp;</a>
<a name="ln2297">                 Stereo-&gt;nCompInv2Abs &amp;&amp; pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv ) {</a>
<a name="ln2298">                    tot_len += MakeCtString( pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv,</a>
<a name="ln2299">                                             pINChI_Aux-&gt;nNumberOfAtoms, 0, NULL, 0,</a>
<a name="ln2300">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2301">            }</a>
<a name="ln2302">            /* else isotopic inv stereo info is not present in pINChI */</a>
<a name="ln2303">        }</a>
<a name="ln2304">    }</a>
<a name="ln2305">    if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2306">        /* the new EqStr of the last item has not been printed; output it now */</a>
<a name="ln2307">        if ( bNext ++ ) {</a>
<a name="ln2308">            tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2309">        }</a>
<a name="ln2310">        tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2311">        pPrevEquStr = NULL;</a>
<a name="ln2312">        multPrevEquStr = 0;</a>
<a name="ln2313">    }</a>
<a name="ln2314">    return tot_len;</a>
<a name="ln2315">}</a>
<a name="ln2316">/***************************************************************************/</a>
<a name="ln2317">int str_HillFormula(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2318">              int *bOverflow, int bOutType, int num_components, int bUseMulipliers)</a>
<a name="ln2319">{</a>
<a name="ln2320">    int          i, ii;</a>
<a name="ln2321">    INCHI_SORT   *is, *is0;</a>
<a name="ln2322">    INChI        *pINChI,  *pINChI_Prev;</a>
<a name="ln2323">    int          mult, eq2prev, bNext;</a>
<a name="ln2324"> </a>
<a name="ln2325">    if ( !(is0 = pINChISort) ) {</a>
<a name="ln2326">        return tot_len;</a>
<a name="ln2327">    }</a>
<a name="ln2328">    i  = 0;</a>
<a name="ln2329">    pINChI_Prev = (0 &lt;= (ii=GET_II(bOutType,is0)))? is0-&gt;pINChI[ii] : NULL;</a>
<a name="ln2330">    mult       = 0;</a>
<a name="ln2331">    bNext      = 0;</a>
<a name="ln2332">    for ( i++; i &lt;= num_components; i ++ ) {</a>
<a name="ln2333">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2334">        eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln2335">                  pINChI &amp;&amp; pINChI_Prev &amp;&amp; pINChI-&gt;szHillFormula &amp;&amp; pINChI_Prev-&gt;szHillFormula &amp;&amp;</a>
<a name="ln2336">                  pINChI-&gt;szHillFormula[0] &amp;&amp; !strcmp(pINChI_Prev-&gt;szHillFormula, pINChI-&gt;szHillFormula);</a>
<a name="ln2337">        if ( eq2prev ) {</a>
<a name="ln2338">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2339">            continue;</a>
<a name="ln2340">        } else {</a>
<a name="ln2341">            if ( bNext ++ ) {</a>
<a name="ln2342">                tot_len += MakeDelim( &quot;.&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2343">            }</a>
<a name="ln2344">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;szHillFormula &amp;&amp; pINChI_Prev-&gt;szHillFormula[0] ) {</a>
<a name="ln2345">                tot_len += MakeMult(  mult+1, &quot;&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2346">                tot_len += MakeHillFormulaString( pINChI_Prev-&gt;szHillFormula, pStr + tot_len,</a>
<a name="ln2347">                                                 nStrLen-tot_len, bOverflow);</a>
<a name="ln2348">            }</a>
<a name="ln2349">        }</a>
<a name="ln2350">        pINChI_Prev = pINChI;</a>
<a name="ln2351">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2352">    }</a>
<a name="ln2353">    return tot_len;</a>
<a name="ln2354">}</a>
<a name="ln2355">/***************************************************************************/</a>
<a name="ln2356">int str_HillFormula2(INCHI_SORT *pINChISort /* non-taut */, INCHI_SORT *pINChISort2 /* taut */,</a>
<a name="ln2357">                     char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2358">                     int *bOverflow, int bOutType, int num_components, int bUseMulipliers)</a>
<a name="ln2359">{</a>
<a name="ln2360">    int          i, ii, ii2;</a>
<a name="ln2361">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln2362">    INChI        *pINChI,  *pINChI_Prev, *pINChI_Taut, *pINChI_Taut_Prev;</a>
<a name="ln2363">    int          mult, eq2prev, bNext, bEqToTaut, tot_len_inp = tot_len;</a>
<a name="ln2364"> </a>
<a name="ln2365">    is   = NULL;</a>
<a name="ln2366">    is2  = NULL;</a>
<a name="ln2367">    is0  = pINChISort;</a>
<a name="ln2368">    is20 = pINChISort2;</a>
<a name="ln2369">    i  = 0;</a>
<a name="ln2370"> </a>
<a name="ln2371">    pINChI_Prev      = (0 &lt;= (ii=GET_II(bOutType,is0)))? is0-&gt;pINChI[ii] : NULL;</a>
<a name="ln2372">    pINChI_Taut_Prev = (0 &lt;= (ii2=GET_II(OUT_T1,is20)))? is20-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2373">    mult       = 0;</a>
<a name="ln2374">    bNext      = 0;</a>
<a name="ln2375">    bEqToTaut  = 1;</a>
<a name="ln2376">    bEqToTaut = bEqToTaut &amp;&amp;</a>
<a name="ln2377">                pINChI_Prev &amp;&amp; pINChI_Taut_Prev &amp;&amp; !pINChI_Taut_Prev-&gt;bDeleted &amp;&amp;</a>
<a name="ln2378">                pINChI_Prev-&gt;szHillFormula &amp;&amp; pINChI_Taut_Prev-&gt;szHillFormula &amp;&amp;</a>
<a name="ln2379">                !strcmp(pINChI_Prev-&gt;szHillFormula, pINChI_Taut_Prev-&gt;szHillFormula);</a>
<a name="ln2380">    for ( i++; i &lt;= num_components; i ++ ) {</a>
<a name="ln2381">        pINChI      = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii =GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2382">        pINChI_Taut = (i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2383">        if ( bEqToTaut &amp;&amp; (pINChI || pINChI_Taut) ) {</a>
<a name="ln2384">            bEqToTaut = pINChI &amp;&amp; pINChI_Taut &amp;&amp; !pINChI_Taut-&gt;bDeleted &amp;&amp;</a>
<a name="ln2385">                        pINChI-&gt;szHillFormula &amp;&amp; pINChI_Taut-&gt;szHillFormula &amp;&amp;</a>
<a name="ln2386">                        !strcmp(pINChI-&gt;szHillFormula, pINChI_Taut-&gt;szHillFormula);</a>
<a name="ln2387">        }</a>
<a name="ln2388">        eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln2389">                  pINChI &amp;&amp; pINChI_Prev &amp;&amp; pINChI-&gt;szHillFormula &amp;&amp; pINChI_Prev-&gt;szHillFormula &amp;&amp;</a>
<a name="ln2390">                  pINChI-&gt;szHillFormula[0] &amp;&amp; !strcmp(pINChI_Prev-&gt;szHillFormula, pINChI-&gt;szHillFormula);</a>
<a name="ln2391">        if ( eq2prev ) {</a>
<a name="ln2392">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2393">            continue;</a>
<a name="ln2394">        } else {</a>
<a name="ln2395">            if ( bNext ++ ) {</a>
<a name="ln2396">                tot_len += MakeDelim( &quot;.&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2397">            }</a>
<a name="ln2398">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;szHillFormula &amp;&amp; pINChI_Prev-&gt;szHillFormula[0] ) {</a>
<a name="ln2399">                tot_len += MakeMult(  mult+1, &quot;&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2400">                tot_len += MakeHillFormulaString( pINChI_Prev-&gt;szHillFormula, pStr + tot_len,</a>
<a name="ln2401">                                                 nStrLen-tot_len, bOverflow);</a>
<a name="ln2402">            }</a>
<a name="ln2403">        }</a>
<a name="ln2404">        pINChI_Prev = pINChI;</a>
<a name="ln2405">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2406">    }</a>
<a name="ln2407">    if ( bEqToTaut ) {</a>
<a name="ln2408">        pStr[tot_len=tot_len_inp] = '\0';</a>
<a name="ln2409">    }</a>
<a name="ln2410">    return tot_len;</a>
<a name="ln2411">}</a>
<a name="ln2412">/***************************************************************************/</a>
<a name="ln2413">int str_Connections(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2414">              int *bOverflow, int bOutType, int ATOM_MODE, int num_components, int bUseMulipliers)</a>
<a name="ln2415">{</a>
<a name="ln2416">    int          i, ii;</a>
<a name="ln2417">    INCHI_SORT   *is, *is0;</a>
<a name="ln2418">    INChI        *pINChI,  *pINChI_Prev;</a>
<a name="ln2419">    int          mult, eq2prev, bNext, tot_len_inp, nNumEmpty;</a>
<a name="ln2420"> </a>
<a name="ln2421">    if ( !(is0 = pINChISort) ) {</a>
<a name="ln2422">        return tot_len;</a>
<a name="ln2423">    }</a>
<a name="ln2424">    i  = 0;</a>
<a name="ln2425">    pINChI_Prev = (0 &lt;= (ii=GET_II(bOutType,is0)))? is0-&gt;pINChI[ii] : NULL;</a>
<a name="ln2426">    is          = NULL;</a>
<a name="ln2427">    mult        = 0;</a>
<a name="ln2428">    bNext       = 0;</a>
<a name="ln2429">    tot_len_inp = tot_len;</a>
<a name="ln2430">    nNumEmpty   = 0;</a>
<a name="ln2431">    for ( i++; i &lt;= num_components; i ++ ) {</a>
<a name="ln2432">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2433">        eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln2434">                 pINChI &amp;&amp; pINChI_Prev &amp;&amp; pINChI-&gt;lenConnTable &gt; 1 &amp;&amp;</a>
<a name="ln2435">                 pINChI_Prev-&gt;lenConnTable==pINChI-&gt;lenConnTable &amp;&amp;</a>
<a name="ln2436">                 !memcmp( pINChI_Prev-&gt;nConnTable, pINChI-&gt;nConnTable,</a>
<a name="ln2437">                          pINChI_Prev-&gt;lenConnTable*sizeof(pINChI-&gt;nConnTable[0]) );</a>
<a name="ln2438">        if ( eq2prev ) {</a>
<a name="ln2439">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2440">            continue;</a>
<a name="ln2441">        } else</a>
<a name="ln2442">        if ( pINChI_Prev ) {</a>
<a name="ln2443">            if ( bNext ++ ) {</a>
<a name="ln2444">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2445">            }</a>
<a name="ln2446">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;lenConnTable &gt; 1 ) {</a>
<a name="ln2447">                tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2448">                tot_len += MakeCtStringNew( pINChI_Prev-&gt;nConnTable, pINChI_Prev-&gt;lenConnTable, 0,</a>
<a name="ln2449">                                         NULL, pINChI_Prev-&gt;nNumberOfAtoms,</a>
<a name="ln2450">                                         pStr + tot_len, nStrLen-tot_len, ATOM_MODE, bOverflow);</a>
<a name="ln2451">            } else {</a>
<a name="ln2452">                nNumEmpty ++;</a>
<a name="ln2453">            }</a>
<a name="ln2454">        }</a>
<a name="ln2455">        pINChI_Prev = pINChI;</a>
<a name="ln2456">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2457">    }</a>
<a name="ln2458">    if ( nNumEmpty == num_components &amp;&amp; tot_len &gt; tot_len_inp ) {</a>
<a name="ln2459">        tot_len = tot_len_inp;</a>
<a name="ln2460">        pStr[tot_len] = '\0';</a>
<a name="ln2461">    }</a>
<a name="ln2462">    return tot_len;</a>
<a name="ln2463">}</a>
<a name="ln2464">/***************************************************************************/</a>
<a name="ln2465">int str_H_atoms(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2466">               int *bOverflow, int bOutType, int ATOM_MODE, int TAUT_MODE,</a>
<a name="ln2467">               int num_components, int bUseMulipliers)</a>
<a name="ln2468">{</a>
<a name="ln2469">    int          i, j, ii, len_H;</a>
<a name="ln2470">    INCHI_SORT   *is, *is0;</a>
<a name="ln2471">    INChI        *pINChI,  *pINChI_Prev;</a>
<a name="ln2472">    int          mult, eq2prev, bNext, bNotEmpty, nNumEmpty, tot_len_inp;</a>
<a name="ln2473"> </a>
<a name="ln2474">    nNumEmpty = 0;</a>
<a name="ln2475">    tot_len_inp = tot_len;</a>
<a name="ln2476">    is0 = pINChISort;</a>
<a name="ln2477">    is  = NULL;</a>
<a name="ln2478">    i  = 0;</a>
<a name="ln2479">    pINChI_Prev = (0 &lt;= (ii=GET_II(bOutType,is0)))? is0-&gt;pINChI[ii] : NULL;</a>
<a name="ln2480">    mult       = 0;</a>
<a name="ln2481">    bNext      = 0;</a>
<a name="ln2482">    for ( i++; i &lt;= num_components; i ++) {</a>
<a name="ln2483">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2484">        /*========== compare to previous ============*/</a>
<a name="ln2485">        eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln2486">                 pINChI &amp;&amp; pINChI_Prev &amp;&amp; (pINChI-&gt;nNumberOfAtoms &gt; 0 || pINChI-&gt;lenTautomer&gt;1) &amp;&amp;</a>
<a name="ln2487">                 pINChI_Prev-&gt;nNumberOfAtoms==pINChI-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln2488">                 (!pINChI_Prev-&gt;nNumberOfAtoms || !memcmp( pINChI_Prev-&gt;nNum_H, pINChI-&gt;nNum_H,</a>
<a name="ln2489">                          pINChI_Prev-&gt;nNumberOfAtoms*sizeof(pINChI-&gt;nNum_H[0]) ) ) &amp;&amp;</a>
<a name="ln2490">                 !CompareTautNonIsoPartOfINChI( pINChI_Prev, pINChI );</a>
<a name="ln2491">                  </a>
<a name="ln2492">        if ( eq2prev &amp;&amp; pINChI_Prev-&gt;lenTautomer &lt;= 1 ) {</a>
<a name="ln2493">            /* make sure it is not empty */</a>
<a name="ln2494">            eq2prev = 0;</a>
<a name="ln2495">            for ( j = 0; j &lt; pINChI_Prev-&gt;nNumberOfAtoms; j ++ ) {</a>
<a name="ln2496">                if ( pINChI_Prev-&gt;nNum_H[j] ) {</a>
<a name="ln2497">                    eq2prev = 1;</a>
<a name="ln2498">                    break;</a>
<a name="ln2499">                }</a>
<a name="ln2500">            }</a>
<a name="ln2501">        }</a>
<a name="ln2502">        if ( eq2prev ) {</a>
<a name="ln2503">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2504">            continue;</a>
<a name="ln2505">        } else</a>
<a name="ln2506">        if ( pINChI_Prev ) {</a>
<a name="ln2507">            /* delimiter */</a>
<a name="ln2508">            if ( bNext ++ ) {</a>
<a name="ln2509">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2510">            }</a>
<a name="ln2511">            /* verify non-empty */</a>
<a name="ln2512">            bNotEmpty = 0;</a>
<a name="ln2513">            if ( pINChI_Prev ) {</a>
<a name="ln2514">                bNotEmpty = (pINChI_Prev-&gt;lenTautomer &gt; 1);</a>
<a name="ln2515">                if ( !bNotEmpty ) {</a>
<a name="ln2516">                    for ( j = 0; j &lt; pINChI_Prev-&gt;nNumberOfAtoms; j ++ ) {</a>
<a name="ln2517">                        if ( pINChI_Prev-&gt;nNum_H[j] ) {</a>
<a name="ln2518">                            bNotEmpty = 1;</a>
<a name="ln2519">                            break;</a>
<a name="ln2520">                        }</a>
<a name="ln2521">                    }</a>
<a name="ln2522">                }</a>
<a name="ln2523">            }</a>
<a name="ln2524">            if ( bNotEmpty ) {</a>
<a name="ln2525">                tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2526">                /* H-atoms */</a>
<a name="ln2527">                tot_len += (len_H = MakeHString( 0, pINChI_Prev-&gt;nNum_H, pINChI_Prev-&gt;nNumberOfAtoms,</a>
<a name="ln2528">                                        pStr + tot_len, nStrLen-tot_len, ATOM_MODE, bOverflow ));</a>
<a name="ln2529">                /*  tautomeric groups */</a>
<a name="ln2530">                tot_len += MakeTautString( pINChI_Prev-&gt;nTautomer, pINChI_Prev-&gt;lenTautomer, (0!=len_H),</a>
<a name="ln2531">                                         pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2532">            } else {</a>
<a name="ln2533">                nNumEmpty ++;</a>
<a name="ln2534">            }</a>
<a name="ln2535">        }</a>
<a name="ln2536">        pINChI_Prev = pINChI;</a>
<a name="ln2537">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2538">    }</a>
<a name="ln2539">    if ( nNumEmpty == num_components &amp;&amp; tot_len &gt; tot_len_inp ) {</a>
<a name="ln2540">        tot_len = tot_len_inp;</a>
<a name="ln2541">        pStr[tot_len] = '\0';</a>
<a name="ln2542">    }</a>
<a name="ln2543">    return tot_len;</a>
<a name="ln2544">}</a>
<a name="ln2545">/***************************************************************************/</a>
<a name="ln2546">int str_Charge2(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2547">              int *bOverflow, int bOutType, int num_components,</a>
<a name="ln2548">              int bSecondNonTautPass, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln2549">{</a>
<a name="ln2550">    int          i, ii, ii2;</a>
<a name="ln2551">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln2552">    INChI        *pINChI,  *pINChI_Prev,  *pINChI_Taut,  *pINChI_Taut_Prev;</a>
<a name="ln2553">    int         nTotalCharge, nTotalCharge_Prev, nTotalCharge_Taut, nTotalCharge_Taut_Prev;</a>
<a name="ln2554">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln2555">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln2556">    int         multPrevEquStr;        </a>
<a name="ln2557">    pINChI_Taut      = NULL;</a>
<a name="ln2558">    pINChI_Prev      = NULL;</a>
<a name="ln2559">    pINChI_Taut_Prev = NULL;</a>
<a name="ln2560">    mult        = 0;</a>
<a name="ln2561">    bNext       = 0;</a>
<a name="ln2562">    is          = NULL;</a>
<a name="ln2563">    is2         = NULL;</a>
<a name="ln2564">    is0         = pINChISort;</a>
<a name="ln2565">    is20        = bSecondNonTautPass? pINChISort2 : NULL;</a>
<a name="ln2566">    eq2taut     = 0; /* may be non-zero only on the 2nd (non-taut) pass */</a>
<a name="ln2567">    eq2tautPrev = 1; /* pINChI_Prev (previous pINChI) does not exist */</a>
<a name="ln2568">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln2569">    multPrevEquStr = 0;     </a>
<a name="ln2570">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln2571">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln2572">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2573">        /*================ compare sp3 to previous =====================*/</a>
<a name="ln2574">        if ( bSecondNonTautPass ) {</a>
<a name="ln2575">            /* component that was output on the 1st pass */</a>
<a name="ln2576">            pINChI_Taut = ( i &lt; num_components &amp;&amp; (is2=is20+i, 0 &lt;= (ii2=GET_II(OUT_T1,is2))))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2577">        }</a>
<a name="ln2578">        /*========= if bSecondNonTautPass then compare non-iso non-taut stereo to non-iso taut ========*/</a>
<a name="ln2579">        eq2taut = 0;</a>
<a name="ln2580">        if ( !eq2taut &amp;&amp; bSecondNonTautPass &amp;&amp; bOmitRepetitions ) {</a>
<a name="ln2581">            eq2taut = pINChI &amp;&amp; pINChI_Taut &amp;&amp; !pINChI_Taut-&gt;bDeleted &amp;&amp;</a>
<a name="ln2582">                      (nTotalCharge = pINChI-&gt;nTotalCharge) &amp;&amp; (nTotalCharge_Taut = pINChI_Taut-&gt;nTotalCharge) &amp;&amp;</a>
<a name="ln2583">                      nTotalCharge == nTotalCharge_Taut;</a>
<a name="ln2584">            eq2taut = eq2taut? (iiEQU | iitNONTAUT) : 0;</a>
<a name="ln2585">        }</a>
<a name="ln2586">        if ( eq2taut ) {</a>
<a name="ln2587">            /* we may be here only in case of the second (non-taut) pass */</a>
<a name="ln2588">            /* current non-taut stereo has been found to be same as tautomeric */</a>
<a name="ln2589">            if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln2590">                /* previous component exists; output it */</a>
<a name="ln2591">                if ( bNext ++ ) {</a>
<a name="ln2592">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2593">                }</a>
<a name="ln2594">                if ( (nTotalCharge_Prev = pINChI_Prev-&gt;nTotalCharge) ) {</a>
<a name="ln2595">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2596">                    tot_len += sprintf( pStr + tot_len, &quot;%+d&quot;, nTotalCharge_Prev );</a>
<a name="ln2597">                }</a>
<a name="ln2598">            } else</a>
<a name="ln2599">            if ( pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms &amp;&amp; !pINChI_Taut_Prev-&gt;bDeleted ) {</a>
<a name="ln2600">                /* previous non-taut component exists only in taut list */</a>
<a name="ln2601">                if ( bNext ++ ) {</a>
<a name="ln2602">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2603">                }</a>
<a name="ln2604">            } </a>
<a name="ln2605">            /* we have found pINChI-&gt;nTotalCharge same as in pINChI_Taut */</a>
<a name="ln2606">            /* output this (current) equivalence as '*', that is, same as tautomeric */</a>
<a name="ln2607">            /* that was printed on the 1st pass. */</a>
<a name="ln2608"> </a>
<a name="ln2609">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln2610">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2611">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln2612">                    multPrevEquStr ++;</a>
<a name="ln2613">                } else {</a>
<a name="ln2614">                    /* new EqStr is different; output it */</a>
<a name="ln2615">                    if ( bNext ++ ) {</a>
<a name="ln2616">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2617">                    }</a>
<a name="ln2618">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2619">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln2620">                    multPrevEquStr = 1;</a>
<a name="ln2621">                }</a>
<a name="ln2622">            } else {</a>
<a name="ln2623">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln2624">                multPrevEquStr = 1;</a>
<a name="ln2625">            }</a>
<a name="ln2626"> </a>
<a name="ln2627">            pINChI_Prev      = NULL; /* pINChI_Prev sp2 does not exist since */</a>
<a name="ln2628">            pINChI_Taut_Prev = NULL; /* pINChI has just been printed */</a>
<a name="ln2629">            mult           = 0;</a>
<a name="ln2630">            eq2tautPrev    = 1;     /* pINChI_Prev sp2 does not exist */</a>
<a name="ln2631">        } else </a>
<a name="ln2632">        if ( eq2tautPrev ) {</a>
<a name="ln2633">            /* at this point pINChI_Prev does not exist; however, pINChI */</a>
<a name="ln2634">             /*might have been discovered and it is different from pINChI_Taut */</a>
<a name="ln2635">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2636">                /* new EqStr is different; output it */</a>
<a name="ln2637">                if ( bNext ++ ) {</a>
<a name="ln2638">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2639">                }</a>
<a name="ln2640">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2641">                pPrevEquStr = NULL;</a>
<a name="ln2642">                multPrevEquStr = 0;</a>
<a name="ln2643">            }</a>
<a name="ln2644">            eq2tautPrev = 0;</a>
<a name="ln2645">            pINChI_Prev      = pINChI;</a>
<a name="ln2646">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln2647">            mult = 0;</a>
<a name="ln2648">        } else {</a>
<a name="ln2649">            /* check whether pINChI and pINChI_Prev have non-zero identical stereo sp3 */</a>
<a name="ln2650">            /*================ compare sp3 to previous =====================*/</a>
<a name="ln2651">            eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln2652">                     pINChI &amp;&amp; pINChI_Prev &amp;&amp;</a>
<a name="ln2653">                     (nTotalCharge = pINChI-&gt;nTotalCharge) &amp;&amp; (nTotalCharge_Prev = pINChI_Prev-&gt;nTotalCharge) &amp;&amp;</a>
<a name="ln2654">                     nTotalCharge == nTotalCharge_Prev;</a>
<a name="ln2655">            if ( eq2prev ) {</a>
<a name="ln2656">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2657">                continue;</a>
<a name="ln2658">            } else {</a>
<a name="ln2659">                if ( bNext ++ ) {</a>
<a name="ln2660">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2661">                }</a>
<a name="ln2662">                if ( pINChI_Prev &amp;&amp; pINChI_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln2663">                    if ( (nTotalCharge_Prev = pINChI_Prev-&gt;nTotalCharge) ) {</a>
<a name="ln2664">                        /* pINChI_Prev exists and has charge info */</a>
<a name="ln2665">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2666">                        tot_len += sprintf( pStr + tot_len, &quot;%+d&quot;, nTotalCharge_Prev );</a>
<a name="ln2667">                    }</a>
<a name="ln2668">                    /* else charge is not present in pINChI_Prev */</a>
<a name="ln2669">                } else</a>
<a name="ln2670">                if ( bSecondNonTautPass &amp;&amp; pINChI_Taut_Prev &amp;&amp; pINChI_Taut_Prev-&gt;nNumberOfAtoms &amp;&amp; !pINChI_Taut_Prev-&gt;bDeleted ) {</a>
<a name="ln2671">                     if ( (nTotalCharge_Taut_Prev = pINChI_Taut_Prev-&gt;nTotalCharge) ) {</a>
<a name="ln2672">                        /* since pINChI_Prev does not exist, pINChI_Taut_Prev is non-tautomeric */</a>
<a name="ln2673">                        /* and it has charge info. This info has already been printed in the main section */</a>
<a name="ln2674">                        /*</a>
<a name="ln2675">                        tot_len += MakeDelim( sIdenticalValues, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2676">                        */</a>
<a name="ln2677">                        ; /* pINChI_Taut_Prev sp3 info was output in the main stereo section */</a>
<a name="ln2678">                     } else {</a>
<a name="ln2679">                        ; /* pINChI_Taut_Prev exists and has not sp3 info */</a>
<a name="ln2680">                     }</a>
<a name="ln2681">                }</a>
<a name="ln2682">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2683">                else {</a>
<a name="ln2684">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln2685">                }</a>
<a name="ln2686">#endif</a>
<a name="ln2687">            }</a>
<a name="ln2688">            pINChI_Prev = pINChI;</a>
<a name="ln2689">            pINChI_Taut_Prev = pINChI_Taut;</a>
<a name="ln2690">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2691">        }</a>
<a name="ln2692">    }</a>
<a name="ln2693">    return tot_len;</a>
<a name="ln2694">}</a>
<a name="ln2695">/***************************************************************************/</a>
<a name="ln2696">int str_FixedH_atoms(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2697">              int *bOverflow, int bOutType, int ATOM_MODE, int num_components, int bUseMulipliers)</a>
<a name="ln2698">{</a>
<a name="ln2699">    int          i, j, ii, nNumEmpty;</a>
<a name="ln2700">    INCHI_SORT   *is, *is0;</a>
<a name="ln2701">    INChI        *pINChI,  *pINChI_Prev;</a>
<a name="ln2702">    int          mult, eq2prev, bNext, bNotEmpty, tot_len_inp;</a>
<a name="ln2703"> </a>
<a name="ln2704">    is  = NULL;</a>
<a name="ln2705">    is0 = pINChISort;</a>
<a name="ln2706">    i  = 0;</a>
<a name="ln2707">    pINChI_Prev = (0 &lt;= (ii=GET_II(bOutType,is0)))? is0-&gt;pINChI[ii] : NULL;</a>
<a name="ln2708">    mult       = 0;</a>
<a name="ln2709">    bNext      = 0;</a>
<a name="ln2710">    nNumEmpty  = 0;</a>
<a name="ln2711">    tot_len_inp = tot_len;</a>
<a name="ln2712">    for ( i++; i &lt;= num_components; i ++ ) {</a>
<a name="ln2713">        /* only non-tautomeric representation of tautomeric */</a>
<a name="ln2714">        pINChI = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2715">        /*================ compare fixed H to previous =====================*/</a>
<a name="ln2716">        eq2prev =bUseMulipliers &amp;&amp;</a>
<a name="ln2717">                 pINChI &amp;&amp; pINChI_Prev &amp;&amp; pINChI-&gt;nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln2718">                 pINChI_Prev-&gt;nNumberOfAtoms==pINChI-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln2719">                 !memcmp( pINChI_Prev-&gt;nNum_H_fixed, pINChI-&gt;nNum_H_fixed,</a>
<a name="ln2720">                          pINChI_Prev-&gt;nNumberOfAtoms*sizeof(pINChI-&gt;nNum_H_fixed[0]) );</a>
<a name="ln2721">        if ( eq2prev ) {</a>
<a name="ln2722">            /* make sure it is not empty */</a>
<a name="ln2723">            eq2prev = 0;</a>
<a name="ln2724">            for ( j = 0; j &lt; pINChI_Prev-&gt;nNumberOfAtoms; j ++ ) {</a>
<a name="ln2725">                if ( pINChI_Prev-&gt;nNum_H_fixed[j] ) {</a>
<a name="ln2726">                    eq2prev = 1;</a>
<a name="ln2727">                    break;</a>
<a name="ln2728">                }</a>
<a name="ln2729">            }</a>
<a name="ln2730">        }</a>
<a name="ln2731">        if ( eq2prev ) {</a>
<a name="ln2732">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2733">            continue;</a>
<a name="ln2734">        } else {</a>
<a name="ln2735">            /* print pINChI_Prev */</a>
<a name="ln2736">            /* delimiter */</a>
<a name="ln2737">            if ( bNext ++ ) {</a>
<a name="ln2738">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2739">            }</a>
<a name="ln2740">            if ( pINChI_Prev ) {</a>
<a name="ln2741">                /* verify it is not empty */</a>
<a name="ln2742">                bNotEmpty = 0;</a>
<a name="ln2743">                for ( j = 0; j &lt; pINChI_Prev-&gt;nNumberOfAtoms; j ++ ) {</a>
<a name="ln2744">                    if ( pINChI_Prev-&gt;nNum_H_fixed[j] ) {</a>
<a name="ln2745">                        bNotEmpty = 1;</a>
<a name="ln2746">                        break;</a>
<a name="ln2747">                    }</a>
<a name="ln2748">                }</a>
<a name="ln2749">                if ( bNotEmpty ) {</a>
<a name="ln2750">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2751">                    /* H-atoms-fixed */</a>
<a name="ln2752">                    tot_len += MakeHString( 0, pINChI_Prev-&gt;nNum_H_fixed, pINChI_Prev-&gt;nNumberOfAtoms,</a>
<a name="ln2753">                                            pStr + tot_len, nStrLen-tot_len, ATOM_MODE, bOverflow );</a>
<a name="ln2754">                } else {</a>
<a name="ln2755">                    nNumEmpty ++;</a>
<a name="ln2756">                }</a>
<a name="ln2757">            }</a>
<a name="ln2758">        }</a>
<a name="ln2759">        pINChI_Prev = pINChI;</a>
<a name="ln2760">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2761">    }</a>
<a name="ln2762">    if ( nNumEmpty == num_components &amp;&amp; tot_len &gt; tot_len_inp ) {</a>
<a name="ln2763">        tot_len = tot_len_inp;</a>
<a name="ln2764">        pStr[tot_len] = '\0';</a>
<a name="ln2765">    }</a>
<a name="ln2766">    return tot_len;</a>
<a name="ln2767">}</a>
<a name="ln2768">/***************************************************************************/</a>
<a name="ln2769">int str_AuxNumb(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2770">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components,</a>
<a name="ln2771">              int bSecondNonTautPass, int bOmitRepetitions)</a>
<a name="ln2772">{</a>
<a name="ln2773">    int          i, ii, ii2;</a>
<a name="ln2774">    INCHI_SORT   *is, *is0 /*, *is2*/;</a>
<a name="ln2775">    INChI        *pINChI,  *pINChI_Taut=NULL;</a>
<a name="ln2776">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Taut=NULL;</a>
<a name="ln2777">    int          eq2taut, bNext;</a>
<a name="ln2778">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln2779">    int         multPrevEquStr;        </a>
<a name="ln2780">    bNext       = 0;</a>
<a name="ln2781">    /*is2         = bSecondNonTautPass? pINChISort2 : NULL;*/</a>
<a name="ln2782">    eq2taut     = 0; /* may be non-zero if another layer of the current component = current layer */</a>
<a name="ln2783">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln2784">    multPrevEquStr = 0;        </a>
<a name="ln2785">    is          = NULL;</a>
<a name="ln2786">    if ( !(is0 = pINChISort) ) {</a>
<a name="ln2787">        return tot_len;</a>
<a name="ln2788">    }</a>
<a name="ln2789">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln2790">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln2791">        is=is0+i;</a>
<a name="ln2792">        pINChI     = ( 0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln2793">        pINChI_Aux = pINChI? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln2794">        /*================ to compare to previously printed =====================*/</a>
<a name="ln2795">        if ( bSecondNonTautPass ) {</a>
<a name="ln2796">            /* component that was printed on the 1st pass */</a>
<a name="ln2797">            pINChI_Taut     = (0 &lt;= (ii2=GET_II(OUT_T1,is)))? is-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2798">            pINChI_Aux_Taut = pINChI_Taut? is-&gt;pINChI_Aux[ii2] : NULL;</a>
<a name="ln2799">        }</a>
<a name="ln2800">        eq2taut = 0;</a>
<a name="ln2801">        /*========= if bSecondNonTautPass then compare iso non-taut stereo to other stereo ========*/</a>
<a name="ln2802">        if ( bSecondNonTautPass &amp;&amp; bOmitRepetitions &amp;&amp; pINChI &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln2803">            /* compare non-tautomeric numbering to:</a>
<a name="ln2804">             *   a) tautomeric numbering</a>
<a name="ln2805">             */</a>
<a name="ln2806">            /* a) compare non-tautomeric numbering to tautomeric numbering */</a>
<a name="ln2807">            if ( !eq2taut ) {</a>
<a name="ln2808">                eq2taut = pINChI_Taut &amp;&amp; !pINChI_Taut-&gt;bDeleted &amp;&amp;</a>
<a name="ln2809">                  Eql_INChI_Aux_Num( pINChI_Aux, EQL_NUM, pINChI_Aux_Taut, EQL_NUM );</a>
<a name="ln2810">                                 /* numbering  non-taut =  taut numbering */</a>
<a name="ln2811">                eq2taut = eq2taut? ( iiNUMB | iitNONTAUT ) : 0;</a>
<a name="ln2812">            }</a>
<a name="ln2813">        }</a>
<a name="ln2814">        if ( eq2taut ) {</a>
<a name="ln2815">            /* we have found another (previously printed) layer of the current component equal to this layer */</a>
<a name="ln2816">            /* output this (current) equivalence mark = EquString(eq2taut) */</a>
<a name="ln2817">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln2818">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2819">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln2820">                    multPrevEquStr ++;</a>
<a name="ln2821">                } else {</a>
<a name="ln2822">                    /* new EqStr is different; output it */</a>
<a name="ln2823">                    if ( bNext ++ ) {</a>
<a name="ln2824">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2825">                    }</a>
<a name="ln2826">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2827">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln2828">                    multPrevEquStr = 1;</a>
<a name="ln2829">                }</a>
<a name="ln2830">            } else {</a>
<a name="ln2831">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln2832">                multPrevEquStr = 1;</a>
<a name="ln2833">            }</a>
<a name="ln2834">        } else {</a>
<a name="ln2835">            /* current layer is different from previously printed layers of the current component */</a>
<a name="ln2836">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2837">                /* new EqStr is different; output it */</a>
<a name="ln2838">                if ( bNext ++ ) {</a>
<a name="ln2839">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2840">                }</a>
<a name="ln2841">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2842">                pPrevEquStr = NULL;</a>
<a name="ln2843">                multPrevEquStr = 0;</a>
<a name="ln2844">            }</a>
<a name="ln2845">            if ( bNext ++ ) {</a>
<a name="ln2846">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2847">            }</a>
<a name="ln2848">            if ( pINChI &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;nNumberOfAtoms ) {</a>
<a name="ln2849">                    tot_len += MakeCtString( pINChI_Aux-&gt;nOrigAtNosInCanonOrd,</a>
<a name="ln2850">                                             pINChI_Aux-&gt;nNumberOfAtoms, 0, NULL, 0,</a>
<a name="ln2851">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2852">            }</a>
<a name="ln2853">        }</a>
<a name="ln2854">    }</a>
<a name="ln2855">    if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln2856">        /* the new EqStr of the last item has not been printed; output it now */</a>
<a name="ln2857">        if ( bNext ++ ) {</a>
<a name="ln2858">            tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2859">        }</a>
<a name="ln2860">        tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2861">        pPrevEquStr = NULL;</a>
<a name="ln2862">        multPrevEquStr = 0;</a>
<a name="ln2863">    }</a>
<a name="ln2864">    return tot_len;</a>
<a name="ln2865">}</a>
<a name="ln2866">/***************************************************************************/</a>
<a name="ln2867">int str_AuxTgroupEqu(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2868">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components, int bUseMulipliers)</a>
<a name="ln2869">{</a>
<a name="ln2870">    int          i, ii;</a>
<a name="ln2871">    INCHI_SORT   *is, *is0;</a>
<a name="ln2872">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev;</a>
<a name="ln2873">    int          mult, eq2prev, bNext;</a>
<a name="ln2874"> </a>
<a name="ln2875">    is0 = pINChISort;</a>
<a name="ln2876">    is  = NULL;</a>
<a name="ln2877">    i  = 0;</a>
<a name="ln2878">    pINChI_Aux_Prev = (0 &lt;= (ii=GET_II(bOutType,is0)))? is0-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln2879">    mult       = 0;</a>
<a name="ln2880">    bNext      = 0;</a>
<a name="ln2881">    for ( i++; i &lt;= num_components; i ++ ) {</a>
<a name="ln2882">        pINChI_Aux = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln2883">        eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln2884">                  Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_TG, pINChI_Aux_Prev, EQL_EQU_TG );</a>
<a name="ln2885">        if ( eq2prev ) {</a>
<a name="ln2886">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2887">            continue;</a>
<a name="ln2888">        } else {</a>
<a name="ln2889">            if ( bNext ++ ) {</a>
<a name="ln2890">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2891">            }</a>
<a name="ln2892">            if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfTGroups &amp;&amp;</a>
<a name="ln2893">                 bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquTGroupNumbers, pINChI_Aux_Prev-&gt;nNumberOfTGroups) ) {</a>
<a name="ln2894">                tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2895">                tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquTGroupNumbers, pINChI_Aux_Prev-&gt;nNumberOfTGroups, 0,</a>
<a name="ln2896">                                         pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2897">            }</a>
<a name="ln2898">        }</a>
<a name="ln2899">        pINChI_Aux_Prev = pINChI_Aux;</a>
<a name="ln2900">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2901">    }</a>
<a name="ln2902">    return tot_len;</a>
<a name="ln2903">}</a>
<a name="ln2904"> </a>
<a name="ln2905">/***************************************************************************/</a>
<a name="ln2906">int str_AuxChargeRadVal(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln2907">                  int *bOverflow, int bOutType, int TAUT_MODE, int num_components, int bUseMulipliers)</a>
<a name="ln2908">{</a>
<a name="ln2909">    int          i, ii;</a>
<a name="ln2910">    INCHI_SORT   *is, *is0;</a>
<a name="ln2911">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev;</a>
<a name="ln2912">    int          mult, eq2prev, bNext;</a>
<a name="ln2913"> </a>
<a name="ln2914">    pINChI_Aux_Prev = NULL;</a>
<a name="ln2915">    mult        = 0;</a>
<a name="ln2916">    bNext       = 0;</a>
<a name="ln2917">    is          = NULL;</a>
<a name="ln2918">    is0         = pINChISort;</a>
<a name="ln2919">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln2920">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln2921">        pINChI_Aux = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln2922">        /* check whether pINChI_Aux and pINChI_Aux_Prev have identical info */</a>
<a name="ln2923">        eq2prev = bUseMulipliers &amp;&amp;</a>
<a name="ln2924">                  EqlOrigInfo( pINChI_Aux, pINChI_Aux_Prev );</a>
<a name="ln2925">        if ( eq2prev ) {</a>
<a name="ln2926">            /* eq. info is same and non-trivial */</a>
<a name="ln2927">            mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln2928">            continue;</a>
<a name="ln2929">        } else</a>
<a name="ln2930">        if ( i ) {</a>
<a name="ln2931">            /* pINChI_Aux info is either different or trivial. Output pINChI_Aux_Prev anyway */</a>
<a name="ln2932">            if ( bNext ++ ) {</a>
<a name="ln2933">                tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln2934">            }</a>
<a name="ln2935">            if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln2936">                 if ( bHasOrigInfo( pINChI_Aux_Prev-&gt;OrigInfo, pINChI_Aux_Prev-&gt;nNumberOfAtoms ) ) {</a>
<a name="ln2937">                    /* pINChI_Aux_Prev exists and has orig. info info */</a>
<a name="ln2938">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln2939">                    tot_len += MakeCRVString( pINChI_Aux_Prev-&gt;OrigInfo, pINChI_Aux_Prev-&gt;nNumberOfAtoms, 0,</a>
<a name="ln2940">                                              pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln2941">                 } else {</a>
<a name="ln2942">                    ; /* pINChI_Aux_Prev exists and has only trivial info */</a>
<a name="ln2943">                 }</a>
<a name="ln2944">            }</a>
<a name="ln2945">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2946">            else {</a>
<a name="ln2947">                int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln2948">            }</a>
<a name="ln2949">#endif</a>
<a name="ln2950">        }</a>
<a name="ln2951">        pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln2952">        mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln2953">    }</a>
<a name="ln2954">    return tot_len;</a>
<a name="ln2955">}</a>
<a name="ln2956">/******************************************************************************************/</a>
<a name="ln2957">int bin_AuxTautTrans(INCHI_SORT *pINChISort, INCHI_SORT *pINChISort2,</a>
<a name="ln2958">                      AT_NUMB **pTrans_n, AT_NUMB **pTrans_s, int bOutType, int num_components)</a>
<a name="ln2959">{</a>
<a name="ln2960">    int          i, ii, ii2, ret;</a>
<a name="ln2961">    INCHI_SORT   *is, *is2, *is0, *is20;</a>
<a name="ln2962">    INChI        *pINChI, *pINChI_Taut;</a>
<a name="ln2963">    AT_NUMB     *nTrans_n  = NULL;</a>
<a name="ln2964">    AT_NUMB     *nTrans_s = NULL;</a>
<a name="ln2965"> </a>
<a name="ln2966">    ret = 0;</a>
<a name="ln2967">    is0  = pINChISort;</a>
<a name="ln2968">    is20 = pINChISort2;</a>
<a name="ln2969">    /* pass 1: save new non-taut numbering */</a>
<a name="ln2970">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln2971">        is=is0+i;</a>
<a name="ln2972">        is2=is20+i;</a>
<a name="ln2973">        pINChI      = ( 0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii]   : NULL;</a>
<a name="ln2974">        pINChI_Taut = ( 0 &lt;= (ii2=GET_II(OUT_T1,is2)))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2975">        if ( pINChI      &amp;&amp; pINChI-&gt;nNumberOfAtoms      &gt; 0 &amp;&amp;</a>
<a name="ln2976">             pINChI_Taut &amp;&amp; pINChI_Taut-&gt;nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln2977">             /* different components save equal new ord. numbers: */</a>
<a name="ln2978">             is-&gt;ord_number != is2-&gt;ord_number ) {</a>
<a name="ln2979">            if ( (nTrans_n &amp;&amp; nTrans_s) || </a>
<a name="ln2980">                 ((nTrans_n  = (AT_NUMB *)inchi_calloc( num_components+1, sizeof(nTrans_n[0]))) &amp;&amp;</a>
<a name="ln2981">                 (nTrans_s  = (AT_NUMB *)inchi_calloc( num_components+1, sizeof(nTrans_s[0])))) ) {</a>
<a name="ln2982">                /* new ordering number for original non-tautomeric component number is-&gt;ord_number */</a>
<a name="ln2983">                nTrans_n[is-&gt;ord_number] = /*nTrans_t[is2-&gt;ord_number] =*/ i+1;</a>
<a name="ln2984">            }</a>
<a name="ln2985">        }</a>
<a name="ln2986">    }</a>
<a name="ln2987">    if ( nTrans_n &amp;&amp; nTrans_s ) {</a>
<a name="ln2988">        /* pass 2: get new taut numbering, retrieve new non-taut and save the transposition */</a>
<a name="ln2989">        for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln2990">            is=is0+i;</a>
<a name="ln2991">            is2=is20+i;</a>
<a name="ln2992">            pINChI      = ( 0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii]   : NULL;</a>
<a name="ln2993">            pINChI_Taut = ( 0 &lt;= (ii2=GET_II(OUT_T1,is2)))? is2-&gt;pINChI[ii2] : NULL;</a>
<a name="ln2994">            if ( pINChI      &amp;&amp; pINChI-&gt;nNumberOfAtoms      &gt; 0 &amp;&amp;</a>
<a name="ln2995">                 pINChI_Taut &amp;&amp; pINChI_Taut-&gt;nNumberOfAtoms &gt; 0 &amp;&amp;</a>
<a name="ln2996">                 is-&gt;ord_number != is2-&gt;ord_number &amp;&amp;</a>
<a name="ln2997">                 nTrans_n[is2-&gt;ord_number] ) {</a>
<a name="ln2998">                 /* nTrans_n[is2-&gt;ord_number] is new ordering number of</a>
<a name="ln2999">                    the non-taut representation of the tautomeric component</a>
<a name="ln3000">                    that has new ord number i+1 and orig ordering number is2-&gt;ord_number.</a>
<a name="ln3001">                    Old numbers start from 0, new start from 1</a>
<a name="ln3002">                  */</a>
<a name="ln3003"> </a>
<a name="ln3004">                /* n = nTrans_s[t]: taut component #t is in position #n of the non-taut representation */</a>
<a name="ln3005">                nTrans_s[i+1] = nTrans_n[is2-&gt;ord_number];</a>
<a name="ln3006">            }</a>
<a name="ln3007">        }</a>
<a name="ln3008">        *pTrans_n = nTrans_n;</a>
<a name="ln3009">        *pTrans_s = nTrans_s;</a>
<a name="ln3010">        ret = 1;</a>
<a name="ln3011">    } else {</a>
<a name="ln3012">        if ( nTrans_n ) {</a>
<a name="ln3013">            inchi_free( nTrans_n );</a>
<a name="ln3014">            ret = -1;</a>
<a name="ln3015">        }</a>
<a name="ln3016">        if ( nTrans_s ) {</a>
<a name="ln3017">            inchi_free( nTrans_s );</a>
<a name="ln3018">            ret = -1;</a>
<a name="ln3019">        }</a>
<a name="ln3020">    }</a>
<a name="ln3021">    return ret;</a>
<a name="ln3022">}</a>
<a name="ln3023">/******************************************************************************************/</a>
<a name="ln3024">int str_AuxTautTrans(AT_NUMB *nTrans_n, AT_NUMB *nTrans_s, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln3025">                     int *bOverflow, int TAUT_MODE, int num_components)</a>
<a name="ln3026">{</a>
<a name="ln3027">    int          i, k, len, j;</a>
<a name="ln3028"> </a>
<a name="ln3029">    if ( nTrans_n &amp;&amp; nTrans_s ) {</a>
<a name="ln3030">        /* print the transposition, cycle after cycle */</a>
<a name="ln3031">        for ( i = 1; i &lt;= num_components; i ++ ) {</a>
<a name="ln3032">            if ( nTrans_s[i] ) {</a>
<a name="ln3033">                /* get one cycle of the transposition */</a>
<a name="ln3034">                for ( j = i, len = 0; (k = nTrans_s[j]); j = k, len ++ ) {</a>
<a name="ln3035">                    nTrans_n[len] = j; /* save the transposition */</a>
<a name="ln3036">                    nTrans_s[j]   = 0; /* clear used element to avoid repetitions */</a>
<a name="ln3037">                }</a>
<a name="ln3038">                /* print one cycle of the transposition */</a>
<a name="ln3039">                tot_len += MakeDelim( &quot;(&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3040">                tot_len += MakeCtString( nTrans_n, len, 0, NULL, 0,</a>
<a name="ln3041">                                         pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln3042">                tot_len += MakeDelim( &quot;)&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3043">            }</a>
<a name="ln3044">        }</a>
<a name="ln3045">    }</a>
<a name="ln3046">    if ( nTrans_n )</a>
<a name="ln3047">        inchi_free( nTrans_n );</a>
<a name="ln3048">    if ( nTrans_s )</a>
<a name="ln3049">        inchi_free( nTrans_s );</a>
<a name="ln3050">    return tot_len;</a>
<a name="ln3051">}</a>
<a name="ln3052">/***************************************************************************/</a>
<a name="ln3053">int str_StereoAbsInv(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln3054">               int *bOverflow, int bOutType, int num_components)</a>
<a name="ln3055">{</a>
<a name="ln3056">    int          i, j, ii;</a>
<a name="ln3057">    INCHI_SORT   *is, *is0;</a>
<a name="ln3058">    INChI_Stereo *Stereo;</a>
<a name="ln3059">    INChI        *pINChI;</a>
<a name="ln3060"> </a>
<a name="ln3061">    is  = NULL;</a>
<a name="ln3062">    is0 = pINChISort;</a>
<a name="ln3063"> </a>
<a name="ln3064">    for ( i = 0; !*bOverflow &amp;&amp; i &lt; num_components; i ++ ) {</a>
<a name="ln3065">        is=is0+i;</a>
<a name="ln3066">        pINChI = (0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln3067">        if ( pINChI &amp;&amp; (Stereo = pINChI-&gt;Stereo) &amp;&amp; (j=Stereo-&gt;nCompInv2Abs) ) {</a>
<a name="ln3068">            tot_len += MakeDelim( j&lt;0? &quot;1&quot;:&quot;0&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3069">        } else {</a>
<a name="ln3070">            tot_len += MakeDelim( &quot;.&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3071">        }</a>
<a name="ln3072">    }</a>
<a name="ln3073"> </a>
<a name="ln3074">    return tot_len;</a>
<a name="ln3075">}</a>
<a name="ln3076">/***************************************************************************/</a>
<a name="ln3077">int str_IsoStereoAbsInv(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln3078">               int *bOverflow, int bOutType, int num_components)</a>
<a name="ln3079">{</a>
<a name="ln3080">    int          i, j, ii;</a>
<a name="ln3081">    INCHI_SORT   *is, *is0;</a>
<a name="ln3082">    INChI_Stereo *Stereo;</a>
<a name="ln3083">    INChI        *pINChI;</a>
<a name="ln3084"> </a>
<a name="ln3085">    is  = NULL;</a>
<a name="ln3086">    is0 = pINChISort;</a>
<a name="ln3087"> </a>
<a name="ln3088">    for ( i = 0; !*bOverflow &amp;&amp; i &lt; num_components; i ++ ) {</a>
<a name="ln3089">        is=is0+i;</a>
<a name="ln3090">        pINChI = (0 &lt;= (ii=GET_II(bOutType,is)))? is-&gt;pINChI[ii] : NULL;</a>
<a name="ln3091">        if ( pINChI &amp;&amp; (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp; (j=Stereo-&gt;nCompInv2Abs) ) {</a>
<a name="ln3092">            tot_len += MakeDelim( j&lt;0? &quot;1&quot;:&quot;0&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3093">        } else {</a>
<a name="ln3094">            tot_len += MakeDelim( &quot;.&quot;, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3095">        }</a>
<a name="ln3096">    }</a>
<a name="ln3097"> </a>
<a name="ln3098">    return tot_len;</a>
<a name="ln3099">}</a>
<a name="ln3100">/***************************************************************************/</a>
<a name="ln3101">int str_AuxIsoTgroupEqu(INCHI_SORT *pINChISort, char *pStr, int nStrLen, int tot_len,</a>
<a name="ln3102">              int *bOverflow, int bOutType, int TAUT_MODE, int num_components, int bOmitRepetitions, int bUseMulipliers)</a>
<a name="ln3103">{</a>
<a name="ln3104">    int          i, ii;</a>
<a name="ln3105">    INCHI_SORT   *is, *is0;</a>
<a name="ln3106">    INChI_Aux    *pINChI_Aux, *pINChI_Aux_Prev;</a>
<a name="ln3107">    int          mult, eq2prev, eq2taut, eq2tautPrev, bNext;</a>
<a name="ln3108">    const char  *pPrevEquStr, *pCurrEquStr;</a>
<a name="ln3109">    int         multPrevEquStr;        </a>
<a name="ln3110">    pINChI_Aux           = NULL;</a>
<a name="ln3111">    pINChI_Aux_Prev      = NULL;</a>
<a name="ln3112">    mult        = 0;</a>
<a name="ln3113">    bNext       = 0;</a>
<a name="ln3114">    is          = NULL;</a>
<a name="ln3115">    is0         = pINChISort;</a>
<a name="ln3116">    eq2taut     = 0; /* equal to non-isotopic equivalence */</a>
<a name="ln3117">    eq2tautPrev = 1; /* pINChI_Aux_Prev (previous pINChI_Aux) does not exist */</a>
<a name="ln3118">    pPrevEquStr = NULL; /*, *pCurrEquStr;*/</a>
<a name="ln3119">    multPrevEquStr = 0;        </a>
<a name="ln3120">    for ( i = 0; i &lt;= num_components; i ++ ) {</a>
<a name="ln3121">        /* 1st (taut) pass: bOutType=OUT_TN  ; 2nd (non-taut pass) bOutType=OUT_NT */</a>
<a name="ln3122">        pINChI_Aux = (i &lt; num_components &amp;&amp; (is=is0+i, 0 &lt;= (ii=GET_II(bOutType,is))))? is-&gt;pINChI_Aux[ii] : NULL;</a>
<a name="ln3123">        /*================ compare iso non-taut equivalence info to non-iso taut ========*/</a>
<a name="ln3124">        eq2taut = 0;</a>
<a name="ln3125">        if ( bOmitRepetitions &amp;&amp; pINChI_Aux &amp;&amp; pINChI_Aux-&gt;bIsIsotopic ) {</a>
<a name="ln3126">            /**************************************************</a>
<a name="ln3127">             * compare isotopic tautomeric equivalence to:</a>
<a name="ln3128">             *    a) non-isotopic tautomeric</a>
<a name="ln3129">             */</a>
<a name="ln3130">            /* compare isotopic t-group equivalence to non-isotopic */</a>
<a name="ln3131">            eq2taut = Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_TG | EQL_EQU_ISO, pINChI_Aux, EQL_EQU_TG );</a>
<a name="ln3132">                               /* equ   taut-isotopic = tautomeric, same as for isotopic atom equivalence info*/</a>
<a name="ln3133">            eq2taut = eq2taut? (iiEQU | iitISO) : 0;</a>
<a name="ln3134">        }</a>
<a name="ln3135">        if ( eq2taut ) {</a>
<a name="ln3136">            /* current isotopic t-group equivalence has been found to be same as non-isotopic */</a>
<a name="ln3137">            if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln3138">                /* previous component exists */</a>
<a name="ln3139">                if ( bNext ++ ) {</a>
<a name="ln3140">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3141">                }</a>
<a name="ln3142">                if ( bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicTGroupNumbers, pINChI_Aux_Prev-&gt;nNumberOfTGroups) ) {</a>
<a name="ln3143">                    /* output previous component(s) equivalence since it was found to be non-trivial */</a>
<a name="ln3144">                    tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln3145">                    tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicTGroupNumbers, pINChI_Aux_Prev-&gt;nNumberOfTGroups, 0,</a>
<a name="ln3146">                                             pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln3147">                } else {</a>
<a name="ln3148">                    ; /* pINChI_Aux_Prev exists and does not have non-trivial t-group equivalence info */</a>
<a name="ln3149">                }</a>
<a name="ln3150">            }</a>
<a name="ln3151">            /* we have found pINChI_Aux-&gt;pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers same as in pINChI_Aux-&gt;nConstitEquTGroupNumbers */</a>
<a name="ln3152">            pCurrEquStr = EquString(eq2taut);</a>
<a name="ln3153">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln3154">                if ( pCurrEquStr &amp;&amp; !strcmp(pCurrEquStr, pPrevEquStr) ) {</a>
<a name="ln3155">                    multPrevEquStr ++;</a>
<a name="ln3156">                } else {</a>
<a name="ln3157">                    /* new EqStr is different; output it */</a>
<a name="ln3158">                    if ( bNext ++ ) {</a>
<a name="ln3159">                        tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3160">                    }</a>
<a name="ln3161">                    tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3162">                    pPrevEquStr = pCurrEquStr;</a>
<a name="ln3163">                    multPrevEquStr = 1;</a>
<a name="ln3164">                }</a>
<a name="ln3165">            } else {</a>
<a name="ln3166">                pPrevEquStr = pCurrEquStr;</a>
<a name="ln3167">                multPrevEquStr = 1;</a>
<a name="ln3168">            }</a>
<a name="ln3169">            pINChI_Aux_Prev      = NULL; /* pINChI_Aux_Prev has already been output */</a>
<a name="ln3170">            mult           = 0;</a>
<a name="ln3171">            eq2tautPrev    = 1;</a>
<a name="ln3172">        } else</a>
<a name="ln3173">        if ( eq2tautPrev ) {</a>
<a name="ln3174">            /* at this point pINChI_Aux_Prev does not exist; however, pINChI_Aux */</a>
<a name="ln3175">            /* might have been discovered and it may be different from non-isotopic */</a>
<a name="ln3176">            if ( multPrevEquStr &amp;&amp; pPrevEquStr ) {</a>
<a name="ln3177">                /* new EqStr is different; output it */</a>
<a name="ln3178">                if ( bNext ++ ) {</a>
<a name="ln3179">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3180">                }</a>
<a name="ln3181">                tot_len += MakeEqStr( pPrevEquStr, multPrevEquStr, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3182">                pPrevEquStr = NULL;</a>
<a name="ln3183">                multPrevEquStr = 0;</a>
<a name="ln3184">            }</a>
<a name="ln3185">            eq2tautPrev = 0;</a>
<a name="ln3186">            pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln3187">            mult = 0;</a>
<a name="ln3188">        } else {</a>
<a name="ln3189">            /* check whether pINChI_Aux and pINChI_Aux_Prev have identical non-trivial isotopic t-group equivalence info */</a>
<a name="ln3190">            eq2prev = bUseMulipliers &amp;&amp; Eql_INChI_Aux_Equ( pINChI_Aux, EQL_EQU_TG | EQL_EQU_ISO, pINChI_Aux_Prev, EQL_EQU_TG | EQL_EQU_ISO );</a>
<a name="ln3191">            if ( eq2prev ) {</a>
<a name="ln3192">                /* eq. info is same and non-trivial */</a>
<a name="ln3193">                mult ++; /* mult = (number of non-empty equal items)-1 */</a>
<a name="ln3194">                continue;</a>
<a name="ln3195">            } else {</a>
<a name="ln3196">                /* pINChI_Aux eq. info is either different or trivial. Output pINChI_Aux_Prev anyway */</a>
<a name="ln3197">                if ( bNext ++ ) {</a>
<a name="ln3198">                    tot_len += MakeDelim( sCompDelim, pStr + tot_len, nStrLen-tot_len, bOverflow);</a>
<a name="ln3199">                }</a>
<a name="ln3200">                if ( pINChI_Aux_Prev &amp;&amp; pINChI_Aux_Prev-&gt;nNumberOfAtoms ) {</a>
<a name="ln3201">                     if ( bHasEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicTGroupNumbers, pINChI_Aux_Prev-&gt;nNumberOfTGroups) ) {</a>
<a name="ln3202">                        /* pINChI_Aux_Prev exists and has equivalence info */</a>
<a name="ln3203">                        tot_len += MakeMult(  mult+1, &quot;*&quot;, pStr + tot_len, nStrLen-tot_len, 0, bOverflow);</a>
<a name="ln3204">                        tot_len += MakeEquString( pINChI_Aux_Prev-&gt;nConstitEquIsotopicTGroupNumbers, pINChI_Aux_Prev-&gt;nNumberOfTGroups, 0,</a>
<a name="ln3205">                                                 pStr + tot_len, nStrLen-tot_len, TAUT_MODE, bOverflow);</a>
<a name="ln3206">                     } else {</a>
<a name="ln3207">                        ; /* pINChI_Aux_Prev exists and has only trivial equivalence info */</a>
<a name="ln3208">                     }</a>
<a name="ln3209">                }</a>
<a name="ln3210">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3211">                else {</a>
<a name="ln3212">                    int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln3213">                }</a>
<a name="ln3214">#endif</a>
<a name="ln3215">            }</a>
<a name="ln3216">            pINChI_Aux_Prev      = pINChI_Aux;</a>
<a name="ln3217">            mult = 0; /* we do not know whether the item is empty */</a>
<a name="ln3218">        }</a>
<a name="ln3219">    }</a>
<a name="ln3220">    return tot_len;</a>
<a name="ln3221">}</a>

</code></pre>
<div class="balloon" rel="114"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !eq2taut.</p></div>
<div class="balloon" rel="148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="290"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !eq2taut.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="448"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !eq2taut.</p></div>
<div class="balloon" rel="460"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI_Prev.</p></div>
<div class="balloon" rel="490"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="635"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="653"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bSecondNonTautPass.</p></div>
<div class="balloon" rel="653"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bOmitRepetitions.</p></div>
<div class="balloon" rel="679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="675"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="724"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="862"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bSecondNonTautPass.</p></div>
<div class="balloon" rel="879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bOmitRepetitions.</p></div>
<div class="balloon" rel="905"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="901"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="1100"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="1229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1300"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="1425"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'ii' index could reach -1.</p></div>
<div class="balloon" rel="1430"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'ii2' index could reach -1.</p></div>
<div class="balloon" rel="1443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1469"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1464"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1480"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="1562"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: i < num_components.</p></div>
<div class="balloon" rel="1576"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1593"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1607"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="1698"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1722"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1756"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="1889"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1888"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1898"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1923"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1931"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1939"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1973"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1972"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="1981"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1989"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI.</p></div>
<div class="balloon" rel="1960"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2031"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="2158"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'ii' index could reach -1.</p></div>
<div class="balloon" rel="2163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'ii2' index could reach -1.</p></div>
<div class="balloon" rel="2180"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="2217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (Stereo_Taut = pINChI->StereoIsotopic).</p></div>
<div class="balloon" rel="2242"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="2255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: Stereo->nCompInv2Abs.</p></div>
<div class="balloon" rel="2231"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="2446"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pINChI_Prev.</p></div>
<div class="balloon" rel="2513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pINChI_Prev' is always true.</p></div>
<div class="balloon" rel="2580"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !eq2taut.</p></div>
<div class="balloon" rel="2610"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="2793"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'ii' index could reach -1.</p></div>
<div class="balloon" rel="2798"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'ii2' index could reach -1.</p></div>
<div class="balloon" rel="2807"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!eq2taut' is always true.</p></div>
<div class="balloon" rel="2818"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>
<div class="balloon" rel="3153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pCurrEquStr' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

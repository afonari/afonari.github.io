
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>runichi.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44">#include &lt;stdarg.h&gt;</a>
<a name="ln45">/* #include &lt;varargs.h&gt; */</a>
<a name="ln46">#include &lt;errno.h&gt;</a>
<a name="ln47">#include &lt;limits.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;mode.h&quot;       /* moved from below, suggestion by David Mosenkis */</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;ichitime.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln56">#include &lt;conio.h&gt;</a>
<a name="ln57">#endif</a>
<a name="ln58"> </a>
<a name="ln59">#include &quot;inpdef.h&quot;</a>
<a name="ln60">#include &quot;ichi.h&quot;</a>
<a name="ln61">#include &quot;strutil.h&quot;</a>
<a name="ln62">#include &quot;util.h&quot;</a>
<a name="ln63">#include &quot;ichidrp.h&quot;</a>
<a name="ln64">#include &quot;ichierr.h&quot;</a>
<a name="ln65">#include &quot;ichimain.h&quot;</a>
<a name="ln66">#include &quot;extr_ct.h&quot;</a>
<a name="ln67">#include &quot;ichitaut.h&quot;</a>
<a name="ln68">#include &quot;ichi_io.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln71">#include &quot;ichi_lib.h&quot;</a>
<a name="ln72">#endif</a>
<a name="ln73">#include &quot;inchi_api.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">#include &quot;ichicomp.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77">#if ( ADD_CMLPP == 1 )</a>
<a name="ln78">#include &quot;readcml.hpp&quot;</a>
<a name="ln79">#include &quot;debug.h&quot;</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">/* for DisplayTheWholeStructure() */</a>
<a name="ln84"> </a>
<a name="ln85">#define COMP_ORIG_0_MAIN  0x0001</a>
<a name="ln86">#define COMP_ORIG_0_RECN  0x0002</a>
<a name="ln87">#define COMP_PREP_0_MAIN  0x0004</a>
<a name="ln88">#define COMP_PREP_0_RECN  0x0008</a>
<a name="ln89">#define COMP_ORIG_1_MAIN  0x0010</a>
<a name="ln90">#define COMP_ORIG_1_RECN  0x0020</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">/* local prototypes */</a>
<a name="ln94">int GetProcessingWarningsOneINChI(INChI *pINChI, INP_ATOM_DATA *inp_norm_data, char *pStrErrStruct);</a>
<a name="ln95">int  GetProcessingWarnings(INChI *cur_INChI[], INP_ATOM_DATA **inp_norm_data, STRUCT_DATA *sd);</a>
<a name="ln96">int DisplayTheWholeStructure( STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle, </a>
<a name="ln97">                              INCHI_IOSTREAM *inp_file, INCHI_IOSTREAM *log_file,</a>
<a name="ln98">                              ORIG_ATOM_DATA *orig_inp_data, long num_inp, int iINChI, int bShowStruct, int bINCHI_LIB_Flag );</a>
<a name="ln99">int DuplicateOrigAtom( ORIG_ATOM_DATA *new_orig_atom, ORIG_ATOM_DATA *orig_atom );</a>
<a name="ln100">int bCheckUnusualValences( ORIG_ATOM_DATA *orig_at_data, int bAddIsoH,  char *pStrErrStruct );</a>
<a name="ln101">int CreateCompositeNormAtom( COMP_ATOM_DATA *composite_norm_data, INP_ATOM_DATA2 *all_inp_norm_data,</a>
<a name="ln102">                             PINChI2 *pINChI, PINChI_Aux2 *pINChI_Aux, int num_components, INCHI_MODE nMode );</a>
<a name="ln103">int DetectInputINChIFileType( FILE **inp_file, INPUT_PARMS *ip, const char *fmode );</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">/*  callback */</a>
<a name="ln107">int (*ConsoleQuit)(void) = NULL; /*  Console user issued CTRL+C etc. */</a>
<a name="ln108">int (*UserAction)(void)  = NULL; /*  callback */</a>
<a name="ln109"> </a>
<a name="ln110">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln111">void (*FWPRINT) (const char * format, va_list argptr )=NULL;</a>
<a name="ln112">void (*DRAWDATA) ( struct DrawData * pDrawData) = NULL;</a>
<a name="ln113">int (*DRAWDATA_EXISTS) ( int nComponent, int nType, int bReconnected ) = NULL;</a>
<a name="ln114">struct DrawData * (*GET_DRAWDATA) ( int nComponent, int nType, int bReconnected ) = NULL;</a>
<a name="ln115">#endif</a>
<a name="ln116"> </a>
<a name="ln117">#if ( TEST_RENUMB_ATOMS == 1 ) /* { */</a>
<a name="ln118">/************************************************/</a>
<a name="ln119">/*    atoms renumbering -- for testing only     */</a>
<a name="ln120">/************************************************/</a>
<a name="ln121">typedef struct tagRenumbData {</a>
<a name="ln122">    PINChI2         ren_INChI2[1];</a>
<a name="ln123">    PINChI_Aux2     ren_INChI_Aux[1];</a>
<a name="ln124">    INP_ATOM_DATA  orig_inp_cur_data;</a>
<a name="ln125">    INP_ATOM_DATA  saved_inp_cur_data;</a>
<a name="ln126">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 || TEST_RENUMB_SWITCH == 1 )</a>
<a name="ln127">    INP_ATOM_DATA  longest_inp_cur_data;</a>
<a name="ln128">#endif</a>
<a name="ln129">    INP_ATOM_DATA  ren_inp_norm_data1, ren_inp_norm_data2;</a>
<a name="ln130">    INP_ATOM_DATA  *ren_inp_norm_data[2];</a>
<a name="ln131">    int            ren_counter;</a>
<a name="ln132">    int            num_taut, num_non_taut, num_taut0, num_non_taut0;</a>
<a name="ln133">    AT_RANK       *new_ord;</a>
<a name="ln134">    int            nRet2, c1, c2, nComp, bRenumbErr;</a>
<a name="ln135">    unsigned long  ulCurTimeNorm0, ulCurTimeCanon0, ulCurTimeNorm1, ulCurTimeCanon1;</a>
<a name="ln136">    unsigned long  ulCurTimeNorm, ulCurTimeCanon, ulMaxTimeNorm, ulMaxTimeCanon;</a>
<a name="ln137">    unsigned long  ulMaxTime, ulCurTime, ulCurTime0, ulCurTime1;</a>
<a name="ln138">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln139">    int bExtract;</a>
<a name="ln140">#endif</a>
<a name="ln141">} RENUMB_DATA;</a>
<a name="ln142"> </a>
<a name="ln143">int RenumberingTestInit( RENUMB_DATA *pRenumbData, INP_ATOM_DATA *inp_cur_data );</a>
<a name="ln144">int RenumberingTestUninit( RENUMB_DATA *pRenumbData );</a>
<a name="ln145">int RenumberingTest( PINChI2 *pICh, PINChI_Aux2 *pINChI_Aux, ORIG_ATOM_DATA *orig_inp_data, int iINChI,</a>
<a name="ln146">                     RENUMB_DATA *pRenumbData, INP_ATOM_DATA *inp_cur_data, INP_ATOM_DATA **inp_norm_data,</a>
<a name="ln147">                     STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *prb_file,</a>
<a name="ln148">                     int i, long num_inp, NORM_CANON_FLAGS *pncFlags);</a>
<a name="ln149">/*</a>
<a name="ln150">int RenumberingTest( INChI *pINChI[][TAUT_NUM], INChI_Aux *pINChI_Aux[][TAUT_NUM], int iINChI,</a>
<a name="ln151">                     RENUMB_DATA *pRenumbData, INP_ATOM_DATA *inp_cur_data, INP_ATOM_DATA **inp_norm_data,</a>
<a name="ln152">                     STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle, INCHI_IOSTREAM *log_file, int i, long num_inp);</a>
<a name="ln153">*/</a>
<a name="ln154">#endif /* } TEST_RENUMB_ATOMS */</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln159">/********************************************************************/</a>
<a name="ln160">void FillTableParms( SET_DRAW_PARMS *sdp, INChI **cur_INChI, INChI_Aux **cur_INChI_Aux,</a>
<a name="ln161">                     INCHI_MODE nMode, int bShowIsotopic, int indx )</a>
<a name="ln162">{</a>
<a name="ln163">    TBL_DRAW_PARMS *tdp = sdp-&gt;tdp;</a>
<a name="ln164">    char   (*ReqShownFound)[TDP_NUM_PAR] = tdp-&gt;ReqShownFound;</a>
<a name="ln165">    int  i, j;</a>
<a name="ln166">    INChI_Stereo *Stereo;</a>
<a name="ln167">    int          bShowTaut = (cur_INChI &amp;&amp; cur_INChI[indx]-&gt;lenTautomer &gt; 0)? 1 : 0;</a>
<a name="ln168">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln169">    int bRelRac = 0 != (nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO ));</a>
<a name="ln170">#endif</a>
<a name="ln171">    if ( !cur_INChI || !cur_INChI_Aux ) {</a>
<a name="ln172">        sdp-&gt;tdp-&gt;bDrawTbl = 0;</a>
<a name="ln173">        sdp-&gt;bOrigAtom     = 1;</a>
<a name="ln174">        return;</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    /*  Displayed */</a>
<a name="ln178">    ReqShownFound[ilSHOWN][itBASIC]    =  bShowTaut?     'T':'\0';</a>
<a name="ln179">    ReqShownFound[ilSHOWN][itISOTOPIC] =  bShowIsotopic? 'I':'\0';</a>
<a name="ln180">/*</a>
<a name="ln181">    ReqShownFound[ilSHOWN][itBASIC]    =  bShowTaut?     'T':'B';</a>
<a name="ln182">    ReqShownFound[ilSHOWN][itISOTOPIC] =  bShowIsotopic? 'I':'N';</a>
<a name="ln183"> */</a>
<a name="ln184">    i = indx;</a>
<a name="ln185">    if ( cur_INChI[i] ) {</a>
<a name="ln186">        Stereo = bShowIsotopic? cur_INChI[i]-&gt;StereoIsotopic : cur_INChI[i]-&gt;Stereo;</a>
<a name="ln187">    } else {</a>
<a name="ln188">        Stereo = NULL;</a>
<a name="ln189">    }</a>
<a name="ln190">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln191">    if ( Stereo &amp;&amp; ( 0 &lt; Stereo-&gt;nNumberOfStereoBonds ||</a>
<a name="ln192">                     0 &lt; Stereo-&gt;nNumberOfStereoCenters-bRelRac ) ) {</a>
<a name="ln193">        ReqShownFound[ilSHOWN][itSTEREO] = 'S';</a>
<a name="ln194">        if ( Stereo-&gt;nNumberOfStereoCenters &amp;&amp; Stereo-&gt;nCompInv2Abs == -1 &amp;&amp;</a>
<a name="ln195">             ( nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO ) ) ) {</a>
<a name="ln196">            if ( Stereo-&gt;nNumberOfStereoCenters &lt; 2 &amp;&amp; !Stereo-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln197">                ReqShownFound[ilSHOWN][itSTEREO] = '\0';</a>
<a name="ln198">            } else</a>
<a name="ln199">            if ( Stereo-&gt;nNumberOfStereoCenters &gt;= 2 ) {</a>
<a name="ln200">                ReqShownFound[ilSHOWN][itSTEREO] =  's'; /* shown Inverted stereo */</a>
<a name="ln201">            }</a>
<a name="ln202">        }</a>
<a name="ln203">#else  /* REL_RAC_STEREO_IGN_1_SC == 0 */</a>
<a name="ln204">    if ( Stereo &amp;&amp; ( Stereo-&gt;nNumberOfStereoBonds || Stereo-&gt;nNumberOfStereoCenters ) ) {</a>
<a name="ln205">        ReqShownFound[ilSHOWN][itSTEREO] = 'S';</a>
<a name="ln206">        if ( Stereo-&gt;nNumberOfStereoCenters &amp;&amp; Stereo-&gt;nCompInv2Abs == -1 &amp;&amp;</a>
<a name="ln207">             ( nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO ) ) ) {</a>
<a name="ln208">            /*</a>
<a name="ln209">            if ( Stereo-&gt;nNumberOfStereoCenters &lt; 2 &amp;&amp; !Stereo-&gt;nNumberOfStereoBonds ) {</a>
<a name="ln210">                ReqShownFound[ilSHOWN][itSTEREO] = '\0';</a>
<a name="ln211">            } else</a>
<a name="ln212">            if ( Stereo-&gt;nNumberOfStereoCenters &gt;= 2 ) {</a>
<a name="ln213">            */</a>
<a name="ln214">                ReqShownFound[ilSHOWN][itSTEREO] =  's'; /* shown Inverted stereo */</a>
<a name="ln215">            /*</a>
<a name="ln216">            }</a>
<a name="ln217">            */</a>
<a name="ln218">        }</a>
<a name="ln219">#endif /* REL_RAC_STEREO_IGN_1_SC */</a>
<a name="ln220">    } else {</a>
<a name="ln221">        ReqShownFound[ilSHOWN][itSTEREO] = '\0';</a>
<a name="ln222">    }</a>
<a name="ln223">    /*</a>
<a name="ln224">    ReqShownFound[ilSHOWN][itSTEREO]   =</a>
<a name="ln225">        (bShowIsotopic? (cur_INChI[i] &amp;&amp; cur_INChI[i]-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln226">                         (cur_INChI[i]-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds ||</a>
<a name="ln227">                          cur_INChI[i]-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) )</a>
<a name="ln228">                        :</a>
<a name="ln229">                        (cur_INChI[i] &amp;&amp; cur_INChI[i]-&gt;Stereo &amp;&amp;</a>
<a name="ln230">                         (cur_INChI[i]-&gt;Stereo-&gt;nNumberOfStereoBonds ||</a>
<a name="ln231">                          cur_INChI[i]-&gt;Stereo-&gt;nNumberOfStereoCenters) )</a>
<a name="ln232">        ) ? 'S':'\0';</a>
<a name="ln233">    */</a>
<a name="ln234"> </a>
<a name="ln235">    /* remove zeroes between chars */</a>
<a name="ln236">    for ( i = j = 0; i &lt; TDP_NUM_PAR; i ++ ) {</a>
<a name="ln237">        if ( ReqShownFound[ilSHOWN][i] &gt;= ' ' ) {</a>
<a name="ln238">            ReqShownFound[ilSHOWN][j++] = ReqShownFound[ilSHOWN][i];</a>
<a name="ln239">        }</a>
<a name="ln240">    }</a>
<a name="ln241">    i = j;</a>
<a name="ln242">    for ( ; i &lt; TDP_NUM_PAR; i ++ ) {</a>
<a name="ln243">        ReqShownFound[ilSHOWN][i] = '\0';</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    sdp-&gt;tdp-&gt;bDrawTbl = j? 1 : 0;</a>
<a name="ln247">    sdp-&gt;bOrigAtom     = 0;</a>
<a name="ln248">}</a>
<a name="ln249">/********************************************************************/</a>
<a name="ln250">void FillCompositeTableParms( SET_DRAW_PARMS *sdp, AT_NUMB StereoFlags,</a>
<a name="ln251">                     INCHI_MODE nMode, int bShowIsotopic, int bShowTaut )</a>
<a name="ln252">{</a>
<a name="ln253">    TBL_DRAW_PARMS *tdp = sdp-&gt;tdp;</a>
<a name="ln254">    char    (*ReqShownFound)[TDP_NUM_PAR] = tdp-&gt;ReqShownFound;</a>
<a name="ln255">    int  i, j;</a>
<a name="ln256"> </a>
<a name="ln257">    /*  Displayed */</a>
<a name="ln258">    ReqShownFound[ilSHOWN][itBASIC]    =  bShowTaut?     'T':'\0';</a>
<a name="ln259">    ReqShownFound[ilSHOWN][itISOTOPIC] =  bShowIsotopic? 'I':'\0';</a>
<a name="ln260">/*</a>
<a name="ln261">    ReqShownFound[ilSHOWN][itBASIC]    =  bShowTaut?     'T':'B';</a>
<a name="ln262">    ReqShownFound[ilSHOWN][itISOTOPIC] =  bShowIsotopic? 'I':'N';</a>
<a name="ln263"> */</a>
<a name="ln264">    if ( StereoFlags &amp; INF_STEREO ) {</a>
<a name="ln265">        ReqShownFound[ilSHOWN][itSTEREO] = 'S';</a>
<a name="ln266">        if ( (StereoFlags &amp; INF_STEREO_INV) &amp;&amp;</a>
<a name="ln267">            ( nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO ) ) ) {</a>
<a name="ln268">            if (StereoFlags &amp; (INF_STEREO_REL | INF_STEREO_RAC) ) {</a>
<a name="ln269">                ReqShownFound[ilSHOWN][itSTEREO] = 's';</a>
<a name="ln270">            } else {</a>
<a name="ln271">                ReqShownFound[ilSHOWN][itSTEREO] =  '\0'; /* shown Inverted stereo */</a>
<a name="ln272">            }</a>
<a name="ln273">        }</a>
<a name="ln274">    } else {</a>
<a name="ln275">        ReqShownFound[ilSHOWN][itSTEREO] = '\0';</a>
<a name="ln276">    }</a>
<a name="ln277">    /*</a>
<a name="ln278">    ReqShownFound[ilSHOWN][itSTEREO]   =</a>
<a name="ln279">        (bShowIsotopic? (cur_INChI[i] &amp;&amp; cur_INChI[i]-&gt;StereoIsotopic &amp;&amp;</a>
<a name="ln280">                         (cur_INChI[i]-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds ||</a>
<a name="ln281">                          cur_INChI[i]-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters) )</a>
<a name="ln282">                        :</a>
<a name="ln283">                        (cur_INChI[i] &amp;&amp; cur_INChI[i]-&gt;Stereo &amp;&amp;</a>
<a name="ln284">                         (cur_INChI[i]-&gt;Stereo-&gt;nNumberOfStereoBonds ||</a>
<a name="ln285">                          cur_INChI[i]-&gt;Stereo-&gt;nNumberOfStereoCenters) )</a>
<a name="ln286">        ) ? 'S':'\0';</a>
<a name="ln287">    */</a>
<a name="ln288"> </a>
<a name="ln289">    /* remove zeroes between chars */</a>
<a name="ln290">    for ( i = j = 0; i &lt; TDP_NUM_PAR; i ++ ) {</a>
<a name="ln291">        if ( ReqShownFound[ilSHOWN][i] &gt;= ' ' ) {</a>
<a name="ln292">            ReqShownFound[ilSHOWN][j++] = ReqShownFound[ilSHOWN][i];</a>
<a name="ln293">        }</a>
<a name="ln294">    }</a>
<a name="ln295">    i = j;</a>
<a name="ln296">    for ( ; i &lt; TDP_NUM_PAR; i ++ ) {</a>
<a name="ln297">        ReqShownFound[ilSHOWN][i] = '\0';</a>
<a name="ln298">    }</a>
<a name="ln299"> </a>
<a name="ln300">    sdp-&gt;tdp-&gt;bDrawTbl = j? 1 : 0;</a>
<a name="ln301">    sdp-&gt;bOrigAtom     = 0;</a>
<a name="ln302">}</a>
<a name="ln303">#endif</a>
<a name="ln304">/* IchiParm.c was here */</a>
<a name="ln305">/*******************************************************************/</a>
<a name="ln306">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln307">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln308">/*******************************************************************/</a>
<a name="ln309">int DisplayStructure( inp_ATOM *at, int num_at, int num_removed_H, int bAdd_DT_to_num_H,</a>
<a name="ln310">                      int nNumRemovedProtons, NUM_H *nNumRemovedProtonsIsotopic,</a>
<a name="ln311">                      int bIsotopic, int j /*bTautomeric*/,</a>
<a name="ln312">                      INChI **cur_INChI, INChI_Aux **cur_INChI_Aux,</a>
<a name="ln313">                      int bAbcNumbers, DRAW_PARMS *dp, INCHI_MODE nMode, char *szTitle )</a>
<a name="ln314">{</a>
<a name="ln315">    INF_ATOM_DATA inf_data = {NULL,};</a>
<a name="ln316">    int err = -1;</a>
<a name="ln317">    if ( CreateInfoAtomData( &amp;inf_data, num_at, 1 ) ) {</a>
<a name="ln318">        err = 0;</a>
<a name="ln319">        FillOutInfAtom( at, &amp;inf_data, num_at, num_removed_H, bAdd_DT_to_num_H,</a>
<a name="ln320">                        nNumRemovedProtons, nNumRemovedProtonsIsotopic, bIsotopic,</a>
<a name="ln321">                        cur_INChI?cur_INChI[j]:NULL,</a>
<a name="ln322">                        cur_INChI_Aux?cur_INChI_Aux[j]:NULL, bAbcNumbers, nMode);</a>
<a name="ln323">        FillTableParms( &amp;dp-&gt;sdp, cur_INChI, cur_INChI_Aux, nMode, bIsotopic, j );</a>
<a name="ln324">        err = DisplayInputStructure( szTitle, at, &amp;inf_data, num_at, dp );</a>
<a name="ln325">        FreeInfoAtomData( &amp;inf_data );</a>
<a name="ln326">    }</a>
<a name="ln327">    return err;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/*******************************************************************/</a>
<a name="ln331">int DisplayCompositeStructure( COMP_ATOM_DATA *composite_norm_data, int bIsotopic, int bTautomeric,</a>
<a name="ln332">                      PINChI2 *pINChI2, PINChI_Aux2 *pINChI_Aux2,</a>
<a name="ln333">                      int bAbcNumbers, DRAW_PARMS *dp, INCHI_MODE nMode, char *szTitle )</a>
<a name="ln334">{</a>
<a name="ln335">    INF_ATOM_DATA inf_data;</a>
<a name="ln336">    int err = -1, ret;</a>
<a name="ln337">    memset( &amp;inf_data, 0, sizeof(inf_data) );</a>
<a name="ln338">    if ( CreateInfoAtomData( &amp;inf_data, (composite_norm_data+bTautomeric)-&gt;num_at,</a>
<a name="ln339">                              (composite_norm_data+bTautomeric)-&gt;num_components ) ) {</a>
<a name="ln340">        ret = FillOutCompositeCanonInfAtom(composite_norm_data, &amp;inf_data,</a>
<a name="ln341">                                 bIsotopic, bTautomeric,</a>
<a name="ln342">                                 pINChI2, pINChI_Aux2, bAbcNumbers, nMode);</a>
<a name="ln343">        if ( !ret ) {</a>
<a name="ln344">            goto exit_function; /* error */</a>
<a name="ln345">        }</a>
<a name="ln346">        if ( bTautomeric == TAUT_INI ) {</a>
<a name="ln347">            /*</a>
<a name="ln348">            FillOutInfAtom( (composite_norm_data+bTautomeric)-&gt;at, &amp;inf_data, (composite_norm_data+bTautomeric)-&gt;num_at,</a>
<a name="ln349">                            (composite_norm_data+bTautomeric)-&gt;num_removed_H, bAdd_DT_to_num_H,</a>
<a name="ln350">                            (composite_norm_data+bTautomeric)-&gt;nNumRemovedProtons,</a>
<a name="ln351">                            (composite_norm_data+bTautomeric)-&gt;nNumRemovedProtonsIsotopic, bIsotopic,</a>
<a name="ln352">                            NULL, NULL, bAbcNumbers, nMode);</a>
<a name="ln353">            */</a>
<a name="ln354">            ;</a>
<a name="ln355">        } else {</a>
<a name="ln356">            /* real check for tautomeric components 02-04-2005 */</a>
<a name="ln357">            int m, nNumTautComponents = 0;</a>
<a name="ln358">            if ( 1 == bTautomeric ) {</a>
<a name="ln359">                for ( m = 0; m &lt; composite_norm_data[TAUT_YES].num_components; m ++ ) {</a>
<a name="ln360">                    if ( !pINChI2[m][TAUT_YES] )</a>
<a name="ln361">                        continue;</a>
<a name="ln362">                    if ( pINChI2[m][TAUT_YES]-&gt;bDeleted || pINChI2[m][TAUT_YES]-&gt;lenTautomer &gt; 0 )</a>
<a name="ln363">                        nNumTautComponents ++;</a>
<a name="ln364">                }</a>
<a name="ln365">            }</a>
<a name="ln366">            FillCompositeTableParms( &amp;dp-&gt;sdp, inf_data.StereoFlags, nMode, bIsotopic, nNumTautComponents );</a>
<a name="ln367">        }</a>
<a name="ln368">        err = DisplayInputStructure( szTitle, (composite_norm_data+bTautomeric)-&gt;at, &amp;inf_data, (composite_norm_data+bTautomeric)-&gt;num_at, dp );</a>
<a name="ln369">        FreeInfoAtomData( &amp;inf_data );</a>
<a name="ln370">    }</a>
<a name="ln371">exit_function:</a>
<a name="ln372">    return err;</a>
<a name="ln373">}</a>
<a name="ln374">#endif</a>
<a name="ln375">#endif</a>
<a name="ln376">/************************************************/</a>
<a name="ln377">const char *ErrMsg( int nErrorCode )</a>
<a name="ln378">{</a>
<a name="ln379">    const char *p;</a>
<a name="ln380">    static char szErrMsg[64];</a>
<a name="ln381">    switch( nErrorCode ) {</a>
<a name="ln382">        case 0:                      p = &quot;&quot;;                      break;</a>
<a name="ln383">        case CT_OVERFLOW:            p = &quot;ARRAY OVERFLOW&quot;;        break;</a>
<a name="ln384">        case CT_LEN_MISMATCH:        p = &quot;LENGTH_MISMATCH&quot;;       break;</a>
<a name="ln385">        case CT_OUT_OF_RAM:          p = &quot;Out of RAM&quot;;            break;</a>
<a name="ln386">        case CT_RANKING_ERR:         p = &quot;RANKING_ERR&quot;;           break;</a>
<a name="ln387">        case CT_ISOCOUNT_ERR:        p = &quot;ISOCOUNT_ERR&quot;;          break;</a>
<a name="ln388">        case CT_TAUCOUNT_ERR:        p = &quot;TAUCOUNT_ERR&quot;;          break;</a>
<a name="ln389">        case CT_ISOTAUCOUNT_ERR:     p = &quot;ISOTAUCOUNT_ERR&quot;;       break;</a>
<a name="ln390">        case CT_MAPCOUNT_ERR:        p = &quot;MAPCOUNT_ERR&quot;;          break;</a>
<a name="ln391">        case CT_TIMEOUT_ERR:         p = &quot;Time limit exceeded&quot;;   break;</a>
<a name="ln392">        case CT_ISO_H_ERR:           p = &quot;ISO_H_ERR&quot;;             break;</a>
<a name="ln393">        case CT_STEREOCOUNT_ERR:     p = &quot;STEREOCOUNT_ERR&quot;;       break;</a>
<a name="ln394">        case CT_ATOMCOUNT_ERR:       p = &quot;ATOMCOUNT_ERR&quot;;         break;</a>
<a name="ln395">        case CT_STEREOBOND_ERROR:    p = &quot;STEREOBOND_ERR&quot;;        break;</a>
<a name="ln396">        case CT_USER_QUIT_ERR:       p = &quot;User requested termination&quot;; break;</a>
<a name="ln397">        case CT_REMOVE_STEREO_ERR:   p = &quot;REMOVE_STEREO_ERR&quot;;     break;</a>
<a name="ln398">        case CT_CALC_STEREO_ERR:     p = &quot;CALC_STEREO_ERR&quot;;       break;</a>
<a name="ln399">        case CT_STEREO_CANON_ERR:    p = &quot;STEREO_CANON_ERR&quot;;      break;</a>
<a name="ln400">        case CT_CANON_ERR:           p = &quot;CANON_ERR&quot;;             break;</a>
<a name="ln401">        case CT_WRONG_FORMULA:       p = &quot;Wrong or missing chemical formula&quot;;  break;</a>
<a name="ln402">        /*case CT_CANON_ERR2:          p = &quot;CT_CANON_ERR2&quot;;         break;*/</a>
<a name="ln403">        case CT_UNKNOWN_ERR:         p = &quot;UNKNOWN_ERR&quot;;           break;</a>
<a name="ln404">        case BNS_RADICAL_ERR:        p = &quot;Cannot process free radical center&quot;; break;</a>
<a name="ln405">        case BNS_ALTBOND_ERR:        p = &quot;Cannot process aromatic bonds&quot;;      break;</a>
<a name="ln406"> </a>
<a name="ln407">        default:</a>
<a name="ln408">            if ( nErrorCode &gt; CT_UNKNOWN_ERR ) {</a>
<a name="ln409">                sprintf( szErrMsg, &quot;No description(%d)&quot;, nErrorCode );</a>
<a name="ln410">                p = szErrMsg;</a>
<a name="ln411">            } else {</a>
<a name="ln412">                sprintf( szErrMsg, &quot;UNKNOWN_ERR(%d)&quot;, CT_UNKNOWN_ERR - nErrorCode );</a>
<a name="ln413">                p = szErrMsg;</a>
<a name="ln414">            }</a>
<a name="ln415">            break;</a>
<a name="ln416">    }</a>
<a name="ln417">    return p;</a>
<a name="ln418">}</a>
<a name="ln419">/***********************************************************************************/</a>
<a name="ln420">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln421">/***********************************************************************************/</a>
<a name="ln422">int SaveEquComponentsInfoAndSortOrder ( int iINChI, INCHI_SORT *pINChISort[TAUT_NUM], int *num_components,</a>
<a name="ln423">                                        ORIG_ATOM_DATA *orig_inp_data, ORIG_ATOM_DATA *prep_inp_data,</a>
<a name="ln424">                                        COMP_ATOM_DATA composite_norm_data[TAUT_NUM+1],</a>
<a name="ln425">                                        int bCompareComponents )</a>
<a name="ln426">{</a>
<a name="ln427">    int nRet = 0, i, k, nNumDeleted;</a>
<a name="ln428">    /* equivalent components and sorting order */</a>
<a name="ln429">    /* bCompareComponents: bit = 1 =&gt; compare */</a>
<a name="ln430">    /*                     bit = 2 =&gt; compare non-isotopic */</a>
<a name="ln431">    /*                     bit = 4 =&gt; compare non-tautomeric  */</a>
<a name="ln432">    int bCompareIsotopic, bCompareTaut, bCompareAlt;</a>
<a name="ln433">    ORIG_ATOM_DATA *inp_data = NULL;</a>
<a name="ln434"> </a>
<a name="ln435">    if ( num_components[iINChI] &lt;= 1 )</a>
<a name="ln436">        return 0;</a>
<a name="ln437">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln438">    if ( !DRAWDATA )</a>
<a name="ln439">        return 0;</a>
<a name="ln440">#endif</a>
<a name="ln441">    if ( !(bCompareComponents &amp; CMP_COMPONENTS) )</a>
<a name="ln442">        return 0;</a>
<a name="ln443">    bCompareIsotopic = !(bCompareComponents &amp; CMP_COMPONENTS_NONISO);</a>
<a name="ln444">    bCompareTaut     =  (bCompareComponents &amp; CMP_COMPONENTS_NONTAUT) ? TAUT_NON : TAUT_YES;</a>
<a name="ln445">    bCompareAlt      =  ALT_TAUT(bCompareTaut);</a>
<a name="ln446">    if ( num_components[iINChI] &gt; 1 ) {</a>
<a name="ln447">        if ( prep_inp_data[iINChI].bSavedInINCHI_LIB[iINChI] &amp;&amp; prep_inp_data[iINChI].bPreprocessed[iINChI] ) {</a>
<a name="ln448">            inp_data       = prep_inp_data+iINChI;</a>
<a name="ln449">        } else</a>
<a name="ln450">        if ( orig_inp_data-&gt;bSavedInINCHI_LIB[iINChI] &amp;&amp; !orig_inp_data-&gt;bPreprocessed[iINChI] ) {</a>
<a name="ln451">            inp_data       = orig_inp_data;</a>
<a name="ln452">        } else {</a>
<a name="ln453">            inp_data       = NULL;</a>
<a name="ln454">        }</a>
<a name="ln455">        if ( inp_data &amp;&amp; !inp_data-&gt;nEquLabels &amp;&amp; !prep_inp_data[iINChI].nSortedOrder ) {</a>
<a name="ln456">            int i1, i2, nSet;</a>
<a name="ln457">            AT_NUMB nAtNo;</a>
<a name="ln458">            AT_NUMB nNumAtoms = (AT_NUMB)inp_data-&gt;num_inp_atoms;</a>
<a name="ln459">            if ( (prep_inp_data[iINChI].nSortedOrder =</a>
<a name="ln460">                                 (AT_NUMB *)inchi_calloc(num_components[iINChI]+1,</a>
<a name="ln461">                                                    sizeof(prep_inp_data[0].nSortedOrder[0])))) {</a>
<a name="ln462">                inp_data-&gt;nNumEquSets = 0;</a>
<a name="ln463">                for ( i1 = 0, nSet = 0; i1 &lt; num_components[iINChI]; i1 = i2 ) {</a>
<a name="ln464">                    nNumDeleted = (pINChISort[bCompareTaut][i1].pINChI[bCompareTaut] &amp;&amp; pINChISort[bCompareTaut][i1].pINChI[bCompareTaut]-&gt;bDeleted);</a>
<a name="ln465">                    for ( i2 = i1+1; i2 &lt; num_components[iINChI]; i2 ++ ) {</a>
<a name="ln466">                        /* isotopic/non-isotopic comparison does not separate equivalent components */</a>
<a name="ln467">                        if ( CompINChI2( pINChISort[bCompareTaut]+i1, pINChISort[bCompareTaut]+i2, bCompareTaut, bCompareIsotopic ) ) {</a>
<a name="ln468">                            break;</a>
<a name="ln469">                        } else {</a>
<a name="ln470">                            nNumDeleted += (pINChISort[bCompareTaut][i2].pINChI[bCompareTaut] &amp;&amp; pINChISort[bCompareTaut][i2].pINChI[bCompareTaut]-&gt;bDeleted);</a>
<a name="ln471">                        }</a>
<a name="ln472">                    }</a>
<a name="ln473">                    if ( i2 - i1 - nNumDeleted &gt; 1 ) {</a>
<a name="ln474">                        if ( inp_data-&gt;nEquLabels ||</a>
<a name="ln475">                             (inp_data-&gt;nEquLabels = (AT_NUMB *)inchi_calloc(inp_data-&gt;num_inp_atoms+1,</a>
<a name="ln476">                                                 sizeof(inp_data-&gt;nEquLabels[0]))) ) {</a>
<a name="ln477">                            nSet ++; /* found i2-i1 equivalent components &amp;&amp; memory has been allocated */</a>
<a name="ln478">                            for ( i = i1; i &lt; i2; i ++ ) {</a>
<a name="ln479">                                INChI_Aux *pINChI_Aux;</a>
<a name="ln480">                                if (pINChISort[bCompareTaut][i].pINChI[bCompareTaut] &amp;&amp; pINChISort[bCompareTaut][i].pINChI[bCompareTaut]-&gt;bDeleted)</a>
<a name="ln481">                                    continue;</a>
<a name="ln482">                                pINChI_Aux = (pINChISort[bCompareTaut][i].pINChI_Aux[bCompareTaut] &amp;&amp;</a>
<a name="ln483">                                             pINChISort[bCompareTaut][i].pINChI_Aux[bCompareTaut]-&gt;nNumberOfAtoms)?</a>
<a name="ln484">                                                pINChISort[bCompareTaut][i].pINChI_Aux[bCompareTaut]:</a>
<a name="ln485">                                             (pINChISort[bCompareTaut][i].pINChI_Aux[bCompareAlt] &amp;&amp;</a>
<a name="ln486">                                             pINChISort[bCompareTaut][i].pINChI_Aux[bCompareAlt]-&gt;nNumberOfAtoms)?</a>
<a name="ln487">                                                pINChISort[bCompareTaut][i].pINChI_Aux[bCompareAlt]:</a>
<a name="ln488">                                             (INChI_Aux *)NULL;</a>
<a name="ln489">                                if ( pINChI_Aux &amp;&amp; pINChI_Aux-&gt;nOrigAtNosInCanonOrd ) {</a>
<a name="ln490">                                    for ( k = 0; k &lt; pINChI_Aux-&gt;nNumberOfAtoms; k ++ ) {</a>
<a name="ln491">                                        if ( (nAtNo = pINChI_Aux-&gt;nOrigAtNosInCanonOrd[k]) &amp;&amp;</a>
<a name="ln492">                                              nAtNo &lt;= nNumAtoms ) {</a>
<a name="ln493">                                            inp_data-&gt;nEquLabels[nAtNo-1] = nSet;</a>
<a name="ln494">                                        }</a>
<a name="ln495">                                    }</a>
<a name="ln496">                                }</a>
<a name="ln497">                            }</a>
<a name="ln498">                        } else {</a>
<a name="ln499">                            return CT_OUT_OF_RAM;</a>
<a name="ln500">                        }</a>
<a name="ln501">                    }</a>
<a name="ln502">                }</a>
<a name="ln503">                nRet |= nSet? 1:0;</a>
<a name="ln504">            } else {</a>
<a name="ln505">                return CT_OUT_OF_RAM;</a>
<a name="ln506">            }</a>
<a name="ln507">            inp_data-&gt;nNumEquSets = nSet;</a>
<a name="ln508">            /* output order */</a>
<a name="ln509">            prep_inp_data[iINChI].nSortedOrder[0] = 0;</a>
<a name="ln510">            for ( i1 = 0; i1 &lt; num_components[iINChI]; i1 ++ ) {</a>
<a name="ln511">                prep_inp_data[iINChI].nSortedOrder[i1+1] = pINChISort[TAUT_YES][i1].ord_number+1;</a>
<a name="ln512">            }</a>
<a name="ln513">#ifdef TARGET_LIB_FOR_WINCHI /* { */</a>
<a name="ln514">            if ( DRAWDATA &amp;&amp; GET_DRAWDATA &amp;&amp; inp_data-&gt;nNumEquSets &gt; 0 &amp;&amp; inp_data-&gt;nEquLabels ) {</a>
<a name="ln515">                int    nType = inp_data-&gt;bPreprocessed[iINChI]?</a>
<a name="ln516">                                        COMPONENT_ORIGINAL_PREPROCESSED :</a>
<a name="ln517">                                        COMPONENT_ORIGINAL;</a>
<a name="ln518">                struct DrawData *pDrawData = GET_DRAWDATA( 0, nType, iINChI);</a>
<a name="ln519">                if ( pDrawData &amp;&amp; pDrawData-&gt;pWindowData &amp;&amp; !pDrawData-&gt;pWindowData-&gt;nEquLabels ) {</a>
<a name="ln520">                    /* copy equivalence data from inp_data to pDrawData-&gt;pWindowData */</a>
<a name="ln521">                    if ( inp_data-&gt;nEquLabels &amp;&amp;</a>
<a name="ln522">                         (pDrawData-&gt;pWindowData-&gt;nEquLabels = (AT_NUMB *)inchi_calloc(inp_data-&gt;num_inp_atoms,</a>
<a name="ln523">                                                                          sizeof(inp_data-&gt;nEquLabels[0])))) {</a>
<a name="ln524">                        memcpy( pDrawData-&gt;pWindowData-&gt;nEquLabels, inp_data-&gt;nEquLabels,</a>
<a name="ln525">                                 inp_data-&gt;num_inp_atoms * sizeof(inp_data-&gt;nEquLabels[0]));</a>
<a name="ln526">                        pDrawData-&gt;pWindowData-&gt;nNumEquSets  = inp_data-&gt;nNumEquSets;</a>
<a name="ln527">                        pDrawData-&gt;pWindowData-&gt;nCurEquLabel = 0;</a>
<a name="ln528">                    }</a>
<a name="ln529">                }</a>
<a name="ln530">            }</a>
<a name="ln531">#endif  /* } TARGET_LIB_FOR_WINCHI */</a>
<a name="ln532">        }</a>
<a name="ln533">    }</a>
<a name="ln534">    return nRet;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">/************************************************************************************************/</a>
<a name="ln538">int DisplayTheWholeCompositeStructure( INPUT_PARMS *ip, STRUCT_DATA *sd, long num_inp, int iINChI,</a>
<a name="ln539">                                       PINChI2 *pINChI2, PINChI_Aux2 *pINChI_Aux2,</a>
<a name="ln540">                                       ORIG_ATOM_DATA *orig_inp_data, ORIG_ATOM_DATA *prep_inp_data,</a>
<a name="ln541">                                       COMP_ATOM_DATA composite_norm_data[TAUT_NUM+1] )</a>
<a name="ln542">{</a>
<a name="ln543">    ORIG_ATOM_DATA *inp_data = NULL;</a>
<a name="ln544">    int jj, j, k, err = 0, nNumIntermediateTaut = 0, bDisplayTaut;</a>
<a name="ln545">    char szTitle[256];</a>
<a name="ln546">    int nNumTautComponents, m;</a>
<a name="ln547"> </a>
<a name="ln548">    int bCompareIsotopic   = !(ip-&gt;bCompareComponents &amp; CMP_COMPONENTS_NONISO);</a>
<a name="ln549">    int bCompareTaut       =  (ip-&gt;bCompareComponents &amp; CMP_COMPONENTS_NONTAUT) ? TAUT_NON : TAUT_YES;</a>
<a name="ln550"> </a>
<a name="ln551">    if ( ip-&gt;bCompareComponents &amp; CMP_COMPONENTS ) {</a>
<a name="ln552">        if ( prep_inp_data[iINChI].bSavedInINCHI_LIB[iINChI] &amp;&amp; prep_inp_data[iINChI].bPreprocessed[iINChI] ) {</a>
<a name="ln553">            inp_data       = prep_inp_data+iINChI;</a>
<a name="ln554">        } else</a>
<a name="ln555">        if ( orig_inp_data-&gt;bSavedInINCHI_LIB[iINChI] &amp;&amp; !orig_inp_data-&gt;bPreprocessed[iINChI] ) {</a>
<a name="ln556">            inp_data       = orig_inp_data;</a>
<a name="ln557">        }</a>
<a name="ln558">    }</a>
<a name="ln559">    /**************************************************************************</a>
<a name="ln560">     * display from one up to 4 structure pictures-results for all components *</a>
<a name="ln561">     * Enable buttons:                                                        *</a>
<a name="ln562">     * BN (non-tautomeric non-isotopic): inp_norm_data[0]-&gt;bExists            *</a>
<a name="ln563">     * TN (tautomeric non-isotopic):     inp_norm_data[1]-&gt;bExists            *</a>
<a name="ln564">     * BI (non-tautomeric isotopic):     inp_norm_data[0]-&gt;bExists &amp;&amp;         *</a>
<a name="ln565">     *                                   inp_norm_data[0]-&gt;bHasIsotopicLayer  *</a>
<a name="ln566">     * TI (tautomeric isotopic):         inp_norm_data[1]-&gt;bExists &amp;&amp;         *</a>
<a name="ln567">     *                                   inp_norm_data[1]-&gt;bHasIsotopicLayer  *</a>
<a name="ln568">     **************************************************************************/</a>
<a name="ln569">    for ( jj = 0; ip-&gt;bDisplayCompositeResults &amp;&amp; !sd-&gt;bUserQuitComponentDisplay &amp;&amp; jj &lt;= TAUT_INI; jj ++ ) {</a>
<a name="ln570">    /*for ( j = 0; ip-&gt;bDisplayCompositeResults &amp;&amp; !sd-&gt;bUserQuitComponentDisplay &amp;&amp; j &lt;= TAUT_INI; j ++ )*/</a>
<a name="ln571">        j = (jj==0)? TAUT_NON : (jj==1)? TAUT_INI : (jj==2)? TAUT_YES : -1;</a>
<a name="ln572">        if ( j &lt; 0 )</a>
<a name="ln573">            continue;</a>
<a name="ln574">        if ( composite_norm_data[j].bExists &amp;&amp; composite_norm_data[j].num_components &gt; 1 ) {</a>
<a name="ln575">            bDisplayTaut = (!(ip-&gt;nMode &amp; REQ_MODE_BASIC) &amp;&amp; !j)? -1 : j;</a>
<a name="ln576">            nNumTautComponents = 0;</a>
<a name="ln577">            if ( bDisplayTaut ) {</a>
<a name="ln578">                /* find whether the structure is actually tautomeric */</a>
<a name="ln579">                for ( m = 0; m &lt; composite_norm_data[TAUT_YES].num_components; m ++ ) {</a>
<a name="ln580">                    if ( !pINChI2[m][TAUT_YES] )</a>
<a name="ln581">                        continue;</a>
<a name="ln582">                    if ( pINChI2[m][TAUT_YES]-&gt;bDeleted || pINChI2[m][TAUT_YES]-&gt;lenTautomer &gt; 0 )</a>
<a name="ln583">                        nNumTautComponents ++;</a>
<a name="ln584">                }</a>
<a name="ln585">            }</a>
<a name="ln586">            for ( k = 0; k &lt;= composite_norm_data[j].bHasIsotopicLayer &amp;&amp; !sd-&gt;bUserQuitComponentDisplay; k ++ ) {</a>
<a name="ln587">                /*  added number of components, added another format for a single component case - DCh */</a>
<a name="ln588">                int bMobileH = (bDisplayTaut&gt;0 &amp;&amp; nNumTautComponents);</a>
<a name="ln589">                sprintf( szTitle, &quot;%s Structure #%ld%s%s.%s%s%s%s%s&quot;,</a>
<a name="ln590">                              j == TAUT_INI? &quot;Preprocessed&quot;:&quot;Result for&quot;, num_inp,</a>
<a name="ln591">                              bMobileH? &quot;, mobile H&quot;:</a>
<a name="ln592">                              bDisplayTaut==0?&quot;, fixed H&quot;:&quot;&quot;,</a>
<a name="ln593">                              /*j? &quot;, mobile H&quot;:&quot;, fixed H&quot;,*/</a>
<a name="ln594">                              k? &quot;, isotopic&quot;:&quot;&quot;,</a>
<a name="ln595">                              SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), iINChI? &quot; (Reconnected)&quot;:&quot;&quot;);</a>
<a name="ln596">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln597">                /****** Display composite Result structure **************/</a>
<a name="ln598">                nNumIntermediateTaut += (j == TAUT_INI );  /* display TAUT_INI (preprocessed) only once */</a>
<a name="ln599">                if ( j != TAUT_INI || nNumIntermediateTaut == 1 ) {</a>
<a name="ln600">                    err = DisplayCompositeStructure( composite_norm_data, j==TAUT_INI? 1:k /* bIsotopic*/,</a>
<a name="ln601">                                                   j/*tautomeric*/,</a>
<a name="ln602">                                                   j==TAUT_INI? NULL:pINChI2, j==TAUT_INI? NULL:pINChI_Aux2,</a>
<a name="ln603">                                                   ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln604">                }</a>
<a name="ln605">                if ( sd-&gt;bUserQuitComponentDisplay = (err==ESC_KEY) ) {</a>
<a name="ln606">                    break;</a>
<a name="ln607">                }</a>
<a name="ln608"> </a>
<a name="ln609">                if ( inp_data &amp;&amp; inp_data-&gt;nEquLabels &amp;&amp; inp_data-&gt;nNumEquSets &amp;&amp; !sd-&gt;bUserQuitComponentDisplay &amp;&amp;</a>
<a name="ln610">                     ((j == bCompareTaut || bCompareTaut &amp;&amp; j == TAUT_INI) || </a>
<a name="ln611">                      bCompareTaut &amp;&amp; !composite_norm_data[bCompareTaut].bExists) &amp;&amp;</a>
<a name="ln612">                     (k == bCompareIsotopic || </a>
<a name="ln613">                      bCompareIsotopic &amp;&amp; !composite_norm_data[j].bHasIsotopicLayer) ) {</a>
<a name="ln614">                    AT_NUMB         nEquSet;</a>
<a name="ln615">                    int             bDisplaySaved = ip-&gt;bDisplay;</a>
<a name="ln616">                    /****** Display Equ Sets of composite Result structure **************/</a>
<a name="ln617">                    for ( nEquSet = 1; nEquSet &lt;= inp_data-&gt;nNumEquSets; nEquSet ++ ) {</a>
<a name="ln618">                        sprintf( szTitle, &quot;Equ set %d of %d, %s Structure #%ld%s%s.%s%s%s%s%s&quot;,</a>
<a name="ln619">                                      nEquSet, inp_data-&gt;nNumEquSets,</a>
<a name="ln620">                                      j == TAUT_INI? &quot;Preprocessed&quot;:&quot;Result for&quot;,</a>
<a name="ln621">                                      num_inp,</a>
<a name="ln622">                                      (bDisplayTaut&gt;0 &amp;&amp; nNumTautComponents)? &quot;, mobile H&quot;: bDisplayTaut==0?&quot;, fixed H&quot;:&quot;&quot;,</a>
<a name="ln623">                                      /*j? &quot;, mobile H&quot;:&quot;, fixed H&quot;,*/</a>
<a name="ln624">                                      k? &quot;, isotopic&quot;:&quot;&quot;,</a>
<a name="ln625">                                      SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), iINChI? &quot; (Reconnected)&quot;:&quot;&quot;);</a>
<a name="ln626">                        ip-&gt;dp.nEquLabels   = inp_data-&gt;nEquLabels;</a>
<a name="ln627">                        ip-&gt;dp.nCurEquLabel = nEquSet;</a>
<a name="ln628">                        ip-&gt;dp.nNumEquSets  = inp_data-&gt;nNumEquSets;</a>
<a name="ln629">                        ip-&gt;bDisplay = 1; /* force display if it was not requested */</a>
<a name="ln630">                        err = DisplayCompositeStructure( composite_norm_data, k, j,</a>
<a name="ln631">                                               pINChI2, pINChI_Aux2,</a>
<a name="ln632">                                               ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln633">                        ip-&gt;dp.nEquLabels   = NULL;</a>
<a name="ln634">                        ip-&gt;dp.nCurEquLabel = 0;</a>
<a name="ln635">                        ip-&gt;dp.nNumEquSets  = 0;</a>
<a name="ln636">                        ip-&gt;bDisplay = bDisplaySaved; /* restore display option */</a>
<a name="ln637"> </a>
<a name="ln638">                        if ( sd-&gt;bUserQuitComponentDisplay = (err==ESC_KEY) ) {</a>
<a name="ln639">                            break;</a>
<a name="ln640">                        }</a>
<a name="ln641">                    }</a>
<a name="ln642">                }</a>
<a name="ln643">#else</a>
<a name="ln644">                if(DRAWDATA &amp;&amp; j &lt;= TAUT_YES)</a>
<a name="ln645">                {</a>
<a name="ln646">                    struct DrawData vDrawData;</a>
<a name="ln647">                    vDrawData.pWindowData = CreateWinDataComposite_( composite_norm_data, k, j,</a>
<a name="ln648">                                                                     pINChI2, pINChI_Aux2,</a>
<a name="ln649">                                                                     ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode);</a>
<a name="ln650">                    /* vDrawData.pWindowData = CreateWinData_( composite_norm_data[j].at, composite_norm_data[j].num_at,</a>
<a name="ln651">                                         k, j, pINChI[i], pINChI_Aux[i],ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode ); */</a>
<a name="ln652">                    if( vDrawData.pWindowData != NULL )</a>
<a name="ln653">                    {</a>
<a name="ln654">                        int nType;</a>
<a name="ln655">                        vDrawData.nComponent = 0;</a>
<a name="ln656">                        if( j == 0 )</a>
<a name="ln657">                            nType = (k == 0) ? COMPONENT_BN: COMPONENT_BI;</a>
<a name="ln658">                        else</a>
<a name="ln659">                            nType = (k == 0) ? COMPONENT_TN: COMPONENT_TI;</a>
<a name="ln660">                        vDrawData.nType        = nType;</a>
<a name="ln661">                           vDrawData.bReconnected = iINChI; /* 0=&gt;main; 1=&gt;reconnected */</a>
<a name="ln662">                        vDrawData.szTitle              = _strdup(szTitle);</a>
<a name="ln663">                        vDrawData.pWindowData-&gt;szTitle = _strdup(szTitle);</a>
<a name="ln664">                        if ( inp_data &amp;&amp; inp_data-&gt;nEquLabels &amp;&amp; inp_data-&gt;nNumEquSets &amp;&amp;</a>
<a name="ln665">                             (j == bCompareTaut     || bCompareTaut     &amp;&amp; !composite_norm_data[bCompareTaut].bExists) &amp;&amp;</a>
<a name="ln666">                             (k == bCompareIsotopic || bCompareIsotopic &amp;&amp; !composite_norm_data[j].bHasIsotopicLayer)  &amp;&amp;</a>
<a name="ln667">                             (vDrawData.pWindowData-&gt;nEquLabels = (AT_NUMB *)inchi_calloc(inp_data-&gt;num_inp_atoms,</a>
<a name="ln668">                                                                                  sizeof(inp_data-&gt;nEquLabels[0])))) {</a>
<a name="ln669">                            memcpy( vDrawData.pWindowData-&gt;nEquLabels, inp_data-&gt;nEquLabels,</a>
<a name="ln670">                                     inp_data-&gt;num_inp_atoms * sizeof(inp_data-&gt;nEquLabels[0]));</a>
<a name="ln671">                            vDrawData.pWindowData-&gt;nNumEquSets  = inp_data-&gt;nNumEquSets;</a>
<a name="ln672">                            vDrawData.pWindowData-&gt;nCurEquLabel = 0;</a>
<a name="ln673">                        }</a>
<a name="ln674">                        DRAWDATA(&amp;vDrawData);</a>
<a name="ln675">                    }</a>
<a name="ln676">                } else</a>
<a name="ln677">                if(DRAWDATA &amp;&amp; GET_DRAWDATA &amp;&amp; j == TAUT_INI)</a>
<a name="ln678">                {</a>
<a name="ln679">                    struct DrawData vDrawData;</a>
<a name="ln680">                    struct DrawData *pDrawData;</a>
<a name="ln681"> </a>
<a name="ln682">                    if ( !(ip-&gt;bCompareComponents &amp; CMP_COMPONENTS) ||</a>
<a name="ln683">                           (ip-&gt;bCompareComponents &amp; CMP_COMPONENTS_NONTAUT) ||</a>
<a name="ln684">                          !k != !composite_norm_data[j].bHasIsotopicLayer ) {</a>
<a name="ln685"> </a>
<a name="ln686">                        continue;</a>
<a name="ln687">                    }</a>
<a name="ln688">                    /*</a>
<a name="ln689">                    vDrawData.pWindowData = CreateWinDataComposite_( composite_norm_data, k, j,</a>
<a name="ln690">                                                                     pINChI2, pINChI_Aux2,</a>
<a name="ln691">                                                                     ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode);</a>
<a name="ln692">                    */</a>
<a name="ln693">                    vDrawData.pWindowData = CreateWinDataComposite_( composite_norm_data, 1 /*k*/, j,</a>
<a name="ln694">                                                                     NULL, NULL,</a>
<a name="ln695">                                                                     ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode);</a>
<a name="ln696">                    if( vDrawData.pWindowData != NULL )</a>
<a name="ln697">                    {</a>
<a name="ln698">                        int nType = COMPONENT_ORIGINAL_PREPROCESSED;</a>
<a name="ln699">                        pDrawData = GET_DRAWDATA( 0, nType, iINChI);</a>
<a name="ln700">                        if ( pDrawData  ) {</a>
<a name="ln701">                            FreeDrawData( pDrawData );</a>
<a name="ln702">                            pDrawData-&gt;pWindowData = vDrawData.pWindowData;</a>
<a name="ln703">                            vDrawData.pWindowData  = NULL;</a>
<a name="ln704">                        } else {</a>
<a name="ln705">                            pDrawData = &amp;vDrawData;</a>
<a name="ln706">                        }</a>
<a name="ln707"> </a>
<a name="ln708">                    /* vDrawData.pWindowData = CreateWinData_( composite_norm_data[j].at, composite_norm_data[j].num_at,</a>
<a name="ln709">                                        k, j, pINChI[i], pINChI_Aux[i],ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode ); */</a>
<a name="ln710">                        pDrawData-&gt;nComponent   = 0;</a>
<a name="ln711">                        pDrawData-&gt;nType        = nType;</a>
<a name="ln712">                           pDrawData-&gt;bReconnected = iINChI; /* 0=&gt;main; 1=&gt;reconnected */</a>
<a name="ln713">                        pDrawData-&gt;szTitle              = _strdup(szTitle);</a>
<a name="ln714">                        pDrawData-&gt;pWindowData-&gt;szTitle = _strdup(szTitle);</a>
<a name="ln715">                        if ( inp_data &amp;&amp; inp_data-&gt;nEquLabels &amp;&amp; inp_data-&gt;nNumEquSets &amp;&amp;</a>
<a name="ln716">                             /*(j == bCompareTaut     || bCompareTaut     &amp;&amp; !composite_norm_data[bCompareTaut].bExists) &amp;&amp;*/</a>
<a name="ln717">                             /*(k == bCompareIsotopic || bCompareIsotopic &amp;&amp; !composite_norm_data[j].bHasIsotopicLayer)  &amp;&amp;*/</a>
<a name="ln718">                             (pDrawData-&gt;pWindowData-&gt;nEquLabels = (AT_NUMB *)inchi_calloc(inp_data-&gt;num_inp_atoms,</a>
<a name="ln719">                                                                                  sizeof(inp_data-&gt;nEquLabels[0])))) {</a>
<a name="ln720">                            memcpy( pDrawData-&gt;pWindowData-&gt;nEquLabels, inp_data-&gt;nEquLabels,</a>
<a name="ln721">                                     inp_data-&gt;num_inp_atoms * sizeof(inp_data-&gt;nEquLabels[0]));</a>
<a name="ln722">                            pDrawData-&gt;pWindowData-&gt;nNumEquSets  = inp_data-&gt;nNumEquSets;</a>
<a name="ln723">                            pDrawData-&gt;pWindowData-&gt;nCurEquLabel = 0;</a>
<a name="ln724">                        }</a>
<a name="ln725">                        if ( pDrawData == &amp;vDrawData ) {</a>
<a name="ln726">                            DRAWDATA(pDrawData);  /* there was no prepocessed structure */</a>
<a name="ln727">                        }</a>
<a name="ln728">                    }</a>
<a name="ln729">                }</a>
<a name="ln730">#endif</a>
<a name="ln731">            }</a>
<a name="ln732">        }</a>
<a name="ln733">    }</a>
<a name="ln734">    return err;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">#endif /*  }COMPILE_ANSI_ONLY */</a>
<a name="ln738"> </a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">/***********************************************************************************/</a>
<a name="ln742">/* pINChI[INCHI_BAS] refers to either disconnected or original structure;            */</a>
<a name="ln743">/*                  num_components[INCHI_BAS] &gt; 0 if there was input structure      */</a>
<a name="ln744">/***********************************************************************************/</a>
<a name="ln745">/* pINChI[INCHI_REC] refers to the reconnected structure,                            */</a>
<a name="ln746">/*                  and only if the input structure has been disconnected, that is,*/</a>
<a name="ln747">/*                  num_components[INCHI_REC] &gt; 0                                   */</a>
<a name="ln748">/***********************************************************************************/</a>
<a name="ln749">int SortAndPrintINChI(INCHI_IOSTREAM *output_file, </a>
<a name="ln750">                      char *pStr, int nStrLen, </a>
<a name="ln751">                      INCHI_IOSTREAM *log_file,</a>
<a name="ln752">                      INPUT_PARMS *ip, </a>
<a name="ln753">                      ORIG_ATOM_DATA *orig_inp_data, ORIG_ATOM_DATA *prep_inp_data,</a>
<a name="ln754">                      COMP_ATOM_DATA composite_norm_data[INCHI_NUM][TAUT_NUM+1],</a>
<a name="ln755">                      ORIG_STRUCT *pOrigStruct, int num_components[INCHI_NUM],</a>
<a name="ln756">                      int num_non_taut[INCHI_NUM], int num_taut[INCHI_NUM],</a>
<a name="ln757">                      INCHI_MODE bTautFlags[INCHI_NUM], INCHI_MODE bTautFlagsDone[INCHI_NUM],</a>
<a name="ln758">                      NORM_CANON_FLAGS *pncFlags, long num_inp,</a>
<a name="ln759">                      PINChI2 *pINChI[INCHI_NUM], </a>
<a name="ln760">                      PINChI_Aux2 *pINChI_Aux[INCHI_NUM], </a>
<a name="ln761">                      int *pSortPrintINChIFlags, unsigned char save_opt_bits)</a>
<a name="ln762">{</a>
<a name="ln763">    INCHI_SORT *pINChISort[INCHI_NUM][TAUT_NUM];</a>
<a name="ln764">    int       j, i, k, k1, ret, iINChI, max_num_components;</a>
<a name="ln765">    INCHI_MODE nMode;</a>
<a name="ln766">    int       bDisconnectedCoord = (0 != (bTautFlagsDone[0] &amp; TG_FLAG_DISCONNECT_COORD_DONE));</a>
<a name="ln767">    int bINChIOutputOptions0, bCurOption, bINChIOutputOptionsCur, bEmbedReconnected, bAnnInXmlBrackets;</a>
<a name="ln768">    static const char szAnnHdr[] = &quot;InChI ANNOTATED CONTENTS&quot;;</a>
<a name="ln769">    int ikflag = 0;</a>
<a name="ln770"> </a>
<a name="ln771">    ret = 1;</a>
<a name="ln772">    for ( i = 0; i &lt; INCHI_NUM; i ++ ) {</a>
<a name="ln773">        for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln774">            bTautFlags[i]     |= pncFlags-&gt;bTautFlags[i][k];</a>
<a name="ln775">            bTautFlagsDone[i] |= pncFlags-&gt;bTautFlagsDone[i][k];</a>
<a name="ln776">        }</a>
<a name="ln777">    }</a>
<a name="ln778">    nMode = ip-&gt;nMode;</a>
<a name="ln779">    if ( !(nMode &amp; (REQ_MODE_BASIC|REQ_MODE_TAUT)) ) {</a>
<a name="ln780">        nMode |= (REQ_MODE_BASIC|REQ_MODE_TAUT);</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">    max_num_components = 0;</a>
<a name="ln784">    for ( j = 0; j &lt; INCHI_NUM; j ++ ) {</a>
<a name="ln785">        if ( max_num_components &lt; num_components[j] )</a>
<a name="ln786">            max_num_components = num_components[j];</a>
<a name="ln787">    }</a>
<a name="ln788">    if ( max_num_components &lt;= 0 )</a>
<a name="ln789">        max_num_components = 1;</a>
<a name="ln790"> </a>
<a name="ln791">    for ( j = 0, i = 0; j &lt; INCHI_NUM; j ++ ) {</a>
<a name="ln792">        if ( num_components[j] ) {</a>
<a name="ln793">            for ( k1 = 0; k1 &lt; TAUT_NUM; k1 ++ ) {</a>
<a name="ln794">                pINChISort[j][k1] = (INCHI_SORT *)inchi_calloc(max_num_components, sizeof(pINChISort[0][0][0]) );</a>
<a name="ln795">                i += !pINChISort[j][k1]; /* number of failed allocatons */</a>
<a name="ln796">            }</a>
<a name="ln797">        } else {</a>
<a name="ln798">            for ( k1 = 0; k1 &lt; TAUT_NUM; k1 ++ ) {</a>
<a name="ln799">                pINChISort[j][k1] = NULL; /* keep BC happy */</a>
<a name="ln800">            }</a>
<a name="ln801">        }</a>
<a name="ln802">    }</a>
<a name="ln803">    if ( i ) {</a>
<a name="ln804">        ret = CT_OUT_OF_RAM;</a>
<a name="ln805">        goto exit_function;</a>
<a name="ln806">    }</a>
<a name="ln807"> </a>
<a name="ln808"> </a>
<a name="ln809">    for ( j = 0; j &lt; INCHI_NUM; j ++ ) {</a>
<a name="ln810"> </a>
<a name="ln811">        if ( !num_components[j] ) {</a>
<a name="ln812">            continue;</a>
<a name="ln813">        }</a>
<a name="ln814"> </a>
<a name="ln815">        iINChI = j;</a>
<a name="ln816"> </a>
<a name="ln817">#if ( OUTPUT_CONNECTED_METAL_ONLY == 1 ) /* test: output connected as the only one INChI */</a>
<a name="ln818">        if ( INCHI_BAS == j &amp;&amp; num_components[INCHI_REC] ) {</a>
<a name="ln819">            j = INCHI_REC;</a>
<a name="ln820">        }</a>
<a name="ln821">#endif</a>
<a name="ln822"> </a>
<a name="ln823">        /*j = INCHI_BAS; &lt;- for debug only */</a>
<a name="ln824">        /* for only normal or disconnected coord compounds */</a>
<a name="ln825">        /* (j=0=INCHI_BAS =&gt; normal or disconnected, j=1=INCHI_REC =&gt; reconnected */</a>
<a name="ln826">        for ( k1 = 0; k1 &lt; TAUT_NUM; k1 ++ ) {</a>
<a name="ln827">            for ( i = 0; i &lt; num_components[j]; i ++ ) {</a>
<a name="ln828">                for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln829">                    pINChISort[j][k1][i].pINChI[k]     = pINChI[j][i][k];</a>
<a name="ln830">                    pINChISort[j][k1][i].pINChI_Aux[k] = pINChI_Aux[j][i][k];</a>
<a name="ln831">                }</a>
<a name="ln832">                pINChISort[j][k1][i].ord_number = i;</a>
<a name="ln833">            }</a>
<a name="ln834">        }</a>
<a name="ln835">        /* sort component INChIs */</a>
<a name="ln836">        for ( k1 = 0; k1 &lt; TAUT_NUM; k1 ++ ) {</a>
<a name="ln837">            switch ( k1 ) {</a>
<a name="ln838">            case TAUT_NON:</a>
<a name="ln839">                qsort( pINChISort[j][k1], num_components[j], sizeof(pINChISort[0][0][0]), CompINChINonTaut2 );</a>
<a name="ln840">                break;</a>
<a name="ln841">            case TAUT_YES:</a>
<a name="ln842">                qsort( pINChISort[j][k1], num_components[j], sizeof(pINChISort[0][0][0]), CompINChITaut2 );</a>
<a name="ln843">                break;</a>
<a name="ln844">            }</a>
<a name="ln845">        }</a>
<a name="ln846">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln847">/* find equivalent and wINChI display order; use requested in ip-&gt;bCompareComponents comparison */</a>
<a name="ln848">        ret = SaveEquComponentsInfoAndSortOrder ( iINChI, pINChISort[j], num_components, orig_inp_data, prep_inp_data,</a>
<a name="ln849">#if ( FIX_DALKE_BUGS == 1 )</a>
<a name="ln850">                                                  composite_norm_data? composite_norm_data[j]:NULL,</a>
<a name="ln851">#else</a>
<a name="ln852">                                                  composite_norm_data[j],</a>
<a name="ln853">#endif</a>
<a name="ln854">                                                  ip-&gt;bCompareComponents );</a>
<a name="ln855">        if ( RETURNED_ERROR( ret ) ) {</a>
<a name="ln856">            ret = 0;</a>
<a name="ln857">            goto exit_function;</a>
<a name="ln858">        } else {</a>
<a name="ln859">            ret = 1;</a>
<a name="ln860">        }</a>
<a name="ln861">#endif</a>
<a name="ln862">    }</a>
<a name="ln863">    </a>
<a name="ln864">    if ( !( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_PRINT_OPTIONS ) ) {</a>
<a name="ln865">        /* prepare InChI from the structures obtained by reversing InChI for returning to the caller */</a>
<a name="ln866">        for ( j = 0; j &lt; INCHI_NUM; j ++ ) {</a>
<a name="ln867">            if ( !num_components[j] ) {</a>
<a name="ln868">                continue;</a>
<a name="ln869">            }</a>
<a name="ln870">            /* pINChI[iINCHI][iComponent][bTaut] */</a>
<a name="ln871">            /* j  = disconnected/connected */</a>
<a name="ln872">            /* k1 = sort order for Mobile or Fixed H */</a>
<a name="ln873">            k1 = TAUT_YES; /* in Mobile H order */</a>
<a name="ln874">            /* store components in Mobile H order */</a>
<a name="ln875">            </a>
<a name="ln876">            for ( i = 0; i &lt; num_components[j]; i ++ ) {</a>
<a name="ln877"> </a>
<a name="ln878">                if ( pINChISort[j][k1][i].pINChI[TAUT_NON] &amp;&amp;</a>
<a name="ln879">                    !pINChISort[j][k1][i].pINChI[TAUT_YES] ) {</a>
<a name="ln880">                    /* make sure Mobile-H is always present */</a>
<a name="ln881">                    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln882">                        pINChI[j][i][k]     = pINChISort[j][k1][i].pINChI[ALT_TAUT(k)];</a>
<a name="ln883">                        pINChI_Aux[j][i][k] = pINChISort[j][k1][i].pINChI_Aux[ALT_TAUT(k)];</a>
<a name="ln884">                    }</a>
<a name="ln885">                } else {</a>
<a name="ln886"> </a>
<a name="ln887">                    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln888">                        pINChI[j][i][k]     = pINChISort[j][k1][i].pINChI[k];</a>
<a name="ln889">                        pINChI_Aux[j][i][k] = pINChISort[j][k1][i].pINChI_Aux[k];</a>
<a name="ln890">                    }</a>
<a name="ln891">                }</a>
<a name="ln892">            }</a>
<a name="ln893">        }</a>
<a name="ln894"> </a>
<a name="ln895">    } else {</a>
<a name="ln896">        </a>
<a name="ln897">        /* print inchi string(s) */</a>
<a name="ln898"> </a>
<a name="ln899"> </a>
<a name="ln900">        bINChIOutputOptions0 = ip-&gt;bINChIOutputOptions &amp; ~INCHI_OUT_PRINT_OPTIONS;</a>
<a name="ln901"> </a>
<a name="ln902">        bEmbedReconnected    = ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_EMBED_REC;</a>
<a name="ln903"> </a>
<a name="ln904">        for ( i = 0; i &lt; 4; i ++ ) {</a>
<a name="ln905">            switch( i ) {</a>
<a name="ln906">            case 0:</a>
<a name="ln907">                bCurOption = INCHI_OUT_XML;</a>
<a name="ln908">                break;</a>
<a name="ln909">            case 1:</a>
<a name="ln910">                bCurOption = INCHI_OUT_PLAIN_TEXT;</a>
<a name="ln911">                break;</a>
<a name="ln912">            case 2:</a>
<a name="ln913">                bCurOption = INCHI_OUT_PLAIN_TEXT_COMMENTS;</a>
<a name="ln914">                break;</a>
<a name="ln915">            case 3:</a>
<a name="ln916">                bCurOption = INCHI_OUT_XML_TEXT_COMMENTS;</a>
<a name="ln917">                break;</a>
<a name="ln918">            default:</a>
<a name="ln919">                continue;</a>
<a name="ln920">            }</a>
<a name="ln921">            if ( ip-&gt;bINChIOutputOptions &amp; bCurOption ) {</a>
<a name="ln922">                bAnnInXmlBrackets = 0;</a>
<a name="ln923">                if ( i == 1 ) {</a>
<a name="ln924">                    ;/*bEmbedReconnected = 0;*/</a>
<a name="ln925">                }</a>
<a name="ln926">                if ( i == 3 ) {</a>
<a name="ln927">                    bCurOption = INCHI_OUT_XML; /* xml output as annotation */</a>
<a name="ln928">                }</a>
<a name="ln929">                bINChIOutputOptionsCur = bINChIOutputOptions0 | bCurOption;</a>
<a name="ln930">                switch ( i ) {</a>
<a name="ln931">                case 0:</a>
<a name="ln932">                case 1:</a>
<a name="ln933">                    /* output INChI */</a>
<a name="ln934">                    bINChIOutputOptionsCur |= bEmbedReconnected;</a>
<a name="ln935">                    break;</a>
<a name="ln936">                case 2:</a>
<a name="ln937">                case 3:</a>
<a name="ln938">                    /* output annotation */</a>
<a name="ln939">                    bAnnInXmlBrackets = (i == 2 &amp;&amp; (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML ));</a>
<a name="ln940">                    if ( bAnnInXmlBrackets ) {</a>
<a name="ln941">                        inchi_ios_print( output_file, &quot;\n&lt;%s&gt;\n&quot;, szAnnHdr );</a>
<a name="ln942">                    } else {</a>
<a name="ln943">                        inchi_ios_print( output_file, &quot;\n==== %s ====\n&quot;, szAnnHdr );</a>
<a name="ln944">                    }</a>
<a name="ln945">                    bINChIOutputOptionsCur |= bEmbedReconnected;</a>
<a name="ln946">                    bINChIOutputOptionsCur &amp;= ~INCHI_OUT_TABBED_OUTPUT;</a>
<a name="ln947">                    break;</a>
<a name="ln948">                default:</a>
<a name="ln949">                    continue;</a>
<a name="ln950">                }</a>
<a name="ln951"> </a>
<a name="ln952">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln953">                if ( ikflag==0 )</a>
<a name="ln954">                    output_file-&gt;type = INCHI_IOSTREAM_STRING;</a>
<a name="ln955">#endif</a>
<a name="ln956"> </a>
<a name="ln957"> </a>
<a name="ln958">                ret &amp;= OutputINChI2(pStr, nStrLen, </a>
<a name="ln959">                                    pINChISort, INCHI_BAS /*iINChI*/, </a>
<a name="ln960">                                    pOrigStruct,</a>
<a name="ln961">                                    bDisconnectedCoord, OUT_TN, </a>
<a name="ln962">                                    bINChIOutputOptionsCur, </a>
<a name="ln963">                                    0 != (bINChIOutputOptionsCur &amp; INCHI_OUT_XML),</a>
<a name="ln964">                                    ip-&gt;bAbcNumbers, ip-&gt;bCtPredecessors, </a>
<a name="ln965">                                    ip-&gt;bNoStructLabels, </a>
<a name="ln966">                                    num_components, num_non_taut, num_taut,</a>
<a name="ln967">                                    output_file, log_file, num_inp,</a>
<a name="ln968">                                    ip-&gt;pSdfLabel,ip-&gt;pSdfValue, ip-&gt;lSdfId, </a>
<a name="ln969">                                    pSortPrintINChIFlags,</a>
<a name="ln970">                                    save_opt_bits);</a>
<a name="ln971"> </a>
<a name="ln972">                if ( ret &amp;&amp;  !(bINChIOutputOptionsCur &amp; INCHI_OUT_EMBED_REC) ) </a>
<a name="ln973">                {</a>
<a name="ln974">                    ret &amp;= OutputINChI2(pStr, nStrLen, pINChISort, INCHI_REC /*iINChI*/, </a>
<a name="ln975">                                        pOrigStruct,</a>
<a name="ln976">                                        bDisconnectedCoord, OUT_TN, </a>
<a name="ln977">                                        bINChIOutputOptionsCur, </a>
<a name="ln978">                                        0 != (bINChIOutputOptionsCur &amp; INCHI_OUT_XML),</a>
<a name="ln979">                                        ip-&gt;bAbcNumbers, ip-&gt;bCtPredecessors, </a>
<a name="ln980">                                        ip-&gt;bNoStructLabels, </a>
<a name="ln981">                                        num_components, num_non_taut, num_taut,</a>
<a name="ln982">                                        output_file, log_file, num_inp,</a>
<a name="ln983">                                        ip-&gt;pSdfLabel,ip-&gt;pSdfValue, ip-&gt;lSdfId, </a>
<a name="ln984">                                        pSortPrintINChIFlags,</a>
<a name="ln985">                                        save_opt_bits);</a>
<a name="ln986">                }</a>
<a name="ln987"> </a>
<a name="ln988">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln989">                /* always calculate InChIKey */</a>
<a name="ln990">                ikflag++;</a>
<a name="ln991">                if (ikflag==1) </a>
<a name="ln992">                {</a>
<a name="ln993">                    if (ret)</a>
<a name="ln994">                    {                    </a>
<a name="ln995">                        char ik_string[256];    /*^^^ Resulting InChIKey string */</a>
<a name="ln996">                        int ik_ret=0;           /*^^^ InChIKey-calc result code */</a>
<a name="ln997">                        int xhash1, xhash2;</a>
<a name="ln998">                        char szXtra1[256], szXtra2[256];</a>
<a name="ln999">                        size_t slen = output_file-&gt;s.nUsedLength;</a>
<a name="ln1000">                        char *buf = NULL;</a>
<a name="ln1001">                        extract_inchi_substring(&amp;buf, output_file-&gt;s.pStr, slen);            </a>
<a name="ln1002">                        inchi_ios_flush(output_file);</a>
<a name="ln1003">                        output_file-&gt;type = INCHI_IOSTREAM_FILE;</a>
<a name="ln1004">                        /* calculate and print InChIKey */</a>
<a name="ln1005">                        if (NULL!=buf)</a>
<a name="ln1006">                        {</a>
<a name="ln1007">                            xhash1 = xhash2 = 0;</a>
<a name="ln1008">                            if ( ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA1 ) ||</a>
<a name="ln1009">                                 ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA1_XTRA2 ) )</a>
<a name="ln1010">                                 xhash1 = 1;</a>
<a name="ln1011">                            if ( ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA2 ) ||</a>
<a name="ln1012">                                 ( ip-&gt;bCalcInChIHash == INCHIHASH_KEY_XTRA1_XTRA2 ) )</a>
<a name="ln1013">                                 xhash2 = 1;                </a>
<a name="ln1014">                            ik_ret = GetINCHIKeyFromINCHI(buf, xhash1, xhash2, ik_string, szXtra1, szXtra2);</a>
<a name="ln1015">                            inchi_free(buf);</a>
<a name="ln1016">                        }</a>
<a name="ln1017">                        else</a>
<a name="ln1018">                            ik_ret = 3;                     </a>
<a name="ln1019">    </a>
<a name="ln1020">                        if (ik_ret==INCHIKEY_OK)   </a>
<a name="ln1021">                        {</a>
<a name="ln1022">                            /* NB: correctly treat tabbed output with InChIKey &amp; hash extensions */                </a>
<a name="ln1023">                            char csep = '\n';</a>
<a name="ln1024">                                if ( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_TABBED_OUTPUT ) </a>
<a name="ln1025">                            csep = '\t';</a>
<a name="ln1026">                            inchi_ios_print(output_file, &quot;InChIKey=%-s&quot;,ik_string);</a>
<a name="ln1027">                            if ( xhash1 )</a>
<a name="ln1028">                                inchi_ios_print(output_file, &quot;%cXHash1=%-s&quot;,csep,szXtra1);</a>
<a name="ln1029">                            if ( xhash2 )</a>
<a name="ln1030">                                inchi_ios_print(output_file, &quot;%cXHash2=%-s&quot;,csep,szXtra2);</a>
<a name="ln1031">                            inchi_ios_print(output_file, &quot;\n&quot;);</a>
<a name="ln1032">                        }</a>
<a name="ln1033">                        else            </a>
<a name="ln1034">                        {</a>
<a name="ln1035">                            inchi_ios_print(log_file, &quot;Warning (Could not compute InChIKey: &quot;, num_inp);    </a>
<a name="ln1036">                        }</a>
<a name="ln1037">                            </a>
<a name="ln1038">                        /*inchi_ios_flush(output_file);</a>
<a name="ln1039">                        inchi_ios_flush2(log_file, stderr);*/</a>
<a name="ln1040">                    }</a>
<a name="ln1041">                    else</a>
<a name="ln1042">                    {</a>
<a name="ln1043">                        inchi_ios_flush(output_file);</a>
<a name="ln1044">                        output_file-&gt;type = INCHI_IOSTREAM_FILE;</a>
<a name="ln1045">                    }</a>
<a name="ln1046"> </a>
<a name="ln1047">                }</a>
<a name="ln1048"> </a>
<a name="ln1049">#endif</a>
<a name="ln1050"> </a>
<a name="ln1051">                if ( bAnnInXmlBrackets ) {</a>
<a name="ln1052">                    inchi_ios_print( output_file, &quot;&lt;/%s&gt;\n\n&quot;, szAnnHdr );</a>
<a name="ln1053">                }</a>
<a name="ln1054">                if ( !ret ) {</a>
<a name="ln1055">                    break;</a>
<a name="ln1056">                }</a>
<a name="ln1057">            }</a>
<a name="ln1058">        }</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">exit_function:</a>
<a name="ln1062">    for ( j = 0; j &lt; INCHI_NUM; j ++ ) {</a>
<a name="ln1063">        for ( k1 = 0, i = 0; k1 &lt; TAUT_NUM; k1 ++ ) {</a>
<a name="ln1064">            if ( pINChISort[j][k1] ) {</a>
<a name="ln1065">                inchi_free( pINChISort[j][k1] );</a>
<a name="ln1066">            }</a>
<a name="ln1067">        }</a>
<a name="ln1068">    }</a>
<a name="ln1069">    ret = ret? 0 : _IS_FATAL;</a>
<a name="ln1070"> </a>
<a name="ln1071"> </a>
<a name="ln1072"> </a>
<a name="ln1073">    return ret;</a>
<a name="ln1074">}</a>
<a name="ln1075">/**********************************************************************************/</a>
<a name="ln1076">void FreeAllINChIArrays( PINChI2 *pINChI[INCHI_NUM], PINChI_Aux2 *pINChI_Aux[INCHI_NUM], int num_components[INCHI_NUM] )</a>
<a name="ln1077">{</a>
<a name="ln1078">    int k;</a>
<a name="ln1079">    for ( k = 0; k &lt; INCHI_NUM; k ++ ) {</a>
<a name="ln1080">        FreeINChIArrays( pINChI[k], pINChI_Aux[k], num_components[k] );</a>
<a name="ln1081">        num_components[k] = 0;</a>
<a name="ln1082">        if ( pINChI[k] ) {</a>
<a name="ln1083">            inchi_free( pINChI[k] );</a>
<a name="ln1084">            pINChI[k] = NULL;</a>
<a name="ln1085">        }</a>
<a name="ln1086">        if ( pINChI_Aux[k] ) {</a>
<a name="ln1087">            inchi_free( pINChI_Aux[k] );</a>
<a name="ln1088">            pINChI_Aux[k] = NULL;</a>
<a name="ln1089">        }</a>
<a name="ln1090"> </a>
<a name="ln1091">    }</a>
<a name="ln1092">}</a>
<a name="ln1093">/**********************************************************************************/</a>
<a name="ln1094">void FreeINChIArrays( PINChI2 *pINChI, PINChI_Aux2 *pINChI_Aux, int num_components )</a>
<a name="ln1095">{</a>
<a name="ln1096">    int i, k;</a>
<a name="ln1097">    /* release allocated memory */</a>
<a name="ln1098">    if ( pINChI ) {</a>
<a name="ln1099">        for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln1100">            for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln1101">                Free_INChI( &amp;pINChI[i][k] );</a>
<a name="ln1102">                /*</a>
<a name="ln1103">                inchi_free( pINChI[i][k] );</a>
<a name="ln1104">                pINChI[i][k] = NULL;</a>
<a name="ln1105">                */</a>
<a name="ln1106">            }</a>
<a name="ln1107">        }</a>
<a name="ln1108">    }</a>
<a name="ln1109">    if ( pINChI_Aux ) {</a>
<a name="ln1110">        for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln1111">            for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln1112">                Free_INChI_Aux( &amp;pINChI_Aux[i][k] );</a>
<a name="ln1113">                /*</a>
<a name="ln1114">                inchi_free( pINChI_Aux[i][k] );</a>
<a name="ln1115">                pINChI_Aux[i][k] = NULL;</a>
<a name="ln1116">                */</a>
<a name="ln1117">            }</a>
<a name="ln1118">        }</a>
<a name="ln1119">    }</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122"> </a>
<a name="ln1123">/**********************************************</a>
<a name="ln1124"> * output &quot; L=V&quot; or &quot; L missing&quot; or &quot;&quot;</a>
<a name="ln1125"> * The fprintf format string must contain %s%s%s%s</a>
<a name="ln1126"> */</a>
<a name="ln1127"> </a>
<a name="ln1128">const char gsMissing[] = &quot;is missing&quot;;</a>
<a name="ln1129">const char gsEmpty[]   = &quot;&quot;;</a>
<a name="ln1130">const char gsSpace[]   = &quot; &quot;;</a>
<a name="ln1131">const char gsEqual[]   = &quot;=&quot;;</a>
<a name="ln1132"> </a>
<a name="ln1133">#ifndef TARGET_API_LIB</a>
<a name="ln1134">/*********************************************************************************************************/</a>
<a name="ln1135">void SplitTime( unsigned long ulTotalTime, int *hours, int *minutes, int *seconds, int *mseconds )</a>
<a name="ln1136">{</a>
<a name="ln1137">        *mseconds = (int)(ulTotalTime % 1000);</a>
<a name="ln1138">        ulTotalTime /= 1000;</a>
<a name="ln1139">        *seconds = (int)(ulTotalTime % 60);</a>
<a name="ln1140">        ulTotalTime /= 60;</a>
<a name="ln1141">        *minutes = (int)(ulTotalTime % 60);</a>
<a name="ln1142">        ulTotalTime /= 60;</a>
<a name="ln1143">        *hours = (int)(ulTotalTime);</a>
<a name="ln1144">}</a>
<a name="ln1145">/*********************************************************************************************************/</a>
<a name="ln1146">int ReadTheStructure( STRUCT_DATA *sd, INPUT_PARMS *ip, INCHI_IOSTREAM  *inp_file, ORIG_ATOM_DATA *orig_inp_data,</a>
<a name="ln1147">                      /* for CML:*/ int inp_index, int *out_index )</a>
<a name="ln1148">{</a>
<a name="ln1149">    inchiTime     ulTStart;</a>
<a name="ln1150">    int           nRet = 0, nRet2 = 0;</a>
<a name="ln1151">    int           bGetOrigCoord = !(ip-&gt;bINChIOutputOptions &amp; (INCHI_OUT_NO_AUX_INFO | INCHI_OUT_SHORT_AUX_INFO));</a>
<a name="ln1152">    INCHI_MODE InpAtomFlags = 0;  /* reading Molfile may set FLAG_INP_AT_CHIRAL bit */</a>
<a name="ln1153"> </a>
<a name="ln1154">    /* vABParityUnknown holds actual value of an internal constant signifying       */</a>
<a name="ln1155">    /* unknown parity: either the same as for undefined parity (default==standard)  */</a>
<a name="ln1156">    /*  or a specific one (non-std; requested by SLUUD switch).                     */</a>
<a name="ln1157">    int vABParityUnknown = AB_PARITY_UNDF;</a>
<a name="ln1158">    if ( 0 != ( ip-&gt;nMode &amp; REQ_MODE_DIFF_UU_STEREO) ) </a>
<a name="ln1159">    {</a>
<a name="ln1160">        /* Make labels for unknown and undefined stereo different */</a>
<a name="ln1161">        vABParityUnknown = AB_PARITY_UNKN;</a>
<a name="ln1162">    }</a>
<a name="ln1163"> </a>
<a name="ln1164">    memset( sd, 0, sizeof(*sd) );</a>
<a name="ln1165">    switch ( ip-&gt;nInputType ) {</a>
<a name="ln1166">    case INPUT_MOLFILE:</a>
<a name="ln1167">    case INPUT_SDFILE:</a>
<a name="ln1168">        if ( orig_inp_data ) {</a>
<a name="ln1169">            if ( ip-&gt;pSdfValue &amp;&amp; ip-&gt;pSdfValue[0] ) {</a>
<a name="ln1170">                /* Added 07-29-2003 to avoid inheriting exact value from prev. structure</a>
<a name="ln1171">                   and to make reference to a (bad) structure with unknown ID Value */</a>
<a name="ln1172">                char *p, *q;  /* q shadows prev declaration of const char *q */</a>
<a name="ln1173">                int  n;</a>
<a name="ln1174">                if ( (p = strrchr( ip-&gt;pSdfValue, '+' )) &amp;&amp;</a>
<a name="ln1175">                     '[' == *(p-1) &amp;&amp; 0 &lt; (n=strtol(p+1,&amp;q,10)) &amp;&amp; q[0] &amp;&amp; ']'==q[0] &amp;&amp; !q[1] ) {</a>
<a name="ln1176">                    sprintf( p+1, &quot;%d]&quot;, n+1 );</a>
<a name="ln1177">                } else {</a>
<a name="ln1178">                    strcat( ip-&gt;pSdfValue, &quot; [+1]&quot; );</a>
<a name="ln1179">                }</a>
<a name="ln1180">            }</a>
<a name="ln1181">            InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1182">            sd-&gt;fPtrStart = (inp_file-&gt;f == stdin)? -1 : ftell( inp_file-&gt;f );</a>
<a name="ln1183">            /*  read the original structure */</a>
<a name="ln1184">            nRet2 = MolfileToOrigAtom( inp_file-&gt;f, orig_inp_data, ip-&gt;bMergeAllInputStructures, bGetOrigCoord, ip-&gt;bDoNotAddH,</a>
<a name="ln1185">                               ip-&gt;pSdfLabel, ip-&gt;pSdfValue, &amp;ip-&gt;lSdfId, &amp;ip-&gt;lMolfileNumber,</a>
<a name="ln1186">                               &amp;InpAtomFlags, &amp;sd-&gt;nStructReadError, sd-&gt;pStrErrStruct );</a>
<a name="ln1187"> </a>
<a name="ln1188"> </a>
<a name="ln1189">            if ( !ip-&gt;bGetSdfileId || ip-&gt;lSdfId == 999999) ip-&gt;lSdfId = 0;</a>
<a name="ln1190">            if ( !ip-&gt;bGetMolfileNumber || ip-&gt;lMolfileNumber &lt; 0 ) ip-&gt;lMolfileNumber = 0;</a>
<a name="ln1191">            sd-&gt;fPtrEnd = (inp_file-&gt;f == stdin)? -1 : ftell( inp_file-&gt;f );</a>
<a name="ln1192">            sd-&gt;ulStructTime += InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1193">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1194">            sd-&gt;bExtract |= orig_inp_data-&gt;bExtract;</a>
<a name="ln1195">#endif</a>
<a name="ln1196">            /* 2004-11-16: added Molfile Chiral Flag Mode */</a>
<a name="ln1197">            /* *****************************************************************************</a>
<a name="ln1198">             * Chiral flags are set in: </a>
<a name="ln1199">             * - RunICHI.c #1610 -- ReadTheStructure()     -- cInChI, wInChI (here)</a>
<a name="ln1200">             * - e_IchiMain.c #273 -- main()               -- C example of calling InChI dll</a>
<a name="ln1201">             * - inchi_dll.c  #1662 -- ExtractOneStructure -- InChI dll code </a>
<a name="ln1202">             *******************************************************************************/   </a>
<a name="ln1203">            /* 1. Highest precedence: Chiral Flag set by the user */</a>
<a name="ln1204">            if ( ip-&gt;bChiralFlag &amp; FLAG_SET_INP_AT_CHIRAL ) {</a>
<a name="ln1205">                InpAtomFlags = FLAG_INP_AT_CHIRAL; /* forced by the user */</a>
<a name="ln1206">            } else</a>
<a name="ln1207">            if ( ip-&gt;bChiralFlag &amp; FLAG_SET_INP_AT_NONCHIRAL ) {</a>
<a name="ln1208">                InpAtomFlags = FLAG_INP_AT_NONCHIRAL; /* forced by the user */</a>
<a name="ln1209">            } else</a>
<a name="ln1210">            if ( (InpAtomFlags &amp; FLAG_INP_AT_CHIRAL) &amp;&amp; (InpAtomFlags &amp;&amp; FLAG_INP_AT_NONCHIRAL) ) {</a>
<a name="ln1211">                InpAtomFlags &amp;= ~FLAG_INP_AT_NONCHIRAL;</a>
<a name="ln1212">            }</a>
<a name="ln1213">            /* save requested flags in the AuxInfo */</a>
<a name="ln1214">            sd-&gt;bChiralFlag &amp;= ~( FLAG_INP_AT_CHIRAL | FLAG_INP_AT_NONCHIRAL );</a>
<a name="ln1215">            sd-&gt;bChiralFlag |= InpAtomFlags &amp; ( FLAG_INP_AT_CHIRAL | FLAG_INP_AT_NONCHIRAL );</a>
<a name="ln1216">            /* quick fix: modify ip-&gt;nMode on the fly */</a>
<a name="ln1217">            /* 2. The user requested both Stereo AND Chiral flag */</a>
<a name="ln1218">            if ( (ip-&gt;nMode &amp; REQ_MODE_CHIR_FLG_STEREO) &amp;&amp; (ip-&gt;nMode &amp; REQ_MODE_STEREO) ) {</a>
<a name="ln1219">                if ( InpAtomFlags &amp; FLAG_INP_AT_CHIRAL ) {</a>
<a name="ln1220">                    /* structure has chiral flag or the user said it is chiral */</a>
<a name="ln1221">                    ip-&gt;nMode &amp;= ~(REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO);</a>
<a name="ln1222">                    sd-&gt;bChiralFlag |= FLAG_INP_AT_CHIRAL; /* write AuxInfo as chiral */</a>
<a name="ln1223">                } else {</a>
<a name="ln1224">                    ip-&gt;nMode &amp;= ~REQ_MODE_RACEMIC_STEREO;</a>
<a name="ln1225">                    ip-&gt;nMode |=  REQ_MODE_RELATIVE_STEREO;</a>
<a name="ln1226">                    sd-&gt;bChiralFlag |= FLAG_INP_AT_NONCHIRAL; /* write AuxInfo as explicitly not chiral */</a>
<a name="ln1227">                }</a>
<a name="ln1228">            }</a>
<a name="ln1229">        } else {</a>
<a name="ln1230">            /*  read the next original structure */</a>
<a name="ln1231">            int           nStructReadError=0;</a>
<a name="ln1232">            if ( !ip-&gt;bMergeAllInputStructures ) {</a>
<a name="ln1233">                nRet2 = MolfileToOrigAtom( inp_file-&gt;f, NULL, 0, 0, 0,</a>
<a name="ln1234">                                       NULL, NULL, NULL, NULL,</a>
<a name="ln1235">                                       NULL, &amp;nStructReadError, NULL );</a>
<a name="ln1236">                if ( nRet2 &lt;= 0 &amp;&amp; 10 &lt; nStructReadError &amp;&amp; nStructReadError &lt; 20 ) {</a>
<a name="ln1237">                    return _IS_EOF;</a>
<a name="ln1238">                }</a>
<a name="ln1239">            } else {</a>
<a name="ln1240">                return _IS_EOF;</a>
<a name="ln1241">            }</a>
<a name="ln1242">        }</a>
<a name="ln1243">        break;</a>
<a name="ln1244">    case INPUT_INCHI_XML:</a>
<a name="ln1245">    case INPUT_INCHI_PLAIN:</a>
<a name="ln1246">        if ( orig_inp_data ) {</a>
<a name="ln1247">            if ( ip-&gt;pSdfValue &amp;&amp; ip-&gt;pSdfValue[0] ) {</a>
<a name="ln1248">                /* Added 07-29-2003 to avoid inheriting exact value from prev. structure</a>
<a name="ln1249">                   and to make reference to a (bad) structure with unknown ID Value */</a>
<a name="ln1250">                char *p, *q;</a>
<a name="ln1251">                int  n;</a>
<a name="ln1252">                if ( (p = strrchr( ip-&gt;pSdfValue, '+' )) &amp;&amp;</a>
<a name="ln1253">                     '[' == *(p-1) &amp;&amp; 0 &lt; (n=strtol(p+1,&amp;q,10)) &amp;&amp; q[0] &amp;&amp; ']'==q[0] &amp;&amp; !q[1] ) {</a>
<a name="ln1254">                    sprintf( p+1, &quot;%d]&quot;, n+1 );</a>
<a name="ln1255">                } else {</a>
<a name="ln1256">                    strcat( ip-&gt;pSdfValue, &quot; [+1]&quot; );</a>
<a name="ln1257">                }</a>
<a name="ln1258">            }</a>
<a name="ln1259">            InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1260">            sd-&gt;fPtrStart = (inp_file-&gt;f == stdin)? -1 : ftell( inp_file-&gt;f );</a>
<a name="ln1261">            /*  read the original structure */</a>
<a name="ln1262">            nRet2 = INChIToOrigAtom( inp_file, orig_inp_data, ip-&gt;bMergeAllInputStructures,</a>
<a name="ln1263">                               bGetOrigCoord, ip-&gt;bDoNotAddH, vABParityUnknown,</a>
<a name="ln1264">                               ip-&gt;nInputType, ip-&gt;pSdfLabel, ip-&gt;pSdfValue, &amp;ip-&gt;lMolfileNumber,</a>
<a name="ln1265">                               &amp;InpAtomFlags, &amp;sd-&gt;nStructReadError, sd-&gt;pStrErrStruct );</a>
<a name="ln1266">            /*if ( !ip-&gt;bGetSdfileId || ip-&gt;lSdfId == 999999) ip-&gt;lSdfId = 0;*/</a>
<a name="ln1267">            sd-&gt;fPtrEnd = (inp_file-&gt;f == stdin)? -1 : ftell( inp_file-&gt;f );</a>
<a name="ln1268"> </a>
<a name="ln1269">            sd-&gt;ulStructTime += InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1270">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1271">            sd-&gt;bExtract |= orig_inp_data-&gt;bExtract;</a>
<a name="ln1272">#endif</a>
<a name="ln1273">            /* 2004-11-16: added Molfile Chiral Flag Mode */</a>
<a name="ln1274">            if ( ip-&gt;bChiralFlag &amp; FLAG_SET_INP_AT_CHIRAL ) {</a>
<a name="ln1275">                InpAtomFlags = FLAG_INP_AT_CHIRAL; /* forced by the user */</a>
<a name="ln1276">            } else</a>
<a name="ln1277">            if ( ip-&gt;bChiralFlag &amp; FLAG_SET_INP_AT_NONCHIRAL ) {</a>
<a name="ln1278">                InpAtomFlags = FLAG_INP_AT_NONCHIRAL; /* forced by the user */</a>
<a name="ln1279">            } else</a>
<a name="ln1280">            if ( (InpAtomFlags &amp; FLAG_INP_AT_CHIRAL) &amp;&amp; (InpAtomFlags &amp;&amp; FLAG_INP_AT_NONCHIRAL) ) {</a>
<a name="ln1281">                InpAtomFlags &amp;= ~FLAG_INP_AT_NONCHIRAL;</a>
<a name="ln1282">            }</a>
<a name="ln1283">            sd-&gt;bChiralFlag |= InpAtomFlags; /* copy chiral flag to AuxInfo */</a>
<a name="ln1284">            /* quick fix: modify ip-&gt;nMode on the fly */</a>
<a name="ln1285">            if ( (ip-&gt;nMode &amp; REQ_MODE_CHIR_FLG_STEREO) &amp;&amp; (ip-&gt;nMode &amp; REQ_MODE_STEREO) ) {</a>
<a name="ln1286">                if ( InpAtomFlags &amp; FLAG_INP_AT_CHIRAL ) {</a>
<a name="ln1287">                    ip-&gt;nMode &amp;= ~(REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO);</a>
<a name="ln1288">                } else {</a>
<a name="ln1289">                    ip-&gt;nMode &amp;= ~REQ_MODE_RACEMIC_STEREO;</a>
<a name="ln1290">                    ip-&gt;nMode |=  REQ_MODE_RELATIVE_STEREO;</a>
<a name="ln1291">                }</a>
<a name="ln1292">            }</a>
<a name="ln1293">        } else {</a>
<a name="ln1294">            /*  read the next original structure */</a>
<a name="ln1295">            int           nStructReadError=0;</a>
<a name="ln1296">            if ( !ip-&gt;bMergeAllInputStructures ) {</a>
<a name="ln1297">                nRet2 = INChIToOrigAtom( inp_file, NULL, 0, 0, 0, 0, </a>
<a name="ln1298">                                    ip-&gt;nInputType, NULL, NULL, NULL, NULL, &amp;nStructReadError, NULL );</a>
<a name="ln1299">                if ( nRet2 &lt;= 0 &amp;&amp; 10 &lt; nStructReadError &amp;&amp; nStructReadError &lt; 20 ) {</a>
<a name="ln1300">                    return _IS_EOF;</a>
<a name="ln1301">                }</a>
<a name="ln1302">            } else {</a>
<a name="ln1303">                return _IS_EOF;</a>
<a name="ln1304">            }</a>
<a name="ln1305">        }</a>
<a name="ln1306">        break;</a>
<a name="ln1307"> </a>
<a name="ln1308">#if ( ADD_CMLPP == 1 )</a>
<a name="ln1309">    /* BILLY 8/6/04 */</a>
<a name="ln1310">    case INPUT_CMLFILE:</a>
<a name="ln1311">        if ( orig_inp_data ) {</a>
<a name="ln1312"> </a>
<a name="ln1313">            InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1314">            /*</a>
<a name="ln1315">            if ( inp_index &gt;= 0 ) {</a>
<a name="ln1316">                sd-&gt;fPtrStart = inp_index;</a>
<a name="ln1317">            } else {</a>
<a name="ln1318">                sd-&gt;fPtrStart = GetCmlStructIndex();</a>
<a name="ln1319">            }</a>
<a name="ln1320">            */</a>
<a name="ln1321">            sd-&gt;fPtrStart = -1; /* disable &quot;CopyMOLfile() for CML input files */</a>
<a name="ln1322">            sd-&gt;fPtrEnd = -1;</a>
<a name="ln1323">            /*  read the original structure */</a>
<a name="ln1324">            nRet = CmlfileToOrigAtom( inp_file-&gt;f, orig_inp_data, ip-&gt;bMergeAllInputStructures,</a>
<a name="ln1325">                               bGetOrigCoord, ip-&gt;bDoNotAddH, inp_index, out_index,</a>
<a name="ln1326">                               ip-&gt;pSdfLabel, ip-&gt;pSdfValue, &amp;ip-&gt;lSdfId,</a>
<a name="ln1327">                               &amp;sd-&gt;nStructReadError, sd-&gt;pStrErrStruct );</a>
<a name="ln1328"> </a>
<a name="ln1329"> </a>
<a name="ln1330">            sd-&gt;ulStructTime += InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1331">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1332">            sd-&gt;bExtract |= orig_inp_data-&gt;bExtract;</a>
<a name="ln1333">#endif</a>
<a name="ln1334">        } else {</a>
<a name="ln1335">            /*  read the next original structure */</a>
<a name="ln1336">            int nStructReadError=0;</a>
<a name="ln1337">            if ( !ip-&gt;bMergeAllInputStructures ) {</a>
<a name="ln1338">                nRet2 = CmlfileToOrigAtom( inp_file-&gt;f, NULL, 0, 0, 0, inp_index, out_index,</a>
<a name="ln1339">                                       NULL, NULL, NULL, &amp;nStructReadError, NULL );</a>
<a name="ln1340"> </a>
<a name="ln1341">                if ( nRet2 &lt;= 0 &amp;&amp; 10 &lt; nStructReadError &amp;&amp; nStructReadError &lt; 20 ) {</a>
<a name="ln1342">                    return _IS_EOF;</a>
<a name="ln1343">                }</a>
<a name="ln1344">            } else {</a>
<a name="ln1345">                return _IS_EOF;</a>
<a name="ln1346">            }</a>
<a name="ln1347">        }</a>
<a name="ln1348">        break;</a>
<a name="ln1349">#endif</a>
<a name="ln1350"> </a>
<a name="ln1351">    default:</a>
<a name="ln1352">        nRet = _IS_FATAL; /*  wrong file type */</a>
<a name="ln1353">    }</a>
<a name="ln1354">    return nRet;</a>
<a name="ln1355">}</a>
<a name="ln1356">#endif</a>
<a name="ln1357">/*****************************************************************************************************/</a>
<a name="ln1358">int TreatReadTheStructureErrors(  STRUCT_DATA *sd, INPUT_PARMS *ip, int nLogMask,</a>
<a name="ln1359">                                  INCHI_IOSTREAM *inp_file, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file, </a>
<a name="ln1360">                                  INCHI_IOSTREAM *prb_file, /*^^^ was: INCHI_IOSTREAM */</a>
<a name="ln1361">                                  ORIG_ATOM_DATA *orig_inp_data, long *num_inp, char *pStr, int nStrLen )</a>
<a name="ln1362">{</a>
<a name="ln1363">    int nRet = _IS_OKAY;</a>
<a name="ln1364">    /*  End of file */</a>
<a name="ln1365">    if ( 10 &lt; sd-&gt;nStructReadError &amp;&amp; sd-&gt;nStructReadError &lt; 20 ) {</a>
<a name="ln1366">        if ( sd-&gt;pStrErrStruct[0] ) {</a>
<a name="ln1367">            inchi_ios_eprint( log_file, &quot;%s inp structure #%ld: End of file.%s%s%s%s    \n&quot;, sd-&gt;pStrErrStruct, *num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1368">        }</a>
<a name="ln1369">        inchi_ios_eprint( log_file, &quot;End of file detected after structure #%ld.   \n&quot;, *num_inp-1 );</a>
<a name="ln1370">        nRet = _IS_EOF;</a>
<a name="ln1371">        goto exit_function; /*  end of file */</a>
<a name="ln1372">    }</a>
<a name="ln1373"> </a>
<a name="ln1374">    /*(*num_inp) ++;*/</a>
<a name="ln1375"> </a>
<a name="ln1376">    /*  Skipping the structures */</a>
<a name="ln1377">    if ( *num_inp &lt; ip-&gt;first_struct_number ) {</a>
<a name="ln1378"> </a>
<a name="ln1379">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln1380">/*^^^ #ifndef TARGET_API_LIB */</a>
<a name="ln1381">        if ( log_file-&gt;f != stderr ) {</a>
<a name="ln1382">            inchi_fprintf( stderr, &quot;\rSkipping structure #%ld.%s%s%s%s...&quot;, *num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue));</a>
<a name="ln1383">        }</a>
<a name="ln1384">#endif</a>
<a name="ln1385">        nRet = sd-&gt;nErrorType = _IS_SKIP;</a>
<a name="ln1386">        goto exit_function;</a>
<a name="ln1387">    }</a>
<a name="ln1388"> </a>
<a name="ln1389">    sd-&gt;nErrorType = GetInpStructErrorType( ip, sd-&gt;nStructReadError, sd-&gt;pStrErrStruct, orig_inp_data-&gt;num_inp_atoms );</a>
<a name="ln1390"> </a>
<a name="ln1391">    /*  init xml output */</a>
<a name="ln1392">    if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML) &amp;&amp; !ip-&gt;bXmlStarted ) {</a>
<a name="ln1393">        OutputINChIXmlRootStartTag( output_file );</a>
<a name="ln1394">        ip-&gt;bXmlStarted ++;</a>
<a name="ln1395">    }</a>
<a name="ln1396">    /*  init xml structure block */</a>
<a name="ln1397">    if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML) &amp;&amp; !sd-&gt;bXmlStructStarted ) {</a>
<a name="ln1398">        if ( !OutputINChIXmlStructStartTag( output_file, pStr, 1, nStrLen, ip-&gt;bNoStructLabels,</a>
<a name="ln1399">                                           *num_inp, ip-&gt;pSdfLabel, ip-&gt;pSdfValue ) ) {</a>
<a name="ln1400">            inchi_ios_eprint( log_file, &quot;Cannot create start xml tag for structure #%ld.%s%s%s%s Terminating.\n&quot;, *num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1401">            sd-&gt;bXmlStructStarted = -1;</a>
<a name="ln1402">            nRet = _IS_FATAL;</a>
<a name="ln1403">            goto exit_function;</a>
<a name="ln1404">        }</a>
<a name="ln1405">        sd-&gt;bXmlStructStarted ++;</a>
<a name="ln1406">    }</a>
<a name="ln1407"> </a>
<a name="ln1408">    /*  Fatal error */</a>
<a name="ln1409">    if ( sd-&gt;nErrorType == _IS_FATAL ) {</a>
<a name="ln1410">        if ( nLogMask &amp; LOG_MASK_FATAL )</a>
<a name="ln1411">            inchi_ios_eprint( log_file, &quot;Fatal Error %d (aborted; %s) inp structure #%ld.%s%s%s%s\n&quot;,</a>
<a name="ln1412">                    sd-&gt;nStructReadError, sd-&gt;pStrErrStruct, *num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1413">#if ( bRELEASE_VERSION == 1 || EXTR_FLAGS == 0 )</a>
<a name="ln1414">        if ( prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd &amp;&amp; !ip-&gt;bSaveAllGoodStructsAsProblem ) {</a>
<a name="ln1415">            CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, *num_inp);</a>
<a name="ln1416">        }</a>
<a name="ln1417">#endif</a>
<a name="ln1418">        /* goto exit_function; */</a>
<a name="ln1419">    }</a>
<a name="ln1420">    /*  Non-fatal errors: do not produce INChI */</a>
<a name="ln1421">    if ( sd-&gt;nErrorType == _IS_ERROR ) {  /*  70 =&gt; too many atoms */</a>
<a name="ln1422">        if ( nLogMask &amp; LOG_MASK_ERR )</a>
<a name="ln1423">            inchi_ios_eprint( log_file, &quot;Error %d (no %s; %s) inp structure #%ld.%s%s%s%s\n&quot;,</a>
<a name="ln1424">                    sd-&gt;nStructReadError, (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_SDFILE_ONLY)?&quot;Molfile&quot;:INCHI_NAME,</a>
<a name="ln1425">                    sd-&gt;pStrErrStruct, *num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1426">#if ( bRELEASE_VERSION == 1 || EXTR_FLAGS == 0 )</a>
<a name="ln1427">        if ( prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd &amp;&amp; !ip-&gt;bSaveAllGoodStructsAsProblem) {</a>
<a name="ln1428">            CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, *num_inp);</a>
<a name="ln1429">        }</a>
<a name="ln1430">#endif</a>
<a name="ln1431">    }</a>
<a name="ln1432"> </a>
<a name="ln1433">    /*  Warnings: try to produce INChI */</a>
<a name="ln1434">    if ( sd-&gt;nErrorType == _IS_WARNING ) {</a>
<a name="ln1435">        if ( nLogMask &amp; LOG_MASK_WARN )</a>
<a name="ln1436">            inchi_ios_eprint( log_file, &quot;Warning: (%s) inp structure #%ld.%s%s%s%s\n&quot;,</a>
<a name="ln1437">                    sd-&gt;pStrErrStruct, *num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1438">    }</a>
<a name="ln1439"> </a>
<a name="ln1440">    /*  xml error/warning processing; close xml struct block if error */</a>
<a name="ln1441">    if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML)</a>
<a name="ln1442">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln1443">         || (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW) &amp;&amp; (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT)</a>
<a name="ln1444">#endif</a>
<a name="ln1445">        ) {</a>
<a name="ln1446">        if ( sd-&gt;nErrorType != _IS_OKAY &amp;&amp; sd-&gt;nErrorType != _IS_WARNING ) {</a>
<a name="ln1447">            sd-&gt;nErrorType =</a>
<a name="ln1448">                ProcessStructError( output_file, log_file, /*sd-&gt;nStructReadError,*/</a>
<a name="ln1449">                         sd-&gt;pStrErrStruct, sd-&gt;nErrorType, &amp;sd-&gt;bXmlStructStarted, *num_inp, ip, pStr, nStrLen );</a>
<a name="ln1450">        }</a>
<a name="ln1451">    }</a>
<a name="ln1452">exit_function:</a>
<a name="ln1453">    if ( nRet &lt;= _IS_OKAY &amp;&amp; sd-&gt;nErrorType &gt; 0 ) {</a>
<a name="ln1454">        nRet = sd-&gt;nErrorType;</a>
<a name="ln1455">    }</a>
<a name="ln1456">    return nRet;</a>
<a name="ln1457">}</a>
<a name="ln1458">/******************************************************************************************************/</a>
<a name="ln1459">int GetOneComponent( STRUCT_DATA *sd, INPUT_PARMS *ip, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file,</a>
<a name="ln1460">                     INP_ATOM_DATA *inp_cur_data,</a>
<a name="ln1461">                     ORIG_ATOM_DATA *orig_inp_data, int i, long num_inp, char *pStr, int nStrLen )</a>
<a name="ln1462">{</a>
<a name="ln1463">    inchiTime ulTStart;</a>
<a name="ln1464">    InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1465">    CreateInpAtomData( inp_cur_data, orig_inp_data-&gt;nCurAtLen[i], 0 );</a>
<a name="ln1466">    inp_cur_data-&gt;num_at = ExtractConnectedComponent( orig_inp_data-&gt;at, orig_inp_data-&gt;num_inp_atoms, i+1, inp_cur_data-&gt;at );</a>
<a name="ln1467">    sd-&gt;ulStructTime += InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1468"> </a>
<a name="ln1469">    /*  error processing */</a>
<a name="ln1470">    if ( inp_cur_data-&gt;num_at &lt;= 0 || orig_inp_data-&gt;nCurAtLen[i] != inp_cur_data-&gt;num_at ) {</a>
<a name="ln1471">        /*  log error message */</a>
<a name="ln1472">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot extract Component&quot;);</a>
<a name="ln1473">        inchi_ios_eprint( log_file, &quot;%s #%d structure #%ld.%s%s%s%s\n&quot;, sd-&gt;pStrErrStruct, i+1, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue));</a>
<a name="ln1474">        sd-&gt;nErrorCode = inp_cur_data-&gt;num_at &lt; 0? inp_cur_data-&gt;num_at : (orig_inp_data-&gt;nCurAtLen[i] != inp_cur_data-&gt;num_at)? CT_ATOMCOUNT_ERR : CT_UNKNOWN_ERR;</a>
<a name="ln1475">        /* num_err ++; */</a>
<a name="ln1476">        sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln1477">        if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML)</a>
<a name="ln1478">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln1479">             || (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW) &amp;&amp; (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT)</a>
<a name="ln1480">#endif</a>
<a name="ln1481">           ) {</a>
<a name="ln1482">            /*  xml error message */</a>
<a name="ln1483">            sd-&gt;nErrorType = ProcessStructError( output_file, log_file, /*sd-&gt;nErrorCode,*/ sd-&gt;pStrErrStruct,</a>
<a name="ln1484">                                            sd-&gt;nErrorType, &amp;sd-&gt;bXmlStructStarted, num_inp, ip, pStr, nStrLen );</a>
<a name="ln1485">        }</a>
<a name="ln1486">    }</a>
<a name="ln1487">    return sd-&gt;nErrorType;</a>
<a name="ln1488">}</a>
<a name="ln1489">/*******************************************************************************************/</a>
<a name="ln1490">int GetProcessingWarningsOneINChI(INChI *pINChI, INP_ATOM_DATA *inp_norm_data, char *pStrErrStruct)</a>
<a name="ln1491">{</a>
<a name="ln1492">    int j;</a>
<a name="ln1493">    int nAmbiguousStereoAtoms, nAmbiguousStereoBonds;</a>
<a name="ln1494">    nAmbiguousStereoAtoms = 0;</a>
<a name="ln1495">    nAmbiguousStereoBonds = 0;</a>
<a name="ln1496"> </a>
<a name="ln1497">    if ( inp_norm_data-&gt;at ) {</a>
<a name="ln1498">        for ( j = 0; j &lt; pINChI-&gt;nNumberOfAtoms; j ++ ) {</a>
<a name="ln1499">            if ( inp_norm_data-&gt;at[j].bAmbiguousStereo &amp; (AMBIGUOUS_STEREO_ATOM | AMBIGUOUS_STEREO_ATOM_ISO) ) {</a>
<a name="ln1500">                nAmbiguousStereoAtoms ++;</a>
<a name="ln1501">            }</a>
<a name="ln1502">            if ( inp_norm_data-&gt;at[j].bAmbiguousStereo &amp; (AMBIGUOUS_STEREO_BOND | AMBIGUOUS_STEREO_BOND_ISO) ) {</a>
<a name="ln1503">                nAmbiguousStereoBonds ++;</a>
<a name="ln1504">            }</a>
<a name="ln1505">        }</a>
<a name="ln1506">        if ( nAmbiguousStereoAtoms ) {</a>
<a name="ln1507">            AddMOLfileError(pStrErrStruct, &quot;Ambiguous stereo:&quot;);</a>
<a name="ln1508">            AddMOLfileError(pStrErrStruct, &quot;center(s)&quot;);</a>
<a name="ln1509">        }</a>
<a name="ln1510">        if ( nAmbiguousStereoBonds ) {</a>
<a name="ln1511">            AddMOLfileError(pStrErrStruct, &quot;Ambiguous stereo:&quot;);</a>
<a name="ln1512">            AddMOLfileError(pStrErrStruct, &quot;bond(s)&quot;);</a>
<a name="ln1513">        }</a>
<a name="ln1514">    }</a>
<a name="ln1515">    return (nAmbiguousStereoAtoms || nAmbiguousStereoBonds);</a>
<a name="ln1516">}</a>
<a name="ln1517">/*******************************************************************************************/</a>
<a name="ln1518">int  GetProcessingWarnings(INChI *cur_INChI[], INP_ATOM_DATA **inp_norm_data, STRUCT_DATA *sd)</a>
<a name="ln1519">{</a>
<a name="ln1520">    int i, ret = 0;</a>
<a name="ln1521">    for (i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln1522">        if ( cur_INChI[i] &amp;&amp; cur_INChI[i]-&gt;nNumberOfAtoms&gt;0 ) {</a>
<a name="ln1523">            ret |= GetProcessingWarningsOneINChI(cur_INChI[i], inp_norm_data[i], sd-&gt;pStrErrStruct);</a>
<a name="ln1524">        }</a>
<a name="ln1525">    }</a>
<a name="ln1526">    return ret;</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">/*******************************************************************************************/</a>
<a name="ln1530">int CreateOneComponentINChI( STRUCT_DATA *sd, INPUT_PARMS *ip, INP_ATOM_DATA *inp_cur_data, ORIG_ATOM_DATA *orig_inp_data,</a>
<a name="ln1531">                            PINChI2 *pINChI, PINChI_Aux2 *pINChI_Aux, int iINChI,</a>
<a name="ln1532">                            int i, long num_inp, INP_ATOM_DATA **inp_norm_data, NORM_CANON_FLAGS *pncFlags, </a>
<a name="ln1533">                            INCHI_IOSTREAM *log_file )</a>
<a name="ln1534">{</a>
<a name="ln1535">    inchiTime     ulTStart, ulTEnd, *pulTEnd = NULL;</a>
<a name="ln1536">    int           k, num_at, ret = 0;</a>
<a name="ln1537">    int           bOrigCoord;</a>
<a name="ln1538">    INCHI_MODE     bTautFlags     = ip-&gt;bTautFlags;</a>
<a name="ln1539">    INCHI_MODE     bTautFlagsDone = (ip-&gt;bTautFlagsDone | sd-&gt;bTautFlagsDone[INCHI_BAS]);</a>
<a name="ln1540">    INChI       *cur_INChI[TAUT_NUM];</a>
<a name="ln1541">    INChI_Aux   *cur_INChI_Aux[TAUT_NUM];</a>
<a name="ln1542">    long          lElapsedTime;</a>
<a name="ln1543">    /*</a>
<a name="ln1544">    PINChI2     *pINChI     = pINChI2[iINChI];</a>
<a name="ln1545">    PINChI_Aux2 *pINChI_Aux = pINChI_Aux2[iINChI];</a>
<a name="ln1546">    */</a>
<a name="ln1547">    InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1548">    bOrigCoord = !(ip-&gt;bINChIOutputOptions &amp; (INCHI_OUT_NO_AUX_INFO | INCHI_OUT_SHORT_AUX_INFO));</a>
<a name="ln1549"> </a>
<a name="ln1550">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln1551">        cur_INChI[k]      = NULL;</a>
<a name="ln1552">        cur_INChI_Aux[k]  = NULL;</a>
<a name="ln1553">    }</a>
<a name="ln1554">    /*  allocate memory for non-tautimeric (k=0) and tautomeric (k=1) results */</a>
<a name="ln1555">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln1556">        int nAllocMode = (k==TAUT_YES? REQ_MODE_TAUT:0) |</a>
<a name="ln1557">                         (bTautFlagsDone &amp; ( TG_FLAG_FOUND_ISOTOPIC_H_DONE |</a>
<a name="ln1558">                                             TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE ))?</a>
<a name="ln1559">                         (ip-&gt;nMode &amp; REQ_MODE_ISO):0;</a>
<a name="ln1560"> </a>
<a name="ln1561">        if ( (k==TAUT_NON &amp;&amp; (ip-&gt;nMode &amp; REQ_MODE_BASIC )) ||</a>
<a name="ln1562">             (k==TAUT_YES &amp;&amp; (ip-&gt;nMode &amp; REQ_MODE_TAUT ))     ) {</a>
<a name="ln1563">            /*  alloc INChI and INChI_Aux */</a>
<a name="ln1564">            cur_INChI[k]     = Alloc_INChI( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at, &amp;inp_cur_data-&gt;num_bonds,</a>
<a name="ln1565">                                          &amp;inp_cur_data-&gt;num_isotopic, nAllocMode );</a>
<a name="ln1566">            cur_INChI_Aux[k] = Alloc_INChI_Aux( inp_cur_data-&gt;num_at,</a>
<a name="ln1567">                                          inp_cur_data-&gt;num_isotopic, nAllocMode, bOrigCoord );</a>
<a name="ln1568">            if ( cur_INChI_Aux[k] ) {</a>
<a name="ln1569">                cur_INChI_Aux[k]-&gt;bIsIsotopic = inp_cur_data-&gt;num_isotopic;</a>
<a name="ln1570">            }</a>
<a name="ln1571">            /*  alloc memory for the output structure: non-tautomeric and tautomeric (for displaying) */</a>
<a name="ln1572">            CreateInpAtomData( inp_norm_data[k], inp_cur_data-&gt;num_at, k );</a>
<a name="ln1573">        } else {</a>
<a name="ln1574">            FreeInpAtomData( inp_norm_data[k] );</a>
<a name="ln1575">        }</a>
<a name="ln1576">    }</a>
<a name="ln1577">    lElapsedTime = InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1578">    if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln1579">        ip-&gt;msec_LeftTime -= lElapsedTime;</a>
<a name="ln1580">    }</a>
<a name="ln1581">    sd-&gt;ulStructTime += lElapsedTime;</a>
<a name="ln1582"> </a>
<a name="ln1583"> </a>
<a name="ln1584">/*^^^#if ( !defined( TARGET_LIB_FOR_WINCHI ) &amp;&amp; !defined( TARGET_API_LIB ) ) */</a>
<a name="ln1585">#if ( !defined( TARGET_LIB_FOR_WINCHI ) &amp;&amp; !defined( TARGET_API_LIB ) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln1586">#if ( TEST_RENUMB_ATOMS != 1 )</a>
<a name="ln1587">    /*  log file / console output */</a>
<a name="ln1588">    if ( log_file-&gt;f &amp;&amp; log_file-&gt;f != stderr ) { /* NULL log_file now ignored. 11-23-2005 */</a>
<a name="ln1589">        if ( ip-&gt;bDisplay )</a>
<a name="ln1590">            inchi_ios_eprint( log_file, &quot;Component #%d structure #%ld.%s%s%s%s...\n&quot;, i+1, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1591">        else</a>
<a name="ln1592">            inchi_fprintf( stderr, &quot;Component #%d structure #%ld.%s%s%s%s...\r&quot;, i+1, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1593">    }</a>
<a name="ln1594">#endif</a>
<a name="ln1595">#endif</a>
<a name="ln1596">    /******************************************************</a>
<a name="ln1597">     *</a>
<a name="ln1598">     *  Get one component canonical numberings, etc.</a>
<a name="ln1599">     *</a>
<a name="ln1600">     ******************************************************/</a>
<a name="ln1601"> </a>
<a name="ln1602">    /*</a>
<a name="ln1603">     * Create_INChI() return value:</a>
<a name="ln1604">     * num_at &lt;= 0: error code</a>
<a name="ln1605">     * num_at &gt;  0: number of atoms (excluding terminal hydrogen atoms)</a>
<a name="ln1606">     * inp_norm_data[0] =&gt; non-tautomeric, inp_norm_data[1] =&gt; tautomeric</a>
<a name="ln1607">     */</a>
<a name="ln1608">    InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1609">    if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln1610">        ulTEnd = ulTStart;</a>
<a name="ln1611">        pulTEnd = &amp;ulTEnd;</a>
<a name="ln1612">        if ( ip-&gt;msec_LeftTime &gt; 0 ) {</a>
<a name="ln1613">            InchiTimeAddMsec( pulTEnd, ip-&gt;msec_LeftTime );</a>
<a name="ln1614">        }</a>
<a name="ln1615">    }</a>
<a name="ln1616">    num_at = Create_INChI( cur_INChI, cur_INChI_Aux, orig_inp_data/* not used */, inp_cur_data-&gt;at,</a>
<a name="ln1617">                          inp_norm_data,</a>
<a name="ln1618">                          inp_cur_data-&gt;num_at,</a>
<a name="ln1619">                          ip-&gt;nMode, &amp;bTautFlags, &amp;bTautFlagsDone, pulTEnd, NULL, sd-&gt;pStrErrStruct);</a>
<a name="ln1620">    SetConnectedComponentNumber( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at, i+1 ); /*  normalization alters structure component number */</a>
<a name="ln1621">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln1622">        if ( cur_INChI_Aux[k] &amp;&amp; cur_INChI_Aux[k]-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln1623">            pncFlags-&gt;bNormalizationFlags[iINChI][k] |= cur_INChI_Aux[k]-&gt;bNormalizationFlags;</a>
<a name="ln1624">            pncFlags-&gt;bTautFlags[iINChI][k]          |= cur_INChI_Aux[k]-&gt;bTautFlags;</a>
<a name="ln1625">            pncFlags-&gt;bTautFlagsDone[iINChI][k]      |= cur_INChI_Aux[k]-&gt;bTautFlagsDone;</a>
<a name="ln1626">            pncFlags-&gt;nCanonFlags[iINChI][k]         |= cur_INChI_Aux[k]-&gt;nCanonFlags;</a>
<a name="ln1627">        }</a>
<a name="ln1628">    }</a>
<a name="ln1629"> </a>
<a name="ln1630">    /*  Detect errors */</a>
<a name="ln1631">    if ( num_at &lt; 0 ) {</a>
<a name="ln1632">        sd-&gt;nErrorCode = num_at;</a>
<a name="ln1633">    } else</a>
<a name="ln1634">    if ( num_at == 0 ) {</a>
<a name="ln1635">        sd-&gt;nErrorCode = -1;</a>
<a name="ln1636">    } else</a>
<a name="ln1637">    if ( cur_INChI[TAUT_NON] &amp;&amp; cur_INChI[TAUT_NON]-&gt;nErrorCode ) {</a>
<a name="ln1638">        /*  non-tautomeric error */</a>
<a name="ln1639">        sd-&gt;nErrorCode = cur_INChI[TAUT_NON]-&gt;nErrorCode;</a>
<a name="ln1640">    } else</a>
<a name="ln1641">    if ( cur_INChI[TAUT_YES] &amp;&amp; cur_INChI[TAUT_YES]-&gt;nErrorCode ) {</a>
<a name="ln1642">        /*  tautomeric error */</a>
<a name="ln1643">        sd-&gt;nErrorCode = cur_INChI[TAUT_YES]-&gt;nErrorCode;</a>
<a name="ln1644">    }</a>
<a name="ln1645">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1646">    if ( cur_INChI[TAUT_NON] ) sd-&gt;bExtract |= cur_INChI[TAUT_NON]-&gt;bExtract;</a>
<a name="ln1647">    if ( cur_INChI[TAUT_YES] ) sd-&gt;bExtract |= cur_INChI[TAUT_YES]-&gt;bExtract;</a>
<a name="ln1648">    if ( (TG_FLAG_TEST_TAUT3_SALTS_DONE &amp; bTautFlagsDone) ) {</a>
<a name="ln1649">        sd-&gt;bExtract |= EXTR_TEST_TAUT3_SALTS_DONE;</a>
<a name="ln1650">    }</a>
<a name="ln1651">#endif</a>
<a name="ln1652">    /*  detect and store stereo warnings */</a>
<a name="ln1653">    if ( !sd-&gt;nErrorCode ) {</a>
<a name="ln1654">        GetProcessingWarnings(cur_INChI, inp_norm_data, sd);</a>
<a name="ln1655">    }</a>
<a name="ln1656"> </a>
<a name="ln1657">    lElapsedTime = InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1658">    if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln1659">        ip-&gt;msec_LeftTime -= lElapsedTime;</a>
<a name="ln1660">    }</a>
<a name="ln1661">    sd-&gt;ulStructTime += lElapsedTime;</a>
<a name="ln1662">#ifndef TARGET_API_LIB</a>
<a name="ln1663">    /*  Display the results */</a>
<a name="ln1664">    if ( ip-&gt;bDisplay )</a>
<a name="ln1665">        eat_keyboard_input();</a>
<a name="ln1666">#endif</a>
<a name="ln1667">    /*  a) No matter what happened save the allocated INChI pointers */</a>
<a name="ln1668">    /*  save the INChI of the current component */</a>
<a name="ln1669"> </a>
<a name="ln1670">    InchiTimeGet( &amp;ulTStart );</a>
<a name="ln1671">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln1672">        pINChI[i][k]     = cur_INChI[k];</a>
<a name="ln1673">        pINChI_Aux[i][k] = cur_INChI_Aux[k];</a>
<a name="ln1674"> </a>
<a name="ln1675">        cur_INChI[k]     = NULL;</a>
<a name="ln1676">        cur_INChI_Aux[k] = NULL;</a>
<a name="ln1677">    }</a>
<a name="ln1678"> </a>
<a name="ln1679">    /*  b) Count one component structure and/or INChI results only if there was no error */</a>
<a name="ln1680">    /*     Set inp_norm_data[j]-&gt;num_removed_H = number of removed explicit H           */</a>
<a name="ln1681"> </a>
<a name="ln1682">    if ( !sd-&gt;nErrorCode ) {</a>
<a name="ln1683"> </a>
<a name="ln1684">        /*  find where the current processed structure is located */</a>
<a name="ln1685">        int cur_is_in_non_taut = (pINChI[i][TAUT_NON] &amp;&amp; pINChI[i][TAUT_NON]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln1686">        int cur_is_in_taut     = (pINChI[i][TAUT_YES] &amp;&amp; pINChI[i][TAUT_YES]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln1687">        int cur_is_non_taut = (cur_is_in_non_taut &amp;&amp; 0 == pINChI[i][TAUT_NON]-&gt;lenTautomer) ||</a>
<a name="ln1688">                              (cur_is_in_taut     &amp;&amp; 0 == pINChI[i][TAUT_YES]-&gt;lenTautomer);</a>
<a name="ln1689">        int cur_is_taut     = cur_is_in_taut     &amp;&amp; 0 &lt;  pINChI[i][TAUT_YES]-&gt;lenTautomer;</a>
<a name="ln1690">        /*</a>
<a name="ln1691">        sd-&gt;bTautFlags[iINChI]     |= bTautFlags;</a>
<a name="ln1692">        sd-&gt;bTautFlagsDone[iINChI] |= bTautFlagsDone;</a>
<a name="ln1693">        */</a>
<a name="ln1694">        if ( cur_is_non_taut + cur_is_taut ) {</a>
<a name="ln1695">            /*  count tautomeric and non-tautomeric components of the structures */</a>
<a name="ln1696">            int j1 = cur_is_in_non_taut? TAUT_NON:TAUT_YES;</a>
<a name="ln1697">            int j2 = cur_is_in_taut?     TAUT_YES:TAUT_NON;</a>
<a name="ln1698">            int j;</a>
<a name="ln1699">            sd-&gt;num_non_taut[iINChI] += cur_is_non_taut;</a>
<a name="ln1700">            sd-&gt;num_taut[iINChI]     += cur_is_taut;</a>
<a name="ln1701">            for ( j = j1; j &lt;= j2; j ++ ) {</a>
<a name="ln1702">                int bIsotopic = (pINChI[i][j]-&gt;nNumberOfIsotopicAtoms ||</a>
<a name="ln1703">                                 pINChI[i][j]-&gt;nNumberOfIsotopicTGroups ||</a>
<a name="ln1704">                                 (pINChI[i][j]-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; pINChI[i][j]-&gt;nPossibleLocationsOfIsotopicH[0]&gt;1));</a>
<a name="ln1705">                if ( j == TAUT_YES ) {</a>
<a name="ln1706">                    bIsotopic |= (0 &lt; pINChI_Aux[i][j]-&gt;nNumRemovedIsotopicH[0] + </a>
<a name="ln1707">                                      pINChI_Aux[i][j]-&gt;nNumRemovedIsotopicH[1] +</a>
<a name="ln1708">                                      pINChI_Aux[i][j]-&gt;nNumRemovedIsotopicH[2]);</a>
<a name="ln1709">                }</a>
<a name="ln1710">                inp_norm_data[j]-&gt;bExists = 1; /*  j=0: non-taut exists, j=1: taut exists */</a>
<a name="ln1711">                inp_norm_data[j]-&gt;bHasIsotopicLayer = bIsotopic;</a>
<a name="ln1712">                /*inp_norm_data[j]-&gt;num_removed_H = inp_norm_data[j]-&gt;num_at - num_at;*/</a>
<a name="ln1713">            }</a>
<a name="ln1714">        }</a>
<a name="ln1715">    }</a>
<a name="ln1716">/*</a>
<a name="ln1717">    return (sd-&gt;nErrorCode==CT_OUT_OF_RAM || sd-&gt;nErrorCode==CT_USER_QUIT_ERR)? _IS_FATAL :</a>
<a name="ln1718">            sd-&gt;nErrorCode? _IS_ERROR : 0;</a>
<a name="ln1719">*/</a>
<a name="ln1720">    if ( sd-&gt;nErrorCode==CT_OUT_OF_RAM || sd-&gt;nErrorCode==CT_USER_QUIT_ERR ) {</a>
<a name="ln1721">        ret = _IS_FATAL;</a>
<a name="ln1722">    } else</a>
<a name="ln1723">    if ( sd-&gt;nErrorCode ) {</a>
<a name="ln1724">        ret = _IS_ERROR;</a>
<a name="ln1725">    }</a>
<a name="ln1726">    lElapsedTime = InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln1727">    if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln1728">        ip-&gt;msec_LeftTime -= lElapsedTime;</a>
<a name="ln1729">    }</a>
<a name="ln1730">    sd-&gt;ulStructTime += lElapsedTime;</a>
<a name="ln1731">    return ret;</a>
<a name="ln1732">}</a>
<a name="ln1733">/****************************************************************************************************/</a>
<a name="ln1734">int TreatCreateOneComponentINChIError(STRUCT_DATA *sd, INPUT_PARMS *ip, ORIG_ATOM_DATA *orig_inp_data,</a>
<a name="ln1735">                                     int i, long num_inp,</a>
<a name="ln1736">                                     INCHI_IOSTREAM *inp_file, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file, </a>
<a name="ln1737">                                     INCHI_IOSTREAM *prb_file, /*^^^ was: INCHI_IOSTREAM */</a>
<a name="ln1738">                                     char *pStr, int nStrLen )</a>
<a name="ln1739">{</a>
<a name="ln1740">    if ( sd-&gt;nErrorCode ) {</a>
<a name="ln1741">        AddMOLfileError(sd-&gt;pStrErrStruct, ErrMsg(sd-&gt;nErrorCode) );</a>
<a name="ln1742">        inchi_ios_eprint( log_file, &quot;Error %d (%s) structure #%ld component %d.%s%s%s%s\n&quot;,</a>
<a name="ln1743">            sd-&gt;nErrorCode, sd-&gt;pStrErrStruct, num_inp, i+1, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1744">        sd-&gt;nErrorType = (sd-&gt;nErrorCode==CT_OUT_OF_RAM || sd-&gt;nErrorCode==CT_USER_QUIT_ERR)? _IS_FATAL : _IS_ERROR;</a>
<a name="ln1745">        if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML)</a>
<a name="ln1746">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln1747">             || (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW) &amp;&amp; (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT)</a>
<a name="ln1748">#endif</a>
<a name="ln1749">            ) {</a>
<a name="ln1750">            sd-&gt;nErrorType = ProcessStructError( output_file, log_file, /*sd-&gt;nErrorCode,*/ sd-&gt;pStrErrStruct,</a>
<a name="ln1751">                                            sd-&gt;nErrorType, &amp;sd-&gt;bXmlStructStarted, num_inp, ip, pStr, nStrLen );</a>
<a name="ln1752">            /*  save the problem structure */</a>
<a name="ln1753">            if ( prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd &amp;&amp; !ip-&gt;bSaveAllGoodStructsAsProblem ) {</a>
<a name="ln1754">                CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, num_inp);</a>
<a name="ln1755">            }</a>
<a name="ln1756">        } else {</a>
<a name="ln1757">            /*  save the problem structure */</a>
<a name="ln1758">            if ( sd-&gt;nErrorCode &amp;&amp; prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd &amp;&amp; !ip-&gt;bSaveAllGoodStructsAsProblem ) {</a>
<a name="ln1759">                CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, num_inp);</a>
<a name="ln1760">            }</a>
<a name="ln1761">        }</a>
<a name="ln1762">    }</a>
<a name="ln1763">/*^^^ #ifndef TARGET_API_LIB */</a>
<a name="ln1764">#if ( !defined( TARGET_API_LIB ) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln1765">    /*  print the logfile record */</a>
<a name="ln1766">    if ( log_file-&gt;f &amp;&amp; log_file-&gt;f != stderr &amp;&amp; (sd-&gt;ulStructTime &gt;= 1000 || sd-&gt;nErrorCode) ) {</a>
<a name="ln1767">        fprintf( log_file-&gt;f, &quot;%10lu msec structure #%ld.%s%s%s%s (%d component%s, %d atom%s, error=%d).\n&quot;,</a>
<a name="ln1768">                sd-&gt;ulStructTime, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue),</a>
<a name="ln1769">                orig_inp_data-&gt;num_components, orig_inp_data-&gt;num_components==1?&quot;&quot;:&quot;s&quot;,</a>
<a name="ln1770">                orig_inp_data-&gt;num_inp_atoms, orig_inp_data-&gt;num_inp_atoms==1?&quot;&quot;:&quot;s&quot;, sd-&gt;nErrorCode );</a>
<a name="ln1771">    }</a>
<a name="ln1772">#endif</a>
<a name="ln1773">    return sd-&gt;nErrorType;</a>
<a name="ln1774">}</a>
<a name="ln1775">/****************************************************************************************************/</a>
<a name="ln1776">int TreatCreateINChIWarning(STRUCT_DATA *sd, INPUT_PARMS *ip, ORIG_ATOM_DATA *orig_inp_data, long num_inp,</a>
<a name="ln1777">                                     INCHI_IOSTREAM *inp_file, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file, </a>
<a name="ln1778">                                     INCHI_IOSTREAM *prb_file, /*^^^ was: INCHI_IOSTREAM */</a>
<a name="ln1779">                                     char *pStr, int nStrLen )</a>
<a name="ln1780">{</a>
<a name="ln1781">#if ( bRELEASE_VERSION == 0 &amp;&amp; (EXTR_FLAGS || EXTR_MASK) )</a>
<a name="ln1782">    if ( EXTR_MASK? ((sd-&gt;bExtract &amp; EXTR_MASK) == EXTR_FLAGS) : (sd-&gt;bExtract &amp; EXTR_FLAGS) ) {</a>
<a name="ln1783">        char szMsg[64];</a>
<a name="ln1784">        sprintf( szMsg, &quot;ExtractStruct.code=0x%X&quot;, sd-&gt;bExtract);</a>
<a name="ln1785">        AddMOLfileError(sd-&gt;pStrErrStruct, szMsg);</a>
<a name="ln1786">    }</a>
<a name="ln1787">#endif</a>
<a name="ln1788">    if ( !sd-&gt;nErrorCode &amp;&amp; sd-&gt;pStrErrStruct[0] ) {</a>
<a name="ln1789">        inchi_ios_eprint( log_file, &quot;Warning (%s) structure #%ld.%s%s%s%s\n&quot;,</a>
<a name="ln1790">            sd-&gt;pStrErrStruct, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln1791">        sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln1792">        if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML)</a>
<a name="ln1793">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln1794">             || (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW) &amp;&amp; (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT)</a>
<a name="ln1795">#endif</a>
<a name="ln1796">            ) {</a>
<a name="ln1797">            sd-&gt;nErrorType = ProcessStructError( output_file, log_file, /*sd-&gt;nErrorCode,*/ sd-&gt;pStrErrStruct,</a>
<a name="ln1798">                                            sd-&gt;nErrorType, &amp;sd-&gt;bXmlStructStarted, num_inp, ip, pStr, nStrLen );</a>
<a name="ln1799">        }</a>
<a name="ln1800">        /*  save the structure as a problem structure if requested */</a>
<a name="ln1801">        if ( ip-&gt;bSaveWarningStructsAsProblem &amp;&amp; !ip-&gt;bSaveAllGoodStructsAsProblem &amp;&amp;</a>
<a name="ln1802">             prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd ) {</a>
<a name="ln1803">            CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, num_inp);</a>
<a name="ln1804">        }</a>
<a name="ln1805">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1806">        /*  otherwise extract the structure as a problem structure if requested */</a>
<a name="ln1807">        else</a>
<a name="ln1808">        if ( (EXTR_MASK? ((sd-&gt;bExtract &amp; EXTR_MASK) == EXTR_FLAGS) : (sd-&gt;bExtract &amp; EXTR_FLAGS)) &amp;&amp; !ip-&gt;bSaveAllGoodStructsAsProblem &amp;&amp;</a>
<a name="ln1809">             prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd ) {</a>
<a name="ln1810">            CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, num_inp);</a>
<a name="ln1811">        }</a>
<a name="ln1812">#endif</a>
<a name="ln1813">    }</a>
<a name="ln1814">#if ( bRELEASE_VERSION != 1 &amp;&amp; bOUTPUT_ONE_STRUCT_TIME == 1 )</a>
<a name="ln1815">#ifndef TARGET_API_LIB</a>
<a name="ln1816">    if ( log_file &amp;&amp; log_file != stderr ) {</a>
<a name="ln1817">        fprintf( log_file, &quot;%10lu msec structure %1dD #%ld.%s%s%s%s (%d component%s, %d atom%s, error=%d).\n&quot;,</a>
<a name="ln1818">                sd-&gt;ulStructTime, orig_inp_data-&gt;num_dimensions, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue),</a>
<a name="ln1819">                orig_inp_data-&gt;num_components, orig_inp_data-&gt;num_components==1?&quot;&quot;:&quot;s&quot;,</a>
<a name="ln1820">                orig_inp_data-&gt;num_inp_atoms, orig_inp_data-&gt;num_inp_atoms==1?&quot;&quot;:&quot;s&quot;, sd-&gt;nErrorCode );</a>
<a name="ln1821">    }</a>
<a name="ln1822">#else</a>
<a name="ln1823">    if ( log_file ) {</a>
<a name="ln1824">        inchi_ios_eprint( log_file, &quot;%10lu msec structure %1dD #%ld.%s%s%s%s (%d component%s, %d atom%s, error=%d).\n&quot;,</a>
<a name="ln1825">                sd-&gt;ulStructTime, orig_inp_data-&gt;num_dimensions, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue),</a>
<a name="ln1826">                orig_inp_data-&gt;num_components, orig_inp_data-&gt;num_components==1?&quot;&quot;:&quot;s&quot;,</a>
<a name="ln1827">                orig_inp_data-&gt;num_inp_atoms, orig_inp_data-&gt;num_inp_atoms==1?&quot;&quot;:&quot;s&quot;, sd-&gt;nErrorCode );</a>
<a name="ln1828">    }</a>
<a name="ln1829">#endif</a>
<a name="ln1830">#endif</a>
<a name="ln1831">    return sd-&gt;nErrorType;</a>
<a name="ln1832">}</a>
<a name="ln1833">/*******************************************************************************************/</a>
<a name="ln1834">int DuplicateOrigAtom( ORIG_ATOM_DATA *new_orig_atom, ORIG_ATOM_DATA *orig_atom )</a>
<a name="ln1835">{</a>
<a name="ln1836">    inp_ATOM  *at                 = NULL;</a>
<a name="ln1837">    AT_NUMB   *nCurAtLen          = NULL;</a>
<a name="ln1838">    AT_NUMB   *nOldCompNumber     = NULL;</a>
<a name="ln1839"> </a>
<a name="ln1840">    if ( new_orig_atom-&gt;at &amp;&amp; new_orig_atom-&gt;num_inp_atoms &gt;= orig_atom-&gt;num_inp_atoms ) {</a>
<a name="ln1841">        at             = new_orig_atom-&gt;at;</a>
<a name="ln1842">    } else {</a>
<a name="ln1843">        at             = (inp_ATOM *)inchi_calloc(orig_atom-&gt;num_inp_atoms+1, sizeof(at[0]));</a>
<a name="ln1844">    }</a>
<a name="ln1845">    if ( new_orig_atom-&gt;nOldCompNumber &amp;&amp; new_orig_atom-&gt;num_components &gt;= orig_atom-&gt;num_components ) {</a>
<a name="ln1846">        nCurAtLen      = new_orig_atom-&gt;nCurAtLen;</a>
<a name="ln1847">    } else {</a>
<a name="ln1848">        nCurAtLen      = (AT_NUMB *)inchi_calloc(orig_atom-&gt;num_components+1, sizeof(nCurAtLen[0]));</a>
<a name="ln1849">    }</a>
<a name="ln1850">    if ( new_orig_atom-&gt;nCurAtLen &amp;&amp; new_orig_atom-&gt;num_components &gt;= orig_atom-&gt;num_components ) {</a>
<a name="ln1851">        nOldCompNumber = new_orig_atom-&gt;nOldCompNumber;</a>
<a name="ln1852">    } else {</a>
<a name="ln1853">        nOldCompNumber = (AT_NUMB *)inchi_calloc(orig_atom-&gt;num_components+1, sizeof(nOldCompNumber[0]));</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">    if ( at &amp;&amp; nCurAtLen &amp;&amp; nOldCompNumber ) {</a>
<a name="ln1857">        /* copy */</a>
<a name="ln1858">        if ( orig_atom-&gt;at )</a>
<a name="ln1859">            memcpy( at, orig_atom-&gt;at, orig_atom-&gt;num_inp_atoms * sizeof(new_orig_atom-&gt;at[0]) );</a>
<a name="ln1860">        if ( orig_atom-&gt;nCurAtLen )</a>
<a name="ln1861">            memcpy( nCurAtLen, orig_atom-&gt;nCurAtLen, orig_atom-&gt;num_components*sizeof(nCurAtLen[0]) );</a>
<a name="ln1862">        if ( orig_atom-&gt;nOldCompNumber )</a>
<a name="ln1863">            memcpy( nOldCompNumber, orig_atom-&gt;nOldCompNumber, orig_atom-&gt;num_components*sizeof(nOldCompNumber[0]) );</a>
<a name="ln1864">        /* deallocate */</a>
<a name="ln1865">        if ( new_orig_atom-&gt;at &amp;&amp; new_orig_atom-&gt;at != at )</a>
<a name="ln1866">            inchi_free( new_orig_atom-&gt;at );</a>
<a name="ln1867">        if ( new_orig_atom-&gt;nCurAtLen &amp;&amp; new_orig_atom-&gt;nCurAtLen != nCurAtLen )</a>
<a name="ln1868">            inchi_free( new_orig_atom-&gt;nCurAtLen );</a>
<a name="ln1869">        if ( new_orig_atom-&gt;nOldCompNumber &amp;&amp; new_orig_atom-&gt;nOldCompNumber != nOldCompNumber )</a>
<a name="ln1870">            inchi_free( new_orig_atom-&gt;nOldCompNumber );</a>
<a name="ln1871"> </a>
<a name="ln1872">        *new_orig_atom                = *orig_atom;</a>
<a name="ln1873">        new_orig_atom-&gt;at             = at;</a>
<a name="ln1874">        new_orig_atom-&gt;nCurAtLen      = nCurAtLen;</a>
<a name="ln1875">        new_orig_atom-&gt;nOldCompNumber = nOldCompNumber;</a>
<a name="ln1876">        /* data that are not to be copied */</a>
<a name="ln1877">        new_orig_atom-&gt;nNumEquSets    = 0;</a>
<a name="ln1878">        memset(new_orig_atom-&gt;bSavedInINCHI_LIB, 0, sizeof(new_orig_atom-&gt;bSavedInINCHI_LIB));</a>
<a name="ln1879">        memset(new_orig_atom-&gt;bPreprocessed,    0, sizeof(new_orig_atom-&gt;bPreprocessed));</a>
<a name="ln1880">        /* arrays that are not to be copied */</a>
<a name="ln1881">        new_orig_atom-&gt;szCoord        = NULL;</a>
<a name="ln1882">        new_orig_atom-&gt;nEquLabels     = NULL;</a>
<a name="ln1883">        new_orig_atom-&gt;nSortedOrder   = NULL;</a>
<a name="ln1884">        return 0;</a>
<a name="ln1885">    }</a>
<a name="ln1886"> </a>
<a name="ln1887">    /* deallocate */</a>
<a name="ln1888">    if ( at &amp;&amp; new_orig_atom-&gt;at != at )</a>
<a name="ln1889">        inchi_free( at );</a>
<a name="ln1890">    if ( nCurAtLen &amp;&amp; new_orig_atom-&gt;nCurAtLen != nCurAtLen )</a>
<a name="ln1891">        inchi_free( nCurAtLen );</a>
<a name="ln1892">    if ( nOldCompNumber &amp;&amp; new_orig_atom-&gt;nOldCompNumber != nOldCompNumber )</a>
<a name="ln1893">        inchi_free( nOldCompNumber );</a>
<a name="ln1894"> </a>
<a name="ln1895">    return -1; /* failed */</a>
<a name="ln1896">}</a>
<a name="ln1897">#ifndef TARGET_API_LIB</a>
<a name="ln1898">/*******************************************************************************************/</a>
<a name="ln1899">int GetOneStructure( STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle,</a>
<a name="ln1900">                     INCHI_IOSTREAM *inp_file, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file, </a>
<a name="ln1901">                     INCHI_IOSTREAM *prb_file, /*^^^ was: INCHI_IOSTREAM */</a>
<a name="ln1902">                     ORIG_ATOM_DATA *orig_inp_data, long *num_inp, char *pStr, int nStrLen, STRUCT_FPTRS *struct_fptrs )</a>
<a name="ln1903">{</a>
<a name="ln1904">    int nRet, inp_index, out_index, bUseFptr = (NULL != struct_fptrs);</a>
<a name="ln1905"> </a>
<a name="ln1906">    FreeOrigAtData( orig_inp_data );</a>
<a name="ln1907">    /*</a>
<a name="ln1908">    FreeOrigAtData( orig_inp_data + 1 );</a>
<a name="ln1909">    FreeOrigAtData( orig_inp_data + 2 );</a>
<a name="ln1910">    */</a>
<a name="ln1911"> </a>
<a name="ln1912">    /* added for TARGET_LIB_FOR_WINCHI early EOF detection */</a>
<a name="ln1913">    inp_index = -1;</a>
<a name="ln1914">    out_index = -1;</a>
<a name="ln1915">    if ( struct_fptrs ) {</a>
<a name="ln1916">        if ( inp_file-&gt;f == stdin ) {</a>
<a name="ln1917">            return _IS_FATAL;</a>
<a name="ln1918">        }</a>
<a name="ln1919">        if ( ip-&gt;nInputType == INPUT_CMLFILE ) {</a>
<a name="ln1920">            bUseFptr = 0;</a>
<a name="ln1921">        }</a>
<a name="ln1922">        /* initially allocate or increase length of struct_fptrs-&gt;fptr array */</a>
<a name="ln1923">        if ( !struct_fptrs-&gt;fptr || struct_fptrs-&gt;len_fptr &lt;= struct_fptrs-&gt;cur_fptr+1 ) {</a>
<a name="ln1924">            INCHI_FPTR *new_fptr = (INCHI_FPTR *)inchi_calloc( struct_fptrs-&gt;len_fptr + ADD_LEN_STRUCT_FPTRS, sizeof(new_fptr[0]) );</a>
<a name="ln1925">            if ( new_fptr ) {</a>
<a name="ln1926">                if ( struct_fptrs-&gt;fptr ) {</a>
<a name="ln1927">                    if ( struct_fptrs-&gt;len_fptr ) {</a>
<a name="ln1928">                        memcpy( new_fptr, struct_fptrs-&gt;fptr, struct_fptrs-&gt;len_fptr*sizeof(new_fptr[0]));</a>
<a name="ln1929">                    }</a>
<a name="ln1930">                    inchi_free( struct_fptrs-&gt;fptr );</a>
<a name="ln1931">                } else {</a>
<a name="ln1932">                    struct_fptrs-&gt;len_fptr = 0;</a>
<a name="ln1933">                    struct_fptrs-&gt;cur_fptr = 0;</a>
<a name="ln1934">                    struct_fptrs-&gt;max_fptr = 0;</a>
<a name="ln1935">                }</a>
<a name="ln1936">                struct_fptrs-&gt;len_fptr += ADD_LEN_STRUCT_FPTRS;</a>
<a name="ln1937">                struct_fptrs-&gt;fptr = new_fptr;</a>
<a name="ln1938">            } else {</a>
<a name="ln1939">                return _IS_FATAL;  /* new_fptr allocation error */</a>
<a name="ln1940">            }</a>
<a name="ln1941">        }</a>
<a name="ln1942">        if ( struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr] == EOF ) {</a>
<a name="ln1943">            return _IS_EOF;</a>
<a name="ln1944">        } else {</a>
<a name="ln1945">            if ( bUseFptr ) {</a>
<a name="ln1946">                if( fseek( inp_file-&gt;f, struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr], SEEK_SET) ) {</a>
<a name="ln1947">                    return _IS_FATAL;</a>
<a name="ln1948">                }</a>
<a name="ln1949">                if ( struct_fptrs-&gt;cur_fptr &amp;&amp; struct_fptrs-&gt;max_fptr &lt;= struct_fptrs-&gt;cur_fptr ) {</a>
<a name="ln1950">                    return _IS_FATAL;</a>
<a name="ln1951">                }</a>
<a name="ln1952">            } else {</a>
<a name="ln1953">                inp_index = struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr];</a>
<a name="ln1954">                out_index = EOF;</a>
<a name="ln1955">            }</a>
<a name="ln1956">        }</a>
<a name="ln1957">        *num_inp = struct_fptrs-&gt;cur_fptr; /* set structure count */</a>
<a name="ln1958">    }</a>
<a name="ln1959"> </a>
<a name="ln1960">    nRet = ReadTheStructure( sd, ip, inp_file, orig_inp_data, inp_index, &amp;out_index );</a>
<a name="ln1961"> </a>
<a name="ln1962">    if ( !nRet ) {</a>
<a name="ln1963">        /*****************************************************</a>
<a name="ln1964">         * In case of no error output structure xml start tag</a>
<a name="ln1965">         * output read the structure errors and warnings</a>
<a name="ln1966">         *****************************************************/</a>
<a name="ln1967">        if ( ip-&gt;nInputType == INPUT_INCHI_PLAIN || ip-&gt;nInputType == INPUT_INCHI_XML ||</a>
<a name="ln1968">             ip-&gt;nInputType == INPUT_MOLFILE     || ip-&gt;nInputType == INPUT_SDFILE) {</a>
<a name="ln1969">            if ( ip-&gt;lMolfileNumber ) {</a>
<a name="ln1970">                *num_inp = ip-&gt;lMolfileNumber;</a>
<a name="ln1971">            } else {</a>
<a name="ln1972">                *num_inp += 1;</a>
<a name="ln1973">            }</a>
<a name="ln1974">        } else {</a>
<a name="ln1975">            *num_inp += 1;</a>
<a name="ln1976">        }</a>
<a name="ln1977">        nRet = TreatReadTheStructureErrors( sd, ip, LOG_MASK_ALL, inp_file, log_file, output_file, prb_file,</a>
<a name="ln1978">                                            orig_inp_data, num_inp, pStr, nStrLen );</a>
<a name="ln1979">    }</a>
<a name="ln1980"> </a>
<a name="ln1981">    /************************************************************/</a>
<a name="ln1982">    /* added for TARGET_LIB_FOR_WINCHI: look ahead for end of file detection */</a>
<a name="ln1983">    /************************************************************/</a>
<a name="ln1984">    if ( struct_fptrs &amp;&amp; struct_fptrs-&gt;fptr &amp;&amp; struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr+1] &lt;= 0 ) {</a>
<a name="ln1985">        int nRet2 = 0;</a>
<a name="ln1986">        INCHI_FPTR next_fptr;</a>
<a name="ln1987">        STRUCT_DATA sd2;</a>
<a name="ln1988"> </a>
<a name="ln1989">        if ( nRet != _IS_EOF &amp;&amp; nRet != _IS_FATAL ) {</a>
<a name="ln1990">            if ( inp_file-&gt;f == stdin || struct_fptrs-&gt;len_fptr &lt;= struct_fptrs-&gt;cur_fptr+1 ) {</a>
<a name="ln1991">                return _IS_FATAL;</a>
<a name="ln1992">            }</a>
<a name="ln1993">            /* get next structure fptr */</a>
<a name="ln1994">            if ( bUseFptr ) {</a>
<a name="ln1995">                next_fptr = ftell( inp_file-&gt;f );</a>
<a name="ln1996">            } else {</a>
<a name="ln1997">                inp_index = out_index;</a>
<a name="ln1998">                out_index = EOF;</a>
<a name="ln1999">            }</a>
<a name="ln2000">            /* read the next structure */</a>
<a name="ln2001">            nRet2 = ReadTheStructure( &amp;sd2, ip, inp_file, NULL, inp_index, &amp;out_index );</a>
<a name="ln2002">            /* restore fptr to the next structure */</a>
<a name="ln2003">            if ( bUseFptr ) {</a>
<a name="ln2004">                if ( next_fptr != -1L ) {</a>
<a name="ln2005">                    fseek( inp_file-&gt;f, next_fptr, SEEK_SET);</a>
<a name="ln2006">                }</a>
<a name="ln2007">            }</a>
<a name="ln2008">#if ( ADD_CMLPP == 1 )</a>
<a name="ln2009">            else {</a>
<a name="ln2010">                if ( inp_index &gt;= 0 ) {</a>
<a name="ln2011">                    SetCmlStructIndex( inp_index ); /* so far nothing to do */</a>
<a name="ln2012">                }</a>
<a name="ln2013">            }</a>
<a name="ln2014">#endif</a>
<a name="ln2015">        } else {</a>
<a name="ln2016">            /* treat current fatal error as end of file */</a>
<a name="ln2017">            struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr] = EOF;</a>
<a name="ln2018">        }</a>
<a name="ln2019">        /* next is end of file or fatal */</a>
<a name="ln2020">        if ( nRet  == _IS_EOF || nRet  == _IS_FATAL ||</a>
<a name="ln2021">             nRet2 == _IS_EOF || nRet2 == _IS_FATAL ) {</a>
<a name="ln2022">            struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr+1] = EOF;</a>
<a name="ln2023">        } else {</a>
<a name="ln2024">            struct_fptrs-&gt;fptr[struct_fptrs-&gt;cur_fptr+1] = bUseFptr? sd-&gt;fPtrEnd : inp_index;</a>
<a name="ln2025">        }</a>
<a name="ln2026"> </a>
<a name="ln2027">        /* update struct_fptrs-&gt;max_fptr */</a>
<a name="ln2028">        if ( struct_fptrs-&gt;max_fptr &lt;= struct_fptrs-&gt;cur_fptr+1  ) {</a>
<a name="ln2029">            struct_fptrs-&gt;max_fptr = struct_fptrs-&gt;cur_fptr+2;</a>
<a name="ln2030">        }</a>
<a name="ln2031">    }</a>
<a name="ln2032"> </a>
<a name="ln2033">    switch ( nRet ) {</a>
<a name="ln2034">    case _IS_EOF:</a>
<a name="ln2035">        *num_inp -= 1;</a>
<a name="ln2036">    case _IS_FATAL:</a>
<a name="ln2037">    case _IS_ERROR:</a>
<a name="ln2038">    case _IS_SKIP:</a>
<a name="ln2039">        goto exit_function;</a>
<a name="ln2040">    }</a>
<a name="ln2041"> </a>
<a name="ln2042">    /*</a>
<a name="ln2043">    if ( !orig_inp_data-&gt;num_dimensions ) {</a>
<a name="ln2044">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;0D&quot;); */ /* 0D-structure: no coordinates</a>
<a name="ln2045">    }</a>
<a name="ln2046">    */</a>
<a name="ln2047"> </a>
<a name="ln2048"> </a>
<a name="ln2049">exit_function:</a>
<a name="ln2050">    return nRet;</a>
<a name="ln2051">}</a>
<a name="ln2052">#endif</a>
<a name="ln2053">#if ( TEST_RENUMB_ATOMS == 1 ) /* { */</a>
<a name="ln2054">/************************************************************************************************/</a>
<a name="ln2055">int RenumberingTestInit( RENUMB_DATA *pRenumbData, INP_ATOM_DATA *inp_cur_data )</a>
<a name="ln2056">{</a>
<a name="ln2057">    int j;</a>
<a name="ln2058">    pRenumbData-&gt;ren_inp_norm_data[0] = &amp;pRenumbData-&gt;ren_inp_norm_data1;</a>
<a name="ln2059">    pRenumbData-&gt;ren_inp_norm_data[1] = &amp;pRenumbData-&gt;ren_inp_norm_data2;</a>
<a name="ln2060">    memset( pRenumbData-&gt;ren_INChI2, 0, sizeof( pRenumbData-&gt;ren_INChI2 ));</a>
<a name="ln2061">    memset( pRenumbData-&gt;ren_INChI_Aux, 0, sizeof( pRenumbData-&gt;ren_INChI_Aux ));</a>
<a name="ln2062">    memset( &amp;pRenumbData-&gt;orig_inp_cur_data, 0, sizeof( pRenumbData-&gt;orig_inp_cur_data ));</a>
<a name="ln2063">    memset( &amp;pRenumbData-&gt;saved_inp_cur_data, 0, sizeof( pRenumbData-&gt;saved_inp_cur_data ));</a>
<a name="ln2064">    memset( pRenumbData-&gt;ren_inp_norm_data[0], 0, sizeof( *pRenumbData-&gt;ren_inp_norm_data[0] ));</a>
<a name="ln2065">    memset( pRenumbData-&gt;ren_inp_norm_data[1], 0, sizeof( *pRenumbData-&gt;ren_inp_norm_data[1] ));</a>
<a name="ln2066">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 )</a>
<a name="ln2067">    memset( &amp;pRenumbData-&gt;longest_inp_cur_data, 0, sizeof(pRenumbData-&gt;longest_inp_cur_data));</a>
<a name="ln2068">#endif</a>
<a name="ln2069">    CopyInpAtomData( &amp;pRenumbData-&gt;orig_inp_cur_data, inp_cur_data );</a>
<a name="ln2070">    pRenumbData-&gt;ren_counter = pRenumbData-&gt;orig_inp_cur_data.num_at * pRenumbData-&gt;orig_inp_cur_data.num_at;</a>
<a name="ln2071">    srand(1);  /*  for reproducibility */</a>
<a name="ln2072">    rand();    /*  shift to avoid prev. sequences */</a>
<a name="ln2073">    pRenumbData-&gt;nComp = 0;</a>
<a name="ln2074">    /*ren_counter = 29;*/</a>
<a name="ln2075">    pRenumbData-&gt;new_ord = (AT_RANK *)inchi_calloc( pRenumbData-&gt;orig_inp_cur_data.num_at, sizeof(pRenumbData-&gt;new_ord[0]) );</a>
<a name="ln2076">    if ( pRenumbData-&gt;new_ord ) {</a>
<a name="ln2077">        for ( j = 0; j &lt; pRenumbData-&gt;orig_inp_cur_data.num_at; j ++ ) {</a>
<a name="ln2078">            pRenumbData-&gt;new_ord[j] = (AT_RANK)j;</a>
<a name="ln2079">        }</a>
<a name="ln2080">        return 0;</a>
<a name="ln2081">    }</a>
<a name="ln2082">    return -1; /* out of RAM */</a>
<a name="ln2083">}</a>
<a name="ln2084">/************************************************************************************************/</a>
<a name="ln2085">int RenumberingTestUninit( RENUMB_DATA *pRenumbData )</a>
<a name="ln2086">{</a>
<a name="ln2087">    FreeInpAtomData( &amp;pRenumbData-&gt;orig_inp_cur_data );</a>
<a name="ln2088">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 )</a>
<a name="ln2089">    FreeInpAtomData( &amp;pRenumbData-&gt;longest_inp_cur_data );</a>
<a name="ln2090">#endif</a>
<a name="ln2091">    inchi_free( pRenumbData-&gt;new_ord );</a>
<a name="ln2092">    return 0;</a>
<a name="ln2093">}</a>
<a name="ln2094">/************************************************************************************************/</a>
<a name="ln2095">int RenumberingTest( PINChI2 *pINChI, PINChI_Aux2 *pINChI_Aux, ORIG_ATOM_DATA *orig_inp_data, int iINChI,</a>
<a name="ln2096">                     RENUMB_DATA *pRenumbData, INP_ATOM_DATA *inp_cur_data, INP_ATOM_DATA **inp_norm_data,</a>
<a name="ln2097">                     STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle, INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *prb_file,</a>
<a name="ln2098">                     int i, long num_inp, NORM_CANON_FLAGS *pncFlags)</a>
<a name="ln2099">{</a>
<a name="ln2100">    int k, bLongerTime;</a>
<a name="ln2101">    CopyInpAtomData( &amp;pRenumbData-&gt;saved_inp_cur_data, inp_cur_data );</a>
<a name="ln2102">    pRenumbData-&gt;nRet2 = 0;</a>
<a name="ln2103">    pRenumbData-&gt;num_taut0     = sd-&gt;num_taut[iINChI];</a>
<a name="ln2104">    pRenumbData-&gt;num_non_taut0 = sd-&gt;num_non_taut[iINChI];</a>
<a name="ln2105">    pRenumbData-&gt;ulMaxTime    = 0;</a>
<a name="ln2106">    while ( -- pRenumbData-&gt;ren_counter &gt;= 0 &amp;&amp; !pRenumbData-&gt;nRet2 ) {</a>
<a name="ln2107">        pRenumbData-&gt;nComp ++;</a>
<a name="ln2108">        MakeNewOrd( pRenumbData-&gt;orig_inp_cur_data.num_at, pRenumbData-&gt;new_ord );</a>
<a name="ln2109">        RenumbInpAtomData( inp_cur_data /* output*/, &amp;pRenumbData-&gt;orig_inp_cur_data/* input*/, pRenumbData-&gt;new_ord/* input*/ );</a>
<a name="ln2110">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 )</a>
<a name="ln2111">        CopyInpAtomData( &amp;pRenumbData-&gt;longest_inp_cur_data, inp_cur_data );</a>
<a name="ln2112">#endif</a>
<a name="ln2113">        if ( 470 == pRenumbData-&gt;nComp ) {</a>
<a name="ln2114">            int stop = 1; /* debug only */</a>
<a name="ln2115">        }</a>
<a name="ln2116"> </a>
<a name="ln2117">        pRenumbData-&gt;nRet2 = CreateOneComponentINChI( sd, ip, inp_cur_data, NULL /*orig_inp_data*/,</a>
<a name="ln2118">                                       pRenumbData-&gt;ren_INChI2, pRenumbData-&gt;ren_INChI_Aux, iINChI,</a>
<a name="ln2119">                                       0, num_inp, pRenumbData-&gt;ren_inp_norm_data, pncFlags, log_file );</a>
<a name="ln2120">        /*</a>
<a name="ln2121">        CreateOneComponentINChI( sd, ip, inp_cur_data, orig_inp_data, pINChI2[iINChI], pINChI_Aux2[iINChI], iINChI,</a>
<a name="ln2122">                                       i, num_inp, inp_norm_data, log_file );</a>
<a name="ln2123">        */</a>
<a name="ln2124">        if ( !pRenumbData-&gt;nRet2 ) {</a>
<a name="ln2125">            pRenumbData-&gt;c1 = CompareINChI( pINChI[i][TAUT_NON], pRenumbData-&gt;ren_INChI2[0][TAUT_NON],</a>
<a name="ln2126">                                           pINChI_Aux[i][TAUT_NON], pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]);</a>
<a name="ln2127">            pRenumbData-&gt;c2 = CompareINChI( pINChI[i][TAUT_YES], pRenumbData-&gt;ren_INChI2[0][TAUT_YES],</a>
<a name="ln2128">                                           pINChI_Aux[i][TAUT_YES], pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]);</a>
<a name="ln2129">            if ( pRenumbData-&gt;c1 || pRenumbData-&gt;c2 || pRenumbData-&gt;nRet2 ) {</a>
<a name="ln2130"> </a>
<a name="ln2131">                /****** the renumbering result is different ******/</a>
<a name="ln2132"> </a>
<a name="ln2133">                inchi_ios_eprint( log_file, &quot;Compare (%d,%d) %d (err=%d) %s structure #%d component %d.%s%s%s%s\n&quot;,</a>
<a name="ln2134">                                    pRenumbData-&gt;c1, pRenumbData-&gt;c2,</a>
<a name="ln2135">                                    pRenumbData-&gt;nComp, pRenumbData-&gt;nRet2, INCHI_NAME,</a>
<a name="ln2136">                                    num_inp, i+1, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2137">                for ( k = 0; k &lt; pRenumbData-&gt;orig_inp_cur_data.num_at; k ++ ) {</a>
<a name="ln2138">                    inchi_ios_eprint( log_file, &quot; %d&quot;, (int)pRenumbData-&gt;new_ord[k] );</a>
<a name="ln2139">                }</a>
<a name="ln2140">                inchi_ios_eprint( log_file, &quot;\n&quot; );</a>
<a name="ln2141">                pRenumbData-&gt;ren_counter = 0; /* force exit */</a>
<a name="ln2142">                pRenumbData-&gt;bRenumbErr = 1000*pRenumbData-&gt;c2 + pRenumbData-&gt;c1;</a>
<a name="ln2143">#if ( TEST_RENUMB_SWITCH == 1 )</a>
<a name="ln2144">                CopyInpAtomData( &amp;pRenumbData-&gt;longest_inp_cur_data, inp_cur_data );</a>
<a name="ln2145">                if ( pRenumbData-&gt;longest_inp_cur_data.at ) {</a>
<a name="ln2146">                    for ( k = 0; k &lt; pRenumbData-&gt;longest_inp_cur_data.num_at; k ++ ) {</a>
<a name="ln2147">                        pRenumbData-&gt;longest_inp_cur_data.at[k].orig_at_number = k+1; /* display new atom numbers */</a>
<a name="ln2148">                    }</a>
<a name="ln2149">                }</a>
<a name="ln2150">#endif</a>
<a name="ln2151">            }</a>
<a name="ln2152">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 )</a>
<a name="ln2153">            /*  output time per this component */</a>
<a name="ln2154">            inchi_ios_eprint( stderr, &quot;\rComp#%d str#%ld/%d%s%s%s%s Ren %d/%d n(%lu:%lu)c(%lu:%lu)...\r&quot;,</a>
<a name="ln2155">                                i+1, num_inp, iINChI, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), pRenumbData-&gt;nComp, pRenumbData-&gt;ren_counter+pRenumbData-&gt;nComp,</a>
<a name="ln2156">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulNormTime, pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulCanonTime,</a>
<a name="ln2157">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulNormTime, pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulCanonTime);</a>
<a name="ln2158">#endif</a>
<a name="ln2159">            /*  make sure the max. time is not overwritten */</a>
<a name="ln2160">            pRenumbData-&gt;ulCurTime0 = pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]?</a>
<a name="ln2161">                                      (pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulNormTime</a>
<a name="ln2162">                                     + pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulCanonTime) : 0;</a>
<a name="ln2163">            pRenumbData-&gt;ulCurTime1 = pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]?</a>
<a name="ln2164">                                      (pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulNormTime</a>
<a name="ln2165">                                      + pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulCanonTime) : 0;</a>
<a name="ln2166">            pRenumbData-&gt;ulCurTime  = inchi_max( pRenumbData-&gt;ulCurTime0, pRenumbData-&gt;ulCurTime1 );</a>
<a name="ln2167"> </a>
<a name="ln2168">            pRenumbData-&gt;ulCurTimeCanon0 = pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulCanonTime : 0;</a>
<a name="ln2169">            pRenumbData-&gt;ulCurTimeCanon1 = pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulCanonTime : 0;</a>
<a name="ln2170">            pRenumbData-&gt;ulCurTimeCanon  = inchi_max( pRenumbData-&gt;ulCurTimeCanon0, pRenumbData-&gt;ulCurTimeCanon1);</a>
<a name="ln2171"> </a>
<a name="ln2172">            pRenumbData-&gt;ulCurTimeNorm0 = pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulNormTime:0;</a>
<a name="ln2173">            pRenumbData-&gt;ulCurTimeNorm1 = pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulNormTime:0;</a>
<a name="ln2174">            pRenumbData-&gt;ulCurTimeNorm  = inchi_max( pRenumbData-&gt;ulCurTimeNorm0, pRenumbData-&gt;ulCurTimeNorm1);</a>
<a name="ln2175"> </a>
<a name="ln2176"> </a>
<a name="ln2177">            bLongerTime = 0;</a>
<a name="ln2178">            if ( pRenumbData-&gt;ulCurTime &gt; pRenumbData-&gt;ulMaxTime ) {</a>
<a name="ln2179">                pRenumbData-&gt;ulMaxTime = pRenumbData-&gt;ulCurTime;</a>
<a name="ln2180">                bLongerTime = 1;</a>
<a name="ln2181">            }</a>
<a name="ln2182">            if ( pRenumbData-&gt;ulMaxTimeCanon &gt; pRenumbData-&gt;ulCurTimeCanon ) {</a>
<a name="ln2183">                pRenumbData-&gt;ulMaxTimeCanon = pRenumbData-&gt;ulCurTimeCanon;</a>
<a name="ln2184">                bLongerTime = 1;</a>
<a name="ln2185">            }</a>
<a name="ln2186">            if ( pRenumbData-&gt;ulMaxTimeNorm &gt; pRenumbData-&gt;ulCurTimeCanon ) {</a>
<a name="ln2187">                pRenumbData-&gt;ulMaxTimeCanon = pRenumbData-&gt;ulCurTimeCanon;</a>
<a name="ln2188">                bLongerTime = 1;</a>
<a name="ln2189">            }</a>
<a name="ln2190">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 || TEST_RENUMB_SWITCH == 1 )</a>
<a name="ln2191">            if ( bLongerTime || TEST_RENUMB_SWITCH == 1 &amp;&amp; (pRenumbData-&gt;c1 || pRenumbData-&gt;c2 || pRenumbData-&gt;nRet2) ) {</a>
<a name="ln2192">                char szLine[512];</a>
<a name="ln2193">                char szValue[512];</a>
<a name="ln2194">                inchi_ios_eprint( stderr, &quot;\n&quot; );</a>
<a name="ln2195">                sprintf( szLine, &quot;Comp#%d str#%ld/%d%s%s%s%s Ren %d/%d n=%lu:%lu c=%lu:%lu&quot;,</a>
<a name="ln2196">                                i+1, num_inp, iINChI, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), pRenumbData-&gt;nComp, pRenumbData-&gt;ren_counter+pRenumbData-&gt;nComp,</a>
<a name="ln2197">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulNormTime:0,</a>
<a name="ln2198">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulCanonTime:0,</a>
<a name="ln2199">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulNormTime:0,</a>
<a name="ln2200">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulCanonTime:0);</a>
<a name="ln2201">                sprintf( szValue, &quot;%s (c%d/s%ld/i%d, r%d/%d n=%lu:%lu c=%lu:%lu)&quot;,</a>
<a name="ln2202">                                  (ip-&gt;pSdfValue &amp;&amp; ip-&gt;pSdfValue[0])? ip-&gt;pSdfValue:&quot;unk&quot;,</a>
<a name="ln2203">                                i+1, num_inp, iINChI, pRenumbData-&gt;nComp, pRenumbData-&gt;ren_counter+pRenumbData-&gt;nComp,</a>
<a name="ln2204">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulNormTime:0,</a>
<a name="ln2205">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON]-&gt;ulCanonTime:0,</a>
<a name="ln2206">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulNormTime:0,</a>
<a name="ln2207">                                pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]? pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES]-&gt;ulCanonTime:0);</a>
<a name="ln2208"> </a>
<a name="ln2209">                WriteToSDfile( &amp;pRenumbData-&gt;longest_inp_cur_data, prb_file, szLine, NULL, ip-&gt;pSdfLabel, szValue );</a>
<a name="ln2210">            }</a>
<a name="ln2211">#endif</a>
<a name="ln2212"> </a>
<a name="ln2213">#if ( TEST_RENUMB_SWITCH == 1 )</a>
<a name="ln2214">            if ( pRenumbData-&gt;c1 || pRenumbData-&gt;c2 || !pRenumbData-&gt;ren_counter ) {</a>
<a name="ln2215">                inchi_swap( (char*)&amp;pINChI[i][TAUT_NON], (char*)&amp;pRenumbData-&gt;ren_INChI2[0][TAUT_NON], sizeof(&amp;pRenumbData-&gt;ren_INChI2[0][0]) );</a>
<a name="ln2216">                inchi_swap( (char*)&amp;pINChI[i][TAUT_YES], (char*)&amp;pRenumbData-&gt;ren_INChI2[0][TAUT_YES], sizeof(&amp;pRenumbData-&gt;ren_INChI2[0][0]) );</a>
<a name="ln2217">                inchi_swap( (char*)&amp;pINChI_Aux[i][TAUT_NON], (char*)&amp;pRenumbData-&gt;ren_INChI_Aux[0][TAUT_NON], sizeof(&amp;pRenumbData-&gt;ren_INChI_Aux[0][0]) );</a>
<a name="ln2218">                inchi_swap( (char*)&amp;pINChI_Aux[i][TAUT_YES], (char*)&amp;pRenumbData-&gt;ren_INChI_Aux[0][TAUT_YES], sizeof(&amp;pRenumbData-&gt;ren_INChI_Aux[0][0]) );</a>
<a name="ln2219">            }</a>
<a name="ln2220">#endif</a>
<a name="ln2221">        }</a>
<a name="ln2222"> </a>
<a name="ln2223">        for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln2224">            if ( pRenumbData-&gt;ren_INChI2[0][k] ) {</a>
<a name="ln2225">                Free_INChI(&amp;pRenumbData-&gt;ren_INChI2[0][k]);</a>
<a name="ln2226">                /*</a>
<a name="ln2227">                inchi_free(pRenumbData-&gt;ren_INChI2[0][k]);</a>
<a name="ln2228">                pRenumbData-&gt;ren_INChI2[0][k] = NULL;</a>
<a name="ln2229">                */</a>
<a name="ln2230">            }</a>
<a name="ln2231">            if ( pRenumbData-&gt;ren_INChI_Aux[0][k] ) {</a>
<a name="ln2232">                Free_INChI_Aux(&amp;pRenumbData-&gt;ren_INChI_Aux[0][k]);</a>
<a name="ln2233">                /*</a>
<a name="ln2234">                inchi_free(pRenumbData-&gt;ren_INChI_Aux[0][k]);</a>
<a name="ln2235">                pRenumbData-&gt;ren_INChI_Aux[0][k] = NULL;</a>
<a name="ln2236">                */</a>
<a name="ln2237">            }</a>
<a name="ln2238">        }</a>
<a name="ln2239">    }</a>
<a name="ln2240">    /*  eliminate overcounting due to multiple renumberings/recalculations */</a>
<a name="ln2241">    pRenumbData-&gt;num_taut         = sd-&gt;num_taut[iINChI] - pRenumbData-&gt;num_taut0;</a>
<a name="ln2242">    pRenumbData-&gt;num_non_taut     = sd-&gt;num_non_taut[iINChI] - pRenumbData-&gt;num_non_taut0;</a>
<a name="ln2243">    sd-&gt;num_taut[iINChI]     = pRenumbData-&gt;num_taut0;</a>
<a name="ln2244">    sd-&gt;num_non_taut[iINChI] = pRenumbData-&gt;num_non_taut0;</a>
<a name="ln2245">    if ( pRenumbData-&gt;num_taut % pRenumbData-&gt;nComp || pRenumbData-&gt;num_non_taut % pRenumbData-&gt;nComp ) {</a>
<a name="ln2246">        inchi_ios_eprint( log_file, &quot;Compare (%d,%d) %d (err=%d) %s structure #%ld component %d.%s%s%s%s\n&quot;,</a>
<a name="ln2247">                    pRenumbData-&gt;num_non_taut % pRenumbData-&gt;nComp, pRenumbData-&gt;num_taut % pRenumbData-&gt;nComp,</a>
<a name="ln2248">                    pRenumbData-&gt;nComp, 333, INCHI_NAME, num_inp, i+1, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2249">    }</a>
<a name="ln2250">#if ( TEST_RENUMB_SWITCH == 1 )  /* { */</a>
<a name="ln2251">    CopyInpAtomData( inp_norm_data[TAUT_NON], pRenumbData-&gt;ren_inp_norm_data[TAUT_NON] );</a>
<a name="ln2252">    CopyInpAtomData( inp_norm_data[TAUT_YES], pRenumbData-&gt;ren_inp_norm_data[TAUT_YES] );</a>
<a name="ln2253">    /*  renumbered input structure */</a>
<a name="ln2254">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln2255">    if ( /*ip-&gt;bDisplayEachComponentINChI &amp;&amp;*/ !pRenumbData-&gt;nRet2 ) {</a>
<a name="ln2256">        int err, len;</a>
<a name="ln2257">        /*</a>
<a name="ln2258">        err = DisplayStructure( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at, 0, 1, 0, NULL. 1, 0, NULL, NULL,</a>
<a name="ln2259">                                            ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln2260">        */</a>
<a name="ln2261">        err = DisplayStructure( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at, 0, 1, 0, NULL, 1/*isotopic*/, 0/*taut*/, NULL, NULL,</a>
<a name="ln2262">                                            ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln2263">        if ( pRenumbData-&gt;c1 || pRenumbData-&gt;c2 ) {</a>
<a name="ln2264">            len = strlen(szTitle);</a>
<a name="ln2265">            strcat( szTitle, &quot; (Renumbered)&quot; );</a>
<a name="ln2266">            err = DisplayStructure( pRenumbData-&gt;longest_inp_cur_data.at, pRenumbData-&gt;longest_inp_cur_data.num_at,</a>
<a name="ln2267">                                    0, 1, 0, NULL, 1, 0, NULL, NULL, ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln2268">            szTitle[len] = '\0';</a>
<a name="ln2269">        }</a>
<a name="ln2270">        sd-&gt;bUserQuitComponentDisplay = (err==ESC_KEY);</a>
<a name="ln2271">        if ( !err ) {</a>
<a name="ln2272">            inchi_ios_eprint( stderr, &quot;Cannot display the structure\n&quot;);</a>
<a name="ln2273">        }</a>
<a name="ln2274">    }</a>
<a name="ln2275">#endif  /* } COMPILE_ANSI_ONLY */</a>
<a name="ln2276">#else /* } TEST_RENUMB_SWITCH { */</a>
<a name="ln2277">    CopyInpAtomData( inp_cur_data, &amp;pRenumbData-&gt;saved_inp_cur_data );</a>
<a name="ln2278">#endif /* } TEST_RENUMB_SWITCH */</a>
<a name="ln2279">    FreeInpAtomData( &amp;pRenumbData-&gt;saved_inp_cur_data );</a>
<a name="ln2280">    FreeInpAtomData( pRenumbData-&gt;ren_inp_norm_data[TAUT_NON] );</a>
<a name="ln2281">    FreeInpAtomData( pRenumbData-&gt;ren_inp_norm_data[TAUT_YES] );</a>
<a name="ln2282">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 || TEST_RENUMB_SWITCH == 1 )</a>
<a name="ln2283">    FreeInpAtomData( &amp;pRenumbData-&gt;longest_inp_cur_data );</a>
<a name="ln2284">#endif</a>
<a name="ln2285">    return pRenumbData-&gt;nRet2;</a>
<a name="ln2286">}</a>
<a name="ln2287">#endif  /* } TEST_RENUMB_ATOMS  */</a>
<a name="ln2288"> </a>
<a name="ln2289">/****************************************************************************/</a>
<a name="ln2290">int bCheckUnusualValences( ORIG_ATOM_DATA *orig_at_data, int bAddIsoH, char *pStrErrStruct )</a>
<a name="ln2291">{</a>
<a name="ln2292">    int i, val, num_found = 0;</a>
<a name="ln2293">    char msg[32];</a>
<a name="ln2294">    int len, num_H;</a>
<a name="ln2295">    inp_ATOM *at = ( orig_at_data &amp;&amp; orig_at_data-&gt;num_inp_atoms &gt; 0 )? orig_at_data-&gt;at : NULL;</a>
<a name="ln2296"> </a>
<a name="ln2297">    if ( at ) {</a>
<a name="ln2298">        for ( i = 0, num_found = 0; i &lt; orig_at_data-&gt;num_inp_atoms; i ++ ) {</a>
<a name="ln2299">            num_H = bAddIsoH? NUMH(at,i) : at[i].num_H;</a>
<a name="ln2300">            val = detect_unusual_el_valence( at[i].el_number, at[i].charge, at[i].radical,</a>
<a name="ln2301">                                          at[i].chem_bonds_valence, num_H, at[i].valence );</a>
<a name="ln2302">            if ( val ) {</a>
<a name="ln2303">                num_found ++;</a>
<a name="ln2304">                /* produce message */</a>
<a name="ln2305">                AddMOLfileError(pStrErrStruct, &quot;Accepted unusual valence(s):&quot;);</a>
<a name="ln2306">                len = sprintf( msg, &quot;%s&quot;, at[i].elname );</a>
<a name="ln2307">                if ( at[i].charge ) {</a>
<a name="ln2308">                    len += sprintf( msg+len, &quot;%+d&quot;, at[i].charge );</a>
<a name="ln2309">                }</a>
<a name="ln2310">                if ( at[i].radical ) {</a>
<a name="ln2311">                    len += sprintf( msg + len, &quot;,%s&quot;, at[i].radical == RADICAL_SINGLET? &quot;s&quot; :</a>
<a name="ln2312">                                                      at[i].radical == RADICAL_DOUBLET? &quot;d&quot; :</a>
<a name="ln2313">                                                      at[i].radical == RADICAL_TRIPLET? &quot;t&quot; : &quot;?&quot; );</a>
<a name="ln2314">                }</a>
<a name="ln2315">                len += sprintf( msg + len, &quot;(%d)&quot;, val ); </a>
<a name="ln2316">                AddMOLfileError(pStrErrStruct, msg);</a>
<a name="ln2317">            }</a>
<a name="ln2318">        }</a>
<a name="ln2319">    }</a>
<a name="ln2320">    return num_found;</a>
<a name="ln2321">}</a>
<a name="ln2322">/***************************************************************************/</a>
<a name="ln2323">int PreprocessOneStructure( STRUCT_DATA *sd, INPUT_PARMS *ip, ORIG_ATOM_DATA *orig_inp_data, ORIG_ATOM_DATA *prep_inp_data )</a>
<a name="ln2324">{        </a>
<a name="ln2325">        int i;</a>
<a name="ln2326">    INCHI_MODE bTautFlags     = 0;</a>
<a name="ln2327">    INCHI_MODE bTautFlagsDone = 0;</a>
<a name="ln2328">    /*************************************************/</a>
<a name="ln2329">    /* 1. copy orig_inp_data --&gt; prep_inp_data */</a>
<a name="ln2330">    /*************************************************/</a>
<a name="ln2331">    if ( 0 &gt; DuplicateOrigAtom( prep_inp_data, orig_inp_data ) ) {</a>
<a name="ln2332">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Out of RAM&quot;);</a>
<a name="ln2333">        sd-&gt;nStructReadError =  99;</a>
<a name="ln2334">        sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln2335">        goto exit_function;</a>
<a name="ln2336">    }</a>
<a name="ln2337">#if ( bRELEASE_VERSION == 0 &amp;&amp; (EXTR_HAS_METAL_ATOM &amp; (EXTR_MASK | EXTR_FLAG) ) )</a>
<a name="ln2338">        if ( bHasMetalAtom( orig_inp_data ) ) {</a>
<a name="ln2339">            sd-&gt;bExtract |= EXTR_HAS_METAL_ATOM;</a>
<a name="ln2340">        }</a>
<a name="ln2341">#endif</a>
<a name="ln2342"> </a>
<a name="ln2343">    /*************************************************/</a>
<a name="ln2344">    /* 2. fix odd things in prep_inp_data            */</a>
<a name="ln2345">    /*************************************************/</a>
<a name="ln2346"> </a>
<a name="ln2347">    if ( 0 &lt; fix_odd_things( prep_inp_data-&gt;num_inp_atoms, prep_inp_data-&gt;at, /*0*/ip-&gt;bTautFlags &amp; TG_FLAG_FIX_SP3_BUG, ip-&gt;bFixNonUniformDraw ) ) { /* changed 2010-03-17 DT */</a>
<a name="ln2348">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Charges were rearranged&quot;);</a>
<a name="ln2349">        if ( sd-&gt;nErrorType &lt; _IS_WARNING ) {</a>
<a name="ln2350">            sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln2351">        }</a>
<a name="ln2352">        sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln2353">    }</a>
<a name="ln2354">#if ( FIX_ADJ_RAD == 1 )</a>
<a name="ln2355">    if ( ip-&gt;bTautFlags &amp; TG_FLAG_FIX_ADJ_RADICALS ) {</a>
<a name="ln2356">        if ( 0 &lt; FixAdjacentRadicals( prep_inp_data-&gt;num_inp_atoms, prep_inp_data-&gt;at ) ) {</a>
<a name="ln2357">            sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FIX_ADJ_RADICALS_DONE;</a>
<a name="ln2358">        }</a>
<a name="ln2359">    }</a>
<a name="ln2360">#endif</a>
<a name="ln2361">#if ( bRELEASE_VERSION == 0 &amp;&amp; (EXTR_FLAGS &amp; EXTR_HAS_FEATURE) )</a>
<a name="ln2362">    if ( bFoundFeature( prep_inp_data-&gt;at, prep_inp_data-&gt;num_inp_atoms ) ) {</a>
<a name="ln2363">        sd-&gt;bExtract |= EXTR_HAS_FEATURE;</a>
<a name="ln2364">    }</a>
<a name="ln2365">#endif</a>
<a name="ln2366"> </a>
<a name="ln2367">    /*******************************************************************</a>
<a name="ln2368">     * Find whether the structure can be disconnected or is a salt</a>
<a name="ln2369">     *******************************************************************/</a>
<a name="ln2370"> </a>
<a name="ln2371"> </a>
<a name="ln2372">    /* needs salt disconnection? */</a>
<a name="ln2373">    if ( ip-&gt;bTautFlags &amp; TG_FLAG_DISCONNECT_SALTS ) {</a>
<a name="ln2374">        prep_inp_data-&gt;bDisconnectSalts = (0 &lt; DisconnectSalts( prep_inp_data, 0 ));</a>
<a name="ln2375">    } else {</a>
<a name="ln2376">        prep_inp_data-&gt;bDisconnectSalts = 0;</a>
<a name="ln2377">    }</a>
<a name="ln2378">    /* needs metal disconnection? */</a>
<a name="ln2379">    if ( ip-&gt;bTautFlags &amp; TG_FLAG_DISCONNECT_COORD ) {</a>
<a name="ln2380">        i = (0 != (ip-&gt;bTautFlags &amp; TG_FLAG_CHECK_VALENCE_COORD));</a>
<a name="ln2381">        bMayDisconnectMetals( prep_inp_data, i, &amp;bTautFlagsDone ); /* changes prep_inp_data-&gt;bDisconnectCoord */</a>
<a name="ln2382">        sd-&gt;bTautFlagsDone[INCHI_BAS] |= bTautFlagsDone; /* whether any disconnection has been rejected because of the metal proper valence */</a>
<a name="ln2383">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2384">        if ( i &amp;&amp; (bTautFlagsDone &amp; TG_FLAG_CHECK_VALENCE_COORD_DONE) ) {</a>
<a name="ln2385">            sd-&gt;bExtract |= EXTR_METAL_WAS_NOT_DISCONNECTED;</a>
<a name="ln2386">        }</a>
<a name="ln2387">#endif</a>
<a name="ln2388">    } else {</a>
<a name="ln2389">        prep_inp_data-&gt;bDisconnectCoord = 0;</a>
<a name="ln2390">    }</a>
<a name="ln2391">    orig_inp_data-&gt;bDisconnectSalts = prep_inp_data-&gt;bDisconnectSalts;</a>
<a name="ln2392">    orig_inp_data-&gt;bDisconnectCoord = prep_inp_data-&gt;bDisconnectCoord;</a>
<a name="ln2393"> </a>
<a name="ln2394">    /*************************************************/</a>
<a name="ln2395">    /* 3. if( orig_inp_data-&gt;bDisconnectSalts ) then */</a>
<a name="ln2396">    /*       -- disconnect salts in prep_inp_data */</a>
<a name="ln2397">    /*************************************************/</a>
<a name="ln2398"> </a>
<a name="ln2399">    if ( ( ip-&gt;bTautFlags &amp; TG_FLAG_DISCONNECT_SALTS ) &amp;&amp; prep_inp_data-&gt;bDisconnectSalts &amp;&amp;</a>
<a name="ln2400">         0 &lt; (i=DisconnectSalts( prep_inp_data, 1 )) ) {</a>
<a name="ln2401">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Salt was disconnected&quot;);</a>
<a name="ln2402">        sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_DISCONNECT_SALTS_DONE;</a>
<a name="ln2403">        if ( sd-&gt;nErrorType &lt; _IS_WARNING ) {</a>
<a name="ln2404">            sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln2405">        }</a>
<a name="ln2406">        if ( (i = ReconcileAllCmlBondParities( prep_inp_data-&gt;at, prep_inp_data-&gt;num_inp_atoms, 0 )) ) {</a>
<a name="ln2407">            char szErrCode[16];</a>
<a name="ln2408">            sprintf( szErrCode, &quot;%d&quot;, i);</a>
<a name="ln2409">            AddMOLfileError( sd-&gt;pStrErrStruct, &quot;0D Parities Reconciliation failed:&quot; );</a>
<a name="ln2410">            AddMOLfileError( sd-&gt;pStrErrStruct, szErrCode );</a>
<a name="ln2411">        }</a>
<a name="ln2412">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2413">        sd-&gt;bExtract |= EXTR_SALT_WAS_DISCONNECTED;</a>
<a name="ln2414">#endif</a>
<a name="ln2415">    } else {</a>
<a name="ln2416">        prep_inp_data-&gt;bDisconnectSalts = 0;</a>
<a name="ln2417">    }</a>
<a name="ln2418"> </a>
<a name="ln2419">    /***********************************************************/</a>
<a name="ln2420">    /*  mark the (disconnected) components in prep_inp_data    */</a>
<a name="ln2421">    /***********************************************************/</a>
<a name="ln2422"> </a>
<a name="ln2423">    prep_inp_data-&gt;num_components = MarkDisconnectedComponents( prep_inp_data, 0 );</a>
<a name="ln2424"> </a>
<a name="ln2425">    if ( prep_inp_data-&gt;num_components &lt; 0 ) {</a>
<a name="ln2426">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Out of RAM&quot;);</a>
<a name="ln2427">        sd-&gt;nStructReadError =  99;</a>
<a name="ln2428">        sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln2429">        goto exit_function;</a>
<a name="ln2430">    }</a>
<a name="ln2431"> </a>
<a name="ln2432">    /***********************************************************/</a>
<a name="ln2433">    /* Detect isotopic H on heteroatoms -- necessary condition */</a>
<a name="ln2434">    /* for global isotopic tautomerism                         */</a>
<a name="ln2435">    /***********************************************************/</a>
<a name="ln2436"> </a>
<a name="ln2437">    if ( (i = bNumHeterAtomHasIsotopicH( prep_inp_data-&gt;at, prep_inp_data-&gt;num_inp_atoms )) ) {</a>
<a name="ln2438">        if ( i &amp; 1 ) {</a>
<a name="ln2439">            sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FOUND_ISOTOPIC_H_DONE;</a>
<a name="ln2440">        }</a>
<a name="ln2441">        if ( i &amp; 2 ) {</a>
<a name="ln2442">            sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE;</a>
<a name="ln2443">        }</a>
<a name="ln2444">    }</a>
<a name="ln2445"> </a>
<a name="ln2446"> </a>
<a name="ln2447">    /****************************************************************************/</a>
<a name="ln2448">    /* 4a. Detect unusual valences                                              */</a>
<a name="ln2449">    /*     should be called before metal disconnection                          */</a>
<a name="ln2450">    /****************************************************************************/</a>
<a name="ln2451"> </a>
<a name="ln2452"> </a>
<a name="ln2453">    if ( bCheckUnusualValences( prep_inp_data, 1, sd-&gt;pStrErrStruct ) ) {</a>
<a name="ln2454">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2455">        sd-&gt;bExtract |= EXTR_UNUSUAL_VALENCES;</a>
<a name="ln2456">#else</a>
<a name="ln2457">        ;</a>
<a name="ln2458">#endif</a>
<a name="ln2459">    }</a>
<a name="ln2460">    /***********************************************************/</a>
<a name="ln2461">    /*    5. if( orig_inp_data-&gt;bDisconnectCoord ) then        */</a>
<a name="ln2462">    /*        -- copy prep_inp_data --&gt; prep_inp_data+1        */</a>
<a name="ln2463">    /*        -- disconnect metals in prep_inp_data            */</a>
<a name="ln2464">    /***********************************************************/</a>
<a name="ln2465"> </a>
<a name="ln2466">    if ( prep_inp_data-&gt;bDisconnectCoord ) {</a>
<a name="ln2467"> </a>
<a name="ln2468">        prep_inp_data-&gt;num_components = MarkDisconnectedComponents( prep_inp_data, 0 );</a>
<a name="ln2469">        if ( prep_inp_data-&gt;num_components &lt; 0 ) {</a>
<a name="ln2470">            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Out of RAM&quot;);</a>
<a name="ln2471">            sd-&gt;nStructReadError =  99;</a>
<a name="ln2472">            sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln2473">            goto exit_function;</a>
<a name="ln2474">        }</a>
<a name="ln2475">        /* save Reconnected structure in prep_inp_data+1 if requested */</a>
<a name="ln2476">        if ( 0 != ( ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD) ) {</a>
<a name="ln2477">            if ( 0 &gt; DuplicateOrigAtom( prep_inp_data+1, prep_inp_data ) ) {</a>
<a name="ln2478">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Out of RAM&quot;);</a>
<a name="ln2479">                sd-&gt;nStructReadError =  99;</a>
<a name="ln2480">                sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln2481">                goto exit_function;</a>
<a name="ln2482">            }</a>
<a name="ln2483">            sd-&gt;bTautFlags[INCHI_REC]     = sd-&gt;bTautFlags[INCHI_BAS];</a>
<a name="ln2484">            sd-&gt;bTautFlagsDone[INCHI_REC] = sd-&gt;bTautFlagsDone[INCHI_BAS];</a>
<a name="ln2485">            {   /* remove &quot;parity undefined in disconnected structure&quot; flag from reconnected structure */</a>
<a name="ln2486">                int k, m, p;</a>
<a name="ln2487">                inp_ATOM *at     = (prep_inp_data+1)-&gt;at;</a>
<a name="ln2488">                int       num_at = (prep_inp_data+1)-&gt;num_inp_atoms;</a>
<a name="ln2489">                for ( k = 0; k &lt; num_at; k ++ ) {</a>
<a name="ln2490">                    for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; (p=at[k].sb_parity[m]); m ++ ) {</a>
<a name="ln2491">                        at[k].sb_parity[m] &amp;= SB_PARITY_MASK;</a>
<a name="ln2492">                    }</a>
<a name="ln2493">                }</a>
<a name="ln2494">            }</a>
<a name="ln2495">        }</a>
<a name="ln2496"> </a>
<a name="ln2497">        /* make Disconnected structure in prep_inp_data */</a>
<a name="ln2498">        i = (0 != ( ip-&gt;bTautFlags &amp; TG_FLAG_CHECK_VALENCE_COORD ));</a>
<a name="ln2499">        /* prep_inp_data-&gt;bDisconnectCoord &gt; 1 means add prep_inp_data-&gt;bDisconnectCoord-1 explicit H atoms */</a>
<a name="ln2500">        if ( 0 &lt; (i = DisconnectMetals( prep_inp_data, i, &amp;bTautFlagsDone ) ) ) {</a>
<a name="ln2501">            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Metal was disconnected&quot;);</a>
<a name="ln2502">            sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_DISCONNECT_COORD_DONE;</a>
<a name="ln2503">            if ( sd-&gt;nErrorType &lt; _IS_WARNING ) {</a>
<a name="ln2504">                sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln2505">            }</a>
<a name="ln2506">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2507">            sd-&gt;bExtract |= EXTR_METAL_WAS_DISCONNECTED;</a>
<a name="ln2508">#endif</a>
<a name="ln2509">            /* last parm=1 means find link between unchanged by Metal Disconnection components */</a>
<a name="ln2510">            prep_inp_data-&gt;num_components = MarkDisconnectedComponents( prep_inp_data, 1 );</a>
<a name="ln2511">            if ( prep_inp_data-&gt;num_components &lt; 0 ) {</a>
<a name="ln2512">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Out of RAM&quot;);</a>
<a name="ln2513">                sd-&gt;nStructReadError =  99;</a>
<a name="ln2514">                sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln2515">                goto exit_function;</a>
<a name="ln2516">            }</a>
<a name="ln2517"> </a>
<a name="ln2518">            {   /* set parities for the disconnected structure */</a>
<a name="ln2519">                int k, m, p;</a>
<a name="ln2520">                inp_ATOM *at     = (prep_inp_data)-&gt;at;</a>
<a name="ln2521">                int       num_at = (prep_inp_data)-&gt;num_inp_atoms;</a>
<a name="ln2522">                for ( k = 0; k &lt; num_at; k ++ ) {</a>
<a name="ln2523">                    for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; (p=at[k].sb_parity[m]); m ++ ) {</a>
<a name="ln2524">                        if ( p &amp; SB_PARITY_FLAG ) {</a>
<a name="ln2525">                            at[k].sb_parity[m] = (p &gt;&gt; SB_PARITY_SHFT) &amp; SB_PARITY_MASK;</a>
<a name="ln2526">                        }</a>
<a name="ln2527">                    }</a>
<a name="ln2528">                }</a>
<a name="ln2529">            }</a>
<a name="ln2530"> </a>
<a name="ln2531">            if ( (i = ReconcileAllCmlBondParities( prep_inp_data-&gt;at, prep_inp_data-&gt;num_inp_atoms, 1 )) ) {</a>
<a name="ln2532">                char szErrCode[16];</a>
<a name="ln2533">                sprintf( szErrCode, &quot;%d&quot;, i);</a>
<a name="ln2534">                AddMOLfileError( sd-&gt;pStrErrStruct, &quot;0D Parities Reconciliation failed:&quot; );</a>
<a name="ln2535">                AddMOLfileError( sd-&gt;pStrErrStruct, szErrCode );</a>
<a name="ln2536">            }</a>
<a name="ln2537"> </a>
<a name="ln2538">#if ( REMOVE_ION_PAIRS_DISC_STRU == 1 )</a>
<a name="ln2539">            if ( 0 &lt; remove_ion_pairs( prep_inp_data-&gt;num_inp_atoms, prep_inp_data-&gt;at ) ) {</a>
<a name="ln2540">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Charges were rearranged&quot;);</a>
<a name="ln2541">                if ( sd-&gt;nErrorType &lt; _IS_WARNING ) {</a>
<a name="ln2542">                    sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln2543">                }</a>
<a name="ln2544">                sd-&gt;bTautFlagsDone[INCHI_REC] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln2545">                sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln2546">            }</a>
<a name="ln2547">#endif</a>
<a name="ln2548"> </a>
<a name="ln2549">            /*</a>
<a name="ln2550">              if prep_inp_data-&gt;nOldCompNumber[i] = iINChI+1 &gt; 0 then</a>
<a name="ln2551">              component #(i+1) in prep_inp_data is identical to component #(iINChI+1) in prep_inp_data+1</a>
<a name="ln2552">            */</a>
<a name="ln2553">        } else</a>
<a name="ln2554">        if ( i &lt; 0 ) {</a>
<a name="ln2555">            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot disconnect metal error&quot;);</a>
<a name="ln2556">            sd-&gt;nStructReadError =  i;</a>
<a name="ln2557">            sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln2558">            goto exit_function;</a>
<a name="ln2559">        }</a>
<a name="ln2560">    } else </a>
<a name="ln2561">    {   /* remove &quot;disconnected structure parities&quot; from the structure */</a>
<a name="ln2562">        int k, m, p;</a>
<a name="ln2563">        inp_ATOM *at     = (prep_inp_data)-&gt;at;</a>
<a name="ln2564">        int       num_at = (prep_inp_data)-&gt;num_inp_atoms;</a>
<a name="ln2565">        for ( k = 0; k &lt; num_at; k ++ ) {</a>
<a name="ln2566">            for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; (p=at[k].sb_parity[m]); m ++ ) {</a>
<a name="ln2567">                at[k].sb_parity[m] &amp;= SB_PARITY_MASK;</a>
<a name="ln2568">            }</a>
<a name="ln2569">        }</a>
<a name="ln2570">    }</a>
<a name="ln2571"> </a>
<a name="ln2572"> </a>
<a name="ln2573">exit_function:</a>
<a name="ln2574"> </a>
<a name="ln2575">    if ( sd-&gt;nErrorType &lt; _IS_ERROR &amp;&amp; prep_inp_data ) {</a>
<a name="ln2576"> </a>
<a name="ln2577">        if ( 0 &lt; post_fix_odd_things( prep_inp_data-&gt;num_inp_atoms, prep_inp_data-&gt;at ) ) {</a>
<a name="ln2578">            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Charges were rearranged&quot;);</a>
<a name="ln2579">            if ( sd-&gt;nErrorType &lt; _IS_WARNING ) {</a>
<a name="ln2580">                sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln2581">            }</a>
<a name="ln2582">            sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln2583">        }</a>
<a name="ln2584">        if ( (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; TG_FLAG_DISCONNECT_COORD_DONE) &amp;&amp;</a>
<a name="ln2585">             (prep_inp_data+1)-&gt;at &amp;&amp; (prep_inp_data+1)-&gt;num_inp_atoms &gt; 0 ) {</a>
<a name="ln2586">            if ( 0 &lt; post_fix_odd_things( (prep_inp_data+1)-&gt;num_inp_atoms, (prep_inp_data+1)-&gt;at ) ) {</a>
<a name="ln2587">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Charges were rearranged&quot;);</a>
<a name="ln2588">                if ( sd-&gt;nErrorType &lt; _IS_WARNING ) {</a>
<a name="ln2589">                    sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln2590">                }</a>
<a name="ln2591">                sd-&gt;bTautFlagsDone[INCHI_REC] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln2592">                sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln2593">            }</a>
<a name="ln2594">        }</a>
<a name="ln2595">    }</a>
<a name="ln2596">    </a>
<a name="ln2597">    sd-&gt;bTautFlags[INCHI_BAS]     |= bTautFlags;  /* TG_FLAG_CHECK_VALENCE_COORD_DONE, TG_FLAG_MOVE_CHARGE_COORD_DONE */</a>
<a name="ln2598">    sd-&gt;bTautFlagsDone[INCHI_BAS] |= bTautFlagsDone;  /* TG_FLAG_CHECK_VALENCE_COORD_DONE, TG_FLAG_MOVE_CHARGE_COORD_DONE */</a>
<a name="ln2599">    return sd-&gt;nErrorType;</a>
<a name="ln2600">}</a>
<a name="ln2601"> </a>
<a name="ln2602">#ifndef COMPILE_ANSI_ONLY  /* { */</a>
<a name="ln2603">/************************************************************************************************/</a>
<a name="ln2604">int DisplayTheWholeStructure( STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle, </a>
<a name="ln2605">                              INCHI_IOSTREAM *inp_file, INCHI_IOSTREAM *log_file,</a>
<a name="ln2606">                              ORIG_ATOM_DATA *orig_inp_data, long num_inp, int iINChI, int bShowStruct, int bINCHI_LIB_Flag )</a>
<a name="ln2607">{</a>
<a name="ln2608"> </a>
<a name="ln2609">    int bDisplayEqu = 0;</a>
<a name="ln2610">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln2611">    /* Displaying equivalent input structures when disconnection has been done: */</a>
<a name="ln2612">    /* in case of TARGET_LIB_FOR_WINCHI equivalence info is always unknown here and bOriginalReconnected=0 */</a>
<a name="ln2613">    int bOriginalReconnected = iINChI &lt; 0 &amp;&amp; orig_inp_data &amp;&amp; orig_inp_data-&gt;nEquLabels &amp;&amp;</a>
<a name="ln2614">                               (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; TG_FLAG_DISCONNECT_COORD_DONE) &amp;&amp;</a>
<a name="ln2615">                               (ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD);</a>
<a name="ln2616">    const char *lpszType = bOriginalReconnected? &quot; (Reconnected)&quot;   :</a>
<a name="ln2617">                           (iINChI &lt;  0        )? &quot;&quot;                 :</a>
<a name="ln2618">                           (iINChI == INCHI_BAS )? &quot; (Preprocessed)&quot;  :</a>
<a name="ln2619">                           (iINChI == INCHI_REC )? &quot; (Reconnected)&quot;   : &quot;&quot;;</a>
<a name="ln2620">    int err = 0;</a>
<a name="ln2621">    /* Display the original structure */</a>
<a name="ln2622">    bDisplayEqu = bShowStruct &amp;&amp; ip-&gt;bDisplay &amp;&amp;</a>
<a name="ln2623">                  ip-&gt;dp.nEquLabels &amp;&amp; 0 &lt; ip-&gt;dp.nCurEquLabel &amp;&amp; ip-&gt;dp.nCurEquLabel &lt;= ip-&gt;dp.nNumEquSets;</a>
<a name="ln2624">#else</a>
<a name="ln2625">    if(!DRAWDATA || !DRAWDATA_EXISTS)</a>
<a name="ln2626">        return 0;</a>
<a name="ln2627">#endif</a>
<a name="ln2628">#ifndef TARGET_API_LIB</a>
<a name="ln2629">    /********************************************************************</a>
<a name="ln2630">     * Ask the user whether to process the input structure or quit</a>
<a name="ln2631">     */</a>
<a name="ln2632">    if ( ip-&gt;bDisplay &amp;&amp; inp_file-&gt;f != stdin ) {</a>
<a name="ln2633">        if ( user_quit(bDisplayEqu?&quot;Enter=Display identical components, Esc=Stop ?&quot; : &quot;Enter=Display, Esc=Stop ?&quot;, ip-&gt;ulDisplTime) ) {</a>
<a name="ln2634">            sd-&gt;bUserQuit = 1;</a>
<a name="ln2635">            goto exit_function;</a>
<a name="ln2636">        }</a>
<a name="ln2637">    }</a>
<a name="ln2638">#endif</a>
<a name="ln2639">    /******************************************************</a>
<a name="ln2640">     * Display the whole input structure in console app</a>
<a name="ln2641">     */</a>
<a name="ln2642">/*^^^ #ifndef TARGET_LIB_FOR_WINCHI */</a>
<a name="ln2643">#if ( !defined( TARGET_LIB_FOR_WINCHI ) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln2644">    if ( bShowStruct &amp;&amp; ip-&gt;bDisplay ) {</a>
<a name="ln2645">        if ( bDisplayEqu ) {</a>
<a name="ln2646">            sprintf( szTitle, &quot; Equ Set %d of %d, Input Structure #%ld.%s%s%s%s%s&quot;,</a>
<a name="ln2647">                     ip-&gt;dp.nCurEquLabel, ip-&gt;dp.nNumEquSets,</a>
<a name="ln2648">                     num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), lpszType);</a>
<a name="ln2649">        } else {</a>
<a name="ln2650">            sprintf( szTitle, &quot;Input Structure #%ld.%s%s%s%s%s&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), lpszType);</a>
<a name="ln2651">        }</a>
<a name="ln2652">        err = DisplayStructure( orig_inp_data-&gt;at, orig_inp_data-&gt;num_inp_atoms, 0, 1, 0, NULL, 1/*isotopic*/, 0/*taut*/, NULL, NULL,</a>
<a name="ln2653">                                            ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln2654">        sd-&gt;bUserQuitComponent = (err==ESC_KEY);</a>
<a name="ln2655">        if ( !err ) {</a>
<a name="ln2656">            inchi_fprintf( stderr, &quot;Cannot display the structure\n&quot;);</a>
<a name="ln2657">        }</a>
<a name="ln2658">    }</a>
<a name="ln2659">    if( !bDisplayEqu ) {</a>
<a name="ln2660">        /*  console output progress report */</a>
<a name="ln2661">        if ( ip-&gt;bDisplay &amp;&amp; !sd-&gt;bUserQuitComponent ) {</a>
<a name="ln2662">            if ( iINChI == 1 ) {</a>
<a name="ln2663">                if ( ip-&gt;bDisplay )</a>
<a name="ln2664">                    inchi_ios_eprint( log_file, &quot;Processing (rec) structure #%ld.%s%s%s%s...\n&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2665">                else</a>
<a name="ln2666">                    inchi_fprintf( stderr, &quot;Processing (rec) structure #%ld.%s%s%s%s...\r&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2667">            } else {</a>
<a name="ln2668">                if ( ip-&gt;bDisplay )</a>
<a name="ln2669">                    inchi_ios_eprint( log_file, &quot;Processing structure #%ld.%s%s%s%s...\n&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2670">                else</a>
<a name="ln2671">                    inchi_fprintf( stderr, &quot;Processing structure #%ld.%s%s%s%s...\r&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2672">            }</a>
<a name="ln2673">        }</a>
<a name="ln2674">    }</a>
<a name="ln2675">#endif</a>
<a name="ln2676"> </a>
<a name="ln2677"> </a>
<a name="ln2678">    /******************************************************</a>
<a name="ln2679">     * Store the whole input structure in GUI application</a>
<a name="ln2680">     */</a>
<a name="ln2681">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln2682">    if ( ip-&gt;bDisplay &amp;&amp; bINCHI_LIB_Flag )</a>
<a name="ln2683">#else</a>
<a name="ln2684">    if ( (ip-&gt;bDisplay || (ip-&gt;bCompareComponents &amp; CMP_COMPONENTS)) &amp;&amp; bINCHI_LIB_Flag )</a>
<a name="ln2685">#endif</a>
<a name="ln2686">    {</a>
<a name="ln2687">        int bBit, k, bReconnected, nComponent, bPreprocessed;</a>
<a name="ln2688">        for ( bBit = 1, k = 0; k &lt; 8; k ++, bBit &lt;&lt;= 1 ) {</a>
<a name="ln2689">            /******************************************************************************</a>
<a name="ln2690">             *  bReconnected  = k%2     (0 or 1)</a>
<a name="ln2691">             *  nComponent    = k/4     (0 or 1)</a>
<a name="ln2692">             *  bPreprocessed = (k/2)%2 (0 or 1)</a>
<a name="ln2693">             ******************************************************************************/</a>
<a name="ln2694">            if ( !(bINCHI_LIB_Flag &amp; bBit) ) {</a>
<a name="ln2695">                continue;</a>
<a name="ln2696">            }</a>
<a name="ln2697">            bReconnected  = k%2;</a>
<a name="ln2698">            nComponent    = k/4;</a>
<a name="ln2699">            bPreprocessed = ((k/2)%2);</a>
<a name="ln2700"> </a>
<a name="ln2701">            sprintf( szTitle, &quot;%s Structure #%ld.%s%s%s%s&quot;,</a>
<a name="ln2702">                              bPreprocessed? &quot;Preprocessed&quot; : bReconnected? &quot;Reconnected&quot; : &quot;Input&quot;,</a>
<a name="ln2703">                              num_inp,</a>
<a name="ln2704">                              SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue));</a>
<a name="ln2705"> </a>
<a name="ln2706">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln2707">            if(DRAWDATA &amp;&amp; DRAWDATA_EXISTS)</a>
<a name="ln2708">            {</a>
<a name="ln2709">                struct DrawData vDrawData;</a>
<a name="ln2710">                int    nType = bPreprocessed? COMPONENT_ORIGINAL_PREPROCESSED : COMPONENT_ORIGINAL;</a>
<a name="ln2711">                if ( DRAWDATA_EXISTS( nComponent, bPreprocessed, bReconnected ) ) {</a>
<a name="ln2712">                    sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln2713">                    sd-&gt;nErrorCode = CT_UNKNOWN_ERR;</a>
<a name="ln2714">                    return -1;</a>
<a name="ln2715">                }</a>
<a name="ln2716">                vDrawData.pWindowData = CreateWinData_( orig_inp_data-&gt;at, orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln2717">                                                        0, 1 /* bAdd_DT_to_num_H */, 0, NULL, 1, 0, NULL, NULL,</a>
<a name="ln2718">                                                        ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode );</a>
<a name="ln2719">                if( vDrawData.pWindowData != NULL )</a>
<a name="ln2720">                {</a>
<a name="ln2721">                    vDrawData.nComponent   = nComponent;</a>
<a name="ln2722">                    vDrawData.nType        = nType; /* COMPONENT_ORIGINAL or COMPONENT_ORIGINAL_PREPROCESSED */</a>
<a name="ln2723">                    vDrawData.bReconnected = bReconnected; /* 0=&gt;main; 1=&gt;reconnected */</a>
<a name="ln2724">                    vDrawData.pWindowData-&gt;szTitle = _strdup(szTitle);</a>
<a name="ln2725">                    vDrawData.szTitle              = _strdup(szTitle);</a>
<a name="ln2726">                    DRAWDATA(&amp;vDrawData);</a>
<a name="ln2727">                    if ( !nComponent ) {</a>
<a name="ln2728">                        /* keep track of saved INCHI_LIB data */</a>
<a name="ln2729">                        orig_inp_data-&gt;bSavedInINCHI_LIB[bReconnected] ++;</a>
<a name="ln2730">                        orig_inp_data-&gt;bPreprocessed[bReconnected]    = bPreprocessed;</a>
<a name="ln2731">                    }</a>
<a name="ln2732">                }</a>
<a name="ln2733">            }</a>
<a name="ln2734">#else</a>
<a name="ln2735">            if ( !nComponent ) {</a>
<a name="ln2736">                /* keep track of saved INCHI_LIB data */</a>
<a name="ln2737">                orig_inp_data-&gt;bSavedInINCHI_LIB[bReconnected] ++;</a>
<a name="ln2738">                orig_inp_data-&gt;bPreprocessed[bReconnected]    = bPreprocessed;</a>
<a name="ln2739">            }</a>
<a name="ln2740">#endif</a>
<a name="ln2741"> </a>
<a name="ln2742">        }</a>
<a name="ln2743">    }</a>
<a name="ln2744"> </a>
<a name="ln2745">exit_function:</a>
<a name="ln2746">    return sd-&gt;bUserQuit;</a>
<a name="ln2747">}</a>
<a name="ln2748">#endif /* } COMPILE_ANSI_ONLY */</a>
<a name="ln2749">/************************************************************************************************/</a>
<a name="ln2750">int ProcessOneStructure( STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle,</a>
<a name="ln2751">                         PINChI2 *pINChI[INCHI_NUM], PINChI_Aux2 *pINChI_Aux[INCHI_NUM],</a>
<a name="ln2752">                         INCHI_IOSTREAM *inp_file, </a>
<a name="ln2753">                         INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file, INCHI_IOSTREAM *prb_file, /*^^^ was: INCHI_IOSTREAM */</a>
<a name="ln2754">                         ORIG_ATOM_DATA *orig_inp_data, ORIG_ATOM_DATA *prep_inp_data,</a>
<a name="ln2755">                         long num_inp, char *pStr, int nStrLen,</a>
<a name="ln2756">                         unsigned char save_opt_bits)</a>
<a name="ln2757">{</a>
<a name="ln2758">        int nRet = 0, nRet1, i, k, maxINChI=0;</a>
<a name="ln2759">        COMP_ATOM_DATA composite_norm_data[INCHI_NUM][TAUT_NUM+1]; /* [0]:non-taut, [1]:taut, [2]:intermediate taut struct */</a>
<a name="ln2760">        NORM_CANON_FLAGS ncFlags;</a>
<a name="ln2761">        NORM_CANON_FLAGS *pncFlags = &amp;ncFlags;</a>
<a name="ln2762">        ORIG_STRUCT      OrigStruct;</a>
<a name="ln2763">        ORIG_STRUCT      *pOrigStruct = NULL;</a>
<a name="ln2764">        int bSortPrintINChIFlags=0;</a>
<a name="ln2765"> </a>
<a name="ln2766"> </a>
<a name="ln2767">#if ( RING2CHAIN == 1 || UNDERIVATIZE == 1 )</a>
<a name="ln2768">        int ret1=0, ret2=0;</a>
<a name="ln2769">#endif</a>
<a name="ln2770">        sd-&gt;bUserQuitComponent = 0;</a>
<a name="ln2771">        sd-&gt;bUserQuitComponentDisplay = 0;</a>
<a name="ln2772">        memset( composite_norm_data, 0, sizeof(composite_norm_data) );</a>
<a name="ln2773">        memset( pncFlags, 0, sizeof(*pncFlags) );</a>
<a name="ln2774">        /* ip-&gt;msec_LeftTime = ip-&gt;msec_MaxTime; */ /* start timeout countdown */</a>
<a name="ln2775"> </a>
<a name="ln2776">        /* for testing only */</a>
<a name="ln2777">#if ( REMOVE_ION_PAIRS_ORIG_STRU == 1 )</a>
<a name="ln2778">        fix_odd_things( orig_inp_data-&gt;num_inp_atoms, orig_inp_data-&gt;at, 0, ip-&gt;bFixNonUniformDraw );</a>
<a name="ln2779">#endif</a>
<a name="ln2780"> </a>
<a name="ln2781">#if ( UNDERIVATIZE == 1 )  /***** post v.1 feature *****/</a>
<a name="ln2782">        if ( ip-&gt;bUnderivatize &amp;&amp; 0 &gt; (ret2=underivatize( orig_inp_data )) ) {</a>
<a name="ln2783">            long num_inp2 = num_inp;</a>
<a name="ln2784">            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Underivatization error&quot;);</a>
<a name="ln2785">            sd-&gt;nStructReadError =  99;</a>
<a name="ln2786">            sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln2787">            nRet = _IS_ERROR;</a>
<a name="ln2788">            TreatReadTheStructureErrors( sd, ip, LOG_MASK_ALL, inp_file, log_file, output_file, prb_file,</a>
<a name="ln2789">                                        prep_inp_data, &amp;num_inp2, pStr, nStrLen );</a>
<a name="ln2790">            goto exit_function; /* output only if derivatives found */</a>
<a name="ln2791">        }</a>
<a name="ln2792">#endif /* UNDERIVATIZE == 1 */</a>
<a name="ln2793">#if ( RING2CHAIN == 1 )  /***** post v.1 feature *****/</a>
<a name="ln2794">        if ( ip-&gt;bRing2Chain &amp;&amp; 0 &gt; (ret1 = Ring2Chain( orig_inp_data )) ) {</a>
<a name="ln2795">            long num_inp2 = num_inp;</a>
<a name="ln2796">            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Ring to chain error&quot;);</a>
<a name="ln2797">            sd-&gt;nStructReadError =  99;</a>
<a name="ln2798">            sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln2799">            nRet = _IS_ERROR;</a>
<a name="ln2800">            TreatReadTheStructureErrors( sd, ip, LOG_MASK_ALL, inp_file, log_file, output_file, prb_file,</a>
<a name="ln2801">                                        prep_inp_data, &amp;num_inp2, pStr, nStrLen );</a>
<a name="ln2802">            goto exit_function; /* output only if derivatives found */</a>
<a name="ln2803">        }</a>
<a name="ln2804">#endif /* RING2CHAIN == 1 */</a>
<a name="ln2805">#if ( RING2CHAIN == 1 || UNDERIVATIZE == 1 )  /***** post v.1 feature *****/</a>
<a name="ln2806">        if ( ip-&gt;bIngnoreUnchanged &amp;&amp; !ret1 &amp;&amp; !ret2 ) {</a>
<a name="ln2807">            goto exit_function; /* output only if derivatives or ring/chain found */</a>
<a name="ln2808">        }</a>
<a name="ln2809">#endif /* RING2CHAIN == 1 || UNDERIVATIZE == 1 */</a>
<a name="ln2810"> </a>
<a name="ln2811"> </a>
<a name="ln2812">        /***** output MOLfile ***************/</a>
<a name="ln2813">        if ( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_SDFILE_ONLY  ) {</a>
<a name="ln2814">            char szNumber[32];</a>
<a name="ln2815">            int ret1a=0, ret2a=0; /* for derivatives and ring-chain */</a>
<a name="ln2816">/*^^^ #if ( !defined( TARGET_LIB_FOR_WINCHI ) &amp;&amp; !defined( TARGET_API_LIB ) ) */</a>
<a name="ln2817">#if ( !defined( TARGET_LIB_FOR_WINCHI ) &amp;&amp; !defined( TARGET_API_LIB ) &amp;&amp; !defined(TARGET_EXE_STANDALONE) )</a>
<a name="ln2818">#if ( TEST_RENUMB_ATOMS != 1 )</a>
<a name="ln2819">            /*  log file / console output */</a>
<a name="ln2820">            if ( log_file-&gt;f != stderr ) {</a>
<a name="ln2821">                if ( ip-&gt;bDisplay )</a>
<a name="ln2822">                    inchi_ios_eprint( log_file, &quot;Writing structure #%ld.%s%s%s%s...\n&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2823">                else</a>
<a name="ln2824">                    inchi_fprintf( stderr, &quot;Writing structure #%ld.%s%s%s%s...\r&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln2825">            }</a>
<a name="ln2826">#endif</a>
<a name="ln2827">#endif</a>
<a name="ln2828">            ret1a = sprintf( szNumber, &quot;Structure #%ld&quot;, num_inp );</a>
<a name="ln2829">            ret2a = WriteOrigAtomDataToSDfile( orig_inp_data, output_file, szNumber, NULL,</a>
<a name="ln2830">                (sd-&gt;bChiralFlag &amp; FLAG_INP_AT_CHIRAL)? 1:0,</a>
<a name="ln2831">                (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_SDFILE_ATOMS_DT)? 1:0, ip-&gt;pSdfLabel, ip-&gt;pSdfValue );</a>
<a name="ln2832">            goto exit_function;</a>
<a name="ln2833">        }</a>
<a name="ln2834"> </a>
<a name="ln2835">        /******* create full reversibility information **************/</a>
<a name="ln2836">        if ( !(ip-&gt;bINChIOutputOptions &amp; (INCHI_OUT_NO_AUX_INFO | INCHI_OUT_SHORT_AUX_INFO)) ) {</a>
<a name="ln2837">            pOrigStruct = &amp;OrigStruct;</a>
<a name="ln2838">            memset( pOrigStruct, 0, sizeof(*pOrigStruct));</a>
<a name="ln2839">            if ( FillOutOrigStruct( orig_inp_data, pOrigStruct, sd ) ) {</a>
<a name="ln2840">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot interpret reversibility information&quot;);</a>
<a name="ln2841">                sd-&gt;nStructReadError =  99;</a>
<a name="ln2842">                sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln2843">                nRet = _IS_ERROR;</a>
<a name="ln2844">            }</a>
<a name="ln2845">        }</a>
<a name="ln2846">        /* create INChI for each connected component of the structure and optionally display them */</a>
<a name="ln2847">        /* create INChI for the whole disconnected or original structure */</a>
<a name="ln2848">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR ) {</a>
<a name="ln2849">            nRet1 = CreateOneStructureINChI(sd, ip, szTitle, pINChI, pINChI_Aux, INCHI_BAS,</a>
<a name="ln2850">                                            inp_file, log_file, output_file, prb_file,</a>
<a name="ln2851">                                            orig_inp_data, prep_inp_data, </a>
<a name="ln2852">                                            composite_norm_data, num_inp, </a>
<a name="ln2853">                                            pStr, nStrLen, pncFlags );</a>
<a name="ln2854">            nRet = inchi_max(nRet, nRet1);</a>
<a name="ln2855">        }</a>
<a name="ln2856">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR ) {</a>
<a name="ln2857">            maxINChI = 1;</a>
<a name="ln2858">        }</a>
<a name="ln2859"> </a>
<a name="ln2860"> </a>
<a name="ln2861">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR &amp;&amp;</a>
<a name="ln2862">             (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; TG_FLAG_DISCONNECT_COORD_DONE) &amp;&amp;</a>
<a name="ln2863">             (ip-&gt;bTautFlags               &amp; TG_FLAG_RECONNECT_COORD)          ) {</a>
<a name="ln2864"> </a>
<a name="ln2865">            /* create INChI for the whole reconnected structure */</a>
<a name="ln2866">            nRet1 = CreateOneStructureINChI(sd, ip, szTitle, pINChI, pINChI_Aux, INCHI_REC,</a>
<a name="ln2867">                                            inp_file, log_file, output_file, prb_file,</a>
<a name="ln2868">                                            orig_inp_data, prep_inp_data, </a>
<a name="ln2869">                                            composite_norm_data,num_inp, </a>
<a name="ln2870">                                            pStr, nStrLen, pncFlags);</a>
<a name="ln2871">            nRet = inchi_max(nRet, nRet1);</a>
<a name="ln2872">            if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR ) {</a>
<a name="ln2873">                maxINChI = 2;</a>
<a name="ln2874">            }</a>
<a name="ln2875">        }</a>
<a name="ln2876"> </a>
<a name="ln2877"> </a>
<a name="ln2878">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR ) {</a>
<a name="ln2879"> </a>
<a name="ln2880">            if ( (sd-&gt;bChiralFlag &amp; FLAG_INP_AT_CHIRAL) &amp;&amp;</a>
<a name="ln2881">                  (ip-&gt;nMode &amp; REQ_MODE_STEREO) &amp;&amp;</a>
<a name="ln2882">                 !(ip-&gt;nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO)) &amp;&amp;</a>
<a name="ln2883">                 !bIsStructChiral( pINChI, sd-&gt;num_components ) ) {</a>
<a name="ln2884"> </a>
<a name="ln2885">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Not chiral&quot;);</a>
<a name="ln2886">            }</a>
<a name="ln2887">            /*************************************/</a>
<a name="ln2888">            /*       Output err/warn messages    */</a>
<a name="ln2889">            /*************************************/</a>
<a name="ln2890">            if ( /*!sd-&gt;nErrorCode &amp;&amp;*/ !sd-&gt;bUserQuitComponent &amp;&amp; !sd-&gt;bUserQuit ) {</a>
<a name="ln2891">                /*  if successful then returns 0, otherwise returns _IS_FATAL */</a>
<a name="ln2892">                /*  exctract the structure if requested */</a>
<a name="ln2893">                nRet1 = TreatCreateINChIWarning(sd, ip, prep_inp_data, num_inp,</a>
<a name="ln2894">                                 inp_file, log_file, output_file, prb_file,pStr, nStrLen );</a>
<a name="ln2895">                nRet = inchi_max(nRet, nRet1);</a>
<a name="ln2896">            }</a>
<a name="ln2897">        }</a>
<a name="ln2898"> </a>
<a name="ln2899"> </a>
<a name="ln2900">            /************************************************/</a>
<a name="ln2901">            /*  sort and print INChI for the whole structure */</a>
<a name="ln2902">            /************************************************/</a>
<a name="ln2903"> </a>
<a name="ln2904">        if ( ip-&gt;nInputType != INPUT_INCHI ) </a>
<a name="ln2905">        {</a>
<a name="ln2906">            /* Prepare SaveOpt bits */</a>
<a name="ln2907">            save_opt_bits = 0;</a>
<a name="ln2908">            if ( ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_SAVEOPT )</a>
<a name="ln2909">            {</a>
<a name="ln2910">                if ( 0 != ( ip-&gt;bTautFlags &amp; TG_FLAG_RECONNECT_COORD) )</a>
<a name="ln2911">                    save_opt_bits |= SAVE_OPT_RECMET;</a>
<a name="ln2912">                if ( 0 != ( ip-&gt;nMode &amp; REQ_MODE_BASIC) )</a>
<a name="ln2913">                    save_opt_bits |= SAVE_OPT_FIXEDH;</a>
<a name="ln2914">                if ( 0 != ( ip-&gt;nMode &amp; REQ_MODE_DIFF_UU_STEREO) ) </a>
<a name="ln2915">                    save_opt_bits |= SAVE_OPT_SLUUD;</a>
<a name="ln2916">                if ( 0 == (ip-&gt;nMode &amp; (REQ_MODE_SB_IGN_ALL_UU | REQ_MODE_SC_IGN_ALL_UU)) ) </a>
<a name="ln2917">                    save_opt_bits |= SAVE_OPT_SUU;</a>
<a name="ln2918">                if ( 0 != (ip-&gt;bTautFlags &amp; TG_FLAG_KETO_ENOL_TAUT) )</a>
<a name="ln2919">                    save_opt_bits |= SAVE_OPT_KET;</a>
<a name="ln2920">                if ( 0 != (ip-&gt;bTautFlags &amp; TG_FLAG_1_5_TAUT) )</a>
<a name="ln2921">                    save_opt_bits |= SAVE_OPT_15T;</a>
<a name="ln2922">                /* Check if /SNon requested and turn OFF stereo bits if so */</a>
<a name="ln2923">                if ( ! (ip-&gt;nMode &amp; REQ_MODE_STEREO) )</a>
<a name="ln2924">                {</a>
<a name="ln2925">                    save_opt_bits &amp;= ~SAVE_OPT_SUU;</a>
<a name="ln2926">                    save_opt_bits &amp;= ~SAVE_OPT_SLUUD;</a>
<a name="ln2927">                }</a>
<a name="ln2928">            }</a>
<a name="ln2929">        }</a>
<a name="ln2930"> </a>
<a name="ln2931">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR ) {</a>
<a name="ln2932">             </a>
<a name="ln2933">            nRet1 = SortAndPrintINChI(output_file, pStr, nStrLen, log_file, </a>
<a name="ln2934">                                      ip, orig_inp_data, prep_inp_data,</a>
<a name="ln2935">                                      composite_norm_data, pOrigStruct,</a>
<a name="ln2936">                                      sd-&gt;num_components, sd-&gt;num_non_taut, sd-&gt;num_taut,</a>
<a name="ln2937">                                      sd-&gt;bTautFlags, sd-&gt;bTautFlagsDone, pncFlags, num_inp,</a>
<a name="ln2938">                                      pINChI, pINChI_Aux, </a>
<a name="ln2939">                                      &amp;bSortPrintINChIFlags, save_opt_bits);</a>
<a name="ln2940">            nRet = inchi_max(nRet, nRet1);</a>
<a name="ln2941">        }</a>
<a name="ln2942">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln2943">        </a>
<a name="ln2944">        /* display equivalent components on original or preprocessed structure(s) */</a>
<a name="ln2945"> </a>
<a name="ln2946">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln2947"> </a>
<a name="ln2948">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR &amp;&amp; /*ip-&gt;bDisplay &amp;&amp;*/</a>
<a name="ln2949">             (ip-&gt;bCompareComponents &amp; CMP_COMPONENTS) &amp;&amp; !sd-&gt;bUserQuit &amp;&amp; !sd-&gt;bUserQuitComponent ) </a>
<a name="ln2950">        {</a>
<a name="ln2951">            int j, ret, ord;</a>
<a name="ln2952">            int bDisplaySaved = ip-&gt;bDisplay;</a>
<a name="ln2953">            ORIG_ATOM_DATA *inp_data;</a>
<a name="ln2954">            AT_NUMB         nEquSet;</a>
<a name="ln2955">            for ( ord = -1; ord &lt; INCHI_NUM; ord ++ ) {</a>
<a name="ln2956">                switch( ord ) {</a>
<a name="ln2957">                case -1:</a>
<a name="ln2958">                    j = INCHI_BAS;  /* preprocessed non-tautomeric */</a>
<a name="ln2959">                    break;</a>
<a name="ln2960">                case 0:</a>
<a name="ln2961">                    j = INCHI_REC;  /* preprocessed tautomeric */</a>
<a name="ln2962">                    break;</a>
<a name="ln2963">                case 1:</a>
<a name="ln2964">                    j = -1;        /* original input */</a>
<a name="ln2965">                    break;</a>
<a name="ln2966">                default:</a>
<a name="ln2967">                    continue;</a>
<a name="ln2968">                }</a>
<a name="ln2969">                inp_data   = j &lt; 0? orig_inp_data : prep_inp_data+j;</a>
<a name="ln2970">                if ( inp_data &amp;&amp; inp_data-&gt;num_inp_atoms &amp;&amp; inp_data-&gt;at &amp;&amp;</a>
<a name="ln2971">                     inp_data-&gt;nEquLabels &amp;&amp;</a>
<a name="ln2972">                     inp_data-&gt;nNumEquSets ) {</a>
<a name="ln2973">                    for ( nEquSet = 1; nEquSet &lt;= inp_data-&gt;nNumEquSets; nEquSet ++ ) {</a>
<a name="ln2974">                        ip-&gt;dp.nEquLabels   = inp_data-&gt;nEquLabels;</a>
<a name="ln2975">                        ip-&gt;dp.nCurEquLabel = nEquSet;</a>
<a name="ln2976">                        ip-&gt;dp.nNumEquSets  = inp_data-&gt;nNumEquSets;</a>
<a name="ln2977">                        ip-&gt;bDisplay = 1; /* force display if it was not requested */</a>
<a name="ln2978">                        ret = DisplayTheWholeStructure( sd, ip, szTitle, inp_file, log_file, inp_data, num_inp,</a>
<a name="ln2979">                                                       j, 1 /*bShowStructure*/, 0 );</a>
<a name="ln2980">                        ip-&gt;dp.nEquLabels   = NULL;</a>
<a name="ln2981">                        ip-&gt;dp.nCurEquLabel = 0;</a>
<a name="ln2982">                        ip-&gt;dp.nNumEquSets  = 0;</a>
<a name="ln2983">                        ip-&gt;bDisplay = bDisplaySaved; /* restore display option */</a>
<a name="ln2984">                        if ( ret ) {</a>
<a name="ln2985">                            /* user pressed Esc */</a>
<a name="ln2986">                            goto exit_loop;</a>
<a name="ln2987">                        }</a>
<a name="ln2988">                    }</a>
<a name="ln2989">                }</a>
<a name="ln2990">            }</a>
<a name="ln2991">exit_loop:;</a>
<a name="ln2992">        }</a>
<a name="ln2993"> </a>
<a name="ln2994">#endif</a>
<a name="ln2995"> </a>
<a name="ln2996"> </a>
<a name="ln2997"> </a>
<a name="ln2998">        /* display composite results and equivalent components on composite results */</a>
<a name="ln2999">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR &amp;&amp; /*ip-&gt;bDisplay &amp;&amp;*/</a>
<a name="ln3000">             ip-&gt;bDisplayCompositeResults ) {</a>
<a name="ln3001">            int iINChI;</a>
<a name="ln3002">            for ( iINChI = 0; iINChI &lt; maxINChI &amp;&amp; !sd-&gt;bUserQuitComponentDisplay; iINChI ++ ) {</a>
<a name="ln3003">                DisplayTheWholeCompositeStructure( ip, sd, num_inp, iINChI,</a>
<a name="ln3004">                                               pINChI[iINChI], pINChI_Aux[iINChI],</a>
<a name="ln3005">                                               orig_inp_data, prep_inp_data,</a>
<a name="ln3006">                                               composite_norm_data[iINChI] );</a>
<a name="ln3007">            }</a>
<a name="ln3008">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln3009">            if( !ip-&gt;bDisplay &amp;&amp; sd-&gt;bUserQuitComponentDisplay ) {</a>
<a name="ln3010">                sd-&gt;bUserQuit = 1;</a>
<a name="ln3011">            }</a>
<a name="ln3012">#endif</a>
<a name="ln3013">        }</a>
<a name="ln3014"> </a>
<a name="ln3015">#endif /* } COMPILE_ANSI_ONLY */</a>
<a name="ln3016"> </a>
<a name="ln3017"> </a>
<a name="ln3018">        /* XML struct end tag */</a>
<a name="ln3019">        if ( (ip-&gt;bINChIOutputOptions &amp; INCHI_OUT_XML) &amp;&amp; sd-&gt;bXmlStructStarted &gt; 0 ) {</a>
<a name="ln3020">            if ( !OutputINChIXmlStructEndTag( output_file, pStr, nStrLen, 1 ) ) {</a>
<a name="ln3021">                inchi_ios_eprint( log_file, &quot;Cannot create end xml tag for structure #%ld.%s%s%s%s Terminating.\n&quot;, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln3022">                sd-&gt;bXmlStructStarted = -1; /*  do not repeat same message */</a>
<a name="ln3023">                nRet = _IS_FATAL;</a>
<a name="ln3024">            } else {</a>
<a name="ln3025">                sd-&gt;bXmlStructStarted = 0; /*  do not continue xml output for this structure */</a>
<a name="ln3026">            }</a>
<a name="ln3027">        }</a>
<a name="ln3028">        if ( nRet != _IS_FATAL &amp;&amp; nRet != _IS_ERROR ) {</a>
<a name="ln3029">            /* Special mode: extract all good MOLfiles into the problem file</a>
<a name="ln3030">             * Do not extract any MOLfile that could not be processed (option /PGO)</a>
<a name="ln3031">             */</a>
<a name="ln3032">            if ( prb_file &amp;&amp; prb_file-&gt;f &amp;&amp; 0L &lt;= sd-&gt;fPtrStart &amp;&amp; sd-&gt;fPtrStart &lt; sd-&gt;fPtrEnd &amp;&amp; ip-&gt;bSaveAllGoodStructsAsProblem ) {</a>
<a name="ln3033">                CopyMOLfile(inp_file-&gt;f, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, 0);</a>
<a name="ln3034">            }</a>
<a name="ln3035">#if ( /*bRELEASE_VERSION != 1 &amp;&amp;*/ EXTR_FLAGS == EXTR_TRANSPOSITION_EXAMPLES &amp;&amp; EXTR_MASK == EXTR_FLAGS )</a>
<a name="ln3036">            else</a>
<a name="ln3037">            if ( prb_file-&gt;f &amp;&amp; (bSortPrintINChIFlags &amp; </a>
<a name="ln3038">                   ( FLAG_SORT_PRINT_TRANSPOS_BAS | FLAG_SORT_PRINT_TRANSPOS_REC ) )</a>
<a name="ln3039">            ) {</a>
<a name="ln3040">                CopyMOLfile(inp_file, sd-&gt;fPtrStart, sd-&gt;fPtrEnd, prb_file-&gt;f, 0);</a>
<a name="ln3041">            }</a>
<a name="ln3042">#endif</a>
<a name="ln3043">        }</a>
<a name="ln3044">        for ( i = 0; i &lt; INCHI_NUM; i ++ ) {</a>
<a name="ln3045">            for ( k = 0; k &lt; TAUT_NUM+1; k ++ ) {</a>
<a name="ln3046">                FreeCompAtomData( &amp;composite_norm_data[i][k] );</a>
<a name="ln3047">            }</a>
<a name="ln3048">        }</a>
<a name="ln3049">        FreeOrigStruct( pOrigStruct);</a>
<a name="ln3050"> </a>
<a name="ln3051"> </a>
<a name="ln3052">/*</a>
<a name="ln3053">        FreeInpAtomData( inp_cur_data     );</a>
<a name="ln3054">        FreeInpAtomData( inp_norm_data[0] );</a>
<a name="ln3055">        FreeInpAtomData( inp_norm_data[1] );</a>
<a name="ln3056">*/</a>
<a name="ln3057">exit_function:</a>
<a name="ln3058"> </a>
<a name="ln3059"> </a>
<a name="ln3060">        return nRet;</a>
<a name="ln3061">}</a>
<a name="ln3062">/************************************************************************************************/</a>
<a name="ln3063">int bIsStructChiral( PINChI2 *pINChI2[INCHI_NUM], int num_components[] )</a>
<a name="ln3064">{</a>
<a name="ln3065">    int i, j, k;</a>
<a name="ln3066">    INChI *pINChI;</a>
<a name="ln3067">    INChI_Stereo *Stereo;</a>
<a name="ln3068">    for ( j = 0; j &lt; INCHI_NUM; j ++ ) {  /* disconnected / reconnected */</a>
<a name="ln3069">        if ( !num_components[j] ) {</a>
<a name="ln3070">            continue;</a>
<a name="ln3071">        }</a>
<a name="ln3072">        for ( i = 0; i &lt; num_components[j]; i ++ ) {  /* component */</a>
<a name="ln3073">            for ( k = 0; k &lt; TAUT_NUM; k ++ ) {       /* mobile/immobile H */</a>
<a name="ln3074">                if ( (pINChI = pINChI2[j][i][k]) &amp;&amp;</a>
<a name="ln3075">                      !pINChI-&gt;bDeleted &amp;&amp;</a>
<a name="ln3076">                      pINChI-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln3077">                    </a>
<a name="ln3078">                    if ( (Stereo = pINChI-&gt;Stereo) &amp;&amp;</a>
<a name="ln3079">                         Stereo-&gt;t_parity &amp;&amp;</a>
<a name="ln3080">                         Stereo-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp;</a>
<a name="ln3081">                         Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln3082">                        return 1; /* inversion changed stereo */</a>
<a name="ln3083">                    }</a>
<a name="ln3084">                    if ( (Stereo = pINChI-&gt;StereoIsotopic) &amp;&amp;</a>
<a name="ln3085">                         Stereo-&gt;t_parity &amp;&amp;</a>
<a name="ln3086">                         Stereo-&gt;nNumberOfStereoCenters &gt; 0 &amp;&amp;</a>
<a name="ln3087">                         Stereo-&gt;nCompInv2Abs ) {</a>
<a name="ln3088">                        return 1; /* inversion changed stereo */</a>
<a name="ln3089">                    }</a>
<a name="ln3090">                }</a>
<a name="ln3091">            }</a>
<a name="ln3092">        }</a>
<a name="ln3093">    }</a>
<a name="ln3094">    return 0;</a>
<a name="ln3095">}</a>
<a name="ln3096">/************************************************************************************************/</a>
<a name="ln3097">int CreateOneStructureINChI( STRUCT_DATA *sd, INPUT_PARMS *ip, char *szTitle,</a>
<a name="ln3098">                         PINChI2 *pINChI2[INCHI_NUM], PINChI_Aux2 *pINChI_Aux2[INCHI_NUM], int iINChI,</a>
<a name="ln3099">                         INCHI_IOSTREAM *inp_file, </a>
<a name="ln3100">                         INCHI_IOSTREAM *log_file, INCHI_IOSTREAM *output_file, INCHI_IOSTREAM *prb_file, /*^^^ was: INCHI_IOSTREAM */</a>
<a name="ln3101">                         ORIG_ATOM_DATA *orig_inp_data, ORIG_ATOM_DATA *prep_inp_data,</a>
<a name="ln3102">                         COMP_ATOM_DATA composite_norm_data2[][TAUT_NUM+1],</a>
<a name="ln3103">                         long num_inp, char *pStr, int nStrLen, NORM_CANON_FLAGS *pncFlags )</a>
<a name="ln3104">{</a>
<a name="ln3105">    int i, j, k, /*m,*/ nRet = 0;</a>
<a name="ln3106">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln3107">    int n;</a>
<a name="ln3108">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln3109">    int err;</a>
<a name="ln3110">#endif</a>
<a name="ln3111">#endif</a>
<a name="ln3112"> </a>
<a name="ln3113">    PINChI2     *pINChI     = NULL;</a>
<a name="ln3114">    PINChI_Aux2 *pINChI_Aux = NULL;</a>
<a name="ln3115"> </a>
<a name="ln3116">    INP_ATOM_DATA InpCurAtData;</a>
<a name="ln3117">    INP_ATOM_DATA *inp_cur_data;</a>
<a name="ln3118"> </a>
<a name="ln3119">    INP_ATOM_DATA InpNormAtData, InpNormTautData;</a>
<a name="ln3120">    INP_ATOM_DATA *inp_norm_data[TAUT_NUM]; /*  = { &amp;InpNormAtData, &amp;InpNormTautData }; */</a>
<a name="ln3121">    ORIG_ATOM_DATA *cur_prep_inp_data = prep_inp_data + iINChI;</a>
<a name="ln3122">    inchiTime      ulTStart;</a>
<a name="ln3123">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln3124">    int            bShowStructure = 0;</a>
<a name="ln3125">    int            bStructurePreprocessed = 0; /* All changes except disconnection */</a>
<a name="ln3126">    int            bStructureDisconnected = 0;</a>
<a name="ln3127">    int            bAlsoOutputReconnected = 0, bINCHI_LIB_Flag = 0;</a>
<a name="ln3128">    COMP_ATOM_DATA *composite_norm_data = composite_norm_data2[iINChI];</a>
<a name="ln3129">    INP_ATOM_DATA2 *all_inp_norm_data = NULL;</a>
<a name="ln3130">#endif</a>
<a name="ln3131"> </a>
<a name="ln3132">    /*</a>
<a name="ln3133">        if ( orig_inp_data is NOT empty AND</a>
<a name="ln3134">             prep_inp_data[0] IS empty ) then:</a>
<a name="ln3135"> </a>
<a name="ln3136">            1. copy orig_inp_data --&gt; prep_inp_data[0]</a>
<a name="ln3137">            2. fix odd things in prep_inp_data[0]</a>
<a name="ln3138">            3. if( orig_inp_data-&gt;bDisconnectSalts ) then</a>
<a name="ln3139">                  -- disconnect salts in prep_inp_data[0]</a>
<a name="ln3140">            4. move protons to neutralize charges on heteroatoms</a>
<a name="ln3141">            5. if( orig_inp_data-&gt;bDisconnectCoord ) then</a>
<a name="ln3142">                  -- copy prep_inp_data[0] --&gt; prep_inp_data[1]</a>
<a name="ln3143">                  -- disconnect metals in prep_inp_data[0]</a>
<a name="ln3144"> </a>
<a name="ln3145">            [ This all is done in PreprocessOneStructure() ]</a>
<a name="ln3146"> </a>
<a name="ln3147">        iINChI = 0</a>
<a name="ln3148">        =========</a>
<a name="ln3149">        (normal/disconnected layer)</a>
<a name="ln3150"> </a>
<a name="ln3151">            1. normalize prep_inp_data[0] in inp_norm_data[0,1]</a>
<a name="ln3152">            2. create INChI[ iINChI ] out of inp_norm_data[0,1]</a>
<a name="ln3153"> </a>
<a name="ln3154"> </a>
<a name="ln3155">        iINChI = 1 AND orig_inp_data-&gt;bDisconnectCoord &gt; 0</a>
<a name="ln3156">        =================================================</a>
<a name="ln3157">        (reconnected layer)</a>
<a name="ln3158"> </a>
<a name="ln3159">            1. normalize prep_inp_data[1] in inp_norm_data[0,1]</a>
<a name="ln3160">            2. create INChI[ iINChI ] out of inp_norm_data[0,1]</a>
<a name="ln3161"> </a>
<a name="ln3162">    */</a>
<a name="ln3163"> </a>
<a name="ln3164">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3165">    RENUMB_DATA RenumbData;</a>
<a name="ln3166">    RENUMB_DATA *pRenumbData = &amp;RenumbData;</a>
<a name="ln3167">#endif</a>
<a name="ln3168"> </a>
<a name="ln3169"> </a>
<a name="ln3170">    ip-&gt;msec_LeftTime = ip-&gt;msec_MaxTime; /* start timeout countdown for each component */</a>
<a name="ln3171"> </a>
<a name="ln3172">#if ( TEST_RENUMB_ATOMS == 1 )</a>
<a name="ln3173">    memset( pRenumbData, 0, sizeof(*pRenumbData) );</a>
<a name="ln3174">#endif</a>
<a name="ln3175"> </a>
<a name="ln3176">    inp_cur_data     = &amp;InpCurAtData;</a>
<a name="ln3177">    inp_norm_data[TAUT_NON] = &amp;InpNormAtData;</a>
<a name="ln3178">    inp_norm_data[TAUT_YES] = &amp;InpNormTautData;</a>
<a name="ln3179"> </a>
<a name="ln3180">    memset( inp_cur_data      , 0, sizeof( *inp_cur_data     ) );</a>
<a name="ln3181">    memset( inp_norm_data[TAUT_NON], 0, sizeof( *inp_norm_data[0] ) );</a>
<a name="ln3182">    memset( inp_norm_data[TAUT_YES], 0, sizeof( *inp_norm_data[0] ) );</a>
<a name="ln3183"> </a>
<a name="ln3184">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln3185">    memset( composite_norm_data+TAUT_NON, 0, sizeof( composite_norm_data[0] ) );</a>
<a name="ln3186">    memset( composite_norm_data+TAUT_YES, 0, sizeof( composite_norm_data[0] ) );</a>
<a name="ln3187">    memset( composite_norm_data+TAUT_INI, 0, sizeof( composite_norm_data[0] ) );</a>
<a name="ln3188">#endif</a>
<a name="ln3189">    if ( ip-&gt;bAllowEmptyStructure &amp;&amp; !orig_inp_data-&gt;at &amp;&amp; !orig_inp_data-&gt;num_inp_atoms ) {</a>
<a name="ln3190">        ;</a>
<a name="ln3191">    } else</a>
<a name="ln3192">    if ( !orig_inp_data-&gt;at || !orig_inp_data-&gt;num_inp_atoms ) {</a>
<a name="ln3193">        return 0; /* nothing to do */</a>
<a name="ln3194">    }</a>
<a name="ln3195">    if ( iINChI == 1 &amp;&amp; orig_inp_data-&gt;bDisconnectCoord &lt;= 0 ) {</a>
<a name="ln3196">        return 0;</a>
<a name="ln3197">    }</a>
<a name="ln3198"> </a>
<a name="ln3199">   /* m = iINChI; */ /* orig_inp_data index */</a>
<a name="ln3200"> </a>
<a name="ln3201">    if ( iINChI != INCHI_BAS &amp;&amp; iINChI != INCHI_REC ) {</a>
<a name="ln3202">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Fatal undetermined program error&quot;);</a>
<a name="ln3203">        sd-&gt;nStructReadError =  97;</a>
<a name="ln3204">        nRet = sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln3205">        goto exit_function;</a>
<a name="ln3206">    }</a>
<a name="ln3207"> </a>
<a name="ln3208">    /*******************************************************************</a>
<a name="ln3209">     *                                                                 *</a>
<a name="ln3210">     *                                                                 *</a>
<a name="ln3211">     *  Whole structure preprocessing: 1st step of the normalization   *</a>
<a name="ln3212">     *                                                                 *</a>
<a name="ln3213">     *  Happen only on the first call to CreateOneStructureINChI()      *</a>
<a name="ln3214">     *                                                                 *</a>
<a name="ln3215">     *                                                                 *</a>
<a name="ln3216">     *******************************************************************/</a>
<a name="ln3217"> </a>
<a name="ln3218">    if ( (!prep_inp_data-&gt;at || !prep_inp_data-&gt;num_inp_atoms) &amp;&amp; orig_inp_data-&gt;num_inp_atoms &gt; 0 ) {</a>
<a name="ln3219">        /* the structure has not been preprocessed */</a>
<a name="ln3220">        if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln3221">            InchiTimeGet( &amp;ulTStart );</a>
<a name="ln3222">        }</a>
<a name="ln3223">        PreprocessOneStructure( sd, ip, orig_inp_data, prep_inp_data );</a>
<a name="ln3224">        pncFlags-&gt;bTautFlags[iINChI][TAUT_YES] =</a>
<a name="ln3225">        pncFlags-&gt;bTautFlags[iINChI][TAUT_NON] = sd-&gt;bTautFlags[INCHI_BAS] | ip-&gt;bTautFlags;</a>
<a name="ln3226">        pncFlags-&gt;bTautFlagsDone[iINChI][TAUT_YES] =</a>
<a name="ln3227">        pncFlags-&gt;bTautFlagsDone[iINChI][TAUT_NON] = sd-&gt;bTautFlagsDone[INCHI_BAS] | ip-&gt;bTautFlagsDone;</a>
<a name="ln3228"> </a>
<a name="ln3229">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln3230">        /* in this location the call happens once for each input structure, before preprocessing */</a>
<a name="ln3231">        bStructurePreprocessed = (0 != (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; (</a>
<a name="ln3232">                                        TG_FLAG_MOVE_HPLUS2NEUTR_DONE  |</a>
<a name="ln3233">                                        TG_FLAG_DISCONNECT_SALTS_DONE  |</a>
<a name="ln3234">                                        TG_FLAG_MOVE_POS_CHARGES_DONE  |</a>
<a name="ln3235">                                        TG_FLAG_FIX_ODD_THINGS_DONE    )));</a>
<a name="ln3236">        bStructureDisconnected = (0 != (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; TG_FLAG_DISCONNECT_COORD_DONE));</a>
<a name="ln3237"> </a>
<a name="ln3238">        bShowStructure = ( bStructurePreprocessed ||</a>
<a name="ln3239">                           bStructureDisconnected ||</a>
<a name="ln3240">                           prep_inp_data[0].num_components &gt; 1);</a>
<a name="ln3241"> </a>
<a name="ln3242">        /* sd-&gt;bTautFlags[] contains output flags</a>
<a name="ln3243">           ip-&gt;bTautFlags   contains input flags</a>
<a name="ln3244">        */</a>
<a name="ln3245">        bAlsoOutputReconnected = (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; TG_FLAG_DISCONNECT_COORD_DONE) &amp;&amp;</a>
<a name="ln3246">                                 (ip-&gt;bTautFlags               &amp; TG_FLAG_RECONNECT_COORD);</a>
<a name="ln3247">        bINCHI_LIB_Flag = 0;</a>
<a name="ln3248"> </a>
<a name="ln3249">        /*************** output structures to TARGET_LIB_FOR_WINCHI conditions *********************</a>
<a name="ln3250">         *</a>
<a name="ln3251">         *  Send to TARGET_LIB_FOR_WINCHI:</a>
<a name="ln3252">         *</a>
<a name="ln3253">         *  type                      component  conditions</a>
<a name="ln3254">         *</a>
<a name="ln3255">         *  COMPONENT_ORIGINAL              #0:  (num_components &gt; 1)</a>
<a name="ln3256">         *  COMPONENT_ORIGINAL_PREPROCESSED #0:  (num_components &gt; 1) &amp;&amp; (preprocessed)</a>
<a name="ln3257">         *  COMPONENT_ORIGINAL              #1:  (num_components = 1) &amp;&amp; (preprocessed)</a>
<a name="ln3258">         *</a>
<a name="ln3259">         *  Flags explanation:</a>
<a name="ln3260">         *        MAIN =&gt; iINChI=0,  RECN =&gt; iINChI=1 (Reconnected)</a>
<a name="ln3261">         *        ORIG =&gt; Original, PREP =&gt; Preprocessed</a>
<a name="ln3262">         *</a>
<a name="ln3263">         *  Possible flags:           k</a>
<a name="ln3264">         *</a>
<a name="ln3265">         *  COMP_ORIG_0_MAIN  0x0001  0  COMPONENT_ORIGINAL, bMain, component #0</a>
<a name="ln3266">         *  COMP_ORIG_0_RECN  0x0002  1  COMPONENT_ORIGINAL, bRecn, component #0</a>
<a name="ln3267">         *</a>
<a name="ln3268">         *  COMP_PREP_0_MAIN  0x0004  2  COMPONENT_ORIGINAL_PREPROCESSED, bMain, component #0</a>
<a name="ln3269">         *  COMP_PREP_0_RECN  0x0008  3  COMPONENT_ORIGINAL_PREPROCESSED, bRecn, component #0</a>
<a name="ln3270">         *</a>
<a name="ln3271">         *  COMP_ORIG_1_MAIN  0x0010  4  COMPONENT_ORIGINAL, bMain, component #1</a>
<a name="ln3272">         *  COMP_ORIG_1_RECN  0x0020  5  COMPONENT_ORIGINAL, bRecn, component #1</a>
<a name="ln3273">         *</a>
<a name="ln3274">         *  bReconnected  = k%2     (0 or 1)</a>
<a name="ln3275">         *  nComponent    = k/4     (0 or 1)</a>
<a name="ln3276">         *  bPreprocessed = (k/2)%2 (0 or 1)</a>
<a name="ln3277">         *</a>
<a name="ln3278">         ******************************************************************************/</a>
<a name="ln3279">        /* Original -&gt; Main, component #0, Original */</a>
<a name="ln3280">        if ( prep_inp_data[INCHI_BAS].num_components &gt; 1 ) {</a>
<a name="ln3281">            bINCHI_LIB_Flag |= COMP_ORIG_0_MAIN;</a>
<a name="ln3282">        } else</a>
<a name="ln3283">        /* Original -&gt; Main, component #1, Original */</a>
<a name="ln3284">        if ( prep_inp_data[INCHI_BAS].num_components == 1 &amp;&amp; bStructurePreprocessed ) {</a>
<a name="ln3285">            bINCHI_LIB_Flag |= COMP_ORIG_1_MAIN;</a>
<a name="ln3286">            /* preprocessed will be added when output canonicalization results */</a>
<a name="ln3287">        }</a>
<a name="ln3288">        if ( bAlsoOutputReconnected ) {</a>
<a name="ln3289">            /* Original -&gt; Reconnected, component #0, Original */</a>
<a name="ln3290">            if ( prep_inp_data[INCHI_REC].num_components &gt; 1 ) {</a>
<a name="ln3291">                bINCHI_LIB_Flag |= COMP_ORIG_0_RECN;</a>
<a name="ln3292">            } else</a>
<a name="ln3293">            /* Original -&gt; Reconnected, component #1, Original */</a>
<a name="ln3294">            if ( prep_inp_data[INCHI_BAS].num_components == 1 &amp;&amp; bStructurePreprocessed ) {</a>
<a name="ln3295">                bINCHI_LIB_Flag |= COMP_ORIG_1_RECN;</a>
<a name="ln3296">                /* preprocessed will be added when output canonicalization results */</a>
<a name="ln3297">            }</a>
<a name="ln3298">        }</a>
<a name="ln3299">        if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln3300">            ip-&gt;msec_LeftTime -= InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln3301">        }</a>
<a name="ln3302"> </a>
<a name="ln3303">        /* display the ORIGINAL, UN-PREPROCESSED structure */</a>
<a name="ln3304">        if ( DisplayTheWholeStructure( sd, ip, szTitle, inp_file, log_file, orig_inp_data, num_inp,</a>
<a name="ln3305">                                       -1, bShowStructure, bINCHI_LIB_Flag ) ) {</a>
<a name="ln3306">            goto exit_function;</a>
<a name="ln3307">        }</a>
<a name="ln3308">#endif</a>
<a name="ln3309">        switch (sd-&gt;nErrorType) {</a>
<a name="ln3310">        case _IS_ERROR:</a>
<a name="ln3311">        case _IS_FATAL:</a>
<a name="ln3312">            /* error message */</a>
<a name="ln3313">            nRet = TreatReadTheStructureErrors( sd, ip, LOG_MASK_ALL, inp_file, log_file, output_file, prb_file,</a>
<a name="ln3314">                                                prep_inp_data, &amp;num_inp, pStr, nStrLen );</a>
<a name="ln3315">            goto exit_cycle;</a>
<a name="ln3316">        }</a>
<a name="ln3317">    }</a>
<a name="ln3318">    /* tranfer flags from INChI_Aux to sd */</a>
<a name="ln3319"> </a>
<a name="ln3320"> </a>
<a name="ln3321"> </a>
<a name="ln3322"> </a>
<a name="ln3323"> </a>
<a name="ln3324">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln3325"> </a>
<a name="ln3326">    /******************************************/</a>
<a name="ln3327">    /*      Displaying the structures         */</a>
<a name="ln3328">    /*          Only under WIN32              */</a>
<a name="ln3329">    /******************************************/</a>
<a name="ln3330">    if ( ip-&gt;bDisplayCompositeResults &amp;&amp;</a>
<a name="ln3331">        !sd-&gt;bUserQuitComponentDisplay &amp;&amp; prep_inp_data[iINChI].num_components &gt; 1) {</a>
<a name="ln3332">        all_inp_norm_data = (INP_ATOM_DATA2 *)inchi_calloc( prep_inp_data[iINChI].num_components, sizeof(all_inp_norm_data[0]));</a>
<a name="ln3333">    }</a>
<a name="ln3334"> </a>
<a name="ln3335"> </a>
<a name="ln3336">    /* Display the input structure AFTER PREPROCESSING */</a>
<a name="ln3337">    switch ( iINChI ) {</a>
<a name="ln3338"> </a>
<a name="ln3339">    case INCHI_BAS:</a>
<a name="ln3340">        /*------------ Possibly disconnected structure -------------------*/</a>
<a name="ln3341">        bStructurePreprocessed = 0 != (sd-&gt;bTautFlagsDone[iINChI] &amp; (</a>
<a name="ln3342">                                        TG_FLAG_MOVE_HPLUS2NEUTR_DONE  |</a>
<a name="ln3343">                                        TG_FLAG_DISCONNECT_SALTS_DONE  |</a>
<a name="ln3344">                                        TG_FLAG_MOVE_POS_CHARGES_DONE  |</a>
<a name="ln3345">                                        TG_FLAG_MOVE_CHARGE_COORD_DONE |</a>
<a name="ln3346">                                        TG_FLAG_DISCONNECT_COORD_DONE  |</a>
<a name="ln3347">                                        TG_FLAG_FIX_ODD_THINGS_DONE    ));</a>
<a name="ln3348">        bINCHI_LIB_Flag = 0;</a>
<a name="ln3349"> </a>
<a name="ln3350">        /* Preprocessed/Main -&gt; Main, component #0, Preprocessed */</a>
<a name="ln3351">        if ( prep_inp_data[iINChI].num_components &gt; 1 &amp;&amp; bStructurePreprocessed ) {</a>
<a name="ln3352">            bINCHI_LIB_Flag |= COMP_PREP_0_MAIN;</a>
<a name="ln3353">        }</a>
<a name="ln3354"> </a>
<a name="ln3355">        bShowStructure = ( bStructurePreprocessed &amp;&amp; prep_inp_data[iINChI].num_components &gt; 1);</a>
<a name="ln3356">        break;</a>
<a name="ln3357"> </a>
<a name="ln3358">    case INCHI_REC:</a>
<a name="ln3359">        /*------------ Reconnected structure ------------------------------*/</a>
<a name="ln3360">        bAlsoOutputReconnected = (sd-&gt;bTautFlagsDone[INCHI_BAS] &amp; TG_FLAG_DISCONNECT_COORD_DONE) &amp;&amp;</a>
<a name="ln3361">                                 (ip-&gt;bTautFlags               &amp; TG_FLAG_RECONNECT_COORD);</a>
<a name="ln3362">        if ( !bAlsoOutputReconnected ) {</a>
<a name="ln3363">            break;</a>
<a name="ln3364">        }</a>
<a name="ln3365">        bStructurePreprocessed = 0 != (sd-&gt;bTautFlagsDone[iINChI] &amp; (</a>
<a name="ln3366">                                        TG_FLAG_MOVE_HPLUS2NEUTR_DONE  |</a>
<a name="ln3367">                                        TG_FLAG_DISCONNECT_SALTS_DONE  |</a>
<a name="ln3368">                                        TG_FLAG_MOVE_POS_CHARGES_DONE  |</a>
<a name="ln3369">                                        TG_FLAG_FIX_ODD_THINGS_DONE    ));</a>
<a name="ln3370">        bINCHI_LIB_Flag = 0;</a>
<a name="ln3371"> </a>
<a name="ln3372">        /* Preprocessed/Reconnected -&gt; Reconnected, component #0, Preprocessed */</a>
<a name="ln3373">        if ( prep_inp_data[iINChI].num_components &gt; 1 &amp;&amp; bStructurePreprocessed ) {</a>
<a name="ln3374">            bINCHI_LIB_Flag |= COMP_PREP_0_RECN;</a>
<a name="ln3375">        }</a>
<a name="ln3376"> </a>
<a name="ln3377">        bShowStructure = ( bStructurePreprocessed &amp;&amp; prep_inp_data[iINChI].num_components &gt; 1 );</a>
<a name="ln3378">        break;</a>
<a name="ln3379">    default:</a>
<a name="ln3380">        bShowStructure = 0;</a>
<a name="ln3381">    }</a>
<a name="ln3382">    if ( prep_inp_data[iINChI].num_inp_atoms &gt; 0 ) {</a>
<a name="ln3383">        if ( DisplayTheWholeStructure( sd, ip, szTitle, inp_file, log_file, prep_inp_data+iINChI, num_inp,</a>
<a name="ln3384">                                       iINChI, bShowStructure, bINCHI_LIB_Flag ) ) {</a>
<a name="ln3385">            goto exit_function;</a>
<a name="ln3386">        }</a>
<a name="ln3387">    }</a>
<a name="ln3388">#endif /* } ifndef COMPILE_ANSI_ONLY */</a>
<a name="ln3389"> </a>
<a name="ln3390"> </a>
<a name="ln3391"> </a>
<a name="ln3392">    /* allocate pINChI[iINChI] and pINChI_Aux2[iINChI] -- arrays of pointers to INChI and INChI_Aux */</a>
<a name="ln3393">    /* assign values to sd-&gt;num_components[]                                                  */</a>
<a name="ln3394">    MYREALLOC2(PINChI2, PINChI_Aux2, pINChI2[iINChI], pINChI_Aux2[iINChI], sd-&gt;num_components[iINChI], cur_prep_inp_data-&gt;num_components, k);</a>
<a name="ln3395">    if ( k ) {</a>
<a name="ln3396">        AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot allocate output data. Terminating&quot;);</a>
<a name="ln3397">        sd-&gt;nStructReadError =  99;</a>
<a name="ln3398">        sd-&gt;nErrorType = _IS_FATAL;</a>
<a name="ln3399">        goto exit_function;</a>
<a name="ln3400">    }</a>
<a name="ln3401">    pINChI     = pINChI2[iINChI];</a>
<a name="ln3402">    pINChI_Aux = pINChI_Aux2[iINChI];</a>
<a name="ln3403"> </a>
<a name="ln3404">    /**************************************************************************/</a>
<a name="ln3405">    /*                                                                        */</a>
<a name="ln3406">    /*                                                                        */</a>
<a name="ln3407">    /*   M A I N   C Y C L E:   P R O C E S S    C O M P O N E N T S          */</a>
<a name="ln3408">    /*                                                                        */</a>
<a name="ln3409">    /*                                                                        */</a>
<a name="ln3410">    /*                     O N E   B Y   O N E                                */</a>
<a name="ln3411">    /*                                                                        */</a>
<a name="ln3412">    /*                                                                        */</a>
<a name="ln3413">    /**************************************************************************/</a>
<a name="ln3414"> </a>
<a name="ln3415">    for ( i = 0, nRet = 0; !sd-&gt;bUserQuitComponent &amp;&amp; i &lt; cur_prep_inp_data-&gt;num_components; i ++ ) {</a>
<a name="ln3416">        if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln3417">            InchiTimeGet( &amp;ulTStart );</a>
<a name="ln3418">        }</a>
<a name="ln3419">#ifndef TARGET_LIB_FOR_WINCHI  /* { */</a>
<a name="ln3420">#if ( bREUSE_INCHI == 1 )</a>
<a name="ln3421">        if ( iINChI == INCHI_REC &amp;&amp; ((!ip-&gt;bDisplay &amp;&amp; !ip-&gt;bDisplayCompositeResults &amp;&amp; !(ip-&gt;bCompareComponents &amp; CMP_COMPONENTS)) ||</a>
<a name="ln3422">                                   sd-&gt;bUserQuitComponentDisplay) ) {</a>
<a name="ln3423">            /* reconnected structure (06-20-2005: added &quot;&amp;&amp; !ip-&gt;bDisplayCompositeResults&quot; to display composite structure) */</a>
<a name="ln3424">            int m = iINChI-1;</a>
<a name="ln3425">            /* find whether we have already calculated this INChI in basic (disconnected) layer */</a>
<a name="ln3426">            for ( j = n = 0; j &lt; prep_inp_data[m].num_components; j ++ ) {</a>
<a name="ln3427">                if ( i+1 == prep_inp_data[m].nOldCompNumber[j] &amp;&amp;</a>
<a name="ln3428">                     (pINChI2[m][j][TAUT_NON] || pINChI2[m][j][TAUT_YES]) ) {</a>
<a name="ln3429">                    /* yes, we have already done this */</a>
<a name="ln3430">                    if ( !n++ ) {</a>
<a name="ln3431">                        memcpy( pINChI    +i, pINChI2    [m]+j, sizeof(pINChI[0]));</a>
<a name="ln3432">                        memcpy( pINChI_Aux+i, pINChI_Aux2[m]+j, sizeof(pINChI_Aux[0]));</a>
<a name="ln3433">                        for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln3434">                            if ( pINChI[i][k] ) {</a>
<a name="ln3435">                                pINChI[i][k]-&gt;nRefCount ++;</a>
<a name="ln3436">                                if ( pINChI[i][k]-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln3437">                                    switch( k ) {</a>
<a name="ln3438">                                    case TAUT_NON:</a>
<a name="ln3439">                                        sd-&gt;num_non_taut[iINChI] ++;</a>
<a name="ln3440">                                        break;</a>
<a name="ln3441">                                    case TAUT_YES:</a>
<a name="ln3442">                                        if ( pINChI[i][k]-&gt;lenTautomer &gt; 0 ) {</a>
<a name="ln3443">                                            sd-&gt;num_taut[iINChI] ++;</a>
<a name="ln3444">                                        } else</a>
<a name="ln3445">                                        if ( !pINChI[i][TAUT_NON] || !pINChI[i][TAUT_NON]-&gt;nNumberOfAtoms ) {</a>
<a name="ln3446">                                            sd-&gt;num_non_taut[iINChI] ++;</a>
<a name="ln3447">                                        }</a>
<a name="ln3448">                                        break;</a>
<a name="ln3449">                                    }</a>
<a name="ln3450">                                }</a>
<a name="ln3451">                            }</a>
<a name="ln3452">                            if ( pINChI_Aux[i][k] ) {</a>
<a name="ln3453">                                pINChI_Aux[i][k]-&gt;nRefCount ++;</a>
<a name="ln3454">                            }</a>
<a name="ln3455">                        }</a>
<a name="ln3456">                    }</a>
<a name="ln3457">                }</a>
<a name="ln3458">            }</a>
<a name="ln3459">            if ( n == 1 ) {</a>
<a name="ln3460">                continue;</a>
<a name="ln3461">            }</a>
<a name="ln3462">            if ( n &gt; 1 ) { /* ith component is equivalent to more than one another component */</a>
<a name="ln3463">                AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot distinguish components&quot;);</a>
<a name="ln3464">                sd-&gt;nStructReadError =  99;</a>
<a name="ln3465">                sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln3466">                goto exit_function;</a>
<a name="ln3467">            }</a>
<a name="ln3468">        }</a>
<a name="ln3469">#endif</a>
<a name="ln3470">#endif /* } TARGET_LIB_FOR_WINCHI */</a>
<a name="ln3471"> </a>
<a name="ln3472">        /*****************************************************/</a>
<a name="ln3473">        /*  a) allocate memory and extract current component */</a>
<a name="ln3474">        /*****************************************************/</a>
<a name="ln3475">        nRet = GetOneComponent( sd, ip, log_file, output_file, inp_cur_data, cur_prep_inp_data, i, num_inp, pStr, nStrLen );</a>
<a name="ln3476">        if ( ip-&gt;msec_MaxTime ) {</a>
<a name="ln3477">            ip-&gt;msec_LeftTime -= InchiTimeElapsed( &amp;ulTStart );</a>
<a name="ln3478">        }</a>
<a name="ln3479">        switch ( nRet ) {</a>
<a name="ln3480">        case _IS_ERROR:</a>
<a name="ln3481">        case _IS_FATAL:</a>
<a name="ln3482">            goto exit_cycle;</a>
<a name="ln3483">        }</a>
<a name="ln3484">#ifndef TARGET_API_LIB</a>
<a name="ln3485">        /*  console request: Display the component? */</a>
<a name="ln3486">        if ( ip-&gt;bDisplay &amp;&amp; inp_file-&gt;f != stdin ) {</a>
<a name="ln3487">            if ( user_quit(&quot;Enter=Display Component, Esc=Stop ?&quot;, ip-&gt;ulDisplTime) ) {</a>
<a name="ln3488">                sd-&gt;bUserQuitComponent = 1;</a>
<a name="ln3489">                break;</a>
<a name="ln3490">            }</a>
<a name="ln3491">        }</a>
<a name="ln3492">#endif</a>
<a name="ln3493">#ifndef COMPILE_ANSI_ONLY  /* { */</a>
<a name="ln3494">        /*  b) Display the extracted original component structure */</a>
<a name="ln3495">        if ( inp_cur_data-&gt;at &amp;&amp; ip-&gt;bDisplay &amp;&amp; !sd-&gt;bUserQuitComponentDisplay ) {</a>
<a name="ln3496">            if ( cur_prep_inp_data-&gt;num_components == 1 ) {</a>
<a name="ln3497">                sprintf( szTitle, &quot;%sInput Structure #%ld.%s%s%s%s%s&quot;,</a>
<a name="ln3498">                                  bStructurePreprocessed? &quot;Preprocessed &quot;:&quot;&quot;,</a>
<a name="ln3499">                                  num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), iINChI? &quot; (Reconnected)&quot;:&quot;&quot;);</a>
<a name="ln3500">            } else {</a>
<a name="ln3501">                sprintf( szTitle, &quot;Component #%d of %d, Input Structure #%ld.%s%s%s%s%s&quot;,</a>
<a name="ln3502">                                  i+1, cur_prep_inp_data-&gt;num_components,</a>
<a name="ln3503">                                  num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), iINChI? &quot; (Reconnected)&quot;:&quot;&quot;);</a>
<a name="ln3504">            }</a>
<a name="ln3505">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln3506">            err = DisplayStructure( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at,</a>
<a name="ln3507">                                    0, 1, 0, NULL, 1/*isotopic*/, 0/*taut*/, NULL, NULL,</a>
<a name="ln3508">                                    ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln3509">            sd-&gt;bUserQuitComponentDisplay = (err==ESC_KEY);</a>
<a name="ln3510">            if ( !err ) </a>
<a name="ln3511">            {</a>
<a name="ln3512">                inchi_fprintf( stderr, &quot;Cannot display the structure\n&quot;);</a>
<a name="ln3513">            }</a>
<a name="ln3514">#else</a>
<a name="ln3515">            if(DRAWDATA &amp;&amp; DRAWDATA_EXISTS)</a>
<a name="ln3516">            {</a>
<a name="ln3517">                struct DrawData vDrawData;</a>
<a name="ln3518">                int    nType = COMPONENT_ORIGINAL;</a>
<a name="ln3519">                vDrawData.pWindowData = CreateWinData_( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at,</a>
<a name="ln3520">                                                        0, 1 /* bAdd_DT_to_num_H */, 0, NULL,</a>
<a name="ln3521">                                                        1 /* display isotopic if present */, 0, NULL, NULL,</a>
<a name="ln3522">                                                        ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode );</a>
<a name="ln3523">                if( vDrawData.pWindowData != NULL )</a>
<a name="ln3524">                {</a>
<a name="ln3525">                    if ( DRAWDATA_EXISTS ( i+1, nType, iINChI ) ) {  /* i = component number */</a>
<a name="ln3526">                        nType = COMPONENT_ORIGINAL_PREPROCESSED;</a>
<a name="ln3527">                    }</a>
<a name="ln3528">                    vDrawData.nComponent   = i+1;</a>
<a name="ln3529">                    vDrawData.nType        = nType;</a>
<a name="ln3530">                       vDrawData.bReconnected = iINChI; /* 0=&gt;main; 1=&gt;reconnected */</a>
<a name="ln3531">                    vDrawData.szTitle              = _strdup(szTitle);</a>
<a name="ln3532">                    vDrawData.pWindowData-&gt;szTitle = _strdup(szTitle);</a>
<a name="ln3533">                    DRAWDATA(&amp;vDrawData);</a>
<a name="ln3534">                }</a>
<a name="ln3535">            }</a>
<a name="ln3536">#endif</a>
<a name="ln3537">        }</a>
<a name="ln3538">#endif   /* } COMPILE_ANSI_ONLY */</a>
<a name="ln3539"> </a>
<a name="ln3540">#if ( TEST_RENUMB_ATOMS == 1 ) /* { */</a>
<a name="ln3541">        /****************************************************************************/</a>
<a name="ln3542">        /*     R E N U M B E R I N G (testing only) Part I  STARTS here             */</a>
<a name="ln3543">        /****************************************************************************/</a>
<a name="ln3544">        RenumberingTestInit( pRenumbData, inp_cur_data );</a>
<a name="ln3545">        if ( log_file != stderr ) {</a>
<a name="ln3546">            if ( ip-&gt;bDisplay )</a>
<a name="ln3547">                inchi_ios_eprint( log_file, &quot;Component #%d structure #%ld.%s%s%s%s...\n&quot;, i+1, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln3548">            else</a>
<a name="ln3549">                inchi_ios_eprint( stderr, &quot;Component #%d structure #%ld.%s%s%s%s...\r&quot;, i+1, num_inp, SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue) );</a>
<a name="ln3550">        }</a>
<a name="ln3551">        /****************************************************************************/</a>
<a name="ln3552">        /*     R E N U M B E R I N G (testing only) Part I  ENDS here               */</a>
<a name="ln3553">        /****************************************************************************/</a>
<a name="ln3554">#endif  /* } TEST_RENUMB_ATOMS */</a>
<a name="ln3555"> </a>
<a name="ln3556"> </a>
<a name="ln3557">        /*******************************************************************************/</a>
<a name="ln3558">        /*                                                                             */</a>
<a name="ln3559">        /*  N O R M A L I Z A T I O N    a n d     C A N O N I C A L I Z A T I O N     */</a>
<a name="ln3560">        /*                                                                             */</a>
<a name="ln3561">        /*         (both tautomeric and non-tautomeric if requested)                   */</a>
<a name="ln3562">        /*                                                                             */</a>
<a name="ln3563">        /*******************************************************************************/</a>
<a name="ln3564">        /*  c) Create the component's INChI ( copies ip-&gt;bTautFlags into sd-&gt;bTautFlags)*/</a>
<a name="ln3565">        /*******************************************************************************/</a>
<a name="ln3566">        nRet = CreateOneComponentINChI( sd, ip, inp_cur_data, orig_inp_data, pINChI/*2[iINChI]*/, pINChI_Aux/*2[iINChI]*/, iINChI,</a>
<a name="ln3567">                                       i, num_inp, inp_norm_data, pncFlags, log_file );</a>
<a name="ln3568"> </a>
<a name="ln3569"> </a>
<a name="ln3570">#if ( TEST_RENUMB_ATOMS == 1 )  /*  { */</a>
<a name="ln3571">        /****************************************************************************/</a>
<a name="ln3572">        /*     R E N U M B E R I N G (testing only) Part II STARTS here             */</a>
<a name="ln3573">        /****************************************************************************/</a>
<a name="ln3574">        if ( !nRet ) {</a>
<a name="ln3575">            nRet = RenumberingTest( pINChI/*2[iINChI]*/, pINChI_Aux/*2[iINChI]*/, orig_inp_data, iINChI, pRenumbData, inp_cur_data, inp_norm_data, sd, ip, szTitle, log_file, prb_file, i, num_inp, pncFlags);</a>
<a name="ln3576">        }</a>
<a name="ln3577">        RenumberingTestUninit( pRenumbData );</a>
<a name="ln3578">        /****************************************************************************/</a>
<a name="ln3579">        /*     R E N U M B E R I N G (testing only)  Part II  ENDS here             */</a>
<a name="ln3580">        /****************************************************************************/</a>
<a name="ln3581">#endif  /*  }  TEST_RENUMB_ATOMS */</a>
<a name="ln3582"> </a>
<a name="ln3583"> </a>
<a name="ln3584">        /*  d) Display one component structure and/or INChI results only if there was no error */</a>
<a name="ln3585">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln3586">        if ( !nRet ) {</a>
<a name="ln3587">            /*  output one component INChI to the stdout if requested */</a>
<a name="ln3588">            /*</a>
<a name="ln3589">            if ( ip-&gt;bDisplayEachComponentINChI ) {</a>
<a name="ln3590">                int cur_num_non_taut = (pINChI[i][TAUT_NON] &amp;&amp; pINChI[i][TAUT_NON]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln3591">                int cur_num_taut     = (pINChI[i][TAUT_YES] &amp;&amp; pINChI[i][TAUT_YES]-&gt;nNumberOfAtoms&gt;0);</a>
<a name="ln3592">                if ( ip-&gt;bDisplayEachComponentINChI &amp;&amp; cur_num_non_taut + cur_num_taut ) {</a>
<a name="ln3593">                    SortAndPrintINChI(stdout, pStr, nStrLen, NULL, </a>
<a name="ln3594">                                      ip, 1, cur_num_non_taut, cur_num_taut,</a>
<a name="ln3595">                                      num_inp, pINChI+i, pINChI_Aux+i, </a>
<a name="ln3596">                                      save_opt_bits);</a>
<a name="ln3597">                }</a>
<a name="ln3598">            }</a>
<a name="ln3599">            */</a>
<a name="ln3600">            /**************************************************************************</a>
<a name="ln3601">             * display from one up to 4 structure pictures-results for each component *</a>
<a name="ln3602">             * Enable buttons:                                                        *</a>
<a name="ln3603">             * BN (non-tautomeric non-isotopic): inp_norm_data[0]-&gt;bExists            *</a>
<a name="ln3604">             * TN (tautomeric non-isotopic):     inp_norm_data[1]-&gt;bExists            *</a>
<a name="ln3605">             * BI (non-tautomeric isotopic):     inp_norm_data[0]-&gt;bExists &amp;&amp;         *</a>
<a name="ln3606">             *                                   inp_norm_data[0]-&gt;bHasIsotopicLayer  *</a>
<a name="ln3607">             * TI (tautomeric isotopic):         inp_norm_data[1]-&gt;bExists &amp;&amp;         *</a>
<a name="ln3608">             *                                   inp_norm_data[1]-&gt;bHasIsotopicLayer  *</a>
<a name="ln3609">             **************************************************************************/</a>
<a name="ln3610">            int bIsotopic, bTautomeric, bDisplayTaut, bHasIsotopicLayer, bFixedBondsTaut, m_max, m, nNumDisplayedFixedBondTaut=0;</a>
<a name="ln3611">            for ( j = 0; ip-&gt;bDisplay &amp;&amp; !sd-&gt;bUserQuitComponentDisplay &amp;&amp; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3612">                if ( inp_norm_data[j]-&gt;bExists &amp;&amp; !inp_norm_data[j]-&gt;bDeleted ) {</a>
<a name="ln3613">                    bTautomeric = (pINChI[i][j]-&gt;lenTautomer &gt; 0); /* same as (inp_norm_data[j]-&gt;bTautomeric &gt; 0) */</a>
<a name="ln3614">                    /* if requested tautomeric and no tautmerism found then do not say mobile or fixed H. 2004-10-27 */</a>
<a name="ln3615">                    bDisplayTaut = (!(ip-&gt;nMode &amp; REQ_MODE_BASIC) &amp;&amp; !bTautomeric)? -1 : bTautomeric;</a>
<a name="ln3616">                    bHasIsotopicLayer = (inp_norm_data[j]-&gt;bHasIsotopicLayer &gt; 0);</a>
<a name="ln3617">                    for ( k = 0; k &lt;= bHasIsotopicLayer; k ++ ) {</a>
<a name="ln3618">                        bIsotopic = (k &gt; 0);</a>
<a name="ln3619">                        m_max = inp_norm_data[j]-&gt;at_fixed_bonds &amp;&amp; inp_norm_data[j]-&gt;bTautPreprocessed? 1 : 0;</a>
<a name="ln3620">                        for ( m = m_max; 0 &lt;= m; m -- ) {</a>
<a name="ln3621">                            bFixedBondsTaut = (m&gt;0);</a>
<a name="ln3622">                            nNumDisplayedFixedBondTaut += bFixedBondsTaut; /* display only one time */</a>
<a name="ln3623">                            /*  added number of components, added another format for a single component case - DCh */</a>
<a name="ln3624">                            if ( cur_prep_inp_data-&gt;num_components &gt; 1 ) {</a>
<a name="ln3625">                                sprintf( szTitle, &quot;%s Component #%d of %d, Structure #%ld%s%s.%s%s%s%s%s&quot;,</a>
<a name="ln3626">                                              bFixedBondsTaut? &quot;Preprocessed&quot;:&quot;Result for&quot;,</a>
<a name="ln3627">                                              i+1, cur_prep_inp_data-&gt;num_components, num_inp,</a>
<a name="ln3628">                                              bDisplayTaut==1? &quot;, mobile H&quot;: bDisplayTaut==0?&quot;, fixed H&quot;:&quot;&quot;,</a>
<a name="ln3629">                                              bIsotopic? &quot;, isotopic&quot;:&quot;&quot;,</a>
<a name="ln3630">                                              SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), iINChI? &quot; (Reconnected)&quot;:&quot;&quot;);</a>
<a name="ln3631">                            } else {</a>
<a name="ln3632">                                sprintf( szTitle, &quot;%s Structure #%ld%s%s.%s%s%s%s%s&quot;,</a>
<a name="ln3633">                                              bFixedBondsTaut? &quot;Preprocessed&quot;:&quot;Result for&quot;,</a>
<a name="ln3634">                                              num_inp,</a>
<a name="ln3635">                                              bDisplayTaut==1? &quot;, mobile H&quot;: bDisplayTaut==0?&quot;, fixed H&quot;:&quot;&quot;,</a>
<a name="ln3636">                                              bIsotopic? &quot;, isotopic&quot;:&quot;&quot;,</a>
<a name="ln3637">                                              SDF_LBL_VAL(ip-&gt;pSdfLabel,ip-&gt;pSdfValue), iINChI? &quot; (Reconnected)&quot;:&quot;&quot;);</a>
<a name="ln3638">                            }</a>
<a name="ln3639">#ifndef TARGET_LIB_FOR_WINCHI</a>
<a name="ln3640">                            if ( bFixedBondsTaut &amp;&amp; nNumDisplayedFixedBondTaut != 1 )</a>
<a name="ln3641">                                continue;</a>
<a name="ln3642">                            if ( bFixedBondsTaut ) {</a>
<a name="ln3643">                                err = DisplayStructure( inp_norm_data[j]-&gt;at_fixed_bonds, inp_norm_data[j]-&gt;num_at,</a>
<a name="ln3644">                                                        inp_norm_data[j]-&gt;num_removed_H, 0 /*bAdd_DT_to_num_H*/,</a>
<a name="ln3645">                                                        inp_norm_data[j]-&gt;nNumRemovedProtons,</a>
<a name="ln3646">                                                        inp_norm_data[j]-&gt;nNumRemovedProtonsIsotopic,</a>
<a name="ln3647">                                                        bHasIsotopicLayer, j, NULL,  NULL,</a>
<a name="ln3648">                                                        ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln3649">                            } else {</a>
<a name="ln3650">                                err = DisplayStructure( inp_norm_data[j]-&gt;at, inp_norm_data[j]-&gt;num_at,</a>
<a name="ln3651">                                                        0, 0 /*bAdd_DT_to_num_H*/, 0, NULL,</a>
<a name="ln3652">                                                        k, j, pINChI[i], pINChI_Aux[i],</a>
<a name="ln3653">                                                        ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode, szTitle );</a>
<a name="ln3654">                            }</a>
<a name="ln3655">                            if ( sd-&gt;bUserQuitComponentDisplay = (err==ESC_KEY) ) {</a>
<a name="ln3656">                                break;</a>
<a name="ln3657">                            }</a>
<a name="ln3658">#else</a>
<a name="ln3659">                            if(DRAWDATA &amp;&amp; !bFixedBondsTaut)</a>
<a name="ln3660">                            {</a>
<a name="ln3661">                                struct DrawData vDrawData;</a>
<a name="ln3662">                                vDrawData.pWindowData = CreateWinData_( inp_norm_data[j]-&gt;at, inp_norm_data[j]-&gt;num_at,</a>
<a name="ln3663">                                                        0, 0 /* bAdd_DT_to_num_H */, 0, NULL,</a>
<a name="ln3664">                                                        k, j, pINChI[i], pINChI_Aux[i],</a>
<a name="ln3665">                                                        ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode );</a>
<a name="ln3666">                                if( vDrawData.pWindowData != NULL )</a>
<a name="ln3667">                                {</a>
<a name="ln3668">                                    int nType;</a>
<a name="ln3669">                                    vDrawData.nComponent = i+1;</a>
<a name="ln3670">                                    if( bTautomeric == 0 )</a>
<a name="ln3671">                                        nType = (bIsotopic == 0) ? COMPONENT_BN: COMPONENT_BI;</a>
<a name="ln3672">                                    else</a>
<a name="ln3673">                                        nType = (bIsotopic == 0) ? COMPONENT_TN: COMPONENT_TI;</a>
<a name="ln3674">                                    vDrawData.nType        = nType;</a>
<a name="ln3675">                                       vDrawData.bReconnected = iINChI; /* 0=&gt;main; 1=&gt;reconnected */</a>
<a name="ln3676">                                    vDrawData.szTitle              = _strdup(szTitle);</a>
<a name="ln3677">                                    vDrawData.pWindowData-&gt;szTitle = _strdup(szTitle);</a>
<a name="ln3678">                                    DRAWDATA(&amp;vDrawData);</a>
<a name="ln3679">                                }</a>
<a name="ln3680">                            } else</a>
<a name="ln3681">                            if(DRAWDATA &amp;&amp; bFixedBondsTaut)</a>
<a name="ln3682">                            {</a>
<a name="ln3683">                                struct DrawData vDrawData;</a>
<a name="ln3684">                                if ( (ip-&gt;bCompareComponents &amp; CMP_COMPONENTS) &amp;&amp;</a>
<a name="ln3685">                                     !(ip-&gt;bCompareComponents &amp; CMP_COMPONENTS_NONTAUT) &amp;&amp;</a>
<a name="ln3686">                                     !bIsotopic == !inp_norm_data[j]-&gt;bHasIsotopicLayer ) {</a>
<a name="ln3687"> </a>
<a name="ln3688">                                    vDrawData.pWindowData =</a>
<a name="ln3689">                                         CreateWinData_( inp_norm_data[j]-&gt;at_fixed_bonds, inp_norm_data[j]-&gt;num_at,</a>
<a name="ln3690">                                                         inp_norm_data[j]-&gt;num_removed_H,</a>
<a name="ln3691">                                                         0 /* bAdd_DT_to_num_H */,</a>
<a name="ln3692">                                                         inp_norm_data[j]-&gt;nNumRemovedProtons,</a>
<a name="ln3693">                                                         inp_norm_data[j]-&gt;nNumRemovedProtonsIsotopic,</a>
<a name="ln3694">                                                         k, j, NULL, NULL,</a>
<a name="ln3695">                                                         ip-&gt;bAbcNumbers, &amp;ip-&gt;dp, ip-&gt;nMode );</a>
<a name="ln3696">                                } else {</a>
<a name="ln3697">                                    continue;</a>
<a name="ln3698">                                }</a>
<a name="ln3699">                                if( vDrawData.pWindowData != NULL )</a>
<a name="ln3700">                                {</a>
<a name="ln3701">                                    vDrawData.nComponent = i+1;</a>
<a name="ln3702">                                    vDrawData.nType        = COMPONENT_ORIGINAL_PREPROCESSED;</a>
<a name="ln3703">                                       vDrawData.bReconnected = iINChI; /* 0=&gt;main; 1=&gt;reconnected */</a>
<a name="ln3704">                                    vDrawData.szTitle              = _strdup(szTitle);</a>
<a name="ln3705">                                    vDrawData.pWindowData-&gt;szTitle = _strdup(szTitle);</a>
<a name="ln3706">                                    DRAWDATA(&amp;vDrawData);</a>
<a name="ln3707">                                }</a>
<a name="ln3708">                            }</a>
<a name="ln3709">#endif</a>
<a name="ln3710">                        }</a>
<a name="ln3711">                    }</a>
<a name="ln3712">                }</a>
<a name="ln3713">            }</a>
<a name="ln3714"> </a>
<a name="ln3715">            /* save normalized components for composite display */</a>
<a name="ln3716">            if ( ip-&gt;bDisplayCompositeResults &amp;&amp; all_inp_norm_data ) {</a>
<a name="ln3717">                for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3718">                    if ( inp_norm_data[j]-&gt;bExists ) {</a>
<a name="ln3719">                        all_inp_norm_data[i][j] = *inp_norm_data[j];</a>
<a name="ln3720">                        memset( inp_norm_data[j], 0, sizeof(*inp_norm_data[0]) );</a>
<a name="ln3721">                    }</a>
<a name="ln3722">                }</a>
<a name="ln3723">            }</a>
<a name="ln3724"> </a>
<a name="ln3725">        }</a>
<a name="ln3726">#endif  /* } COMPILE_ANSI_ONLY */</a>
<a name="ln3727">        if ( nRet ) {</a>
<a name="ln3728">            nRet = TreatCreateOneComponentINChIError(sd, ip, cur_prep_inp_data, i, num_inp,</a>
<a name="ln3729">                                 inp_file, log_file, output_file, prb_file,pStr, nStrLen );</a>
<a name="ln3730"> </a>
<a name="ln3731">            break;</a>
<a name="ln3732">        }</a>
<a name="ln3733">    }</a>
<a name="ln3734">    /**************************************************************************/</a>
<a name="ln3735">    /*                                                                        */</a>
<a name="ln3736">    /*                                                                        */</a>
<a name="ln3737">    /*   E N D   O F   T H E    M A I N   C Y C L E   P R O C E S S I N G     */</a>
<a name="ln3738">    /*                                                                        */</a>
<a name="ln3739">    /*          C O M P O N E N T S    O N E   B Y   O N E                    */</a>
<a name="ln3740">    /*                                                                        */</a>
<a name="ln3741">    /*                                                                        */</a>
<a name="ln3742">    /**************************************************************************/</a>
<a name="ln3743"> </a>
<a name="ln3744"> </a>
<a name="ln3745">exit_cycle:</a>
<a name="ln3746"> </a>
<a name="ln3747">#if ( TEST_RENUMB_ATOMS == 1 )  /* { */</a>
<a name="ln3748">    if ( pRenumbData-&gt;bRenumbErr &amp;&amp; (!nRet || nRet==_IS_WARNING) ) {</a>
<a name="ln3749">        sd-&gt;nErrorCode = pRenumbData-&gt;bRenumbErr;</a>
<a name="ln3750">        nRet = TreatCreateOneComponentINChIError(sd, ip, cur_prep_inp_data, -1, num_inp,</a>
<a name="ln3751">                             inp_file, log_file, output_file, prb_file,pStr, nStrLen );</a>
<a name="ln3752">        /* nRet = _IS_ERROR; */</a>
<a name="ln3753">        sd-&gt;nErrorCode = 0;</a>
<a name="ln3754">        nRet           = 0;</a>
<a name="ln3755">    }</a>
<a name="ln3756">#endif /* } TEST_RENUMB_ATOMS */</a>
<a name="ln3757">    switch ( nRet ) {</a>
<a name="ln3758"> </a>
<a name="ln3759">    case _IS_FATAL:</a>
<a name="ln3760">    case _IS_ERROR:</a>
<a name="ln3761">        break;</a>
<a name="ln3762"> </a>
<a name="ln3763">    default:</a>
<a name="ln3764"> </a>
<a name="ln3765">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln3766">        /* composite results picture(s) */</a>
<a name="ln3767">        if ( all_inp_norm_data ) {</a>
<a name="ln3768">             int res = CreateCompositeNormAtom( composite_norm_data, all_inp_norm_data, pINChI, pINChI_Aux,</a>
<a name="ln3769">                                          prep_inp_data[iINChI].num_components, ip-&gt;nMode );</a>
<a name="ln3770">             /*</a>
<a name="ln3771">             for ( i = 0; i &lt; prep_inp_data[iINChI].num_components; i ++ ) {</a>
<a name="ln3772">                 for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln3773">                    FreeInpAtomData( &amp;all_inp_norm_data[i][k] );</a>
<a name="ln3774">                 }</a>
<a name="ln3775">             }</a>
<a name="ln3776">             inchi_free( all_inp_norm_data );</a>
<a name="ln3777">             all_inp_norm_data = NULL;</a>
<a name="ln3778">             */</a>
<a name="ln3779">        }</a>
<a name="ln3780">#endif /* } COMPILE_ANSI_ONLY */</a>
<a name="ln3781"> </a>
<a name="ln3782">        break;</a>
<a name="ln3783">    }</a>
<a name="ln3784"> </a>
<a name="ln3785"> </a>
<a name="ln3786">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln3787">        /* avoid memory leaks in case of error */</a>
<a name="ln3788">        if ( all_inp_norm_data ) {</a>
<a name="ln3789">             for ( i = 0; i &lt; prep_inp_data[iINChI].num_components; i ++ ) {</a>
<a name="ln3790">                 for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln3791">                    FreeInpAtomData( &amp;all_inp_norm_data[i][k] );</a>
<a name="ln3792">                 }</a>
<a name="ln3793">             }</a>
<a name="ln3794">             inchi_free( all_inp_norm_data );</a>
<a name="ln3795">             all_inp_norm_data = NULL;</a>
<a name="ln3796">        }</a>
<a name="ln3797">#endif /* } COMPILE_ANSI_ONLY */</a>
<a name="ln3798"> </a>
<a name="ln3799"> </a>
<a name="ln3800">    FreeInpAtomData( inp_cur_data     );</a>
<a name="ln3801">    for ( i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln3802">        FreeInpAtomData( inp_norm_data[i] );</a>
<a name="ln3803">    }</a>
<a name="ln3804"> </a>
<a name="ln3805"> </a>
<a name="ln3806">exit_function:</a>
<a name="ln3807"> </a>
<a name="ln3808">    return nRet;</a>
<a name="ln3809">}</a>
<a name="ln3810"> </a>
<a name="ln3811"> </a>
<a name="ln3812"> </a>
<a name="ln3813">#ifndef COMPILE_ANSI_ONLY /* { */</a>
<a name="ln3814">/****************************************************************************/</a>
<a name="ln3815">int CreateCompositeNormAtom( COMP_ATOM_DATA *composite_norm_data, INP_ATOM_DATA2 *all_inp_norm_data,</a>
<a name="ln3816">                             PINChI2 *pINChI, PINChI_Aux2 *pINChI_Aux, int num_components, INCHI_MODE nMode )</a>
<a name="ln3817">{</a>
<a name="ln3818">    int i, j, jj, k, n, m, tot_num_at, tot_num_H, cur_num_at, cur_num_H, nNumRemovedProtons;</a>
<a name="ln3819">    int num_comp[TAUT_NUM+1], num_taut[TAUT_NUM+1], num_del[TAUT_NUM+1], num_at[TAUT_NUM+1], num_inp_at[TAUT_NUM+1];</a>
<a name="ln3820">    int ret = 0, indicator = 1;</a>
<a name="ln3821">    inp_ATOM *at, *at_from;</a>
<a name="ln3822">    memset( num_comp, 0, sizeof(num_comp) );</a>
<a name="ln3823">    memset( num_taut, 0, sizeof(num_taut) );</a>
<a name="ln3824">    memset( num_del, 0, sizeof(num_taut) );</a>
<a name="ln3825">    /* count taut and non-taut components */</a>
<a name="ln3826">    for ( j = 0; j &lt; TAUT_NUM; j ++ ) {</a>
<a name="ln3827">        num_comp[j] = num_taut[j] = 0;</a>
<a name="ln3828">        for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln3829">            if ( all_inp_norm_data[i][j].bExists ) {</a>
<a name="ln3830">                num_del[j]  += (0 != all_inp_norm_data[i][j].bDeleted );</a>
<a name="ln3831">                num_comp[j] ++;</a>
<a name="ln3832">                num_taut[j] += (0 != all_inp_norm_data[i][j].bTautomeric);</a>
<a name="ln3833">            }</a>
<a name="ln3834">        }</a>
<a name="ln3835">    }</a>
<a name="ln3836">    /* count intermediate taut structure components */</a>
<a name="ln3837">    if ( num_comp[TAUT_YES] &gt; num_del[TAUT_YES] &amp;&amp; num_taut[TAUT_YES] ) {</a>
<a name="ln3838">        /*</a>
<a name="ln3839">        num_comp[TAUT_INI] = num_comp[TAUT_YES] - num_del[TAUT_YES];</a>
<a name="ln3840">        */</a>
<a name="ln3841"> </a>
<a name="ln3842">        for ( i = 0, j=TAUT_YES; i &lt; num_components; i ++ ) {</a>
<a name="ln3843">            if ( all_inp_norm_data[i][j].bExists &amp;&amp;</a>
<a name="ln3844">                (all_inp_norm_data[i][j].bDeleted ||</a>
<a name="ln3845">                 all_inp_norm_data[i][j].bTautomeric &amp;&amp;</a>
<a name="ln3846">                 all_inp_norm_data[i][j].at_fixed_bonds &amp;&amp;</a>
<a name="ln3847">                 all_inp_norm_data[i][j].bTautPreprocessed) ) {</a>
<a name="ln3848">                num_comp[TAUT_INI] ++;</a>
<a name="ln3849">            }</a>
<a name="ln3850">        }</a>
<a name="ln3851"> </a>
<a name="ln3852">    }</a>
<a name="ln3853">    /* count atoms and allocate composite atom data */</a>
<a name="ln3854">    for ( jj = 0; jj &lt;= TAUT_INI; jj ++ ) {</a>
<a name="ln3855">        num_at[jj] = num_inp_at[jj] = 0;</a>
<a name="ln3856">        j = inchi_min (jj, TAUT_YES);</a>
<a name="ln3857">        if ( num_comp[jj] ) {</a>
<a name="ln3858">            for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln3859">                if ( all_inp_norm_data[i][j].bDeleted )</a>
<a name="ln3860">                    continue;</a>
<a name="ln3861">                /* find k = the normaized structure index */</a>
<a name="ln3862">                if ( jj == TAUT_INI ) {</a>
<a name="ln3863">                    if ( all_inp_norm_data[i][j].bExists &amp;&amp;</a>
<a name="ln3864">                         all_inp_norm_data[i][j].at_fixed_bonds ) {</a>
<a name="ln3865">                        k = j;</a>
<a name="ln3866">                    } else</a>
<a name="ln3867">                    if ( all_inp_norm_data[i][ALT_TAUT(j)].bExists &amp;&amp; !all_inp_norm_data[i][ALT_TAUT(j)].bDeleted &amp;&amp;</a>
<a name="ln3868">                         !all_inp_norm_data[i][j].bDeleted  ) {</a>
<a name="ln3869">                        k = ALT_TAUT(j);</a>
<a name="ln3870">                    } else</a>
<a name="ln3871">                    if ( all_inp_norm_data[i][j].bExists ) {</a>
<a name="ln3872">                        k = j;</a>
<a name="ln3873">                    } else {</a>
<a name="ln3874">                        continue;</a>
<a name="ln3875">                    }</a>
<a name="ln3876">                } else {</a>
<a name="ln3877">                    if ( all_inp_norm_data[i][j].bExists ) {</a>
<a name="ln3878">                        k = j;</a>
<a name="ln3879">                    } else</a>
<a name="ln3880">                    if ( all_inp_norm_data[i][ALT_TAUT(j)].bExists &amp;&amp; !all_inp_norm_data[i][ALT_TAUT(j)].bDeleted) {</a>
<a name="ln3881">                        k = ALT_TAUT(j);</a>
<a name="ln3882">                    } else {</a>
<a name="ln3883">                        continue;</a>
<a name="ln3884">                    }</a>
<a name="ln3885">                }</a>
<a name="ln3886">                num_inp_at[jj] += all_inp_norm_data[i][k].num_at; /* all atoms including terminal H */</a>
<a name="ln3887">                num_at[jj]     += all_inp_norm_data[i][k].num_at - all_inp_norm_data[i][k].num_removed_H;</a>
<a name="ln3888">            }</a>
<a name="ln3889">            if ( num_inp_at[jj] ) {</a>
<a name="ln3890">                if ( !CreateCompAtomData( composite_norm_data+jj, num_inp_at[jj], num_components, jj == TAUT_INI ) )</a>
<a name="ln3891">                    goto exit_error;</a>
<a name="ln3892">                composite_norm_data[jj].num_removed_H = num_inp_at[jj] - num_at[jj];</a>
<a name="ln3893">            }</a>
<a name="ln3894">        }</a>
<a name="ln3895">    }</a>
<a name="ln3896">    /* fill out composite atom */</a>
<a name="ln3897">    for ( jj = 0; jj &lt;= TAUT_INI; jj ++, indicator &lt;&lt;= 1 ) {</a>
<a name="ln3898">        j = inchi_min (jj, TAUT_YES);</a>
<a name="ln3899">        if ( num_comp[jj] ) {</a>
<a name="ln3900">            tot_num_at = 0;</a>
<a name="ln3901">            tot_num_H = 0;</a>
<a name="ln3902">            for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln3903">                if ( all_inp_norm_data[i][j].bDeleted ) {</a>
<a name="ln3904">                    composite_norm_data[jj].nNumRemovedProtons += all_inp_norm_data[i][j].nNumRemovedProtons;</a>
<a name="ln3905">                    for ( n = 0; n &lt; NUM_H_ISOTOPES; n ++ ) {</a>
<a name="ln3906">                        composite_norm_data[jj].nNumRemovedProtonsIsotopic[n] += all_inp_norm_data[i][j].nNumRemovedProtonsIsotopic[n];</a>
<a name="ln3907">                    }</a>
<a name="ln3908">                    continue;</a>
<a name="ln3909">                }</a>
<a name="ln3910">                nNumRemovedProtons = 0;</a>
<a name="ln3911">                k = TAUT_NUM;</a>
<a name="ln3912">                /* find k = the normaized structure index */</a>
<a name="ln3913">                if ( jj == TAUT_INI ) {</a>
<a name="ln3914">                    if ( all_inp_norm_data[i][j].bExists &amp;&amp; all_inp_norm_data[i][j].at_fixed_bonds ) {</a>
<a name="ln3915">                        k = j;</a>
<a name="ln3916">                    } else</a>
<a name="ln3917">                    if ( all_inp_norm_data[i][ALT_TAUT(j)].bExists ) {</a>
<a name="ln3918">                        k = ALT_TAUT(j);</a>
<a name="ln3919">                    } else</a>
<a name="ln3920">                    if ( all_inp_norm_data[i][j].bExists &amp;&amp; !all_inp_norm_data[i][ALT_TAUT(j)].bDeleted ) {</a>
<a name="ln3921">                        k = j;</a>
<a name="ln3922">                    } else {</a>
<a name="ln3923">                        continue;</a>
<a name="ln3924">                    }</a>
<a name="ln3925">                } else {</a>
<a name="ln3926">                    if ( all_inp_norm_data[i][j].bExists ) {</a>
<a name="ln3927">                        k = j;</a>
<a name="ln3928">                    } else</a>
<a name="ln3929">                    if ( all_inp_norm_data[i][ALT_TAUT(j)].bExists &amp;&amp; !all_inp_norm_data[i][ALT_TAUT(j)].bDeleted ) {</a>
<a name="ln3930">                        k = ALT_TAUT(j);</a>
<a name="ln3931">                    } else {</a>
<a name="ln3932">                        continue;</a>
<a name="ln3933">                    }</a>
<a name="ln3934">                }</a>
<a name="ln3935">                /* copy main atoms */</a>
<a name="ln3936">                cur_num_H  = all_inp_norm_data[i][k].num_removed_H;       /* number of terminal H atoms */</a>
<a name="ln3937">                cur_num_at = all_inp_norm_data[i][k].num_at - cur_num_H;  /* number of all but explicit terminal H atoms */</a>
<a name="ln3938"> </a>
<a name="ln3939">                if ( (tot_num_at + cur_num_at) &gt; num_at[jj] ||</a>
<a name="ln3940">                     (num_at[jj] + tot_num_H + cur_num_H) &gt; num_inp_at[jj] ) {</a>
<a name="ln3941">                    goto exit_error; /* miscount */</a>
<a name="ln3942">                }</a>
<a name="ln3943">                at      = composite_norm_data[jj].at+tot_num_at; /* points to the 1st destination atom */</a>
<a name="ln3944">                at_from = (jj == TAUT_INI &amp;&amp; k == TAUT_YES &amp;&amp; all_inp_norm_data[i][k].at_fixed_bonds)?</a>
<a name="ln3945">                          all_inp_norm_data[i][k].at_fixed_bonds : all_inp_norm_data[i][k].at;</a>
<a name="ln3946">                memcpy( at, at_from, sizeof(composite_norm_data[0].at[0]) * cur_num_at ); /* copy atoms except terminal H */</a>
<a name="ln3947">                /* shift neighbors of main atoms */</a>
<a name="ln3948">                for ( n = 0; n &lt; cur_num_at; n ++, at ++ ) {</a>
<a name="ln3949">                    for ( m = 0; m &lt; at-&gt;valence; m ++ ) {</a>
<a name="ln3950">                        at-&gt;neighbor[m] += tot_num_at;</a>
<a name="ln3951">                    }</a>
<a name="ln3952">                }</a>
<a name="ln3953">                /* copy explicit H */</a>
<a name="ln3954">                if ( cur_num_H ) {</a>
<a name="ln3955">                    at = composite_norm_data[jj].at+num_at[jj]+tot_num_H; /* points to the 1st destination atom */</a>
<a name="ln3956">                    memcpy( at, at_from+cur_num_at,</a>
<a name="ln3957">                            sizeof(composite_norm_data[0].at[0]) * cur_num_H );</a>
<a name="ln3958">                    /* shift neighbors of explicit H atoms */</a>
<a name="ln3959">                    for ( n = 0; n &lt; cur_num_H; n ++, at ++ ) {</a>
<a name="ln3960">                        for ( m = 0; m &lt; at-&gt;valence; m ++ ) {</a>
<a name="ln3961">                            at-&gt;neighbor[m] += tot_num_at;</a>
<a name="ln3962">                        }</a>
<a name="ln3963">                    }</a>
<a name="ln3964">                }</a>
<a name="ln3965">                /* composite counts */</a>
<a name="ln3966">                composite_norm_data[jj].bHasIsotopicLayer   |= all_inp_norm_data[i][k].bHasIsotopicLayer;</a>
<a name="ln3967">                composite_norm_data[jj].num_isotopic        += all_inp_norm_data[i][k].num_isotopic;</a>
<a name="ln3968">                composite_norm_data[jj].num_bonds           += all_inp_norm_data[i][k].num_bonds;</a>
<a name="ln3969">                composite_norm_data[jj].bTautomeric         += (j == jj) &amp;&amp; all_inp_norm_data[i][k].bTautomeric;</a>
<a name="ln3970">                composite_norm_data[jj].nNumRemovedProtons  += all_inp_norm_data[i][k].nNumRemovedProtons;</a>
<a name="ln3971">                for ( n = 0; n &lt; NUM_H_ISOTOPES; n ++ ) {</a>
<a name="ln3972">                    composite_norm_data[jj].nNumRemovedProtonsIsotopic[n] += all_inp_norm_data[i][k].nNumRemovedProtonsIsotopic[n];</a>
<a name="ln3973">                    composite_norm_data[jj].num_iso_H[n]                  += all_inp_norm_data[i][k].num_iso_H[n];</a>
<a name="ln3974">                }</a>
<a name="ln3975">                /*</a>
<a name="ln3976">                composite_norm_data[j].num_at            += cur_num_at + cur_num_H;</a>
<a name="ln3977">                composite_norm_data[j].num_removed_H     += cur_num_H;</a>
<a name="ln3978">                */</a>
<a name="ln3979">                /* total count */</a>
<a name="ln3980">                tot_num_at += cur_num_at;</a>
<a name="ln3981">                tot_num_H += cur_num_H;</a>
<a name="ln3982">                /* offset for the next component */</a>
<a name="ln3983">                if ( composite_norm_data[jj].nOffsetAtAndH ) {</a>
<a name="ln3984">                    composite_norm_data[jj].nOffsetAtAndH[2*i]   = tot_num_at;</a>
<a name="ln3985">                    composite_norm_data[jj].nOffsetAtAndH[2*i+1] = num_at[jj]+tot_num_H;</a>
<a name="ln3986">                }</a>
<a name="ln3987">            }</a>
<a name="ln3988">            if ( tot_num_at != num_at[jj] ||</a>
<a name="ln3989">                 num_at[jj] + tot_num_H  != num_inp_at[jj] ) {</a>
<a name="ln3990">                goto exit_error; /* miscount */</a>
<a name="ln3991">            }</a>
<a name="ln3992">            composite_norm_data[jj].bExists       = (tot_num_at&gt;0);</a>
<a name="ln3993">            ret |= indicator;</a>
<a name="ln3994">        }</a>
<a name="ln3995">    }</a>
<a name="ln3996">    return ret;</a>
<a name="ln3997"> </a>
<a name="ln3998"> </a>
<a name="ln3999"> </a>
<a name="ln4000"> </a>
<a name="ln4001"> </a>
<a name="ln4002">exit_error:</a>
<a name="ln4003">    return ret;</a>
<a name="ln4004">}</a>
<a name="ln4005">#endif /* } COMPILE_ANSI_ONLY */</a>

</code></pre>
<div class="balloon" rel="1694"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'cur_is_non_taut + cur_is_taut' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1758"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: sd->nErrorCode.</p></div>
<div class="balloon" rel="2541"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sd->nErrorType < 1' is always false.</p></div>
<div class="balloon" rel="2848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: nRet != 3.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

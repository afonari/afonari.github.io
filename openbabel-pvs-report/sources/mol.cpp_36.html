
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mol.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">mol.cpp - Handle molecules.</a>
<a name="ln3"> </a>
<a name="ln4">Copyright (C) 1998-2001 by OpenEye Scientific Software, Inc.</a>
<a name="ln5">Some portions Copyright (C) 2001-2008 by Geoffrey R. Hutchison</a>
<a name="ln6">Some portions Copyright (C) 2003 by Michael Banck</a>
<a name="ln7"> </a>
<a name="ln8">This file is part of the Open Babel project.</a>
<a name="ln9">For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln10"> </a>
<a name="ln11">This program is free software; you can redistribute it and/or modify</a>
<a name="ln12">it under the terms of the GNU General Public License as published by</a>
<a name="ln13">the Free Software Foundation version 2 of the License.</a>
<a name="ln14"> </a>
<a name="ln15">This program is distributed in the hope that it will be useful,</a>
<a name="ln16">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln17">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18">GNU General Public License for more details.</a>
<a name="ln19">***********************************************************************/</a>
<a name="ln20">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln23">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln24">#include &lt;openbabel/ring.h&gt;</a>
<a name="ln25">#include &lt;openbabel/rotamer.h&gt;</a>
<a name="ln26">#include &lt;openbabel/phmodel.h&gt;</a>
<a name="ln27">#include &lt;openbabel/bondtyper.h&gt;</a>
<a name="ln28">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln29">#include &lt;openbabel/builder.h&gt;</a>
<a name="ln30">#include &lt;openbabel/kekulize.h&gt;</a>
<a name="ln31">#include &lt;openbabel/internalcoord.h&gt;</a>
<a name="ln32">#include &lt;openbabel/math/matrix3x3.h&gt;</a>
<a name="ln33">#include &lt;openbabel/obfunctions.h&gt;</a>
<a name="ln34">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;openbabel/stereo/tetrahedral.h&gt;</a>
<a name="ln37">#include &lt;openbabel/stereo/cistrans.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;sstream&gt;</a>
<a name="ln40">#include &lt;set&gt;</a>
<a name="ln41"> </a>
<a name="ln42">using namespace std;</a>
<a name="ln43"> </a>
<a name="ln44">namespace OpenBabel</a>
<a name="ln45">{</a>
<a name="ln46"> </a>
<a name="ln47">  extern bool SwabInt;</a>
<a name="ln48">  extern THREAD_LOCAL OBPhModel  phmodel;</a>
<a name="ln49">  extern THREAD_LOCAL OBAromaticTyper  aromtyper;</a>
<a name="ln50">  extern THREAD_LOCAL OBAtomTyper      atomtyper;</a>
<a name="ln51">  extern THREAD_LOCAL OBBondTyper      bondtyper;</a>
<a name="ln52"> </a>
<a name="ln53">  /** \class OBMol mol.h &lt;openbabel/mol.h&gt;</a>
<a name="ln54">      \brief Molecule Class</a>
<a name="ln55"> </a>
<a name="ln56">      The most important class in Open Babel is OBMol, or the molecule class.</a>
<a name="ln57">      The OBMol class is designed to store all the basic information</a>
<a name="ln58">      associated with a molecule, to make manipulations on the connection</a>
<a name="ln59">      table of a molecule facile, and to provide member functions which</a>
<a name="ln60">      automatically perceive information about a molecule. A guided tour</a>
<a name="ln61">      of the OBMol class is a good place to start.</a>
<a name="ln62"> </a>
<a name="ln63">      An OBMol class can be declared:</a>
<a name="ln64">      \code</a>
<a name="ln65">      OBMol mol;</a>
<a name="ln66">      \endcode</a>
<a name="ln67"> </a>
<a name="ln68">      For example:</a>
<a name="ln69">      \code</a>
<a name="ln70">      #include &lt;iostream.h&gt;</a>
<a name="ln71"> </a>
<a name="ln72">      #include &lt;openbabel/mol.h&gt;</a>
<a name="ln73">      #include &lt;openbabel/obconversion.h&gt;</a>
<a name="ln74">      int main(int argc,char **argv)</a>
<a name="ln75">      {</a>
<a name="ln76">      OBConversion conv(&amp;cin,&amp;cout);</a>
<a name="ln77">      if(conv.SetInAndOutFormats(&quot;SDF&quot;,&quot;MOL2&quot;))</a>
<a name="ln78">      {</a>
<a name="ln79">      OBMol mol;</a>
<a name="ln80">      if(conv.Read(&amp;mol))</a>
<a name="ln81">      ...manipulate molecule</a>
<a name="ln82"> </a>
<a name="ln83">      conv-&gt;Write(&amp;mol);</a>
<a name="ln84">      }</a>
<a name="ln85">      return(1);</a>
<a name="ln86">      }</a>
<a name="ln87">      \endcode</a>
<a name="ln88"> </a>
<a name="ln89">      will read in a molecule in SD file format from stdin</a>
<a name="ln90">      (or the C++ equivalent cin) and write a MOL2 format file out</a>
<a name="ln91">      to standard out. Additionally, The input and output formats can</a>
<a name="ln92">      be altered using the OBConversion class</a>
<a name="ln93"> </a>
<a name="ln94">      Once a molecule has been read into an OBMol (or created via other methods)</a>
<a name="ln95">      the atoms and bonds</a>
<a name="ln96">      can be accessed by the following methods:</a>
<a name="ln97">      \code</a>
<a name="ln98">      OBAtom *atom;</a>
<a name="ln99">      atom = mol.GetAtom(5); //random access of an atom</a>
<a name="ln100">      \endcode</a>
<a name="ln101">      or</a>
<a name="ln102">      \code</a>
<a name="ln103">      OBBond *bond;</a>
<a name="ln104">      bond = mol.GetBond(14); //random access of a bond</a>
<a name="ln105">      \endcode</a>
<a name="ln106">      or</a>
<a name="ln107">      \code</a>
<a name="ln108">      FOR_ATOMS_OF_MOL(atom, mol) // iterator access (see OBMolAtomIter)</a>
<a name="ln109">      \endcode</a>
<a name="ln110">      or</a>
<a name="ln111">      \code</a>
<a name="ln112">      FOR_BONDS_OF_MOL(bond, mol) // iterator access (see OBMolBondIter)</a>
<a name="ln113">      \endcode</a>
<a name="ln114">      It is important to note that atom arrays currently begin at 1 and bond arrays</a>
<a name="ln115">      begin at 0. Requesting atom 0 (\code</a>
<a name="ln116">      OBAtom *atom = mol.GetAtom(0); \endcode</a>
<a name="ln117">      will result in an error, but</a>
<a name="ln118">      \code</a>
<a name="ln119">      OBBond *bond = mol.GetBond(0);</a>
<a name="ln120">      \endcode</a>
<a name="ln121">      is perfectly valid.</a>
<a name="ln122">      Note that this is expected to change in the near future to simplify coding</a>
<a name="ln123">      and improve efficiency.</a>
<a name="ln124"> </a>
<a name="ln125">      The ambiguity of numbering issues and off-by-one errors led to the use</a>
<a name="ln126">      of iterators in Open Babel. An iterator is essentially just a pointer, but</a>
<a name="ln127">      when used in conjunction with Standard Template Library (STL) vectors</a>
<a name="ln128">      it provides an unambiguous way to loop over arrays. OBMols store their</a>
<a name="ln129">      atom and bond information in STL vectors. Since vectors are template</a>
<a name="ln130">      based, a vector of any user defined type can be declared. OBMols declare</a>
<a name="ln131">      vector&lt;OBAtom*&gt; and vector&lt;OBBond*&gt; to store atom and bond information.</a>
<a name="ln132">      Iterators are then a natural way to loop over the vectors of atoms and bonds.</a>
<a name="ln133"> </a>
<a name="ln134">      A variety of predefined iterators have been created to simplify</a>
<a name="ln135">      common looping requests (e.g., looping over all atoms in a molecule,</a>
<a name="ln136">      bonds to a given atom, etc.)</a>
<a name="ln137"> </a>
<a name="ln138">      \code</a>
<a name="ln139">      #include &lt;openbabel/obiter.h&gt;</a>
<a name="ln140">      ...</a>
<a name="ln141">      #define FOR_ATOMS_OF_MOL(a,m)     for( OBMolAtomIter     a(m); a; ++a )</a>
<a name="ln142">      #define FOR_BONDS_OF_MOL(b,m)     for( OBMolBondIter     b(m); b; ++b )</a>
<a name="ln143">      #define FOR_NBORS_OF_ATOM(a,p)    for( OBAtomAtomIter    a(p); a; ++a )</a>
<a name="ln144">      #define FOR_BONDS_OF_ATOM(b,p)    for( OBAtomBondIter    b(p); b; ++b )</a>
<a name="ln145">      #define FOR_RESIDUES_OF_MOL(r,m)  for( OBResidueIter     r(m); r; ++r )</a>
<a name="ln146">      #define FOR_ATOMS_OF_RESIDUE(a,r) for( OBResidueAtomIter a(r); a; ++a )</a>
<a name="ln147">      ...</a>
<a name="ln148">      \endcode</a>
<a name="ln149"> </a>
<a name="ln150">      These convenience functions can be used like so:</a>
<a name="ln151">      \code</a>
<a name="ln152">      #include &lt;openbabel/obiter.h&gt;</a>
<a name="ln153">      #include &lt;openbabel/mol.h&gt;</a>
<a name="ln154"> </a>
<a name="ln155">      OBMol mol;</a>
<a name="ln156">      double exactMass = 0.0;</a>
<a name="ln157">      FOR_ATOMS_OF_MOL(a, mol)</a>
<a name="ln158">      {</a>
<a name="ln159">      exactMass +=  a-&gt;GetExactMass();</a>
<a name="ln160">      }</a>
<a name="ln161">      \endcode</a>
<a name="ln162"> </a>
<a name="ln163">      Note that with these convenience macros, the iterator &quot;a&quot; (or</a>
<a name="ln164">      whichever name you pick) is declared for you -- you do not need to</a>
<a name="ln165">      do it beforehand.</a>
<a name="ln166">  */</a>
<a name="ln167"> </a>
<a name="ln168">  //</a>
<a name="ln169">  // OBMol member functions</a>
<a name="ln170">  //</a>
<a name="ln171">  void  OBMol::SetTitle(const char *title)</a>
<a name="ln172">  {</a>
<a name="ln173">    _title = title;</a>
<a name="ln174">    Trim(_title);</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  void  OBMol::SetTitle(std::string &amp;title)</a>
<a name="ln178">  {</a>
<a name="ln179">    _title = title;</a>
<a name="ln180">    Trim(_title);</a>
<a name="ln181">  }</a>
<a name="ln182"> </a>
<a name="ln183">  const char *OBMol::GetTitle(bool replaceNewlines) const</a>
<a name="ln184">  {</a>
<a name="ln185">    if (!replaceNewlines || _title.find('\n')== string::npos )</a>
<a name="ln186">      return(_title.c_str());</a>
<a name="ln187"> </a>
<a name="ln188">    //Only multiline titles use the following to replace newlines by spaces</a>
<a name="ln189">    static string title;</a>
<a name="ln190">    title=_title;</a>
<a name="ln191">    string::size_type j;</a>
<a name="ln192">    for ( ; (j = title.find_first_of( &quot;\n\r&quot; )) != string::npos ; ) {</a>
<a name="ln193">      title.replace( j, 1, &quot; &quot;);</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">    return(title.c_str());</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  bool SortVVInt(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)</a>
<a name="ln200">  {</a>
<a name="ln201">    return(a.size() &gt; b.size());</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  bool SortAtomZ(const pair&lt;OBAtom*,double&gt; &amp;a, const pair&lt;OBAtom*,double&gt; &amp;b)</a>
<a name="ln205">  {</a>
<a name="ln206">    return (a.second &lt; b.second);</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  double OBMol::GetAngle( OBAtom* a, OBAtom* b, OBAtom* c)</a>
<a name="ln210">  {</a>
<a name="ln211">    return a-&gt;GetAngle( b, c );</a>
<a name="ln212">  }</a>
<a name="ln213"> </a>
<a name="ln214">  double OBMol::GetTorsion(int a,int b,int c,int d)</a>
<a name="ln215">  {</a>
<a name="ln216">    return(GetTorsion((OBAtom*)_vatom[a-1],</a>
<a name="ln217">                      (OBAtom*)_vatom[b-1],</a>
<a name="ln218">                      (OBAtom*)_vatom[c-1],</a>
<a name="ln219">                      (OBAtom*)_vatom[d-1]));</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  void OBMol::SetTorsion(OBAtom *a,OBAtom *b,OBAtom *c, OBAtom *d, double ang)</a>
<a name="ln223">  {</a>
<a name="ln224">    vector&lt;int&gt; tor;</a>
<a name="ln225">    vector&lt;int&gt; atoms;</a>
<a name="ln226"> </a>
<a name="ln227">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln228">                          &quot;Ran OpenBabel::SetTorsion&quot;, obAuditMsg);</a>
<a name="ln229"> </a>
<a name="ln230">    tor.push_back(a-&gt;GetCoordinateIdx());</a>
<a name="ln231">    tor.push_back(b-&gt;GetCoordinateIdx());</a>
<a name="ln232">    tor.push_back(c-&gt;GetCoordinateIdx());</a>
<a name="ln233">    tor.push_back(d-&gt;GetCoordinateIdx());</a>
<a name="ln234"> </a>
<a name="ln235">    FindChildren(atoms, b-&gt;GetIdx(), c-&gt;GetIdx());</a>
<a name="ln236">    int j;</a>
<a name="ln237">    for (j = 0 ; (unsigned)j &lt; atoms.size() ; j++ )</a>
<a name="ln238">      atoms[j] = (atoms[j] - 1) * 3;</a>
<a name="ln239"> </a>
<a name="ln240">    double v2x,v2y,v2z;</a>
<a name="ln241">    double radang,m[9];</a>
<a name="ln242">    double x,y,z,mag,rotang,sn,cs,t,tx,ty,tz;</a>
<a name="ln243"> </a>
<a name="ln244">    //calculate the torsion angle</a>
<a name="ln245">    // TODO: fix this calculation for periodic systems</a>
<a name="ln246">    radang = CalcTorsionAngle(a-&gt;GetVector(),</a>
<a name="ln247">                              b-&gt;GetVector(),</a>
<a name="ln248">                              c-&gt;GetVector(),</a>
<a name="ln249">                              d-&gt;GetVector()) / RAD_TO_DEG;</a>
<a name="ln250">    //</a>
<a name="ln251">    // now we have the torsion angle (radang) - set up the rot matrix</a>
<a name="ln252">    //</a>
<a name="ln253"> </a>
<a name="ln254">    //find the difference between current and requested</a>
<a name="ln255">    rotang = ang - radang;</a>
<a name="ln256"> </a>
<a name="ln257">    sn = sin(rotang);</a>
<a name="ln258">    cs = cos(rotang);</a>
<a name="ln259">    t = 1 - cs;</a>
<a name="ln260"> </a>
<a name="ln261">    v2x = _c[tor[1]]   - _c[tor[2]];</a>
<a name="ln262">    v2y = _c[tor[1]+1] - _c[tor[2]+1];</a>
<a name="ln263">    v2z = _c[tor[1]+2] - _c[tor[2]+2];</a>
<a name="ln264"> </a>
<a name="ln265">   //normalize the rotation vector</a>
<a name="ln266">    mag = sqrt(SQUARE(v2x)+SQUARE(v2y)+SQUARE(v2z));</a>
<a name="ln267">    x = v2x/mag;</a>
<a name="ln268">    y = v2y/mag;</a>
<a name="ln269">    z = v2z/mag;</a>
<a name="ln270"> </a>
<a name="ln271">    //set up the rotation matrix</a>
<a name="ln272">    m[0]= t*x*x + cs;</a>
<a name="ln273">    m[1] = t*x*y + sn*z;</a>
<a name="ln274">    m[2] = t*x*z - sn*y;</a>
<a name="ln275">    m[3] = t*x*y - sn*z;</a>
<a name="ln276">    m[4] = t*y*y + cs;</a>
<a name="ln277">    m[5] = t*y*z + sn*x;</a>
<a name="ln278">    m[6] = t*x*z + sn*y;</a>
<a name="ln279">    m[7] = t*y*z - sn*x;</a>
<a name="ln280">    m[8] = t*z*z + cs;</a>
<a name="ln281"> </a>
<a name="ln282">    //</a>
<a name="ln283">    //now the matrix is set - time to rotate the atoms</a>
<a name="ln284">    //</a>
<a name="ln285">    tx = _c[tor[1]];</a>
<a name="ln286">    ty = _c[tor[1]+1];</a>
<a name="ln287">    tz = _c[tor[1]+2];</a>
<a name="ln288">    vector&lt;int&gt;::iterator i;</a>
<a name="ln289">    for (i = atoms.begin(); i != atoms.end(); ++i)</a>
<a name="ln290">      {</a>
<a name="ln291">        j = *i;</a>
<a name="ln292"> </a>
<a name="ln293">        _c[j] -= tx;</a>
<a name="ln294">        _c[j+1] -= ty;</a>
<a name="ln295">        _c[j+2]-= tz;</a>
<a name="ln296">        x = _c[j]*m[0] + _c[j+1]*m[1] + _c[j+2]*m[2];</a>
<a name="ln297">        y = _c[j]*m[3] + _c[j+1]*m[4] + _c[j+2]*m[5];</a>
<a name="ln298">        z = _c[j]*m[6] + _c[j+1]*m[7] + _c[j+2]*m[8];</a>
<a name="ln299">        _c[j] = x;</a>
<a name="ln300">        _c[j+1] = y;</a>
<a name="ln301">        _c[j+2] = z;</a>
<a name="ln302">        _c[j] += tx;</a>
<a name="ln303">        _c[j+1] += ty;</a>
<a name="ln304">        _c[j+2] += tz;</a>
<a name="ln305">      }</a>
<a name="ln306">  }</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">  double OBMol::GetTorsion(OBAtom *a,OBAtom *b,OBAtom *c,OBAtom *d)</a>
<a name="ln310">  {</a>
<a name="ln311">    if (!IsPeriodic())</a>
<a name="ln312">      {</a>
<a name="ln313">        return(CalcTorsionAngle(a-&gt;GetVector(),</a>
<a name="ln314">                                b-&gt;GetVector(),</a>
<a name="ln315">                                c-&gt;GetVector(),</a>
<a name="ln316">                                d-&gt;GetVector()));</a>
<a name="ln317">      }</a>
<a name="ln318">    else</a>
<a name="ln319">      {</a>
<a name="ln320">        vector3 v1, v2, v3, v4;</a>
<a name="ln321">        // Wrap the atomic positions in a continuous chain that makes sense based on the unit cell</a>
<a name="ln322">        // Start by extracting the absolute Cartesian coordinates</a>
<a name="ln323">        v1 = a-&gt;GetVector();</a>
<a name="ln324">        v2 = b-&gt;GetVector();</a>
<a name="ln325">        v3 = c-&gt;GetVector();</a>
<a name="ln326">        v4 = d-&gt;GetVector();</a>
<a name="ln327">        // Then redefine the positions based on proximity to the previous atom</a>
<a name="ln328">        // to build a continuous chain of expanded Cartesian coordinates</a>
<a name="ln329">        OBUnitCell *unitCell = (OBUnitCell * ) GetData(OBGenericDataType::UnitCell);</a>
<a name="ln330">        v2 = unitCell-&gt;UnwrapCartesianNear(v2, v1);</a>
<a name="ln331">        v3 = unitCell-&gt;UnwrapCartesianNear(v3, v2);</a>
<a name="ln332">        v4 = unitCell-&gt;UnwrapCartesianNear(v4, v3);</a>
<a name="ln333">        return(CalcTorsionAngle(v1, v2, v3, v4));</a>
<a name="ln334">      }</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  void OBMol::ContigFragList(std::vector&lt;std::vector&lt;int&gt; &gt;&amp;cfl)</a>
<a name="ln338">  {</a>
<a name="ln339">    int j;</a>
<a name="ln340">    OBAtom *atom;</a>
<a name="ln341">    OBBond *bond;</a>
<a name="ln342">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln343">    vector&lt;OBBond*&gt;::iterator k;</a>
<a name="ln344">    OBBitVec used,curr,next,frag;</a>
<a name="ln345">    vector&lt;int&gt; tmp;</a>
<a name="ln346"> </a>
<a name="ln347">    used.Resize(NumAtoms()+1);</a>
<a name="ln348">    curr.Resize(NumAtoms()+1);</a>
<a name="ln349">    next.Resize(NumAtoms()+1);</a>
<a name="ln350">    frag.Resize(NumAtoms()+1);</a>
<a name="ln351"> </a>
<a name="ln352">    while ((unsigned)used.CountBits() &lt; NumAtoms())</a>
<a name="ln353">      {</a>
<a name="ln354">        curr.Clear();</a>
<a name="ln355">        frag.Clear();</a>
<a name="ln356">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln357">          if (!used.BitIsSet(atom-&gt;GetIdx()))</a>
<a name="ln358">            {</a>
<a name="ln359">              curr.SetBitOn(atom-&gt;GetIdx());</a>
<a name="ln360">              break;</a>
<a name="ln361">            }</a>
<a name="ln362"> </a>
<a name="ln363">        frag |= curr;</a>
<a name="ln364">        while (!curr.IsEmpty())</a>
<a name="ln365">          {</a>
<a name="ln366">            next.Clear();</a>
<a name="ln367">            for (j = curr.NextBit(-1);j != curr.EndBit();j = curr.NextBit(j))</a>
<a name="ln368">              {</a>
<a name="ln369">                atom = GetAtom(j);</a>
<a name="ln370">                for (bond = atom-&gt;BeginBond(k);bond;bond = atom-&gt;NextBond(k))</a>
<a name="ln371">                  if (!used.BitIsSet(bond-&gt;GetNbrAtomIdx(atom)))</a>
<a name="ln372">                    next.SetBitOn(bond-&gt;GetNbrAtomIdx(atom));</a>
<a name="ln373">              }</a>
<a name="ln374"> </a>
<a name="ln375">            used |= curr;</a>
<a name="ln376">            used |= next;</a>
<a name="ln377">            frag |= next;</a>
<a name="ln378">            curr = next;</a>
<a name="ln379">          }</a>
<a name="ln380"> </a>
<a name="ln381">        tmp.clear();</a>
<a name="ln382">        frag.ToVecInt(tmp);</a>
<a name="ln383">        cfl.push_back(tmp);</a>
<a name="ln384">      }</a>
<a name="ln385"> </a>
<a name="ln386">    sort(cfl.begin(),cfl.end(),SortVVInt);</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  void OBMol::FindAngles()</a>
<a name="ln390">  {</a>
<a name="ln391">    //if already has data return</a>
<a name="ln392">    if(HasData(OBGenericDataType::AngleData))</a>
<a name="ln393">      return;</a>
<a name="ln394"> </a>
<a name="ln395">    //get new data and attach it to molecule</a>
<a name="ln396">    OBAngleData *angles = new OBAngleData;</a>
<a name="ln397">    angles-&gt;SetOrigin(perceived);</a>
<a name="ln398">    SetData(angles);</a>
<a name="ln399"> </a>
<a name="ln400">    OBAngle angle;</a>
<a name="ln401">    OBAtom *b;</a>
<a name="ln402">    int unique_angle;</a>
<a name="ln403"> </a>
<a name="ln404">    unique_angle = 0;</a>
<a name="ln405"> </a>
<a name="ln406">    FOR_ATOMS_OF_MOL(atom, this) {</a>
<a name="ln407">      if(atom-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln408">        continue;</a>
<a name="ln409"> </a>
<a name="ln410">      b = (OBAtom*) &amp;*atom;</a>
<a name="ln411"> </a>
<a name="ln412">      FOR_NBORS_OF_ATOM(a, b) {</a>
<a name="ln413">        FOR_NBORS_OF_ATOM(c, b) {</a>
<a name="ln414">          if(&amp;*a == &amp;*c) {</a>
<a name="ln415">            unique_angle = 1;</a>
<a name="ln416">            continue;</a>
<a name="ln417">          }</a>
<a name="ln418"> </a>
<a name="ln419">          if (unique_angle) {</a>
<a name="ln420">            angle.SetAtoms((OBAtom*)b, (OBAtom*)&amp;*a, (OBAtom*)&amp;*c);</a>
<a name="ln421">            angles-&gt;SetData(angle);</a>
<a name="ln422">            angle.Clear();</a>
<a name="ln423">          }</a>
<a name="ln424">        }</a>
<a name="ln425">        unique_angle = 0;</a>
<a name="ln426">      }</a>
<a name="ln427">    }</a>
<a name="ln428"> </a>
<a name="ln429">    return;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  void OBMol::FindTorsions()</a>
<a name="ln433">  {</a>
<a name="ln434">    //if already has data return</a>
<a name="ln435">    if(HasData(OBGenericDataType::TorsionData))</a>
<a name="ln436">      return;</a>
<a name="ln437"> </a>
<a name="ln438">    //get new data and attach it to molecule</a>
<a name="ln439">    OBTorsionData *torsions = new OBTorsionData;</a>
<a name="ln440">    torsions-&gt;SetOrigin(perceived);</a>
<a name="ln441">    SetData(torsions);</a>
<a name="ln442"> </a>
<a name="ln443">    OBTorsion torsion;</a>
<a name="ln444">    vector&lt;OBBond*&gt;::iterator bi1,bi2,bi3;</a>
<a name="ln445">    OBBond* bond;</a>
<a name="ln446">    OBAtom *a,*b,*c,*d;</a>
<a name="ln447"> </a>
<a name="ln448">    //loop through all bonds generating torsions</a>
<a name="ln449">    for(bond = BeginBond(bi1);bond;bond = NextBond(bi1))</a>
<a name="ln450">      {</a>
<a name="ln451">        b = bond-&gt;GetBeginAtom();</a>
<a name="ln452">        c = bond-&gt;GetEndAtom();</a>
<a name="ln453">        if(b-&gt;GetAtomicNum() == OBElements::Hydrogen || c-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln454">          continue;</a>
<a name="ln455"> </a>
<a name="ln456">        for(a = b-&gt;BeginNbrAtom(bi2);a;a = b-&gt;NextNbrAtom(bi2))</a>
<a name="ln457">          {</a>
<a name="ln458">            if(a == c)</a>
<a name="ln459">              continue;</a>
<a name="ln460"> </a>
<a name="ln461">            for(d = c-&gt;BeginNbrAtom(bi3);d;d = c-&gt;NextNbrAtom(bi3))</a>
<a name="ln462">              {</a>
<a name="ln463">                if ((d == b) || (d == a))</a>
<a name="ln464">                  continue;</a>
<a name="ln465">                torsion.AddTorsion(a,b,c,d);</a>
<a name="ln466">              }</a>
<a name="ln467">          }</a>
<a name="ln468">        //add torsion to torsionData</a>
<a name="ln469">        if(torsion.GetSize())</a>
<a name="ln470">          torsions-&gt;SetData(torsion);</a>
<a name="ln471">        torsion.Clear();</a>
<a name="ln472">      }</a>
<a name="ln473"> </a>
<a name="ln474">    return;</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  void OBMol::FindLargestFragment(OBBitVec &amp;lf)</a>
<a name="ln478">  {</a>
<a name="ln479">    int j;</a>
<a name="ln480">    OBAtom *atom;</a>
<a name="ln481">    OBBond *bond;</a>
<a name="ln482">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln483">    vector&lt;OBBond*&gt;::iterator k;</a>
<a name="ln484">    OBBitVec used,curr,next,frag;</a>
<a name="ln485"> </a>
<a name="ln486">    lf.Clear();</a>
<a name="ln487">    while ((unsigned)used.CountBits() &lt; NumAtoms())</a>
<a name="ln488">      {</a>
<a name="ln489">        curr.Clear();</a>
<a name="ln490">        frag.Clear();</a>
<a name="ln491">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln492">          if (!used.BitIsSet(atom-&gt;GetIdx()))</a>
<a name="ln493">            {</a>
<a name="ln494">              curr.SetBitOn(atom-&gt;GetIdx());</a>
<a name="ln495">              break;</a>
<a name="ln496">            }</a>
<a name="ln497"> </a>
<a name="ln498">        frag |= curr;</a>
<a name="ln499">        while (!curr.IsEmpty())</a>
<a name="ln500">          {</a>
<a name="ln501">            next.Clear();</a>
<a name="ln502">            for (j = curr.NextBit(-1);j != curr.EndBit();j = curr.NextBit(j))</a>
<a name="ln503">              {</a>
<a name="ln504">                atom = GetAtom(j);</a>
<a name="ln505">                for (bond = atom-&gt;BeginBond(k);bond;bond = atom-&gt;NextBond(k))</a>
<a name="ln506">                  if (!used.BitIsSet(bond-&gt;GetNbrAtomIdx(atom)))</a>
<a name="ln507">                    next.SetBitOn(bond-&gt;GetNbrAtomIdx(atom));</a>
<a name="ln508">              }</a>
<a name="ln509"> </a>
<a name="ln510">            used |= curr;</a>
<a name="ln511">            used |= next;</a>
<a name="ln512">            frag |= next;</a>
<a name="ln513">            curr = next;</a>
<a name="ln514">          }</a>
<a name="ln515"> </a>
<a name="ln516">        if (lf.IsEmpty() || lf.CountBits() &lt; frag.CountBits())</a>
<a name="ln517">          lf = frag;</a>
<a name="ln518">      }</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  //! locates all atoms for which there exists a path to 'end'</a>
<a name="ln522">  //! without going through 'bgn'</a>
<a name="ln523">  //! children must not include 'end'</a>
<a name="ln524">  void OBMol::FindChildren(vector&lt;OBAtom*&gt; &amp;children,OBAtom *bgn,OBAtom *end)</a>
<a name="ln525">  {</a>
<a name="ln526">    OBBitVec used,curr,next;</a>
<a name="ln527"> </a>
<a name="ln528">    used |= bgn-&gt;GetIdx();</a>
<a name="ln529">    used |= end-&gt;GetIdx();</a>
<a name="ln530">    curr |= end-&gt;GetIdx();</a>
<a name="ln531">    children.clear();</a>
<a name="ln532"> </a>
<a name="ln533">    int i;</a>
<a name="ln534">    OBAtom *atom,*nbr;</a>
<a name="ln535">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln536"> </a>
<a name="ln537">    for (;;)</a>
<a name="ln538">      {</a>
<a name="ln539">        next.Clear();</a>
<a name="ln540">        for (i = curr.NextBit(-1);i != curr.EndBit();i = curr.NextBit(i))</a>
<a name="ln541">          {</a>
<a name="ln542">            atom = GetAtom(i);</a>
<a name="ln543">            for (nbr = atom-&gt;BeginNbrAtom(j);nbr;nbr = atom-&gt;NextNbrAtom(j))</a>
<a name="ln544">              if (!used[nbr-&gt;GetIdx()])</a>
<a name="ln545">                {</a>
<a name="ln546">                  children.push_back(nbr);</a>
<a name="ln547">                  next |= nbr-&gt;GetIdx();</a>
<a name="ln548">                  used |= nbr-&gt;GetIdx();</a>
<a name="ln549">                }</a>
<a name="ln550">          }</a>
<a name="ln551">        if (next.IsEmpty())</a>
<a name="ln552">          break;</a>
<a name="ln553">        curr = next;</a>
<a name="ln554">      }</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  //! locates all atoms for which there exists a path to 'second'</a>
<a name="ln558">  //! without going through 'first'</a>
<a name="ln559">  //! children must not include 'second'</a>
<a name="ln560">  void OBMol::FindChildren(vector&lt;int&gt; &amp;children,int first,int second)</a>
<a name="ln561">  {</a>
<a name="ln562">    int i;</a>
<a name="ln563">    OBBitVec used,curr,next;</a>
<a name="ln564"> </a>
<a name="ln565">    used.SetBitOn(first);</a>
<a name="ln566">    used.SetBitOn(second);</a>
<a name="ln567">    curr.SetBitOn(second);</a>
<a name="ln568"> </a>
<a name="ln569">    OBAtom *atom;</a>
<a name="ln570">    while (!curr.IsEmpty())</a>
<a name="ln571">      {</a>
<a name="ln572">        next.Clear();</a>
<a name="ln573">        for (i = curr.NextBit(-1);i != curr.EndBit();i = curr.NextBit(i))</a>
<a name="ln574">          {</a>
<a name="ln575">            atom = GetAtom(i);</a>
<a name="ln576">            FOR_BONDS_OF_ATOM (bond, atom)</a>
<a name="ln577">              if (!used.BitIsSet(bond-&gt;GetNbrAtomIdx(atom)))</a>
<a name="ln578">                next.SetBitOn(bond-&gt;GetNbrAtomIdx(atom));</a>
<a name="ln579">          }</a>
<a name="ln580"> </a>
<a name="ln581">        used |= next;</a>
<a name="ln582">        curr = next;</a>
<a name="ln583">      }</a>
<a name="ln584"> </a>
<a name="ln585">    used.SetBitOff(first);</a>
<a name="ln586">    used.SetBitOff(second);</a>
<a name="ln587">    used.ToVecInt(children);</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  /*! \brief Calculates the graph theoretical distance (GTD) of each atom.</a>
<a name="ln591">   *</a>
<a name="ln592">   * Creates a vector (indexed from zero) containing, for each atom</a>
<a name="ln593">   * in the molecule, the number of bonds plus one to the most</a>
<a name="ln594">   * distant non-H atom.</a>
<a name="ln595">   *</a>
<a name="ln596">   * For example, for the molecule H3CC(=O)Cl the GTD value for C1</a>
<a name="ln597">   * would be 3, as the most distant non-H atom (either Cl or O) is</a>
<a name="ln598">   * 2 bonds away.</a>
<a name="ln599">   *</a>
<a name="ln600">   * Since the GTD measures the distance to non-H atoms, the GTD values</a>
<a name="ln601">   * for terminal H atoms tend to be larger than for non-H terminal atoms.</a>
<a name="ln602">   * In the example above, the GTD values for the H atoms are all 4.</a>
<a name="ln603">   */</a>
<a name="ln604">  bool OBMol::GetGTDVector(vector&lt;int&gt; &amp;gtd)</a>
<a name="ln605">  //calculates the graph theoretical distance for every atom</a>
<a name="ln606">  //and puts it into gtd</a>
<a name="ln607">  {</a>
<a name="ln608">    gtd.clear();</a>
<a name="ln609">    gtd.resize(NumAtoms());</a>
<a name="ln610"> </a>
<a name="ln611">    int gtdcount,natom;</a>
<a name="ln612">    OBBitVec used,curr,next;</a>
<a name="ln613">    OBAtom *atom,*atom1;</a>
<a name="ln614">    OBBond *bond;</a>
<a name="ln615">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln616">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln617"> </a>
<a name="ln618">    next.Clear();</a>
<a name="ln619"> </a>
<a name="ln620">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln621">      {</a>
<a name="ln622">        gtdcount = 0;</a>
<a name="ln623">        used.Clear();</a>
<a name="ln624">        curr.Clear();</a>
<a name="ln625">        used.SetBitOn(atom-&gt;GetIdx());</a>
<a name="ln626">        curr.SetBitOn(atom-&gt;GetIdx());</a>
<a name="ln627"> </a>
<a name="ln628">        while (!curr.IsEmpty())</a>
<a name="ln629">          {</a>
<a name="ln630">            next.Clear();</a>
<a name="ln631">            for (natom = curr.NextBit(-1);natom != curr.EndBit();natom = curr.NextBit(natom))</a>
<a name="ln632">              {</a>
<a name="ln633">                atom1 = GetAtom(natom);</a>
<a name="ln634">                for (bond = atom1-&gt;BeginBond(j);bond;bond = atom1-&gt;NextBond(j))</a>
<a name="ln635">                  if (!used.BitIsSet(bond-&gt;GetNbrAtomIdx(atom1)) &amp;&amp; !curr.BitIsSet(bond-&gt;GetNbrAtomIdx(atom1)))</a>
<a name="ln636">                    if (bond-&gt;GetNbrAtom(atom1)-&gt;GetAtomicNum() != OBElements::Hydrogen)</a>
<a name="ln637">                      next.SetBitOn(bond-&gt;GetNbrAtomIdx(atom1));</a>
<a name="ln638">              }</a>
<a name="ln639"> </a>
<a name="ln640">            used |= next;</a>
<a name="ln641">            curr = next;</a>
<a name="ln642">            gtdcount++;</a>
<a name="ln643">          }</a>
<a name="ln644">        gtd[atom-&gt;GetIdx()-1] = gtdcount;</a>
<a name="ln645">      }</a>
<a name="ln646">    return(true);</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  /*!</a>
<a name="ln650">  **\brief Calculates a set of graph invariant indexes using</a>
<a name="ln651">  ** the graph theoretical distance, number of connected heavy atoms,</a>
<a name="ln652">  ** aromatic boolean, ring boolean, atomic number, and</a>
<a name="ln653">  ** summation of bond orders connected to the atom.</a>
<a name="ln654">  ** Vector is indexed from zero</a>
<a name="ln655">  */</a>
<a name="ln656">  void OBMol::GetGIVector(vector&lt;unsigned int&gt; &amp;vid)</a>
<a name="ln657">  {</a>
<a name="ln658">    vid.clear();</a>
<a name="ln659">    vid.resize(NumAtoms()+1);</a>
<a name="ln660"> </a>
<a name="ln661">    vector&lt;int&gt; v;</a>
<a name="ln662">    GetGTDVector(v);</a>
<a name="ln663"> </a>
<a name="ln664">    int i;</a>
<a name="ln665">    OBAtom *atom;</a>
<a name="ln666">    vector&lt;OBAtom*&gt;::iterator j;</a>
<a name="ln667">    for (i=0,atom = BeginAtom(j);atom;atom = NextAtom(j),++i)</a>
<a name="ln668">      {</a>
<a name="ln669">        vid[i] =  (unsigned int)v[i];</a>
<a name="ln670">        vid[i] += (unsigned int)(atom-&gt;GetHvyDegree()*100);</a>
<a name="ln671">        vid[i] += (unsigned int)(((atom-&gt;IsAromatic()) ? 1 : 0)*1000);</a>
<a name="ln672">        vid[i] += (unsigned int)(((atom-&gt;IsInRing()) ? 1 : 0)*10000);</a>
<a name="ln673">        vid[i] += (unsigned int)(atom-&gt;GetAtomicNum()*100000);</a>
<a name="ln674">        vid[i] += (unsigned int)(atom-&gt;GetImplicitHCount()*10000000);</a>
<a name="ln675">      }</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  static bool OBComparePairSecond(const pair&lt;OBAtom*,unsigned int&gt; &amp;a,const pair&lt;OBAtom*,unsigned int&gt; &amp;b)</a>
<a name="ln679">  {</a>
<a name="ln680">    return(a.second &lt; b.second);</a>
<a name="ln681">  }</a>
<a name="ln682"> </a>
<a name="ln683">  static bool OBComparePairFirst(const pair&lt;OBAtom*,unsigned int&gt; &amp;a,const pair&lt;OBAtom*,unsigned int&gt; &amp;b)</a>
<a name="ln684">  {</a>
<a name="ln685">    return(a.first-&gt;GetIdx() &lt; b.first-&gt;GetIdx());</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  //! counts the number of unique symmetry classes in a list</a>
<a name="ln689">  static void ClassCount(vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt; &amp;vp,unsigned int &amp;count)</a>
<a name="ln690">  {</a>
<a name="ln691">    count = 0;</a>
<a name="ln692">    vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt;::iterator k;</a>
<a name="ln693">    sort(vp.begin(),vp.end(),OBComparePairSecond);</a>
<a name="ln694">#if 0 // original version</a>
<a name="ln695"> </a>
<a name="ln696">    unsigned int id=0; // [ejk] appease gcc's bogus &quot;might be undef'd&quot; warning</a>
<a name="ln697">    for (k = vp.begin();k != vp.end();++k)</a>
<a name="ln698">      {</a>
<a name="ln699">        if (k == vp.begin())</a>
<a name="ln700">          {</a>
<a name="ln701">            id = k-&gt;second;</a>
<a name="ln702">            k-&gt;second = count = 0;</a>
<a name="ln703">          }</a>
<a name="ln704">        else</a>
<a name="ln705">          if (k-&gt;second != id)</a>
<a name="ln706">            {</a>
<a name="ln707">              id = k-&gt;second;</a>
<a name="ln708">              k-&gt;second = ++count;</a>
<a name="ln709">            }</a>
<a name="ln710">          else</a>
<a name="ln711">            k-&gt;second = count;</a>
<a name="ln712">      }</a>
<a name="ln713">    count++;</a>
<a name="ln714">#else // get rid of warning, moves test out of loop, returns 0 for empty input</a>
<a name="ln715"> </a>
<a name="ln716">    k = vp.begin();</a>
<a name="ln717">    if (k != vp.end())</a>
<a name="ln718">      {</a>
<a name="ln719">        unsigned int id = k-&gt;second;</a>
<a name="ln720">        k-&gt;second = 0;</a>
<a name="ln721">        ++k;</a>
<a name="ln722">        for (;k != vp.end(); ++k)</a>
<a name="ln723">          {</a>
<a name="ln724">            if (k-&gt;second != id)</a>
<a name="ln725">              {</a>
<a name="ln726">                id = k-&gt;second;</a>
<a name="ln727">                k-&gt;second = ++count;</a>
<a name="ln728">              }</a>
<a name="ln729">            else</a>
<a name="ln730">              k-&gt;second = count;</a>
<a name="ln731">          }</a>
<a name="ln732">        ++count;</a>
<a name="ln733">      }</a>
<a name="ln734">    else</a>
<a name="ln735">      {</a>
<a name="ln736">        // [ejk] thinks count=0 might be OK for an empty list, but orig code did</a>
<a name="ln737">        //++count;</a>
<a name="ln738">      }</a>
<a name="ln739">#endif</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">  //! creates a new vector of symmetry classes base on an existing vector</a>
<a name="ln743">  //! helper routine to GetGIDVector</a>
<a name="ln744">  static void CreateNewClassVector(vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt; &amp;vp1,vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt; &amp;vp2)</a>
<a name="ln745">  {</a>
<a name="ln746">    int m,id;</a>
<a name="ln747">    OBAtom *nbr;</a>
<a name="ln748">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln749">    vector&lt;unsigned int&gt;::iterator k;</a>
<a name="ln750">    vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt;::iterator i;</a>
<a name="ln751">    sort(vp1.begin(),vp1.end(),OBComparePairFirst);</a>
<a name="ln752">    vp2.clear();</a>
<a name="ln753">    for (i = vp1.begin();i != vp1.end();++i)</a>
<a name="ln754">      {</a>
<a name="ln755">        vector&lt;unsigned int&gt; vtmp;</a>
<a name="ln756">        for (nbr = i-&gt;first-&gt;BeginNbrAtom(j);nbr;nbr = i-&gt;first-&gt;NextNbrAtom(j))</a>
<a name="ln757">          vtmp.push_back(vp1[nbr-&gt;GetIdx()-1].second);</a>
<a name="ln758">        sort(vtmp.begin(),vtmp.end(),OBCompareUnsigned);</a>
<a name="ln759">        for (id=i-&gt;second,m=100,k = vtmp.begin();k != vtmp.end();++k,m*=100)</a>
<a name="ln760">          id += *k * m;</a>
<a name="ln761"> </a>
<a name="ln762">        vp2.push_back(pair&lt;OBAtom*,unsigned int&gt; (i-&gt;first,id));</a>
<a name="ln763">      }</a>
<a name="ln764">  }</a>
<a name="ln765"> </a>
<a name="ln766">  /*!</a>
<a name="ln767">  **\brief Calculates a set of symmetry identifiers for a molecule.</a>
<a name="ln768">  ** Atoms with the same symmetry ID are symmetrically equivalent.</a>
<a name="ln769">  ** Vector is indexed from zero</a>
<a name="ln770">  */</a>
<a name="ln771">  void OBMol::GetGIDVector(vector&lt;unsigned int&gt; &amp;vgid)</a>
<a name="ln772">  {</a>
<a name="ln773">    vector&lt;unsigned int&gt; vgi;</a>
<a name="ln774">    GetGIVector(vgi);  //get vector of graph invariants</a>
<a name="ln775"> </a>
<a name="ln776">    int i;</a>
<a name="ln777">    OBAtom *atom;</a>
<a name="ln778">    vector&lt;OBAtom*&gt;::iterator j;</a>
<a name="ln779">    vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt; vp1,vp2;</a>
<a name="ln780">    for (i=0,atom = BeginAtom(j);atom;atom = NextAtom(j),++i)</a>
<a name="ln781">      vp1.push_back(pair&lt;OBAtom*,unsigned int&gt; (atom,vgi[i]));</a>
<a name="ln782"> </a>
<a name="ln783">    unsigned int nclass1,nclass2; //number of classes</a>
<a name="ln784">    ClassCount(vp1,nclass1);</a>
<a name="ln785"> </a>
<a name="ln786">    if (nclass1 &lt; NumAtoms())</a>
<a name="ln787">      {</a>
<a name="ln788">        for (i = 0;i &lt; 100;++i) //sanity check - shouldn't ever hit this number</a>
<a name="ln789">          {</a>
<a name="ln790">            CreateNewClassVector(vp1,vp2);</a>
<a name="ln791">            ClassCount(vp2,nclass2);</a>
<a name="ln792">            vp1 = vp2;</a>
<a name="ln793">            if (nclass1 == nclass2)</a>
<a name="ln794">              break;</a>
<a name="ln795">            nclass1 = nclass2;</a>
<a name="ln796">          }</a>
<a name="ln797">      }</a>
<a name="ln798"> </a>
<a name="ln799">    vgid.clear();</a>
<a name="ln800">    sort(vp1.begin(),vp1.end(),OBComparePairFirst);</a>
<a name="ln801">    vector&lt;pair&lt;OBAtom*,unsigned int&gt; &gt;::iterator k;</a>
<a name="ln802">    for (k = vp1.begin();k != vp1.end();++k)</a>
<a name="ln803">      vgid.push_back(k-&gt;second);</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  unsigned int OBMol::NumHvyAtoms()</a>
<a name="ln807">  {</a>
<a name="ln808">    OBAtom *atom;</a>
<a name="ln809">    vector&lt;OBAtom*&gt;::iterator(i);</a>
<a name="ln810">    unsigned int count = 0;</a>
<a name="ln811"> </a>
<a name="ln812">    for(atom = this-&gt;BeginAtom(i);atom;atom = this-&gt;NextAtom(i))</a>
<a name="ln813">      {</a>
<a name="ln814">        if (atom-&gt;GetAtomicNum() != OBElements::Hydrogen)</a>
<a name="ln815">          count++;</a>
<a name="ln816">      }</a>
<a name="ln817"> </a>
<a name="ln818">    return(count);</a>
<a name="ln819">  }</a>
<a name="ln820"> </a>
<a name="ln821">  unsigned int OBMol::NumRotors(bool sampleRingBonds)</a>
<a name="ln822">  {</a>
<a name="ln823">    OBRotorList rl;</a>
<a name="ln824">    rl.FindRotors(*this, sampleRingBonds);</a>
<a name="ln825">    return rl.Size();</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  //! Returns a pointer to the atom after a safety check</a>
<a name="ln829">  //! 0 &lt; idx &lt;= NumAtoms</a>
<a name="ln830">  OBAtom *OBMol::GetAtom(int idx) const</a>
<a name="ln831">  {</a>
<a name="ln832">    if ((unsigned)idx &lt; 1 || (unsigned)idx &gt; NumAtoms())</a>
<a name="ln833">      {</a>
<a name="ln834">        obErrorLog.ThrowError(__FUNCTION__, &quot;Requested Atom Out of Range&quot;, obDebug);</a>
<a name="ln835">        return nullptr;</a>
<a name="ln836">      }</a>
<a name="ln837"> </a>
<a name="ln838">    return((OBAtom*)_vatom[idx-1]);</a>
<a name="ln839">  }</a>
<a name="ln840"> </a>
<a name="ln841">  OBAtom *OBMol::GetAtomById(unsigned long id) const</a>
<a name="ln842">  {</a>
<a name="ln843">    if (id &gt;= _atomIds.size()) {</a>
<a name="ln844">      obErrorLog.ThrowError(__FUNCTION__, &quot;Requested atom with invalid id.&quot;, obDebug);</a>
<a name="ln845">      return nullptr;</a>
<a name="ln846">    }</a>
<a name="ln847"> </a>
<a name="ln848">    return((OBAtom*)_atomIds[id]);</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  OBAtom *OBMol::GetFirstAtom() const</a>
<a name="ln852">  {</a>
<a name="ln853">    return _vatom.empty() ? nullptr : (OBAtom*)_vatom[0];</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">  //! Returns a pointer to the bond after a safety check</a>
<a name="ln857">  //! 0 &lt;= idx &lt; NumBonds</a>
<a name="ln858">  OBBond *OBMol::GetBond(int idx) const</a>
<a name="ln859">  {</a>
<a name="ln860">    if (idx &lt; 0 || (unsigned)idx &gt;= NumBonds())</a>
<a name="ln861">      {</a>
<a name="ln862">        obErrorLog.ThrowError(__FUNCTION__, &quot;Requested Bond Out of Range&quot;, obDebug);</a>
<a name="ln863">        return nullptr;</a>
<a name="ln864">      }</a>
<a name="ln865"> </a>
<a name="ln866">    return((OBBond*)_vbond[idx]);</a>
<a name="ln867">  }</a>
<a name="ln868"> </a>
<a name="ln869">  OBBond *OBMol::GetBondById(unsigned long id) const</a>
<a name="ln870">  {</a>
<a name="ln871">    if (id &gt;= _bondIds.size()) {</a>
<a name="ln872">      obErrorLog.ThrowError(__FUNCTION__, &quot;Requested bond with invalid id.&quot;, obDebug);</a>
<a name="ln873">      return nullptr;</a>
<a name="ln874">    }</a>
<a name="ln875"> </a>
<a name="ln876">    return((OBBond*)_bondIds[id]);</a>
<a name="ln877">  }</a>
<a name="ln878"> </a>
<a name="ln879">  OBBond *OBMol::GetBond(int bgn, int end) const</a>
<a name="ln880">  {</a>
<a name="ln881">    return(GetBond(GetAtom(bgn),GetAtom(end)));</a>
<a name="ln882">  }</a>
<a name="ln883"> </a>
<a name="ln884">  OBBond *OBMol::GetBond(OBAtom *bgn,OBAtom *end) const</a>
<a name="ln885">  {</a>
<a name="ln886">    OBAtom *nbr;</a>
<a name="ln887">    vector&lt;OBBond*&gt;::iterator i;</a>
<a name="ln888"> </a>
<a name="ln889">    if (!bgn || !end) return nullptr;</a>
<a name="ln890"> </a>
<a name="ln891">    for (nbr = bgn-&gt;BeginNbrAtom(i);nbr;nbr = bgn-&gt;NextNbrAtom(i))</a>
<a name="ln892">      if (nbr == end)</a>
<a name="ln893">        return((OBBond *)*i);</a>
<a name="ln894"> </a>
<a name="ln895">    return nullptr; //just to keep the SGI compiler happy</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  OBResidue *OBMol::GetResidue(int idx) const</a>
<a name="ln899">  {</a>
<a name="ln900">    if (idx &lt; 0 || (unsigned)idx &gt;= NumResidues())</a>
<a name="ln901">      {</a>
<a name="ln902">        obErrorLog.ThrowError(__FUNCTION__, &quot;Requested Residue Out of Range&quot;, obDebug);</a>
<a name="ln903">        return nullptr;</a>
<a name="ln904">      }</a>
<a name="ln905"> </a>
<a name="ln906">    return (_residue[idx]);</a>
<a name="ln907">  }</a>
<a name="ln908"> </a>
<a name="ln909">  std::vector&lt;OBInternalCoord*&gt; OBMol::GetInternalCoord()</a>
<a name="ln910">  {</a>
<a name="ln911">    if (_internals.empty())</a>
<a name="ln912">      {</a>
<a name="ln913">        _internals.push_back(nullptr);</a>
<a name="ln914">        for(unsigned int i = 1; i &lt;= NumAtoms(); ++i)</a>
<a name="ln915">          {</a>
<a name="ln916">            _internals.push_back(new OBInternalCoord);</a>
<a name="ln917">          }</a>
<a name="ln918">        CartesianToInternal(_internals, *this);</a>
<a name="ln919">      }</a>
<a name="ln920">    return _internals;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  //! Implements &lt;a href=&quot;http://qsar.sourceforge.net/dicts/blue-obelisk/index.xhtml#findSmallestSetOfSmallestRings&quot;&gt;blue-obelisk:findSmallestSetOfSmallestRings&lt;/a&gt;.</a>
<a name="ln924">  vector&lt;OBRing*&gt; &amp;OBMol::GetSSSR()</a>
<a name="ln925">  {</a>
<a name="ln926">    if (!HasSSSRPerceived())</a>
<a name="ln927">      FindSSSR();</a>
<a name="ln928"> </a>
<a name="ln929">    OBRingData *rd = nullptr;</a>
<a name="ln930">    if (!HasData(&quot;SSSR&quot;)) {</a>
<a name="ln931">      rd = new OBRingData();</a>
<a name="ln932">      rd-&gt;SetAttribute(&quot;SSSR&quot;);</a>
<a name="ln933">      SetData(rd);</a>
<a name="ln934">    }</a>
<a name="ln935"> </a>
<a name="ln936">    rd = (OBRingData *) GetData(&quot;SSSR&quot;);</a>
<a name="ln937">    rd-&gt;SetOrigin(perceived);</a>
<a name="ln938">    return(rd-&gt;GetData());</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  vector&lt;OBRing*&gt; &amp;OBMol::GetLSSR()</a>
<a name="ln942">  {</a>
<a name="ln943">    if (!HasLSSRPerceived())</a>
<a name="ln944">      FindLSSR();</a>
<a name="ln945"> </a>
<a name="ln946">    OBRingData *rd = nullptr;</a>
<a name="ln947">    if (!HasData(&quot;LSSR&quot;)) {</a>
<a name="ln948">      rd = new OBRingData();</a>
<a name="ln949">      rd-&gt;SetAttribute(&quot;LSSR&quot;);</a>
<a name="ln950">      SetData(rd);</a>
<a name="ln951">    }</a>
<a name="ln952"> </a>
<a name="ln953">    rd = (OBRingData *) GetData(&quot;LSSR&quot;);</a>
<a name="ln954">    rd-&gt;SetOrigin(perceived);</a>
<a name="ln955">    return(rd-&gt;GetData());</a>
<a name="ln956">  }</a>
<a name="ln957"> </a>
<a name="ln958">  double OBMol::GetMolWt(bool implicitH)</a>
<a name="ln959">  {</a>
<a name="ln960">    double molwt=0.0;</a>
<a name="ln961">    OBAtom *atom;</a>
<a name="ln962">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln963"> </a>
<a name="ln964">    double hmass = OBElements::GetMass(1);</a>
<a name="ln965">    for (atom = BeginAtom(i);atom;atom = NextAtom(i)) {</a>
<a name="ln966">      molwt += atom-&gt;GetAtomicMass();</a>
<a name="ln967">      if (implicitH)</a>
<a name="ln968">        molwt += atom-&gt;GetImplicitHCount() * hmass;</a>
<a name="ln969">    }</a>
<a name="ln970">    return(molwt);</a>
<a name="ln971">  }</a>
<a name="ln972"> </a>
<a name="ln973">  double OBMol::GetExactMass(bool implicitH)</a>
<a name="ln974">  {</a>
<a name="ln975">    double mass=0.0;</a>
<a name="ln976">    OBAtom *atom;</a>
<a name="ln977">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln978"> </a>
<a name="ln979">    double hmass = OBElements::GetExactMass(1, 1);</a>
<a name="ln980">    for (atom = BeginAtom(i); atom; atom = NextAtom(i)) {</a>
<a name="ln981">      mass += atom-&gt;GetExactMass();</a>
<a name="ln982">      if (implicitH)</a>
<a name="ln983">        mass += atom-&gt;GetImplicitHCount() * hmass;</a>
<a name="ln984">    }</a>
<a name="ln985"> </a>
<a name="ln986">    return(mass);</a>
<a name="ln987">  }</a>
<a name="ln988"> </a>
<a name="ln989">  //! Stochoimetric formula in spaced format e.g. C 4 H 6 O 1</a>
<a name="ln990">  //! No pair data is stored. Normally use without parameters: GetSpacedFormula()</a>
<a name="ln991">  //! \since version 2.1</a>
<a name="ln992">  string OBMol::GetSpacedFormula(int ones, const char* sp, bool implicitH)</a>
<a name="ln993">  {</a>
<a name="ln994">    //Default ones=0, sp=&quot; &quot;.</a>
<a name="ln995">    //Using ones=1 and sp=&quot;&quot; will give unspaced formula (and no pair data entry)</a>
<a name="ln996">    // These are the atomic numbers of the elements in alphabetical order, plus</a>
<a name="ln997">    // pseudo atomic numbers for D, T isotopes.</a>
<a name="ln998">    const int NumElements = 118 + 2;</a>
<a name="ln999">    const int alphabetical[NumElements] = {</a>
<a name="ln1000">      89, 47, 13, 95, 18, 33, 85, 79, 5, 56, 4, 107, 83, 97, 35, 6, 20, 48,</a>
<a name="ln1001">      58, 98, 17, 96, 112, 27, 24, 55, 29, NumElements-1,</a>
<a name="ln1002">      105, 110, 66, 68, 99, 63, 9, 26, 114, 100, 87, 31,</a>
<a name="ln1003">      64, 32, 1, 2, 72, 80, 67, 108, 53, 49, 77, 19, 36, 57, 3, 103, 71, 116, 115, 101,</a>
<a name="ln1004">      12, 25, 42, 109, 7, 11, 41, 60, 10, 113, 28, 102, 93, 8, 118, 76, 15, 91, 82, 46,</a>
<a name="ln1005">      61, 84, 59, 78, 94, 88, 37, 75, 104, 111, 45, 86, 44, 16, 51, 21, 34, 106, 14,</a>
<a name="ln1006">      62, 50, 38, NumElements, 73, 65, 43, 52, 90, 22, 81, 69, 117, 92, 23, 74, 54, 39, 70,</a>
<a name="ln1007">      30, 40 };</a>
<a name="ln1008"> </a>
<a name="ln1009">    int atomicCount[NumElements];</a>
<a name="ln1010">    stringstream formula;</a>
<a name="ln1011"> </a>
<a name="ln1012">    for (int i = 0; i &lt; NumElements; ++i)</a>
<a name="ln1013">      atomicCount[i] = 0;</a>
<a name="ln1014"> </a>
<a name="ln1015">    bool UseImplicitH = (NumBonds()!=0 || NumAtoms()==1);</a>
<a name="ln1016">    // Do not use implicit hydrogens if explicitly required not to</a>
<a name="ln1017">    if (!implicitH) UseImplicitH = false;</a>
<a name="ln1018">    bool HasHvyAtoms = NumHvyAtoms()&gt;0;</a>
<a name="ln1019">    FOR_ATOMS_OF_MOL(a, *this)</a>
<a name="ln1020">      {</a>
<a name="ln1021">        int anum = a-&gt;GetAtomicNum();</a>
<a name="ln1022">        if(anum==0)</a>
<a name="ln1023">          continue;</a>
<a name="ln1024">        if(anum &gt; (NumElements-2)) {</a>
<a name="ln1025">          char buffer[BUFF_SIZE];  // error buffer</a>
<a name="ln1026">          snprintf(buffer, BUFF_SIZE, &quot;Skipping unknown element with atomic number %d&quot;, anum);</a>
<a name="ln1027">          obErrorLog.ThrowError(__FUNCTION__, buffer, obWarning);</a>
<a name="ln1028">          continue;</a>
<a name="ln1029">        }</a>
<a name="ln1030">        bool IsHiso = anum == 1 &amp;&amp; a-&gt;GetIsotope()&gt;=2;</a>
<a name="ln1031">        if(UseImplicitH)</a>
<a name="ln1032">          {</a>
<a name="ln1033">            if (anum == 1 &amp;&amp; !IsHiso &amp;&amp; HasHvyAtoms)</a>
<a name="ln1034">              continue; // skip explicit hydrogens except D,T</a>
<a name="ln1035">            if(anum==1)</a>
<a name="ln1036">              {</a>
<a name="ln1037">                if (IsHiso &amp;&amp; HasHvyAtoms)</a>
<a name="ln1038">                  --atomicCount[0]; //one of the implicit hydrogens is now explicit</a>
<a name="ln1039">              }</a>
<a name="ln1040">            else</a>
<a name="ln1041">              atomicCount[0] += a-&gt;GetImplicitHCount() + a-&gt;ExplicitHydrogenCount();</a>
<a name="ln1042">          }</a>
<a name="ln1043">        if (IsHiso)</a>
<a name="ln1044">          anum = NumElements + a-&gt;GetIsotope() - 3; //pseudo AtNo for D, T</a>
<a name="ln1045">        atomicCount[anum - 1]++;</a>
<a name="ln1046">      }</a>
<a name="ln1047"> </a>
<a name="ln1048">    if (atomicCount[5] != 0) // Carbon (i.e. 6 - 1 = 5)</a>
<a name="ln1049">      {</a>
<a name="ln1050">        if (atomicCount[5] &gt; ones)</a>
<a name="ln1051">          formula &lt;&lt; &quot;C&quot; &lt;&lt; sp &lt;&lt; atomicCount[5] &lt;&lt; sp;</a>
<a name="ln1052">        else if (atomicCount[5] == 1)</a>
<a name="ln1053">          formula &lt;&lt; &quot;C&quot;;</a>
<a name="ln1054"> </a>
<a name="ln1055">        atomicCount[5] = 0; // So we don't output C twice</a>
<a name="ln1056"> </a>
<a name="ln1057">        // only output H if there's also carbon -- otherwise do it alphabetical</a>
<a name="ln1058">        if (atomicCount[0] != 0) // Hydrogen (i.e., 1 - 1 = 0)</a>
<a name="ln1059">          {</a>
<a name="ln1060">            if (atomicCount[0] &gt; ones)</a>
<a name="ln1061">              formula &lt;&lt; &quot;H&quot; &lt;&lt; sp &lt;&lt; atomicCount[0] &lt;&lt; sp;</a>
<a name="ln1062">            else if (atomicCount[0] == 1)</a>
<a name="ln1063">              formula &lt;&lt; &quot;H&quot;;</a>
<a name="ln1064"> </a>
<a name="ln1065">            atomicCount[0] = 0;</a>
<a name="ln1066">          }</a>
<a name="ln1067">      }</a>
<a name="ln1068"> </a>
<a name="ln1069">    for (int j = 0; j &lt; NumElements; ++j)</a>
<a name="ln1070">      {</a>
<a name="ln1071">        char DT[4] = {'D',0,'T',0};</a>
<a name="ln1072">        const char* symb;</a>
<a name="ln1073">        int alph = alphabetical[j]-1;</a>
<a name="ln1074">        if (atomicCount[ alph ])</a>
<a name="ln1075">          {</a>
<a name="ln1076">            if(alph==NumElements-1)</a>
<a name="ln1077">              symb = DT + 2;//T</a>
<a name="ln1078">            else if (alph==NumElements-2)</a>
<a name="ln1079">              symb = DT; //D</a>
<a name="ln1080">            else</a>
<a name="ln1081">              symb = OBElements::GetSymbol(alphabetical[j]);</a>
<a name="ln1082"> </a>
<a name="ln1083">            formula &lt;&lt; symb &lt;&lt; sp;</a>
<a name="ln1084">            if(atomicCount[alph] &gt; ones)</a>
<a name="ln1085">              formula &lt;&lt; atomicCount[alph] &lt;&lt; sp;</a>
<a name="ln1086">          }</a>
<a name="ln1087">      }</a>
<a name="ln1088"> </a>
<a name="ln1089">    int chg = GetTotalCharge();</a>
<a name="ln1090">    char ch = chg&gt;0 ? '+' : '-' ;</a>
<a name="ln1091">    chg = abs(chg);</a>
<a name="ln1092">    while(chg--)</a>
<a name="ln1093">      formula &lt;&lt; ch &lt;&lt; sp;</a>
<a name="ln1094"> </a>
<a name="ln1095">    string f_str = formula.str();</a>
<a name="ln1096">    return (Trim(f_str));</a>
<a name="ln1097">  }</a>
<a name="ln1098"> </a>
<a name="ln1099">  //! Stochoimetric formula (e.g., C4H6O).</a>
<a name="ln1100">  //!   This is either set by OBMol::SetFormula() or generated on-the-fly</a>
<a name="ln1101">  //!   using the &quot;Hill order&quot; -- i.e., C first if present, then H if present</a>
<a name="ln1102">  //!   all other elements in alphabetical order.</a>
<a name="ln1103">  string OBMol::GetFormula()</a>
<a name="ln1104">  {</a>
<a name="ln1105">    string attr = &quot;Formula&quot;;</a>
<a name="ln1106">    OBPairData *dp = (OBPairData *) GetData(attr);</a>
<a name="ln1107"> </a>
<a name="ln1108">    if (dp != nullptr) // we already set the formula (or it was read from a file)</a>
<a name="ln1109">      return dp-&gt;GetValue();</a>
<a name="ln1110"> </a>
<a name="ln1111">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1112">                          &quot;Ran OpenBabel::SetFormula -- Hill order formula&quot;,</a>
<a name="ln1113">                          obAuditMsg);</a>
<a name="ln1114"> </a>
<a name="ln1115">    string sformula = GetSpacedFormula(1, &quot;&quot;);</a>
<a name="ln1116"> </a>
<a name="ln1117">    dp = new OBPairData;</a>
<a name="ln1118">    dp-&gt;SetAttribute(attr);</a>
<a name="ln1119">    dp-&gt;SetValue( sformula );</a>
<a name="ln1120">    dp-&gt;SetOrigin( perceived ); // internal generation</a>
<a name="ln1121">    SetData(dp);</a>
<a name="ln1122">    return sformula;</a>
<a name="ln1123">  }</a>
<a name="ln1124"> </a>
<a name="ln1125">  void OBMol::SetFormula(string molFormula)</a>
<a name="ln1126">  {</a>
<a name="ln1127">    string attr = &quot;Formula&quot;;</a>
<a name="ln1128">    OBPairData *dp = (OBPairData *) GetData(attr);</a>
<a name="ln1129">    if (dp == nullptr)</a>
<a name="ln1130">      {</a>
<a name="ln1131">        dp = new OBPairData;</a>
<a name="ln1132">        dp-&gt;SetAttribute(attr);</a>
<a name="ln1133">        SetData(dp);</a>
<a name="ln1134">      }</a>
<a name="ln1135">    dp-&gt;SetValue(molFormula);</a>
<a name="ln1136">    // typically file input, but this needs to be revisited</a>
<a name="ln1137">    dp-&gt;SetOrigin(fileformatInput);</a>
<a name="ln1138">  }</a>
<a name="ln1139"> </a>
<a name="ln1140">  void OBMol::SetTotalCharge(int charge)</a>
<a name="ln1141">  {</a>
<a name="ln1142">    SetFlag(OB_TCHARGE_MOL);</a>
<a name="ln1143">    _totalCharge = charge;</a>
<a name="ln1144">  }</a>
<a name="ln1145"> </a>
<a name="ln1146">  //! Returns the total molecular charge -- if it has not previously been set</a>
<a name="ln1147">  //!  it is calculated from the atomic formal charge information.</a>
<a name="ln1148">  //!  (This may or may not be correct!)</a>
<a name="ln1149">  //!  If you set atomic charges with OBAtom::SetFormalCharge()</a>
<a name="ln1150">  //!   you really should set the molecular charge with OBMol::SetTotalCharge()</a>
<a name="ln1151">  int OBMol::GetTotalCharge()</a>
<a name="ln1152">  {</a>
<a name="ln1153">    if(HasFlag(OB_TCHARGE_MOL))</a>
<a name="ln1154">      return(_totalCharge);</a>
<a name="ln1155">    else // calculate from atomic formal charges (seems the best default)</a>
<a name="ln1156">      {</a>
<a name="ln1157">        obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1158">                              &quot;Ran OpenBabel::GetTotalCharge -- calculated from formal charges&quot;,</a>
<a name="ln1159">                              obAuditMsg);</a>
<a name="ln1160"> </a>
<a name="ln1161">        OBAtom *atom;</a>
<a name="ln1162">        vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1163">        int chg = 0;</a>
<a name="ln1164"> </a>
<a name="ln1165">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln1166">          chg += atom-&gt;GetFormalCharge();</a>
<a name="ln1167">        return (chg);</a>
<a name="ln1168">      }</a>
<a name="ln1169">  }</a>
<a name="ln1170"> </a>
<a name="ln1171">  void   OBMol::SetTotalSpinMultiplicity(unsigned int spin)</a>
<a name="ln1172">  {</a>
<a name="ln1173">    SetFlag(OB_TSPIN_MOL);</a>
<a name="ln1174">    _totalSpin = spin;</a>
<a name="ln1175">  }</a>
<a name="ln1176"> </a>
<a name="ln1177">  void OBMol::SetInternalCoord(std::vector&lt;OBInternalCoord*&gt; int_coord) {</a>
<a name="ln1178">    if (int_coord[0] != nullptr) {</a>
<a name="ln1179">      std::vector&lt;OBInternalCoord*&gt;::iterator it = int_coord.begin();</a>
<a name="ln1180">      int_coord.insert(it, nullptr);</a>
<a name="ln1181">    }</a>
<a name="ln1182"> </a>
<a name="ln1183">    if (int_coord.size() != _natoms + 1) {</a>
<a name="ln1184">      string error = &quot;Number of internal coordinates is not the same as&quot;;</a>
<a name="ln1185">      error += &quot; the number of atoms in molecule&quot;;</a>
<a name="ln1186">      obErrorLog.ThrowError(__FUNCTION__, error, obError);</a>
<a name="ln1187">      return;</a>
<a name="ln1188">    }</a>
<a name="ln1189"> </a>
<a name="ln1190">    _internals = int_coord;</a>
<a name="ln1191"> </a>
<a name="ln1192">    return;</a>
<a name="ln1193">  }</a>
<a name="ln1194"> </a>
<a name="ln1195">  //! Returns the total spin multiplicity -- if it has not previously been set</a>
<a name="ln1196">  //!  It is calculated from the atomic spin multiplicity information</a>
<a name="ln1197">  //!  assuming the high-spin case (i.e. it simply sums the number of unpaired</a>
<a name="ln1198">  //!  electrons assuming no further pairing of spins.</a>
<a name="ln1199">  //!  if it fails (gives singlet for odd number of electronic systems),</a>
<a name="ln1200">  //!  then assign wrt parity of the total electrons.</a>
<a name="ln1201">  unsigned int OBMol::GetTotalSpinMultiplicity()</a>
<a name="ln1202">  {</a>
<a name="ln1203">    if (HasFlag(OB_TSPIN_MOL))</a>
<a name="ln1204">      return(_totalSpin);</a>
<a name="ln1205">    else // calculate from atomic spin information (assuming high-spin case)</a>
<a name="ln1206">      {</a>
<a name="ln1207">        obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1208">                              &quot;Ran OpenBabel::GetTotalSpinMultiplicity -- calculating from atomic spins assuming high spin case&quot;,</a>
<a name="ln1209">                              obAuditMsg);</a>
<a name="ln1210"> </a>
<a name="ln1211">        OBAtom *atom;</a>
<a name="ln1212">        vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1213">        unsigned int unpaired_electrons = 0;</a>
<a name="ln1214">        int chg = GetTotalCharge();</a>
<a name="ln1215">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln1216">          {</a>
<a name="ln1217">            if (atom-&gt;GetSpinMultiplicity() &gt; 1)</a>
<a name="ln1218">              unpaired_electrons += (atom-&gt;GetSpinMultiplicity() - 1);</a>
<a name="ln1219">           chg += atom-&gt;GetAtomicNum();</a>
<a name="ln1220">          }</a>
<a name="ln1221">        if (chg % 2 != unpaired_electrons %2)</a>
<a name="ln1222">          return ((abs(chg) % 2) + 1);</a>
<a name="ln1223">        else</a>
<a name="ln1224">          return (unpaired_electrons + 1);</a>
<a name="ln1225">      }</a>
<a name="ln1226">  }</a>
<a name="ln1227"> </a>
<a name="ln1228">  OBMol &amp;OBMol::operator=(const OBMol &amp;source)</a>
<a name="ln1229">  //atom and bond info is copied from src to dest</a>
<a name="ln1230">  //Conformers are now copied also, MM 2/7/01</a>
<a name="ln1231">  //Residue information are copied, MM 4-27-01</a>
<a name="ln1232">  //All OBGenericData incl OBRotameterList is copied, CM 2006</a>
<a name="ln1233">  //Zeros all flags except OB_TCHARGE_MOL, OB_PCHARGE_MOL, OB_HYBRID_MOL</a>
<a name="ln1234">  //OB_TSPIN_MOL, OB_AROMATIC_MOL, OB_PERIODIC_MOL, OB_CHAINS_MOL and OB_PATTERN_STRUCTURE which are copied</a>
<a name="ln1235">  {</a>
<a name="ln1236">    if (this == &amp;source)</a>
<a name="ln1237">      return *this;</a>
<a name="ln1238"> </a>
<a name="ln1239">    OBMol &amp;src = (OBMol &amp;)source;</a>
<a name="ln1240">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1241">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln1242">    OBAtom *atom;</a>
<a name="ln1243">    OBBond *bond;</a>
<a name="ln1244"> </a>
<a name="ln1245">    Clear();</a>
<a name="ln1246">    BeginModify();</a>
<a name="ln1247"> </a>
<a name="ln1248">    _vatom.reserve(src.NumAtoms());</a>
<a name="ln1249">    _atomIds.reserve(src.NumAtoms());</a>
<a name="ln1250">    _vbond.reserve(src.NumBonds());</a>
<a name="ln1251">    _bondIds.reserve(src.NumBonds());</a>
<a name="ln1252"> </a>
<a name="ln1253">    for (atom = src.BeginAtom(i);atom;atom = src.NextAtom(i))</a>
<a name="ln1254">      AddAtom(*atom);</a>
<a name="ln1255">    for (bond = src.BeginBond(j);bond;bond = src.NextBond(j))</a>
<a name="ln1256">      AddBond(*bond);</a>
<a name="ln1257"> </a>
<a name="ln1258">    this-&gt;_title  = src.GetTitle();</a>
<a name="ln1259">    this-&gt;_energy = src.GetEnergy();</a>
<a name="ln1260">    this-&gt;_dimension = src.GetDimension();</a>
<a name="ln1261">    this-&gt;SetTotalCharge(src.GetTotalCharge()); //also sets a flag</a>
<a name="ln1262">    this-&gt;SetTotalSpinMultiplicity(src.GetTotalSpinMultiplicity()); //also sets a flag</a>
<a name="ln1263"> </a>
<a name="ln1264">    EndModify(); //zeros flags!</a>
<a name="ln1265"> </a>
<a name="ln1266">    if (src.HasFlag(OB_PATTERN_STRUCTURE))</a>
<a name="ln1267">      this-&gt;SetFlag(OB_PATTERN_STRUCTURE);</a>
<a name="ln1268">    if (src.HasFlag(OB_TSPIN_MOL))</a>
<a name="ln1269">      this-&gt;SetFlag(OB_TSPIN_MOL);</a>
<a name="ln1270">    if (src.HasFlag(OB_TCHARGE_MOL))</a>
<a name="ln1271">      this-&gt;SetFlag(OB_TCHARGE_MOL);</a>
<a name="ln1272">    if (src.HasFlag(OB_PCHARGE_MOL))</a>
<a name="ln1273">      this-&gt;SetFlag(OB_PCHARGE_MOL);</a>
<a name="ln1274">    if (src.HasFlag(OB_PERIODIC_MOL))</a>
<a name="ln1275">      this-&gt;SetFlag(OB_PERIODIC_MOL);</a>
<a name="ln1276">    if (src.HasFlag(OB_HYBRID_MOL))</a>
<a name="ln1277">      this-&gt;SetFlag(OB_HYBRID_MOL);</a>
<a name="ln1278">    if (src.HasFlag(OB_AROMATIC_MOL))</a>
<a name="ln1279">      this-&gt;SetFlag(OB_AROMATIC_MOL);</a>
<a name="ln1280">    if (src.HasFlag(OB_CHAINS_MOL))</a>
<a name="ln1281">      this-&gt;SetFlag(OB_CHAINS_MOL);</a>
<a name="ln1282">    //this-&gt;_flags = src.GetFlags(); //Copy all flags. Perhaps too drastic a change</a>
<a name="ln1283"> </a>
<a name="ln1284"> </a>
<a name="ln1285">    //Copy Residue information</a>
<a name="ln1286">    unsigned int NumRes = src.NumResidues();</a>
<a name="ln1287">    if (NumRes)</a>
<a name="ln1288">      {</a>
<a name="ln1289">        unsigned int k;</a>
<a name="ln1290">        OBResidue *src_res = nullptr;</a>
<a name="ln1291">        OBResidue *res = nullptr;</a>
<a name="ln1292">        OBAtom *src_atom = nullptr;</a>
<a name="ln1293">        OBAtom *atom = nullptr;</a>
<a name="ln1294">        vector&lt;OBAtom*&gt;::iterator ii;</a>
<a name="ln1295">        for (k=0 ; k&lt;NumRes ; ++k)</a>
<a name="ln1296">          {</a>
<a name="ln1297">            res = NewResidue();</a>
<a name="ln1298">            src_res = src.GetResidue(k);</a>
<a name="ln1299">            *res = *src_res; //does not copy atoms</a>
<a name="ln1300">            for (src_atom=src_res-&gt;BeginAtom(ii) ; src_atom ; src_atom=src_res-&gt;NextAtom(ii))</a>
<a name="ln1301">              {</a>
<a name="ln1302">                atom = GetAtom(src_atom-&gt;GetIdx());</a>
<a name="ln1303">                res-&gt;AddAtom(atom);</a>
<a name="ln1304">                res-&gt;SetAtomID(atom,src_res-&gt;GetAtomID(src_atom));</a>
<a name="ln1305">                res-&gt;SetHetAtom(atom,src_res-&gt;IsHetAtom(src_atom));</a>
<a name="ln1306">                res-&gt;SetSerialNum(atom,src_res-&gt;GetSerialNum(src_atom));</a>
<a name="ln1307">              }</a>
<a name="ln1308">          }</a>
<a name="ln1309">      }</a>
<a name="ln1310"> </a>
<a name="ln1311">    //Copy conformer information</a>
<a name="ln1312">    if (src.NumConformers() &gt; 1) {</a>
<a name="ln1313">      int k;//,l;</a>
<a name="ln1314">      vector&lt;double*&gt; conf;</a>
<a name="ln1315">      int currConf = -1;</a>
<a name="ln1316">      double* xyz = nullptr;</a>
<a name="ln1317">      for (k=0 ; k&lt;src.NumConformers() ; ++k) {</a>
<a name="ln1318">        xyz = new double [3*src.NumAtoms()];</a>
<a name="ln1319">        memcpy( xyz, src.GetConformer(k), sizeof( double )*3*src.NumAtoms() );</a>
<a name="ln1320">        conf.push_back(xyz);</a>
<a name="ln1321"> </a>
<a name="ln1322">        if( src.GetConformer(k) == src._c ) {</a>
<a name="ln1323">          currConf = k;</a>
<a name="ln1324">        }</a>
<a name="ln1325">      }</a>
<a name="ln1326"> </a>
<a name="ln1327">      SetConformers(conf);</a>
<a name="ln1328">      if( currConf &gt;= 0 &amp;&amp; _vconf.size() ) {</a>
<a name="ln1329">        _c = _vconf[currConf];</a>
<a name="ln1330">      }</a>
<a name="ln1331">    }</a>
<a name="ln1332"> </a>
<a name="ln1333">    //Copy all the OBGenericData, providing the new molecule, this,</a>
<a name="ln1334">    //for those classes like OBRotameterList which contain Atom pointers</a>
<a name="ln1335">    //OBGenericData classes can choose not to be cloned by returning NULL</a>
<a name="ln1336">    vector&lt;OBGenericData*&gt;::iterator itr;</a>
<a name="ln1337">    for(itr=src.BeginData();itr!=src.EndData();++itr)</a>
<a name="ln1338">      {</a>
<a name="ln1339">        OBGenericData* pCopiedData = (*itr)-&gt;Clone(this);</a>
<a name="ln1340">        SetData(pCopiedData);</a>
<a name="ln1341">      }</a>
<a name="ln1342"> </a>
<a name="ln1343">    if (src.HasChiralityPerceived())</a>
<a name="ln1344">      SetChiralityPerceived();</a>
<a name="ln1345"> </a>
<a name="ln1346">    return(*this);</a>
<a name="ln1347">  }</a>
<a name="ln1348"> </a>
<a name="ln1349">  OBMol &amp;OBMol::operator+=(const OBMol &amp;source)</a>
<a name="ln1350">  {</a>
<a name="ln1351">    OBMol &amp;src = (OBMol &amp;)source;</a>
<a name="ln1352">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1353">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln1354">    vector&lt;OBResidue*&gt;::iterator k;</a>
<a name="ln1355">    OBAtom *atom;</a>
<a name="ln1356">    OBBond *bond;</a>
<a name="ln1357">    OBResidue *residue;</a>
<a name="ln1358"> </a>
<a name="ln1359">    BeginModify();</a>
<a name="ln1360"> </a>
<a name="ln1361">    int prevatms = NumAtoms();</a>
<a name="ln1362"> </a>
<a name="ln1363">    string extitle(src.GetTitle());</a>
<a name="ln1364">    if(!extitle.empty())</a>
<a name="ln1365">      _title += &quot;_&quot; + extitle;</a>
<a name="ln1366"> </a>
<a name="ln1367">    // First, handle atoms and bonds</a>
<a name="ln1368">    map&lt;unsigned long int, unsigned long int&gt; correspondingId;</a>
<a name="ln1369">    for (atom = src.BeginAtom(i) ; atom ; atom = src.NextAtom(i)) {</a>
<a name="ln1370">      AddAtom(*atom, true); // forceNewId=true (don't reuse the original Id)</a>
<a name="ln1371">      OBAtom *addedAtom = GetAtom(NumAtoms());</a>
<a name="ln1372">      correspondingId[atom-&gt;GetId()] = addedAtom-&gt;GetId();</a>
<a name="ln1373">    }</a>
<a name="ln1374">    correspondingId[OBStereo::ImplicitRef] = OBStereo::ImplicitRef;</a>
<a name="ln1375"> </a>
<a name="ln1376">    for (bond = src.BeginBond(j) ; bond ; bond = src.NextBond(j)) {</a>
<a name="ln1377">      bond-&gt;SetId(NoId);//Need to remove ID which relates to source mol rather than this mol</a>
<a name="ln1378">      AddBond(bond-&gt;GetBeginAtomIdx() + prevatms,</a>
<a name="ln1379">              bond-&gt;GetEndAtomIdx() + prevatms,</a>
<a name="ln1380">              bond-&gt;GetBondOrder(), bond-&gt;GetFlags());</a>
<a name="ln1381">    }</a>
<a name="ln1382"> </a>
<a name="ln1383">    // Now update all copied residues too</a>
<a name="ln1384">    for (residue = src.BeginResidue(k); residue; residue = src.NextResidue(k)) {</a>
<a name="ln1385">      AddResidue(*residue);</a>
<a name="ln1386"> </a>
<a name="ln1387">      FOR_ATOMS_OF_RESIDUE(resAtom, residue)</a>
<a name="ln1388">        {</a>
<a name="ln1389">          // This is the equivalent atom in our combined molecule</a>
<a name="ln1390">          atom = GetAtom(resAtom-&gt;GetIdx() + prevatms);</a>
<a name="ln1391">          // So we add this to the last-added residue</a>
<a name="ln1392">          // (i.e., what we just copied)</a>
<a name="ln1393">          (_residue[_residue.size() - 1])-&gt;AddAtom(atom);</a>
<a name="ln1394">        }</a>
<a name="ln1395">    }</a>
<a name="ln1396"> </a>
<a name="ln1397">    // Copy the stereo</a>
<a name="ln1398">    std::vector&lt;OBGenericData*&gt; vdata = src.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln1399">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data) {</a>
<a name="ln1400">      OBStereo::Type datatype = ((OBStereoBase*)*data)-&gt;GetType();</a>
<a name="ln1401">      if (datatype == OBStereo::CisTrans) {</a>
<a name="ln1402">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln1403">        OBCisTransStereo *nct = new OBCisTransStereo(this);</a>
<a name="ln1404">        OBCisTransStereo::Config ct_cfg = ct-&gt;GetConfig();</a>
<a name="ln1405">        ct_cfg.begin = correspondingId[ct_cfg.begin];</a>
<a name="ln1406">        ct_cfg.end = correspondingId[ct_cfg.end];</a>
<a name="ln1407">        for(OBStereo::RefIter ri = ct_cfg.refs.begin(); ri != ct_cfg.refs.end(); ++ri)</a>
<a name="ln1408">          *ri = correspondingId[*ri];</a>
<a name="ln1409">        nct-&gt;SetConfig(ct_cfg);</a>
<a name="ln1410">        SetData(nct);</a>
<a name="ln1411">      }</a>
<a name="ln1412">      else if (datatype == OBStereo::Tetrahedral) {</a>
<a name="ln1413">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln1414">        OBTetrahedralStereo *nts = new OBTetrahedralStereo(this);</a>
<a name="ln1415">        OBTetrahedralStereo::Config ts_cfg = ts-&gt;GetConfig();</a>
<a name="ln1416">        ts_cfg.center = correspondingId[ts_cfg.center];</a>
<a name="ln1417">        ts_cfg.from = correspondingId[ts_cfg.from];</a>
<a name="ln1418">        for(OBStereo::RefIter ri = ts_cfg.refs.begin(); ri != ts_cfg.refs.end(); ++ri)</a>
<a name="ln1419">          *ri = correspondingId[*ri];</a>
<a name="ln1420">        nts-&gt;SetConfig(ts_cfg);</a>
<a name="ln1421">        SetData(nts);</a>
<a name="ln1422">      }</a>
<a name="ln1423">    }</a>
<a name="ln1424"> </a>
<a name="ln1425">    // TODO: This is actually a weird situation (e.g., adding a 2D mol to 3D one)</a>
<a name="ln1426">    // We should do something to update the src coordinates if they're not 3D</a>
<a name="ln1427">    if(src.GetDimension()&lt;_dimension)</a>
<a name="ln1428">      _dimension = src.GetDimension();</a>
<a name="ln1429">    // TODO: Periodicity is similarly weird (e.g., adding nonperiodic data to</a>
<a name="ln1430">    // a crystal, or two incompatible lattice parameters).  For now, just assume</a>
<a name="ln1431">    // we intend to keep the lattice of the source (no updates necessary)</a>
<a name="ln1432"> </a>
<a name="ln1433">    EndModify();</a>
<a name="ln1434"> </a>
<a name="ln1435">    return(*this);</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  bool OBMol::Clear()</a>
<a name="ln1439">  {</a>
<a name="ln1440">    if (obErrorLog.GetOutputLevel() &gt;= obAuditMsg)</a>
<a name="ln1441">      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1442">                            &quot;Ran OpenBabel::Clear Molecule&quot;, obAuditMsg);</a>
<a name="ln1443"> </a>
<a name="ln1444">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1445">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln1446">    for (i = _vatom.begin();i != _vatom.end();++i)</a>
<a name="ln1447">      {</a>
<a name="ln1448">        DestroyAtom(*i);</a>
<a name="ln1449">        *i = nullptr;</a>
<a name="ln1450">      }</a>
<a name="ln1451">    for (j = _vbond.begin();j != _vbond.end();++j)</a>
<a name="ln1452">      {</a>
<a name="ln1453">        DestroyBond(*j);</a>
<a name="ln1454">        *j = nullptr;</a>
<a name="ln1455">      }</a>
<a name="ln1456"> </a>
<a name="ln1457">    _atomIds.clear();</a>
<a name="ln1458">    _bondIds.clear();</a>
<a name="ln1459">    _natoms = _nbonds = 0;</a>
<a name="ln1460"> </a>
<a name="ln1461">    //Delete residues</a>
<a name="ln1462">    unsigned int ii;</a>
<a name="ln1463">    for (ii=0 ; ii&lt;_residue.size() ; ++ii)</a>
<a name="ln1464">      {</a>
<a name="ln1465">        DestroyResidue(_residue[ii]);</a>
<a name="ln1466">      }</a>
<a name="ln1467">    _residue.clear();</a>
<a name="ln1468"> </a>
<a name="ln1469">    //clear out the multiconformer data</a>
<a name="ln1470">    vector&lt;double*&gt;::iterator k;</a>
<a name="ln1471">    for (k = _vconf.begin();k != _vconf.end();++k)</a>
<a name="ln1472">      delete [] *k;</a>
<a name="ln1473">    _vconf.clear();</a>
<a name="ln1474"> </a>
<a name="ln1475">    //Clear flags except OB_PATTERN_STRUCTURE which is left the same</a>
<a name="ln1476">    _flags &amp;= OB_PATTERN_STRUCTURE;</a>
<a name="ln1477"> </a>
<a name="ln1478">    _c = nullptr;</a>
<a name="ln1479">    _mod = 0;</a>
<a name="ln1480"> </a>
<a name="ln1481">    // Clean up generic data via the base class</a>
<a name="ln1482">    return(OBBase::Clear());</a>
<a name="ln1483">  }</a>
<a name="ln1484"> </a>
<a name="ln1485">  void OBMol::BeginModify()</a>
<a name="ln1486">  {</a>
<a name="ln1487">    //suck coordinates from _c into _v for each atom</a>
<a name="ln1488">    if (!_mod &amp;&amp; !Empty())</a>
<a name="ln1489">      {</a>
<a name="ln1490">        OBAtom *atom;</a>
<a name="ln1491">        vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1492">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln1493">          {</a>
<a name="ln1494">            atom-&gt;SetVector();</a>
<a name="ln1495">            atom-&gt;ClearCoordPtr();</a>
<a name="ln1496">          }</a>
<a name="ln1497"> </a>
<a name="ln1498">        vector&lt;double*&gt;::iterator j;</a>
<a name="ln1499">        for (j = _vconf.begin();j != _vconf.end();++j)</a>
<a name="ln1500">          delete [] *j;</a>
<a name="ln1501"> </a>
<a name="ln1502">        _c = nullptr;</a>
<a name="ln1503">        _vconf.clear();</a>
<a name="ln1504"> </a>
<a name="ln1505">        //Destroy rotamer list if necessary</a>
<a name="ln1506">        if ((OBRotamerList *)GetData(OBGenericDataType::RotamerList))</a>
<a name="ln1507">          {</a>
<a name="ln1508">            delete (OBRotamerList *)GetData(OBGenericDataType::RotamerList);</a>
<a name="ln1509">            DeleteData(OBGenericDataType::RotamerList);</a>
<a name="ln1510">          }</a>
<a name="ln1511">      }</a>
<a name="ln1512"> </a>
<a name="ln1513">    _mod++;</a>
<a name="ln1514">  }</a>
<a name="ln1515"> </a>
<a name="ln1516">  void OBMol::EndModify(bool nukePerceivedData)</a>
<a name="ln1517">  {</a>
<a name="ln1518">    if (_mod == 0)</a>
<a name="ln1519">      {</a>
<a name="ln1520">        obErrorLog.ThrowError(__FUNCTION__, &quot;_mod is negative - EndModify() called too many times&quot;, obDebug);</a>
<a name="ln1521">        return;</a>
<a name="ln1522">      }</a>
<a name="ln1523"> </a>
<a name="ln1524">    _mod--;</a>
<a name="ln1525"> </a>
<a name="ln1526">    if (_mod)</a>
<a name="ln1527">      return;</a>
<a name="ln1528"> </a>
<a name="ln1529">    // wipe all but whether it has aromaticity perceived, is a reaction, or has periodic boundaries enabled</a>
<a name="ln1530">    if (nukePerceivedData)</a>
<a name="ln1531">      _flags = _flags &amp; (OB_AROMATIC_MOL|OB_REACTION_MOL|OB_PERIODIC_MOL);</a>
<a name="ln1532"> </a>
<a name="ln1533">    _c = nullptr;</a>
<a name="ln1534"> </a>
<a name="ln1535">    if (Empty())</a>
<a name="ln1536">      return;</a>
<a name="ln1537"> </a>
<a name="ln1538">    //if atoms present convert coords into array</a>
<a name="ln1539">    double *c = new double [NumAtoms()*3];</a>
<a name="ln1540">    _c = c;</a>
<a name="ln1541"> </a>
<a name="ln1542">    unsigned int idx;</a>
<a name="ln1543">    OBAtom *atom;</a>
<a name="ln1544">    vector&lt;OBAtom*&gt;::iterator j;</a>
<a name="ln1545">    for (idx=0,atom = BeginAtom(j);atom;atom = NextAtom(j),++idx)</a>
<a name="ln1546">      {</a>
<a name="ln1547">        atom-&gt;SetIdx(idx+1);</a>
<a name="ln1548">        (atom-&gt;GetVector()).Get(&amp;_c[idx*3]);</a>
<a name="ln1549">        atom-&gt;SetCoordPtr(&amp;_c);</a>
<a name="ln1550">      }</a>
<a name="ln1551">    _vconf.push_back(c);</a>
<a name="ln1552"> </a>
<a name="ln1553">    // Always remove angle and torsion data, since they will interfere with the iterators</a>
<a name="ln1554">    // PR#2812013</a>
<a name="ln1555">    DeleteData(OBGenericDataType::AngleData);</a>
<a name="ln1556">    DeleteData(OBGenericDataType::TorsionData);</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">  void OBMol::DestroyAtom(OBAtom *atom)</a>
<a name="ln1560">  {</a>
<a name="ln1561">    if (atom)</a>
<a name="ln1562">      {</a>
<a name="ln1563">        delete atom;</a>
<a name="ln1564">        atom = nullptr;</a>
<a name="ln1565">      }</a>
<a name="ln1566">  }</a>
<a name="ln1567"> </a>
<a name="ln1568">  void OBMol::DestroyBond(OBBond *bond)</a>
<a name="ln1569">  {</a>
<a name="ln1570">    if (bond)</a>
<a name="ln1571">      {</a>
<a name="ln1572">        delete bond;</a>
<a name="ln1573">        bond = nullptr;</a>
<a name="ln1574">      }</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  void OBMol::DestroyResidue(OBResidue *residue)</a>
<a name="ln1578">  {</a>
<a name="ln1579">    if (residue)</a>
<a name="ln1580">      {</a>
<a name="ln1581">        delete residue;</a>
<a name="ln1582">        residue = nullptr;</a>
<a name="ln1583">      }</a>
<a name="ln1584">  }</a>
<a name="ln1585"> </a>
<a name="ln1586">  OBAtom *OBMol::NewAtom()</a>
<a name="ln1587">  {</a>
<a name="ln1588">    return NewAtom(_atomIds.size());</a>
<a name="ln1589">  }</a>
<a name="ln1590"> </a>
<a name="ln1591">  //! \brief Instantiate a New Atom and add it to the molecule</a>
<a name="ln1592">  //!</a>
<a name="ln1593">  //! Checks bond_queue for any bonds that should be made to the new atom</a>
<a name="ln1594">  //! and updates atom indexes.</a>
<a name="ln1595">  OBAtom *OBMol::NewAtom(unsigned long id)</a>
<a name="ln1596">  {</a>
<a name="ln1597">    //   BeginModify();</a>
<a name="ln1598"> </a>
<a name="ln1599">    // resize _atomIds if needed</a>
<a name="ln1600">    if (id &gt;= _atomIds.size()) {</a>
<a name="ln1601">      unsigned int size = _atomIds.size();</a>
<a name="ln1602">      _atomIds.resize(id+1);</a>
<a name="ln1603">      for (unsigned long i = size; i &lt; id; ++i)</a>
<a name="ln1604">        _atomIds[i] = nullptr;</a>
<a name="ln1605">    }</a>
<a name="ln1606"> </a>
<a name="ln1607">    if (_atomIds.at(id))</a>
<a name="ln1608">      return nullptr;</a>
<a name="ln1609"> </a>
<a name="ln1610">    OBAtom *obatom = new OBAtom;</a>
<a name="ln1611">    obatom-&gt;SetIdx(_natoms+1);</a>
<a name="ln1612">    obatom-&gt;SetParent(this);</a>
<a name="ln1613"> </a>
<a name="ln1614">    _atomIds[id] = obatom;</a>
<a name="ln1615">    obatom-&gt;SetId(id);</a>
<a name="ln1616"> </a>
<a name="ln1617">#define OBAtomIncrement 100</a>
<a name="ln1618"> </a>
<a name="ln1619">    if (_natoms+1 &gt;= _vatom.size())</a>
<a name="ln1620">      {</a>
<a name="ln1621">        _vatom.resize(_natoms+OBAtomIncrement);</a>
<a name="ln1622">        vector&lt;OBAtom*&gt;::iterator j;</a>
<a name="ln1623">        for (j = _vatom.begin(),j+=(_natoms+1);j != _vatom.end();++j)</a>
<a name="ln1624">          *j = nullptr;</a>
<a name="ln1625">      }</a>
<a name="ln1626">#undef OBAtomIncrement</a>
<a name="ln1627"> </a>
<a name="ln1628"> </a>
<a name="ln1629">    _vatom[_natoms] = obatom;</a>
<a name="ln1630">    _natoms++;</a>
<a name="ln1631"> </a>
<a name="ln1632">    if (HasData(OBGenericDataType::VirtualBondData))</a>
<a name="ln1633">      {</a>
<a name="ln1634">        /*add bonds that have been queued*/</a>
<a name="ln1635">        OBVirtualBond *vb;</a>
<a name="ln1636">        vector&lt;OBGenericData*&gt; verase;</a>
<a name="ln1637">        vector&lt;OBGenericData*&gt;::iterator i;</a>
<a name="ln1638">        for (i = BeginData();i != EndData();++i)</a>
<a name="ln1639">          if ((*i)-&gt;GetDataType() == OBGenericDataType::VirtualBondData)</a>
<a name="ln1640">            {</a>
<a name="ln1641">              vb = (OBVirtualBond*)*i;</a>
<a name="ln1642">              if (vb-&gt;GetBgn() &gt; _natoms || vb-&gt;GetEnd() &gt; _natoms)</a>
<a name="ln1643">                continue;</a>
<a name="ln1644">              if (obatom-&gt;GetIdx() == static_cast&lt;unsigned int&gt;(vb-&gt;GetBgn())</a>
<a name="ln1645">                  || obatom-&gt;GetIdx() == static_cast&lt;unsigned int&gt;(vb-&gt;GetEnd()))</a>
<a name="ln1646">                {</a>
<a name="ln1647">                  AddBond(vb-&gt;GetBgn(),vb-&gt;GetEnd(),vb-&gt;GetOrder());</a>
<a name="ln1648">                  verase.push_back(*i);</a>
<a name="ln1649">                }</a>
<a name="ln1650">            }</a>
<a name="ln1651"> </a>
<a name="ln1652">        if (!verase.empty())</a>
<a name="ln1653">          DeleteData(verase);</a>
<a name="ln1654">      }</a>
<a name="ln1655"> </a>
<a name="ln1656">    // EndModify();</a>
<a name="ln1657"> </a>
<a name="ln1658">    return(obatom);</a>
<a name="ln1659">  }</a>
<a name="ln1660"> </a>
<a name="ln1661">  OBResidue *OBMol::NewResidue()</a>
<a name="ln1662">  {</a>
<a name="ln1663">    OBResidue *obresidue = new OBResidue;</a>
<a name="ln1664">    obresidue-&gt;SetIdx(_residue.size());</a>
<a name="ln1665">    _residue.push_back(obresidue);</a>
<a name="ln1666">    return(obresidue);</a>
<a name="ln1667">  }</a>
<a name="ln1668"> </a>
<a name="ln1669">  OBBond *OBMol::NewBond()</a>
<a name="ln1670">  {</a>
<a name="ln1671">    return NewBond(_bondIds.size());</a>
<a name="ln1672">  }</a>
<a name="ln1673"> </a>
<a name="ln1674">  //! \since version 2.1</a>
<a name="ln1675">  //! \brief Instantiate a New Bond and add it to the molecule</a>
<a name="ln1676">  //!</a>
<a name="ln1677">  //! Sets the proper Bond index and insures this molecule is set as the parent.</a>
<a name="ln1678">  OBBond *OBMol::NewBond(unsigned long id)</a>
<a name="ln1679">  {</a>
<a name="ln1680">    // resize _bondIds if needed</a>
<a name="ln1681">    if (id &gt;= _bondIds.size()) {</a>
<a name="ln1682">      unsigned int size = _bondIds.size();</a>
<a name="ln1683">      _bondIds.resize(id+1);</a>
<a name="ln1684">      for (unsigned long i = size; i &lt; id; ++i)</a>
<a name="ln1685">        _bondIds[i] = nullptr;</a>
<a name="ln1686">    }</a>
<a name="ln1687"> </a>
<a name="ln1688">    if (_bondIds.at(id))</a>
<a name="ln1689">      return nullptr;</a>
<a name="ln1690"> </a>
<a name="ln1691">    OBBond *pBond = new OBBond;</a>
<a name="ln1692">    pBond-&gt;SetParent(this);</a>
<a name="ln1693">    pBond-&gt;SetIdx(_nbonds);</a>
<a name="ln1694"> </a>
<a name="ln1695">    _bondIds[id] = pBond;</a>
<a name="ln1696">    pBond-&gt;SetId(id);</a>
<a name="ln1697"> </a>
<a name="ln1698">#define OBBondIncrement 100</a>
<a name="ln1699">    if (_nbonds+1 &gt;= _vbond.size())</a>
<a name="ln1700">      {</a>
<a name="ln1701">        _vbond.resize(_nbonds+OBBondIncrement);</a>
<a name="ln1702">        vector&lt;OBBond*&gt;::iterator i;</a>
<a name="ln1703">        for (i = _vbond.begin(),i+=(_nbonds+1);i != _vbond.end();++i)</a>
<a name="ln1704">          *i = nullptr;</a>
<a name="ln1705">      }</a>
<a name="ln1706">#undef  OBBondIncrement</a>
<a name="ln1707"> </a>
<a name="ln1708">    _vbond[_nbonds] = (OBBond*)pBond;</a>
<a name="ln1709">    _nbonds++;</a>
<a name="ln1710"> </a>
<a name="ln1711">    return(pBond);</a>
<a name="ln1712">  }</a>
<a name="ln1713"> </a>
<a name="ln1714">  //! \brief Add an atom to a molecule</a>
<a name="ln1715">  //!</a>
<a name="ln1716">  //! Also checks bond_queue for any bonds that should be made to the new atom</a>
<a name="ln1717">  bool OBMol::AddAtom(OBAtom &amp;atom, bool forceNewId)</a>
<a name="ln1718">  {</a>
<a name="ln1719">    //    BeginModify();</a>
<a name="ln1720"> </a>
<a name="ln1721">    // Use the existing atom Id unless either it's invalid or forceNewId has been specified</a>
<a name="ln1722">    unsigned long id;</a>
<a name="ln1723">    if (forceNewId)</a>
<a name="ln1724">      id = _atomIds.size();</a>
<a name="ln1725">    else {</a>
<a name="ln1726">      id = atom.GetId();</a>
<a name="ln1727">      if (id == NoId)</a>
<a name="ln1728">        id = _atomIds.size();</a>
<a name="ln1729">    }</a>
<a name="ln1730"> </a>
<a name="ln1731">    OBAtom *obatom = new OBAtom;</a>
<a name="ln1732">    *obatom = atom;</a>
<a name="ln1733">    obatom-&gt;SetIdx(_natoms+1);</a>
<a name="ln1734">    obatom-&gt;SetParent(this);</a>
<a name="ln1735"> </a>
<a name="ln1736">    // resize _atomIds if needed</a>
<a name="ln1737">    if (id &gt;= _atomIds.size()) {</a>
<a name="ln1738">      unsigned int size = _atomIds.size();</a>
<a name="ln1739">      _atomIds.resize(id+1);</a>
<a name="ln1740">      for (unsigned long i = size; i &lt; id; ++i)</a>
<a name="ln1741">        _atomIds[i] = nullptr;</a>
<a name="ln1742">    }</a>
<a name="ln1743"> </a>
<a name="ln1744">    obatom-&gt;SetId(id);</a>
<a name="ln1745">    _atomIds[id] = obatom;</a>
<a name="ln1746"> </a>
<a name="ln1747">#define OBAtomIncrement 100</a>
<a name="ln1748"> </a>
<a name="ln1749">    if (_natoms+1 &gt;= _vatom.size())</a>
<a name="ln1750">      {</a>
<a name="ln1751">        _vatom.resize(_natoms+OBAtomIncrement);</a>
<a name="ln1752">        vector&lt;OBAtom*&gt;::iterator j;</a>
<a name="ln1753">        for (j = _vatom.begin(),j+=(_natoms+1);j != _vatom.end();++j)</a>
<a name="ln1754">          *j = nullptr;</a>
<a name="ln1755">      }</a>
<a name="ln1756">#undef OBAtomIncrement</a>
<a name="ln1757"> </a>
<a name="ln1758">    _vatom[_natoms] = (OBAtom*)obatom;</a>
<a name="ln1759">    _natoms++;</a>
<a name="ln1760"> </a>
<a name="ln1761">    if (HasData(OBGenericDataType::VirtualBondData))</a>
<a name="ln1762">      {</a>
<a name="ln1763">        /*add bonds that have been queued*/</a>
<a name="ln1764">        OBVirtualBond *vb;</a>
<a name="ln1765">        vector&lt;OBGenericData*&gt; verase;</a>
<a name="ln1766">        vector&lt;OBGenericData*&gt;::iterator i;</a>
<a name="ln1767">        for (i = BeginData();i != EndData();++i)</a>
<a name="ln1768">          if ((*i)-&gt;GetDataType() == OBGenericDataType::VirtualBondData)</a>
<a name="ln1769">            {</a>
<a name="ln1770">              vb = (OBVirtualBond*)*i;</a>
<a name="ln1771">              if (vb-&gt;GetBgn() &gt; _natoms || vb-&gt;GetEnd() &gt; _natoms)</a>
<a name="ln1772">                continue;</a>
<a name="ln1773">              if (obatom-&gt;GetIdx() == static_cast&lt;unsigned int&gt;(vb-&gt;GetBgn())</a>
<a name="ln1774">                  || obatom-&gt;GetIdx() == static_cast&lt;unsigned int&gt;(vb-&gt;GetEnd()))</a>
<a name="ln1775">                {</a>
<a name="ln1776">                  AddBond(vb-&gt;GetBgn(),vb-&gt;GetEnd(),vb-&gt;GetOrder());</a>
<a name="ln1777">                  verase.push_back(*i);</a>
<a name="ln1778">                }</a>
<a name="ln1779">            }</a>
<a name="ln1780"> </a>
<a name="ln1781">        if (!verase.empty())</a>
<a name="ln1782">          DeleteData(verase);</a>
<a name="ln1783">      }</a>
<a name="ln1784"> </a>
<a name="ln1785">    //    EndModify();</a>
<a name="ln1786"> </a>
<a name="ln1787">    return(true);</a>
<a name="ln1788">  }</a>
<a name="ln1789"> </a>
<a name="ln1790">  bool OBMol::InsertAtom(OBAtom &amp;atom)</a>
<a name="ln1791">  {</a>
<a name="ln1792">    BeginModify();</a>
<a name="ln1793">    AddAtom(atom);</a>
<a name="ln1794">    EndModify();</a>
<a name="ln1795"> </a>
<a name="ln1796">    return(true);</a>
<a name="ln1797">  }</a>
<a name="ln1798"> </a>
<a name="ln1799">  bool OBMol::AddResidue(OBResidue &amp;residue)</a>
<a name="ln1800">  {</a>
<a name="ln1801">    BeginModify();</a>
<a name="ln1802"> </a>
<a name="ln1803">    OBResidue *obresidue = new OBResidue;</a>
<a name="ln1804">    *obresidue = residue;</a>
<a name="ln1805"> </a>
<a name="ln1806">    obresidue-&gt;SetIdx(_residue.size());</a>
<a name="ln1807"> </a>
<a name="ln1808">    _residue.push_back(obresidue);</a>
<a name="ln1809"> </a>
<a name="ln1810">    EndModify();</a>
<a name="ln1811"> </a>
<a name="ln1812">    return(true);</a>
<a name="ln1813">  }</a>
<a name="ln1814"> </a>
<a name="ln1815">  bool OBMol::StripSalts(unsigned int threshold)</a>
<a name="ln1816">  {</a>
<a name="ln1817">    vector&lt;vector&lt;int&gt; &gt; cfl;</a>
<a name="ln1818">    vector&lt;vector&lt;int&gt; &gt;::iterator i,max;</a>
<a name="ln1819"> </a>
<a name="ln1820">    ContigFragList(cfl);</a>
<a name="ln1821">    if (cfl.empty() || cfl.size() == 1)</a>
<a name="ln1822">      {</a>
<a name="ln1823">        return(false);</a>
<a name="ln1824">      }</a>
<a name="ln1825"> </a>
<a name="ln1826"> </a>
<a name="ln1827">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::StripSalts&quot;, obAuditMsg);</a>
<a name="ln1828"> </a>
<a name="ln1829">    max = cfl.begin();</a>
<a name="ln1830">    for (i = cfl.begin();i != cfl.end();++i)</a>
<a name="ln1831">      {</a>
<a name="ln1832">        if ((*max).size() &lt; (*i).size())</a>
<a name="ln1833">          max = i;</a>
<a name="ln1834">      }</a>
<a name="ln1835"> </a>
<a name="ln1836">    vector&lt;int&gt;::iterator j;</a>
<a name="ln1837">    vector&lt;OBAtom*&gt; delatoms;</a>
<a name="ln1838">    set&lt;int&gt; atomIndices;</a>
<a name="ln1839">    for (i = cfl.begin(); i != cfl.end(); ++i)</a>
<a name="ln1840">      {</a>
<a name="ln1841">        if (i-&gt;size() &lt; threshold || (threshold == 0 &amp;&amp; i != max))</a>
<a name="ln1842">          {</a>
<a name="ln1843">            for (j = (*i).begin(); j != (*i).end(); ++j)</a>
<a name="ln1844">              {</a>
<a name="ln1845">                if (atomIndices.find( *j ) == atomIndices.end())</a>
<a name="ln1846">                  {</a>
<a name="ln1847">                    delatoms.push_back(GetAtom(*j));</a>
<a name="ln1848">                    atomIndices.insert(*j);</a>
<a name="ln1849">                  }</a>
<a name="ln1850">              }</a>
<a name="ln1851">          }</a>
<a name="ln1852">      }</a>
<a name="ln1853"> </a>
<a name="ln1854">    if (!delatoms.empty())</a>
<a name="ln1855">      {</a>
<a name="ln1856">        //      int tmpflags = _flags &amp; (~(OB_SSSR_MOL));</a>
<a name="ln1857">        BeginModify();</a>
<a name="ln1858">        vector&lt;OBAtom*&gt;::iterator k;</a>
<a name="ln1859">        for (k = delatoms.begin(); k != delatoms.end(); ++k)</a>
<a name="ln1860">          DeleteAtom((OBAtom*)*k);</a>
<a name="ln1861">        EndModify();</a>
<a name="ln1862">        //      _flags = tmpflags;  // Gave crash when SmartsPattern::Match()</a>
<a name="ln1863">        // was called susequently</a>
<a name="ln1864">        // Hans De Winter; 03-nov-2010</a>
<a name="ln1865">      }</a>
<a name="ln1866"> </a>
<a name="ln1867">    return (true);</a>
<a name="ln1868">  }</a>
<a name="ln1869"> </a>
<a name="ln1870">  // Convenience function used by the DeleteHydrogens methods</a>
<a name="ln1871">  static bool IsSuppressibleHydrogen(OBAtom *atom)</a>
<a name="ln1872">  {</a>
<a name="ln1873">    if (atom-&gt;GetIsotope() == 0 &amp;&amp; atom-&gt;GetHvyDegree() == 1 &amp;&amp; atom-&gt;GetFormalCharge() == 0</a>
<a name="ln1874">        &amp;&amp; !atom-&gt;GetData(&quot;Atom Class&quot;))</a>
<a name="ln1875">      return true;</a>
<a name="ln1876">    else</a>
<a name="ln1877">      return false;</a>
<a name="ln1878">  }</a>
<a name="ln1879"> </a>
<a name="ln1880">  bool OBMol::DeletePolarHydrogens()</a>
<a name="ln1881">  {</a>
<a name="ln1882">    OBAtom *atom;</a>
<a name="ln1883">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1884">    vector&lt;OBAtom*&gt; delatoms;</a>
<a name="ln1885"> </a>
<a name="ln1886">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1887">                          &quot;Ran OpenBabel::DeleteHydrogens -- polar&quot;,</a>
<a name="ln1888">                          obAuditMsg);</a>
<a name="ln1889"> </a>
<a name="ln1890">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln1891">      if (atom-&gt;IsPolarHydrogen() &amp;&amp; IsSuppressibleHydrogen(atom))</a>
<a name="ln1892">        delatoms.push_back(atom);</a>
<a name="ln1893"> </a>
<a name="ln1894">    if (delatoms.empty())</a>
<a name="ln1895">      return(true);</a>
<a name="ln1896"> </a>
<a name="ln1897">    IncrementMod();</a>
<a name="ln1898"> </a>
<a name="ln1899">    for (i = delatoms.begin();i != delatoms.end();++i)</a>
<a name="ln1900">      DeleteAtom((OBAtom *)*i);</a>
<a name="ln1901"> </a>
<a name="ln1902">    DecrementMod();</a>
<a name="ln1903"> </a>
<a name="ln1904">    SetSSSRPerceived(false);</a>
<a name="ln1905">    SetLSSRPerceived(false);</a>
<a name="ln1906">    return(true);</a>
<a name="ln1907">  }</a>
<a name="ln1908"> </a>
<a name="ln1909"> </a>
<a name="ln1910">  bool OBMol::DeleteNonPolarHydrogens()</a>
<a name="ln1911">  {</a>
<a name="ln1912">    OBAtom *atom;</a>
<a name="ln1913">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1914">    vector&lt;OBAtom*&gt; delatoms;</a>
<a name="ln1915"> </a>
<a name="ln1916">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1917">                          &quot;Ran OpenBabel::DeleteHydrogens -- nonpolar&quot;,</a>
<a name="ln1918">                          obAuditMsg);</a>
<a name="ln1919"> </a>
<a name="ln1920"> </a>
<a name="ln1921">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln1922">      if (atom-&gt;IsNonPolarHydrogen() &amp;&amp; IsSuppressibleHydrogen(atom))</a>
<a name="ln1923">        delatoms.push_back(atom);</a>
<a name="ln1924"> </a>
<a name="ln1925">    if (delatoms.empty())</a>
<a name="ln1926">      return(true);</a>
<a name="ln1927"> </a>
<a name="ln1928">    /*</a>
<a name="ln1929">      int idx1,idx2;</a>
<a name="ln1930">      vector&lt;double*&gt;::iterator j;</a>
<a name="ln1931">      for (idx1=0,idx2=0,atom = BeginAtom(i);atom;atom = NextAtom(i),++idx1)</a>
<a name="ln1932">      if (atom-&gt;GetAtomicNum() != OBElements::Hydrogen)</a>
<a name="ln1933">      {</a>
<a name="ln1934">      for (j = _vconf.begin();j != _vconf.end();++j)</a>
<a name="ln1935">      memcpy((char*)&amp;((*j)[idx2*3]),(char*)&amp;((*j)[idx1*3]),sizeof(double)*3);</a>
<a name="ln1936">      idx2++;</a>
<a name="ln1937">      }</a>
<a name="ln1938">    */</a>
<a name="ln1939"> </a>
<a name="ln1940">    IncrementMod();</a>
<a name="ln1941"> </a>
<a name="ln1942">    for (i = delatoms.begin();i != delatoms.end();++i)</a>
<a name="ln1943">      DeleteAtom((OBAtom *)*i);</a>
<a name="ln1944"> </a>
<a name="ln1945">    DecrementMod();</a>
<a name="ln1946"> </a>
<a name="ln1947">    SetSSSRPerceived(false);</a>
<a name="ln1948">    SetLSSRPerceived(false);</a>
<a name="ln1949">    return(true);</a>
<a name="ln1950">  }</a>
<a name="ln1951"> </a>
<a name="ln1952">  bool OBMol::DeleteHydrogens()</a>
<a name="ln1953">  {</a>
<a name="ln1954">    OBAtom *atom;//,*nbr;</a>
<a name="ln1955">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln1956">    vector&lt;OBAtom*&gt; delatoms,va;</a>
<a name="ln1957"> </a>
<a name="ln1958">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1959">                          &quot;Ran OpenBabel::DeleteHydrogens&quot;, obAuditMsg);</a>
<a name="ln1960"> </a>
<a name="ln1961">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln1962">      if (atom-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; IsSuppressibleHydrogen(atom))</a>
<a name="ln1963">        delatoms.push_back(atom);</a>
<a name="ln1964"> </a>
<a name="ln1965">    SetHydrogensAdded(false);</a>
<a name="ln1966"> </a>
<a name="ln1967">    if (delatoms.empty())</a>
<a name="ln1968">      return(true);</a>
<a name="ln1969"> </a>
<a name="ln1970">    /* decide whether these flags need to be reset</a>
<a name="ln1971">       _flags &amp;= (~(OB_ATOMTYPES_MOL));</a>
<a name="ln1972">       _flags &amp;= (~(OB_HYBRID_MOL));</a>
<a name="ln1973">       _flags &amp;= (~(OB_PCHARGE_MOL));</a>
<a name="ln1974">       _flags &amp;= (~(OB_IMPVAL_MOL));</a>
<a name="ln1975">    */</a>
<a name="ln1976"> </a>
<a name="ln1977">    IncrementMod();</a>
<a name="ln1978"> </a>
<a name="ln1979">    // This is slow -- we need methods to delete a set of atoms</a>
<a name="ln1980">    //  and to delete a set of bonds</a>
<a name="ln1981">    // Calling this sequentially does result in correct behavior</a>
<a name="ln1982">    //  (e.g., fixing PR# 1704551)</a>
<a name="ln1983">    OBBondIterator bi;</a>
<a name="ln1984">    for (i = delatoms.begin(); i != delatoms.end(); ++i) {</a>
<a name="ln1985">      OBAtom* nbr = (*i)-&gt;BeginNbrAtom(bi);</a>
<a name="ln1986">      if (nbr) // defensive</a>
<a name="ln1987">        nbr-&gt;SetImplicitHCount(nbr-&gt;GetImplicitHCount() + 1);</a>
<a name="ln1988">      DeleteAtom((OBAtom *)*i);</a>
<a name="ln1989">    }</a>
<a name="ln1990"> </a>
<a name="ln1991">    DecrementMod();</a>
<a name="ln1992"> </a>
<a name="ln1993">    SetSSSRPerceived(false);</a>
<a name="ln1994">    SetLSSRPerceived(false);</a>
<a name="ln1995">    return(true);</a>
<a name="ln1996">  }</a>
<a name="ln1997"> </a>
<a name="ln1998">  bool OBMol::DeleteHydrogens(OBAtom *atom)</a>
<a name="ln1999">  //deletes all hydrogens attached to the atom passed to the function</a>
<a name="ln2000">  {</a>
<a name="ln2001">    OBAtom *nbr;</a>
<a name="ln2002">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2003">    vector&lt;OBBond*&gt;::iterator k;</a>
<a name="ln2004">    vector&lt;OBAtom*&gt; delatoms;</a>
<a name="ln2005"> </a>
<a name="ln2006">    for (nbr = atom-&gt;BeginNbrAtom(k);nbr;nbr = atom-&gt;NextNbrAtom(k))</a>
<a name="ln2007">      if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; IsSuppressibleHydrogen(atom))</a>
<a name="ln2008">        delatoms.push_back(nbr);</a>
<a name="ln2009"> </a>
<a name="ln2010">    if (delatoms.empty())</a>
<a name="ln2011">      return(true);</a>
<a name="ln2012"> </a>
<a name="ln2013">    IncrementMod();</a>
<a name="ln2014">    for (i = delatoms.begin();i != delatoms.end();++i)</a>
<a name="ln2015">      DeleteHydrogen((OBAtom*)*i);</a>
<a name="ln2016">    DecrementMod();</a>
<a name="ln2017"> </a>
<a name="ln2018">    SetHydrogensAdded(false);</a>
<a name="ln2019">    SetSSSRPerceived(false);</a>
<a name="ln2020">    SetLSSRPerceived(false);</a>
<a name="ln2021">    return(true);</a>
<a name="ln2022">  }</a>
<a name="ln2023"> </a>
<a name="ln2024">  bool OBMol::DeleteHydrogen(OBAtom *atom)</a>
<a name="ln2025">  //deletes the hydrogen atom passed to the function</a>
<a name="ln2026">  {</a>
<a name="ln2027">    if (atom-&gt;GetAtomicNum() != OBElements::Hydrogen)</a>
<a name="ln2028">      return false;</a>
<a name="ln2029"> </a>
<a name="ln2030">    unsigned atomidx = atom-&gt;GetIdx();</a>
<a name="ln2031"> </a>
<a name="ln2032">    //find bonds to delete</a>
<a name="ln2033">    OBAtom *nbr;</a>
<a name="ln2034">    vector&lt;OBBond*&gt; vdb;</a>
<a name="ln2035">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln2036">    for (nbr = atom-&gt;BeginNbrAtom(j);nbr;nbr = atom-&gt;NextNbrAtom(j))</a>
<a name="ln2037">      vdb.push_back(*j);</a>
<a name="ln2038"> </a>
<a name="ln2039">    IncrementMod();</a>
<a name="ln2040">    for (j = vdb.begin();j != vdb.end();++j)</a>
<a name="ln2041">      DeleteBond((OBBond*)*j); //delete bonds</a>
<a name="ln2042">    DecrementMod();</a>
<a name="ln2043"> </a>
<a name="ln2044">    int idx;</a>
<a name="ln2045">    if (atomidx != NumAtoms())</a>
<a name="ln2046">      {</a>
<a name="ln2047">        idx = atom-&gt;GetCoordinateIdx();</a>
<a name="ln2048">        int size = NumAtoms()-atom-&gt;GetIdx();</a>
<a name="ln2049">        vector&lt;double*&gt;::iterator k;</a>
<a name="ln2050">        for (k = _vconf.begin();k != _vconf.end();++k)</a>
<a name="ln2051">          memmove((char*)&amp;(*k)[idx],(char*)&amp;(*k)[idx+3],sizeof(double)*3*size);</a>
<a name="ln2052"> </a>
<a name="ln2053">      }</a>
<a name="ln2054"> </a>
<a name="ln2055">    // Deleting hydrogens does not invalidate the stereo objects</a>
<a name="ln2056">    // - however, any explicit refs to the hydrogen atom must be</a>
<a name="ln2057">    //   converted to implicit refs</a>
<a name="ln2058">    OBStereo::Ref id = atom-&gt;GetId();</a>
<a name="ln2059">    StereoRefToImplicit(*this, id);</a>
<a name="ln2060"> </a>
<a name="ln2061">    _atomIds[id] = nullptr;</a>
<a name="ln2062">    _vatom.erase(_vatom.begin()+(atomidx-1));</a>
<a name="ln2063">    _natoms--;</a>
<a name="ln2064"> </a>
<a name="ln2065">    //reset all the indices to the atoms</a>
<a name="ln2066">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2067">    OBAtom *atomi;</a>
<a name="ln2068">    for (idx=1,atomi = BeginAtom(i);atomi;atomi = NextAtom(i),++idx)</a>
<a name="ln2069">      atomi-&gt;SetIdx(idx);</a>
<a name="ln2070"> </a>
<a name="ln2071">    SetHydrogensAdded(false);</a>
<a name="ln2072"> </a>
<a name="ln2073">    DestroyAtom(atom);</a>
<a name="ln2074"> </a>
<a name="ln2075">    SetSSSRPerceived(false);</a>
<a name="ln2076">    SetLSSRPerceived(false);</a>
<a name="ln2077">    return(true);</a>
<a name="ln2078">  }</a>
<a name="ln2079"> </a>
<a name="ln2080">  /*</a>
<a name="ln2081">  this has become a wrapper for backward compatibility</a>
<a name="ln2082">  */</a>
<a name="ln2083">  bool OBMol::AddHydrogens(bool polaronly, bool correctForPH, double pH)</a>
<a name="ln2084">  {</a>
<a name="ln2085">    return(AddNewHydrogens(polaronly ? PolarHydrogen : AllHydrogen, correctForPH, pH));</a>
<a name="ln2086">  }</a>
<a name="ln2087"> </a>
<a name="ln2088">  static bool AtomIsNSOP(OBAtom *atom)</a>
<a name="ln2089">  {</a>
<a name="ln2090">    switch (atom-&gt;GetAtomicNum()) {</a>
<a name="ln2091">    case OBElements::Nitrogen:</a>
<a name="ln2092">    case OBElements::Sulfur:</a>
<a name="ln2093">    case OBElements::Oxygen:</a>
<a name="ln2094">    case OBElements::Phosphorus:</a>
<a name="ln2095">      return true;</a>
<a name="ln2096">    default:</a>
<a name="ln2097">      return false;</a>
<a name="ln2098">    }</a>
<a name="ln2099">  }</a>
<a name="ln2100"> </a>
<a name="ln2101">  //! \return a &quot;corrected&quot; bonding radius based on the hybridization.</a>
<a name="ln2102">  //! Scales the covalent radius by 0.95 for sp2 and 0.90 for sp hybrids</a>
<a name="ln2103">  static double CorrectedBondRad(unsigned int elem, unsigned int hyb)</a>
<a name="ln2104">  {</a>
<a name="ln2105">    double rad = OBElements::GetCovalentRad(elem);</a>
<a name="ln2106">    switch (hyb) {</a>
<a name="ln2107">    case 2:</a>
<a name="ln2108">      return rad * 0.95;</a>
<a name="ln2109">    case 1:</a>
<a name="ln2110">      return rad * 0.90;</a>
<a name="ln2111">    default:</a>
<a name="ln2112">      return rad;</a>
<a name="ln2113">    }</a>
<a name="ln2114">  }</a>
<a name="ln2115"> </a>
<a name="ln2116">  bool OBMol::AddNewHydrogens(HydrogenType whichHydrogen, bool correctForPH, double pH)</a>
<a name="ln2117">  {</a>
<a name="ln2118">    if (!IsCorrectedForPH() &amp;&amp; correctForPH)</a>
<a name="ln2119">      CorrectForPH(pH);</a>
<a name="ln2120"> </a>
<a name="ln2121">    if (HasHydrogensAdded())</a>
<a name="ln2122">      return(true);</a>
<a name="ln2123"> </a>
<a name="ln2124">    bool hasChiralityPerceived = this-&gt;HasChiralityPerceived(); // remember</a>
<a name="ln2125"> </a>
<a name="ln2126">    /*</a>
<a name="ln2127">    //</a>
<a name="ln2128">    // This was causing bug #1892844 in avogadro. We also want to add hydrogens if the molecule has no bonds.</a>
<a name="ln2129">    //</a>
<a name="ln2130">    if(NumBonds()==0 &amp;&amp; NumAtoms()!=1)</a>
<a name="ln2131">    {</a>
<a name="ln2132">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2133">    &quot;Did not run OpenBabel::AddHydrogens on molecule with no bonds&quot;, obAuditMsg);</a>
<a name="ln2134">    return true;</a>
<a name="ln2135">    }</a>
<a name="ln2136">    */</a>
<a name="ln2137">    if (whichHydrogen == AllHydrogen)</a>
<a name="ln2138">      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2139">                            &quot;Ran OpenBabel::AddHydrogens&quot;, obAuditMsg);</a>
<a name="ln2140">    else if (whichHydrogen == PolarHydrogen)</a>
<a name="ln2141">      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2142">                            &quot;Ran OpenBabel::AddHydrogens -- polar only&quot;, obAuditMsg);</a>
<a name="ln2143">    else</a>
<a name="ln2144">      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2145">                            &quot;Ran OpenBabel::AddHydrogens -- nonpolar only&quot;, obAuditMsg);</a>
<a name="ln2146"> </a>
<a name="ln2147">    // Make sure we have conformers (PR#1665519)</a>
<a name="ln2148">    if (!_vconf.empty() &amp;&amp; !Empty()) {</a>
<a name="ln2149">      OBAtom *atom;</a>
<a name="ln2150">      vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2151">      for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2152">        {</a>
<a name="ln2153">          atom-&gt;SetVector();</a>
<a name="ln2154">        }</a>
<a name="ln2155">    }</a>
<a name="ln2156"> </a>
<a name="ln2157">    SetHydrogensAdded(); // This must come after EndModify() as EndModify() wipes the flags</a>
<a name="ln2158">    // If chirality was already perceived, remember this (to avoid wiping information</a>
<a name="ln2159">    if (hasChiralityPerceived)</a>
<a name="ln2160">      this-&gt;SetChiralityPerceived();</a>
<a name="ln2161"> </a>
<a name="ln2162">    //count up number of hydrogens to add</a>
<a name="ln2163">    OBAtom *atom,*h;</a>
<a name="ln2164">    int hcount,count=0;</a>
<a name="ln2165">    vector&lt;pair&lt;OBAtom*,int&gt; &gt; vhadd;</a>
<a name="ln2166">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2167">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2168">      {</a>
<a name="ln2169">        if (whichHydrogen == PolarHydrogen &amp;&amp; !AtomIsNSOP(atom))</a>
<a name="ln2170">          continue;</a>
<a name="ln2171">        if (whichHydrogen == NonPolarHydrogen &amp;&amp; AtomIsNSOP(atom))</a>
<a name="ln2172">          continue;</a>
<a name="ln2173"> </a>
<a name="ln2174">        hcount = atom-&gt;GetImplicitHCount();</a>
<a name="ln2175">        atom-&gt;SetImplicitHCount(0);</a>
<a name="ln2176"> </a>
<a name="ln2177">        if (hcount)</a>
<a name="ln2178">          {</a>
<a name="ln2179">            vhadd.push_back(pair&lt;OBAtom*,int&gt;(atom,hcount));</a>
<a name="ln2180">            count += hcount;</a>
<a name="ln2181">          }</a>
<a name="ln2182">      }</a>
<a name="ln2183"> </a>
<a name="ln2184">    if (count == 0) {</a>
<a name="ln2185">      // Make sure to clear SSSR and aromatic flags we may have tripped above</a>
<a name="ln2186">      _flags &amp;= (~(OB_SSSR_MOL|OB_AROMATIC_MOL));</a>
<a name="ln2187">      return(true);</a>
<a name="ln2188">    }</a>
<a name="ln2189">    bool hasCoords = HasNonZeroCoords();</a>
<a name="ln2190"> </a>
<a name="ln2191">    //realloc memory in coordinate arrays for new hydrogens</a>
<a name="ln2192">    double *tmpf;</a>
<a name="ln2193">    vector&lt;double*&gt;::iterator j;</a>
<a name="ln2194">    for (j = _vconf.begin();j != _vconf.end();++j)</a>
<a name="ln2195">      {</a>
<a name="ln2196">        tmpf = new double [(NumAtoms()+count)*3];</a>
<a name="ln2197">        memset(tmpf,'\0',sizeof(double)*(NumAtoms()+count)*3);</a>
<a name="ln2198">        if (hasCoords)</a>
<a name="ln2199">          memcpy(tmpf,(*j),sizeof(double)*NumAtoms()*3);</a>
<a name="ln2200">        delete []*j;</a>
<a name="ln2201">        *j = tmpf;</a>
<a name="ln2202">      }</a>
<a name="ln2203"> </a>
<a name="ln2204">    IncrementMod();</a>
<a name="ln2205"> </a>
<a name="ln2206">    int m,n;</a>
<a name="ln2207">    vector3 v;</a>
<a name="ln2208">    vector&lt;pair&lt;OBAtom*,int&gt; &gt;::iterator k;</a>
<a name="ln2209">    double hbrad = CorrectedBondRad(1, 0);</a>
<a name="ln2210"> </a>
<a name="ln2211">    for (k = vhadd.begin();k != vhadd.end();++k)</a>
<a name="ln2212">      {</a>
<a name="ln2213">        atom = k-&gt;first;</a>
<a name="ln2214">        double bondlen = hbrad + CorrectedBondRad(atom-&gt;GetAtomicNum(), atom-&gt;GetHyb());</a>
<a name="ln2215">        for (m = 0;m &lt; k-&gt;second;++m)</a>
<a name="ln2216">          {</a>
<a name="ln2217">            int badh = 0;</a>
<a name="ln2218">            for (n = 0;n &lt; NumConformers();++n)</a>
<a name="ln2219">              {</a>
<a name="ln2220">                SetConformer(n);</a>
<a name="ln2221">                if (hasCoords)</a>
<a name="ln2222">                  {</a>
<a name="ln2223">                    // Ensure that add hydrogens only returns finite coords</a>
<a name="ln2224">                    //atom-&gt;GetNewBondVector(v,bondlen);</a>
<a name="ln2225">                    v = OBBuilder::GetNewBondVector(atom,bondlen);</a>
<a name="ln2226">                    if (isfinite(v.x()) || isfinite(v.y()) || isfinite(v.z())) {</a>
<a name="ln2227">                      _c[(NumAtoms())*3]   = v.x();</a>
<a name="ln2228">                      _c[(NumAtoms())*3+1] = v.y();</a>
<a name="ln2229">                      _c[(NumAtoms())*3+2] = v.z();</a>
<a name="ln2230">                    }</a>
<a name="ln2231">                    else {</a>
<a name="ln2232">                      _c[(NumAtoms())*3]   = 0.0;</a>
<a name="ln2233">                      _c[(NumAtoms())*3+1] = 0.0;</a>
<a name="ln2234">                      _c[(NumAtoms())*3+2] = 0.0;</a>
<a name="ln2235">                      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2236">                                            &quot;Ran OpenBabel::AddHydrogens -- no reasonable bond geometry for desired hydrogen.&quot;,</a>
<a name="ln2237">                                            obAuditMsg);</a>
<a name="ln2238">                      badh++;</a>
<a name="ln2239">                    }</a>
<a name="ln2240">                  }</a>
<a name="ln2241">                else</a>
<a name="ln2242">                  memset((char*)&amp;_c[NumAtoms()*3],'\0',sizeof(double)*3);</a>
<a name="ln2243">              }</a>
<a name="ln2244">            if(badh == 0 || badh &lt; NumConformers())</a>
<a name="ln2245">              {</a>
<a name="ln2246">                // Add the new H atom to the appropriate residue list</a>
<a name="ln2247">                //but avoid doing perception by checking for existence of residue</a>
<a name="ln2248">                //just in case perception is trigger, make sure GetResidue is called</a>
<a name="ln2249">                //before adding the hydrogen to the molecule</a>
<a name="ln2250">                OBResidue *res = atom-&gt;HasResidue() ? atom-&gt;GetResidue() : nullptr;</a>
<a name="ln2251">                h = NewAtom();</a>
<a name="ln2252">                h-&gt;SetType(&quot;H&quot;);</a>
<a name="ln2253">                h-&gt;SetAtomicNum(1);</a>
<a name="ln2254">                string aname = &quot;H&quot;;</a>
<a name="ln2255"> </a>
<a name="ln2256">                if(res)</a>
<a name="ln2257">                {</a>
<a name="ln2258">                  res-&gt;AddAtom(h);</a>
<a name="ln2259">                  res-&gt;SetAtomID(h,aname);</a>
<a name="ln2260"> </a>
<a name="ln2261">                  //hydrogen should inherit hetatm status of heteroatom (default is false)</a>
<a name="ln2262">                  if(res-&gt;IsHetAtom(atom))</a>
<a name="ln2263">                  {</a>
<a name="ln2264">                      res-&gt;SetHetAtom(h, true);</a>
<a name="ln2265">                  }</a>
<a name="ln2266">                }</a>
<a name="ln2267"> </a>
<a name="ln2268">                int bondFlags = 0;</a>
<a name="ln2269">                AddBond(atom-&gt;GetIdx(),h-&gt;GetIdx(),1, bondFlags);</a>
<a name="ln2270">                h-&gt;SetCoordPtr(&amp;_c);</a>
<a name="ln2271">                OpenBabel::ImplicitRefToStereo(*this, atom-&gt;GetId(), h-&gt;GetId());</a>
<a name="ln2272">              }</a>
<a name="ln2273">          }</a>
<a name="ln2274">      }</a>
<a name="ln2275"> </a>
<a name="ln2276">    DecrementMod();</a>
<a name="ln2277"> </a>
<a name="ln2278">    //reset atom type and partial charge flags</a>
<a name="ln2279">    _flags &amp;= (~(OB_PCHARGE_MOL|OB_ATOMTYPES_MOL|OB_SSSR_MOL|OB_AROMATIC_MOL|OB_HYBRID_MOL));</a>
<a name="ln2280"> </a>
<a name="ln2281">    return(true);</a>
<a name="ln2282">  }</a>
<a name="ln2283"> </a>
<a name="ln2284">  bool OBMol::AddPolarHydrogens()</a>
<a name="ln2285">  {</a>
<a name="ln2286">    return(AddNewHydrogens(PolarHydrogen));</a>
<a name="ln2287">  }</a>
<a name="ln2288"> </a>
<a name="ln2289">  bool OBMol::AddNonPolarHydrogens()</a>
<a name="ln2290">  {</a>
<a name="ln2291">    return(AddNewHydrogens(NonPolarHydrogen));</a>
<a name="ln2292">  }</a>
<a name="ln2293"> </a>
<a name="ln2294">  bool OBMol::AddHydrogens(OBAtom *atom)</a>
<a name="ln2295">  {</a>
<a name="ln2296">    int hcount = atom-&gt;GetImplicitHCount();</a>
<a name="ln2297">    if (hcount == 0)</a>
<a name="ln2298">      return true;</a>
<a name="ln2299"> </a>
<a name="ln2300">    atom-&gt;SetImplicitHCount(0);</a>
<a name="ln2301"> </a>
<a name="ln2302">    vector&lt;pair&lt;OBAtom*, int&gt; &gt; vhadd;</a>
<a name="ln2303">    vhadd.push_back(pair&lt;OBAtom*,int&gt;(atom, hcount));</a>
<a name="ln2304"> </a>
<a name="ln2305">    //realloc memory in coordinate arrays for new hydroges</a>
<a name="ln2306">    double *tmpf;</a>
<a name="ln2307">    vector&lt;double*&gt;::iterator j;</a>
<a name="ln2308">    for (j = _vconf.begin();j != _vconf.end();++j)</a>
<a name="ln2309">      {</a>
<a name="ln2310">        tmpf = new double [(NumAtoms()+hcount)*3+10];</a>
<a name="ln2311">        memcpy(tmpf,(*j),sizeof(double)*NumAtoms()*3);</a>
<a name="ln2312">        delete []*j;</a>
<a name="ln2313">        *j = tmpf;</a>
<a name="ln2314">      }</a>
<a name="ln2315"> </a>
<a name="ln2316">    IncrementMod();</a>
<a name="ln2317"> </a>
<a name="ln2318">    int m,n;</a>
<a name="ln2319">    vector3 v;</a>
<a name="ln2320">    vector&lt;pair&lt;OBAtom*,int&gt; &gt;::iterator k;</a>
<a name="ln2321">    double hbrad = CorrectedBondRad(1,0);</a>
<a name="ln2322"> </a>
<a name="ln2323">    OBAtom *h;</a>
<a name="ln2324">    for (k = vhadd.begin();k != vhadd.end();++k)</a>
<a name="ln2325">      {</a>
<a name="ln2326">        atom = k-&gt;first;</a>
<a name="ln2327">        double bondlen = hbrad + CorrectedBondRad(atom-&gt;GetAtomicNum(),atom-&gt;GetHyb());</a>
<a name="ln2328">        for (m = 0;m &lt; k-&gt;second;++m)</a>
<a name="ln2329">          {</a>
<a name="ln2330">            for (n = 0;n &lt; NumConformers();++n)</a>
<a name="ln2331">              {</a>
<a name="ln2332">                SetConformer(n);</a>
<a name="ln2333">                //atom-&gt;GetNewBondVector(v,bondlen);</a>
<a name="ln2334">                v = OBBuilder::GetNewBondVector(atom,bondlen);</a>
<a name="ln2335">                _c[(NumAtoms())*3]   = v.x();</a>
<a name="ln2336">                _c[(NumAtoms())*3+1] = v.y();</a>
<a name="ln2337">                _c[(NumAtoms())*3+2] = v.z();</a>
<a name="ln2338">              }</a>
<a name="ln2339">            h = NewAtom();</a>
<a name="ln2340">            h-&gt;SetType(&quot;H&quot;);</a>
<a name="ln2341">            h-&gt;SetAtomicNum(1);</a>
<a name="ln2342"> </a>
<a name="ln2343">            int bondFlags = 0;</a>
<a name="ln2344">            AddBond(atom-&gt;GetIdx(),h-&gt;GetIdx(),1, bondFlags);</a>
<a name="ln2345">            h-&gt;SetCoordPtr(&amp;_c);</a>
<a name="ln2346">            OpenBabel::ImplicitRefToStereo(*this, atom-&gt;GetId(), h-&gt;GetId());</a>
<a name="ln2347">          }</a>
<a name="ln2348">      }</a>
<a name="ln2349"> </a>
<a name="ln2350">    DecrementMod();</a>
<a name="ln2351">    SetConformer(0);</a>
<a name="ln2352"> </a>
<a name="ln2353">    //reset atom type and partial charge flags</a>
<a name="ln2354">    //_flags &amp;= (~(OB_PCHARGE_MOL|OB_ATOMTYPES_MOL));</a>
<a name="ln2355"> </a>
<a name="ln2356">    return(true);</a>
<a name="ln2357">  }</a>
<a name="ln2358"> </a>
<a name="ln2359">  bool OBMol::CorrectForPH(double pH)</a>
<a name="ln2360">  {</a>
<a name="ln2361">    if (IsCorrectedForPH())</a>
<a name="ln2362">      return(true);</a>
<a name="ln2363">    phmodel.CorrectForPH(*this, pH);</a>
<a name="ln2364"> </a>
<a name="ln2365">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2366">                          &quot;Ran OpenBabel::CorrectForPH&quot;, obAuditMsg);</a>
<a name="ln2367"> </a>
<a name="ln2368">    return(true);</a>
<a name="ln2369">  }</a>
<a name="ln2370"> </a>
<a name="ln2371">  //! \brief set spin multiplicity for H-deficient atoms</a>
<a name="ln2372">  /**</a>
<a name="ln2373">     If NoImplicitH is true then the molecule has no implicit hydrogens. Individual atoms</a>
<a name="ln2374">     on which ForceNoH() has been called also have no implicit hydrogens.</a>
<a name="ln2375">     If NoImplicitH is false (the default), then if there are any explicit hydrogens</a>
<a name="ln2376">     on an atom then they constitute all the hydrogen on that atom. However, a hydrogen</a>
<a name="ln2377">     atom with its _isotope!=0 is not considered explicit hydrogen for this purpose.</a>
<a name="ln2378">     In addition, an atom which has had ForceImplH()called for it is never considered</a>
<a name="ln2379">     hydrogen deficient, e.g. unbracketed atoms in SMILES.</a>
<a name="ln2380">     Any discrepancy with the expected atom valency is interpreted as the atom being a</a>
<a name="ln2381">     radical of some sort and iits _spinMultiplicity is set to 2 when it is one hydrogen short</a>
<a name="ln2382">     and 3 when it is two hydrogens short and similarly for greater hydrogen deficiency.</a>
<a name="ln2383"> </a>
<a name="ln2384">     So SMILES C[CH] is interpreted as methyl carbene, CC[H][H] as ethane, and CC[2H] as CH3CH2D.</a>
<a name="ln2385">  **/</a>
<a name="ln2386"> </a>
<a name="ln2387"> </a>
<a name="ln2388"> </a>
<a name="ln2389">  bool OBMol::AssignSpinMultiplicity(bool NoImplicitH)</a>
<a name="ln2390">  {</a>
<a name="ln2391">    // TODO: The following functions simply returns true, as it has been made</a>
<a name="ln2392">    // redundant by changes to the handling of implicit hydrogens, and spin.</a>
<a name="ln2393">    // This needs to be sorted out properly at some point.</a>
<a name="ln2394">    return true;</a>
<a name="ln2395">  }</a>
<a name="ln2396"> </a>
<a name="ln2397">  // Used by DeleteAtom below. Code based on StereoRefToImplicit</a>
<a name="ln2398">  static void DeleteStereoOnAtom(OBMol&amp; mol, OBStereo::Ref atomId)</a>
<a name="ln2399">  {</a>
<a name="ln2400">    std::vector&lt;OBGenericData*&gt; vdata = mol.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln2401">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data) {</a>
<a name="ln2402">      OBStereo::Type datatype = ((OBStereoBase*)*data)-&gt;GetType();</a>
<a name="ln2403"> </a>
<a name="ln2404">      if (datatype != OBStereo::CisTrans &amp;&amp; datatype != OBStereo::Tetrahedral) {</a>
<a name="ln2405">        obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2406">            &quot;This function should be updated to handle additional stereo types.\nSome stereochemistry objects may contain explicit refs to hydrogens which have been removed.&quot;, obWarning);</a>
<a name="ln2407">        continue;</a>
<a name="ln2408">      }</a>
<a name="ln2409"> </a>
<a name="ln2410">      if (datatype == OBStereo::CisTrans) {</a>
<a name="ln2411">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln2412">        OBCisTransStereo::Config ct_cfg = ct-&gt;GetConfig();</a>
<a name="ln2413">        if (ct_cfg.begin == atomId || ct_cfg.end == atomId ||</a>
<a name="ln2414">            std::find(ct_cfg.refs.begin(), ct_cfg.refs.end(), atomId) != ct_cfg.refs.end())</a>
<a name="ln2415">          mol.DeleteData(ct);</a>
<a name="ln2416">      }</a>
<a name="ln2417">      else if (datatype == OBStereo::Tetrahedral) {</a>
<a name="ln2418">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln2419">        OBTetrahedralStereo::Config ts_cfg = ts-&gt;GetConfig();</a>
<a name="ln2420">        if (ts_cfg.from == atomId ||</a>
<a name="ln2421">            std::find(ts_cfg.refs.begin(), ts_cfg.refs.end(), atomId) != ts_cfg.refs.end())</a>
<a name="ln2422">          mol.DeleteData(ts);</a>
<a name="ln2423">      }</a>
<a name="ln2424">    }</a>
<a name="ln2425">  }</a>
<a name="ln2426"> </a>
<a name="ln2427">  bool OBMol::DeleteAtom(OBAtom *atom, bool destroyAtom)</a>
<a name="ln2428">  {</a>
<a name="ln2429">    if (atom-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln2430">      return(DeleteHydrogen(atom));</a>
<a name="ln2431"> </a>
<a name="ln2432">    BeginModify();</a>
<a name="ln2433">    //don't need to do anything with coordinates b/c</a>
<a name="ln2434">    //BeginModify() blows away coordinates</a>
<a name="ln2435"> </a>
<a name="ln2436">    //find bonds to delete</a>
<a name="ln2437">    OBAtom *nbr;</a>
<a name="ln2438">    vector&lt;OBBond*&gt; vdb;</a>
<a name="ln2439">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln2440">    for (nbr = atom-&gt;BeginNbrAtom(j);nbr;nbr = atom-&gt;NextNbrAtom(j))</a>
<a name="ln2441">      vdb.push_back(*j);</a>
<a name="ln2442"> </a>
<a name="ln2443">    for (j = vdb.begin();j != vdb.end();++j)</a>
<a name="ln2444">      DeleteBond((OBBond *)*j); //delete bonds</a>
<a name="ln2445"> </a>
<a name="ln2446">    _atomIds[atom-&gt;GetId()] = nullptr;</a>
<a name="ln2447">    _vatom.erase(_vatom.begin()+(atom-&gt;GetIdx()-1));</a>
<a name="ln2448">    _natoms--;</a>
<a name="ln2449"> </a>
<a name="ln2450">    //reset all the indices to the atoms</a>
<a name="ln2451">    int idx;</a>
<a name="ln2452">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2453">    OBAtom *atomi;</a>
<a name="ln2454">    for (idx=1,atomi = BeginAtom(i);atomi;atomi = NextAtom(i),++idx)</a>
<a name="ln2455">      atomi-&gt;SetIdx(idx);</a>
<a name="ln2456"> </a>
<a name="ln2457">    EndModify();</a>
<a name="ln2458"> </a>
<a name="ln2459">    // Delete any stereo objects involving this atom</a>
<a name="ln2460">    OBStereo::Ref id = atom-&gt;GetId();</a>
<a name="ln2461">    DeleteStereoOnAtom(*this, id);</a>
<a name="ln2462"> </a>
<a name="ln2463">    if (destroyAtom)</a>
<a name="ln2464">      DestroyAtom(atom);</a>
<a name="ln2465"> </a>
<a name="ln2466">    SetSSSRPerceived(false);</a>
<a name="ln2467">    SetLSSRPerceived(false);</a>
<a name="ln2468">    return(true);</a>
<a name="ln2469">  }</a>
<a name="ln2470"> </a>
<a name="ln2471">  bool OBMol::DeleteResidue(OBResidue *residue, bool destroyResidue)</a>
<a name="ln2472">  {</a>
<a name="ln2473">    unsigned short idx = residue-&gt;GetIdx();</a>
<a name="ln2474">    _residue.erase(_residue.begin() + idx);</a>
<a name="ln2475"> </a>
<a name="ln2476">    for ( unsigned short i = idx ; i &lt; _residue.size() ; i++ )</a>
<a name="ln2477">      _residue[i]-&gt;SetIdx(i);</a>
<a name="ln2478"> </a>
<a name="ln2479">    if (destroyResidue)</a>
<a name="ln2480">      DestroyResidue(residue);</a>
<a name="ln2481"> </a>
<a name="ln2482">    SetSSSRPerceived(false);</a>
<a name="ln2483">    SetLSSRPerceived(false);</a>
<a name="ln2484">    return(true);</a>
<a name="ln2485">  }</a>
<a name="ln2486"> </a>
<a name="ln2487">  bool OBMol::DeleteBond(OBBond *bond, bool destroyBond)</a>
<a name="ln2488">  {</a>
<a name="ln2489">    BeginModify();</a>
<a name="ln2490"> </a>
<a name="ln2491">    (bond-&gt;GetBeginAtom())-&gt;DeleteBond(bond);</a>
<a name="ln2492">    (bond-&gt;GetEndAtom())-&gt;DeleteBond(bond);</a>
<a name="ln2493">    _bondIds[bond-&gt;GetId()] = nullptr;</a>
<a name="ln2494">    _vbond.erase(_vbond.begin() + bond-&gt;GetIdx()); // bond index starts at 0!!!</a>
<a name="ln2495">    _nbonds--;</a>
<a name="ln2496"> </a>
<a name="ln2497">    vector&lt;OBBond*&gt;::iterator i;</a>
<a name="ln2498">    int j;</a>
<a name="ln2499">    OBBond *bondi;</a>
<a name="ln2500">    for (bondi = BeginBond(i),j=0;bondi;bondi = NextBond(i),++j)</a>
<a name="ln2501">      bondi-&gt;SetIdx(j);</a>
<a name="ln2502"> </a>
<a name="ln2503">    EndModify();</a>
<a name="ln2504"> </a>
<a name="ln2505">    if (destroyBond)</a>
<a name="ln2506">      DestroyBond(bond);</a>
<a name="ln2507"> </a>
<a name="ln2508">    SetSSSRPerceived(false);</a>
<a name="ln2509">    SetLSSRPerceived(false);</a>
<a name="ln2510">    return(true);</a>
<a name="ln2511">  }</a>
<a name="ln2512"> </a>
<a name="ln2513">  bool OBMol::AddBond(int first,int second,int order,int flags,int insertpos)</a>
<a name="ln2514">  {</a>
<a name="ln2515">    // Don't add the bond if it already exists</a>
<a name="ln2516">    if (first == second || GetBond(first, second) != nullptr)</a>
<a name="ln2517">      return(false);</a>
<a name="ln2518"> </a>
<a name="ln2519">    //    BeginModify();</a>
<a name="ln2520"> </a>
<a name="ln2521">    if ((unsigned)first &lt;= NumAtoms() &amp;&amp; (unsigned)second &lt;= NumAtoms())</a>
<a name="ln2522">      //atoms exist and bond doesn't</a>
<a name="ln2523">      {</a>
<a name="ln2524">        OBBond *bond = new OBBond;</a>
<a name="ln2525">        if (!bond)</a>
<a name="ln2526">          {</a>
<a name="ln2527">            //EndModify();</a>
<a name="ln2528">            return(false);</a>
<a name="ln2529">          }</a>
<a name="ln2530"> </a>
<a name="ln2531">        OBAtom *bgn,*end;</a>
<a name="ln2532">        bgn = GetAtom(first);</a>
<a name="ln2533">        end = GetAtom(second);</a>
<a name="ln2534">        if (!bgn || !end)</a>
<a name="ln2535">          {</a>
<a name="ln2536">            obErrorLog.ThrowError(__FUNCTION__, &quot;Unable to add bond - invalid atom index&quot;, obDebug);</a>
<a name="ln2537">            return(false);</a>
<a name="ln2538">          }</a>
<a name="ln2539">        bond-&gt;Set(_nbonds,bgn,end,order,flags);</a>
<a name="ln2540">        bond-&gt;SetParent(this);</a>
<a name="ln2541"> </a>
<a name="ln2542">        bond-&gt;SetId(_bondIds.size());</a>
<a name="ln2543">        _bondIds.push_back(bond);</a>
<a name="ln2544"> </a>
<a name="ln2545">#define OBBondIncrement 100</a>
<a name="ln2546">        if (_nbonds+1 &gt;= _vbond.size())</a>
<a name="ln2547">          {</a>
<a name="ln2548">            _vbond.resize(_nbonds+OBBondIncrement);</a>
<a name="ln2549">            vector&lt;OBBond*&gt;::iterator i;</a>
<a name="ln2550">            for (i = _vbond.begin(),i+=(_nbonds+1);i != _vbond.end();++i)</a>
<a name="ln2551">              *i = nullptr;</a>
<a name="ln2552">          }</a>
<a name="ln2553">#undef  OBBondIncrement</a>
<a name="ln2554"> </a>
<a name="ln2555">        _vbond[_nbonds] = (OBBond*)bond;</a>
<a name="ln2556">        _nbonds++;</a>
<a name="ln2557"> </a>
<a name="ln2558">        if (insertpos == -1)</a>
<a name="ln2559">          {</a>
<a name="ln2560">            bgn-&gt;AddBond(bond);</a>
<a name="ln2561">            end-&gt;AddBond(bond);</a>
<a name="ln2562">          }</a>
<a name="ln2563">        else</a>
<a name="ln2564">          {</a>
<a name="ln2565">            if (insertpos &gt;= static_cast&lt;int&gt;(bgn-&gt;GetExplicitDegree()))</a>
<a name="ln2566">              bgn-&gt;AddBond(bond);</a>
<a name="ln2567">            else //need to insert the bond for the connectivity order to be preserved</a>
<a name="ln2568">              {    //otherwise stereochemistry gets screwed up</a>
<a name="ln2569">                vector&lt;OBBond*&gt;::iterator bi;</a>
<a name="ln2570">                bgn-&gt;BeginNbrAtom(bi);</a>
<a name="ln2571">                bi += insertpos;</a>
<a name="ln2572">                bgn-&gt;InsertBond(bi,bond);</a>
<a name="ln2573">              }</a>
<a name="ln2574">            end-&gt;AddBond(bond);</a>
<a name="ln2575">          }</a>
<a name="ln2576">      }</a>
<a name="ln2577">    else //at least one atom doesn't exist yet - add to bond_q</a>
<a name="ln2578">      SetData(new OBVirtualBond(first,second,order,flags));</a>
<a name="ln2579"> </a>
<a name="ln2580">    //    EndModify();</a>
<a name="ln2581"> </a>
<a name="ln2582">    return(true);</a>
<a name="ln2583">  }</a>
<a name="ln2584"> </a>
<a name="ln2585">  bool OBMol::AddBond(OBBond &amp;bond)</a>
<a name="ln2586">  {</a>
<a name="ln2587">    if(!AddBond(bond.GetBeginAtomIdx(),</a>
<a name="ln2588">                   bond.GetEndAtomIdx(),</a>
<a name="ln2589">                   bond.GetBondOrder(),</a>
<a name="ln2590">                   bond.GetFlags()))</a>
<a name="ln2591">      return false;</a>
<a name="ln2592">    //copy the bond's generic data</a>
<a name="ln2593">    OBDataIterator diter;</a>
<a name="ln2594">    for(diter=bond.BeginData(); diter!=bond.EndData();++diter)</a>
<a name="ln2595">      GetBond(NumBonds()-1)-&gt;CloneData(*diter);</a>
<a name="ln2596">    return true;</a>
<a name="ln2597">  }</a>
<a name="ln2598"> </a>
<a name="ln2599">  void OBMol::Align(OBAtom *a1,OBAtom *a2,vector3 &amp;p1,vector3 &amp;p2)</a>
<a name="ln2600">  {</a>
<a name="ln2601">    vector&lt;int&gt; children;</a>
<a name="ln2602"> </a>
<a name="ln2603">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2604">                          &quot;Ran OpenBabel::Align&quot;, obAuditMsg);</a>
<a name="ln2605"> </a>
<a name="ln2606">    //find which atoms to rotate</a>
<a name="ln2607">    FindChildren(children,a1-&gt;GetIdx(),a2-&gt;GetIdx());</a>
<a name="ln2608">    children.push_back(a2-&gt;GetIdx());</a>
<a name="ln2609"> </a>
<a name="ln2610">    //find the rotation vector and angle</a>
<a name="ln2611">    vector3 v1,v2,v3;</a>
<a name="ln2612">    v1 = p2 - p1;</a>
<a name="ln2613">    v2 = a2-&gt;GetVector() - a1-&gt;GetVector();</a>
<a name="ln2614">    v3 = cross(v1,v2);</a>
<a name="ln2615">    double angle = vectorAngle(v1,v2);</a>
<a name="ln2616"> </a>
<a name="ln2617">    //find the rotation matrix</a>
<a name="ln2618">    matrix3x3 m;</a>
<a name="ln2619">    m.RotAboutAxisByAngle(v3,angle);</a>
<a name="ln2620"> </a>
<a name="ln2621">    //rotate atoms</a>
<a name="ln2622">    vector3 v;</a>
<a name="ln2623">    OBAtom *atom;</a>
<a name="ln2624">    vector&lt;int&gt;::iterator i;</a>
<a name="ln2625">    for (i = children.begin();i != children.end();++i)</a>
<a name="ln2626">      {</a>
<a name="ln2627">        atom = GetAtom(*i);</a>
<a name="ln2628">        v = atom-&gt;GetVector();</a>
<a name="ln2629">        v -= a1-&gt;GetVector();</a>
<a name="ln2630">        v *= m;   //rotate the point</a>
<a name="ln2631">        v += p1;  //translate the vector</a>
<a name="ln2632">        atom-&gt;SetVector(v);</a>
<a name="ln2633">      }</a>
<a name="ln2634">    //set a1 = p1</a>
<a name="ln2635">    a1-&gt;SetVector(p1);</a>
<a name="ln2636">  }</a>
<a name="ln2637"> </a>
<a name="ln2638">  void OBMol::ToInertialFrame()</a>
<a name="ln2639">  {</a>
<a name="ln2640">    double m[9];</a>
<a name="ln2641">    for (int i = 0;i &lt; NumConformers();++i)</a>
<a name="ln2642">      ToInertialFrame(i,m);</a>
<a name="ln2643">  }</a>
<a name="ln2644"> </a>
<a name="ln2645">  void OBMol::ToInertialFrame(int conf,double *rmat)</a>
<a name="ln2646">  {</a>
<a name="ln2647">    unsigned int i;</a>
<a name="ln2648">    double x,y,z;</a>
<a name="ln2649">    double mi;</a>
<a name="ln2650">    double mass = 0.0;</a>
<a name="ln2651">    double center[3],m[3][3];</a>
<a name="ln2652"> </a>
<a name="ln2653">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2654">                          &quot;Ran OpenBabel::ToInertialFrame&quot;, obAuditMsg);</a>
<a name="ln2655"> </a>
<a name="ln2656">    for (i = 0;i &lt; 3;++i)</a>
<a name="ln2657">      memset(&amp;m[i],'\0',sizeof(double)*3);</a>
<a name="ln2658">    memset(center,'\0',sizeof(double)*3);</a>
<a name="ln2659"> </a>
<a name="ln2660">    SetConformer(conf);</a>
<a name="ln2661">    OBAtom *atom;</a>
<a name="ln2662">    vector&lt;OBAtom*&gt;::iterator j;</a>
<a name="ln2663">    //find center of mass</a>
<a name="ln2664">    for (atom = BeginAtom(j);atom;atom = NextAtom(j))</a>
<a name="ln2665">      {</a>
<a name="ln2666">        mi = atom-&gt;GetAtomicMass();</a>
<a name="ln2667">        center[0] += mi*atom-&gt;x();</a>
<a name="ln2668">        center[1] += mi*atom-&gt;y();</a>
<a name="ln2669">        center[2] += mi*atom-&gt;z();</a>
<a name="ln2670">        mass += mi;</a>
<a name="ln2671">      }</a>
<a name="ln2672"> </a>
<a name="ln2673">    center[0] /= mass;</a>
<a name="ln2674">    center[1] /= mass;</a>
<a name="ln2675">    center[2] /= mass;</a>
<a name="ln2676"> </a>
<a name="ln2677">    //calculate inertial tensor</a>
<a name="ln2678">    for (atom = BeginAtom(j);atom;atom = NextAtom(j))</a>
<a name="ln2679">      {</a>
<a name="ln2680">        x = atom-&gt;x()-center[0];</a>
<a name="ln2681">        y = atom-&gt;y()-center[1];</a>
<a name="ln2682">        z = atom-&gt;z()-center[2];</a>
<a name="ln2683">        mi = atom-&gt;GetAtomicMass();</a>
<a name="ln2684"> </a>
<a name="ln2685">        m[0][0] += mi*(y*y+z*z);</a>
<a name="ln2686">        m[0][1] -= mi*x*y;</a>
<a name="ln2687">        m[0][2] -= mi*x*z;</a>
<a name="ln2688">        //        m[1][0] -= mi*x*y;</a>
<a name="ln2689">        m[1][1] += mi*(x*x+z*z);</a>
<a name="ln2690">        m[1][2] -= mi*y*z;</a>
<a name="ln2691">        //        m[2][0] -= mi*x*z;</a>
<a name="ln2692">        //        m[2][1] -= mi*y*z;</a>
<a name="ln2693">        m[2][2] += mi*(x*x+y*y);</a>
<a name="ln2694">      }</a>
<a name="ln2695">    // Fill in the lower triangle using symmetry across the diagonal</a>
<a name="ln2696">    m[1][0] = m[0][1];</a>
<a name="ln2697">    m[2][0] = m[0][2];</a>
<a name="ln2698">    m[2][1] = m[1][2];</a>
<a name="ln2699"> </a>
<a name="ln2700">    /* find rotation matrix for moment of inertia */</a>
<a name="ln2701">    ob_make_rmat(m,rmat);</a>
<a name="ln2702"> </a>
<a name="ln2703">    /* rotate all coordinates */</a>
<a name="ln2704">    double *c = GetConformer(conf);</a>
<a name="ln2705">    for(i=0; i &lt; NumAtoms();++i)</a>
<a name="ln2706">      {</a>
<a name="ln2707">        x = c[i*3]-center[0];</a>
<a name="ln2708">        y = c[i*3+1]-center[1];</a>
<a name="ln2709">        z = c[i*3+2]-center[2];</a>
<a name="ln2710">        c[i*3]   = x*rmat[0] + y*rmat[1] + z*rmat[2];</a>
<a name="ln2711">        c[i*3+1] = x*rmat[3] + y*rmat[4] + z*rmat[5];</a>
<a name="ln2712">        c[i*3+2] = x*rmat[6] + y*rmat[7] + z*rmat[8];</a>
<a name="ln2713">      }</a>
<a name="ln2714">  }</a>
<a name="ln2715"> </a>
<a name="ln2716">  OBMol::OBMol()</a>
<a name="ln2717">  {</a>
<a name="ln2718">    _natoms = _nbonds = 0;</a>
<a name="ln2719">    _mod = 0;</a>
<a name="ln2720">    _totalCharge = 0;</a>
<a name="ln2721">    _dimension = 3;</a>
<a name="ln2722">    _vatom.clear();</a>
<a name="ln2723">    _atomIds.clear();</a>
<a name="ln2724">    _vbond.clear();</a>
<a name="ln2725">    _bondIds.clear();</a>
<a name="ln2726">    _vdata.clear();</a>
<a name="ln2727">    _title = &quot;&quot;;</a>
<a name="ln2728">    _c = nullptr;</a>
<a name="ln2729">    _flags = 0;</a>
<a name="ln2730">    _vconf.clear();</a>
<a name="ln2731">    _autoPartialCharge = true;</a>
<a name="ln2732">    _autoFormalCharge = true;</a>
<a name="ln2733">    _energy = 0.0;</a>
<a name="ln2734">  }</a>
<a name="ln2735"> </a>
<a name="ln2736">  OBMol::OBMol(const OBMol &amp;mol) : OBBase(mol)</a>
<a name="ln2737">  {</a>
<a name="ln2738">    _natoms = _nbonds = 0;</a>
<a name="ln2739">    _mod = 0;</a>
<a name="ln2740">    _totalCharge = 0;</a>
<a name="ln2741">    _dimension = 3;</a>
<a name="ln2742">    _vatom.clear();</a>
<a name="ln2743">    _atomIds.clear();</a>
<a name="ln2744">    _vbond.clear();</a>
<a name="ln2745">    _bondIds.clear();</a>
<a name="ln2746">    _vdata.clear();</a>
<a name="ln2747">    _title = &quot;&quot;;</a>
<a name="ln2748">    _c = nullptr;</a>
<a name="ln2749">    _flags = 0;</a>
<a name="ln2750">    _vconf.clear();</a>
<a name="ln2751">    _autoPartialCharge = true;</a>
<a name="ln2752">    _autoFormalCharge = true;</a>
<a name="ln2753">    //NF  _compressed = false;</a>
<a name="ln2754">    _energy = 0.0;</a>
<a name="ln2755">    *this = mol;</a>
<a name="ln2756">  }</a>
<a name="ln2757"> </a>
<a name="ln2758">  OBMol::~OBMol()</a>
<a name="ln2759">  {</a>
<a name="ln2760">    OBAtom    *atom;</a>
<a name="ln2761">    OBBond    *bond;</a>
<a name="ln2762">    OBResidue *residue;</a>
<a name="ln2763">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2764">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln2765">    vector&lt;OBResidue*&gt;::iterator r;</a>
<a name="ln2766">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2767">      DestroyAtom(atom);</a>
<a name="ln2768">    for (bond = BeginBond(j);bond;bond = NextBond(j))</a>
<a name="ln2769">      DestroyBond(bond);</a>
<a name="ln2770">    for (residue = BeginResidue(r);residue;residue = NextResidue(r))</a>
<a name="ln2771">      DestroyResidue(residue);</a>
<a name="ln2772"> </a>
<a name="ln2773">    //clear out the multiconformer data</a>
<a name="ln2774">    vector&lt;double*&gt;::iterator k;</a>
<a name="ln2775">    for (k = _vconf.begin();k != _vconf.end();++k)</a>
<a name="ln2776">      delete [] *k;</a>
<a name="ln2777">    _vconf.clear();</a>
<a name="ln2778">  }</a>
<a name="ln2779"> </a>
<a name="ln2780">  bool OBMol::HasNonZeroCoords()</a>
<a name="ln2781">  {</a>
<a name="ln2782">    OBAtom *atom;</a>
<a name="ln2783">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2784"> </a>
<a name="ln2785">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2786">      if (atom-&gt;GetVector() != VZero)</a>
<a name="ln2787">        return(true);</a>
<a name="ln2788"> </a>
<a name="ln2789">    return(false);</a>
<a name="ln2790">  }</a>
<a name="ln2791"> </a>
<a name="ln2792">  bool OBMol::Has2D(bool Not3D)</a>
<a name="ln2793">  {</a>
<a name="ln2794">    bool hasX,hasY;</a>
<a name="ln2795">    OBAtom *atom;</a>
<a name="ln2796">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2797"> </a>
<a name="ln2798">    hasX = hasY = false;</a>
<a name="ln2799">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2800">      {</a>
<a name="ln2801">        if (!hasX &amp;&amp; !IsNearZero(atom-&gt;x()))</a>
<a name="ln2802">          hasX = true;</a>
<a name="ln2803">        if (!hasY &amp;&amp; !IsNearZero(atom-&gt;y()))</a>
<a name="ln2804">          hasY = true;</a>
<a name="ln2805">        if(Not3D &amp;&amp; atom-&gt;z())</a>
<a name="ln2806">          return false;</a>
<a name="ln2807">      }</a>
<a name="ln2808">    if (hasX || hasY) //was &amp;&amp; but this excluded vertically or horizontally aligned linear mols</a>
<a name="ln2809">      return(true);</a>
<a name="ln2810">    return(false);</a>
<a name="ln2811">  }</a>
<a name="ln2812"> </a>
<a name="ln2813">  bool OBMol::Has3D()</a>
<a name="ln2814">  {</a>
<a name="ln2815">    bool hasX,hasY,hasZ;</a>
<a name="ln2816">    OBAtom *atom;</a>
<a name="ln2817">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2818"> </a>
<a name="ln2819">    hasX = hasY = hasZ = false;</a>
<a name="ln2820">    //    if (this-&gt;_c == NULL) **Test removed** Prevented function use during molecule construction</a>
<a name="ln2821">    //      return(false);</a>
<a name="ln2822">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2823">      {</a>
<a name="ln2824">        if (!hasX &amp;&amp; !IsNearZero(atom-&gt;x()))</a>
<a name="ln2825">          hasX = true;</a>
<a name="ln2826">        if (!hasY &amp;&amp; !IsNearZero(atom-&gt;y()))</a>
<a name="ln2827">          hasY = true;</a>
<a name="ln2828">        if (!hasZ &amp;&amp; !IsNearZero(atom-&gt;z()))</a>
<a name="ln2829">          hasZ = true;</a>
<a name="ln2830"> </a>
<a name="ln2831">        if (hasX &amp;&amp; hasY &amp;&amp; hasZ)</a>
<a name="ln2832">          return(true);</a>
<a name="ln2833">      }</a>
<a name="ln2834">    return(false);</a>
<a name="ln2835">  }</a>
<a name="ln2836"> </a>
<a name="ln2837">  void OBMol::SetCoordinates(double *newCoords)</a>
<a name="ln2838">  {</a>
<a name="ln2839">    bool noCptr = (_c == nullptr); // did we previously have a coordinate ptr</a>
<a name="ln2840">    if (noCptr) {</a>
<a name="ln2841">      _c = new double [NumAtoms()*3];</a>
<a name="ln2842">    }</a>
<a name="ln2843"> </a>
<a name="ln2844">    // copy from external to internal</a>
<a name="ln2845">    memcpy((char*)_c, (char*)newCoords, sizeof(double)*3*NumAtoms());</a>
<a name="ln2846"> </a>
<a name="ln2847">    if (noCptr) {</a>
<a name="ln2848">      OBAtom *atom;</a>
<a name="ln2849">      vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2850">      for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2851">        atom-&gt;SetCoordPtr(&amp;_c);</a>
<a name="ln2852">      _vconf.push_back(newCoords);</a>
<a name="ln2853">    }</a>
<a name="ln2854">  }</a>
<a name="ln2855"> </a>
<a name="ln2856">  //! Renumber the atoms according to the order of indexes in the supplied vector</a>
<a name="ln2857">  //! This with assemble an atom vector and call RenumberAtoms(vector&lt;OBAtom*&gt;)</a>
<a name="ln2858">  //! It will return without action if the supplied vector is empty or does not</a>
<a name="ln2859">  //! have the same number of atoms as the molecule.</a>
<a name="ln2860">  //!</a>
<a name="ln2861">  //! \since version 2.3</a>
<a name="ln2862">  void OBMol::RenumberAtoms(vector&lt;int&gt; v)</a>
<a name="ln2863">  {</a>
<a name="ln2864">    if (Empty() || v.size() != NumAtoms())</a>
<a name="ln2865">      return;</a>
<a name="ln2866"> </a>
<a name="ln2867">    vector &lt;OBAtom*&gt; va;</a>
<a name="ln2868">    va.reserve(NumAtoms());</a>
<a name="ln2869"> </a>
<a name="ln2870">    vector&lt;int&gt;::iterator i;</a>
<a name="ln2871">    for (i = v.begin(); i != v.end(); ++i)</a>
<a name="ln2872">      va.push_back( GetAtom(*i) );</a>
<a name="ln2873"> </a>
<a name="ln2874">    this-&gt;RenumberAtoms(va);</a>
<a name="ln2875">  }</a>
<a name="ln2876"> </a>
<a name="ln2877">  //! Renumber the atoms in this molecule according to the order in the supplied</a>
<a name="ln2878">  //! vector. This will return without action if the supplied vector is empty or</a>
<a name="ln2879">  //! does not have the same number of atoms as the molecule.</a>
<a name="ln2880">  void OBMol::RenumberAtoms(vector&lt;OBAtom*&gt; &amp;v)</a>
<a name="ln2881">  {</a>
<a name="ln2882">    if (Empty())</a>
<a name="ln2883">      return;</a>
<a name="ln2884"> </a>
<a name="ln2885">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2886">                          &quot;Ran OpenBabel::RenumberAtoms&quot;, obAuditMsg);</a>
<a name="ln2887"> </a>
<a name="ln2888">    OBAtom *atom;</a>
<a name="ln2889">    vector&lt;OBAtom*&gt; va;</a>
<a name="ln2890">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2891"> </a>
<a name="ln2892">    va = v;</a>
<a name="ln2893"> </a>
<a name="ln2894">    //make sure all atoms are represented in the vector</a>
<a name="ln2895">    if (va.empty() || va.size() != NumAtoms())</a>
<a name="ln2896">      return;</a>
<a name="ln2897"> </a>
<a name="ln2898">    OBBitVec bv;</a>
<a name="ln2899">    for (i = va.begin();i != va.end();++i)</a>
<a name="ln2900">      bv |= (*i)-&gt;GetIdx();</a>
<a name="ln2901"> </a>
<a name="ln2902">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln2903">      if (!bv[atom-&gt;GetIdx()])</a>
<a name="ln2904">        va.push_back(atom);</a>
<a name="ln2905"> </a>
<a name="ln2906">    int j,k;</a>
<a name="ln2907">    double *c;</a>
<a name="ln2908">    double *ctmp = new double [NumAtoms()*3];</a>
<a name="ln2909"> </a>
<a name="ln2910">    for (j = 0;j &lt; NumConformers();++j)</a>
<a name="ln2911">      {</a>
<a name="ln2912">        c = GetConformer(j);</a>
<a name="ln2913">        for (k=0,i = va.begin();i != va.end(); ++i,++k)</a>
<a name="ln2914">          memcpy((char*)&amp;ctmp[k*3],(char*)&amp;c[((OBAtom*)*i)-&gt;GetCoordinateIdx()],sizeof(double)*3);</a>
<a name="ln2915">        memcpy((char*)c,(char*)ctmp,sizeof(double)*3*NumAtoms());</a>
<a name="ln2916">      }</a>
<a name="ln2917"> </a>
<a name="ln2918">    for (k=1,i = va.begin();i != va.end(); ++i,++k)</a>
<a name="ln2919">      (*i)-&gt;SetIdx(k);</a>
<a name="ln2920"> </a>
<a name="ln2921">    delete [] ctmp;</a>
<a name="ln2922"> </a>
<a name="ln2923">    _vatom.clear();</a>
<a name="ln2924">    for (i = va.begin();i != va.end();++i)</a>
<a name="ln2925">      _vatom.push_back(*i);</a>
<a name="ln2926"> </a>
<a name="ln2927">    DeleteData(OBGenericDataType::RingData);</a>
<a name="ln2928">    DeleteData(&quot;OpenBabel Symmetry Classes&quot;);</a>
<a name="ln2929">    DeleteData(&quot;LSSR&quot;);</a>
<a name="ln2930">    DeleteData(&quot;SSSR&quot;);</a>
<a name="ln2931">    UnsetFlag(OB_LSSR_MOL);</a>
<a name="ln2932">    UnsetFlag(OB_SSSR_MOL);</a>
<a name="ln2933">  }</a>
<a name="ln2934"> </a>
<a name="ln2935">  bool WriteTitles(ostream &amp;ofs, OBMol &amp;mol)</a>
<a name="ln2936">  {</a>
<a name="ln2937">    ofs &lt;&lt; mol.GetTitle() &lt;&lt; endl;</a>
<a name="ln2938">    return true;</a>
<a name="ln2939">  }</a>
<a name="ln2940"> </a>
<a name="ln2941">  //check that unreasonable bonds aren't being added</a>
<a name="ln2942">  static bool validAdditionalBond(OBAtom *a, OBAtom *n)</a>
<a name="ln2943">  {</a>
<a name="ln2944">    if(a-&gt;GetExplicitValence() == 5 &amp;&amp; a-&gt;GetAtomicNum() == 15)</a>
<a name="ln2945">    {</a>
<a name="ln2946">      //only allow octhedral bonding for F and Cl</a>
<a name="ln2947">      if(n-&gt;GetAtomicNum() == 9 || n-&gt;GetAtomicNum() == 17)</a>
<a name="ln2948">        return true;</a>
<a name="ln2949">      else</a>
<a name="ln2950">        return false;</a>
<a name="ln2951">    }</a>
<a name="ln2952">    //other things to check?</a>
<a name="ln2953">    return true;</a>
<a name="ln2954">  }</a>
<a name="ln2955"> </a>
<a name="ln2956">  /*! This method adds single bonds between all atoms</a>
<a name="ln2957">    closer than their combined atomic covalent radii,</a>
<a name="ln2958">    then &quot;cleans up&quot; making sure bonded atoms are not</a>
<a name="ln2959">    closer than 0.4A and the atom does not exceed its valence.</a>
<a name="ln2960">    It implements blue-obelisk:rebondFrom3DCoordinates.</a>
<a name="ln2961"> </a>
<a name="ln2962">  */</a>
<a name="ln2963">  void OBMol::ConnectTheDots(void)</a>
<a name="ln2964">  {</a>
<a name="ln2965">    if (Empty())</a>
<a name="ln2966">      return;</a>
<a name="ln2967">    if (_dimension != 3) return; // not useful on non-3D structures</a>
<a name="ln2968"> </a>
<a name="ln2969">    if (IsPeriodic())</a>
<a name="ln2970">      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2971">                            &quot;Ran OpenBabel::ConnectTheDots -- using periodic boundary conditions&quot;,</a>
<a name="ln2972">                            obAuditMsg);</a>
<a name="ln2973">    else</a>
<a name="ln2974">      obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2975">                            &quot;Ran OpenBabel::ConnectTheDots&quot;, obAuditMsg);</a>
<a name="ln2976"> </a>
<a name="ln2977"> </a>
<a name="ln2978">    int j,k,max;</a>
<a name="ln2979">    double maxrad = 0;</a>
<a name="ln2980">    bool unset = false;</a>
<a name="ln2981">    OBAtom *atom,*nbr;</a>
<a name="ln2982">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln2983">    vector&lt;pair&lt;OBAtom*,double&gt; &gt; zsortedAtoms;</a>
<a name="ln2984">    vector&lt;double&gt; rad;</a>
<a name="ln2985">    vector&lt;int&gt; zsorted;</a>
<a name="ln2986">    vector&lt;int&gt; bondCount; // existing bonds (e.g., from residues in PDB)</a>
<a name="ln2987"> </a>
<a name="ln2988">    double *c = new double [NumAtoms()*3];</a>
<a name="ln2989">    rad.resize(_natoms);</a>
<a name="ln2990"> </a>
<a name="ln2991">    for (j = 0, atom = BeginAtom(i) ; atom ; atom = NextAtom(i), ++j)</a>
<a name="ln2992">      {</a>
<a name="ln2993">        bondCount.push_back(atom-&gt;GetExplicitDegree());</a>
<a name="ln2994">        //don't consider atoms with a full valance already</a>
<a name="ln2995">        //this is both for correctness (trust existing bonds) and performance</a>
<a name="ln2996">        if(atom-&gt;GetExplicitValence() &gt;= OBElements::GetMaxBonds(atom-&gt;GetAtomicNum()))</a>
<a name="ln2997">          continue;</a>
<a name="ln2998">        if(atom-&gt;GetAtomicNum() == 7 &amp;&amp; atom-&gt;GetFormalCharge() == 0 &amp;&amp; atom-&gt;GetExplicitValence() &gt;= 3)</a>
<a name="ln2999">          continue;</a>
<a name="ln3000">        (atom-&gt;GetVector()).Get(&amp;c[j*3]);</a>
<a name="ln3001">        pair&lt;OBAtom*,double&gt; entry(atom, atom-&gt;GetVector().z());</a>
<a name="ln3002">        zsortedAtoms.push_back(entry);</a>
<a name="ln3003">      }</a>
<a name="ln3004">    sort(zsortedAtoms.begin(), zsortedAtoms.end(), SortAtomZ);</a>
<a name="ln3005"> </a>
<a name="ln3006">    max = zsortedAtoms.size();</a>
<a name="ln3007"> </a>
<a name="ln3008">    for ( j = 0 ; j &lt; max ; j++ )</a>
<a name="ln3009">      {</a>
<a name="ln3010">        atom   = zsortedAtoms[j].first;</a>
<a name="ln3011">        rad[j] = OBElements::GetCovalentRad(atom-&gt;GetAtomicNum());</a>
<a name="ln3012">        maxrad = std::max(rad[j],maxrad);</a>
<a name="ln3013">        zsorted.push_back(atom-&gt;GetIdx()-1);</a>
<a name="ln3014">      }</a>
<a name="ln3015"> </a>
<a name="ln3016">    int idx1, idx2;</a>
<a name="ln3017">    double d2,cutoff,zd;</a>
<a name="ln3018">    vector3 atom1, atom2, wrapped_coords;  // Only used for periodic coords</a>
<a name="ln3019">    for (j = 0 ; j &lt; max ; ++j)</a>
<a name="ln3020">      {</a>
<a name="ln3021">        double maxcutoff = SQUARE(rad[j]+maxrad+0.45);</a>
<a name="ln3022">        idx1 = zsorted[j];</a>
<a name="ln3023">        for (k = j + 1 ; k &lt; max ; k++ )</a>
<a name="ln3024">          {</a>
<a name="ln3025">            idx2 = zsorted[k];</a>
<a name="ln3026"> </a>
<a name="ln3027">            // bonded if closer than elemental Rcov + tolerance</a>
<a name="ln3028">            cutoff = SQUARE(rad[j] + rad[k] + 0.45);</a>
<a name="ln3029"> </a>
<a name="ln3030">            // Use minimum image convention if the unit cell is periodic</a>
<a name="ln3031">            // Otherwise, use a simpler (faster) distance calculation based on raw coordinates</a>
<a name="ln3032">            if (IsPeriodic())</a>
<a name="ln3033">              {</a>
<a name="ln3034">                atom1 = vector3(c[idx1*3], c[idx1*3+1], c[idx1*3+2]);</a>
<a name="ln3035">                atom2 = vector3(c[idx2*3], c[idx2*3+1], c[idx2*3+2]);</a>
<a name="ln3036">                OBUnitCell *unitCell = (OBUnitCell * ) GetData(OBGenericDataType::UnitCell);</a>
<a name="ln3037">                wrapped_coords = unitCell-&gt;MinimumImageCartesian(atom1 - atom2);</a>
<a name="ln3038">                d2 = wrapped_coords.length_2();</a>
<a name="ln3039">              }</a>
<a name="ln3040">            else</a>
<a name="ln3041">              {</a>
<a name="ln3042">                zd  = SQUARE(c[idx1*3+2] - c[idx2*3+2]);</a>
<a name="ln3043">                // bigger than max cutoff, which is determined using largest radius,</a>
<a name="ln3044">                // not the radius of k (which might be small, ie H, and cause an early  termination)</a>
<a name="ln3045">                // since we sort by z, anything beyond k will also fail</a>
<a name="ln3046">                if (zd &gt; maxcutoff )</a>
<a name="ln3047">                  break;</a>
<a name="ln3048"> </a>
<a name="ln3049">                d2  = SQUARE(c[idx1*3]   - c[idx2*3]);</a>
<a name="ln3050">                if (d2 &gt; cutoff)</a>
<a name="ln3051">                  continue; // x's bigger than cutoff</a>
<a name="ln3052">                d2 += SQUARE(c[idx1*3+1] - c[idx2*3+1]);</a>
<a name="ln3053">                if (d2 &gt; cutoff)</a>
<a name="ln3054">                  continue; // x^2 + y^2 bigger than cutoff</a>
<a name="ln3055">                d2 += zd;</a>
<a name="ln3056">              }</a>
<a name="ln3057"> </a>
<a name="ln3058">            if (d2 &gt; cutoff)</a>
<a name="ln3059">              continue;</a>
<a name="ln3060">            if (d2 &lt; 0.16) // 0.4 * 0.4 = 0.16</a>
<a name="ln3061">              continue;</a>
<a name="ln3062"> </a>
<a name="ln3063">            atom = GetAtom(idx1+1);</a>
<a name="ln3064">            nbr  = GetAtom(idx2+1);</a>
<a name="ln3065"> </a>
<a name="ln3066">            if (atom-&gt;IsConnected(nbr))</a>
<a name="ln3067">              continue;</a>
<a name="ln3068"> </a>
<a name="ln3069">            if (!validAdditionalBond(atom,nbr) || !validAdditionalBond(nbr, atom))</a>
<a name="ln3070">              continue;</a>
<a name="ln3071"> </a>
<a name="ln3072">            AddBond(idx1+1,idx2+1,1);</a>
<a name="ln3073">          }</a>
<a name="ln3074">      }</a>
<a name="ln3075"> </a>
<a name="ln3076">    // If between BeginModify and EndModify, coord pointers are NULL</a>
<a name="ln3077">    // setup molecule to handle current coordinates</a>
<a name="ln3078"> </a>
<a name="ln3079">    if (_c == nullptr)</a>
<a name="ln3080">      {</a>
<a name="ln3081">        _c = c;</a>
<a name="ln3082">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3083">          atom-&gt;SetCoordPtr(&amp;_c);</a>
<a name="ln3084">        _vconf.push_back(c);</a>
<a name="ln3085">        unset = true;</a>
<a name="ln3086">      }</a>
<a name="ln3087"> </a>
<a name="ln3088">    // Cleanup -- delete long bonds that exceed max valence</a>
<a name="ln3089">    OBBond *maxbond, *bond;</a>
<a name="ln3090">    double maxlength;</a>
<a name="ln3091">    vector&lt;OBBond*&gt;::iterator l, m;</a>
<a name="ln3092">    int valCount;</a>
<a name="ln3093">    bool changed;</a>
<a name="ln3094">    BeginModify(); //prevent needless re-perception in DeleteBond</a>
<a name="ln3095">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3096">      {</a>
<a name="ln3097">        while (atom-&gt;GetExplicitValence() &gt; static_cast&lt;unsigned int&gt;(OBElements::GetMaxBonds(atom-&gt;GetAtomicNum()))</a>
<a name="ln3098">               || atom-&gt;SmallestBondAngle() &lt; 45.0)</a>
<a name="ln3099">          {</a>
<a name="ln3100">            bond = atom-&gt;BeginBond(l);</a>
<a name="ln3101">            maxbond = bond;</a>
<a name="ln3102">            // Fix from Liu Zhiguo 2008-01-26</a>
<a name="ln3103">            // loop past any bonds</a>
<a name="ln3104">            // which existed before ConnectTheDots was called</a>
<a name="ln3105">            // (e.g., from PDB resdata.txt)</a>
<a name="ln3106">            valCount = 0;</a>
<a name="ln3107">            while (valCount &lt; bondCount[atom-&gt;GetIdx() - 1]) {</a>
<a name="ln3108">              bond = atom-&gt;NextBond(l);</a>
<a name="ln3109">              // timvdm: 2008-03-05</a>
<a name="ln3110">              // NextBond only returns NULL if the iterator l == _bonds.end().</a>
<a name="ln3111">              // This was casuing problems as follows:</a>
<a name="ln3112">              // NextBond = 0x????????</a>
<a name="ln3113">              // NextBond = 0x????????</a>
<a name="ln3114">              // NextBond = 0x????????</a>
<a name="ln3115">              // NextBond = 0x????????</a>
<a name="ln3116">              // NextBond = NULL  &lt;-- this NULL was not detected</a>
<a name="ln3117">              // NextBond = 0x????????</a>
<a name="ln3118">              if (!bond) // so we add an additional check</a>
<a name="ln3119">                break;</a>
<a name="ln3120">              maxbond = bond;</a>
<a name="ln3121">              valCount++;</a>
<a name="ln3122">            }</a>
<a name="ln3123">            if (!bond) // no new bonds added for this atom, just skip it</a>
<a name="ln3124">              break;</a>
<a name="ln3125"> </a>
<a name="ln3126">            // delete bonds between hydrogens when over max valence</a>
<a name="ln3127">            if (atom-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln3128">              {</a>
<a name="ln3129">                m = l;</a>
<a name="ln3130">                changed = false;</a>
<a name="ln3131">                for (;bond;bond = atom-&gt;NextBond(m))</a>
<a name="ln3132">                  {</a>
<a name="ln3133">                    if (bond-&gt;GetNbrAtom(atom)-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln3134">                      {</a>
<a name="ln3135">                        DeleteBond(bond);</a>
<a name="ln3136">                        changed = true;</a>
<a name="ln3137">                        break;</a>
<a name="ln3138">                      }</a>
<a name="ln3139">                  }</a>
<a name="ln3140">                if (changed)</a>
<a name="ln3141">                  {</a>
<a name="ln3142">                    // bond deleted, reevaluate BOSum</a>
<a name="ln3143">                    continue;</a>
<a name="ln3144">                  }</a>
<a name="ln3145">                else</a>
<a name="ln3146">                  {</a>
<a name="ln3147">                    // reset to first new bond</a>
<a name="ln3148">                    bond = maxbond;</a>
<a name="ln3149">                  }</a>
<a name="ln3150">              }</a>
<a name="ln3151"> </a>
<a name="ln3152">            maxlength = maxbond-&gt;GetLength();</a>
<a name="ln3153">            for (bond = atom-&gt;NextBond(l);bond;bond = atom-&gt;NextBond(l))</a>
<a name="ln3154">              {</a>
<a name="ln3155">                if (bond-&gt;GetLength() &gt; maxlength)</a>
<a name="ln3156">                  {</a>
<a name="ln3157">                    maxbond = bond;</a>
<a name="ln3158">                    maxlength = bond-&gt;GetLength();</a>
<a name="ln3159">                  }</a>
<a name="ln3160">              }</a>
<a name="ln3161">            DeleteBond(maxbond); // delete the new bond with the longest length</a>
<a name="ln3162">          }</a>
<a name="ln3163">      }</a>
<a name="ln3164">    EndModify();</a>
<a name="ln3165">    if (unset)</a>
<a name="ln3166">      {</a>
<a name="ln3167">        _c = nullptr;</a>
<a name="ln3168">        for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3169">          atom-&gt;ClearCoordPtr();</a>
<a name="ln3170">	if (_vconf.size() &gt; 0)</a>
<a name="ln3171">	  _vconf.resize(_vconf.size()-1);</a>
<a name="ln3172">      }</a>
<a name="ln3173"> </a>
<a name="ln3174">    if (_c != nullptr)</a>
<a name="ln3175">      delete [] c;</a>
<a name="ln3176">  }</a>
<a name="ln3177"> </a>
<a name="ln3178">  /*! This method uses bond angles and geometries from current</a>
<a name="ln3179">    connectivity to guess atom types and then filling empty valences</a>
<a name="ln3180">    with multiple bonds. It currently has a pass to detect some</a>
<a name="ln3181">    frequent functional groups. It still needs a pass to detect aromatic</a>
<a name="ln3182">    rings to &quot;clean up.&quot;</a>
<a name="ln3183">    AssignSpinMultiplicity(true) is called at the end of the function. The true</a>
<a name="ln3184">    states that there are no implict hydrogens in the molecule.</a>
<a name="ln3185">  */</a>
<a name="ln3186">  void OBMol::PerceiveBondOrders()</a>
<a name="ln3187">  {</a>
<a name="ln3188">    if (Empty())</a>
<a name="ln3189">      return;</a>
<a name="ln3190">    if (_dimension != 3) return; // not useful on non-3D structures</a>
<a name="ln3191"> </a>
<a name="ln3192">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln3193">                          &quot;Ran OpenBabel::PerceiveBondOrders&quot;, obAuditMsg);</a>
<a name="ln3194"> </a>
<a name="ln3195">    OBAtom *atom, *b, *c;</a>
<a name="ln3196">    vector3 v1, v2;</a>
<a name="ln3197">    double angle;//, dist1, dist2;</a>
<a name="ln3198">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln3199">    vector&lt;OBBond*&gt;::iterator j;//,k;</a>
<a name="ln3200"> </a>
<a name="ln3201">    //  BeginModify();</a>
<a name="ln3202"> </a>
<a name="ln3203">    // Pass 1: Assign estimated hybridization based on avg. angles</a>
<a name="ln3204">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3205">      {</a>
<a name="ln3206">        angle = atom-&gt;AverageBondAngle();</a>
<a name="ln3207"> </a>
<a name="ln3208">        //        cout &lt;&lt; atom-&gt;GetAtomicNum() &lt;&lt; &quot; &quot; &lt;&lt; angle &lt;&lt; endl;</a>
<a name="ln3209"> </a>
<a name="ln3210">        if (angle &gt; 155.0)</a>
<a name="ln3211">          atom-&gt;SetHyb(1);</a>
<a name="ln3212">        else if (angle &lt;= 155.0 &amp;&amp; angle &gt; 115.0)</a>
<a name="ln3213">          atom-&gt;SetHyb(2);</a>
<a name="ln3214"> </a>
<a name="ln3215">        // special case for imines</a>
<a name="ln3216">        if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen</a>
<a name="ln3217">            &amp;&amp; atom-&gt;ExplicitHydrogenCount() == 1</a>
<a name="ln3218">            &amp;&amp; atom-&gt;GetExplicitDegree() == 2</a>
<a name="ln3219">            &amp;&amp; angle &gt; 109.5)</a>
<a name="ln3220">          atom-&gt;SetHyb(2);</a>
<a name="ln3221"> </a>
<a name="ln3222">      } // pass 1</a>
<a name="ln3223"> </a>
<a name="ln3224">    // Make sure upcoming calls to GetHyb() don't kill these temporary values</a>
<a name="ln3225">    SetHybridizationPerceived();</a>
<a name="ln3226"> </a>
<a name="ln3227">    // Pass 2: look for 5-member rings with torsions &lt;= 7.5 degrees</a>
<a name="ln3228">    //         and 6-member rings with torsions &lt;= 12 degrees</a>
<a name="ln3229">    //         (set all atoms with at least two bonds to sp2)</a>
<a name="ln3230"> </a>
<a name="ln3231">    vector&lt;OBRing*&gt; rlist;</a>
<a name="ln3232">    vector&lt;OBRing*&gt;::iterator ringit;</a>
<a name="ln3233">    vector&lt;int&gt; path;</a>
<a name="ln3234">    double torsions = 0.0;</a>
<a name="ln3235"> </a>
<a name="ln3236">    if (!HasSSSRPerceived())</a>
<a name="ln3237">      FindSSSR();</a>
<a name="ln3238">    rlist = GetSSSR();</a>
<a name="ln3239">    for (ringit = rlist.begin(); ringit != rlist.end(); ++ringit)</a>
<a name="ln3240">      {</a>
<a name="ln3241">        if ((*ringit)-&gt;PathSize() == 5)</a>
<a name="ln3242">          {</a>
<a name="ln3243">            path = (*ringit)-&gt;_path;</a>
<a name="ln3244">            torsions =</a>
<a name="ln3245">              ( fabs(GetTorsion(path[0], path[1], path[2], path[3])) +</a>
<a name="ln3246">                fabs(GetTorsion(path[1], path[2], path[3], path[4])) +</a>
<a name="ln3247">                fabs(GetTorsion(path[2], path[3], path[4], path[0])) +</a>
<a name="ln3248">                fabs(GetTorsion(path[3], path[4], path[0], path[1])) +</a>
<a name="ln3249">                fabs(GetTorsion(path[4], path[0], path[1], path[2])) ) / 5.0;</a>
<a name="ln3250">            if (torsions &lt;= 7.5)</a>
<a name="ln3251">              {</a>
<a name="ln3252">                for (unsigned int ringAtom = 0; ringAtom != path.size(); ++ringAtom)</a>
<a name="ln3253">                  {</a>
<a name="ln3254">                    b = GetAtom(path[ringAtom]);</a>
<a name="ln3255">                    // if an aromatic ring atom has valence 3, it is already set</a>
<a name="ln3256">                    // to sp2 because the average angles should be 120 anyway</a>
<a name="ln3257">                    // so only look for valence 2</a>
<a name="ln3258">                    if (b-&gt;GetExplicitDegree() == 2)</a>
<a name="ln3259">                      b-&gt;SetHyb(2);</a>
<a name="ln3260">                  }</a>
<a name="ln3261">              }</a>
<a name="ln3262">          }</a>
<a name="ln3263">        else if ((*ringit)-&gt;PathSize() == 6)</a>
<a name="ln3264">          {</a>
<a name="ln3265">            path = (*ringit)-&gt;_path;</a>
<a name="ln3266">            torsions =</a>
<a name="ln3267">              ( fabs(GetTorsion(path[0], path[1], path[2], path[3])) +</a>
<a name="ln3268">                fabs(GetTorsion(path[1], path[2], path[3], path[4])) +</a>
<a name="ln3269">                fabs(GetTorsion(path[2], path[3], path[4], path[5])) +</a>
<a name="ln3270">                fabs(GetTorsion(path[3], path[4], path[5], path[0])) +</a>
<a name="ln3271">                fabs(GetTorsion(path[4], path[5], path[0], path[1])) +</a>
<a name="ln3272">                fabs(GetTorsion(path[5], path[0], path[1], path[2])) ) / 6.0;</a>
<a name="ln3273">            if (torsions &lt;= 12.0)</a>
<a name="ln3274">              {</a>
<a name="ln3275">                for (unsigned int ringAtom = 0; ringAtom != path.size(); ++ringAtom)</a>
<a name="ln3276">                  {</a>
<a name="ln3277">                    b = GetAtom(path[ringAtom]);</a>
<a name="ln3278">                    if (b-&gt;GetExplicitDegree() == 2 || b-&gt;GetExplicitDegree() == 3)</a>
<a name="ln3279">                      b-&gt;SetHyb(2);</a>
<a name="ln3280">                  }</a>
<a name="ln3281">              }</a>
<a name="ln3282">          }</a>
<a name="ln3283">      }</a>
<a name="ln3284"> </a>
<a name="ln3285">    // Pass 3: &quot;Antialiasing&quot; If an atom marked as sp hybrid isn't</a>
<a name="ln3286">    //          bonded to another or an sp2 hybrid isn't bonded</a>
<a name="ln3287">    //          to another (or terminal atoms in both cases)</a>
<a name="ln3288">    //          mark them to a lower hybridization for now</a>
<a name="ln3289">    bool openNbr;</a>
<a name="ln3290">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3291">      {</a>
<a name="ln3292">        if (atom-&gt;GetHyb() == 2 || atom-&gt;GetHyb() == 1)</a>
<a name="ln3293">          {</a>
<a name="ln3294">            openNbr = false;</a>
<a name="ln3295">            for (b = atom-&gt;BeginNbrAtom(j); b; b = atom-&gt;NextNbrAtom(j))</a>
<a name="ln3296">              {</a>
<a name="ln3297">                if (b-&gt;GetHyb() &lt; 3 || b-&gt;GetExplicitDegree() == 1)</a>
<a name="ln3298">                  {</a>
<a name="ln3299">                    openNbr = true;</a>
<a name="ln3300">                    break;</a>
<a name="ln3301">                  }</a>
<a name="ln3302">              }</a>
<a name="ln3303">            if (!openNbr &amp;&amp; atom-&gt;GetHyb() == 2)</a>
<a name="ln3304">              atom-&gt;SetHyb(3);</a>
<a name="ln3305">            else if (!openNbr &amp;&amp; atom-&gt;GetHyb() == 1)</a>
<a name="ln3306">              atom-&gt;SetHyb(2);</a>
<a name="ln3307">          }</a>
<a name="ln3308">      } // pass 3</a>
<a name="ln3309"> </a>
<a name="ln3310">    // Pass 4: Check for known functional group patterns and assign bonds</a>
<a name="ln3311">    //         to the canonical form</a>
<a name="ln3312">    //      Currently we have explicit code to do this, but a &quot;bond typer&quot;</a>
<a name="ln3313">    //      is in progress to make it simpler to test and debug.</a>
<a name="ln3314">    bondtyper.AssignFunctionalGroupBonds(*this);</a>
<a name="ln3315"> </a>
<a name="ln3316">    // Pass 5: Check for aromatic rings and assign bonds as appropriate</a>
<a name="ln3317">    // This is just a quick and dirty approximation that marks everything</a>
<a name="ln3318">    //  as potentially aromatic</a>
<a name="ln3319"> </a>
<a name="ln3320">    // This doesn't work perfectly, but it's pretty decent.</a>
<a name="ln3321">    //  Need to have a list of SMARTS patterns for common rings</a>
<a name="ln3322">    //  which would &quot;break ties&quot; on complicated multi-ring systems</a>
<a name="ln3323">    // (Most of the current problems lie in the interface with the</a>
<a name="ln3324">    //   Kekulize code anyway, not in marking everything as potentially aromatic)</a>
<a name="ln3325"> </a>
<a name="ln3326">    bool needs_kekulization = false; // are there any aromatic bonds?</a>
<a name="ln3327">    bool typed; // has this ring been typed?</a>
<a name="ln3328">    unsigned int loop, loopSize;</a>
<a name="ln3329">    for (ringit = rlist.begin(); ringit != rlist.end(); ++ringit)</a>
<a name="ln3330">      {</a>
<a name="ln3331">        typed = false;</a>
<a name="ln3332">        loopSize = (*ringit)-&gt;PathSize();</a>
<a name="ln3333">        if (loopSize == 5 || loopSize == 6 || loopSize == 7)</a>
<a name="ln3334">          {</a>
<a name="ln3335">            path = (*ringit)-&gt;_path;</a>
<a name="ln3336">            for(loop = 0; loop &lt; loopSize; ++loop)</a>
<a name="ln3337">              {</a>
<a name="ln3338">                atom = GetAtom(path[loop]);</a>
<a name="ln3339">                if(atom-&gt;HasBondOfOrder(2) || atom-&gt;HasBondOfOrder(3)</a>
<a name="ln3340">                   || atom-&gt;GetHyb() != 2)</a>
<a name="ln3341">                  {</a>
<a name="ln3342">                    typed = true;</a>
<a name="ln3343">                    break;</a>
<a name="ln3344">                  }</a>
<a name="ln3345">              }</a>
<a name="ln3346"> </a>
<a name="ln3347">            if (!typed)</a>
<a name="ln3348">              for(loop = 0; loop &lt; loopSize; ++loop)</a>
<a name="ln3349">                {</a>
<a name="ln3350">                  //    cout &lt;&lt; &quot; set aromatic &quot; &lt;&lt; path[loop] &lt;&lt; endl;</a>
<a name="ln3351">                  (GetBond(path[loop], path[(loop+1) % loopSize]))-&gt;SetAromatic();</a>
<a name="ln3352">                  needs_kekulization = true;</a>
<a name="ln3353">                }</a>
<a name="ln3354">          }</a>
<a name="ln3355">      }</a>
<a name="ln3356"> </a>
<a name="ln3357">    // Kekulization is necessary if an aromatic bond is present</a>
<a name="ln3358">    if (needs_kekulization) {</a>
<a name="ln3359">      this-&gt;SetAromaticPerceived();</a>
<a name="ln3360">      // First of all, set the atoms at the ends of the aromatic bonds to also</a>
<a name="ln3361">      // be aromatic. This information is required for OBKekulize.</a>
<a name="ln3362">      FOR_BONDS_OF_MOL(bond, this) {</a>
<a name="ln3363">        if (bond-&gt;IsAromatic()) {</a>
<a name="ln3364">          bond-&gt;GetBeginAtom()-&gt;SetAromatic();</a>
<a name="ln3365">          bond-&gt;GetEndAtom()-&gt;SetAromatic();</a>
<a name="ln3366">        }</a>
<a name="ln3367">      }</a>
<a name="ln3368">      bool ok = OBKekulize(this);</a>
<a name="ln3369">      if (!ok) {</a>
<a name="ln3370">        stringstream errorMsg;</a>
<a name="ln3371">        errorMsg &lt;&lt; &quot;Failed to kekulize aromatic bonds in OBMol::PerceiveBondOrders&quot;;</a>
<a name="ln3372">        std::string title = this-&gt;GetTitle();</a>
<a name="ln3373">        if (!title.empty())</a>
<a name="ln3374">          errorMsg &lt;&lt; &quot; (title is &quot; &lt;&lt; title &lt;&lt; &quot;)&quot;;</a>
<a name="ln3375">        errorMsg &lt;&lt; endl;</a>
<a name="ln3376">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln3377">        // return false; Should we return false for a kekulization failure?</a>
<a name="ln3378">      }</a>
<a name="ln3379">      this-&gt;SetAromaticPerceived(false);</a>
<a name="ln3380">    }</a>
<a name="ln3381"> </a>
<a name="ln3382">    // Quick pass.. eliminate inter-ring sulfur atom multiple bonds</a>
<a name="ln3383">    // dkoes - I have removed this code - if double bonds are set,</a>
<a name="ln3384">    // we should trust them.  See pdb_ligands_sdf/4iph_1fj.sdf for</a>
<a name="ln3385">    // a case where the charge isn't set, but we break the molecule</a>
<a name="ln3386">    // if we remove the double bond.  Also, the previous code was</a>
<a name="ln3387">    // fragile - relying on the total mol charge being set.  If we</a>
<a name="ln3388">    // are going to do anything, we should &quot;perceive&quot; a formal charge</a>
<a name="ln3389">    // in the case of a ring sulfur with a double bond (thiopyrylium)</a>
<a name="ln3390"> </a>
<a name="ln3391">    // Pass 6: Assign remaining bond types, ordered by atom electronegativity</a>
<a name="ln3392">    vector&lt;pair&lt;OBAtom*,double&gt; &gt; sortedAtoms;</a>
<a name="ln3393">    vector&lt;double&gt; rad;</a>
<a name="ln3394">    vector&lt;int&gt; sorted;</a>
<a name="ln3395">    int iter, max;</a>
<a name="ln3396">    double maxElNeg, shortestBond, currentElNeg;</a>
<a name="ln3397">    double bondLength, testLength;</a>
<a name="ln3398"> </a>
<a name="ln3399">    for (atom = BeginAtom(i) ; atom ; atom = NextAtom(i))</a>
<a name="ln3400">      {</a>
<a name="ln3401">        // if atoms have the same electronegativity, make sure those with shorter bonds</a>
<a name="ln3402">        // are handled first (helps with assignment of conjugated single/double bonds)</a>
<a name="ln3403">        shortestBond = 1.0e5;</a>
<a name="ln3404">        for (b = atom-&gt;BeginNbrAtom(j); b; b = atom-&gt;NextNbrAtom(j))</a>
<a name="ln3405">          {</a>
<a name="ln3406">            if (b-&gt;GetAtomicNum()!=1) shortestBond =</a>
<a name="ln3407">                                        std::min(shortestBond,(atom-&gt;GetBond(b))-&gt;GetLength());</a>
<a name="ln3408">          }</a>
<a name="ln3409">        pair&lt;OBAtom*,double&gt; entry(atom,</a>
<a name="ln3410">                                   OBElements::GetElectroNeg(atom-&gt;GetAtomicNum())*1e6+shortestBond);</a>
<a name="ln3411"> </a>
<a name="ln3412">        sortedAtoms.push_back(entry);</a>
<a name="ln3413">      }</a>
<a name="ln3414">    sort(sortedAtoms.begin(), sortedAtoms.end(), SortAtomZ);</a>
<a name="ln3415"> </a>
<a name="ln3416">    max = sortedAtoms.size();</a>
<a name="ln3417">    for (iter = 0 ; iter &lt; max ; iter++ )</a>
<a name="ln3418">      {</a>
<a name="ln3419">        atom = sortedAtoms[iter].first;</a>
<a name="ln3420">        // Debugging statement</a>
<a name="ln3421">        //        cout &lt;&lt; &quot; atom-&gt;Hyb &quot; &lt;&lt; atom-&gt;GetAtomicNum() &lt;&lt; &quot; &quot; &lt;&lt; atom-&gt;GetIdx() &lt;&lt; &quot; &quot; &lt;&lt; atom-&gt;GetHyb()</a>
<a name="ln3422">        //             &lt;&lt; &quot; BO: &quot; &lt;&lt; atom-&gt;GetExplicitValence() &lt;&lt; endl;</a>
<a name="ln3423"> </a>
<a name="ln3424">        // Possible sp-hybrids</a>
<a name="ln3425">        if ( (atom-&gt;GetHyb() == 1 || atom-&gt;GetExplicitDegree() == 1)</a>
<a name="ln3426">             &amp;&amp; atom-&gt;GetExplicitValence() + 2  &lt;= static_cast&lt;unsigned int&gt;(OBElements::GetMaxBonds(atom-&gt;GetAtomicNum()))</a>
<a name="ln3427">             )</a>
<a name="ln3428">          {</a>
<a name="ln3429"> </a>
<a name="ln3430">            // loop through the neighbors looking for a hybrid or terminal atom</a>
<a name="ln3431">            // (and pick the one with highest electronegativity first)</a>
<a name="ln3432">            // *or* pick a neighbor that's a terminal atom</a>
<a name="ln3433">            if (atom-&gt;HasNonSingleBond() ||</a>
<a name="ln3434">                (atom-&gt;GetAtomicNum() == 7 &amp;&amp; atom-&gt;GetExplicitValence() + 2 &gt; 3))</a>
<a name="ln3435">              continue;</a>
<a name="ln3436"> </a>
<a name="ln3437">            maxElNeg = 0.0;</a>
<a name="ln3438">            shortestBond = 5000.0;</a>
<a name="ln3439">            c = nullptr;</a>
<a name="ln3440">            for (b = atom-&gt;BeginNbrAtom(j); b; b = atom-&gt;NextNbrAtom(j))</a>
<a name="ln3441">              {</a>
<a name="ln3442">                currentElNeg = OBElements::GetElectroNeg(b-&gt;GetAtomicNum());</a>
<a name="ln3443">                if ( (b-&gt;GetHyb() == 1 || b-&gt;GetExplicitDegree() == 1)</a>
<a name="ln3444">                     &amp;&amp; b-&gt;GetExplicitValence() + 2 &lt;= static_cast&lt;unsigned int&gt;(OBElements::GetMaxBonds(b-&gt;GetAtomicNum()))</a>
<a name="ln3445">                     &amp;&amp; (currentElNeg &gt; maxElNeg ||</a>
<a name="ln3446">                         (IsApprox(currentElNeg,maxElNeg, 1.0e-6)</a>
<a name="ln3447">                          &amp;&amp; (atom-&gt;GetBond(b))-&gt;GetLength() &lt; shortestBond)) )</a>
<a name="ln3448">                  {</a>
<a name="ln3449">                    if (b-&gt;HasNonSingleBond() ||</a>
<a name="ln3450">                        (b-&gt;GetAtomicNum() == 7 &amp;&amp; b-&gt;GetExplicitValence() + 2 &gt; 3))</a>
<a name="ln3451">                      continue;</a>
<a name="ln3452"> </a>
<a name="ln3453">                    // Test terminal bonds against expected triple bond lengths</a>
<a name="ln3454">                    bondLength = (atom-&gt;GetBond(b))-&gt;GetLength();</a>
<a name="ln3455">                    if (atom-&gt;GetExplicitDegree() == 1 || b-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln3456">                      testLength = CorrectedBondRad(atom-&gt;GetAtomicNum(), atom-&gt;GetHyb())</a>
<a name="ln3457">                        + CorrectedBondRad(b-&gt;GetAtomicNum(), b-&gt;GetHyb());</a>
<a name="ln3458">                      if (bondLength &gt; 0.9 * testLength)</a>
<a name="ln3459">                        continue; // too long, ignore it</a>
<a name="ln3460">                    }</a>
<a name="ln3461"> </a>
<a name="ln3462">                    shortestBond = bondLength;</a>
<a name="ln3463">                    maxElNeg = OBElements::GetElectroNeg(b-&gt;GetAtomicNum());</a>
<a name="ln3464">                    c = b; // save this atom for later use</a>
<a name="ln3465">                  }</a>
<a name="ln3466">              }</a>
<a name="ln3467">            if (c)</a>
<a name="ln3468">              (atom-&gt;GetBond(c))-&gt;SetBondOrder(3);</a>
<a name="ln3469">          }</a>
<a name="ln3470">        // Possible sp2-hybrid atoms</a>
<a name="ln3471">        else if ( (atom-&gt;GetHyb() == 2 || atom-&gt;GetExplicitDegree() == 1)</a>
<a name="ln3472">                  &amp;&amp; atom-&gt;GetExplicitValence() + 1 &lt;= static_cast&lt;unsigned int&gt;(OBElements::GetMaxBonds(atom-&gt;GetAtomicNum())) )</a>
<a name="ln3473">          {</a>
<a name="ln3474">            // as above</a>
<a name="ln3475">            if (atom-&gt;HasNonSingleBond() ||</a>
<a name="ln3476">                (atom-&gt;GetAtomicNum() == 7 &amp;&amp; atom-&gt;GetExplicitValence() + 1 &gt; 3))</a>
<a name="ln3477">              continue;</a>
<a name="ln3478"> </a>
<a name="ln3479">            // Don't build multiple bonds to ring sulfurs</a>
<a name="ln3480">            //  except thiopyrylium</a>
<a name="ln3481">            if (atom-&gt;IsInRing() &amp;&amp; atom-&gt;GetAtomicNum() == 16) {</a>
<a name="ln3482">              if (_totalCharge &gt; 1 &amp;&amp; atom-&gt;GetFormalCharge() == 0)</a>
<a name="ln3483">                atom-&gt;SetFormalCharge(+1);</a>
<a name="ln3484">              else</a>
<a name="ln3485">                continue;</a>
<a name="ln3486">            }</a>
<a name="ln3487"> </a>
<a name="ln3488">            maxElNeg = 0.0;</a>
<a name="ln3489">            shortestBond = 5000.0;</a>
<a name="ln3490">            c = nullptr;</a>
<a name="ln3491">            for (b = atom-&gt;BeginNbrAtom(j); b; b = atom-&gt;NextNbrAtom(j))</a>
<a name="ln3492">              {</a>
<a name="ln3493">                currentElNeg = OBElements::GetElectroNeg(b-&gt;GetAtomicNum());</a>
<a name="ln3494">                if ( (b-&gt;GetHyb() == 2 || b-&gt;GetExplicitDegree() == 1)</a>
<a name="ln3495">                     &amp;&amp; b-&gt;GetExplicitValence() + 1 &lt;= static_cast&lt;unsigned int&gt;(OBElements::GetMaxBonds(b-&gt;GetAtomicNum()))</a>
<a name="ln3496">                     &amp;&amp; (GetBond(atom, b))-&gt;IsDoubleBondGeometry()</a>
<a name="ln3497">                     &amp;&amp; (currentElNeg &gt; maxElNeg || (IsApprox(currentElNeg,maxElNeg, 1.0e-6)) ) )</a>
<a name="ln3498">                  {</a>
<a name="ln3499">                    if (b-&gt;HasNonSingleBond() ||</a>
<a name="ln3500">                        (b-&gt;GetAtomicNum() == 7 &amp;&amp; b-&gt;GetExplicitValence() + 1 &gt; 3))</a>
<a name="ln3501">                      continue;</a>
<a name="ln3502"> </a>
<a name="ln3503">                    if (b-&gt;IsInRing() &amp;&amp; b-&gt;GetAtomicNum() == 16) {</a>
<a name="ln3504">                      if (_totalCharge &gt; 1 &amp;&amp; b-&gt;GetFormalCharge() == 0)</a>
<a name="ln3505">                        b-&gt;SetFormalCharge(+1);</a>
<a name="ln3506">                      else</a>
<a name="ln3507">                        continue;</a>
<a name="ln3508">                    }</a>
<a name="ln3509"> </a>
<a name="ln3510">                    // Test terminal bonds against expected double bond lengths</a>
<a name="ln3511">                    bondLength = (atom-&gt;GetBond(b))-&gt;GetLength();</a>
<a name="ln3512">                    if (atom-&gt;GetExplicitDegree() == 1 || b-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln3513">                      testLength = CorrectedBondRad(atom-&gt;GetAtomicNum(), atom-&gt;GetHyb())</a>
<a name="ln3514">                        + CorrectedBondRad(b-&gt;GetAtomicNum(), b-&gt;GetHyb());</a>
<a name="ln3515">                      if (bondLength &gt; 0.93 * testLength)</a>
<a name="ln3516">                        continue; // too long, ignore it</a>
<a name="ln3517">                    }</a>
<a name="ln3518"> </a>
<a name="ln3519">                    // OK, see if this is better than the previous choice</a>
<a name="ln3520">                    // If it's much shorter, pick it (e.g., fulvene)</a>
<a name="ln3521">                    // If they're close (0.1A) then prefer the bond in the ring</a>
<a name="ln3522">                    double difference = shortestBond - (atom-&gt;GetBond(b))-&gt;GetLength();</a>
<a name="ln3523">                    if ( (difference &gt; 0.1)</a>
<a name="ln3524">                         || ( (difference &gt; -0.01) &amp;&amp;</a>
<a name="ln3525">                              ( (!atom-&gt;IsInRing() || !c || !c-&gt;IsInRing() || b-&gt;IsInRing())</a>
<a name="ln3526">                                || (atom-&gt;IsInRing() &amp;&amp; c &amp;&amp; !c-&gt;IsInRing() &amp;&amp; b-&gt;IsInRing()) ) ) ) {</a>
<a name="ln3527">                      shortestBond = (atom-&gt;GetBond(b))-&gt;GetLength();</a>
<a name="ln3528">                      maxElNeg = OBElements::GetElectroNeg(b-&gt;GetAtomicNum());</a>
<a name="ln3529">                      c = b; // save this atom for later use</a>
<a name="ln3530">                    } // is this bond better than previous choices</a>
<a name="ln3531">                  }</a>
<a name="ln3532">              } // loop through neighbors</a>
<a name="ln3533">            if (c)</a>
<a name="ln3534">              (atom-&gt;GetBond(c))-&gt;SetBondOrder(2);</a>
<a name="ln3535">          }</a>
<a name="ln3536">      } // pass 6</a>
<a name="ln3537"> </a>
<a name="ln3538">    // Now let the atom typer go to work again</a>
<a name="ln3539">    _flags &amp;= (~(OB_HYBRID_MOL));</a>
<a name="ln3540">    _flags &amp;= (~(OB_AROMATIC_MOL));</a>
<a name="ln3541">    _flags &amp;= (~(OB_ATOMTYPES_MOL));</a>
<a name="ln3542">    //  EndModify(true); // &quot;nuke&quot; perceived data</a>
<a name="ln3543"> </a>
<a name="ln3544">    //Set _spinMultiplicity other than zero for atoms which are hydrogen</a>
<a name="ln3545">    //deficient and which have implicit valency definitions (essentially the</a>
<a name="ln3546">    //organic subset in SMILES). There are assumed to no implicit hydrogens.</a>
<a name="ln3547">    //AssignSpinMultiplicity(true); // TODO: sort out radicals</a>
<a name="ln3548">    }</a>
<a name="ln3549"> </a>
<a name="ln3550">  void OBMol::Center()</a>
<a name="ln3551">  {</a>
<a name="ln3552">    for (int i = 0;i &lt; NumConformers();++i)</a>
<a name="ln3553">      Center(i);</a>
<a name="ln3554">  }</a>
<a name="ln3555"> </a>
<a name="ln3556">  vector3 OBMol::Center(int nconf)</a>
<a name="ln3557">  {</a>
<a name="ln3558">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln3559">                          &quot;Ran OpenBabel::Center&quot;, obAuditMsg);</a>
<a name="ln3560"> </a>
<a name="ln3561">    SetConformer(nconf);</a>
<a name="ln3562"> </a>
<a name="ln3563">    OBAtom *atom;</a>
<a name="ln3564">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln3565"> </a>
<a name="ln3566">    double x=0.0,y=0.0,z=0.0;</a>
<a name="ln3567">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3568">      {</a>
<a name="ln3569">        x += atom-&gt;x();</a>
<a name="ln3570">        y += atom-&gt;y();</a>
<a name="ln3571">        z += atom-&gt;z();</a>
<a name="ln3572">      }</a>
<a name="ln3573"> </a>
<a name="ln3574">    x /= (double)NumAtoms();</a>
<a name="ln3575">    y /= (double)NumAtoms();</a>
<a name="ln3576">    z /= (double)NumAtoms();</a>
<a name="ln3577"> </a>
<a name="ln3578">    vector3 vtmp;</a>
<a name="ln3579">    vector3 v(x,y,z);</a>
<a name="ln3580"> </a>
<a name="ln3581">    for (atom = BeginAtom(i);atom;atom = NextAtom(i))</a>
<a name="ln3582">      {</a>
<a name="ln3583">        vtmp = atom-&gt;GetVector() - v;</a>
<a name="ln3584">        atom-&gt;SetVector(vtmp);</a>
<a name="ln3585">      }</a>
<a name="ln3586"> </a>
<a name="ln3587">    return(v);</a>
<a name="ln3588">  }</a>
<a name="ln3589"> </a>
<a name="ln3590"> </a>
<a name="ln3591">  /*! this method adds the vector v to all atom positions in all conformers */</a>
<a name="ln3592">  void OBMol::Translate(const vector3 &amp;v)</a>
<a name="ln3593">  {</a>
<a name="ln3594">    for (int i = 0;i &lt; NumConformers();++i)</a>
<a name="ln3595">      Translate(v,i);</a>
<a name="ln3596">  }</a>
<a name="ln3597"> </a>
<a name="ln3598">  /*! this method adds the vector v to all atom positions in the</a>
<a name="ln3599">    conformer nconf. If nconf == OB_CURRENT_CONFORMER, then the atom</a>
<a name="ln3600">    positions in the current conformer are translated. */</a>
<a name="ln3601">  void OBMol::Translate(const vector3 &amp;v, int nconf)</a>
<a name="ln3602">  {</a>
<a name="ln3603">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln3604">                          &quot;Ran OpenBabel::Translate&quot;, obAuditMsg);</a>
<a name="ln3605"> </a>
<a name="ln3606">    int i,size;</a>
<a name="ln3607">    double x,y,z;</a>
<a name="ln3608">    double *c = (nconf == OB_CURRENT_CONFORMER)? _c : GetConformer(nconf);</a>
<a name="ln3609"> </a>
<a name="ln3610">    x = v.x();</a>
<a name="ln3611">    y = v.y();</a>
<a name="ln3612">    z = v.z();</a>
<a name="ln3613">    size = NumAtoms();</a>
<a name="ln3614">    for (i = 0;i &lt; size;++i)</a>
<a name="ln3615">      {</a>
<a name="ln3616">        c[i*3  ] += x;</a>
<a name="ln3617">        c[i*3+1] += y;</a>
<a name="ln3618">        c[i*3+2] += z;</a>
<a name="ln3619">      }</a>
<a name="ln3620">  }</a>
<a name="ln3621"> </a>
<a name="ln3622">  void OBMol::Rotate(const double u[3][3])</a>
<a name="ln3623">  {</a>
<a name="ln3624">    int i,j,k;</a>
<a name="ln3625">    double m[9];</a>
<a name="ln3626">    for (k=0,i = 0;i &lt; 3;++i)</a>
<a name="ln3627">      for (j = 0;j &lt; 3;++j)</a>
<a name="ln3628">        m[k++] = u[i][j];</a>
<a name="ln3629"> </a>
<a name="ln3630">    for (i = 0;i &lt; NumConformers();++i)</a>
<a name="ln3631">      Rotate(m,i);</a>
<a name="ln3632">  }</a>
<a name="ln3633"> </a>
<a name="ln3634">  void OBMol::Rotate(const double m[9])</a>
<a name="ln3635">  {</a>
<a name="ln3636">    for (int i = 0;i &lt; NumConformers();++i)</a>
<a name="ln3637">      Rotate(m,i);</a>
<a name="ln3638">  }</a>
<a name="ln3639"> </a>
<a name="ln3640">  void OBMol::Rotate(const double m[9],int nconf)</a>
<a name="ln3641">  {</a>
<a name="ln3642">    int i,size;</a>
<a name="ln3643">    double x,y,z;</a>
<a name="ln3644">    double *c = (nconf == OB_CURRENT_CONFORMER)? _c : GetConformer(nconf);</a>
<a name="ln3645"> </a>
<a name="ln3646">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln3647">                          &quot;Ran OpenBabel::Rotate&quot;, obAuditMsg);</a>
<a name="ln3648"> </a>
<a name="ln3649">    size = NumAtoms();</a>
<a name="ln3650">    for (i = 0;i &lt; size;++i)</a>
<a name="ln3651">      {</a>
<a name="ln3652">        x = c[i*3  ];</a>
<a name="ln3653">        y = c[i*3+1];</a>
<a name="ln3654">        z = c[i*3+2];</a>
<a name="ln3655">        c[i*3  ] = m[0]*x + m[1]*y + m[2]*z;</a>
<a name="ln3656">        c[i*3+1] = m[3]*x + m[4]*y + m[5]*z;</a>
<a name="ln3657">        c[i*3+2] = m[6]*x + m[7]*y + m[8]*z;</a>
<a name="ln3658">      }</a>
<a name="ln3659">  }</a>
<a name="ln3660"> </a>
<a name="ln3661">  void OBMol::SetEnergies(std::vector&lt;double&gt; &amp;energies)</a>
<a name="ln3662">  {</a>
<a name="ln3663">    if (!HasData(OBGenericDataType::ConformerData))</a>
<a name="ln3664">      SetData(new OBConformerData);</a>
<a name="ln3665">    OBConformerData *cd = (OBConformerData*) GetData(OBGenericDataType::ConformerData);</a>
<a name="ln3666">    cd-&gt;SetEnergies(energies);</a>
<a name="ln3667">  }</a>
<a name="ln3668"> </a>
<a name="ln3669">  vector&lt;double&gt; OBMol::GetEnergies()</a>
<a name="ln3670">  {</a>
<a name="ln3671">    if (!HasData(OBGenericDataType::ConformerData))</a>
<a name="ln3672">      SetData(new OBConformerData);</a>
<a name="ln3673">    OBConformerData *cd = (OBConformerData*) GetData(OBGenericDataType::ConformerData);</a>
<a name="ln3674">    vector&lt;double&gt; energies = cd-&gt;GetEnergies();</a>
<a name="ln3675"> </a>
<a name="ln3676">    return energies;</a>
<a name="ln3677">  }</a>
<a name="ln3678"> </a>
<a name="ln3679">  double OBMol::GetEnergy(int ci)</a>
<a name="ln3680">  {</a>
<a name="ln3681">    if (!HasData(OBGenericDataType::ConformerData))</a>
<a name="ln3682">      SetData(new OBConformerData);</a>
<a name="ln3683">    OBConformerData *cd = (OBConformerData*) GetData(OBGenericDataType::ConformerData);</a>
<a name="ln3684">    vector&lt;double&gt; energies = cd-&gt;GetEnergies();</a>
<a name="ln3685"> </a>
<a name="ln3686">    if (((unsigned int)ci &gt;= energies.size()) || (ci &lt; 0))</a>
<a name="ln3687">      return 0.0;</a>
<a name="ln3688"> </a>
<a name="ln3689">    return energies[ci];</a>
<a name="ln3690">  }</a>
<a name="ln3691"> </a>
<a name="ln3692">  void OBMol::SetConformers(vector&lt;double*&gt; &amp;v)</a>
<a name="ln3693">  {</a>
<a name="ln3694">    vector&lt;double*&gt;::iterator i;</a>
<a name="ln3695">    for (i = _vconf.begin();i != _vconf.end();++i)</a>
<a name="ln3696">      delete [] *i;</a>
<a name="ln3697"> </a>
<a name="ln3698">    _vconf = v;</a>
<a name="ln3699">    _c = _vconf.empty() ? nullptr : _vconf[0];</a>
<a name="ln3700"> </a>
<a name="ln3701">  }</a>
<a name="ln3702"> </a>
<a name="ln3703">  void OBMol::SetConformer(unsigned int i)</a>
<a name="ln3704">  {</a>
<a name="ln3705">    if (i &lt; _vconf.size())</a>
<a name="ln3706">      _c = _vconf[i];</a>
<a name="ln3707">  }</a>
<a name="ln3708"> </a>
<a name="ln3709">  void OBMol::CopyConformer(double *c,int idx)</a>
<a name="ln3710">  {</a>
<a name="ln3711">    //    obAssert(!_vconf.empty() &amp;&amp; (unsigned)idx &lt; _vconf.size());</a>
<a name="ln3712">    memcpy((char*)c, (char*)_vconf[idx], sizeof(double)*3*NumAtoms());</a>
<a name="ln3713">  }</a>
<a name="ln3714"> </a>
<a name="ln3715">  // void OBMol::CopyConformer(double *c,int idx)</a>
<a name="ln3716">  // {</a>
<a name="ln3717">  //   obAssert(!_vconf.empty() &amp;&amp; (unsigned)idx &lt; _vconf.size());</a>
<a name="ln3718"> </a>
<a name="ln3719">  //   unsigned int i;</a>
<a name="ln3720">  //   for (i = 0;i &lt; NumAtoms();++i)</a>
<a name="ln3721">  //     {</a>
<a name="ln3722">  //       _vconf[idx][i*3  ] = (double)c[i*3  ];</a>
<a name="ln3723">  //       _vconf[idx][i*3+1] = (double)c[i*3+1];</a>
<a name="ln3724">  //       _vconf[idx][i*3+2] = (double)c[i*3+2];</a>
<a name="ln3725">  //     }</a>
<a name="ln3726">  // }</a>
<a name="ln3727"> </a>
<a name="ln3728">  void OBMol::DeleteConformer(int idx)</a>
<a name="ln3729">  {</a>
<a name="ln3730">    if (idx &lt; 0 || idx &gt;= (signed)_vconf.size())</a>
<a name="ln3731">      return;</a>
<a name="ln3732"> </a>
<a name="ln3733">    delete [] _vconf[idx];</a>
<a name="ln3734">    _vconf.erase((_vconf.begin()+idx));</a>
<a name="ln3735">  }</a>
<a name="ln3736"> </a>
<a name="ln3737">  ///Converts for instance [N+]([O-])=O to N(=O)=O</a>
<a name="ln3738">  bool OBMol::ConvertDativeBonds()</a>
<a name="ln3739">  {</a>
<a name="ln3740">    obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln3741">                          &quot;Ran OpenBabel::ConvertDativeBonds&quot;, obAuditMsg);</a>
<a name="ln3742"> </a>
<a name="ln3743">    //Look for + and - charges on adjacent atoms</a>
<a name="ln3744">    OBAtom* patom;</a>
<a name="ln3745">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln3746">    bool converted = false;</a>
<a name="ln3747">    for (patom = BeginAtom(i);patom;patom = NextAtom(i))</a>
<a name="ln3748">      {</a>
<a name="ln3749">        vector&lt;OBBond*&gt;::iterator itr;</a>
<a name="ln3750">        OBBond *pbond;</a>
<a name="ln3751">        for (pbond = patom-&gt;BeginBond(itr);patom-&gt;GetFormalCharge() &amp;&amp; pbond;pbond = patom-&gt;NextBond(itr))</a>
<a name="ln3752">          {</a>
<a name="ln3753">            OBAtom* pNbratom = pbond-&gt;GetNbrAtom(patom);</a>
<a name="ln3754">            int chg1 = patom-&gt;GetFormalCharge();</a>
<a name="ln3755">            int chg2 = pNbratom-&gt;GetFormalCharge();</a>
<a name="ln3756">            if((chg1&gt;0 &amp;&amp; chg2&lt;0)|| (chg1&lt;0 &amp;&amp; chg2&gt;0))</a>
<a name="ln3757">              {</a>
<a name="ln3758">                //dative bond. Reduce charges and increase bond order</a>
<a name="ln3759">                converted =true;</a>
<a name="ln3760">                if(chg1&gt;0)</a>
<a name="ln3761">                  --chg1;</a>
<a name="ln3762">                else</a>
<a name="ln3763">                  ++chg1;</a>
<a name="ln3764">                patom-&gt;SetFormalCharge(chg1);</a>
<a name="ln3765">                if(chg2&gt;0)</a>
<a name="ln3766">                  --chg2;</a>
<a name="ln3767">                else</a>
<a name="ln3768">                  ++chg2;</a>
<a name="ln3769">                pNbratom-&gt;SetFormalCharge(chg2);</a>
<a name="ln3770">                pbond-&gt;SetBondOrder(pbond-&gt;GetBondOrder()+1);</a>
<a name="ln3771">              }</a>
<a name="ln3772">          }</a>
<a name="ln3773">      }</a>
<a name="ln3774">    return converted; //false if no changes made</a>
<a name="ln3775">  }</a>
<a name="ln3776"> </a>
<a name="ln3777">  static bool IsNotCorH(OBAtom* atom)</a>
<a name="ln3778">  {</a>
<a name="ln3779">    switch (atom-&gt;GetAtomicNum())</a>
<a name="ln3780">    {</a>
<a name="ln3781">    case OBElements::Hydrogen:</a>
<a name="ln3782">    case OBElements::Carbon:</a>
<a name="ln3783">      return false;</a>
<a name="ln3784">    }</a>
<a name="ln3785">    return true;</a>
<a name="ln3786">  }</a>
<a name="ln3787"> </a>
<a name="ln3788">  //This maybe would be better using smirks from a datafile</a>
<a name="ln3789">  bool OBMol::MakeDativeBonds()</a>
<a name="ln3790">  {</a>
<a name="ln3791">    //! Converts 5-valent N to charged form of dative bonds,</a>
<a name="ln3792">    //! e.g. -N(=O)=O converted to -[N+]([O-])=O. Returns true if conversion occurs.</a>
<a name="ln3793">    BeginModify();</a>
<a name="ln3794">    //AddHydrogens();</a>
<a name="ln3795">    bool converted = false;</a>
<a name="ln3796">    OBAtom* patom;</a>
<a name="ln3797">    vector&lt;OBAtom*&gt;::iterator ai;</a>
<a name="ln3798">    for (patom = BeginAtom(ai);patom;patom = NextAtom(ai)) //all atoms</a>
<a name="ln3799">    {</a>
<a name="ln3800">      if(patom-&gt;GetAtomicNum() == OBElements::Nitrogen // || patom-&gt;GetAtomicNum() == OBElements::Phosphorus) not phosphorus!</a>
<a name="ln3801">        &amp;&amp; (patom-&gt;GetExplicitValence()==5 || (patom-&gt;GetExplicitValence()==4 &amp;&amp; patom-&gt;GetFormalCharge()==0)))</a>
<a name="ln3802">      {</a>
<a name="ln3803">        // Find the bond to be modified. Prefer a bond to a hetero-atom,</a>
<a name="ln3804">        // and the highest order bond if there is a choice.</a>
<a name="ln3805">        OBBond *bond, *bestbond;</a>
<a name="ln3806">        OBBondIterator bi;</a>
<a name="ln3807">        for (bestbond = bond = patom-&gt;BeginBond(bi); bond; bond = patom-&gt;NextBond(bi))</a>
<a name="ln3808">        {</a>
<a name="ln3809">          unsigned int bo = bond-&gt;GetBondOrder();</a>
<a name="ln3810">          if(bo&gt;=2 &amp;&amp; bo&lt;=4)</a>
<a name="ln3811">          {</a>
<a name="ln3812">            bool het = IsNotCorH(bond-&gt;GetNbrAtom(patom));</a>
<a name="ln3813">            bool oldhet = IsNotCorH(bestbond-&gt;GetNbrAtom(patom));</a>
<a name="ln3814">            bool higherorder = bo &gt; bestbond-&gt;GetBondOrder();</a>
<a name="ln3815">            if((het &amp;&amp; !oldhet) || (((het &amp;&amp; oldhet) || (!het &amp;&amp; !oldhet)) &amp;&amp; higherorder))</a>
<a name="ln3816">              bestbond = bond;</a>
<a name="ln3817">          }</a>
<a name="ln3818">        }</a>
<a name="ln3819">        //Make the charged form</a>
<a name="ln3820">        bestbond-&gt;SetBondOrder(bestbond-&gt;GetBondOrder()-1);</a>
<a name="ln3821">        patom-&gt;SetFormalCharge(+1);</a>
<a name="ln3822">        OBAtom* at = bestbond-&gt;GetNbrAtom(patom);</a>
<a name="ln3823">        at-&gt;SetFormalCharge(-1);</a>
<a name="ln3824">        converted=true;</a>
<a name="ln3825">      }</a>
<a name="ln3826">    }</a>
<a name="ln3827">    EndModify();</a>
<a name="ln3828">    return converted;</a>
<a name="ln3829">  }</a>
<a name="ln3830"> </a>
<a name="ln3831">  /**</a>
<a name="ln3832">   *  This function is useful when writing to legacy formats (such as MDL MOL) that do</a>
<a name="ln3833">   *  not support zero-order bonds. It is worth noting that some compounds cannot be</a>
<a name="ln3834">   *  well represented using just single, double and triple bonds, even with adjustments</a>
<a name="ln3835">   *  to adjacent charges. In these cases, simply converting zero-order bonds to single</a>
<a name="ln3836">   *  bonds is all that can be done.</a>
<a name="ln3837">   *</a>
<a name="ln3838">   @verbatim</a>
<a name="ln3839">   Algorithm from:</a>
<a name="ln3840">   Clark, A. M. Accurate Specification of Molecular Structures: The Case for</a>
<a name="ln3841">   Zero-Order Bonds and Explicit Hydrogen Counting. Journal of Chemical Information</a>
<a name="ln3842">   and Modeling, 51, 3149-3157 (2011). http://pubs.acs.org/doi/abs/10.1021/ci200488k</a>
<a name="ln3843">   @endverbatim</a>
<a name="ln3844">  */</a>
<a name="ln3845">  bool OBMol::ConvertZeroBonds()</a>
<a name="ln3846">  {</a>
<a name="ln3847">    // TODO: Option to just remove zero-order bonds entirely</a>
<a name="ln3848"> </a>
<a name="ln3849">    // TODO: Is it OK to not wrap this in BeginModify() and EndModify()?</a>
<a name="ln3850">    // If we must, I think we need to manually remember HasImplicitValencePerceived and</a>
<a name="ln3851">    // re-set it after EndModify()</a>
<a name="ln3852"> </a>
<a name="ln3853">    // Periodic table block for element (1=s, 2=p, 3=d, 4=f)</a>
<a name="ln3854">    const int BLOCKS[113] = {0,1,2,1,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,1,3,3,3,3,3,3,3,3,3,</a>
<a name="ln3855">                             3,2,2,2,2,2,2,1,1,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,1,1,4,4,4,</a>
<a name="ln3856">                             4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,1,1,4,</a>
<a name="ln3857">                             4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3};</a>
<a name="ln3858"> </a>
<a name="ln3859">    bool converted = false;</a>
<a name="ln3860">    // Get contiguous fragments of molecule</a>
<a name="ln3861">    vector&lt;vector&lt;int&gt; &gt; cfl;</a>
<a name="ln3862">    ContigFragList(cfl);</a>
<a name="ln3863">    // Iterate over contiguous fragments</a>
<a name="ln3864">    for (vector&lt; vector&lt;int&gt; &gt;::iterator i = cfl.begin(); i != cfl.end(); ++i) {</a>
<a name="ln3865">      // Get all zero-order bonds in contiguous fragment</a>
<a name="ln3866">      vector&lt;OBBond*&gt; bonds;</a>
<a name="ln3867">      for(vector&lt;int&gt;::const_iterator j = i-&gt;begin(); j != i-&gt;end(); ++j) {</a>
<a name="ln3868">        FOR_BONDS_OF_ATOM(b, GetAtom(*j)) {</a>
<a name="ln3869">          if (b-&gt;GetBondOrder() == 0 &amp;&amp; !(find(bonds.begin(), bonds.end(), &amp;*b) != bonds.end())) {</a>
<a name="ln3870">            bonds.push_back(&amp;*b);</a>
<a name="ln3871">          }</a>
<a name="ln3872">        }</a>
<a name="ln3873">      }</a>
<a name="ln3874">      // Convert zero-order bonds</a>
<a name="ln3875">      while (bonds.size() &gt; 0) {</a>
<a name="ln3876">        // Pick a bond using scoring system</a>
<a name="ln3877">        int bi = 0;</a>
<a name="ln3878">        if (bonds.size() &gt; 1) {</a>
<a name="ln3879">          vector&lt;int&gt; scores(bonds.size());</a>
<a name="ln3880">          for (unsigned int n = 0; n &lt; bonds.size(); n++) {</a>
<a name="ln3881">            OBAtom *bgn = bonds[n]-&gt;GetBeginAtom();</a>
<a name="ln3882">            OBAtom *end = bonds[n]-&gt;GetEndAtom();</a>
<a name="ln3883">            int score = 0;</a>
<a name="ln3884">            score += bgn-&gt;GetAtomicNum() + end-&gt;GetAtomicNum();</a>
<a name="ln3885">            score += abs(bgn-&gt;GetFormalCharge()) + abs(end-&gt;GetFormalCharge());</a>
<a name="ln3886">            pair&lt;int, int&gt; lb = bgn-&gt;LewisAcidBaseCounts();</a>
<a name="ln3887">            pair&lt;int, int&gt; le = end-&gt;LewisAcidBaseCounts();</a>
<a name="ln3888">            if (lb.first &gt; 0 &amp;&amp; lb.second &gt; 0 &amp;&amp; le.first &gt; 0 &amp;&amp; le.second &gt; 0) {</a>
<a name="ln3889">              score += 100;   // Both atoms are Lewis acids *and* Lewis bases</a>
<a name="ln3890">            } else if ((lb.first &gt; 0 &amp;&amp; le.second &gt; 0) &amp;&amp; (lb.second &gt; 0 &amp;&amp; le.first &gt; 0)) {</a>
<a name="ln3891">              score -= 1000;  // Lewis acid/base direction is mono-directional</a>
<a name="ln3892">            }</a>
<a name="ln3893">            int bcount = bgn-&gt;GetImplicitHCount();</a>
<a name="ln3894">            FOR_BONDS_OF_ATOM(b, bgn) { bcount += 1; }</a>
<a name="ln3895">            int ecount = end-&gt;GetImplicitHCount();</a>
<a name="ln3896">            FOR_BONDS_OF_ATOM(b, end) { ecount += 1; }</a>
<a name="ln3897">            if (bcount == 1 || ecount == 1) {</a>
<a name="ln3898">              score -= 10; // If the start or end atoms have only 1 neighbour</a>
<a name="ln3899">            }</a>
<a name="ln3900">            scores[n] = score;</a>
<a name="ln3901">          }</a>
<a name="ln3902">          for (unsigned int n = 1; n &lt; scores.size(); n++) {</a>
<a name="ln3903">            if (scores[n] &lt; scores[bi]) {</a>
<a name="ln3904">              bi = n;</a>
<a name="ln3905">            }</a>
<a name="ln3906">          }</a>
<a name="ln3907">        }</a>
<a name="ln3908">        OBBond *bond = bonds[bi];</a>
<a name="ln3909">        bonds.erase(bonds.begin() + bi);</a>
<a name="ln3910">        OBAtom *bgn = bond-&gt;GetBeginAtom();</a>
<a name="ln3911">        OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln3912">        int blockb = BLOCKS[bgn-&gt;GetAtomicNum()];</a>
<a name="ln3913">        int blocke = BLOCKS[end-&gt;GetAtomicNum()];;</a>
<a name="ln3914">        pair&lt;int, int&gt; lb = bgn-&gt;LewisAcidBaseCounts();</a>
<a name="ln3915">        pair&lt;int, int&gt; le = end-&gt;LewisAcidBaseCounts();</a>
<a name="ln3916">        int chg = 0; // Amount to adjust atom charges</a>
<a name="ln3917">        int ord = 1; // New bond order</a>
<a name="ln3918">        if (lb.first &gt; 0 &amp;&amp; lb.second &gt; 0 &amp;&amp; le.first &gt; 0 &amp;&amp; le.second &gt; 0) {</a>
<a name="ln3919">          ord = 2;  // both atoms are amphoteric, so turn it into a double bond</a>
<a name="ln3920">        } else if (lb.first &gt; 0 &amp;&amp; blockb == 2 &amp;&amp; blocke &gt;= 3) {</a>
<a name="ln3921">          ord = 2;  // p-block lewis acid with d/f-block element: make into double bond</a>
<a name="ln3922">        } else if (le.first &gt; 0 &amp;&amp; blocke == 2 &amp;&amp; blockb &gt;= 3) {</a>
<a name="ln3923">          ord = 2;  // p-block lewis acid with d/f-block element: make into double bond</a>
<a name="ln3924">        } else if (lb.first &gt; 0 &amp;&amp; le.second &gt; 0) {</a>
<a name="ln3925">          chg = -1;  // lewis acid/base goes one way only; charge separate it</a>
<a name="ln3926">        } else if (lb.second &gt; 0 &amp;&amp; le.first &gt; 0) {</a>
<a name="ln3927">          chg = 1;  //  no matching capacity; do not charge separate</a>
<a name="ln3928">        }</a>
<a name="ln3929">        // adjust bond order and atom charges accordingly</a>
<a name="ln3930">        bgn-&gt;SetFormalCharge(bgn-&gt;GetFormalCharge()+chg);</a>
<a name="ln3931">        end-&gt;SetFormalCharge(end-&gt;GetFormalCharge()-chg);</a>
<a name="ln3932">        bond-&gt;SetBondOrder(ord);</a>
<a name="ln3933">        converted = true;</a>
<a name="ln3934">      }</a>
<a name="ln3935">    }</a>
<a name="ln3936">    return converted;</a>
<a name="ln3937">  }</a>
<a name="ln3938"> </a>
<a name="ln3939">  OBAtom *OBMol::BeginAtom(OBAtomIterator &amp;i)</a>
<a name="ln3940">  {</a>
<a name="ln3941">    i = _vatom.begin();</a>
<a name="ln3942">    return i == _vatom.end() ? nullptr : (OBAtom*)*i;</a>
<a name="ln3943">  }</a>
<a name="ln3944"> </a>
<a name="ln3945">  OBAtom *OBMol::NextAtom(OBAtomIterator &amp;i)</a>
<a name="ln3946">  {</a>
<a name="ln3947">    ++i;</a>
<a name="ln3948">    return i == _vatom.end() ? nullptr : (OBAtom*)*i;</a>
<a name="ln3949">  }</a>
<a name="ln3950"> </a>
<a name="ln3951">  OBBond *OBMol::BeginBond(OBBondIterator &amp;i)</a>
<a name="ln3952">  {</a>
<a name="ln3953">    i = _vbond.begin();</a>
<a name="ln3954">    return i == _vbond.end() ? nullptr : (OBBond*)*i;</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">  OBBond *OBMol::NextBond(OBBondIterator &amp;i)</a>
<a name="ln3958">  {</a>
<a name="ln3959">    ++i;</a>
<a name="ln3960">    return i == _vbond.end() ? nullptr : (OBBond*)*i;</a>
<a name="ln3961">  }</a>
<a name="ln3962"> </a>
<a name="ln3963">  //! \since version 2.4</a>
<a name="ln3964">  int OBMol::AreInSameRing(OBAtom *a, OBAtom *b)</a>
<a name="ln3965">  {</a>
<a name="ln3966">    bool a_in, b_in;</a>
<a name="ln3967">    vector&lt;OBRing*&gt; vr;</a>
<a name="ln3968">    vr = GetLSSR();</a>
<a name="ln3969"> </a>
<a name="ln3970">    vector&lt;OBRing*&gt;::iterator i;</a>
<a name="ln3971">    vector&lt;int&gt;::iterator j;</a>
<a name="ln3972"> </a>
<a name="ln3973">    for (i = vr.begin();i != vr.end();++i) {</a>
<a name="ln3974">      a_in = false;</a>
<a name="ln3975">      b_in = false;</a>
<a name="ln3976">      // Go through the path of the ring and see if a and/or b match</a>
<a name="ln3977">      // each node in the path</a>
<a name="ln3978">      for(j = (*i)-&gt;_path.begin();j != (*i)-&gt;_path.end();++j) {</a>
<a name="ln3979">        if ((unsigned)(*j) == a-&gt;GetIdx())</a>
<a name="ln3980">          a_in = true;</a>
<a name="ln3981">        if ((unsigned)(*j) == b-&gt;GetIdx())</a>
<a name="ln3982">          b_in = true;</a>
<a name="ln3983">      }</a>
<a name="ln3984"> </a>
<a name="ln3985">      if (a_in &amp;&amp; b_in)</a>
<a name="ln3986">        return (*i)-&gt;Size();</a>
<a name="ln3987">    }</a>
<a name="ln3988"> </a>
<a name="ln3989">    return 0;</a>
<a name="ln3990">  }</a>
<a name="ln3991"> </a>
<a name="ln3992">  vector&lt;OBMol&gt; OBMol::Separate(int StartIndex)</a>
<a name="ln3993">  {</a>
<a name="ln3994">    vector&lt;OBMol&gt; result;</a>
<a name="ln3995">    if( NumAtoms() == 0 )</a>
<a name="ln3996">      return result; // nothing to do, but let's prevent a crash</a>
<a name="ln3997"> </a>
<a name="ln3998">    OBMolAtomDFSIter iter( this, StartIndex );</a>
<a name="ln3999">    OBMol newMol;</a>
<a name="ln4000">    while( GetNextFragment( iter, newMol ) ) {</a>
<a name="ln4001">      result.push_back( newMol );</a>
<a name="ln4002">      newMol.Clear();</a>
<a name="ln4003">    }</a>
<a name="ln4004"> </a>
<a name="ln4005">    return result;</a>
<a name="ln4006">  }</a>
<a name="ln4007"> </a>
<a name="ln4008">  //! \brief Copy part of a molecule to another molecule</a>
<a name="ln4009">  /**</a>
<a name="ln4010">  This function copies a substructure of a molecule to another molecule. The key</a>
<a name="ln4011">  information needed is an OBBitVec indicating which atoms to include and (optionally)</a>
<a name="ln4012">  an OBBitVec indicating which bonds to exclude. By default, only bonds joining</a>
<a name="ln4013">  included atoms are copied.</a>
<a name="ln4014"> </a>
<a name="ln4015">  When an atom is copied, but not all of its bonds are, by default hydrogen counts are</a>
<a name="ln4016">  adjusted to account for the missing bonds. That is, given the SMILES &quot;CF&quot;, if we</a>
<a name="ln4017">  copy the two atoms but exclude the bond, we will end up with &quot;C.F&quot;. This behavior</a>
<a name="ln4018">  can be changed by specifiying a value other than 1 for the \p correctvalence parameter.</a>
<a name="ln4019">  A value of 0 will yield &quot;[C].[F]&quot; while 2 will yield &quot;C*.F*&quot; (see \p correctvalence below</a>
<a name="ln4020">  for more information).</a>
<a name="ln4021"> </a>
<a name="ln4022">  Aromaticity is preserved as present in the original OBMol. If this is not desired,</a>
<a name="ln4023">  the user should call OBMol::SetAromaticPerceived(false) on the new OBMol.</a>
<a name="ln4024"> </a>
<a name="ln4025">  Stereochemistry is only preserved if the corresponding elements are wholly present in</a>
<a name="ln4026">  the substructure. For example, all four atoms and bonds of a tetrahedral stereocenter</a>
<a name="ln4027">  must be copied.</a>
<a name="ln4028"> </a>
<a name="ln4029">  Residue information is preserved if the original OBMol is marked as having</a>
<a name="ln4030">  its residues perceived. If this is not desired, either call</a>
<a name="ln4031">  OBMol::SetChainsPerceived(false) in advance on the original OBMol to avoid copying</a>
<a name="ln4032">  the residues (and then reset it afterwards), or else call it on the new OBMol so</a>
<a name="ln4033">  that residue information will be reperceived (when requested).</a>
<a name="ln4034"> </a>
<a name="ln4035">  Here is an example of using this method to copy ring systems to a new molecule.</a>
<a name="ln4036">  Given the molecule represented by the SMILES string, &quot;FC1CC1c2ccccc2I&quot;, we will</a>
<a name="ln4037">  end up with a new molecule represented by the SMILES string, &quot;C1CC1.c2ccccc2&quot;.</a>
<a name="ln4038">  \code{.cpp}</a>
<a name="ln4039">  OBBitVec atoms(mol.NumAtoms() + 1); // the maximum size needed</a>
<a name="ln4040">  FOR_ATOMS_OF_MOL(atom, mol) {</a>
<a name="ln4041">    if(atom-&gt;IsInRing())</a>
<a name="ln4042">      atoms.SetBitOn(atom-&gt;Idx());</a>
<a name="ln4043">  }</a>
<a name="ln4044">  OBBitVec excludebonds(mol.NumBonds()); // the maximum size needed</a>
<a name="ln4045">  FOR_BONDS_OF_MOL(bond, mol) {</a>
<a name="ln4046">    if(!bond-&gt;IsInRing())</a>
<a name="ln4047">      excludebonds.SetBitOn(bond-&gt;Idx());</a>
<a name="ln4048">  }</a>
<a name="ln4049">  OBMol newmol;</a>
<a name="ln4050">  mol.CopySubstructure(&amp;newmol, &amp;atoms, &amp;excludebonds);</a>
<a name="ln4051">  \endcode</a>
<a name="ln4052"> </a>
<a name="ln4053">  When used from Python, note that &quot;None&quot; may be used to specify an empty value for</a>
<a name="ln4054">  the \p excludebonds parameter.</a>
<a name="ln4055"> </a>
<a name="ln4056">  \remark Some alternatives to using this function, which may be preferred in some</a>
<a name="ln4057">          instances due to efficiency or convenience are:</a>
<a name="ln4058">          -# Copying the entire OBMol, and then deleting the unwanted parts</a>
<a name="ln4059">          -# Modifiying the original OBMol, and then restoring it</a>
<a name="ln4060">          -# Using the SMILES writer option -xf to specify fragment atom idxs</a>
<a name="ln4061"> </a>
<a name="ln4062">  \return A boolean indicating success or failure. Currently failure is only reported</a>
<a name="ln4063">          if one of the specified atoms is not present, or \p atoms is a NULL</a>
<a name="ln4064">          pointer.</a>
<a name="ln4065"> </a>
<a name="ln4066">  \param newmol   The molecule to which to add the substructure. Note that atoms are</a>
<a name="ln4067">                  appended to this molecule.</a>
<a name="ln4068">  \param atoms    An OBBitVec, indexed by atom Idx, specifying which atoms to copy</a>
<a name="ln4069">  \param excludebonds  An OBBitVec, indexed by bond Idx, specifying a list of bonds</a>
<a name="ln4070">                       to exclude. By default, all bonds between the specified atoms are</a>
<a name="ln4071">                       included - this parameter overrides that.</a>
<a name="ln4072">  \param correctvalence  A value of 0, 1 (default) or 2 that indicates how atoms with missing</a>
<a name="ln4073">                         bonds are handled:</a>
<a name="ln4074">                        0 - Leave the implicit hydrogen count unchanged;</a>
<a name="ln4075">                        1 - Adjust the implicit hydrogen count to correct for</a>
<a name="ln4076">                            the missing bonds;</a>
<a name="ln4077">                        2 - Replace the missing bonds with bonds to dummy atoms</a>
<a name="ln4078">  \param atomorder Record the Idxs of the original atoms. That is, the first element</a>
<a name="ln4079">                   in this vector will be the Idx of the atom in the original OBMol</a>
<a name="ln4080">                   that corresponds to the first atom in the new OBMol. Note that</a>
<a name="ln4081">                   the information is appended to this vector.</a>
<a name="ln4082">  \param bondorder Record the Idxs of the original bonds. See \p atomorder above.</a>
<a name="ln4083"> </a>
<a name="ln4084">  **/</a>
<a name="ln4085"> </a>
<a name="ln4086">  bool OBMol::CopySubstructure(OBMol&amp; newmol, OBBitVec *atoms, OBBitVec *excludebonds, unsigned int correctvalence,</a>
<a name="ln4087">                               std::vector&lt;unsigned int&gt; *atomorder, std::vector&lt;unsigned int&gt; *bondorder)</a>
<a name="ln4088">  {</a>
<a name="ln4089">    if (!atoms)</a>
<a name="ln4090">      return false;</a>
<a name="ln4091"> </a>
<a name="ln4092">    bool record_atomorder = atomorder != nullptr;</a>
<a name="ln4093">    bool record_bondorder = bondorder != nullptr;</a>
<a name="ln4094">    bool bonds_specified = excludebonds != nullptr;</a>
<a name="ln4095"> </a>
<a name="ln4096">    newmol.SetDimension(GetDimension());</a>
<a name="ln4097"> </a>
<a name="ln4098">    // If the parent is set to periodic, then also apply boundary conditions to the fragments</a>
<a name="ln4099">    if (IsPeriodic()) {</a>
<a name="ln4100">      OBUnitCell* parent_uc = (OBUnitCell*)GetData(OBGenericDataType::UnitCell);</a>
<a name="ln4101">      newmol.SetData(parent_uc-&gt;Clone(nullptr));</a>
<a name="ln4102">      newmol.SetPeriodicMol();</a>
<a name="ln4103">    }</a>
<a name="ln4104">    // If the parent had aromaticity perceived, then retain that for the fragment</a>
<a name="ln4105">    newmol.SetFlag(_flags &amp; OB_AROMATIC_MOL);</a>
<a name="ln4106">    // The fragment will preserve the &quot;chains perceived&quot; flag of the parent</a>
<a name="ln4107">    newmol.SetFlag(_flags &amp; OB_CHAINS_MOL);</a>
<a name="ln4108">    // We will check for residues only if the parent has chains perceived already</a>
<a name="ln4109">    bool checkresidues = HasChainsPerceived();</a>
<a name="ln4110"> </a>
<a name="ln4111">    // Now add the atoms</a>
<a name="ln4112">    map&lt;OBAtom*, OBAtom*&gt; AtomMap;//key is from old mol; value from new mol</a>
<a name="ln4113">    for (int bit = atoms-&gt;FirstBit(); bit != atoms-&gt;EndBit(); bit = atoms-&gt;NextBit(bit)) {</a>
<a name="ln4114">      OBAtom* atom = this-&gt;GetAtom(bit);</a>
<a name="ln4115">      if (!atom)</a>
<a name="ln4116">        return false;</a>
<a name="ln4117">      newmol.AddAtom(*atom); // each subsequent atom</a>
<a name="ln4118">      if (record_atomorder)</a>
<a name="ln4119">        atomorder-&gt;push_back(bit);</a>
<a name="ln4120">      AtomMap[&amp;*atom] = newmol.GetAtom(newmol.NumAtoms());</a>
<a name="ln4121">    }</a>
<a name="ln4122"> </a>
<a name="ln4123">    //Add the residues</a>
<a name="ln4124">    if (checkresidues) {</a>
<a name="ln4125">      map&lt;OBResidue*, OBResidue*&gt; ResidueMap; // map from old-&gt;new</a>
<a name="ln4126">      for (int bit = atoms-&gt;FirstBit(); bit != atoms-&gt;EndBit(); bit = atoms-&gt;NextBit(bit)) {</a>
<a name="ln4127">        OBAtom* atom = this-&gt;GetAtom(bit);</a>
<a name="ln4128">        OBResidue* res = atom-&gt;GetResidue();</a>
<a name="ln4129">        if (!res) continue;</a>
<a name="ln4130">        map&lt;OBResidue*, OBResidue*&gt;::iterator mit = ResidueMap.find(res);</a>
<a name="ln4131">        OBResidue *newres;</a>
<a name="ln4132">        if (mit == ResidueMap.end()) {</a>
<a name="ln4133">          newres = newmol.NewResidue();</a>
<a name="ln4134">          *newres = *res;</a>
<a name="ln4135">          ResidueMap[res] = newres;</a>
<a name="ln4136">        } else {</a>
<a name="ln4137">          newres = mit-&gt;second;</a>
<a name="ln4138">        }</a>
<a name="ln4139">        OBAtom* newatom = AtomMap[&amp;*atom];</a>
<a name="ln4140">        newres-&gt;AddAtom(newatom);</a>
<a name="ln4141">        newres-&gt;SetAtomID(newatom, res-&gt;GetAtomID(atom));</a>
<a name="ln4142">        newres-&gt;SetHetAtom(newatom, res-&gt;IsHetAtom(atom));</a>
<a name="ln4143">        newres-&gt;SetSerialNum(newatom, res-&gt;GetSerialNum(atom));</a>
<a name="ln4144">      }</a>
<a name="ln4145">    }</a>
<a name="ln4146"> </a>
<a name="ln4147">    // Update Stereo</a>
<a name="ln4148">    std::vector&lt;OBGenericData*&gt;::iterator data;</a>
<a name="ln4149">    std::vector&lt;OBGenericData*&gt; stereoData = GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln4150">    for (data = stereoData.begin(); data != stereoData.end(); ++data) {</a>
<a name="ln4151">      if (static_cast&lt;OBStereoBase*&gt;(*data)-&gt;GetType() == OBStereo::CisTrans) {</a>
<a name="ln4152">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln4153"> </a>
<a name="ln4154">        // Check that the entirety of this cistrans cfg occurs in this substructure</a>
<a name="ln4155">        OBCisTransStereo::Config cfg = ct-&gt;GetConfig();</a>
<a name="ln4156">        OBAtom* begin = GetAtomById(cfg.begin);</a>
<a name="ln4157">        if (AtomMap.find(begin) == AtomMap.end())</a>
<a name="ln4158">          continue;</a>
<a name="ln4159">        OBAtom* end = GetAtomById(cfg.end);</a>
<a name="ln4160">        if (AtomMap.find(end) == AtomMap.end())</a>
<a name="ln4161">          continue;</a>
<a name="ln4162">        bool skip_cfg = false;</a>
<a name="ln4163">        if (bonds_specified) {</a>
<a name="ln4164">          FOR_BONDS_OF_ATOM(bond, begin) {</a>
<a name="ln4165">            if (excludebonds-&gt;BitIsSet(bond-&gt;GetIdx())) {</a>
<a name="ln4166">              skip_cfg = true;</a>
<a name="ln4167">              break;</a>
<a name="ln4168">            }</a>
<a name="ln4169">          }</a>
<a name="ln4170">          if (skip_cfg)</a>
<a name="ln4171">            continue;</a>
<a name="ln4172">          FOR_BONDS_OF_ATOM(bond, end) {</a>
<a name="ln4173">            if (excludebonds-&gt;BitIsSet(bond-&gt;GetIdx())) {</a>
<a name="ln4174">              skip_cfg = true;</a>
<a name="ln4175">              break;</a>
<a name="ln4176">            }</a>
<a name="ln4177">          }</a>
<a name="ln4178">          if (skip_cfg)</a>
<a name="ln4179">            continue;</a>
<a name="ln4180">        }</a>
<a name="ln4181">        for (OBStereo::RefIter ri = cfg.refs.begin(); ri != cfg.refs.end(); ++ri) {</a>
<a name="ln4182">          if (*ri != OBStereo::ImplicitRef &amp;&amp; AtomMap.find(GetAtomById(*ri)) == AtomMap.end()) {</a>
<a name="ln4183">            skip_cfg = true;</a>
<a name="ln4184">            break;</a>
<a name="ln4185">          }</a>
<a name="ln4186">        }</a>
<a name="ln4187">        if (skip_cfg)</a>
<a name="ln4188">          continue;</a>
<a name="ln4189"> </a>
<a name="ln4190">        OBCisTransStereo::Config newcfg;</a>
<a name="ln4191">        newcfg.specified = cfg.specified;</a>
<a name="ln4192">        newcfg.begin = cfg.begin == OBStereo::ImplicitRef ? OBStereo::ImplicitRef : AtomMap[GetAtomById(cfg.begin)]-&gt;GetId();</a>
<a name="ln4193">        newcfg.end = cfg.end == OBStereo::ImplicitRef ? OBStereo::ImplicitRef : AtomMap[GetAtomById(cfg.end)]-&gt;GetId();</a>
<a name="ln4194">        OBStereo::Refs refs;</a>
<a name="ln4195">        for (OBStereo::RefIter ri = cfg.refs.begin(); ri != cfg.refs.end(); ++ri) {</a>
<a name="ln4196">          OBStereo::Ref ref = *ri == OBStereo::ImplicitRef ? OBStereo::ImplicitRef : AtomMap[GetAtomById(*ri)]-&gt;GetId();</a>
<a name="ln4197">          refs.push_back(ref);</a>
<a name="ln4198">        }</a>
<a name="ln4199">        newcfg.refs = refs;</a>
<a name="ln4200"> </a>
<a name="ln4201">        OBCisTransStereo *newct = new OBCisTransStereo(this);</a>
<a name="ln4202">        newct-&gt;SetConfig(newcfg);</a>
<a name="ln4203">        newmol.SetData(newct);</a>
<a name="ln4204">      }</a>
<a name="ln4205">      else if (static_cast&lt;OBStereoBase*&gt;(*data)-&gt;GetType() == OBStereo::Tetrahedral) {</a>
<a name="ln4206">        OBTetrahedralStereo *tet = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln4207">        OBTetrahedralStereo::Config cfg = tet-&gt;GetConfig();</a>
<a name="ln4208"> </a>
<a name="ln4209">        // Check that the entirety of this tet cfg occurs in this substructure</a>
<a name="ln4210">        OBAtom *center = GetAtomById(cfg.center);</a>
<a name="ln4211">        std::map&lt;OBAtom*, OBAtom*&gt;::iterator centerit = AtomMap.find(center);</a>
<a name="ln4212">        if (centerit == AtomMap.end())</a>
<a name="ln4213">          continue;</a>
<a name="ln4214">        if (cfg.from != OBStereo::ImplicitRef &amp;&amp; AtomMap.find(GetAtomById(cfg.from)) == AtomMap.end())</a>
<a name="ln4215">          continue;</a>
<a name="ln4216">        bool skip_cfg = false;</a>
<a name="ln4217">        if (bonds_specified) {</a>
<a name="ln4218">          FOR_BONDS_OF_ATOM(bond, center) {</a>
<a name="ln4219">            if (excludebonds-&gt;BitIsSet(bond-&gt;GetIdx())) {</a>
<a name="ln4220">              skip_cfg = true;</a>
<a name="ln4221">              break;</a>
<a name="ln4222">            }</a>
<a name="ln4223">          }</a>
<a name="ln4224">          if (skip_cfg)</a>
<a name="ln4225">            continue;</a>
<a name="ln4226">        }</a>
<a name="ln4227">        for (OBStereo::RefIter ri = cfg.refs.begin(); ri != cfg.refs.end(); ++ri) {</a>
<a name="ln4228">          if (*ri != OBStereo::ImplicitRef &amp;&amp; AtomMap.find(GetAtomById(*ri)) == AtomMap.end()) {</a>
<a name="ln4229">            skip_cfg = true;</a>
<a name="ln4230">            break;</a>
<a name="ln4231">          }</a>
<a name="ln4232">        }</a>
<a name="ln4233">        if (skip_cfg)</a>
<a name="ln4234">          continue;</a>
<a name="ln4235"> </a>
<a name="ln4236">        OBTetrahedralStereo::Config newcfg;</a>
<a name="ln4237">        newcfg.specified = cfg.specified;</a>
<a name="ln4238">        newcfg.center = centerit-&gt;second-&gt;GetId();</a>
<a name="ln4239">        newcfg.from = cfg.from == OBStereo::ImplicitRef ? OBStereo::ImplicitRef : AtomMap[GetAtomById(cfg.from)]-&gt;GetId();</a>
<a name="ln4240">        OBStereo::Refs refs;</a>
<a name="ln4241">        for (OBStereo::RefIter ri = cfg.refs.begin(); ri != cfg.refs.end(); ++ri) {</a>
<a name="ln4242">          OBStereo::Ref ref = *ri == OBStereo::ImplicitRef ? OBStereo::ImplicitRef : AtomMap[GetAtomById(*ri)]-&gt;GetId();</a>
<a name="ln4243">          refs.push_back(ref);</a>
<a name="ln4244">        }</a>
<a name="ln4245">        newcfg.refs = refs;</a>
<a name="ln4246"> </a>
<a name="ln4247">        OBTetrahedralStereo *newtet = new OBTetrahedralStereo(this);</a>
<a name="ln4248">        newtet-&gt;SetConfig(newcfg);</a>
<a name="ln4249">        newmol.SetData(newtet);</a>
<a name="ln4250">      }</a>
<a name="ln4251">    }</a>
<a name="ln4252"> </a>
<a name="ln4253">    // Options:</a>
<a name="ln4254">    // 1. Bonds that do not connect atoms in the subset are ignored</a>
<a name="ln4255">    // 2. As 1. but implicit Hs are added to replace them</a>
<a name="ln4256">    // 3. As 1. but asterisks are added to replace them</a>
<a name="ln4257">    FOR_BONDS_OF_MOL(bond, this) {</a>
<a name="ln4258">      bool skipping_bond = bonds_specified &amp;&amp; excludebonds-&gt;BitIsSet(bond-&gt;GetIdx());</a>
<a name="ln4259">      map&lt;OBAtom*, OBAtom*&gt;::iterator posB = AtomMap.find(bond-&gt;GetBeginAtom());</a>
<a name="ln4260">      map&lt;OBAtom*, OBAtom*&gt;::iterator posE = AtomMap.find(bond-&gt;GetEndAtom());</a>
<a name="ln4261">      if (posB == AtomMap.end() &amp;&amp; posE == AtomMap.end())</a>
<a name="ln4262">        continue;</a>
<a name="ln4263"> </a>
<a name="ln4264">      if (posB == AtomMap.end() || posE == AtomMap.end() || skipping_bond) {</a>
<a name="ln4265">        switch(correctvalence) {</a>
<a name="ln4266">        case 1:</a>
<a name="ln4267">          if (posB == AtomMap.end() || (skipping_bond &amp;&amp; posE != AtomMap.end()))</a>
<a name="ln4268">            posE-&gt;second-&gt;SetImplicitHCount(posE-&gt;second-&gt;GetImplicitHCount() + bond-&gt;GetBondOrder());</a>
<a name="ln4269">          if (posE == AtomMap.end() || (skipping_bond &amp;&amp; posB != AtomMap.end()))</a>
<a name="ln4270">            posB-&gt;second-&gt;SetImplicitHCount(posB-&gt;second-&gt;GetImplicitHCount() + bond-&gt;GetBondOrder());</a>
<a name="ln4271">          break;</a>
<a name="ln4272">        case 2: {</a>
<a name="ln4273">            OBAtom *atomB, *atomE;</a>
<a name="ln4274">            if (skipping_bond) {</a>
<a name="ln4275">              for(int N=0; N&lt;2; ++N) {</a>
<a name="ln4276">                if (N==0) {</a>
<a name="ln4277">                  if (posB != AtomMap.end()) {</a>
<a name="ln4278">                    atomB = posB-&gt;second;</a>
<a name="ln4279">                    atomE = newmol.NewAtom();</a>
<a name="ln4280">                    if (record_atomorder)</a>
<a name="ln4281">                      atomorder-&gt;push_back(bond-&gt;GetEndAtomIdx());</a>
<a name="ln4282">                  }</a>
<a name="ln4283">                } else if (posE != AtomMap.end()) {</a>
<a name="ln4284">                  atomE = posE-&gt;second;</a>
<a name="ln4285">                  atomB = newmol.NewAtom();</a>
<a name="ln4286">                  if (record_atomorder)</a>
<a name="ln4287">                    atomorder-&gt;push_back(bond-&gt;GetBeginAtomIdx());</a>
<a name="ln4288">                }</a>
<a name="ln4289">                newmol.AddBond(atomB-&gt;GetIdx(), atomE-&gt;GetIdx(),</a>
<a name="ln4290">                  bond-&gt;GetBondOrder(), bond-&gt;GetFlags());</a>
<a name="ln4291">                if (record_bondorder)</a>
<a name="ln4292">                  bondorder-&gt;push_back(bond-&gt;GetIdx());</a>
<a name="ln4293">              }</a>
<a name="ln4294">            }</a>
<a name="ln4295">            else {</a>
<a name="ln4296">              atomB = (posB == AtomMap.end()) ? newmol.NewAtom() : posB-&gt;second;</a>
<a name="ln4297">              atomE = (posE == AtomMap.end()) ? newmol.NewAtom() : posE-&gt;second;</a>
<a name="ln4298">              if (record_atomorder) {</a>
<a name="ln4299">                if (posB == AtomMap.end())</a>
<a name="ln4300">                  atomorder-&gt;push_back(bond-&gt;GetBeginAtomIdx());</a>
<a name="ln4301">                else</a>
<a name="ln4302">                  atomorder-&gt;push_back(bond-&gt;GetEndAtomIdx());</a>
<a name="ln4303">              }</a>
<a name="ln4304">              newmol.AddBond(atomB-&gt;GetIdx(), atomE-&gt;GetIdx(),</a>
<a name="ln4305">                bond-&gt;GetBondOrder(), bond-&gt;GetFlags());</a>
<a name="ln4306">              if (record_bondorder)</a>
<a name="ln4307">                bondorder-&gt;push_back(bond-&gt;GetIdx());</a>
<a name="ln4308">            }</a>
<a name="ln4309">          }</a>
<a name="ln4310">          break;</a>
<a name="ln4311">        default:</a>
<a name="ln4312">          break;</a>
<a name="ln4313">        }</a>
<a name="ln4314">      }</a>
<a name="ln4315">      else {</a>
<a name="ln4316">        newmol.AddBond((posB-&gt;second)-&gt;GetIdx(), posE-&gt;second-&gt;GetIdx(),</a>
<a name="ln4317">                       bond-&gt;GetBondOrder(), bond-&gt;GetFlags());</a>
<a name="ln4318">        if (record_bondorder)</a>
<a name="ln4319">          bondorder-&gt;push_back(bond-&gt;GetIdx());</a>
<a name="ln4320">      }</a>
<a name="ln4321">    }</a>
<a name="ln4322"> </a>
<a name="ln4323">    return true;</a>
<a name="ln4324">  }</a>
<a name="ln4325"> </a>
<a name="ln4326">  bool OBMol::GetNextFragment( OBMolAtomDFSIter&amp; iter, OBMol&amp; newmol ) {</a>
<a name="ln4327">    if( ! iter ) return false;</a>
<a name="ln4328"> </a>
<a name="ln4329">    // We want to keep the atoms in their original order rather than use</a>
<a name="ln4330">    // the DFS order so just record the information first</a>
<a name="ln4331">    OBBitVec infragment(this-&gt;NumAtoms()+1);</a>
<a name="ln4332">    do { //for each atom in fragment</a>
<a name="ln4333">      infragment.SetBitOn(iter-&gt;GetIdx());</a>
<a name="ln4334">    } while ((iter++).next());</a>
<a name="ln4335"> </a>
<a name="ln4336">    bool ok = CopySubstructure(newmol, &amp;infragment);</a>
<a name="ln4337"> </a>
<a name="ln4338">    return ok;</a>
<a name="ln4339">  }</a>
<a name="ln4340"> </a>
<a name="ln4341">  // Put the specified molecular charge on a single atom (which is expected for InChIFormat).</a>
<a name="ln4342">  // Assumes all the hydrogen is explicitly included in the molecule,</a>
<a name="ln4343">  // and that SetTotalCharge() has not been called. (This function is an alternative.)</a>
<a name="ln4344">  // Returns false if cannot assign all the charge.</a>
<a name="ln4345">  // Not robust in the general case, but see below for the more common simpler cases.</a>
<a name="ln4346">  bool OBMol::AssignTotalChargeToAtoms(int charge)</a>
<a name="ln4347">  {</a>
<a name="ln4348">    int extraCharge = charge - GetTotalCharge(); //GetTotalCharge() gets charge on atoms</a>
<a name="ln4349"> </a>
<a name="ln4350">    FOR_ATOMS_OF_MOL (atom, this)</a>
<a name="ln4351">    {</a>
<a name="ln4352">      unsigned int atomicnum = atom-&gt;GetAtomicNum();</a>
<a name="ln4353">      if (atomicnum == 1)</a>
<a name="ln4354">        continue;</a>
<a name="ln4355">      int charge = atom-&gt;GetFormalCharge();</a>
<a name="ln4356">      unsigned bosum = atom-&gt;GetExplicitValence();</a>
<a name="ln4357">      unsigned int totalValence = bosum + atom-&gt;GetImplicitHCount();</a>
<a name="ln4358">      unsigned int typicalValence = GetTypicalValence(atomicnum, bosum, charge);</a>
<a name="ln4359">      int diff = typicalValence - totalValence;</a>
<a name="ln4360">      if(diff != 0)</a>
<a name="ln4361">      {</a>
<a name="ln4362">        int c;</a>
<a name="ln4363">        if(extraCharge == 0)</a>
<a name="ln4364">          c = diff &gt; 0 ? -1 : +1; //e.g. CH3C(=O)O, NH4 respectively</a>
<a name="ln4365">        else</a>
<a name="ln4366">          c = extraCharge &lt; 0 ? -1 : 1;</a>
<a name="ln4367">        if (totalValence == GetTypicalValence(atomicnum, bosum, charge + c)) {</a>
<a name="ln4368">          atom-&gt;SetFormalCharge(charge + c);</a>
<a name="ln4369">          extraCharge -= c;</a>
<a name="ln4370">        }</a>
<a name="ln4371">      }</a>
<a name="ln4372">    }</a>
<a name="ln4373">    if(extraCharge != 0)</a>
<a name="ln4374">    {</a>
<a name="ln4375">      obErrorLog.ThrowError(__FUNCTION__, &quot;Unable to assign all the charge to atoms&quot;, obWarning);</a>
<a name="ln4376">      return false;</a>
<a name="ln4377">    }</a>
<a name="ln4378">    return true;</a>
<a name="ln4379"> }</a>
<a name="ln4380">  /* These cases work ok</a>
<a name="ln4381">   original      charge  result</a>
<a name="ln4382">  [NH4]             +1   [NH4+]</a>
<a name="ln4383">  -C(=O)[O]         -1   -C(=O)[O-]</a>
<a name="ln4384">  -[CH2]            +1   -C[CH2+]</a>
<a name="ln4385">  -[CH2]            -1   -C[CH2-]</a>
<a name="ln4386">  [NH3]CC(=O)[O]     0   [NH3+]CC(=O)[O-]</a>
<a name="ln4387">  S(=O)(=O)([O])[O] -2   S(=O)(=O)([O-])[O-]</a>
<a name="ln4388">  [NH4].[Cl]         0   [NH4+].[Cl-]</a>
<a name="ln4389">  */</a>
<a name="ln4390"> </a>
<a name="ln4391">} // end namespace OpenBabel</a>
<a name="ln4392"> </a>
<a name="ln4393">//! \file mol.cpp</a>
<a name="ln4394">//! \brief Handle molecules. Implementation of OBMol.</a>

</code></pre>
<div class="balloon" rel="2525"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v668/" target="_blank">V668</a> There is no sense in testing the 'bond' pointer against null, as the memory was allocated using the 'new' operator. The exception will be generated in the case of memory allocation error.</p></div>
<div class="balloon" rel="2537"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'bond' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="3526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: c.</p></div>
<div class="balloon" rel="3526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v686/" target="_blank">V686</a> A pattern was detected: (b->IsInRing()) || ((b->IsInRing()) && ...). The expression is excessive or contains a logical error.</p></div>
<div class="balloon" rel="3526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!atom->IsInRing()' and 'atom->IsInRing()'. </p></div>
<div class="balloon" rel="3815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '(A && B) || (!A && !B)' expression is equivalent to the 'bool(A) == bool(B)' expression.</p></div>
<div class="balloon" rel="2716"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _totalSpin.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

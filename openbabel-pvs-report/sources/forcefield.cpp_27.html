
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>forcefield.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">forcefield.cpp - Handle OBForceField class.</a>
<a name="ln3"> </a>
<a name="ln4">Copyright (C) 2006-2007 by Tim Vandermeersch &lt;tim.vandermeersch@gmail.com&gt;</a>
<a name="ln5">Some portions Copyright (C) 2007-2008 by Geoffrey Hutchison</a>
<a name="ln6"> </a>
<a name="ln7">This file is part of the Open Babel project.</a>
<a name="ln8">For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln9"> </a>
<a name="ln10">This program is free software; you can redistribute it and/or modify</a>
<a name="ln11">it under the terms of the GNU General Public License as published by</a>
<a name="ln12">the Free Software Foundation version 2 of the License.</a>
<a name="ln13"> </a>
<a name="ln14">This program is distributed in the hope that it will be useful,</a>
<a name="ln15">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln17">GNU General Public License for more details.</a>
<a name="ln18"> </a>
<a name="ln19">***********************************************************************/</a>
<a name="ln20">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;set&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;openbabel/forcefield.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln27">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln28">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln29">#include &lt;openbabel/ring.h&gt;</a>
<a name="ln30">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln31">#include &lt;openbabel/math/matrix3x3.h&gt;</a>
<a name="ln32">#include &lt;openbabel/rotamer.h&gt;</a>
<a name="ln33">#include &lt;openbabel/rotor.h&gt;</a>
<a name="ln34">#include &lt;openbabel/grid.h&gt;</a>
<a name="ln35">#include &lt;openbabel/griddata.h&gt;</a>
<a name="ln36">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln37">#include &quot;rand.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">using namespace std;</a>
<a name="ln40"> </a>
<a name="ln41">namespace OpenBabel</a>
<a name="ln42">{</a>
<a name="ln43">#if defined(__CYGWIN__) || defined(__MINGW32__)</a>
<a name="ln44">  // macro to implement static OBPlugin::PluginMapType&amp; Map()</a>
<a name="ln45">  PLUGIN_CPP_FILE(OBForceField)</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">  /** \class OBForceField forcefield.h &lt;openbabel/forcefield.h&gt;</a>
<a name="ln49">      \brief Base class for molecular mechanics force fields</a>
<a name="ln50"> </a>
<a name="ln51">      The OBForceField class is the base class for molecular mechanics in Open Babel.</a>
<a name="ln52">      Classes derived from the OBForceField implement specific force fields (Ghemical,</a>
<a name="ln53">      MMFF94, UFF, ...).Other classes such as OBFFParameter, OBFFConstraint,</a>
<a name="ln54">      OBFFCalculation and its derived classes are only for internal use. As a user</a>
<a name="ln55">      interested in using the available force fields in Open Babel, you don't need</a>
<a name="ln56">      these classes. The rest of this short introduction is aimed at these users. For</a>
<a name="ln57">      information on how to implement additional force fields, see the wiki pages or</a>
<a name="ln58">      post your questions to the openbabel-devel mailing list.</a>
<a name="ln59"> </a>
<a name="ln60">      Before we can start using a force field, we must first select it and set it up.</a>
<a name="ln61">      This is illustrated in the first example below. The Setup procedure assigns atom</a>
<a name="ln62">      types, charges and parameters. There are several reasons why this may fail, a log</a>
<a name="ln63">      message will be written to the logfile before Setup() returns false.</a>
<a name="ln64"> </a>
<a name="ln65">      The force field classes use their own logging functions. You can set the logfile</a>
<a name="ln66">      using SetLogFile() and set the log level using SetLogLevel(). If needed you can</a>
<a name="ln67">      also write to the logfile using OBFFLog(). There are four log levels:</a>
<a name="ln68">      BFF_LOGLVL_NONE, OBFF_LOGLVL_LOW, OBFF_LOGLVL_MEDIUM, OBFF_LOGLVL_HIGH.</a>
<a name="ln69">      See the API documentation to know what kind of output each function writes to</a>
<a name="ln70">      the logfile for the different log levels.</a>
<a name="ln71"> </a>
<a name="ln72">      Below are two examples which explain the basics.</a>
<a name="ln73"> </a>
<a name="ln74">      This piece of code will output a list of available forcefields to cout:</a>
<a name="ln75">      \code</a>
<a name="ln76">      OBPlugin::List(&quot;forcefields&quot;);</a>
<a name="ln77">      \endcode</a>
<a name="ln78"> </a>
<a name="ln79">      Calculate the energy for the structure in mol using the Ghemical forcefield.</a>
<a name="ln80">      \code</a>
<a name="ln81">      #include &lt;openbabel/forcefield.h&gt;</a>
<a name="ln82">      #include &lt;openbabel/mol.h&gt;</a>
<a name="ln83"> </a>
<a name="ln84">      // See OBConversion class to fill the mol object.</a>
<a name="ln85">      OBMol mol;</a>
<a name="ln86">      // Select the forcefield, this returns a pointer that we</a>
<a name="ln87">      // will later use to access the forcefield functions.</a>
<a name="ln88">      OBForceField* pFF = OBForceField::FindForceField(&quot;MMFF94&quot;);</a>
<a name="ln89"> </a>
<a name="ln90">      // Make sure we have a valid pointer</a>
<a name="ln91">      if (!pFF)</a>
<a name="ln92">      // exit...</a>
<a name="ln93"> </a>
<a name="ln94">      // Set the logfile (can also be &amp;cout or &amp;cerr)</a>
<a name="ln95">      pFF-&gt;SetLogFile(&amp;cerr);</a>
<a name="ln96">      // Set the log level. See indivual functions to know</a>
<a name="ln97">      // what kind of output each function produces for the</a>
<a name="ln98">      // different log levels.</a>
<a name="ln99">      pFF-&gt;SetLogLevel(OBFF_LOGLVL_HIGH);</a>
<a name="ln100"> </a>
<a name="ln101">      // We need to setup the forcefield before we can use it. Setup()</a>
<a name="ln102">      // returns false if it failes to find the atom types, parameters, ...</a>
<a name="ln103">      if (!pFF-&gt;Setup(mol)) {</a>
<a name="ln104">      cerr &lt;&lt; &quot;ERROR: could not setup force field.&quot; &lt;&lt; endl;</a>
<a name="ln105">      }</a>
<a name="ln106"> </a>
<a name="ln107">      // Calculate the energy. The output will be written to the</a>
<a name="ln108">      // logfile specified by SetLogFile()</a>
<a name="ln109">      pFF-&gt;Energy();</a>
<a name="ln110">      \endcode</a>
<a name="ln111"> </a>
<a name="ln112">      Minimize the structure in mol using conjugate gradients.</a>
<a name="ln113">      \code</a>
<a name="ln114">      #include &lt;openbabel/forcefield.h&gt;</a>
<a name="ln115">      #include &lt;openbabel/mol.h&gt;</a>
<a name="ln116"> </a>
<a name="ln117">      OBMol mol;</a>
<a name="ln118">      OBForceField* pFF = OBForceField::FindForceField(&quot;MMFF94&quot;);</a>
<a name="ln119"> </a>
<a name="ln120">      // Make sure we have a valid pointer</a>
<a name="ln121">      if (!pFF)</a>
<a name="ln122">      // exit...</a>
<a name="ln123"> </a>
<a name="ln124">      pFF-&gt;SetLogFile(&amp;cerr);</a>
<a name="ln125">      pFF-&gt;SetLogLevel(OBFF_LOGLVL_LOW);</a>
<a name="ln126">      if (!pFF-&gt;Setup(mol)) {</a>
<a name="ln127">      cerr &lt;&lt; &quot;ERROR: could not setup force field.&quot; &lt;&lt; endl;</a>
<a name="ln128">      }</a>
<a name="ln129"> </a>
<a name="ln130">      // Perform the actual minimization, maximum 1000 steps</a>
<a name="ln131">      pFF-&gt;ConjugateGradients(1000);</a>
<a name="ln132">      \endcode</a>
<a name="ln133"> </a>
<a name="ln134">      Minimize the structure in mol using steepest descent and fix the position of atom with index 1.</a>
<a name="ln135">      \code</a>
<a name="ln136">      #include &lt;openbabel/forcefield.h&gt;</a>
<a name="ln137">      #include &lt;openbabel/mol.h&gt;</a>
<a name="ln138"> </a>
<a name="ln139">      OBMol mol;</a>
<a name="ln140">      OBForceField* pFF = OBForceField::FindForceField(&quot;MMFF94&quot;);</a>
<a name="ln141"> </a>
<a name="ln142">      // Make sure we have a valid pointer</a>
<a name="ln143">      if (!pFF)</a>
<a name="ln144">      // exit...</a>
<a name="ln145"> </a>
<a name="ln146">      pFF-&gt;SetLogFile(&amp;cerr);</a>
<a name="ln147">      pFF-&gt;SetLogLevel(OBFF_LOGLVL_LOW);</a>
<a name="ln148"> </a>
<a name="ln149">      // Set the constraints</a>
<a name="ln150">      OBFFConstraints constraints;</a>
<a name="ln151">      constraints.AddAtomConstraint(1);</a>
<a name="ln152"> </a>
<a name="ln153">      // We pass the constraints as argument for Setup()</a>
<a name="ln154">      if (!pFF-&gt;Setup(mol, constraints)) {</a>
<a name="ln155">      cerr &lt;&lt; &quot;ERROR: could not setup force field.&quot; &lt;&lt; endl;</a>
<a name="ln156">      }</a>
<a name="ln157"> </a>
<a name="ln158">      // Perform the actual minimization, maximum 1000 steps</a>
<a name="ln159">      pFF-&gt;ConjugateGradients(1000);</a>
<a name="ln160">      \endcode</a>
<a name="ln161"> </a>
<a name="ln162">      Minimize a ligand molecule in a binding pocket.</a>
<a name="ln163">      \code</a>
<a name="ln164">      #include &lt;openbabel/forcefield.h&gt;</a>
<a name="ln165">      #include &lt;openbabel/mol.h&gt;</a>
<a name="ln166"> </a>
<a name="ln167">      OBMol mol;</a>
<a name="ln168"> </a>
<a name="ln169">      //</a>
<a name="ln170">      // Read the pocket + ligand (initial guess for position) into mol...</a>
<a name="ln171">      //</a>
<a name="ln172"> </a>
<a name="ln173">      OBBitVec pocket; // set the bits with atoms indexes for the pocket to 1...</a>
<a name="ln174">      OBBitVec ligand; // set the bits with atoms indexes for the ligand to 1...</a>
<a name="ln175"> </a>
<a name="ln176">      OBForceField* pFF = OBForceField::FindForceField(&quot;MMFF94&quot;);</a>
<a name="ln177"> </a>
<a name="ln178">      // Make sure we have a valid pointer</a>
<a name="ln179">      if (!pFF)</a>
<a name="ln180">      // exit...</a>
<a name="ln181"> </a>
<a name="ln182">      pFF-&gt;SetLogFile(&amp;cerr);</a>
<a name="ln183">      pFF-&gt;SetLogLevel(OBFF_LOGLVL_LOW);</a>
<a name="ln184"> </a>
<a name="ln185">      // Fix the binding pocket atoms</a>
<a name="ln186">      OBFFConstraints constraints;</a>
<a name="ln187">      FOR_ATOMS_OF_MOL (a, mol) {</a>
<a name="ln188">      if (pocket.BitIsSet(a-&gt;GetIdx())</a>
<a name="ln189">      constraints.AddAtomConstraint(a-&gt;GetIdx());</a>
<a name="ln190">      }</a>
<a name="ln191"> </a>
<a name="ln192">      // Specify the interacting groups. The pocket atoms are fixed, so there</a>
<a name="ln193">      // is no need to calculate intra- and inter-molecular interactions for</a>
<a name="ln194">      // the binding pocket.</a>
<a name="ln195">      pFF-&gt;AddIntraGroup(ligand); // bonded interactions in the ligand</a>
<a name="ln196">      pFF-&gt;AddInterGroup(ligand); // non-bonded between ligand-ligand atoms</a>
<a name="ln197">      pFF-&gt;AddInterGroups(ligand, pocket); // non-bonded between ligand and pocket atoms</a>
<a name="ln198"> </a>
<a name="ln199">      // We pass the constraints as argument for Setup()</a>
<a name="ln200">      if (!pFF-&gt;Setup(mol, constraints)) {</a>
<a name="ln201">      cerr &lt;&lt; &quot;ERROR: could not setup force field.&quot; &lt;&lt; endl;</a>
<a name="ln202">      }</a>
<a name="ln203"> </a>
<a name="ln204">      // Perform the actual minimization, maximum 1000 steps</a>
<a name="ln205">      pFF-&gt;ConjugateGradients(1000);</a>
<a name="ln206">      \endcode</a>
<a name="ln207"> </a>
<a name="ln208">  **/</a>
<a name="ln209"> </a>
<a name="ln210">  int OBForceField::GetParameterIdx(int a, int b, int c, int d, vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln211">  {</a>
<a name="ln212">    if (!b)</a>
<a name="ln213">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln214">        if (a == parameter[idx].a)</a>
<a name="ln215">          return idx;</a>
<a name="ln216"> </a>
<a name="ln217">    if (!c)</a>
<a name="ln218">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln219">        if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b)) ||</a>
<a name="ln220">            ((a == parameter[idx].b) &amp;&amp; (b == parameter[idx].a)))</a>
<a name="ln221">          return idx;</a>
<a name="ln222"> </a>
<a name="ln223">    if (!d)</a>
<a name="ln224">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln225">        if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].c)) ||</a>
<a name="ln226">            ((a == parameter[idx].c) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].a)))</a>
<a name="ln227">          return idx;</a>
<a name="ln228"> </a>
<a name="ln229">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln230">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp;</a>
<a name="ln231">           (c == parameter[idx].c) &amp;&amp; (d == parameter[idx].d)) ||</a>
<a name="ln232">          ((a == parameter[idx].d) &amp;&amp; (b == parameter[idx].c) &amp;&amp;</a>
<a name="ln233">           (c == parameter[idx].b) &amp;&amp; (d == parameter[idx].a)))</a>
<a name="ln234">        return idx;</a>
<a name="ln235"> </a>
<a name="ln236">    return -1;</a>
<a name="ln237">  }</a>
<a name="ln238"> </a>
<a name="ln239">  OBFFParameter* OBForceField::GetParameter(int a, int b, int c, int d,</a>
<a name="ln240">                                            vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln241">  {</a>
<a name="ln242">    OBFFParameter *par;</a>
<a name="ln243"> </a>
<a name="ln244">    if (!b)</a>
<a name="ln245">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln246">        if (a == parameter[idx].a) {</a>
<a name="ln247">          par = &amp;parameter[idx];</a>
<a name="ln248">          return par;</a>
<a name="ln249">        }</a>
<a name="ln250"> </a>
<a name="ln251">    if (!c)</a>
<a name="ln252">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln253">        if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b)) ||</a>
<a name="ln254">            ((a == parameter[idx].b) &amp;&amp; (b == parameter[idx].a))) {</a>
<a name="ln255">          par = &amp;parameter[idx];</a>
<a name="ln256">          return par;</a>
<a name="ln257">        }</a>
<a name="ln258"> </a>
<a name="ln259">    if (!d)</a>
<a name="ln260">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln261">        if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].c)) ||</a>
<a name="ln262">            ((a == parameter[idx].c) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].a))) {</a>
<a name="ln263">          par = &amp;parameter[idx];</a>
<a name="ln264">          return par;</a>
<a name="ln265">        }</a>
<a name="ln266"> </a>
<a name="ln267">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln268">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp;</a>
<a name="ln269">           (c == parameter[idx].c) &amp;&amp; (d == parameter[idx].d)) ||</a>
<a name="ln270">          ((a == parameter[idx].d) &amp;&amp; (b == parameter[idx].c) &amp;&amp;</a>
<a name="ln271">           (c == parameter[idx].b) &amp;&amp; (d == parameter[idx].a))) {</a>
<a name="ln272">        par = &amp;parameter[idx];</a>
<a name="ln273">        return par;</a>
<a name="ln274">      }</a>
<a name="ln275"> </a>
<a name="ln276">    return nullptr;</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  OBFFParameter* OBForceField::GetParameter(const char* a, const char* b, const char* c,</a>
<a name="ln280">                                            const char* d, vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln281">  {</a>
<a name="ln282">    OBFFParameter *par;</a>
<a name="ln283">    if (a == nullptr)</a>
<a name="ln284">      return nullptr;</a>
<a name="ln285"> </a>
<a name="ln286">    if (b == nullptr) {</a>
<a name="ln287">      string _a(a);</a>
<a name="ln288">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln289">        if (_a == parameter[idx]._a) {</a>
<a name="ln290">          par = &amp;parameter[idx];</a>
<a name="ln291">          return par;</a>
<a name="ln292">        }</a>
<a name="ln293">      return nullptr;</a>
<a name="ln294">    }</a>
<a name="ln295">    if (c == nullptr) {</a>
<a name="ln296">      string _a(a);</a>
<a name="ln297">      string _b(b);</a>
<a name="ln298">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++) {</a>
<a name="ln299">        if (((_a == parameter[idx]._a) &amp;&amp; (_b == parameter[idx]._b)) ||</a>
<a name="ln300">            ((_a == parameter[idx]._b) &amp;&amp; (_b == parameter[idx]._a))) {</a>
<a name="ln301">          par = &amp;parameter[idx];</a>
<a name="ln302">          return par;</a>
<a name="ln303">        }</a>
<a name="ln304">      }</a>
<a name="ln305">      return nullptr;</a>
<a name="ln306">    }</a>
<a name="ln307">    if (d == nullptr) {</a>
<a name="ln308">      string _a(a);</a>
<a name="ln309">      string _b(b);</a>
<a name="ln310">      string _c(c);</a>
<a name="ln311">      for (unsigned int idx=0; idx &lt; parameter.size(); idx++) {</a>
<a name="ln312">        if (((_a == parameter[idx]._a) &amp;&amp; (_b == parameter[idx]._b) &amp;&amp; (_c == parameter[idx]._c)) ||</a>
<a name="ln313">            ((_a == parameter[idx]._c) &amp;&amp; (_b == parameter[idx]._b) &amp;&amp; (_c == parameter[idx]._a))) {</a>
<a name="ln314">          par = &amp;parameter[idx];</a>
<a name="ln315">          return par;</a>
<a name="ln316">        }</a>
<a name="ln317">      }</a>
<a name="ln318">      return nullptr;</a>
<a name="ln319">    }</a>
<a name="ln320">    string _a(a);</a>
<a name="ln321">    string _b(b);</a>
<a name="ln322">    string _c(c);</a>
<a name="ln323">    string _d(d);</a>
<a name="ln324">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln325">      if (((_a == parameter[idx]._a) &amp;&amp; (_b == parameter[idx]._b) &amp;&amp;</a>
<a name="ln326">           (_c == parameter[idx]._c) &amp;&amp; (_d == parameter[idx]._d)) ||</a>
<a name="ln327">          ((_a == parameter[idx]._d) &amp;&amp; (_b == parameter[idx]._c) &amp;&amp;</a>
<a name="ln328">           (_c == parameter[idx]._b) &amp;&amp; (_d == parameter[idx]._a))) {</a>
<a name="ln329">        par = &amp;parameter[idx];</a>
<a name="ln330">        return par;</a>
<a name="ln331">      }</a>
<a name="ln332"> </a>
<a name="ln333">    return nullptr;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln337">  //</a>
<a name="ln338">  // Constraints</a>
<a name="ln339">  //</a>
<a name="ln340">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln341"> </a>
<a name="ln342">  OBFFConstraints OBForceField::_constraints = OBFFConstraints(); // define static data variable</a>
<a name="ln343">  unsigned int OBForceField::_fixAtom = 0; // define static data variable</a>
<a name="ln344">  unsigned int OBForceField::_ignoreAtom = 0; // define static data variable</a>
<a name="ln345"> </a>
<a name="ln346">  OBFFConstraints&amp; OBForceField::GetConstraints()</a>
<a name="ln347">  {</a>
<a name="ln348">    return _constraints;</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  void OBForceField::SetConstraints(OBFFConstraints&amp; constraints)</a>
<a name="ln352">  {</a>
<a name="ln353">    if (!(_constraints.GetIgnoredBitVec() == constraints.GetIgnoredBitVec())) {</a>
<a name="ln354">      _constraints = constraints;</a>
<a name="ln355">      if (!SetupCalculations()) {</a>
<a name="ln356">        _validSetup = false;</a>
<a name="ln357">        return;</a>
<a name="ln358">      }</a>
<a name="ln359">    } else {</a>
<a name="ln360">      _constraints = constraints;</a>
<a name="ln361">    }</a>
<a name="ln362"> </a>
<a name="ln363">    _constraints.Setup(_mol);</a>
<a name="ln364">  }</a>
<a name="ln365"> </a>
<a name="ln366">  void OBForceField::SetFixAtom(int index)</a>
<a name="ln367">  {</a>
<a name="ln368">    _fixAtom = index;</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  void OBForceField::UnsetFixAtom()</a>
<a name="ln372">  {</a>
<a name="ln373">    _fixAtom = 0;</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  void OBForceField::SetIgnoreAtom(int index)</a>
<a name="ln377">  {</a>
<a name="ln378">    _ignoreAtom = index; // remember the index</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  void OBForceField::UnsetIgnoreAtom()</a>
<a name="ln382">  {</a>
<a name="ln383">    _ignoreAtom = 0;</a>
<a name="ln384">  }</a>
<a name="ln385"> </a>
<a name="ln386">  bool OBForceField::IgnoreCalculation(int a, int b)</a>
<a name="ln387">  {</a>
<a name="ln388">    if (!_ignoreAtom)</a>
<a name="ln389">      return false;</a>
<a name="ln390"> </a>
<a name="ln391">    if (_ignoreAtom == a)</a>
<a name="ln392">      return true;</a>
<a name="ln393">    if (_ignoreAtom == b)</a>
<a name="ln394">      return true;</a>
<a name="ln395"> </a>
<a name="ln396">    return false;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  bool OBForceField::IgnoreCalculation(int a, int b, int c)</a>
<a name="ln400">  {</a>
<a name="ln401">    if (OBForceField::IgnoreCalculation(a, c))</a>
<a name="ln402">      return true;</a>
<a name="ln403">    if (_ignoreAtom == b)</a>
<a name="ln404">      return true;</a>
<a name="ln405"> </a>
<a name="ln406">    return false;</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  bool OBForceField::IgnoreCalculation(int a, int b, int c, int d)</a>
<a name="ln410">  {</a>
<a name="ln411">    if (OBForceField::IgnoreCalculation(a, b, c))</a>
<a name="ln412">      return true;</a>
<a name="ln413">    if (_ignoreAtom == d)</a>
<a name="ln414">      return true;</a>
<a name="ln415"> </a>
<a name="ln416">    return false;</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  OBFFConstraints::OBFFConstraints()</a>
<a name="ln420">  {</a>
<a name="ln421">    _factor = 50000.0;</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  void OBFFConstraints::Setup(OBMol&amp; mol)</a>
<a name="ln425">  {</a>
<a name="ln426">    vector&lt;OBFFConstraint&gt;::iterator i;</a>
<a name="ln427"> </a>
<a name="ln428">    for (i = _constraints.begin(); i != _constraints.end(); ++i) {</a>
<a name="ln429">      i-&gt;a = mol.GetAtom(i-&gt;ia);</a>
<a name="ln430">      i-&gt;b = mol.GetAtom(i-&gt;ib);</a>
<a name="ln431">      i-&gt;c = mol.GetAtom(i-&gt;ic);</a>
<a name="ln432">      i-&gt;d = mol.GetAtom(i-&gt;id);</a>
<a name="ln433">    }</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  vector3 OBFFConstraints::GetGradient(int a)</a>
<a name="ln437">  {</a>
<a name="ln438">    vector&lt;OBFFConstraint&gt;::iterator i;</a>
<a name="ln439"> </a>
<a name="ln440">    vector3 grad(0.0, 0.0, 0.0);</a>
<a name="ln441"> </a>
<a name="ln442">    for (i = _constraints.begin(); i != _constraints.end(); ++i)</a>
<a name="ln443">      grad += i-&gt;GetGradient(a);</a>
<a name="ln444"> </a>
<a name="ln445">    return grad;</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  void OBFFConstraints::Clear()</a>
<a name="ln449">  {</a>
<a name="ln450">    _constraints.clear();</a>
<a name="ln451">    _ignored.Clear();</a>
<a name="ln452">    _fixed.Clear();</a>
<a name="ln453">    _Xfixed.Clear();</a>
<a name="ln454">    _Yfixed.Clear();</a>
<a name="ln455">    _Zfixed.Clear();</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458">  int OBFFConstraints::Size() const</a>
<a name="ln459">  {</a>
<a name="ln460">    return _constraints.size();</a>
<a name="ln461">  }</a>
<a name="ln462"> </a>
<a name="ln463">  double OBFFConstraints::GetConstraintEnergy()</a>
<a name="ln464">  {</a>
<a name="ln465">    vector&lt;OBFFConstraint&gt;::iterator i;</a>
<a name="ln466">    double constraint_energy = 0.0;</a>
<a name="ln467"> </a>
<a name="ln468">    for (i = _constraints.begin(); i != _constraints.end(); ++i)</a>
<a name="ln469">      if ( (i-&gt;type == OBFF_CONST_DISTANCE) || (i-&gt;type == OBFF_CONST_ANGLE) ||</a>
<a name="ln470">           (i-&gt;type == OBFF_CONST_TORSION) ) {</a>
<a name="ln471">        vector3 da, db, dc, dd;</a>
<a name="ln472">        double delta, delta2, rab, theta, dE;</a>
<a name="ln473"> </a>
<a name="ln474">        switch (i-&gt;type) {</a>
<a name="ln475">        case OBFF_CONST_DISTANCE:</a>
<a name="ln476">          if (i-&gt;a == nullptr || (i-&gt;b) == nullptr)</a>
<a name="ln477">            break;</a>
<a name="ln478"> </a>
<a name="ln479">          da = (i-&gt;a)-&gt;GetVector();</a>
<a name="ln480">          db = (i-&gt;b)-&gt;GetVector();</a>
<a name="ln481"> </a>
<a name="ln482">          rab = OBForceField::VectorLengthDerivative(da, db);</a>
<a name="ln483">          delta = rab - i-&gt;constraint_value;</a>
<a name="ln484">          delta2 = delta * delta;</a>
<a name="ln485">          constraint_energy += i-&gt;factor * delta2;</a>
<a name="ln486">          dE = 2.0 * i-&gt;factor * delta;</a>
<a name="ln487"> </a>
<a name="ln488">          i-&gt;grada = dE * da;</a>
<a name="ln489">          i-&gt;gradb = dE * db;</a>
<a name="ln490">          break;</a>
<a name="ln491">        case OBFF_CONST_ANGLE:</a>
<a name="ln492">          if (i-&gt;a == nullptr || i-&gt;b == nullptr || i-&gt;c == nullptr)</a>
<a name="ln493">            break;</a>
<a name="ln494"> </a>
<a name="ln495">          da = (i-&gt;a)-&gt;GetVector();</a>
<a name="ln496">          db = (i-&gt;b)-&gt;GetVector();</a>
<a name="ln497">          dc = (i-&gt;c)-&gt;GetVector();</a>
<a name="ln498"> </a>
<a name="ln499">          theta = OBForceField::VectorAngleDerivative(da, db, dc);</a>
<a name="ln500">          delta = theta - i-&gt;constraint_value;</a>
<a name="ln501">          delta2 = delta * delta;</a>
<a name="ln502">          constraint_energy += 0.0002 * i-&gt;factor * delta2;</a>
<a name="ln503">          dE = 0.0004 * i-&gt;factor * delta;</a>
<a name="ln504"> </a>
<a name="ln505">          i-&gt;grada = dE * da;</a>
<a name="ln506">          i-&gt;gradb = dE * db;</a>
<a name="ln507">          i-&gt;gradc = dE * dc;</a>
<a name="ln508">          break;</a>
<a name="ln509">        case OBFF_CONST_TORSION:</a>
<a name="ln510">          if (i-&gt;a == nullptr || i-&gt;b == nullptr || i-&gt;c == nullptr || i-&gt;d == nullptr)</a>
<a name="ln511">            break;</a>
<a name="ln512"> </a>
<a name="ln513">          da = (i-&gt;a)-&gt;GetVector();</a>
<a name="ln514">          db = (i-&gt;b)-&gt;GetVector();</a>
<a name="ln515">          dc = (i-&gt;c)-&gt;GetVector();</a>
<a name="ln516">          dd = (i-&gt;d)-&gt;GetVector();</a>
<a name="ln517"> </a>
<a name="ln518">          theta = OBForceField::VectorTorsionDerivative(da, db, dc, dd);</a>
<a name="ln519">          if (!isfinite(theta))</a>
<a name="ln520">            theta = 1.0e-7;</a>
<a name="ln521"> </a>
<a name="ln522">          theta = DEG_TO_RAD * (theta + 180.0 - i-&gt;constraint_value);</a>
<a name="ln523">          constraint_energy +=  0.001 * i-&gt;factor * (1.0 + cos(theta));</a>
<a name="ln524">          dE = 0.001 * i-&gt;factor * sin(theta);</a>
<a name="ln525"> </a>
<a name="ln526">          i-&gt;grada = dE * da;</a>
<a name="ln527">          i-&gt;gradb = dE * db;</a>
<a name="ln528">          i-&gt;gradc = dE * dc;</a>
<a name="ln529">          i-&gt;gradd = dE * dd;</a>
<a name="ln530">          break;</a>
<a name="ln531">        default:</a>
<a name="ln532">          break;</a>
<a name="ln533">        }</a>
<a name="ln534">      }</a>
<a name="ln535">    return constraint_energy;</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  void OBFFConstraints::DeleteConstraint(int index)</a>
<a name="ln539">  {</a>
<a name="ln540">    vector&lt;OBFFConstraint&gt;::iterator i;</a>
<a name="ln541">    int n = 0;</a>
<a name="ln542"> </a>
<a name="ln543">    for (i = _constraints.begin(); i != _constraints.end(); ++n, ++i) {</a>
<a name="ln544">      if (n == index) {</a>
<a name="ln545">        if (i-&gt;type == OBFF_CONST_IGNORE)</a>
<a name="ln546">          _ignored.SetBitOff(i-&gt;ia);</a>
<a name="ln547">        if (i-&gt;type == OBFF_CONST_ATOM)</a>
<a name="ln548">          _fixed.SetBitOff(i-&gt;ia);</a>
<a name="ln549">        if (i-&gt;type == OBFF_CONST_ATOM_X)</a>
<a name="ln550">          _Xfixed.SetBitOff(i-&gt;ia);</a>
<a name="ln551">        if (i-&gt;type == OBFF_CONST_ATOM_Y)</a>
<a name="ln552">          _Yfixed.SetBitOff(i-&gt;ia);</a>
<a name="ln553">        if (i-&gt;type == OBFF_CONST_ATOM_Z)</a>
<a name="ln554">          _Zfixed.SetBitOff(i-&gt;ia);</a>
<a name="ln555"> </a>
<a name="ln556"> </a>
<a name="ln557">        _constraints.erase(i);</a>
<a name="ln558">        break;</a>
<a name="ln559">      }</a>
<a name="ln560">    }</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  void OBFFConstraints::SetFactor(double factor)</a>
<a name="ln564">  {</a>
<a name="ln565">    _factor = factor;</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  double OBFFConstraints::GetFactor()</a>
<a name="ln569">  {</a>
<a name="ln570">    return _factor;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  void OBFFConstraints::AddIgnore(int a)</a>
<a name="ln574">  {</a>
<a name="ln575">    _ignored.SetBitOn(a);</a>
<a name="ln576"> </a>
<a name="ln577">    OBFFConstraint constraint;</a>
<a name="ln578">    constraint.type = OBFF_CONST_IGNORE; // constraint type</a>
<a name="ln579">    constraint.ia   = a; // atom to fix</a>
<a name="ln580">    _constraints.push_back(constraint);</a>
<a name="ln581">  }</a>
<a name="ln582"> </a>
<a name="ln583">  void OBFFConstraints::AddAtomConstraint(int a)</a>
<a name="ln584">  {</a>
<a name="ln585">    _fixed.SetBitOn(a);</a>
<a name="ln586"> </a>
<a name="ln587">    OBFFConstraint constraint;</a>
<a name="ln588">    constraint.type = OBFF_CONST_ATOM; // constraint type</a>
<a name="ln589">    constraint.ia   = a; // atom to fix</a>
<a name="ln590">    constraint.factor = _factor;</a>
<a name="ln591">    _constraints.push_back(constraint);</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  void OBFFConstraints::AddAtomXConstraint(int a)</a>
<a name="ln595">  {</a>
<a name="ln596">    _Xfixed.SetBitOn(a);</a>
<a name="ln597"> </a>
<a name="ln598">    OBFFConstraint constraint;</a>
<a name="ln599">    constraint.type = OBFF_CONST_ATOM_X; // constraint type</a>
<a name="ln600">    constraint.ia   = a; // atom to fix</a>
<a name="ln601">    constraint.factor = _factor;</a>
<a name="ln602">    _constraints.push_back(constraint);</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  void OBFFConstraints::AddAtomYConstraint(int a)</a>
<a name="ln606">  {</a>
<a name="ln607">    _Yfixed.SetBitOn(a);</a>
<a name="ln608"> </a>
<a name="ln609">    OBFFConstraint constraint;</a>
<a name="ln610">    constraint.type = OBFF_CONST_ATOM_Y; // constraint type</a>
<a name="ln611">    constraint.ia   = a; // atom to fix</a>
<a name="ln612">    constraint.factor = _factor;</a>
<a name="ln613">    _constraints.push_back(constraint);</a>
<a name="ln614">  }</a>
<a name="ln615"> </a>
<a name="ln616">  void OBFFConstraints::AddAtomZConstraint(int a)</a>
<a name="ln617">  {</a>
<a name="ln618">    _Zfixed.SetBitOn(a);</a>
<a name="ln619"> </a>
<a name="ln620">    OBFFConstraint constraint;</a>
<a name="ln621">    constraint.type = OBFF_CONST_ATOM_Z; // constraint type</a>
<a name="ln622">    constraint.ia   = a; // atom to fix</a>
<a name="ln623">    constraint.factor = _factor;</a>
<a name="ln624">    _constraints.push_back(constraint);</a>
<a name="ln625">  }</a>
<a name="ln626"> </a>
<a name="ln627">  void OBFFConstraints::AddDistanceConstraint(int a, int b, double length)</a>
<a name="ln628">  {</a>
<a name="ln629">    OBFFConstraint constraint;</a>
<a name="ln630">    constraint.type = OBFF_CONST_DISTANCE; // constraint type</a>
<a name="ln631">    constraint.ia   = a; // atom a</a>
<a name="ln632">    constraint.ib   = b; // atom b</a>
<a name="ln633">    constraint.constraint_value = length; // bond length</a>
<a name="ln634">    constraint.factor = _factor;</a>
<a name="ln635">    _constraints.push_back(constraint);</a>
<a name="ln636">  }</a>
<a name="ln637"> </a>
<a name="ln638">  void OBFFConstraints::AddAngleConstraint(int a, int b, int c, double angle)</a>
<a name="ln639">  {</a>
<a name="ln640">    OBFFConstraint constraint;</a>
<a name="ln641">    constraint.type = OBFF_CONST_ANGLE; // constraint type</a>
<a name="ln642">    constraint.ia   = a; // atom a</a>
<a name="ln643">    constraint.ib   = b; // atom b</a>
<a name="ln644">    constraint.ic   = c; // atom c</a>
<a name="ln645">    constraint.constraint_value = angle; // angle</a>
<a name="ln646">    constraint.factor = _factor;</a>
<a name="ln647">    _constraints.push_back(constraint);</a>
<a name="ln648">  }</a>
<a name="ln649"> </a>
<a name="ln650">  void OBFFConstraints::AddTorsionConstraint(int a, int b, int c, int d, double torsion)</a>
<a name="ln651">  {</a>
<a name="ln652">    OBFFConstraint constraint;</a>
<a name="ln653">    constraint.type = OBFF_CONST_TORSION; // constraint type</a>
<a name="ln654">    constraint.ia   = a; // atom a</a>
<a name="ln655">    constraint.ib   = b; // atom b</a>
<a name="ln656">    constraint.ic   = c; // atom c</a>
<a name="ln657">    constraint.id   = d; // atom d</a>
<a name="ln658">    constraint.constraint_value = torsion; // torsion</a>
<a name="ln659">    constraint.factor = _factor;</a>
<a name="ln660">    _constraints.push_back(constraint);</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  int OBFFConstraints::GetConstraintType(int index) const</a>
<a name="ln664">  {</a>
<a name="ln665">    if (index &gt;= _constraints.size())</a>
<a name="ln666">      return 0;</a>
<a name="ln667"> </a>
<a name="ln668">    return _constraints[index].type;</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  double OBFFConstraints::GetConstraintValue(int index) const</a>
<a name="ln672">  {</a>
<a name="ln673">    if (index &gt;= _constraints.size())</a>
<a name="ln674">      return 0;</a>
<a name="ln675"> </a>
<a name="ln676">    return _constraints[index].constraint_value;</a>
<a name="ln677">  }</a>
<a name="ln678"> </a>
<a name="ln679">  int OBFFConstraints::GetConstraintAtomA(int index) const</a>
<a name="ln680">  {</a>
<a name="ln681">    if (index &gt;= _constraints.size())</a>
<a name="ln682">      return 0;</a>
<a name="ln683"> </a>
<a name="ln684">    return _constraints[index].ia;</a>
<a name="ln685">  }</a>
<a name="ln686"> </a>
<a name="ln687">  int OBFFConstraints::GetConstraintAtomB(int index) const</a>
<a name="ln688">  {</a>
<a name="ln689">    if (index &gt;= _constraints.size())</a>
<a name="ln690">      return 0;</a>
<a name="ln691"> </a>
<a name="ln692">    return _constraints[index].ib;</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695">  int OBFFConstraints::GetConstraintAtomC(int index) const</a>
<a name="ln696">  {</a>
<a name="ln697">    if (index &gt;= _constraints.size())</a>
<a name="ln698">      return 0;</a>
<a name="ln699"> </a>
<a name="ln700">    return _constraints[index].ic;</a>
<a name="ln701">  }</a>
<a name="ln702"> </a>
<a name="ln703">  int OBFFConstraints::GetConstraintAtomD(int index) const</a>
<a name="ln704">  {</a>
<a name="ln705">    if (index &gt;= _constraints.size())</a>
<a name="ln706">      return 0;</a>
<a name="ln707"> </a>
<a name="ln708">    return _constraints[index].id;</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  bool OBFFConstraints::IsIgnored(int index)</a>
<a name="ln712">  {</a>
<a name="ln713">    return _ignored.BitIsSet(index);</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  bool OBFFConstraints::IsFixed(int index)</a>
<a name="ln717">  {</a>
<a name="ln718">    return _fixed.BitIsSet(index);</a>
<a name="ln719">  }</a>
<a name="ln720"> </a>
<a name="ln721">  bool OBFFConstraints::IsXFixed(int index)</a>
<a name="ln722">  {</a>
<a name="ln723">    return _Xfixed.BitIsSet(index);</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  bool OBFFConstraints::IsYFixed(int index)</a>
<a name="ln727">  {</a>
<a name="ln728">    return _Yfixed.BitIsSet(index);</a>
<a name="ln729">  }</a>
<a name="ln730"> </a>
<a name="ln731">  bool OBFFConstraints::IsZFixed(int index)</a>
<a name="ln732">  {</a>
<a name="ln733">    return _Zfixed.BitIsSet(index);</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln737">  //</a>
<a name="ln738">  // Methods for logging</a>
<a name="ln739">  //</a>
<a name="ln740">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln741"> </a>
<a name="ln742">  void OBForceField::PrintTypes()</a>
<a name="ln743">  {</a>
<a name="ln744">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln745">      OBFFLog(&quot;\nA T O M   T Y P E S\n\n&quot;);</a>
<a name="ln746">      OBFFLog(&quot;IDX\tTYPE\tRING\n&quot;);</a>
<a name="ln747"> </a>
<a name="ln748">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln749">        snprintf(_logbuf, BUFF_SIZE, &quot;%d\t%s\t%s\n&quot;, a-&gt;GetIdx(), a-&gt;GetType(),</a>
<a name="ln750">          (a-&gt;IsInRing() ? (a-&gt;IsAromatic() ? &quot;AR&quot; : &quot;AL&quot;) : &quot;NO&quot;));</a>
<a name="ln751">        OBFFLog(_logbuf);</a>
<a name="ln752">      }</a>
<a name="ln753">    }</a>
<a name="ln754">  }</a>
<a name="ln755"> </a>
<a name="ln756">  void OBForceField::PrintFormalCharges()</a>
<a name="ln757">  {</a>
<a name="ln758">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln759">      OBFFLog(&quot;\nF O R M A L   C H A R G E S\n\n&quot;);</a>
<a name="ln760">      OBFFLog(&quot;IDX\tCHARGE\n&quot;);</a>
<a name="ln761"> </a>
<a name="ln762">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln763">        snprintf(_logbuf, BUFF_SIZE, &quot;%d\t%f\n&quot;, a-&gt;GetIdx(), a-&gt;GetPartialCharge());</a>
<a name="ln764">        OBFFLog(_logbuf);</a>
<a name="ln765">      }</a>
<a name="ln766">    }</a>
<a name="ln767">  }</a>
<a name="ln768"> </a>
<a name="ln769">  void OBForceField::PrintPartialCharges()</a>
<a name="ln770">  {</a>
<a name="ln771">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln772">      OBFFLog(&quot;\nP A R T I A L   C H A R G E S\n\n&quot;);</a>
<a name="ln773">      OBFFLog(&quot;IDX\tCHARGE\n&quot;);</a>
<a name="ln774"> </a>
<a name="ln775">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln776">        snprintf(_logbuf, BUFF_SIZE, &quot;%d\t%f\n&quot;, a-&gt;GetIdx(), a-&gt;GetPartialCharge());</a>
<a name="ln777">        OBFFLog(_logbuf);</a>
<a name="ln778">      }</a>
<a name="ln779">    }</a>
<a name="ln780">  }</a>
<a name="ln781"> </a>
<a name="ln782">  void OBForceField::PrintVelocities()</a>
<a name="ln783">  {</a>
<a name="ln784">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln785">      OBFFLog(&quot;\nA T O M   V E L O C I T I E S\n\n&quot;);</a>
<a name="ln786">      OBFFLog(&quot;IDX\tVELOCITY\n&quot;);</a>
<a name="ln787"> </a>
<a name="ln788">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln789">        snprintf(_logbuf, BUFF_SIZE, &quot;%d\t&lt;%8.3f, %8.3f, %8.3f&gt;\n&quot;, a-&gt;GetIdx(), _velocityPtr[a-&gt;GetIdx()],</a>
<a name="ln790">                 _velocityPtr[a-&gt;GetIdx()+1], _velocityPtr[a-&gt;GetIdx()+2]);</a>
<a name="ln791">        OBFFLog(_logbuf);</a>
<a name="ln792">      }</a>
<a name="ln793">    }</a>
<a name="ln794">  }</a>
<a name="ln795"> </a>
<a name="ln796">  bool OBForceField::SetLogFile(ostream* pos)</a>
<a name="ln797">  {</a>
<a name="ln798">    if(pos)</a>
<a name="ln799">      _logos = pos;</a>
<a name="ln800">    else</a>
<a name="ln801">      _logos = &amp;cout;</a>
<a name="ln802"> </a>
<a name="ln803">    return true;</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln807">  //</a>
<a name="ln808">  // General</a>
<a name="ln809">  //</a>
<a name="ln810">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln811"> </a>
<a name="ln812">  bool OBForceField::Setup(OBMol &amp;mol)</a>
<a name="ln813">  {</a>
<a name="ln814">    if (!_init) {</a>
<a name="ln815">      ParseParamFile();</a>
<a name="ln816">      _init = true;</a>
<a name="ln817">      _velocityPtr = nullptr;</a>
<a name="ln818">      _gradientPtr = nullptr;</a>
<a name="ln819">      _grad1 = nullptr;</a>
<a name="ln820">    }</a>
<a name="ln821"> </a>
<a name="ln822">    if (IsSetupNeeded(mol)) {</a>
<a name="ln823">      _mol = mol;</a>
<a name="ln824">      _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln825"> </a>
<a name="ln826">      if (_velocityPtr)</a>
<a name="ln827">        delete [] _velocityPtr;</a>
<a name="ln828">      _velocityPtr = nullptr;</a>
<a name="ln829"> </a>
<a name="ln830">      if (_gradientPtr)</a>
<a name="ln831">        delete [] _gradientPtr;</a>
<a name="ln832">      _gradientPtr = new double[_ncoords];</a>
<a name="ln833"> </a>
<a name="ln834">      if (_mol.NumAtoms() &amp;&amp; _constraints.Size())</a>
<a name="ln835">        _constraints.Setup(_mol);</a>
<a name="ln836"> </a>
<a name="ln837">      _mol.SetSSSRPerceived(false);</a>
<a name="ln838">      _mol.DeleteData(OBGenericDataType::TorsionData); // bug #1954233</a>
<a name="ln839"> </a>
<a name="ln840">      if (!SetTypes()) {</a>
<a name="ln841">        _validSetup = false;</a>
<a name="ln842">        return false;</a>
<a name="ln843">      }</a>
<a name="ln844"> </a>
<a name="ln845">      SetFormalCharges();</a>
<a name="ln846">      SetPartialCharges();</a>
<a name="ln847"> </a>
<a name="ln848">      if (!SetupCalculations()) {</a>
<a name="ln849">        _validSetup = false;</a>
<a name="ln850">        return false;</a>
<a name="ln851">      }</a>
<a name="ln852"> </a>
<a name="ln853">    } else {</a>
<a name="ln854">      if (_validSetup) {</a>
<a name="ln855">        PrintTypes();</a>
<a name="ln856">        PrintFormalCharges();</a>
<a name="ln857">        PrintPartialCharges();</a>
<a name="ln858">        SetCoordinates(mol);</a>
<a name="ln859">        return true;</a>
<a name="ln860">      } else {</a>
<a name="ln861">        return false;</a>
<a name="ln862">      }</a>
<a name="ln863">    }</a>
<a name="ln864"> </a>
<a name="ln865">    _validSetup = true;</a>
<a name="ln866">    return true;</a>
<a name="ln867">  }</a>
<a name="ln868"> </a>
<a name="ln869">  bool OBForceField::Setup(OBMol &amp;mol, OBFFConstraints &amp;constraints)</a>
<a name="ln870">  {</a>
<a name="ln871">    if (!_init) {</a>
<a name="ln872">      ParseParamFile();</a>
<a name="ln873">      _init = true;</a>
<a name="ln874">      _velocityPtr = nullptr;</a>
<a name="ln875">      _gradientPtr = nullptr;</a>
<a name="ln876">    }</a>
<a name="ln877"> </a>
<a name="ln878">    if (IsSetupNeeded(mol)) {</a>
<a name="ln879">      _mol = mol;</a>
<a name="ln880">      _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln881"> </a>
<a name="ln882">      if (_velocityPtr)</a>
<a name="ln883">        delete [] _velocityPtr;</a>
<a name="ln884">      _velocityPtr = nullptr;</a>
<a name="ln885"> </a>
<a name="ln886">      if (_gradientPtr)</a>
<a name="ln887">        delete [] _gradientPtr;</a>
<a name="ln888">      _gradientPtr = new double[_ncoords];</a>
<a name="ln889"> </a>
<a name="ln890">      _constraints = constraints;</a>
<a name="ln891">      if (_mol.NumAtoms() &amp;&amp; _constraints.Size())</a>
<a name="ln892">        _constraints.Setup(_mol);</a>
<a name="ln893"> </a>
<a name="ln894">      _mol.SetSSSRPerceived(false);</a>
<a name="ln895">      _mol.DeleteData(OBGenericDataType::TorsionData); // bug #1954233</a>
<a name="ln896"> </a>
<a name="ln897">      if (!SetTypes()) {</a>
<a name="ln898">        _validSetup = false;</a>
<a name="ln899">        return false;</a>
<a name="ln900">      }</a>
<a name="ln901"> </a>
<a name="ln902">      SetFormalCharges();</a>
<a name="ln903">      SetPartialCharges();</a>
<a name="ln904"> </a>
<a name="ln905">      if (!SetupCalculations()) {</a>
<a name="ln906">        _validSetup = false;</a>
<a name="ln907">        return false;</a>
<a name="ln908">      }</a>
<a name="ln909"> </a>
<a name="ln910">    } else {</a>
<a name="ln911">      if (_validSetup) {</a>
<a name="ln912">        if (!(_constraints.GetIgnoredBitVec() == constraints.GetIgnoredBitVec())) {</a>
<a name="ln913">          _constraints = constraints;</a>
<a name="ln914">          if (!SetupCalculations()) {</a>
<a name="ln915">            _validSetup = false;</a>
<a name="ln916">            return false;</a>
<a name="ln917">          }</a>
<a name="ln918">        } else {</a>
<a name="ln919">          _constraints = constraints;</a>
<a name="ln920">        }</a>
<a name="ln921"> </a>
<a name="ln922">        _constraints.Setup(_mol);</a>
<a name="ln923">        SetCoordinates(mol);</a>
<a name="ln924">        return true;</a>
<a name="ln925">      } else {</a>
<a name="ln926">        return false;</a>
<a name="ln927">      }</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">    _validSetup = true;</a>
<a name="ln931">    return true;</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  bool OBForceField::SetLogLevel(int level)</a>
<a name="ln935">  {</a>
<a name="ln936">    _loglvl = level;</a>
<a name="ln937"> </a>
<a name="ln938">    return true;</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  // This function might need expanding, bu could really increase performance for</a>
<a name="ln942">  // avogadro's AutoOpt tool</a>
<a name="ln943">  bool OBForceField::IsSetupNeeded(OBMol &amp;mol)</a>
<a name="ln944">  {</a>
<a name="ln945">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln946">      return true;</a>
<a name="ln947"> </a>
<a name="ln948">    if (_mol.NumBonds() != mol.NumBonds())</a>
<a name="ln949">      return true;</a>
<a name="ln950"> </a>
<a name="ln951">    FOR_ATOMS_OF_MOL (atom, _mol) {</a>
<a name="ln952">      // if we have Fe or Cu the atom type depends on the formal</a>
<a name="ln953">      // charge, so a new setup must be forced anyway</a>
<a name="ln954">      if (atom-&gt;GetAtomicNum() == 26 || atom-&gt;GetAtomicNum() == 29)</a>
<a name="ln955">        return true;</a>
<a name="ln956">      if (atom-&gt;GetAtomicNum() != (mol.GetAtom(atom-&gt;GetIdx()))-&gt;GetAtomicNum())</a>
<a name="ln957">        return true;</a>
<a name="ln958">      if (atom-&gt;GetExplicitDegree() != (mol.GetAtom(atom-&gt;GetIdx()))-&gt;GetExplicitDegree())</a>
<a name="ln959">        return true;</a>
<a name="ln960">    }</a>
<a name="ln961">    FOR_BONDS_OF_MOL (bond, _mol) {</a>
<a name="ln962">      if (bond-&gt;GetBondOrder() != (mol.GetBond(bond-&gt;GetIdx()))-&gt;GetBondOrder())</a>
<a name="ln963">        return true;</a>
<a name="ln964">      if (bond-&gt;GetBeginAtom()-&gt;GetAtomicNum()</a>
<a name="ln965">          != (mol.GetBond(bond-&gt;GetIdx()))-&gt;GetBeginAtom()-&gt;GetAtomicNum()</a>
<a name="ln966">          || bond-&gt;GetEndAtom()-&gt;GetAtomicNum()</a>
<a name="ln967">          != (mol.GetBond(bond-&gt;GetIdx()))-&gt;GetEndAtom()-&gt;GetAtomicNum())</a>
<a name="ln968">        return true;</a>
<a name="ln969">    }</a>
<a name="ln970"> </a>
<a name="ln971">    return false;</a>
<a name="ln972">  }</a>
<a name="ln973"> </a>
<a name="ln974">  bool OBForceField::GetAtomTypes(OBMol &amp;mol)</a>
<a name="ln975">  {</a>
<a name="ln976">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln977">      return false;</a>
<a name="ln978"> </a>
<a name="ln979">    FOR_ATOMS_OF_MOL (intAtom, _mol) {</a>
<a name="ln980">      OBAtom *extAtom = mol.GetAtom(intAtom-&gt;GetIdx());</a>
<a name="ln981"> </a>
<a name="ln982">      if (extAtom-&gt;HasData(&quot;FFAtomType&quot;)) {</a>
<a name="ln983">        OBPairData *data = (OBPairData*) extAtom-&gt;GetData(&quot;FFAtomType&quot;);</a>
<a name="ln984">        data-&gt;SetValue(intAtom-&gt;GetType());</a>
<a name="ln985">      } else {</a>
<a name="ln986">        OBPairData *data = new OBPairData();</a>
<a name="ln987">       	data-&gt;SetAttribute(&quot;FFAtomType&quot;);</a>
<a name="ln988">        data-&gt;SetValue(intAtom-&gt;GetType());</a>
<a name="ln989">        extAtom-&gt;SetData(data);</a>
<a name="ln990">      }</a>
<a name="ln991">    }</a>
<a name="ln992"> </a>
<a name="ln993">    return true;</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  bool OBForceField::GetPartialCharges(OBMol &amp;mol)</a>
<a name="ln997">  {</a>
<a name="ln998">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln999">      return false;</a>
<a name="ln1000"> </a>
<a name="ln1001">    ostringstream out;</a>
<a name="ln1002">    FOR_ATOMS_OF_MOL (intAtom, _mol) {</a>
<a name="ln1003">      OBAtom *extAtom = mol.GetAtom(intAtom-&gt;GetIdx());</a>
<a name="ln1004"> </a>
<a name="ln1005">      out.str(&quot;&quot;);</a>
<a name="ln1006">      out &lt;&lt; intAtom-&gt;GetPartialCharge();</a>
<a name="ln1007">      if (extAtom-&gt;HasData(&quot;FFPartialCharge&quot;)) {</a>
<a name="ln1008">        OBPairData *data = (OBPairData*) extAtom-&gt;GetData(&quot;FFPartialCharge&quot;);</a>
<a name="ln1009">        data-&gt;SetValue(out.str());</a>
<a name="ln1010">      } else {</a>
<a name="ln1011">        OBPairData *data = new OBPairData();</a>
<a name="ln1012">       	data-&gt;SetAttribute(&quot;FFPartialCharge&quot;);</a>
<a name="ln1013">        data-&gt;SetValue(out.str());</a>
<a name="ln1014">        extAtom-&gt;SetData(data);</a>
<a name="ln1015">      }</a>
<a name="ln1016">    }</a>
<a name="ln1017"> </a>
<a name="ln1018">    return true;</a>
<a name="ln1019">  }</a>
<a name="ln1020"> </a>
<a name="ln1021"> </a>
<a name="ln1022">  bool OBForceField::GetCoordinates(OBMol &amp;mol)</a>
<a name="ln1023">  {</a>
<a name="ln1024">    OBAtom *atom;</a>
<a name="ln1025"> </a>
<a name="ln1026">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln1027">      return false;</a>
<a name="ln1028"> </a>
<a name="ln1029">    // Copy coordinates for current conformer only</a>
<a name="ln1030">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln1031">      atom = mol.GetAtom(a-&gt;GetIdx());</a>
<a name="ln1032">      atom-&gt;SetVector(a-&gt;GetVector());</a>
<a name="ln1033">    }</a>
<a name="ln1034"> </a>
<a name="ln1035">    if (!mol.HasData(OBGenericDataType::ConformerData))</a>
<a name="ln1036">      mol.SetData(new OBConformerData);</a>
<a name="ln1037">    OBConformerData *cd = (OBConformerData*) mol.GetData(OBGenericDataType::ConformerData);</a>
<a name="ln1038">    cd-&gt;SetEnergies(_energies);</a>
<a name="ln1039"> </a>
<a name="ln1040">    vector&lt;vector3&gt; forces;</a>
<a name="ln1041">    vector&lt;vector&lt;vector3&gt; &gt; confForces;</a>
<a name="ln1042">    for (unsigned int i = 0; i &lt; _mol.NumAtoms(); ++i) {</a>
<a name="ln1043">      const int coordIdx = i * 3;</a>
<a name="ln1044">      forces.push_back(vector3(_gradientPtr[coordIdx],</a>
<a name="ln1045">                               _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]));</a>
<a name="ln1046">    }</a>
<a name="ln1047">    confForces.push_back(forces);</a>
<a name="ln1048">    cd-&gt;SetForces(confForces);</a>
<a name="ln1049"> </a>
<a name="ln1050">    return true;</a>
<a name="ln1051">  }</a>
<a name="ln1052"> </a>
<a name="ln1053">  bool OBForceField::GetConformers(OBMol &amp;mol)</a>
<a name="ln1054">  {</a>
<a name="ln1055">    //    OBAtom *atom;</a>
<a name="ln1056"> </a>
<a name="ln1057">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln1058">      return false;</a>
<a name="ln1059"> </a>
<a name="ln1060">    /*</a>
<a name="ln1061">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln1062">      atom = mol.GetAtom(a-&gt;GetIdx());</a>
<a name="ln1063">      atom-&gt;SetVector(a-&gt;GetVector());</a>
<a name="ln1064">      }</a>
<a name="ln1065">    */</a>
<a name="ln1066"> </a>
<a name="ln1067">    //Copy conformer information</a>
<a name="ln1068">    if (_mol.NumConformers() &gt; 0) {</a>
<a name="ln1069">      int k,l;</a>
<a name="ln1070">      vector&lt;double*&gt; conf;</a>
<a name="ln1071">      double* xyz = nullptr;</a>
<a name="ln1072">      for (k=0 ; k&lt;_mol.NumConformers() ; ++k) {</a>
<a name="ln1073">        xyz = new double [3*_mol.NumAtoms()];</a>
<a name="ln1074">        for (l=0 ; l&lt;(int) (3*_mol.NumAtoms()) ; ++l)</a>
<a name="ln1075">          xyz[l] = _mol.GetConformer(k)[l];</a>
<a name="ln1076">        conf.push_back(xyz);</a>
<a name="ln1077">      }</a>
<a name="ln1078">      mol.SetConformers(conf);</a>
<a name="ln1079">      mol.SetConformer(_current_conformer);</a>
<a name="ln1080"> </a>
<a name="ln1081">      if (!mol.HasData(OBGenericDataType::ConformerData))</a>
<a name="ln1082">        mol.SetData(new OBConformerData);</a>
<a name="ln1083">      OBConformerData *cd = (OBConformerData*) mol.GetData(OBGenericDataType::ConformerData);</a>
<a name="ln1084">      cd-&gt;SetEnergies(_energies);</a>
<a name="ln1085"> </a>
<a name="ln1086">      //mol.SetEnergies(_energies);</a>
<a name="ln1087">    }</a>
<a name="ln1088"> </a>
<a name="ln1089">    return true;</a>
<a name="ln1090">  }</a>
<a name="ln1091"> </a>
<a name="ln1092">  bool OBForceField::SetCoordinates(OBMol &amp;mol)</a>
<a name="ln1093">  {</a>
<a name="ln1094">    OBAtom *atom;</a>
<a name="ln1095"> </a>
<a name="ln1096">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln1097">      return false;</a>
<a name="ln1098"> </a>
<a name="ln1099">    // Copy coordinates for current conformer only</a>
<a name="ln1100">    FOR_ATOMS_OF_MOL (a, mol) {</a>
<a name="ln1101">      atom = _mol.GetAtom(a-&gt;GetIdx());</a>
<a name="ln1102">      atom-&gt;SetVector(a-&gt;GetVector());</a>
<a name="ln1103">    }</a>
<a name="ln1104"> </a>
<a name="ln1105">    return true;</a>
<a name="ln1106">  }</a>
<a name="ln1107"> </a>
<a name="ln1108">  bool OBForceField::SetConformers(OBMol &amp;mol)</a>
<a name="ln1109">  {</a>
<a name="ln1110">    OBAtom *atom;</a>
<a name="ln1111"> </a>
<a name="ln1112">    if (_mol.NumAtoms() != mol.NumAtoms())</a>
<a name="ln1113">      return false;</a>
<a name="ln1114"> </a>
<a name="ln1115">    FOR_ATOMS_OF_MOL (a, mol) {</a>
<a name="ln1116">      atom = _mol.GetAtom(a-&gt;GetIdx());</a>
<a name="ln1117">      atom-&gt;SetVector(a-&gt;GetVector());</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    //Copy conformer information</a>
<a name="ln1121">    if (mol.NumConformers() &gt; 1) {</a>
<a name="ln1122">      int k,l;</a>
<a name="ln1123">      vector&lt;double*&gt; conf;</a>
<a name="ln1124">      double* xyz = nullptr;</a>
<a name="ln1125">      for (k=0 ; k&lt;mol.NumConformers() ; ++k) {</a>
<a name="ln1126">        xyz = new double [3*mol.NumAtoms()];</a>
<a name="ln1127">        for (l=0 ; l&lt;(int) (3*mol.NumAtoms()) ; ++l)</a>
<a name="ln1128">          xyz[l] = mol.GetConformer(k)[l];</a>
<a name="ln1129">        conf.push_back(xyz);</a>
<a name="ln1130">      }</a>
<a name="ln1131">      _mol.SetConformers(conf);</a>
<a name="ln1132">      _mol.SetConformer(_current_conformer);</a>
<a name="ln1133">      SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1134">    }</a>
<a name="ln1135"> </a>
<a name="ln1136">    return true;</a>
<a name="ln1137">  }</a>
<a name="ln1138"> </a>
<a name="ln1139">  vector3 OBForceField::ValidateGradientError(vector3 &amp;numgrad, vector3 &amp;anagrad)</a>
<a name="ln1140">  {</a>
<a name="ln1141">    double errx, erry, errz;</a>
<a name="ln1142"> </a>
<a name="ln1143">    if (fabs(numgrad.x()) &lt; 1.0)</a>
<a name="ln1144">      errx = numgrad.x() * fabs(numgrad.x() - anagrad.x()) * 100;</a>
<a name="ln1145">    else</a>
<a name="ln1146">      errx = fabs((numgrad.x() - anagrad.x()) / numgrad.x()) * 100;</a>
<a name="ln1147"> </a>
<a name="ln1148">    if (fabs(numgrad.y()) &lt; 1.0)</a>
<a name="ln1149">      erry = numgrad.y() * fabs(numgrad.y() - anagrad.y()) * 100;</a>
<a name="ln1150">    else</a>
<a name="ln1151">      erry = fabs((numgrad.y() - anagrad.y()) / numgrad.y()) * 100;</a>
<a name="ln1152"> </a>
<a name="ln1153">    if (fabs(numgrad.z()) &lt; 1.0)</a>
<a name="ln1154">      errz = numgrad.z() * fabs(numgrad.z() - anagrad.z()) * 100;</a>
<a name="ln1155">    else</a>
<a name="ln1156">      errz = fabs((numgrad.z() - anagrad.z()) / numgrad.z()) * 100;</a>
<a name="ln1157"> </a>
<a name="ln1158">    errx = fabs(errx);</a>
<a name="ln1159">    erry = fabs(erry);</a>
<a name="ln1160">    errz = fabs(errz);</a>
<a name="ln1161"> </a>
<a name="ln1162">    return vector3(errx, erry, errz);</a>
<a name="ln1163">  }</a>
<a name="ln1164"> </a>
<a name="ln1165">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1166">  //</a>
<a name="ln1167">  // Structure generation</a>
<a name="ln1168">  //</a>
<a name="ln1169">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1170"> </a>
<a name="ln1171">  int OBForceField::SystematicRotorSearchInitialize(unsigned int geomSteps, bool sampleRingBonds)</a>
<a name="ln1172">  {</a>
<a name="ln1173">    if (!_validSetup)</a>
<a name="ln1174">      return 0;</a>
<a name="ln1175"> </a>
<a name="ln1176">    OBRotorList rl;</a>
<a name="ln1177">    OBRotamerList rotamers;</a>
<a name="ln1178">    OBRotorIterator ri;</a>
<a name="ln1179">    OBRotor *rotor;</a>
<a name="ln1180"> </a>
<a name="ln1181">    _origLogLevel = _loglvl;</a>
<a name="ln1182"> </a>
<a name="ln1183">    OBBitVec fixed = _constraints.GetFixedBitVec();</a>
<a name="ln1184">    rl.SetFixAtoms(fixed);</a>
<a name="ln1185">    rl.Setup(_mol, sampleRingBonds);</a>
<a name="ln1186">    rotamers.SetBaseCoordinateSets(_mol);</a>
<a name="ln1187">    rotamers.Setup(_mol, rl);</a>
<a name="ln1188"> </a>
<a name="ln1189">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1190">      OBFFLog(&quot;\nS Y S T E M A T I C   R O T O R   S E A R C H\n\n&quot;);</a>
<a name="ln1191">      snprintf(_logbuf, BUFF_SIZE, &quot;  NUMBER OF ROTATABLE BONDS: %lu\n&quot;, (unsigned long)rl.Size());</a>
<a name="ln1192">      OBFFLog(_logbuf);</a>
<a name="ln1193"> </a>
<a name="ln1194">      unsigned long int combinations = 1;</a>
<a name="ln1195">      for (rotor = rl.BeginRotor(ri); rotor;</a>
<a name="ln1196">           rotor = rl.NextRotor(ri)) {</a>
<a name="ln1197">        combinations *= rotor-&gt;GetResolution().size();</a>
<a name="ln1198">      }</a>
<a name="ln1199">      snprintf(_logbuf, BUFF_SIZE, &quot;  NUMBER OF POSSIBLE ROTAMERS: %lu\n&quot;, combinations);</a>
<a name="ln1200">      OBFFLog(_logbuf);</a>
<a name="ln1201">    }</a>
<a name="ln1202"> </a>
<a name="ln1203">    _current_conformer = 0;</a>
<a name="ln1204"> </a>
<a name="ln1205">    if (!rl.Size()) { // only one conformer</a>
<a name="ln1206">      IF_OBFF_LOGLVL_LOW</a>
<a name="ln1207">        OBFFLog(&quot;  GENERATED ONLY ONE CONFORMER\n\n&quot;);</a>
<a name="ln1208"> </a>
<a name="ln1209">      ConjugateGradients(geomSteps); // final energy minimizatin for best conformation</a>
<a name="ln1210"> </a>
<a name="ln1211">      return 1; // there are no more conformers</a>
<a name="ln1212">    }</a>
<a name="ln1213"> </a>
<a name="ln1214">    OBRotorKeys rotorKeys;</a>
<a name="ln1215">    rotor = rl.BeginRotor(ri);</a>
<a name="ln1216">    for (unsigned int i = 1; i &lt; rl.Size() + 1; ++i, rotor = rl.NextRotor(ri)) // foreach rotor</a>
<a name="ln1217">      rotorKeys.AddRotor(rotor-&gt;GetResolution().size());</a>
<a name="ln1218"> </a>
<a name="ln1219">    rotamers.AddRotamer(rotorKeys.GetKey());</a>
<a name="ln1220">    while (rotorKeys.Next())</a>
<a name="ln1221">      rotamers.AddRotamer(rotorKeys.GetKey());</a>
<a name="ln1222"> </a>
<a name="ln1223">    rotamers.ExpandConformerList(_mol, _mol.GetConformers());</a>
<a name="ln1224"> </a>
<a name="ln1225">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1226">      snprintf(_logbuf, BUFF_SIZE, &quot;  GENERATED %d CONFORMERS\n\n&quot;, _mol.NumConformers());</a>
<a name="ln1227">      OBFFLog(_logbuf);</a>
<a name="ln1228">      OBFFLog(&quot;CONFORMER     ENERGY\n&quot;);</a>
<a name="ln1229">      OBFFLog(&quot;--------------------\n&quot;);</a>
<a name="ln1230">    }</a>
<a name="ln1231"> </a>
<a name="ln1232">    _energies.clear();</a>
<a name="ln1233"> </a>
<a name="ln1234">    return _mol.NumConformers();</a>
<a name="ln1235">  }</a>
<a name="ln1236"> </a>
<a name="ln1237">  bool OBForceField::SystematicRotorSearchNextConformer(unsigned int geomSteps)</a>
<a name="ln1238">  {</a>
<a name="ln1239">    if (!_validSetup)</a>
<a name="ln1240">      return 0;</a>
<a name="ln1241"> </a>
<a name="ln1242">    if (_current_conformer &gt;=  _mol.NumConformers()) { // done</a>
<a name="ln1243">      // Select conformer with lowest energy</a>
<a name="ln1244">      int best_conformer = 0;</a>
<a name="ln1245">      for (int i = 0; i &lt; _mol.NumConformers(); i++) {</a>
<a name="ln1246">        if (_energies[i] &lt; _energies[best_conformer])</a>
<a name="ln1247">          best_conformer = i;</a>
<a name="ln1248">      }</a>
<a name="ln1249"> </a>
<a name="ln1250">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1251">        snprintf(_logbuf, BUFF_SIZE, &quot;\n  CONFORMER %d HAS THE LOWEST ENERGY\n\n&quot;,  best_conformer + 1);</a>
<a name="ln1252">        OBFFLog(_logbuf);</a>
<a name="ln1253">      }</a>
<a name="ln1254"> </a>
<a name="ln1255">      _mol.SetConformer(best_conformer);</a>
<a name="ln1256">      SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1257">      _current_conformer = best_conformer;</a>
<a name="ln1258"> </a>
<a name="ln1259">      return false;</a>
<a name="ln1260">    }</a>
<a name="ln1261"> </a>
<a name="ln1262">    _mol.SetConformer(_current_conformer); // select conformer</a>
<a name="ln1263">    SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1264"> </a>
<a name="ln1265">    _loglvl = OBFF_LOGLVL_NONE;</a>
<a name="ln1266">    ConjugateGradients(geomSteps); // energy minimization for conformer</a>
<a name="ln1267">    _loglvl = _origLogLevel;</a>
<a name="ln1268"> </a>
<a name="ln1269">    _energies.push_back(Energy(false)); // calculate and store energy</a>
<a name="ln1270"> </a>
<a name="ln1271">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1272">      snprintf(_logbuf, BUFF_SIZE, &quot;   %3d   %20.3f\n&quot;, (_current_conformer + 1), _energies[_current_conformer]);</a>
<a name="ln1273">      OBFFLog(_logbuf);</a>
<a name="ln1274">    }</a>
<a name="ln1275"> </a>
<a name="ln1276">    _current_conformer++;</a>
<a name="ln1277">    return true;</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  void OBForceField::SystematicRotorSearch(unsigned int geomSteps, bool sampleRingBonds)</a>
<a name="ln1281">  {</a>
<a name="ln1282">    if (SystematicRotorSearchInitialize(geomSteps, sampleRingBonds))</a>
<a name="ln1283">      while (SystematicRotorSearchNextConformer(geomSteps)) {}</a>
<a name="ln1284">  }</a>
<a name="ln1285"> </a>
<a name="ln1286">  int OBForceField::FastRotorSearch(bool permute)</a>
<a name="ln1287">  {</a>
<a name="ln1288">    if (_mol.NumRotors() == 0)</a>
<a name="ln1289">      return 0;</a>
<a name="ln1290"> </a>
<a name="ln1291">    int origLogLevel = _loglvl;</a>
<a name="ln1292"> </a>
<a name="ln1293">    // Remove all conformers (e.g. from previous conformer generators) except for current conformer</a>
<a name="ln1294">    double *initialCoord = new double [_mol.NumAtoms() * 3]; // initial state</a>
<a name="ln1295">    double *store_initial = new double [_mol.NumAtoms() * 3]; // store the initial state</a>
<a name="ln1296">    memcpy((char*)initialCoord,(char*)_mol.GetCoordinates(),sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1297">    memcpy((char*)store_initial,(char*)_mol.GetCoordinates(),sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1298">    std::vector&lt;double *&gt; newConfs(1, initialCoord);</a>
<a name="ln1299">    _mol.SetConformers(newConfs);</a>
<a name="ln1300"> </a>
<a name="ln1301">    _energies.clear(); // Wipe any energies from previous conformer generators</a>
<a name="ln1302"> </a>
<a name="ln1303">    OBRotorList rl;</a>
<a name="ln1304">    OBBitVec fixed = _constraints.GetFixedBitVec();</a>
<a name="ln1305">    rl.SetFixAtoms(fixed);</a>
<a name="ln1306">    rl.SetQuiet();</a>
<a name="ln1307">    rl.Setup(_mol);</a>
<a name="ln1308"> </a>
<a name="ln1309">    OBRotorIterator ri;</a>
<a name="ln1310">    OBRotamerList rotamerlist;</a>
<a name="ln1311">    rotamerlist.SetBaseCoordinateSets(_mol);</a>
<a name="ln1312">    rotamerlist.Setup(_mol, rl);</a>
<a name="ln1313"> </a>
<a name="ln1314">    // Start with all of the rotors in their 0 position</a>
<a name="ln1315">    // (perhaps instead I should set them randomly?)</a>
<a name="ln1316">    std::vector&lt;int&gt; init_rotorKey(rl.Size() + 1, 0);</a>
<a name="ln1317">    std::vector&lt;int&gt; rotorKey(init_rotorKey);</a>
<a name="ln1318"> </a>
<a name="ln1319">    unsigned int j, minj;</a>
<a name="ln1320">    double currentE, minE, best_minE;</a>
<a name="ln1321"> </a>
<a name="ln1322">    double *verybestconf = new double [_mol.NumAtoms() * 3]; // store the best conformer to date</a>
<a name="ln1323">    double *bestconf = new double [_mol.NumAtoms() * 3]; // store the best conformer to date in the current permutation</a>
<a name="ln1324">    double *minconf = new double [_mol.NumAtoms() * 3];  // store the best conformer for the current rotor</a>
<a name="ln1325">    memcpy((char*)bestconf,(char*)_mol.GetCoordinates(),sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1326"> </a>
<a name="ln1327">    double energy_offset;</a>
<a name="ln1328">    // Can take shortcut later, as 4 components of the energy will be constant</a>
<a name="ln1329">    rotamerlist.SetCurrentCoordinates(_mol, rotorKey);</a>
<a name="ln1330">    SetupPointers();</a>
<a name="ln1331">    energy_offset = E_Bond(false) + E_Angle(false) + E_StrBnd(false) + E_OOP(false);</a>
<a name="ln1332"> </a>
<a name="ln1333">    // This function relies on the fact that Rotors are ordered from the most</a>
<a name="ln1334">    // central to the most peripheral (due to CompareRotors in rotor.cpp)</a>
<a name="ln1335">    std::vector&lt;OBRotor *&gt; vrotors;</a>
<a name="ln1336">    OBRotor *rotor;</a>
<a name="ln1337">    for (rotor = rl.BeginRotor(ri); rotor; rotor = rl.NextRotor(ri))</a>
<a name="ln1338">      vrotors.push_back(rotor);</a>
<a name="ln1339"> </a>
<a name="ln1340">    // The permutations are ordered so that the first 2 permutations cover the</a>
<a name="ln1341">    // combinations of 2, and the first 6 permutations cover the combinations of 3</a>
<a name="ln1342">    const char permutations[24*4] = {0,1,2,3, 1,0,2,3, 0,2,1,3, 1,2,0,3, 2,0,1,3, 2,1,0,3,</a>
<a name="ln1343">                                     0,1,3,2, 0,2,3,1, 0,3,1,2, 0,3,2,1, 1,0,3,2, 1,2,3,0,</a>
<a name="ln1344">                                     1,3,0,2, 1,3,2,0, 2,0,3,1, 2,1,3,0, 2,3,0,1, 2,3,1,0,</a>
<a name="ln1345">                                     3,0,1,2, 3,0,2,1, 3,1,0,2, 3,1,2,0, 3,2,0,1, 3,2,1,0};</a>
<a name="ln1346">    const char factorial[5] = {0, 1, 2, 6, 24};</a>
<a name="ln1347"> </a>
<a name="ln1348">    char num_rotors_to_permute, num_permutations;</a>
<a name="ln1349">    if (permute)</a>
<a name="ln1350">      num_rotors_to_permute = (char)std::min&lt;size_t&gt; (4, vrotors.size());</a>
<a name="ln1351">    else</a>
<a name="ln1352">      num_rotors_to_permute = 1; // i.e. just use the original order</a>
<a name="ln1353">    num_permutations = factorial[num_rotors_to_permute];</a>
<a name="ln1354"> </a>
<a name="ln1355">    // Initialize reordered_rotors - the order in which to test rotors</a>
<a name="ln1356">    std::vector&lt;unsigned int&gt; reordered_rotors(vrotors.size());</a>
<a name="ln1357">    for (int i=0; i&lt;vrotors.size(); ++i)</a>
<a name="ln1358">      reordered_rotors[i] = i;</a>
<a name="ln1359"> </a>
<a name="ln1360">    std::set&lt;unsigned int&gt; seen;</a>
<a name="ln1361">    best_minE = DBL_MAX;</a>
<a name="ln1362">    for (int N=0; N&lt;num_permutations; ++N) {</a>
<a name="ln1363">      for (int i=0; i&lt;num_rotors_to_permute; ++i)</a>
<a name="ln1364">        reordered_rotors.at(i) = *(permutations + N*4 + i);</a>
<a name="ln1365"> </a>
<a name="ln1366">      rotorKey = init_rotorKey;</a>
<a name="ln1367">      _mol.SetCoordinates(store_initial);</a>
<a name="ln1368">      bool quit = false;</a>
<a name="ln1369"> </a>
<a name="ln1370">      for (int i=0; i&lt;reordered_rotors.size(); ++i) {</a>
<a name="ln1371">        unsigned int idx = reordered_rotors[i];</a>
<a name="ln1372">        rotor = vrotors.at(idx);</a>
<a name="ln1373"> </a>
<a name="ln1374">        minE = DBL_MAX;</a>
<a name="ln1375"> </a>
<a name="ln1376">        for (j = 0; j &lt; rotor-&gt;GetResolution().size(); j++) { // For each rotor position</a>
<a name="ln1377">          // Note: we could do slightly better by skipping the rotor position we already</a>
<a name="ln1378">          //       tested in the last loop (position 0 at the moment). Note that this</a>
<a name="ln1379">          //       isn't as simple as just changing the loop starting point to j = 1.</a>
<a name="ln1380">          _mol.SetCoordinates(bestconf);</a>
<a name="ln1381">          rotorKey[idx + 1] = j;</a>
<a name="ln1382">          rotamerlist.SetCurrentCoordinates(_mol, rotorKey);</a>
<a name="ln1383">          SetupPointers();</a>
<a name="ln1384"> </a>
<a name="ln1385">          currentE = E_VDW(false) + E_Torsion(false) + E_Electrostatic(false);</a>
<a name="ln1386"> </a>
<a name="ln1387">          if (currentE &lt; minE) {</a>
<a name="ln1388">            minE = currentE;</a>
<a name="ln1389">            minj = j;</a>
<a name="ln1390">            memcpy((char*)minconf,(char*)_mol.GetCoordinates(),sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1391">          }</a>
<a name="ln1392">        } // Finished testing all positions of this rotor</a>
<a name="ln1393">        rotorKey[idx + 1] = minj;</a>
<a name="ln1394"> </a>
<a name="ln1395">        if (i==4) { // Check whether this rotorKey has already been chosen</a>
<a name="ln1396">          // Create a hash of the rotorKeys (given that the max value of any rotorKey is 11 from torlib.txt)</a>
<a name="ln1397">          unsigned int hash = rotorKey[1] + rotorKey[2]*12 + rotorKey[3]*12*12 + rotorKey[4]*12*12*12;</a>
<a name="ln1398"> </a>
<a name="ln1399">          if (seen.find(hash) == seen.end()) // Not seen before</a>
<a name="ln1400">            seen.insert(hash);</a>
<a name="ln1401">          else { // Already seen - no point continuing</a>
<a name="ln1402">            quit = true;</a>
<a name="ln1403">            break;</a>
<a name="ln1404">          }</a>
<a name="ln1405">        }</a>
<a name="ln1406"> </a>
<a name="ln1407">        memcpy((char*)bestconf,(char*)minconf,sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1408">      } // end of this permutation</a>
<a name="ln1409">      if (!quit) {</a>
<a name="ln1410">          if (minE &lt; best_minE) {</a>
<a name="ln1411">            best_minE = minE;</a>
<a name="ln1412">            memcpy((char*)verybestconf,(char*)bestconf,sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1413">          }</a>
<a name="ln1414">      }</a>
<a name="ln1415"> </a>
<a name="ln1416">    } // end of final permutation</a>
<a name="ln1417"> </a>
<a name="ln1418">    _mol.SetCoordinates(verybestconf);</a>
<a name="ln1419">    SetupPointers();</a>
<a name="ln1420"> </a>
<a name="ln1421">    delete [] store_initial;</a>
<a name="ln1422">    delete [] bestconf;</a>
<a name="ln1423">    delete [] verybestconf;</a>
<a name="ln1424">    delete [] minconf;</a>
<a name="ln1425"> </a>
<a name="ln1426">    return true;</a>
<a name="ln1427">  }</a>
<a name="ln1428"> </a>
<a name="ln1429">  void OBForceField::RandomRotorSearchInitialize(unsigned int conformers, unsigned int geomSteps,</a>
<a name="ln1430">                                                 bool sampleRingBonds)</a>
<a name="ln1431">  {</a>
<a name="ln1432">    if (!_validSetup)</a>
<a name="ln1433">      return;</a>
<a name="ln1434"> </a>
<a name="ln1435">    OBRotorList rl;</a>
<a name="ln1436">    OBRotamerList rotamers;</a>
<a name="ln1437">    OBRotorIterator ri;</a>
<a name="ln1438">    OBRotor *rotor;</a>
<a name="ln1439"> </a>
<a name="ln1440">    OBRandom generator;</a>
<a name="ln1441">    generator.TimeSeed();</a>
<a name="ln1442">    _origLogLevel = _loglvl;</a>
<a name="ln1443"> </a>
<a name="ln1444">    if (_mol.GetCoordinates() == nullptr)</a>
<a name="ln1445">      return;</a>
<a name="ln1446"> </a>
<a name="ln1447">    OBBitVec fixed = _constraints.GetFixedBitVec();</a>
<a name="ln1448">    rl.SetFixAtoms(fixed);</a>
<a name="ln1449">    rl.Setup(_mol, sampleRingBonds);</a>
<a name="ln1450">    rotamers.SetBaseCoordinateSets(_mol);</a>
<a name="ln1451">    rotamers.Setup(_mol, rl);</a>
<a name="ln1452"> </a>
<a name="ln1453">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1454">      OBFFLog(&quot;\nR A N D O M   R O T O R   S E A R C H\n\n&quot;);</a>
<a name="ln1455">      snprintf(_logbuf, BUFF_SIZE, &quot;  NUMBER OF ROTATABLE BONDS: %lu\n&quot;, (unsigned long)rl.Size());</a>
<a name="ln1456">      OBFFLog(_logbuf);</a>
<a name="ln1457"> </a>
<a name="ln1458">      unsigned long int combinations = 1;</a>
<a name="ln1459">      for (rotor = rl.BeginRotor(ri); rotor;</a>
<a name="ln1460">           rotor = rl.NextRotor(ri)) {</a>
<a name="ln1461">        combinations *= rotor-&gt;GetResolution().size();</a>
<a name="ln1462">      }</a>
<a name="ln1463">      snprintf(_logbuf, BUFF_SIZE, &quot;  NUMBER OF POSSIBLE ROTAMERS: %lu\n&quot;, combinations);</a>
<a name="ln1464">      OBFFLog(_logbuf);</a>
<a name="ln1465">    }</a>
<a name="ln1466"> </a>
<a name="ln1467">    _current_conformer = 0;</a>
<a name="ln1468"> </a>
<a name="ln1469">    if (!rl.Size()) { // only one conformer</a>
<a name="ln1470">      IF_OBFF_LOGLVL_LOW</a>
<a name="ln1471">        OBFFLog(&quot;  GENERATED ONLY ONE CONFORMER\n\n&quot;);</a>
<a name="ln1472"> </a>
<a name="ln1473">      _loglvl = OBFF_LOGLVL_NONE;</a>
<a name="ln1474">      ConjugateGradients(geomSteps); // energy minimization for conformer</a>
<a name="ln1475">      _loglvl = _origLogLevel;</a>
<a name="ln1476"> </a>
<a name="ln1477">      return;</a>
<a name="ln1478">    }</a>
<a name="ln1479"> </a>
<a name="ln1480">    std::vector&lt;int&gt; rotorKey(rl.Size() + 1, 0); // indexed from 1</a>
<a name="ln1481"> </a>
<a name="ln1482">    for (unsigned int c = 0; c &lt; conformers; ++c) {</a>
<a name="ln1483">      rotor = rl.BeginRotor(ri);</a>
<a name="ln1484">      for (unsigned int i = 1; i &lt; rl.Size() + 1; ++i, rotor = rl.NextRotor(ri)) {</a>
<a name="ln1485">        // foreach rotor</a>
<a name="ln1486">        rotorKey[i] = generator.NextInt() % rotor-&gt;GetResolution().size();</a>
<a name="ln1487">      }</a>
<a name="ln1488">      rotamers.AddRotamer(rotorKey);</a>
<a name="ln1489">    }</a>
<a name="ln1490"> </a>
<a name="ln1491">    rotamers.ExpandConformerList(_mol, _mol.GetConformers());</a>
<a name="ln1492"> </a>
<a name="ln1493">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1494">      snprintf(_logbuf, BUFF_SIZE, &quot;  GENERATED %d CONFORMERS\n\n&quot;, _mol.NumConformers());</a>
<a name="ln1495">      OBFFLog(_logbuf);</a>
<a name="ln1496">      OBFFLog(&quot;CONFORMER     ENERGY\n&quot;);</a>
<a name="ln1497">      OBFFLog(&quot;--------------------\n&quot;);</a>
<a name="ln1498">    }</a>
<a name="ln1499"> </a>
<a name="ln1500">    _energies.clear();</a>
<a name="ln1501">  }</a>
<a name="ln1502"> </a>
<a name="ln1503">  bool OBForceField::RandomRotorSearchNextConformer(unsigned int geomSteps)</a>
<a name="ln1504">  {</a>
<a name="ln1505">    if (!_validSetup)</a>
<a name="ln1506">      return 0;</a>
<a name="ln1507"> </a>
<a name="ln1508">    if (_current_conformer &gt;=  _mol.NumConformers()) { // done</a>
<a name="ln1509">      // Select conformer with lowest energy</a>
<a name="ln1510">      int best_conformer = 0;</a>
<a name="ln1511">      for (int i = 0; i &lt; _mol.NumConformers(); i++) {</a>
<a name="ln1512">        if (_energies[i] &lt; _energies[best_conformer])</a>
<a name="ln1513">          best_conformer = i;</a>
<a name="ln1514">      }</a>
<a name="ln1515"> </a>
<a name="ln1516">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1517">        snprintf(_logbuf, BUFF_SIZE, &quot;\n  CONFORMER %d HAS THE LOWEST ENERGY\n\n&quot;,  best_conformer + 1);</a>
<a name="ln1518">        OBFFLog(_logbuf);</a>
<a name="ln1519">      }</a>
<a name="ln1520"> </a>
<a name="ln1521">      _mol.SetConformer(best_conformer);</a>
<a name="ln1522">      SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1523">      _current_conformer = best_conformer;</a>
<a name="ln1524"> </a>
<a name="ln1525">      return false;</a>
<a name="ln1526">    }</a>
<a name="ln1527"> </a>
<a name="ln1528">    _mol.SetConformer(_current_conformer); // select conformer</a>
<a name="ln1529">    SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1530"> </a>
<a name="ln1531">    _loglvl = OBFF_LOGLVL_NONE;</a>
<a name="ln1532">    ConjugateGradients(geomSteps); // energy minimization for conformer</a>
<a name="ln1533">    _loglvl = _origLogLevel;</a>
<a name="ln1534"> </a>
<a name="ln1535">    _energies.push_back(Energy(false)); // calculate and store energy</a>
<a name="ln1536"> </a>
<a name="ln1537">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1538">      snprintf(_logbuf, BUFF_SIZE, &quot;   %3d      %8.3f\n&quot;, (_current_conformer + 1), _energies[_current_conformer]);</a>
<a name="ln1539">      OBFFLog(_logbuf);</a>
<a name="ln1540">    }</a>
<a name="ln1541"> </a>
<a name="ln1542">    _current_conformer++;</a>
<a name="ln1543">    return true;</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  void OBForceField::RandomRotorSearch(unsigned int conformers, unsigned int geomSteps,</a>
<a name="ln1547">                                       bool sampleRingBonds)</a>
<a name="ln1548">  {</a>
<a name="ln1549">    RandomRotorSearchInitialize(conformers, geomSteps, sampleRingBonds);</a>
<a name="ln1550">    while (RandomRotorSearchNextConformer(geomSteps)) {}</a>
<a name="ln1551">  }</a>
<a name="ln1552"> </a>
<a name="ln1553">  void Reweight(std::vector&lt; std::vector &lt;double&gt; &gt; &amp;rotorWeights,</a>
<a name="ln1554">                std::vector&lt;int&gt; rotorKey, double bonus)</a>
<a name="ln1555">  {</a>
<a name="ln1556">    double fraction, minWeight, maxWeight;</a>
<a name="ln1557">    bool improve = (bonus &gt; 0.0);</a>
<a name="ln1558"> </a>
<a name="ln1559">    for (unsigned int i = 1; i &lt; rotorWeights.size() - 1; ++i) {</a>
<a name="ln1560">			if (rotorKey[i] == -1)</a>
<a name="ln1561">				continue; // don't rotate</a>
<a name="ln1562"> </a>
<a name="ln1563">      if (improve &amp;&amp; rotorWeights[i][rotorKey[i]] &gt; 0.999 - bonus)</a>
<a name="ln1564">        continue;</a>
<a name="ln1565">      if (!improve &amp;&amp; rotorWeights[i][rotorKey[i]] &lt; 0.001 - bonus) // bonus &lt; 0</a>
<a name="ln1566">        continue;</a>
<a name="ln1567"> </a>
<a name="ln1568">      // Check to make sure we don't kill some poor weight</a>
<a name="ln1569">      minWeight = maxWeight = rotorWeights[i][0];</a>
<a name="ln1570">      for (unsigned int j = 1; j &lt; rotorWeights[i].size(); ++j) {</a>
<a name="ln1571">        if (j == rotorKey[i])</a>
<a name="ln1572">          continue; // we already checked for problems with this entry</a>
<a name="ln1573">        if (rotorWeights[i][j] &lt; minWeight)</a>
<a name="ln1574">          minWeight = rotorWeights[i][j];</a>
<a name="ln1575">        if (rotorWeights[i][j] &gt; maxWeight)</a>
<a name="ln1576">          maxWeight = rotorWeights[i][j];</a>
<a name="ln1577">      }</a>
<a name="ln1578"> </a>
<a name="ln1579">      fraction = bonus / (rotorWeights[i].size() - 1);</a>
<a name="ln1580">      if (improve &amp;&amp; fraction &gt; minWeight) {</a>
<a name="ln1581">        bonus = minWeight / 2.0;</a>
<a name="ln1582">        fraction = bonus / (rotorWeights[i].size() - 1);</a>
<a name="ln1583">      }</a>
<a name="ln1584">      if (!improve &amp;&amp; fraction &gt; maxWeight) {</a>
<a name="ln1585">        bonus = (maxWeight - 1.0) / 2.0; // negative &quot;bonus&quot;</a>
<a name="ln1586">        fraction = bonus / (rotorWeights[i].size() - 1);</a>
<a name="ln1587">      }</a>
<a name="ln1588"> </a>
<a name="ln1589">      for (unsigned int j = 0; j &lt; rotorWeights[i].size(); ++j) {</a>
<a name="ln1590">        if (j == rotorKey[i])</a>
<a name="ln1591">          rotorWeights[i][j] += bonus;</a>
<a name="ln1592">        else</a>
<a name="ln1593">          rotorWeights[i][j] -= fraction;</a>
<a name="ln1594">      }</a>
<a name="ln1595">    }</a>
<a name="ln1596">  }</a>
<a name="ln1597"> </a>
<a name="ln1598"> </a>
<a name="ln1599">  void OBForceField::WeightedRotorSearch(unsigned int conformers, unsigned int geomSteps,</a>
<a name="ln1600">                                         bool sampleRingBonds)</a>
<a name="ln1601">  {</a>
<a name="ln1602">    if (!_validSetup)</a>
<a name="ln1603">      return;</a>
<a name="ln1604"> </a>
<a name="ln1605">    OBRotorList rl;</a>
<a name="ln1606">    OBRotamerList rotamers;</a>
<a name="ln1607">    OBRotorIterator ri;</a>
<a name="ln1608">    OBRotor *rotor;</a>
<a name="ln1609"> </a>
<a name="ln1610">    OBRandom generator;</a>
<a name="ln1611">    generator.TimeSeed();</a>
<a name="ln1612">    int origLogLevel = _loglvl;</a>
<a name="ln1613"> </a>
<a name="ln1614">    if (_mol.GetCoordinates() == nullptr)</a>
<a name="ln1615">      return;</a>
<a name="ln1616"> </a>
<a name="ln1617">    double *initialCoord = new double [_mol.NumAtoms() * 3]; // initial state</a>
<a name="ln1618">    memcpy((double*)initialCoord,(double*)_mol.GetCoordinates(),sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1619">    vector&lt;double *&gt; newConfs(1, initialCoord);</a>
<a name="ln1620">    _mol.SetConformers(newConfs);</a>
<a name="ln1621">    _current_conformer = 0;</a>
<a name="ln1622">    _mol.SetConformer(_current_conformer);</a>
<a name="ln1623">    SetupPointers();</a>
<a name="ln1624"> </a>
<a name="ln1625">    OBBitVec fixed = _constraints.GetFixedBitVec();</a>
<a name="ln1626">    rl.SetFixAtoms(fixed);</a>
<a name="ln1627">    rl.Setup(_mol, sampleRingBonds);</a>
<a name="ln1628">    rotamers.SetBaseCoordinateSets(_mol);</a>
<a name="ln1629">    rotamers.Setup(_mol, rl);</a>
<a name="ln1630"> </a>
<a name="ln1631">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1632">      OBFFLog(&quot;\nW E I G H T E D   R O T O R   S E A R C H\n\n&quot;);</a>
<a name="ln1633">      snprintf(_logbuf, BUFF_SIZE, &quot;  NUMBER OF ROTATABLE BONDS: %lu\n&quot;, (unsigned long)rl.Size());</a>
<a name="ln1634">      OBFFLog(_logbuf);</a>
<a name="ln1635"> </a>
<a name="ln1636">      unsigned long int combinations = 1;</a>
<a name="ln1637">      for (rotor = rl.BeginRotor(ri); rotor;</a>
<a name="ln1638">           rotor = rl.NextRotor(ri)) {</a>
<a name="ln1639">        combinations *= rotor-&gt;GetResolution().size();</a>
<a name="ln1640">      }</a>
<a name="ln1641">      snprintf(_logbuf, BUFF_SIZE, &quot;  NUMBER OF POSSIBLE ROTAMERS: %lu\n&quot;, combinations);</a>
<a name="ln1642">      OBFFLog(_logbuf);</a>
<a name="ln1643">    }</a>
<a name="ln1644"> </a>
<a name="ln1645"> </a>
<a name="ln1646">    _energies.clear(); // Wipe any energies from previous conformer generators</a>
<a name="ln1647"> </a>
<a name="ln1648">    if (!rl.Size()) { // only one conformer</a>
<a name="ln1649">      IF_OBFF_LOGLVL_LOW</a>
<a name="ln1650">        OBFFLog(&quot;  GENERATED ONLY ONE CONFORMER\n\n&quot;);</a>
<a name="ln1651"> </a>
<a name="ln1652">      _loglvl = OBFF_LOGLVL_NONE;</a>
<a name="ln1653">      ConjugateGradients(geomSteps); // energy minimization for conformer</a>
<a name="ln1654">      _loglvl = origLogLevel;</a>
<a name="ln1655">      _energies.push_back(Energy(false));</a>
<a name="ln1656"> </a>
<a name="ln1657">      return;</a>
<a name="ln1658">    }</a>
<a name="ln1659"> </a>
<a name="ln1660">    _energies.push_back(Energy(false)); // Store the energy of the original conf</a>
<a name="ln1661"> </a>
<a name="ln1662">    // key for generating particular conformers</a>
<a name="ln1663">    std::vector&lt;int&gt; rotorKey(rl.Size() + 1, 0); // indexed from 1</a>
<a name="ln1664"> </a>
<a name="ln1665">    // initialize the weights</a>
<a name="ln1666">    std::vector&lt; std::vector &lt;double&gt; &gt; rotorWeights;</a>
<a name="ln1667">    std::vector&lt; double &gt; weightSet;</a>
<a name="ln1668">    rotorWeights.push_back(weightSet); // empty set for unused index 0</a>
<a name="ln1669"> </a>
<a name="ln1670">    double weight;</a>
<a name="ln1671">    double bestE, worstE, currentE;</a>
<a name="ln1672">    std::vector&lt;double&gt; energies;</a>
<a name="ln1673">    // First off, we test out each rotor position. How good (or bad) is it?</a>
<a name="ln1674">    // This lets us pre-weight the search to a useful level</a>
<a name="ln1675">    // So each rotor is considered in isolation</a>
<a name="ln1676">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln1677">      OBFFLog(&quot;  INITIAL WEIGHTING OF ROTAMERS...\n\n&quot;);</a>
<a name="ln1678"> </a>
<a name="ln1679">    rotor = rl.BeginRotor(ri);</a>
<a name="ln1680">    for (unsigned int i = 1; i &lt; rl.Size() + 1; ++i, rotor = rl.NextRotor(ri)) {</a>
<a name="ln1681">      rotorKey[i] = -1; // no rotation (new in 2.2)</a>
<a name="ln1682">    }</a>
<a name="ln1683"> </a>
<a name="ln1684">    rotor = rl.BeginRotor(ri);</a>
<a name="ln1685"> </a>
<a name="ln1686">    for (unsigned int i = 1; i &lt; rl.Size() + 1; ++i, rotor = rl.NextRotor(ri)) {</a>
<a name="ln1687">      // foreach rotor</a>
<a name="ln1688">      energies.clear();</a>
<a name="ln1689">      for (unsigned int j = 0; j &lt; rotor-&gt;GetResolution().size(); j++) {</a>
<a name="ln1690">        // foreach rotor position</a>
<a name="ln1691">        _mol.SetCoordinates(initialCoord);</a>
<a name="ln1692">        rotorKey[i] = j;</a>
<a name="ln1693">        rotamers.SetCurrentCoordinates(_mol, rotorKey);</a>
<a name="ln1694">        SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1695"> </a>
<a name="ln1696">        _loglvl = OBFF_LOGLVL_NONE;</a>
<a name="ln1697">        ConjugateGradients(geomSteps); // energy minimization for conformer</a>
<a name="ln1698">        _loglvl = origLogLevel;</a>
<a name="ln1699">        currentE = Energy(false);</a>
<a name="ln1700"> </a>
<a name="ln1701">        if (j == 0)</a>
<a name="ln1702">          bestE = worstE = currentE;</a>
<a name="ln1703">        else {</a>
<a name="ln1704">          if (currentE &gt; worstE)</a>
<a name="ln1705">            worstE = currentE;</a>
<a name="ln1706">          else if (currentE &lt; bestE)</a>
<a name="ln1707">            bestE = currentE;</a>
<a name="ln1708">        }</a>
<a name="ln1709">        energies.push_back(currentE);</a>
<a name="ln1710">      }</a>
<a name="ln1711">      rotorKey[i] = -1; // back to the previous setting before we go to another rotor</a>
<a name="ln1712"> </a>
<a name="ln1713">      weightSet.clear();</a>
<a name="ln1714">      // first loop through and calculate the relative populations from Boltzmann</a>
<a name="ln1715">      double totalPop = 0.0;</a>
<a name="ln1716">      for (unsigned int j = 0; j &lt; rotor-&gt;GetResolution().size(); j++) {</a>
<a name="ln1717">        currentE = energies[j];</a>
<a name="ln1718">        // add back the Boltzmann population for these relative energies at 300K (assuming kJ/mol)</a>
<a name="ln1719">        energies[j] = exp(-1.0*fabs(currentE - bestE) / 2.5);</a>
<a name="ln1720">        totalPop += energies[j];</a>
<a name="ln1721">      }</a>
<a name="ln1722">      // now set the weights</a>
<a name="ln1723">      for (unsigned int j = 0; j &lt; rotor-&gt;GetResolution().size(); j++) {</a>
<a name="ln1724">        if (IsNear(worstE, bestE, 1.0e-3))</a>
<a name="ln1725">          weight = 1 / rotor-&gt;GetResolution().size();</a>
<a name="ln1726">        else</a>
<a name="ln1727">          weight = energies[j]/totalPop;</a>
<a name="ln1728">        weightSet.push_back(weight);</a>
<a name="ln1729">      }</a>
<a name="ln1730">      rotorWeights.push_back(weightSet);</a>
<a name="ln1731">    }</a>
<a name="ln1732"> </a>
<a name="ln1733">    int best_conformer=-1;</a>
<a name="ln1734">    //    double penalty; // for poor performance</a>
<a name="ln1735">    double randFloat; // generated random number -- used to pick a rotor</a>
<a name="ln1736">    double total; // used to calculate the total probability</a>
<a name="ln1737"> </a>
<a name="ln1738">    // Start with the current coordinates</a>
<a name="ln1739">    bestE = worstE = Energy(false);</a>
<a name="ln1740"> </a>
<a name="ln1741">    // Now we actually test some weightings</a>
<a name="ln1742">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1743">      snprintf(_logbuf, BUFF_SIZE, &quot;  GENERATED %d CONFORMERS\n\n&quot;, conformers);</a>
<a name="ln1744">      OBFFLog(_logbuf);</a>
<a name="ln1745">      OBFFLog(&quot;CONFORMER     ENERGY\n&quot;);</a>
<a name="ln1746">      OBFFLog(&quot;--------------------\n&quot;);</a>
<a name="ln1747">    }</a>
<a name="ln1748"> </a>
<a name="ln1749">    double defaultRotor = 1.0/sqrt((double)rl.Size());</a>
<a name="ln1750">    unsigned c = 0;</a>
<a name="ln1751">    while (c &lt; conformers) {</a>
<a name="ln1752">      _mol.SetCoordinates(initialCoord);</a>
<a name="ln1753"> </a>
<a name="ln1754">      // Choose the rotor key based on current weightings</a>
<a name="ln1755">      rotor = rl.BeginRotor(ri);</a>
<a name="ln1756">      for (unsigned int i = 1; i &lt; rl.Size() + 1; ++i, rotor = rl.NextRotor(ri)) {</a>
<a name="ln1757">        // foreach rotor</a>
<a name="ln1758">        rotorKey[i] = -1; // default = don't change dihedral</a>
<a name="ln1759">        randFloat = generator.NextFloat();</a>
<a name="ln1760">        if (randFloat &lt; defaultRotor) // should we just leave this rotor with default setting?</a>
<a name="ln1761">          continue;</a>
<a name="ln1762"> </a>
<a name="ln1763">        randFloat = generator.NextFloat();</a>
<a name="ln1764">        total = 0.0;</a>
<a name="ln1765">        for (unsigned int j = 0; j &lt; rotor-&gt;GetResolution().size(); j++) {</a>
<a name="ln1766">          if (randFloat &gt; total &amp;&amp; randFloat &lt; (total+ rotorWeights[i][j])) {</a>
<a name="ln1767">            rotorKey[i] = j;</a>
<a name="ln1768">            break;</a>
<a name="ln1769">          }</a>
<a name="ln1770">          else</a>
<a name="ln1771">            total += rotorWeights[i][j];</a>
<a name="ln1772">        }</a>
<a name="ln1773">      }</a>
<a name="ln1774"> </a>
<a name="ln1775">      //FIXME: for now, allow even invalid ring conformers</a>
<a name="ln1776">      rotamers.SetCurrentCoordinates(_mol, rotorKey);</a>
<a name="ln1777">      ++c;</a>
<a name="ln1778"> </a>
<a name="ln1779">      SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1780"> </a>
<a name="ln1781">      _loglvl = OBFF_LOGLVL_NONE;</a>
<a name="ln1782">      ConjugateGradients(geomSteps); // energy minimization for conformer</a>
<a name="ln1783">      _loglvl = origLogLevel;</a>
<a name="ln1784">      currentE = Energy(false);</a>
<a name="ln1785">      _energies.push_back(currentE);</a>
<a name="ln1786">      double *confCoord = new double [_mol.NumAtoms() * 3]; // initial state</a>
<a name="ln1787">      memcpy((char*)confCoord,(char*)_mol.GetCoordinates(),sizeof(double)*3*_mol.NumAtoms());</a>
<a name="ln1788">      _mol.AddConformer(confCoord);</a>
<a name="ln1789"> </a>
<a name="ln1790">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1791">        snprintf(_logbuf, BUFF_SIZE, &quot;   %3d      %8.3f\n&quot;, c + 1, currentE);</a>
<a name="ln1792">        OBFFLog(_logbuf);</a>
<a name="ln1793">      }</a>
<a name="ln1794"> </a>
<a name="ln1795">      if (!isfinite(currentE))</a>
<a name="ln1796">        continue;</a>
<a name="ln1797"> </a>
<a name="ln1798">      if (currentE &lt; bestE) {</a>
<a name="ln1799">        bestE = currentE;</a>
<a name="ln1800">        best_conformer = c;</a>
<a name="ln1801"> </a>
<a name="ln1802">        // improve this rotorKey</a>
<a name="ln1803">        Reweight(rotorWeights, rotorKey, +0.11);</a>
<a name="ln1804">      } else if (currentE &gt; worstE) { // horrible!</a>
<a name="ln1805">        worstE = currentE;</a>
<a name="ln1806"> </a>
<a name="ln1807">        // penalize this rotorKey</a>
<a name="ln1808">        Reweight(rotorWeights, rotorKey, -0.11);</a>
<a name="ln1809">      } else {</a>
<a name="ln1810">        double slope = -0.2 / (worstE - bestE);</a>
<a name="ln1811">        Reweight(rotorWeights, rotorKey, (currentE - bestE)*slope);</a>
<a name="ln1812">      }</a>
<a name="ln1813">    }</a>
<a name="ln1814"> </a>
<a name="ln1815">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1816">      snprintf(_logbuf, BUFF_SIZE, &quot;\n  LOWEST ENERGY: %8.3f\n\n&quot;,</a>
<a name="ln1817">               bestE);</a>
<a name="ln1818">      OBFFLog(_logbuf);</a>
<a name="ln1819">    }</a>
<a name="ln1820"> </a>
<a name="ln1821">    // debugging output to see final weightings of each rotor setting</a>
<a name="ln1822">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln1823">      OBFFLog(&quot;Final Weights: \n&quot;);</a>
<a name="ln1824">      for (unsigned int i = 1; i &lt; rotorWeights.size() - 1; ++i) {</a>
<a name="ln1825">        snprintf(_logbuf, BUFF_SIZE, &quot; Weight: %d&quot;, i);</a>
<a name="ln1826">        OBFFLog(_logbuf);</a>
<a name="ln1827">        for (unsigned int j = 0; j &lt; rotorWeights[i].size(); ++j) {</a>
<a name="ln1828">          snprintf(_logbuf, BUFF_SIZE, &quot; %8.3f&quot;, rotorWeights[i][j]);</a>
<a name="ln1829">          OBFFLog(_logbuf);</a>
<a name="ln1830">        }</a>
<a name="ln1831">        OBFFLog(&quot;\n&quot;);</a>
<a name="ln1832">      }</a>
<a name="ln1833">    }</a>
<a name="ln1834"> </a>
<a name="ln1835">    _current_conformer = best_conformer; // Initial coords are stored in _vconf[0]</a>
<a name="ln1836">    _mol.SetConformer(_current_conformer);</a>
<a name="ln1837">    SetupPointers(); // update pointers to atom positions in the OBFFCalculation objects</a>
<a name="ln1838">  }</a>
<a name="ln1839"> </a>
<a name="ln1840">  void OBForceField::DistanceGeometry()</a>
<a name="ln1841">  {</a>
<a name="ln1842">    if (!_validSetup)</a>
<a name="ln1843">      return;</a>
<a name="ln1844"> </a>
<a name="ln1845">    int N = _mol.NumAtoms();</a>
<a name="ln1846">    int i = 0;</a>
<a name="ln1847">    int j = 0;</a>
<a name="ln1848">    //double matrix[N][N], G[N][N];</a>
<a name="ln1849">    vector&lt;vector&lt;double&gt; &gt; matrix(N);</a>
<a name="ln1850">    for(int i=0; i&lt;N; i++)</a>
<a name="ln1851">      matrix[i].reserve(N);</a>
<a name="ln1852">    vector&lt;vector&lt;double&gt; &gt; G(N);</a>
<a name="ln1853">    for(int i=0; i&lt;N; i++)</a>
<a name="ln1854">      G[i].reserve(N);</a>
<a name="ln1855"> </a>
<a name="ln1856">    bool is15;</a>
<a name="ln1857"> </a>
<a name="ln1858">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln1859">      OBFFLog(&quot;\nD I S T A N C E   G E O M E T R Y\n\n&quot;);</a>
<a name="ln1860"> </a>
<a name="ln1861">    // Calculate initial distance matrix</a>
<a name="ln1862">    //</a>
<a name="ln1863">    // - diagonal elements are 0.0</a>
<a name="ln1864">    // - when atoms i and j form a bond, the bond length is used for</a>
<a name="ln1865">    //   upper and lower limit</a>
<a name="ln1866">    // - when atoms i and j are in a 1-3 relationship, the distance</a>
<a name="ln1867">    //   is calculated using the cosine rule: (upper limit = lower limit)</a>
<a name="ln1868">    //</a>
<a name="ln1869">    //          b_         ab: bond length</a>
<a name="ln1870">    //         /  \_       bc: bond length</a>
<a name="ln1871">    //        /A    \_     ac = sqrt(ab^2 + bc^2 - 2*ab*bc*cos(A))</a>
<a name="ln1872">    //       a--------c</a>
<a name="ln1873">    //</a>
<a name="ln1874">    // - when atoms i anf j are in a 1-4 relationship, the lower distance</a>
<a name="ln1875">    //   limit is calculated using a torsional angle of 0.0. The upper limit</a>
<a name="ln1876">    //   is calculated using a torsion angle of 180.0.</a>
<a name="ln1877">    //</a>
<a name="ln1878">    //      a       d      ab, bc, cd: bond lengths</a>
<a name="ln1879">    //       \ B C /</a>
<a name="ln1880">    //        b---c        ad = bc + ab*cos(180-B) + cd*cos(180-C)</a>
<a name="ln1881">    //</a>
<a name="ln1882">    //      a</a>
<a name="ln1883">    //       \ B           delta_x = bc + ab*cos(180-B) + cd*cos(180-C)</a>
<a name="ln1884">    //        b---c        delta_y = ab*sin(180-B) + cd*sin(180-C)</a>
<a name="ln1885">    //           C \       .</a>
<a name="ln1886">    //              d      ad = sqrt(delta_x^2 + delta_y^2)</a>
<a name="ln1887">    //</a>
<a name="ln1888">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln1889">      i = a-&gt;GetIdx() - 1;</a>
<a name="ln1890">      FOR_ATOMS_OF_MOL (b, _mol) {</a>
<a name="ln1891">        j = b-&gt;GetIdx() - 1;</a>
<a name="ln1892"> </a>
<a name="ln1893">        if (&amp;*a == &amp;*b) {</a>
<a name="ln1894">          matrix[i][j] = 0.0; // diagonal</a>
<a name="ln1895">          continue;</a>
<a name="ln1896">        }</a>
<a name="ln1897">        // Find relationship</a>
<a name="ln1898">        is15 = true;</a>
<a name="ln1899">        FOR_NBORS_OF_ATOM (nbr1, _mol.GetAtom(a-&gt;GetIdx())) { // 1-2</a>
<a name="ln1900">          if (&amp;*nbr1 == &amp;*b) {</a>
<a name="ln1901">            matrix[i][j] = 1.3;</a>
<a name="ln1902">            break;</a>
<a name="ln1903">          }</a>
<a name="ln1904">          FOR_NBORS_OF_ATOM (nbr2, _mol.GetAtom(nbr1-&gt;GetIdx())) { // 1-3</a>
<a name="ln1905">            if (&amp;*nbr2 == &amp;*b) {</a>
<a name="ln1906">              matrix[i][j] = sqrt(1.3*1.3 + 1.3*1.3 - 2.0 *</a>
<a name="ln1907">                                  cos(DEG_TO_RAD*120.0) * 1.3*1.3 );</a>
<a name="ln1908">              is15 = false;</a>
<a name="ln1909">              break;</a>
<a name="ln1910">            }</a>
<a name="ln1911">            FOR_NBORS_OF_ATOM (nbr3, &amp;*nbr2) { // 1-4</a>
<a name="ln1912">              if (&amp;*nbr3 == &amp;*b) {</a>
<a name="ln1913">                is15 = false;</a>
<a name="ln1914">                if (i &gt; j) // minimum distance (torsion angle = 0)</a>
<a name="ln1915">                  matrix[i][j] = 1.3 + 1.3*cos(DEG_TO_RAD*(180.0 - 120.0))</a>
<a name="ln1916">                    + 1.3*cos(DEG_TO_RAD*(180.0 - 120.0));</a>
<a name="ln1917">                else {// maximum distance (torsion angle = 180)</a>
<a name="ln1918">                  double delta_x, delta_y;</a>
<a name="ln1919">                  delta_x = 1.3 + 1.3*cos(DEG_TO_RAD*(180.0-120.0))</a>
<a name="ln1920">                    + 1.3*cos(DEG_TO_RAD*(180.0-120.0));</a>
<a name="ln1921">                  delta_y = 1.3*sin(DEG_TO_RAD*(180.0-120.0)) + 1.3*sin(DEG_TO_RAD*(180.0-120.0));</a>
<a name="ln1922">                  matrix[i][j] = sqrt(delta_x*delta_x + delta_y*delta_y);</a>
<a name="ln1923">                }</a>
<a name="ln1924">                break;</a>
<a name="ln1925">              }</a>
<a name="ln1926">              if (i &gt; j &amp;&amp; is15) {// minimum distance (sum vdw radii)</a>
<a name="ln1927">                matrix[i][j] = 1.4 + 1.4;</a>
<a name="ln1928">              } else if (is15) // maximum distance (torsion angle = 180)</a>
<a name="ln1929">                matrix[i][j] = 99.0;</a>
<a name="ln1930">            }</a>
<a name="ln1931">          }</a>
<a name="ln1932">        }</a>
<a name="ln1933">      }</a>
<a name="ln1934">    }</a>
<a name="ln1935"> </a>
<a name="ln1936">    // output initial distance matrix</a>
<a name="ln1937">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln1938"> </a>
<a name="ln1939">      OBFFLog(&quot;INITIAL DISTANCE MATRIX\n\n&quot;);</a>
<a name="ln1940">      for (i=0; i&lt;N; i++) {</a>
<a name="ln1941">        OBFFLog(&quot;[&quot;);</a>
<a name="ln1942">        for (j=0; j&lt;N; j++) {</a>
<a name="ln1943">          snprintf(_logbuf, BUFF_SIZE, &quot; %8.4f &quot;, matrix[i][j]);</a>
<a name="ln1944">          OBFFLog(_logbuf);</a>
<a name="ln1945">        }</a>
<a name="ln1946">        OBFFLog(&quot;]\n&quot;);</a>
<a name="ln1947">      }</a>
<a name="ln1948">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln1949">    }</a>
<a name="ln1950"> </a>
<a name="ln1951">    // Triangle smoothing</a>
<a name="ln1952">    //FOR_ANGLES_OF_MOL(angle, _mol) {</a>
<a name="ln1953">    int a, b, c;</a>
<a name="ln1954">    bool self_consistent = false;</a>
<a name="ln1955">    while (!self_consistent) {</a>
<a name="ln1956">      self_consistent = true;</a>
<a name="ln1957"> </a>
<a name="ln1958">      FOR_ATOMS_OF_MOL (_a, _mol) {</a>
<a name="ln1959">        a = _a-&gt;GetIdx() - 1;</a>
<a name="ln1960">        FOR_ATOMS_OF_MOL (_b, _mol) {</a>
<a name="ln1961">          if (&amp;*_b == &amp;*_a)</a>
<a name="ln1962">            continue;</a>
<a name="ln1963">          b = _b-&gt;GetIdx() - 1;</a>
<a name="ln1964">          FOR_ATOMS_OF_MOL (_c, _mol) {</a>
<a name="ln1965">            if ((&amp;*_c == &amp;*_b) || (&amp;*_c == &amp;*_a))</a>
<a name="ln1966">              continue;</a>
<a name="ln1967">            c = _c-&gt;GetIdx() - 1;</a>
<a name="ln1968"> </a>
<a name="ln1969">            double u_ab, u_bc, u_ac; // upper limits</a>
<a name="ln1970">            double l_ab, l_bc, l_ac; // lower limits</a>
<a name="ln1971"> </a>
<a name="ln1972">            // get the upper and lower limits for ab, bc and ac</a>
<a name="ln1973">            if (b &gt; a) {</a>
<a name="ln1974">              u_ab = matrix[a][b];</a>
<a name="ln1975">              l_ab = matrix[b][a];</a>
<a name="ln1976">            } else {</a>
<a name="ln1977">              u_ab = matrix[b][a];</a>
<a name="ln1978">              l_ab = matrix[a][b];</a>
<a name="ln1979">            }</a>
<a name="ln1980">            if (c &gt; b) {</a>
<a name="ln1981">              u_bc = matrix[b][c];</a>
<a name="ln1982">              l_bc = matrix[c][b];</a>
<a name="ln1983">            } else {</a>
<a name="ln1984">              u_bc = matrix[c][b];</a>
<a name="ln1985">              l_bc = matrix[b][c];</a>
<a name="ln1986">            }</a>
<a name="ln1987">            if (c &gt; a) {</a>
<a name="ln1988">              u_ac = matrix[a][c];</a>
<a name="ln1989">              l_ac = matrix[c][a];</a>
<a name="ln1990">            } else {</a>
<a name="ln1991">              u_ac = matrix[c][a];</a>
<a name="ln1992">              l_ac = matrix[a][c];</a>
<a name="ln1993">            }</a>
<a name="ln1994"> </a>
<a name="ln1995">            if (u_ac &gt; (u_ab + u_bc)) { // u_ac &lt;= u_ab + u_bc</a>
<a name="ln1996">              u_ac = u_ab + u_bc;</a>
<a name="ln1997">              self_consistent = false;</a>
<a name="ln1998">            }</a>
<a name="ln1999"> </a>
<a name="ln2000">            if (l_ac &lt; (l_ab - l_bc)) {// l_ac &gt;= l_ab - l_bc</a>
<a name="ln2001">              l_ac = l_ab - l_bc;</a>
<a name="ln2002">      	      self_consistent = false;</a>
<a name="ln2003">            }</a>
<a name="ln2004"> </a>
<a name="ln2005">            // store smoothed l_ac and u_ac</a>
<a name="ln2006">            if (c &gt; a) {</a>
<a name="ln2007">              matrix[a][c] = u_ac;</a>
<a name="ln2008">              matrix[c][a] = l_ac;</a>
<a name="ln2009">            } else {</a>
<a name="ln2010">              matrix[c][a] = u_ac;</a>
<a name="ln2011">              matrix[a][c] = l_ac;</a>
<a name="ln2012">            }</a>
<a name="ln2013">          }</a>
<a name="ln2014">        }</a>
<a name="ln2015">      }</a>
<a name="ln2016">    }</a>
<a name="ln2017"> </a>
<a name="ln2018">    // output result of triangle smoothing</a>
<a name="ln2019">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2020"> </a>
<a name="ln2021">      OBFFLog(&quot;TRIANGLE SMOOTHING\n\n&quot;);</a>
<a name="ln2022">      for (i=0; i&lt;N; i++) {</a>
<a name="ln2023">        OBFFLog(&quot;[&quot;);</a>
<a name="ln2024">        for (j=0; j&lt;N; j++) {</a>
<a name="ln2025">          snprintf(_logbuf, BUFF_SIZE, &quot; %8.4f &quot;, matrix[i][j]);</a>
<a name="ln2026">          OBFFLog(_logbuf);</a>
<a name="ln2027">        }</a>
<a name="ln2028">        OBFFLog(&quot;]\n&quot;);</a>
<a name="ln2029">      }</a>
<a name="ln2030">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln2031">    }</a>
<a name="ln2032"> </a>
<a name="ln2033">    // Generate random distance matrix between lower and upper limits</a>
<a name="ln2034">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln2035">      i = a-&gt;GetIdx() - 1;</a>
<a name="ln2036">      FOR_ATOMS_OF_MOL (b, _mol) {</a>
<a name="ln2037">        j = b-&gt;GetIdx() - 1;</a>
<a name="ln2038"> </a>
<a name="ln2039">        if (&amp;*a == &amp;*b) {</a>
<a name="ln2040">          matrix[i][j] = 0.0; // diagonal</a>
<a name="ln2041">          continue;</a>
<a name="ln2042">        }</a>
<a name="ln2043"> </a>
<a name="ln2044">        srand(static_cast&lt;unsigned int&gt;(time(nullptr)));</a>
<a name="ln2045">        double rand_ab, u_ab, l_ab;</a>
<a name="ln2046">        if (j &gt; i) {</a>
<a name="ln2047">          u_ab = matrix[i][j];</a>
<a name="ln2048">          l_ab = matrix[j][i];</a>
<a name="ln2049">          rand_ab = l_ab + (u_ab - l_ab) * rand()/RAND_MAX;</a>
<a name="ln2050">          matrix[i][j] = rand_ab;</a>
<a name="ln2051">          matrix[j][i] = rand_ab;</a>
<a name="ln2052">        } else {</a>
<a name="ln2053">          u_ab = matrix[j][i];</a>
<a name="ln2054">          l_ab = matrix[i][j];</a>
<a name="ln2055">          rand_ab = l_ab + (u_ab - l_ab) * rand()/RAND_MAX;</a>
<a name="ln2056">          matrix[i][j] = rand_ab;</a>
<a name="ln2057">          matrix[j][i] = rand_ab;</a>
<a name="ln2058">        }</a>
<a name="ln2059">      }</a>
<a name="ln2060">    }</a>
<a name="ln2061"> </a>
<a name="ln2062">    // output result of triangle smoothing</a>
<a name="ln2063">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2064">      OBFFLog(&quot;RANDOM DISTANCE MATRIX BETWEEN LIMITS\n\n&quot;);</a>
<a name="ln2065">      for (i=0; i&lt;N; i++) {</a>
<a name="ln2066">        OBFFLog(&quot;[&quot;);</a>
<a name="ln2067">        for (j=0; j&lt;N; j++) {</a>
<a name="ln2068">          snprintf(_logbuf, BUFF_SIZE, &quot; %8.4f &quot;, matrix[i][j]);</a>
<a name="ln2069">          OBFFLog(_logbuf);</a>
<a name="ln2070">        }</a>
<a name="ln2071">        OBFFLog(&quot;]\n&quot;);</a>
<a name="ln2072">      }</a>
<a name="ln2073">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln2074">    }</a>
<a name="ln2075"> </a>
<a name="ln2076">    // Generate metric matrix</a>
<a name="ln2077">    // (origin = first atom )</a>
<a name="ln2078">    for (i=0; i&lt;N; i++) {</a>
<a name="ln2079">      for (j=0; j&lt;N; j++) {</a>
<a name="ln2080">        G[i][j] = 0.5 * (matrix[0][i]*matrix[0][i] + matrix[0][j]*matrix[0][j] - matrix[i][j]*matrix[i][j]);</a>
<a name="ln2081">      }</a>
<a name="ln2082">    }</a>
<a name="ln2083"> </a>
<a name="ln2084">    // output metric matrix</a>
<a name="ln2085">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2086">      OBFFLog(&quot;METRIC MATRIX\n\n&quot;);</a>
<a name="ln2087">      for (i=0; i&lt;N; i++) {</a>
<a name="ln2088">        OBFFLog(&quot;[&quot;);</a>
<a name="ln2089">        for (j=0; j&lt;N; j++) {</a>
<a name="ln2090">          snprintf(_logbuf, BUFF_SIZE, &quot; %8.4f &quot;, G[i][j]);</a>
<a name="ln2091">          OBFFLog(_logbuf);</a>
<a name="ln2092">        }</a>
<a name="ln2093">        OBFFLog(&quot;]\n&quot;);</a>
<a name="ln2094">      }</a>
<a name="ln2095">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln2096">    }</a>
<a name="ln2097"> </a>
<a name="ln2098">    // Calculate eigenvalues and eigenvectors</a>
<a name="ln2099">    //double eigenvalues[N];</a>
<a name="ln2100">    vector&lt;double&gt; eigenvalues(N);</a>
<a name="ln2101">    //double eigenvectors[N][N];</a>
<a name="ln2102">    vector&lt;vector&lt;double&gt; &gt; eigenvectors(N);</a>
<a name="ln2103">    for(int i=0; i&lt;N; i++)</a>
<a name="ln2104">      eigenvectors[i].reserve(N);</a>
<a name="ln2105"> </a>
<a name="ln2106">    matrix3x3::jacobi(N, (double *) &amp;G, (double *) &amp;eigenvalues, (double *) &amp;eigenvectors);</a>
<a name="ln2107"> </a>
<a name="ln2108">    // output eigenvalues and eigenvectors</a>
<a name="ln2109">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2110"> </a>
<a name="ln2111">      OBFFLog(&quot;EIGENVALUES OF METRIC MATRIX\n\n&quot;);</a>
<a name="ln2112">      for (i=0; i&lt;N; i++) {</a>
<a name="ln2113">        snprintf(_logbuf, BUFF_SIZE, &quot;%8.4f &quot;, eigenvalues[i]);</a>
<a name="ln2114">        OBFFLog(_logbuf);</a>
<a name="ln2115">      }</a>
<a name="ln2116">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln2117"> </a>
<a name="ln2118">      OBFFLog(&quot;EIGENVECTORS OF METRIC MATRIX\n\n&quot;);</a>
<a name="ln2119">      for (i=0; i&lt;N; i++) {</a>
<a name="ln2120">        OBFFLog(&quot;[&quot;);</a>
<a name="ln2121">        for (j=0; j&lt;N; j++) {</a>
<a name="ln2122">          snprintf(_logbuf, BUFF_SIZE, &quot; %8.4f &quot;, eigenvectors[i][j]);</a>
<a name="ln2123">          OBFFLog(_logbuf);</a>
<a name="ln2124">        }</a>
<a name="ln2125">        OBFFLog(&quot;]\n&quot;);</a>
<a name="ln2126">      }</a>
<a name="ln2127">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln2128">    }</a>
<a name="ln2129"> </a>
<a name="ln2130">    // Assign coordinates</a>
<a name="ln2131">    double xa, ya, za;</a>
<a name="ln2132">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln2133">      i = a-&gt;GetIdx() - 1;</a>
<a name="ln2134"> </a>
<a name="ln2135">      if (eigenvectors[i][N-1] &gt; 0)</a>
<a name="ln2136">        xa = sqrt(eigenvalues[N-1] * eigenvectors[i][N-1]);</a>
<a name="ln2137">      else</a>
<a name="ln2138">        xa = -sqrt(eigenvalues[N-1] * -eigenvectors[i][N-1]);</a>
<a name="ln2139"> </a>
<a name="ln2140">      if (eigenvectors[i][N-2] &gt; 0)</a>
<a name="ln2141">        ya = sqrt(eigenvalues[N-2] * eigenvectors[i][N-2]);</a>
<a name="ln2142">      else</a>
<a name="ln2143">        ya = -sqrt(eigenvalues[N-2] * -eigenvectors[i][N-2]);</a>
<a name="ln2144"> </a>
<a name="ln2145">      if (eigenvectors[i][N-3] &gt; 0)</a>
<a name="ln2146">        za = sqrt(eigenvalues[N-3] * eigenvectors[i][N-3]);</a>
<a name="ln2147">      else</a>
<a name="ln2148">        za = -sqrt(eigenvalues[N-3] * -eigenvectors[i][N-3]);</a>
<a name="ln2149"> </a>
<a name="ln2150">      a-&gt;SetVector(xa, ya, za);</a>
<a name="ln2151">    }</a>
<a name="ln2152"> </a>
<a name="ln2153">  }</a>
<a name="ln2154"> </a>
<a name="ln2155">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2156">  //</a>
<a name="ln2157">  // Cut-off</a>
<a name="ln2158">  //</a>
<a name="ln2159">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2160"> </a>
<a name="ln2161">  void OBForceField::UpdatePairsSimple()</a>
<a name="ln2162">  {</a>
<a name="ln2163">    _vdwpairs.Clear();</a>
<a name="ln2164">    _elepairs.Clear();</a>
<a name="ln2165"> </a>
<a name="ln2166">    const unsigned int numAtoms = _mol.NumAtoms();</a>
<a name="ln2167">    const unsigned int numPairs = numAtoms * (numAtoms - 1) / 2;</a>
<a name="ln2168">    _vdwpairs.Resize(numPairs);</a>
<a name="ln2169">    _elepairs.Resize(numPairs);</a>
<a name="ln2170"> </a>
<a name="ln2171">    //! \todo set the criteria as squared values</a>
<a name="ln2172">    //  from what the user supplies</a>
<a name="ln2173">    double rvdwSquared = SQUARE(_rvdw);</a>
<a name="ln2174">    double releSquared = SQUARE(_rele);</a>
<a name="ln2175"> </a>
<a name="ln2176">    unsigned int pairIndex = -1;</a>
<a name="ln2177">    FOR_PAIRS_OF_MOL(p, _mol) {</a>
<a name="ln2178">      ++pairIndex;</a>
<a name="ln2179"> </a>
<a name="ln2180">      OBAtom *a = _mol.GetAtom((*p)[0]);</a>
<a name="ln2181">      OBAtom *b = _mol.GetAtom((*p)[1]);</a>
<a name="ln2182"> </a>
<a name="ln2183">      // Check whether or not this interaction is included</a>
<a name="ln2184">      if (HasGroups()) {</a>
<a name="ln2185">        bool isIncludedPair = false;</a>
<a name="ln2186">        for (size_t i=0; i &lt; _interGroup.size(); ++i) {</a>
<a name="ln2187">          if (_interGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln2188">              _interGroup[i].BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln2189">            isIncludedPair = true;</a>
<a name="ln2190">            break;</a>
<a name="ln2191">          }</a>
<a name="ln2192">        }</a>
<a name="ln2193">        if (!isIncludedPair) {</a>
<a name="ln2194">          for (size_t i=0; i &lt; _interGroups.size(); ++i) {</a>
<a name="ln2195">            if (_interGroups[i].first.BitIsSet(a-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln2196">                _interGroups[i].second.BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln2197">              isIncludedPair = true;</a>
<a name="ln2198">              break;</a>
<a name="ln2199">            }</a>
<a name="ln2200">            if (_interGroups[i].first.BitIsSet(b-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln2201">                _interGroups[i].second.BitIsSet(a-&gt;GetIdx())) {</a>
<a name="ln2202">              isIncludedPair = true;</a>
<a name="ln2203">              break;</a>
<a name="ln2204">            }</a>
<a name="ln2205">          }</a>
<a name="ln2206">        }</a>
<a name="ln2207">        if (!isIncludedPair) {</a>
<a name="ln2208">          continue;</a>
<a name="ln2209">        }</a>
<a name="ln2210">      }</a>
<a name="ln2211"> </a>
<a name="ln2212">      // Get the distance squared btwn a and b</a>
<a name="ln2213">      // Not currently a method and this can be vectorized</a>
<a name="ln2214">      double ab[3];</a>
<a name="ln2215">      VectorSubtract(a-&gt;GetCoordinate(), b-&gt;GetCoordinate(), ab);</a>
<a name="ln2216">      double rabSq = 0.0;</a>
<a name="ln2217">      for (int j = 0; j &lt; 3; ++j) {</a>
<a name="ln2218">        rabSq += SQUARE(ab[j]);</a>
<a name="ln2219">      }</a>
<a name="ln2220"> </a>
<a name="ln2221">      // update vdw pairs</a>
<a name="ln2222">      if (rabSq &lt; rvdwSquared) {</a>
<a name="ln2223">        _vdwpairs.SetBitOn(pairIndex);</a>
<a name="ln2224">      } else {</a>
<a name="ln2225">        _vdwpairs.SetBitOff(pairIndex);</a>
<a name="ln2226">      }</a>
<a name="ln2227">      // update electrostatic pairs</a>
<a name="ln2228">      if (rabSq &lt; releSquared) {</a>
<a name="ln2229">        _elepairs.SetBitOn(pairIndex);</a>
<a name="ln2230">      } else {</a>
<a name="ln2231">        _elepairs.SetBitOff(pairIndex);</a>
<a name="ln2232">      }</a>
<a name="ln2233">    }</a>
<a name="ln2234"> </a>
<a name="ln2235">    /*</a>
<a name="ln2236">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2237">      snprintf(_logbuf, BUFF_SIZE, &quot;UPDATE VDW PAIRS: %d --&gt; %d (VDW), %d (ELE) \n&quot;, i+1,</a>
<a name="ln2238">      _vdwpairs.CountBits(), _elepairs.CountBits());</a>
<a name="ln2239">      OBFFLog(_logbuf);</a>
<a name="ln2240">      }</a>
<a name="ln2241">    */</a>
<a name="ln2242">  }</a>
<a name="ln2243"> </a>
<a name="ln2244">  unsigned int OBForceField::GetNumPairs()</a>
<a name="ln2245">  {</a>
<a name="ln2246">    unsigned int i = 1;</a>
<a name="ln2247">    FOR_PAIRS_OF_MOL(p, _mol)</a>
<a name="ln2248">      i++;</a>
<a name="ln2249"> </a>
<a name="ln2250">    return i;</a>
<a name="ln2251">  }</a>
<a name="ln2252"> </a>
<a name="ln2253">  unsigned int OBForceField::GetNumElectrostaticPairs()</a>
<a name="ln2254">  {</a>
<a name="ln2255">    return _elepairs.CountBits();</a>
<a name="ln2256">  }</a>
<a name="ln2257"> </a>
<a name="ln2258">  unsigned int OBForceField::GetNumVDWPairs()</a>
<a name="ln2259">  {</a>
<a name="ln2260">    return _vdwpairs.CountBits();</a>
<a name="ln2261">  }</a>
<a name="ln2262"> </a>
<a name="ln2263">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2264">  //</a>
<a name="ln2265">  // Interaction groups</a>
<a name="ln2266">  //</a>
<a name="ln2267">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2268"> </a>
<a name="ln2269"> </a>
<a name="ln2270">  void OBForceField::AddIntraGroup(OBBitVec &amp;group)</a>
<a name="ln2271">  {</a>
<a name="ln2272">    _intraGroup.push_back(group);</a>
<a name="ln2273">  }</a>
<a name="ln2274"> </a>
<a name="ln2275">  void OBForceField::AddInterGroup(OBBitVec &amp;group)</a>
<a name="ln2276">  {</a>
<a name="ln2277">    _interGroup.push_back(group);</a>
<a name="ln2278">  }</a>
<a name="ln2279"> </a>
<a name="ln2280">  void OBForceField::AddInterGroups(OBBitVec &amp;group1, OBBitVec &amp;group2)</a>
<a name="ln2281">  {</a>
<a name="ln2282">    pair&lt;OBBitVec,OBBitVec&gt; groups;</a>
<a name="ln2283">    groups.first = group1;</a>
<a name="ln2284">    groups.second = group2;</a>
<a name="ln2285">    _interGroups.push_back(groups);</a>
<a name="ln2286">  }</a>
<a name="ln2287"> </a>
<a name="ln2288">  void OBForceField::ClearGroups()</a>
<a name="ln2289">  {</a>
<a name="ln2290">    _intraGroup.clear();</a>
<a name="ln2291">    _interGroup.clear();</a>
<a name="ln2292">    _interGroups.clear();</a>
<a name="ln2293">  }</a>
<a name="ln2294"> </a>
<a name="ln2295">  bool OBForceField::HasGroups()</a>
<a name="ln2296">  {</a>
<a name="ln2297">    if (!_intraGroup.empty())</a>
<a name="ln2298">      return true;</a>
<a name="ln2299"> </a>
<a name="ln2300">    if (!_interGroup.empty())</a>
<a name="ln2301">      return true;</a>
<a name="ln2302"> </a>
<a name="ln2303">    if (!_interGroups.empty())</a>
<a name="ln2304">      return true;</a>
<a name="ln2305"> </a>
<a name="ln2306">    return false;</a>
<a name="ln2307">  }</a>
<a name="ln2308"> </a>
<a name="ln2309">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2310">  //</a>
<a name="ln2311">  // Energy Minimization</a>
<a name="ln2312">  //</a>
<a name="ln2313">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2314"> </a>
<a name="ln2315">  // LineSearch</a>
<a name="ln2316">  //</a>
<a name="ln2317">  // atom: coordinates of atom at iteration k (x_k)</a>
<a name="ln2318">  // direction: search direction ( d = -grad(x_0) )</a>
<a name="ln2319">  //</a>
<a name="ln2320">  // ALGORITHM:</a>
<a name="ln2321">  //</a>
<a name="ln2322">  // step = 1</a>
<a name="ln2323">  // for (i = 1 to 100) {                max steps = 100</a>
<a name="ln2324">  //   e_k = energy(x_k)                 energy of current iteration</a>
<a name="ln2325">  //   x_k = x_k + step * d              update coordinates</a>
<a name="ln2326">  //   e_k+1 = energy(x_k+1)             energy of next iteration</a>
<a name="ln2327">  //</a>
<a name="ln2328">  //   if (e_k+1 &lt; e_k)</a>
<a name="ln2329">  //     step = step * 1.2               increase step size</a>
<a name="ln2330">  //   if (e_k+1 &gt; e_k) {</a>
<a name="ln2331">  //     x_k = x_k - step * d            reset coordinates to previous iteration</a>
<a name="ln2332">  //     step = step * 0.5               reduce step size</a>
<a name="ln2333">  //   }</a>
<a name="ln2334">  //   if (e_k+1 == e_k)</a>
<a name="ln2335">  //     end                             convergence criteria reached, stop</a>
<a name="ln2336">  // }</a>
<a name="ln2337">  vector3 OBForceField::LineSearch(OBAtom *atom, vector3 &amp;direction)</a>
<a name="ln2338">  {</a>
<a name="ln2339">    double e_n1, e_n2, step;</a>
<a name="ln2340">    vector3 old_xyz, orig_xyz, xyz_k, dir(0.0, 0.0, 0.0);</a>
<a name="ln2341"> </a>
<a name="ln2342">    // This needs several enhancements</a>
<a name="ln2343">    // 1) Switch to smarter line search method (e.g., Newton's method in 1D)</a>
<a name="ln2344">    //  x(n+1) = x(n) - F(x) / F'(x)   -- can be done numerically</a>
<a name="ln2345">    // 2) Switch to line search for one step of the entire molecule!</a>
<a name="ln2346">    //   This dramatically cuts down on the number of Energy() calls.</a>
<a name="ln2347">    //  (and is more correct anyway)</a>
<a name="ln2348"> </a>
<a name="ln2349">    // See the following implementation</a>
<a name="ln2350"> </a>
<a name="ln2351">    step = 0.2;</a>
<a name="ln2352">    direction.normalize();</a>
<a name="ln2353">    orig_xyz = atom-&gt;GetVector();</a>
<a name="ln2354"> </a>
<a name="ln2355">    e_n1 = Energy(false); // calculate e_k</a>
<a name="ln2356"> </a>
<a name="ln2357">    unsigned int i;</a>
<a name="ln2358">    for (i=0; i&lt;100; i++) {</a>
<a name="ln2359">      old_xyz = atom-&gt;GetVector();</a>
<a name="ln2360"> </a>
<a name="ln2361">      xyz_k = atom-&gt;GetVector() + direction*step;</a>
<a name="ln2362">      atom-&gt;SetVector(xyz_k);  // update coordinates</a>
<a name="ln2363"> </a>
<a name="ln2364">      e_n2 = Energy(false); // calculate e_k+1</a>
<a name="ln2365"> </a>
<a name="ln2366">      // convergence criteria: A higher precision here</a>
<a name="ln2367">      // only takes longer with the same result.</a>
<a name="ln2368">      if (IsNear(e_n2, e_n1, 1.0e-3))</a>
<a name="ln2369">        break;</a>
<a name="ln2370"> </a>
<a name="ln2371">      if (e_n2 &gt; e_n1) { // decrease stepsize</a>
<a name="ln2372">        step *= 0.1;</a>
<a name="ln2373">        atom-&gt;SetVector(old_xyz);</a>
<a name="ln2374">      }</a>
<a name="ln2375">      if (e_n2 &lt; e_n1) {  // increase stepsize</a>
<a name="ln2376">        e_n1 = e_n2;</a>
<a name="ln2377">        step *= 2.15;</a>
<a name="ln2378">        if (step &gt; 1.0)</a>
<a name="ln2379">          step = 1.0;</a>
<a name="ln2380">      }</a>
<a name="ln2381"> </a>
<a name="ln2382">    }</a>
<a name="ln2383"> </a>
<a name="ln2384">    dir = atom-&gt;GetVector() - orig_xyz;</a>
<a name="ln2385">    atom-&gt;SetVector(orig_xyz);</a>
<a name="ln2386"> </a>
<a name="ln2387">    // cutoff accuracy</a>
<a name="ln2388">    if (dir.length() &lt; 1.0e-8)</a>
<a name="ln2389">      return VZero;</a>
<a name="ln2390"> </a>
<a name="ln2391">    return dir;</a>
<a name="ln2392">  }</a>
<a name="ln2393"> </a>
<a name="ln2394">  //</a>
<a name="ln2395">  // Based on the ghemical code (conjgrad.cpp)</a>
<a name="ln2396">  //</a>
<a name="ln2397">  // Implements several enhancements:</a>
<a name="ln2398">  // 1) Switch to smarter line search method (e.g., Newton's method in 1D)</a>
<a name="ln2399">  //  x(n+1) = x(n) - F(x) / F'(x)   -- can be done numerically</a>
<a name="ln2400">  // 2) Switch to line search for one step of the entire molecule!</a>
<a name="ln2401">  //   This dramatically cuts down on the number of Energy() calls.</a>
<a name="ln2402">  //  (and is more correct anyway)</a>
<a name="ln2403">  double OBForceField::Newton2NumLineSearch(double *direction)</a>
<a name="ln2404">  {</a>
<a name="ln2405">    double e_n1, e_n2, e_n3;</a>
<a name="ln2406">    double *origCoords = new double [_ncoords];</a>
<a name="ln2407"> </a>
<a name="ln2408">    double opt_step = 0.0;</a>
<a name="ln2409">    double opt_e = _e_n1; // get energy calculated by sd or cg</a>
<a name="ln2410">    const double def_step = 0.025; // default step</a>
<a name="ln2411">    const double max_step = 4.5; // don't go too far</a>
<a name="ln2412"> </a>
<a name="ln2413">    double sum = 0.0;</a>
<a name="ln2414">    for (unsigned int c = 0; c &lt; _ncoords; ++c) {</a>
<a name="ln2415">      if (isfinite(direction[c])) {</a>
<a name="ln2416">        sum += direction[c] * direction[c];</a>
<a name="ln2417">      } else {</a>
<a name="ln2418">        // make sure we don't have NaN or infinity</a>
<a name="ln2419">        direction[c] = 0.0;</a>
<a name="ln2420">      }</a>
<a name="ln2421">    }</a>
<a name="ln2422"> </a>
<a name="ln2423">    double scale = sqrt(sum);</a>
<a name="ln2424">    if (IsNearZero(scale)) {</a>
<a name="ln2425">      //      cout &lt;&lt; &quot;WARNING: too small \&quot;scale\&quot; at Newton2NumLineSearch&quot; &lt;&lt; endl;</a>
<a name="ln2426">      scale = 1.0e-70; // try to avoid &quot;division by zero&quot; conditions</a>
<a name="ln2427">    }</a>
<a name="ln2428"> </a>
<a name="ln2429">    double step = def_step / scale;</a>
<a name="ln2430">    double max_scl = max_step / scale;</a>
<a name="ln2431"> </a>
<a name="ln2432">    // Save the current position, before we take a step</a>
<a name="ln2433">    memcpy((char*)origCoords,(char*)_mol.GetCoordinates(),sizeof(double)*_ncoords);</a>
<a name="ln2434"> </a>
<a name="ln2435">    int newton = 0;</a>
<a name="ln2436">    while (true) {</a>
<a name="ln2437">      // Take step X(n) + step</a>
<a name="ln2438">      LineSearchTakeStep(origCoords, direction, step);</a>
<a name="ln2439">      e_n1 = Energy(false) + _constraints.GetConstraintEnergy();</a>
<a name="ln2440"> </a>
<a name="ln2441">      if (e_n1 &lt; opt_e) {</a>
<a name="ln2442">        opt_step = step;</a>
<a name="ln2443">        opt_e = e_n1;</a>
<a name="ln2444">      }</a>
<a name="ln2445"> </a>
<a name="ln2446">      if (newton++ &gt; 3)</a>
<a name="ln2447">        break;</a>
<a name="ln2448">      double delta = step * 0.001;</a>
<a name="ln2449"> </a>
<a name="ln2450">      // Take step X(n) + step + delta</a>
<a name="ln2451">      LineSearchTakeStep(origCoords, direction, step+delta);</a>
<a name="ln2452">      e_n2 = Energy(false) + _constraints.GetConstraintEnergy();</a>
<a name="ln2453"> </a>
<a name="ln2454">      // Take step X(n) + step + delta * 2.0</a>
<a name="ln2455">      LineSearchTakeStep(origCoords, direction, step+delta*2.0);</a>
<a name="ln2456">      e_n3 = Energy(false) + _constraints.GetConstraintEnergy();</a>
<a name="ln2457"> </a>
<a name="ln2458">      double denom = e_n3 - 2.0 * e_n2 + e_n1; // f'(x)</a>
<a name="ln2459">      if (denom != 0.0) {</a>
<a name="ln2460">        step = fabs(step - delta * (e_n2 - e_n1) / denom);</a>
<a name="ln2461">        if (step &gt; max_scl) {</a>
<a name="ln2462">          //          cout &lt;&lt; &quot;WARNING: damped steplength &quot; &lt;&lt; step &lt;&lt; &quot; to &quot; &lt;&lt; max_scl &lt;&lt; endl;</a>
<a name="ln2463">          step = max_scl;</a>
<a name="ln2464">        }</a>
<a name="ln2465">      } else {</a>
<a name="ln2466">        break;</a>
<a name="ln2467">      }</a>
<a name="ln2468">    }</a>
<a name="ln2469"> </a>
<a name="ln2470">    if (opt_step == 0.0) { // if we still don't have any valid steplength, try a very small step</a>
<a name="ln2471">      step = 0.001 * def_step / scale;</a>
<a name="ln2472"> </a>
<a name="ln2473">      // Take step X(n) + step</a>
<a name="ln2474">      LineSearchTakeStep(origCoords, direction, step);</a>
<a name="ln2475">      e_n1 = Energy(false) + _constraints.GetConstraintEnergy();</a>
<a name="ln2476"> </a>
<a name="ln2477">      if (e_n1 &lt; opt_e) {</a>
<a name="ln2478">        opt_step = step;</a>
<a name="ln2479">        opt_e = e_n1;</a>
<a name="ln2480">      }</a>
<a name="ln2481"> </a>
<a name="ln2482">    }</a>
<a name="ln2483"> </a>
<a name="ln2484">    // Take optimal step</a>
<a name="ln2485">    LineSearchTakeStep(origCoords, direction, opt_step);</a>
<a name="ln2486"> </a>
<a name="ln2487">    //    cout &lt;&lt; &quot; scale: &quot; &lt;&lt; scale &lt;&lt; &quot; step: &quot; &lt;&lt; opt_step*scale &lt;&lt; &quot; maxstep &quot; &lt;&lt; max_scl*scale &lt;&lt; endl;</a>
<a name="ln2488"> </a>
<a name="ln2489">    delete [] origCoords;</a>
<a name="ln2490"> </a>
<a name="ln2491">    return opt_step * scale;</a>
<a name="ln2492">  }</a>
<a name="ln2493"> </a>
<a name="ln2494">  void OBForceField::LineSearchTakeStep(double* origCoords, double *direction, double step)</a>
<a name="ln2495">  {</a>
<a name="ln2496">    double *currentCoords = _mol.GetCoordinates();</a>
<a name="ln2497"> </a>
<a name="ln2498">    for (unsigned int c = 0; c &lt; _ncoords; ++c) {</a>
<a name="ln2499">      if (isfinite(direction[c])) {</a>
<a name="ln2500">        currentCoords[c] = origCoords[c] + direction[c] * step;</a>
<a name="ln2501">      }</a>
<a name="ln2502">    }</a>
<a name="ln2503">  }</a>
<a name="ln2504"> </a>
<a name="ln2505">  double OBForceField::LineSearch(double *currentCoords, double *direction)</a>
<a name="ln2506">  {</a>
<a name="ln2507">    unsigned int numCoords = _mol.NumAtoms() * 3;</a>
<a name="ln2508">    double e_n1, e_n2, step, alpha, tempStep;</a>
<a name="ln2509">    double *lastStep = new double [numCoords];</a>
<a name="ln2510"> </a>
<a name="ln2511">    alpha = 0.0; // Scale factor along direction vector</a>
<a name="ln2512">    step = 0.2;</a>
<a name="ln2513">    double trustRadius = 0.75; // don't move too far at once</a>
<a name="ln2514"> </a>
<a name="ln2515">    // The initial energy should be precomputed</a>
<a name="ln2516">    e_n1 = _e_n1; // Energy(false) + _constraints.GetConstraintEnergy();</a>
<a name="ln2517"> </a>
<a name="ln2518">    unsigned int i;</a>
<a name="ln2519">    for (i=0; i &lt; 10; ++i) {</a>
<a name="ln2520">      // Save the current position, before we take a step</a>
<a name="ln2521">      memcpy((char*)lastStep,(char*)currentCoords,sizeof(double)*numCoords);</a>
<a name="ln2522"> </a>
<a name="ln2523">      // Vectorizing this would be a big benefit</a>
<a name="ln2524">      // Need to look up using BLAS or Eigen or whatever</a>
<a name="ln2525">      for (unsigned int c = 0; c &lt; numCoords; ++c) {</a>
<a name="ln2526">        if (isfinite(direction[c])) {</a>
<a name="ln2527">          // make sure we don't have NaN or infinity</a>
<a name="ln2528">          tempStep = direction[c] * step;</a>
<a name="ln2529"> </a>
<a name="ln2530">          if (tempStep &gt; trustRadius) // positive big step</a>
<a name="ln2531">            currentCoords[c] += trustRadius;</a>
<a name="ln2532">          else if (tempStep &lt; -trustRadius) // negative big step</a>
<a name="ln2533">            currentCoords[c] -= trustRadius;</a>
<a name="ln2534">          else</a>
<a name="ln2535">            currentCoords[c] += tempStep;</a>
<a name="ln2536">        }</a>
<a name="ln2537">      }</a>
<a name="ln2538"> </a>
<a name="ln2539">      e_n2 = Energy(false) + _constraints.GetConstraintEnergy();</a>
<a name="ln2540"> </a>
<a name="ln2541">      // convergence criteria: A higher precision here</a>
<a name="ln2542">      // only takes longer with the same result.</a>
<a name="ln2543">      if (IsNear(e_n2, e_n1, 1.0e-3)) {</a>
<a name="ln2544">        alpha += step;</a>
<a name="ln2545">        break;</a>
<a name="ln2546">      }</a>
<a name="ln2547"> </a>
<a name="ln2548">      if (e_n2 &gt; e_n1) { // decrease stepsize</a>
<a name="ln2549">        step *= 0.1;</a>
<a name="ln2550">        // move back to the last step</a>
<a name="ln2551">        memcpy((char*)currentCoords,(char*)lastStep,sizeof(double)*numCoords);</a>
<a name="ln2552">      } else if (e_n2 &lt; e_n1) {  // increase stepsize</a>
<a name="ln2553">        e_n1 = e_n2;</a>
<a name="ln2554">        alpha += step; // we've moved some distance</a>
<a name="ln2555">        step *= 2.15;</a>
<a name="ln2556">        if (step &gt; 1.0)</a>
<a name="ln2557">          step = 1.0;</a>
<a name="ln2558">      }</a>
<a name="ln2559"> </a>
<a name="ln2560">    }</a>
<a name="ln2561"> </a>
<a name="ln2562">    delete [] lastStep;</a>
<a name="ln2563"> </a>
<a name="ln2564">    return alpha;</a>
<a name="ln2565">  }</a>
<a name="ln2566"> </a>
<a name="ln2567">  bool OBForceField::DetectExplosion()</a>
<a name="ln2568">  {</a>
<a name="ln2569">    FOR_ATOMS_OF_MOL (atom, _mol) {</a>
<a name="ln2570">      if (!isfinite(atom-&gt;GetX()))</a>
<a name="ln2571">        return true;</a>
<a name="ln2572">      if (!isfinite(atom-&gt;GetY()))</a>
<a name="ln2573">        return true;</a>
<a name="ln2574">      if (!isfinite(atom-&gt;GetZ()))</a>
<a name="ln2575">        return true;</a>
<a name="ln2576">    }</a>
<a name="ln2577"> </a>
<a name="ln2578">    FOR_BONDS_OF_MOL (bond, _mol) {</a>
<a name="ln2579">      if (bond-&gt;GetLength() &gt; 30.0)</a>
<a name="ln2580">        return true;</a>
<a name="ln2581">    }</a>
<a name="ln2582"> </a>
<a name="ln2583">    return false;</a>
<a name="ln2584">  }</a>
<a name="ln2585"> </a>
<a name="ln2586">  vector3 OBForceField::ValidateLineSearch(OBAtom *atom, vector3 &amp;direction)</a>
<a name="ln2587">  {</a>
<a name="ln2588">    double e_n1, e_n2, step;</a>
<a name="ln2589">    vector3 old_xyz, orig_xyz, xyz_k, dir(0.0, 0.0, 0.0);</a>
<a name="ln2590"> </a>
<a name="ln2591">    step = 0.2;</a>
<a name="ln2592">    direction.normalize();</a>
<a name="ln2593">    orig_xyz = atom-&gt;GetVector();</a>
<a name="ln2594"> </a>
<a name="ln2595">    e_n1 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y()); // e_k</a>
<a name="ln2596"> </a>
<a name="ln2597">    for (unsigned int i=0; i&lt;100; i++) {</a>
<a name="ln2598">      old_xyz = atom-&gt;GetVector();</a>
<a name="ln2599"> </a>
<a name="ln2600">      xyz_k = atom-&gt;GetVector() + direction*step;</a>
<a name="ln2601">      atom-&gt;SetVector(xyz_k);  // update coordinates</a>
<a name="ln2602"> </a>
<a name="ln2603">      e_n2 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y()); // e_k+1</a>
<a name="ln2604"> </a>
<a name="ln2605">      if (e_n2 == e_n1) // convergence criteria</a>
<a name="ln2606">        break;</a>
<a name="ln2607"> </a>
<a name="ln2608">      if (e_n2 &gt; e_n1) { // decrease stepsize</a>
<a name="ln2609">        step *= 0.5;</a>
<a name="ln2610">        atom-&gt;SetVector(old_xyz);</a>
<a name="ln2611">      }</a>
<a name="ln2612">      if (e_n2 &lt; e_n1) {  // increase stepsize</a>
<a name="ln2613">        e_n1 = e_n2;</a>
<a name="ln2614">        step *= 1.2;</a>
<a name="ln2615">        if (step &gt; 1.0)</a>
<a name="ln2616">          step = 1.0;</a>
<a name="ln2617">      }</a>
<a name="ln2618"> </a>
<a name="ln2619">    }</a>
<a name="ln2620"> </a>
<a name="ln2621">    dir = atom-&gt;GetVector() - orig_xyz;</a>
<a name="ln2622">    atom-&gt;SetVector(orig_xyz);</a>
<a name="ln2623">    return dir;</a>
<a name="ln2624">  }</a>
<a name="ln2625"> </a>
<a name="ln2626">  // used to validate the SteepestDescent implementation using a simple function.</a>
<a name="ln2627">  //</a>
<a name="ln2628">  // f(x,y) = x^2 + 2y^2</a>
<a name="ln2629">  // minimum: (0, 0)</a>
<a name="ln2630">  // df/dx = 2x</a>
<a name="ln2631">  // df/dy = 4y</a>
<a name="ln2632">  //</a>
<a name="ln2633">  void OBForceField::ValidateSteepestDescent(int steps)</a>
<a name="ln2634">  {</a>
<a name="ln2635">    OBAtom *atom = new OBAtom;</a>
<a name="ln2636">    vector3 grad;</a>
<a name="ln2637">    double e_n1, e_n2;</a>
<a name="ln2638"> </a>
<a name="ln2639">    atom-&gt;SetVector(9.0, 9.0, 0.0);</a>
<a name="ln2640">    e_n1 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y());</a>
<a name="ln2641"> </a>
<a name="ln2642">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2643">      OBFFLog(&quot;\nV A L I D A T E   S T E E P E S T   D E S C E N T\n\n&quot;);</a>
<a name="ln2644">      snprintf(_logbuf, BUFF_SIZE, &quot;STEPS = %d\n\n&quot;,  steps);</a>
<a name="ln2645">      OBFFLog(_logbuf);</a>
<a name="ln2646">      OBFFLog(&quot;STEP n     E(n)       E(n-1)    \n&quot;);</a>
<a name="ln2647">      OBFFLog(&quot;--------------------------------\n&quot;);</a>
<a name="ln2648">    }</a>
<a name="ln2649"> </a>
<a name="ln2650">    for (int i = 1; i &lt;= steps; i++) {</a>
<a name="ln2651">      grad.Set(-2*atom-&gt;x(), -4*atom-&gt;y(), 0.0);</a>
<a name="ln2652">      grad = ValidateLineSearch(&amp;*atom, grad);</a>
<a name="ln2653">      atom-&gt;SetVector(atom-&gt;x() + grad.x(), atom-&gt;y() + grad.y(), 0.0);</a>
<a name="ln2654">      e_n2 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y());</a>
<a name="ln2655"> </a>
<a name="ln2656">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2657">        snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f    %8.3f\n&quot;, i, e_n2, e_n1);</a>
<a name="ln2658">        OBFFLog(_logbuf);</a>
<a name="ln2659">      }</a>
<a name="ln2660"> </a>
<a name="ln2661">      if (IsNear(e_n2, e_n1, 1.0e-7)) {</a>
<a name="ln2662">        IF_OBFF_LOGLVL_LOW</a>
<a name="ln2663">          OBFFLog(&quot;    STEEPEST DESCENT HAS CONVERGED (DELTA E &lt; 1.0e-7)\n&quot;);</a>
<a name="ln2664">        break;</a>
<a name="ln2665">      }</a>
<a name="ln2666"> </a>
<a name="ln2667">      e_n1 = e_n2;</a>
<a name="ln2668">    }</a>
<a name="ln2669"> </a>
<a name="ln2670">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln2671">      OBFFLog(&quot;\n&quot;);</a>
<a name="ln2672"> </a>
<a name="ln2673">    delete atom;</a>
<a name="ln2674">  }</a>
<a name="ln2675"> </a>
<a name="ln2676">  void OBForceField::ValidateConjugateGradients(int steps)</a>
<a name="ln2677">  {</a>
<a name="ln2678">    OBAtom *atom = new OBAtom;</a>
<a name="ln2679">    vector3 grad1, grad2, dir1, dir2;</a>
<a name="ln2680">    double e_n1, e_n2;</a>
<a name="ln2681">    double g2g2, g1g1, g2g1;</a>
<a name="ln2682">    bool firststep;</a>
<a name="ln2683"> </a>
<a name="ln2684">    firststep = true;</a>
<a name="ln2685">    atom-&gt;SetVector(9.0, 9.0, 0.0);</a>
<a name="ln2686">    e_n1 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y());</a>
<a name="ln2687"> </a>
<a name="ln2688">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2689">      OBFFLog(&quot;\nV A L I D A T E   C O N J U G A T E   G R A D I E N T S\n\n&quot;);</a>
<a name="ln2690">      snprintf(_logbuf, BUFF_SIZE, &quot;STEPS = %d\n\n&quot;,  steps);</a>
<a name="ln2691">      OBFFLog(_logbuf);</a>
<a name="ln2692">      OBFFLog(&quot;STEP n     E(n)       E(n-1)    \n&quot;);</a>
<a name="ln2693">      OBFFLog(&quot;--------------------------------\n&quot;);</a>
<a name="ln2694">    }</a>
<a name="ln2695"> </a>
<a name="ln2696">    for (int i = 1; i &lt;= steps; i++) {</a>
<a name="ln2697">      if (firststep) {</a>
<a name="ln2698">        grad1.Set(-2*atom-&gt;x(), -4*atom-&gt;y(), 0.0);</a>
<a name="ln2699">        dir1 = grad1;</a>
<a name="ln2700">        dir1 = ValidateLineSearch(&amp;*atom, dir1);</a>
<a name="ln2701">        atom-&gt;SetVector(atom-&gt;x() + dir1.x(), atom-&gt;y() + dir1.y(), atom-&gt;z() + dir1.z());</a>
<a name="ln2702">        e_n2 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y());</a>
<a name="ln2703"> </a>
<a name="ln2704">        IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2705">          snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f    %8.3f\n&quot;, i, e_n2, e_n1);</a>
<a name="ln2706">          OBFFLog(_logbuf);</a>
<a name="ln2707">        }</a>
<a name="ln2708"> </a>
<a name="ln2709">        e_n1 = e_n2;</a>
<a name="ln2710">        dir1 = grad1;</a>
<a name="ln2711">        firststep = false;</a>
<a name="ln2712">      } else {</a>
<a name="ln2713">        grad2.Set(-2*atom-&gt;x(), -4*atom-&gt;y(), 0.0);</a>
<a name="ln2714">        g2g2 = dot(grad2, grad2);</a>
<a name="ln2715">        g1g1 = dot(grad1, grad1);</a>
<a name="ln2716">        g2g1 = g2g2 / g1g1;</a>
<a name="ln2717">        dir2 = grad2 + g2g1 * dir1;</a>
<a name="ln2718">        dir2 = ValidateLineSearch(&amp;*atom, dir2);</a>
<a name="ln2719">        atom-&gt;SetVector(atom-&gt;x() + dir2.x(), atom-&gt;y() + dir2.y(), atom-&gt;z() + dir2.z());</a>
<a name="ln2720">        grad1 = grad2;</a>
<a name="ln2721">        dir1 = dir2;</a>
<a name="ln2722">        e_n2 = atom-&gt;x() * atom-&gt;x() + 2 * (atom-&gt;y() * atom-&gt;y());</a>
<a name="ln2723"> </a>
<a name="ln2724">        IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2725">          snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f    %8.3f\n&quot;, i, e_n2, e_n1);</a>
<a name="ln2726">          OBFFLog(_logbuf);</a>
<a name="ln2727">        }</a>
<a name="ln2728"> </a>
<a name="ln2729">        if (IsNear(e_n2, e_n1, 1.0e-7)) {</a>
<a name="ln2730">          IF_OBFF_LOGLVL_LOW</a>
<a name="ln2731">            OBFFLog(&quot;    CONJUGATE GRADIENTS HAS CONVERGED (DELTA E &lt; 1.0e-7)\n&quot;);</a>
<a name="ln2732">          break;</a>
<a name="ln2733">        }</a>
<a name="ln2734"> </a>
<a name="ln2735">        e_n1 = e_n2;</a>
<a name="ln2736">      }</a>
<a name="ln2737">    }</a>
<a name="ln2738"> </a>
<a name="ln2739">    delete atom;</a>
<a name="ln2740">  }</a>
<a name="ln2741"> </a>
<a name="ln2742">  void OBForceField::SteepestDescentInitialize(int steps, double econv, int method)</a>
<a name="ln2743">  {</a>
<a name="ln2744">    if (!_validSetup)</a>
<a name="ln2745">      return;</a>
<a name="ln2746"> </a>
<a name="ln2747">    _nsteps = steps;</a>
<a name="ln2748">    _cstep = 0;</a>
<a name="ln2749">    _econv = econv;</a>
<a name="ln2750">    _gconv = 1.0e-2; // gradient convergence (0.1) squared</a>
<a name="ln2751"> </a>
<a name="ln2752">    if (_cutoff)</a>
<a name="ln2753">      UpdatePairsSimple(); // Update the non-bonded pairs (Cut-off)</a>
<a name="ln2754"> </a>
<a name="ln2755">    _e_n1 = Energy() + _constraints.GetConstraintEnergy();</a>
<a name="ln2756"> </a>
<a name="ln2757">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2758">      OBFFLog(&quot;\nS T E E P E S T   D E S C E N T\n\n&quot;);</a>
<a name="ln2759">      snprintf(_logbuf, BUFF_SIZE, &quot;STEPS = %d\n\n&quot;,  steps);</a>
<a name="ln2760">      OBFFLog(_logbuf);</a>
<a name="ln2761">      OBFFLog(&quot;STEP n       E(n)         E(n-1)    \n&quot;);</a>
<a name="ln2762">      OBFFLog(&quot;------------------------------------\n&quot;);</a>
<a name="ln2763">      snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f      ----\n&quot;, _cstep, _e_n1);</a>
<a name="ln2764">      OBFFLog(_logbuf);</a>
<a name="ln2765">    }</a>
<a name="ln2766"> </a>
<a name="ln2767">  }</a>
<a name="ln2768"> </a>
<a name="ln2769">  bool OBForceField::SteepestDescentTakeNSteps(int n)</a>
<a name="ln2770">  {</a>
<a name="ln2771">    if (!_validSetup)</a>
<a name="ln2772">      return 0;</a>
<a name="ln2773"> </a>
<a name="ln2774">    _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln2775">    double e_n2;</a>
<a name="ln2776">    vector3 dir;</a>
<a name="ln2777">    double maxgrad; // for convergence</a>
<a name="ln2778"> </a>
<a name="ln2779">    for (int i = 1; i &lt;= n; i++) {</a>
<a name="ln2780">      _cstep++;</a>
<a name="ln2781">      maxgrad = 1.0e20;</a>
<a name="ln2782"> </a>
<a name="ln2783">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln2784">        unsigned int idx = a-&gt;GetIdx();</a>
<a name="ln2785">        unsigned int coordIdx = (idx - 1) * 3;</a>
<a name="ln2786"> </a>
<a name="ln2787">        if (_constraints.IsFixed(idx) || (_fixAtom == idx) || (_ignoreAtom == idx)) {</a>
<a name="ln2788">          _gradientPtr[coordIdx] = 0.0;</a>
<a name="ln2789">          _gradientPtr[coordIdx+1] = 0.0;</a>
<a name="ln2790">          _gradientPtr[coordIdx+2] = 0.0;</a>
<a name="ln2791">        } else {</a>
<a name="ln2792">          if (!HasAnalyticalGradients()) {</a>
<a name="ln2793">            // use numerical gradients</a>
<a name="ln2794">            dir = NumericalDerivative(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln2795">          } else {</a>
<a name="ln2796">            // use analytical gradients</a>
<a name="ln2797">            dir = GetGradient(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln2798">          }</a>
<a name="ln2799"> </a>
<a name="ln2800">          // check to see how large the gradients are</a>
<a name="ln2801">          if (dir.length_2() &lt; maxgrad)</a>
<a name="ln2802">            maxgrad = dir.length_2();</a>
<a name="ln2803"> </a>
<a name="ln2804">          if (!_constraints.IsXFixed(idx))</a>
<a name="ln2805">            _gradientPtr[coordIdx] = dir.x();</a>
<a name="ln2806">          else</a>
<a name="ln2807">            _gradientPtr[coordIdx] = 0.0;</a>
<a name="ln2808"> </a>
<a name="ln2809">          if (!_constraints.IsYFixed(idx))</a>
<a name="ln2810">            _gradientPtr[coordIdx+1] = dir.y();</a>
<a name="ln2811">          else</a>
<a name="ln2812">            _gradientPtr[coordIdx+1] = 0.0;</a>
<a name="ln2813"> </a>
<a name="ln2814">          if (!_constraints.IsZFixed(idx))</a>
<a name="ln2815">            _gradientPtr[coordIdx+2] = dir.z();</a>
<a name="ln2816">          else</a>
<a name="ln2817">            _gradientPtr[coordIdx+2] = 0.0;</a>
<a name="ln2818">        }</a>
<a name="ln2819">      }</a>
<a name="ln2820">      // perform a linesearch</a>
<a name="ln2821">      switch (_linesearch) {</a>
<a name="ln2822">      case LineSearchType::Newton2Num:</a>
<a name="ln2823">        Newton2NumLineSearch(_gradientPtr);</a>
<a name="ln2824">        break;</a>
<a name="ln2825">      default:</a>
<a name="ln2826">      case LineSearchType::Simple:</a>
<a name="ln2827">        LineSearch(_mol.GetCoordinates(), _gradientPtr);</a>
<a name="ln2828">        break;</a>
<a name="ln2829">      }</a>
<a name="ln2830">      e_n2 = Energy() + _constraints.GetConstraintEnergy();</a>
<a name="ln2831"> </a>
<a name="ln2832">      if ((_cstep % _pairfreq == 0) &amp;&amp; _cutoff)</a>
<a name="ln2833">        UpdatePairsSimple(); // Update the non-bonded pairs (Cut-off)</a>
<a name="ln2834"> </a>
<a name="ln2835">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2836">        if (_cstep % 10 == 0) {</a>
<a name="ln2837">          snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.5f    %8.5f\n&quot;, _cstep, e_n2, _e_n1);</a>
<a name="ln2838">          OBFFLog(_logbuf);</a>
<a name="ln2839">        }</a>
<a name="ln2840">      }</a>
<a name="ln2841"> </a>
<a name="ln2842">      if (IsNear(e_n2, _e_n1, _econv)</a>
<a name="ln2843">          &amp;&amp; (maxgrad &lt; _gconv)) { // gradient criteria (0.1) squared</a>
<a name="ln2844">        IF_OBFF_LOGLVL_LOW</a>
<a name="ln2845">          OBFFLog(&quot;    STEEPEST DESCENT HAS CONVERGED\n&quot;);</a>
<a name="ln2846">        return false;</a>
<a name="ln2847">      }</a>
<a name="ln2848"> </a>
<a name="ln2849">      if (_nsteps == _cstep) {</a>
<a name="ln2850">        return false;</a>
<a name="ln2851">      }</a>
<a name="ln2852"> </a>
<a name="ln2853">      _e_n1 = e_n2;</a>
<a name="ln2854">    }</a>
<a name="ln2855"> </a>
<a name="ln2856">    return true;  // no convergence reached</a>
<a name="ln2857">  }</a>
<a name="ln2858"> </a>
<a name="ln2859">  void OBForceField::SteepestDescent(int steps, double econv, int method)</a>
<a name="ln2860">  {</a>
<a name="ln2861">    if (steps &gt; 0) {</a>
<a name="ln2862">      SteepestDescentInitialize(steps, econv, method);</a>
<a name="ln2863">      SteepestDescentTakeNSteps(steps);</a>
<a name="ln2864">    }</a>
<a name="ln2865">  }</a>
<a name="ln2866"> </a>
<a name="ln2867">  void OBForceField::ConjugateGradientsInitialize(int steps, double econv,</a>
<a name="ln2868">                                                  int method)</a>
<a name="ln2869">  {</a>
<a name="ln2870">    if (!_validSetup || steps==0)</a>
<a name="ln2871">      return;</a>
<a name="ln2872"> </a>
<a name="ln2873">    double e_n2;</a>
<a name="ln2874">    vector3 dir;</a>
<a name="ln2875"> </a>
<a name="ln2876">    _cstep = 0;</a>
<a name="ln2877">    _nsteps = steps;</a>
<a name="ln2878">    _econv = econv;</a>
<a name="ln2879">    _gconv = 1.0e-2; // gradient convergence (0.1) squared</a>
<a name="ln2880">    _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln2881"> </a>
<a name="ln2882">    if (_cutoff)</a>
<a name="ln2883">      UpdatePairsSimple(); // Update the non-bonded pairs (Cut-off)</a>
<a name="ln2884"> </a>
<a name="ln2885">    _e_n1 = Energy() + _constraints.GetConstraintEnergy();</a>
<a name="ln2886"> </a>
<a name="ln2887">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2888">      OBFFLog(&quot;\nC O N J U G A T E   G R A D I E N T S\n\n&quot;);</a>
<a name="ln2889">      snprintf(_logbuf, BUFF_SIZE, &quot;STEPS = %d\n\n&quot;,  steps);</a>
<a name="ln2890">      OBFFLog(_logbuf);</a>
<a name="ln2891">      OBFFLog(&quot;STEP n     E(n)       E(n-1)    \n&quot;);</a>
<a name="ln2892">      OBFFLog(&quot;--------------------------------\n&quot;);</a>
<a name="ln2893">    }</a>
<a name="ln2894"> </a>
<a name="ln2895">    if (_grad1 != nullptr)</a>
<a name="ln2896">      delete [] _grad1;</a>
<a name="ln2897">    _grad1 = new double[_ncoords];</a>
<a name="ln2898">    memset(_grad1, '\0', sizeof(double)*_ncoords);</a>
<a name="ln2899"> </a>
<a name="ln2900">    // Take the first step (same as steepest descent because there is no</a>
<a name="ln2901">    // gradient from the previous step.</a>
<a name="ln2902">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln2903">      unsigned int idx = a-&gt;GetIdx();</a>
<a name="ln2904">      unsigned int coordIdx = (idx - 1) * 3;</a>
<a name="ln2905"> </a>
<a name="ln2906">      if (_constraints.IsFixed(idx) || (_fixAtom == idx) || (_ignoreAtom == idx)) {</a>
<a name="ln2907">        _gradientPtr[coordIdx] = 0.0;</a>
<a name="ln2908">        _gradientPtr[coordIdx+1] = 0.0;</a>
<a name="ln2909">        _gradientPtr[coordIdx+2] = 0.0;</a>
<a name="ln2910">      } else {</a>
<a name="ln2911">        if (!HasAnalyticalGradients()) {</a>
<a name="ln2912">          // use numerical gradients</a>
<a name="ln2913">          dir = NumericalDerivative(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln2914">        } else {</a>
<a name="ln2915">          // use analytical gradients</a>
<a name="ln2916">          dir = GetGradient(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln2917">        }</a>
<a name="ln2918"> </a>
<a name="ln2919">        if (!_constraints.IsXFixed(idx))</a>
<a name="ln2920">          _gradientPtr[coordIdx] = dir.x();</a>
<a name="ln2921">        else</a>
<a name="ln2922">          _gradientPtr[coordIdx] = 0.0;</a>
<a name="ln2923"> </a>
<a name="ln2924">        if (!_constraints.IsYFixed(idx))</a>
<a name="ln2925">          _gradientPtr[coordIdx+1] = dir.y();</a>
<a name="ln2926">        else</a>
<a name="ln2927">          _gradientPtr[coordIdx+1] = 0.0;</a>
<a name="ln2928"> </a>
<a name="ln2929">        if (!_constraints.IsZFixed(idx))</a>
<a name="ln2930">          _gradientPtr[coordIdx+2] = dir.z();</a>
<a name="ln2931">        else</a>
<a name="ln2932">          _gradientPtr[coordIdx+2] = 0.0;</a>
<a name="ln2933">      }</a>
<a name="ln2934">    }</a>
<a name="ln2935">    // perform a linesearch</a>
<a name="ln2936">    switch (_linesearch) {</a>
<a name="ln2937">    case LineSearchType::Newton2Num:</a>
<a name="ln2938">      Newton2NumLineSearch(_gradientPtr);</a>
<a name="ln2939">      break;</a>
<a name="ln2940">    default:</a>
<a name="ln2941">    case LineSearchType::Simple:</a>
<a name="ln2942">      LineSearch(_mol.GetCoordinates(), _gradientPtr);</a>
<a name="ln2943">      break;</a>
<a name="ln2944">    }</a>
<a name="ln2945">    e_n2 = Energy() + _constraints.GetConstraintEnergy();</a>
<a name="ln2946"> </a>
<a name="ln2947">    IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2948">      snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f    %8.3f\n&quot;, 1, e_n2, _e_n1);</a>
<a name="ln2949">      OBFFLog(_logbuf);</a>
<a name="ln2950">    }</a>
<a name="ln2951"> </a>
<a name="ln2952">    // save the direction and energy</a>
<a name="ln2953">    memcpy(_grad1, _gradientPtr, sizeof(double)*_ncoords);</a>
<a name="ln2954">    _e_n1 = e_n2;</a>
<a name="ln2955">  }</a>
<a name="ln2956"> </a>
<a name="ln2957">  bool OBForceField::ConjugateGradientsTakeNSteps(int n)</a>
<a name="ln2958">  {</a>
<a name="ln2959">    if (!_validSetup)</a>
<a name="ln2960">      return 0;</a>
<a name="ln2961"> </a>
<a name="ln2962">    double e_n2;</a>
<a name="ln2963">    double g2g2, g1g1, beta;</a>
<a name="ln2964">    vector3 grad2, dir2;</a>
<a name="ln2965">    vector3 grad1, dir1; // temporaries to perform dot product, etc.</a>
<a name="ln2966">    double maxgrad; // for convergence</a>
<a name="ln2967"> </a>
<a name="ln2968">    if (_ncoords != _mol.NumAtoms() * 3)</a>
<a name="ln2969">      return false;</a>
<a name="ln2970"> </a>
<a name="ln2971">    e_n2 = 0.0;</a>
<a name="ln2972"> </a>
<a name="ln2973">    for (int i = 1; i &lt;= n; i++) {</a>
<a name="ln2974">      _cstep++;</a>
<a name="ln2975">      maxgrad = 1.0e20;</a>
<a name="ln2976"> </a>
<a name="ln2977">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln2978">        unsigned int idx = a-&gt;GetIdx();</a>
<a name="ln2979">        unsigned int coordIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln2980"> </a>
<a name="ln2981">        if (_constraints.IsFixed(idx) || (_fixAtom == idx) || (_ignoreAtom == idx)) {</a>
<a name="ln2982">          _grad1[coordIdx] = 0.0;</a>
<a name="ln2983">          _grad1[coordIdx+1] = 0.0;</a>
<a name="ln2984">          _grad1[coordIdx+2] = 0.0;</a>
<a name="ln2985">        } else {</a>
<a name="ln2986">          if (!HasAnalyticalGradients()) {</a>
<a name="ln2987">            // use numerical gradients</a>
<a name="ln2988">            grad2 = NumericalDerivative(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln2989">          } else {</a>
<a name="ln2990">            // use analytical gradients</a>
<a name="ln2991">            grad2 = GetGradient(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln2992">          }</a>
<a name="ln2993"> </a>
<a name="ln2994">          // Fletcher-Reeves formula for Beta</a>
<a name="ln2995">          // http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>
<a name="ln2996">          // NOTE: We make sure to reset and use the steepest descent direction</a>
<a name="ln2997">          //   after NumAtoms steps</a>
<a name="ln2998">          if (_cstep % _mol.NumAtoms() != 0) {</a>
<a name="ln2999">            g2g2 = dot(grad2, grad2);</a>
<a name="ln3000">            grad1 = vector3(_grad1[coordIdx], _grad1[coordIdx+1], _grad1[coordIdx+2]);</a>
<a name="ln3001">            g1g1 = dot(grad1, grad1);</a>
<a name="ln3002">            beta = g2g2 / g1g1;</a>
<a name="ln3003">            grad2 += beta * grad1;</a>
<a name="ln3004">          }</a>
<a name="ln3005"> </a>
<a name="ln3006">          // check to see how large the gradients are</a>
<a name="ln3007">          if (grad2.length_2() &lt; maxgrad)</a>
<a name="ln3008">            maxgrad = grad2.length_2();</a>
<a name="ln3009"> </a>
<a name="ln3010">          if (!_constraints.IsXFixed(idx))</a>
<a name="ln3011">            _grad1[coordIdx] = grad2.x();</a>
<a name="ln3012">          else</a>
<a name="ln3013">            _grad1[coordIdx] = 0.0;</a>
<a name="ln3014"> </a>
<a name="ln3015">          if (!_constraints.IsYFixed(idx))</a>
<a name="ln3016">            _grad1[coordIdx+1] = grad2.y();</a>
<a name="ln3017">          else</a>
<a name="ln3018">            _grad1[coordIdx+1] = 0.0;</a>
<a name="ln3019"> </a>
<a name="ln3020">          if (!_constraints.IsZFixed(idx))</a>
<a name="ln3021">            _grad1[coordIdx+2] = grad2.z();</a>
<a name="ln3022">          else</a>
<a name="ln3023">            _grad1[coordIdx+2] = 0.0;</a>
<a name="ln3024">        }</a>
<a name="ln3025">      }</a>
<a name="ln3026">      // perform a linesearch</a>
<a name="ln3027">      switch (_linesearch) {</a>
<a name="ln3028">      case LineSearchType::Newton2Num:</a>
<a name="ln3029">        Newton2NumLineSearch(_grad1);</a>
<a name="ln3030">        break;</a>
<a name="ln3031">      default:</a>
<a name="ln3032">      case LineSearchType::Simple:</a>
<a name="ln3033">        LineSearch(_mol.GetCoordinates(), _grad1);</a>
<a name="ln3034">        break;</a>
<a name="ln3035">      }</a>
<a name="ln3036">      // save the direction</a>
<a name="ln3037">      memcpy(_gradientPtr, _grad1, sizeof(double)*_ncoords);</a>
<a name="ln3038"> </a>
<a name="ln3039">      e_n2 = Energy() + _constraints.GetConstraintEnergy();</a>
<a name="ln3040"> </a>
<a name="ln3041">      if ((_cstep % _pairfreq == 0) &amp;&amp; _cutoff)</a>
<a name="ln3042">        UpdatePairsSimple(); // Update the non-bonded pairs (Cut-off)</a>
<a name="ln3043"> </a>
<a name="ln3044">      if (IsNear(e_n2, _e_n1, _econv)</a>
<a name="ln3045">          &amp;&amp; (maxgrad &lt; _gconv)) { // gradient criteria (0.1) squared</a>
<a name="ln3046">        IF_OBFF_LOGLVL_LOW {</a>
<a name="ln3047">          snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f    %8.3f\n&quot;, _cstep, e_n2, _e_n1);</a>
<a name="ln3048">          OBFFLog(_logbuf);</a>
<a name="ln3049">          OBFFLog(&quot;    CONJUGATE GRADIENTS HAS CONVERGED\n&quot;);</a>
<a name="ln3050">        }</a>
<a name="ln3051">        return false;</a>
<a name="ln3052">      }</a>
<a name="ln3053"> </a>
<a name="ln3054">      IF_OBFF_LOGLVL_LOW {</a>
<a name="ln3055">        if (_cstep % 10 == 0) {</a>
<a name="ln3056">          snprintf(_logbuf, BUFF_SIZE, &quot; %4d    %8.3f    %8.3f\n&quot;, _cstep, e_n2, _e_n1);</a>
<a name="ln3057">          OBFFLog(_logbuf);</a>
<a name="ln3058">        }</a>
<a name="ln3059">      }</a>
<a name="ln3060"> </a>
<a name="ln3061">      if (_nsteps == _cstep)</a>
<a name="ln3062">        return false;</a>
<a name="ln3063"> </a>
<a name="ln3064">      _e_n1 = e_n2;</a>
<a name="ln3065">    }</a>
<a name="ln3066"> </a>
<a name="ln3067">    return true; // no convergence reached</a>
<a name="ln3068">  }</a>
<a name="ln3069"> </a>
<a name="ln3070">  void OBForceField::ConjugateGradients(int steps, double econv, int method)</a>
<a name="ln3071">  {</a>
<a name="ln3072">    ConjugateGradientsInitialize(steps, econv, method);</a>
<a name="ln3073">    if (steps &gt; 1) // ConjugateGradientsInitialize takes the first step</a>
<a name="ln3074">      ConjugateGradientsTakeNSteps(steps);</a>
<a name="ln3075">  }</a>
<a name="ln3076"> </a>
<a name="ln3077">  //</a>
<a name="ln3078">  //         f(1) - f(0)</a>
<a name="ln3079">  // f'(0) = -----------      f(1) = f(0+h)</a>
<a name="ln3080">  //              h</a>
<a name="ln3081">  //</a>
<a name="ln3082">  vector3 OBForceField::NumericalDerivative(OBAtom *atom, int terms)</a>
<a name="ln3083">  {</a>
<a name="ln3084">    vector3 va, grad;</a>
<a name="ln3085">    double e_orig, e_plus_delta, delta, dx, dy, dz;</a>
<a name="ln3086"> </a>
<a name="ln3087">    delta = 1.0e-5;</a>
<a name="ln3088"> </a>
<a name="ln3089">    va = atom-&gt;GetVector();</a>
<a name="ln3090"> </a>
<a name="ln3091">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3092">      e_orig = Energy(false);</a>
<a name="ln3093">    else {</a>
<a name="ln3094">      e_orig = 0.0;</a>
<a name="ln3095">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3096">        e_orig += E_Bond(false);</a>
<a name="ln3097">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3098">        e_orig += E_Angle(false);</a>
<a name="ln3099">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3100">        e_orig += E_StrBnd(false);</a>
<a name="ln3101">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3102">        e_orig += E_Torsion(false);</a>
<a name="ln3103">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3104">        e_orig += E_OOP(false);</a>
<a name="ln3105">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3106">        e_orig += E_VDW(false);</a>
<a name="ln3107">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3108">        e_orig += E_Electrostatic(false);</a>
<a name="ln3109">    }</a>
<a name="ln3110"> </a>
<a name="ln3111">    // X direction</a>
<a name="ln3112">    atom-&gt;SetVector(va.x() + delta, va.y(), va.z());</a>
<a name="ln3113"> </a>
<a name="ln3114">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3115">      e_plus_delta = Energy(false);</a>
<a name="ln3116">    else {</a>
<a name="ln3117">      e_plus_delta = 0.0;</a>
<a name="ln3118">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3119">        e_plus_delta += E_Bond(false);</a>
<a name="ln3120">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3121">        e_plus_delta += E_Angle(false);</a>
<a name="ln3122">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3123">        e_plus_delta += E_StrBnd(false);</a>
<a name="ln3124">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3125">        e_plus_delta += E_Torsion(false);</a>
<a name="ln3126">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3127">        e_plus_delta += E_OOP(false);</a>
<a name="ln3128">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3129">        e_plus_delta += E_VDW(false);</a>
<a name="ln3130">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3131">        e_plus_delta += E_Electrostatic(false);</a>
<a name="ln3132">    }</a>
<a name="ln3133"> </a>
<a name="ln3134">    dx = (e_plus_delta - e_orig) / delta;</a>
<a name="ln3135"> </a>
<a name="ln3136">    // Y direction</a>
<a name="ln3137">    atom-&gt;SetVector(va.x(), va.y() + delta, va.z());</a>
<a name="ln3138"> </a>
<a name="ln3139">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3140">      e_plus_delta = Energy(false);</a>
<a name="ln3141">    else {</a>
<a name="ln3142">      e_plus_delta = 0.0;</a>
<a name="ln3143">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3144">        e_plus_delta += E_Bond(false);</a>
<a name="ln3145">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3146">        e_plus_delta += E_Angle(false);</a>
<a name="ln3147">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3148">        e_plus_delta += E_StrBnd(false);</a>
<a name="ln3149">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3150">        e_plus_delta += E_Torsion(false);</a>
<a name="ln3151">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3152">        e_plus_delta += E_OOP(false);</a>
<a name="ln3153">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3154">        e_plus_delta += E_VDW(false);</a>
<a name="ln3155">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3156">        e_plus_delta += E_Electrostatic(false);</a>
<a name="ln3157">    }</a>
<a name="ln3158"> </a>
<a name="ln3159">    dy = (e_plus_delta - e_orig) / delta;</a>
<a name="ln3160"> </a>
<a name="ln3161">    // Z direction</a>
<a name="ln3162">    atom-&gt;SetVector(va.x(), va.y(), va.z() + delta);</a>
<a name="ln3163"> </a>
<a name="ln3164">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3165">      e_plus_delta = Energy(false);</a>
<a name="ln3166">    else {</a>
<a name="ln3167">      e_plus_delta = 0.0;</a>
<a name="ln3168">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3169">        e_plus_delta += E_Bond(false);</a>
<a name="ln3170">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3171">        e_plus_delta += E_Angle(false);</a>
<a name="ln3172">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3173">        e_plus_delta += E_StrBnd(false);</a>
<a name="ln3174">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3175">        e_plus_delta += E_Torsion(false);</a>
<a name="ln3176">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3177">        e_plus_delta += E_OOP(false);</a>
<a name="ln3178">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3179">        e_plus_delta += E_VDW(false);</a>
<a name="ln3180">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3181">        e_plus_delta += E_Electrostatic(false);</a>
<a name="ln3182">    }</a>
<a name="ln3183"> </a>
<a name="ln3184">    dz = (e_plus_delta - e_orig) / delta;</a>
<a name="ln3185"> </a>
<a name="ln3186">    // reset coordinates to original</a>
<a name="ln3187">    atom-&gt;SetVector(va.x(), va.y(), va.z());</a>
<a name="ln3188"> </a>
<a name="ln3189">    grad.Set(-dx, -dy, -dz);</a>
<a name="ln3190">    return (grad);</a>
<a name="ln3191">  }</a>
<a name="ln3192"> </a>
<a name="ln3193">  //</a>
<a name="ln3194">  //         f(2) - 2f(1) + f(0)</a>
<a name="ln3195">  // f'(0) = -------------------      f(1) = f(0+h)</a>
<a name="ln3196">  //                 h^2              f(1) = f(0+2h)</a>
<a name="ln3197">  //</a>
<a name="ln3198">  vector3 OBForceField::NumericalSecondDerivative(OBAtom *atom, int terms)</a>
<a name="ln3199">  {</a>
<a name="ln3200">    vector3 va, grad;</a>
<a name="ln3201">    double e_0, e_1, e_2, delta, dx, dy, dz;</a>
<a name="ln3202"> </a>
<a name="ln3203">    delta = 1.0e-5;</a>
<a name="ln3204"> </a>
<a name="ln3205">    va = atom-&gt;GetVector();</a>
<a name="ln3206"> </a>
<a name="ln3207">    // calculate f(0)</a>
<a name="ln3208">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3209">      e_0 = Energy(false);</a>
<a name="ln3210">    else {</a>
<a name="ln3211">      e_0 = 0.0;</a>
<a name="ln3212">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3213">        e_0 += E_Bond(false);</a>
<a name="ln3214">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3215">        e_0 += E_Angle(false);</a>
<a name="ln3216">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3217">        e_0 += E_StrBnd(false);</a>
<a name="ln3218">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3219">        e_0 += E_Torsion(false);</a>
<a name="ln3220">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3221">        e_0 += E_OOP(false);</a>
<a name="ln3222">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3223">        e_0 += E_VDW(false);</a>
<a name="ln3224">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3225">        e_0 += E_Electrostatic(false);</a>
<a name="ln3226">    }</a>
<a name="ln3227"> </a>
<a name="ln3228">    //</a>
<a name="ln3229">    // X direction</a>
<a name="ln3230">    //</a>
<a name="ln3231"> </a>
<a name="ln3232">    // calculate f(1)</a>
<a name="ln3233">    atom-&gt;SetVector(va.x() + delta, va.y(), va.z());</a>
<a name="ln3234"> </a>
<a name="ln3235">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3236">      e_1 = Energy(false);</a>
<a name="ln3237">    else {</a>
<a name="ln3238">      e_1 = 0.0;</a>
<a name="ln3239">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3240">        e_1 += E_Bond(false);</a>
<a name="ln3241">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3242">        e_1 += E_Angle(false);</a>
<a name="ln3243">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3244">        e_1 += E_StrBnd(false);</a>
<a name="ln3245">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3246">        e_1 += E_Torsion(false);</a>
<a name="ln3247">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3248">        e_1 += E_OOP(false);</a>
<a name="ln3249">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3250">        e_1 += E_VDW(false);</a>
<a name="ln3251">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3252">        e_1 += E_Electrostatic(false);</a>
<a name="ln3253">    }</a>
<a name="ln3254"> </a>
<a name="ln3255">    // calculate f(2)</a>
<a name="ln3256">    atom-&gt;SetVector(va.x() + 2 * delta, va.y(), va.z());</a>
<a name="ln3257"> </a>
<a name="ln3258">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3259">      e_2 = Energy(false);</a>
<a name="ln3260">    else {</a>
<a name="ln3261">      e_2 = 0.0;</a>
<a name="ln3262">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3263">        e_2 += E_Bond(false);</a>
<a name="ln3264">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3265">        e_2 += E_Angle(false);</a>
<a name="ln3266">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3267">        e_2 += E_StrBnd(false);</a>
<a name="ln3268">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3269">        e_2 += E_Torsion(false);</a>
<a name="ln3270">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3271">        e_2 += E_OOP(false);</a>
<a name="ln3272">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3273">        e_2 += E_VDW(false);</a>
<a name="ln3274">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3275">        e_2 += E_Electrostatic(false);</a>
<a name="ln3276">    }</a>
<a name="ln3277"> </a>
<a name="ln3278">    dx = (e_2 - 2 * e_1 + e_0) / (delta * delta);</a>
<a name="ln3279"> </a>
<a name="ln3280">    //</a>
<a name="ln3281">    // Y direction</a>
<a name="ln3282">    //</a>
<a name="ln3283"> </a>
<a name="ln3284">    // calculate f(1)</a>
<a name="ln3285">    atom-&gt;SetVector(va.x(), va.y() + delta, va.z());</a>
<a name="ln3286"> </a>
<a name="ln3287">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3288">      e_1 = Energy(false);</a>
<a name="ln3289">    else {</a>
<a name="ln3290">      e_1 = 0.0;</a>
<a name="ln3291">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3292">        e_1 += E_Bond(false);</a>
<a name="ln3293">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3294">        e_1 += E_Angle(false);</a>
<a name="ln3295">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3296">        e_1 += E_StrBnd(false);</a>
<a name="ln3297">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3298">        e_1 += E_Torsion(false);</a>
<a name="ln3299">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3300">        e_1 += E_OOP(false);</a>
<a name="ln3301">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3302">        e_1 += E_VDW(false);</a>
<a name="ln3303">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3304">        e_1 += E_Electrostatic(false);</a>
<a name="ln3305">    }</a>
<a name="ln3306"> </a>
<a name="ln3307">    // calculate f(2)</a>
<a name="ln3308">    atom-&gt;SetVector(va.x(), va.y() + 2 * delta, va.z());</a>
<a name="ln3309"> </a>
<a name="ln3310">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3311">      e_2 = Energy(false);</a>
<a name="ln3312">    else {</a>
<a name="ln3313">      e_2 = 0.0;</a>
<a name="ln3314">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3315">        e_2 += E_Bond(false);</a>
<a name="ln3316">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3317">        e_2 += E_Angle(false);</a>
<a name="ln3318">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3319">        e_2 += E_StrBnd(false);</a>
<a name="ln3320">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3321">        e_2 += E_Torsion(false);</a>
<a name="ln3322">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3323">        e_2 += E_OOP(false);</a>
<a name="ln3324">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3325">        e_2 += E_VDW(false);</a>
<a name="ln3326">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3327">        e_2 += E_Electrostatic(false);</a>
<a name="ln3328">    }</a>
<a name="ln3329"> </a>
<a name="ln3330">    dy = (e_2 - 2 * e_1 + e_0) / (delta * delta);</a>
<a name="ln3331"> </a>
<a name="ln3332">    //</a>
<a name="ln3333">    // Z direction</a>
<a name="ln3334">    //</a>
<a name="ln3335"> </a>
<a name="ln3336">    // calculate f(1)</a>
<a name="ln3337">    atom-&gt;SetVector(va.x(), va.y(), va.z() + delta);</a>
<a name="ln3338"> </a>
<a name="ln3339">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3340">      e_1 = Energy(false);</a>
<a name="ln3341">    else {</a>
<a name="ln3342">      e_1 = 0.0;</a>
<a name="ln3343">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3344">        e_1 += E_Bond(false);</a>
<a name="ln3345">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3346">        e_1 += E_Angle(false);</a>
<a name="ln3347">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3348">        e_1 += E_StrBnd(false);</a>
<a name="ln3349">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3350">        e_1 += E_Torsion(false);</a>
<a name="ln3351">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3352">        e_1 += E_OOP(false);</a>
<a name="ln3353">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3354">        e_1 += E_VDW(false);</a>
<a name="ln3355">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3356">        e_1 += E_Electrostatic(false);</a>
<a name="ln3357">    }</a>
<a name="ln3358"> </a>
<a name="ln3359">    // calculate f(2)</a>
<a name="ln3360">    atom-&gt;SetVector(va.x(), va.y(), va.z() + 2 * delta);</a>
<a name="ln3361"> </a>
<a name="ln3362">    if (terms &amp; OBFF_ENERGY)</a>
<a name="ln3363">      e_2 = Energy(false);</a>
<a name="ln3364">    else {</a>
<a name="ln3365">      e_2 = 0.0;</a>
<a name="ln3366">      if (terms &amp; OBFF_EBOND)</a>
<a name="ln3367">        e_2 += E_Bond(false);</a>
<a name="ln3368">      if (terms &amp; OBFF_EANGLE)</a>
<a name="ln3369">        e_2 += E_Angle(false);</a>
<a name="ln3370">      if (terms &amp; OBFF_ESTRBND)</a>
<a name="ln3371">        e_2 += E_StrBnd(false);</a>
<a name="ln3372">      if (terms &amp; OBFF_ETORSION)</a>
<a name="ln3373">        e_2 += E_Torsion(false);</a>
<a name="ln3374">      if (terms &amp; OBFF_EOOP)</a>
<a name="ln3375">        e_2 += E_OOP(false);</a>
<a name="ln3376">      if (terms &amp; OBFF_EVDW)</a>
<a name="ln3377">        e_2 += E_VDW(false);</a>
<a name="ln3378">      if (terms &amp; OBFF_EELECTROSTATIC)</a>
<a name="ln3379">        e_2 += E_Electrostatic(false);</a>
<a name="ln3380">    }</a>
<a name="ln3381"> </a>
<a name="ln3382">    dz = (e_2 - 2 * e_1 + e_0) / (delta * delta);</a>
<a name="ln3383"> </a>
<a name="ln3384">    // reset coordinates to original</a>
<a name="ln3385">    atom-&gt;SetVector(va.x(), va.y(), va.z());</a>
<a name="ln3386"> </a>
<a name="ln3387">    grad.Set(-dx, -dy, -dz);</a>
<a name="ln3388">    return (grad);</a>
<a name="ln3389">  }</a>
<a name="ln3390"> </a>
<a name="ln3391">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3392">  //</a>
<a name="ln3393">  // Molecular Dynamics</a>
<a name="ln3394">  //</a>
<a name="ln3395">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3396">  // Most OpenBabel MD alogrithms are based on:</a>
<a name="ln3397">  // GROMACS, Groningen Machine for Chemical Simulations, USER MANUAL, version 3.3</a>
<a name="ln3398">  //</a>
<a name="ln3399">  // Quantity:		Symbol:		Unit:</a>
<a name="ln3400">  // length		r		A = 10e-10m</a>
<a name="ln3401">  // mass		m 		amu = 1.6605402 10e-27kg</a>
<a name="ln3402">  // time		t		ps = 10e-12s</a>
<a name="ln3403">  // temperature	T		K</a>
<a name="ln3404">  //</a>
<a name="ln3405">  // force		F		kcal mol^-1 A^-1</a>
<a name="ln3406">  // acceleration	a		kcal mol^-1 A^-1 1000x amu-1 = A ps^-2 (*)</a>
<a name="ln3407">  // velocity		v		A ps^-1</a>
<a name="ln3408">  //</a>
<a name="ln3409">  // The force we calculate comes from the force field. Currently this functions</a>
<a name="ln3410">  // only works for MMFF94 and so the unit for energy is kcal, but this does not</a>
<a name="ln3411">  // affect what is explained below. (note: A isn't a SI unit either)</a>
<a name="ln3412">  //</a>
<a name="ln3413">  //     [   kcal   ]          F    [     kcal    ]   [       kcal       ]   [      A      ]   [   A    ]</a>
<a name="ln3414">  // F = [ -------- ]     a = --- = [ ----------- ] = [ ---------------- ] = [ ----------- ] = [ ------ ]</a>
<a name="ln3415">  //     [  mol  A  ]          m    [  mol A amu  ]   [  mol A 10^-27kg  ]   [  10^-24s^2  ]   [  ps^2  ]</a>
<a name="ln3416">  //</a>
<a name="ln3417">  // This means that if we divide the force (coming from the FF) by 1000x its mass in amu,</a>
<a name="ln3418">  // we get the acceleration in A ps^-2.</a>
<a name="ln3419"> </a>
<a name="ln3420">  // gromacs user manual page 17</a>
<a name="ln3421">  void OBForceField::GenerateVelocities()</a>
<a name="ln3422">  {</a>
<a name="ln3423">    cout &lt;&lt; &quot;OBForceField::GenerateVelocities()&quot; &lt;&lt; endl;</a>
<a name="ln3424">    OBRandom generator;</a>
<a name="ln3425">    generator.TimeSeed();</a>
<a name="ln3426">    _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln3427">    int velocityIdx;</a>
<a name="ln3428">    double velocity;</a>
<a name="ln3429"> </a>
<a name="ln3430">    _velocityPtr = new double[_ncoords];</a>
<a name="ln3431">    memset(_velocityPtr, '\0', sizeof(double)*_ncoords);</a>
<a name="ln3432"> </a>
<a name="ln3433">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln3434">      if (!_constraints.IsFixed(a-&gt;GetIdx()) || (_fixAtom == a-&gt;GetIdx()) || (_ignoreAtom == a-&gt;GetIdx())) {</a>
<a name="ln3435">        velocityIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln3436"> </a>
<a name="ln3437">        // add twelve random numbers between 0.0 and 1.0,</a>
<a name="ln3438">        // subtract 6.0 from their sum, multiply with sqrt(kT/m)</a>
<a name="ln3439">        if (!_constraints.IsXFixed(a-&gt;GetIdx())) {</a>
<a name="ln3440">          velocity = 0.0;</a>
<a name="ln3441">          for (int i=0; i &lt; 12; ++i)</a>
<a name="ln3442">            velocity += generator.NextFloat();</a>
<a name="ln3443">          velocity -= 6.0;</a>
<a name="ln3444">          velocity *= sqrt((GAS_CONSTANT * _temp)/ (1000 * a-&gt;GetAtomicMass()));</a>
<a name="ln3445">          _velocityPtr[velocityIdx] = velocity; // x10: gromacs uses nm instead of A</a>
<a name="ln3446">        }</a>
<a name="ln3447"> </a>
<a name="ln3448">        if (!_constraints.IsYFixed(a-&gt;GetIdx())) {</a>
<a name="ln3449">          velocity = 0.0;</a>
<a name="ln3450">          for (int i=0; i &lt; 12; ++i)</a>
<a name="ln3451">            velocity += generator.NextFloat();</a>
<a name="ln3452">          velocity -= 6.0;</a>
<a name="ln3453">          velocity *= sqrt((GAS_CONSTANT * _temp)/ (1000 * a-&gt;GetAtomicMass()));</a>
<a name="ln3454">          _velocityPtr[velocityIdx+1] = velocity; // idem</a>
<a name="ln3455">        }</a>
<a name="ln3456"> </a>
<a name="ln3457">        if (!_constraints.IsZFixed(a-&gt;GetIdx())) {</a>
<a name="ln3458">          velocity = 0.0;</a>
<a name="ln3459">          for (int i=0; i &lt; 12; ++i)</a>
<a name="ln3460">            velocity += generator.NextFloat();</a>
<a name="ln3461">          velocity -= 6.0;</a>
<a name="ln3462">          velocity *= sqrt((GAS_CONSTANT * _temp)/ (1000 * a-&gt;GetAtomicMass()));</a>
<a name="ln3463">          _velocityPtr[velocityIdx+2] = velocity; // idem</a>
<a name="ln3464">        }</a>
<a name="ln3465">      }</a>
<a name="ln3466">    }</a>
<a name="ln3467"> </a>
<a name="ln3468">    CorrectVelocities();</a>
<a name="ln3469">  }</a>
<a name="ln3470"> </a>
<a name="ln3471">  void OBForceField::CorrectVelocities()</a>
<a name="ln3472">  {</a>
<a name="ln3473">    _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln3474">    int velocityIdx;</a>
<a name="ln3475">    double velocity, E_kin, E_kin2, factor;</a>
<a name="ln3476"> </a>
<a name="ln3477">    // E_kin = 0.5 * Ndf * R * T</a>
<a name="ln3478">    E_kin = _ncoords * GAS_CONSTANT * _temp;</a>
<a name="ln3479">    //cout &lt;&lt; &quot;E_{kin} = Ndf * R * T = &quot; &lt;&lt; E_kin &lt;&lt; endl;</a>
<a name="ln3480"> </a>
<a name="ln3481">    // E_kin = 0.5 * sum( m_i * v_i^2 )</a>
<a name="ln3482">    E_kin2 = 0.0;</a>
<a name="ln3483">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln3484">      velocityIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln3485"> </a>
<a name="ln3486">      velocity = sqrt( _velocityPtr[velocityIdx] * _velocityPtr[velocityIdx] +</a>
<a name="ln3487">                       _velocityPtr[velocityIdx+1] * _velocityPtr[velocityIdx+1] +</a>
<a name="ln3488">                       _velocityPtr[velocityIdx+2] * _velocityPtr[velocityIdx+2] );</a>
<a name="ln3489"> </a>
<a name="ln3490">      E_kin2 += 1000 * a-&gt;GetAtomicMass() * velocity * velocity;</a>
<a name="ln3491">    }</a>
<a name="ln3492">    //cout &lt;&lt; &quot;E_{kin} = sum( m_i * v_i^2 ) = &quot; &lt;&lt; E_kin2 &lt;&lt; endl;</a>
<a name="ln3493"> </a>
<a name="ln3494">    // correct</a>
<a name="ln3495">    factor = sqrt(E_kin / E_kin2);</a>
<a name="ln3496">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln3497">      velocityIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln3498">      _velocityPtr[velocityIdx] *= factor;</a>
<a name="ln3499">      _velocityPtr[velocityIdx+1] *= factor;</a>
<a name="ln3500">      _velocityPtr[velocityIdx+2] *= factor;</a>
<a name="ln3501">    }</a>
<a name="ln3502"> </a>
<a name="ln3503">    // E_kin = 0.5 * sum( m_i * v_i^2 )</a>
<a name="ln3504">    E_kin2 = 0.0;</a>
<a name="ln3505">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln3506">      velocityIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln3507"> </a>
<a name="ln3508">      velocity = sqrt( _velocityPtr[velocityIdx] * _velocityPtr[velocityIdx] +</a>
<a name="ln3509">                       _velocityPtr[velocityIdx+1] * _velocityPtr[velocityIdx+1] +</a>
<a name="ln3510">                       _velocityPtr[velocityIdx+2] * _velocityPtr[velocityIdx+2] );</a>
<a name="ln3511"> </a>
<a name="ln3512">      E_kin2 += 1000 * a-&gt;GetAtomicMass() * velocity * velocity;</a>
<a name="ln3513">    }</a>
<a name="ln3514">    //cout &lt;&lt; &quot;E_{kin_corr} = sum( m_i * v_i^2 ) = &quot; &lt;&lt; E_kin2 &lt;&lt; endl;</a>
<a name="ln3515">  }</a>
<a name="ln3516"> </a>
<a name="ln3517">  void OBForceField::MolecularDynamicsTakeNSteps(int n, double T, double timestep, int method)</a>
<a name="ln3518">  {</a>
<a name="ln3519">    if (!_validSetup)</a>
<a name="ln3520">      return;</a>
<a name="ln3521"> </a>
<a name="ln3522">    int coordIdx;</a>
<a name="ln3523">    double timestep2;</a>
<a name="ln3524">    vector3 force, pos, accel;</a>
<a name="ln3525">    _timestep = timestep;</a>
<a name="ln3526">    _temp = T;</a>
<a name="ln3527"> </a>
<a name="ln3528"> </a>
<a name="ln3529">    timestep2 = 0.5 * _timestep * _timestep;</a>
<a name="ln3530"> </a>
<a name="ln3531">    if (!_velocityPtr)</a>
<a name="ln3532">      GenerateVelocities();</a>
<a name="ln3533">    Energy(true); // compute gradients</a>
<a name="ln3534"> </a>
<a name="ln3535">    for (int i = 1; i &lt;= n; i++) {</a>
<a name="ln3536">      FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln3537">        if (!_constraints.IsFixed(a-&gt;GetIdx()) || (_fixAtom == a-&gt;GetIdx()) || (_ignoreAtom == a-&gt;GetIdx())) {</a>
<a name="ln3538">          if (HasAnalyticalGradients())</a>
<a name="ln3539">            force = GetGradient(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln3540">          else</a>
<a name="ln3541">            force = NumericalDerivative(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln3542"> </a>
<a name="ln3543">          pos = a-&gt;GetVector();</a>
<a name="ln3544">          coordIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln3545"> </a>
<a name="ln3546">          // a(i) = F(i) / m</a>
<a name="ln3547">          accel = force / (1000 * a-&gt;GetAtomicMass());</a>
<a name="ln3548"> </a>
<a name="ln3549">          // x(i+1) = x(i) + v(i) /\t + 0.5 a(i) /\t^2</a>
<a name="ln3550">          pos.SetX(pos.x() + _velocityPtr[coordIdx]   * _timestep + accel.x() * timestep2);</a>
<a name="ln3551">          pos.SetY(pos.y() + _velocityPtr[coordIdx+1] * _timestep + accel.y() * timestep2);</a>
<a name="ln3552">          pos.SetZ(pos.z() + _velocityPtr[coordIdx+2] * _timestep + accel.z() * timestep2);</a>
<a name="ln3553">          a-&gt;SetVector(pos);</a>
<a name="ln3554"> </a>
<a name="ln3555">          // v(i+.5) = v(i) + 0.5 a(i) /\t</a>
<a name="ln3556">          _velocityPtr[coordIdx]   += 0.5 * accel.x() * _timestep;</a>
<a name="ln3557">          _velocityPtr[coordIdx+1] += 0.5 * accel.y() * _timestep;</a>
<a name="ln3558">          _velocityPtr[coordIdx+2] += 0.5 * accel.z() * _timestep;</a>
<a name="ln3559"> </a>
<a name="ln3560">          Energy(true); // compute gradients</a>
<a name="ln3561"> </a>
<a name="ln3562">          if (HasAnalyticalGradients())</a>
<a name="ln3563">            force = GetGradient(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln3564">          else</a>
<a name="ln3565">            force = NumericalDerivative(&amp;*a) + _constraints.GetGradient(a-&gt;GetIdx());</a>
<a name="ln3566"> </a>
<a name="ln3567">          // a(i+1) = F(i+1) / m</a>
<a name="ln3568">          accel = force / (1000 * a-&gt;GetAtomicMass());</a>
<a name="ln3569"> </a>
<a name="ln3570">          _velocityPtr[coordIdx]   += 0.5 * accel.x() * _timestep;</a>
<a name="ln3571">          _velocityPtr[coordIdx+1] += 0.5 * accel.y() * _timestep;</a>
<a name="ln3572">          _velocityPtr[coordIdx+2] += 0.5 * accel.z() * _timestep;</a>
<a name="ln3573"> </a>
<a name="ln3574">        }</a>
<a name="ln3575">      }</a>
<a name="ln3576">      if (i % 10 == 0)</a>
<a name="ln3577">        CorrectVelocities();</a>
<a name="ln3578">    }</a>
<a name="ln3579">  }</a>
<a name="ln3580"> </a>
<a name="ln3581">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3582">  //</a>
<a name="ln3583">  // Vector analyse</a>
<a name="ln3584">  //</a>
<a name="ln3585">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3586"> </a>
<a name="ln3587">  double OBForceField::VectorLengthDerivative(vector3 &amp;a, vector3 &amp;b)</a>
<a name="ln3588">  {</a>
<a name="ln3589">    vector3 vab, drab;</a>
<a name="ln3590">    double rab;</a>
<a name="ln3591"> </a>
<a name="ln3592">    vab = a - b;</a>
<a name="ln3593">    rab = vab.length();</a>
<a name="ln3594">    if (rab &lt; 0.1) // atoms are too close to each other</a>
<a name="ln3595">      {</a>
<a name="ln3596">        vab.randomUnitVector();</a>
<a name="ln3597">        vab *= 0.1; // move the atoms a small, random distance apart</a>
<a name="ln3598">        rab = 0.1;</a>
<a name="ln3599">      }</a>
<a name="ln3600">    drab = vab / rab;</a>
<a name="ln3601"> </a>
<a name="ln3602">    a = -drab; // -drab/da</a>
<a name="ln3603">    b =  drab; // -drab/db</a>
<a name="ln3604"> </a>
<a name="ln3605">    return rab;</a>
<a name="ln3606">  }</a>
<a name="ln3607"> </a>
<a name="ln3608">  double OBForceField::VectorBondDerivative(double *pos_i, double *pos_j,</a>
<a name="ln3609">                                            double *force_i, double *force_j)</a>
<a name="ln3610">  {</a>
<a name="ln3611">    double ij[3];</a>
<a name="ln3612">    VectorSubtract(pos_i, pos_j, ij);</a>
<a name="ln3613"> </a>
<a name="ln3614">    double rij = VectorLength(ij);</a>
<a name="ln3615">    if (rij &lt; 0.1) { // atoms are too close to each other</a>
<a name="ln3616">      vector3 vij;</a>
<a name="ln3617">      vij.randomUnitVector();</a>
<a name="ln3618">      vij *= 0.1; // move the atoms a small, random distance apart</a>
<a name="ln3619">      vij.Get(ij);</a>
<a name="ln3620">      rij = 0.1;</a>
<a name="ln3621">    }</a>
<a name="ln3622">    VectorDivide(ij, rij, force_j);</a>
<a name="ln3623">    VectorMultiply(force_j, -1.0, force_i);</a>
<a name="ln3624"> </a>
<a name="ln3625">    return rij;</a>
<a name="ln3626">  }</a>
<a name="ln3627"> </a>
<a name="ln3628"> </a>
<a name="ln3629">  double OBForceField::VectorDistanceDerivative(const double* const pos_i, const double* const pos_j,</a>
<a name="ln3630">                                                double *force_i, double *force_j)</a>
<a name="ln3631">  {</a>
<a name="ln3632">    VectorSubtract(pos_i, pos_j, force_j);</a>
<a name="ln3633">    const double rij = VectorLength(force_j);</a>
<a name="ln3634">    const double inverse_rij = 1.0 / rij;</a>
<a name="ln3635">    VectorSelfMultiply(force_j, inverse_rij);</a>
<a name="ln3636">    VectorMultiply(force_j, -1.0, force_i);</a>
<a name="ln3637">    return rij;</a>
<a name="ln3638">  }</a>
<a name="ln3639"> </a>
<a name="ln3640">  double OBForceField::VectorAngleDerivative(vector3 &amp;i, vector3 &amp;j, vector3 &amp;k)</a>
<a name="ln3641">  {</a>
<a name="ln3642">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln3643">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln3644"> </a>
<a name="ln3645">    vector3 v1, v2;</a>
<a name="ln3646">    vector3 n1, n2;</a>
<a name="ln3647"> </a>
<a name="ln3648">    // Calculate the vector between atom1 and atom2,</a>
<a name="ln3649">    // test if the vector has length larger than 0 and normalize it</a>
<a name="ln3650">    v1 = i - j;</a>
<a name="ln3651">    v2 = k - j;</a>
<a name="ln3652"> </a>
<a name="ln3653">    double length1 = v1.length();</a>
<a name="ln3654">    double length2 = v2.length();</a>
<a name="ln3655"> </a>
<a name="ln3656">    // test if the vector has length larger than 0 and normalize it</a>
<a name="ln3657">    if (IsNearZero(length1) || IsNearZero(length2)) {</a>
<a name="ln3658">      i = VZero;</a>
<a name="ln3659">      j = VZero;</a>
<a name="ln3660">      k = VZero;</a>
<a name="ln3661">      return 0.0;</a>
<a name="ln3662">    }</a>
<a name="ln3663"> </a>
<a name="ln3664">    // Calculate the normalized bond vectors</a>
<a name="ln3665">    double inverse_length_v1 = 1.0 / length1;</a>
<a name="ln3666">    double inverse_length_v2 = 1.0 / length2;</a>
<a name="ln3667">    v1 *= inverse_length_v1 ;</a>
<a name="ln3668">    v2 *= inverse_length_v2;</a>
<a name="ln3669"> </a>
<a name="ln3670">    // Calculate the cross product of v1 and v2, test if it has length unequal 0,</a>
<a name="ln3671">    // and normalize it.</a>
<a name="ln3672">    vector3 c1 = cross(v1, v2);</a>
<a name="ln3673">    double length = c1.length();</a>
<a name="ln3674">    if (IsNearZero(length)) {</a>
<a name="ln3675">      i = VZero;</a>
<a name="ln3676">      j = VZero;</a>
<a name="ln3677">      k = VZero;</a>
<a name="ln3678">      return 0.0;</a>
<a name="ln3679">    }</a>
<a name="ln3680"> </a>
<a name="ln3681">    c1 /= length;</a>
<a name="ln3682"> </a>
<a name="ln3683">    // Calculate the cos of theta and then theta</a>
<a name="ln3684">    double costheta = dot(v1, v2);</a>
<a name="ln3685">    double theta;</a>
<a name="ln3686">    if (costheta &gt; 1.0) {</a>
<a name="ln3687">      theta = 0.0;</a>
<a name="ln3688">      costheta = 1.0;</a>
<a name="ln3689">    } else if (costheta &lt; -1.0) {</a>
<a name="ln3690">      theta = 180.0;</a>
<a name="ln3691">      costheta = -1.0;</a>
<a name="ln3692">    } else {</a>
<a name="ln3693">      theta = RAD_TO_DEG * acos(costheta);</a>
<a name="ln3694">    }</a>
<a name="ln3695"> </a>
<a name="ln3696">    vector3 t1 = cross(v1, c1);</a>
<a name="ln3697">    t1.normalize();</a>
<a name="ln3698">    vector3 t2 = cross(v2, c1);</a>
<a name="ln3699">    t2.normalize();</a>
<a name="ln3700"> </a>
<a name="ln3701">    i = -t1 * inverse_length_v1;</a>
<a name="ln3702">    k =  t2 * inverse_length_v2;</a>
<a name="ln3703">    j = - (i + k);</a>
<a name="ln3704"> </a>
<a name="ln3705">    return theta;</a>
<a name="ln3706">  }</a>
<a name="ln3707"> </a>
<a name="ln3708">  double OBForceField::VectorAngleDerivative(double *pos_i, double *pos_j, double *pos_k,</a>
<a name="ln3709">                                             double *force_i, double *force_j, double *force_k)</a>
<a name="ln3710">  {</a>
<a name="ln3711">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln3712">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln3713"> </a>
<a name="ln3714">    // Bond vectors of the three atoms</a>
<a name="ln3715">    double ij[3], jk[3];</a>
<a name="ln3716">    VectorSubtract(pos_i, pos_j, ij);</a>
<a name="ln3717">    VectorSubtract(pos_k, pos_j, jk);</a>
<a name="ln3718"> </a>
<a name="ln3719">    // length of the two bonds</a>
<a name="ln3720">    double l_ij, l_jk;</a>
<a name="ln3721">    l_ij = VectorLength(ij);</a>
<a name="ln3722">    l_jk = VectorLength(jk);</a>
<a name="ln3723"> </a>
<a name="ln3724">    if (IsNearZero(l_ij) || IsNearZero(l_jk)) {</a>
<a name="ln3725">      VectorClear(force_i);</a>
<a name="ln3726">      VectorClear(force_j);</a>
<a name="ln3727">      VectorClear(force_k);</a>
<a name="ln3728">      return 0.0;</a>
<a name="ln3729">    }</a>
<a name="ln3730"> </a>
<a name="ln3731">    // normalize the bond vectors:</a>
<a name="ln3732">    VectorDivide (ij, l_ij, ij);</a>
<a name="ln3733">    VectorDivide (jk, l_jk, jk);</a>
<a name="ln3734"> </a>
<a name="ln3735">    // Calculate the cross product of v1 and v2, test if it has length unequal 0,</a>
<a name="ln3736">    // and normalize it.</a>
<a name="ln3737">    double c1[3];</a>
<a name="ln3738">    VectorCross(ij, jk, c1);</a>
<a name="ln3739">    double length = VectorLength(c1);</a>
<a name="ln3740">    if (IsNearZero(length)) {</a>
<a name="ln3741">      VectorClear(force_i);</a>
<a name="ln3742">      VectorClear(force_j);</a>
<a name="ln3743">      VectorClear(force_k);</a>
<a name="ln3744">      return 0.0;</a>
<a name="ln3745">    }</a>
<a name="ln3746"> </a>
<a name="ln3747">    VectorDivide(c1, length, c1);</a>
<a name="ln3748"> </a>
<a name="ln3749">    // Calculate the cos of theta and then theta</a>
<a name="ln3750">    double cos_ijk = VectorDot(ij, jk);</a>
<a name="ln3751">    double angle_ijk;</a>
<a name="ln3752">    if (cos_ijk &gt; 1.0) {</a>
<a name="ln3753">      angle_ijk = 0.0;</a>
<a name="ln3754">      cos_ijk = 1.0;</a>
<a name="ln3755">    } else if (cos_ijk &lt; -1.0) {</a>
<a name="ln3756">      angle_ijk = 180.0;</a>
<a name="ln3757">      cos_ijk = -1.0;</a>
<a name="ln3758">    } else {</a>
<a name="ln3759">      angle_ijk = RAD_TO_DEG * acos(cos_ijk);</a>
<a name="ln3760">    }</a>
<a name="ln3761"> </a>
<a name="ln3762">    double t1[3], t2[3];</a>
<a name="ln3763"> </a>
<a name="ln3764">    VectorCross(ij, c1, t1);</a>
<a name="ln3765">    VectorNormalize(t1);</a>
<a name="ln3766"> </a>
<a name="ln3767">    VectorCross(jk, c1, t2);</a>
<a name="ln3768">    VectorNormalize(t2);</a>
<a name="ln3769"> </a>
<a name="ln3770">    VectorDivide(t1, -l_ij, force_i);</a>
<a name="ln3771">    VectorDivide(t2,  l_jk, force_k);</a>
<a name="ln3772"> </a>
<a name="ln3773">    VectorAdd(force_i, force_k, force_j);</a>
<a name="ln3774">    VectorSelfMultiply(force_j, -1.0);</a>
<a name="ln3775"> </a>
<a name="ln3776">    return angle_ijk;</a>
<a name="ln3777">  }</a>
<a name="ln3778"> </a>
<a name="ln3779">  double OBForceField::VectorAngle(double *pos_i, double *pos_j, double *pos_k)</a>
<a name="ln3780">  {</a>
<a name="ln3781">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln3782">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln3783"> </a>
<a name="ln3784">    // Bond vectors of the three atoms</a>
<a name="ln3785">    double ij[3], jk[3];</a>
<a name="ln3786">    VectorSubtract(pos_i, pos_j, ij);</a>
<a name="ln3787">    VectorSubtract(pos_k, pos_j, jk);</a>
<a name="ln3788"> </a>
<a name="ln3789">    // length of the two bonds</a>
<a name="ln3790">    double l_ij, l_jk;</a>
<a name="ln3791">    l_ij = VectorLength(ij);</a>
<a name="ln3792">    l_jk = VectorLength(jk);</a>
<a name="ln3793"> </a>
<a name="ln3794">    if (IsNearZero(l_ij) || IsNearZero(l_jk)) {</a>
<a name="ln3795">      return 0.0;</a>
<a name="ln3796">    }</a>
<a name="ln3797"> </a>
<a name="ln3798">    // normalize the bond vectors:</a>
<a name="ln3799">    VectorDivide (ij, l_ij, ij);</a>
<a name="ln3800">    VectorDivide (jk, l_jk, jk);</a>
<a name="ln3801"> </a>
<a name="ln3802">    // Calculate the cross product of v1 and v2, test if it has length unequal 0,</a>
<a name="ln3803">    // and normalize it.</a>
<a name="ln3804">    double c1[3];</a>
<a name="ln3805">    VectorCross(ij, jk, c1);</a>
<a name="ln3806">    double length = VectorLength(c1);</a>
<a name="ln3807">    if (IsNearZero(length)) {</a>
<a name="ln3808">      return 0.0;</a>
<a name="ln3809">    }</a>
<a name="ln3810"> </a>
<a name="ln3811">    // Calculate the cos of theta and then theta</a>
<a name="ln3812">    double cos_ijk = VectorDot(ij, jk);</a>
<a name="ln3813">    double angle_ijk;</a>
<a name="ln3814">    if (cos_ijk &gt; 1.0) {</a>
<a name="ln3815">      angle_ijk = 0.0;</a>
<a name="ln3816">      cos_ijk = 1.0;</a>
<a name="ln3817">    } else if (cos_ijk &lt; -1.0) {</a>
<a name="ln3818">      angle_ijk = 180.0;</a>
<a name="ln3819">      cos_ijk = -1.0;</a>
<a name="ln3820">    } else {</a>
<a name="ln3821">      angle_ijk = RAD_TO_DEG * acos(cos_ijk);</a>
<a name="ln3822">    }</a>
<a name="ln3823"> </a>
<a name="ln3824">    return angle_ijk;</a>
<a name="ln3825">  }</a>
<a name="ln3826"> </a>
<a name="ln3827">  double OBForceField::VectorOOPDerivative(vector3 &amp;i, vector3 &amp;j, vector3 &amp;k, vector3 &amp;l)</a>
<a name="ln3828">  {</a>
<a name="ln3829">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln3830">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln3831"> </a>
<a name="ln3832">    // temp variables:</a>
<a name="ln3833">    double length;</a>
<a name="ln3834">    vector3 delta;</a>
<a name="ln3835"> </a>
<a name="ln3836">    // normal vectors of the three planes:</a>
<a name="ln3837">    vector3 an, bn, cn;</a>
<a name="ln3838"> </a>
<a name="ln3839">    // calculate normalized bond vectors from central atom to outer atoms:</a>
<a name="ln3840">    delta = i - j;</a>
<a name="ln3841">    length = delta.length();</a>
<a name="ln3842">    if (IsNearZero(length)) {</a>
<a name="ln3843">      i = VZero;</a>
<a name="ln3844">      j = VZero;</a>
<a name="ln3845">      k = VZero;</a>
<a name="ln3846">      l = VZero;</a>
<a name="ln3847">      return 0.0;</a>
<a name="ln3848">    }</a>
<a name="ln3849">    // normalize the bond vector:</a>
<a name="ln3850">    delta /= length;</a>
<a name="ln3851">    // store the normalized bond vector from central atom to outer atoms:</a>
<a name="ln3852">    const vector3 ji = delta;</a>
<a name="ln3853">    // store length of this bond:</a>
<a name="ln3854">    const double length_ji = length;</a>
<a name="ln3855"> </a>
<a name="ln3856">    delta = k - j;</a>
<a name="ln3857">    length = delta.length();</a>
<a name="ln3858">    if (IsNearZero(length)) {</a>
<a name="ln3859">      i = VZero;</a>
<a name="ln3860">      j = VZero;</a>
<a name="ln3861">      k = VZero;</a>
<a name="ln3862">      l = VZero;</a>
<a name="ln3863">      return 0.0;</a>
<a name="ln3864">    }</a>
<a name="ln3865">    // normalize the bond vector:</a>
<a name="ln3866">    delta /= length;</a>
<a name="ln3867">    // store the normalized bond vector from central atom to outer atoms:</a>
<a name="ln3868">    const vector3 jk = delta;</a>
<a name="ln3869">    // store length of this bond:</a>
<a name="ln3870">    const double length_jk = length;</a>
<a name="ln3871"> </a>
<a name="ln3872">    delta = l - j;</a>
<a name="ln3873">    length = delta.length();</a>
<a name="ln3874">    if (IsNearZero(length)) {</a>
<a name="ln3875">      i = VZero;</a>
<a name="ln3876">      j = VZero;</a>
<a name="ln3877">      k = VZero;</a>
<a name="ln3878">      l = VZero;</a>
<a name="ln3879">      return 0.0;</a>
<a name="ln3880">    }</a>
<a name="ln3881">    // normalize the bond vector:</a>
<a name="ln3882">    delta /= length;</a>
<a name="ln3883">    // store the normalized bond vector from central atom to outer atoms:</a>
<a name="ln3884">    const vector3 jl = delta;</a>
<a name="ln3885">    // store length of this bond:</a>
<a name="ln3886">    const double length_jl = length;</a>
<a name="ln3887"> </a>
<a name="ln3888">    // the normal vectors of the three planes:</a>
<a name="ln3889">    an = cross(ji, jk);</a>
<a name="ln3890">    bn = cross(jk, jl);</a>
<a name="ln3891">    cn = cross(jl, ji);</a>
<a name="ln3892"> </a>
<a name="ln3893">    // Bond angle ji to jk</a>
<a name="ln3894">    const double cos_theta = dot(ji, jk);</a>
<a name="ln3895">    const double theta = acos(cos_theta);</a>
<a name="ln3896">    // If theta equals 180 degree or 0 degree</a>
<a name="ln3897">    if (IsNearZero(theta) || IsNearZero(fabs(theta - M_PI))) {</a>
<a name="ln3898">      i = VZero;</a>
<a name="ln3899">      j = VZero;</a>
<a name="ln3900">      k = VZero;</a>
<a name="ln3901">      l = VZero;</a>
<a name="ln3902">      return 0.0;</a>
<a name="ln3903">    }</a>
<a name="ln3904"> </a>
<a name="ln3905">    const double sin_theta = sin(theta);</a>
<a name="ln3906">    const double sin_dl = dot(an, jl) / sin_theta;</a>
<a name="ln3907"> </a>
<a name="ln3908">    // the wilson angle:</a>
<a name="ln3909">    const double dl = asin(sin_dl);</a>
<a name="ln3910"> </a>
<a name="ln3911">    // In case: wilson angle equals 0 or 180 degree: do nothing</a>
<a name="ln3912">    if (IsNearZero(dl) || IsNearZero(fabs(dl - M_PI))) {</a>
<a name="ln3913">      i = VZero;</a>
<a name="ln3914">      j = VZero;</a>
<a name="ln3915">      k = VZero;</a>
<a name="ln3916">      l = VZero;</a>
<a name="ln3917">      return RAD_TO_DEG * dl;</a>
<a name="ln3918">    }</a>
<a name="ln3919"> </a>
<a name="ln3920">    const double cos_dl = cos(dl);</a>
<a name="ln3921"> </a>
<a name="ln3922">    // if wilson angle equal 90 degree: abort</a>
<a name="ln3923">    if (cos_dl &lt; 0.0001) {</a>
<a name="ln3924">      i = VZero;</a>
<a name="ln3925">      j = VZero;</a>
<a name="ln3926">      k = VZero;</a>
<a name="ln3927">      l = VZero;</a>
<a name="ln3928">      return RAD_TO_DEG * dl;</a>
<a name="ln3929">    }</a>
<a name="ln3930"> </a>
<a name="ln3931">    l = (an / sin_theta - jl * sin_dl) / length_jl;</a>
<a name="ln3932">    i = ((bn + (((-ji + jk * cos_theta) * sin_dl) / sin_theta)) / length_ji) / sin_theta;</a>
<a name="ln3933">    k = ((cn + (((-jk + ji * cos_theta) * sin_dl) / sin_theta)) / length_jk) / sin_theta;</a>
<a name="ln3934">    j = -(i + k + l);</a>
<a name="ln3935"> </a>
<a name="ln3936">    return RAD_TO_DEG * dl;</a>
<a name="ln3937">  }</a>
<a name="ln3938"> </a>
<a name="ln3939">  double OBForceField::VectorOOPDerivative(double *pos_i, double *pos_j, double *pos_k, double *pos_l,</a>
<a name="ln3940">                                           double *force_i, double *force_j, double *force_k, double *force_l)</a>
<a name="ln3941">  {</a>
<a name="ln3942">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln3943">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln3944"> </a>
<a name="ln3945">    // vector lengths of the three bonds:</a>
<a name="ln3946">    double ji[3], jk[3], jl[3];</a>
<a name="ln3947">    // normal vectors of the three planes:</a>
<a name="ln3948">    double an[3], bn[3], cn[3];</a>
<a name="ln3949"> </a>
<a name="ln3950">    // calculate normalized bond vectors from central atom to outer atoms:</a>
<a name="ln3951">    VectorSubtract(pos_i, pos_j, ji);</a>
<a name="ln3952">    // store length of this bond:</a>
<a name="ln3953">    const double length_ji = VectorLength(ji);</a>
<a name="ln3954">    if (IsNearZero(length_ji)) {</a>
<a name="ln3955">      VectorClear(force_i);</a>
<a name="ln3956">      VectorClear(force_j);</a>
<a name="ln3957">      VectorClear(force_k);</a>
<a name="ln3958">      VectorClear(force_l);</a>
<a name="ln3959">      return 0.0;</a>
<a name="ln3960">    }</a>
<a name="ln3961">    // store the normalized bond vector from central atom to outer atoms:</a>
<a name="ln3962">    // normalize the bond vector:</a>
<a name="ln3963">    VectorDivide(ji, length_ji, ji);</a>
<a name="ln3964"> </a>
<a name="ln3965">    VectorSubtract(pos_k, pos_j, jk);</a>
<a name="ln3966">    const double length_jk = VectorLength(jk);</a>
<a name="ln3967">    if (IsNearZero(length_jk)) {</a>
<a name="ln3968">      VectorClear(force_i);</a>
<a name="ln3969">      VectorClear(force_j);</a>
<a name="ln3970">      VectorClear(force_k);</a>
<a name="ln3971">      VectorClear(force_l);</a>
<a name="ln3972">      return 0.0;</a>
<a name="ln3973">    }</a>
<a name="ln3974">    VectorDivide(jk, length_jk, jk);</a>
<a name="ln3975"> </a>
<a name="ln3976">    VectorSubtract(pos_l, pos_j, jl);</a>
<a name="ln3977">    const double length_jl = VectorLength(jl);</a>
<a name="ln3978">    if (IsNearZero(length_jl)) {</a>
<a name="ln3979">      VectorClear(force_i);</a>
<a name="ln3980">      VectorClear(force_j);</a>
<a name="ln3981">      VectorClear(force_k);</a>
<a name="ln3982">      VectorClear(force_l);</a>
<a name="ln3983">      return 0.0;</a>
<a name="ln3984">    }</a>
<a name="ln3985">    VectorDivide(jl, length_jl, jl);</a>
<a name="ln3986"> </a>
<a name="ln3987">    // the normal vectors of the three planes:</a>
<a name="ln3988">    VectorCross(ji, jk, an);</a>
<a name="ln3989">    VectorCross(jk, jl, bn);</a>
<a name="ln3990">    VectorCross(jl, ji, cn);</a>
<a name="ln3991"> </a>
<a name="ln3992">    // Bond angle ji to jk</a>
<a name="ln3993">    const double cos_theta = VectorDot(ji, jk);</a>
<a name="ln3994">    const double theta = acos(cos_theta);</a>
<a name="ln3995">    // If theta equals 180 degree or 0 degree</a>
<a name="ln3996">    if (IsNearZero(theta) || IsNearZero(fabs(theta - M_PI))) {</a>
<a name="ln3997">      VectorClear(force_i);</a>
<a name="ln3998">      VectorClear(force_j);</a>
<a name="ln3999">      VectorClear(force_k);</a>
<a name="ln4000">      VectorClear(force_l);</a>
<a name="ln4001">      return 0.0;</a>
<a name="ln4002">    }</a>
<a name="ln4003"> </a>
<a name="ln4004">    const double sin_theta = sin(theta);</a>
<a name="ln4005">    const double sin_dl = VectorDot(an, jl) / sin_theta;</a>
<a name="ln4006"> </a>
<a name="ln4007">    // the wilson angle:</a>
<a name="ln4008">    const double dl = asin(sin_dl);</a>
<a name="ln4009"> </a>
<a name="ln4010">    // In case: wilson angle equals 0 or 180 degree: do nothing</a>
<a name="ln4011">    if (IsNearZero(dl) || IsNearZero(fabs(dl - M_PI))) {</a>
<a name="ln4012">      VectorClear(force_i);</a>
<a name="ln4013">      VectorClear(force_j);</a>
<a name="ln4014">      VectorClear(force_k);</a>
<a name="ln4015">      VectorClear(force_l);</a>
<a name="ln4016">      return RAD_TO_DEG * dl;</a>
<a name="ln4017">    }</a>
<a name="ln4018"> </a>
<a name="ln4019">    const double cos_dl = cos(dl);</a>
<a name="ln4020"> </a>
<a name="ln4021">    // if wilson angle equal 90 degree: abort</a>
<a name="ln4022">    if (cos_dl &lt; 0.0001) {</a>
<a name="ln4023">      VectorClear(force_i);</a>
<a name="ln4024">      VectorClear(force_j);</a>
<a name="ln4025">      VectorClear(force_k);</a>
<a name="ln4026">      VectorClear(force_l);</a>
<a name="ln4027">      return RAD_TO_DEG * dl;</a>
<a name="ln4028">    }</a>
<a name="ln4029"> </a>
<a name="ln4030">    double temp[3];</a>
<a name="ln4031">    /* l = (an / sin_theta - jl * sin_dl) / length_jl; */</a>
<a name="ln4032">    VectorDivide(an, sin_theta, an);</a>
<a name="ln4033">    VectorMultiply(jl, sin_dl, temp);</a>
<a name="ln4034">    VectorSubtract(an, temp, force_l);</a>
<a name="ln4035">    VectorDivide(force_l, length_jl, force_l);</a>
<a name="ln4036">    /* i = ((bn + (((-ji + jk * cos_theta) * sin_dl) / sin_theta)) / length_ji) / sin_theta; */</a>
<a name="ln4037">    VectorMultiply(jk, cos_theta, temp);</a>
<a name="ln4038">    VectorSubtract(temp, ji, temp);</a>
<a name="ln4039">    VectorSelfMultiply(temp, sin_dl);</a>
<a name="ln4040">    VectorDivide(temp, sin_theta, temp);</a>
<a name="ln4041">    VectorAdd(bn, temp, force_i);</a>
<a name="ln4042">    VectorSelfMultiply(force_i, (sin_theta/length_ji));</a>
<a name="ln4043">    /* k = ((cn + (((-jk + ji * cos_theta) * sin_dl) / sin_theta)) / length_jk) / sin_theta; */</a>
<a name="ln4044">    VectorMultiply(ji, cos_theta, temp);</a>
<a name="ln4045">    VectorSubtract(temp, jk, temp);</a>
<a name="ln4046">    VectorSelfMultiply(temp, sin_dl);</a>
<a name="ln4047">    VectorDivide(temp, sin_theta, temp);</a>
<a name="ln4048">    VectorAdd(cn, temp, force_k);</a>
<a name="ln4049">    VectorSelfMultiply(force_k, (sin_theta/length_jk));</a>
<a name="ln4050">    /* j = -(i + k + l); */</a>
<a name="ln4051">    VectorAdd(force_i, force_k, temp);</a>
<a name="ln4052">    VectorAdd(force_l, temp, temp);</a>
<a name="ln4053">    VectorMultiply(temp, -1.0, force_j);</a>
<a name="ln4054"> </a>
<a name="ln4055">    return RAD_TO_DEG * dl;</a>
<a name="ln4056">  }</a>
<a name="ln4057"> </a>
<a name="ln4058">  double OBForceField::VectorOOP(double *pos_i, double *pos_j, double *pos_k, double *pos_l)</a>
<a name="ln4059">  {</a>
<a name="ln4060">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln4061">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln4062"> </a>
<a name="ln4063">    // vector lengths of the three bonds:</a>
<a name="ln4064">    double ji[3], jk[3], jl[3];</a>
<a name="ln4065">    // normal vectors of the three planes:</a>
<a name="ln4066">    double an[3], bn[3], cn[3];</a>
<a name="ln4067"> </a>
<a name="ln4068">    // calculate normalized bond vectors from central atom to outer atoms:</a>
<a name="ln4069">    VectorSubtract(pos_i, pos_j, ji);</a>
<a name="ln4070">    // store length of this bond:</a>
<a name="ln4071">    const double length_ji = VectorLength(ji);</a>
<a name="ln4072">    if (IsNearZero(length_ji)) {</a>
<a name="ln4073">      return 0.0;</a>
<a name="ln4074">    }</a>
<a name="ln4075">    // store the normalized bond vector from central atom to outer atoms:</a>
<a name="ln4076">    // normalize the bond vector:</a>
<a name="ln4077">    VectorDivide(ji, length_ji, ji);</a>
<a name="ln4078"> </a>
<a name="ln4079">    VectorSubtract(pos_k, pos_j, jk);</a>
<a name="ln4080">    const double length_jk = VectorLength(jk);</a>
<a name="ln4081">    if (IsNearZero(length_jk)) {</a>
<a name="ln4082">      return 0.0;</a>
<a name="ln4083">    }</a>
<a name="ln4084">    VectorDivide(jk, length_jk, jk);</a>
<a name="ln4085"> </a>
<a name="ln4086">    VectorSubtract(pos_l, pos_j, jl);</a>
<a name="ln4087">    const double length_jl = VectorLength(jl);</a>
<a name="ln4088">    if (IsNearZero(length_jl)) {</a>
<a name="ln4089">      return 0.0;</a>
<a name="ln4090">    }</a>
<a name="ln4091">    VectorDivide(jl, length_jl, jl);</a>
<a name="ln4092"> </a>
<a name="ln4093">    // the normal vectors of the three planes:</a>
<a name="ln4094">    VectorCross(ji, jk, an);</a>
<a name="ln4095">    VectorCross(jk, jl, bn);</a>
<a name="ln4096">    VectorCross(jl, ji, cn);</a>
<a name="ln4097"> </a>
<a name="ln4098">    // Bond angle ji to jk</a>
<a name="ln4099">    const double cos_theta = VectorDot(ji, jk);</a>
<a name="ln4100">    const double theta = acos(cos_theta);</a>
<a name="ln4101">    // If theta equals 180 degree or 0 degree</a>
<a name="ln4102">    if (IsNearZero(theta) || IsNearZero(fabs(theta - M_PI))) {</a>
<a name="ln4103">      return 0.0;</a>
<a name="ln4104">    }</a>
<a name="ln4105"> </a>
<a name="ln4106">    const double sin_theta = sin(theta);</a>
<a name="ln4107">    const double sin_dl = VectorDot(an, jl) / sin_theta;</a>
<a name="ln4108"> </a>
<a name="ln4109">    // the wilson angle:</a>
<a name="ln4110">    const double dl = asin(sin_dl);</a>
<a name="ln4111"> </a>
<a name="ln4112">    return RAD_TO_DEG * dl;</a>
<a name="ln4113">  }</a>
<a name="ln4114"> </a>
<a name="ln4115">  double OBForceField::VectorTorsionDerivative(vector3 &amp;i, vector3 &amp;j, vector3 &amp;k, vector3 &amp;l)</a>
<a name="ln4116">  {</a>
<a name="ln4117">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln4118">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln4119"> </a>
<a name="ln4120">    // Bond vectors of the three atoms</a>
<a name="ln4121">    vector3 ij, jk, kl;</a>
<a name="ln4122">    // length of the three bonds</a>
<a name="ln4123">    double l_ij, l_jk, l_kl;</a>
<a name="ln4124">    // angle between ijk and jkl:</a>
<a name="ln4125">    double angle_ijk, angle_jkl;</a>
<a name="ln4126"> </a>
<a name="ln4127">    ij = j - i;</a>
<a name="ln4128">    jk = k - j;</a>
<a name="ln4129">    kl = l - k;</a>
<a name="ln4130"> </a>
<a name="ln4131">    l_ij = ij.length();</a>
<a name="ln4132">    l_jk = jk.length();</a>
<a name="ln4133">    l_kl = kl.length();</a>
<a name="ln4134"> </a>
<a name="ln4135">    if (IsNearZero(l_ij) || IsNearZero(l_jk) || IsNearZero(l_kl) ) {</a>
<a name="ln4136">      i = VZero;</a>
<a name="ln4137">      j = VZero;</a>
<a name="ln4138">      k = VZero;</a>
<a name="ln4139">      l = VZero;</a>
<a name="ln4140">      return 0.0;</a>
<a name="ln4141">    }</a>
<a name="ln4142"> </a>
<a name="ln4143">    angle_ijk = DEG_TO_RAD * vectorAngle(ij, jk);</a>
<a name="ln4144">    angle_jkl = DEG_TO_RAD * vectorAngle(jk, kl);</a>
<a name="ln4145"> </a>
<a name="ln4146">    // normalize the bond vectors:</a>
<a name="ln4147">    ij /= l_ij;</a>
<a name="ln4148">    jk /= l_jk;</a>
<a name="ln4149">    kl /= l_kl;</a>
<a name="ln4150"> </a>
<a name="ln4151">    double sin_j = sin(angle_ijk);</a>
<a name="ln4152">    double sin_k = sin(angle_jkl);</a>
<a name="ln4153"> </a>
<a name="ln4154">    double rsj = l_ij * sin_j;</a>
<a name="ln4155">    double rsk = l_kl * sin_k;</a>
<a name="ln4156"> </a>
<a name="ln4157">    double rs2j = 1. / (rsj * sin_j);</a>
<a name="ln4158">    double rs2k = 1. / (rsk * sin_k);</a>
<a name="ln4159"> </a>
<a name="ln4160">    double rrj = l_ij / l_jk;</a>
<a name="ln4161">    double rrk = l_kl / l_jk;</a>
<a name="ln4162"> </a>
<a name="ln4163">    double rrcj = rrj * (-cos(angle_ijk));</a>
<a name="ln4164">    double rrck = rrk * (-cos(angle_jkl));</a>
<a name="ln4165"> </a>
<a name="ln4166">    vector3 a = cross(ij, jk);</a>
<a name="ln4167">    vector3 b = cross(jk, kl);</a>
<a name="ln4168">    vector3 c = cross(a, b);</a>
<a name="ln4169">    double d1 = dot(c, jk);</a>
<a name="ln4170">    double d2 = dot(a, b);</a>
<a name="ln4171">    double tor = RAD_TO_DEG * atan2(d1, d2);</a>
<a name="ln4172"> </a>
<a name="ln4173">    i = -a * rs2j;</a>
<a name="ln4174">    l = b * rs2k;</a>
<a name="ln4175"> </a>
<a name="ln4176">    j = i * (rrcj - 1.) - l * rrck;</a>
<a name="ln4177">    k = -(i + j + l);</a>
<a name="ln4178"> </a>
<a name="ln4179">    return tor;</a>
<a name="ln4180">  }</a>
<a name="ln4181"> </a>
<a name="ln4182">  double OBForceField::VectorTorsionDerivative(double *pos_i, double *pos_j, double *pos_k, double *pos_l,</a>
<a name="ln4183">                                               double *force_i, double *force_j, double *force_k, double *force_l)</a>
<a name="ln4184">  {</a>
<a name="ln4185">    // This is adapted from http://scidok.sulb.uni-saarland.de/volltexte/2007/1325/pdf/Dissertation_1544_Moll_Andr_2007.pdf</a>
<a name="ln4186">    // Many thanks to Andreas Moll and the BALLView developers for this</a>
<a name="ln4187"> </a>
<a name="ln4188">    // Bond vectors of the three atoms</a>
<a name="ln4189">    double ij[3], jk[3], kl[3];</a>
<a name="ln4190">    VectorSubtract(pos_j, pos_i, ij);</a>
<a name="ln4191">    VectorSubtract(pos_k, pos_j, jk);</a>
<a name="ln4192">    VectorSubtract(pos_l, pos_k, kl);</a>
<a name="ln4193"> </a>
<a name="ln4194">    // length of the three bonds</a>
<a name="ln4195">    double l_ij, l_jk, l_kl;</a>
<a name="ln4196">    l_ij = VectorLength(ij);</a>
<a name="ln4197">    l_jk = VectorLength(jk);</a>
<a name="ln4198">    l_kl = VectorLength(kl);</a>
<a name="ln4199"> </a>
<a name="ln4200">    if (IsNearZero(l_ij) || IsNearZero(l_jk) || IsNearZero(l_kl) ) {</a>
<a name="ln4201">      VectorClear(force_i);</a>
<a name="ln4202">      VectorClear(force_j);</a>
<a name="ln4203">      VectorClear(force_k);</a>
<a name="ln4204">      VectorClear(force_l);</a>
<a name="ln4205">      return 0.0;</a>
<a name="ln4206">    }</a>
<a name="ln4207"> </a>
<a name="ln4208">    // normalize the bond vectors:</a>
<a name="ln4209">    VectorDivide (ij, l_ij, ij);</a>
<a name="ln4210">    VectorDivide (jk, l_jk, jk);</a>
<a name="ln4211">    VectorDivide (kl, l_kl, kl);</a>
<a name="ln4212"> </a>
<a name="ln4213">    // angle between ijk and jkl:</a>
<a name="ln4214">    double angle_ijk, angle_jkl;</a>
<a name="ln4215"> </a>
<a name="ln4216">    double cos_ijk = VectorDot(ij, jk);</a>
<a name="ln4217">    if (cos_ijk &gt; 1.0) {</a>
<a name="ln4218">      angle_ijk = 0.0;</a>
<a name="ln4219">      cos_ijk = 1.0;</a>
<a name="ln4220">    } else if (cos_ijk &lt; -1.0) {</a>
<a name="ln4221">      angle_ijk = M_PI;</a>
<a name="ln4222">      cos_ijk = -1.0;</a>
<a name="ln4223">    } else {</a>
<a name="ln4224">      angle_ijk = acos(cos_ijk);</a>
<a name="ln4225">    }</a>
<a name="ln4226"> </a>
<a name="ln4227">    double cos_jkl = VectorDot(jk, kl);</a>
<a name="ln4228">    if (cos_jkl &gt; 1.0) {</a>
<a name="ln4229">      angle_jkl = 0.0;</a>
<a name="ln4230">      cos_jkl = 1.0;</a>
<a name="ln4231">    } else if (cos_jkl &lt; -1.0) {</a>
<a name="ln4232">      angle_jkl = M_PI;</a>
<a name="ln4233">      cos_jkl = -1.0;</a>
<a name="ln4234">    } else {</a>
<a name="ln4235">      angle_jkl = acos(cos_jkl);</a>
<a name="ln4236">    }</a>
<a name="ln4237"> </a>
<a name="ln4238">    double sin_j = sin(angle_ijk);</a>
<a name="ln4239">    double sin_k = sin(angle_jkl);</a>
<a name="ln4240"> </a>
<a name="ln4241">    double rsj = l_ij * sin_j;</a>
<a name="ln4242">    double rsk = l_kl * sin_k;</a>
<a name="ln4243"> </a>
<a name="ln4244">    double rs2j = 1. / (rsj * sin_j);</a>
<a name="ln4245">    double rs2k = 1. / (rsk * sin_k);</a>
<a name="ln4246"> </a>
<a name="ln4247">    double rrj = l_ij / l_jk;</a>
<a name="ln4248">    double rrk = l_kl / l_jk;</a>
<a name="ln4249"> </a>
<a name="ln4250">    double rrcj = rrj * (-cos(angle_ijk));</a>
<a name="ln4251">    double rrck = rrk * (-cos(angle_jkl));</a>
<a name="ln4252"> </a>
<a name="ln4253">    double a[3];</a>
<a name="ln4254">    VectorCross(ij, jk, a);</a>
<a name="ln4255">    double b[3];</a>
<a name="ln4256">    VectorCross(jk, kl, b);</a>
<a name="ln4257">    double c[3];</a>
<a name="ln4258">    VectorCross(a, b, c);</a>
<a name="ln4259">    double d1 = VectorDot(c, jk);</a>
<a name="ln4260">    double d2 = VectorDot(a, b);</a>
<a name="ln4261">    double tor = RAD_TO_DEG * atan2(d1, d2);</a>
<a name="ln4262"> </a>
<a name="ln4263">    VectorMultiply(a, -rs2j, force_i);</a>
<a name="ln4264">    VectorMultiply(b, rs2k, force_l);</a>
<a name="ln4265"> </a>
<a name="ln4266">    VectorMultiply(force_i, (rrcj - 1.0), a);</a>
<a name="ln4267">    VectorMultiply(force_l, rrck, b);</a>
<a name="ln4268">    VectorSubtract(a, b, force_j);</a>
<a name="ln4269"> </a>
<a name="ln4270">    VectorAdd(force_i, force_j, a);</a>
<a name="ln4271">    VectorAdd(a, force_l, b);</a>
<a name="ln4272">    VectorMultiply(b, -1.0, force_k);</a>
<a name="ln4273"> </a>
<a name="ln4274">    return tor;</a>
<a name="ln4275">  }</a>
<a name="ln4276"> </a>
<a name="ln4277">  double OBForceField::VectorTorsion(double *pos_i, double *pos_j, double *pos_k, double *pos_l)</a>
<a name="ln4278">  {</a>
<a name="ln4279">    // Bond vectors of the three atoms</a>
<a name="ln4280">    double ij[3], jk[3], kl[3];</a>
<a name="ln4281">    VectorSubtract(pos_j, pos_i, ij);</a>
<a name="ln4282">    VectorSubtract(pos_k, pos_j, jk);</a>
<a name="ln4283">    VectorSubtract(pos_l, pos_k, kl);</a>
<a name="ln4284"> </a>
<a name="ln4285">    // length of the three bonds</a>
<a name="ln4286">    const double l_ij = VectorLength(ij);</a>
<a name="ln4287">    const double l_jk = VectorLength(jk);</a>
<a name="ln4288">    const double l_kl = VectorLength(kl);</a>
<a name="ln4289"> </a>
<a name="ln4290">    if (IsNearZero(l_ij) || IsNearZero(l_jk) || IsNearZero(l_kl) ) {</a>
<a name="ln4291">      return 0.0;</a>
<a name="ln4292">    }</a>
<a name="ln4293"> </a>
<a name="ln4294">    // normalize the bond vectors:</a>
<a name="ln4295">    VectorDivide (ij, l_ij, ij);</a>
<a name="ln4296">    VectorDivide (jk, l_jk, jk);</a>
<a name="ln4297">    VectorDivide (kl, l_kl, kl);</a>
<a name="ln4298"> </a>
<a name="ln4299">    double a[3];</a>
<a name="ln4300">    VectorCross(ij, jk, a);</a>
<a name="ln4301">    double b[3];</a>
<a name="ln4302">    VectorCross(jk, kl, b);</a>
<a name="ln4303">    double c[3];</a>
<a name="ln4304">    VectorCross(a, b, c);</a>
<a name="ln4305">    double d1 = VectorDot(c, jk);</a>
<a name="ln4306">    double d2 = VectorDot(a, b);</a>
<a name="ln4307">    double tor = RAD_TO_DEG * atan2(d1, d2);</a>
<a name="ln4308"> </a>
<a name="ln4309">    return tor;</a>
<a name="ln4310">  }</a>
<a name="ln4311"> </a>
<a name="ln4312">  bool OBForceField::IsInSameRing(OBAtom* a, OBAtom* b)</a>
<a name="ln4313">  {</a>
<a name="ln4314">    bool a_in, b_in;</a>
<a name="ln4315">    vector&lt;OBRing*&gt; vr;</a>
<a name="ln4316">    vr = _mol.GetSSSR();</a>
<a name="ln4317"> </a>
<a name="ln4318">    vector&lt;OBRing*&gt;::iterator i;</a>
<a name="ln4319">    vector&lt;int&gt;::iterator j;</a>
<a name="ln4320"> </a>
<a name="ln4321">    for (i = vr.begin();i != vr.end();++i) {</a>
<a name="ln4322">      a_in = false;</a>
<a name="ln4323">      b_in = false;</a>
<a name="ln4324">      for(j = (*i)-&gt;_path.begin();j != (*i)-&gt;_path.end();++j) {</a>
<a name="ln4325">        if ((unsigned)(*j) == a-&gt;GetIdx())</a>
<a name="ln4326">          a_in = true;</a>
<a name="ln4327">        if ((unsigned)(*j) == b-&gt;GetIdx())</a>
<a name="ln4328">          b_in = true;</a>
<a name="ln4329">      }</a>
<a name="ln4330"> </a>
<a name="ln4331">      if (a_in &amp;&amp; b_in)</a>
<a name="ln4332">        return true;</a>
<a name="ln4333">    }</a>
<a name="ln4334"> </a>
<a name="ln4335">    return false;</a>
<a name="ln4336">  }</a>
<a name="ln4337"> </a>
<a name="ln4338">  OBGridData* OBForceField::GetGrid(double step, double padding, const char* type, double pchg)</a>
<a name="ln4339">  {</a>
<a name="ln4340">    cout &lt;&lt; &quot;OBForceFieldMMFF94::GetGrid(&quot; &lt;&lt; step &lt;&lt; &quot;, &quot; &lt;&lt; type &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln4341">    OBFloatGrid fgrid;</a>
<a name="ln4342">    fgrid.Init(_mol, step, padding);</a>
<a name="ln4343">    vector3 min;</a>
<a name="ln4344">    unsigned int xDim, yDim, zDim, xyzDim;</a>
<a name="ln4345"> </a>
<a name="ln4346">    min = fgrid.GetMin();</a>
<a name="ln4347"> </a>
<a name="ln4348">    xDim = fgrid.GetXdim();</a>
<a name="ln4349">    yDim = fgrid.GetYdim();</a>
<a name="ln4350">    zDim = fgrid.GetZdim();</a>
<a name="ln4351">    xyzDim = xDim * yDim * zDim;</a>
<a name="ln4352"> </a>
<a name="ln4353">    cout &lt;&lt; &quot;xDim = &quot; &lt;&lt; xDim &lt;&lt; &quot;, yDim = &quot; &lt;&lt; yDim &lt;&lt; &quot;, zDim = &quot; &lt;&lt; zDim &lt;&lt; endl;</a>
<a name="ln4354"> </a>
<a name="ln4355">    // Add the probe atom</a>
<a name="ln4356">    _mol.BeginModify();</a>
<a name="ln4357">    OBAtom *atom = _mol.NewAtom();</a>
<a name="ln4358">    int index = atom-&gt;GetIdx();</a>
<a name="ln4359">    _mol.EndModify();</a>
<a name="ln4360">    SetTypes();</a>
<a name="ln4361">    atom-&gt;SetType(type);</a>
<a name="ln4362">    atom-&gt;SetPartialCharge(pchg);</a>
<a name="ln4363"> </a>
<a name="ln4364">    SetupCalculations();</a>
<a name="ln4365"> </a>
<a name="ln4366">    atom = _mol.GetAtom(index);</a>
<a name="ln4367">    double *pos = atom-&gt;GetCoordinate();</a>
<a name="ln4368"> </a>
<a name="ln4369">    vector3 coord;</a>
<a name="ln4370">    double evdw, eele;</a>
<a name="ln4371">    double distance, minDistance;</a>
<a name="ln4372"> </a>
<a name="ln4373">    OBGridData *grid = new OBGridData;</a>
<a name="ln4374">    vector3 xAxis, yAxis, zAxis;</a>
<a name="ln4375">    xAxis = vector3(step, 0.0, 0.0);</a>
<a name="ln4376">    yAxis = vector3(0.0, step, 0.0);</a>
<a name="ln4377">    zAxis = vector3(0.0, 0.0, step);</a>
<a name="ln4378"> </a>
<a name="ln4379">    grid-&gt;SetNumberOfPoints(xDim, yDim, zDim);</a>
<a name="ln4380">    grid-&gt;SetLimits(min, xAxis, yAxis, zAxis);</a>
<a name="ln4381"> </a>
<a name="ln4382">    // VDW surface</a>
<a name="ln4383">    for (unsigned int i = 0; i &lt; xDim; ++i) {</a>
<a name="ln4384">      coord.SetX(min[0] + i * step);</a>
<a name="ln4385">      for (unsigned int j = 0; j &lt; yDim; ++j) {</a>
<a name="ln4386">        coord.SetY(min[1] + j * step);</a>
<a name="ln4387">        for (unsigned int k = 0; k &lt; zDim; ++k)</a>
<a name="ln4388">          {</a>
<a name="ln4389">            coord.SetZ(min[2] + k * step);</a>
<a name="ln4390">            minDistance = 1.0E+10;</a>
<a name="ln4391">            FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln4392">              if (a-&gt;GetIdx() == atom-&gt;GetIdx())</a>
<a name="ln4393">                continue;</a>
<a name="ln4394">              if (a-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln4395">                continue;</a>
<a name="ln4396"> </a>
<a name="ln4397">              distance = sqrt(coord.distSq(a-&gt;GetVector()));</a>
<a name="ln4398"> </a>
<a name="ln4399">              if (distance &lt; minDistance)</a>
<a name="ln4400">                minDistance = distance;</a>
<a name="ln4401">            } // end checking atoms</a>
<a name="ln4402">            // negative = away from molecule, 0 = vdw surface, positive = inside</a>
<a name="ln4403">            if (minDistance &gt; 1.0) {</a>
<a name="ln4404">              grid-&gt;SetValue(i, j, k, 0.0); // outside the molecule</a>
<a name="ln4405">            } else {</a>
<a name="ln4406">              grid-&gt;SetValue(i, j, k, 10e99); // inside the molecule</a>
<a name="ln4407">            }</a>
<a name="ln4408">          } // z-axis</a>
<a name="ln4409">      } // y-axis</a>
<a name="ln4410">    } // x-axis</a>
<a name="ln4411"> </a>
<a name="ln4412"> </a>
<a name="ln4413">    unsigned int count = 0;</a>
<a name="ln4414">    for (unsigned int i = 0; i &lt; xDim; ++i) {</a>
<a name="ln4415">      coord.SetX(min[0] + i * step);</a>
<a name="ln4416">      for (unsigned int j = 0; j &lt; yDim; ++j) {</a>
<a name="ln4417">        coord.SetY(min[1] + j * step);</a>
<a name="ln4418">        for (unsigned int k = 0; k &lt; zDim; ++k)</a>
<a name="ln4419">          {</a>
<a name="ln4420">            coord.SetZ(min[2] + k * step);</a>
<a name="ln4421"> </a>
<a name="ln4422">            count++;</a>
<a name="ln4423">            cout &lt;&lt; &quot;\r&quot; &lt;&lt; count &lt;&lt; &quot;/&quot; &lt;&lt; xyzDim;</a>
<a name="ln4424"> </a>
<a name="ln4425">            if (grid-&gt;GetValue(i, j, k) == 0.0) {</a>
<a name="ln4426">              pos[0] = coord.x();</a>
<a name="ln4427">              pos[1] = coord.y();</a>
<a name="ln4428">              pos[2] = coord.z();</a>
<a name="ln4429">              evdw = E_VDW(false);</a>
<a name="ln4430">              eele = E_Electrostatic(false);</a>
<a name="ln4431">              grid-&gt;SetValue(i, j, k, evdw + eele);</a>
<a name="ln4432">            }</a>
<a name="ln4433">          } // z-axis</a>
<a name="ln4434">      } // y-axis</a>
<a name="ln4435">    } // x-axis</a>
<a name="ln4436"> </a>
<a name="ln4437">    cout &lt;&lt; endl;</a>
<a name="ln4438"> </a>
<a name="ln4439">    _mol.BeginModify();</a>
<a name="ln4440">    _mol.DeleteAtom(atom);</a>
<a name="ln4441">    _mol.EndModify();</a>
<a name="ln4442"> </a>
<a name="ln4443">    return grid;</a>
<a name="ln4444">  }</a>
<a name="ln4445"> </a>
<a name="ln4446">  /**</a>
<a name="ln4447">   * @example obforcefield_energy.cpp</a>
<a name="ln4448">   * Example showing how to compute the enrgy for a molecule.</a>
<a name="ln4449">   */</a>
<a name="ln4450"> </a>
<a name="ln4451">} // end namespace OpenBabel</a>
<a name="ln4452"> </a>
<a name="ln4453"> </a>
<a name="ln4454">//! \file forcefield.cpp</a>
<a name="ln4455">//! \brief Handle OBForceField class</a>

</code></pre>
<div class="balloon" rel="4190"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'VectorSubtract' function: 'pos_j' and 'pos_i'.</p></div>
<div class="balloon" rel="4281"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'VectorSubtract' function: 'pos_j' and 'pos_i'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

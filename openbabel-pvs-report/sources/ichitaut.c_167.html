
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichitaut.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;inpdef.h&quot;</a>
<a name="ln48">#include &quot;extr_ct.h&quot;</a>
<a name="ln49">#include &quot;inpdef.h&quot;</a>
<a name="ln50">#include &quot;ichitaut.h&quot;</a>
<a name="ln51">#include &quot;ichinorm.h&quot;</a>
<a name="ln52">#include &quot;ichicant.h&quot;</a>
<a name="ln53">#include &quot;ichicomn.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;ichicomp.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">#include &quot;util.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59">#include &quot;ichi_bns.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">/* Local prototypes */</a>
<a name="ln63">int SetTautomericBonds( inp_ATOM *at, int nNumBondPos, T_BONDPOS *BondPos );</a>
<a name="ln64">int CompRankTautomer(const void* a1, const void* a2 );</a>
<a name="ln65">int RegisterEndPoints( T_GROUP_INFO *t_group_info, /* T_GROUP *t_group, int *pnum_t, int max_num_t,*/</a>
<a name="ln66">                       T_ENDPOINT *EndPoint, int nNumEndPoints, inp_ATOM *at, int num_atoms, C_GROUP_INFO *cgi</a>
<a name="ln67">                       , struct BalancedNetworkStructure *pBNS );</a>
<a name="ln68">int cmpTGroupNumber( const void *a1, const void *a2 );</a>
<a name="ln69">int comp_candidates( const void *a1, const void *a2 );</a>
<a name="ln70">int MoveEndpoint( inp_ATOM *at, S_CANDIDATE *s_candidate, AT_NUMB endpoint, AT_NUMB *nTGroupNewNumbers,</a>
<a name="ln71">                  AT_NUMB *nTGroupPosition, int nNewTGroupOrd, T_GROUP_INFO *t_group_info);</a>
<a name="ln72"> </a>
<a name="ln73">int FindAccessibleEndPoints( T_ENDPOINT *EndPoint, int *nNumEndPoints, T_BONDPOS *BondPos, int *nNumBondPos,</a>
<a name="ln74">                         struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD,</a>
<a name="ln75">                         inp_ATOM *at, int num_atoms, C_GROUP_INFO *cgi, int taut_mode );</a>
<a name="ln76"> </a>
<a name="ln77">/* Bits for GetChargeType */</a>
<a name="ln78"> </a>
<a name="ln79">#define C_SUBTYPE_CHARGED     0</a>
<a name="ln80">#define C_SUBTYPE_p_DONOR     1  /* new */</a>
<a name="ln81">#define C_SUBTYPE_p_ACCEPT    2  /* new */</a>
<a name="ln82">#define C_SUBTYPE_H_ACCEPT    4</a>
<a name="ln83">#define C_SUBTYPE_H_DONOR     8</a>
<a name="ln84">#define C_SUBTYPE_NEUTRAL    16</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">/* Internal stack array size */</a>
<a name="ln88">#define MAX_STACK_ARRAY_LEN 127</a>
<a name="ln89">#define MAX_TGROUP_ARRAY_LEN 127</a>
<a name="ln90"> </a>
<a name="ln91">/* local prototypes */</a>
<a name="ln92">int GetChargeType( inp_ATOM *atom, int iat, S_CHAR *cChargeSubtype );</a>
<a name="ln93">int GetNeutralRepsIfNeeded( AT_NUMB *pri, AT_NUMB *prj, inp_ATOM *at, int num_atoms, T_ENDPOINT *EndPoint, int nNumEndPoints, C_GROUP_INFO *cgi );</a>
<a name="ln94">int bCanBeACPoint( inp_ATOM *at, S_CHAR cCharge, S_CHAR cChangeValence, S_CHAR neutral_bonds_valence,</a>
<a name="ln95">                   S_CHAR neutral_valence, S_CHAR nEndpointValence, S_CHAR *cChargeSubtype );</a>
<a name="ln96">int CmpCCandidates( const void *a1, const void *a2 );</a>
<a name="ln97">int RegisterCPoints( C_GROUP *c_group, int *pnum_c, int max_num_c, T_GROUP_INFO *t_group_info,</a>
<a name="ln98">                     int point1, int point2, int ctype, inp_ATOM *at, int num_atoms );</a>
<a name="ln99">int GetSaltChargeType( inp_ATOM *at, int at_no, T_GROUP_INFO *t_group_info, int *s_subtype );</a>
<a name="ln100">int GetOtherSaltChargeType( inp_ATOM *at, int at_no, T_GROUP_INFO *t_group_info, int *s_subtype, int bAccept_O );</a>
<a name="ln101">int MergeSaltTautGroupsBlind( inp_ATOM *at, int s_type, int num_atoms, S_GROUP_INFO *s_group_info, int nNumCandidates,</a>
<a name="ln102">                          T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info,</a>
<a name="ln103">                          struct BalancedNetworkStructure *pBNS );</a>
<a name="ln104">int ConnectSaltTGroups2SuperTGroup( inp_ATOM *at, int num_atoms, S_GROUP_INFO *s_group_info, int nNumCandidates,</a>
<a name="ln105">                          T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info,</a>
<a name="ln106">                          struct BalancedNetworkStructure *pBNS, int *nNewTGroupNumber, int *vertSuperTGroup );</a>
<a name="ln107">int bDoNotMergeNonTautAtom(inp_ATOM *at, int at_no);</a>
<a name="ln108">int GetOtherSaltType( inp_ATOM *at, int at_no, int *s_subtype );</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">/*****************************************************************************/</a>
<a name="ln112">/*  Tautomers: Sorting globals												 */</a>
<a name="ln113">AT_RANK        *pn_tRankForSort;</a>
<a name="ln114">/*****************************************************************************/</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">/*****************************************************************************/</a>
<a name="ln119">int is_centerpoint_elem( U_CHAR el_number )</a>
<a name="ln120">{</a>
<a name="ln121">    static U_CHAR el_numb[12];</a>
<a name="ln122">    static int len;</a>
<a name="ln123">    int i;</a>
<a name="ln124">    if ( !el_numb[0] &amp;&amp; !len ) {</a>
<a name="ln125">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln126">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln127">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;P&quot; );</a>
<a name="ln128">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln129">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;I&quot; );</a>
<a name="ln130">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;As&quot; );</a>
<a name="ln131">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Sb&quot; );</a>
<a name="ln132">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln133">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln134">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Cl&quot; );</a>
<a name="ln135">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Br&quot; );</a>
<a name="ln136">    }</a>
<a name="ln137">    for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln138">        if ( el_numb[i] == el_number ) {</a>
<a name="ln139">            return 1;</a>
<a name="ln140">        }</a>
<a name="ln141">    }</a>
<a name="ln142">    return 0;</a>
<a name="ln143">}</a>
<a name="ln144">#if ( KETO_ENOL_TAUT == 1 )  /* post v.1 feature */</a>
<a name="ln145"> </a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">/*****************************************************************************/</a>
<a name="ln149">int is_centerpoint_elem_KET( U_CHAR el_number )</a>
<a name="ln150">{</a>
<a name="ln151">    static U_CHAR el_numb[1];</a>
<a name="ln152">    static int len;</a>
<a name="ln153">    int i;</a>
<a name="ln154">    if ( !el_numb[0] &amp;&amp; !len ) {</a>
<a name="ln155">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln156">    }</a>
<a name="ln157">    for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln158">        if ( el_numb[i] == el_number ) {</a>
<a name="ln159">            return 1;</a>
<a name="ln160">        }</a>
<a name="ln161">    }</a>
<a name="ln162">    return 0;</a>
<a name="ln163">}</a>
<a name="ln164">#endif</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">/*****************************************************************************/</a>
<a name="ln169">int is_centerpoint_elem_strict( U_CHAR el_number )</a>
<a name="ln170">{</a>
<a name="ln171">    static U_CHAR el_numb[6];</a>
<a name="ln172">    static int len;</a>
<a name="ln173">    int i;</a>
<a name="ln174">    if ( !el_numb[0] &amp;&amp; !len ) {</a>
<a name="ln175">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln176">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln177">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;P&quot; );</a>
<a name="ln178">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;As&quot; );</a>
<a name="ln179">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Sb&quot; );</a>
<a name="ln180">    }</a>
<a name="ln181">    for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln182">        if ( el_numb[i] == el_number ) {</a>
<a name="ln183">            return 1;</a>
<a name="ln184">        }</a>
<a name="ln185">    }</a>
<a name="ln186">    return 0;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">/*****************************************************************************/</a>
<a name="ln192">int get_endpoint_valence( U_CHAR el_number )</a>
<a name="ln193">{</a>
<a name="ln194">    static U_CHAR el_numb[6];</a>
<a name="ln195">    static int len, len2;</a>
<a name="ln196">    int i;</a>
<a name="ln197">    if ( !el_numb[0] &amp;&amp; !len ) {</a>
<a name="ln198">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln199">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln200">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln201">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln202">        len2 = len;</a>
<a name="ln203">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln204">    }</a>
<a name="ln205">    for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln206">        if ( el_numb[i] == el_number ) {</a>
<a name="ln207">            return i &lt; len2? 2 : 3;</a>
<a name="ln208">        }</a>
<a name="ln209">    }</a>
<a name="ln210">    return 0;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">/*****************************************************************************/</a>
<a name="ln216">#if ( KETO_ENOL_TAUT == 1 )  /* post v.1 feature */</a>
<a name="ln217">/*****************************************************************************/</a>
<a name="ln218">int get_endpoint_valence_KET( U_CHAR el_number )</a>
<a name="ln219">{</a>
<a name="ln220">    static U_CHAR el_numb[2];</a>
<a name="ln221">    static int len, len2;</a>
<a name="ln222">    int i;</a>
<a name="ln223">    if ( !el_numb[0] &amp;&amp; !len ) {</a>
<a name="ln224">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln225">        len2 = len;</a>
<a name="ln226">        el_numb[len++] = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln227">    }</a>
<a name="ln228">    for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln229">        if ( el_numb[i] == el_number ) {</a>
<a name="ln230">            return i &lt; len2? 2 : 4;</a>
<a name="ln231">        }</a>
<a name="ln232">    }</a>
<a name="ln233">    return 0;</a>
<a name="ln234">}</a>
<a name="ln235">#endif</a>
<a name="ln236">/*****************************************************************************/</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239"> </a>
<a name="ln240">/*****************************************************************************/</a>
<a name="ln241">int AddAtom2num(  AT_RANK num[], inp_ATOM *atom, int at_no, int bSubtract )</a>
<a name="ln242">{  /*  bSubtract: 0=&gt; add, 1=&gt;subtract, 2=&gt; fill */</a>
<a name="ln243">    inp_ATOM *at = atom + at_no;</a>
<a name="ln244">    int       k;</a>
<a name="ln245">    int       nMobile  =  (at-&gt;charge == -1);</a>
<a name="ln246">    if ( bSubtract == 1 ) {</a>
<a name="ln247">        /* 1: subtract */</a>
<a name="ln248">        num[1] -= nMobile;</a>
<a name="ln249">        nMobile += at-&gt;num_H;</a>
<a name="ln250">        num[0] -= nMobile;</a>
<a name="ln251">        for ( k = 0; k &lt; T_NUM_ISOTOPIC; k ++ ) {</a>
<a name="ln252">            /*  T (3H isotope) first because it has higher weight */</a>
<a name="ln253">            num[T_NUM_NO_ISOTOPIC+k] -= at-&gt;num_iso_H[NUM_H_ISOTOPES-k-1];</a>
<a name="ln254">        }</a>
<a name="ln255">    } else {</a>
<a name="ln256">        if ( bSubtract == 2 ) {</a>
<a name="ln257">            /* fill */</a>
<a name="ln258">            memset( num, 0, (T_NUM_NO_ISOTOPIC + T_NUM_ISOTOPIC)*sizeof(num[0]) );</a>
<a name="ln259">        }</a>
<a name="ln260">        /* else (0): add */</a>
<a name="ln261">        num[1] += nMobile;</a>
<a name="ln262">        nMobile += at-&gt;num_H;</a>
<a name="ln263">        num[0] += nMobile;</a>
<a name="ln264">        for ( k = 0; k &lt; T_NUM_ISOTOPIC; k ++ ) {</a>
<a name="ln265">            /*  T (3H isotope) first because it has higher weight */</a>
<a name="ln266">            num[T_NUM_NO_ISOTOPIC+k] += at-&gt;num_iso_H[NUM_H_ISOTOPES-k-1];</a>
<a name="ln267">        }</a>
<a name="ln268">    }</a>
<a name="ln269">    return nMobile;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273"> </a>
<a name="ln274">/*****************************************************************************/</a>
<a name="ln275">void AddAtom2DA( AT_RANK num_DA[], inp_ATOM *atom, int at_no, int bSubtract )</a>
<a name="ln276">{   /*  bSubtract: 0=&gt; add, 1=&gt;subtract, 2=&gt; fill */</a>
<a name="ln277">    inp_ATOM *at = atom + at_no;</a>
<a name="ln278">    int       nDelta, nAcidic_O;</a>
<a name="ln279"> </a>
<a name="ln280">    if (at-&gt;charge &lt; -1 || (at-&gt;charge == 1 &amp;&amp; !at-&gt;c_point) || at-&gt;charge &gt; 1 )</a>
<a name="ln281">        return;</a>
<a name="ln282"> </a>
<a name="ln283">    nDelta = ( bSubtract == 1 )? -1 : 1;</a>
<a name="ln284"> </a>
<a name="ln285">    /* &quot;Acidic&quot; O, S, Se, Te recognition */</a>
<a name="ln286">    if ( at-&gt;at_type &amp; ATT_ACIDIC_CO ) {</a>
<a name="ln287">        nAcidic_O = nDelta;</a>
<a name="ln288">    } else {</a>
<a name="ln289">        nAcidic_O = 0;</a>
<a name="ln290">    }</a>
<a name="ln291"> </a>
<a name="ln292">    if ( bSubtract == 2 ) { /* 2: fill, otherwise add */</a>
<a name="ln293">        memset( num_DA, 0, TG_NUM_DA * sizeof(num_DA[0]) );</a>
<a name="ln294">    }</a>
<a name="ln295">    if ( (at-&gt;charge &lt;= 0 &amp;&amp; at-&gt;valence == at-&gt;chem_bonds_valence) ||</a>
<a name="ln296">         /* neutral or negative donor */</a>
<a name="ln297">         (at-&gt;charge &gt; 0  &amp;&amp; at-&gt;valence + 1 == at-&gt;chem_bonds_valence)</a>
<a name="ln298">         /* positively charged donor */ </a>
<a name="ln299">       ) {</a>
<a name="ln300">        if ( at-&gt;charge &lt; 0 ) {</a>
<a name="ln301">            num_DA[TG_Num_dM] += nDelta;</a>
<a name="ln302">            num_DA[TG_Num_dO] += nAcidic_O;</a>
<a name="ln303">        } else</a>
<a name="ln304">        if ( at-&gt;num_H ) {</a>
<a name="ln305">            num_DA[TG_Num_dH] += nDelta;</a>
<a name="ln306">            num_DA[TG_Num_dO] += nAcidic_O;</a>
<a name="ln307">        }</a>
<a name="ln308">    } else</a>
<a name="ln309">    if ( (at-&gt;charge &lt;= 0 &amp;&amp; at-&gt;valence + 1 == at-&gt;chem_bonds_valence) ||</a>
<a name="ln310">         (at-&gt;charge &gt; 0  &amp;&amp; at-&gt;valence + 2 == at-&gt;chem_bonds_valence) ) {</a>
<a name="ln311">        /* acceptor */</a>
<a name="ln312">        if ( at-&gt;charge &lt; 0 ) {</a>
<a name="ln313">            num_DA[TG_Num_aM] += nDelta;</a>
<a name="ln314">        } else</a>
<a name="ln315">        if ( at-&gt;num_H ) {</a>
<a name="ln316">            num_DA[TG_Num_aH] += nDelta;</a>
<a name="ln317">        } else {</a>
<a name="ln318">            num_DA[TG_Num_aO] += nAcidic_O; /* acidic O-acceptor has no H or charge */</a>
<a name="ln319">        }</a>
<a name="ln320">    }</a>
<a name="ln321">    return;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">/*****************************************************************************/</a>
<a name="ln327">int AddEndPoint( T_ENDPOINT *pEndPoint, inp_ATOM *at, int iat )</a>
<a name="ln328">{        </a>
<a name="ln329">    pEndPoint-&gt;nAtomNumber  = iat;</a>
<a name="ln330">    pEndPoint-&gt;nEquNumber   = 0;</a>
<a name="ln331">    pEndPoint-&gt;nGroupNumber = at[iat].endpoint;</a>
<a name="ln332">    if ( at[iat].endpoint ) {</a>
<a name="ln333">        /* already an endpoint */</a>
<a name="ln334">        memset( pEndPoint-&gt;num, 0, sizeof(pEndPoint-&gt;num) );</a>
<a name="ln335">    } else {</a>
<a name="ln336">        /* not an endpoint yet, make it an endpoint */</a>
<a name="ln337">        AddAtom2num( pEndPoint-&gt;num, at, iat, 2 );  /* fill */</a>
<a name="ln338">        AddAtom2DA( pEndPoint-&gt;num_DA, at, iat, 2 );</a>
<a name="ln339">        /*</a>
<a name="ln340">        nMobile  = pEndPoint-&gt;num[1] = (at[iat].charge == -1);</a>
<a name="ln341">        nMobile  = pEndPoint-&gt;num[0] = at[iat].num_H + nMobile;</a>
<a name="ln342">        for ( k = 0; k &lt; T_NUM_ISOTOPIC; k ++ ) {</a>
<a name="ln343">            pEndPoint-&gt;num[T_NUM_NO_ISOTOPIC+k] = at[iat].num_iso_H[NUM_H_ISOTOPES-k-1];</a>
<a name="ln344">        }</a>
<a name="ln345">        */</a>
<a name="ln346">    }</a>
<a name="ln347">    return 0;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">/*****************************************************************************/</a>
<a name="ln353">int nGetEndpointInfo( inp_ATOM *atom, int iat, ENDPOINT_INFO *eif )</a>
<a name="ln354">{</a>
<a name="ln355">    int  nEndpointValence;</a>
<a name="ln356">    int  nMobile;</a>
<a name="ln357">    S_CHAR cChargeSubtype;</a>
<a name="ln358"> </a>
<a name="ln359">    if ( atom[iat].radical &amp;&amp; atom[iat].radical != RADICAL_SINGLET )</a>
<a name="ln360">        return 0; /* a radical */</a>
<a name="ln361">    if ( !(nEndpointValence = get_endpoint_valence( atom[iat].el_number )) )</a>
<a name="ln362">        return 0; /* not an endpoint */</a>
<a name="ln363">    if ( nEndpointValence &lt;= atom[iat].valence )</a>
<a name="ln364">        return 0; /* not an endpoint, for example &gt;N(+)&lt; or &gt;N&lt;  or &gt;O(+)- or &gt;O- or &gt;N- or -O- */</a>
<a name="ln365"> </a>
<a name="ln366">    if ( atom[iat].charge == -1 || atom[iat].charge == 0 ) {</a>
<a name="ln367">        /* not a positive charge-point */</a>
<a name="ln368">        if ( nEndpointValence &lt; atom[iat].chem_bonds_valence )</a>
<a name="ln369">            return 0; /* abnormal valence &gt; standard endpoint valence */</a>
<a name="ln370">        nMobile = atom[iat].num_H + (atom[iat].charge == -1);</a>
<a name="ln371">        if ( nMobile + atom[iat].chem_bonds_valence != nEndpointValence )</a>
<a name="ln372">            return 0; /* non-standard endpoint valence */</a>
<a name="ln373">        switch ( atom[iat].chem_bonds_valence - atom[iat].valence ) {</a>
<a name="ln374">        case 0:</a>
<a name="ln375">            eif-&gt;cDonor    = 1;</a>
<a name="ln376">            eif-&gt;cAcceptor = 0;</a>
<a name="ln377">            break;</a>
<a name="ln378">        case 1:</a>
<a name="ln379">            eif-&gt;cDonor    = 0;</a>
<a name="ln380">            eif-&gt;cAcceptor = 1;</a>
<a name="ln381">            break;</a>
<a name="ln382">        default:</a>
<a name="ln383">            return 0;</a>
<a name="ln384">        }</a>
<a name="ln385">        eif-&gt;cMobile = nMobile;</a>
<a name="ln386">        eif-&gt;cNeutralBondsValence = nEndpointValence-nMobile;</a>
<a name="ln387">        eif-&gt;cMoveableCharge = 0;</a>
<a name="ln388">#if ( KETO_ENOL_TAUT == 1 )</a>
<a name="ln389">        eif-&gt;cKetoEnolCode = 0;</a>
<a name="ln390">#endif</a>
<a name="ln391">        return nEndpointValence;</a>
<a name="ln392">    } else</a>
<a name="ln393">    if ( atom[iat].c_point &amp;&amp;</a>
<a name="ln394">         0 &lt;= GetChargeType( atom, iat, &amp;cChargeSubtype ) &amp;&amp;</a>
<a name="ln395">         ((int)cChargeSubtype &amp; (C_SUBTYPE_H_ACCEPT|C_SUBTYPE_H_DONOR))</a>
<a name="ln396">        ) {</a>
<a name="ln397">        /* charge-point */</a>
<a name="ln398">        if ( cChargeSubtype &amp; C_SUBTYPE_H_ACCEPT ) {</a>
<a name="ln399">            eif-&gt;cDonor    = 0;</a>
<a name="ln400">            eif-&gt;cAcceptor = 1;</a>
<a name="ln401">        } else</a>
<a name="ln402">        if ( cChargeSubtype &amp; C_SUBTYPE_H_DONOR ) {</a>
<a name="ln403">            eif-&gt;cDonor    = 1;</a>
<a name="ln404">            eif-&gt;cAcceptor = 0;</a>
<a name="ln405">        } else {</a>
<a name="ln406">            return 0;</a>
<a name="ln407">        }</a>
<a name="ln408">        eif-&gt;cMobile = atom[iat].num_H;</a>
<a name="ln409">        eif-&gt;cNeutralBondsValence = nEndpointValence-atom[iat].num_H;</a>
<a name="ln410">        eif-&gt;cMoveableCharge = atom[iat].charge;</a>
<a name="ln411">#if ( KETO_ENOL_TAUT == 1 )</a>
<a name="ln412">        eif-&gt;cKetoEnolCode = 0;</a>
<a name="ln413">#endif</a>
<a name="ln414">        return nEndpointValence;</a>
<a name="ln415">    }</a>
<a name="ln416">    return 0;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420"> </a>
<a name="ln421">/*****************************************************************************/</a>
<a name="ln422">#if ( KETO_ENOL_TAUT == 1 )  /* post v.1 feature */</a>
<a name="ln423">/*****************************************************************************/</a>
<a name="ln424">int nGetEndpointInfo_KET( inp_ATOM *atom, int iat, ENDPOINT_INFO *eif )</a>
<a name="ln425">{</a>
<a name="ln426">    int  nEndpointValence;</a>
<a name="ln427">    int  nMobile;</a>
<a name="ln428">    S_CHAR cChargeSubtype;</a>
<a name="ln429"> </a>
<a name="ln430">    /*</a>
<a name="ln431">    static U_CHAR el_number_O, el_number_C;</a>
<a name="ln432"> </a>
<a name="ln433">    if ( !el_number_O ) {</a>
<a name="ln434">        el_number_O = (U_CHAR)get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln435">        el_number_C = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln436">    }</a>
<a name="ln437">    */</a>
<a name="ln438">    if ( atom[iat].radical &amp;&amp; atom[iat].radical != RADICAL_SINGLET )</a>
<a name="ln439">        return 0; /* a radical */</a>
<a name="ln440">    if ( !(nEndpointValence = get_endpoint_valence_KET( atom[iat].el_number )) )</a>
<a name="ln441">        return 0; /* not an endpoint; only O and C can be an endpoint for keto-enol tautomerism */</a>
<a name="ln442">    if ( nEndpointValence &lt;= atom[iat].valence )</a>
<a name="ln443">        return 0; /* not an endpoint, for example &gt;N(+)&lt; or &gt;N&lt;  or &gt;O(+)- or &gt;O- or &gt;N- or -O- */</a>
<a name="ln444">    if ( nEndpointValence == 4 &amp;&amp; atom[iat].valence &lt; 2 )</a>
<a name="ln445">        return 0; /* exclude O==C--CH3  &lt;=&gt; HO--C==CH2 */</a>
<a name="ln446">    if ( nEndpointValence == 2 &amp;&amp; atom[iat].valence &gt; 1 )</a>
<a name="ln447">        return 0; /* exclude --O--C==CH-- */</a>
<a name="ln448"> </a>
<a name="ln449">    if ( atom[iat].charge == -1 || atom[iat].charge == 0 ) {</a>
<a name="ln450">        /* not a positive charge-point */</a>
<a name="ln451">        if ( nEndpointValence &lt; atom[iat].chem_bonds_valence )</a>
<a name="ln452">            return 0; /* abnormal valence &gt; standard endpoint valence */</a>
<a name="ln453">        nMobile = atom[iat].num_H + (atom[iat].charge == -1);</a>
<a name="ln454">        if ( nMobile + atom[iat].chem_bonds_valence != nEndpointValence )</a>
<a name="ln455">            return 0; /* non-standard endpoint valence */</a>
<a name="ln456">        switch ( atom[iat].chem_bonds_valence - atom[iat].valence ) {</a>
<a name="ln457">        case 0:</a>
<a name="ln458">            eif-&gt;cDonor    = 1;</a>
<a name="ln459">            eif-&gt;cAcceptor = 0;</a>
<a name="ln460">            break;</a>
<a name="ln461">        case 1:</a>
<a name="ln462">            eif-&gt;cDonor    = 0;</a>
<a name="ln463">            eif-&gt;cAcceptor = 1;</a>
<a name="ln464">            break;</a>
<a name="ln465">        default:</a>
<a name="ln466">            return 0;</a>
<a name="ln467">        }</a>
<a name="ln468">        eif-&gt;cMobile = nMobile;</a>
<a name="ln469">        eif-&gt;cNeutralBondsValence = nEndpointValence-nMobile;</a>
<a name="ln470">        eif-&gt;cMoveableCharge = 0;</a>
<a name="ln471">        eif-&gt;cKetoEnolCode   = (nEndpointValence == 2)? 1 : (nEndpointValence == 4)? 2 : 0;</a>
<a name="ln472">        return nEndpointValence;</a>
<a name="ln473">    } else</a>
<a name="ln474">    if ( atom[iat].c_point &amp;&amp;</a>
<a name="ln475">         0 &lt;= GetChargeType( atom, iat, &amp;cChargeSubtype ) &amp;&amp;</a>
<a name="ln476">         ((int)cChargeSubtype &amp; (C_SUBTYPE_H_ACCEPT|C_SUBTYPE_H_DONOR))</a>
<a name="ln477">        ) {</a>
<a name="ln478">        /* charge-point; currently only O for keto-enol tautomerism */</a>
<a name="ln479">        if ( cChargeSubtype &amp; C_SUBTYPE_H_ACCEPT ) {</a>
<a name="ln480">            eif-&gt;cDonor    = 0;</a>
<a name="ln481">            eif-&gt;cAcceptor = 1;</a>
<a name="ln482">        } else</a>
<a name="ln483">        if ( cChargeSubtype &amp; C_SUBTYPE_H_DONOR ) {</a>
<a name="ln484">            eif-&gt;cDonor    = 1;</a>
<a name="ln485">            eif-&gt;cAcceptor = 0;</a>
<a name="ln486">        } else {</a>
<a name="ln487">            return 0;</a>
<a name="ln488">        }</a>
<a name="ln489">        eif-&gt;cMobile = atom[iat].num_H;</a>
<a name="ln490">        eif-&gt;cNeutralBondsValence = nEndpointValence-atom[iat].num_H;</a>
<a name="ln491">        eif-&gt;cMoveableCharge = atom[iat].charge;</a>
<a name="ln492">        eif-&gt;cKetoEnolCode   = (nEndpointValence == 2)? 1 : (nEndpointValence == 4)? 2 : 0;</a>
<a name="ln493">        return nEndpointValence;</a>
<a name="ln494">    }</a>
<a name="ln495">    return 0;</a>
<a name="ln496">}</a>
<a name="ln497">#endif</a>
<a name="ln498">/*****************************************************************************/</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">/*****************************************************************************/</a>
<a name="ln503">/*  RegisterEndPoints ret&gt;0 =&gt; new registration happened,					 */</a>
<a name="ln504">/*                       =0 =&gt; no changes, -1 =&gt; program error (debug)		 */</a>
<a name="ln505">/*****************************************************************************/</a>
<a name="ln506">int RegisterEndPoints( T_GROUP_INFO *t_group_info, </a>
<a name="ln507">                       /* T_GROUP *t_group, int *pnum_t, int max_num_t,*/</a>
<a name="ln508">                       T_ENDPOINT *EndPoint, int nNumEndPoints, inp_ATOM *at, int num_atoms, </a>
<a name="ln509">                       C_GROUP_INFO *cgi, struct BalancedNetworkStructure *pBNS )</a>
<a name="ln510">{</a>
<a name="ln511">    T_GROUP  *t_group   =  t_group_info-&gt;t_group;</a>
<a name="ln512">    int      *pnum_t    = &amp;t_group_info-&gt;num_t_groups;</a>
<a name="ln513">    int       max_num_t =  t_group_info-&gt;max_num_t_groups;</a>
<a name="ln514">    int       nNumZeroEqu, nNumNewTGroups;</a>
<a name="ln515">    AT_NUMB   group, prev_group, prev_eqnum, nNextGroupNumber, nLeastGroupNumber; </a>
<a name="ln516">    int       nNumGroups, num_t, difference;</a>
<a name="ln517">    int       i, j, k, ret;</a>
<a name="ln518">    AT_NUMB   nNewTgNumberStackArray[MAX_STACK_ARRAY_LEN+1];</a>
<a name="ln519">    AT_NUMB   nGroupNumberStackArray[MAX_STACK_ARRAY_LEN+1];</a>
<a name="ln520">    AT_NUMB   nGroupNewNumberStackArray[MAX_STACK_ARRAY_LEN+1];</a>
<a name="ln521">    AT_NUMB  *nNewTgNumber    = nNewTgNumberStackArray;</a>
<a name="ln522">    AT_NUMB  *nGroupNumber    = nGroupNumberStackArray;</a>
<a name="ln523">    AT_NUMB  *nGroupNewNumber = nGroupNewNumberStackArray;</a>
<a name="ln524"> </a>
<a name="ln525">    if ( nNumEndPoints &lt;= 0 )</a>
<a name="ln526">        return 0; /* nothing to do */</a>
<a name="ln527">    num_t            = *pnum_t;</a>
<a name="ln528">    difference       = 0;</a>
<a name="ln529">    nNextGroupNumber = 0;</a>
<a name="ln530">    nNumZeroEqu      = 0;</a>
<a name="ln531">    ret              = 0;</a>
<a name="ln532">    /* find max group number; increment it to obtain next available group number */</a>
<a name="ln533">    for ( i = 0; i &lt; num_t; i ++ ) {</a>
<a name="ln534">        if ( nNextGroupNumber &lt; t_group[i].nGroupNumber )</a>
<a name="ln535">            nNextGroupNumber = t_group[i].nGroupNumber;</a>
<a name="ln536">    }</a>
<a name="ln537">    nNextGroupNumber ++;</a>
<a name="ln538"> </a>
<a name="ln539">    /* find min non-zero group number nLeastGroupNumber;</a>
<a name="ln540">       count zero EndPoint[i].nEquNumber</a>
<a name="ln541">       if all EndPoint[i].nGroupNumber are equal and non-zero then exit: nothing to do.</a>
<a name="ln542">    */</a>
<a name="ln543">    nLeastGroupNumber = nNextGroupNumber;</a>
<a name="ln544">    prev_group        = EndPoint[0].nGroupNumber;</a>
<a name="ln545">    prev_eqnum        = EndPoint[0].nEquNumber;</a>
<a name="ln546">    for ( i = j = k = 0; i &lt; nNumEndPoints; i ++ ) {</a>
<a name="ln547">        if ( (group = EndPoint[i].nGroupNumber) ) {</a>
<a name="ln548">            if ( group &lt; nLeastGroupNumber ) {</a>
<a name="ln549">                nLeastGroupNumber = group;</a>
<a name="ln550">            }</a>
<a name="ln551">        }</a>
<a name="ln552">        j += (prev_group == EndPoint[i].nGroupNumber); /* count endpoints that belong to the 1st group */</a>
<a name="ln553">        k += (prev_eqnum == EndPoint[i].nEquNumber);   /* count endpoints that belongo to a group equivalent to the 1st group */</a>
<a name="ln554">        nNumZeroEqu += !EndPoint[i].nEquNumber;        /* count endpoints that have been processed by FindAccessibleEndPoints() */</a>
<a name="ln555">    }</a>
<a name="ln556">    if ( j == nNumEndPoints &amp;&amp; prev_group &amp;&amp; k == nNumEndPoints ) {</a>
<a name="ln557">        /* all endpoints already belong to one t-group;</a>
<a name="ln558">           the last comparison is not needed for now </a>
<a name="ln559">           because EndPoint[i].nEquNumber cannot make</a>
<a name="ln560">           endpont partitioning finer</a>
<a name="ln561">        */</a>
<a name="ln562">        return 0;</a>
<a name="ln563">    }</a>
<a name="ln564">         </a>
<a name="ln565">    nNumNewTGroups   = 0;</a>
<a name="ln566"> </a>
<a name="ln567">    if ( !nNumZeroEqu ) {</a>
<a name="ln568">        /* EndPoint[] has been processed by FindAccessibleEndPoints;</a>
<a name="ln569">         * equal EndPoint[i].nEquNumber mark endpoints belonging to</a>
<a name="ln570">         * the same t-group</a>
<a name="ln571">         * Since now the next available t-group number, nNextGroupNumber,</a>
<a name="ln572">         * is known,replace fict. IDs assigned by FindAccessibleEndPoints</a>
<a name="ln573">         * with correct new t-group numbers.</a>
<a name="ln574">         */</a>
<a name="ln575">        for ( i = 0; i &lt; nNumEndPoints; i ++ ) {</a>
<a name="ln576">            if ( (group = EndPoint[i].nEquNumber) &gt;= nNextGroupNumber ) {</a>
<a name="ln577">                /* replace fict. IDs assigned by FindAccessibleEndPoints() with new t-group numbers */</a>
<a name="ln578">                /* these fict. IDs have values = (num_atoms+1), (num_atoms+2),...; they may be non-contiguous */</a>
<a name="ln579">                for ( j = 0; j &lt; nNumNewTGroups; j ++ ) {</a>
<a name="ln580">                    if ( group == nGroupNewNumber[j] )</a>
<a name="ln581">                        break;</a>
<a name="ln582">                }</a>
<a name="ln583">                if ( j == nNumNewTGroups ) {</a>
<a name="ln584">                    /* found new fict. ID = group */</a>
<a name="ln585">                    if ( j == MAX_STACK_ARRAY_LEN &amp;&amp; nGroupNewNumber == nGroupNewNumberStackArray ) {</a>
<a name="ln586">                        /* stack array overflow; allocate more memory than may be needed */</a>
<a name="ln587">                        nGroupNewNumber = (AT_NUMB *) inchi_malloc(nNumEndPoints*sizeof(nGroupNewNumber[0]));</a>
<a name="ln588">                        if ( !nGroupNewNumber ) {</a>
<a name="ln589">                            ret = -1;</a>
<a name="ln590">                            goto exit_function;</a>
<a name="ln591">                        }</a>
<a name="ln592">                        memcpy( nGroupNewNumber, nGroupNewNumberStackArray, nNumNewTGroups*sizeof(nGroupNewNumber[0]));</a>
<a name="ln593">                    }</a>
<a name="ln594">                    /* save newly found fict. t-group ID to compare to the next values of EndPoint[].nEquNumber  */</a>
<a name="ln595">                    nGroupNewNumber[j] = group;</a>
<a name="ln596">                    nNumNewTGroups ++;</a>
<a name="ln597">                }</a>
<a name="ln598">                EndPoint[i].nEquNumber = nNextGroupNumber + j;</a>
<a name="ln599">            }</a>
<a name="ln600">        } /* after this point the values just stored in nGroupNewNumber[] will not</a>
<a name="ln601">             be used. However, the obtained nNumNewTGroups value will be used */</a>
<a name="ln602">    } else</a>
<a name="ln603">    if ( nNumZeroEqu == nNumEndPoints ) {</a>
<a name="ln604">        /* EndPoint[] has NOT been processed by FindAccessibleEndPoints;</a>
<a name="ln605">           all atoms and t-groups to which endpoints belong should be merged into a single t-group</a>
<a name="ln606">         */</a>
<a name="ln607">        if ( nLeastGroupNumber == nNextGroupNumber ) {</a>
<a name="ln608">            /* flag to create a new t-group: none of the found</a>
<a name="ln609">             *  endpoints belong to an already known t-group</a>
<a name="ln610">             */</a>
<a name="ln611">            nNumNewTGroups = 1; /* otherwise 0 */</a>
<a name="ln612">        }</a>
<a name="ln613">        /* All EndPoint[*].nEquNumber are zeroes. All endpoints will</a>
<a name="ln614">         * belong to one new or old t-group; its ID is nLeastGroupNumber.</a>
<a name="ln615">         * Set  EndPoint[i].nEquNumber = nLeastGroupNumber;</a>
<a name="ln616">         */</a>
<a name="ln617">        for ( i = 0; i &lt; nNumEndPoints; i ++ ) {</a>
<a name="ln618">            EndPoint[i].nEquNumber = nLeastGroupNumber;</a>
<a name="ln619">        }</a>
<a name="ln620">    } else {</a>
<a name="ln621">        ret = -1; /* program error: only some of EndPoint[i].nEquNumber are zero */ /*   &lt;BRKPT&gt; */</a>
<a name="ln622">        goto exit_function;</a>
<a name="ln623">    }</a>
<a name="ln624"> </a>
<a name="ln625">    if ( nNumNewTGroups ) {</a>
<a name="ln626">        /* create new nNumNewTGroups t-group(s) */</a>
<a name="ln627">        if ( num_t + nNumNewTGroups &gt; max_num_t ) {</a>
<a name="ln628">            ret = -1; /* found too many t-groups */ /*   &lt;BRKPT&gt; */</a>
<a name="ln629">            goto exit_function;</a>
<a name="ln630">        }</a>
<a name="ln631">        /* initialize new t-group(s) */</a>
<a name="ln632">        memset( t_group + num_t, 0, nNumNewTGroups * sizeof(t_group[0]) );</a>
<a name="ln633">        for ( i = 0; i &lt; nNumNewTGroups; i ++ ) {</a>
<a name="ln634">            t_group[num_t+i].nGroupNumber = nNextGroupNumber + i;</a>
<a name="ln635">        }</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    /* At this point:</a>
<a name="ln639">     *   EndPoint[i].nGroupNumber == 0   =&gt; the endpoint atom does not belong to a t-group yet</a>
<a name="ln640">     *   EndPoint[i].nGroupNumber  &gt; 0   =&gt; current t-group ID of the endpoint atom</a>
<a name="ln641">     *   EndPoint[i].nEquNumber      --&gt;    new ID of a tautomeric group of this endpoint atom</a>
<a name="ln642">     *   EndPoint[i].nAtomNumber     --&gt;    number of the endpoint atom</a>
<a name="ln643">     */</a>
<a name="ln644"> </a>
<a name="ln645">     nNumGroups = 0; /* counts the groups to be renumbered */</a>
<a name="ln646">     for ( i = j = 0; i &lt; nNumEndPoints; i ++ ) {</a>
<a name="ln647">         if ( (group = EndPoint[i].nGroupNumber) ) {</a>
<a name="ln648">             if ( group == EndPoint[i].nEquNumber ) {</a>
<a name="ln649">                continue; /* ignore: the endpoint belongs to the same t-group as before */</a>
<a name="ln650">             }</a>
<a name="ln651">             /* save information for renumbering of the existing t-groups */</a>
<a name="ln652">             for ( j = 0; j &lt; nNumGroups; j ++ ) {</a>
<a name="ln653">                 if ( group == nGroupNumber[j] ) {</a>
<a name="ln654">                     if ( EndPoint[i].nEquNumber != nGroupNewNumber[j] ) {</a>
<a name="ln655">                         ret = -1; /* program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln656">                         goto exit_function;</a>
<a name="ln657">                     }</a>
<a name="ln658">                     break;</a>
<a name="ln659">                 }</a>
<a name="ln660">             }</a>
<a name="ln661">             if ( j == nNumGroups ) {</a>
<a name="ln662">                 /* discovered a new t-group number; store it together with its nEquNumber */</a>
<a name="ln663">                 if ( j == MAX_STACK_ARRAY_LEN ) {</a>
<a name="ln664">                    if ( nGroupNewNumber == nGroupNewNumberStackArray ) {</a>
<a name="ln665">                        nGroupNewNumber = (AT_NUMB *) inchi_malloc(nNumEndPoints*sizeof(nGroupNewNumber[0]));</a>
<a name="ln666">                        if ( !nGroupNewNumber ) {</a>
<a name="ln667">                            ret = -1;</a>
<a name="ln668">                            goto exit_function;</a>
<a name="ln669">                        }</a>
<a name="ln670">                        memcpy( nGroupNewNumber, nGroupNewNumberStackArray, nNumGroups*sizeof(nGroupNewNumber[0]));</a>
<a name="ln671">                    }</a>
<a name="ln672">                    if ( nGroupNumber == nGroupNumberStackArray ) {</a>
<a name="ln673">                        nGroupNumber = (AT_NUMB *) inchi_malloc(nNumEndPoints*sizeof(nGroupNumber[0]));</a>
<a name="ln674">                        if ( !nGroupNumber ) {</a>
<a name="ln675">                            ret = -1;</a>
<a name="ln676">                            goto exit_function;</a>
<a name="ln677">                        }</a>
<a name="ln678">                        memcpy( nGroupNumber, nGroupNumberStackArray, nNumGroups*sizeof(nGroupNumber[0]));</a>
<a name="ln679">                    }</a>
<a name="ln680">                 }</a>
<a name="ln681"> </a>
<a name="ln682">                 nGroupNumber[j] = group;  /* old t-group ID */</a>
<a name="ln683">                 nGroupNewNumber[j] = EndPoint[i].nEquNumber; /* new t-group ID */</a>
<a name="ln684">                 nNumGroups ++;</a>
<a name="ln685">             }</a>
<a name="ln686">         } else {</a>
<a name="ln687">            /* add a new endpoint to the newly created or previously existing t-groups */</a>
<a name="ln688">             group = EndPoint[i].nEquNumber;</a>
<a name="ln689">             if ( group &gt;= nNextGroupNumber ) {</a>
<a name="ln690">                 /* get index of a new t-group from equ number */</a>
<a name="ln691">                 j = num_t + group - nNextGroupNumber; /* newly assigned IDs are contiguous */</a>
<a name="ln692">             } else {</a>
<a name="ln693">                 /* old t-group */</a>
<a name="ln694">                 if ( j &gt;= num_t || group != t_group[j].nGroupNumber ) {</a>
<a name="ln695">                     /* search only if j is not a needed group index */</a>
<a name="ln696">                     for ( j = 0; j &lt; num_t; j ++ ) {</a>
<a name="ln697">                         if ( group == t_group[j].nGroupNumber )</a>
<a name="ln698">                             break;</a>
<a name="ln699">                     }</a>
<a name="ln700">                     if ( j == num_t ) {</a>
<a name="ln701">                         ret = -1; /* program error: t-group not found */ /*   &lt;BRKPT&gt; */</a>
<a name="ln702">                         goto exit_function;</a>
<a name="ln703">                     }</a>
<a name="ln704">                 }</a>
<a name="ln705">             }</a>
<a name="ln706">             /* add aton to existing or new t-group */</a>
<a name="ln707">             t_group[j].nNumEndpoints ++;</a>
<a name="ln708">             for ( k = 0; k &lt; (int)(sizeof(t_group-&gt;num)/sizeof(t_group-&gt;num[0])); k ++ )</a>
<a name="ln709">                 t_group[j].num[k]    += EndPoint[i].num[k];</a>
<a name="ln710">             for ( k = 0; k &lt; (int)(sizeof(t_group-&gt;num_DA)/sizeof(t_group-&gt;num_DA[0])); k ++ )</a>
<a name="ln711">                 t_group[j].num_DA[k] += EndPoint[i].num_DA[k];</a>
<a name="ln712">             /* mark endpoint */</a>
<a name="ln713">             at[EndPoint[i].nAtomNumber].endpoint = group;</a>
<a name="ln714">             difference ++;</a>
<a name="ln715">         }</a>
<a name="ln716">     }</a>
<a name="ln717"> </a>
<a name="ln718">     difference += nNumGroups;</a>
<a name="ln719">     num_t      += nNumNewTGroups;</a>
<a name="ln720">     if ( !difference ) {</a>
<a name="ln721">         ret = 0; /* nothing to do. Not necessarily a program error: happens if all EndPoint[i].nGroupNumber==EndPoint[i].nEquNumber  */</a>
<a name="ln722">         goto exit_function;</a>
<a name="ln723">     }</a>
<a name="ln724">     </a>
<a name="ln725">     if ( nNumGroups ) {</a>
<a name="ln726">         /* prepare for renumbering: find max t-group number */</a>
<a name="ln727">         for ( i = 0, nNextGroupNumber = 0; i &lt;  num_t; i ++ ) {</a>
<a name="ln728">             if ( nNextGroupNumber &lt; t_group[i].nGroupNumber ) {</a>
<a name="ln729">                 nNextGroupNumber = t_group[i].nGroupNumber;</a>
<a name="ln730">             }</a>
<a name="ln731">         }</a>
<a name="ln732">     }</a>
<a name="ln733">     /* renumber and merge t-groups */</a>
<a name="ln734">     for ( i = 0; i &lt; nNumGroups; i ++ ) {</a>
<a name="ln735">         int i1, i2;</a>
<a name="ln736">         AT_NUMB group1 = nGroupNumber[i];</a>
<a name="ln737">         AT_NUMB group2 = nGroupNewNumber[i];</a>
<a name="ln738">         /* add group1 to group2, then delete group1. */</a>
<a name="ln739">         for ( j = 0, i1 = i2 = -1; j &lt; num_t &amp;&amp; (i1 &lt; 0 || i2 &lt; 0); j ++ ) {</a>
<a name="ln740">             if ( i1 &lt; 0 &amp;&amp; group1 == t_group[j].nGroupNumber )</a>
<a name="ln741">                 i1 = j;</a>
<a name="ln742">             if ( i2 &lt; 0 &amp;&amp; group2 == t_group[j].nGroupNumber )</a>
<a name="ln743">                 i2 = j;</a>
<a name="ln744">         }</a>
<a name="ln745">         if ( i1 &lt; 0 || i2 &lt; 0 ) {</a>
<a name="ln746">             ret = -1; /* program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln747">             goto exit_function;</a>
<a name="ln748">         }</a>
<a name="ln749">         /*  add t_group[i1] to t_group[i2] and remove t_group[i1] */</a>
<a name="ln750">         for ( k = 0; k &lt; (int)(sizeof(t_group-&gt;num)/sizeof(t_group-&gt;num[0])); k ++ )</a>
<a name="ln751">             t_group[i2].num[k]    += t_group[i1].num[k];</a>
<a name="ln752">         for ( k = 0; k &lt; (int)(sizeof(t_group-&gt;num_DA)/sizeof(t_group-&gt;num_DA[0])); k ++ )</a>
<a name="ln753">             t_group[i2].num_DA[k] += t_group[i1].num_DA[k];</a>
<a name="ln754">         t_group[i2].nNumEndpoints += t_group[i1].nNumEndpoints;</a>
<a name="ln755">         num_t --;</a>
<a name="ln756">         if ( num_t &gt; i1 ) {</a>
<a name="ln757">             memmove( t_group+i1, t_group+i1+1, ( num_t - i1)*sizeof(t_group[0]) );</a>
<a name="ln758">         }</a>
<a name="ln759">     }</a>
<a name="ln760"> </a>
<a name="ln761">     if ( nNumGroups ) {</a>
<a name="ln762">         /* there are groups to merge */</a>
<a name="ln763">         if ( nNextGroupNumber &gt;= MAX_STACK_ARRAY_LEN ) {</a>
<a name="ln764">             nNewTgNumber = (AT_NUMB *) inchi_malloc((nNextGroupNumber+1)*sizeof(*nNewTgNumber));</a>
<a name="ln765">             if ( !nNewTgNumber ) {</a>
<a name="ln766">                 ret = -1;</a>
<a name="ln767">                 goto exit_function; /* error: out of RAM */</a>
<a name="ln768">             }</a>
<a name="ln769">         }</a>
<a name="ln770">         memset( nNewTgNumber, 0, (nNextGroupNumber+1)*sizeof(*nNewTgNumber) );</a>
<a name="ln771">         for ( i = 0; i &lt; num_t; i ++ ) {</a>
<a name="ln772">             nNewTgNumber[t_group[i].nGroupNumber] = i+1; /* new t-group numbers */</a>
<a name="ln773">         }</a>
<a name="ln774">         for ( j = 0; j &lt; nNumGroups; j ++ ) {</a>
<a name="ln775">             if ( !nNewTgNumber[nGroupNumber[j]] &amp;&amp; nNewTgNumber[nGroupNewNumber[j]] ) {</a>
<a name="ln776">                     nNewTgNumber[nGroupNumber[j]] = nNewTgNumber[nGroupNewNumber[j]];</a>
<a name="ln777">             } else {</a>
<a name="ln778">                 ret = -1; /* program error: all new numbers must have been marked */</a>
<a name="ln779">                 goto exit_function;</a>
<a name="ln780">             }</a>
<a name="ln781">         }</a>
<a name="ln782">         /* renumber t-groups */</a>
<a name="ln783">         for ( i = 0; i &lt; num_t; i ++ ) {</a>
<a name="ln784">             t_group[i].nGroupNumber = nNewTgNumber[t_group[i].nGroupNumber];</a>
<a name="ln785">         }</a>
<a name="ln786">#if ( bRELEASE_VERSION != 1 )</a>
<a name="ln787">         /* Check: debug only */</a>
<a name="ln788">         for ( i = 1; i &lt; num_t; i ++ ) {</a>
<a name="ln789">             if ( 1 != t_group[i].nGroupNumber - t_group[i-1].nGroupNumber ) {</a>
<a name="ln790">                 ret = -1; /* debug */</a>
<a name="ln791">                 goto exit_function;</a>
<a name="ln792">             }</a>
<a name="ln793">         }</a>
<a name="ln794">#endif</a>
<a name="ln795">         /* renumber endpoints */</a>
<a name="ln796">         for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln797">             if ( (group = at[i].endpoint) ) {</a>
<a name="ln798">                 if ( !(at[i].endpoint = nNewTgNumber[group]) || nNextGroupNumber &lt;= nNewTgNumber[group] ) {</a>
<a name="ln799">                     ret = -1; /* program error */</a>
<a name="ln800">                     goto exit_function;</a>
<a name="ln801">                 }</a>
<a name="ln802">             }</a>
<a name="ln803">         }</a>
<a name="ln804">     }</a>
<a name="ln805">     if ( nNewTgNumber != nNewTgNumberStackArray ) {</a>
<a name="ln806">         inchi_free( nNewTgNumber );</a>
<a name="ln807">         nNewTgNumber = nNewTgNumberStackArray;</a>
<a name="ln808">     }</a>
<a name="ln809">     if ( nGroupNumber != nGroupNumberStackArray ) {</a>
<a name="ln810">         inchi_free(nGroupNumber);</a>
<a name="ln811">         nGroupNumber = nGroupNumberStackArray;</a>
<a name="ln812">     }</a>
<a name="ln813">     if ( nGroupNewNumber != nGroupNewNumberStackArray ) {</a>
<a name="ln814">         inchi_free( nGroupNewNumber );</a>
<a name="ln815">         nGroupNewNumber = nGroupNewNumberStackArray;</a>
<a name="ln816">     }</a>
<a name="ln817">     if ( !t_group_info-&gt;tGroupNumber ) {</a>
<a name="ln818">        t_group_info-&gt;tGroupNumber = (AT_NUMB *) inchi_malloc(2*max_num_t*sizeof(t_group_info-&gt;tGroupNumber[0])); </a>
<a name="ln819">        if ( !t_group_info-&gt;tGroupNumber ) {</a>
<a name="ln820">            ret = -1;</a>
<a name="ln821">            goto exit_function;</a>
<a name="ln822">        }</a>
<a name="ln823">     }</a>
<a name="ln824">     /* fill out t-group index 2004-02-27 */</a>
<a name="ln825">     memset( t_group_info-&gt;tGroupNumber, 0, 2*max_num_t*sizeof(t_group_info-&gt;tGroupNumber[0]) );</a>
<a name="ln826">     for ( i = 0; i &lt; num_t; i ++ ) {</a>
<a name="ln827">         if ( t_group[i].nNumEndpoints &amp;&amp; t_group[i].nGroupNumber )</a>
<a name="ln828">            t_group_info-&gt;tGroupNumber[t_group[i].nGroupNumber] = i+1;</a>
<a name="ln829">     }</a>
<a name="ln830"> </a>
<a name="ln831">     if ( pBNS &amp;&amp; (pBNS-&gt;tot_st_cap == pBNS-&gt;tot_st_flow || ALWAYS_ADD_TG_ON_THE_FLY) ) {</a>
<a name="ln832">        T_GROUP_INFO tgi;</a>
<a name="ln833">        int ret_bns;</a>
<a name="ln834">        memset( &amp;tgi, 0, sizeof(tgi) );</a>
<a name="ln835">        tgi.num_t_groups = num_t;</a>
<a name="ln836">        tgi.t_group = t_group;</a>
<a name="ln837">#if ( KETO_ENOL_TAUT == 1 )</a>
<a name="ln838">        tgi.bTautFlags |= (t_group_info-&gt;bTautFlags &amp; TG_FLAG_KETO_ENOL_TAUT); /* needed in AddTGroups2BnStruct() */</a>
<a name="ln839">#endif</a>
<a name="ln840">        /* reinitialize BN Structure */</a>
<a name="ln841">        ret_bns = ReInitBnStruct( pBNS, at, num_atoms, 0 );</a>
<a name="ln842">        if ( IS_BNS_ERROR( ret_bns ) ) {</a>
<a name="ln843">            return ret_bns;</a>
<a name="ln844">        }</a>
<a name="ln845">        if ( *pBNS-&gt;pbTautFlags &amp; TG_FLAG_MOVE_POS_CHARGES ) {</a>
<a name="ln846">            /* set new charge groups */</a>
<a name="ln847">            ret_bns = AddCGroups2BnStruct( pBNS, at, num_atoms, cgi );</a>
<a name="ln848">            if ( IS_BNS_ERROR( ret_bns ) ) {</a>
<a name="ln849">                return ret_bns;</a>
<a name="ln850">            }</a>
<a name="ln851">        }</a>
<a name="ln852">        /* set new tautomeric groups */</a>
<a name="ln853">        ret_bns = AddTGroups2BnStruct( pBNS, at, num_atoms, &amp;tgi );</a>
<a name="ln854">        if ( IS_BNS_ERROR( ret_bns ) ) {</a>
<a name="ln855">            return ret_bns;</a>
<a name="ln856">        }</a>
<a name="ln857">     }</a>
<a name="ln858"> </a>
<a name="ln859">     *pnum_t = num_t;</a>
<a name="ln860">     return difference;</a>
<a name="ln861"> </a>
<a name="ln862">exit_function:</a>
<a name="ln863">     if ( nNewTgNumber != nNewTgNumberStackArray ) {</a>
<a name="ln864">         inchi_free( nNewTgNumber );</a>
<a name="ln865">     }</a>
<a name="ln866">     if ( nGroupNumber != nGroupNumberStackArray ) {</a>
<a name="ln867">         inchi_free(nGroupNumber);</a>
<a name="ln868">     }</a>
<a name="ln869">     if ( nGroupNewNumber != nGroupNewNumberStackArray ) {</a>
<a name="ln870">         inchi_free( nGroupNewNumber );</a>
<a name="ln871">     }</a>
<a name="ln872">     return ret;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">/*****************************************************************************</a>
<a name="ln878"> * Change non-alternating and non-tautomeric bonds</a>
<a name="ln879"> * (that is, single and double bonds) to tautomeric</a>
<a name="ln880"> *****************************************************************************/</a>
<a name="ln881">int SetTautomericBonds( inp_ATOM *at, int nNumBondPos, T_BONDPOS *BondPos )</a>
<a name="ln882">{</a>
<a name="ln883">    int k, n;</a>
<a name="ln884">    for ( k = n = 0; k &lt; nNumBondPos; k ++ ) {</a>
<a name="ln885">        int neighbor_index = BondPos[k].neighbor_index;</a>
<a name="ln886">        int center         = BondPos[k].nAtomNumber;</a>
<a name="ln887">        int bond_mark      = at[center].bond_type[neighbor_index];</a>
<a name="ln888">        int bond_type      = bond_mark &amp; ~BOND_MARK_ALL;</a>
<a name="ln889">        int neighbor;</a>
<a name="ln890">#if ( REPLACE_ALT_WITH_TAUT == 1 )</a>
<a name="ln891">        if ( bond_type != BOND_TAUTOM )</a>
<a name="ln892">#else</a>
<a name="ln893">        if ( bond_type != BOND_ALTERN &amp;&amp; bond_type != BOND_TAUTOM )</a>
<a name="ln894">#endif</a>
<a name="ln895">        {</a>
<a name="ln896">            int ii;</a>
<a name="ln897">            /*  change bond type to BOND_TAUTOM presering higher bits marks */</a>
<a name="ln898">            bond_type = (bond_mark &amp; BOND_MARK_ALL) | BOND_TAUTOM;</a>
<a name="ln899">            /*  change center-neighbor bond */</a>
<a name="ln900">            at[center].bond_type[neighbor_index] = bond_type;</a>
<a name="ln901">            neighbor = at[center].neighbor[neighbor_index];</a>
<a name="ln902">            for ( ii = 0; ii &lt; at[neighbor].valence; ii ++ ) {</a>
<a name="ln903">                if ( at[neighbor].neighbor[ii] == center ) {</a>
<a name="ln904">                    /*  neighbor-center bond found */</a>
<a name="ln905">                    at[neighbor].bond_type[ii] = bond_type;</a>
<a name="ln906">                    break;</a>
<a name="ln907">                }</a>
<a name="ln908">            }</a>
<a name="ln909">            n ++;</a>
<a name="ln910">        }</a>
<a name="ln911">    }</a>
<a name="ln912">    return n;</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">/*****************************************************************************/</a>
<a name="ln918">int GetNeutralRepsIfNeeded( AT_NUMB *pri, AT_NUMB *prj, inp_ATOM *at, int num_atoms, </a>
<a name="ln919">                           T_ENDPOINT *EndPoint, int nNumEndPoints, C_GROUP_INFO *cgi )</a>
<a name="ln920">{</a>
<a name="ln921">    AT_NUMB ri = *pri;</a>
<a name="ln922">    AT_NUMB rj = *prj;</a>
<a name="ln923">    int     i, k;</a>
<a name="ln924">    AT_NUMB c_point, endpoint, r;</a>
<a name="ln925"> </a>
<a name="ln926">    if ( (c_point = at[ri].c_point) &amp;&amp; (c_point == at[rj].c_point) &amp;&amp; </a>
<a name="ln927">         (at[ri].charge == 1 || at[rj].charge == 1) &amp;&amp; cgi &amp;&amp; cgi-&gt;num_c_groups &gt; 0 ) {</a>
<a name="ln928">        /* at[ri] and at[rj] belong to the same charge group, at least one is charged */</a>
<a name="ln929">        /* MS VC++ 2005 reports unreachable code here ??? */</a>
<a name="ln930">        for ( k = 0; k &lt; cgi-&gt;num_c_groups; k ++ ) {</a>
<a name="ln931">            if ( cgi-&gt;c_group[k].nGroupNumber == c_point ) {</a>
<a name="ln932">                /* cgi-&gt;c_group[k] is found to be this charge group */</a>
<a name="ln933">                if ( cgi-&gt;c_group[k].num_CPoints - cgi-&gt;c_group[k].num[0] &lt; 2 ) {</a>
<a name="ln934">                    /* Only one neutral in the c-group: we will not be able to neutralize both</a>
<a name="ln935">                       when looking for the alt path to discover the tautomerism.</a>
<a name="ln936">                       Therefore we need to find a neutral t-group representative */</a>
<a name="ln937">                    /* at[rj] */</a>
<a name="ln938">                    if ( (endpoint = at[rj].endpoint) ) {</a>
<a name="ln939">                        for ( i = 0; i &lt; nNumEndPoints; i ++ ) {</a>
<a name="ln940">                            if ( (r=EndPoint[i].nAtomNumber) == *prj )</a>
<a name="ln941">                                continue; /* ignore at[*prj] */</a>
<a name="ln942">                            if ( at[r].endpoint != endpoint )</a>
<a name="ln943">                                continue; /* at[r] does not belong to the same t-group as at[*prj]; ignore the atom */</a>
<a name="ln944">                            if ( !at[r].c_point ) {</a>
<a name="ln945">                                rj = r; /* found a neutral t-group representative */</a>
<a name="ln946">                                break;</a>
<a name="ln947">                            }</a>
<a name="ln948">                            if ( at[r].c_point != c_point &amp;&amp; c_point == at[rj].c_point ) {</a>
<a name="ln949">                                /* replace only once because of (c_point == at[rj].c_point) condition  */</a>
<a name="ln950">                                rj = r;</a>
<a name="ln951">                            }</a>
<a name="ln952">                        }</a>
<a name="ln953">                        if ( rj == *prj /*&amp;&amp; at[ri].endpoint*/ ) {</a>
<a name="ln954">                            /* !!! &quot;&amp;&amp; at[ri].endpoint&quot;: only between 2 t-groups 2004-02-27;</a>
<a name="ln955">                                the change disabled due to undiscovered yet possibility of ambiguity*/</a>
<a name="ln956">                            /* no replacement has been found in EndPoint[]; try all atoms in the t-group */</a>
<a name="ln957">                            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln958">                                if ( at[i].endpoint != endpoint )</a>
<a name="ln959">                                    continue;</a>
<a name="ln960">                                if ( i == (int)*prj )</a>
<a name="ln961">                                    continue;</a>
<a name="ln962">                                if ( !at[i].c_point ) {</a>
<a name="ln963">                                    rj = (AT_NUMB)i; /* found neutral t-group representative */</a>
<a name="ln964">                                    break;</a>
<a name="ln965">                                }</a>
<a name="ln966">                                if ( at[i].c_point != c_point &amp;&amp; c_point == at[rj].c_point ) {</a>
<a name="ln967">                                    /* replace only once */</a>
<a name="ln968">                                    rj = (AT_NUMB)i;</a>
<a name="ln969">                                }</a>
<a name="ln970">                            }</a>
<a name="ln971">                        }</a>
<a name="ln972">                    }</a>
<a name="ln973">                    /* at[ri] */</a>
<a name="ln974">                    if ( (endpoint = at[ri].endpoint) ) {</a>
<a name="ln975">                        for ( i = 0; i &lt; nNumEndPoints; i ++ ) {</a>
<a name="ln976">                            if ( (r=EndPoint[i].nAtomNumber) == *pri )</a>
<a name="ln977">                                continue;</a>
<a name="ln978">                            if ( at[r].endpoint != endpoint )</a>
<a name="ln979">                                continue;</a>
<a name="ln980">                            if ( !at[r].c_point ) {</a>
<a name="ln981">                                ri = r; /* found neutral t-group representative */</a>
<a name="ln982">                                break;</a>
<a name="ln983">                            }</a>
<a name="ln984">                            if ( at[r].c_point != c_point &amp;&amp; c_point == at[ri].c_point &amp;&amp;</a>
<a name="ln985">                                 at[r].c_point != at[rj].c_point ) {</a>
<a name="ln986">                                /* replace only once */</a>
<a name="ln987">                                ri = r;</a>
<a name="ln988">                            }</a>
<a name="ln989">                        }</a>
<a name="ln990">                        if ( ri == *pri &amp;&amp; at[rj].endpoint ) {</a>
<a name="ln991">                            /* !!! &quot;&amp;&amp; at[rj].endpoint&quot;: only between 2 t-groups 2004-02-27;</a>
<a name="ln992">                               the change disabled due to undiscovered yet possibility of ambiguity */</a>
<a name="ln993">                            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln994">                                if ( at[i].endpoint != endpoint )</a>
<a name="ln995">                                    continue;</a>
<a name="ln996">                                if ( i == (int)*pri )</a>
<a name="ln997">                                    continue;</a>
<a name="ln998">                                if ( !at[i].c_point ) {</a>
<a name="ln999">                                    ri = (AT_NUMB)i; /* found neutral t-group representative */</a>
<a name="ln1000">                                    break;</a>
<a name="ln1001">                                }</a>
<a name="ln1002">                                if ( at[i].c_point != c_point &amp;&amp; c_point == at[ri].c_point &amp;&amp;</a>
<a name="ln1003">                                     at[i].c_point != at[rj].c_point) {</a>
<a name="ln1004">                                    /* replace only once */</a>
<a name="ln1005">                                    ri = (AT_NUMB)i;</a>
<a name="ln1006">                                }</a>
<a name="ln1007">                            }</a>
<a name="ln1008">                        }</a>
<a name="ln1009">                    }</a>
<a name="ln1010"> </a>
<a name="ln1011">                }</a>
<a name="ln1012">            }</a>
<a name="ln1013">            break;</a>
<a name="ln1014">        }</a>
<a name="ln1015">        *prj = rj;</a>
<a name="ln1016">        *pri = ri;</a>
<a name="ln1017">    }</a>
<a name="ln1018">    return 0;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021"> </a>
<a name="ln1022"> </a>
<a name="ln1023">/*****************************************************************************/</a>
<a name="ln1024">int FindAccessibleEndPoints( T_ENDPOINT *EndPoint, int *nNumEndPoints, T_BONDPOS *BondPos, int *nNumBondPos,</a>
<a name="ln1025">                         struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD,</a>
<a name="ln1026">                         inp_ATOM *at, int num_atoms, C_GROUP_INFO *cgi, int taut_mode )</a>
<a name="ln1027">{</a>
<a name="ln1028">    AT_NUMB nTGroupRepresenative[MAXVAL], nTGroupEqu[MAXVAL], nTGEndPointNo[MAXVAL], ri, rj;</a>
<a name="ln1029">    AT_NUMB nCurTGroupNumber, nMaxTGroupNumber, nNumTgroupNumbers, nMaxEquNumber;</a>
<a name="ln1030">    int   i, j, k, nNumDiffTGroupNumbers = 0, nNumFoundEqu, nErr;</a>
<a name="ln1031">    </a>
<a name="ln1032">    if ( *nNumEndPoints != *nNumBondPos )</a>
<a name="ln1033">        return 0;</a>
<a name="ln1034">    /* collect all group numbers. Fill EndPoint[i].nEquNumber */</a>
<a name="ln1035">    for ( i = 0; i &lt; *nNumEndPoints; i ++ ) {</a>
<a name="ln1036">        nCurTGroupNumber = EndPoint[i].nEquNumber = EndPoint[i].nGroupNumber; /* initial equivalence */</a>
<a name="ln1037">        if ( nCurTGroupNumber ) {</a>
<a name="ln1038">            /* found endpoint that already belongs to a t-group */</a>
<a name="ln1039">            for ( j = 0; j &lt; nNumDiffTGroupNumbers; j ++ ) {</a>
<a name="ln1040">                if ( nTGroupEqu[j] == nCurTGroupNumber )</a>
<a name="ln1041">                    break;</a>
<a name="ln1042">            }</a>
<a name="ln1043">            if ( j == nNumDiffTGroupNumbers ) {</a>
<a name="ln1044">                nTGroupRepresenative[nNumDiffTGroupNumbers] = EndPoint[i].nAtomNumber;</a>
<a name="ln1045">                nTGroupEqu[nNumDiffTGroupNumbers]           = EndPoint[i].nGroupNumber;</a>
<a name="ln1046">                nTGEndPointNo[nNumDiffTGroupNumbers]        = i;</a>
<a name="ln1047">                nNumDiffTGroupNumbers ++;</a>
<a name="ln1048">            }</a>
<a name="ln1049">        }</a>
<a name="ln1050">    }</a>
<a name="ln1051"> </a>
<a name="ln1052"> </a>
<a name="ln1053">    /* check whether each pair belongs to the same t-group and establish the equivalence(s) */</a>
<a name="ln1054">    for ( i = 0, nNumFoundEqu=0; i &lt; nNumDiffTGroupNumbers; i ++ ) {</a>
<a name="ln1055">        for ( j = i+1; j &lt; nNumDiffTGroupNumbers; j ++ ) {</a>
<a name="ln1056">            ri = nTGroupRepresenative[i];</a>
<a name="ln1057">            rj = nTGroupRepresenative[j];</a>
<a name="ln1058">            /* both at[ri] and at[rj] are known to belong to tautomeric groups */</a>
<a name="ln1059">            GetNeutralRepsIfNeeded( &amp;ri, &amp;rj, at, num_atoms, EndPoint, *nNumEndPoints, cgi );</a>
<a name="ln1060">            nErr = bExistsAnyAltPath( pBNS, pBD, at, num_atoms, ri, rj, taut_mode );</a>
<a name="ln1061">            if ( IS_BNS_ERROR(nErr) )</a>
<a name="ln1062">                return nErr;</a>
<a name="ln1063">            if ( 0 == nErr )</a>
<a name="ln1064">                continue; /* alt path between at[ri] and at[rj] not found */</a>
<a name="ln1065">            nCurTGroupNumber = inchi_min( nTGroupEqu[i], nTGroupEqu[j] );</a>
<a name="ln1066">            nMaxTGroupNumber = inchi_max( nTGroupEqu[i], nTGroupEqu[j] );</a>
<a name="ln1067">            for ( k = 0; k &lt; nNumDiffTGroupNumbers; k ++ ) {</a>
<a name="ln1068">                if ( nTGroupEqu[k]==nMaxTGroupNumber ) {</a>
<a name="ln1069">                    nTGroupEqu[k] = nCurTGroupNumber;</a>
<a name="ln1070">                    nNumFoundEqu ++;</a>
<a name="ln1071">                }</a>
<a name="ln1072">            }</a>
<a name="ln1073">            for ( k = 0; k &lt; *nNumEndPoints; k ++ ) {</a>
<a name="ln1074">                if ( EndPoint[k].nEquNumber == nMaxTGroupNumber ) {</a>
<a name="ln1075">                    EndPoint[k].nEquNumber = nCurTGroupNumber;</a>
<a name="ln1076">                }</a>
<a name="ln1077">            }</a>
<a name="ln1078">        }</a>
<a name="ln1079">    }</a>
<a name="ln1080">    if ( nNumFoundEqu ) {</a>
<a name="ln1081">        /* leave in only non-equivalent representatives */</a>
<a name="ln1082">        for ( i = 1, k = 0; i &lt; nNumDiffTGroupNumbers; i ++ ) {</a>
<a name="ln1083">            for ( j = 0; j &lt; i; j ++ ) {</a>
<a name="ln1084">                if ( nTGroupEqu[j] == nTGroupEqu[i] ) {</a>
<a name="ln1085">                    nTGroupEqu[i] = 0;  /* i &gt; j; mark equivalent for removal*/</a>
<a name="ln1086">                    break;</a>
<a name="ln1087">                }</a>
<a name="ln1088">            }</a>
<a name="ln1089">        }</a>
<a name="ln1090">        for ( i = j = 0; i &lt; nNumDiffTGroupNumbers; i ++ ) {</a>
<a name="ln1091">            if ( nTGroupEqu[i] ) {</a>
<a name="ln1092">                if ( i != j ) { /* remove the marked */</a>
<a name="ln1093">                    nTGroupEqu[j]           = nTGroupEqu[i];</a>
<a name="ln1094">                    nTGroupRepresenative[j] = nTGroupRepresenative[i];</a>
<a name="ln1095">                    nTGEndPointNo[j]        = nTGEndPointNo[i];</a>
<a name="ln1096">                }</a>
<a name="ln1097">                j ++;</a>
<a name="ln1098">            }</a>
<a name="ln1099">        }</a>
<a name="ln1100">        nNumDiffTGroupNumbers = j; /* number of known t-group representatives */</a>
<a name="ln1101">    }</a>
<a name="ln1102">    /* collect endpoints that have not been assigned to t-groups */</a>
<a name="ln1103">    for ( i = 0, j = nNumDiffTGroupNumbers; i &lt; *nNumEndPoints; i ++ ) {</a>
<a name="ln1104">        if ( EndPoint[i].nEquNumber )</a>
<a name="ln1105">            continue;</a>
<a name="ln1106">        nTGroupEqu[j] = 0;</a>
<a name="ln1107">        nTGroupRepresenative[j] = EndPoint[i].nAtomNumber;</a>
<a name="ln1108">        nTGEndPointNo[j]        = i;</a>
<a name="ln1109">        j ++;</a>
<a name="ln1110"> </a>
<a name="ln1111">    }</a>
<a name="ln1112">    nNumTgroupNumbers = j;</a>
<a name="ln1113">    nMaxEquNumber = num_atoms + 1; /* impossible atom or t-group number */</a>
<a name="ln1114"> </a>
<a name="ln1115">    /* check whether each pair belongs to the same group and establish the equivalence(s) */</a>
<a name="ln1116">    for ( i = 0, nNumFoundEqu=0; i &lt; nNumTgroupNumbers; i ++ ) {</a>
<a name="ln1117">        for ( j = i+1; j &lt; nNumTgroupNumbers; j ++ ) {</a>
<a name="ln1118">            if ( (nTGroupEqu[i] != nTGroupEqu[j] &amp;&amp; (i&gt;=nNumDiffTGroupNumbers || j&gt;=nNumDiffTGroupNumbers)) ||</a>
<a name="ln1119">                 /* equivalence of a t-group and a non-t-group atom */</a>
<a name="ln1120">                 (!nTGroupEqu[i] &amp;&amp; !nTGroupEqu[j])</a>
<a name="ln1121">                 /* equivalence of two non-t-group atoms */</a>
<a name="ln1122">               ) {</a>
<a name="ln1123">                ri = nTGroupRepresenative[i];</a>
<a name="ln1124">                rj = nTGroupRepresenative[j];</a>
<a name="ln1125">                /*------------------------------!!!---------------------------------------------  </a>
<a name="ln1126">                    Explanation why GetNeutralRepsIfNeeded() may need to be changed 2004-02-27</a>
<a name="ln1127">                    The change has been disabled due to undiscovered yet possibility of ambiguity</a>
<a name="ln1128">                    to search for neutral only among EndPoint[] in case taut-not_taut pairs</a>
<a name="ln1129">                </a>
<a name="ln1130">                    Counterexample:   O=C-NH(+)=C-NH2</a>
<a name="ln1131">                                      1   2       3</a>
<a name="ln1132"> </a>
<a name="ln1133">                    Has already been found: 2-3 (+)-charge exchange</a>
<a name="ln1134">                                            1-2 tautomerism (charge removed to 3)</a>
<a name="ln1135">                    Now testing: 2-3 tautomerism. If not commented out,</a>
<a name="ln1136">                       GetNeutralRepsIfNeeded() would replace 2-3 test with 1-3 test because:</a>
<a name="ln1137">                        o Charge group has only one neutral and both 2 and 3 belong to it,</a>
<a name="ln1138">                          therefore we cannot neutralize both; search for neutral representative;</a>
<a name="ln1139">                        o Since 1 and 2 belong to the same t-group and 1 is neutral,</a>
<a name="ln1140">                          test 1-3 instead of 2-3.</a>
<a name="ln1141">                    This breaks our condition:</a>
<a name="ln1142">                        Test tautomeric H movement only between neutral atoms.</a>
<a name="ln1143">                 -----------------------------------------------------------------------------*/</a>
<a name="ln1144">                GetNeutralRepsIfNeeded( &amp;ri, &amp;rj, at, num_atoms, EndPoint, *nNumEndPoints, cgi );</a>
<a name="ln1145">                </a>
<a name="ln1146">                nErr = bExistsAnyAltPath( pBNS, pBD, at, num_atoms, ri, rj, taut_mode );</a>
<a name="ln1147">                if ( IS_BNS_ERROR(nErr) )</a>
<a name="ln1148">                    return nErr;</a>
<a name="ln1149">                if ( nErr &lt;= 0 )</a>
<a name="ln1150">                    continue;</a>
<a name="ln1151">                if ( nTGroupEqu[i] &amp;&amp; nTGroupEqu[j] ) {</a>
<a name="ln1152">                    /* found equivalence of two t-groups; at least one of them must be a new one */</a>
<a name="ln1153">                    nCurTGroupNumber = inchi_min( nTGroupEqu[i], nTGroupEqu[j] );</a>
<a name="ln1154">                    nMaxTGroupNumber = inchi_max( nTGroupEqu[i], nTGroupEqu[j] );</a>
<a name="ln1155">                    for ( k = 0; k &lt; nNumTgroupNumbers; k ++ ) {</a>
<a name="ln1156">                        if ( nTGroupEqu[k]==nMaxTGroupNumber ) {</a>
<a name="ln1157">                            nTGroupEqu[k] = nCurTGroupNumber;</a>
<a name="ln1158">                            nNumFoundEqu ++;</a>
<a name="ln1159">                        }</a>
<a name="ln1160">                    }</a>
<a name="ln1161">                    for ( k = 0; k &lt; *nNumEndPoints; k ++ ) {</a>
<a name="ln1162">                        if ( EndPoint[k].nEquNumber == nMaxTGroupNumber ) {</a>
<a name="ln1163">                            EndPoint[k].nEquNumber = nCurTGroupNumber;</a>
<a name="ln1164">                        }</a>
<a name="ln1165">                    }</a>
<a name="ln1166">                } else</a>
<a name="ln1167">                if ( nTGroupEqu[i] ) { /* extend existing t-group */</a>
<a name="ln1168">                    nTGroupEqu[j] = nTGroupEqu[i];</a>
<a name="ln1169">                    EndPoint[nTGEndPointNo[j]].nEquNumber = nTGroupEqu[i];</a>
<a name="ln1170"> </a>
<a name="ln1171">                } else</a>
<a name="ln1172">                if ( nTGroupEqu[j] ) { /* extend existing t-group */</a>
<a name="ln1173">                    nTGroupEqu[i] = nTGroupEqu[j];</a>
<a name="ln1174">                    EndPoint[nTGEndPointNo[i]].nEquNumber = nTGroupEqu[j];</a>
<a name="ln1175"> </a>
<a name="ln1176">                } else { /* establis a new t-group */</a>
<a name="ln1177">                    nTGroupEqu[i] =</a>
<a name="ln1178">                    nTGroupEqu[j] = nMaxEquNumber; /* assign a fict. ID to establish equivalence */</a>
<a name="ln1179">                    EndPoint[nTGEndPointNo[i]].nEquNumber =</a>
<a name="ln1180">                    EndPoint[nTGEndPointNo[j]].nEquNumber = nMaxEquNumber;</a>
<a name="ln1181">                    nMaxEquNumber ++;</a>
<a name="ln1182">                }</a>
<a name="ln1183">            }</a>
<a name="ln1184">        }</a>
<a name="ln1185">    }</a>
<a name="ln1186">    /* eliminate endpoints and bonds that do not belong to t-group(s) </a>
<a name="ln1187">       (they have not been found connected by an alt path to any other endpoint)</a>
<a name="ln1188">    */</a>
<a name="ln1189">    for ( i = 0, j = 0; i &lt; *nNumEndPoints; i ++ ) {</a>
<a name="ln1190">        if ( EndPoint[i].nEquNumber ) {</a>
<a name="ln1191">#if ( IGNORE_SINGLE_ENDPOINTS == 1 )  /* 1-28-2003 */</a>
<a name="ln1192">            for ( k = 0, nNumFoundEqu = 0; k &lt; *nNumEndPoints; k ++ ) {</a>
<a name="ln1193">                nNumFoundEqu += (EndPoint[i].nEquNumber == EndPoint[k].nEquNumber);</a>
<a name="ln1194">            }</a>
<a name="ln1195">            if ( nNumFoundEqu &lt;= 1 ) { /* one time it is equal to itself when i == k above */</a>
<a name="ln1196">                /* if EndPoint[i] is not &quot;equivalent&quot; to any other EndPoint then ignore it */</a>
<a name="ln1197">                continue;</a>
<a name="ln1198">            }</a>
<a name="ln1199">#endif</a>
<a name="ln1200">            if ( i != j ) { /* save endpoints that are found to be connected to other endpoints by alt paths */</a>
<a name="ln1201">                EndPoint[j] = EndPoint[i];</a>
<a name="ln1202">                BondPos[j]  = BondPos[i];</a>
<a name="ln1203">            }</a>
<a name="ln1204">            j ++;</a>
<a name="ln1205">        }</a>
<a name="ln1206">    }</a>
<a name="ln1207"> </a>
<a name="ln1208">#if ( IGNORE_SINGLE_ENDPOINTS != 1 )  /* 1-28-2003 */</a>
<a name="ln1209">    /* Do not allow a centerpoint to have only one tautomeric bond */</a>
<a name="ln1210">    /* Hack: we may have only one centerpoint */</a>
<a name="ln1211">    /* BondPos[*].nAtomNumber are centerpoints */</a>
<a name="ln1212">    if ( j == 1 ) {</a>
<a name="ln1213">        /* check if there exist other centerpoint neighbors</a>
<a name="ln1214">         * connected to it by another tautomeric-bond</a>
<a name="ln1215">         */</a>
<a name="ln1216">        for ( i = 0, k = 0; i &lt; at[BondPos[0].nAtomNumber].valence; i ++ ) {</a>
<a name="ln1217">            k += ( i != BondPos[0].neighbor_index &amp;&amp;</a>
<a name="ln1218">                   BOND_TAUTOM == (at[BondPos[0].nAtomNumber].bond_type[i] &amp; ~BOND_MARK_ALL));</a>
<a name="ln1219">        }</a>
<a name="ln1220">        if ( !k ) {</a>
<a name="ln1221">            j = 0;</a>
<a name="ln1222">        }</a>
<a name="ln1223">    }</a>
<a name="ln1224">#endif</a>
<a name="ln1225"> </a>
<a name="ln1226">    *nNumEndPoints = *nNumBondPos = j;</a>
<a name="ln1227">    return j;</a>
<a name="ln1228">    </a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">/*****************************************************************************/</a>
<a name="ln1234">/*#if ( MOVE_CHARGES == 1 ) */  /* { */</a>
<a name="ln1235">/*****************************************************************************/</a>
<a name="ln1236"> </a>
<a name="ln1237">/**********************************************/</a>
<a name="ln1238">/*                                            */</a>
<a name="ln1239">/* definitions for positive ion recognition   */</a>
<a name="ln1240">/*                                            */</a>
<a name="ln1241">/**********************************************/</a>
<a name="ln1242"> </a>
<a name="ln1243">/*****************************************************************************/</a>
<a name="ln1244">typedef struct tagChargeType {  /* meaning see in bCanBeACPoint() */</a>
<a name="ln1245">    char    elname[3];</a>
<a name="ln1246">    S_CHAR  charge;</a>
<a name="ln1247">    S_CHAR  neutral_valence;</a>
<a name="ln1248">    S_CHAR  neutral_bonds_valence; /* valence of a neutral atom */</a>
<a name="ln1249">    S_CHAR  cChangeValence; /* charge increases valence by this value */</a>
<a name="ln1250">    S_CHAR  cChargeType;    /* different types are treated separately */</a>
<a name="ln1251">    S_CHAR  num_bonds;      /* added 02-06-2005 */</a>
<a name="ln1252">} CHARGE_TYPE;</a>
<a name="ln1253"> </a>
<a name="ln1254">CHARGE_TYPE CType[] = {</a>
<a name="ln1255">    { &quot;N\0&quot;,  1, 3, 3, 1, 0, 0 },</a>
<a name="ln1256">    { &quot;P\0&quot;,  1, 3, 3, 1, 1, 0 },</a>
<a name="ln1257">#if ( ADD_MOVEABLE_O_PLUS == 1 )</a>
<a name="ln1258">    { &quot;O\0&quot;,  1, 2, 2, 1, 2, 2 }, /* added 02-06-2005 */</a>
<a name="ln1259">    { &quot;S\0&quot;,  1, 2, 2, 1, 3, 2 }, /* added 03-18-2005 */</a>
<a name="ln1260">    { &quot;Se&quot;,   1, 2, 2, 1, 4, 2 }, /* added 03-18-2005 */</a>
<a name="ln1261">    { &quot;Te&quot;,   1, 2, 2, 1, 5, 2 }, /* added 03-18-2005 */</a>
<a name="ln1262">#endif</a>
<a name="ln1263">};</a>
<a name="ln1264"> </a>
<a name="ln1265">/* bits */</a>
<a name="ln1266"> </a>
<a name="ln1267">#define C_SUBTYPE_CHARGED     0</a>
<a name="ln1268">#define C_SUBTYPE_p_DONOR     1  /* new */</a>
<a name="ln1269">#define C_SUBTYPE_p_ACCEPT    2  /* new */</a>
<a name="ln1270">#define C_SUBTYPE_H_ACCEPT    4</a>
<a name="ln1271">#define C_SUBTYPE_H_DONOR     8</a>
<a name="ln1272">#define C_SUBTYPE_NEUTRAL    16</a>
<a name="ln1273"> </a>
<a name="ln1274">/* make sure any C_SUBTYPE_CHARGED_... &lt; any C_SUBTYPE_NEUTRAL_... */</a>
<a name="ln1275">/* charged */</a>
<a name="ln1276">#define C_SUBTYPE_CHARGED_NON_TAUT          (C_SUBTYPE_CHARGED)</a>
<a name="ln1277">#define C_SUBTYPE_CHARGED_p_DONOR           (C_SUBTYPE_CHARGED|C_SUBTYPE_p_DONOR)</a>
<a name="ln1278">#define C_SUBTYPE_CHARGED_H_ACCEPT          (C_SUBTYPE_CHARGED|C_SUBTYPE_H_ACCEPT)</a>
<a name="ln1279">#define C_SUBTYPE_CHARGED_H_ACCEPT_p_DONOR  (C_SUBTYPE_CHARGED|C_SUBTYPE_H_ACCEPT|C_SUBTYPE_p_DONOR)</a>
<a name="ln1280">#define C_SUBTYPE_CHARGED_H_DONOR           (C_SUBTYPE_CHARGED|C_SUBTYPE_H_DONOR |C_SUBTYPE_p_DONOR)</a>
<a name="ln1281">/* neutral */</a>
<a name="ln1282">#define C_SUBTYPE_NEUTRAL_NON_TAUT          (C_SUBTYPE_NEUTRAL)</a>
<a name="ln1283">#define C_SUBTYPE_NEUTRAL_H_ACCEPT          (C_SUBTYPE_NEUTRAL|C_SUBTYPE_H_ACCEPT)</a>
<a name="ln1284">#define C_SUBTYPE_NEUTRAL_H_ACCEPT_p_ACCEPT (C_SUBTYPE_NEUTRAL|C_SUBTYPE_H_ACCEPT|C_SUBTYPE_p_ACCEPT)</a>
<a name="ln1285">#define C_SUBTYPE_NEUTRAL_H_DONOR           (C_SUBTYPE_NEUTRAL|C_SUBTYPE_H_DONOR)</a>
<a name="ln1286"> </a>
<a name="ln1287">#define NUM_C_TYPES  (int)(sizeof( CType )/sizeof(CType[0]))</a>
<a name="ln1288">/*****************************************************************************/</a>
<a name="ln1289"> </a>
<a name="ln1290"> </a>
<a name="ln1291"> </a>
<a name="ln1292">/*****************************************************************************/</a>
<a name="ln1293">int bCanBeACPoint( inp_ATOM *at, S_CHAR cCharge, S_CHAR cChangeValence, S_CHAR neutral_bonds_valence,</a>
<a name="ln1294">                   S_CHAR neutral_valence, S_CHAR nEndpointValence, S_CHAR *cChargeSubtype )</a>
<a name="ln1295">{</a>
<a name="ln1296">    int nChangeValence;</a>
<a name="ln1297">    int nNumBonds;</a>
<a name="ln1298">    int nBondsValence;</a>
<a name="ln1299">    int bNegCharge = (at-&gt;charge == -1);  /* add fict. bonds to (-) 2004-02-24*/</a>
<a name="ln1300">    if ( at-&gt;charge == cCharge &amp;&amp; at-&gt;valence == at-&gt;chem_bonds_valence &amp;&amp; at-&gt;num_H ) {</a>
<a name="ln1301">        /* proton donors candidates &gt;NH(+)-, &gt;NH2(+), -NH3(+), &gt;OH(+), -OH2(+) */</a>
<a name="ln1302">        /* charged, added p-transfer -- 01-28-2004 */</a>
<a name="ln1303">        nChangeValence = at-&gt;charge * cChangeValence; /* +1 or -1; currently only +1 */</a>
<a name="ln1304">        nBondsValence  = at-&gt;chem_bonds_valence + at-&gt;num_H;</a>
<a name="ln1305">        if ( nBondsValence == neutral_bonds_valence + nChangeValence &amp;&amp; nEndpointValence ) {</a>
<a name="ln1306">            *cChargeSubtype = C_SUBTYPE_CHARGED_p_DONOR; /* ignore Phosphorus p-donors for now */</a>
<a name="ln1307">        }</a>
<a name="ln1308">        return 0;</a>
<a name="ln1309">    } else</a>
<a name="ln1310">    if ( at-&gt;charge == cCharge &amp;&amp; at-&gt;valence &lt; at-&gt;chem_bonds_valence ) {</a>
<a name="ln1311">        /* the requirement at-&gt;valence &lt; at-&gt;chem_bonds_valence rejects</a>
<a name="ln1312">           candidates &gt;NH(+)-, &gt;NH2(+), -NH3(+), &gt;N(+)&lt;, &gt;OH(+), -OH2(+), &gt;O(+)-</a>
<a name="ln1313">           Moveable charge requires double bonds; these ions have no double bonds</a>
<a name="ln1314">         */</a>
<a name="ln1315"> </a>
<a name="ln1316">        /* charged */</a>
<a name="ln1317">        nChangeValence = at-&gt;charge * cChangeValence; /* +1 or -1; currently only +1 */</a>
<a name="ln1318">        nBondsValence  = at-&gt;chem_bonds_valence + at-&gt;num_H;</a>
<a name="ln1319">        nNumBonds      = at-&gt;valence + at-&gt;num_H;</a>
<a name="ln1320">        if ( nBondsValence == neutral_bonds_valence + nChangeValence ) { /* known valence */</a>
<a name="ln1321">            if ( nNumBonds == neutral_valence ) {</a>
<a name="ln1322">                /* non-tautomeric: &gt;N(+)=, =O(+)-</a>
<a name="ln1323">                   possibly tautomeric donor: =NH(+)-, =NH2(+), =OH(+) */</a>
<a name="ln1324">                if ( at-&gt;valence == neutral_valence || !nEndpointValence ) {</a>
<a name="ln1325">                    /* non-tautomeric: &gt;N(+)=, =O(+)-; any suitable P+: &gt;P(+)=, =PH(+)-, =PH2(+) */</a>
<a name="ln1326">                    *cChargeSubtype = C_SUBTYPE_CHARGED_NON_TAUT;</a>
<a name="ln1327">                } else {</a>
<a name="ln1328">                    /* possibly tautomeric donor: =NH(+)-, =NH2(+), =OH(+) */</a>
<a name="ln1329">                    *cChargeSubtype = C_SUBTYPE_CHARGED_H_DONOR;</a>
<a name="ln1330">                }</a>
<a name="ln1331">                return 1;</a>
<a name="ln1332">            }</a>
<a name="ln1333">            if ( nNumBonds == neutral_valence - 1 ) {</a>
<a name="ln1334">                /* possibly tutomeric acceptor: =N(+)=, #N(+)-, #NH(+), #O(+) */</a>
<a name="ln1335">                if ( nEndpointValence ) {</a>
<a name="ln1336">                    *cChargeSubtype = at-&gt;num_H? C_SUBTYPE_CHARGED_H_ACCEPT_p_DONOR : C_SUBTYPE_CHARGED_H_ACCEPT;</a>
<a name="ln1337">                } else {</a>
<a name="ln1338">                    /* =P(+)=, #P(+)-, #PH(+) */</a>
<a name="ln1339">                    *cChargeSubtype = C_SUBTYPE_CHARGED_NON_TAUT;</a>
<a name="ln1340">                }</a>
<a name="ln1341">                return 1; /* charge type, charged */</a>
<a name="ln1342">            }</a>
<a name="ln1343">        }</a>
<a name="ln1344"> </a>
<a name="ln1345">    } else</a>
<a name="ln1346">    if ( at-&gt;charge == 0 || bNegCharge ) {</a>
<a name="ln1347">        /* neutral atom or anion, all bonds are single */</a>
<a name="ln1348">        nBondsValence  = at-&gt;chem_bonds_valence + at-&gt;num_H + bNegCharge; /* add fict. bonds to (-) 2004-02-24*/</a>
<a name="ln1349">        nNumBonds      = at-&gt;valence + at-&gt;num_H + bNegCharge; /* add fict. bonds to (-) 2004-02-24*/</a>
<a name="ln1350">        if ( nBondsValence == neutral_bonds_valence ) {</a>
<a name="ln1351">            if ( nNumBonds == neutral_valence ) {</a>
<a name="ln1352">                /* only single bonds: &gt;N-, &gt;NH, -NH2, -O-, -OH, &gt;P- &gt;PH -PH2 */</a>
<a name="ln1353">                /*                    &gt;N(-), -NH(-), -O(-). &gt;P(-) -PH(-) */</a>
<a name="ln1354">                if ( at-&gt;valence == neutral_valence || !nEndpointValence ) {</a>
<a name="ln1355">                    /* &gt;N-, -O-, any P(3 single bonds): &gt;P- &gt;PH -PH2  */</a>
<a name="ln1356">                    *cChargeSubtype = C_SUBTYPE_NEUTRAL_NON_TAUT;</a>
<a name="ln1357">                } else</a>
<a name="ln1358">                if ( at-&gt;valence &lt; neutral_valence /*&amp;&amp; nEndpointValence */ ) {</a>
<a name="ln1359">                    /* num_H &gt; 0: &gt;NH -NH2 -OH */</a>
<a name="ln1360">                    /* num_H = 0: none C_SUBTYPE_NEUTRAL_H_ACCEPT for now */</a>
<a name="ln1361">                    *cChargeSubtype = at-&gt;num_H? C_SUBTYPE_NEUTRAL_H_DONOR: C_SUBTYPE_NEUTRAL_H_ACCEPT;</a>
<a name="ln1362">                } else {</a>
<a name="ln1363">                    return 0;</a>
<a name="ln1364">                }</a>
<a name="ln1365">                return 1; /* charge type, neutral */</a>
<a name="ln1366">            }</a>
<a name="ln1367">            if ( nNumBonds == neutral_valence - 1 ) {</a>
<a name="ln1368">                /* possibly tautomeric acceptor =N-, =NH, =O or non-taut =P-, =PH */</a>
<a name="ln1369">                if ( nEndpointValence ) {</a>
<a name="ln1370">                    /* =N-,  =NH, =O  */</a>
<a name="ln1371">                    *cChargeSubtype = C_SUBTYPE_NEUTRAL_H_ACCEPT_p_ACCEPT;</a>
<a name="ln1372">                } else {</a>
<a name="ln1373">                    /* =P-, =PH */</a>
<a name="ln1374">                    *cChargeSubtype = C_SUBTYPE_NEUTRAL_NON_TAUT;</a>
<a name="ln1375">                }</a>
<a name="ln1376">                return 1; /* charge type, (+) =&gt; neutral */</a>
<a name="ln1377">            }</a>
<a name="ln1378">        }</a>
<a name="ln1379">    }</a>
<a name="ln1380">    return 0;</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">/*****************************************************************************/</a>
<a name="ln1386">int GetChargeType( inp_ATOM *atom, int iat, S_CHAR *cChargeSubtype )</a>
<a name="ln1387">{</a>
<a name="ln1388">    int i, n;</a>
<a name="ln1389">    S_CHAR    nEndpointValence;</a>
<a name="ln1390">    inp_ATOM *at = atom + iat;</a>
<a name="ln1391"> </a>
<a name="ln1392">    *cChargeSubtype = 0;</a>
<a name="ln1393">    /* ignore ion pairs and charges != 1 */</a>
<a name="ln1394">    if ( abs(at-&gt;charge) == 1 ) {</a>
<a name="ln1395">        for ( i = 0; i &lt; at-&gt;valence; i ++ ) {</a>
<a name="ln1396">            n = at-&gt;neighbor[i];</a>
<a name="ln1397">            /* allow negatively charged tautomeric neighbors 2004-02-26 */</a>
<a name="ln1398">            if ( abs(atom[n].charge + at-&gt;charge) &lt; abs(atom[n].charge - at-&gt;charge) &amp;&amp; !atom[n].endpoint ) {</a>
<a name="ln1399">                return -1; /* charges have different signs */</a>
<a name="ln1400">            }</a>
<a name="ln1401">        }</a>
<a name="ln1402">    } else</a>
<a name="ln1403">    if ( at-&gt;charge ) {</a>
<a name="ln1404">        return -1; /* abs(charge) != 1 */</a>
<a name="ln1405">    }</a>
<a name="ln1406">    /* find candidates */</a>
<a name="ln1407">    for ( i = 0; i &lt; NUM_C_TYPES; i ++ ) {</a>
<a name="ln1408">        if ( !strcmp( at-&gt;elname, CType[i].elname ) &amp;&amp;</a>
<a name="ln1409">             (!CType[i].num_bonds || (CType[i].num_bonds==at-&gt;valence &amp;&amp; at-&gt;nNumAtInRingSystem &gt;= 5)) ) {</a>
<a name="ln1410">            nEndpointValence = (S_CHAR)get_endpoint_valence(at-&gt;el_number );</a>
<a name="ln1411">            if ( bCanBeACPoint( at, CType[i].charge, CType[i].cChangeValence, CType[i].neutral_bonds_valence,</a>
<a name="ln1412">                                CType[i].neutral_valence, nEndpointValence, cChargeSubtype ) ) {</a>
<a name="ln1413">                return CType[i].cChargeType;</a>
<a name="ln1414">            }</a>
<a name="ln1415">        }</a>
<a name="ln1416">    }</a>
<a name="ln1417">    return -1;</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420"> </a>
<a name="ln1421">/*****************************************************************************/</a>
<a name="ln1422">int CmpCCandidates( const void *a1, const void *a2 )</a>
<a name="ln1423">{</a>
<a name="ln1424">    const C_CANDIDATE *c1 = (const C_CANDIDATE *)a1;</a>
<a name="ln1425">    const C_CANDIDATE *c2 = (const C_CANDIDATE *)a2;</a>
<a name="ln1426">    int ret;</a>
<a name="ln1427">    if ( (ret = (int)c1-&gt;type - (int)c2-&gt;type) )</a>
<a name="ln1428">        return ret;</a>
<a name="ln1429">    if ( (ret = (int)c1-&gt;subtype - (int)c2-&gt;subtype) )</a>
<a name="ln1430">        return ret;</a>
<a name="ln1431">    ret = (int)c1-&gt;atnumber - (int)c2-&gt;atnumber;</a>
<a name="ln1432">    return ret;</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435"> </a>
<a name="ln1436">/*****************************************************************************/</a>
<a name="ln1437">int RegisterCPoints( C_GROUP *c_group, int *pnum_c, int max_num_c, T_GROUP_INFO *t_group_info,</a>
<a name="ln1438">                     int point1, int point2, int ctype, inp_ATOM *at, int num_atoms )</a>
<a name="ln1439">{</a>
<a name="ln1440">    int num_c = *pnum_c, i, i1, i2;</a>
<a name="ln1441">    AT_NUMB nGroupNumber = 0, nNewGroupNumber;</a>
<a name="ln1442"> </a>
<a name="ln1443"> </a>
<a name="ln1444">    if ( at[point1].c_point == at[point2].c_point ) {</a>
<a name="ln1445">        if ( at[point1].c_point )</a>
<a name="ln1446">            return 0;</a>
<a name="ln1447">        memset( c_group+num_c, 0, sizeof(c_group[0]) );</a>
<a name="ln1448">        if ( num_c &lt; max_num_c ) {</a>
<a name="ln1449">            c_group[num_c].num[0] = CHARGED_CPOINT(at,point1) + CHARGED_CPOINT(at, point2);</a>
<a name="ln1450">            c_group[num_c].num_CPoints += 2;</a>
<a name="ln1451">            c_group[num_c].cGroupType   = ctype;</a>
<a name="ln1452">            /* get next available c-group number */</a>
<a name="ln1453">            for ( i = 0; i &lt; num_c; i ++ ) {</a>
<a name="ln1454">                if ( nGroupNumber &lt; c_group[i].nGroupNumber )</a>
<a name="ln1455">                    nGroupNumber = c_group[i].nGroupNumber;</a>
<a name="ln1456">            }</a>
<a name="ln1457">            nGroupNumber ++;</a>
<a name="ln1458">            c_group[num_c].nGroupNumber =</a>
<a name="ln1459">            at[point1].c_point          =</a>
<a name="ln1460">            at[point2].c_point          = nGroupNumber;</a>
<a name="ln1461">            *pnum_c = num_c+1;</a>
<a name="ln1462">            /* count protons */</a>
<a name="ln1463">            if ( at[point1].num_H ) {</a>
<a name="ln1464">                c_group[num_c].num[1] ++;</a>
<a name="ln1465">            } else</a>
<a name="ln1466">            if ( at[point2].num_H ) {</a>
<a name="ln1467">                c_group[num_c].num[1] ++;</a>
<a name="ln1468">            } else</a>
<a name="ln1469">            if ( (at[point1].endpoint || at[point2].endpoint) &amp;&amp; t_group_info &amp;&amp; t_group_info-&gt;t_group &amp;&amp; t_group_info-&gt;num_t_groups ) {</a>
<a name="ln1470">            /* !!! add later !!! */</a>
<a name="ln1471">            }</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">            return 1;</a>
<a name="ln1475">        }</a>
<a name="ln1476">        return BNS_CPOINT_ERR; /* overflow */</a>
<a name="ln1477">    }</a>
<a name="ln1478">    if ( at[point1].c_point &gt; at[point2].c_point ) {</a>
<a name="ln1479">        /* make sure at[point1].c_point &lt; at[point2].c_point */</a>
<a name="ln1480">        i = point1;</a>
<a name="ln1481">        point1 = point2;</a>
<a name="ln1482">        point2 = i;</a>
<a name="ln1483">    }</a>
<a name="ln1484">    if ( !at[point1].c_point ) {</a>
<a name="ln1485">        /* add a new c-endpoint to an existing c-group */</a>
<a name="ln1486">        nGroupNumber = at[point2].c_point;</a>
<a name="ln1487">        for ( i = 0; i &lt; num_c; i ++ ) {</a>
<a name="ln1488">            if ( nGroupNumber == c_group[i].nGroupNumber ) {</a>
<a name="ln1489">                at[point1].c_point = at[point2].c_point;</a>
<a name="ln1490">                c_group[i].num_CPoints ++;</a>
<a name="ln1491">                c_group[i].num[0] += CHARGED_CPOINT(at,point1);</a>
<a name="ln1492">                return 1;</a>
<a name="ln1493">            }</a>
<a name="ln1494">        }</a>
<a name="ln1495">        return BNS_CPOINT_ERR; /* program error: c-group not found */</a>
<a name="ln1496">    } else {</a>
<a name="ln1497">        /* merge two c-groups */</a>
<a name="ln1498">        nNewGroupNumber = at[point1].c_point;</a>
<a name="ln1499">        nGroupNumber    = at[point2].c_point;</a>
<a name="ln1500">        for ( i = 0, i1=i2=-1; i &lt; num_c &amp;&amp; (i1 &lt; 0 || i2 &lt; 0); i ++ ) {</a>
<a name="ln1501">            if ( nNewGroupNumber == c_group[i].nGroupNumber ) {</a>
<a name="ln1502">                i1 = i;</a>
<a name="ln1503">                continue;</a>
<a name="ln1504">            }</a>
<a name="ln1505">            if ( nGroupNumber    == c_group[i].nGroupNumber ) {</a>
<a name="ln1506">                i2 = i;</a>
<a name="ln1507">                continue;</a>
<a name="ln1508">            }</a>
<a name="ln1509">        }</a>
<a name="ln1510">        if ( i1 &lt; 0 || i2 &lt; 0 ) {</a>
<a name="ln1511">            return BNS_CPOINT_ERR; /* at least one not found */</a>
<a name="ln1512">        }</a>
<a name="ln1513"> </a>
<a name="ln1514">        c_group[i1].num[0]      += c_group[i2].num[0];</a>
<a name="ln1515">        c_group[i1].num_CPoints += c_group[i2].num_CPoints;</a>
<a name="ln1516">        num_c --;</a>
<a name="ln1517">        if ( num_c &gt; i2 ) {</a>
<a name="ln1518">            memmove( c_group+i2, c_group+i2+1, ( num_c - i2)*sizeof(c_group[0]) );</a>
<a name="ln1519">        }</a>
<a name="ln1520">        *pnum_c = num_c;</a>
<a name="ln1521">        /* renumber c-groups */</a>
<a name="ln1522">        for ( i = 0; i &lt; num_c; i ++ ) {</a>
<a name="ln1523">            if ( c_group[i].nGroupNumber &gt; nGroupNumber ) {</a>
<a name="ln1524">                c_group[i].nGroupNumber --;</a>
<a name="ln1525">            }</a>
<a name="ln1526">        }</a>
<a name="ln1527">        /* renumber c-points */</a>
<a name="ln1528">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1529">            if ( at[i].c_point &gt; nGroupNumber ) {</a>
<a name="ln1530">                at[i].c_point --;</a>
<a name="ln1531">            } else</a>
<a name="ln1532">            if ( at[i].c_point == nGroupNumber ) {</a>
<a name="ln1533">                at[i].c_point = nNewGroupNumber;</a>
<a name="ln1534">            }</a>
<a name="ln1535">        }</a>
<a name="ln1536">        return 1;</a>
<a name="ln1537">    }</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540"> </a>
<a name="ln1541"> </a>
<a name="ln1542">/*****************************************************************************/</a>
<a name="ln1543">int MarkChargeGroups(inp_ATOM *at, int num_atoms, </a>
<a name="ln1544">                     C_GROUP_INFO *c_group_info, T_GROUP_INFO *t_group_info,</a>
<a name="ln1545">                     struct BalancedNetworkStructure *pBNS, </a>
<a name="ln1546">                     struct BalancedNetworkData *pBD)</a>
<a name="ln1547">{   </a>
<a name="ln1548">    int nNumChanges = 0;</a>
<a name="ln1549"> </a>
<a name="ln1550">    if ( c_group_info &amp;&amp; c_group_info-&gt;c_candidate &amp;&amp; c_group_info-&gt;max_num_candidates &gt; 0 ) {</a>
<a name="ln1551">        int i, i1, i2, i3, j, num_tested;</a>
<a name="ln1552">        C_CANDIDATE *c_candidate       = c_group_info-&gt;c_candidate;</a>
<a name="ln1553">        int          nMaxNumCandidates = c_group_info-&gt;max_num_candidates;</a>
<a name="ln1554">        int          nNumCandidates    = c_group_info-&gt;num_candidates;</a>
<a name="ln1555">        S_CHAR       c_type, c_subtype;</a>
<a name="ln1556">        int          iat1, iat2, ret, nDelta;</a>
<a name="ln1557"> </a>
<a name="ln1558">        if ( nNumCandidates == -1 ) </a>
<a name="ln1559">        {</a>
<a name="ln1560">            nNumCandidates = 0; /* 2004-02-26 they could appear after t-group discovery */</a>
<a name="ln1561">            /*return 0;*/</a>
<a name="ln1562">        }</a>
<a name="ln1563">        if ( nNumCandidates == 0 ) </a>
<a name="ln1564">        {</a>
<a name="ln1565">            for ( i = 0, nNumCandidates = 0; i &lt; num_atoms; i ++ ) </a>
<a name="ln1566">            {</a>
<a name="ln1567">                if ( 0 &lt;= (c_type = GetChargeType( at, i, &amp;c_subtype )) ) </a>
<a name="ln1568">                {</a>
<a name="ln1569">                    if ( nNumCandidates &gt;= nMaxNumCandidates ) </a>
<a name="ln1570">                    {</a>
<a name="ln1571">                        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln1572">                    }</a>
<a name="ln1573">                    c_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln1574">                    c_candidate[nNumCandidates].type     = c_type;</a>
<a name="ln1575">                    c_candidate[nNumCandidates].subtype  = c_subtype;</a>
<a name="ln1576">                    nNumCandidates ++;</a>
<a name="ln1577">                }</a>
<a name="ln1578">            }</a>
<a name="ln1579">            if ( nNumCandidates &lt;= 1 ) </a>
<a name="ln1580">            {</a>
<a name="ln1581">                c_group_info-&gt;num_candidates = -1; /* no candidate exists */</a>
<a name="ln1582">                return 0;</a>
<a name="ln1583">            }</a>
<a name="ln1584">        }</a>
<a name="ln1585">        /* sorting keys: (1) atom type (N,P); (2) uncharged=16/charged=0; (3) other;</a>
<a name="ln1586">           atom-charged-N .... i1</a>
<a name="ln1587">              ...</a>
<a name="ln1588">           atom-charged-N</a>
<a name="ln1589">           atom-neutral-N .... i2</a>
<a name="ln1590">              ...</a>
<a name="ln1591">           atom-neutral-N</a>
<a name="ln1592">           atom-charged-P .... i3 ... i1</a>
<a name="ln1593">              ...</a>
<a name="ln1594">           atom-charged-P</a>
<a name="ln1595">           atom-neutral-P ........... i2</a>
<a name="ln1596">              ...</a>
<a name="ln1597">           atom-neutral-P</a>
<a name="ln1598">           end.           ........... i3</a>
<a name="ln1599">        */</a>
<a name="ln1600">        qsort(c_candidate, nNumCandidates, sizeof(c_candidate[0]), CmpCCandidates);</a>
<a name="ln1601">    </a>
<a name="ln1602">        i1 = 0;</a>
<a name="ln1603">        num_tested = 0;</a>
<a name="ln1604">        nDelta     = 0;</a>
<a name="ln1605"> </a>
<a name="ln1606">        while ( i1 &lt; nNumCandidates ) </a>
<a name="ln1607">        {</a>
<a name="ln1608">    </a>
<a name="ln1609">            /* the the first charged candidate of a new atom type */</a>
<a name="ln1610">            for (; i1 &lt; nNumCandidates &amp;&amp; (c_candidate[i1].subtype &amp; C_SUBTYPE_NEUTRAL); i1 ++)</a>
<a name="ln1611">                ;</a>
<a name="ln1612">            if ( i1 == nNumCandidates )</a>
<a name="ln1613">                break; /* not found */</a>
<a name="ln1614">        </a>
<a name="ln1615">            /* bypass other charged candidates of the same atom type */</a>
<a name="ln1616">            for ( i2 = i1+1; i2 &lt; nNumCandidates &amp;&amp;</a>
<a name="ln1617">                            c_candidate[i2].type    == c_candidate[i1].type &amp;&amp;</a>
<a name="ln1618">                            !(c_candidate[i2].subtype &amp; C_SUBTYPE_NEUTRAL); i2++ )</a>
<a name="ln1619">                ;</a>
<a name="ln1620">            if ( i2 == nNumCandidates )</a>
<a name="ln1621">                break; /* no neutral candidates */</a>
<a name="ln1622">        </a>
<a name="ln1623">            /* find next to the last neutral candidate of the same atom type */</a>
<a name="ln1624">            for ( i3 = i2;  i3 &lt; nNumCandidates &amp;&amp;</a>
<a name="ln1625">                            c_candidate[i3].type    == c_candidate[i1].type; i3 ++ )</a>
<a name="ln1626">                ; </a>
<a name="ln1627">        </a>
<a name="ln1628">            if ( i3 == i2 ) </a>
<a name="ln1629">            {</a>
<a name="ln1630">                /* no neutral candidates found */</a>
<a name="ln1631">                if ( i2 &lt; nNumCandidates ) </a>
<a name="ln1632">                {</a>
<a name="ln1633">                    i1 = i3;</a>
<a name="ln1634">                    continue;  /* move to the next atom type */</a>
<a name="ln1635">                }</a>
<a name="ln1636">                break; /* nothing more to do */</a>
<a name="ln1637">            }</a>
<a name="ln1638"> </a>
<a name="ln1639">            /* found charged candidates: i1...i2-1;  neutral candidates: i2...i3-1 */</a>
<a name="ln1640">            for ( i = i1; i &lt; i2; i ++ ) </a>
<a name="ln1641">            {</a>
<a name="ln1642">                iat1 = c_candidate[i].atnumber;</a>
<a name="ln1643">                for ( j = i2; j &lt; i3; j ++ ) </a>
<a name="ln1644">                {</a>
<a name="ln1645">                    /* check alt path at[iat1]=-=-...-at[iat2]; at[iat1] is charged, at[iat2] is neutral */</a>
<a name="ln1646">                    num_tested ++;</a>
<a name="ln1647">                    iat2 = c_candidate[j].atnumber;</a>
<a name="ln1648">                    if ( at[iat1].c_point &amp;&amp; at[iat1].c_point == at[iat2].c_point )</a>
<a name="ln1649">                        continue;</a>
<a name="ln1650">                    ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, iat1, iat2, ALT_PATH_MODE_CHARGE );</a>
<a name="ln1651">                    if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln1652">                    {</a>
<a name="ln1653">                        return ret;</a>
<a name="ln1654">                    }</a>
<a name="ln1655">                    if ( ret &amp; 1 ) </a>
<a name="ln1656">                    {</a>
<a name="ln1657">                        nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln1658">                        nNumChanges += (ret &amp; 2);</a>
<a name="ln1659">                        ret = RegisterCPoints( c_group_info-&gt;c_group, &amp;c_group_info-&gt;num_c_groups,</a>
<a name="ln1660">                                               c_group_info-&gt;max_num_c_groups, t_group_info,</a>
<a name="ln1661">                                               iat1, iat2, c_candidate[i1].type, at, num_atoms );</a>
<a name="ln1662">                        if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln1663">                        {</a>
<a name="ln1664">                            return ret;</a>
<a name="ln1665">                        }</a>
<a name="ln1666">                        if ( nDelta ) </a>
<a name="ln1667">                        {</a>
<a name="ln1668">                            goto quick_exit;</a>
<a name="ln1669">                        }</a>
<a name="ln1670">                    }</a>
<a name="ln1671">                }</a>
<a name="ln1672">            }</a>
<a name="ln1673">            i1 = i3;</a>
<a name="ln1674">        }</a>
<a name="ln1675">quick_exit:</a>
<a name="ln1676">        if ( c_group_info-&gt;num_candidates == 0 ) </a>
<a name="ln1677">        {</a>
<a name="ln1678">            /* first time: initialize */</a>
<a name="ln1679">            c_group_info-&gt;num_candidates = num_tested? nNumCandidates : -1; /* no candidate exists */</a>
<a name="ln1680">        }</a>
<a name="ln1681">        </a>
<a name="ln1682">    }</a>
<a name="ln1683">    return nNumChanges;</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686"> </a>
<a name="ln1687"> </a>
<a name="ln1688">/*****************************************************************************/</a>
<a name="ln1689">int GetSaltChargeType(inp_ATOM *at, int at_no, T_GROUP_INFO *t_group_info, int *s_subtype )</a>
<a name="ln1690">{</a>
<a name="ln1691">    static int el_number_C  = 0;</a>
<a name="ln1692">    static int el_number_O  = 0;</a>
<a name="ln1693">    static int el_number_S  = 0;</a>
<a name="ln1694">    static int el_number_Se = 0;</a>
<a name="ln1695">    static int el_number_Te = 0;</a>
<a name="ln1696"> </a>
<a name="ln1697">/* </a>
<a name="ln1698">   type (returned value):</a>
<a name="ln1699">    -1 =&gt; ignore</a>
<a name="ln1700">     0 =&gt; oxygen</a>
<a name="ln1701">   subtype:</a>
<a name="ln1702">     1 = SALT_DONOR_H   =&gt; has H </a>
<a name="ln1703">     2 = SALT_DONOR_Neg =&gt; has (-) charge</a>
<a name="ln1704">     4 = SALT_ACCEPTOR  =&gt; may be an acceptor of H or (-), but not necessarily</a>
<a name="ln1705"> </a>
<a name="ln1706">   O-atom should be:</a>
<a name="ln1707">     - a terminal atom</a>
<a name="ln1708">     - connected to unsaturated, uncharged, non-radical atom C that has chemical valence 4:</a>
<a name="ln1709">     H-donors:             =CH-OH, =C(-X)-OH</a>
<a name="ln1710">     possible H-acceptors: -CH=O, &gt;C=O</a>
<a name="ln1711">     H-acceptors are true if O is tautomeric</a>
<a name="ln1712">*/</a>
<a name="ln1713">    int iC, tg, i, type;</a>
<a name="ln1714">    /* one-time initialization */</a>
<a name="ln1715">    if ( !el_number_O ) {</a>
<a name="ln1716">        el_number_C  = get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln1717">        el_number_O  = get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln1718">        el_number_S  = get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln1719">        el_number_Se = get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln1720">        el_number_Te = get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln1721">    }</a>
<a name="ln1722">    *s_subtype = 0; /* initialize the output */</a>
<a name="ln1723">    /* check whether it is a candidate */</a>
<a name="ln1724">    if ( at[at_no].valence != 1 ||</a>
<a name="ln1725">         (at[at_no].radical &amp;&amp; at[at_no].radical != RADICAL_SINGLET) ||</a>
<a name="ln1726">         at[at_no].charge &lt; -1 ||</a>
<a name="ln1727">         (at[at_no].charge &gt; 0 &amp;&amp; !at[at_no].c_point) ) {</a>
<a name="ln1728">        return -1;</a>
<a name="ln1729">    }</a>
<a name="ln1730">    </a>
<a name="ln1731">    if ( at[at_no].el_number == el_number_O  ||</a>
<a name="ln1732">         at[at_no].el_number == el_number_S  ||</a>
<a name="ln1733">         at[at_no].el_number == el_number_Se ||</a>
<a name="ln1734">         at[at_no].el_number == el_number_Te ) {</a>
<a name="ln1735">        type = 0;  /* terminal oxygen atom, needs more to be checked... */</a>
<a name="ln1736">    } else {</a>
<a name="ln1737">        type = -1; /* ignore this atom */</a>
<a name="ln1738">    }</a>
<a name="ln1739"> </a>
<a name="ln1740">    if ( type &lt; 0 ||</a>
<a name="ln1741">         at[at_no].chem_bonds_valence + at[at_no].num_H !=</a>
<a name="ln1742">         get_el_valence(at[at_no].el_number, at[at_no].charge, 0) ) {</a>
<a name="ln1743">        return -1; /* non-standard valence or not an oxygen */</a>
<a name="ln1744">    }</a>
<a name="ln1745">    </a>
<a name="ln1746">    iC = at[at_no].neighbor[0];</a>
<a name="ln1747"> </a>
<a name="ln1748">#if ( SALT_WITH_PROTONS == 1 )</a>
<a name="ln1749">    if ( at[iC].el_number != el_number_C ||</a>
<a name="ln1750">         at[iC].chem_bonds_valence + at[iC].num_H != 4 || /* allow =C(H)-OH or -C(H)=O */</a>
<a name="ln1751">         at[iC].charge         ||</a>
<a name="ln1752">         (at[iC].radical &amp;&amp; at[iC].radical != RADICAL_SINGLET) ||</a>
<a name="ln1753">         at[iC].valence == at[iC].chem_bonds_valence ) {</a>
<a name="ln1754">        return -1; /* oxigen is connected to a wrong atom */</a>
<a name="ln1755">    }</a>
<a name="ln1756">#else</a>
<a name="ln1757">    if ( at[iC].el_number != el_number_C ||</a>
<a name="ln1758">         at[iC].num_H ||</a>
<a name="ln1759">         at[iC].chem_bonds_valence != 4 ||  /* allow only no H on C */</a>
<a name="ln1760">         at[iC].charge         ||</a>
<a name="ln1761">         at[iC].radical &amp;&amp; at[iC].radical != RADICAL_SINGLET ||</a>
<a name="ln1762">         at[iC].valence == at[iC].chem_bonds_valence ) {</a>
<a name="ln1763">        return -1; /* oxigen is connected to a wrong atom */</a>
<a name="ln1764">    }</a>
<a name="ln1765">#endif</a>
<a name="ln1766">    if ( (tg = at[at_no].endpoint) &amp;&amp; t_group_info &amp;&amp; t_group_info-&gt;t_group ) {</a>
<a name="ln1767">        /* O-atom is in a tautomeric group */</a>
<a name="ln1768">        for ( i = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln1769">            if ( tg == t_group_info-&gt;t_group[i].nGroupNumber ) {</a>
<a name="ln1770">                /*</a>
<a name="ln1771">                t_group_info-&gt;t_group[i].num[0] = number of attached H-atoms and negative charges</a>
<a name="ln1772">                t_group_info-&gt;t_group[i].num[1] = number of attached negative charges</a>
<a name="ln1773">                */</a>
<a name="ln1774">                if ( t_group_info-&gt;t_group[i].num[0] &gt; t_group_info-&gt;t_group[i].num[1] ) {</a>
<a name="ln1775">                    *s_subtype |= SALT_DONOR_H; /* has H */</a>
<a name="ln1776">                }</a>
<a name="ln1777">                if ( t_group_info-&gt;t_group[i].num[1] ) {</a>
<a name="ln1778">                    *s_subtype |= SALT_DONOR_Neg; /* has (-) */</a>
<a name="ln1779">                }</a>
<a name="ln1780">                *s_subtype |= SALT_ACCEPTOR; /* there is always an acceptor in a t-group */</a>
<a name="ln1781">                return type;</a>
<a name="ln1782">            }</a>
<a name="ln1783">        }</a>
<a name="ln1784">        return -1; /* error: t-group not found */</a>
<a name="ln1785">    }</a>
<a name="ln1786">    /* O is not not in a tautomeric group */</a>
<a name="ln1787">    /* assume valence(O-) &lt; valence(O) &lt; valence(O+) */</a>
<a name="ln1788">    if ( at[at_no].charge == -1 ) {</a>
<a name="ln1789">        *s_subtype |= SALT_DONOR_Neg; /* has (-) */</a>
<a name="ln1790">    }</a>
<a name="ln1791">    if ( at[at_no].charge &lt;= 0 &amp;&amp; at[at_no].num_H ) {</a>
<a name="ln1792">        *s_subtype |= SALT_DONOR_H; /* has H */</a>
<a name="ln1793">    }</a>
<a name="ln1794">    if ( at[at_no].charge == 0 &amp;&amp; at[at_no].chem_bonds_valence == 2 ) {</a>
<a name="ln1795">        *s_subtype |= SALT_ACCEPTOR;</a>
<a name="ln1796">    }</a>
<a name="ln1797">    /* since O cannot be a charge point, the following cannot happen: */</a>
<a name="ln1798">    if ( at[at_no].charge == 1 &amp;&amp; at[at_no].c_point &amp;&amp; at[at_no].chem_bonds_valence == 2 &amp;&amp; at[at_no].num_H ) {</a>
<a name="ln1799">        *s_subtype |= SALT_DONOR_H; /* has H */</a>
<a name="ln1800">    }</a>
<a name="ln1801">    return type;</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804"> </a>
<a name="ln1805"> </a>
<a name="ln1806">/*****************************************************************************/</a>
<a name="ln1807">int bDoNotMergeNonTautAtom(inp_ATOM *at, int at_no)</a>
<a name="ln1808">{</a>
<a name="ln1809">    static int el_number_N  = 0;</a>
<a name="ln1810"> </a>
<a name="ln1811">    if ( !el_number_N ) {</a>
<a name="ln1812">        el_number_N  = get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln1813">    }</a>
<a name="ln1814">    if ( at[at_no].el_number == el_number_N )</a>
<a name="ln1815">    {</a>
<a name="ln1816">        return 1;</a>
<a name="ln1817">    }</a>
<a name="ln1818">    return 0;</a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822"> </a>
<a name="ln1823">/*****************************************************************************/</a>
<a name="ln1824">int GetOtherSaltChargeType( inp_ATOM *at, int at_no, T_GROUP_INFO *t_group_info, int *s_subtype, int bAccept_O )</a>
<a name="ln1825">{</a>
<a name="ln1826">   /* static int el_number_C  = 0; */</a>
<a name="ln1827">   /* static int el_number_N  = 0; */</a>
<a name="ln1828">    static int el_number_O  = 0;</a>
<a name="ln1829">    static int el_number_S  = 0;</a>
<a name="ln1830">    static int el_number_Se = 0;</a>
<a name="ln1831">    static int el_number_Te = 0;</a>
<a name="ln1832"> </a>
<a name="ln1833">/* </a>
<a name="ln1834">   type (returned value):</a>
<a name="ln1835">    -1 =&gt; ignore</a>
<a name="ln1836">     1 =&gt; not an oxygen</a>
<a name="ln1837">   subtype:</a>
<a name="ln1838">     1 = SALT_DONOR_H   =&gt; has H </a>
<a name="ln1839">     2 = SALT_DONOR_Neg =&gt; has (-) charge</a>
<a name="ln1840">     4 = SALT_ACCEPTOR  =&gt; may be an acceptor of H or (-), but not necessarily</a>
<a name="ln1841"> </a>
<a name="ln1842">   the atom should be:</a>
<a name="ln1843">     - a tautomeric endpoint atom</a>
<a name="ln1844">     - connected to possible centerpoint atom</a>
<a name="ln1845"> </a>
<a name="ln1846">   another description of the atom searched here:</a>
<a name="ln1847"> </a>
<a name="ln1848">   any possibly tautomeric atom adjacent to a possibly centerpoint</a>
<a name="ln1849">      that has at least one double bond (possibly if positively charged);</a>
<a name="ln1850">   if eif.cAcceptor then the bond between the atom and the centerpoint must be possibly double</a>
<a name="ln1851">   if eif.cAcceptor then the bond must be possibly single</a>
<a name="ln1852">   Donors that belong to a t-group are also acceptors</a>
<a name="ln1853"> </a>
<a name="ln1854"> </a>
<a name="ln1855">*/</a>
<a name="ln1856">    int tg, i, j, type, endpoint_valence, num_centerpoints, bond_type, centerpoint;</a>
<a name="ln1857">    ENDPOINT_INFO eif;</a>
<a name="ln1858">    /* one-time initialization */</a>
<a name="ln1859">    if ( !el_number_O &amp;&amp; !bAccept_O ) {</a>
<a name="ln1860">       /* el_number_C  = get_periodic_table_number( &quot;C&quot; ); */</a>
<a name="ln1861">       /* el_number_N  = get_periodic_table_number( &quot;N&quot; ); */</a>
<a name="ln1862">        el_number_O  = get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln1863">        el_number_S  = get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln1864">        el_number_Se = get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln1865">        el_number_Te = get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln1866">    }</a>
<a name="ln1867">    *s_subtype = 0; /* initialize the output */</a>
<a name="ln1868">    if ( !bAccept_O /* only N */ &amp;&amp; </a>
<a name="ln1869">         (at[at_no].el_number == el_number_O  ||</a>
<a name="ln1870">          at[at_no].el_number == el_number_S  ||</a>
<a name="ln1871">          at[at_no].el_number == el_number_Se ||</a>
<a name="ln1872">          at[at_no].el_number == el_number_Te ) ) {</a>
<a name="ln1873">        return -1; /* we are not looking for oxygen here */</a>
<a name="ln1874">    }</a>
<a name="ln1875"> </a>
<a name="ln1876">    type = 1;</a>
<a name="ln1877">    if ( !(endpoint_valence = nGetEndpointInfo( at, at_no, &amp;eif )) ) {</a>
<a name="ln1878">        return -1; /* not a possible endpoint */</a>
<a name="ln1879">    } else {</a>
<a name="ln1880">        /* at[at_no] is not not in a tautomeric group; use eif previously filled out by nGetEndpointInfo */</a>
<a name="ln1881">        /* check whether there is adjacent atom-candidate for a centerpoint */</a>
<a name="ln1882">        num_centerpoints = 0;</a>
<a name="ln1883">        for ( j = 0; j &lt; at[at_no].valence; j ++ ) {</a>
<a name="ln1884">            bond_type   = (int)at[at_no].bond_type[j] &amp; BOND_TYPE_MASK;</a>
<a name="ln1885">            centerpoint = (int)at[at_no].neighbor[j];  /*  a centerpoint candidate */</a>
<a name="ln1886">            if ( ( (eif.cAcceptor &amp;&amp; (bond_type == BOND_DOUBLE  ||</a>
<a name="ln1887">                                     bond_type == BOND_ALTERN  || /* possibly double */</a>
<a name="ln1888">                                     bond_type == BOND_ALT12NS ||</a>
<a name="ln1889">                                     bond_type == BOND_TAUTOM   ))  ||</a>
<a name="ln1890">                   (eif.cDonor    &amp;&amp; (bond_type == BOND_SINGLE  ||</a>
<a name="ln1891">                                     bond_type == BOND_ALTERN  || /* possibly single */</a>
<a name="ln1892">                                     bond_type == BOND_ALT12NS ||</a>
<a name="ln1893">                                     bond_type == BOND_TAUTOM   ))  ) &amp;&amp;</a>
<a name="ln1894">                   (at[centerpoint].chem_bonds_valence &gt;  at[centerpoint].valence ||</a>
<a name="ln1895">                   /* check for possible endpoint added 2004-02-24 */</a>
<a name="ln1896">                    (at[centerpoint].chem_bonds_valence == at[centerpoint].valence &amp;&amp;</a>
<a name="ln1897">                    (at[centerpoint].endpoint || at[centerpoint].c_point)) /* tautomerism or charge may increment at[centerpoint].chem_bonds_valence*/ ) &amp;&amp;</a>
<a name="ln1898">                   is_centerpoint_elem( at[centerpoint].el_number ) ) {</a>
<a name="ln1899">                num_centerpoints ++;</a>
<a name="ln1900">                break; /* at least one possibly centerpoint neighbor has been found */</a>
<a name="ln1901">            }</a>
<a name="ln1902">        }</a>
<a name="ln1903">        if ( !num_centerpoints ) {</a>
<a name="ln1904">            return -1;</a>
<a name="ln1905">        }</a>
<a name="ln1906">        /* moved here from just after &quot;type = 1;&quot; line 2004-02-26 */</a>
<a name="ln1907">        if ( (tg = at[at_no].endpoint) &amp;&amp; t_group_info &amp;&amp; t_group_info-&gt;t_group ) {</a>
<a name="ln1908">            /* atom is in a tautomeric group */</a>
<a name="ln1909">            for ( i = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln1910">                if ( tg == t_group_info-&gt;t_group[i].nGroupNumber ) {</a>
<a name="ln1911">                    /*</a>
<a name="ln1912">                    t_group_info-&gt;t_group[i].num[0] = number of attached H-atoms and negative charges</a>
<a name="ln1913">                    t_group_info-&gt;t_group[i].num[1] = number of attached negative charges</a>
<a name="ln1914">                    */</a>
<a name="ln1915">                    if ( t_group_info-&gt;t_group[i].num[0] &gt; t_group_info-&gt;t_group[i].num[1] ) {</a>
<a name="ln1916">                        *s_subtype |= SALT_DONOR_H; /* has H */</a>
<a name="ln1917">                    }</a>
<a name="ln1918">                    if ( t_group_info-&gt;t_group[i].num[1] ) {</a>
<a name="ln1919">                        *s_subtype |= SALT_DONOR_Neg; /* has (-) */</a>
<a name="ln1920">                    }</a>
<a name="ln1921">                    *s_subtype |= SALT_ACCEPTOR; /* there is always an acceptor in a t-group */</a>
<a name="ln1922">                    return type;</a>
<a name="ln1923">                }</a>
<a name="ln1924">            }</a>
<a name="ln1925">            return -1; /* error: t-group not found */</a>
<a name="ln1926">        }</a>
<a name="ln1927"> </a>
<a name="ln1928">        if ( eif.cAcceptor ) {</a>
<a name="ln1929">            *s_subtype |= SALT_ACCEPTOR;</a>
<a name="ln1930">        }</a>
<a name="ln1931">        if ( eif.cDonor ) {</a>
<a name="ln1932">            if ( at[at_no].charge == -1 ) {</a>
<a name="ln1933">                *s_subtype |= SALT_DONOR_Neg; /* has (-) */</a>
<a name="ln1934">            }</a>
<a name="ln1935">            if ( at[at_no].num_H ) {</a>
<a name="ln1936">                *s_subtype |= SALT_DONOR_H; /* has H */</a>
<a name="ln1937">            }</a>
<a name="ln1938">        }</a>
<a name="ln1939">    }</a>
<a name="ln1940">    return type;</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943"> </a>
<a name="ln1944"> </a>
<a name="ln1945">/*****************************************************************************/</a>
<a name="ln1946">int GetOtherSaltType( inp_ATOM *at, int at_no, int *s_subtype )</a>
<a name="ln1947">{</a>
<a name="ln1948">    static int el_number_C  = 0;</a>
<a name="ln1949">   /* static int el_number_N  = 0; */</a>
<a name="ln1950">   /* static int el_number_O  = 0; */</a>
<a name="ln1951">    static int el_number_S  = 0;</a>
<a name="ln1952">    static int el_number_Se = 0;</a>
<a name="ln1953">    static int el_number_Te = 0;</a>
<a name="ln1954"> </a>
<a name="ln1955">/* </a>
<a name="ln1956">   type (returned value):</a>
<a name="ln1957">    -1 =&gt; ignore</a>
<a name="ln1958">     2 =&gt; found:                           SH</a>
<a name="ln1959">          proton donor     -CH2-SH, &gt;CH-SH, &gt;C&lt;    S(-)</a>
<a name="ln1960">          proton acceptor  -CH2-S(-), &gt;CH-S(-), &gt;C&lt;</a>
<a name="ln1961">   subtype:</a>
<a name="ln1962">     1 = SALT_DONOR_H   =&gt; has H </a>
<a name="ln1963">     2 = SALT_DONOR_Neg =&gt; has (-) charge</a>
<a name="ln1964">     4 = SALT_ACCEPTOR  =&gt; may be an acceptor of H or (-), but not necessarily</a>
<a name="ln1965"> </a>
<a name="ln1966">   non-O-atom should be:</a>
<a name="ln1967">     - a tautomeric endpoint atom</a>
<a name="ln1968">     - connected to possible middle point atom</a>
<a name="ln1969">*/</a>
<a name="ln1970">    int type, endpoint_valence, bond_type, centerpoint;</a>
<a name="ln1971">    ENDPOINT_INFO eif;</a>
<a name="ln1972"> </a>
<a name="ln1973">    if ( at[at_no].valence != 1 || at[at_no].chem_bonds_valence != 1 ||</a>
<a name="ln1974">         1 != (at[at_no].num_H==1) + (at[at_no].charge==-1) ) {</a>
<a name="ln1975">        return -1;</a>
<a name="ln1976">    }</a>
<a name="ln1977">    /* one-time initialization */</a>
<a name="ln1978">    if ( !el_number_S ) {</a>
<a name="ln1979">        el_number_C  = get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln1980">       /* el_number_N  = get_periodic_table_number( &quot;N&quot; ); */</a>
<a name="ln1981">       /* el_number_O  = get_periodic_table_number( &quot;O&quot; ); */</a>
<a name="ln1982">        el_number_S  = get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln1983">        el_number_Se = get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln1984">        el_number_Te = get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln1985">    }</a>
<a name="ln1986">    *s_subtype = 0; /* initialize the output */</a>
<a name="ln1987">    if ( !(at[at_no].el_number == el_number_S  ||</a>
<a name="ln1988">           at[at_no].el_number == el_number_Se ||</a>
<a name="ln1989">           at[at_no].el_number == el_number_Te ) ) {</a>
<a name="ln1990">        return -1; /* we are not looking for oxygen here */</a>
<a name="ln1991">    }</a>
<a name="ln1992"> </a>
<a name="ln1993">    type = 2; /* non-tautomeric p-donor or acceptor: C-SH, C-S(-) */</a>
<a name="ln1994"> </a>
<a name="ln1995">    if ( !(endpoint_valence = nGetEndpointInfo( at, at_no, &amp;eif )) ||</a>
<a name="ln1996">         (eif.cMoveableCharge &amp;&amp; !at[at_no].c_point) || !eif.cDonor || eif.cAcceptor ) {</a>
<a name="ln1997">        return -1; /* not a possible -SH or -S(-) */</a>
<a name="ln1998">    } else {</a>
<a name="ln1999">        /* at[at_no] is not not in a tautomeric group; use eif previously filled out by nGetEndpointInfo */</a>
<a name="ln2000">        /* check whether there is adjacent atom-candidate for a centerpoint */</a>
<a name="ln2001">        centerpoint = (int)at[at_no].neighbor[0];</a>
<a name="ln2002">        bond_type   = (int)at[at_no].bond_type[0] &amp; BOND_TYPE_MASK;</a>
<a name="ln2003">        if ( at[centerpoint].el_number != el_number_C ||</a>
<a name="ln2004">             at[centerpoint].charge ||</a>
<a name="ln2005">             (at[centerpoint].radical &amp;&amp; at[centerpoint].radical != RADICAL_SINGLET) ||</a>
<a name="ln2006">             at[centerpoint].valence != at[centerpoint].chem_bonds_valence ) {</a>
<a name="ln2007">            return -1; /* not a carbon with all single bonds */</a>
<a name="ln2008">        }</a>
<a name="ln2009">        if ( at[at_no].num_H == 1 ) {</a>
<a name="ln2010">            *s_subtype |= SALT_p_DONOR;</a>
<a name="ln2011">        } else</a>
<a name="ln2012">        if ( at[at_no].charge == -1 ) {</a>
<a name="ln2013">            *s_subtype |= SALT_p_ACCEPTOR;</a>
<a name="ln2014">        } else {</a>
<a name="ln2015">            return -1;</a>
<a name="ln2016">        }</a>
<a name="ln2017">    }</a>
<a name="ln2018">    return type;</a>
<a name="ln2019">}</a>
<a name="ln2020"> </a>
<a name="ln2021">/********************************************************************************************************/</a>
<a name="ln2022">/* new version: merge all, check alt paths, then unmerge unreachable O-atoms if any */</a>
<a name="ln2023">/* Check for oxygen negative charge-H tautomerism (Salts)</a>
<a name="ln2024">   allowed long-range tautomerism; more than one H or (-) can be moved, for example:</a>
<a name="ln2025">   HO-C=C-O(-)         O=C-C=O   </a>
<a name="ln2026">     /   \              /   \    </a>
<a name="ln2027">    R     R            R     R   </a>
<a name="ln2028">    |     |       =&gt;   |     |   </a>
<a name="ln2029">    R'    R'           R'    R'  </a>
<a name="ln2030">     \   /              \   /    </a>
<a name="ln2031">    O=C-C=O           HO-C=C-O(-)</a>
<a name="ln2032"> </a>
<a name="ln2033">    To check:</a>
<a name="ln2034"> </a>
<a name="ln2035">                          |             |</a>
<a name="ln2036">     -add all possible HO-C=, O=C, (-)O-C= (including all containing O t-groups) into one t-group;</a>
<a name="ln2037">     -temporarily disconnect one of previously not belonging to any t-group O-atoms from the one t-group;</a>
<a name="ln2038">     -find whether there is an alt path allowing H or (-) to migrate</a>
<a name="ln2039">      from the temp. disconnected O to any one left in the group.</a>
<a name="ln2040">      If the alt path does not exist then the temp. disconnected atom does not</a>
<a name="ln2041">      participate in the H/(-) migrartion and it will be unmarked/unmerged.</a>
<a name="ln2042"> </a>
<a name="ln2043">*/</a>
<a name="ln2044"> </a>
<a name="ln2045"> </a>
<a name="ln2046"> </a>
<a name="ln2047">/*****************************************************************************/</a>
<a name="ln2048">int comp_candidates( const void *a1, const void *a2 )</a>
<a name="ln2049">{</a>
<a name="ln2050">    const S_CANDIDATE *s1 = (const S_CANDIDATE *)a1;</a>
<a name="ln2051">    const S_CANDIDATE *s2 = (const S_CANDIDATE *)a2;</a>
<a name="ln2052">    int ret;</a>
<a name="ln2053">    if ( s1-&gt;type &gt;= 0 /* enabled &lt; */  &amp;&amp; s2-&gt;type &lt; 0 /* disabled */ )</a>
<a name="ln2054">        return -1; /* enabled goes first */</a>
<a name="ln2055">    if ( s1-&gt;type &lt;  0 /* disabled &gt; */ &amp;&amp; s2-&gt;type &gt;= 0 /* enabled */ )</a>
<a name="ln2056">        return 1;</a>
<a name="ln2057">    if ( s1-&gt;endpoint &amp;&amp; !s2-&gt;endpoint )</a>
<a name="ln2058">        return -1; /* tautomeric goes first; only tautomeric may be disabled */</a>
<a name="ln2059">    if ( !s1-&gt;endpoint &amp;&amp; s2-&gt;endpoint )</a>
<a name="ln2060">        return 1; /* tautomeric goes first; only tautomeric may be disabled */</a>
<a name="ln2061">    if ( s1-&gt;endpoint &amp;&amp; s2-&gt;endpoint &amp;&amp; (ret = (int)s1-&gt;endpoint - (int)s2-&gt;endpoint) ) {</a>
<a name="ln2062">        return ret;</a>
<a name="ln2063">    }</a>
<a name="ln2064">    return (int)s1-&gt;atnumber - (int)s2-&gt;atnumber;</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067"> </a>
<a name="ln2068"> </a>
<a name="ln2069">/*****************************************************************************/</a>
<a name="ln2070">int MarkSaltChargeGroups2 ( inp_ATOM *at, int num_atoms, S_GROUP_INFO *s_group_info,</a>
<a name="ln2071">                          T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info,</a>
<a name="ln2072">                          struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD )</a>
<a name="ln2073">{</a>
<a name="ln2074">/* BNS_EDGE_FORBIDDEN_TEMP */</a>
<a name="ln2075">#define ALT_PATH_FOUND    (MAX_ATOMS+1)</a>
<a name="ln2076">#define NO_ENDPOINT       (MAX_ATOMS+2)  /* the two defines must be different */</a>
<a name="ln2077">#define DISABLE_CANDIDATE 10</a>
<a name="ln2078">#define cPAIR(a,b) cPair[a+b*nNumLeftCandidates]</a>
<a name="ln2079">#define ACCEPTOR_PAIR 1</a>
<a name="ln2080">#define DONOR_PAIR    2</a>
<a name="ln2081"> </a>
<a name="ln2082">    int nNumChanges = 0, nNumOtherChanges = 0, nNumAcidicChanges = 0, nTotNumChanges = 0;</a>
<a name="ln2083">    S_CHAR      *cPair    = NULL;</a>
<a name="ln2084">    T_ENDPOINT  *EndPoint = NULL;</a>
<a name="ln2085">    if ( s_group_info &amp;&amp; s_group_info-&gt;s_candidate &amp;&amp; s_group_info-&gt;max_num_candidates &gt; 0 ) {</a>
<a name="ln2086">        int i, j, i1, j1;</a>
<a name="ln2087">        S_CANDIDATE *s_candidate         = s_group_info-&gt;s_candidate;</a>
<a name="ln2088">        int          nMaxNumCandidates   = s_group_info-&gt;max_num_candidates;</a>
<a name="ln2089">        int          nNumCandidates      = s_group_info-&gt;num_candidates;</a>
<a name="ln2090">        int          nNumOtherCandidates = s_group_info-&gt;num_other_candidates;</a>
<a name="ln2091">        int          nNumPOnlyCandidates = s_group_info-&gt;num_p_only_candidates;</a>
<a name="ln2092">        int          nNumLeftCandidates  = 0;</a>
<a name="ln2093">        int          nNumMarkedCandidates = 0;</a>
<a name="ln2094">        int          s_type, s_subtype;</a>
<a name="ln2095">        int          ret, nDelta;</a>
<a name="ln2096">        int          bHardAddedRemovedProtons = t_group_info &amp;&amp; (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT);</a>
<a name="ln2097"> </a>
<a name="ln2098">        int          s_subtype_all = 0;</a>
<a name="ln2099">        int          nDonorPairs, nAcceptorPairs, nCurDonorPairs, nCurAcceptorPairs, bAlreadyTested;</a>
<a name="ln2100">/*</a>
<a name="ln2101">        ENDPOINT_INFO    eif;</a>
<a name="ln2102">*/</a>
<a name="ln2103"> </a>
<a name="ln2104">#if ( IGNORE_TGROUP_WITHOUT_H == 1 )</a>
<a name="ln2105">        int          bTGroupHasNegativeChargesOnly = 1;</a>
<a name="ln2106">#endif</a>
<a name="ln2107">        /*return 0;*/ /* debug only */</a>
<a name="ln2108">        </a>
<a name="ln2109">        i1 = -1;</a>
<a name="ln2110"> </a>
<a name="ln2111">        if ( nNumCandidates &lt;= -2 || !t_group_info || !t_group_info-&gt;t_group ) {</a>
<a name="ln2112">            return 0;</a>
<a name="ln2113">        }</a>
<a name="ln2114">        /*************************************************************************/</a>
<a name="ln2115">        /* find all candidates including those with differen s_type (other type) */</a>
<a name="ln2116">        /*************************************************************************/</a>
<a name="ln2117">        for ( i = 0, nNumCandidates = nNumOtherCandidates = nNumPOnlyCandidates = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2118">            if ( 0 == (s_type = GetSaltChargeType( at, i, t_group_info, &amp;s_subtype )) ||</a>
<a name="ln2119">                 /* -C=O or =C-OH, O = S, Se, Te */</a>
<a name="ln2120">                 1 == (s_type = GetOtherSaltChargeType( at, i, t_group_info, &amp;s_subtype, 1/* bAccept_O*/ ))  ||</a>
<a name="ln2121">                 /* =Z-MH or -Z=M, Z = centerpoint, M = endpoint, other than above */</a>
<a name="ln2122">                 2 == (s_type = GetOtherSaltType( at, i, &amp;s_subtype ) ) ||</a>
<a name="ln2123">                 ( bHardAddedRemovedProtons &amp;&amp; 4 == (s_type = bIsHardRemHCandidate( at, i, &amp;s_subtype ) ) )</a>
<a name="ln2124">                 /* &gt;C-SH, &gt;C-S(-); S=S,Se,Te */</a>
<a name="ln2125">               ) {</a>
<a name="ln2126"> </a>
<a name="ln2127">                if ( nNumCandidates &gt;= nMaxNumCandidates ) {</a>
<a name="ln2128">                    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2129">                }</a>
<a name="ln2130">                s_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln2131">                s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2132">                s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2133">                s_candidate[nNumCandidates].endpoint = at[i].endpoint;</a>
<a name="ln2134">                nNumCandidates ++;</a>
<a name="ln2135">                nNumOtherCandidates += (1 == s_type);</a>
<a name="ln2136">                s_subtype_all                        |= s_subtype;</a>
<a name="ln2137">                i1 = i; /* save a representative of a tautomeric group */</a>
<a name="ln2138">            }</a>
<a name="ln2139">        }</a>
<a name="ln2140"> </a>
<a name="ln2141">        if ( nNumCandidates &lt;= 1 ||  /* TG_FLAG_ALLOW_NO_NEGTV_O &lt;=&gt; CHARGED_SALTS_ONLY=0 */</a>
<a name="ln2142">             !(s_subtype_all &amp; SALT_ACCEPTOR) ||</a>
<a name="ln2143">             (((t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O) ||</a>
<a name="ln2144">               (t_group_info-&gt;bTautFlagsDone &amp; TG_FLAG_FOUND_SALT_CHARGES_DONE) ||</a>
<a name="ln2145">               (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT)) ?</a>
<a name="ln2146">                !(s_subtype_all &amp; (SALT_DONOR)):</a>
<a name="ln2147">                (!(s_subtype_all &amp; SALT_DONOR_Neg) || nNumOtherCandidates == nNumCandidates ))</a>
<a name="ln2148">            ) {</a>
<a name="ln2149">            s_group_info-&gt;num_candidates = 0; /* no candidate exists */</a>
<a name="ln2150">            return 0;</a>
<a name="ln2151">        }</a>
<a name="ln2152">        if ( !(s_subtype_all &amp; (SALT_DONOR_Neg) ) ) {</a>
<a name="ln2153">            t_group_info-&gt;bTautFlagsDone |= TG_FLAG_ALLOW_NO_NEGTV_O_DONE;</a>
<a name="ln2154">        }</a>
<a name="ln2155"> </a>
<a name="ln2156">        /************************************************************************************/</a>
<a name="ln2157">        /* Mark redundant candidates so that only one candidate from one t-group is left in */</a>
<a name="ln2158">        /************************************************************************************/</a>
<a name="ln2159">        for ( i = 0; i &lt; nNumCandidates; i ++ ) {</a>
<a name="ln2160">            if ( 2 == s_candidate[nNumCandidates].type ) {</a>
<a name="ln2161">                s_candidate[i].type -= DISABLE_CANDIDATE; /* disable &gt;C-SH candidates */</a>
<a name="ln2162">                nNumLeftCandidates ++; /* count rejected */</a>
<a name="ln2163">                continue;</a>
<a name="ln2164">            }</a>
<a name="ln2165">            if ( s_candidate[i].endpoint ) {</a>
<a name="ln2166">                for ( j = i-1; 0 &lt;= j; j -- ) {</a>
<a name="ln2167">                    if ( s_candidate[i].endpoint == s_candidate[j].endpoint ) {</a>
<a name="ln2168">                        s_candidate[i].type -= DISABLE_CANDIDATE; /* disable subsequent redundant */</a>
<a name="ln2169">                        nNumLeftCandidates ++; /* count rejected */</a>
<a name="ln2170">                        break;</a>
<a name="ln2171">                    }</a>
<a name="ln2172">                }</a>
<a name="ln2173">            }</a>
<a name="ln2174">        }</a>
<a name="ln2175">        nNumLeftCandidates = nNumCandidates - nNumLeftCandidates; /* subtract num. rejected from the total */</a>
<a name="ln2176">        s_group_info-&gt;num_candidates = 0; /* reinit next time */</a>
<a name="ln2177">        /*********************************************************************/</a>
<a name="ln2178">        /* reorder so that all disabled are at the end, tautomeric are first */</a>
<a name="ln2179">        /*********************************************************************/</a>
<a name="ln2180">        qsort ( s_candidate, nNumCandidates, sizeof(s_candidate[0]), comp_candidates );</a>
<a name="ln2181">        cPair = (S_CHAR *)inchi_calloc( nNumLeftCandidates*nNumLeftCandidates, sizeof(cPair[0]) );</a>
<a name="ln2182">        if ( !cPair ) {</a>
<a name="ln2183">            /*printf(&quot;BNS_OUT_OF_RAM-6\n&quot;);*/</a>
<a name="ln2184">            nTotNumChanges = BNS_OUT_OF_RAM;</a>
<a name="ln2185">            goto quick_exit;</a>
<a name="ln2186">        }</a>
<a name="ln2187">        nDonorPairs = nAcceptorPairs = 0;</a>
<a name="ln2188">        /**********************************************************************/</a>
<a name="ln2189">        /* Find whether we have at least one donor pair and one acceptor pair */</a>
<a name="ln2190">        /**********************************************************************/</a>
<a name="ln2191">        for ( i = 0; i &lt; nNumLeftCandidates; i ++ ) {</a>
<a name="ln2192">            nCurDonorPairs = nCurAcceptorPairs = 0;</a>
<a name="ln2193">            for ( j = 0; j &lt;= i; j ++ ) {</a>
<a name="ln2194">                if ( i == j &amp;&amp; !s_candidate[i].endpoint ) {</a>
<a name="ln2195">                    continue;  /* same non-taut atom. However, success for i==j means     *</a>
<a name="ln2196">                                * that the whole tautomeric group may donate or accept 2H */</a>
<a name="ln2197">                }</a>
<a name="ln2198">                /* check for acceptor pair */</a>
<a name="ln2199">                if ( (s_candidate[i].subtype &amp; SALT_ACCEPTOR) &amp;&amp; (s_candidate[j].subtype &amp; SALT_ACCEPTOR) &amp;&amp;</a>
<a name="ln2200">                     (ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, s_candidate[i].atnumber,</a>
<a name="ln2201">                                            s_candidate[j].atnumber, ALT_PATH_MODE_ADD2H_TST ))) {</a>
<a name="ln2202">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2203">                        nTotNumChanges = ret;</a>
<a name="ln2204">                        goto quick_exit;</a>
<a name="ln2205">                    }</a>
<a name="ln2206">                    if ( ret &amp; 1 ) {</a>
<a name="ln2207">                        nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln2208">                        /*nNumChanges += (ret &amp; 2);*/</a>
<a name="ln2209">                        if ( nDelta ) {</a>
<a name="ln2210">                            /* alt path unleashed previously localized radicals and they annihilated */</a>
<a name="ln2211">                            nNumChanges = 0;</a>
<a name="ln2212">                            nTotNumChanges = BNS_RADICAL_ERR;</a>
<a name="ln2213">                            goto quick_exit;</a>
<a name="ln2214">                        }</a>
<a name="ln2215">                        cPAIR(i,j) |= ACCEPTOR_PAIR; /* the result: mark the pair */</a>
<a name="ln2216">                        /*cPAIR(j,i) |= ACCEPTOR_PAIR;*/</a>
<a name="ln2217">                    }</a>
<a name="ln2218">                }</a>
<a name="ln2219">                /* check for donor pair */</a>
<a name="ln2220">                if ( (s_candidate[i].subtype &amp; SALT_DONOR) &amp;&amp; (s_candidate[j].subtype &amp; SALT_DONOR) &amp;&amp;</a>
<a name="ln2221">                     (ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, s_candidate[i].atnumber,</a>
<a name="ln2222">                                            s_candidate[j].atnumber, ALT_PATH_MODE_REM2H_TST ))) {</a>
<a name="ln2223">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2224">                        nTotNumChanges = ret;</a>
<a name="ln2225">                        goto quick_exit;</a>
<a name="ln2226">                    }</a>
<a name="ln2227">                    if ( ret &amp; 1 ) {</a>
<a name="ln2228">                        nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln2229">                        /*nNumChanges += (ret &amp; 2);*/</a>
<a name="ln2230">                        if ( nDelta ) {</a>
<a name="ln2231">                            /* alt path unleashed previously localized radicals and they annihilated */</a>
<a name="ln2232">                            nNumChanges = 0;</a>
<a name="ln2233">                            nTotNumChanges = BNS_RADICAL_ERR;</a>
<a name="ln2234">                            goto quick_exit;</a>
<a name="ln2235">                        }</a>
<a name="ln2236">                        cPAIR(i,j) |= DONOR_PAIR; /* the result: mark the pair */</a>
<a name="ln2237">                        /*cPAIR(j,i) |= ACCEPTOR_PAIR;*/</a>
<a name="ln2238">                    }</a>
<a name="ln2239">                }</a>
<a name="ln2240">                /* since the results will be used later to change bonds, check only now */</a>
<a name="ln2241">                /* when both results for (i,j) have been obtained. */</a>
<a name="ln2242">                if ( cPAIR(i,j) &amp; ACCEPTOR_PAIR ) {</a>
<a name="ln2243">                    nCurAcceptorPairs ++;</a>
<a name="ln2244">                    if ( nDonorPairs ) {</a>
<a name="ln2245">                        /* find donor pair (i1,j1) such that i!=i1, i!=j1, j!=i1, j!=j1 */</a>
<a name="ln2246">                        for ( i1 = 0; i1 &lt; i; i1 ++ ) {</a>
<a name="ln2247">                            for ( j1 = 0; j1 &lt;= i1; j1 ++ ) {</a>
<a name="ln2248">                                /* here always j1 &lt; i &amp;&amp; i1 &lt; i therefore we do not compare i to i1 or j1 */</a>
<a name="ln2249">                                if ( j1 != j &amp;&amp; i1 != j &amp;&amp; (cPAIR(i1,j1) &amp; DONOR_PAIR) ) { </a>
<a name="ln2250">                                    /* both the donor and the acceptor pairs have been found */</a>
<a name="ln2251">                                    goto bFound2Pairs;</a>
<a name="ln2252">                                }</a>
<a name="ln2253">                            }</a>
<a name="ln2254">                        }</a>
<a name="ln2255">                    }</a>
<a name="ln2256">                }</a>
<a name="ln2257">                if ( cPAIR(i,j) &amp; DONOR_PAIR ) {</a>
<a name="ln2258">                    nCurDonorPairs ++;</a>
<a name="ln2259">                    if ( nAcceptorPairs ) {</a>
<a name="ln2260">                        /* find acceptor pair (i1,j1) such that i!=i1, i!=j1, j!=i1, j!=j1 */</a>
<a name="ln2261">                        for ( i1 = 0; i1 &lt; i; i1 ++ ) {</a>
<a name="ln2262">                            for ( j1 = 0; j1 &lt;= i1; j1 ++ ) {</a>
<a name="ln2263">                                /* here always j1 &lt; i &amp;&amp; i1 &lt; i therefore we do not compare i to i1 or j1 */</a>
<a name="ln2264">                                if ( j1 != j &amp;&amp; i1 != j &amp;&amp; (cPAIR(i1,j1) &amp; ACCEPTOR_PAIR) ) { </a>
<a name="ln2265">                                    /* both the donor and the acceptor pairs have been found */</a>
<a name="ln2266">                                    goto bFound2Pairs;</a>
<a name="ln2267">                                }</a>
<a name="ln2268">                            }</a>
<a name="ln2269">                        }</a>
<a name="ln2270">                    }</a>
<a name="ln2271">                }</a>
<a name="ln2272">            }</a>
<a name="ln2273">            nDonorPairs    += nCurDonorPairs;</a>
<a name="ln2274">            nAcceptorPairs += nCurAcceptorPairs;</a>
<a name="ln2275">        }</a>
<a name="ln2276">        /* nothing has been found */</a>
<a name="ln2277">        nNumChanges = 0;</a>
<a name="ln2278">        inchi_free( cPair );</a>
<a name="ln2279">        cPair = NULL;</a>
<a name="ln2280">        goto quick_exit;</a>
<a name="ln2281"> </a>
<a name="ln2282"> </a>
<a name="ln2283">        /* both the donor and the acceptor pairs have been found */</a>
<a name="ln2284">bFound2Pairs:</a>
<a name="ln2285">        /* first, try already found pairs */</a>
<a name="ln2286">        i1 = i;</a>
<a name="ln2287">        j1 = j;</a>
<a name="ln2288"> </a>
<a name="ln2289">        /* Find all possible donor and acceptor pairs */</a>
<a name="ln2290">        nNumMarkedCandidates = 0;</a>
<a name="ln2291">        for ( i = 0; i &lt; nNumLeftCandidates; i ++ ) {</a>
<a name="ln2292">            nCurDonorPairs = nCurAcceptorPairs = 0;</a>
<a name="ln2293">            for ( j = 0; j &lt;= i; j ++ ) {</a>
<a name="ln2294">                bAlreadyTested = (i &lt; i1 || (i == i1 &amp;&amp; j &lt;= j1));</a>
<a name="ln2295">                if ( (bAlreadyTested &amp;&amp; (cPAIR(i,j) &amp; ACCEPTOR_PAIR)) || !bAlreadyTested ) {</a>
<a name="ln2296">                    /* checking for acceptor pair */</a>
<a name="ln2297">                    if ( (s_candidate[i].subtype &amp; SALT_ACCEPTOR) &amp;&amp; (s_candidate[j].subtype &amp; SALT_ACCEPTOR) &amp;&amp;</a>
<a name="ln2298">                         (ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, s_candidate[i].atnumber,</a>
<a name="ln2299">                                                s_candidate[j].atnumber, ALT_PATH_MODE_ADD2H_CHG ))) {</a>
<a name="ln2300">                        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2301">                            nTotNumChanges = ret;</a>
<a name="ln2302">                            goto quick_exit;</a>
<a name="ln2303">                        }</a>
<a name="ln2304">                        if ( ret &amp; 1 ) {</a>
<a name="ln2305">                            nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln2306">                            nNumChanges += (ret &amp; 2);</a>
<a name="ln2307">                            if ( nDelta ) {</a>
<a name="ln2308">                                /* alt path unleashed previously localized radicals and they annihilated */</a>
<a name="ln2309">                                nNumChanges = 0;</a>
<a name="ln2310">                                nTotNumChanges = BNS_RADICAL_ERR;</a>
<a name="ln2311">                                goto quick_exit;</a>
<a name="ln2312">                            }</a>
<a name="ln2313">                            cPAIR(i,j) |= ACCEPTOR_PAIR;</a>
<a name="ln2314">                            /*cPAIR(j,i) |= ACCEPTOR_PAIR;*/</a>
<a name="ln2315">                            nCurAcceptorPairs += !bAlreadyTested;</a>
<a name="ln2316">                            if ( !(s_candidate[i].subtype &amp; SALT_SELECTED) ) {</a>
<a name="ln2317">                                s_candidate[i].subtype |= SALT_SELECTED;</a>
<a name="ln2318">                                nNumMarkedCandidates ++;</a>
<a name="ln2319">                                if ( !s_candidate[i].endpoint &amp;&amp; s_candidate[i].type ) {</a>
<a name="ln2320">                                    nNumOtherChanges ++;</a>
<a name="ln2321">                                } else {</a>
<a name="ln2322">                                    nNumAcidicChanges ++;</a>
<a name="ln2323">                                }</a>
<a name="ln2324">                            }</a>
<a name="ln2325">                            if ( !(s_candidate[j].subtype &amp; SALT_SELECTED) ) {</a>
<a name="ln2326">                                s_candidate[j].subtype |= SALT_SELECTED;</a>
<a name="ln2327">                                nNumMarkedCandidates ++;</a>
<a name="ln2328">                                if ( !s_candidate[j].endpoint &amp;&amp; s_candidate[j].type ) {</a>
<a name="ln2329">                                    nNumOtherChanges ++;</a>
<a name="ln2330">                                } else {</a>
<a name="ln2331">                                    nNumAcidicChanges ++;</a>
<a name="ln2332">                                }</a>
<a name="ln2333">                            }</a>
<a name="ln2334">                        }</a>
<a name="ln2335">                    }</a>
<a name="ln2336">                }</a>
<a name="ln2337">                if ( (bAlreadyTested &amp;&amp; (cPAIR(i,j) &amp; DONOR_PAIR)) || !bAlreadyTested ) {</a>
<a name="ln2338">                    /* checking for donor pair */</a>
<a name="ln2339">                    if ( (s_candidate[i].subtype &amp; SALT_DONOR) &amp;&amp; (s_candidate[j].subtype &amp; SALT_DONOR) &amp;&amp;</a>
<a name="ln2340">                         (ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, s_candidate[i].atnumber,</a>
<a name="ln2341">                                                s_candidate[j].atnumber, ALT_PATH_MODE_REM2H_CHG ))) {</a>
<a name="ln2342">                        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2343">                            nTotNumChanges = ret;</a>
<a name="ln2344">                            goto quick_exit;</a>
<a name="ln2345">                        }</a>
<a name="ln2346">                        if ( ret &amp; 1 ) {</a>
<a name="ln2347">                            nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln2348">                            nNumChanges += (ret &amp; 2);</a>
<a name="ln2349">                            if ( nDelta ) {</a>
<a name="ln2350">                                /* alt path unleashed previously localized radicals and they annihilated */</a>
<a name="ln2351">                                nNumChanges = 0;</a>
<a name="ln2352">                                nTotNumChanges = BNS_RADICAL_ERR;</a>
<a name="ln2353">                                goto quick_exit;</a>
<a name="ln2354">                            }</a>
<a name="ln2355">                            cPAIR(i,j) |= DONOR_PAIR;</a>
<a name="ln2356">                            /*cPAIR(j,i) |= ACCEPTOR_PAIR;*/</a>
<a name="ln2357">                            nCurDonorPairs += !bAlreadyTested;</a>
<a name="ln2358">                            if ( !(s_candidate[i].subtype &amp; SALT_SELECTED) ) {</a>
<a name="ln2359">                                s_candidate[i].subtype |= SALT_SELECTED;</a>
<a name="ln2360">                                nNumMarkedCandidates ++;</a>
<a name="ln2361">                                if ( !s_candidate[i].endpoint &amp;&amp; s_candidate[i].type ) {</a>
<a name="ln2362">                                    nNumOtherChanges ++;</a>
<a name="ln2363">                                } else {</a>
<a name="ln2364">                                    nNumAcidicChanges ++;</a>
<a name="ln2365">                                }</a>
<a name="ln2366">                            }</a>
<a name="ln2367">                            if ( !(s_candidate[j].subtype &amp; SALT_SELECTED) ) {</a>
<a name="ln2368">                                s_candidate[j].subtype |= SALT_SELECTED;</a>
<a name="ln2369">                                nNumMarkedCandidates ++;</a>
<a name="ln2370">                                if ( !s_candidate[j].endpoint &amp;&amp; s_candidate[j].type ) {</a>
<a name="ln2371">                                    nNumOtherChanges ++;</a>
<a name="ln2372">                                } else {</a>
<a name="ln2373">                                    nNumAcidicChanges ++;</a>
<a name="ln2374">                                }</a>
<a name="ln2375">                            }</a>
<a name="ln2376">                        }</a>
<a name="ln2377">                    }</a>
<a name="ln2378">                }</a>
<a name="ln2379">            }</a>
<a name="ln2380">            nDonorPairs    += nCurDonorPairs;</a>
<a name="ln2381">            nAcceptorPairs += nCurAcceptorPairs;</a>
<a name="ln2382">        }</a>
<a name="ln2383">        inchi_free( cPair );</a>
<a name="ln2384">        cPair = NULL;</a>
<a name="ln2385"> </a>
<a name="ln2386">        if ( nNumMarkedCandidates  ) {</a>
<a name="ln2387">            EndPoint = (T_ENDPOINT *)inchi_calloc( nNumMarkedCandidates, sizeof(EndPoint[0]));</a>
<a name="ln2388">            if ( !EndPoint ) {</a>
<a name="ln2389">                /*printf(&quot;BNS_OUT_OF_RAM-7\n&quot;);*/</a>
<a name="ln2390">                nTotNumChanges = BNS_OUT_OF_RAM;</a>
<a name="ln2391">                goto quick_exit;</a>
<a name="ln2392">            }</a>
<a name="ln2393">            for ( i = 0, j = 0; i &lt; nNumLeftCandidates; i ++ ) {</a>
<a name="ln2394">                if ( s_candidate[i].subtype &amp; SALT_SELECTED ) {</a>
<a name="ln2395">                    s_candidate[i].subtype ^= SALT_SELECTED; /* remove the flag */</a>
<a name="ln2396">                    if ( j &lt; nNumMarkedCandidates ) {</a>
<a name="ln2397">                        i1 = s_candidate[i].atnumber; /* save a representative of the t-group to be created */</a>
<a name="ln2398">                        AddEndPoint( EndPoint+j, at, i1 );</a>
<a name="ln2399">                    }</a>
<a name="ln2400">                    j ++;</a>
<a name="ln2401">                }</a>
<a name="ln2402">            }</a>
<a name="ln2403">            if ( j != nNumMarkedCandidates ) {</a>
<a name="ln2404">                nTotNumChanges = BNS_PROGRAM_ERR;</a>
<a name="ln2405">                goto quick_exit;</a>
<a name="ln2406">            }</a>
<a name="ln2407">            /* merge all marked atoms and their t-groups into one t-group */</a>
<a name="ln2408">            ret = RegisterEndPoints( t_group_info, EndPoint, nNumMarkedCandidates, at, num_atoms, c_group_info, pBNS );</a>
<a name="ln2409">            if ( ret == -1 ) {</a>
<a name="ln2410">                ret = BNS_PROGRAM_ERR;</a>
<a name="ln2411">            }</a>
<a name="ln2412">            if ( ret &lt; 0 ) {</a>
<a name="ln2413">                nTotNumChanges = ret;</a>
<a name="ln2414">                goto quick_exit;</a>
<a name="ln2415">            }</a>
<a name="ln2416">            nTotNumChanges += (ret &gt; 0);</a>
<a name="ln2417">            inchi_free( EndPoint );</a>
<a name="ln2418">            EndPoint = NULL;</a>
<a name="ln2419"> </a>
<a name="ln2420">            if ( nNumMarkedCandidates ) {</a>
<a name="ln2421">                for ( i = nNumLeftCandidates; i &lt; nNumCandidates; i ++ ) {</a>
<a name="ln2422">                    s_candidate[i].type += DISABLE_CANDIDATE;</a>
<a name="ln2423">                    j1 = s_candidate[i].atnumber;</a>
<a name="ln2424">                    if ( at[j1].endpoint == at[i1].endpoint ) {</a>
<a name="ln2425">                        if ( !s_candidate[i].endpoint &amp;&amp; s_candidate[i].type ) {</a>
<a name="ln2426">                            nNumOtherChanges ++;</a>
<a name="ln2427">                        } else {</a>
<a name="ln2428">                            nNumAcidicChanges ++;</a>
<a name="ln2429">                        }</a>
<a name="ln2430">                    }</a>
<a name="ln2431">                }</a>
<a name="ln2432">            } else {</a>
<a name="ln2433">                for ( i = nNumLeftCandidates; i &lt; nNumCandidates; i ++ ) {</a>
<a name="ln2434">                    s_candidate[i].type += DISABLE_CANDIDATE;</a>
<a name="ln2435">                }</a>
<a name="ln2436">            }</a>
<a name="ln2437"> </a>
<a name="ln2438">            /* find whether the new t-group have any movable H */</a>
<a name="ln2439">            for ( i = 0, bTGroupHasNegativeChargesOnly = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln2440">                if ( t_group_info-&gt;t_group[i].nGroupNumber == at[i1].endpoint &amp;&amp;</a>
<a name="ln2441">                     t_group_info-&gt;t_group[i].num[0] == t_group_info-&gt;t_group[i].num[1] ) {</a>
<a name="ln2442">                    bTGroupHasNegativeChargesOnly = 1;</a>
<a name="ln2443">                    break;</a>
<a name="ln2444">                }</a>
<a name="ln2445">            }</a>
<a name="ln2446">        }</a>
<a name="ln2447">        nTotNumChanges = ( nTotNumChanges &gt; 0);</a>
<a name="ln2448"> </a>
<a name="ln2449">#if ( IGNORE_TGROUP_WITHOUT_H == 1 )</a>
<a name="ln2450">        if ( nTotNumChanges &amp;&amp; bTGroupHasNegativeChargesOnly ) {</a>
<a name="ln2451">            nTotNumChanges = 2;  /* means no moveable H has been affected */</a>
<a name="ln2452">        }</a>
<a name="ln2453">#endif</a>
<a name="ln2454">    }</a>
<a name="ln2455">    </a>
<a name="ln2456">quick_exit:</a>
<a name="ln2457">    if ( nNumOtherChanges &amp;&amp; nTotNumChanges == 1 ) {</a>
<a name="ln2458">        nTotNumChanges = 5; /* not only acidic atoms merged */</a>
<a name="ln2459">    }</a>
<a name="ln2460">    if ( cPair ) {</a>
<a name="ln2461">        inchi_free( cPair );</a>
<a name="ln2462">        /*cPair = NULL;*/</a>
<a name="ln2463">    }</a>
<a name="ln2464">    if ( EndPoint ) {</a>
<a name="ln2465">        inchi_free ( EndPoint );</a>
<a name="ln2466">        /*EndPoint = NULL;*/</a>
<a name="ln2467">    }</a>
<a name="ln2468">    return nTotNumChanges; /* 0=&gt;no changes, 1=&gt;new salt tautomerism found, 2=&gt;only new charge tautomerism found */</a>
<a name="ln2469">#undef ALT_PATH_FOUND</a>
<a name="ln2470">#undef NO_ENDPOINT</a>
<a name="ln2471">}</a>
<a name="ln2472">/********************************************************************************************************/</a>
<a name="ln2473">/* regular one-path version: find alt paths then merge */</a>
<a name="ln2474">/* Check for oxygen negative charge-H tautomerism (Salts)</a>
<a name="ln2475">   allowed long-range tautomerism; only one H or (-) can be moved, for example:</a>
<a name="ln2476">   HO-C=X-Y=Z-...-C=O  =&gt; O=C-X=Y-Z=...=C-OH</a>
<a name="ln2477">*/</a>
<a name="ln2478"> </a>
<a name="ln2479">#if ( SALT_WITH_PROTONS == 1 )</a>
<a name="ln2480"> </a>
<a name="ln2481">#define MAX_LOCAL_TGNUM 0 /* was 32; disable since it has not been used */</a>
<a name="ln2482"> </a>
<a name="ln2483">#if ( MAX_LOCAL_TGNUM &gt; 0 )</a>
<a name="ln2484">typedef struct tagTGroupData {</a>
<a name="ln2485">    S_SHORT nGroupNumber; /* t-group number from t_group_info-&gt;t_group-&gt;nGroupNumber */</a>
<a name="ln2486">    S_SHORT nGroupIndex;  /* TGroupData[nGroupNumber]nGroupIndex = index of t_group in t_group_info */</a>
<a name="ln2487">    S_SHORT nDonorM;      /* number of endpoint-donors that have negative charge (Minus) */</a>
<a name="ln2488">    S_SHORT nDonorH;      /* number of endpoint-donors that have only H */</a>
<a name="ln2489">    S_SHORT nAccepM;      /* number of endpoint-acceptors that have negative charge (Minus) */</a>
<a name="ln2490">    S_SHORT nAccepH;      /* number of endpoint-acceptors that have H and no negative charge */</a>
<a name="ln2491">    S_SHORT nAccep0;      /* number of endpoint-acceptors that have no H and no negative charge */ </a>
<a name="ln2492">    S_SHORT nDonorA;      /* number of acidic endpoint-donors */</a>
<a name="ln2493">    S_SHORT nAccepS;      /* number of acidic endpoint-acceptors */</a>
<a name="ln2494">} TGroupData;</a>
<a name="ln2495">#endif</a>
<a name="ln2496"> </a>
<a name="ln2497"> </a>
<a name="ln2498"> </a>
<a name="ln2499">/*****************************************************************************/</a>
<a name="ln2500">int MarkSaltChargeGroups ( inp_ATOM *at, int num_atoms, S_GROUP_INFO *s_group_info,</a>
<a name="ln2501">                          T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info,</a>
<a name="ln2502">                          struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD )</a>
<a name="ln2503">{</a>
<a name="ln2504">    </a>
<a name="ln2505">    int nNumChanges = 0, nTotNumChanges = 0;</a>
<a name="ln2506">    if ( s_group_info &amp;&amp; s_group_info-&gt;s_candidate &amp;&amp; s_group_info-&gt;max_num_candidates &gt; 0 ) {</a>
<a name="ln2507">        int i, i1, i2, j, j1, j2, jj, ii1, ii2, jj1, jj2, /*k,*/ num_tested;</a>
<a name="ln2508">        S_CANDIDATE *s_candidate         = s_group_info-&gt;s_candidate;</a>
<a name="ln2509">        int          nMaxNumCandidates   = s_group_info-&gt;max_num_candidates;</a>
<a name="ln2510">        int          nNumCandidates      = s_group_info-&gt;num_candidates;</a>
<a name="ln2511">        int          nNumOtherCandidates = s_group_info-&gt;num_other_candidates;</a>
<a name="ln2512">        int          nNumPOnlyCandidates = s_group_info-&gt;num_p_only_candidates;</a>
<a name="ln2513">        int          s_type, s_subtype;</a>
<a name="ln2514">        int          ret, nDelta, /*nMobile,*/ err = 0;</a>
<a name="ln2515">        int          s_subtype_all = 0;</a>
<a name="ln2516">        int          nGroupNumber;</a>
<a name="ln2517">        T_ENDPOINT   EndPoint[2];</a>
<a name="ln2518">#if ( MAX_LOCAL_TGNUM &gt; 0 )</a>
<a name="ln2519">        TGroupData   tgData[MAX_LOCAL_TGNUM];</a>
<a name="ln2520">        TGroupData   *ptgData = tgData;</a>
<a name="ln2521">#endif</a>
<a name="ln2522">        int cond1=0,cond2a=0,cond2b=0,cond2c=0,cond2=0;</a>
<a name="ln2523"> </a>
<a name="ln2524">        if ( nNumCandidates &lt;= -1 || !t_group_info || !t_group_info-&gt;t_group ) {</a>
<a name="ln2525">            return 0;</a>
<a name="ln2526">        }</a>
<a name="ln2527"> </a>
<a name="ln2528">        /* count t-groups */</a>
<a name="ln2529">        for ( i = 0, nGroupNumber = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln2530">            if ( nGroupNumber &lt; t_group_info-&gt;t_group[i].nGroupNumber ) {</a>
<a name="ln2531">                nGroupNumber = t_group_info-&gt;t_group[i].nGroupNumber; /* max. t-group number */</a>
<a name="ln2532">            }</a>
<a name="ln2533">        }</a>
<a name="ln2534">#if ( MAX_LOCAL_TGNUM &gt; 0 )</a>
<a name="ln2535">        /* prepare memory */</a>
<a name="ln2536">        if ( nGroupNumber &gt;= MAX_LOCAL_TGNUM ) {</a>
<a name="ln2537">            if ( !( ptgData = (TGroupData*)inchi_calloc( nGroupNumber+1, sizeof(TGroupData) ) ) ) {</a>
<a name="ln2538">                err = BNS_OUT_OF_RAM;</a>
<a name="ln2539">                goto quick_exit;</a>
<a name="ln2540">            }</a>
<a name="ln2541">        } else {</a>
<a name="ln2542">            memset( ptgData, 0, sizeof(tgData) );</a>
<a name="ln2543">        }</a>
<a name="ln2544">        ptgData[0].nGroupIndex = -1; /* data for non-tautomeric atoms */</a>
<a name="ln2545">        for ( i = 0, nGroupNumber = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln2546">            if ( nGroupNumber = t_group_info-&gt;t_group[i].nGroupNumber ) {</a>
<a name="ln2547">                ptgData[nGroupNumber].nGroupIndex = i;</a>
<a name="ln2548">                ptgData[i].nGroupNumber = nGroupNumber;</a>
<a name="ln2549">            }</a>
<a name="ln2550">        }</a>
<a name="ln2551">#endif</a>
<a name="ln2552">        nNumCandidates = 0; /* always recalculate 2004-03-22 */</a>
<a name="ln2553">        num_tested = 0;</a>
<a name="ln2554"> </a>
<a name="ln2555">        if ( nNumCandidates == 0 ) </a>
<a name="ln2556">        {</a>
<a name="ln2557">            for ( i = 0, nNumCandidates = nNumOtherCandidates = nNumPOnlyCandidates = 0; i &lt; num_atoms; i ++ ) </a>
<a name="ln2558">            {</a>
<a name="ln2559">                if ( 0 == (s_type = GetSaltChargeType( at, i, t_group_info, &amp;s_subtype )) ||</a>
<a name="ln2560">                     /* -C=O or =C-OH, O = S, Se, Te */</a>
<a name="ln2561">#if ( INCL_NON_SALT_CANDIDATATES == 1 )            </a>
<a name="ln2562">                     1 == (s_type = GetOtherSaltChargeType( at, i, t_group_info, &amp;s_subtype, 1 )) ||</a>
<a name="ln2563">                     /* =Z-MH or -Z=M, Z = centerpoint, M = endpoint, other than above */</a>
<a name="ln2564">#endif</a>
<a name="ln2565">                     2 == (s_type = GetOtherSaltType( at, i, &amp;s_subtype ) ) </a>
<a name="ln2566">                     /* &gt;C-SH, &gt;C-S(-); S=S,Se,Te */</a>
<a name="ln2567">                   ) </a>
<a name="ln2568">                {</a>
<a name="ln2569"> </a>
<a name="ln2570">                    if ( nNumCandidates &gt;= nMaxNumCandidates ) </a>
<a name="ln2571">                    {</a>
<a name="ln2572">                        err = BNS_VERT_EDGE_OVFL;</a>
<a name="ln2573">                        goto quick_exit;</a>
<a name="ln2574">                    }</a>
<a name="ln2575">                    s_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln2576">                    s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2577">                    s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2578">                    s_candidate[nNumCandidates].endpoint = at[i].endpoint;</a>
<a name="ln2579">                    nNumCandidates ++;</a>
<a name="ln2580">                    nNumOtherCandidates += (1 == s_type);</a>
<a name="ln2581">                    nNumPOnlyCandidates += (2 == s_type);</a>
<a name="ln2582">                    s_subtype_all                        |= s_subtype;</a>
<a name="ln2583">                    /*i1 = i;*/ /* save a representative of a tautomeric group */</a>
<a name="ln2584">                }</a>
<a name="ln2585">            } /* for */</a>
<a name="ln2586"> </a>
<a name="ln2587">            /* changes: TG_FLAG_ALLOW_NO_NEGTV_O replaced CHARGED_SALTS_ONLY==0 */</a>
<a name="ln2588">#if 0</a>
<a name="ln2589">            if ( nNumCandidates &lt;= 1 ||</a>
<a name="ln2590">                !(s_subtype_all &amp; SALT_ACCEPTOR) ||</a>
<a name="ln2591">                 (((t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O)||</a>
<a name="ln2592">                   (t_group_info-&gt;bTautFlagsDone &amp; TG_FLAG_FOUND_SALT_CHARGES_DONE) ||</a>
<a name="ln2593">                   (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT)) ?</a>
<a name="ln2594">                    !(s_subtype_all &amp; (SALT_DONOR_Neg | SALT_DONOR_H)):</a>
<a name="ln2595">                    (!(s_subtype_all &amp; SALT_DONOR_Neg) || nNumOtherCandidates==nNumCandidates))</a>
<a name="ln2596">               ) {</a>
<a name="ln2597">#endif</a>
<a name="ln2598">            cond1 = s_subtype_all &amp; SALT_ACCEPTOR;</a>
<a name="ln2599">            cond2a = t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O;</a>
<a name="ln2600">            cond2b = t_group_info-&gt;bTautFlagsDone &amp; TG_FLAG_FOUND_SALT_CHARGES_DONE;</a>
<a name="ln2601">            cond2c = t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT;</a>
<a name="ln2602">            if ( cond2a || cond2b|| cond2c ) </a>
<a name="ln2603">                cond2 = !(s_subtype_all &amp; (SALT_DONOR_Neg | SALT_DONOR_H));</a>
<a name="ln2604">            else</a>
<a name="ln2605">                cond2 = !(s_subtype_all &amp; SALT_DONOR_Neg) || nNumOtherCandidates==nNumCandidates;</a>
<a name="ln2606">            if ( nNumCandidates &lt;= 1 || !cond1 || cond2</a>
<a name="ln2607">                 /*(</a>
<a name="ln2608">                    ( cond2a || cond2b	|| cond2c ) </a>
<a name="ln2609">                    ?		!(s_subtype_all &amp; (SALT_DONOR_Neg | SALT_DONOR_H))</a>
<a name="ln2610">                    :		( !(s_subtype_all &amp; SALT_DONOR_Neg) || nNumOtherCandidates==nNumCandidates) ) */</a>
<a name="ln2611">               ) </a>
<a name="ln2612">            {</a>
<a name="ln2613">                s_group_info-&gt;num_candidates = -1; /* no candidate exists */</a>
<a name="ln2614">                goto quick_exit;</a>
<a name="ln2615">            }</a>
<a name="ln2616">            if ( !(s_subtype_all &amp; (SALT_DONOR_Neg) ) ) {</a>
<a name="ln2617">                t_group_info-&gt;bTautFlagsDone |= TG_FLAG_ALLOW_NO_NEGTV_O_DONE;</a>
<a name="ln2618">            }</a>
<a name="ln2619">        } else {</a>
<a name="ln2620">            for ( i = 0; i &lt; nNumCandidates; i ++ ) {</a>
<a name="ln2621">                i1 = s_candidate[i].atnumber;</a>
<a name="ln2622">                if ( 0 &lt;= (s_type = GetSaltChargeType( at, i1, t_group_info, &amp;s_subtype ))</a>
<a name="ln2623">#if ( INCL_NON_SALT_CANDIDATATES == 1 )            </a>
<a name="ln2624">                     || 0 &lt; (s_type = GetOtherSaltChargeType( at, i1, t_group_info, &amp;s_subtype, 1 /* bAccept_O*/ ))</a>
<a name="ln2625">#endif</a>
<a name="ln2626">                    ) {</a>
<a name="ln2627">                    s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2628">                    s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2629">                    s_candidate[nNumCandidates].endpoint = at[i1].endpoint;</a>
<a name="ln2630">                }</a>
<a name="ln2631">            }</a>
<a name="ln2632">        }</a>
<a name="ln2633">        /* Look for alt paths connecting:</a>
<a name="ln2634">           SALT_DONOR_Neg to SALT_ACCEPTOR  : long distance migration of negative charges</a>
<a name="ln2635">           SALT_DONOR_H   to SALT_ACCEPTOR  : long distance migration of H-atoms</a>
<a name="ln2636">        */</a>
<a name="ln2637">        do {</a>
<a name="ln2638">            nNumChanges = 0;</a>
<a name="ln2639">            for ( i1 = 0; i1 &lt; nNumCandidates; i1 ++ ) {</a>
<a name="ln2640">                j1 = s_candidate[i1].atnumber; </a>
<a name="ln2641">                for ( i2 = i1+1; i2 &lt; nNumCandidates; i2 ++ ) {</a>
<a name="ln2642">                    /* prev. approach: do not test if both candidates are not &quot;salt-type&quot;. Disabled 2004-03-18</a>
<a name="ln2643">                    if ( s_candidate[i1].type &amp;&amp; s_candidate[i2].type )</a>
<a name="ln2644">                        continue;</a>
<a name="ln2645">                    */</a>
<a name="ln2646">                    j2 = s_candidate[i2].atnumber;</a>
<a name="ln2647">                    if ( at[j1].endpoint &amp;&amp; at[j1].endpoint == at[j2].endpoint ) {</a>
<a name="ln2648">                        continue;</a>
<a name="ln2649">                    }</a>
<a name="ln2650">                    for ( j = 0; j &lt; 2; j ++ ) {</a>
<a name="ln2651">                        if ( j ) {</a>
<a name="ln2652">                            ii1 = i2; /* candidate 1 (donor)    ordering number */</a>
<a name="ln2653">                            ii2 = i1; /* candidate 2 (acceptor) ordering number */</a>
<a name="ln2654">                            jj1 = j2; /* candidate 1 (donor)    atom number */</a>
<a name="ln2655">                            jj2 = j1; /* candidate 2 (acceptor) atom number */</a>
<a name="ln2656">                        } else {      /* transposition */</a>
<a name="ln2657">                            ii1 = i1; /* candidate 1 (donor)    ordering number */</a>
<a name="ln2658">                            ii2 = i2; /* candidate 2 (acceptor) ordering number */</a>
<a name="ln2659">                            jj1 = j1; /* candidate 1 (donor)    atom number     */</a>
<a name="ln2660">                            jj2 = j2; /* candidate 2 (acceptor) atom number     */</a>
<a name="ln2661">                        }</a>
<a name="ln2662"> </a>
<a name="ln2663">                        if ( ( s_candidate[ii1].subtype &amp; (SALT_DONOR_Neg | SALT_DONOR_H) ) &amp;&amp;</a>
<a name="ln2664">                             ( s_candidate[ii2].subtype &amp; SALT_ACCEPTOR ) ) </a>
<a name="ln2665">                        {</a>
<a name="ln2666">                            ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, jj2, jj1, ALT_PATH_MODE_4_SALT );</a>
<a name="ln2667">                            num_tested ++;</a>
<a name="ln2668">                            if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln2669">                            {</a>
<a name="ln2670">                                err = ret;</a>
<a name="ln2671">                                goto quick_exit;</a>
<a name="ln2672">                            }</a>
<a name="ln2673">                            if ( ret &amp; 1 ) </a>
<a name="ln2674">                            {</a>
<a name="ln2675">                                nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln2676">                                nNumChanges += (ret &amp; 2);</a>
<a name="ln2677">                                for ( i = 0; i &lt; 2; i ++ ) </a>
<a name="ln2678">                                {</a>
<a name="ln2679">                                    jj = i? jj2 : jj1;</a>
<a name="ln2680">                                    AddEndPoint( EndPoint+i, at, jj );</a>
<a name="ln2681">                                }</a>
<a name="ln2682">                                /* add/merge taut groups and reinit pBNS in the fly */</a>
<a name="ln2683">                                ret = RegisterEndPoints(  t_group_info,</a>
<a name="ln2684">                                                          EndPoint, 2, at, num_atoms, c_group_info, pBNS );</a>
<a name="ln2685">                                if ( ret == -1 ) </a>
<a name="ln2686">                                {</a>
<a name="ln2687">                                    ret = BNS_PROGRAM_ERR;</a>
<a name="ln2688">                                }</a>
<a name="ln2689">                                if ( ret &lt; 0 ) </a>
<a name="ln2690">                                {</a>
<a name="ln2691">                                    err = ret;</a>
<a name="ln2692">                                    goto quick_exit;</a>
<a name="ln2693">                                }</a>
<a name="ln2694">                                if ( nDelta ) </a>
<a name="ln2695">                                {</a>
<a name="ln2696">                                    err = BNS_RADICAL_ERR;</a>
<a name="ln2697">                                    goto quick_exit;</a>
<a name="ln2698">                                }</a>
<a name="ln2699">                                nNumChanges += (ret &gt; 0);</a>
<a name="ln2700">                                break; /* avoid redundant repetition */</a>
<a name="ln2701">                            }</a>
<a name="ln2702">                        }</a>
<a name="ln2703">                    }</a>
<a name="ln2704">                }</a>
<a name="ln2705">            }</a>
<a name="ln2706">            nTotNumChanges += nNumChanges;</a>
<a name="ln2707">        } while ( num_tested &amp;&amp; nNumChanges );</a>
<a name="ln2708">    </a>
<a name="ln2709">quick_exit:</a>
<a name="ln2710">        if ( !err ) {</a>
<a name="ln2711">            nTotNumChanges += nNumChanges; /* nNumChanges != 0 only in case of 'goto quick_exit' */</a>
<a name="ln2712">            if ( s_group_info-&gt;num_candidates == 0 ) {</a>
<a name="ln2713">                /* first time: initialize */</a>
<a name="ln2714">                s_group_info-&gt;num_candidates = num_tested? nNumCandidates : -1; /* no candidate exists */</a>
<a name="ln2715">            }</a>
<a name="ln2716">        } else {</a>
<a name="ln2717">            nTotNumChanges = err;</a>
<a name="ln2718">        }</a>
<a name="ln2719">#if ( MAX_LOCAL_TGNUM &gt; 0 )</a>
<a name="ln2720">        if ( ptgData != tgData ) {</a>
<a name="ln2721">            inchi_free( ptgData );</a>
<a name="ln2722">        }</a>
<a name="ln2723">#endif        </a>
<a name="ln2724">    }</a>
<a name="ln2725">    return nTotNumChanges;</a>
<a name="ln2726">}</a>
<a name="ln2727">#else</a>
<a name="ln2728"> </a>
<a name="ln2729">/*****************************************************************************/</a>
<a name="ln2730">int MarkSaltChargeGroups ( inp_ATOM *at, int num_atoms, S_GROUP_INFO *s_group_info,</a>
<a name="ln2731">                          T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info,</a>
<a name="ln2732">                          struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD )</a>
<a name="ln2733">{</a>
<a name="ln2734">    </a>
<a name="ln2735">    int nNumChanges = 0, nTotNumChanges = 0;</a>
<a name="ln2736">    if ( s_group_info &amp;&amp; s_group_info-&gt;s_candidate &amp;&amp; s_group_info-&gt;max_num_candidates &gt; 0 ) {</a>
<a name="ln2737">        int i, i1, i2, j, j1, j2, jj, ii1, ii2, jj1, jj2, k, num_tested;</a>
<a name="ln2738">        S_CANDIDATE *s_candidate         = s_group_info-&gt;s_candidate;</a>
<a name="ln2739">        int          nMaxNumCandidates   = s_group_info-&gt;max_num_candidates;</a>
<a name="ln2740">        int          nNumCandidates      = s_group_info-&gt;num_candidates;</a>
<a name="ln2741">        int          nNumOtherCandidates = s_group_info-&gt;num_other_candidates;</a>
<a name="ln2742">        int          s_type, s_subtype;</a>
<a name="ln2743">        int          ret, nDelta, nMobile;</a>
<a name="ln2744">        int          s_subtype_all = 0;</a>
<a name="ln2745">        T_ENDPOINT   EndPoint[2];</a>
<a name="ln2746"> </a>
<a name="ln2747">        if ( nNumCandidates &lt;= -1 || !t_group_info || !t_group_info-&gt;t_group ) {</a>
<a name="ln2748">            return 0;</a>
<a name="ln2749">        } else</a>
<a name="ln2750">        if ( nNumCandidates == 0 ) {</a>
<a name="ln2751">            for ( i = 0, nNumCandidates = nNumOtherCandidates = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2752">                if ( 0 &lt;= (s_type = GetSaltChargeType( at, i, t_group_info, &amp;s_subtype )) ) {</a>
<a name="ln2753">                    if ( nNumCandidates &gt;= nMaxNumCandidates ) {</a>
<a name="ln2754">                        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2755">                    }</a>
<a name="ln2756">                    s_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln2757">                    s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2758">                    s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2759">                    s_candidate[nNumCandidates].endpoint = at[i].endpoint;</a>
<a name="ln2760">                    nNumCandidates ++;</a>
<a name="ln2761">                    s_subtype_all                        |= s_subtype;</a>
<a name="ln2762">                    /*i1 = i;*/ /* save a representative of a tautomeric group */</a>
<a name="ln2763">                }</a>
<a name="ln2764">#if ( INCL_NON_SALT_CANDIDATATES == 1 )            </a>
<a name="ln2765">                else  /* new */</a>
<a name="ln2766">                if ( 0 &lt; (s_type = GetOtherSaltChargeType( at, i, t_group_info, &amp;s_subtype, 1 /* bAccept_O*/ )) ) {</a>
<a name="ln2767">                    if ( nNumCandidates &gt;= nMaxNumCandidates ) {</a>
<a name="ln2768">                        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2769">                    }</a>
<a name="ln2770">                    s_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln2771">                    s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2772">                    s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2773">                    s_candidate[nNumCandidates].endpoint = at[i].endpoint;</a>
<a name="ln2774">                    nNumCandidates ++;</a>
<a name="ln2775">                    nNumOtherCandidates ++;</a>
<a name="ln2776">                    s_subtype_all                        |= s_subtype;</a>
<a name="ln2777">                }</a>
<a name="ln2778">#endif</a>
<a name="ln2779">            }</a>
<a name="ln2780"> </a>
<a name="ln2781">            /* changes: TG_FLAG_ALLOW_NO_NEGTV_O replaced CHARGED_SALTS_ONLY==0 */</a>
<a name="ln2782">            if ( nNumCandidates &lt;= 1 || nNumOtherCandidates == nNumCandidates || </a>
<a name="ln2783">                 ((t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O) ?</a>
<a name="ln2784">                    !(s_subtype_all &amp; (SALT_DONOR_Neg | SALT_DONOR_H)):</a>
<a name="ln2785">                    !(s_subtype_all &amp; SALT_DONOR_Neg)) ||</a>
<a name="ln2786">                 !(s_subtype_all &amp; SALT_ACCEPTOR)) {</a>
<a name="ln2787">                s_group_info-&gt;num_candidates = -1; /* no candidate exists */</a>
<a name="ln2788">                return 0;</a>
<a name="ln2789">            }</a>
<a name="ln2790">            if ( !(s_subtype_all &amp; (SALT_DONOR_Neg) ) ) {</a>
<a name="ln2791">                t_group_info-&gt;bTautFlagsDone |= TG_FLAG_ALLOW_NO_NEGTV_O_DONE;</a>
<a name="ln2792">            }</a>
<a name="ln2793">        } else {</a>
<a name="ln2794">            for ( i = 0; i &lt; nNumCandidates; i ++ ) {</a>
<a name="ln2795">                i1 = s_candidate[i].atnumber;</a>
<a name="ln2796">                if ( 0 &lt;= (s_type = GetSaltChargeType( at, i1, t_group_info, &amp;s_subtype ))</a>
<a name="ln2797">#if ( INCL_NON_SALT_CANDIDATATES == 1 )            </a>
<a name="ln2798">                     || 0 &lt; (s_type = GetOtherSaltChargeType( at, i1, t_group_info, &amp;s_subtype, 1 /* bAccept_O*/ ))</a>
<a name="ln2799">#endif</a>
<a name="ln2800">                    ) {</a>
<a name="ln2801">                    s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2802">                    s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2803">                    s_candidate[nNumCandidates].endpoint = at[i1].endpoint;</a>
<a name="ln2804">                }</a>
<a name="ln2805">            }</a>
<a name="ln2806">        }</a>
<a name="ln2807">        /* Look for alt paths connecting:</a>
<a name="ln2808">           SALT_DONOR_Neg to SALT_ACCEPTOR  : long distance migration of negative charges</a>
<a name="ln2809">           SALT_DONOR_H   to SALT_ACCEPTOR  : long distance migration of H-atoms</a>
<a name="ln2810">        */</a>
<a name="ln2811">        num_tested = 0;</a>
<a name="ln2812">        do {</a>
<a name="ln2813">            nNumChanges = 0;</a>
<a name="ln2814">            for ( i1 = 0; i1 &lt; nNumCandidates; i1 ++ ) {</a>
<a name="ln2815">                j1 = s_candidate[i1].atnumber; </a>
<a name="ln2816">                for ( i2 = i1+1; i2 &lt; nNumCandidates; i2 ++ ) {</a>
<a name="ln2817">                    if ( s_candidate[i1].type &amp;&amp; s_candidate[i2].type )</a>
<a name="ln2818">                        continue; /* both candidates are not &quot;salt-type&quot; */</a>
<a name="ln2819">                    j2 = s_candidate[i2].atnumber;</a>
<a name="ln2820">                    if ( at[j1].endpoint &amp;&amp; at[j1].endpoint == at[j2].endpoint ) {</a>
<a name="ln2821">                        continue;</a>
<a name="ln2822">                    }</a>
<a name="ln2823">                    for ( j = 0; j &lt; 2; j ++ ) {</a>
<a name="ln2824">                        if ( j ) {</a>
<a name="ln2825">                            ii1 = i2; /* candidate 1 (donor)    ordering number */</a>
<a name="ln2826">                            ii2 = i1; /* candidate 2 (acceptor) ordering number */</a>
<a name="ln2827">                            jj1 = j2; /* candidate 1 (donor)    atom number */</a>
<a name="ln2828">                            jj2 = j1; /* candidate 2 (acceptor) atom number */</a>
<a name="ln2829">                        } else {      /* transposition */</a>
<a name="ln2830">                            ii1 = i1; /* candidate 1 (donor)    ordering number */</a>
<a name="ln2831">                            ii2 = i2; /* candidate 2 (acceptor) ordering number */</a>
<a name="ln2832">                            jj1 = j1; /* candidate 1 (donor)    atom number     */</a>
<a name="ln2833">                            jj2 = j2; /* candidate 2 (acceptor) atom number     */</a>
<a name="ln2834">                        }</a>
<a name="ln2835"> </a>
<a name="ln2836">                        if ( ( s_candidate[ii1].subtype &amp; (SALT_DONOR_Neg | SALT_DONOR_H) ) &amp;&amp;</a>
<a name="ln2837">                             ( s_candidate[ii2].subtype &amp; SALT_ACCEPTOR ) ) {</a>
<a name="ln2838">                            ret = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, jj2, jj1, ALT_PATH_MODE_4_SALT );</a>
<a name="ln2839">                            num_tested ++;</a>
<a name="ln2840">                            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2841">                                return ret;</a>
<a name="ln2842">                            }</a>
<a name="ln2843">                            if ( ret &amp; 1 ) {</a>
<a name="ln2844">                                nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln2845">                                nNumChanges += (ret &amp; 2);</a>
<a name="ln2846">                                for ( i = 0; i &lt; 2; i ++ ) {</a>
<a name="ln2847">                                    jj = i? jj2 : jj1;</a>
<a name="ln2848">                                    EndPoint[i].nAtomNumber  = jj;</a>
<a name="ln2849">                                    EndPoint[i].nEquNumber   = 0;</a>
<a name="ln2850">                                    EndPoint[i].nGroupNumber = at[jj].endpoint;</a>
<a name="ln2851">                                    if ( at[jj].endpoint ) {</a>
<a name="ln2852">                                        memset( EndPoint[i].num, 0, sizeof(EndPoint[i].num) );</a>
<a name="ln2853">                                    } else {</a>
<a name="ln2854">                                        AddAtom2num( EndPoint[i].num, at, jj, 2 ); /* fill out */</a>
<a name="ln2855">                                        AddAtom2DA( EndPoint[i].num_DA, at, jj, 2 );</a>
<a name="ln2856">                                        /*</a>
<a name="ln2857">                                        nMobile  = EndPoint[i].num[1] = (at[jj].charge == -1);</a>
<a name="ln2858">                                        nMobile  = EndPoint[i].num[0] = at[jj].num_H + nMobile;</a>
<a name="ln2859">                                        for ( k = 0; k &lt; T_NUM_ISOTOPIC; k ++ ) {</a>
<a name="ln2860">                                            EndPoint[i].num[T_NUM_NO_ISOTOPIC+k] = at[jj].num_iso_H[NUM_H_ISOTOPES-k-1];</a>
<a name="ln2861">                                        }</a>
<a name="ln2862">                                        */</a>
<a name="ln2863">                                    }</a>
<a name="ln2864">                                }</a>
<a name="ln2865">                                /* add/merge taut groups and reinit pBNS */</a>
<a name="ln2866">                                ret = RegisterEndPoints(  t_group_info,</a>
<a name="ln2867">                                                          EndPoint, 2, at, num_atoms, c_group_info, pBNS );</a>
<a name="ln2868">                                if ( ret &lt; 0 ) {</a>
<a name="ln2869">                                    return ret;</a>
<a name="ln2870">                                }</a>
<a name="ln2871">                                nNumChanges += (ret &gt; 0);</a>
<a name="ln2872">                                if ( nDelta ) {</a>
<a name="ln2873">                                    goto quick_exit;</a>
<a name="ln2874">                                }</a>
<a name="ln2875">                                break; /* avoid redundant repetition */</a>
<a name="ln2876">                            }</a>
<a name="ln2877">                        }</a>
<a name="ln2878">                    }</a>
<a name="ln2879">                }</a>
<a name="ln2880">            }</a>
<a name="ln2881">            nTotNumChanges += nNumChanges;</a>
<a name="ln2882">        } while ( num_tested &amp;&amp; nNumChanges );</a>
<a name="ln2883">    </a>
<a name="ln2884">quick_exit:</a>
<a name="ln2885">        nTotNumChanges += nNumChanges; /* nNumChanges != 0 only in case of 'goto quick_exit' */</a>
<a name="ln2886">        if ( s_group_info-&gt;num_candidates == 0 ) {</a>
<a name="ln2887">            /* first time: initialize */</a>
<a name="ln2888">            s_group_info-&gt;num_candidates = num_tested? nNumCandidates : -1; /* no candidate exists */</a>
<a name="ln2889">        }</a>
<a name="ln2890">        </a>
<a name="ln2891">    }</a>
<a name="ln2892">    return nTotNumChanges;</a>
<a name="ln2893">}</a>
<a name="ln2894">#endif</a>
<a name="ln2895"> </a>
<a name="ln2896"> </a>
<a name="ln2897"> </a>
<a name="ln2898">/*****************************************************************************/</a>
<a name="ln2899">int MergeSaltTautGroups( inp_ATOM *at, int num_atoms, S_GROUP_INFO *s_group_info,</a>
<a name="ln2900">                          T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info,</a>
<a name="ln2901">                          struct BalancedNetworkStructure *pBNS )</a>
<a name="ln2902">{</a>
<a name="ln2903">    /* count candidates to be connected: exclude pure donors that do not belong to any t-group */</a>
<a name="ln2904">    AT_NUMB    nCurTGroupNumber;</a>
<a name="ln2905">    int        i, j, /*k,*/ ret, iat, /*nMobile,*/ nMinNumEndpoints;</a>
<a name="ln2906">    int        s_subtype_all, s_subtype_taut;</a>
<a name="ln2907">    int        nMaxNumCandidates, nNumCandidates, nNumCandidates2;</a>
<a name="ln2908">    T_ENDPOINT EndPointStackArray[MAX_STACK_ARRAY_LEN]; /* will be reallocated if too short */</a>
<a name="ln2909">    T_ENDPOINT  *EndPoint = EndPointStackArray;</a>
<a name="ln2910"> </a>
<a name="ln2911"> </a>
<a name="ln2912">    if ( !s_group_info || !s_group_info-&gt;s_candidate || /*s_group_info-&gt;num_candidates &lt;= 0 ||*/</a>
<a name="ln2913">         !t_group_info || !t_group_info-&gt;t_group || !c_group_info ) {</a>
<a name="ln2914">        return 0;</a>
<a name="ln2915">    }</a>
<a name="ln2916">    nMinNumEndpoints = 0;</a>
<a name="ln2917">    nMaxNumCandidates = s_group_info-&gt;max_num_candidates;</a>
<a name="ln2918">    nCurTGroupNumber = MAX_ATOMS;  /* impossible t-group number */</a>
<a name="ln2919">    s_subtype_all = s_subtype_taut = 0;</a>
<a name="ln2920">    /* collect tautomeric acidic O and previously non-tautomeric C-OH, C-SH, C-O(-), C-S(-)  */</a>
<a name="ln2921">    /* find whether previously found tautomeric atoms have both mobile H and (-) */</a>
<a name="ln2922">    if ( 1 || (s_group_info-&gt;num_candidates &lt; 0) ) {</a>
<a name="ln2923">        /* can be only -O(-)  and -OH */</a>
<a name="ln2924">        int          s_type, s_subtype;</a>
<a name="ln2925">        S_CANDIDATE *s_candidate       = s_group_info-&gt;s_candidate;</a>
<a name="ln2926">        for ( i = 0, nNumCandidates = nNumCandidates2 = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2927">            s_subtype = 0;</a>
<a name="ln2928">            if ( 0 == (s_type = GetSaltChargeType( at, i, t_group_info, &amp;s_subtype )) ||</a>
<a name="ln2929">                 /* -C=O or =C-OH, O = S, Se, Te */</a>
<a name="ln2930">                 </a>
<a name="ln2931">                 /*(t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT) &amp;&amp;*/</a>
<a name="ln2932">                 1 == (s_type = GetOtherSaltChargeType( at, i, t_group_info, &amp;s_subtype, 1/* bAccept_O*/ ))  ||</a>
<a name="ln2933">                 /* =Z-MH or -Z=M, Z = centerpoint, M = endpoint, other than above. M may be N */</a>
<a name="ln2934"> </a>
<a name="ln2935">                 2 == (s_type = GetOtherSaltType( at, i, &amp;s_subtype )) ||</a>
<a name="ln2936">                 /* &gt;C-SH, &gt;C-S(-); S=S,Se,Te */</a>
<a name="ln2937">                 </a>
<a name="ln2938">                 /* other proton donor or acceptor */</a>
<a name="ln2939">                 (bHasAcidicHydrogen( at, i)    &amp;&amp; ((s_type=3), (s_subtype = SALT_p_DONOR))) ||</a>
<a name="ln2940">                 (bHasAcidicMinus( at, i)       &amp;&amp; ((s_type=3), (s_subtype = SALT_p_ACCEPTOR)))</a>
<a name="ln2941">               ) {</a>
<a name="ln2942"> </a>
<a name="ln2943">                if ( nNumCandidates &gt;= nMaxNumCandidates ) {</a>
<a name="ln2944">                    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2945">                }</a>
<a name="ln2946">                if ( at[i].endpoint ) {</a>
<a name="ln2947">                    s_subtype_taut |= s_subtype;</a>
<a name="ln2948">                } else</a>
<a name="ln2949">                if ( bDoNotMergeNonTautAtom(at, i) ) {</a>
<a name="ln2950">                    continue; /* ignore non-tautomeric N */</a>
<a name="ln2951">                }</a>
<a name="ln2952">                if ( !( s_subtype &amp; SALT_DONOR_ALL ) ||</a>
<a name="ln2953">                     ((s_subtype &amp; SALT_ACCEPTOR) &amp;&amp; !at[i].endpoint) ) {</a>
<a name="ln2954">                    continue;  /* do not include non-taut acceptors like -C=O */</a>
<a name="ln2955">                }</a>
<a name="ln2956">                s_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln2957">                s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln2958">                s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln2959">                s_candidate[nNumCandidates].endpoint = at[i].endpoint;</a>
<a name="ln2960">                nNumCandidates ++;</a>
<a name="ln2961">                s_subtype_all  |= s_subtype;</a>
<a name="ln2962">            }</a>
<a name="ln2963">        }</a>
<a name="ln2964">        /*</a>
<a name="ln2965">         Forced merging occurs upon:</a>
<a name="ln2966">         ===========================</a>
<a name="ln2967">                (t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O) or</a>
<a name="ln2968">                (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT)</a>
<a name="ln2969"> </a>
<a name="ln2970"> </a>
<a name="ln2971">         Allow forced merging in cases:</a>
<a name="ln2972">           {t-groups}  (H, (-)}  {H, (-), t-groups}</a>
<a name="ln2973"> </a>
<a name="ln2974"> </a>
<a name="ln2975">         Normal salt merging in cases:</a>
<a name="ln2976">            (H, (-)} {H, (-), t-groups},</a>
<a name="ln2977">           </a>
<a name="ln2978">         Cannot merge H into t-groups if no (-) is present</a>
<a name="ln2979">         */</a>
<a name="ln2980"> </a>
<a name="ln2981"> </a>
<a name="ln2982">        if ( (t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O) ||</a>
<a name="ln2983">             (t_group_info-&gt;bTautFlagsDone &amp; TG_FLAG_FOUND_SALT_CHARGES_DONE) ||</a>
<a name="ln2984">             (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT) ) {</a>
<a name="ln2985">            /* force merge even though no negative charges are present */</a>
<a name="ln2986">            if ( nNumCandidates &lt;= 1 ||</a>
<a name="ln2987">                 ((!(s_subtype_all &amp; SALT_DONOR_Neg2) || !(s_subtype_all &amp; SALT_DONOR_H2)) &amp;&amp;</a>
<a name="ln2988">                 !t_group_info-&gt;num_t_groups) ) {</a>
<a name="ln2989">                s_group_info-&gt;num_candidates = -1; /* no candidate exists */</a>
<a name="ln2990">                return 0;</a>
<a name="ln2991">            }</a>
<a name="ln2992">        } else {</a>
<a name="ln2993">            /* normal salt mode: merge if both -XH and -X(-) are present */</a>
<a name="ln2994">            if ( nNumCandidates &lt;= 1 ||</a>
<a name="ln2995">                 (!(s_subtype_all &amp; SALT_DONOR_Neg2) || !(s_subtype_all &amp; SALT_DONOR_H2)) ) {</a>
<a name="ln2996">                s_group_info-&gt;num_candidates = -1; /* no candidate exists */</a>
<a name="ln2997">                return 0;</a>
<a name="ln2998">            }</a>
<a name="ln2999">        }</a>
<a name="ln3000">        /* -- old code --</a>
<a name="ln3001">        if ( nNumCandidates &lt;= 1 ||</a>
<a name="ln3002">             (((t_group_info-&gt;bTautFlags &amp; TG_FLAG_ALLOW_NO_NEGTV_O) ||</a>
<a name="ln3003">               (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT)) ?</a>
<a name="ln3004">                 !(s_subtype_all &amp; SALT_DONOR_ALL):</a>
<a name="ln3005">                 !(s_subtype_all &amp; SALT_DONOR_Neg2)</a>
<a name="ln3006">             ) </a>
<a name="ln3007">           ) {</a>
<a name="ln3008">            s_group_info-&gt;num_candidates = -1;</a>
<a name="ln3009">            return 0;</a>
<a name="ln3010">        }</a>
<a name="ln3011">        */</a>
<a name="ln3012">        if ( !(s_subtype_all &amp; (SALT_DONOR_Neg2) ) ) {</a>
<a name="ln3013">            t_group_info-&gt;bTautFlagsDone |= TG_FLAG_ALLOW_NO_NEGTV_O_DONE;</a>
<a name="ln3014">        }</a>
<a name="ln3015">        s_group_info-&gt;num_candidates = nNumCandidates;</a>
<a name="ln3016">    }</a>
<a name="ln3017"> </a>
<a name="ln3018">    for ( i = 0; i &lt; s_group_info-&gt;num_candidates; i ++ ) {</a>
<a name="ln3019">        iat = s_group_info-&gt;s_candidate[i].atnumber;</a>
<a name="ln3020">        if ( (s_group_info-&gt;s_candidate[i].subtype &amp; SALT_ACCEPTOR) &amp;&amp; !at[iat].endpoint ) {</a>
<a name="ln3021">            continue; /* should not happen */</a>
<a name="ln3022">        }</a>
<a name="ln3023">        s_subtype_all |= s_group_info-&gt;s_candidate[i].subtype;</a>
<a name="ln3024">        if ( at[iat].endpoint != nCurTGroupNumber || !at[iat].endpoint ) {</a>
<a name="ln3025">            nMinNumEndpoints ++;</a>
<a name="ln3026">        }</a>
<a name="ln3027">        nCurTGroupNumber = (int)at[iat].endpoint;</a>
<a name="ln3028">    }</a>
<a name="ln3029">    if ( nMinNumEndpoints &lt;= 1 ) {</a>
<a name="ln3030">        return 0; /* too few endpoints */</a>
<a name="ln3031">    }</a>
<a name="ln3032">    </a>
<a name="ln3033">    /* make sure we have enough memory */</a>
<a name="ln3034">    if ( nMinNumEndpoints &gt; MAX_STACK_ARRAY_LEN ) {</a>
<a name="ln3035">        if ( !(EndPoint = (T_ENDPOINT *)inchi_calloc( nMinNumEndpoints, sizeof(EndPoint[0]) ) ) ) {</a>
<a name="ln3036">            /*printf(&quot;BNS_OUT_OF_RAM-8\n&quot;);*/</a>
<a name="ln3037">            return BNS_OUT_OF_RAM;</a>
<a name="ln3038">        }</a>
<a name="ln3039">    }</a>
<a name="ln3040">    </a>
<a name="ln3041">    nCurTGroupNumber = MAX_ATOMS;  /* impossible t-group number */</a>
<a name="ln3042">    for ( i = j = 0; i &lt; s_group_info-&gt;num_candidates; i ++ ) {</a>
<a name="ln3043">        iat = s_group_info-&gt;s_candidate[i].atnumber;</a>
<a name="ln3044">        if ( s_group_info-&gt;s_candidate[i].subtype == SALT_ACCEPTOR &amp;&amp; !at[iat].endpoint ) {</a>
<a name="ln3045">            continue;</a>
<a name="ln3046">        }</a>
<a name="ln3047">        if ( at[iat].endpoint != nCurTGroupNumber || !at[iat].endpoint ) {</a>
<a name="ln3048">            AddEndPoint( EndPoint+j, at, iat );</a>
<a name="ln3049">            j ++;</a>
<a name="ln3050">        }</a>
<a name="ln3051">        nCurTGroupNumber = (int)at[iat].endpoint;</a>
<a name="ln3052">    }</a>
<a name="ln3053"> </a>
<a name="ln3054">    ret = RegisterEndPoints(  t_group_info,</a>
<a name="ln3055">                              EndPoint, j, at, num_atoms, c_group_info, pBNS );</a>
<a name="ln3056">    if ( ret == -1 ) {</a>
<a name="ln3057">        ret = BNS_PROGRAM_ERR;</a>
<a name="ln3058">    }</a>
<a name="ln3059"> </a>
<a name="ln3060">    if ( EndPoint != EndPointStackArray ) {</a>
<a name="ln3061">        inchi_free( EndPoint );</a>
<a name="ln3062">    }</a>
<a name="ln3063"> </a>
<a name="ln3064">    return ret;</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067"> </a>
<a name="ln3068"> </a>
<a name="ln3069">/*****************************************************************************/</a>
<a name="ln3070">int MakeIsotopicHGroup(inp_ATOM *at, int num_atoms, S_GROUP_INFO *s_group_info, </a>
<a name="ln3071">                       T_GROUP_INFO *t_group_info)</a>
<a name="ln3072">{</a>
<a name="ln3073">    /* all tautomeric atoms and all possible H+ donors and acceptors that have H */</a>
<a name="ln3074">    int        i, j, k, n, bHasH, tg, nError=0;</a>
<a name="ln3075">    int        s_subtype_all, s_subtype_taut;</a>
<a name="ln3076">    int        nMaxNumCandidates, nNumCandidates, nNumNonTautCandidates;</a>
<a name="ln3077"> </a>
<a name="ln3078"> </a>
<a name="ln3079">    if ( !s_group_info || !s_group_info-&gt;s_candidate || /*s_group_info-&gt;num_candidates &lt;= 0 ||*/</a>
<a name="ln3080">         !t_group_info || !t_group_info-&gt;t_group ) {</a>
<a name="ln3081">        return 0;</a>
<a name="ln3082">    }</a>
<a name="ln3083">    nMaxNumCandidates = s_group_info-&gt;max_num_candidates;</a>
<a name="ln3084">    s_subtype_all = s_subtype_taut = 0;</a>
<a name="ln3085">    memset( t_group_info-&gt;num_iso_H, 0, sizeof(t_group_info-&gt;num_iso_H) );</a>
<a name="ln3086">    if ( 1 || (s_group_info-&gt;num_candidates &lt; 0) ) {</a>
<a name="ln3087">        int          s_type, s_subtype;</a>
<a name="ln3088">        S_CANDIDATE *s_candidate       = s_group_info-&gt;s_candidate;</a>
<a name="ln3089">        for ( i = 0, nNumCandidates = nNumNonTautCandidates = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3090">            s_subtype = 0;</a>
<a name="ln3091">            s_type    = 0;</a>
<a name="ln3092">            if ( at[i].endpoint ) {</a>
<a name="ln3093">                if ( (tg = t_group_info-&gt;tGroupNumber[at[i].endpoint]) &amp;&amp;</a>
<a name="ln3094">                     at[i].endpoint == t_group_info-&gt;t_group[tg-=1].nGroupNumber ) {</a>
<a name="ln3095">                    bHasH = (int)t_group_info-&gt;t_group[tg].num[0] - (int)t_group_info-&gt;t_group[tg].num[1];</a>
<a name="ln3096">                } else {</a>
<a name="ln3097">                    nError = BNS_PROGRAM_ERR;</a>
<a name="ln3098">                    break;</a>
<a name="ln3099">                }</a>
<a name="ln3100">            } else {</a>
<a name="ln3101">                bHasH = (int)at[i].num_H;</a>
<a name="ln3102">            }</a>
<a name="ln3103">            if ( (bHasH &amp;&amp; at[i].endpoint) || /* tautomeric atoms */</a>
<a name="ln3104"> </a>
<a name="ln3105">                 /* non-tautomeric heteroatoms that </a>
<a name="ln3106">                    (a) have H and </a>
<a name="ln3107">                    (b) may be donors of H</a>
<a name="ln3108">                    therefore may exchange isotopic-non-isotopic H */</a>
<a name="ln3109">                 (bHasH &amp;&amp;</a>
<a name="ln3110">                 (0 == (s_type = GetSaltChargeType( at, i, t_group_info, &amp;s_subtype )) ||</a>
<a name="ln3111">                 /* -C=O or =C-OH, O = S, Se, Te */</a>
<a name="ln3112">                 </a>
<a name="ln3113">                 /*(t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_FORCE_SALT_TAUT) &amp;&amp;*/</a>
<a name="ln3114">                 1 == (s_type = GetOtherSaltChargeType( at, i, t_group_info, &amp;s_subtype, 1/* bAccept_O*/ ))  ||</a>
<a name="ln3115">                 /* =Z-MH or -Z=M, Z = centerpoint, M = endpoint, other than above. M may be N */</a>
<a name="ln3116"> </a>
<a name="ln3117">                 2 == (s_type = GetOtherSaltType( at, i, &amp;s_subtype )) ||</a>
<a name="ln3118">                 /* &gt;C-SH, &gt;C-S(-); S=S,Se,Te */</a>
<a name="ln3119">                 </a>
<a name="ln3120">                 /* other proton donor or acceptor */</a>
<a name="ln3121">                 (bHasAcidicHydrogen( at, i) &amp;&amp; ((s_type=3), (s_subtype = SALT_p_DONOR))) ||</a>
<a name="ln3122">                 (bHasAcidicMinus( at, i)    &amp;&amp; ((s_type=3), (s_subtype = SALT_p_ACCEPTOR))) ||</a>
<a name="ln3123">                 (bHasOtherExchangableH (at, i) &amp;&amp; ((s_type=3), (s_subtype = SALT_DONOR_H))) ))</a>
<a name="ln3124">                 </a>
<a name="ln3125">               ) {</a>
<a name="ln3126"> </a>
<a name="ln3127">                if ( nNumCandidates &gt;= nMaxNumCandidates ) {</a>
<a name="ln3128">                    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3129">                }</a>
<a name="ln3130">                s_candidate[nNumCandidates].atnumber = i;</a>
<a name="ln3131">                s_candidate[nNumCandidates].type     = s_type;</a>
<a name="ln3132">                s_candidate[nNumCandidates].subtype  = s_subtype;</a>
<a name="ln3133">                s_candidate[nNumCandidates].endpoint = at[i].endpoint;</a>
<a name="ln3134">                nNumCandidates ++;</a>
<a name="ln3135">                nNumNonTautCandidates += !at[i].endpoint;</a>
<a name="ln3136">                s_subtype_all  |= s_subtype;</a>
<a name="ln3137">            }</a>
<a name="ln3138">        }</a>
<a name="ln3139">        if ( nError ) {</a>
<a name="ln3140">            return nError;</a>
<a name="ln3141">        }</a>
<a name="ln3142">        if ( nNumCandidates &gt; 0 ) {</a>
<a name="ln3143">            t_group_info-&gt;nIsotopicEndpointAtomNumber = (AT_NUMB *)inchi_calloc( nNumNonTautCandidates+1, sizeof(t_group_info-&gt;nIsotopicEndpointAtomNumber[0]));</a>
<a name="ln3144">            t_group_info-&gt;nIsotopicEndpointAtomNumber[0] = nNumNonTautCandidates;</a>
<a name="ln3145">            for ( i = 0, n = 1; i &lt; nNumCandidates; i ++ ) {</a>
<a name="ln3146">                k = s_candidate[i].atnumber;</a>
<a name="ln3147">                if ( !at[k].endpoint ) {</a>
<a name="ln3148">                    t_group_info-&gt;nIsotopicEndpointAtomNumber[n++] = k;</a>
<a name="ln3149">                }</a>
<a name="ln3150">                for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ ) {</a>
<a name="ln3151">                    t_group_info-&gt;num_iso_H[j] += at[k].num_iso_H[j];</a>
<a name="ln3152">                }</a>
<a name="ln3153">                at[k].cFlags |= AT_FLAG_ISO_H_POINT;</a>
<a name="ln3154">            }</a>
<a name="ln3155">            t_group_info-&gt;nNumIsotopicEndpoints = nNumNonTautCandidates+1;</a>
<a name="ln3156">        }</a>
<a name="ln3157">    }</a>
<a name="ln3158">    return nNumCandidates;</a>
<a name="ln3159">}</a>
<a name="ln3160"> </a>
<a name="ln3161">/*#else*/ /* } DISCONNECT_SALTS == 0 */</a>
<a name="ln3162"> </a>
<a name="ln3163">/**********************************************************************************</a>
<a name="ln3164">                       Charges and tautomeric endpoints (N only)</a>
<a name="ln3165"> **********************************************************************************</a>
<a name="ln3166"> </a>
<a name="ln3167"> H = number of possibly moveable hydrogen atoms</a>
<a name="ln3168"> C = possibly moveable positive charge</a>
<a name="ln3169"> </a>
<a name="ln3170"> - = single bond</a>
<a name="ln3171"> = = double bond</a>
<a name="ln3172"> # = triple bond</a>
<a name="ln3173"> </a>
<a name="ln3174">+-----------------------------------------------------------------------------+</a>
<a name="ln3175">|ca-| H    | edges to t-   | 1 bond         |  2 bonds       |  3 bonds    *) |</a>
<a name="ln3176">|se | C    | and c-groups  | (valence)      |  (valence)     |  (valence)     |</a>
<a name="ln3177">| # |      | (edges flow)  |                |                |                |</a>
<a name="ln3178">+---|------+---------------+----------------+----------------+----------------|</a>
<a name="ln3179">| 1 | H=0  | --  (1)       | =NH     (3)    |  =N-     (3)   |   &gt;N-     (3)  |</a>
<a name="ln3180">|   | C=0  | ==            |                |                |                |</a>
<a name="ln3181">+---|------+---------------+----------------+----------------+----------------|</a>
<a name="ln3182">| 2 | H=1  | ==  (2)       | -NH2    (3)    |  -NH-    (3)   |   none         |</a>
<a name="ln3183">|   | C=0  | ==            |                |                |                |</a>
<a name="ln3184">+---|------+---------------+----------------+----------------+----------------|</a>
<a name="ln3185">| 3 | H=0  | --  (0)       | #NH(+)  (4)    |  =N(+)=  (4) +)|   &gt;N(+)=  (4)  |</a>
<a name="ln3186">|   | C=1  | --            | (prohibited    |                |                |</a>
<a name="ln3187">|   |      |               | by edge cap)   |                |                |</a>
<a name="ln3188">+---|------+---------------+----------------+----------------+----------------|</a>
<a name="ln3189">| 4 | H=1  | ==  (1)       | =NH2(+) (4)  +)|  =NH(+)- (4) +)|   &gt;NH(+)- (4)  |     </a>
<a name="ln3190">|   | C=1  | --            |                |                |                |</a>
<a name="ln3191">+---+-------------------------------------------------------------------------+</a>
<a name="ln3192"> </a>
<a name="ln3193">  *) Cannot be a tautomeric endpoint</a>
<a name="ln3194"> </a>
<a name="ln3195">  +) The three charged types of atoms [=N(+)=, =NH(+)-, =NH2(+)] should be</a>
<a name="ln3196">     checked for possible H-tautomerism. Other types in the marked by *)</a>
<a name="ln3197">     column should not be checked as long as H(+) exchange is not considered</a>
<a name="ln3198">     tautomeric.</a>
<a name="ln3199"> </a>
<a name="ln3200">  Other possibilities:  -NH3(+)  &gt;NH2(+)  &gt;N(+)&lt;  cannot be H-tautomeric endpoints.</a>
<a name="ln3201"> </a>
<a name="ln3202">  Case #1 (H=0, C=0) and #4 (H=1,C=0) is indistinguishable from the</a>
<a name="ln3203">  viewpoint of edges flow and capacities except for flow from N to (+) vertex.</a>
<a name="ln3204"> </a>
<a name="ln3205">  Without taking precautions H(+) can be transferred</a>
<a name="ln3206"> </a>
<a name="ln3207">  from =NH2(+)  to =NH,</a>
<a name="ln3208">  from =NH(+)-  to =N-,</a>
<a name="ln3209">  from &gt;NH(+)-  to &gt;N-</a>
<a name="ln3210"> </a>
<a name="ln3211">  or to any other appropriate atom that has a lone electron pair and bonds</a>
<a name="ln3212">  will not change. In this case no bond must be marked as tautomeric.</a>
<a name="ln3213"> </a>
<a name="ln3214">  For this reason before attempting to transfer H from one endpoint to</a>
<a name="ln3215">  another the charges on the two atoms should be set to zero by</a>
<a name="ln3216">  forcing zero flow from each of atoms to the (+)-vertices if the</a>
<a name="ln3217">  atoms belong to a c-group.</a>
<a name="ln3218"> </a>
<a name="ln3219"> **********************************************************************************/</a>
<a name="ln3220"> </a>
<a name="ln3221"> </a>
<a name="ln3222">/***********************************************************************************/</a>
<a name="ln3223">/*   MarkTautomerGroups: do not identify positively charged N as endpoints for now */</a>
<a name="ln3224">/***********************************************************************************/</a>
<a name="ln3225">int MarkTautomerGroups( inp_ATOM *at, int num_atoms, T_GROUP_INFO *t_group_info, C_GROUP_INFO *c_group_info</a>
<a name="ln3226">                        , struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD )</a>
<a name="ln3227">{</a>
<a name="ln3228">    int i, j, k, m, endpoint_valence, centerpoint, endpoint, bond_type, nMobile, num_changes=0, tot_changes=0;</a>
<a name="ln3229">    T_ENDPOINT EndPoint[MAXVAL];</a>
<a name="ln3230">    T_BONDPOS  BondPos[MAXVAL];</a>
<a name="ln3231">    AT_NUMB    nGroupNumber;</a>
<a name="ln3232">    int        bDiffGroups;</a>
<a name="ln3233">    int  nNumEndPoints, nNumBondPos, nNumPossibleMobile;</a>
<a name="ln3234">    int  bTautBond, bNonTautBond, bAltBond;</a>
<a name="ln3235">    int  nNumDonor, nNumAcceptor, bPossiblyEndpoint;</a>
<a name="ln3236">    T_GROUP *t_group;</a>
<a name="ln3237">    int *pnum_t, max_num_t, bIgnoreIsotopic;</a>
<a name="ln3238">    ENDPOINT_INFO eif1, eif2;</a>
<a name="ln3239">    int nErr = 0;</a>
<a name="ln3240">#define ALLOWED_EDGE(PBNS, IAT,IBOND)  ( !(PBNS) || !(PBNS)-&gt;edge || !(PBNS)-&gt;vert || !(PBNS)-&gt;edge[(PBNS)-&gt;vert[IAT].iedge[IBOND]].forbidden)</a>
<a name="ln3241">#define ACTUAL_ORDER(PBNS, IAT,IBOND, BTYPE)  ( ((PBNS) &amp;&amp; (PBNS)-&gt;edge &amp;&amp; (PBNS)-&gt;vert &amp;&amp;\</a>
<a name="ln3242">    ((BTYPE)==BOND_ALT_123 || (BTYPE)==BOND_ALT_13 || (BTYPE)==BOND_ALT_23))? (PBNS)-&gt;edge[(PBNS)-&gt;vert[IAT].iedge[IBOND]].flow+BOND_TYPE_SINGLE:(BTYPE))</a>
<a name="ln3243"> </a>
<a name="ln3244"> </a>
<a name="ln3245">    if ( !t_group_info || !(t_group_info-&gt;bTautFlags &amp; TG_FLAG_TEST_TAUT__ATOMS) )</a>
<a name="ln3246">        return 0;</a>
<a name="ln3247">    /*  initial t_group allocation */</a>
<a name="ln3248">    if ( !t_group_info-&gt;t_group &amp;&amp; !t_group_info-&gt;max_num_t_groups ) {</a>
<a name="ln3249">        INCHI_MODE bTautFlags     = t_group_info-&gt;bTautFlags;       /*  save initial setting */</a>
<a name="ln3250">        INCHI_MODE bTautFlagsDone = t_group_info-&gt;bTautFlagsDone;   /*  save previous findings, if any */</a>
<a name="ln3251">        TNI       tni           = t_group_info-&gt;tni;</a>
<a name="ln3252">        AT_NUMB   *tGroupNumber = t_group_info-&gt;tGroupNumber;</a>
<a name="ln3253">        bIgnoreIsotopic = t_group_info-&gt;bIgnoreIsotopic;</a>
<a name="ln3254">        memset( t_group_info, 0, sizeof(*t_group_info) );</a>
<a name="ln3255">        t_group_info-&gt;bIgnoreIsotopic = bIgnoreIsotopic; /*  restore initial setting */</a>
<a name="ln3256">        t_group_info-&gt;bTautFlags      = bTautFlags;</a>
<a name="ln3257">        t_group_info-&gt;bTautFlagsDone  = bTautFlagsDone;</a>
<a name="ln3258">        t_group_info-&gt;tni             = tni;</a>
<a name="ln3259">        t_group_info-&gt;tGroupNumber    = tGroupNumber;</a>
<a name="ln3260">        t_group_info-&gt;max_num_t_groups = num_atoms/2+1; /*  upper limit */</a>
<a name="ln3261">        if (!(t_group_info-&gt;t_group = (T_GROUP*)inchi_calloc(t_group_info-&gt;max_num_t_groups, sizeof(t_group[0])))) {</a>
<a name="ln3262">            return (t_group_info-&gt;max_num_t_groups = -1); /*  failed, out of RAM */</a>
<a name="ln3263">        }</a>
<a name="ln3264">    }</a>
<a name="ln3265">    /*  check if t_group_info exists */</a>
<a name="ln3266">    if ( !t_group_info-&gt;t_group || !t_group_info-&gt;max_num_t_groups )</a>
<a name="ln3267">        return 0;</a>
<a name="ln3268"> </a>
<a name="ln3269">    if ( 0 &gt; t_group_info-&gt;max_num_t_groups )</a>
<a name="ln3270">        return t_group_info-&gt;max_num_t_groups;</a>
<a name="ln3271"> </a>
<a name="ln3272">    pnum_t          = &amp;t_group_info-&gt;num_t_groups; /*  number of found tautomer endpoint groups */</a>
<a name="ln3273">    t_group         =  t_group_info-&gt;t_group;</a>
<a name="ln3274">    max_num_t       =  t_group_info-&gt;max_num_t_groups;</a>
<a name="ln3275">    bIgnoreIsotopic =  t_group_info-&gt;bIgnoreIsotopic;</a>
<a name="ln3276">    /*  1-3 tautomers */</a>
<a name="ln3277">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3278">        /*  find possible endpoint Z = at[i] */</a>
<a name="ln3279">        if ( (endpoint_valence = nGetEndpointInfo( at, i, &amp;eif1 )) ) {</a>
<a name="ln3280">            /*  1st endpoint candidate found. Find centerpoint candidate */</a>
<a name="ln3281">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln3282">                bond_type   = (int)at[i].bond_type[j] &amp; ~BOND_MARK_ALL;</a>
<a name="ln3283">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln3284">                bond_type = ACTUAL_ORDER(pBNS,i,j,bond_type);</a>
<a name="ln3285">#endif</a>
<a name="ln3286">                centerpoint = (int)at[i].neighbor[j];  /*  a centerpoint candidate */</a>
<a name="ln3287">                if ( (bond_type == BOND_DOUBLE ||</a>
<a name="ln3288">                      bond_type == BOND_ALTERN ||</a>
<a name="ln3289">                      bond_type == BOND_ALT12NS ||</a>
<a name="ln3290">                      bond_type == BOND_TAUTOM) &amp;&amp; is_centerpoint_elem( at[centerpoint].el_number ) </a>
<a name="ln3291">                      &amp;&amp; ALLOWED_EDGE(pBNS, i, j)</a>
<a name="ln3292">                      ) {</a>
<a name="ln3293">                    /*  test a centerpoint candidate. */</a>
<a name="ln3294">                    /*  find all endpoints including at[i] and store them into EndPoint[] */</a>
<a name="ln3295">                    nNumPossibleMobile =  0;</a>
<a name="ln3296">                    nGroupNumber       =  (AT_NUMB)num_atoms; /*  greater than any tautomeric group number */</a>
<a name="ln3297">                    bDiffGroups        = -1;         /*  ignore the first difference */</a>
<a name="ln3298">                    nNumDonor = nNumAcceptor = 0;</a>
<a name="ln3299">                    for ( k = 0, nNumEndPoints = 0, nNumBondPos = 0; k &lt; at[centerpoint].valence; k ++ ) {</a>
<a name="ln3300">                        endpoint = at[centerpoint].neighbor[k]; /*  endpoint candidate */</a>
<a name="ln3301">                        bond_type    = (int)at[centerpoint].bond_type[k] &amp; ~BOND_MARK_ALL;</a>
<a name="ln3302">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln3303">                        bond_type = ACTUAL_ORDER(pBNS,centerpoint,k,bond_type);</a>
<a name="ln3304">#endif</a>
<a name="ln3305">                        bTautBond    =</a>
<a name="ln3306">                        bNonTautBond =</a>
<a name="ln3307">                        bAltBond     =</a>
<a name="ln3308">                        bPossiblyEndpoint = 0;</a>
<a name="ln3309">                        if ( !ALLOWED_EDGE(pBNS, centerpoint, k) ) {</a>
<a name="ln3310">                            continue;</a>
<a name="ln3311">                        } else</a>
<a name="ln3312">                        if ( bond_type == BOND_ALTERN || bond_type == BOND_ALT12NS || bond_type == BOND_TAUTOM ) {</a>
<a name="ln3313">                            bTautBond = 1;</a>
<a name="ln3314">#if ( REPLACE_ALT_WITH_TAUT == 1 )</a>
<a name="ln3315">                            bAltBond  = (bond_type == BOND_ALTERN || bond_type == BOND_ALT12NS);</a>
<a name="ln3316">#endif</a>
<a name="ln3317">                        } else</a>
<a name="ln3318">                        if ( bond_type == BOND_SINGLE || bond_type == BOND_DOUBLE )</a>
<a name="ln3319">                            bNonTautBond = 1;</a>
<a name="ln3320">                        else</a>
<a name="ln3321">                            continue;</a>
<a name="ln3322"> </a>
<a name="ln3323">                        if ( !(endpoint_valence = nGetEndpointInfo( at, endpoint, &amp;eif1 )) )</a>
<a name="ln3324">                            continue; /*  not an endpoint element or can't have mobile groups */</a>
<a name="ln3325">                        /*  save information about the found possible tautomeric endpoint */</a>
<a name="ln3326">                        /*  2 = T_NUM_NO_ISOTOPIC non-isotopic values */</a>
<a name="ln3327">                        nMobile  =</a>
<a name="ln3328">                        AddAtom2num( EndPoint[nNumEndPoints].num, at, endpoint, 2 ); /* fill out */</a>
<a name="ln3329">                        AddAtom2DA( EndPoint[nNumEndPoints].num_DA, at, endpoint, 2 );</a>
<a name="ln3330">                        /* --- why is isitopic info missing ? -- see below</a>
<a name="ln3331">                        nMobile  = EndPoint[nNumEndPoints].num[1] = (at[endpoint].charge == -1);</a>
<a name="ln3332">                        nMobile  = EndPoint[nNumEndPoints].num[0] = at[endpoint].num_H + nMobile;</a>
<a name="ln3333">                        */</a>
<a name="ln3334">                        if ( bNonTautBond ) {</a>
<a name="ln3335">                            m = (bond_type == BOND_SINGLE &amp;&amp; (nMobile || at[endpoint].endpoint));</a>
<a name="ln3336">                            nNumDonor         += m;</a>
<a name="ln3337">                            bPossiblyEndpoint += m;</a>
<a name="ln3338">                            m = (bond_type == BOND_DOUBLE );</a>
<a name="ln3339">                            nNumAcceptor      += m;</a>
<a name="ln3340">                            bPossiblyEndpoint += m;</a>
<a name="ln3341">                        } else {</a>
<a name="ln3342">                            /*  tautomeric or alternating bond */</a>
<a name="ln3343">                            m = (0 != at[endpoint].endpoint || eif1.cDonor );</a>
<a name="ln3344">                            nNumDonor         += m;</a>
<a name="ln3345">                            bPossiblyEndpoint += m;</a>
<a name="ln3346">                            m = ( at[endpoint].endpoint ||</a>
<a name="ln3347">                                  eif1.cNeutralBondsValence &gt; at[endpoint].valence );</a>
<a name="ln3348">                            nNumAcceptor      += m;</a>
<a name="ln3349">                            bPossiblyEndpoint += m;</a>
<a name="ln3350">                        }</a>
<a name="ln3351">                        if ( !bPossiblyEndpoint )</a>
<a name="ln3352">                            continue;</a>
<a name="ln3353">                        EndPoint[nNumEndPoints].nGroupNumber  = at[endpoint].endpoint; /* =0 if it is an endpoint for the 1st time */</a>
<a name="ln3354">                        EndPoint[nNumEndPoints].nEquNumber    = 0;</a>
<a name="ln3355">                        EndPoint[nNumEndPoints].nAtomNumber   = (AT_NUMB)endpoint;</a>
<a name="ln3356">                        if ( nGroupNumber != at[endpoint].endpoint ) {</a>
<a name="ln3357">                            bDiffGroups ++;</a>
<a name="ln3358">                            nGroupNumber  = at[endpoint].endpoint;</a>
<a name="ln3359">                        }</a>
<a name="ln3360">                        </a>
<a name="ln3361">                        /*  save positions of all, not only possibly tautomeric bonds */</a>
<a name="ln3362">#if ( REPLACE_ALT_WITH_TAUT != 1 )</a>
<a name="ln3363">                        if ( bNonTautBond || bAltBond ) {</a>
<a name="ln3364">#endif</a>
<a name="ln3365">                            BondPos[nNumBondPos].nAtomNumber    = (AT_NUMB)centerpoint;</a>
<a name="ln3366">                            BondPos[nNumBondPos].neighbor_index = (AT_NUMB)k; /* bond ordering number; used to change bonds to tautomeric only  */</a>
<a name="ln3367">                            nNumBondPos ++;</a>
<a name="ln3368">#if ( REPLACE_ALT_WITH_TAUT != 1 )</a>
<a name="ln3369">                        }</a>
<a name="ln3370">#endif</a>
<a name="ln3371">                        /*  mobile group is possible if (a) the endpoint has a mobile group or */</a>
<a name="ln3372">                        /*                              (b) the centerpoint is adjacent to another endpoint */</a>
<a name="ln3373">                        nNumPossibleMobile += (nMobile&gt;0 || at[endpoint].endpoint);</a>
<a name="ln3374">                        nNumEndPoints ++;</a>
<a name="ln3375">                    }</a>
<a name="ln3376">                    if ( nNumEndPoints &gt; 1 &amp;&amp; nNumPossibleMobile &amp;&amp; nNumDonor &amp;&amp; nNumAcceptor ) {</a>
<a name="ln3377">                        /*</a>
<a name="ln3378">                         * a tautomeric group has been found</a>
<a name="ln3379">                         *</a>
<a name="ln3380">                         * at this point:</a>
<a name="ln3381">                         * nGroupNumber = 0 if all endpoints belong to a newly discovered tautomeric group</a>
<a name="ln3382">                         * bDiffGroups  &gt; 0 if at least 2 tautomeric groups are to be merged (one of them can be new)</a>
<a name="ln3383">                         * case (nGroupNumber != 0 &amp;&amp; bDiffGroups = 0 ) ignored because all endpoints belong to the same known t-group</a>
<a name="ln3384">                         * case (nGroupNumber != 0 &amp;&amp; bDiffGroups &lt; 0 ) cannot happen</a>
<a name="ln3385">                         */</a>
<a name="ln3386"> </a>
<a name="ln3387">                        nErr=FindAccessibleEndPoints( EndPoint, &amp;nNumEndPoints, BondPos, &amp;nNumBondPos,</a>
<a name="ln3388">                                                 pBNS, pBD, at, num_atoms, c_group_info, ALT_PATH_MODE_TAUTOM );</a>
<a name="ln3389">                        if ( IS_BNS_ERROR(nErr) ) {</a>
<a name="ln3390">                            return nErr;</a>
<a name="ln3391">                        }</a>
<a name="ln3392">                        nErr = 0;</a>
<a name="ln3393"> </a>
<a name="ln3394">                        if ( nNumEndPoints &gt; 0 ) {</a>
<a name="ln3395">                            if ( !nGroupNumber || bDiffGroups &gt; 0 ) {</a>
<a name="ln3396">                                num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS );</a>
<a name="ln3397">                                if ( num_changes == -1 ) {</a>
<a name="ln3398">                                    nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3399">                                }</a>
<a name="ln3400">                                if ( num_changes &lt; 0 ) {</a>
<a name="ln3401">                                    nErr = num_changes;</a>
<a name="ln3402">                                }</a>
<a name="ln3403">                                if ( nErr )</a>
<a name="ln3404">                                    goto exit_function;</a>
<a name="ln3405">                                tot_changes += (num_changes&gt;0);</a>
<a name="ln3406">                            }</a>
<a name="ln3407">                            if ( nNumBondPos &gt; 0 ) {</a>
<a name="ln3408">                                /*  some of the bonds have not been marked as tautomeric yet */</a>
<a name="ln3409">                                num_changes = SetTautomericBonds( at, nNumBondPos, BondPos );</a>
<a name="ln3410">                                tot_changes += (num_changes&gt;0);</a>
<a name="ln3411">                            }</a>
<a name="ln3412">                        }</a>
<a name="ln3413">                    }</a>
<a name="ln3414">                }</a>
<a name="ln3415">            }</a>
<a name="ln3416">        }</a>
<a name="ln3417">    }</a>
<a name="ln3418">#if ( KETO_ENOL_TAUT == 1 )  /***** post v.1 feature *****/</a>
<a name="ln3419">    if ( t_group_info-&gt;bTautFlags &amp; TG_FLAG_KETO_ENOL_TAUT ) {</a>
<a name="ln3420">        /* 1,3 keto-enol tautomerism */</a>
<a name="ln3421">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3422">            /*  find possible endpoint Z = at[i] */</a>
<a name="ln3423">            if ( (endpoint_valence = nGetEndpointInfo_KET( at, i, &amp;eif1 )) ) {</a>
<a name="ln3424">                /*  1st endpoint candidate found. Find centerpoint candidate */</a>
<a name="ln3425">                for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln3426">                    bond_type   = (int)at[i].bond_type[j] &amp; ~BOND_MARK_ALL;</a>
<a name="ln3427">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln3428">                    bond_type = ACTUAL_ORDER(pBNS,i,j,bond_type);</a>
<a name="ln3429">#endif</a>
<a name="ln3430">                    centerpoint = (int)at[i].neighbor[j];  /*  a centerpoint candidate */</a>
<a name="ln3431">                    if ( (bond_type == BOND_DOUBLE ||</a>
<a name="ln3432">                          bond_type == BOND_ALTERN ||</a>
<a name="ln3433">                          bond_type == BOND_ALT12NS ||</a>
<a name="ln3434">                          bond_type == BOND_TAUTOM) &amp;&amp;</a>
<a name="ln3435">                          is_centerpoint_elem_KET( at[centerpoint].el_number ) &amp;&amp;</a>
<a name="ln3436">                          !at[centerpoint].charge &amp;&amp; !at[centerpoint].radical &amp;&amp;</a>
<a name="ln3437">                          /* only normal carbon is allowed */</a>
<a name="ln3438">                          4 == at[centerpoint].chem_bonds_valence + at[centerpoint].num_H</a>
<a name="ln3439">                          &amp;&amp; ALLOWED_EDGE(pBNS, i, j)</a>
<a name="ln3440">                          ) {</a>
<a name="ln3441">                        int num_O = 0;</a>
<a name="ln3442">                        int num_C = 0;</a>
<a name="ln3443">                        /*  test a centerpoint candidate. */</a>
<a name="ln3444">                        /*  find all endpoints including at[i] and store them into EndPoint[] */</a>
<a name="ln3445">                        nNumPossibleMobile =  0;</a>
<a name="ln3446">                        nGroupNumber       =  (AT_NUMB)num_atoms; /*  greater than any tautomeric group number */</a>
<a name="ln3447">                        bDiffGroups        = -1;         /*  ignore the first difference */</a>
<a name="ln3448">                        nNumDonor = nNumAcceptor = 0;</a>
<a name="ln3449">                        for ( k = 0, nNumEndPoints = 0, nNumBondPos = 0; k &lt; at[centerpoint].valence; k ++ ) {</a>
<a name="ln3450">                            endpoint = at[centerpoint].neighbor[k]; /*  endpoint candidate */</a>
<a name="ln3451">                            bond_type    = (int)at[centerpoint].bond_type[k] &amp; ~BOND_MARK_ALL;</a>
<a name="ln3452">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln3453">                            bond_type = ACTUAL_ORDER(pBNS,centerpoint,k,bond_type);</a>
<a name="ln3454">#endif</a>
<a name="ln3455">                            bTautBond    =</a>
<a name="ln3456">                            bNonTautBond =</a>
<a name="ln3457">                            bAltBond     =</a>
<a name="ln3458">                            bPossiblyEndpoint = 0;</a>
<a name="ln3459">                            if ( !ALLOWED_EDGE(pBNS, centerpoint, k) ) {</a>
<a name="ln3460">                                continue;</a>
<a name="ln3461">                            } else</a>
<a name="ln3462">                            if ( bond_type == BOND_ALTERN || bond_type == BOND_ALT12NS || bond_type == BOND_TAUTOM ) {</a>
<a name="ln3463">                                bTautBond = 1;</a>
<a name="ln3464">#if ( REPLACE_ALT_WITH_TAUT == 1 )</a>
<a name="ln3465">                                bAltBond  = (bond_type == BOND_ALTERN || bond_type == BOND_ALT12NS);</a>
<a name="ln3466">#endif</a>
<a name="ln3467">                            } else</a>
<a name="ln3468">                            if ( bond_type == BOND_SINGLE || bond_type == BOND_DOUBLE )</a>
<a name="ln3469">                                bNonTautBond = 1;</a>
<a name="ln3470">                            else</a>
<a name="ln3471">                                continue;</a>
<a name="ln3472"> </a>
<a name="ln3473">                            if ( !(endpoint_valence = nGetEndpointInfo_KET( at, endpoint, &amp;eif2 )) ) {</a>
<a name="ln3474">                                continue;</a>
<a name="ln3475">                            }</a>
<a name="ln3476">                            /*</a>
<a name="ln3477">                            if ( 3 != eif1.cKetoEnolCode + eif2.cKetoEnolCode &amp;&amp; endpoint != i )</a>
<a name="ln3478">                                continue;</a>
<a name="ln3479">                            */</a>
<a name="ln3480">                            /*  save information about the found possible tautomeric endpoint */</a>
<a name="ln3481">                            /*  2 = T_NUM_NO_ISOTOPIC non-isotopic values */</a>
<a name="ln3482">                            nMobile  =</a>
<a name="ln3483">                            AddAtom2num( EndPoint[nNumEndPoints].num, at, endpoint, 2 ); /* fill out */</a>
<a name="ln3484">                            AddAtom2DA( EndPoint[nNumEndPoints].num_DA, at, endpoint, 2 );</a>
<a name="ln3485">                            /* --- why is isitopic info missing ? -- see below</a>
<a name="ln3486">                            nMobile  = EndPoint[nNumEndPoints].num[1] = (at[endpoint].charge == -1);</a>
<a name="ln3487">                            nMobile  = EndPoint[nNumEndPoints].num[0] = at[endpoint].num_H + nMobile;</a>
<a name="ln3488">                            */</a>
<a name="ln3489">                            if ( bNonTautBond ) {</a>
<a name="ln3490">                                m = (bond_type == BOND_SINGLE &amp;&amp; (nMobile || at[endpoint].endpoint));</a>
<a name="ln3491">                                nNumDonor         += m;</a>
<a name="ln3492">                                bPossiblyEndpoint += m;</a>
<a name="ln3493">                                m = (bond_type == BOND_DOUBLE );</a>
<a name="ln3494">                                nNumAcceptor      += m;</a>
<a name="ln3495">                                bPossiblyEndpoint += m;</a>
<a name="ln3496">                            } else {</a>
<a name="ln3497">                                /*  tautomeric or alternating bond */</a>
<a name="ln3498">                                m = (0 != at[endpoint].endpoint || eif1.cDonor );</a>
<a name="ln3499">                                nNumDonor         += m;</a>
<a name="ln3500">                                bPossiblyEndpoint += m;</a>
<a name="ln3501">                                m = ( at[endpoint].endpoint ||</a>
<a name="ln3502">                                      eif1.cNeutralBondsValence &gt; at[endpoint].valence );</a>
<a name="ln3503">                                nNumAcceptor      += m;</a>
<a name="ln3504">                                bPossiblyEndpoint += m;</a>
<a name="ln3505">                            }</a>
<a name="ln3506">                            if ( !bPossiblyEndpoint )</a>
<a name="ln3507">                                continue;</a>
<a name="ln3508"> </a>
<a name="ln3509">                            num_O += (endpoint_valence == 2);</a>
<a name="ln3510">                            num_C += (endpoint_valence == 4);</a>
<a name="ln3511"> </a>
<a name="ln3512">                            EndPoint[nNumEndPoints].nGroupNumber  = at[endpoint].endpoint; /* =0 if it is an endpoint for the 1st time */</a>
<a name="ln3513">                            EndPoint[nNumEndPoints].nEquNumber    = 0;</a>
<a name="ln3514">                            EndPoint[nNumEndPoints].nAtomNumber   = (AT_NUMB)endpoint;</a>
<a name="ln3515">                            if ( nGroupNumber != at[endpoint].endpoint ) {</a>
<a name="ln3516">                                bDiffGroups ++;</a>
<a name="ln3517">                                nGroupNumber  = at[endpoint].endpoint;</a>
<a name="ln3518">                            }</a>
<a name="ln3519">                            </a>
<a name="ln3520">                            /*  save positions of all, not only possibly tautomeric bonds */</a>
<a name="ln3521">#if ( REPLACE_ALT_WITH_TAUT != 1 )</a>
<a name="ln3522">                            if ( bNonTautBond || bAltBond ) {</a>
<a name="ln3523">#endif</a>
<a name="ln3524">                                BondPos[nNumBondPos].nAtomNumber    = (AT_NUMB)centerpoint;</a>
<a name="ln3525">                                BondPos[nNumBondPos].neighbor_index = (AT_NUMB)k; /* bond ordering number; used to change bonds to tautomeric only  */</a>
<a name="ln3526">                                nNumBondPos ++;</a>
<a name="ln3527">#if ( REPLACE_ALT_WITH_TAUT != 1 )</a>
<a name="ln3528">                            }</a>
<a name="ln3529">#endif</a>
<a name="ln3530">                            /*  mobile group is possible if (a) the endpoint has a mobile group or */</a>
<a name="ln3531">                            /*                              (b) the centerpoint is adjacent to another endpoint */</a>
<a name="ln3532">                            nNumPossibleMobile += (nMobile&gt;0 || at[endpoint].endpoint);</a>
<a name="ln3533">                            nNumEndPoints ++;</a>
<a name="ln3534">                        }</a>
<a name="ln3535">                        if ( nNumEndPoints &gt; 1 &amp;&amp; nNumPossibleMobile &amp;&amp; nNumDonor &amp;&amp; nNumAcceptor &amp;&amp; num_O==1 &amp;&amp; num_C ) {</a>
<a name="ln3536">                            /*</a>
<a name="ln3537">                             * a tautomeric group has been found</a>
<a name="ln3538">                             *</a>
<a name="ln3539">                             * at this point:</a>
<a name="ln3540">                             * nGroupNumber = 0 if all endpoints belong to a newly discovered tautomeric group</a>
<a name="ln3541">                             * bDiffGroups  &gt; 0 if at least 2 tautomeric groups are to be merged (one of them can be new)</a>
<a name="ln3542">                             * case (nGroupNumber != 0 &amp;&amp; bDiffGroups = 0 ) ignored because all endpoints belong to the same known t-group</a>
<a name="ln3543">                             * case (nGroupNumber != 0 &amp;&amp; bDiffGroups &lt; 0 ) cannot happen</a>
<a name="ln3544">                             */</a>
<a name="ln3545"> </a>
<a name="ln3546">                            nErr=FindAccessibleEndPoints( EndPoint, &amp;nNumEndPoints, BondPos, &amp;nNumBondPos,</a>
<a name="ln3547">                                                     pBNS, pBD, at, num_atoms, c_group_info, ALT_PATH_MODE_TAUTOM_KET );</a>
<a name="ln3548">                            if ( IS_BNS_ERROR(nErr) ) {</a>
<a name="ln3549">                                return nErr;</a>
<a name="ln3550">                            }</a>
<a name="ln3551">                            nErr = 0;</a>
<a name="ln3552"> </a>
<a name="ln3553">                            if ( nNumEndPoints &gt; 0 ) {</a>
<a name="ln3554">                                if ( !nGroupNumber || bDiffGroups &gt; 0 ) {</a>
<a name="ln3555">                                    num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS );</a>
<a name="ln3556">                                    if ( num_changes == -1 ) {</a>
<a name="ln3557">                                        nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3558">                                    }</a>
<a name="ln3559">                                    if ( num_changes &lt; 0 ) {</a>
<a name="ln3560">                                        nErr = num_changes;</a>
<a name="ln3561">                                    }</a>
<a name="ln3562">                                    if ( nErr )</a>
<a name="ln3563">                                        goto exit_function;</a>
<a name="ln3564">                                    tot_changes += (num_changes&gt;0);</a>
<a name="ln3565">                                }</a>
<a name="ln3566">                                if ( nNumBondPos &gt; 0 ) {</a>
<a name="ln3567">                                    /*  some of the bonds have not been marked as tautomeric yet */</a>
<a name="ln3568">                                    num_changes = SetTautomericBonds( at, nNumBondPos, BondPos );</a>
<a name="ln3569">                                    tot_changes += (num_changes&gt;0);</a>
<a name="ln3570">                                }</a>
<a name="ln3571">                            }</a>
<a name="ln3572">                        }</a>
<a name="ln3573">                    }</a>
<a name="ln3574">                }</a>
<a name="ln3575">            }</a>
<a name="ln3576">        }</a>
<a name="ln3577">    }</a>
<a name="ln3578">#endif  /* KETO_ENOL_TAUT */</a>
<a name="ln3579"> </a>
<a name="ln3580">#if ( TAUT_OTHER == 1 ) /* { */</a>
<a name="ln3581">    if ( !tot_changes ) {</a>
<a name="ln3582">#define MAX_ALT_PATH_LEN 8</a>
<a name="ln3583">        int nMaxLenDfsPath = MAX_ALT_PATH_LEN;</a>
<a name="ln3584">        int i1, i2;</a>
<a name="ln3585">        AT_RANK *nDfsPathPos = (AT_RANK  *)inchi_calloc( num_atoms, sizeof(nDfsPathPos[0]) );</a>
<a name="ln3586">        DFS_PATH DfsPath[MAX_ALT_PATH_LEN];</a>
<a name="ln3587">        int      ret;</a>
<a name="ln3588">        if ( !nDfsPathPos || !DfsPath ) {</a>
<a name="ln3589">            tot_changes = CT_OUT_OF_RAM;  /*   &lt;BRKPT&gt; */</a>
<a name="ln3590">            goto free_memory;</a>
<a name="ln3591">        }</a>
<a name="ln3592">#if ( TAUT_15_NON_RING      == 1 ) /***** post v.1 feature *****/</a>
<a name="ln3593">        if ( t_group_info-&gt;bTautFlags &amp; TG_FLAG_1_5_TAUT ) {</a>
<a name="ln3594">            /*  1,5 tautomerism; one of the endpoints should no be on a ring  */</a>
<a name="ln3595">            /*</a>
<a name="ln3596">                  O                OH                 O      </a>
<a name="ln3597">                  ||               |                  ||     </a>
<a name="ln3598">                  A--pos-          A--pos-            A--pos-</a>
<a name="ln3599">                 /   sib-        //   sib-     ?     /   sib-</a>
<a name="ln3600">                C    ly          C    ly            CH   ly</a>
<a name="ln3601">                \\   a     &lt;--&gt;   \   a       &lt;--&gt;   \   a   </a>
<a name="ln3602">                  B--ring          B--ring            B--ring</a>
<a name="ln3603">                  |                ||                 ||     </a>
<a name="ln3604">                  NH               N                  N</a>
<a name="ln3605"> </a>
<a name="ln3606">               Note: few recent modifications now allow the terminal N be in a ring, too</a>
<a name="ln3607">             */</a>
<a name="ln3608">            for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) {</a>
<a name="ln3609">                /*  find possible endpoint Z = at[i1] */</a>
<a name="ln3610">                if ( !(endpoint_valence = nGetEndpointInfo( at, i1, &amp;eif1 ) ) /*||</a>
<a name="ln3611">                     at[i1].nNumAtInRingSystem &gt; 1*/ ) {</a>
<a name="ln3612">                    continue; /*  not a possibly endpoint */</a>
<a name="ln3613">                }</a>
<a name="ln3614"> </a>
<a name="ln3615">                if ( 1 ) {</a>
<a name="ln3616">                    nNumEndPoints = 0;</a>
<a name="ln3617">                    nNumBondPos   = 0;</a>
<a name="ln3618"> </a>
<a name="ln3619">                    ret = nGet15TautInAltPath( at, i1, nDfsPathPos,</a>
<a name="ln3620">                                                  DfsPath,  nMaxLenDfsPath,</a>
<a name="ln3621">                                                  EndPoint, sizeof(EndPoint)/sizeof(EndPoint[0]),</a>
<a name="ln3622">                                                  BondPos, sizeof(BondPos)/sizeof(BondPos[0]),</a>
<a name="ln3623">                                                  &amp;nNumEndPoints, &amp;nNumBondPos, </a>
<a name="ln3624">                                                  pBNS, pBD, num_atoms);</a>
<a name="ln3625">                    if ( ret &gt; 0 ) {</a>
<a name="ln3626">                        if ( nNumEndPoints ) {</a>
<a name="ln3627">                            num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS);</a>
<a name="ln3628">                            if ( num_changes == -1 ) {</a>
<a name="ln3629">                                nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3630">                            }</a>
<a name="ln3631">                            if ( num_changes &lt; 0 ) {</a>
<a name="ln3632">                                nErr = num_changes;</a>
<a name="ln3633">                            }</a>
<a name="ln3634">                            if ( nErr )</a>
<a name="ln3635">                                goto free_memory;</a>
<a name="ln3636">                            tot_changes += (num_changes &gt; 0);</a>
<a name="ln3637">                        }</a>
<a name="ln3638">                        if ( nNumBondPos ) {</a>
<a name="ln3639">                            tot_changes += ( 0 &lt; SetTautomericBonds( at, nNumBondPos, BondPos ) );</a>
<a name="ln3640">                        }</a>
<a name="ln3641">                    } else</a>
<a name="ln3642">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3643">                        nErr = ret;</a>
<a name="ln3644">                        goto free_memory;</a>
<a name="ln3645">                    }</a>
<a name="ln3646">                }</a>
<a name="ln3647">            }</a>
<a name="ln3648">        }</a>
<a name="ln3649">#endif</a>
<a name="ln3650">#if ( TAUT_4PYRIDINOL_RINGS == 1 )</a>
<a name="ln3651">        /*  6-member rings */</a>
<a name="ln3652">        /*</a>
<a name="ln3653">              O              OH             OH   </a>
<a name="ln3654">              ||             |              |    </a>
<a name="ln3655">             /  \          //  \           /  \\ </a>
<a name="ln3656">            ||   ||  &lt;--&gt;  |    ||  &lt;--&gt;  ||   | </a>
<a name="ln3657">             \  /          \\  /           \  // </a>
<a name="ln3658">              NH             N              N    </a>
<a name="ln3659">         */</a>
<a name="ln3660">        for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) {</a>
<a name="ln3661">            /*  find possible endpoint Z = at[i1] */</a>
<a name="ln3662">            if ( 3 != (endpoint_valence = nGetEndpointInfo( at, i1, &amp;eif1 ) ) ||</a>
<a name="ln3663">                 2 != at[i1].valence ) {</a>
<a name="ln3664">                continue; /*  not a nitrogen atom or a wrong valence */</a>
<a name="ln3665">            }</a>
<a name="ln3666"> </a>
<a name="ln3667">            if ( at[i1].nNumAtInRingSystem &gt;= 6 ) {</a>
<a name="ln3668">                nNumEndPoints = 0;</a>
<a name="ln3669">                nNumBondPos   = 0;</a>
<a name="ln3670"> </a>
<a name="ln3671">                ret = nGet15TautIn6MembAltRing( at, i1, nDfsPathPos,</a>
<a name="ln3672">                                              DfsPath,  nMaxLenDfsPath,</a>
<a name="ln3673">                                              EndPoint, sizeof(EndPoint)/sizeof(EndPoint[0]),</a>
<a name="ln3674">                                              BondPos, sizeof(BondPos)/sizeof(BondPos[0]),</a>
<a name="ln3675">                                              &amp;nNumEndPoints, &amp;nNumBondPos, </a>
<a name="ln3676">                                              pBNS, pBD, num_atoms);</a>
<a name="ln3677">                if ( ret &gt; 0 ) {</a>
<a name="ln3678">                    if ( nNumEndPoints ) {</a>
<a name="ln3679">                        num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS);</a>
<a name="ln3680">                        if ( num_changes == -1 ) {</a>
<a name="ln3681">                            nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3682">                        }</a>
<a name="ln3683">                        if ( num_changes &lt; 0 ) {</a>
<a name="ln3684">                            nErr = num_changes;</a>
<a name="ln3685">                        }</a>
<a name="ln3686">                        if ( nErr )</a>
<a name="ln3687">                            goto free_memory;</a>
<a name="ln3688">                        tot_changes += (num_changes &gt; 0);</a>
<a name="ln3689">                    }</a>
<a name="ln3690">                    if ( nNumBondPos ) {</a>
<a name="ln3691">                        tot_changes += ( 0 &lt; SetTautomericBonds( at, nNumBondPos, BondPos ) );</a>
<a name="ln3692">                    }</a>
<a name="ln3693">                } else</a>
<a name="ln3694">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3695">                    nErr = ret;</a>
<a name="ln3696">                    goto free_memory;</a>
<a name="ln3697">                }</a>
<a name="ln3698">            }</a>
<a name="ln3699">        }</a>
<a name="ln3700">#endif /* TAUT_4PYRIDINOL_RINGS */</a>
<a name="ln3701">#if ( TAUT_PYRAZOLE_RINGS == 1 )</a>
<a name="ln3702">        /* 5-member rings:</a>
<a name="ln3703"> </a>
<a name="ln3704">            Z               Z   </a>
<a name="ln3705">          /  \\           //  \ </a>
<a name="ln3706">         X     Y  &lt;--&gt;   X     Y</a>
<a name="ln3707">         \\   /          \    //</a>
<a name="ln3708">          N--NH           HN--N  </a>
<a name="ln3709">                       </a>
<a name="ln3710">             ^             ^</a>
<a name="ln3711">             search for these NH</a>
<a name="ln3712">        */</a>
<a name="ln3713">        /*  5-member rings (pyrazole derivatives): look for the neighboring N */</a>
<a name="ln3714">        for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) {</a>
<a name="ln3715">            if ( 2 == at[i1].valence &amp;&amp;</a>
<a name="ln3716">                 at[i1].nNumAtInRingSystem &gt;= 5 &amp;&amp;</a>
<a name="ln3717">                 3 == (endpoint_valence = nGetEndpointInfo( at, i1, &amp;eif1 ))</a>
<a name="ln3718">               ) {</a>
<a name="ln3719">                nMobile = at[i1].num_H + (at[i1].charge == -1);</a>
<a name="ln3720">                for ( j = 0; j &lt; at[i1].valence; j ++ ) {</a>
<a name="ln3721">                    int nMobile2, endpoint_valence2;</a>
<a name="ln3722">                    i2 = at[i1].neighbor[j];</a>
<a name="ln3723"> </a>
<a name="ln3724">                    /*  may be important */</a>
<a name="ln3725">                    if ( i2 &gt;= i1 )</a>
<a name="ln3726">                        continue; /*  do not try same pair 2 times */</a>
<a name="ln3727"> </a>
<a name="ln3728">                    if ( at[i2].nRingSystem != at[i1].nRingSystem )</a>
<a name="ln3729">                        continue;</a>
<a name="ln3730">                    </a>
<a name="ln3731">                    bond_type = (at[i1].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln3732">                    if ( (bond_type != BOND_SINGLE &amp;&amp;</a>
<a name="ln3733">                         bond_type != BOND_TAUTOM &amp;&amp;</a>
<a name="ln3734">                         bond_type != BOND_ALT12NS &amp;&amp;</a>
<a name="ln3735">                         bond_type != BOND_ALTERN) ||  /* added 1-15-2002 */</a>
<a name="ln3736">                         2 != at[i2].valence      ||</a>
<a name="ln3737">                         3 != (endpoint_valence2 = nGetEndpointInfo( at, i2, &amp;eif2 ) ) ) {</a>
<a name="ln3738">                        continue; /*  not a nitrogen atom or a wrong valence or not a single bond */</a>
<a name="ln3739">                    }</a>
<a name="ln3740">                    nMobile2 = at[i2].num_H + (at[i2].charge == -1);  /*  number of mobile groups */</a>
<a name="ln3741">#if ( TAUT_IGNORE_EQL_ENDPOINTS == 1 )</a>
<a name="ln3742">                      if ( at[i1].endpoint &amp;&amp; at[i1].endpoint == at[i2].endpoint )</a>
<a name="ln3743">                          continue; /* atoms already belong to the same t-group */</a>
<a name="ln3744">#endif</a>
<a name="ln3745">                    if ( !at[i1].endpoint &amp;&amp; !at[i2].endpoint &amp;&amp; 1!=nMobile + nMobile2 )</a>
<a name="ln3746">                        continue;</a>
<a name="ln3747"> </a>
<a name="ln3748">                    ret = nGet12TautIn5MembAltRing( at, i1, j, nDfsPathPos,</a>
<a name="ln3749">                                                  DfsPath,  nMaxLenDfsPath,</a>
<a name="ln3750">                                                  EndPoint, sizeof(EndPoint)/sizeof(EndPoint[0]),</a>
<a name="ln3751">                                                  BondPos, sizeof(BondPos)/sizeof(BondPos[0]),</a>
<a name="ln3752">                                                  &amp;nNumEndPoints, &amp;nNumBondPos </a>
<a name="ln3753">                                                 , pBNS, pBD, num_atoms);</a>
<a name="ln3754">                    if ( ret &gt; 0 ) {</a>
<a name="ln3755">                        if ( nNumEndPoints ) {</a>
<a name="ln3756">                            num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS);</a>
<a name="ln3757">                            if ( num_changes == -1 ) {</a>
<a name="ln3758">                                nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3759">                            }</a>
<a name="ln3760">                            if ( num_changes &lt; 0 ) {</a>
<a name="ln3761">                                nErr = num_changes;</a>
<a name="ln3762">                            }</a>
<a name="ln3763">                            if ( nErr )</a>
<a name="ln3764">                                goto free_memory;</a>
<a name="ln3765">                            tot_changes += (num_changes &gt; 0);</a>
<a name="ln3766">                        }</a>
<a name="ln3767">                        if ( nNumBondPos ) {</a>
<a name="ln3768">                            tot_changes += ( 0 &lt; SetTautomericBonds( at, nNumBondPos, BondPos ) );</a>
<a name="ln3769">                        }</a>
<a name="ln3770">                    } else</a>
<a name="ln3771">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3772">                        nErr = ret;</a>
<a name="ln3773">                        goto free_memory;</a>
<a name="ln3774">                    }</a>
<a name="ln3775">                }</a>
<a name="ln3776">            }</a>
<a name="ln3777">        }</a>
<a name="ln3778">#endif /* TAUT_PYRAZOLE_RINGS */</a>
<a name="ln3779">#if ( TAUT_TROPOLONE_7 == 1 || TAUT_TROPOLONE_5 == 1 ) /* { */</a>
<a name="ln3780">        /********************************************************</a>
<a name="ln3781">         *                                         A  B</a>
<a name="ln3782">         *                                         | ||</a>
<a name="ln3783">         * 7-member rings (tropolones): look for M=Q--R--ZH,</a>
<a name="ln3784">         *                                       ^ ^  ^  ^</a>
<a name="ln3785">         *                               endpoint1 i1 i2 endpoint2</a>
<a name="ln3786">         * where A-Q-R=B belong to a 7-member alt. (except Q-R bond) ring: ..=A-(Q-R)=B-..</a>
<a name="ln3787">         * Bond Q-R should be single or tautomeric or alternating</a>
<a name="ln3788">         * M=Q and R-ZH should be chain (non-ring) bonds</a>
<a name="ln3789">         * Same for 5-member rings</a>
<a name="ln3790">         */</a>
<a name="ln3791">        for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) {</a>
<a name="ln3792">            if ( at[i1].nNumAtInRingSystem &gt;=</a>
<a name="ln3793">#if ( TAUT_TROPOLONE_5 == 1 )</a>
<a name="ln3794">                  5</a>
<a name="ln3795">#else</a>
<a name="ln3796">                  7 </a>
<a name="ln3797">#endif</a>
<a name="ln3798">                 &amp;&amp;</a>
<a name="ln3799">                 bIsCenterPointStrict( at, i1 ) &amp;&amp;</a>
<a name="ln3800">#if ( TAUT_RINGS_ATTACH_CHAIN == 1 )        </a>
<a name="ln3801">                 at[i1].bCutVertex &amp;&amp;</a>
<a name="ln3802">#endif</a>
<a name="ln3803">                 at[i1].valence == 3 &amp;&amp; !at[i1].endpoint ) {</a>
<a name="ln3804">                int nMobile1, endpoint1, endpoint1_valence, bond_type1;</a>
<a name="ln3805">                int nMobile2, endpoint2, endpoint2_valence, bond_type2;</a>
<a name="ln3806">                for ( j = 0; j &lt; at[i1].valence; j ++ ) {</a>
<a name="ln3807">                    i2 = at[i1].neighbor[j];</a>
<a name="ln3808">                    /*</a>
<a name="ln3809">                         // may be important</a>
<a name="ln3810">                    if ( i2 &gt; i1 )</a>
<a name="ln3811">                        continue; // do not try same pair 2 times</a>
<a name="ln3812">                    */</a>
<a name="ln3813">                    if ( at[i2].nRingSystem != at[i1].nRingSystem ||</a>
<a name="ln3814">                         !bIsCenterPointStrict( at, i2 ) ||</a>
<a name="ln3815">#if ( TAUT_RINGS_ATTACH_CHAIN == 1 )        </a>
<a name="ln3816">                         !at[i2].bCutVertex ||</a>
<a name="ln3817">#endif                         </a>
<a name="ln3818">                         at[i2].valence != 3 || at[i2].endpoint )</a>
<a name="ln3819">                        continue;</a>
<a name="ln3820">                    bond_type = (at[i1].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln3821">                    if ( bond_type != BOND_SINGLE &amp;&amp;</a>
<a name="ln3822">                         bond_type != BOND_TAUTOM &amp;&amp;</a>
<a name="ln3823">                         bond_type != BOND_ALT12NS &amp;&amp;</a>
<a name="ln3824">                         bond_type != BOND_ALTERN ) {</a>
<a name="ln3825">                        continue; /*  not a single bond between Q-R */</a>
<a name="ln3826">                    }</a>
<a name="ln3827">                    /*  find endpoints */</a>
<a name="ln3828">                    for ( k = 0; k &lt; at[i1].valence; k ++ ) {</a>
<a name="ln3829">                        endpoint1 = at[i1].neighbor[k];</a>
<a name="ln3830">                        if ( endpoint1 == i2 )</a>
<a name="ln3831">                            continue; /*  j == k */</a>
<a name="ln3832">                        if ( !(endpoint1_valence = nGetEndpointInfo( at, endpoint1, &amp;eif1 ) ) )</a>
<a name="ln3833">                            continue; /*  not an endpoint1 element or can't have mobile groups */</a>
<a name="ln3834">#if ( TAUT_RINGS_ATTACH_CHAIN == 1 )        </a>
<a name="ln3835">                        if ( at[endpoint1].nRingSystem == at[i1].nRingSystem )</a>
<a name="ln3836">                            continue;</a>
<a name="ln3837">#endif</a>
<a name="ln3838">                        nMobile1  = at[endpoint1].num_H + (at[endpoint1].charge == -1);  /*  number of mobile groups */</a>
<a name="ln3839">                        if ( nMobile1 + at[endpoint1].chem_bonds_valence != endpoint1_valence )</a>
<a name="ln3840">                            continue; /*  abnormal endpoint1 valence; ignore. */</a>
<a name="ln3841">                        bond_type1 = (at[i1].bond_type[k] &amp; ~BOND_MARK_ALL);</a>
<a name="ln3842">                        </a>
<a name="ln3843">                        if ( bond_type1 != BOND_SINGLE &amp;&amp;</a>
<a name="ln3844">                             bond_type1 != BOND_DOUBLE &amp;&amp;</a>
<a name="ln3845">                             bond_type1 != BOND_TAUTOM &amp;&amp;</a>
<a name="ln3846">                             bond_type1 != BOND_ALT12NS &amp;&amp;</a>
<a name="ln3847">                             bond_type1 != BOND_ALTERN )</a>
<a name="ln3848">                            continue;</a>
<a name="ln3849">                        </a>
<a name="ln3850">                        for ( m = 0; m &lt; at[i2].valence; m ++ ) {</a>
<a name="ln3851">                            endpoint2 = at[i2].neighbor[m];</a>
<a name="ln3852">                            if ( endpoint2 == i1 )</a>
<a name="ln3853">                                continue;</a>
<a name="ln3854">                            if ( !(endpoint2_valence = nGetEndpointInfo( at, endpoint2, &amp;eif2 )) )</a>
<a name="ln3855">                                continue; /*  not an endpoint2 element or can't have mobile groups */</a>
<a name="ln3856">#if ( TAUT_RINGS_ATTACH_CHAIN == 1 )        </a>
<a name="ln3857">                            if ( at[endpoint2].nRingSystem == at[i2].nRingSystem )</a>
<a name="ln3858">                                continue;</a>
<a name="ln3859">#endif</a>
<a name="ln3860">                            nMobile2  = at[endpoint2].num_H + (at[endpoint2].charge == -1);  /*  number of mobile groups */</a>
<a name="ln3861">                            bond_type2 = (at[i2].bond_type[m] &amp; ~BOND_MARK_ALL);</a>
<a name="ln3862">                            </a>
<a name="ln3863">                            if ( bond_type2 != BOND_SINGLE &amp;&amp;</a>
<a name="ln3864">                                 bond_type2 != BOND_DOUBLE &amp;&amp;</a>
<a name="ln3865">                                 bond_type2 != BOND_TAUTOM &amp;&amp;</a>
<a name="ln3866">                                 bond_type2 != BOND_ALT12NS &amp;&amp;</a>
<a name="ln3867">                                 bond_type2 != BOND_ALTERN )</a>
<a name="ln3868">                                continue;</a>
<a name="ln3869">                            </a>
<a name="ln3870">                            /*  final test for possible tautomerism */</a>
<a name="ln3871">                            nMobile = 0;</a>
<a name="ln3872">                            </a>
<a name="ln3873">                            if ( ALLOWED_EDGE(pBNS, i1, k) &amp;&amp; ALLOWED_EDGE(pBNS, i2, m) ) {</a>
<a name="ln3874">                            </a>
<a name="ln3875">                                /*  can mobile group move from 1 to 2? */</a>
<a name="ln3876">                                nMobile += (at[endpoint1].endpoint || nMobile1) &amp;&amp;  /*  from endpoint1 */</a>
<a name="ln3877">                                           (bond_type1 != BOND_DOUBLE)   &amp;&amp;</a>
<a name="ln3878">                                       </a>
<a name="ln3879">                                            (at[endpoint2].endpoint ||          /*  to endpoint2 */</a>
<a name="ln3880">                                            eif2.cNeutralBondsValence &gt; at[endpoint2].valence ) &amp;&amp;</a>
<a name="ln3881">                                           (bond_type2 != BOND_SINGLE); </a>
<a name="ln3882"> </a>
<a name="ln3883"> </a>
<a name="ln3884">                                /*  can mobile group move from 2 to 1? */</a>
<a name="ln3885">                                nMobile += (at[endpoint2].endpoint || nMobile2) &amp;&amp;  /*  from endpoint2 */</a>
<a name="ln3886">                                           (bond_type2 != BOND_DOUBLE)   &amp;&amp; /*changed from BOND_SINGLE 2004-02-26 */</a>
<a name="ln3887">                                       </a>
<a name="ln3888">                                            (at[endpoint1].endpoint ||          /*  to endpoint1 */</a>
<a name="ln3889">                                            eif1.cNeutralBondsValence &gt; at[endpoint1].valence ) &amp;&amp;</a>
<a name="ln3890">                                           (bond_type1 != BOND_SINGLE);</a>
<a name="ln3891">                            }</a>
<a name="ln3892">                            if ( !nMobile )</a>
<a name="ln3893">                                continue;</a>
<a name="ln3894">                            </a>
<a name="ln3895">                            if ( bond_type1 == bond_type2 &amp;&amp;</a>
<a name="ln3896">                                 (bond_type1 == BOND_SINGLE || bond_type1 == BOND_DOUBLE) )</a>
<a name="ln3897">                                continue;</a>
<a name="ln3898">                            /* -- old --</a>
<a name="ln3899">                            if ( !at[endpoint1].endpoint &amp;&amp; !at[endpoint2].endpoint &amp;&amp; 1 != nMobile1 + nMobile2 )</a>
<a name="ln3900">                                continue;</a>
<a name="ln3901">                            */</a>
<a name="ln3902">                            /* -- new --</a>
<a name="ln3903"> </a>
<a name="ln3904">                            if ( !at[endpoint1].endpoint &amp;&amp; !at[endpoint2].endpoint ) {</a>
<a name="ln3905">                                if ( !(bond_type1 == BOND_SINGLE || bond_type1 == BOND_DOUBLE) ||</a>
<a name="ln3906">                                     !(bond_type2 == BOND_SINGLE || bond_type2 == BOND_DOUBLE) ) {</a>
<a name="ln3907">                                    // at this point bond_type1 != bond_type2</a>
<a name="ln3908">                                    continue;</a>
<a name="ln3909">                                }</a>
<a name="ln3910">                                if ( bond_type1 == BOND_SINGLE &amp;&amp; !nMobile1 ||</a>
<a name="ln3911">                                     bond_type2 == BOND_SINGLE &amp;&amp; !nMobile2 ||</a>
<a name="ln3912">                                     0 == nMobile1 + nMobile2 ) {</a>
<a name="ln3913">                                    continue;</a>
<a name="ln3914">                                }</a>
<a name="ln3915">                            }</a>
<a name="ln3916">                            */</a>
<a name="ln3917">#if ( TAUT_TROPOLONE_7 == 1 )</a>
<a name="ln3918">                            if ( at[i1].nNumAtInRingSystem &gt;= 7 ) {</a>
<a name="ln3919">                                ret = nGet14TautIn7MembAltRing( at, i1, j, k, m, nDfsPathPos,</a>
<a name="ln3920">                                                              DfsPath,  nMaxLenDfsPath,</a>
<a name="ln3921">                                                              EndPoint, sizeof(EndPoint)/sizeof(EndPoint[0]),</a>
<a name="ln3922">                                                              BondPos, sizeof(BondPos)/sizeof(BondPos[0]),</a>
<a name="ln3923">                                                              &amp;nNumEndPoints, &amp;nNumBondPos, </a>
<a name="ln3924">                                                              pBNS, pBD, num_atoms);</a>
<a name="ln3925">                                if ( ret &gt; 0 ) {</a>
<a name="ln3926">                                    if ( nNumEndPoints ) {</a>
<a name="ln3927">                                        num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS);</a>
<a name="ln3928">                                        if ( num_changes == -1 ) {</a>
<a name="ln3929">                                            nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3930">                                        }</a>
<a name="ln3931">                                        if ( num_changes &lt; 0 ) {</a>
<a name="ln3932">                                            nErr = num_changes;</a>
<a name="ln3933">                                        }</a>
<a name="ln3934">                                        if ( nErr )</a>
<a name="ln3935">                                            goto free_memory;</a>
<a name="ln3936">                                        tot_changes += (num_changes &gt; 0);</a>
<a name="ln3937">                                    }</a>
<a name="ln3938">                                    if ( nNumBondPos ) {</a>
<a name="ln3939">                                        tot_changes += ( 0 &lt; SetTautomericBonds( at, nNumBondPos, BondPos ) );</a>
<a name="ln3940">                                    }</a>
<a name="ln3941">                                } else</a>
<a name="ln3942">                                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3943">                                    nErr = ret;</a>
<a name="ln3944">                                    goto free_memory;</a>
<a name="ln3945">                                }</a>
<a name="ln3946">                            }</a>
<a name="ln3947">#endif</a>
<a name="ln3948"> </a>
<a name="ln3949">#if ( TAUT_TROPOLONE_5 == 1 )</a>
<a name="ln3950">                            if ( at[i1].nNumAtInRingSystem &gt;= 5 ) {</a>
<a name="ln3951">                                ret = nGet14TautIn5MembAltRing( at, i1, j, k, m, nDfsPathPos,</a>
<a name="ln3952">                                                              DfsPath,  nMaxLenDfsPath,</a>
<a name="ln3953">                                                              EndPoint, sizeof(EndPoint)/sizeof(EndPoint[0]),</a>
<a name="ln3954">                                                              BondPos, sizeof(BondPos)/sizeof(BondPos[0]),</a>
<a name="ln3955">                                                              &amp;nNumEndPoints, &amp;nNumBondPos, </a>
<a name="ln3956">                                                              pBNS, pBD, num_atoms);</a>
<a name="ln3957">                                if ( ret &gt; 0 ) {</a>
<a name="ln3958">                                    if ( nNumEndPoints ) {</a>
<a name="ln3959">                                        num_changes = RegisterEndPoints( t_group_info, EndPoint, nNumEndPoints, at, num_atoms, c_group_info, pBNS);</a>
<a name="ln3960">                                        if ( num_changes == -1 ) {</a>
<a name="ln3961">                                            nErr = CT_TAUCOUNT_ERR;</a>
<a name="ln3962">                                        }</a>
<a name="ln3963">                                        if ( num_changes &lt; 0 ) {</a>
<a name="ln3964">                                            nErr = num_changes;</a>
<a name="ln3965">                                        }</a>
<a name="ln3966">                                        if ( nErr )</a>
<a name="ln3967">                                            goto free_memory;</a>
<a name="ln3968">                                        tot_changes += (num_changes &gt; 0);</a>
<a name="ln3969">                                    }</a>
<a name="ln3970">                                    if ( nNumBondPos ) {</a>
<a name="ln3971">                                        tot_changes += ( 0 &lt; SetTautomericBonds( at, nNumBondPos, BondPos ) );</a>
<a name="ln3972">                                    }</a>
<a name="ln3973">                                } else</a>
<a name="ln3974">                                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3975">                                    nErr = ret;</a>
<a name="ln3976">                                    goto free_memory;</a>
<a name="ln3977">                                }</a>
<a name="ln3978">                            }</a>
<a name="ln3979">#endif</a>
<a name="ln3980">                        }</a>
<a name="ln3981">                    }</a>
<a name="ln3982">                }</a>
<a name="ln3983">            }</a>
<a name="ln3984">        }</a>
<a name="ln3985">#endif /* } TAUT_TROPOLONE */</a>
<a name="ln3986">free_memory:</a>
<a name="ln3987">        if ( nDfsPathPos ) {</a>
<a name="ln3988">            inchi_free( nDfsPathPos );</a>
<a name="ln3989">        }</a>
<a name="ln3990">#undef MAX_ALT_PATH_LEN</a>
<a name="ln3991">    }</a>
<a name="ln3992">#endif  /* } FIND_RING_SYSTEMS */</a>
<a name="ln3993">exit_function:</a>
<a name="ln3994">    return nErr &lt; 0? nErr : tot_changes;</a>
<a name="ln3995">}</a>
<a name="ln3996"> </a>
<a name="ln3997"> </a>
<a name="ln3998"> </a>
<a name="ln3999">/*****************************************************************************/</a>
<a name="ln4000">int free_t_group_info( T_GROUP_INFO *t_group_info )</a>
<a name="ln4001">{</a>
<a name="ln4002">    if ( t_group_info ) {</a>
<a name="ln4003">        if ( t_group_info-&gt;t_group ) {</a>
<a name="ln4004">            inchi_free( t_group_info-&gt;t_group );</a>
<a name="ln4005">        }</a>
<a name="ln4006">        if ( t_group_info-&gt;nEndpointAtomNumber ) {</a>
<a name="ln4007">            inchi_free( t_group_info-&gt;nEndpointAtomNumber );</a>
<a name="ln4008">        }</a>
<a name="ln4009">        if ( t_group_info-&gt;tGroupNumber ) {</a>
<a name="ln4010">            inchi_free( t_group_info-&gt;tGroupNumber );</a>
<a name="ln4011">        }</a>
<a name="ln4012">        if ( t_group_info-&gt;nIsotopicEndpointAtomNumber ) {</a>
<a name="ln4013">            inchi_free( t_group_info-&gt;nIsotopicEndpointAtomNumber );</a>
<a name="ln4014">        }</a>
<a name="ln4015">        memset( t_group_info, 0, sizeof(*t_group_info));</a>
<a name="ln4016">    }</a>
<a name="ln4017">    return 0;</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020"> </a>
<a name="ln4021"> </a>
<a name="ln4022">/*****************************************************************************/</a>
<a name="ln4023">int make_a_copy_of_t_group_info( T_GROUP_INFO *t_group_info, T_GROUP_INFO *t_group_info_orig )</a>
<a name="ln4024">{</a>
<a name="ln4025">    int err = 0, len;</a>
<a name="ln4026">    free_t_group_info( t_group_info );</a>
<a name="ln4027">    if ( t_group_info_orig &amp;&amp; t_group_info ) {</a>
<a name="ln4028">        if ( (len=t_group_info_orig-&gt;max_num_t_groups) &gt; 0 ) {</a>
<a name="ln4029">            if ( (t_group_info-&gt;t_group =</a>
<a name="ln4030">                 (T_GROUP*) inchi_malloc( len * sizeof(t_group_info-&gt;t_group[0]))) ) {</a>
<a name="ln4031">                memcpy(t_group_info-&gt;t_group,</a>
<a name="ln4032">                       t_group_info_orig-&gt;t_group,</a>
<a name="ln4033">                       len * sizeof(t_group_info-&gt;t_group[0]));</a>
<a name="ln4034">            } else {</a>
<a name="ln4035">                err ++;</a>
<a name="ln4036">            }</a>
<a name="ln4037">        }</a>
<a name="ln4038">        if ( (len = t_group_info_orig-&gt;nNumEndpoints) &gt; 0 ) {</a>
<a name="ln4039">            if ( (t_group_info-&gt;nEndpointAtomNumber =</a>
<a name="ln4040">                 (AT_NUMB*) inchi_malloc( len * sizeof(t_group_info-&gt;nEndpointAtomNumber[0]))) ) {</a>
<a name="ln4041">                memcpy(t_group_info-&gt;nEndpointAtomNumber,</a>
<a name="ln4042">                       t_group_info_orig-&gt;nEndpointAtomNumber,</a>
<a name="ln4043">                       len * sizeof(t_group_info-&gt;nEndpointAtomNumber[0]));</a>
<a name="ln4044">            } else {</a>
<a name="ln4045">                err ++;</a>
<a name="ln4046">            }</a>
<a name="ln4047">        }</a>
<a name="ln4048">        if ( (len = t_group_info_orig-&gt;num_t_groups) &gt; 0 ) {</a>
<a name="ln4049">            if ( (t_group_info-&gt;tGroupNumber =</a>
<a name="ln4050">                 (AT_NUMB*) inchi_malloc( len * TGSO_TOTAL_LEN * sizeof(t_group_info-&gt;tGroupNumber[0]))) ) {</a>
<a name="ln4051">                memcpy(t_group_info-&gt;tGroupNumber,</a>
<a name="ln4052">                       t_group_info_orig-&gt;tGroupNumber,</a>
<a name="ln4053">                       len * TGSO_TOTAL_LEN * sizeof(t_group_info-&gt;tGroupNumber[0]));</a>
<a name="ln4054">            } else {</a>
<a name="ln4055">                err ++;</a>
<a name="ln4056">            }</a>
<a name="ln4057">        }</a>
<a name="ln4058">        if ( (len = t_group_info_orig-&gt;nNumIsotopicEndpoints) &gt; 0 ) {</a>
<a name="ln4059">            if ( (t_group_info-&gt;nIsotopicEndpointAtomNumber =</a>
<a name="ln4060">                 (AT_NUMB*) inchi_malloc( len * sizeof(t_group_info-&gt;nIsotopicEndpointAtomNumber[0]))) ) {</a>
<a name="ln4061">                memcpy(t_group_info-&gt;nIsotopicEndpointAtomNumber,</a>
<a name="ln4062">                       t_group_info_orig-&gt;nIsotopicEndpointAtomNumber,</a>
<a name="ln4063">                       len * sizeof(t_group_info-&gt;nIsotopicEndpointAtomNumber[0]));</a>
<a name="ln4064">            } else {</a>
<a name="ln4065">                err ++;</a>
<a name="ln4066">            }</a>
<a name="ln4067">        }</a>
<a name="ln4068">        if ( !err ) {</a>
<a name="ln4069">            t_group_info-&gt;nNumEndpoints              = t_group_info_orig-&gt;nNumEndpoints;   </a>
<a name="ln4070">            t_group_info-&gt;num_t_groups               = t_group_info_orig-&gt;num_t_groups;    </a>
<a name="ln4071">            t_group_info-&gt;max_num_t_groups           = t_group_info_orig-&gt;max_num_t_groups;</a>
<a name="ln4072">            t_group_info-&gt;bIgnoreIsotopic            = t_group_info_orig-&gt;bIgnoreIsotopic;</a>
<a name="ln4073">            t_group_info-&gt;nNumIsotopicEndpoints      = t_group_info_orig-&gt;nNumIsotopicEndpoints;</a>
<a name="ln4074">            t_group_info-&gt;tni                        = t_group_info_orig-&gt;tni;</a>
<a name="ln4075">            /*</a>
<a name="ln4076">            t_group_info-&gt;nNumRemovedExplicitH       = t_group_info_orig-&gt;nNumRemovedExplicitH;</a>
<a name="ln4077">            t_group_info-&gt;nNumRemovedProtons         = t_group_info_orig-&gt;nNumRemovedProtons;</a>
<a name="ln4078">            t_group_info-&gt;bNormalizationFlags        = t_group_info_orig-&gt;bNormalizationFlags;</a>
<a name="ln4079">            */</a>
<a name="ln4080">            /*</a>
<a name="ln4081">            t_group_info-&gt;bHardAddedRemovedProtons   = t_group_info_orig-&gt;bHardAddedRemovedProtons;</a>
<a name="ln4082">            t_group_info-&gt;bSimpleAddedRemovedProtons = t_group_info_orig-&gt;bSimpleAddedRemovedProtons;</a>
<a name="ln4083">            t_group_info-&gt;nNumCanceledCharges        = t_group_info_orig-&gt;nNumCanceledCharges;</a>
<a name="ln4084">            */</a>
<a name="ln4085">        }</a>
<a name="ln4086">        t_group_info-&gt;bTautFlags         = t_group_info_orig-&gt;bTautFlags;</a>
<a name="ln4087">        t_group_info-&gt;bTautFlagsDone     = t_group_info_orig-&gt;bTautFlagsDone;</a>
<a name="ln4088">    }</a>
<a name="ln4089">    return err;</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092"> </a>
<a name="ln4093"> </a>
<a name="ln4094">/*****************************************************************************/</a>
<a name="ln4095">/*  Set tautomer group isotopic sort keys									 */</a>
<a name="ln4096">/*****************************************************************************/</a>
<a name="ln4097">int set_tautomer_iso_sort_keys( T_GROUP_INFO *t_group_info )</a>
<a name="ln4098">{</a>
<a name="ln4099">    T_GROUP       *t_group;</a>
<a name="ln4100">    T_GROUP_ISOWT Mult = 1;</a>
<a name="ln4101">    int     i, j, num_t_groups, num_iso_t_groups = 0;</a>
<a name="ln4102">    if ( !t_group_info || !(t_group = t_group_info-&gt;t_group) ||</a>
<a name="ln4103">         0 &gt;= (num_t_groups = t_group_info-&gt;num_t_groups) || t_group_info-&gt;nNumIsotopicEndpoints )</a>
<a name="ln4104">        return 0;</a>
<a name="ln4105">    for ( i = 0; i &lt; num_t_groups; i ++ ) {</a>
<a name="ln4106">        t_group[i].iWeight = 0;</a>
<a name="ln4107">        j = T_NUM_ISOTOPIC - 1;</a>
<a name="ln4108">        Mult = 1;</a>
<a name="ln4109">        do {</a>
<a name="ln4110">            t_group[i].iWeight += Mult * (T_GROUP_ISOWT)t_group[i].num[T_NUM_NO_ISOTOPIC+j];</a>
<a name="ln4111">        } while ( --j &gt;= 0 &amp;&amp; (Mult *= T_GROUP_ISOWT_MULT) );</a>
<a name="ln4112">        num_iso_t_groups += (t_group[i].iWeight != 0);</a>
<a name="ln4113">    }</a>
<a name="ln4114">    return num_iso_t_groups;</a>
<a name="ln4115">}</a>
<a name="ln4116"> </a>
<a name="ln4117">/******************************************************************************</a>
<a name="ln4118"> *</a>
<a name="ln4119"> *  Fill t_group_info with information necessary to fill out tautomer part</a>
<a name="ln4120"> *  of the linear connection table record.</a>
<a name="ln4121"> *  Note: on input, t_group_info should contain information created by MarkTautomerGroups()</a>
<a name="ln4122"> *        No previous t_group_info adjustment due to throwing out disconnected parts of</a>
<a name="ln4123"> *        the chemical structure is needed.</a>
<a name="ln4124"> *</a>
<a name="ln4125"> *  Note2: throws out t_groups containing negative charges only (IGNORE_TGROUP_WITHOUT_H==1)</a>
<a name="ln4126"> *         (leave their tautomeric bonds unchanged)</a>
<a name="ln4127"> *  Note3: removes negative charges from other tautomeric groups</a>
<a name="ln4128"> *         and adjust counts of mobile atoms if permitted         (REMOVE_TGROUP_CHARGE==1)</a>
<a name="ln4129"> */</a>
<a name="ln4130">int CountTautomerGroups( sp_ATOM *at, int num_atoms, T_GROUP_INFO *t_group_info )</a>
<a name="ln4131">{</a>
<a name="ln4132">    int i, j, ret = 0, nNumEndpoints, max_t_group, num_groups_noH;</a>
<a name="ln4133"> </a>
<a name="ln4134">    AT_NUMB    nGroupNumber, nNewGroupNumber, *nCurrEndpointAtNoPos = NULL;</a>
<a name="ln4135">    </a>
<a name="ln4136">    T_GROUP   *t_group;</a>
<a name="ln4137">    int        num_t;</a>
<a name="ln4138">    /* int bIgnoreIsotopic, max_num_t; */</a>
<a name="ln4139">    AT_NUMB   *nTautomerGroupNumber        = NULL;</a>
<a name="ln4140">    AT_NUMB   *nEndpointAtomNumber         = NULL;</a>
<a name="ln4141">    AT_NUMB   *tGroupNumber  = NULL;</a>
<a name="ln4142">    </a>
<a name="ln4143">    if ( !t_group_info || !t_group_info-&gt;t_group || 0 &gt;= t_group_info-&gt;max_num_t_groups ) {</a>
<a name="ln4144">        return 0; /* empty t-groups */</a>
<a name="ln4145">    }</a>
<a name="ln4146">    num_t           =  t_group_info-&gt;num_t_groups;</a>
<a name="ln4147">    t_group         =  t_group_info-&gt;t_group;</a>
<a name="ln4148">    /*</a>
<a name="ln4149">      max_num_t       =  t_group_info-&gt;max_num_t_groups;</a>
<a name="ln4150">      bIgnoreIsotopic =  t_group_info-&gt;bIgnoreIsotopic;</a>
<a name="ln4151">     */</a>
<a name="ln4152">    num_groups_noH  = 0;</a>
<a name="ln4153"> </a>
<a name="ln4154">    /* the following 2 arrays are to be rebuilt here */</a>
<a name="ln4155">    if ( t_group_info-&gt;nEndpointAtomNumber ) {</a>
<a name="ln4156">        inchi_free ( t_group_info-&gt;nEndpointAtomNumber );</a>
<a name="ln4157">        t_group_info-&gt;nEndpointAtomNumber = NULL;</a>
<a name="ln4158">    }</a>
<a name="ln4159">    if ( t_group_info-&gt;tGroupNumber ) {</a>
<a name="ln4160">        inchi_free ( t_group_info-&gt;tGroupNumber );</a>
<a name="ln4161">        t_group_info-&gt;tGroupNumber = NULL;</a>
<a name="ln4162">    }</a>
<a name="ln4163">    /*  find max_t_group */</a>
<a name="ln4164">    for ( i = 0, max_t_group = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln4165">        if ( max_t_group &lt; t_group[i].nGroupNumber )</a>
<a name="ln4166">            max_t_group = t_group[i].nGroupNumber;</a>
<a name="ln4167">    }</a>
<a name="ln4168">    /*  allocate memory for temp storage of numbers of endpoints  */</a>
<a name="ln4169">    if ( max_t_group &amp;&amp;</a>
<a name="ln4170">         !(nTautomerGroupNumber = (AT_NUMB*) inchi_calloc( max_t_group+1, sizeof(nTautomerGroupNumber[0]) ) /*temp*/ ) ) {</a>
<a name="ln4171">        goto err_exit_function; /*  program error: out of RAM */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4172">    }</a>
<a name="ln4173">    </a>
<a name="ln4174">    /*  count endpoints for each tautomer group */</a>
<a name="ln4175">    for ( i = 0, nNumEndpoints = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4176">        if ( (j = at[i].endpoint) == 0 )</a>
<a name="ln4177">            continue;</a>
<a name="ln4178">        if ( j &gt; max_t_group ) /*  debug only */</a>
<a name="ln4179">            goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4180">        nTautomerGroupNumber[j] ++;</a>
<a name="ln4181">        nNumEndpoints ++;</a>
<a name="ln4182">    }</a>
<a name="ln4183">    </a>
<a name="ln4184">    if ( !nNumEndpoints ) {</a>
<a name="ln4185">        goto exit_function; /*  not a tautomer */</a>
<a name="ln4186">    }</a>
<a name="ln4187"> </a>
<a name="ln4188">    /*  allocate temporary array */</a>
<a name="ln4189">    if ( !(nEndpointAtomNumber  = (AT_NUMB*) inchi_calloc( nNumEndpoints, sizeof(nEndpointAtomNumber[0]) ) ) ||</a>
<a name="ln4190">         !(nCurrEndpointAtNoPos = (AT_NUMB*) inchi_calloc( num_t, sizeof(nCurrEndpointAtNoPos[0]) ) /*temp*/ ) ) {</a>
<a name="ln4191">        goto err_exit_function; /*   program error: out of RAM */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4192">    }</a>
<a name="ln4193">    /*</a>
<a name="ln4194">     * Remove missing endpoints from t_group. Since only one</a>
<a name="ln4195">     * disconnected part is processed, some endpoints groups may have disappeared.</a>
<a name="ln4196">     * Mark t_groups containing charges only for subsequent removal</a>
<a name="ln4197">     */</a>
<a name="ln4198">    for ( i = 0, nNewGroupNumber = 0; i &lt; num_t; /*i ++*/ ) {</a>
<a name="ln4199">        int bNoH = 0, nNumH;</a>
<a name="ln4200">        nGroupNumber  = t_group[i].nGroupNumber;</a>
<a name="ln4201">        for ( j = 1, nNumH = t_group[i].num[0]; j &lt; T_NUM_NO_ISOTOPIC; j ++ ) {</a>
<a name="ln4202">            nNumH -= (int)t_group[i].num[j];</a>
<a name="ln4203">        }</a>
<a name="ln4204">        if ( t_group[i].nNumEndpoints != nTautomerGroupNumber[(int)nGroupNumber]</a>
<a name="ln4205">#if ( IGNORE_TGROUP_WITHOUT_H == 1 )</a>
<a name="ln4206">             || (bNoH = (t_group[i].num[0]==t_group[i].num[1]))  /* only for (H,-) t-groups; (+) t-groups are not removed */</a>
<a name="ln4207">#endif</a>
<a name="ln4208">           ) {</a>
<a name="ln4209">            if ( !nTautomerGroupNumber[(int)nGroupNumber] || bNoH ) {</a>
<a name="ln4210">                /*  the group belongs to another disconnected part of the structure or has only charges */</a>
<a name="ln4211">                /*  Remove the group */</a>
<a name="ln4212">                num_t --;</a>
<a name="ln4213">                if ( i &lt; num_t )</a>
<a name="ln4214">                    memmove( t_group+i, t_group+i+1, (num_t-i)*sizeof(t_group[0]) );</a>
<a name="ln4215">                if ( bNoH ) {</a>
<a name="ln4216">                    /*  group contains no mobile hydrogen atoms, only charges. Prepare to remove it. */</a>
<a name="ln4217">                    nTautomerGroupNumber[(int)nGroupNumber] = 0;</a>
<a name="ln4218">                    num_groups_noH ++;</a>
<a name="ln4219">                }</a>
<a name="ln4220">                /*i --;*/</a>
<a name="ln4221">            } else {</a>
<a name="ln4222">                /*  different number of endpoints */</a>
<a name="ln4223">                goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4224">            }</a>
<a name="ln4225">        } else {</a>
<a name="ln4226">            /*  renumber t_group and prepare to renumber at[i].endpoint */</a>
<a name="ln4227">            nTautomerGroupNumber[(int)nGroupNumber] =</a>
<a name="ln4228">            t_group[i].nGroupNumber                 = ++nNewGroupNumber; /*  = i+1 */</a>
<a name="ln4229">            /*  get first group atom orig. number position in the nEndpointAtomNumber[] */</a>
<a name="ln4230">            /*  and in the tautomer endpoint canon numbers part of the connection table */</a>
<a name="ln4231">            t_group[i].nFirstEndpointAtNoPos = nCurrEndpointAtNoPos[i]  =</a>
<a name="ln4232">                i? (t_group[i-1].nFirstEndpointAtNoPos+t_group[i-1].nNumEndpoints) : 0;</a>
<a name="ln4233">            t_group[i].num[0] = nNumH;</a>
<a name="ln4234">#if ( REMOVE_TGROUP_CHARGE == 1 )</a>
<a name="ln4235">            t_group[i].num[1]  = 0;  /* remove only (-) charges */</a>
<a name="ln4236">#endif</a>
<a name="ln4237">            /* -- wrong condition. Disabled.</a>
<a name="ln4238">            if ( t_group[i].nGroupNumber != i + 1 ) { // for debug only</a>
<a name="ln4239">                goto err_exit_function; // program error</a>
<a name="ln4240">            }</a>
<a name="ln4241">            */</a>
<a name="ln4242">            i ++;</a>
<a name="ln4243">        }</a>
<a name="ln4244">    }</a>
<a name="ln4245">    if ( num_t != nNewGroupNumber ) { /*  for debug only */</a>
<a name="ln4246">        goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4247">    }</a>
<a name="ln4248">    </a>
<a name="ln4249">    /*  check if any tautomer group was left */</a>
<a name="ln4250">    if ( !nNewGroupNumber ) {</a>
<a name="ln4251">        if ( !num_groups_noH )</a>
<a name="ln4252">            goto err_exit_function; /*  program error: not a tautomer */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4253">        else</a>
<a name="ln4254">            goto exit_function;</a>
<a name="ln4255">    }</a>
<a name="ln4256">    /*</a>
<a name="ln4257">     * an array for tautomer group sorting later, at the time of storing Connection Table</a>
<a name="ln4258">     * Later the sorting consists out of 2 steps:</a>
<a name="ln4259">     * 1) Sort t_group[i].nNumEndpoints endpoint atom ranks within each endpoint group</a>
<a name="ln4260">     *    starting from t_group[i].nFirstEndpointAtNoPos; i = 0..t_group_info-&gt;num_t_groups-1</a>
<a name="ln4261">     * 2) Sort the groups indexes t_group_info-&gt;tGroupNumber[]</a>
<a name="ln4262">     */</a>
<a name="ln4263">    if ( !(tGroupNumber=</a>
<a name="ln4264">           (AT_NUMB*)inchi_calloc(nNewGroupNumber*TGSO_TOTAL_LEN, sizeof(tGroupNumber[0])))) {</a>
<a name="ln4265">        goto err_exit_function; /*  out of RAM */</a>
<a name="ln4266">    }</a>
<a name="ln4267">    for ( i = 0; i &lt; nNewGroupNumber; i ++ ) {</a>
<a name="ln4268">        tGroupNumber[i] = (AT_NUMB)i; /*  initialization: original t_group number = (at[i]-&gt;endpoint-1) */</a>
<a name="ln4269">    }</a>
<a name="ln4270">    /*</a>
<a name="ln4271">     * renumber endpoint atoms and save their orig. atom </a>
<a name="ln4272">     * numbers for filling out the tautomer part of the LinearCT.</a>
<a name="ln4273">     * nCurrEndpointAtNoPos[j] is an index of the atom number in the nEndpointAtomNumber[]</a>
<a name="ln4274">     */</a>
<a name="ln4275">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4276">        if ( (j = (int)at[i].endpoint) ) {</a>
<a name="ln4277">            j = (int)(at[i].endpoint = nTautomerGroupNumber[j])-1; /*  new t_group number */</a>
<a name="ln4278">            if ( j &gt;= 0 ) { /*  j=-1 in case of no mobile hydrogen atoms (charges only), group being removed */</a>
<a name="ln4279">                if ( nCurrEndpointAtNoPos[j] &gt;=   /*  debug only */</a>
<a name="ln4280">                     t_group[j].nFirstEndpointAtNoPos+t_group[j].nNumEndpoints ) {</a>
<a name="ln4281">                    goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4282">                }</a>
<a name="ln4283">                nEndpointAtomNumber[(int)nCurrEndpointAtNoPos[j] ++] = (AT_NUMB)i;</a>
<a name="ln4284">            } else {</a>
<a name="ln4285">                nNumEndpoints --; /*  endpoint has been removed */</a>
<a name="ln4286">            }</a>
<a name="ln4287">        }</a>
<a name="ln4288">    }</a>
<a name="ln4289">    t_group_info-&gt;num_t_groups               = nNewGroupNumber;</a>
<a name="ln4290">    t_group_info-&gt;nNumEndpoints              = nNumEndpoints;</a>
<a name="ln4291">    t_group_info-&gt;nEndpointAtomNumber        = nEndpointAtomNumber;</a>
<a name="ln4292">    t_group_info-&gt;tGroupNumber               = tGroupNumber; /* only the 1st segment filled */</a>
<a name="ln4293">    inchi_free ( nTautomerGroupNumber );</a>
<a name="ln4294">    inchi_free ( nCurrEndpointAtNoPos );</a>
<a name="ln4295">    return nNumEndpoints + T_GROUP_HDR_LEN * nNewGroupNumber + 1; /*  nLenLinearCTTautomer */</a>
<a name="ln4296"> </a>
<a name="ln4297">err_exit_function:</a>
<a name="ln4298">    ret = CT_TAUCOUNT_ERR;</a>
<a name="ln4299">exit_function:</a>
<a name="ln4300">    /*  release allocated memory; set &quot;no tautomeric group&quot; */</a>
<a name="ln4301">    if ( nEndpointAtomNumber )</a>
<a name="ln4302">        inchi_free ( nEndpointAtomNumber );</a>
<a name="ln4303">    if ( nTautomerGroupNumber )</a>
<a name="ln4304">        inchi_free ( nTautomerGroupNumber );</a>
<a name="ln4305">    if ( tGroupNumber )</a>
<a name="ln4306">        inchi_free ( tGroupNumber );</a>
<a name="ln4307">    if ( nCurrEndpointAtNoPos )</a>
<a name="ln4308">        inchi_free ( nCurrEndpointAtNoPos );</a>
<a name="ln4309">    t_group_info-&gt;nNumEndpoints = 0;</a>
<a name="ln4310">    t_group_info-&gt;num_t_groups  = 0;</a>
<a name="ln4311">    if ( !ret &amp;&amp; ((t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_NORM_CONSIDER_TAUT) ||</a>
<a name="ln4312">                   (t_group_info-&gt;nNumIsotopicEndpoints&gt;1 &amp;&amp; (t_group_info-&gt;bTautFlagsDone &amp; (TG_FLAG_FOUND_ISOTOPIC_H_DONE | TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE)))) ) {</a>
<a name="ln4313">        ret = 1; /* only protons have been (re)moved or neitralization happened */</a>
<a name="ln4314">    }</a>
<a name="ln4315">    return ret;</a>
<a name="ln4316">}</a>
<a name="ln4317">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln4318">#if ( INCLUDE_NORMALIZATION_ENTRY_POINT == 1 )</a>
<a name="ln4319">/*****************************************************************************/</a>
<a name="ln4320">int CountTautomerGroupsInpAt( inp_ATOM *at, int num_atoms, T_GROUP_INFO *t_group_info )</a>
<a name="ln4321">{</a>
<a name="ln4322">    int i, j, ret = 0, nNumEndpoints, max_t_group, num_groups_noH;</a>
<a name="ln4323"> </a>
<a name="ln4324">    AT_NUMB    nGroupNumber, nNewGroupNumber, *nCurrEndpointAtNoPos = NULL;</a>
<a name="ln4325">    </a>
<a name="ln4326">    T_GROUP   *t_group;</a>
<a name="ln4327">    int        num_t;</a>
<a name="ln4328">    /* int bIgnoreIsotopic, max_num_t; */</a>
<a name="ln4329">    AT_NUMB   *nTautomerGroupNumber        = NULL;</a>
<a name="ln4330">    AT_NUMB   *nEndpointAtomNumber         = NULL;</a>
<a name="ln4331">    AT_NUMB   *tGroupNumber  = NULL;</a>
<a name="ln4332">    </a>
<a name="ln4333">    if ( !t_group_info || !t_group_info-&gt;t_group || 0 &gt;= t_group_info-&gt;max_num_t_groups ) {</a>
<a name="ln4334">        return 0; /* empty t-groups */</a>
<a name="ln4335">    }</a>
<a name="ln4336">    num_t           =  t_group_info-&gt;num_t_groups;</a>
<a name="ln4337">    t_group         =  t_group_info-&gt;t_group;</a>
<a name="ln4338">    /*</a>
<a name="ln4339">      max_num_t       =  t_group_info-&gt;max_num_t_groups;</a>
<a name="ln4340">      bIgnoreIsotopic =  t_group_info-&gt;bIgnoreIsotopic;</a>
<a name="ln4341">     */</a>
<a name="ln4342">    num_groups_noH  = 0;</a>
<a name="ln4343"> </a>
<a name="ln4344">    /* the following 2 arrays are to be rebuilt here */</a>
<a name="ln4345">    if ( t_group_info-&gt;nEndpointAtomNumber ) {</a>
<a name="ln4346">        inchi_free ( t_group_info-&gt;nEndpointAtomNumber );</a>
<a name="ln4347">        t_group_info-&gt;nEndpointAtomNumber = NULL;</a>
<a name="ln4348">    }</a>
<a name="ln4349">    if ( t_group_info-&gt;tGroupNumber ) {</a>
<a name="ln4350">        inchi_free ( t_group_info-&gt;tGroupNumber );</a>
<a name="ln4351">        t_group_info-&gt;tGroupNumber = NULL;</a>
<a name="ln4352">    }</a>
<a name="ln4353">    /*  find max_t_group */</a>
<a name="ln4354">    for ( i = 0, max_t_group = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln4355">        if ( max_t_group &lt; t_group[i].nGroupNumber )</a>
<a name="ln4356">            max_t_group = t_group[i].nGroupNumber;</a>
<a name="ln4357">    }</a>
<a name="ln4358">    /*  allocate memory for temp storage of numbers of endpoints  */</a>
<a name="ln4359">    if ( max_t_group &amp;&amp;</a>
<a name="ln4360">         !(nTautomerGroupNumber = (AT_NUMB*) inchi_calloc( max_t_group+1, sizeof(nTautomerGroupNumber[0]) ) /*temp*/ ) ) {</a>
<a name="ln4361">        goto err_exit_function; /*  program error: out of RAM */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4362">    }</a>
<a name="ln4363">    </a>
<a name="ln4364">    /*  count endpoints for each tautomer group */</a>
<a name="ln4365">    for ( i = 0, nNumEndpoints = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4366">        if ( (j = at[i].endpoint) == 0 )</a>
<a name="ln4367">            continue;</a>
<a name="ln4368">        if ( j &gt; max_t_group ) /*  debug only */</a>
<a name="ln4369">            goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4370">        nTautomerGroupNumber[j] ++;</a>
<a name="ln4371">        nNumEndpoints ++;</a>
<a name="ln4372">    }</a>
<a name="ln4373">    </a>
<a name="ln4374">    if ( !nNumEndpoints ) {</a>
<a name="ln4375">        goto exit_function; /*  not a tautomer */</a>
<a name="ln4376">    }</a>
<a name="ln4377"> </a>
<a name="ln4378">    /*  allocate temporary array */</a>
<a name="ln4379">    if ( !(nEndpointAtomNumber  = (AT_NUMB*) inchi_calloc( nNumEndpoints, sizeof(nEndpointAtomNumber[0]) ) ) ||</a>
<a name="ln4380">         !(nCurrEndpointAtNoPos = (AT_NUMB*) inchi_calloc( num_t, sizeof(nCurrEndpointAtNoPos[0]) ) /*temp*/ ) ) {</a>
<a name="ln4381">        goto err_exit_function; /*   program error: out of RAM */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4382">    }</a>
<a name="ln4383">    /*</a>
<a name="ln4384">     * Remove missing endpoints from t_group. Since only one</a>
<a name="ln4385">     * disconnected part is processed, some endpoints groups may have disappeared.</a>
<a name="ln4386">     * Mark t_groups containing charges only for subsequent removal</a>
<a name="ln4387">     */</a>
<a name="ln4388">    for ( i = 0, nNewGroupNumber = 0; i &lt; num_t; /*i ++*/ ) {</a>
<a name="ln4389">        int bNoH = 0, nNumH;</a>
<a name="ln4390">        nGroupNumber  = t_group[i].nGroupNumber;</a>
<a name="ln4391">        for ( j = 1, nNumH = t_group[i].num[0]; j &lt; T_NUM_NO_ISOTOPIC; j ++ ) {</a>
<a name="ln4392">            nNumH -= (int)t_group[i].num[j];</a>
<a name="ln4393">        }</a>
<a name="ln4394">        if ( t_group[i].nNumEndpoints != nTautomerGroupNumber[(int)nGroupNumber]</a>
<a name="ln4395">#if ( IGNORE_TGROUP_WITHOUT_H == 1 )</a>
<a name="ln4396">             || (bNoH = (t_group[i].num[0]==t_group[i].num[1]))  /* only for (H,-) t-groups; (+) t-groups are not removed */</a>
<a name="ln4397">#endif</a>
<a name="ln4398">           ) {</a>
<a name="ln4399">            if ( !nTautomerGroupNumber[(int)nGroupNumber] || bNoH ) {</a>
<a name="ln4400">                /*  the group belongs to another disconnected part of the structure or has only charges */</a>
<a name="ln4401">                /*  Remove the group */</a>
<a name="ln4402">                num_t --;</a>
<a name="ln4403">                if ( i &lt; num_t )</a>
<a name="ln4404">                    memmove( t_group+i, t_group+i+1, (num_t-i)*sizeof(t_group[0]) );</a>
<a name="ln4405">                if ( bNoH ) {</a>
<a name="ln4406">                    /*  group contains no mobile hydrogen atoms, only charges. Prepare to remove it. */</a>
<a name="ln4407">                    nTautomerGroupNumber[(int)nGroupNumber] = 0;</a>
<a name="ln4408">                    num_groups_noH ++;</a>
<a name="ln4409">                }</a>
<a name="ln4410">                /*i --;*/</a>
<a name="ln4411">            } else {</a>
<a name="ln4412">                /*  different number of endpoints */</a>
<a name="ln4413">                goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4414">            }</a>
<a name="ln4415">        } else {</a>
<a name="ln4416">            /*  renumber t_group and prepare to renumber at[i].endpoint */</a>
<a name="ln4417">            nTautomerGroupNumber[(int)nGroupNumber] =</a>
<a name="ln4418">            t_group[i].nGroupNumber                 = ++nNewGroupNumber; /*  = i+1 */</a>
<a name="ln4419">            /*  get first group atom orig. number position in the nEndpointAtomNumber[] */</a>
<a name="ln4420">            /*  and in the tautomer endpoint canon numbers part of the connection table */</a>
<a name="ln4421">            t_group[i].nFirstEndpointAtNoPos = nCurrEndpointAtNoPos[i]  =</a>
<a name="ln4422">                i? (t_group[i-1].nFirstEndpointAtNoPos+t_group[i-1].nNumEndpoints) : 0;</a>
<a name="ln4423">            t_group[i].num[0] = nNumH;</a>
<a name="ln4424">#if ( REMOVE_TGROUP_CHARGE == 1 )</a>
<a name="ln4425">            t_group[i].num[1]  = 0;  /* remove only (-) charges */</a>
<a name="ln4426">#endif</a>
<a name="ln4427">            /* -- wrong condition. Disabled.</a>
<a name="ln4428">            if ( t_group[i].nGroupNumber != i + 1 ) { // for debug only</a>
<a name="ln4429">                goto err_exit_function; // program error</a>
<a name="ln4430">            }</a>
<a name="ln4431">            */</a>
<a name="ln4432">            i ++;</a>
<a name="ln4433">        }</a>
<a name="ln4434">    }</a>
<a name="ln4435">    if ( num_t != nNewGroupNumber ) { /*  for debug only */</a>
<a name="ln4436">        goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4437">    }</a>
<a name="ln4438">    </a>
<a name="ln4439">    /*  check if any tautomer group was left */</a>
<a name="ln4440">    if ( !nNewGroupNumber ) {</a>
<a name="ln4441">        if ( !num_groups_noH )</a>
<a name="ln4442">            goto err_exit_function; /*  program error: not a tautomer */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4443">        else</a>
<a name="ln4444">            goto exit_function;</a>
<a name="ln4445">    }</a>
<a name="ln4446">    /*</a>
<a name="ln4447">     * an array for tautomer group sorting later, at the time of storing Connection Table</a>
<a name="ln4448">     * Later the sorting consists out of 2 steps:</a>
<a name="ln4449">     * 1) Sort t_group[i].nNumEndpoints endpoint atom ranks within each endpoint group</a>
<a name="ln4450">     *    starting from t_group[i].nFirstEndpointAtNoPos; i = 0..t_group_info-&gt;num_t_groups-1</a>
<a name="ln4451">     * 2) Sort the groups indexes t_group_info-&gt;tGroupNumber[]</a>
<a name="ln4452">     */</a>
<a name="ln4453">    if ( !(tGroupNumber=</a>
<a name="ln4454">           (AT_NUMB*)inchi_calloc(nNewGroupNumber*TGSO_TOTAL_LEN, sizeof(tGroupNumber[0])))) {</a>
<a name="ln4455">        goto err_exit_function; /*  out of RAM */</a>
<a name="ln4456">    }</a>
<a name="ln4457">    for ( i = 0; i &lt; nNewGroupNumber; i ++ ) {</a>
<a name="ln4458">        tGroupNumber[i] = (AT_NUMB)i; /*  initialization: original t_group number = (at[i]-&gt;endpoint-1) */</a>
<a name="ln4459">    }</a>
<a name="ln4460">    /*</a>
<a name="ln4461">     * renumber endpoint atoms and save their orig. atom </a>
<a name="ln4462">     * numbers for filling out the tautomer part of the LinearCT.</a>
<a name="ln4463">     * nCurrEndpointAtNoPos[j] is an index of the atom number in the nEndpointAtomNumber[]</a>
<a name="ln4464">     */</a>
<a name="ln4465">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4466">        if ( j = (int)at[i].endpoint ) {</a>
<a name="ln4467">            j = (int)(at[i].endpoint = nTautomerGroupNumber[j])-1; /*  new t_group number */</a>
<a name="ln4468">            if ( j &gt;= 0 ) { /*  j=-1 in case of no mobile hydrogen atoms (charges only), group being removed */</a>
<a name="ln4469">                if ( nCurrEndpointAtNoPos[j] &gt;=   /*  debug only */</a>
<a name="ln4470">                     t_group[j].nFirstEndpointAtNoPos+t_group[j].nNumEndpoints ) {</a>
<a name="ln4471">                    goto err_exit_function; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4472">                }</a>
<a name="ln4473">                nEndpointAtomNumber[(int)nCurrEndpointAtNoPos[j] ++] = (AT_NUMB)i;</a>
<a name="ln4474">            } else {</a>
<a name="ln4475">                nNumEndpoints --; /*  endpoint has been removed */</a>
<a name="ln4476">            }</a>
<a name="ln4477">        }</a>
<a name="ln4478">    }</a>
<a name="ln4479">    t_group_info-&gt;num_t_groups               = nNewGroupNumber;</a>
<a name="ln4480">    t_group_info-&gt;nNumEndpoints              = nNumEndpoints;</a>
<a name="ln4481">    t_group_info-&gt;nEndpointAtomNumber        = nEndpointAtomNumber;</a>
<a name="ln4482">    t_group_info-&gt;tGroupNumber               = tGroupNumber; /* only the 1st segment filled */</a>
<a name="ln4483">    inchi_free ( nTautomerGroupNumber );</a>
<a name="ln4484">    inchi_free ( nCurrEndpointAtNoPos );</a>
<a name="ln4485">    return nNumEndpoints + T_GROUP_HDR_LEN * nNewGroupNumber + 1; /*  nLenLinearCTTautomer */</a>
<a name="ln4486"> </a>
<a name="ln4487">err_exit_function:</a>
<a name="ln4488">    ret = CT_TAUCOUNT_ERR;</a>
<a name="ln4489">exit_function:</a>
<a name="ln4490">    /*  release allocated memory; set &quot;no tautomeric group&quot; */</a>
<a name="ln4491">    if ( nEndpointAtomNumber )</a>
<a name="ln4492">        inchi_free ( nEndpointAtomNumber );</a>
<a name="ln4493">    if ( nTautomerGroupNumber )</a>
<a name="ln4494">        inchi_free ( nTautomerGroupNumber );</a>
<a name="ln4495">    if ( tGroupNumber )</a>
<a name="ln4496">        inchi_free ( tGroupNumber );</a>
<a name="ln4497">    if ( nCurrEndpointAtNoPos )</a>
<a name="ln4498">        inchi_free ( nCurrEndpointAtNoPos );</a>
<a name="ln4499">    t_group_info-&gt;nNumEndpoints = 0;</a>
<a name="ln4500">    t_group_info-&gt;num_t_groups  = 0;</a>
<a name="ln4501">    if ( !ret &amp;&amp; ((t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_NORM_CONSIDER_TAUT) ||</a>
<a name="ln4502">                   t_group_info-&gt;nNumIsotopicEndpoints&gt;1 &amp;&amp; (t_group_info-&gt;bTautFlagsDone &amp; (TG_FLAG_FOUND_ISOTOPIC_H_DONE | TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE))) ) {</a>
<a name="ln4503">        ret = 1; /* only protons have been (re)moved or neitralization happened */</a>
<a name="ln4504">    }</a>
<a name="ln4505">    return ret;</a>
<a name="ln4506">}</a>
<a name="ln4507">#endif</a>
<a name="ln4508">#endif</a>
<a name="ln4509"> </a>
<a name="ln4510"> </a>
<a name="ln4511"> </a>
<a name="ln4512">/*****************************************************************************</a>
<a name="ln4513"> * tautomers: Compare for sorting</a>
<a name="ln4514"> *****************************************************************************/</a>
<a name="ln4515">/*  Compare for sorting Ranks only */</a>
<a name="ln4516">/*  Globals: pn_tRankForSort */</a>
<a name="ln4517">int CompRankTautomer(const void* a1, const void* a2 )</a>
<a name="ln4518">{</a>
<a name="ln4519">    int ret = (int)pn_tRankForSort[(int)(*(const AT_RANK*)a1)] -</a>
<a name="ln4520">              (int)pn_tRankForSort[(int)(*(const AT_RANK*)a2)];</a>
<a name="ln4521">    return ret;</a>
<a name="ln4522">}</a>
<a name="ln4523"> </a>
<a name="ln4524"> </a>
<a name="ln4525"> </a>
<a name="ln4526">/*****************************************************************************/</a>
<a name="ln4527">int SortTautomerGroupsAndEndpoints( T_GROUP_INFO *t_group_info, int num_atoms, int num_at_tg, AT_RANK *nRank )</a>
<a name="ln4528">{</a>
<a name="ln4529">    int i, nFirstEndpointAtNoPos, nNumEndpoints;</a>
<a name="ln4530">    AT_NUMB  *nEndpointAtomNumber;</a>
<a name="ln4531">    int       num_t_groups = num_at_tg - num_atoms;</a>
<a name="ln4532">    T_GROUP   *t_group = NULL;</a>
<a name="ln4533">    /*  check if sorting is required */</a>
<a name="ln4534">     </a>
<a name="ln4535">    if ( num_t_groups &lt;= 0 || t_group_info-&gt;nNumEndpoints &lt; 2 ) {</a>
<a name="ln4536">         return 0; /*  no tautomer data */</a>
<a name="ln4537">    }</a>
<a name="ln4538">    t_group = t_group_info-&gt;t_group;</a>
<a name="ln4539">    /*  sort endpoints within the groups */</a>
<a name="ln4540">    for ( i = 0; i &lt; num_t_groups; i ++ ) {</a>
<a name="ln4541">        if ( t_group[i].nNumEndpoints &lt; 2 )</a>
<a name="ln4542">            continue;  /*  program error; should not happen */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4543">        /*  set globals for sorting */</a>
<a name="ln4544">        nFirstEndpointAtNoPos = t_group[i].nFirstEndpointAtNoPos;</a>
<a name="ln4545">        nNumEndpoints         = t_group[i].nNumEndpoints;</a>
<a name="ln4546">        if ( nNumEndpoints + nFirstEndpointAtNoPos &gt; t_group_info-&gt;nNumEndpoints ) { /*  for debug only */</a>
<a name="ln4547">            return CT_TAUCOUNT_ERR; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln4548">        }</a>
<a name="ln4549">        nEndpointAtomNumber = t_group_info-&gt;nEndpointAtomNumber+(int)nFirstEndpointAtNoPos;</a>
<a name="ln4550">        pn_tRankForSort = nRank;</a>
<a name="ln4551">        insertions_sort( nEndpointAtomNumber, nNumEndpoints, sizeof(nEndpointAtomNumber[0]), CompRankTautomer);</a>
<a name="ln4552">    }</a>
<a name="ln4553">    /*  sort the tautomeric groups according to their ranks only</a>
<a name="ln4554">        (that is, ignoring the isotopic composition of the mobile groups and ranks of the endpoints) */</a>
<a name="ln4555">    if ( t_group_info-&gt;num_t_groups &gt; 1 ) {</a>
<a name="ln4556">        /*  set globals for sorting */</a>
<a name="ln4557">        /*  a hack: the ranks of all tautomeric groups are */</a>
<a name="ln4558">        /*  located at nRank[num_atoms..num_at_tg-1] */</a>
<a name="ln4559">        pn_tRankForSort    = nRank+num_atoms;</a>
<a name="ln4560">        /*  sort */</a>
<a name="ln4561">        /*  ordering numbers to sort : t_group_info-&gt;tGroupNumber; */</a>
<a name="ln4562">        insertions_sort( t_group_info-&gt;tGroupNumber, num_t_groups,</a>
<a name="ln4563">                         sizeof(t_group_info-&gt;tGroupNumber[0]), CompRankTautomer);</a>
<a name="ln4564">    }</a>
<a name="ln4565">    return t_group_info-&gt;num_t_groups;</a>
<a name="ln4566">}</a>

</code></pre>
<div class="balloon" rel="471"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nEndpointValence == 4' is always true.</p></div>
<div class="balloon" rel="492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nEndpointValence == 4' is always true.</p></div>
<div class="balloon" rel="831"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: 1.</p></div>
<div class="balloon" rel="2295"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!bAlreadyTested' and 'bAlreadyTested'. </p></div>
<div class="balloon" rel="2337"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!bAlreadyTested' and 'bAlreadyTested'. </p></div>
<div class="balloon" rel="2420"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nNumMarkedCandidates' is always true.</p></div>
<div class="balloon" rel="2555"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nNumCandidates == 0' is always true.</p></div>
<div class="balloon" rel="3144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer.</p></div>
<div class="balloon" rel="3588"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v600/" target="_blank">V600</a> Consider inspecting the condition. The 'DfsPath' pointer is always not equal to NULL.</p></div>
<div class="balloon" rel="4180"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'nTautomerGroupNumber'.</p></div>
<div class="balloon" rel="4231"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v699/" target="_blank">V699</a> Consider inspecting the 'foo = bar = baz ? .... : ....' expression. It is possible that 'foo = bar == baz ? .... : ....' should be used here instead.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

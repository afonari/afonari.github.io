
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichican2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44">#include &lt;limits.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">/* #define CHECK_WIN32_VC_HEAP */</a>
<a name="ln47">#include &quot;mode.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;ichi.h&quot;</a>
<a name="ln50">#include &quot;util.h&quot;</a>
<a name="ln51">#include &quot;extr_ct.h&quot;</a>
<a name="ln52">#include &quot;ichitaut.h&quot;</a>
<a name="ln53">#include &quot;inpdef.h&quot;</a>
<a name="ln54">#include &quot;ichinorm.h&quot;</a>
<a name="ln55">#include &quot;ichicant.h&quot;</a>
<a name="ln56">#include &quot;ichicano.h&quot;</a>
<a name="ln57">#include &quot;ichicomn.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59">#include &quot;ichicomp.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">#define MAX_CELLS    1024</a>
<a name="ln62">#define MAX_NODES    1024</a>
<a name="ln63">#define MAX_SET_SIZE 2048 /*16384*/</a>
<a name="ln64">#define MAX_LAYERS   7</a>
<a name="ln65"> </a>
<a name="ln66">#define INFINITY       0x3FFF</a>
<a name="ln67">#define EMPTY_CT       0</a>
<a name="ln68">#define EMPTY_H_NUMBER (INFINITY-1)</a>
<a name="ln69">#define BASE_H_NUMBER  ((INFINITY-1)/2)</a>
<a name="ln70">#define EMPTY_ISO_SORT_KEY LONG_MAX</a>
<a name="ln71"> </a>
<a name="ln72">#define SEPARATE_CANON_CALLS 0</a>
<a name="ln73"> </a>
<a name="ln74">/* #define INCHI_CANON_USE_HASH */</a>
<a name="ln75">#define INCHI_CANON_MIN</a>
<a name="ln76"> </a>
<a name="ln77">/****************************************************************/</a>
<a name="ln78">#ifdef INCHI_CANON_USE_HASH</a>
<a name="ln79">typedef unsigned long  U_INT_32;</a>
<a name="ln80">typedef unsigned char  U_INT_08;</a>
<a name="ln81">typedef U_INT_32       CtHash;</a>
<a name="ln82">CtHash hash_mark_bit;</a>
<a name="ln83">#endif</a>
<a name="ln84"> </a>
<a name="ln85">/* -- moved to ichi_bns.h --</a>
<a name="ln86">typedef U_SHORT  bitWord;</a>
<a name="ln87">#define BIT_WORD_MASK  ((bitWord)~0)</a>
<a name="ln88">*/</a>
<a name="ln89"> </a>
<a name="ln90">static bitWord *bBit = NULL;</a>
<a name="ln91">static int    num_bit = 0;     </a>
<a name="ln92">/*bitWord      mark_bit; */    /* highest bit in AT_NUMB */</a>
<a name="ln93">/*bitWord      mask_bit; */    /* ~mark_bit */</a>
<a name="ln94"> </a>
<a name="ln95">AT_NUMB       rank_mark_bit;</a>
<a name="ln96">AT_NUMB       rank_mask_bit;</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">typedef AT_NUMB    Node;</a>
<a name="ln100">typedef NEIGH_LIST Graph;</a>
<a name="ln101">/*</a>
<a name="ln102">typedef struct tagGraph {</a>
<a name="ln103">    int dummy;</a>
<a name="ln104">} Graph;</a>
<a name="ln105">*/</a>
<a name="ln106">typedef struct tagUnorderedPartition {</a>
<a name="ln107">    /* AT_NUMB *next; */ /* links */</a>
<a name="ln108">    AT_NUMB *equ2; /* mcr */</a>
<a name="ln109">} UnorderedPartition;</a>
<a name="ln110"> </a>
<a name="ln111">typedef struct tagCell {</a>
<a name="ln112">    int       first; /* index of the first cell element in Partition::AtNumber[] */</a>
<a name="ln113">    int       next;   /* next after the last index */</a>
<a name="ln114">    int       prev;   /* position of the previously returned cell element */</a>
<a name="ln115">} Cell;</a>
<a name="ln116"> </a>
<a name="ln117">#ifdef NEVER /* moved to ichi_bns.h */</a>
<a name="ln118">typedef struct tagNodeSet {</a>
<a name="ln119">    bitWord **bitword;</a>
<a name="ln120">    int num_set; /* number of sets */</a>
<a name="ln121">    int len_set; /* number of bitWords in each set */</a>
<a name="ln122">} NodeSet;</a>
<a name="ln123">#endif</a>
<a name="ln124"> </a>
<a name="ln125">typedef struct tagTransposition {</a>
<a name="ln126">    AT_NUMB *nAtNumb;</a>
<a name="ln127">} Transposition;</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">typedef struct tagCTable {</a>
<a name="ln131">    AT_RANK  *Ctbl;     /* connection table */</a>
<a name="ln132">    /* Format-atoms:   atom_rank[k] neigh_rank[k][1]...neigh_rank[k][n]</a>
<a name="ln133">                       1) atom_rank[k1] &lt; atom_rank[k2]  &lt;=&gt; k1 &lt; k2</a>
<a name="ln134">              where    2) atom_rank[k] &gt; neigh_rank[k][i], i=1..n</a>
<a name="ln135">                       3) neigh_rank[k][i] &lt; neigh_rank[k][j]  &lt;=&gt;  i &lt; j</a>
<a name="ln136"> </a>
<a name="ln137">       Format-tgroup:  tgroup_rank[k] endpoint_rank[k][1]...endpoint_rank[k][n]</a>
<a name="ln138">              where    1) tgroup_rank[k1] &lt; tgroup_rank[k2] &lt;=&gt; k1 &lt; k2</a>
<a name="ln139">                       2) endpoint_rank[k][i] &lt; endpoint_rank[k][j] &lt;=&gt; i &lt; j</a>
<a name="ln140">                           </a>
<a name="ln141">              Note:    tgroup_rank[k] &gt; endpoint_rank[k][j] for all j by construction</a>
<a name="ln142">    */</a>
<a name="ln143"> </a>
<a name="ln144">    int       lenCt;        /* used length */</a>
<a name="ln145">    int       nLenCTAtOnly; /* to split Ctnl comparison in case of bDigraph != 0 */</a>
<a name="ln146">    int       maxlenCt;     /* allocated length of Ctbl */</a>
<a name="ln147">    int       maxPos;       /* allocated length of nextCtblPos */</a>
<a name="ln148">    int       maxVert;      /* max number of vertices to separate atoms from taut groups */</a>
<a name="ln149">    int       lenPos;       /* first unused element of nextCtblPos */</a>
<a name="ln150">    AT_RANK  *nextAtRank;   /* rank (k value) after the last node of the Ctbl portion*/</a>
<a name="ln151">    AT_NUMB  *nextCtblPos;  /* first unused element of Ctbl */</a>
<a name="ln152"> </a>
<a name="ln153">    /* hydrogen atoms fixed in tautomeric representation:</a>
<a name="ln154">       compare before diff sign inversion: (+) &lt;=&gt; Ct1-&gt;() &gt; Ct2-&gt;() */</a>
<a name="ln155">    NUM_H          *NumH;      </a>
<a name="ln156">    int             lenNumH;    /* used length */</a>
<a name="ln157">    int             maxlenNumH; /*  n + T_NUM_NO_ISOTOPIC*(n_tg-n) + 1 */</a>
<a name="ln158"> </a>
<a name="ln159">    /* hydrogen atoms fixed in non-tautomeric representation only:</a>
<a name="ln160">       compare before diff sign inversion: (+) &lt;=&gt; Ct1-&gt;() &gt; Ct2-&gt;() */</a>
<a name="ln161">    NUM_H           *NumHfixed;          </a>
<a name="ln162">    /*int              lenNumHfixed;    */   /* used length */   </a>
<a name="ln163">    /*int              maxlenNumHfixed; */   /* max length = n+1  */</a>
<a name="ln164"> </a>
<a name="ln165">    /* isotopic atoms (without tautomeric H) and isotopic tautomeric groups */</a>
<a name="ln166">    /* note: AT_ISO_SORT_KEY and T_GROUP_ISOWT are identical types: long    */</a>
<a name="ln167">    AT_ISO_SORT_KEY *iso_sort_key;        </a>
<a name="ln168">    int              len_iso_sort_key;    /* used length */</a>
<a name="ln169">    int              maxlen_iso_sort_key; /* max length = n_tg+1 */</a>
<a name="ln170"> </a>
<a name="ln171">    S_CHAR          *iso_exchg_atnos;</a>
<a name="ln172">    int              len_iso_exchg_atnos;</a>
<a name="ln173">    int              maxlen_iso_exchg_atnos;</a>
<a name="ln174"> </a>
<a name="ln175">    /* isotopic hydrogen atoms fixed in non-tautomeric representation only */</a>
<a name="ln176">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln177">    AT_ISO_SORT_KEY *iso_sort_key_Hfixed;     </a>
<a name="ln178">    int              len_iso_sort_key_Hfixed;    /* used length */    </a>
<a name="ln179">    int              maxlen_iso_sort_key_Hfixed; /* max length = n+1  */</a>
<a name="ln180">#endif</a>
<a name="ln181">    </a>
<a name="ln182">#ifdef INCHI_CANON_USE_HASH</a>
<a name="ln183">    CtHash   *hash;</a>
<a name="ln184">#endif</a>
<a name="ln185">} ConTable;</a>
<a name="ln186">/**************************************************************/</a>
<a name="ln187">typedef struct tagkLeast {</a>
<a name="ln188">    int k;</a>
<a name="ln189">    int i;</a>
<a name="ln190">} kLeast;</a>
<a name="ln191">/*************local prototypes **********************************/</a>
<a name="ln192">int CanonGraph( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln193">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln194">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln195">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  );</a>
<a name="ln196"> </a>
<a name="ln197">void CtPartFill( Graph *G, CANON_DATA *pCD, Partition *p,</a>
<a name="ln198">                 ConTable *Ct, int k, int n, int n_tg );</a>
<a name="ln199">void CtPartClear( ConTable *Ct, int k );</a>
<a name="ln200">void CtPartInfinity( ConTable *Ct, S_CHAR *cmp, int k );</a>
<a name="ln201">int CtPartCompare( ConTable *Ct1, ConTable *Ct2, S_CHAR *cmp,</a>
<a name="ln202">                   kLeast *kLeastForLayer, int k, int bOnlyCommon, int bSplitTautCompare );</a>
<a name="ln203">int CtFullCompare( ConTable *Ct1, ConTable *Ct2, int bOnlyCommon, int bSplitTautCompare );</a>
<a name="ln204">void CtPartCopy( ConTable *Ct1 /* to */, ConTable *Ct2 /* from */, int k );</a>
<a name="ln205">void CtFullCopy( ConTable *Ct1, ConTable *Ct2 );</a>
<a name="ln206"> </a>
<a name="ln207">int CtFullCompareLayers( kLeast *kLeastForLayer );</a>
<a name="ln208">int CtCompareLayersGetFirstDiff( kLeast *kLeast_rho, int nOneAdditionalLayer,</a>
<a name="ln209">                                 int *L_rho, int *I_rho, int *k_rho );</a>
<a name="ln210">int CtPartCompareLayers( kLeast *kLeast_rho, int L_rho_fix_prev, int nOneAdditionalLayer );</a>
<a name="ln211">void UpdateCompareLayers( kLeast kLeastForLayer[], int hzz );</a>
<a name="ln212">int GetOneAdditionalLayer( CANON_DATA *pCD, ConTable *pzb_rho_fix );</a>
<a name="ln213"> </a>
<a name="ln214">void CleanNumH( NUM_H *NumH, int len );</a>
<a name="ln215">int CleanCt( AT_RANK *Ct, int len );</a>
<a name="ln216">void CleanIsoSortKeys( AT_ISO_SORT_KEY * isk, int len );</a>
<a name="ln217">void MergeCleanIsoSortKeys( AT_ISO_SORT_KEY * isk1, AT_ISO_SORT_KEY * isk2, int len );</a>
<a name="ln218"> </a>
<a name="ln219">int  UnorderedPartitionJoin( UnorderedPartition *p1, UnorderedPartition *p2, int n );</a>
<a name="ln220">Node GetUnorderedPartitionMcrNode( UnorderedPartition *p1, Node v );</a>
<a name="ln221">int  nJoin2Mcrs2( AT_RANK *nEqArray, AT_RANK n1, AT_RANK n2 );</a>
<a name="ln222">AT_RANK nGetMcr2( AT_RANK *nEqArray, AT_RANK n );</a>
<a name="ln223">int  AllNodesAreInSet(  NodeSet *cur_nodes, int lcur_nodes, NodeSet *set, int lset );</a>
<a name="ln224">void NodeSetFromVertices( NodeSet *cur_nodes, int l, Node *v, int num_v);</a>
<a name="ln225">void CellMakeEmpty( Cell *baseW, int k );</a>
<a name="ln226">Node CellGetMinNode( Partition *p, Cell *W, Node v, CANON_DATA *pCD );</a>
<a name="ln227">int  CellGetNumberOfNodes( Partition *p, Cell *W );</a>
<a name="ln228">int  CellIntersectWithSet( Partition *p, Cell *W, NodeSet *Mcr, int l );</a>
<a name="ln229"> </a>
<a name="ln230">int  PartitionColorVertex( Graph *G, Partition *p, Node v, int n, int n_tg, int n_max, int bDigraph, int nNumPrevRanks );</a>
<a name="ln231">void PartitionCopy( Partition *To, Partition *From, int n );</a>
<a name="ln232">int  PartitionSatisfiesLemma_2_25( Partition *p, int n );</a>
<a name="ln233">void PartitionGetTransposition( Partition *pFrom, Partition *pTo, int n, Transposition *gamma );</a>
<a name="ln234">void PartitionGetMcrAndFixSet( Partition *p, NodeSet *Mcr, NodeSet *Fix, int n, int l );</a>
<a name="ln235">int  PartitionGetFirstCell( Partition *p, Cell *baseW, int k, int n );</a>
<a name="ln236">int  PartitionIsDiscrete( Partition *p, int n);</a>
<a name="ln237">void PartitionFree( Partition *p );</a>
<a name="ln238">int  PartitionCreate( Partition *p, int n);</a>
<a name="ln239">void UnorderedPartitionMakeDiscrete( UnorderedPartition *p, int n);</a>
<a name="ln240">void UnorderedPartitionFree( UnorderedPartition *p );</a>
<a name="ln241">int  UnorderedPartitionCreate( UnorderedPartition *p, int n );</a>
<a name="ln242">void CTableFree( ConTable *Ct );</a>
<a name="ln243">int  CTableCreate( ConTable *Ct, int n, CANON_DATA *pCD );</a>
<a name="ln244">void TranspositionFree( Transposition *p );</a>
<a name="ln245">int  TranspositionCreate( Transposition *p, int n );</a>
<a name="ln246">void TranspositionGetMcrAndFixSetAndUnorderedPartition( Transposition *gamma, NodeSet *McrSet, NodeSet *FixSet, int n, int l, UnorderedPartition *p );</a>
<a name="ln247"> </a>
<a name="ln248">void insertions_sort_NeighList_AT_NUMBERS2( NEIGH_LIST base, AT_RANK *nRank, AT_RANK max_rj );</a>
<a name="ln249">int  WriteGraph( Graph *G, int n, int gnum, char *fname, char *fmode );</a>
<a name="ln250"> </a>
<a name="ln251">int  SetInitialRanks2( int num_atoms, ATOM_INVARIANT2* pAtomInvariant2, AT_RANK *nNewRank, AT_RANK *nAtomNumber );</a>
<a name="ln252">void FillOutAtomInvariant2( sp_ATOM* at, int num_atoms, int num_at_tg, ATOM_INVARIANT2* pAtomInvariant,</a>
<a name="ln253">                           int bIgnoreIsotopic, int bHydrogensInRanks, int bHydrogensFixedInRanks,</a>
<a name="ln254">                           int bDigraph, int bTautGroupsOnly, T_GROUP_INFO *t_group_info );</a>
<a name="ln255"> </a>
<a name="ln256">int  GetCanonRanking2( int num_atoms, int num_at_tg, int num_max, int bDigraph, sp_ATOM* at,</a>
<a name="ln257">                     AT_RANK **pRankStack,  int nNumPrevRanks,</a>
<a name="ln258">                     AT_RANK *nSymmRank,  AT_RANK *nCanonRank,</a>
<a name="ln259">                     NEIGH_LIST *NeighList, AT_RANK *nTempRank,</a>
<a name="ln260">                     CANON_STAT* pCS );</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">#if ( SEPARATE_CANON_CALLS == 1 )</a>
<a name="ln264">/* for profiling purposes */</a>
<a name="ln265"> </a>
<a name="ln266">int CanonGraph01( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln267">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln268">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln269">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln270">{</a>
<a name="ln271">    return</a>
<a name="ln272">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln273">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln274">                            pCD,               pCC,</a>
<a name="ln275">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln276">}</a>
<a name="ln277">int CanonGraph02( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln278">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln279">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln280">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln281">{</a>
<a name="ln282">    return</a>
<a name="ln283">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln284">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln285">                            pCD,               pCC,</a>
<a name="ln286">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln287">}</a>
<a name="ln288">int CanonGraph03( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln289">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln290">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln291">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln292">{</a>
<a name="ln293">    return</a>
<a name="ln294">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln295">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln296">                            pCD,               pCC,</a>
<a name="ln297">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln298">}</a>
<a name="ln299">int CanonGraph04( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln300">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln301">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln302">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln303">{</a>
<a name="ln304">    return</a>
<a name="ln305">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln306">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln307">                            pCD,               pCC,</a>
<a name="ln308">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln309">}</a>
<a name="ln310">int CanonGraph05( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln311">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln312">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln313">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln314">{</a>
<a name="ln315">    return</a>
<a name="ln316">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln317">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln318">                            pCD,               pCC,</a>
<a name="ln319">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln320">}</a>
<a name="ln321">int CanonGraph06( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln322">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln323">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln324">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln325">{</a>
<a name="ln326">    return</a>
<a name="ln327">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln328">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln329">                            pCD,               pCC,</a>
<a name="ln330">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln331">}</a>
<a name="ln332">int CanonGraph07( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln333">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln334">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln335">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln336">{</a>
<a name="ln337">    return</a>
<a name="ln338">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln339">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln340">                            pCD,               pCC,</a>
<a name="ln341">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln342">}</a>
<a name="ln343">int CanonGraph08( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln344">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln345">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln346">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln347">{</a>
<a name="ln348">    return</a>
<a name="ln349">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln350">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln351">                            pCD,               pCC,</a>
<a name="ln352">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln353">}</a>
<a name="ln354">int CanonGraph09( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln355">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln356">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln357">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln358">{</a>
<a name="ln359">    return</a>
<a name="ln360">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln361">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln362">                            pCD,               pCC,</a>
<a name="ln363">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln364">}</a>
<a name="ln365">int CanonGraph10( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln366">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln367">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln368">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln369">{</a>
<a name="ln370">    return</a>
<a name="ln371">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln372">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln373">                            pCD,               pCC,</a>
<a name="ln374">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln375">}</a>
<a name="ln376">int CanonGraph11( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln377">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln378">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln379">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln380">{</a>
<a name="ln381">    return</a>
<a name="ln382">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln383">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln384">                            pCD,               pCC,</a>
<a name="ln385">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln386">}</a>
<a name="ln387">int CanonGraph12( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln388">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln389">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln390">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln391">{</a>
<a name="ln392">    return</a>
<a name="ln393">    CanonGraph(     n,     n_tg,     n_max,     bDigraph,        G,           pi  ,</a>
<a name="ln394">                         nSymmRank,           nCanonRank,          nAtomNumberCanon,</a>
<a name="ln395">                            pCD,               pCC,</a>
<a name="ln396">                           pp_zb_rho_inp,            pp_zb_rho_out  );</a>
<a name="ln397">}</a>
<a name="ln398">#else</a>
<a name="ln399"> </a>
<a name="ln400">#define CanonGraph01 CanonGraph</a>
<a name="ln401">#define CanonGraph02 CanonGraph</a>
<a name="ln402">#define CanonGraph03 CanonGraph</a>
<a name="ln403">#define CanonGraph04 CanonGraph</a>
<a name="ln404">#define CanonGraph05 CanonGraph</a>
<a name="ln405">#define CanonGraph06 CanonGraph</a>
<a name="ln406">#define CanonGraph07 CanonGraph</a>
<a name="ln407">#define CanonGraph08 CanonGraph</a>
<a name="ln408">#define CanonGraph09 CanonGraph</a>
<a name="ln409">#define CanonGraph10 CanonGraph</a>
<a name="ln410">#define CanonGraph11 CanonGraph</a>
<a name="ln411">#define CanonGraph12 CanonGraph</a>
<a name="ln412"> </a>
<a name="ln413">#endif</a>
<a name="ln414"> </a>
<a name="ln415">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln416">/****************************************************************/</a>
<a name="ln417">static call_fill_crc32_data = 1;</a>
<a name="ln418">static U_INT_32 crc32_data[256];</a>
<a name="ln419"> </a>
<a name="ln420">void fill_crc32_data()</a>
<a name="ln421">{</a>
<a name="ln422">  U_INT_32 c;</a>
<a name="ln423">  int n, k;</a>
<a name="ln424"> </a>
<a name="ln425">  for (n = 0; n &lt; 256; n++)</a>
<a name="ln426">  {</a>
<a name="ln427">    c = (U_INT_32)n;</a>
<a name="ln428">    for (k = 0; k &lt; 8; k++)</a>
<a name="ln429">      c = c &amp; 1 ? 0xEDB88320L ^ (c &gt;&gt; 1) : c &gt;&gt; 1;</a>
<a name="ln430">    crc32_data[n] = c;</a>
<a name="ln431">  }</a>
<a name="ln432">  call_fill_crc32_data = 0;</a>
<a name="ln433">}</a>
<a name="ln434">/****************************************************************/</a>
<a name="ln435">unsigned long add2crc32( unsigned long crc32, AT_NUMB n )</a>
<a name="ln436">{</a>
<a name="ln437">    U_INT_08 chr;</a>
<a name="ln438">    if (call_fill_crc32_data) {</a>
<a name="ln439">      fill_crc32_data();</a>
<a name="ln440">    }</a>
<a name="ln441">    chr = n % 128;</a>
<a name="ln442">    crc32 = crc32_data[((int)crc32 ^ (int)chr) &amp; 0xff] ^ (crc32 &gt;&gt; 8);</a>
<a name="ln443">    chr = n / 128;</a>
<a name="ln444">    crc32 = crc32_data[((int)crc32 ^ (int)chr) &amp; 0xff] ^ (crc32 &gt;&gt; 8);</a>
<a name="ln445">    return crc32;</a>
<a name="ln446">}</a>
<a name="ln447">#endif</a>
<a name="ln448">/****************************************************************/</a>
<a name="ln449">int TranspositionCreate( Transposition *p, int n )</a>
<a name="ln450">{</a>
<a name="ln451">    p-&gt;nAtNumb = (AT_NUMB*)inchi_calloc( n, sizeof(p-&gt;nAtNumb[0]) );</a>
<a name="ln452">    if ( p-&gt;nAtNumb ) {</a>
<a name="ln453">        return 1;</a>
<a name="ln454">    }</a>
<a name="ln455">    return 0;</a>
<a name="ln456">}</a>
<a name="ln457">/****************************************************************/</a>
<a name="ln458">void TranspositionFree( Transposition *p )</a>
<a name="ln459">{</a>
<a name="ln460">    if ( p &amp;&amp; p-&gt;nAtNumb ) {</a>
<a name="ln461">        inchi_free( p-&gt;nAtNumb );</a>
<a name="ln462">        p-&gt;nAtNumb = NULL;</a>
<a name="ln463">    }</a>
<a name="ln464">}</a>
<a name="ln465">/****************************************************************/</a>
<a name="ln466">int NodeSetCreate( NodeSet *pSet, int n, int L )</a>
<a name="ln467">{</a>
<a name="ln468">    int i, len;</a>
<a name="ln469"> </a>
<a name="ln470">    len = (n+ num_bit - 1)/num_bit;</a>
<a name="ln471"> </a>
<a name="ln472">    pSet-&gt;bitword = (bitWord**)inchi_calloc(L, sizeof(pSet-&gt;bitword[0]));</a>
<a name="ln473"> </a>
<a name="ln474">    if ( !pSet-&gt;bitword ) {</a>
<a name="ln475">        return 0;</a>
<a name="ln476">    }</a>
<a name="ln477">    pSet-&gt;bitword[0] = (bitWord*)inchi_calloc(len*L, sizeof(pSet-&gt;bitword[0][0]));</a>
<a name="ln478">    if ( !pSet-&gt;bitword[0] ) {</a>
<a name="ln479">        /* cleanup */</a>
<a name="ln480">        inchi_free( pSet-&gt;bitword );</a>
<a name="ln481">        pSet-&gt;bitword = NULL;</a>
<a name="ln482">        return 0; /* failed */</a>
<a name="ln483">    }</a>
<a name="ln484">    for ( i = 1; i &lt; L; i ++ ) {</a>
<a name="ln485">        pSet-&gt;bitword[i] = pSet-&gt;bitword[i-1]+len;</a>
<a name="ln486">    }</a>
<a name="ln487">    pSet-&gt;len_set = len;</a>
<a name="ln488">    pSet-&gt;num_set = L;</a>
<a name="ln489">    return 1;</a>
<a name="ln490">}</a>
<a name="ln491">/****************************************************************/</a>
<a name="ln492">void NodeSetFree( NodeSet *pSet )</a>
<a name="ln493">{</a>
<a name="ln494">    if ( pSet &amp;&amp; pSet-&gt;bitword ) {</a>
<a name="ln495">        if ( pSet-&gt;bitword[0] ) {</a>
<a name="ln496">            inchi_free( pSet-&gt;bitword[0] );</a>
<a name="ln497">        }</a>
<a name="ln498">        inchi_free( pSet-&gt;bitword );</a>
<a name="ln499">        pSet-&gt;bitword = NULL;</a>
<a name="ln500">    }</a>
<a name="ln501">}</a>
<a name="ln502">/****************************************************************/</a>
<a name="ln503">int CTableCreate( ConTable *Ct, int n, CANON_DATA *pCD )</a>
<a name="ln504">{</a>
<a name="ln505">    int maxlenCt        = pCD-&gt;nMaxLenLinearCT + 1; /* add one element for CtPartInfinity() */</a>
<a name="ln506">    int maxlenNumH      = pCD-&gt;NumH?       (pCD-&gt;maxlenNumH + 1)      : 0;</a>
<a name="ln507">    int maxlenNumHfixed = pCD-&gt;NumHfixed?  (pCD-&gt;maxlenNumHfixed + 1) : 0;</a>
<a name="ln508">    int maxlenIso       = pCD-&gt;maxlen_iso_sort_key? (pCD-&gt;maxlen_iso_sort_key+1) : 0;</a>
<a name="ln509">    int maxlenIsoExchg  = pCD-&gt;iso_exchg_atnos? (pCD-&gt;maxlen_iso_exchg_atnos+1) : 0;</a>
<a name="ln510">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln511">    int maxlenIsoHfixed = pCD-&gt;maxlen_iso_sort_key_Hfixed? (pCD-&gt;maxlen_iso_sort_key_Hfixed+1):0;</a>
<a name="ln512">#endif</a>
<a name="ln513">    </a>
<a name="ln514">    memset( Ct, 0, sizeof(Ct[0]) );</a>
<a name="ln515">    </a>
<a name="ln516">    Ct-&gt;maxVert = n;</a>
<a name="ln517">    </a>
<a name="ln518">    n ++;</a>
<a name="ln519"> </a>
<a name="ln520">    Ct-&gt;Ctbl           = (AT_RANK*) inchi_calloc(maxlenCt, sizeof(Ct-&gt;Ctbl[0]) );</a>
<a name="ln521">    Ct-&gt;nextCtblPos    = (AT_NUMB*) inchi_calloc(n, sizeof(Ct-&gt;nextCtblPos[0]) );</a>
<a name="ln522">    Ct-&gt;nextAtRank     = (AT_RANK*) inchi_calloc(n, sizeof(Ct-&gt;nextAtRank[0]) );</a>
<a name="ln523">    if ( maxlenNumH ) {</a>
<a name="ln524">        Ct-&gt;NumH            = (NUM_H *)  inchi_calloc(maxlenNumH, sizeof(Ct-&gt;NumH[0]));</a>
<a name="ln525">    }</a>
<a name="ln526">    if ( maxlenNumHfixed ) {</a>
<a name="ln527">        Ct-&gt;NumHfixed = (NUM_H *)  inchi_calloc(maxlenNumHfixed, sizeof(Ct-&gt;NumH[0]));</a>
<a name="ln528">    }</a>
<a name="ln529">    if ( maxlenIso ) {</a>
<a name="ln530">        Ct-&gt;iso_sort_key = (AT_ISO_SORT_KEY *)inchi_calloc(maxlenIso, sizeof(Ct-&gt;iso_sort_key[0]));</a>
<a name="ln531">    }</a>
<a name="ln532">    if ( maxlenIsoExchg ) {</a>
<a name="ln533">        Ct-&gt;iso_exchg_atnos = (S_CHAR *)inchi_calloc( maxlenIsoExchg, sizeof(Ct-&gt;iso_exchg_atnos[0]));</a>
<a name="ln534">    }</a>
<a name="ln535">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln536">    if ( maxlenIsoHfixed ) {</a>
<a name="ln537">        Ct-&gt;iso_sort_key_Hfixed = (AT_ISO_SORT_KEY *)inchi_calloc(maxlenIsoHfixed, sizeof(Ct-&gt;iso_sort_key_Hfixed[0]));</a>
<a name="ln538">    }</a>
<a name="ln539">#endif</a>
<a name="ln540">#ifdef INCHI_CANON_USE_HASH</a>
<a name="ln541">    Ct-&gt;hash           = (CtHash*) inchi_calloc(n, sizeof(Ct-&gt;hash[0]) );</a>
<a name="ln542">#endif</a>
<a name="ln543">    Ct-&gt;lenCt          = 0;</a>
<a name="ln544">    Ct-&gt;nLenCTAtOnly   = pCD-&gt;nLenCTAtOnly;</a>
<a name="ln545">    Ct-&gt;maxlenCt       = maxlenCt;</a>
<a name="ln546">    Ct-&gt;lenNumH        = 0;</a>
<a name="ln547">    Ct-&gt;maxlenNumH     = maxlenNumH;</a>
<a name="ln548">    Ct-&gt;len_iso_sort_key           = 0;</a>
<a name="ln549">    Ct-&gt;maxlen_iso_sort_key        = maxlenIso;</a>
<a name="ln550">    Ct-&gt;len_iso_exchg_atnos        = 0;</a>
<a name="ln551">    Ct-&gt;maxlen_iso_exchg_atnos     = maxlenIso;</a>
<a name="ln552">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln553">    Ct-&gt;len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln554">    Ct-&gt;maxlen_iso_sort_key_Hfixed = maxlenIsoHfixed;</a>
<a name="ln555">#endif</a>
<a name="ln556">    Ct-&gt;maxPos         = n;</a>
<a name="ln557">    Ct-&gt;lenPos         = 0;</a>
<a name="ln558">    Ct-&gt;nextAtRank[0]  = 0;</a>
<a name="ln559">    Ct-&gt;nextCtblPos[0] = 0;</a>
<a name="ln560">    if ( Ct-&gt;Ctbl &amp;&amp; Ct-&gt;nextCtblPos &amp;&amp;</a>
<a name="ln561">         (!maxlenNumH || Ct-&gt;NumH)   &amp;&amp;</a>
<a name="ln562">         (!maxlenNumHfixed || Ct-&gt;NumHfixed ) ) {</a>
<a name="ln563">        return 1;</a>
<a name="ln564">    }</a>
<a name="ln565">    return 0;</a>
<a name="ln566">}</a>
<a name="ln567">/****************************************************************/</a>
<a name="ln568">void CTableFree( ConTable *Ct )</a>
<a name="ln569">{</a>
<a name="ln570">    if ( Ct ) {</a>
<a name="ln571">        if ( Ct-&gt;Ctbl )</a>
<a name="ln572">            inchi_free( Ct-&gt;Ctbl );</a>
<a name="ln573">        if ( Ct-&gt;nextCtblPos )</a>
<a name="ln574">            inchi_free( Ct-&gt;nextCtblPos );</a>
<a name="ln575">        if ( Ct-&gt;nextAtRank )</a>
<a name="ln576">            inchi_free( Ct-&gt;nextAtRank );</a>
<a name="ln577">        if ( Ct-&gt;NumH )</a>
<a name="ln578">            inchi_free( Ct-&gt;NumH );</a>
<a name="ln579">        if ( Ct-&gt;NumHfixed )</a>
<a name="ln580">            inchi_free( Ct-&gt;NumHfixed );</a>
<a name="ln581">        if ( Ct-&gt;iso_sort_key )</a>
<a name="ln582">            inchi_free( Ct-&gt;iso_sort_key );</a>
<a name="ln583">        if ( Ct-&gt;iso_exchg_atnos )</a>
<a name="ln584">            inchi_free( Ct-&gt;iso_exchg_atnos );</a>
<a name="ln585">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln586">        if ( Ct-&gt;iso_sort_key_Hfixed )</a>
<a name="ln587">            inchi_free( Ct-&gt;iso_sort_key_Hfixed );</a>
<a name="ln588">#endif</a>
<a name="ln589">#ifdef INCHI_CANON_USE_HASH</a>
<a name="ln590">        if ( Ct-&gt;hash )</a>
<a name="ln591">            inchi_free( Ct-&gt;hash );</a>
<a name="ln592">#endif</a>
<a name="ln593">        memset( Ct, 0, sizeof( Ct[0] ) );</a>
<a name="ln594">    }</a>
<a name="ln595">}</a>
<a name="ln596">/****************************************************************/</a>
<a name="ln597">int UnorderedPartitionCreate( UnorderedPartition *p, int n )</a>
<a name="ln598">{</a>
<a name="ln599">    p-&gt;equ2 = (AT_NUMB*)inchi_calloc( n, sizeof(p-&gt;equ2[0]));</a>
<a name="ln600">    /* p-&gt;next = (AT_NUMB*)inchi_calloc( n, sizeof(p-&gt;next[0])); */</a>
<a name="ln601">    if ( p-&gt;equ2 /*&amp;&amp; p-&gt;next*/ )</a>
<a name="ln602">        return 1;</a>
<a name="ln603">    return 0;</a>
<a name="ln604">}</a>
<a name="ln605">/****************************************************************/</a>
<a name="ln606">void UnorderedPartitionFree( UnorderedPartition *p )</a>
<a name="ln607">{</a>
<a name="ln608">    if (p-&gt;equ2) inchi_free(p-&gt;equ2);</a>
<a name="ln609">    /* if (p-&gt;next) inchi_free(p-&gt;next); */</a>
<a name="ln610">    p-&gt;equ2 = NULL;</a>
<a name="ln611">    /* p-&gt;next = NULL; */</a>
<a name="ln612">}</a>
<a name="ln613">/****************************************************************/</a>
<a name="ln614">void UnorderedPartitionMakeDiscrete( UnorderedPartition *p, int n)</a>
<a name="ln615">{</a>
<a name="ln616">    int i;</a>
<a name="ln617">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln618">        p-&gt;equ2[i] = (AT_NUMB)i;</a>
<a name="ln619">        /* p-&gt;next[i] = INFINITY; */</a>
<a name="ln620">    }</a>
<a name="ln621">    INCHI_HEAPCHK</a>
<a name="ln622">}</a>
<a name="ln623">/****************************************************************/</a>
<a name="ln624">int PartitionCreate( Partition *p, int n)</a>
<a name="ln625">{</a>
<a name="ln626">    p-&gt;AtNumber = (AT_NUMB*)inchi_calloc( n, sizeof(p-&gt;AtNumber[0]));</a>
<a name="ln627">    p-&gt;Rank     = (AT_RANK*)inchi_calloc( n, sizeof(p-&gt;Rank[0]));</a>
<a name="ln628">    if ( p-&gt;AtNumber &amp;&amp; p-&gt;Rank ) {</a>
<a name="ln629">        return 1;</a>
<a name="ln630">    }</a>
<a name="ln631">    return 0;</a>
<a name="ln632">}</a>
<a name="ln633">/****************************************************************/</a>
<a name="ln634">void PartitionFree( Partition *p )</a>
<a name="ln635">{</a>
<a name="ln636">    if ( p ) {</a>
<a name="ln637">        if ( p-&gt;AtNumber ) {</a>
<a name="ln638">            inchi_free( p-&gt;AtNumber );</a>
<a name="ln639">            p-&gt;AtNumber = NULL;</a>
<a name="ln640">        }</a>
<a name="ln641">        if ( p-&gt;Rank ) {</a>
<a name="ln642">            inchi_free( p-&gt;Rank );</a>
<a name="ln643">            p-&gt;Rank = NULL;</a>
<a name="ln644">        }</a>
<a name="ln645">    }</a>
<a name="ln646">}</a>
<a name="ln647">/****************************************************************/</a>
<a name="ln648">int PartitionIsDiscrete( Partition *p, int n)</a>
<a name="ln649">{</a>
<a name="ln650">    int i;</a>
<a name="ln651">    AT_RANK r;</a>
<a name="ln652">    for ( i = 0, r = 1; i &lt; n; i ++, r ++ ) {</a>
<a name="ln653">        if ( r != (rank_mask_bit &amp; p-&gt;Rank[p-&gt;AtNumber[i]]) ) {</a>
<a name="ln654">            INCHI_HEAPCHK</a>
<a name="ln655">            return 0;</a>
<a name="ln656">        }</a>
<a name="ln657">    }</a>
<a name="ln658">    INCHI_HEAPCHK</a>
<a name="ln659">    return 1;</a>
<a name="ln660">}</a>
<a name="ln661">/****************************************************************/</a>
<a name="ln662">int PartitionGetFirstCell( Partition *p, Cell *baseW, int k, int n )</a>
<a name="ln663">{</a>
<a name="ln664">    int i;</a>
<a name="ln665">    AT_RANK r;</a>
<a name="ln666">    Cell *W = baseW+k-1;</a>
<a name="ln667"> </a>
<a name="ln668">    i = (k &gt; 1)? baseW[k-2].first+1 : 0;</a>
<a name="ln669">    if ( i &lt; n ) {</a>
<a name="ln670">        /* bypass single vertex cells */</a>
<a name="ln671">        for ( r = (AT_RANK)(i+1); i &lt; n &amp;&amp; r == (rank_mask_bit &amp; p-&gt;Rank[(int)p-&gt;AtNumber[i]]); i ++, r++ )</a>
<a name="ln672">            ;</a>
<a name="ln673">    }</a>
<a name="ln674">    if ( i &lt; n ) {</a>
<a name="ln675">        W-&gt;first = i;</a>
<a name="ln676">        for ( r = (rank_mask_bit &amp; p-&gt;Rank[(int)p-&gt;AtNumber[i]]), i++ ;</a>
<a name="ln677">                i &lt; n &amp;&amp; r == (rank_mask_bit &amp; p-&gt;Rank[(int)p-&gt;AtNumber[i]]);</a>
<a name="ln678">                   i ++ )</a>
<a name="ln679">            ;</a>
<a name="ln680">        W-&gt;next = i;</a>
<a name="ln681">        INCHI_HEAPCHK</a>
<a name="ln682">        return (W-&gt;next - W-&gt;first);</a>
<a name="ln683">    }</a>
<a name="ln684">    W-&gt;first = INFINITY;</a>
<a name="ln685">    W-&gt;next  = 0;</a>
<a name="ln686">    INCHI_HEAPCHK</a>
<a name="ln687">    return 0;</a>
<a name="ln688">}</a>
<a name="ln689">/****************************************************************/</a>
<a name="ln690">void CellMakeEmpty( Cell *baseW, int k )</a>
<a name="ln691">{</a>
<a name="ln692">    k --;</a>
<a name="ln693">    baseW[k].first = INFINITY;</a>
<a name="ln694">    baseW[k].next  = 0;</a>
<a name="ln695">    baseW[k].prev  = -1;</a>
<a name="ln696">    INCHI_HEAPCHK</a>
<a name="ln697">}</a>
<a name="ln698">/****************************************************************/</a>
<a name="ln699">void NodeSetFromVertices( NodeSet *cur_nodes, int l, Node *v, int num_v)</a>
<a name="ln700">{</a>
<a name="ln701">    bitWord *Bits = cur_nodes-&gt;bitword[l-1];</a>
<a name="ln702">    int      len  = cur_nodes-&gt;len_set*sizeof(bitWord);</a>
<a name="ln703">    int      i, j;</a>
<a name="ln704"> </a>
<a name="ln705">    memset( Bits, 0, len );</a>
<a name="ln706"> </a>
<a name="ln707">    for ( i = 0; i &lt; num_v; i ++ ) {</a>
<a name="ln708">        j = (int)v[i]-1;</a>
<a name="ln709">        Bits[ j / num_bit ] |= bBit[ j % num_bit ];</a>
<a name="ln710">    }</a>
<a name="ln711">    INCHI_HEAPCHK</a>
<a name="ln712">}</a>
<a name="ln713">/****************************************************************/</a>
<a name="ln714">int AllNodesAreInSet(  NodeSet *cur_nodes, int lcur_nodes, NodeSet *set, int lset )</a>
<a name="ln715">{</a>
<a name="ln716">    int i;</a>
<a name="ln717">    int n = cur_nodes-&gt;len_set;</a>
<a name="ln718">    bitWord *BitsNode = cur_nodes-&gt;bitword[lcur_nodes-1];</a>
<a name="ln719">    bitWord *BitsSet  = set-&gt;bitword[lset-1];</a>
<a name="ln720">    /* find any BitsNode[i] bit not in BitsSet[i] */</a>
<a name="ln721">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln722">        if ( BitsNode[i] &amp; ~BitsSet[i] ) {</a>
<a name="ln723">            INCHI_HEAPCHK</a>
<a name="ln724">            return 0;</a>
<a name="ln725">        }</a>
<a name="ln726">    }</a>
<a name="ln727">    INCHI_HEAPCHK</a>
<a name="ln728">    return 1;</a>
<a name="ln729">}</a>
<a name="ln730">/****************************************************************/</a>
<a name="ln731">void PartitionGetMcrAndFixSet( Partition *p, NodeSet *Mcr, NodeSet *Fix, int n, int l )</a>
<a name="ln732">{</a>
<a name="ln733">    int i, j1, j2;</a>
<a name="ln734">    AT_RANK r, r1;</a>
<a name="ln735">    bitWord *McrBits = Mcr-&gt;bitword[l-1];</a>
<a name="ln736">    bitWord *FixBits = Fix-&gt;bitword[l-1];</a>
<a name="ln737">    int     len      = Mcr-&gt;len_set*sizeof(bitWord);</a>
<a name="ln738"> </a>
<a name="ln739">    memset( McrBits, 0, len );</a>
<a name="ln740">    memset( FixBits, 0, len );</a>
<a name="ln741">    for ( i = 0, r = 1; i &lt; n; i ++, r ++ ) {</a>
<a name="ln742">        if ( r == (r1=(rank_mask_bit&amp;p-&gt;Rank[j1=(int)p-&gt;AtNumber[i]])) ) {</a>
<a name="ln743">            FixBits[j1 / num_bit] |= bBit[j1 % num_bit];</a>
<a name="ln744">            McrBits[j1 / num_bit] |= bBit[j1 % num_bit];</a>
<a name="ln745">        } else {</a>
<a name="ln746">            for ( r = r1; i+1 &lt; n &amp;&amp; r == (rank_mask_bit&amp;p-&gt;Rank[j2=(int)p-&gt;AtNumber[i+1]]); i ++ ) {</a>
<a name="ln747">                if ( j1 &gt; j2 ) {</a>
<a name="ln748">                    j1 = j2;</a>
<a name="ln749">                }</a>
<a name="ln750">            }</a>
<a name="ln751">            McrBits[j1 / num_bit] |= bBit[j1 % num_bit];</a>
<a name="ln752">        }</a>
<a name="ln753">    }</a>
<a name="ln754">    INCHI_HEAPCHK</a>
<a name="ln755">}</a>
<a name="ln756">/************* used in ichi_bns.c ********************************/</a>
<a name="ln757">void NodeSetFromRadEndpoints( NodeSet *cur_nodes, int k, /*Node *v*/ Vertex RadEndpoints[], int num_v)</a>
<a name="ln758">{</a>
<a name="ln759">    bitWord *Bits = cur_nodes-&gt;bitword[k];</a>
<a name="ln760">    int      len  = cur_nodes-&gt;len_set*sizeof(bitWord);</a>
<a name="ln761">    int      i, j;</a>
<a name="ln762"> </a>
<a name="ln763">    memset( Bits, 0, len );</a>
<a name="ln764"> </a>
<a name="ln765">    for ( i = 1; i &lt; num_v; i += 2 ) {</a>
<a name="ln766">        j = (int)RadEndpoints[i];</a>
<a name="ln767">        Bits[ j / num_bit ] |= bBit[ j % num_bit ];</a>
<a name="ln768">    }</a>
<a name="ln769">}</a>
<a name="ln770">/************* used in ichi_bns.c ********************************/</a>
<a name="ln771">void RemoveFromNodeSet( NodeSet *cur_nodes, int k, Vertex v[], int num_v)</a>
<a name="ln772">{</a>
<a name="ln773">    if ( cur_nodes-&gt;bitword ) {</a>
<a name="ln774">        bitWord *Bits = cur_nodes-&gt;bitword[k];</a>
<a name="ln775">        /*int      len  = cur_nodes-&gt;len_set*sizeof(bitWord);*/</a>
<a name="ln776">        int      i, j;</a>
<a name="ln777"> </a>
<a name="ln778">        for ( i = 0; i &lt; num_v; i ++ ) {</a>
<a name="ln779">            j = (int) v[i];</a>
<a name="ln780">            Bits[ j / num_bit ] &amp;= ~bBit[ j % num_bit ];</a>
<a name="ln781">        }</a>
<a name="ln782">    }</a>
<a name="ln783">}</a>
<a name="ln784">/************* used in ichi_bns.c ********************************/</a>
<a name="ln785">int DoNodeSetsIntersect( NodeSet *cur_nodes, int k1, int k2)</a>
<a name="ln786">{</a>
<a name="ln787">    if ( cur_nodes-&gt;bitword ) {</a>
<a name="ln788">        bitWord *Bits1 = cur_nodes-&gt;bitword[k1];</a>
<a name="ln789">        bitWord *Bits2 = cur_nodes-&gt;bitword[k2];</a>
<a name="ln790">        int      len  = cur_nodes-&gt;len_set;</a>
<a name="ln791">        int      i;</a>
<a name="ln792"> </a>
<a name="ln793">        for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln794">            if ( Bits1[i] &amp; Bits2[i] )</a>
<a name="ln795">                return 1;</a>
<a name="ln796">        }</a>
<a name="ln797">    }</a>
<a name="ln798">    return 0;</a>
<a name="ln799">}</a>
<a name="ln800">/************* used in ichi_bns.c ********************************/</a>
<a name="ln801">int IsNodeSetEmpty( NodeSet *cur_nodes, int k)</a>
<a name="ln802">{</a>
<a name="ln803">    if ( cur_nodes-&gt;bitword ) {</a>
<a name="ln804">        bitWord *Bits = cur_nodes-&gt;bitword[k];</a>
<a name="ln805">        int      len  = cur_nodes-&gt;len_set;</a>
<a name="ln806">        int      i;</a>
<a name="ln807"> </a>
<a name="ln808">        for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln809">            if ( Bits[i] )</a>
<a name="ln810">                return 0;</a>
<a name="ln811">        }</a>
<a name="ln812">    }</a>
<a name="ln813">    return 1;</a>
<a name="ln814">}</a>
<a name="ln815">/************* used in ichi_bns.c ********************************/</a>
<a name="ln816">void AddNodeSet2ToNodeSet1( NodeSet *cur_nodes, int k1, int k2)</a>
<a name="ln817">{</a>
<a name="ln818">    if ( cur_nodes-&gt;bitword ) {</a>
<a name="ln819">        bitWord *Bits1 = cur_nodes-&gt;bitword[k1];</a>
<a name="ln820">        bitWord *Bits2 = cur_nodes-&gt;bitword[k2];</a>
<a name="ln821">        int      len  = cur_nodes-&gt;len_set;</a>
<a name="ln822">        int      i;</a>
<a name="ln823"> </a>
<a name="ln824">        for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln825">            Bits1[i] |= Bits2[i];</a>
<a name="ln826">        }</a>
<a name="ln827">    }</a>
<a name="ln828">}</a>
<a name="ln829">/************* used in ichi_bns.c ********************************/</a>
<a name="ln830">int AddNodesToRadEndpoints( NodeSet *cur_nodes, int k, Vertex RadEndpoints[], Vertex vRad, int nStart, int nLen )</a>
<a name="ln831">{</a>
<a name="ln832">    int n = nStart;</a>
<a name="ln833">    if ( cur_nodes-&gt;bitword ) {</a>
<a name="ln834">        bitWord *Bits = cur_nodes-&gt;bitword[k];</a>
<a name="ln835">        int      len  = cur_nodes-&gt;len_set;</a>
<a name="ln836">        int      i, j;</a>
<a name="ln837">        Vertex   v;</a>
<a name="ln838"> </a>
<a name="ln839">        for ( i = 0, v = 0; i &lt; len; i ++ ) {</a>
<a name="ln840">            if ( Bits[i] ) {</a>
<a name="ln841">                for ( j = 0; j &lt; num_bit; j ++, v ++ ) {</a>
<a name="ln842">                    if ( Bits[i] &amp; bBit[j] ) {</a>
<a name="ln843">                        if ( n &gt;= nLen ) {</a>
<a name="ln844">                            return -1; /* overflow */</a>
<a name="ln845">                        }</a>
<a name="ln846">                        RadEndpoints[n ++] = vRad;</a>
<a name="ln847">                        RadEndpoints[n ++] = v;</a>
<a name="ln848">                    }</a>
<a name="ln849">                }</a>
<a name="ln850">            } else {</a>
<a name="ln851">                v += num_bit;</a>
<a name="ln852">            }</a>
<a name="ln853">        }</a>
<a name="ln854">    }</a>
<a name="ln855">    return n;</a>
<a name="ln856">}</a>
<a name="ln857">/****************************************************************/</a>
<a name="ln858">void PartitionGetTransposition( Partition *pFrom, Partition *pTo, int n, Transposition *gamma )</a>
<a name="ln859">{</a>
<a name="ln860">    int i;</a>
<a name="ln861">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln862">        gamma-&gt;nAtNumb[(int)pFrom-&gt;AtNumber[i]] =pTo-&gt;AtNumber[i];</a>
<a name="ln863">    }</a>
<a name="ln864">    INCHI_HEAPCHK</a>
<a name="ln865">}</a>
<a name="ln866">/**************************************************************************************/</a>
<a name="ln867">/*  Get minimal set (class) representative and partially compress the partitioning */</a>
<a name="ln868">/*  mcr = minimal class representative. */</a>
<a name="ln869">AT_RANK nGetMcr2( AT_RANK *nEqArray, AT_RANK n )</a>
<a name="ln870">{</a>
<a name="ln871">    AT_RANK n1, n2, mcr; /*  recursive version is much shorter. */</a>
<a name="ln872">    INCHI_HEAPCHK</a>
<a name="ln873">    n1=nEqArray[(int)n];</a>
<a name="ln874">    if ( n == n1 ) {</a>
<a name="ln875">        return n;</a>
<a name="ln876">    }</a>
<a name="ln877">    /*  1st pass: find mcr */</a>
<a name="ln878">    while ( n1 != (n2=nEqArray[(int)n1])) {</a>
<a name="ln879">        n1 = n2;</a>
<a name="ln880">    }</a>
<a name="ln881">    /*  2nd pass: copy mcr to each element of the set starting from nEqArray[n] */</a>
<a name="ln882">    mcr = n1;</a>
<a name="ln883">    n1  = n;</a>
<a name="ln884">    while ( /*n1*/ mcr != (n2=nEqArray[(int)n1]) ) {</a>
<a name="ln885">        nEqArray[(int)n1]=mcr;</a>
<a name="ln886">        n1 = n2;</a>
<a name="ln887">    }</a>
<a name="ln888">    INCHI_HEAPCHK</a>
<a name="ln889">    return ( mcr );</a>
<a name="ln890">}</a>
<a name="ln891">/**************************************************************************************/</a>
<a name="ln892">/*  Join 2 sets (classes) that have members n1 and n2 */</a>
<a name="ln893">int nJoin2Mcrs2( AT_RANK *nEqArray, AT_RANK n1, AT_RANK n2 )</a>
<a name="ln894">{</a>
<a name="ln895">    n1 = nGetMcr2( nEqArray, n1 );</a>
<a name="ln896">    n2 = nGetMcr2( nEqArray, n2 );</a>
<a name="ln897">    if ( n1 &lt; n2 ) {</a>
<a name="ln898">        nEqArray[n2] = n1;</a>
<a name="ln899">        INCHI_HEAPCHK</a>
<a name="ln900">        return 1; /*  a change has been made */</a>
<a name="ln901">    }</a>
<a name="ln902">    if ( n2 &lt; n1 ) {</a>
<a name="ln903">        nEqArray[n1] = n2;</a>
<a name="ln904">        INCHI_HEAPCHK</a>
<a name="ln905">        return 1; /*  a change has been made */</a>
<a name="ln906">    }</a>
<a name="ln907">    INCHI_HEAPCHK</a>
<a name="ln908">    return 0; /*  no changes */</a>
<a name="ln909">}</a>
<a name="ln910">/****************************************************************/</a>
<a name="ln911">Node GetUnorderedPartitionMcrNode( UnorderedPartition *p1, Node v )</a>
<a name="ln912">{</a>
<a name="ln913">    Node ret = (Node)(1+ nGetMcr2( p1-&gt;equ2, (AT_RANK)(v-1) ));</a>
<a name="ln914">    INCHI_HEAPCHK</a>
<a name="ln915">    return ret;</a>
<a name="ln916">}</a>
<a name="ln917">/****************************************************************/</a>
<a name="ln918">/* change p2 to (p2 v p1)  */</a>
<a name="ln919">int UnorderedPartitionJoin( UnorderedPartition *p1, UnorderedPartition *p2, int n )</a>
<a name="ln920">{</a>
<a name="ln921">    int i, j;</a>
<a name="ln922">    int nNumChanges = 0;</a>
<a name="ln923">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln924">        if ( (j=(int)p1-&gt;equ2[i]) == i || p2-&gt;equ2[(int)i] == p2-&gt;equ2[(int)j] ) {</a>
<a name="ln925">            continue;</a>
<a name="ln926">        }</a>
<a name="ln927">        nNumChanges += nJoin2Mcrs2(p2-&gt;equ2, (AT_NUMB)i, (AT_NUMB)j );</a>
<a name="ln928">    }</a>
<a name="ln929">    INCHI_HEAPCHK</a>
<a name="ln930">    return nNumChanges;</a>
<a name="ln931">}</a>
<a name="ln932">/****************************************************************/</a>
<a name="ln933">int PartitionSatisfiesLemma_2_25( Partition *p, int n )</a>
<a name="ln934">{</a>
<a name="ln935">    int nPartitionSize = 0;</a>
<a name="ln936">    int nNumNonTrivialCells = 0;</a>
<a name="ln937">    AT_RANK r;</a>
<a name="ln938">    int i, num;</a>
<a name="ln939">    for ( i = num = 0, r=1; i &lt; n; i ++, r++ ) {</a>
<a name="ln940">        if ( (rank_mask_bit &amp; p-&gt;Rank[(int)p-&gt;AtNumber[i]]) == r ) {</a>
<a name="ln941">            nPartitionSize ++;</a>
<a name="ln942">            if ( num ) {</a>
<a name="ln943">                /* num+1 = cell size &gt; 1 */</a>
<a name="ln944">                nNumNonTrivialCells ++;</a>
<a name="ln945">                num = 0;</a>
<a name="ln946">            }</a>
<a name="ln947">        } else {</a>
<a name="ln948">            num ++;</a>
<a name="ln949">        }</a>
<a name="ln950">    }</a>
<a name="ln951">    /* check Lemma_2_25 conditions */</a>
<a name="ln952">    if ( n &lt;= nPartitionSize+4 ||</a>
<a name="ln953">         n == nPartitionSize + nNumNonTrivialCells ||</a>
<a name="ln954">         n == nPartitionSize + nNumNonTrivialCells + 1 ) {</a>
<a name="ln955">        return 1;</a>
<a name="ln956">    }</a>
<a name="ln957">    return 0;</a>
<a name="ln958">}</a>
<a name="ln959">/****************************************************************/</a>
<a name="ln960">void PartitionCopy( Partition *To, Partition *From, int n )</a>
<a name="ln961">{</a>
<a name="ln962">    int i;</a>
<a name="ln963">    memcpy( To-&gt;AtNumber, From-&gt;AtNumber, n*sizeof(To-&gt;AtNumber[0]));</a>
<a name="ln964">    memcpy( To-&gt;Rank, From-&gt;Rank, n*sizeof(To-&gt;AtNumber[0]));</a>
<a name="ln965">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln966">        To-&gt;Rank[i] &amp;= rank_mask_bit;</a>
<a name="ln967">    }</a>
<a name="ln968">    INCHI_HEAPCHK</a>
<a name="ln969">}</a>
<a name="ln970">/****************************************************************/</a>
<a name="ln971">/* makes new equitable partition (p+1) out of p; first reduce the rank of vertex v */</a>
<a name="ln972">int PartitionColorVertex( Graph *G, Partition *p, Node v, int n, int n_tg, int n_max, int bDigraph, int nNumPrevRanks )</a>
<a name="ln973">{</a>
<a name="ln974">    int     nNumNewRanks, i, j;</a>
<a name="ln975">    long    lNumNeighListIter = 0;</a>
<a name="ln976">    AT_RANK rv, r;</a>
<a name="ln977">    AT_NUMB s, sv;</a>
<a name="ln978">    for ( i = 1; i &lt;= 2; i ++ ) {</a>
<a name="ln979">        if ( !p[i].AtNumber ) {</a>
<a name="ln980">            p[i].AtNumber = (AT_NUMB *) inchi_malloc(n_max*sizeof(p[0].AtNumber[0]));</a>
<a name="ln981">        }</a>
<a name="ln982">        if ( !p[i].Rank ) {</a>
<a name="ln983">            p[i].Rank = (AT_RANK *) inchi_malloc(n_max*sizeof(p[0].Rank[0]));</a>
<a name="ln984">        }</a>
<a name="ln985">        if ( !p[i].AtNumber || !p[i].Rank ) {</a>
<a name="ln986">            INCHI_HEAPCHK</a>
<a name="ln987">            return CT_OUT_OF_RAM;</a>
<a name="ln988">        }</a>
<a name="ln989">    }</a>
<a name="ln990">    PartitionCopy( p+1, p, n_tg );</a>
<a name="ln991">    sv  = v-1;          /* atom number we are looking for */</a>
<a name="ln992">    if ( sv &gt;= (AT_NUMB) n_tg ) {</a>
<a name="ln993">        INCHI_HEAPCHK</a>
<a name="ln994">        return CT_CANON_ERR; /* !!! severe program error: sv not found !!! */</a>
<a name="ln995">    }</a>
<a name="ln996">    rv = p[1].Rank[(int)sv];  /* rank of this atom */</a>
<a name="ln997">    /* second, locate sv among all vertices that have same rank as v */</a>
<a name="ln998">    s = n_max + 1; /* always greater than sv; this initialization is needed only to keep the compiler happy */</a>
<a name="ln999">    for ( j = (int)rv-1;  0 &lt;= j &amp;&amp; rv == (r = p[1].Rank[(int)(s=p[1].AtNumber[j])]) &amp;&amp; s != sv; j -- )</a>
<a name="ln1000">        ;</a>
<a name="ln1001">    if ( s != sv ) {</a>
<a name="ln1002">        INCHI_HEAPCHK</a>
<a name="ln1003">        return CT_CANON_ERR; /* !!! severe program error: sv not found !!! */</a>
<a name="ln1004">    }</a>
<a name="ln1005">    /* shift preceding atom numbers to the right to fill the gap after removing sv */</a>
<a name="ln1006">    r = rv-1; /* initialization only to keep compiler happy */</a>
<a name="ln1007">    for ( i = j--;  0 &lt;= j &amp;&amp; rv == (r = p[1].Rank[(int)(s=p[1].AtNumber[j])]); i = j, j -- ) {</a>
<a name="ln1008">        p[1].AtNumber[i] = s;</a>
<a name="ln1009">    }</a>
<a name="ln1010">    r = (i &gt; 0)? (r+1):1;  /* new reduced rank = (next lower rank)+1 or 1 */</a>
<a name="ln1011">    /* insert sv and adjust its rank */</a>
<a name="ln1012">    p[1].AtNumber[i] = sv;</a>
<a name="ln1013">    p[1].Rank[(int)sv] = r;</a>
<a name="ln1014"> </a>
<a name="ln1015"> </a>
<a name="ln1016">    /* make equitable partition */</a>
<a name="ln1017">    if ( bDigraph ) {</a>
<a name="ln1018"> </a>
<a name="ln1019">        /*</a>
<a name="ln1020">        nNumNewRanks = DifferentiateRanks2( n_tg, G,</a>
<a name="ln1021">                                         nNumPrevRanks+1, p[1].Rank, p[2].Rank,</a>
<a name="ln1022">                                         p[1].AtNumber, &amp;lNumNeighListIter, 1 );</a>
<a name="ln1023">        */</a>
<a name="ln1024">        nNumNewRanks = DifferentiateRanks4( n_tg, G, </a>
<a name="ln1025">                                         nNumPrevRanks+1, p[1].Rank, p[2].Rank /* temp array */,</a>
<a name="ln1026">                                         p[1].AtNumber,  (AT_RANK)n, &amp;lNumNeighListIter );</a>
<a name="ln1027">    </a>
<a name="ln1028">    </a>
<a name="ln1029">    } else {</a>
<a name="ln1030">        /*</a>
<a name="ln1031">        nNumNewRanks = DifferentiateRanks2( n_tg, G,</a>
<a name="ln1032">                                         nNumPrevRanks+1, p[1].Rank, p[2].Rank,</a>
<a name="ln1033">                                         p[1].AtNumber, &amp;lNumNeighListIter, 1 );</a>
<a name="ln1034">        */</a>
<a name="ln1035">        nNumNewRanks = DifferentiateRanks3( n_tg, G,</a>
<a name="ln1036">                                         nNumPrevRanks+1, p[1].Rank, p[2].Rank /* temp array */,</a>
<a name="ln1037">                                         p[1].AtNumber, &amp;lNumNeighListIter );</a>
<a name="ln1038">    }</a>
<a name="ln1039">    INCHI_HEAPCHK</a>
<a name="ln1040"> </a>
<a name="ln1041">    return nNumNewRanks;</a>
<a name="ln1042">}</a>
<a name="ln1043">typedef struct tagNodeValues {</a>
<a name="ln1044">    NUM_H            NumH;</a>
<a name="ln1045">    AT_ISO_SORT_KEY  iso_sort_key;</a>
<a name="ln1046">    NUM_H            NumHfixed;</a>
<a name="ln1047">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln1048">    AT_ISO_SORT_KEY  iso_sort_key_Hfixed;</a>
<a name="ln1049">#endif</a>
<a name="ln1050">    AT_NUMB          nAtNumber;</a>
<a name="ln1051">} NV;</a>
<a name="ln1052"> </a>
<a name="ln1053">/****************************************************************/</a>
<a name="ln1054">/* return min node &gt; vPrev or INFINITY if not found */</a>
<a name="ln1055">/* Input: v = previous atom number + 1 or 0 on first call*/</a>
<a name="ln1056">Node CellGetMinNode( Partition *p, Cell *W, Node v, CANON_DATA *pCD )</a>
<a name="ln1057">{</a>
<a name="ln1058">    AT_NUMB i;</a>
<a name="ln1059">    AT_NUMB uCurAtNumb, uMinAtNumb = INFINITY;</a>
<a name="ln1060">    /* in case of emty cell:  (W-&gt;first=INFINITY) &gt; (W-&gt;next=0); returns INFINITY */</a>
<a name="ln1061">    if ( W-&gt;first &gt; W-&gt;next ) {</a>
<a name="ln1062">        return INFINITY;</a>
<a name="ln1063">    }</a>
<a name="ln1064">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln1065">    if ( pCD &amp;&amp; pCD-&gt;nAuxRank )</a>
<a name="ln1066">    {</a>
<a name="ln1067">        AT_RANK uMinAuxRank, uCurAuxRank;</a>
<a name="ln1068">        int     nCurAtNumb;</a>
<a name="ln1069">#if ( USE_AUX_RANKING_ALL == 1 )</a>
<a name="ln1070">        AT_RANK uInpAuxRank;</a>
<a name="ln1071">        int     nInpAtNumb, nMinAtNumb;</a>
<a name="ln1072">#endif</a>
<a name="ln1073">        for ( i = W-&gt;first; i &lt; W-&gt;next; i ++ ) {</a>
<a name="ln1074">            uCurAtNumb = p-&gt;AtNumber[(int)i];</a>
<a name="ln1075">            if ( !(p-&gt;Rank[(int)uCurAtNumb] &amp; rank_mark_bit) ) {</a>
<a name="ln1076">                break; /* found the first unmarked yet node */</a>
<a name="ln1077">            }</a>
<a name="ln1078">        }</a>
<a name="ln1079">        if ( i == W-&gt;next ) {</a>
<a name="ln1080">            return INFINITY;</a>
<a name="ln1081">        }</a>
<a name="ln1082">#if ( USE_AUX_RANKING_ALL == 1 )</a>
<a name="ln1083">        /*==== vertex ordering definition ===</a>
<a name="ln1084">         * vertex v1 &lt; v2 &lt;=&gt; (AuxRank(v1)==AuxRank(v2) &amp;&amp; AtNumb(v1) &lt; AtNumb(v2)) || (AuxRank(v1) &lt; AuxRank(v2))</a>
<a name="ln1085">         * vertex v1 &gt; v2 &lt;=&gt; (AuxRank(v1)==AuxRank(v2) &amp;&amp; AtNumb(v1) &gt; AtNumb(v2)) || (AuxRank(v1) &gt; AuxRank(v2))</a>
<a name="ln1086">         * vertex v1 = v2 &lt;=&gt; (AuxRank(v1)==AuxRank(v2) &amp;&amp; AtNumb(v1) == AtNumb(v2))</a>
<a name="ln1087">         */</a>
<a name="ln1088">        </a>
<a name="ln1089">        /* set initial vMin so that vMin &gt; any vertex */</a>
<a name="ln1090">        uMinAuxRank = INFINITY;</a>
<a name="ln1091">        nMinAtNumb  = INFINITY;</a>
<a name="ln1092">        /* set vInp */</a>
<a name="ln1093">        if ( v ) {</a>
<a name="ln1094">            nInpAtNumb  = (int)v - 1; /* previous vertex */</a>
<a name="ln1095">            uInpAuxRank = pCD-&gt;nAuxRank[nInpAtNumb];</a>
<a name="ln1096">        } else {</a>
<a name="ln1097">            nInpAtNumb  = -1; /* less than any vertex */</a>
<a name="ln1098">            uInpAuxRank =  0;</a>
<a name="ln1099">        }</a>
<a name="ln1100">        /* find vMin = min { vCur : (vCur &gt; vInp) &amp;&amp; (vCur in W) } */ </a>
<a name="ln1101">        for ( ; i &lt; W-&gt;next; i ++ ) {</a>
<a name="ln1102">            nCurAtNumb = (int)p-&gt;AtNumber[(int)i];</a>
<a name="ln1103">            if ( !(p-&gt;Rank[nCurAtNumb] &amp; rank_mark_bit) ) {</a>
<a name="ln1104">                /* vertex nCurAtNumb is not marked, find whether it fits the conditions */</a>
<a name="ln1105">                uCurAuxRank = pCD-&gt;nAuxRank[nCurAtNumb];</a>
<a name="ln1106">                if ( ((uCurAuxRank == uInpAuxRank) &amp;&amp; (nCurAtNumb &gt; nInpAtNumb)) ||</a>
<a name="ln1107">                      (uCurAuxRank &gt; uInpAuxRank) ) {</a>
<a name="ln1108">                    /* here vCur &gt; vInp */</a>
<a name="ln1109">                    if ( uCurAuxRank == uMinAuxRank &amp;&amp; nCurAtNumb &lt; nMinAtNumb ) {</a>
<a name="ln1110">                        /* vCur &lt; vMin (1) */</a>
<a name="ln1111">                        nMinAtNumb = nCurAtNumb;</a>
<a name="ln1112">                    } else</a>
<a name="ln1113">                    if ( uCurAuxRank &lt; uMinAuxRank ) {</a>
<a name="ln1114">                        /* vCur &lt; vMin (2) */</a>
<a name="ln1115">                        uMinAuxRank = uCurAuxRank;</a>
<a name="ln1116">                        nMinAtNumb = nCurAtNumb;</a>
<a name="ln1117">                    }</a>
<a name="ln1118">                }</a>
<a name="ln1119">            }</a>
<a name="ln1120">        }</a>
<a name="ln1121">        uMinAtNumb = (nMinAtNumb==INFINITY)? INFINITY : (AT_NUMB)nMinAtNumb;</a>
<a name="ln1122">#else</a>
<a name="ln1123">        if ( v ) {</a>
<a name="ln1124">            nCurAtNumb = (int)v-1;</a>
<a name="ln1125">            /* any valid found node must have nAuxRank == uMinAuxRank */</a>
<a name="ln1126">            uMinAuxRank   = pCD-&gt;nAuxRank[nCurAtNumb];</a>
<a name="ln1127">        } else {</a>
<a name="ln1128">            /* any valid found node must have minimal uMinAuxRank from pCD-&gt;nAuxRank[] */</a>
<a name="ln1129">            uMinAuxRank   = INFINITY; /* undefined */</a>
<a name="ln1130">        }</a>
<a name="ln1131"> </a>
<a name="ln1132">        for ( ; i &lt; W-&gt;next; i ++ ) {</a>
<a name="ln1133">            uCurAtNumb = p-&gt;AtNumber[(int)i];</a>
<a name="ln1134">            nCurAtNumb = (int)uCurAtNumb;</a>
<a name="ln1135">            if ( uCurAtNumb &gt;= v &amp;&amp; !(p-&gt;Rank[nCurAtNumb] &amp; rank_mark_bit) ) {</a>
<a name="ln1136">                uCurAuxRank = pCD-&gt;nAuxRank[nCurAtNumb];</a>
<a name="ln1137">                if ( v ) {</a>
<a name="ln1138">                    /* get next node */</a>
<a name="ln1139">                    /* find node with smallest uCurAtNumb among nodes with aux. ranks equal to uMinAuxRank */</a>
<a name="ln1140">                    if ( uCurAuxRank == uMinAuxRank &amp;&amp; uCurAtNumb &lt; uMinAtNumb ) {</a>
<a name="ln1141">                        uMinAtNumb = uCurAtNumb;</a>
<a name="ln1142">                    }</a>
<a name="ln1143">                } else {</a>
<a name="ln1144">                    /* get first node */</a>
<a name="ln1145">                    /* find node with smallest smallest uCurAtNumb among nodes with smallest aux. ranks */</a>
<a name="ln1146">                    if ( uMinAuxRank &gt; uCurAuxRank ) {</a>
<a name="ln1147">                        uMinAuxRank = uCurAuxRank;</a>
<a name="ln1148">                        uMinAtNumb = uCurAtNumb;</a>
<a name="ln1149">                    } else</a>
<a name="ln1150">                    if ( uMinAuxRank == uCurAuxRank &amp;&amp; uCurAtNumb &lt; uMinAtNumb ) {</a>
<a name="ln1151">                        uMinAtNumb = uCurAtNumb;</a>
<a name="ln1152">                    }</a>
<a name="ln1153">                }</a>
<a name="ln1154">            }</a>
<a name="ln1155">        }</a>
<a name="ln1156">#endif</a>
<a name="ln1157">    } else</a>
<a name="ln1158">#endif /* } USE_AUX_RANKING */</a>
<a name="ln1159">    {</a>
<a name="ln1160">        for ( i = W-&gt;first; i &lt; W-&gt;next; i ++ ) {</a>
<a name="ln1161">            uCurAtNumb = p-&gt;AtNumber[(int)i];</a>
<a name="ln1162">            if ( uCurAtNumb &gt;= v &amp;&amp; !(p-&gt;Rank[(int)uCurAtNumb] &amp; rank_mark_bit) &amp;&amp; uCurAtNumb &lt; uMinAtNumb ) {</a>
<a name="ln1163">                uMinAtNumb = uCurAtNumb;</a>
<a name="ln1164">            }</a>
<a name="ln1165">        }</a>
<a name="ln1166">    }</a>
<a name="ln1167">    if ( uMinAtNumb != INFINITY ) uMinAtNumb ++;</a>
<a name="ln1168">    INCHI_HEAPCHK</a>
<a name="ln1169">    return uMinAtNumb;</a>
<a name="ln1170">}</a>
<a name="ln1171">/****************************************************************/</a>
<a name="ln1172">int CellGetNumberOfNodes( Partition *p, Cell *W )</a>
<a name="ln1173">{</a>
<a name="ln1174">    int first = W-&gt;first;</a>
<a name="ln1175">    int next  = W-&gt;next;</a>
<a name="ln1176">    int i, num;</a>
<a name="ln1177">    for ( i = first, num = 0; i &lt; next; i ++ ) {</a>
<a name="ln1178">        if ( !( rank_mark_bit &amp; p-&gt;Rank[(int)p-&gt;AtNumber[i]] ) ) {</a>
<a name="ln1179">            num++;</a>
<a name="ln1180">        }</a>
<a name="ln1181">    }</a>
<a name="ln1182">    INCHI_HEAPCHK</a>
<a name="ln1183">    return num;</a>
<a name="ln1184">}</a>
<a name="ln1185">/****************************************************************/</a>
<a name="ln1186">int CellIntersectWithSet( Partition *p, Cell *W, NodeSet *Mcr, int l )</a>
<a name="ln1187">{</a>
<a name="ln1188">    bitWord *McrBits = Mcr-&gt;bitword[l-1];</a>
<a name="ln1189">    int first = W-&gt;first;</a>
<a name="ln1190">    int next  = W-&gt;next;</a>
<a name="ln1191">    int i, j, k;</a>
<a name="ln1192">    if ( first &gt;= next ) { /* for testing only */</a>
<a name="ln1193">        return 0;</a>
<a name="ln1194">    }</a>
<a name="ln1195">    for ( i = first, k = 0; i &lt; next; i ++ ) {</a>
<a name="ln1196">        j = (int)p-&gt;AtNumber[i];</a>
<a name="ln1197">        if ( !(McrBits[ j / num_bit ] &amp; bBit[ j % num_bit ]) ) { /* BC: reading uninit memory ???-not examined yet */</a>
<a name="ln1198">            k += !(p-&gt;Rank[j] &amp; rank_mark_bit); /* for testing only */</a>
<a name="ln1199">            p-&gt;Rank[j] |= rank_mark_bit;</a>
<a name="ln1200">        }</a>
<a name="ln1201">    }</a>
<a name="ln1202">    INCHI_HEAPCHK</a>
<a name="ln1203">    return k;</a>
<a name="ln1204">}</a>
<a name="ln1205">/****************************************************************/</a>
<a name="ln1206">void CtPartClear( ConTable *Ct, int k )</a>
<a name="ln1207">{</a>
<a name="ln1208">    int start;</a>
<a name="ln1209">    int len;</a>
<a name="ln1210">    /* connection table */</a>
<a name="ln1211">    start = k&gt;1? Ct-&gt;nextCtblPos[k-1] : 0;</a>
<a name="ln1212">    len   = Ct-&gt;lenCt - start;</a>
<a name="ln1213">    if ( len &gt; 0 ) {</a>
<a name="ln1214">        memset( Ct-&gt;Ctbl + start, 0, (Ct-&gt;lenCt - start)*sizeof(Ct-&gt;Ctbl[0]) );</a>
<a name="ln1215">    }</a>
<a name="ln1216">    Ct-&gt;lenCt = start;</a>
<a name="ln1217">    Ct-&gt;lenPos = k;</a>
<a name="ln1218"> </a>
<a name="ln1219">    INCHI_HEAPCHK</a>
<a name="ln1220">}</a>
<a name="ln1221">/**********************************************************************************/</a>
<a name="ln1222">/*  Sort neighbors according to ranks in ascending order */</a>
<a name="ln1223">void insertions_sort_NeighList_AT_NUMBERS2( NEIGH_LIST base, AT_RANK *nRank, AT_RANK max_rj )</a>
<a name="ln1224">{</a>
<a name="ln1225">  AT_NUMB *i, *j, *pk, tmp, rj;</a>
<a name="ln1226">  int k, num = (int)*base++;</a>
<a name="ln1227">  for( k=1, pk = base; k &lt; num; k++, pk ++ ) {</a>
<a name="ln1228">     i = pk;</a>
<a name="ln1229">     j = i + 1;</a>
<a name="ln1230">     rj = (rank_mask_bit &amp; nRank[(int)*j]);</a>
<a name="ln1231">     if ( rj &lt; max_rj ) {</a>
<a name="ln1232">         while ( j &gt; base &amp;&amp; rj &lt; (rank_mask_bit &amp; nRank[(int)*i])) {</a>
<a name="ln1233">             tmp = *i;</a>
<a name="ln1234">             *i = *j;</a>
<a name="ln1235">             *j = tmp;</a>
<a name="ln1236">             j = i --;</a>
<a name="ln1237">         }</a>
<a name="ln1238">     }</a>
<a name="ln1239">  }</a>
<a name="ln1240">  INCHI_HEAPCHK</a>
<a name="ln1241">}</a>
<a name="ln1242">/****************************************************************/</a>
<a name="ln1243">/* may need previous Lambda */</a>
<a name="ln1244">void CtPartFill( Graph *G, CANON_DATA *pCD, Partition *p,</a>
<a name="ln1245">                 ConTable *Ct, int k, int n, int n_tg )</a>
<a name="ln1246"> /*  k = (new index in Ct-&gt;nextAtRank[] and Ct-&gt;nextCtblPos[]) + 1 */</a>
<a name="ln1247">{</a>
<a name="ln1248">    int     startCtbl;</a>
<a name="ln1249">    int     startAtOrd;</a>
<a name="ln1250">    AT_RANK r, rj, nn, j, rj_prev;</a>
<a name="ln1251">    int     i, m;</a>
<a name="ln1252">#ifdef INCHI_CANON_USE_HASH</a>
<a name="ln1253">    CtHash  hash = 0;</a>
<a name="ln1254">#endif</a>
<a name="ln1255">        static int count; /* for debug only */</a>
<a name="ln1256">        count ++;</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">    INCHI_HEAPCHK</a>
<a name="ln1260">    </a>
<a name="ln1261">    k --;</a>
<a name="ln1262">    if ( k ) {</a>
<a name="ln1263">        startCtbl  = Ct-&gt;nextCtblPos[k-1];</a>
<a name="ln1264">        startAtOrd = Ct-&gt;nextAtRank[k-1]-1;  /* here  p-&gt;Rank[p-&gt;AtNumber[r-1]] = r */</a>
<a name="ln1265">    } else {</a>
<a name="ln1266">        startCtbl  = 0;</a>
<a name="ln1267">        startAtOrd = 0;</a>
<a name="ln1268">    }</a>
<a name="ln1269">    /******* well-defined (by fixed ranks) part of the connection table ************/</a>
<a name="ln1270">    r = (rank_mask_bit &amp; p-&gt;Rank[(int)p-&gt;AtNumber[startAtOrd]]);</a>
<a name="ln1271">    for ( i = startAtOrd; i &lt; n_tg &amp;&amp; r == (rank_mask_bit&amp;p-&gt;Rank[m=(int)p-&gt;AtNumber[i]]); i++, r ++ ) {</a>
<a name="ln1272">        Ct-&gt;Ctbl[startCtbl++] = r;</a>
<a name="ln1273">        insertions_sort_NeighList_AT_NUMBERS2( G[m], p-&gt;Rank, r );</a>
<a name="ln1274">        nn = G[m][0]; /* number of neighbors */</a>
<a name="ln1275">        rj_prev = 0; /* debug only */</a>
<a name="ln1276">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln1277">        hash = add2crc32( hash, (AT_NUMB)(r + n) );</a>
<a name="ln1278">#endif</a>
<a name="ln1279">        for ( j = 1; j &lt;= nn &amp;&amp; (rj=(rank_mask_bit&amp;p-&gt;Rank[(int)G[m][j]])) &lt; r; j ++ ) {</a>
<a name="ln1280">            Ct-&gt;Ctbl[startCtbl++] = rj;</a>
<a name="ln1281">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln1282">            hash = add2crc32( hash, rj );</a>
<a name="ln1283">#endif</a>
<a name="ln1284">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1285">            /* debug only */</a>
<a name="ln1286">            if ( rj &lt; rj_prev ) {</a>
<a name="ln1287">                int stop = 1;   /* &lt;BRKPT&gt; */</a>
<a name="ln1288">            }</a>
<a name="ln1289">#endif</a>
<a name="ln1290">            rj_prev = rj;</a>
<a name="ln1291">        }</a>
<a name="ln1292">    }</a>
<a name="ln1293">    </a>
<a name="ln1294">    INCHI_HEAPCHK</a>
<a name="ln1295"> </a>
<a name="ln1296">    /****************** well-defined part of base hydrogen atoms *******************/</a>
<a name="ln1297">    if ( pCD-&gt;NumH &amp;&amp; Ct-&gt;NumH ) {</a>
<a name="ln1298">        nn = inchi_min(n, i);</a>
<a name="ln1299">        for ( j = startAtOrd; j &lt; nn; j ++ ) { /* atoms */</a>
<a name="ln1300">            Ct-&gt;NumH[j] = pCD-&gt;NumH[p-&gt;AtNumber[j]];</a>
<a name="ln1301">        }</a>
<a name="ln1302">        for ( ; j &lt; i; j ++ ) {  /* t-groups */</a>
<a name="ln1303">            int data_pos = n + T_NUM_NO_ISOTOPIC * ((int)p-&gt;AtNumber[j] - n);</a>
<a name="ln1304">            for ( m = 0; m &lt; T_NUM_NO_ISOTOPIC; m ++ ) {</a>
<a name="ln1305">                Ct-&gt;NumH[nn ++] = pCD-&gt;NumH[data_pos ++];</a>
<a name="ln1306">            }</a>
<a name="ln1307">        }</a>
<a name="ln1308">        Ct-&gt;lenNumH = nn;</a>
<a name="ln1309">    } else {</a>
<a name="ln1310">        Ct-&gt;lenNumH = 0;</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">    INCHI_HEAPCHK</a>
<a name="ln1314"> </a>
<a name="ln1315">    /****************** well-defined part of fixed hydrogen atoms *******************/</a>
<a name="ln1316">    if ( pCD-&gt;NumHfixed &amp;&amp; Ct-&gt;NumHfixed ) {</a>
<a name="ln1317">        nn = inchi_min(n, i);</a>
<a name="ln1318">        for ( j = startAtOrd; j &lt; nn; j ++ ) {</a>
<a name="ln1319">            Ct-&gt;NumHfixed[j] = pCD-&gt;NumHfixed[p-&gt;AtNumber[j]];</a>
<a name="ln1320"> </a>
<a name="ln1321">    INCHI_HEAPCHK</a>
<a name="ln1322"> </a>
<a name="ln1323">        }</a>
<a name="ln1324">        /* Ct-&gt;lenNumHfixed = nn; */</a>
<a name="ln1325">    } else {</a>
<a name="ln1326">        ;/* Ct-&gt;lenNumHfixed = 0; */</a>
<a name="ln1327">    }</a>
<a name="ln1328"> </a>
<a name="ln1329">    INCHI_HEAPCHK</a>
<a name="ln1330"> </a>
<a name="ln1331">    /****************** well-defined part of isotopic keys ***************************/</a>
<a name="ln1332">    if ( pCD-&gt;iso_sort_key &amp;&amp; Ct-&gt;iso_sort_key ) {</a>
<a name="ln1333">        for ( j = startAtOrd; j &lt; i; j ++ ) {</a>
<a name="ln1334">            Ct-&gt;iso_sort_key[j] = pCD-&gt;iso_sort_key[p-&gt;AtNumber[j]];</a>
<a name="ln1335">        }</a>
<a name="ln1336">        Ct-&gt;len_iso_sort_key = i;</a>
<a name="ln1337">    } else {</a>
<a name="ln1338">        Ct-&gt;len_iso_sort_key = 0;</a>
<a name="ln1339">    }</a>
<a name="ln1340"> </a>
<a name="ln1341">    INCHI_HEAPCHK</a>
<a name="ln1342"> </a>
<a name="ln1343">    /****************** well-defined part of isotopic iso_exchg_atnos ***************************/</a>
<a name="ln1344">    if ( pCD-&gt;iso_exchg_atnos &amp;&amp; Ct-&gt;iso_exchg_atnos ) {</a>
<a name="ln1345">        for ( j = startAtOrd; j &lt; i; j ++ ) {</a>
<a name="ln1346">            Ct-&gt;iso_exchg_atnos[j] = pCD-&gt;iso_exchg_atnos[p-&gt;AtNumber[j]];</a>
<a name="ln1347">        }</a>
<a name="ln1348">        Ct-&gt;len_iso_exchg_atnos = i;</a>
<a name="ln1349">    } else {</a>
<a name="ln1350">        Ct-&gt;len_iso_exchg_atnos = 0;</a>
<a name="ln1351">    }</a>
<a name="ln1352"> </a>
<a name="ln1353">    INCHI_HEAPCHK</a>
<a name="ln1354">    /******** well-defined part of isotopic keys for fixed hydrogen atoms ************/</a>
<a name="ln1355">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln1356">    if ( pCD-&gt;iso_sort_key_Hfixed &amp;&amp; Ct-&gt;iso_sort_key_Hfixed ) {</a>
<a name="ln1357">        nn = inchi_min(n, i);</a>
<a name="ln1358">        for ( j = startAtOrd; j &lt; nn; j ++ ) {</a>
<a name="ln1359">            Ct-&gt;iso_sort_key_Hfixed[j] = pCD-&gt;iso_sort_key_Hfixed[p-&gt;AtNumber[j]];</a>
<a name="ln1360">        }</a>
<a name="ln1361">        Ct-&gt;len_iso_sort_key_Hfixed = nn;</a>
<a name="ln1362">    } else {</a>
<a name="ln1363">        Ct-&gt;len_iso_sort_key_Hfixed = 0;</a>
<a name="ln1364">    }</a>
<a name="ln1365">#endif</a>
<a name="ln1366"> </a>
<a name="ln1367">    INCHI_HEAPCHK</a>
<a name="ln1368"> </a>
<a name="ln1369">    Ct-&gt;lenCt          = startCtbl; /* not aways increases */</a>
<a name="ln1370">    Ct-&gt;nextCtblPos[k] = startCtbl;</a>
<a name="ln1371">    Ct-&gt;nextAtRank[k]  = r;</a>
<a name="ln1372">    Ct-&gt;lenPos = k+1;</a>
<a name="ln1373">    /* the rest of the CTable */</a>
<a name="ln1374">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln1375">    while ( i &lt; n ) {</a>
<a name="ln1376">        r = (rank_mask_bit&amp;p-&gt;Rank[m=(int)p-&gt;AtNumber[i]]);</a>
<a name="ln1377">        hash = add2crc32( hash, (AT_NUMB)(r + n) );</a>
<a name="ln1378">        r++;</a>
<a name="ln1379">        insertions_sort_NeighList_AT_NUMBERS2( G[m], p-&gt;Rank, r );</a>
<a name="ln1380">        nn = G[m][0];</a>
<a name="ln1381">        rj_prev = 0; /* debug only */</a>
<a name="ln1382">        for ( j = 1; j &lt;= nn &amp;&amp; (rj=(rank_mask_bit&amp;p-&gt;Rank[(int)G[m][j]])) &lt; r; j ++ ) {</a>
<a name="ln1383">            hash = add2crc32( hash, rj );</a>
<a name="ln1384">        }</a>
<a name="ln1385">        i ++;</a>
<a name="ln1386">    }</a>
<a name="ln1387">    Ct-&gt;hash[k] = hash;</a>
<a name="ln1388">#endif        </a>
<a name="ln1389"> </a>
<a name="ln1390">    INCHI_HEAPCHK</a>
<a name="ln1391">}</a>
<a name="ln1392">/****************************************************************/</a>
<a name="ln1393">void CtPartInfinity( ConTable *Ct, S_CHAR *cmp, int k )</a>
<a name="ln1394">{</a>
<a name="ln1395">    int     startCtbl;</a>
<a name="ln1396">    /*int     startAtOrd;*/</a>
<a name="ln1397">    k --;</a>
<a name="ln1398">    if ( k ) {</a>
<a name="ln1399">        startCtbl  = Ct-&gt;nextCtblPos[k-1];</a>
<a name="ln1400">        /*startAtOrd = Ct-&gt;nextAtRank[k-1]-1;*/  /* here  p-&gt;Rank[p-&gt;AtNumber[r-1]] = r */</a>
<a name="ln1401">        if ( cmp ) {</a>
<a name="ln1402">            memset( cmp, 0, k*sizeof(cmp[0]) );</a>
<a name="ln1403">        }</a>
<a name="ln1404">    } else {</a>
<a name="ln1405">        startCtbl  = 0;</a>
<a name="ln1406">        /*startAtOrd = 0;*/</a>
<a name="ln1407">    }</a>
<a name="ln1408">    if ( !startCtbl || Ct-&gt;Ctbl[startCtbl-1] != EMPTY_CT ) {</a>
<a name="ln1409">        Ct-&gt;Ctbl[startCtbl] = EMPTY_CT;</a>
<a name="ln1410">    }</a>
<a name="ln1411">    INCHI_HEAPCHK</a>
<a name="ln1412">}</a>
<a name="ln1413">/****************************************************************/</a>
<a name="ln1414">/* Return value:</a>
<a name="ln1415">  -1 &lt;=&gt; *Lambda1 &lt; *Lambda2</a>
<a name="ln1416">   0 &lt;=&gt; *Lambda1 = *Lambda2</a>
<a name="ln1417">  +1 &lt;=&gt; *Lambda1 &gt; *Lambda2</a>
<a name="ln1418"> </a>
<a name="ln1419">  Input: k+1 = value of level at which the comparison is executed</a>
<a name="ln1420">               (that is, in the calling program k(caller) = k+1)</a>
<a name="ln1421"> </a>
<a name="ln1422">  Stars (*) below mark the differences:</a>
<a name="ln1423"> </a>
<a name="ln1424">  bSplitTautCompare != 0 =&gt; directed graph; compare:</a>
<a name="ln1425">                   non-tautomeric part of CT in layer 0; (*)</a>
<a name="ln1426">                   non-tautomeric H          in layer 1; (*)</a>
<a name="ln1427">                   tautomeric part of CT &amp; H in layer 2; (*)</a>
<a name="ln1428">                   fixed H                   in layer 3;</a>
<a name="ln1429">                   isotopic atoms, non-taut</a>
<a name="ln1430">                               H &amp; t-groups  in layer 4;</a>
<a name="ln1431">                   fixed isotopic H          in layer 5; &lt;- move to layer 4</a>
<a name="ln1432"> </a>
<a name="ln1433">  bSplitTautCompare == 0 =&gt; undirected graph; compare:</a>
<a name="ln1434">                   full CT                   in Layer 0; (*)</a>
<a name="ln1435">                   taut and non-taut H       in Layer 1; (*)</a>
<a name="ln1436">                   * nothing *               in layer 2; (*)</a>
<a name="ln1437">                   fixed H                   in layer 3;</a>
<a name="ln1438">                   isotopic atoms, non-taut</a>
<a name="ln1439">                               H &amp; t-groups  in layer 4;</a>
<a name="ln1440">                   fixed isotopic H          in layer 5; &lt;- move to layer 4</a>
<a name="ln1441"> </a>
<a name="ln1442">*/</a>
<a name="ln1443">int CtPartCompare( ConTable *Ct1, ConTable *Ct2, S_CHAR *cmp,</a>
<a name="ln1444">                   kLeast *kLeastForLayer, int k, int bOnlyCommon, int bSplitTautCompare )</a>
<a name="ln1445">{</a>
<a name="ln1446">    int     startCt1, endCt1, startCt2, endCt2; /*endCt,*/</a>
<a name="ln1447">    int     startAt1, endAt1, startAt2, endAt2; /*endCt,*/</a>
<a name="ln1448">    int     midCt /* end of atoms only Ct */, midNumH=0 /* end of atoms only NumH */, maxVert;</a>
<a name="ln1449">    int     diff, i, k1, k2, lenNumH, len_iso_sort_key, /*mid_iso_sort_key,*/ midAt;</a>
<a name="ln1450">    int     nLayer = 0;</a>
<a name="ln1451"> </a>
<a name="ln1452">    k --;</a>
<a name="ln1453">    i = -1;</a>
<a name="ln1454">    /* set kLeastForLayer[nLayer].k = (k+1) or -(k+1)</a>
<a name="ln1455">           kLeastForLayer[nLayer].i = iDiff</a>
<a name="ln1456">        if all the conditions are met:</a>
<a name="ln1457">        1) kLeastForLayer[nLayer].k = 0</a>
<a name="ln1458">        2) diff==0 for all layers &lt; nLayer</a>
<a name="ln1459"> </a>
<a name="ln1460">        sign:</a>
<a name="ln1461">        if the final diff &lt; 0 then kLeastForLayer[nLayer].k = -(k+1) else</a>
<a name="ln1462">        if the final diff &gt; 0 then kLeastForLayer[nLayer].k = +(k+1)</a>
<a name="ln1463"> </a>
<a name="ln1464">        k+1 instead of k takes into account k--; statememt above)</a>
<a name="ln1465"> </a>
<a name="ln1466">        meaning:</a>
<a name="ln1467">        ========</a>
<a name="ln1468">        abs(kLeastForLayer[nLayer].k) is the greatest level k at which</a>
<a name="ln1469">        difference at layer nLayer are zeroes of hidden by differences in smaller nLayer.</a>
<a name="ln1470">        </a>
<a name="ln1471">        &quot;Hidden by difference in smaller level&quot; means that nLayer of comparison</a>
<a name="ln1472">        has not been reached because the difference was discovered at a previous layer.</a>
<a name="ln1473"> </a>
<a name="ln1474">  </a>
<a name="ln1475">        Lambda vs zf_zeta comparison</a>
<a name="ln1476">        =============================================</a>
<a name="ln1477">        accept only diff == 0</a>
<a name="ln1478"> </a>
<a name="ln1479">        Lambda vs pzb_rho and pzb_rho_fix comparison</a>
<a name="ln1480">        =============================================</a>
<a name="ln1481">        Maintain kLeastForLayer[] and kLeastForLayerFix[]</a>
<a name="ln1482"> </a>
<a name="ln1483">        The algorithm provides that pzb_rho(m-1) &lt; pzb_rho(m) &lt;= pzb_rho_fix</a>
<a name="ln1484"> </a>
<a name="ln1485">        Definition: pzb_rho(m-1) &lt; pzb_rho(m) means that</a>
<a name="ln1486">        -----------------------------------------------</a>
<a name="ln1487">        pzb_rho(m-1)[nLayerCurr] == pzb_rho(m)[nLayerCurr] for nLayerCurr = 0..nLayerDiff-1</a>
<a name="ln1488">        pzb_rho(m-1)[nLayerDiff] &lt;  pzb_rho(m)[nLayerDiff]</a>
<a name="ln1489"> </a>
<a name="ln1490">        Definition: pzb_rho(m-1)[nLayerDiff] &lt;  pzb_rho(m)[nLayerDiff] means that</a>
<a name="ln1491">        -------------------------------------------------------------------------</a>
<a name="ln1492">        pzb_rho(m-1)[nLayerDiff][i]     == pzb_rho(m)[nLayerDiff][i] for i=0..iDdiff-1</a>
<a name="ln1493">        pzb_rho(m-1)[nLayerDiff][iDdiff] &lt; pzb_rho(m)[nLayerDiff][iDdiff]</a>
<a name="ln1494"> </a>
<a name="ln1495">        This defines nLayerDiff(pzb1, pzb2) where pszb1 = pzb_rho(a), pzb2=pzb_rho(b) (a&lt;b) or pzb_rho_fix</a>
<a name="ln1496">               and   iDdiff    (pzb1, pzb2).</a>
<a name="ln1497">        In case pzb_rho(m)[nLayerCurr] == pzb_rho_fix[nLayerCurr] for all non-NULL nLayerCurr in pzb_rho_fix,</a>
<a name="ln1498">           nLayerDiff(pzb_rho(m), pzb_rho_fix) = the first layer in pzb_rho(m) not present in pzb_rho_fix</a>
<a name="ln1499">           iDdiff    (pzb_rho(m), pzb_rho_fix) = -1</a>
<a name="ln1500">        Case when such a layer does not exist means program error</a>
<a name="ln1501"> </a>
<a name="ln1502">        Suppose L_rho = nLayerDiff(Lambda, pzb_rho(m))</a>
<a name="ln1503">                L_fix = nLayerDiff(Lambda, pzb_rho_fix)</a>
<a name="ln1504">                I_rho = iDdiff    (Lambda, pzb_rho(m))</a>
<a name="ln1505">                I_fix = iDdiff    (Lambda, pzb_rho_fix)</a>
<a name="ln1506">                kLeastForLayer determined from Lambda vs pzb_rho(m) comparison</a>
<a name="ln1507">        Then:</a>
<a name="ln1508"> </a>
<a name="ln1509">        1. Comparison Lambda vs pzb_rho_fix before reaching discrete partition</a>
<a name="ln1510">        ----------------------------------------------------------------------</a>
<a name="ln1511">        a)    0 &lt; abs(kLeastForLayerFix[L_fix].k) &lt;= k-1 (* in this case I_fix &gt;= 0 *)  &amp;&amp;</a>
<a name="ln1512">              ((L_fix &lt; L_rho) || (L_fix == L_rho &amp;&amp; I_fix &lt; I_rho))</a>
<a name="ln1513">              =&gt;</a>
<a name="ln1514">              qzb_rho_fix = kLeastForLayerFix[L_fix].k if prevoiusly qzb_rho_fix == 0</a>
<a name="ln1515"> </a>
<a name="ln1516">        b)    otherwise do not change qzb_rho_fix, except the following:</a>
<a name="ln1517"> </a>
<a name="ln1518">        c)    Special case L_rho == L_fix &amp;&amp; I_rho == I_fix. Let L=L_rho, I = I_rho.</a>
<a name="ln1519"> </a>
<a name="ln1520">              Compare 3 valirs: Lambda[L][I], pzb_rho(m)[L][I], pzb_rho_fix[L][I]</a>
<a name="ln1521">              The algorithm provides pzb_rho(m)[L][I] &lt; pzb_rho_fix[L][I]</a>
<a name="ln1522">              (pzb_rho(m)[L][I]==pzb_rho_fix[L][I] &lt;=&gt; pzb_rho(m)[L][I]==pzb_rho_fix[L][I] </a>
<a name="ln1523">               is impossible by construction)</a>
<a name="ln1524">              There are 3 possibilities:</a>
<a name="ln1525">              c1) Lambda[L][I]     &lt; pzb_rho(m)[L][I]  &lt; pzb_rho_fix[L][I] &lt;=&gt;</a>
<a name="ln1526">                  kLeastForLayer[L].k  &lt; 0 &amp;&amp; kLeastForLayerFix[L].k &lt; 0</a>
<a name="ln1527">                  =&gt; qzb_rho := kLeastForLayer[L].k, reject too small Lambda</a>
<a name="ln1528">              c2) pzb_rho(m)[L][I] &lt; Lambda[L][I]      &lt; pzb_rho_fix[L][I]</a>
<a name="ln1529">                  kLeastForLayer[L].k  &gt; 0 &amp;&amp; kLeastForLayerFix[L].k &lt; 0</a>
<a name="ln1530">                  =&gt; qzb_rho := kLeastForLayer[L].k, accept Lambda, rho:=nu</a>
<a name="ln1531">              c3) pzb_rho(m)[L][I] &lt; pzb_rho_fix[L][I] &lt; Lambda[L][I]</a>
<a name="ln1532">                  kLeastForLayer[L].k  &gt; 0 &amp;&amp; kLeastForLayerFix[L].k &gt; 0</a>
<a name="ln1533">                  =&gt; qzb_rho_fix := kLeastForLayerFix[L].k, reject too big Lambda</a>
<a name="ln1534"> </a>
<a name="ln1535">              Case</a>
<a name="ln1536">                  kLeastForLayer[L].k  &lt; 0 &amp;&amp; kLeastForLayerFix[L].k &gt; 0 is impossible</a>
<a name="ln1537">                  because it means</a>
<a name="ln1538">                  pzb_rho_fix &lt; Lambda &lt; pzb_rho(m) &lt;=&gt; pzb_rho_fix &lt; pzb_rho(m)</a>
<a name="ln1539"> </a>
<a name="ln1540"> </a>
<a name="ln1541">            Case (c3) occurs in case of (a)</a>
<a name="ln1542">            Case (c1) </a>
<a name="ln1543"> </a>
<a name="ln1544">        2. Comparison Lambda vs pzb_rho before reaching discrete partition</a>
<a name="ln1545">        ----------------------------------------------------------------------</a>
<a name="ln1546">        a) (L_rho &lt; L_fix) || (L_rho == L_fix &amp;&amp; I_rho &lt; I_fix)  =&gt;</a>
<a name="ln1547"> </a>
<a name="ln1548">           Lambda differs from pzb_rho(m) in the part of pzb_rho(m) that will never change</a>
<a name="ln1549">           qzb_rho = kLeastForLayer[L_rho].k; reject Labmda or accept pzb_rho(m+1):=Labmda</a>
<a name="ln1550"> </a>
<a name="ln1551">        b) (L_rho == L_fix &amp;&amp; I_rho &gt; I_fix) &amp;&amp; kLeastForLayer[L_rho].k &lt; 0</a>
<a name="ln1552">           Lambda &lt; pzb_rho(m), therefore</a>
<a name="ln1553">           qzb_rho = kLeastForLayer[L_rho].k; reject Labmda</a>
<a name="ln1554"> </a>
<a name="ln1555">        c) (L_rho &gt; L_fix) =&gt;</a>
<a name="ln1556">           qzb_rho := 0 because more significant difference may be discovered</a>
<a name="ln1557">           in layer &lt; L_rho later. The final comparison may be needed at the</a>
<a name="ln1558">           level of discrete partition.</a>
<a name="ln1559"> </a>
<a name="ln1560"> </a>
<a name="ln1561">    */</a>
<a name="ln1562"> </a>
<a name="ln1563">    if ( cmp ) {</a>
<a name="ln1564">        for ( i = 0; i &lt;= k &amp;&amp; !cmp[i]; i++ )</a>
<a name="ln1565">            ;</a>
<a name="ln1566">        if ( i &lt; k ) {</a>
<a name="ln1567">            cmp[k] = cmp[i];</a>
<a name="ln1568">            return (int)cmp[i];</a>
<a name="ln1569">        }</a>
<a name="ln1570">    }</a>
<a name="ln1571">    k1 = Ct1-&gt;lenPos-1;</a>
<a name="ln1572">    k2 = Ct2-&gt;lenPos-1;</a>
<a name="ln1573"> </a>
<a name="ln1574">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1575">    if ( k &gt; k1 || k &gt; k2 ) {</a>
<a name="ln1576">        int stop = 1;</a>
<a name="ln1577">    }</a>
<a name="ln1578">#endif</a>
<a name="ln1579">    diff = 0;</a>
<a name="ln1580"> </a>
<a name="ln1581">    if ( k ) {</a>
<a name="ln1582">        startCt1  = Ct1-&gt;nextCtblPos[k-1];</a>
<a name="ln1583">        startCt2  = Ct2-&gt;nextCtblPos[k-1];</a>
<a name="ln1584">        startAt1  = Ct1-&gt;nextAtRank[k-1]-1;</a>
<a name="ln1585">        startAt2  = Ct2-&gt;nextAtRank[k-1]-1;</a>
<a name="ln1586">    } else {</a>
<a name="ln1587">        startCt1 = startCt2 = 0;</a>
<a name="ln1588">        startAt1 = startAt2 = 0;</a>
<a name="ln1589">    }</a>
<a name="ln1590"> </a>
<a name="ln1591">    endCt1 = Ct1-&gt;nextCtblPos[k];</a>
<a name="ln1592">    endCt2 = Ct2-&gt;nextCtblPos[k];</a>
<a name="ln1593">    endAt1 = (int)Ct1-&gt;nextAtRank[k]-1;</a>
<a name="ln1594">    endAt2 = (int)Ct2-&gt;nextAtRank[k]-1;</a>
<a name="ln1595"> </a>
<a name="ln1596">    maxVert = inchi_min(Ct1-&gt;maxVert, Ct2-&gt;maxVert);</a>
<a name="ln1597"> </a>
<a name="ln1598">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln1599">    if ( !diff ) {</a>
<a name="ln1600">        if ( Ct1-&gt;hash[k] &gt; Ct2-&gt;hash[k] )</a>
<a name="ln1601">            diff = 1;</a>
<a name="ln1602">        else</a>
<a name="ln1603">        if ( Ct1-&gt;hash[k] &lt; Ct2-&gt;hash[k] )</a>
<a name="ln1604">            diff = -1;</a>
<a name="ln1605">    }</a>
<a name="ln1606">    if ( diff ) {</a>
<a name="ln1607">        goto done;</a>
<a name="ln1608">    }</a>
<a name="ln1609">#endif</a>
<a name="ln1610">    </a>
<a name="ln1611">    /************************** lengths **************************************************/</a>
<a name="ln1612">    if ( (diff = -(startCt1 - startCt2)) ) {</a>
<a name="ln1613">        /* comparing two INFINITY terminations */</a>
<a name="ln1614">        if ( bOnlyCommon &amp;&amp;</a>
<a name="ln1615">             startCt1 &gt;= Ct1-&gt;nLenCTAtOnly &amp;&amp; startCt2 &gt;= Ct2-&gt;nLenCTAtOnly &amp;&amp;</a>
<a name="ln1616">             Ct1-&gt;Ctbl[startCt1] == EMPTY_CT &amp;&amp; Ct2-&gt;Ctbl[startCt2] == EMPTY_CT ) {</a>
<a name="ln1617">            return 0;</a>
<a name="ln1618">        }</a>
<a name="ln1619">        if ( bOnlyCommon ) {</a>
<a name="ln1620">            startCt1 = startCt2 = inchi_min(startCt1, startCt2);</a>
<a name="ln1621">            startAt1 = startAt2 = inchi_min(startAt1, startAt2);</a>
<a name="ln1622">            if ( Ct1-&gt;lenCt == Ct2-&gt;lenCt ) {</a>
<a name="ln1623">                endCt1 = endCt2 = inchi_max(endCt1, endCt2);</a>
<a name="ln1624">                endAt1 = endAt2 = inchi_max(endAt1, endAt2);</a>
<a name="ln1625">            }</a>
<a name="ln1626">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1627">            else {</a>
<a name="ln1628">                int stop = 1;</a>
<a name="ln1629">            }</a>
<a name="ln1630">#endif</a>
<a name="ln1631">        } else</a>
<a name="ln1632">        /* comparing (taut tail) vs INFINITY termination -- ??? */</a>
<a name="ln1633">        if ( startCt1 &gt; startCt2 &amp;&amp;</a>
<a name="ln1634">             Ct1-&gt;maxVert &gt; Ct2-&gt;maxVert &amp;&amp;</a>
<a name="ln1635">             startAt2 == Ct2-&gt;maxVert ) {</a>
<a name="ln1636">            return 0;</a>
<a name="ln1637">        } else {</a>
<a name="ln1638">            goto done;</a>
<a name="ln1639">        }</a>
<a name="ln1640">    }</a>
<a name="ln1641">    </a>
<a name="ln1642">    lenNumH          = Ct1-&gt;lenNumH;</a>
<a name="ln1643">    len_iso_sort_key = Ct1-&gt;len_iso_sort_key;</a>
<a name="ln1644">    </a>
<a name="ln1645">    if ( (diff = -(endCt1 - endCt2)) ) { /* negative sign reproduces results for NSC=28393 */</a>
<a name="ln1646">        if ( bOnlyCommon ) {</a>
<a name="ln1647">            endCt1 = endCt2 = inchi_min(endCt1, endCt2);</a>
<a name="ln1648">            endAt1 = endAt2 = inchi_min(endAt1, endAt2);</a>
<a name="ln1649">            lenNumH = inchi_min(Ct1-&gt;lenNumH, Ct2-&gt;lenNumH);</a>
<a name="ln1650">            len_iso_sort_key = inchi_min(Ct1-&gt;len_iso_sort_key, Ct1-&gt;len_iso_sort_key);</a>
<a name="ln1651">        } else</a>
<a name="ln1652">        /* take care of case when comparing tautomeric vs non-tautomeric:</a>
<a name="ln1653">           since (taut)-&gt;maxVert &gt; (non-taut)-&gt;maxVert, --???</a>
<a name="ln1654">           (taut)-&gt;maxlenCt  &gt; (non-taut)-&gt;maxlenCt     --!!!</a>
<a name="ln1655">           compare up to min out of the two, ignoring INFINITY in the last position */</a>
<a name="ln1656">        if ( endCt1 &gt; endCt2 &amp;&amp; Ct1-&gt;maxlenCt &gt; Ct2-&gt;maxlenCt ) {</a>
<a name="ln1657">            if ( endAt2 == Ct2-&gt;maxVert + 1 ) {</a>
<a name="ln1658">                /* remove INFINITY termination of the shorter CT */</a>
<a name="ln1659">                /* should never happen */</a>
<a name="ln1660">                endAt2 --;</a>
<a name="ln1661">                len_iso_sort_key = lenNumH = endAt1 = endAt2;</a>
<a name="ln1662">                endCt2 --;</a>
<a name="ln1663">                endCt1 = endCt2;</a>
<a name="ln1664">                diff = 0;</a>
<a name="ln1665">            } else</a>
<a name="ln1666">            if ( endAt2 == Ct2-&gt;maxVert ) {</a>
<a name="ln1667">                /* remove INFINITY termination of CT */</a>
<a name="ln1668">                len_iso_sort_key = lenNumH = endAt1 = endAt2;</a>
<a name="ln1669">                endCt1 = endCt2;</a>
<a name="ln1670">                diff = 0;</a>
<a name="ln1671">            } else {</a>
<a name="ln1672">                goto done;</a>
<a name="ln1673">            }</a>
<a name="ln1674">        } else {</a>
<a name="ln1675">            goto done;</a>
<a name="ln1676">        }</a>
<a name="ln1677">    }</a>
<a name="ln1678">    </a>
<a name="ln1679">    if ( bSplitTautCompare ) {</a>
<a name="ln1680">        midCt = inchi_min(Ct1-&gt;nLenCTAtOnly, Ct2-&gt;nLenCTAtOnly);</a>
<a name="ln1681">        if ( midCt &gt; endCt1 ) {</a>
<a name="ln1682">            midCt = endCt1;</a>
<a name="ln1683">        }</a>
<a name="ln1684">        midAt = inchi_min(maxVert, endAt1); </a>
<a name="ln1685">    } else {</a>
<a name="ln1686">        midCt = endCt1;</a>
<a name="ln1687">        midAt = endAt1;</a>
<a name="ln1688">    }</a>
<a name="ln1689"> </a>
<a name="ln1690">    /*endCt   = min(endCt1, endCt2);*/</a>
<a name="ln1691">    /*************************************************************************/</a>
<a name="ln1692">    /************ layer 0: connection table without tautomeric groups ********/</a>
<a name="ln1693">    /*************************************************************************/</a>
<a name="ln1694">    for ( i = startCt1; i &lt; midCt &amp;&amp; Ct1-&gt;Ctbl[i] == Ct2-&gt;Ctbl[i]; i ++ )</a>
<a name="ln1695">    /*for ( i = startCt1; i &lt; endCt &amp;&amp; !(diff = (int)Ct1-&gt;Ctbl[i] - (int)Ct2-&gt;Ctbl[i]); i ++ )*/</a>
<a name="ln1696">        ;</a>
<a name="ln1697">    if ( i &lt; midCt ) {</a>
<a name="ln1698">        diff = (int)Ct1-&gt;Ctbl[i] - (int)Ct2-&gt;Ctbl[i];</a>
<a name="ln1699">        goto done;</a>
<a name="ln1700">    }</a>
<a name="ln1701">    /*************************************************************************/</a>
<a name="ln1702">    /******** layer 1 NumH: H atoms without tautomeric H *********************/</a>
<a name="ln1703">    /*************************************************************************/</a>
<a name="ln1704">    nLayer ++;</a>
<a name="ln1705">    /*============= check limits for consistency  ==========*/</a>
<a name="ln1706">    if ( (diff = -(startAt1 - startAt2)) ) {</a>
<a name="ln1707">        goto done;   /* should not happen */</a>
<a name="ln1708">    }</a>
<a name="ln1709">    if ( (diff = -(endAt1 - endAt2)) ) {</a>
<a name="ln1710">        goto done;   /* should not happen */</a>
<a name="ln1711">    }</a>
<a name="ln1712">    /*============= comparison =============================*/</a>
<a name="ln1713">    if ( Ct1-&gt;NumH &amp;&amp; Ct2-&gt;NumH ) {</a>
<a name="ln1714">        if ( endAt1 &lt; maxVert ) {</a>
<a name="ln1715">            midNumH = lenNumH = endAt1;</a>
<a name="ln1716">        } else</a>
<a name="ln1717">        if ( bSplitTautCompare ) {</a>
<a name="ln1718">            midNumH = maxVert;</a>
<a name="ln1719">        } else {</a>
<a name="ln1720">            midNumH = lenNumH;</a>
<a name="ln1721">        }</a>
<a name="ln1722">        /* lenNumH = (endAt2 &gt;= maxVert)? lenNumH : endAt2; */</a>
<a name="ln1723">        /* endAt1 = (endAt2 == n)? lenNumH : endAt2; */</a>
<a name="ln1724">        </a>
<a name="ln1725">        for ( i = startAt1; i &lt; midNumH &amp;&amp; Ct1-&gt;NumH[i] == Ct2-&gt;NumH[i]; i ++ )</a>
<a name="ln1726">            ;</a>
<a name="ln1727">        if ( i &lt; midNumH ) {</a>
<a name="ln1728">            diff = (int)Ct1-&gt;NumH[i] - (int)Ct2-&gt;NumH[i];</a>
<a name="ln1729">            goto done;</a>
<a name="ln1730">        }</a>
<a name="ln1731">    }</a>
<a name="ln1732">    /*************************************************************************/</a>
<a name="ln1733">    /************** layer 2: tautomeric part of CT and tautomeric H **********/</a>
<a name="ln1734">    /*************************************************************************/</a>
<a name="ln1735">    nLayer ++;</a>
<a name="ln1736">    for ( i = midCt; i &lt; endCt1 &amp;&amp; Ct1-&gt;Ctbl[i] == Ct2-&gt;Ctbl[i]; i ++ )</a>
<a name="ln1737">        ; /* compare tautomeric groups part of CT */</a>
<a name="ln1738">    if ( i &lt; endCt1 ) {</a>
<a name="ln1739">        diff = (int)Ct1-&gt;Ctbl[i] - (int)Ct2-&gt;Ctbl[i];</a>
<a name="ln1740">        goto done;</a>
<a name="ln1741">    }</a>
<a name="ln1742">    if ( Ct1-&gt;NumH &amp;&amp; Ct2-&gt;NumH ) {</a>
<a name="ln1743">        for ( i = midNumH; i &lt; lenNumH &amp;&amp; Ct1-&gt;NumH[i] == Ct2-&gt;NumH[i]; i ++ )</a>
<a name="ln1744">            ; /* compare tautomeric H */</a>
<a name="ln1745">        if ( i &lt; lenNumH ) {</a>
<a name="ln1746">            diff = (int)Ct1-&gt;NumH[i] - (int)Ct2-&gt;NumH[i];</a>
<a name="ln1747">            i += endCt1 - midCt;</a>
<a name="ln1748">            goto done;</a>
<a name="ln1749">        }</a>
<a name="ln1750">    }</a>
<a name="ln1751">    /*************************************************************************/</a>
<a name="ln1752">    /************** layer 3: Fixed H atoms ***********************************/</a>
<a name="ln1753">    /*************************************************************************/</a>
<a name="ln1754">    nLayer ++;</a>
<a name="ln1755">    if ( Ct1-&gt;NumHfixed &amp;&amp; Ct2-&gt;NumHfixed ) {</a>
<a name="ln1756">        for ( i = startAt1; i &lt; midAt &amp;&amp; Ct1-&gt;NumHfixed[i] == Ct2-&gt;NumHfixed[i]; i ++ )</a>
<a name="ln1757">            ;</a>
<a name="ln1758">        if ( i &lt; midAt ) {</a>
<a name="ln1759">            diff = (int)Ct1-&gt;NumHfixed[i] - (int)Ct2-&gt;NumHfixed[i];</a>
<a name="ln1760">            goto done;</a>
<a name="ln1761">        }</a>
<a name="ln1762">    }</a>
<a name="ln1763">    /*************************************************************************/</a>
<a name="ln1764">    /************** layer 4: isotopic atoms H, incl. tautomeric **************/</a>
<a name="ln1765">    /*************************************************************************/</a>
<a name="ln1766">    nLayer ++;</a>
<a name="ln1767">    if ( Ct1-&gt;iso_sort_key &amp;&amp; Ct2-&gt;iso_sort_key ) {</a>
<a name="ln1768">        for ( i = startAt1; i &lt; endAt1 &amp;&amp; Ct1-&gt;iso_sort_key[i] == Ct2-&gt;iso_sort_key[i]; i ++ )</a>
<a name="ln1769">            ;</a>
<a name="ln1770">        if ( i &lt; endAt1 ) {</a>
<a name="ln1771">            diff = Ct1-&gt;iso_sort_key[i] &gt; Ct2-&gt;iso_sort_key[i]? 1:-1;</a>
<a name="ln1772">            goto done;</a>
<a name="ln1773">        }</a>
<a name="ln1774">    }</a>
<a name="ln1775">    if ( Ct1-&gt;iso_exchg_atnos &amp;&amp; Ct2-&gt;len_iso_exchg_atnos ) {</a>
<a name="ln1776">        for ( i = startAt1; i &lt; endAt1 &amp;&amp; Ct1-&gt;iso_exchg_atnos[i] == Ct2-&gt;iso_exchg_atnos[i]; i ++ )</a>
<a name="ln1777">            ;</a>
<a name="ln1778">        if ( i &lt; endAt1 ) {</a>
<a name="ln1779">            diff = Ct1-&gt;iso_exchg_atnos[i] &gt; Ct2-&gt;iso_exchg_atnos[i]? 1:-1;</a>
<a name="ln1780">            goto done;</a>
<a name="ln1781">        }</a>
<a name="ln1782">    }</a>
<a name="ln1783">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln1784">    /*************************************************************************/</a>
<a name="ln1785">    /************** layer 6: Fixed isotopic H atoms **************************/</a>
<a name="ln1786">    /*************************************************************************/</a>
<a name="ln1787">    nLayer ++;</a>
<a name="ln1788">    if ( Ct1-&gt;iso_sort_key_Hfixed &amp;&amp; Ct2-&gt;iso_sort_key_Hfixed ) {</a>
<a name="ln1789">        for ( i = startAt1; i &lt; midAt &amp;&amp; Ct1-&gt;iso_sort_key_Hfixed[i] == Ct2-&gt;iso_sort_key_Hfixed[i]; i ++ )</a>
<a name="ln1790">            ;</a>
<a name="ln1791">        if ( i &lt; midAt ) {</a>
<a name="ln1792">            diff = Ct1-&gt;iso_sort_key_Hfixed[i] &gt; Ct2-&gt;iso_sort_key_Hfixed[i]? 1:-1;</a>
<a name="ln1793">            goto done;</a>
<a name="ln1794">        }</a>
<a name="ln1795">    }</a>
<a name="ln1796">#endif</a>
<a name="ln1797"> </a>
<a name="ln1798">done:</a>
<a name="ln1799">#ifdef INCHI_CANON_MIN</a>
<a name="ln1800">    diff = -diff;</a>
<a name="ln1801">#endif</a>
<a name="ln1802"> </a>
<a name="ln1803">    if ( diff ) {</a>
<a name="ln1804">        diff = (diff &gt; 0)? (nLayer+1) : -(nLayer+1); /* return the discovered difference layer number &gt;= 1 */</a>
<a name="ln1805">        if ( kLeastForLayer ) {</a>
<a name="ln1806">#if ( bRELEASE_VERSION != 1 )</a>
<a name="ln1807">            if ( abs(kLeastForLayer[nLayer].k) &gt; k+1 ) { /* for debug only */</a>
<a name="ln1808">                int stop = 1; /* &lt;BRKPT&gt; */</a>
<a name="ln1809">            }</a>
<a name="ln1810">#endif</a>
<a name="ln1811">            if ( !kLeastForLayer[nLayer].k ) {</a>
<a name="ln1812">                kLeastForLayer[nLayer].k = (diff &gt; 0)? (k+1) : -(k+1);</a>
<a name="ln1813">                kLeastForLayer[nLayer].i = i;</a>
<a name="ln1814">            }</a>
<a name="ln1815">            if ( nLayer /* &amp;&amp; !bOnlyCommon */) {</a>
<a name="ln1816">                diff = 0;</a>
<a name="ln1817">            }</a>
<a name="ln1818">        }</a>
<a name="ln1819">    }</a>
<a name="ln1820">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln1821">    else {</a>
<a name="ln1822">        int stop = 1;  /* for debug only */</a>
<a name="ln1823">    }</a>
<a name="ln1824">#endif</a>
<a name="ln1825">    if ( cmp ) {</a>
<a name="ln1826">        cmp[k] = (diff &gt; 0)? 1 : (diff &lt; 0)? -1 : 0;</a>
<a name="ln1827">    }</a>
<a name="ln1828">    return diff;</a>
<a name="ln1829">}</a>
<a name="ln1830">/**************************************************************************************************************/</a>
<a name="ln1831">int CtFullCompare( ConTable *Ct1, ConTable *Ct2, int bOnlyCommon, int bSplitTautCompare )</a>
<a name="ln1832">{</a>
<a name="ln1833">    int     startCt1, endCt1, startCt2, endCt2; /*endCt,*/</a>
<a name="ln1834">    int     startAt1, endAt1, startAt2, endAt2; /*endCt,*/</a>
<a name="ln1835">    int     midCt   /* end of atoms only in Ctbl */,</a>
<a name="ln1836">            midNumH = 0 /* end of atoms only NumH */,</a>
<a name="ln1837">            midAt   /* end of atoms only */;</a>
<a name="ln1838">    int     diff, i, k1, k2, lenNumH1, lenNumH2, lenNumH, maxVert /* min num atoms */;</a>
<a name="ln1839">    int     len_iso_sort_key1, len_iso_sort_key2, len_iso_sort_key /*, mid_iso_sort_key*/;</a>
<a name="ln1840">    int     nLayer = 0;</a>
<a name="ln1841"> </a>
<a name="ln1842">    k1 = Ct1-&gt;lenPos-1;</a>
<a name="ln1843">    k2 = Ct2-&gt;lenPos-1;</a>
<a name="ln1844"> </a>
<a name="ln1845">    diff = 0;</a>
<a name="ln1846"> </a>
<a name="ln1847">    startCt1 = startCt2 = 0;</a>
<a name="ln1848">    startAt1 = startAt2 = 0;</a>
<a name="ln1849"> </a>
<a name="ln1850">    endCt1 = Ct1-&gt;nextCtblPos[k1];</a>
<a name="ln1851">    endCt2 = Ct2-&gt;nextCtblPos[k2];</a>
<a name="ln1852">    endAt1 = (int)Ct1-&gt;nextAtRank[k1]-1;</a>
<a name="ln1853">    endAt2 = (int)Ct2-&gt;nextAtRank[k2]-1;</a>
<a name="ln1854"> </a>
<a name="ln1855">    maxVert = inchi_min(Ct1-&gt;maxVert, Ct2-&gt;maxVert);</a>
<a name="ln1856"> </a>
<a name="ln1857">    if ( bOnlyCommon ) {</a>
<a name="ln1858">        endCt1 = inchi_min(endCt1, endCt2);</a>
<a name="ln1859">        endCt1 = endCt2 = inchi_min(endCt1, Ct1-&gt;lenCt);</a>
<a name="ln1860">        endAt1 = endAt2 = inchi_min(endAt1, endAt2);</a>
<a name="ln1861">        if ( Ct1-&gt;Ctbl[endCt1] == EMPTY_CT || Ct1-&gt;Ctbl[endCt1] == 0 ||</a>
<a name="ln1862">             Ct2-&gt;Ctbl[endCt1] == EMPTY_CT || Ct2-&gt;Ctbl[endCt1] == 0 ) {</a>
<a name="ln1863">            endCt1 = endCt2 = endCt1-1;</a>
<a name="ln1864">        }</a>
<a name="ln1865">        lenNumH  =</a>
<a name="ln1866">        lenNumH1 =</a>
<a name="ln1867">        lenNumH2 = inchi_min(Ct1-&gt;lenNumH, Ct2-&gt;lenNumH);</a>
<a name="ln1868">        len_iso_sort_key  =</a>
<a name="ln1869">        len_iso_sort_key1 =</a>
<a name="ln1870">        len_iso_sort_key2 = inchi_min(Ct1-&gt;len_iso_sort_key, Ct1-&gt;len_iso_sort_key);</a>
<a name="ln1871">    } else {</a>
<a name="ln1872">        if ( Ct1-&gt;Ctbl[endCt1-1] == EMPTY_CT ) {</a>
<a name="ln1873">            endCt1 --;</a>
<a name="ln1874">        }</a>
<a name="ln1875">        if ( Ct2-&gt;Ctbl[endCt2-1] == EMPTY_CT ) {</a>
<a name="ln1876">            endCt2 --;</a>
<a name="ln1877">        }</a>
<a name="ln1878">        lenNumH1          = Ct1-&gt;lenNumH;</a>
<a name="ln1879">        lenNumH2          = Ct2-&gt;lenNumH;</a>
<a name="ln1880">        lenNumH           = inchi_min(lenNumH1, lenNumH2);</a>
<a name="ln1881">        len_iso_sort_key1 = Ct1-&gt;len_iso_sort_key;</a>
<a name="ln1882">        len_iso_sort_key2 = Ct2-&gt;len_iso_sort_key;</a>
<a name="ln1883">        len_iso_sort_key  = inchi_min(len_iso_sort_key1, len_iso_sort_key2);</a>
<a name="ln1884">    }</a>
<a name="ln1885"> </a>
<a name="ln1886">    if ( (diff = -(endCt1 - endCt2)) ) { /* negative sign reproduces results for NSC=28393 */</a>
<a name="ln1887">        goto done;</a>
<a name="ln1888">    }</a>
<a name="ln1889">    </a>
<a name="ln1890">    if ( bSplitTautCompare ) {</a>
<a name="ln1891">        midCt = inchi_min(Ct1-&gt;nLenCTAtOnly, Ct2-&gt;nLenCTAtOnly);</a>
<a name="ln1892">        if ( midCt &gt; endCt1 ) {</a>
<a name="ln1893">            midCt = endCt1;</a>
<a name="ln1894">        }</a>
<a name="ln1895">        midAt = inchi_min(maxVert, endAt1);</a>
<a name="ln1896">    } else {</a>
<a name="ln1897">        midCt = endCt1;</a>
<a name="ln1898">        midAt = endAt1;</a>
<a name="ln1899">    }</a>
<a name="ln1900"> </a>
<a name="ln1901">    /*************************************************************************/</a>
<a name="ln1902">    /************ layer 0: connection table without tautomeric groups ********/</a>
<a name="ln1903">    /*************************************************************************/</a>
<a name="ln1904">    for ( i = startCt1; i &lt; midCt &amp;&amp; Ct1-&gt;Ctbl[i] == Ct2-&gt;Ctbl[i]; i ++ )</a>
<a name="ln1905">        ;</a>
<a name="ln1906">    if ( i &lt; midCt ) {</a>
<a name="ln1907">        diff = (int)Ct1-&gt;Ctbl[i] - (int)Ct2-&gt;Ctbl[i];</a>
<a name="ln1908">        goto done;</a>
<a name="ln1909">    }</a>
<a name="ln1910">    /*************************************************************************/</a>
<a name="ln1911">    /************* layer 1: H atoms without tautomeric H *********************/</a>
<a name="ln1912">    /*************************************************************************/</a>
<a name="ln1913">    nLayer ++;</a>
<a name="ln1914">    if ( Ct1-&gt;NumH &amp;&amp; Ct2-&gt;NumH ) {</a>
<a name="ln1915">        if ( (diff = -(lenNumH1 - lenNumH2)) ) { /* negative sign reproduces results for NSC=28393 */</a>
<a name="ln1916">            goto done;</a>
<a name="ln1917">        }</a>
<a name="ln1918">        if ( endAt1 &lt; maxVert ) {</a>
<a name="ln1919">            midNumH = lenNumH1 = endAt1;</a>
<a name="ln1920">        } else</a>
<a name="ln1921">        if ( bSplitTautCompare ) {</a>
<a name="ln1922">            midNumH = maxVert;</a>
<a name="ln1923">        } else {</a>
<a name="ln1924">            midNumH = lenNumH1;</a>
<a name="ln1925">        }</a>
<a name="ln1926">        for ( i = startAt1; i &lt; midNumH &amp;&amp; Ct1-&gt;NumH[i] == Ct2-&gt;NumH[i]; i ++ )</a>
<a name="ln1927">            ;</a>
<a name="ln1928">        if ( i &lt; midNumH ) {</a>
<a name="ln1929">            diff = (int)Ct1-&gt;NumH[i] - (int)Ct2-&gt;NumH[i];</a>
<a name="ln1930">            goto done;</a>
<a name="ln1931">        }</a>
<a name="ln1932">    }</a>
<a name="ln1933">    /*************************************************************************/</a>
<a name="ln1934">    /************** layer 2: tautomeric part of CT and tautomeric H **********/</a>
<a name="ln1935">    /*************************************************************************/</a>
<a name="ln1936">    nLayer ++;</a>
<a name="ln1937">    for ( i = midCt; i &lt; endCt1 &amp;&amp; Ct1-&gt;Ctbl[i] == Ct2-&gt;Ctbl[i]; i ++ )</a>
<a name="ln1938">        ; /* compare tautomeric groups part of CT */</a>
<a name="ln1939">    if ( i &lt; endCt1 ) {</a>
<a name="ln1940">        diff = (int)Ct1-&gt;Ctbl[i] - (int)Ct2-&gt;Ctbl[i];</a>
<a name="ln1941">        goto done;</a>
<a name="ln1942">    }</a>
<a name="ln1943">    if ( Ct1-&gt;NumH &amp;&amp; Ct2-&gt;NumH ) {</a>
<a name="ln1944">        for ( i = midNumH; i &lt; lenNumH1 &amp;&amp; Ct1-&gt;NumH[i] == Ct2-&gt;NumH[i]; i ++ )</a>
<a name="ln1945">            ; /* compare tautomeric H */</a>
<a name="ln1946">        if ( i &lt; lenNumH1 ) {</a>
<a name="ln1947">            diff = (int)Ct1-&gt;NumH[i] - (int)Ct2-&gt;NumH[i];</a>
<a name="ln1948">            goto done;</a>
<a name="ln1949">        }</a>
<a name="ln1950">    }</a>
<a name="ln1951">    /*************************************************************************/</a>
<a name="ln1952">    /************** layer 3: Fixed H atoms ***********************************/</a>
<a name="ln1953">    /*************************************************************************/</a>
<a name="ln1954">    nLayer ++;</a>
<a name="ln1955">    if ( Ct1-&gt;NumHfixed &amp;&amp; Ct2-&gt;NumHfixed ) {</a>
<a name="ln1956">        for ( i = startAt1; i &lt; endAt1 &amp;&amp; Ct1-&gt;NumHfixed[i] == Ct2-&gt;NumHfixed[i]; i ++ )</a>
<a name="ln1957">            ;</a>
<a name="ln1958">        if ( i &lt; endAt1 ) {</a>
<a name="ln1959">            diff = (int)Ct1-&gt;NumHfixed[i] - (int)Ct2-&gt;NumHfixed[i];</a>
<a name="ln1960">            goto done;</a>
<a name="ln1961">        }</a>
<a name="ln1962">    }</a>
<a name="ln1963">    /*************************************************************************/</a>
<a name="ln1964">    /************** layer 4: isotopic atoms, H and isotopic taut H ***********/</a>
<a name="ln1965">    /*************************************************************************/</a>
<a name="ln1966">    nLayer ++;</a>
<a name="ln1967">    if ( Ct1-&gt;iso_sort_key &amp;&amp; Ct2-&gt;iso_sort_key ) {</a>
<a name="ln1968">        if ( (diff = -(len_iso_sort_key1 - len_iso_sort_key2)) ) { /* negative sign reproduces results for NSC=28393 */</a>
<a name="ln1969">            goto done;</a>
<a name="ln1970">        }</a>
<a name="ln1971">        for ( i = startAt1; i &lt; endAt1 &amp;&amp; Ct1-&gt;iso_sort_key[i] == Ct2-&gt;iso_sort_key[i]; i ++ )</a>
<a name="ln1972">            ;</a>
<a name="ln1973">        if ( i &lt; endAt1 ) {</a>
<a name="ln1974">            diff = Ct1-&gt;iso_sort_key[i] &gt; Ct2-&gt;iso_sort_key[i]? 1:-1;</a>
<a name="ln1975">            goto done;</a>
<a name="ln1976">        }</a>
<a name="ln1977">    }</a>
<a name="ln1978">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln1979">    /*************************************************************************/</a>
<a name="ln1980">    /************** layer 6: Fixed isotopic H atoms **************************/</a>
<a name="ln1981">    /*************************************************************************/</a>
<a name="ln1982">    nLayer ++;</a>
<a name="ln1983">    if ( Ct1-&gt;iso_sort_key_Hfixed &amp;&amp; Ct2-&gt;iso_sort_key_Hfixed ) {</a>
<a name="ln1984">        for ( i = startAt1; i &lt; midAt &amp;&amp; Ct1-&gt;iso_sort_key_Hfixed[i] == Ct2-&gt;iso_sort_key_Hfixed[i]; i ++ )</a>
<a name="ln1985">            ;</a>
<a name="ln1986">        if ( i &lt; midAt ) {</a>
<a name="ln1987">            diff = Ct1-&gt;iso_sort_key_Hfixed[i] &gt; Ct2-&gt;iso_sort_key_Hfixed[i]? 1:-1;</a>
<a name="ln1988">            goto done;</a>
<a name="ln1989">        }</a>
<a name="ln1990">    }</a>
<a name="ln1991">#endif</a>
<a name="ln1992"> </a>
<a name="ln1993">done:</a>
<a name="ln1994">#ifdef INCHI_CANON_MIN</a>
<a name="ln1995">    diff = -diff;</a>
<a name="ln1996">#endif</a>
<a name="ln1997"> </a>
<a name="ln1998">    if ( diff ) {</a>
<a name="ln1999">        diff = (diff &gt; 0)? (nLayer+1) : -(nLayer+1); /* return the discovered difference layer number &gt;= 1 */</a>
<a name="ln2000">    }</a>
<a name="ln2001">    return diff;</a>
<a name="ln2002">}</a>
<a name="ln2003">/****************************************************************/</a>
<a name="ln2004">int CtFullCompareLayers( kLeast *kLeastForLayer )</a>
<a name="ln2005">{</a>
<a name="ln2006">    int iLayer;</a>
<a name="ln2007">    /* check for the rejection condition: Lambda &gt; zb_rho_fix */</a>
<a name="ln2008">    for ( iLayer = 0; iLayer &lt; MAX_LAYERS; iLayer ++ ) {</a>
<a name="ln2009">        if ( kLeastForLayer[iLayer].k ) {</a>
<a name="ln2010">            return (kLeastForLayer[iLayer].k &gt; 0)? (iLayer+1) : -(iLayer+1);</a>
<a name="ln2011">        }</a>
<a name="ln2012">    }</a>
<a name="ln2013">    return 0;</a>
<a name="ln2014">}</a>
<a name="ln2015">/**************************************************************/</a>
<a name="ln2016">int CtCompareLayersGetFirstDiff( kLeast *kLeast_rho, int nOneAdditionalLayer,</a>
<a name="ln2017">                                 int *L_rho, int *I_rho, int *k_rho )</a>
<a name="ln2018">{</a>
<a name="ln2019">    int iLayer;</a>
<a name="ln2020">    if ( kLeast_rho ) {</a>
<a name="ln2021">        for ( iLayer = 0; iLayer &lt; MAX_LAYERS; iLayer ++ ) {</a>
<a name="ln2022">            if ( kLeast_rho[iLayer].k ) {</a>
<a name="ln2023">                *L_rho = iLayer;</a>
<a name="ln2024">                *I_rho = kLeast_rho[iLayer].i;</a>
<a name="ln2025">                *k_rho = kLeast_rho[iLayer].k;</a>
<a name="ln2026">                break;</a>
<a name="ln2027">            }</a>
<a name="ln2028">        }</a>
<a name="ln2029">        if ( iLayer == MAX_LAYERS ) {</a>
<a name="ln2030">            if ( nOneAdditionalLayer ) {</a>
<a name="ln2031">                *L_rho = nOneAdditionalLayer;  /* ??? subtract 1 ??? */</a>
<a name="ln2032">                *I_rho = -1;</a>
<a name="ln2033">                *k_rho =  0;</a>
<a name="ln2034">                return 0; /* difference may be in the first additional layer */</a>
<a name="ln2035">            } else {</a>
<a name="ln2036">                *L_rho = INFINITY;</a>
<a name="ln2037">                *I_rho = -1;</a>
<a name="ln2038">                *k_rho =  0;</a>
<a name="ln2039">                return 0; /* no difference found */</a>
<a name="ln2040">            }</a>
<a name="ln2041">        } else {</a>
<a name="ln2042">            return 1; /* difference in a real layer */</a>
<a name="ln2043">        }</a>
<a name="ln2044">    } else {</a>
<a name="ln2045">        return -1; /* no input, should not happen */</a>
<a name="ln2046">    }</a>
<a name="ln2047">}</a>
<a name="ln2048">/**************************************************************/</a>
<a name="ln2049">int CtPartCompareLayers( kLeast *kLeast_rho, int L_rho_fix_prev, int nOneAdditionalLayer )</a>
<a name="ln2050">{</a>
<a name="ln2051">    int L_rho, I_rho, k_rho;</a>
<a name="ln2052">    if ( 0 &lt; CtCompareLayersGetFirstDiff( kLeast_rho, nOneAdditionalLayer, &amp;L_rho, &amp;I_rho, &amp;k_rho ) &amp;&amp;</a>
<a name="ln2053">         /* differences has been found in a real layer or all real layers are identical */</a>
<a name="ln2054">         L_rho &lt;= L_rho_fix_prev ) {</a>
<a name="ln2055">         /* in this layer pzb_rho == pzb_rho_fix or in the previous real layer */</a>
<a name="ln2056">        return k_rho &gt; 0? (L_rho+1) : -(L_rho+1);</a>
<a name="ln2057">    }</a>
<a name="ln2058">    return 0;</a>
<a name="ln2059">}</a>
<a name="ln2060">/****************************************************************/</a>
<a name="ln2061">void UpdateCompareLayers( kLeast kLeastForLayer[], int hzz )</a>
<a name="ln2062">{</a>
<a name="ln2063">    int i;</a>
<a name="ln2064">    if ( kLeastForLayer ) {</a>
<a name="ln2065">        for ( i = 0; i &lt; MAX_LAYERS; i ++ ) {</a>
<a name="ln2066">            if ( abs(kLeastForLayer[i].k) &gt;= hzz ) {</a>
<a name="ln2067">                kLeastForLayer[i].k = 0;</a>
<a name="ln2068">                kLeastForLayer[i].i = 0;</a>
<a name="ln2069">            }</a>
<a name="ln2070">        }                                          </a>
<a name="ln2071">    }</a>
<a name="ln2072">}</a>
<a name="ln2073">    </a>
<a name="ln2074">/****************************************************************/</a>
<a name="ln2075">void CtPartCopy( ConTable *Ct1 /* to */, ConTable *Ct2 /* from */, int k )</a>
<a name="ln2076">{</a>
<a name="ln2077">    int     startCt1, startCt2, endCt1, endCt2;</a>
<a name="ln2078">    int     len2, len2H, len2Hfixed, len2iso_sort_key, len2iso_exchg_atnos, i;</a>
<a name="ln2079">    int     startAt1, endAt1, startAt2, endAt2; /*endCt,*/</a>
<a name="ln2080">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln2081">    int     len2iso_sort_key_Hfixed;</a>
<a name="ln2082">#endif</a>
<a name="ln2083">    k --;</a>
<a name="ln2084">    if ( k ) {</a>
<a name="ln2085">        startCt1  = Ct1-&gt;nextCtblPos[k-1];</a>
<a name="ln2086">        startCt2  = Ct2-&gt;nextCtblPos[k-1];</a>
<a name="ln2087">        startAt1  = Ct1-&gt;nextAtRank[k-1]-1;</a>
<a name="ln2088">        startAt2  = Ct2-&gt;nextAtRank[k-1]-1;</a>
<a name="ln2089">    } else {</a>
<a name="ln2090">        startCt1 = startCt2 = 0;</a>
<a name="ln2091">        startAt1 = startAt2 = 0;</a>
<a name="ln2092">    }</a>
<a name="ln2093"> </a>
<a name="ln2094">    endCt1 = Ct1-&gt;nextCtblPos[k];</a>
<a name="ln2095">    endCt2 = Ct2-&gt;nextCtblPos[k];</a>
<a name="ln2096">    endAt1 = (int)Ct1-&gt;nextAtRank[k]-1;</a>
<a name="ln2097">    endAt2 = (int)Ct2-&gt;nextAtRank[k]-1;</a>
<a name="ln2098"> </a>
<a name="ln2099">    len2   = endCt2-startCt2;</a>
<a name="ln2100">    /* len    = min(len1, len2); */</a>
<a name="ln2101">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2102">    if ( startCt1 != startCt2 || startAt1 != startAt2  ) {</a>
<a name="ln2103">        int stop = 1;</a>
<a name="ln2104">    }</a>
<a name="ln2105">#endif</a>
<a name="ln2106"> </a>
<a name="ln2107">    /* copy connection table: Ctbl */</a>
<a name="ln2108">    for ( i = 0; i &lt; len2; i ++ ) {</a>
<a name="ln2109">        Ct1-&gt;Ctbl[startCt1+i] = Ct2-&gt;Ctbl[startCt2+i];</a>
<a name="ln2110">    }</a>
<a name="ln2111">    /* copy number of H: NumH */</a>
<a name="ln2112">    len2H = 0;</a>
<a name="ln2113">    if ( Ct1-&gt;NumH &amp;&amp; Ct2-&gt;NumH ) {</a>
<a name="ln2114">        len2H   = endAt2-startAt2;</a>
<a name="ln2115">        if ( endAt2 &gt; Ct2-&gt;maxVert ) {</a>
<a name="ln2116">            len2H = Ct2-&gt;lenNumH - startAt2;</a>
<a name="ln2117">        }</a>
<a name="ln2118">        for ( i = 0; i &lt; len2H; i ++ ) {</a>
<a name="ln2119">            Ct1-&gt;NumH[startAt1+i] = Ct2-&gt;NumH[startAt2+i];</a>
<a name="ln2120">        }</a>
<a name="ln2121">    }</a>
<a name="ln2122">    /* copy number of fixed H */</a>
<a name="ln2123">    len2Hfixed = 0;</a>
<a name="ln2124">    if ( Ct1-&gt;NumHfixed &amp;&amp; Ct2-&gt;NumHfixed ) {</a>
<a name="ln2125">        len2Hfixed   = endAt2-startAt2;</a>
<a name="ln2126">        for ( i = 0; i &lt; len2Hfixed; i ++ ) {</a>
<a name="ln2127">            Ct1-&gt;NumHfixed[startAt1+i] = Ct2-&gt;NumHfixed[startAt2+i];</a>
<a name="ln2128">        }</a>
<a name="ln2129">    }</a>
<a name="ln2130">    /* copy isotopic keys */</a>
<a name="ln2131">    len2iso_sort_key = 0;</a>
<a name="ln2132">    if ( Ct1-&gt;iso_sort_key &amp;&amp; Ct2-&gt;iso_sort_key ) {</a>
<a name="ln2133">        len2iso_sort_key = endAt2-startAt2;</a>
<a name="ln2134">        for ( i = 0; i &lt; len2iso_sort_key; i ++ ) {</a>
<a name="ln2135">            Ct1-&gt;iso_sort_key[startAt1+i] = Ct2-&gt;iso_sort_key[startAt2+i];</a>
<a name="ln2136">        }</a>
<a name="ln2137">    }</a>
<a name="ln2138">    len2iso_exchg_atnos = 0;</a>
<a name="ln2139">    if ( Ct1-&gt;iso_exchg_atnos &amp;&amp; Ct2-&gt;iso_exchg_atnos ) {</a>
<a name="ln2140">        len2iso_exchg_atnos = endAt2-startAt2;</a>
<a name="ln2141">        for ( i = 0; i &lt; len2iso_exchg_atnos; i ++ ) {</a>
<a name="ln2142">            Ct1-&gt;iso_exchg_atnos[startAt1+i] = Ct2-&gt;iso_exchg_atnos[startAt2+i];</a>
<a name="ln2143">        }</a>
<a name="ln2144">    }</a>
<a name="ln2145">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln2146">    len2iso_sort_key_Hfixed = 0;</a>
<a name="ln2147">    if ( Ct1-&gt;iso_sort_key_Hfixed &amp;&amp; Ct2-&gt;iso_sort_key_Hfixed ) {</a>
<a name="ln2148">        len2iso_sort_key_Hfixed = endAt2-startAt2;</a>
<a name="ln2149">        for ( i = 0; i &lt; len2iso_sort_key; i ++ ) {</a>
<a name="ln2150">            Ct1-&gt;iso_sort_key_Hfixed[startAt1+i] = Ct2-&gt;iso_sort_key_Hfixed[startAt2+i];</a>
<a name="ln2151">        }</a>
<a name="ln2152">    }</a>
<a name="ln2153">#endif</a>
<a name="ln2154">    Ct1-&gt;lenCt          = startCt1 + len2;</a>
<a name="ln2155">    Ct1-&gt;nextCtblPos[k] = startCt1 + len2;</a>
<a name="ln2156">    Ct1-&gt;nextAtRank[k]  = Ct2-&gt;nextAtRank[k];</a>
<a name="ln2157">    if ( len2H ) {</a>
<a name="ln2158">        Ct1-&gt;lenNumH        = startAt1 + len2H;</a>
<a name="ln2159">    }</a>
<a name="ln2160">    /*</a>
<a name="ln2161">    if ( len2Hfixed ) {</a>
<a name="ln2162">        Ct1-&gt;lenNumHfixed   = startAt1 + len2Hfixed;</a>
<a name="ln2163">    }</a>
<a name="ln2164">    */</a>
<a name="ln2165">    if ( len2iso_sort_key ) {</a>
<a name="ln2166">        Ct1-&gt;len_iso_sort_key = startAt1 + len2iso_sort_key;</a>
<a name="ln2167">    }</a>
<a name="ln2168">    if ( len2iso_exchg_atnos ) {</a>
<a name="ln2169">        Ct1-&gt;len_iso_exchg_atnos = startAt1 + len2iso_exchg_atnos;</a>
<a name="ln2170">    }</a>
<a name="ln2171"> </a>
<a name="ln2172">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln2173">    if ( len2iso_sort_key_Hfixed ) {</a>
<a name="ln2174">        Ct1-&gt;len_iso_sort_key_Hfixed = startAt1 + len2iso_sort_key_Hfixed;</a>
<a name="ln2175">    }</a>
<a name="ln2176">#endif</a>
<a name="ln2177">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln2178">    Ct1-&gt;hash[k]        = Ct2-&gt;hash[k];</a>
<a name="ln2179">#endif</a>
<a name="ln2180">    Ct1-&gt;lenPos         = k+1;</a>
<a name="ln2181">    INCHI_HEAPCHK</a>
<a name="ln2182">}</a>
<a name="ln2183">/****************************************************************/</a>
<a name="ln2184">void CtFullCopy( ConTable *Ct1, ConTable *Ct2 )</a>
<a name="ln2185">{</a>
<a name="ln2186">    /* Ct1 does not have INFINITY termination */</a>
<a name="ln2187">    int k;</a>
<a name="ln2188">    for ( k = 0; k &lt; Ct2-&gt;lenPos; k ++ ) {</a>
<a name="ln2189">        CtPartCopy( Ct1 /* to */, Ct2 /* from */, k+1 );</a>
<a name="ln2190">    }</a>
<a name="ln2191">}</a>
<a name="ln2192">/****************************************************************/</a>
<a name="ln2193">void TranspositionGetMcrAndFixSetAndUnorderedPartition( Transposition *gamma, NodeSet *McrSet, NodeSet *FixSet, int n, int l, UnorderedPartition *p )</a>
<a name="ln2194">{</a>
<a name="ln2195">    int i, j, k, mcr, num;</a>
<a name="ln2196">    AT_RANK next;</a>
<a name="ln2197">    bitWord *McrBits = McrSet-&gt;bitword[l-1];</a>
<a name="ln2198">    bitWord *FixBits = FixSet-&gt;bitword[l-1];</a>
<a name="ln2199">    int     len      = McrSet-&gt;len_set*sizeof(bitWord);</a>
<a name="ln2200"> </a>
<a name="ln2201">    memset( McrBits, 0, len );</a>
<a name="ln2202">    memset( FixBits, 0, len );</a>
<a name="ln2203">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2204">        p-&gt;equ2[i] = INFINITY; /* for debug only */</a>
<a name="ln2205">    }</a>
<a name="ln2206"> </a>
<a name="ln2207">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2208">        j = (int)(next = gamma-&gt;nAtNumb[i]);</a>
<a name="ln2209">        if ( j == i ) {</a>
<a name="ln2210">            FixBits[ i / num_bit ] |= bBit[ i % num_bit ];</a>
<a name="ln2211">            McrBits[ i / num_bit ] |= bBit[ i % num_bit ];</a>
<a name="ln2212">            /* p-&gt;next[i] = INFINITY; */ /* no link to same orbit points */</a>
<a name="ln2213">            p-&gt;equ2[i] = next;  /* fixed point */</a>
<a name="ln2214">        } else</a>
<a name="ln2215">        if ( !(rank_mark_bit &amp; next) ) {</a>
<a name="ln2216">            gamma-&gt;nAtNumb[i] |= rank_mark_bit;</a>
<a name="ln2217">            mcr = inchi_min(j, i);</a>
<a name="ln2218">            num = 0;</a>
<a name="ln2219">            /* mark all nodes in the cycle to ignore later; find mcr */</a>
<a name="ln2220">            while( !(rank_mark_bit &amp; (next = gamma-&gt;nAtNumb[j])) ) {</a>
<a name="ln2221">                gamma-&gt;nAtNumb[j] |= rank_mark_bit;</a>
<a name="ln2222">                j = (int)next;</a>
<a name="ln2223">                if ( mcr &gt; j ) {</a>
<a name="ln2224">                    mcr = j;</a>
<a name="ln2225">                }</a>
<a name="ln2226">                num ++;</a>
<a name="ln2227">            }</a>
<a name="ln2228">            McrBits[ mcr / num_bit ] |= bBit[mcr % num_bit]; /* save mcr */</a>
<a name="ln2229">            /* fill out the unordered partition, the mcr first, other in the cycle after that */</a>
<a name="ln2230">            p-&gt;equ2[mcr] = mcr;</a>
<a name="ln2231">            for ( k = mcr; mcr != (j = (int)(rank_mask_bit &amp; gamma-&gt;nAtNumb[k])); k = j ) {</a>
<a name="ln2232">                p-&gt;equ2[j] = mcr;</a>
<a name="ln2233">            }</a>
<a name="ln2234">        }</a>
<a name="ln2235">    }</a>
<a name="ln2236">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2237">    /* for debug only */</a>
<a name="ln2238">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2239">        if ( p-&gt;equ2[i] &gt;= n ) {</a>
<a name="ln2240">            int stop = 1;</a>
<a name="ln2241">        }</a>
<a name="ln2242">    }</a>
<a name="ln2243">#endif</a>
<a name="ln2244">    /* remove the marks */</a>
<a name="ln2245">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2246">        gamma-&gt;nAtNumb[i] &amp;= rank_mask_bit;</a>
<a name="ln2247">    }</a>
<a name="ln2248">    INCHI_HEAPCHK</a>
<a name="ln2249">}</a>
<a name="ln2250">/****************************************************************/</a>
<a name="ln2251">int SetBitCreate( void )</a>
<a name="ln2252">{</a>
<a name="ln2253">    bitWord  b1, b2;</a>
<a name="ln2254">    AT_NUMB n1, n2;</a>
<a name="ln2255">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln2256">    CtHash  h1, h2;</a>
<a name="ln2257">#endif</a>
<a name="ln2258">    int    i;</a>
<a name="ln2259"> </a>
<a name="ln2260">    if ( bBit ) {</a>
<a name="ln2261">        INCHI_HEAPCHK</a>
<a name="ln2262">        return 0; /* already created */</a>
<a name="ln2263">    }</a>
<a name="ln2264"> </a>
<a name="ln2265">    b1 = 1;</a>
<a name="ln2266">    num_bit  = 1;</a>
<a name="ln2267">    for ( b1=1, num_bit=1; b1 &lt; (b2 = (bitWord)((b1 &lt;&lt; 1)&amp; BIT_WORD_MASK)); b1 = b2, num_bit ++ )</a>
<a name="ln2268">        ;</a>
<a name="ln2269">    bBit = (bitWord*)inchi_calloc( num_bit, sizeof(bitWord));</a>
<a name="ln2270">    if ( !bBit ) {</a>
<a name="ln2271">        INCHI_HEAPCHK</a>
<a name="ln2272">        return -1; /* failed */</a>
<a name="ln2273">    }</a>
<a name="ln2274">    for ( i = 0, b1=1; i &lt; num_bit; i++, b1 &lt;&lt;= 1 ) {</a>
<a name="ln2275">        bBit[i] = b1;</a>
<a name="ln2276">    }</a>
<a name="ln2277"> </a>
<a name="ln2278">    for ( n1 = 1; n1 &lt; (n2 = (AT_RANK)((n1 &lt;&lt; 1)&amp; AT_RANK_MASK) ); n1 = n2 )</a>
<a name="ln2279">        ;</a>
<a name="ln2280">    rank_mark_bit = n1;</a>
<a name="ln2281">    rank_mask_bit = ~n1;</a>
<a name="ln2282"> </a>
<a name="ln2283">#ifdef INCHI_CANON_USE_HASH        </a>
<a name="ln2284">    for ( h1 = 1; h1 &lt; (h2 = (h1 &lt;&lt; 1)); h1 = h2 )</a>
<a name="ln2285">        ;</a>
<a name="ln2286">    hash_mark_bit = h1;</a>
<a name="ln2287">#endif</a>
<a name="ln2288">    INCHI_HEAPCHK</a>
<a name="ln2289">    return 1;</a>
<a name="ln2290">}</a>
<a name="ln2291">/****************************************************************/</a>
<a name="ln2292">int SetBitFree( void )</a>
<a name="ln2293">{</a>
<a name="ln2294">    if ( bBit ) {</a>
<a name="ln2295">        inchi_free( bBit );</a>
<a name="ln2296">        bBit = NULL;</a>
<a name="ln2297">        INCHI_HEAPCHK</a>
<a name="ln2298">        return 1; /* success */</a>
<a name="ln2299">    }</a>
<a name="ln2300">    INCHI_HEAPCHK</a>
<a name="ln2301">    return 0; /* already destroyed */</a>
<a name="ln2302">}</a>
<a name="ln2303">#ifdef NEVER  /* { how to renumber a graph */</a>
<a name="ln2304">/*********************************************************************/</a>
<a name="ln2305">void RenumberTheGraph( int n, NEIGH_LIST *NeighList, AT_NUMB *old2new,</a>
<a name="ln2306">                       AT_NUMB *new2old, S_CHAR *mark, int bDone )</a>
<a name="ln2307">{</a>
<a name="ln2308">    int        i, k, j;</a>
<a name="ln2309">    NEIGH_LIST nl;</a>
<a name="ln2310">    </a>
<a name="ln2311">    /* renumber neighbors */</a>
<a name="ln2312">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2313">        for ( j = 1; j &lt;= NeighList[i][0]; j ++ ) {</a>
<a name="ln2314">            NeighList[i][j] = old2new[NeighList[i][j]];</a>
<a name="ln2315">        }</a>
<a name="ln2316">    }</a>
<a name="ln2317">    /* rearrange NeighList in situ using new2old[] */</a>
<a name="ln2318">    for ( k = 0; k &lt; n; k ++ ) {</a>
<a name="ln2319">        if ( mark[k] &amp; bDone )</a>
<a name="ln2320">            continue;</a>
<a name="ln2321">        if ( k == ( j = new2old[k] ) ) {</a>
<a name="ln2322">            mark[k] |= bDone;</a>
<a name="ln2323">            continue;</a>
<a name="ln2324">        }</a>
<a name="ln2325">        /* transposition cycle */</a>
<a name="ln2326">        i = k;</a>
<a name="ln2327">        nl = NeighList[k];</a>
<a name="ln2328">        do {</a>
<a name="ln2329">            NeighList[i] = NeighList[j];</a>
<a name="ln2330">            mark[i] |= bDone;</a>
<a name="ln2331">            i = j;</a>
<a name="ln2332">        } while ( k != ( j = new2old[i] ) );</a>
<a name="ln2333">        NeighList[i] = nl;</a>
<a name="ln2334">        mark[i] |= bDone;</a>
<a name="ln2335">    }</a>
<a name="ln2336">#ifdef NEVER</a>
<a name="ln2337">    /* rearrange NeighList in situ using old2new[] */</a>
<a name="ln2338">    s = 0;</a>
<a name="ln2339">    for ( k = 0; k &lt; n; k ++ ) {</a>
<a name="ln2340">        if ( mark[k] &amp; bDone )</a>
<a name="ln2341">            continue;</a>
<a name="ln2342">        if ( k == ( j = old2new[k] ) ) {</a>
<a name="ln2343">            mark[k] |= bDone;</a>
<a name="ln2344">            continue;</a>
<a name="ln2345">        }</a>
<a name="ln2346">        /* transposition cycle */</a>
<a name="ln2347">        i = k;</a>
<a name="ln2348">        /* NeighList[j] goes to ith position */</a>
<a name="ln2349">        nl2[s] = NeighList[j];</a>
<a name="ln2350">        s ^= 1;</a>
<a name="ln2351">        do {</a>
<a name="ln2352">            nl2[s] = NeighList[i];</a>
<a name="ln2353">            NeighList[i] = nl2[s ^= 1];</a>
<a name="ln2354">            mark[i] |= bDone;</a>
<a name="ln2355">            i = j;</a>
<a name="ln2356">            j = old2new[i];</a>
<a name="ln2357">        } while ( k != ( j = old2new[i] ) );</a>
<a name="ln2358">        NeighList[j] = nl2[s ^= 1];</a>
<a name="ln2359">        mark[j] |= bDone;</a>
<a name="ln2360">    }</a>
<a name="ln2361">#endif</a>
<a name="ln2362">}</a>
<a name="ln2363">/***************************************************************************************/</a>
<a name="ln2364">void RearrangeAtRankArray ( int n, AT_RANK *nRank, AT_NUMB *new2old, S_CHAR *mark, int bDone )</a>
<a name="ln2365">{</a>
<a name="ln2366">    int i, k, j;</a>
<a name="ln2367">    AT_RANK r;    </a>
<a name="ln2368">    /* rearrange the array in situ using new2old[] */</a>
<a name="ln2369">    for ( k = 0; k &lt; n; k ++ ) {</a>
<a name="ln2370">        if ( mark[k] &amp; bDone )</a>
<a name="ln2371">            continue;</a>
<a name="ln2372">        if ( k == ( j = new2old[k] ) ) {</a>
<a name="ln2373">            mark[k] |= bDone;</a>
<a name="ln2374">            continue;</a>
<a name="ln2375">        }</a>
<a name="ln2376">        /* transposition cycle */</a>
<a name="ln2377">        i = k;</a>
<a name="ln2378">        r = nRank[k];</a>
<a name="ln2379">        do {</a>
<a name="ln2380">            nRank[i] = nRank[j];</a>
<a name="ln2381">            mark[i] |= bDone;</a>
<a name="ln2382">            i = j;</a>
<a name="ln2383">        } while ( k != ( j = new2old[i] ) );</a>
<a name="ln2384">        nRank[i] = r;</a>
<a name="ln2385">        mark[i] |= bDone;</a>
<a name="ln2386">    }</a>
<a name="ln2387"> </a>
<a name="ln2388">}</a>
<a name="ln2389">/***************************************************************************************/</a>
<a name="ln2390">void RenumberAtNumbArray( int n, AT_NUMB *nAtNumb, AT_NUMB *old2new )</a>
<a name="ln2391">{</a>
<a name="ln2392">    int i;</a>
<a name="ln2393">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2394">        nAtNumb[i] = old2new[nAtNumb[i]];</a>
<a name="ln2395">    }</a>
<a name="ln2396">}</a>
<a name="ln2397">/****************************************************************/</a>
<a name="ln2398">int  GetCanonRanking2( int num_atoms, int num_at_tg, int num_max, int bDigraph, sp_ATOM* at,</a>
<a name="ln2399">                     AT_RANK **pRankStack,  int nNumPrevRanks,</a>
<a name="ln2400">                     AT_RANK *nSymmRank,  AT_RANK *nCanonRank,</a>
<a name="ln2401">                     NEIGH_LIST *NeighList, AT_RANK *nTempRank,</a>
<a name="ln2402">                     CANON_STAT* pCS )</a>
<a name="ln2403">{</a>
<a name="ln2404">    void *pzb_rho=NULL;</a>
<a name="ln2405">    int ret, cmp1=0, cmp2=0;</a>
<a name="ln2406">    </a>
<a name="ln2407">    int i, j, k, n;</a>
<a name="ln2408">    AT_NUMB *old2new = NULL, *new2old = NULL, m, r1, r2;</a>
<a name="ln2409">    S_CHAR  *mark = NULL;</a>
<a name="ln2410"> </a>
<a name="ln2411">    int      nMaxLenCt        =  pCS-&gt;nMaxLenLinearCT;</a>
<a name="ln2412">    AT_RANK *pCt              =  pCS-&gt;LinearCT;</a>
<a name="ln2413">    int      nLenCt           =  pCS-&gt;nLenLinearCT;</a>
<a name="ln2414">    AT_RANK *pCt0             =  pCS-&gt;LinearCT;</a>
<a name="ln2415">    int      nLenCt0          =  pCS-&gt;nLenLinearCT;</a>
<a name="ln2416"> </a>
<a name="ln2417"> </a>
<a name="ln2418">    CANON_DATA CanonData;</a>
<a name="ln2419">    CANON_DATA *pCD = &amp;CanonData;</a>
<a name="ln2420">    CANON_COUNTS CanonCounts;</a>
<a name="ln2421">    CANON_COUNTS *pCC = &amp;CanonCounts;</a>
<a name="ln2422">    memset (pCD, 0, sizeof(pCD[0]));</a>
<a name="ln2423">    memset (pCC, 0, sizeof(pCC[0]));</a>
<a name="ln2424">    /* pointers */</a>
<a name="ln2425">    pCD-&gt;LinearCT           = pCS-&gt;LinearCT;</a>
<a name="ln2426">    /* variables - unchanged */</a>
<a name="ln2427">    pCD-&gt;ulTimeOutTime      = pCS-&gt;ulTimeOutTime;</a>
<a name="ln2428">    pCD-&gt;nMaxLenLinearCT    = pCS-&gt;nMaxLenLinearCT;</a>
<a name="ln2429">    /* return values &amp; input/output */</a>
<a name="ln2430">    pCD-&gt;nLenLinearCT       = pCS-&gt;nLenLinearCT;</a>
<a name="ln2431"> </a>
<a name="ln2432">    pCC-&gt;lNumBreakTies      = pCS-&gt;lNumBreakTies;</a>
<a name="ln2433">    pCC-&gt;lNumDecreasedCT    = pCS-&gt;lNumDecreasedCT;</a>
<a name="ln2434">    pCC-&gt;lNumRejectedCT     = pCS-&gt;lNumRejectedCT;</a>
<a name="ln2435">    pCC-&gt;lNumEqualCT        = pCS-&gt;lNumEqualCT;</a>
<a name="ln2436">    pCC-&gt;lNumTotCT          = pCS-&gt;lNumTotCT;</a>
<a name="ln2437"> </a>
<a name="ln2438">    ret = CanonGraph( num_atoms, num_at_tg, num_max, bDigraph, NeighList, (Partition *)pRankStack,</a>
<a name="ln2439">                       nSymmRank,  nCanonRank, pCS-&gt;nPrevAtomNumber, pCD, pCC, NULL, &amp;pzb_rho );</a>
<a name="ln2440"> </a>
<a name="ln2441">    pCS-&gt;nLenLinearCT       = pCD-&gt;nLenLinearCT;</a>
<a name="ln2442">    pCS-&gt;lNumBreakTies      = pCC-&gt;lNumBreakTies;</a>
<a name="ln2443">    pCS-&gt;lNumDecreasedCT    = pCC-&gt;lNumDecreasedCT;</a>
<a name="ln2444">    pCS-&gt;lNumRejectedCT     = pCC-&gt;lNumRejectedCT;</a>
<a name="ln2445">    pCS-&gt;lNumEqualCT        = pCC-&gt;lNumEqualCT;</a>
<a name="ln2446">    pCS-&gt;lNumTotCT          = pCC-&gt;lNumTotCT;</a>
<a name="ln2447"> </a>
<a name="ln2448">   </a>
<a name="ln2449">    /* save the connection table for comparison with the 2nd one */</a>
<a name="ln2450">    pCt0 = (AT_RANK*)inchi_calloc(nMaxLenCt, sizeof(pCt0[0]));</a>
<a name="ln2451">    memcpy(pCt0, pCS-&gt;LinearCT, nMaxLenCt*sizeof(pCt0[0]));</a>
<a name="ln2452">    nLenCt0 =  pCS-&gt;nLenLinearCT;</a>
<a name="ln2453"> </a>
<a name="ln2454">    /**********************************************************/</a>
<a name="ln2455">    /* rearrange numbering to make canon. numbering the first */</a>
<a name="ln2456">    /**********************************************************/</a>
<a name="ln2457">    n = num_at_tg;</a>
<a name="ln2458">    /* 1. get transpositions */</a>
<a name="ln2459">    old2new = (AT_NUMB*) inchi_calloc( n, sizeof(old2new[0]) ); </a>
<a name="ln2460">    new2old = (AT_NUMB*) inchi_calloc( n, sizeof(new2old[0]) );</a>
<a name="ln2461">    mark    = (S_CHAR *) inchi_calloc( n, sizeof(mark[0]) );</a>
<a name="ln2462">    for ( i = 0; i &lt; n; i ++ ) {</a>
<a name="ln2463">        /* forward transposition: at[i] -&gt; at[old2new[i]] position */</a>
<a name="ln2464">        old2new[i] = m = nCanonRank[i]-1;</a>
<a name="ln2465">        /* forward transposition: at[new2old[i]] -&gt; at[i] position */</a>
<a name="ln2466">        new2old[m] = i;</a>
<a name="ln2467">    }</a>
<a name="ln2468">    /* rearrange input data according to the new numbering */</a>
<a name="ln2469">    RenumberTheGraph( n, NeighList, old2new, new2old, mark, 1 );</a>
<a name="ln2470">    RearrangeAtRankArray ( n, pRankStack[0], new2old, mark, 2 );</a>
<a name="ln2471">    RenumberAtNumbArray ( n, pRankStack[1], old2new );</a>
<a name="ln2472">    /* make sure the atom numbers are sorted */</a>
<a name="ln2473">    for ( i = k = 0, r1 = pRankStack[0][pRankStack[1][i]]; i &lt; n; r1 = r2) {</a>
<a name="ln2474">        for ( j = i++; i &lt; n &amp;&amp; r1 == (r2 = pRankStack[0][pRankStack[1][i]]); i ++ )</a>
<a name="ln2475">            ;</a>
<a name="ln2476">        if ( i - j &gt; 1 ) {</a>
<a name="ln2477">            k += insertions_sort_AT_RANK( pRankStack[1]+j, i-j );</a>
<a name="ln2478">        }</a>
<a name="ln2479">    }</a>
<a name="ln2480"> </a>
<a name="ln2481">    ret = CanonGraph( num_atoms, num_at_tg, num_max, bDigraph, NeighList, (Partition *)pRankStack,</a>
<a name="ln2482">                       nSymmRank,  nCanonRank, pCS-&gt;nPrevAtomNumber, pCD, pCC, &amp;pzb_rho, NULL );</a>
<a name="ln2483"> </a>
<a name="ln2484">    pCS-&gt;nLenLinearCT       = pCD-&gt;nLenLinearCT;</a>
<a name="ln2485">    pCS-&gt;lNumBreakTies      = pCC-&gt;lNumBreakTies;</a>
<a name="ln2486">    pCS-&gt;lNumDecreasedCT    = pCC-&gt;lNumDecreasedCT;</a>
<a name="ln2487">    pCS-&gt;lNumRejectedCT     = pCC-&gt;lNumRejectedCT;</a>
<a name="ln2488">    pCS-&gt;lNumEqualCT        = pCC-&gt;lNumEqualCT;</a>
<a name="ln2489">    pCS-&gt;lNumTotCT          = pCC-&gt;lNumTotCT;</a>
<a name="ln2490"> </a>
<a name="ln2491"> </a>
<a name="ln2492">    /* compare the connection tables */</a>
<a name="ln2493">    cmp1 = nLenCt0 - pCS-&gt;nLenLinearCT;</a>
<a name="ln2494">    cmp2 = memcmp( pCt0, pCS-&gt;LinearCT, pCS-&gt;nLenLinearCT*sizeof(pCt0[0]));</a>
<a name="ln2495">#ifdef _DEBUG            </a>
<a name="ln2496">    if ( cmp1 || cmp2 ) {</a>
<a name="ln2497">        int stop = 1;</a>
<a name="ln2498">    }</a>
<a name="ln2499">#endif</a>
<a name="ln2500">    /**********************************************************/</a>
<a name="ln2501">    /* rearrange numbering back to the original numbering     */</a>
<a name="ln2502">    /**********************************************************/</a>
<a name="ln2503">    /* restore the input data to its original numbering */</a>
<a name="ln2504">    RenumberTheGraph( n, NeighList, new2old, old2new, mark, 4 );</a>
<a name="ln2505">    RearrangeAtRankArray ( n, pRankStack[0], old2new, mark, 8 );</a>
<a name="ln2506">    RenumberAtNumbArray ( n, pRankStack[1], new2old );</a>
<a name="ln2507">    /* rearrange the output data to the original numbering */</a>
<a name="ln2508">    RearrangeAtRankArray ( n, nCanonRank, old2new, mark, 16 );</a>
<a name="ln2509">    RenumberAtNumbArray ( n, pCS-&gt;nPrevAtomNumber, new2old );</a>
<a name="ln2510">    RearrangeAtRankArray ( n, nSymmRank, old2new, mark, 32 );</a>
<a name="ln2511"> </a>
<a name="ln2512">    /* free memory */</a>
<a name="ln2513">    CTableFree( pzb_rho );</a>
<a name="ln2514">    if ( pzb_rho ) {</a>
<a name="ln2515">        inchi_free( pzb_rho );</a>
<a name="ln2516">    }</a>
<a name="ln2517">    inchi_free( old2new );</a>
<a name="ln2518">    inchi_free( new2old );</a>
<a name="ln2519">    inchi_free( mark );</a>
<a name="ln2520">    inchi_free( pCt0 );</a>
<a name="ln2521"> </a>
<a name="ln2522">    return ret;</a>
<a name="ln2523">}</a>
<a name="ln2524">#endif  /* } */</a>
<a name="ln2525"> </a>
<a name="ln2526">#define QZFIX_OK(X) ((X)&lt;=0)</a>
<a name="ln2527"> </a>
<a name="ln2528">int GetOneAdditionalLayer( CANON_DATA *pCD, ConTable *pzb_rho_fix )</a>
<a name="ln2529">{</a>
<a name="ln2530">    int nLastLayer = -1, nNumLast = 0, nLayer = 0;</a>
<a name="ln2531"> </a>
<a name="ln2532">    if ( !pCD || !pzb_rho_fix ) {</a>
<a name="ln2533">        return 0;</a>
<a name="ln2534">    }</a>
<a name="ln2535"> </a>
<a name="ln2536">    nLayer ++; /* 1 */</a>
<a name="ln2537">    if ( pCD-&gt;NumH &amp;&amp; !pzb_rho_fix-&gt;NumH ) {</a>
<a name="ln2538">        nLastLayer = nLayer;</a>
<a name="ln2539">        nNumLast ++;</a>
<a name="ln2540">    }</a>
<a name="ln2541">    nLayer ++; /* 2 */</a>
<a name="ln2542">    if ( pCD-&gt;nLenCTAtOnly &lt; pCD-&gt;nLenLinearCT &amp;&amp; pzb_rho_fix-&gt;nLenCTAtOnly == pzb_rho_fix-&gt;lenCt ) {</a>
<a name="ln2543">        nLastLayer = nLayer;</a>
<a name="ln2544">        nNumLast ++;</a>
<a name="ln2545">    }</a>
<a name="ln2546">    nLayer ++; /* 3 */</a>
<a name="ln2547">    if ( pCD-&gt;NumHfixed &amp;&amp; !pzb_rho_fix-&gt;NumHfixed ) {</a>
<a name="ln2548">        nLastLayer = nLayer;</a>
<a name="ln2549">        nNumLast ++;</a>
<a name="ln2550">    }</a>
<a name="ln2551">    nLayer ++; /* 4 */</a>
<a name="ln2552">    if ( pCD-&gt;iso_sort_key &amp;&amp; !pzb_rho_fix-&gt;iso_sort_key ) {</a>
<a name="ln2553">        nLastLayer = nLayer;</a>
<a name="ln2554">        nNumLast ++;</a>
<a name="ln2555">    }</a>
<a name="ln2556">    /*</a>
<a name="ln2557">    nLayer ++; // 5</a>
<a name="ln2558">    if ( pCD-&gt;nLenCTAtOnly &lt; pCD-&gt;nLenLinearCT &amp;&amp; pCD-&gt;iso_sort_key &amp;&amp;</a>
<a name="ln2559">        (pzb_rho_fix-&gt;nLenCTAtOnly == pzb_rho_fix-&gt;lenCt || !pzb_rho_fix-&gt;iso_sort_key ) ) {</a>
<a name="ln2560">        nLastLayer = nLayer;</a>
<a name="ln2561">        nNumLast ++;</a>
<a name="ln2562">    }</a>
<a name="ln2563">    */</a>
<a name="ln2564">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln2565">    nLayer ++; /* 6 */</a>
<a name="ln2566">    if ( pCD-&gt;iso_sort_key_Hfixed &amp;&amp; !pzb_rho_fix-&gt;iso_sort_key_Hfixed ) {</a>
<a name="ln2567">        nLastLayer = nLayer;</a>
<a name="ln2568">        nNumLast ++;</a>
<a name="ln2569">    }</a>
<a name="ln2570">#endif</a>
<a name="ln2571">    if ( 1 == nNumLast ) {</a>
<a name="ln2572">        return nLastLayer;</a>
<a name="ln2573">    }</a>
<a name="ln2574">    return 0;</a>
<a name="ln2575">}</a>
<a name="ln2576"> </a>
<a name="ln2577"> </a>
<a name="ln2578">/*#define QZFIX_OK(X) (!(X))*/</a>
<a name="ln2579"> </a>
<a name="ln2580">/********************** CanonGraph *************************************</a>
<a name="ln2581"> *   A naive implementation of graph canonical numbering algorithm     *</a>
<a name="ln2582"> *   from &quot;Practical Graph Isomorphism&quot; by Brendan D. McKay,           *</a>
<a name="ln2583"> *   Congressus Numerantium, Vol. 30 (1981), pp. 45 - 87.              *</a>
<a name="ln2584"> *   Note: Several typos fixed, added chem. struct. specifics          *</a>
<a name="ln2585"> ***********************************************************************/</a>
<a name="ln2586"> </a>
<a name="ln2587">/* on entry: pi[0] is equitable */</a>
<a name="ln2588">/*******************************************************10/21/2003******</a>
<a name="ln2589"> * Later add optimization: if Aut(G) &lt;= Aut(G0) due to some additional *</a>
<a name="ln2590"> * layer of coloring applied to G and the following is known about G0: *                                                    *</a>
<a name="ln2591"> *                                                                     *</a>
<a name="ln2592"> * 0) canonical numbering of G should be same as that of G0            *</a>
<a name="ln2593"> *                                                                     *</a>
<a name="ln2594"> * 1) canonical numbering as v= v0[n] {vertex number v from            *</a>
<a name="ln2595"> *                                     G0 canonical number n)          *</a>
<a name="ln2596"> * 2) orbits of Aut(G0) as UnorderedPartition theta0                   *</a>
<a name="ln2597"> *                                                                     *</a>
<a name="ln2598"> * then when choosing next v[i] for refining the partition consider    *</a>
<a name="ln2599"> * only vertices from the Aut(G0) orbit of V(i), that is, only such    *</a>
<a name="ln2600"> * v[i] that:                                                          *</a>
<a name="ln2601"> *                                                                     *</a>
<a name="ln2602"> *       GetUnorderedPartitionMcrNode( &amp;theta0, v[i] ) ==              *</a>
<a name="ln2603"> *       GetUnorderedPartitionMcrNode( &amp;theta0, v0[i] )                *</a>
<a name="ln2604"> ***********************************************************************/</a>
<a name="ln2605">int CanonGraph( int n, int n_tg, int n_max, int bDigraph, Graph *G, Partition pi[],</a>
<a name="ln2606">                AT_RANK *nSymmRank,  AT_RANK *nCanonRank, AT_NUMB *nAtomNumberCanon,</a>
<a name="ln2607">                CANON_DATA *pCD, CANON_COUNTS *pCC,</a>
<a name="ln2608">                ConTable **pp_zb_rho_inp, ConTable **pp_zb_rho_out  )</a>
<a name="ln2609">{   </a>
<a name="ln2610">    /* bDigraph != 0</a>
<a name="ln2611">       means consider edges from atoms to t-groups</a>
<a name="ln2612">       as directed, that is, do not include</a>
<a name="ln2613">       t-group ranks in comparing neighbors</a>
<a name="ln2614">       when refining partition</a>
<a name="ln2615">    */</a>
<a name="ln2616"> </a>
<a name="ln2617">    /* Always set</a>
<a name="ln2618">       lab = true</a>
<a name="ln2619">       dig = true</a>
<a name="ln2620">    */</a>
<a name="ln2621"> </a>
<a name="ln2622">    /* in the comments:</a>
<a name="ln2623">        m = |zeta|</a>
<a name="ln2624">        r = |rho|</a>
<a name="ln2625"> </a>
<a name="ln2626">        m &lt; n or r &lt; n in case pi[k] in P (i.e. satisfies Lemma 2.25)</a>
<a name="ln2627"> </a>
<a name="ln2628">        Just after passing point B:</a>
<a name="ln2629">        ===========================</a>
<a name="ln2630">        K = k-1</a>
<a name="ln2631">        wi = v[i], i = 1..K</a>
<a name="ln2632">        Gamma(0) = Gamma = Aut(G)pi</a>
<a name="ln2633">        Gamma(i) = Gamma(w1,w2,...,wi) pointwise stabilizer for i=1..K</a>
<a name="ln2634">        zeta is a terminal node =&gt;</a>
<a name="ln2635">          the coarsest equitable partition that fixes w1,...,wK is discrete =&gt;</a>
<a name="ln2636">            Gamma(K)=1</a>
<a name="ln2637">        At point A only:</a>
<a name="ln2638">            index = |Gamma(k-1)|/|Gamma(k)|</a>
<a name="ln2639">        At points A and B:</a>
<a name="ln2640">            size  = |Gamma(k-1)|</a>
<a name="ln2641">            theta = theta(Gamma(k-1));</a>
<a name="ln2642">            Gamma(k-1) = &lt;Y&gt;, where Y is the set of all automprhisms output up</a>
<a name="ln2643">              to the present stage (in Step 10 = L10 )</a>
<a name="ln2644">            |Y| &lt;= n - |theta|</a>
<a name="ln2645">    */</a>
<a name="ln2646"> </a>
<a name="ln2647">    AT_RANK    *pCt              =  pCD-&gt;LinearCT;</a>
<a name="ln2648">    /*int         nMaxLenCt        =  pCD-&gt;nMaxLenLinearCT;*/</a>
<a name="ln2649">    int        *nLenCt           = &amp;pCD-&gt;nLenLinearCT;</a>
<a name="ln2650">    CANON_DATA *pCD1             = pCD;</a>
<a name="ln2651"> </a>
<a name="ln2652">    int i, k, k2, index, l, ok, ret=0, res;</a>
<a name="ln2653">    int t_Lemma;   /* hh: if pi[k-1] satisfies Lemma 2-25 then </a>
<a name="ln2654">                          t_Lemma = min{i| i=1..k &amp;&amp; pi[i-1] satisfies Lemma 2-25}*/</a>
<a name="ln2655">                   /* otherwise t_Lemma = k --&gt; here this is always the case */</a>
<a name="ln2656">    int t_eq_zeta; /* ht: min{i|i=1..m &amp;&amp; all terminal modes descended from or equal</a>
<a name="ln2657">                      to zeta(i) have been shown to be equivalent}. */</a>
<a name="ln2658">    int h_zeta;    /* h: the longest common ancestor of zeta and nu is nu(h_zeta) */</a>
<a name="ln2659">    int h_rho;     /* hb: the longest common ancestor of rho and nu is nu(h_rho) */</a>
<a name="ln2660">    int hz_rho;    /* hzb: max{i|i=1..min(k,r) &amp;&amp; Lambda(G,pi,nu(i)) == Lambda(G,pi,rho(i))} */</a>
<a name="ln2661">    int hz_zeta;   /* hzf: max{i|i=1..min(k,m) &amp;&amp; Lambda(G,pi,nu(i)) == Lambda(G,pi,zeta(i))} */</a>
<a name="ln2662">    int qzb_rho;   /* Ct(Lambda[k]) - Ct(rho[k]) */</a>
<a name="ln2663">    double size;     /* |Aut(G)| */</a>
<a name="ln2664">    int  nNumLayers = (NULL != pCD-&gt;NumH) + (NULL != pCD-&gt;NumHfixed) +</a>
<a name="ln2665">                      /* (bDigraph &amp;&amp; pCD-&gt;nLenLinearCT &gt; pCD-&gt;nLenCTAtOnly)*/ /* ??? tautomeric */</a>
<a name="ln2666">                      (NULL != pCD-&gt;iso_sort_key)</a>
<a name="ln2667">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln2668">                      + (NULL != pCD-&gt;iso_sort_key_Hfixed)</a>
<a name="ln2669">#endif</a>
<a name="ln2670">                      ;</a>
<a name="ln2671">    int  dig        = (bDigraph || nNumLayers);</a>
<a name="ln2672">    int  bSplitTautCompare = (bDigraph || nNumLayers); /* compare taut. H and tgroups connections after H */</a>
<a name="ln2673">                   /* digraph: 1=&gt;do not use Lemma 2.25, 0 =&gt; use */</a>
<a name="ln2674">    int  lab = 1;  /* label: 1=&gt;find canonical numbering;</a>
<a name="ln2675">                      0=&gt;do not find canonical numbering, do not use rho */</a>
<a name="ln2676">    int  r;        /* |rho| */</a>
<a name="ln2677">    int  bZetaEqRho = lab;</a>
<a name="ln2678">    int  bZetaIsomorph;</a>
<a name="ln2679"> </a>
<a name="ln2680">    long lNumEqlZeta;</a>
<a name="ln2681"> </a>
<a name="ln2682">    </a>
<a name="ln2683">    const int L = MAX_SET_SIZE;</a>
<a name="ln2684">    UnorderedPartition theta, theta_from_gamma;</a>
<a name="ln2685">    Cell *W;  /* W[i] is the first non-trivial cell of pi[i+1] */ </a>
<a name="ln2686">    Node *v;  /* v[i] is in W[i] to create T(G,pi,nu[i+1]) */</a>
<a name="ln2687">    Node tvc, tvh;</a>
<a name="ln2688">    S_CHAR *e, *qzb=NULL;   /* qzb = NULL always */</a>
<a name="ln2689">    /* current node CT */</a>
<a name="ln2690">    ConTable Lambda;</a>
<a name="ln2691">    /* first leaf CT */</a>
<a name="ln2692">    ConTable zf_zeta; /* Ct for zeta,  the first discovered terminal node */</a>
<a name="ln2693">    /* best leaf/node CT: find the greatest pzb_rho possibly subject to pzb_rho[k] &lt;= pzb_rho_fix[k] condition */</a>
<a name="ln2694">    ConTable *pzb_rho = NULL;  /* Ct for rho,   the best discovered terminal node */</a>
<a name="ln2695">    /* fixed input CT: for all k pzb_rho[k] &lt;= pzb_rho_fix[k]; at the end pzb_rho == pzb_rho_fix */</a>
<a name="ln2696">    ConTable *pzb_rho_fix = (pp_zb_rho_inp &amp;&amp; *pp_zb_rho_inp)? *pp_zb_rho_inp:NULL;</a>
<a name="ln2697">    </a>
<a name="ln2698">    NodeSet Omega; /* MAX_SET_SIZE */</a>
<a name="ln2699">    NodeSet Phi;   /* MAX_SET_SIZE */</a>
<a name="ln2700">    NodeSet cur_nodes;   /* 1 each */</a>
<a name="ln2701">    Transposition gamma;</a>
<a name="ln2702">    Partition zeta;      /* the first discovered terminal node */</a>
<a name="ln2703">    Partition rho;       /* the best discovered terminal node */</a>
<a name="ln2704">    int nNumFoundGenerators=0;</a>
<a name="ln2705">    int qzb_rho_fix = 0;</a>
<a name="ln2706">    int hzb_rho_fix = 0;</a>
<a name="ln2707">    int bRhoIsDiscrete = 1;</a>
<a name="ln2708">    kLeast kLeast_rho[MAX_LAYERS];</a>
<a name="ln2709">    kLeast kLeast_rho_fix[MAX_LAYERS];</a>
<a name="ln2710">    int nOneAdditionalLayer;</a>
<a name="ln2711">    int pzb_rho_fix_reached = 0;</a>
<a name="ln2712">    int L_rho_fix_prev = 0, I_rho_fix_prev=-1, k_rho_fix_prev=0;</a>
<a name="ln2713"> </a>
<a name="ln2714">    /* Note: Layered comparison should be consistent, especially in layer numbers.</a>
<a name="ln2715">             Layered comparison is implemented in:</a>
<a name="ln2716">                     CtFullCompare()</a>
<a name="ln2717">                     CtPartCompare()</a>
<a name="ln2718">                     GetOneAdditionalLayer()</a>
<a name="ln2719"> </a>
<a name="ln2720">             The partial comparison results in kLeast[] are used in</a>
<a name="ln2721">                     CtFullCompareLayers()</a>
<a name="ln2722">                     CtPartCompareLayers()</a>
<a name="ln2723">                     CtCompareLayersGetFirstDiff()</a>
<a name="ln2724">                     UpdateCompareLayers()</a>
<a name="ln2725">     */</a>
<a name="ln2726">    nOneAdditionalLayer = GetOneAdditionalLayer( pCD1, pzb_rho_fix );</a>
<a name="ln2727"> </a>
<a name="ln2728"> </a>
<a name="ln2729">    /* next 2 lines for debug only */</a>
<a name="ln2730">    /* num_g++;  */</a>
<a name="ln2731">    /* WriteGraph( G, n_tg, num_g, &quot;V:\\IChI_v10\\Gordon-Graphs\\hard\\k06g08v312-alt.dre&quot;, &quot;a+&quot; ); */</a>
<a name="ln2732">    </a>
<a name="ln2733">    /* memory allocation */</a>
<a name="ln2734"> </a>
<a name="ln2735">    if ( 0 &gt; SetBitCreate() ) {</a>
<a name="ln2736">        return -1;</a>
<a name="ln2737">    }</a>
<a name="ln2738">    if ( pzb_rho_fix &amp;&amp; pzb_rho_fix-&gt;nLenCTAtOnly != pCD-&gt;nLenCTAtOnly ) {</a>
<a name="ln2739">        /* consistency check */</a>
<a name="ln2740">        return -2;</a>
<a name="ln2741">    }</a>
<a name="ln2742">    ok = 1;</a>
<a name="ln2743"> </a>
<a name="ln2744"> </a>
<a name="ln2745">    ok &amp;= UnorderedPartitionCreate( &amp;theta, n_tg );</a>
<a name="ln2746">    ok &amp;= UnorderedPartitionCreate( &amp;theta_from_gamma, n_tg );</a>
<a name="ln2747"> </a>
<a name="ln2748">    ok &amp;= (NULL != (W   = (Cell*)inchi_calloc(n_tg, sizeof(W[0]))));</a>
<a name="ln2749">    ok &amp;= (NULL != (v   = (Node*)inchi_calloc(n_tg, sizeof(v[0]))));</a>
<a name="ln2750">    ok &amp;= (NULL != (e   = (S_CHAR*)inchi_calloc(n_tg, sizeof(e[0]))));</a>
<a name="ln2751"> </a>
<a name="ln2752">/*</a>
<a name="ln2753">    ok &amp;= (NULL != (v   = (Node*)inchi_calloc(n_tg, sizeof(W[0]))));</a>
<a name="ln2754">    ok &amp;= (NULL != (e   = (S_CHAR*)inchi_calloc(n_tg, sizeof(W[0]))));</a>
<a name="ln2755">*/</a>
<a name="ln2756"> </a>
<a name="ln2757">    /*    ok &amp;= (NULL != (qzb = (S_CHAR*)calloc(n_tg, sizeof(W[0])))); */</a>
<a name="ln2758">    ok &amp;= CTableCreate( &amp;Lambda, n, pCD );</a>
<a name="ln2759">    ok &amp;= CTableCreate( &amp;zf_zeta, n, pCD );</a>
<a name="ln2760">    ok &amp;= ( (pzb_rho = (ConTable *)inchi_calloc( 1, sizeof( *pzb_rho ) ) ) &amp;&amp;</a>
<a name="ln2761">            CTableCreate( pzb_rho, n, pCD ) );</a>
<a name="ln2762"> </a>
<a name="ln2763">    ok &amp;= NodeSetCreate( &amp;Omega, n_tg, MAX_SET_SIZE );</a>
<a name="ln2764">    ok &amp;= NodeSetCreate( &amp;Phi, n_tg, MAX_SET_SIZE );</a>
<a name="ln2765">    ok &amp;= NodeSetCreate( &amp;cur_nodes, n_tg, 1 );</a>
<a name="ln2766"> </a>
<a name="ln2767">    ok &amp;= PartitionCreate( &amp;zeta, n_tg);</a>
<a name="ln2768">    ok &amp;= PartitionCreate( &amp;rho, n_tg);</a>
<a name="ln2769">    ok &amp;= TranspositionCreate( &amp;gamma, n_tg );</a>
<a name="ln2770"> </a>
<a name="ln2771">    INCHI_HEAPCHK</a>
<a name="ln2772"> </a>
<a name="ln2773">    </a>
<a name="ln2774">/*L1:*/</a>
<a name="ln2775">    k = 1;</a>
<a name="ln2776">    size = 1.0;</a>
<a name="ln2777">    h_zeta = hz_rho = index = l = 0;</a>
<a name="ln2778"> </a>
<a name="ln2779">    if ( !ok ) {</a>
<a name="ln2780">        goto exit_function; /* initialization failed */</a>
<a name="ln2781">    }</a>
<a name="ln2782"> </a>
<a name="ln2783">    UnorderedPartitionMakeDiscrete(&amp;theta, n_tg);</a>
<a name="ln2784">    t_Lemma = 2;</a>
<a name="ln2785"> </a>
<a name="ln2786">    pCC-&gt;lNumBreakTies   = 0;</a>
<a name="ln2787">    pCC-&gt;lNumDecreasedCT = 0;</a>
<a name="ln2788">    pCC-&gt;lNumRejectedCT  = 0;</a>
<a name="ln2789">    pCC-&gt;lNumEqualCT     = 1;</a>
<a name="ln2790">    pCC-&gt;lNumTotCT       = 0;</a>
<a name="ln2791">    lNumEqlZeta          = 1;</a>
<a name="ln2792">    </a>
<a name="ln2793">    hzb_rho_fix          = 1;</a>
<a name="ln2794"> </a>
<a name="ln2795">    memset( kLeast_rho, 0, sizeof(kLeast_rho) );</a>
<a name="ln2796">    memset( kLeast_rho_fix, 0, sizeof(kLeast_rho_fix) );</a>
<a name="ln2797"> </a>
<a name="ln2798">    if ( PartitionIsDiscrete( &amp;pi[k-1], n_tg ) ) {</a>
<a name="ln2799">        /* added the following 3 lines to the original to create Ct */</a>
<a name="ln2800">        PartitionCopy( &amp;rho, &amp;pi[k-1], n_tg );</a>
<a name="ln2801">        CtPartFill( G, pCD, &amp;pi[k-1], pzb_rho, 1, n, n_tg );</a>
<a name="ln2802">        CtPartInfinity( pzb_rho, qzb, 2 );</a>
<a name="ln2803">        pCC-&gt;lNumTotCT ++;</a>
<a name="ln2804">        r = k;</a>
<a name="ln2805">        /* goto L18; */</a>
<a name="ln2806">        goto exit_function;</a>
<a name="ln2807">    }</a>
<a name="ln2808">    if ( !dig &amp;&amp; PartitionSatisfiesLemma_2_25( &amp;pi[0], n ) )</a>
<a name="ln2809">        t_Lemma = 1;</a>
<a name="ln2810">    /*</a>
<a name="ln2811">    PartitionGetFirstCell( &amp;pi[k-1], &amp;W[k-1], k, n );</a>
<a name="ln2812">    v[k-1] = CellGetMinNode( &amp;pi[k-1], &amp;W[k-1], 0, pCD1 );</a>
<a name="ln2813">    CtPartClear( &amp;Lambda, 1 ); </a>
<a name="ln2814">    e[k-1] = 0;</a>
<a name="ln2815">    */</a>
<a name="ln2816">    CtPartClear( &amp;Lambda, 1 ); </a>
<a name="ln2817">    INCHI_HEAPCHK</a>
<a name="ln2818"> </a>
<a name="ln2819">/* L2: reach the first leaf and save it in zeta and rho */</a>
<a name="ln2820">    while( k ) {</a>
<a name="ln2821">        /* the two next lines intentionally switched */</a>
<a name="ln2822">        /* Create equitable partition in pi[k]  */</a>
<a name="ln2823">        PartitionGetFirstCell( &amp;pi[k-1], W, k, n );</a>
<a name="ln2824">        v[k-1] = CellGetMinNode( &amp;pi[k-1], &amp;W[k-1], 0, pCD1 );</a>
<a name="ln2825">        e[k-1] = 0;</a>
<a name="ln2826">        if ( dig || !PartitionSatisfiesLemma_2_25(&amp;pi[k-1], n) )</a>
<a name="ln2827">            t_Lemma = k+1;</a>
<a name="ln2828">        /* e[k-1] = 0; */</a>
<a name="ln2829">        { Node vv = v[k-1];</a>
<a name="ln2830">        if ( 0 &gt; (ret=PartitionColorVertex( G, &amp;pi[k-1], vv /*v[k-1]*/, n, n_tg, n_max, bDigraph, 0 )) ) {</a>
<a name="ln2831">            goto exit_error;</a>
<a name="ln2832">        }}</a>
<a name="ln2833">        pCC-&gt;lNumBreakTies ++;</a>
<a name="ln2834">        k ++;</a>
<a name="ln2835">        CtPartFill( G, pCD, &amp;pi[k-1], &amp;Lambda, k-1, n, n_tg );</a>
<a name="ln2836">        /* return -1; *//* debug only */</a>
<a name="ln2837">        /* if(h_zeta==0)goto L5; L5: */</a>
<a name="ln2838">        /* the first terminal node has not been reached yet */</a>
<a name="ln2839">        /* search for the predefined numbering */</a>
<a name="ln2840">        if ( pzb_rho_fix &amp;&amp; QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2841">            qzb_rho_fix = CtPartCompare( &amp;Lambda, pzb_rho_fix, qzb, kLeast_rho_fix, k-1, 1, bSplitTautCompare );</a>
<a name="ln2842">            if ( QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2843">                hzb_rho_fix = k;</a>
<a name="ln2844">            }</a>
<a name="ln2845">        }</a>
<a name="ln2846"> </a>
<a name="ln2847">        if ( lab &amp;&amp; QZFIX_OK(qzb_rho_fix) )  /* DCh */</a>
<a name="ln2848">            CtPartCopy( pzb_rho, &amp;Lambda, k-1 );</a>
<a name="ln2849">        CtPartCopy( &amp;zf_zeta, &amp;Lambda, k-1 );</a>
<a name="ln2850">        /*goto L4; L4:*/</a>
<a name="ln2851">        if ( PartitionIsDiscrete( &amp;pi[k-1], n ) ) {</a>
<a name="ln2852">            break;  /* goto L7; */</a>
<a name="ln2853">        }</a>
<a name="ln2854">        /* goto L2; */</a>
<a name="ln2855">    }</a>
<a name="ln2856">    pCC-&gt;lNumTotCT ++;</a>
<a name="ln2857">    /* L7; L7: */</a>
<a name="ln2858">    /* if ( h_zeta == 0 ) goto L18; L18:*/</a>
<a name="ln2859">    h_zeta = t_eq_zeta = hz_zeta = k;</a>
<a name="ln2860">    CtPartInfinity( &amp;zf_zeta, NULL, k );</a>
<a name="ln2861">    /******************** &lt;&lt;&lt;===== B **************************/</a>
<a name="ln2862">    PartitionCopy( &amp;zeta, &amp;pi[k-1], n_tg );</a>
<a name="ln2863">    if ( lab ) {</a>
<a name="ln2864">        if ( pzb_rho_fix ) {</a>
<a name="ln2865">            if ( 0 == qzb_rho_fix ) {</a>
<a name="ln2866">                qzb_rho_fix = CtFullCompare( &amp;Lambda, pzb_rho_fix, 1, bSplitTautCompare );</a>
<a name="ln2867">                if ( qzb_rho_fix &gt; 0 ) {</a>
<a name="ln2868">                    hzb_rho_fix = 1;</a>
<a name="ln2869">                }</a>
<a name="ln2870">            }</a>
<a name="ln2871">            if ( hzb_rho_fix &gt; 1 ) {</a>
<a name="ln2872">                PartitionCopy( &amp;rho, &amp;pi[hzb_rho_fix-1], n_tg );</a>
<a name="ln2873">                /*CtPartInfinity( pzb_rho, qzb, k );*/</a>
<a name="ln2874">            }</a>
<a name="ln2875">            hz_rho = h_rho = hzb_rho_fix;</a>
<a name="ln2876">            bRhoIsDiscrete = (hzb_rho_fix == k);</a>
<a name="ln2877">            if ( bRhoIsDiscrete ) {</a>
<a name="ln2878">                CtPartInfinity( pzb_rho, qzb, k );</a>
<a name="ln2879">                pzb_rho_fix_reached = !qzb_rho_fix;</a>
<a name="ln2880">                CtCompareLayersGetFirstDiff( kLeast_rho_fix, nOneAdditionalLayer,</a>
<a name="ln2881">                                 &amp;L_rho_fix_prev, &amp;I_rho_fix_prev, &amp;k_rho_fix_prev );</a>
<a name="ln2882">            }</a>
<a name="ln2883">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2884">            else {</a>
<a name="ln2885">                int stop = 1;</a>
<a name="ln2886">            }</a>
<a name="ln2887">#endif</a>
<a name="ln2888">        } else {</a>
<a name="ln2889">            PartitionCopy( &amp;rho, &amp;pi[k-1], n_tg );</a>
<a name="ln2890">            hz_rho = h_rho = k;</a>
<a name="ln2891">            CtPartInfinity( pzb_rho, qzb, k );</a>
<a name="ln2892">        }</a>
<a name="ln2893">        qzb_rho = 0;</a>
<a name="ln2894">    }</a>
<a name="ln2895">    r = k;</a>
<a name="ln2896">    v[k-1] = INFINITY;     /* DCh */</a>
<a name="ln2897">    CellMakeEmpty( W, k ); /* DCh */</a>
<a name="ln2898">    k --;</a>
<a name="ln2899">    goto L13;</a>
<a name="ln2900"> </a>
<a name="ln2901"> </a>
<a name="ln2902">L2:</a>
<a name="ln2903">    /* the two next lines intentionally switched */</a>
<a name="ln2904">    /* Create equitable partition in pi[k]  */</a>
<a name="ln2905">    if ( 0 &gt; (ret=PartitionColorVertex( G, &amp;pi[k-1], v[k-1], n, n_tg, n_max, bDigraph, 0 )) ) {</a>
<a name="ln2906">        goto exit_error;</a>
<a name="ln2907">    }</a>
<a name="ln2908">    pCC-&gt;lNumBreakTies ++;</a>
<a name="ln2909">    k ++;</a>
<a name="ln2910">    CtPartFill( G, pCD, &amp;pi[k-1], &amp;Lambda, k-1, n, n_tg );</a>
<a name="ln2911">    e[k-1] = 0;         /* moved  */</a>
<a name="ln2912">    v[k-1] = INFINITY;  /* added by DCh. */</a>
<a name="ln2913">    CellMakeEmpty( W, k ); /* DCh */</a>
<a name="ln2914"> </a>
<a name="ln2915">    if ( hz_zeta == k-1 &amp;&amp; 0 == CtPartCompare( &amp;Lambda, &amp;zf_zeta, NULL, NULL, k-1, 0, bSplitTautCompare ) ) {</a>
<a name="ln2916">        hz_zeta = k; /* max{k|Lambda(G,pi,nu(k))==Lambda(G,pi,zeta) }  */</a>
<a name="ln2917">    } /* added */</a>
<a name="ln2918">    </a>
<a name="ln2919">    /* -- old code ---</a>
<a name="ln2920">    if ( pzb_rho_fix &amp;&amp; QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2921">        qzb_rho_fix = CtPartCompare( &amp;Lambda, pzb_rho_fix, qzb, kLeast_rho_fix, k-1, 1, bSplitTautCompare );</a>
<a name="ln2922">        if ( QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2923">            hzb_rho_fix = k;</a>
<a name="ln2924">        } else {</a>
<a name="ln2925">            pCC-&gt;lNumRejectedCT ++;</a>
<a name="ln2926">        }</a>
<a name="ln2927">    }</a>
<a name="ln2928">    */</a>
<a name="ln2929"> </a>
<a name="ln2930">    /* --- new code ---*/</a>
<a name="ln2931">    if ( pzb_rho_fix &amp;&amp; !qzb_rho_fix ) {</a>
<a name="ln2932">        qzb_rho_fix = CtPartCompare( &amp;Lambda, pzb_rho_fix, qzb, kLeast_rho_fix, k-1, 1, bSplitTautCompare );</a>
<a name="ln2933">        if ( !qzb_rho_fix &amp;&amp; bRhoIsDiscrete ) {</a>
<a name="ln2934">            qzb_rho_fix = CtPartCompareLayers( kLeast_rho_fix, L_rho_fix_prev, nOneAdditionalLayer );</a>
<a name="ln2935"> </a>
<a name="ln2936">#if ( FIX_ChCh_CONSTIT_CANON_BUG == 1 )</a>
<a name="ln2937">            if ( qzb_rho_fix ) {</a>
<a name="ln2938">                int L_rho_fix_diff = abs(qzb_rho_fix)-1;</a>
<a name="ln2939">                if ( L_rho_fix_diff &lt; L_rho_fix_prev ||</a>
<a name="ln2940">                     ((L_rho_fix_diff == L_rho_fix_prev) &amp;&amp;</a>
<a name="ln2941">                     (kLeast_rho_fix[L_rho_fix_diff].i &lt; I_rho_fix_prev)) ) {</a>
<a name="ln2942">                    qzb_rho_fix = L_rho_fix_diff+1; /* positive difference will be rejected */</a>
<a name="ln2943">                }</a>
<a name="ln2944">            }</a>
<a name="ln2945">#endif</a>
<a name="ln2946"> </a>
<a name="ln2947">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2948">            if ( qzb_rho_fix ) {</a>
<a name="ln2949">                int stop = 1; /* debug only */</a>
<a name="ln2950">            }</a>
<a name="ln2951">#endif</a>
<a name="ln2952">        }</a>
<a name="ln2953">        if ( !QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2954">            pCC-&gt;lNumRejectedCT ++;</a>
<a name="ln2955">        }</a>
<a name="ln2956">    }</a>
<a name="ln2957">    if ( pzb_rho_fix &amp;&amp; QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2958">        hzb_rho_fix = k;</a>
<a name="ln2959">    }</a>
<a name="ln2960">    /* if (!lab) goto L3; */</a>
<a name="ln2961">    if ( lab &amp;&amp; QZFIX_OK(qzb_rho_fix) ) {</a>
<a name="ln2962">        /* once the difference has been found it is meaningful as long as k increments */</a>
<a name="ln2963">        /* cur_qzb2 = CtPartCompare( &amp;Lambda, pzb_rho, qzb, k-1 ); */ /* rho compare */</a>
<a name="ln2964">        if ( hz_rho == k-1 &amp;&amp; !qzb_rho &amp;&amp; bRhoIsDiscrete ) {</a>
<a name="ln2965">            int qzb_rho_temp = 0;</a>
<a name="ln2966">            qzb_rho = CtPartCompare( &amp;Lambda, pzb_rho, qzb, kLeast_rho, k-1, 0, bSplitTautCompare );</a>
<a name="ln2967">            /* old code */</a>
<a name="ln2968">            if ( !qzb_rho &amp;&amp; pzb_rho_fix_reached &amp;&amp;</a>
<a name="ln2969">                  nOneAdditionalLayer &amp;&amp; 0 &gt; kLeast_rho[nOneAdditionalLayer].k ) {</a>
<a name="ln2970">                qzb_rho_temp = -(nOneAdditionalLayer+1);</a>
<a name="ln2971">                /* qzb_rho = -(nOneAdditionalLayer+1); *//* early rejection */</a>
<a name="ln2972">            }</a>
<a name="ln2973">            /* new code */</a>
<a name="ln2974">            if ( !qzb_rho &amp;&amp; bRhoIsDiscrete ) {</a>
<a name="ln2975">                qzb_rho = CtPartCompareLayers( kLeast_rho, L_rho_fix_prev, 0 );</a>
<a name="ln2976">#if ( FIX_ChCh_CONSTIT_CANON_BUG == 1 )</a>
<a name="ln2977">                if ( qzb_rho ) {</a>
<a name="ln2978">                    int L_rho_diff = abs(qzb_rho)-1;</a>
<a name="ln2979">                    if ( L_rho_diff &lt; L_rho_fix_prev ||</a>
<a name="ln2980">                         ((L_rho_diff == L_rho_fix_prev) &amp;&amp;</a>
<a name="ln2981">                         (kLeast_rho[L_rho_diff].i &lt; I_rho_fix_prev)) ) {</a>
<a name="ln2982">                        qzb_rho = -(L_rho_diff+1); /* negative difference will be rejected */</a>
<a name="ln2983">                    }</a>
<a name="ln2984">                }</a>
<a name="ln2985">#endif</a>
<a name="ln2986">            }</a>
<a name="ln2987">            /* compare old results to new */</a>
<a name="ln2988">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2989">            if ( qzb_rho_temp &amp;&amp; qzb_rho_temp != qzb_rho ) {</a>
<a name="ln2990">                int stop = 1; /* &lt;BRKPT&gt; */</a>
<a name="ln2991">            }</a>
<a name="ln2992">#endif</a>
<a name="ln2993">            if ( !qzb_rho ) {</a>
<a name="ln2994">                hz_rho = k;</a>
<a name="ln2995">            } else</a>
<a name="ln2996">            if ( qzb_rho &lt; 0 ) {</a>
<a name="ln2997">                pCC-&gt;lNumRejectedCT ++;</a>
<a name="ln2998">            }</a>
<a name="ln2999">        }</a>
<a name="ln3000">        if ( qzb_rho &gt; 0 || (!qzb_rho &amp;&amp; !bRhoIsDiscrete) ) {</a>
<a name="ln3001">            /* found better rho */</a>
<a name="ln3002">            if ( !nNumLayers ) {</a>
<a name="ln3003">                CtPartCopy( pzb_rho, &amp;Lambda, k-1 );</a>
<a name="ln3004">            }</a>
<a name="ln3005">        }</a>
<a name="ln3006">    }</a>
<a name="ln3007">/*L3:*/</a>
<a name="ln3008">    /*if ( hz_rho == k || (lab &amp;&amp; qzb_rho &gt;= 0 ) )*/</a>
<a name="ln3009">    /*if ( hz_zeta == k || hz_rho == k || (lab &amp;&amp; qzb_rho &gt;= 0 ) ) goto L4; else goto L6;*/</a>
<a name="ln3010">    if ( hz_zeta == k || hz_rho == k || (lab &amp;&amp; qzb_rho &gt;= 0 &amp;&amp; QZFIX_OK(qzb_rho_fix) ) ) {</a>
<a name="ln3011">        /*L4: check for possible isomorphism or found a better rho */</a>
<a name="ln3012">        if ( PartitionIsDiscrete( &amp;pi[k-1], n ) ) {</a>
<a name="ln3013">            pCC-&gt;lNumTotCT ++;</a>
<a name="ln3014">            goto L7;</a>
<a name="ln3015">        }</a>
<a name="ln3016">        PartitionGetFirstCell( &amp;pi[k-1], W, k, n );</a>
<a name="ln3017">        v[k-1] = CellGetMinNode( &amp;pi[k-1], &amp;W[k-1], 0, pCD1 );</a>
<a name="ln3018">        if ( !dig &amp;&amp; PartitionSatisfiesLemma_2_25(&amp;pi[k-1], n) ) {</a>
<a name="ln3019">            ; /* found additional isomprphism */</a>
<a name="ln3020">        } else {</a>
<a name="ln3021">            t_Lemma = k+1;</a>
<a name="ln3022">        }</a>
<a name="ln3023">        e[k-1] = 0;  /* created new cell W[k-1] */</a>
<a name="ln3024">        goto L2;</a>
<a name="ln3025">    }</a>
<a name="ln3026">L6:</a>
<a name="ln3027">    /* a better rho or no good node was found at this level; return to smaller k */</a>
<a name="ln3028">    k2 = k;</a>
<a name="ln3029">    k = inchi_min(t_Lemma-1, inchi_max(t_eq_zeta-1, hz_rho));</a>
<a name="ln3030">    if ( k2 == t_Lemma )</a>
<a name="ln3031">        goto L13;</a>
<a name="ln3032">    /* store isomorphism found from Lemma 2.25. should be dig=0 !!! */</a>
<a name="ln3033">    if ( dig ) {</a>
<a name="ln3034">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3035">        int stop = 1;</a>
<a name="ln3036">#endif</a>
<a name="ln3037">        goto L13;</a>
<a name="ln3038">    } </a>
<a name="ln3039">    l = inchi_min(l+1, L);</a>
<a name="ln3040">    PartitionGetMcrAndFixSet( &amp;pi[t_Lemma-1], &amp;Omega, &amp;Phi, n_tg, l );</a>
<a name="ln3041">    goto L12;</a>
<a name="ln3042">L7:</a>
<a name="ln3043">    /* from L4: pi[k-1] is discrete */</a>
<a name="ln3044">    if ( h_zeta == 0 ) {</a>
<a name="ln3045">        /*goto L18;*/  /* error. the first T(nu) leaf was found */</a>
<a name="ln3046">        ret = CT_CANON_ERR;</a>
<a name="ln3047">        goto exit_error;</a>
<a name="ln3048">    }</a>
<a name="ln3049">    if ( k != hz_zeta )</a>
<a name="ln3050">        goto L8;</a>
<a name="ln3051">    /*  here zeta^gamma == nu */</a>
<a name="ln3052">    /*  if ( G^gamma == G ) goto L10; */</a>
<a name="ln3053">    if ( 0 == (res=CtFullCompare( &amp;Lambda, &amp;zf_zeta, 0, bSplitTautCompare )) ) {</a>
<a name="ln3054">        PartitionGetTransposition( &amp;zeta, &amp;pi[k-1], n_tg, &amp;gamma );</a>
<a name="ln3055">        bZetaIsomorph = 1; /* for testing only */</a>
<a name="ln3056">        lNumEqlZeta ++;</a>
<a name="ln3057">        goto L10;</a>
<a name="ln3058">    } else</a>
<a name="ln3059">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3060">    {</a>
<a name="ln3061">        int stop = 1;</a>
<a name="ln3062">    }</a>
<a name="ln3063">#endif</a>
<a name="ln3064">    /* !!! we should never come here !!! */</a>
<a name="ln3065">    if ( !nNumLayers ) {</a>
<a name="ln3066">        ret = -2;</a>
<a name="ln3067">        goto exit_error;</a>
<a name="ln3068">    }</a>
<a name="ln3069"> </a>
<a name="ln3070">L8: /* here nu is discrete: check rho for being a bettere leaf or isomorphism */</a>
<a name="ln3071">    /*if ( !lab || qzb_rho &lt; 0 || !QZFIX_OK(qzb_rho_fix) )*/</a>
<a name="ln3072">    if ( !lab || ((qzb_rho &lt; 0) &amp;&amp; ( !pzb_rho_fix || qzb_rho_fix &gt; 0 )) )</a>
<a name="ln3073">        goto L6;</a>
<a name="ln3074">    if ( pzb_rho_fix &amp;&amp; kLeast_rho_fix &amp;&amp; 0 == qzb_rho_fix ) {</a>
<a name="ln3075">        /* check for the rejection condition: Lambda &gt; zb_rho_fix */</a>
<a name="ln3076">        if ( kLeast_rho_fix ) {</a>
<a name="ln3077">            int qzb_rho_fix_alt;</a>
<a name="ln3078">            qzb_rho_fix     = CtFullCompareLayers( kLeast_rho_fix );</a>
<a name="ln3079">            /* for debug only */</a>
<a name="ln3080">            qzb_rho_fix_alt =  CtFullCompare( &amp;Lambda, pzb_rho_fix, 1, bSplitTautCompare );</a>
<a name="ln3081">            if ( qzb_rho_fix != qzb_rho_fix_alt ) {</a>
<a name="ln3082">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3083">                int stop = 1;</a>
<a name="ln3084">#endif</a>
<a name="ln3085">                qzb_rho_fix = qzb_rho_fix_alt;</a>
<a name="ln3086">            }</a>
<a name="ln3087">            /* end debug */</a>
<a name="ln3088">        } else {</a>
<a name="ln3089">            qzb_rho_fix = CtFullCompare( &amp;Lambda, pzb_rho_fix, 1, bSplitTautCompare );</a>
<a name="ln3090">        }</a>
<a name="ln3091">        if ( !pzb_rho_fix_reached ) {</a>
<a name="ln3092">            pzb_rho_fix_reached = !qzb_rho_fix;</a>
<a name="ln3093">        }</a>
<a name="ln3094">        if ( 0 &lt; qzb_rho_fix ) {</a>
<a name="ln3095">            /* Lambda &gt; pzb_rho_fix, ignore this node */</a>
<a name="ln3096">            /* hzb_rho_fix = min( hzb_rho_fix, hz_rho ); */ /* ??? */</a>
<a name="ln3097">            qzb_rho_fix = 0;</a>
<a name="ln3098">            goto L6;</a>
<a name="ln3099">        }</a>
<a name="ln3100">        qzb_rho_fix = 0;</a>
<a name="ln3101">    }</a>
<a name="ln3102"> </a>
<a name="ln3103">    if ( qzb_rho &lt; 0 )</a>
<a name="ln3104">        goto L6;</a>
<a name="ln3105">    if ( qzb_rho &gt; 0 || !bRhoIsDiscrete )</a>
<a name="ln3106">        goto L9; /* note: p67 says k &gt; PartitionSize( &amp;rho, n ) */</a>
<a name="ln3107">    if ( k &lt; r ) {</a>
<a name="ln3108">        goto L9; /* cannot understand it... */</a>
<a name="ln3109">    }</a>
<a name="ln3110"> </a>
<a name="ln3111">    /* !!! we should never come here if G(nu) != G(rho): CtPartCompare must be enough !!! */</a>
<a name="ln3112">    </a>
<a name="ln3113">    /* if ( G(nu) &gt; G(rho) ) goto L9; */</a>
<a name="ln3114">    if ( kLeast_rho ) {</a>
<a name="ln3115">        int cur_qzb_alt;</a>
<a name="ln3116">        qzb_rho =     CtFullCompareLayers( kLeast_rho );</a>
<a name="ln3117">        /* for debug only */</a>
<a name="ln3118">        cur_qzb_alt = CtFullCompare( &amp;Lambda, pzb_rho, 0, bSplitTautCompare );</a>
<a name="ln3119">        if ( qzb_rho != cur_qzb_alt ) {</a>
<a name="ln3120">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3121">            int stop = 1;</a>
<a name="ln3122">#endif</a>
<a name="ln3123">            qzb_rho = cur_qzb_alt;</a>
<a name="ln3124">        }</a>
<a name="ln3125">        /* end debug */</a>
<a name="ln3126">    } else {</a>
<a name="ln3127">        qzb_rho = CtFullCompare( &amp;Lambda, pzb_rho, 0, bSplitTautCompare );</a>
<a name="ln3128">    }</a>
<a name="ln3129">    /* qzb_rho difference can be due to layers 1..MAX_LAYERS-1 only */</a>
<a name="ln3130">    if ( 0 &lt; qzb_rho ) {</a>
<a name="ln3131">        /* CtFullCompare( &amp;Lambda, pzb_rho, 0, bSplitTautCompare ); */</a>
<a name="ln3132">        qzb_rho = 0;</a>
<a name="ln3133">        goto L9;</a>
<a name="ln3134">    }</a>
<a name="ln3135">    /* if ( G(nu) &lt; G(rho) ) goto L6; */</a>
<a name="ln3136">    if ( 0 &gt; qzb_rho ) {</a>
<a name="ln3137">        qzb_rho = 0;</a>
<a name="ln3138">        goto L6;</a>
<a name="ln3139">    }</a>
<a name="ln3140">    /* nu^gamma == rho */</a>
<a name="ln3141">    if ( r != k ) {  /* if() is for debug only */</a>
<a name="ln3142">        r = k;</a>
<a name="ln3143">    }</a>
<a name="ln3144">    PartitionGetTransposition( &amp;pi[k-1], &amp;rho, n_tg, &amp;gamma );</a>
<a name="ln3145">    bZetaIsomorph = 0; /* DCh */</a>
<a name="ln3146">    pCC-&gt;lNumEqualCT ++;</a>
<a name="ln3147">    goto L10;</a>
<a name="ln3148">L9:</a>
<a name="ln3149">    /* rho := nu; */</a>
<a name="ln3150">    PartitionCopy( &amp;rho, &amp;pi[k-1], n_tg );</a>
<a name="ln3151">    if ( nNumLayers ) {</a>
<a name="ln3152">        CtFullCopy( pzb_rho, &amp;Lambda );</a>
<a name="ln3153">    }</a>
<a name="ln3154">    bZetaEqRho = 0;</a>
<a name="ln3155">    qzb_rho = 0;</a>
<a name="ln3156">    CtCompareLayersGetFirstDiff( kLeast_rho_fix, nOneAdditionalLayer,</a>
<a name="ln3157">                                 &amp;L_rho_fix_prev, &amp;I_rho_fix_prev, &amp;k_rho_fix_prev );</a>
<a name="ln3158">    memset( kLeast_rho, 0, sizeof(kLeast_rho) );</a>
<a name="ln3159">    h_rho = hz_rho = k;</a>
<a name="ln3160">    CtPartInfinity( pzb_rho, qzb, k );</a>
<a name="ln3161">    pCC-&gt;lNumDecreasedCT ++;</a>
<a name="ln3162">    pCC-&gt;lNumEqualCT = 1;</a>
<a name="ln3163">    bRhoIsDiscrete = 1;</a>
<a name="ln3164">    goto L6;</a>
<a name="ln3165"> </a>
<a name="ln3166">L10: /* discrete pi[k-1] &amp;&amp; G^gamma == G */</a>
<a name="ln3167"> </a>
<a name="ln3168">    pCC-&gt;lNumEqualCT += bZetaEqRho || !(bZetaIsomorph || qzb_rho);</a>
<a name="ln3169">    l = inchi_min(l+1, L);</a>
<a name="ln3170">    /* Omega[l] := mcr(gamma);</a>
<a name="ln3171">       Phi[l]   := fix(gamma);</a>
<a name="ln3172">    */</a>
<a name="ln3173">    TranspositionGetMcrAndFixSetAndUnorderedPartition( &amp;gamma, &amp;Omega, &amp;Phi, n_tg, l, &amp;theta_from_gamma );</a>
<a name="ln3174"> </a>
<a name="ln3175">    /*</a>
<a name="ln3176">    if ( theta(gamma) &lt;= theta ) goto L11;</a>
<a name="ln3177">    theta := theta v theta(gamma);</a>
<a name="ln3178">    UnorderedPartitionJoin() returns 0 if theta_from_gamma is finer than theta,</a>
<a name="ln3179">    which means no changes in theta: theta_from_gamma ^ theta == theta.</a>
<a name="ln3180">    */</a>
<a name="ln3181">    if ( !UnorderedPartitionJoin( &amp;theta_from_gamma, &amp;theta, n_tg ) )</a>
<a name="ln3182">        goto L11; /* no new isomorphism found */</a>
<a name="ln3183">    /*  Output gamma (it is the Aut(G) generator) -- omitted -- */</a>
<a name="ln3184">    nNumFoundGenerators ++;</a>
<a name="ln3185">    /* if ( tvc in mcr(theta) ) goto L11; */</a>
<a name="ln3186">    if ( tvc == GetUnorderedPartitionMcrNode( &amp;theta, tvc ) )</a>
<a name="ln3187">        goto L11;</a>
<a name="ln3188">    k = h_zeta;</a>
<a name="ln3189">    goto L13;</a>
<a name="ln3190">L11:</a>
<a name="ln3191">    k = lab? h_rho : h_zeta; /***Changed*** originally was k = h_rho; */</a>
<a name="ln3192">L12:</a>
<a name="ln3193">    /* if ( e[k-1] == 1 ) */</a>
<a name="ln3194">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3195">    if ( e[k-1] == 1 &amp;&amp; v[k-1] == INFINITY ) {</a>
<a name="ln3196">        int stop = 1;          /* &lt;BRKPT&gt; testing only */</a>
<a name="ln3197">    }</a>
<a name="ln3198">#endif</a>
<a name="ln3199">    if ( e[k-1] == 1 &amp;&amp; v[k-1] != INFINITY ) { /* INFINITY for testing only */</a>
<a name="ln3200">        CellIntersectWithSet( &amp;pi[k-1], &amp;W[k-1], &amp;Omega, l );</a>
<a name="ln3201">    }</a>
<a name="ln3202">L13:</a>
<a name="ln3203">    </a>
<a name="ln3204">    if ( (UserAction &amp;&amp; USER_ACTION_QUIT == (*UserAction)()) ||</a>
<a name="ln3205">         (ConsoleQuit &amp;&amp; (*ConsoleQuit)()) ) {</a>
<a name="ln3206">        ret = CT_USER_QUIT_ERR;</a>
<a name="ln3207">        goto exit_error;</a>
<a name="ln3208">    }</a>
<a name="ln3209">    if ( bInchiTimeIsOver(pCD-&gt;ulTimeOutTime) ) {</a>
<a name="ln3210">        ret = CT_TIMEOUT_ERR;</a>
<a name="ln3211">        goto exit_error;</a>
<a name="ln3212">    }</a>
<a name="ln3213">    </a>
<a name="ln3214">    if ( k == 0 )</a>
<a name="ln3215">        goto exit_function; /* stop */</a>
<a name="ln3216"> </a>
<a name="ln3217">    if ( lab &amp;&amp; k &lt; h_rho ) {  /***Added***/</a>
<a name="ln3218">        h_rho = k;</a>
<a name="ln3219">    }</a>
<a name="ln3220">    if ( k &gt;  h_zeta ) {</a>
<a name="ln3221">        if ( v[k-1] == INFINITY ) {/*** Added by DCh for testing only ****/</a>
<a name="ln3222">            k --;</a>
<a name="ln3223">            goto L13;</a>
<a name="ln3224">        }</a>
<a name="ln3225">        goto L17;</a>
<a name="ln3226">    }</a>
<a name="ln3227">    if ( k == h_zeta )</a>
<a name="ln3228">        goto L14;</a>
<a name="ln3229">    h_zeta = k;</a>
<a name="ln3230">    tvc = tvh = CellGetMinNode( &amp;pi[k-1], &amp;W[k-1], 0, pCD1 );</a>
<a name="ln3231">L14:</a>
<a name="ln3232">    /* if v[k] and tvh are in the same cell of theta then index ++ */</a>
<a name="ln3233">    if ( GetUnorderedPartitionMcrNode( &amp;theta, v[k-1] ) ==</a>
<a name="ln3234">         GetUnorderedPartitionMcrNode( &amp;theta, tvh ) ) {</a>
<a name="ln3235">        index ++;</a>
<a name="ln3236">    }</a>
<a name="ln3237">    v[k-1] = CellGetMinNode(  &amp;pi[k-1], &amp;W[k-1], v[k-1], pCD1 );</a>
<a name="ln3238"> </a>
<a name="ln3239">    if ( v[k-1] == INFINITY )</a>
<a name="ln3240">        goto L16;</a>
<a name="ln3241">    if ( v[k-1] != GetUnorderedPartitionMcrNode( &amp;theta, v[k-1] ) )</a>
<a name="ln3242">        goto L14;</a>
<a name="ln3243">L15:</a>
<a name="ln3244">    t_Lemma = inchi_min(t_Lemma, k+1);</a>
<a name="ln3245">    hz_zeta = inchi_min(hz_zeta, k);</a>
<a name="ln3246">/*    </a>
<a name="ln3247">    if ( lab &amp;&amp; hz_rho &gt;= k ) {</a>
<a name="ln3248">        hz_rho = k;</a>
<a name="ln3249">        qzb_rho = 0;</a>
<a name="ln3250">    }</a>
<a name="ln3251">*/</a>
<a name="ln3252">    if ( lab ) {</a>
<a name="ln3253">        if ( hz_rho &gt;= k /*-1*/ )</a>
<a name="ln3254">            qzb_rho = 0;</a>
<a name="ln3255">        if ( hz_rho &gt; k )</a>
<a name="ln3256">            hz_rho = k;</a>
<a name="ln3257">        UpdateCompareLayers( kLeast_rho, hz_rho );</a>
<a name="ln3258">    }</a>
<a name="ln3259">    if ( pzb_rho_fix ) {</a>
<a name="ln3260">        if ( hzb_rho_fix &gt;= k /*-1*/ )</a>
<a name="ln3261">            qzb_rho_fix = 0;</a>
<a name="ln3262">        if ( hzb_rho_fix &gt; k )</a>
<a name="ln3263">            hzb_rho_fix = k;</a>
<a name="ln3264">        UpdateCompareLayers( kLeast_rho_fix, hzb_rho_fix );</a>
<a name="ln3265">    }</a>
<a name="ln3266"> </a>
<a name="ln3267">    goto L2;</a>
<a name="ln3268">L16:</a>
<a name="ln3269">    if ( t_eq_zeta == k+1 &amp;&amp; index == CellGetNumberOfNodes( &amp;pi[k-1], &amp;W[k-1] ) )</a>
<a name="ln3270">        t_eq_zeta = k;</a>
<a name="ln3271">    size *= (double)index;</a>
<a name="ln3272">    /******************** &lt;&lt;&lt;===== A **************************/</a>
<a name="ln3273">    /* passed K times after passing point A. At these passes</a>
<a name="ln3274">       k = K, K-1, ..., 1 in this order</a>
<a name="ln3275">    */</a>
<a name="ln3276">    index = 0;</a>
<a name="ln3277">    k --;</a>
<a name="ln3278">    goto L13;</a>
<a name="ln3279">L17:</a>
<a name="ln3280">    /* if ( e[k-1] == 0 ) */</a>
<a name="ln3281">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln3282">    if ( e[k-1] == 0 &amp;&amp; v[k-1] == INFINITY ) { /* testing only */</a>
<a name="ln3283">        int stop = 1;  /* &lt;BRKPT&gt; */</a>
<a name="ln3284">    }</a>
<a name="ln3285">#endif</a>
<a name="ln3286">    /*</a>
<a name="ln3287">    if ( e[k] == 0 set W[k] = Intersection(W[k], Omega[i]) for each i = 1..l,</a>
<a name="ln3288">         such that {v[1]..v[k-1]} in Phi[i]</a>
<a name="ln3289">    */</a>
<a name="ln3290">    if ( e[k-1] == 0 &amp;&amp; v[k-1] != INFINITY ) /* Added v[k-1]!=... DCh */</a>
<a name="ln3291">    {</a>
<a name="ln3292">        NodeSetFromVertices( &amp;cur_nodes, 1, v, k-1 );</a>
<a name="ln3293">        for ( i = 1; i &lt;= l; i ++ ) {</a>
<a name="ln3294">            if ( AllNodesAreInSet( &amp;cur_nodes, 1, &amp;Phi, i ) ) {</a>
<a name="ln3295">                CellIntersectWithSet( &amp;pi[k-1], &amp;W[k-1],  &amp;Omega, i );</a>
<a name="ln3296">            }</a>
<a name="ln3297">        }</a>
<a name="ln3298">    }</a>
<a name="ln3299">    e[k-1] = 1;</a>
<a name="ln3300">    v[k-1] = CellGetMinNode(  &amp;pi[k-1], &amp;W[k-1], v[k-1], pCD1 );</a>
<a name="ln3301">    if ( v[k-1] != INFINITY )</a>
<a name="ln3302">        goto L15;</a>
<a name="ln3303">    k --;</a>
<a name="ln3304">    goto L13;</a>
<a name="ln3305">/* L18: see above */</a>
<a name="ln3306"> </a>
<a name="ln3307">exit_function:</a>
<a name="ln3308">    /* CtPartFill( G, pCD, &amp;rho, pzb_rho, 1, n, n_tg ); */</a>
<a name="ln3309">    if ( !bRhoIsDiscrete ) {</a>
<a name="ln3310">        ret = CT_CANON_ERR;</a>
<a name="ln3311">        goto exit_error;</a>
<a name="ln3312">    }</a>
<a name="ln3313">    if ( pzb_rho_fix ) {</a>
<a name="ln3314">        qzb_rho_fix = CtFullCompare( pzb_rho_fix, pzb_rho, 1, bSplitTautCompare );</a>
<a name="ln3315">        if ( qzb_rho_fix ) {</a>
<a name="ln3316">            ret = CT_CANON_ERR;</a>
<a name="ln3317">            goto exit_error;</a>
<a name="ln3318">        }</a>
<a name="ln3319">    }</a>
<a name="ln3320">    /* SymmRank */</a>
<a name="ln3321">    memset( nSymmRank, 0, n_tg * sizeof(nSymmRank[0]) );</a>
<a name="ln3322">    for ( i = 0; i &lt; n_tg; i ++ ) {</a>
<a name="ln3323">        k = rho.AtNumber[i];</a>
<a name="ln3324">        k2 = (int)GetUnorderedPartitionMcrNode( &amp;theta, (AT_NUMB)(k+1) ) - 1;</a>
<a name="ln3325">        if ( !nSymmRank[k2] || nSymmRank[k2] &gt; rho.Rank[k] ) {</a>
<a name="ln3326">            nSymmRank[k2] = rho.Rank[k];</a>
<a name="ln3327">        }</a>
<a name="ln3328">    }</a>
<a name="ln3329">    for ( i = 0; i &lt; n_tg; i ++ ) {</a>
<a name="ln3330">        k = rho.AtNumber[i];</a>
<a name="ln3331">        k2 = (int)GetUnorderedPartitionMcrNode( &amp;theta, (AT_NUMB)(k+1) ) - 1;</a>
<a name="ln3332">        nSymmRank[k] = nSymmRank[k2];</a>
<a name="ln3333">    }</a>
<a name="ln3334">    /* CanonRank, nAtomNumberCanon */</a>
<a name="ln3335">    memcpy( nCanonRank, rho.Rank, n_tg * sizeof(nCanonRank[0]) );</a>
<a name="ln3336">    memcpy( nAtomNumberCanon, rho.AtNumber, n_tg * sizeof(nAtomNumberCanon[0]) );</a>
<a name="ln3337">    /* LinearCT */</a>
<a name="ln3338">    *nLenCt = pzb_rho-&gt;lenCt-1;</a>
<a name="ln3339">    if ( pCt ) {</a>
<a name="ln3340">        memcpy( pCt, pzb_rho-&gt;Ctbl, *nLenCt*sizeof(pCt[0]) );</a>
<a name="ln3341">    }</a>
<a name="ln3342">    pCC-&gt;lNumTotCT = pCC-&gt;lNumDecreasedCT + pCC-&gt;lNumRejectedCT + pCC-&gt;lNumEqualCT;</a>
<a name="ln3343">    pCC-&gt;dGroupSize             = size;</a>
<a name="ln3344">    pCC-&gt;lNumGenerators         = nNumFoundGenerators;</a>
<a name="ln3345">    pCC-&gt;lNumStoredIsomorphisms = l;</a>
<a name="ln3346">    /* Note: check nNumFoundGenerators */</a>
<a name="ln3347"> </a>
<a name="ln3348">    if ( pp_zb_rho_out &amp;&amp; !*pp_zb_rho_out ) {</a>
<a name="ln3349">        *pp_zb_rho_out = pzb_rho;</a>
<a name="ln3350">        pzb_rho = NULL;</a>
<a name="ln3351">    }</a>
<a name="ln3352">    </a>
<a name="ln3353">exit_error:</a>
<a name="ln3354">    INCHI_HEAPCHK</a>
<a name="ln3355"> </a>
<a name="ln3356">    UnorderedPartitionFree( &amp;theta );</a>
<a name="ln3357">    UnorderedPartitionFree( &amp;theta_from_gamma );</a>
<a name="ln3358">    if ( W )   inchi_free( W );</a>
<a name="ln3359">    if ( v )   inchi_free( v );</a>
<a name="ln3360">    if ( e )   inchi_free( e );</a>
<a name="ln3361">    if ( qzb ) inchi_free( qzb );</a>
<a name="ln3362">    CTableFree( &amp;Lambda );</a>
<a name="ln3363">    CTableFree( &amp;zf_zeta );</a>
<a name="ln3364">    if ( pzb_rho ) {</a>
<a name="ln3365">        CTableFree( pzb_rho );</a>
<a name="ln3366">        inchi_free( pzb_rho );</a>
<a name="ln3367">        pzb_rho = NULL;</a>
<a name="ln3368">    }</a>
<a name="ln3369"> </a>
<a name="ln3370">/*    CTableFree( &amp;zf_zeta2 ); */</a>
<a name="ln3371"> </a>
<a name="ln3372"> </a>
<a name="ln3373">    NodeSetFree( &amp;Omega );</a>
<a name="ln3374">    NodeSetFree( &amp;Phi );</a>
<a name="ln3375">  /* NodeSetFree( &amp;mcr_theta, n, 1 ); */</a>
<a name="ln3376">    NodeSetFree( &amp;cur_nodes );</a>
<a name="ln3377"> </a>
<a name="ln3378">    PartitionFree( &amp;zeta );</a>
<a name="ln3379">/*    PartitionFree( &amp;zeta2 ); */</a>
<a name="ln3380">    PartitionFree( &amp;rho );</a>
<a name="ln3381">    TranspositionFree( &amp;gamma );</a>
<a name="ln3382"> </a>
<a name="ln3383"> </a>
<a name="ln3384">    return ret;</a>
<a name="ln3385">}</a>
<a name="ln3386">/**********************************************************************************************</a>
<a name="ln3387"> * SetInitialRanks2: Set initial ranks in nRank according to pAtomInvariant[] values</a>
<a name="ln3388"> *                  Make sure enough prines have been generated.</a>
<a name="ln3389"> **********************************************************************************************/</a>
<a name="ln3390">/* Upon exit: */</a>
<a name="ln3391">/* nAtomNumber[i]: number (from 0) of an atom in the ith (from 0) position of the sorted order */</a>
<a name="ln3392">/* nNewRank[i]:    initial rank of the atom[i] based on atom invariants; from 1 to num_atoms */</a>
<a name="ln3393">/* Return value:   Number of different ranks */</a>
<a name="ln3394">int SetInitialRanks2( int num_atoms, ATOM_INVARIANT2* pAtomInvariant2, AT_RANK *nNewRank, AT_RANK *nAtomNumber )</a>
<a name="ln3395">{</a>
<a name="ln3396">    int i, nNumDiffRanks;</a>
<a name="ln3397">    AT_RANK nCurrentRank;</a>
<a name="ln3398"> </a>
<a name="ln3399">    for ( i = 0; i &lt; num_atoms; i++ )</a>
<a name="ln3400">        nAtomNumber[i] = (AT_RANK)i;</a>
<a name="ln3401">    </a>
<a name="ln3402">    /* global for qsort */</a>
<a name="ln3403">    pAtomInvariant2ForSort = pAtomInvariant2;</a>
<a name="ln3404"> </a>
<a name="ln3405">    qsort( nAtomNumber, num_atoms, sizeof(nAtomNumber[0]), CompAtomInvariants2 );</a>
<a name="ln3406"> </a>
<a name="ln3407">    /* nNewRank[i]: non-decreading order; do not increment nCurrentRank */</a>
<a name="ln3408">    /*           if consecutive sorted atom invariants are identical */</a>
<a name="ln3409"> </a>
<a name="ln3410">    for ( i=num_atoms-1, nCurrentRank=nNewRank[nAtomNumber[i]] = (AT_RANK)num_atoms, nNumDiffRanks = 1; 0 &lt; i ; i -- ) {</a>
<a name="ln3411">        /* Note: CompAtomInvariants2Only() in following line implicitly reads pAtomInvariant2 pointed by pAtomInvariant2ForSort */</a>
<a name="ln3412">        if ( CompAtomInvariants2Only( &amp;nAtomNumber[i-1], &amp;nAtomNumber[i] ) ) {</a>
<a name="ln3413">            nNumDiffRanks ++;</a>
<a name="ln3414">            nCurrentRank = (AT_RANK)i;</a>
<a name="ln3415">        }</a>
<a name="ln3416">        nNewRank[nAtomNumber[i - 1]] = nCurrentRank;</a>
<a name="ln3417">    }</a>
<a name="ln3418">    </a>
<a name="ln3419">    </a>
<a name="ln3420">    return nNumDiffRanks;</a>
<a name="ln3421">}</a>
<a name="ln3422"> </a>
<a name="ln3423">/****************************************************************************/</a>
<a name="ln3424">void FillOutAtomInvariant2( sp_ATOM* at, int num_atoms, int num_at_tg, ATOM_INVARIANT2* pAtomInvariant,</a>
<a name="ln3425">                           int bIgnoreIsotopic, int bHydrogensInRanks, int bHydrogensFixedInRanks,</a>
<a name="ln3426">                           int bDigraph, int bTautGroupsOnly, T_GROUP_INFO *t_group_info )</a>
<a name="ln3427">{</a>
<a name="ln3428">    int i, k, j, i_t_group;</a>
<a name="ln3429">    /* tautomers */</a>
<a name="ln3430">    T_GROUP          *t_group=NULL;</a>
<a name="ln3431">    int               num_t_groups     = 0;</a>
<a name="ln3432">    int               num_tautomer_iso = 0;</a>
<a name="ln3433">#define ELEM_NAME_LEN  2</a>
<a name="ln3434">    char ChemElements[ELEM_NAME_LEN*NUM_CHEM_ELEMENTS+ELEM_NAME_LEN];</a>
<a name="ln3435">    char CurElement[ELEM_NAME_LEN + ELEM_NAME_LEN], *pCurElem;</a>
<a name="ln3436">    int  nNumChemElements  = 0;</a>
<a name="ln3437">    int  nNumHydrogenAtoms = 0;</a>
<a name="ln3438">    int  nNumCarbonAtoms   = 0;</a>
<a name="ln3439">    memset( ChemElements, 0, sizeof(ChemElements) );</a>
<a name="ln3440">    memset( CurElement,   0, sizeof(CurElement)   );</a>
<a name="ln3441">    nNumChemElements = 0;</a>
<a name="ln3442"> </a>
<a name="ln3443">    if ( num_at_tg &gt; num_atoms &amp;&amp; t_group_info ) {</a>
<a name="ln3444">        t_group          = t_group_info-&gt;t_group;</a>
<a name="ln3445">        num_t_groups     = t_group_info-&gt;num_t_groups;</a>
<a name="ln3446">        num_tautomer_iso = t_group_info-&gt;bIgnoreIsotopic? 0 : T_NUM_ISOTOPIC;</a>
<a name="ln3447">    }</a>
<a name="ln3448"> </a>
<a name="ln3449">    if ( !bTautGroupsOnly ) {</a>
<a name="ln3450"> </a>
<a name="ln3451">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3452">            if ( !strcmp( at[i].elname, &quot;C&quot; ) ) {</a>
<a name="ln3453">                nNumCarbonAtoms ++;</a>
<a name="ln3454">            } else</a>
<a name="ln3455">            if ( !strcmp( at[i].elname, &quot;H&quot; ) ||</a>
<a name="ln3456">                 !strcmp( at[i].elname, &quot;D&quot; ) ||</a>
<a name="ln3457">                 !strcmp( at[i].elname, &quot;T&quot; ) ) {</a>
<a name="ln3458">                nNumHydrogenAtoms ++;</a>
<a name="ln3459">            } else {</a>
<a name="ln3460">                CurElement[0] = at[i].elname[0];</a>
<a name="ln3461">                CurElement[1] = at[i].elname[1]? at[i].elname[1] : ' ';</a>
<a name="ln3462">                if ( ! (pCurElem = strstr( ChemElements, CurElement ) ) ) {</a>
<a name="ln3463">                    strcat( ChemElements, CurElement );</a>
<a name="ln3464">                    nNumChemElements ++;</a>
<a name="ln3465">                }</a>
<a name="ln3466">            }</a>
<a name="ln3467">        }</a>
<a name="ln3468">        if ( nNumChemElements &gt; 1 ) {</a>
<a name="ln3469">            qsort( ChemElements, nNumChemElements, ELEM_NAME_LEN, CompChemElemLex );</a>
<a name="ln3470">        }</a>
<a name="ln3471">        if ( nNumCarbonAtoms ) {</a>
<a name="ln3472">            if ( nNumChemElements ) {</a>
<a name="ln3473">                memmove( ChemElements + ELEM_NAME_LEN, ChemElements, ELEM_NAME_LEN*nNumChemElements );</a>
<a name="ln3474">            }</a>
<a name="ln3475">            ChemElements[0] = 'C';</a>
<a name="ln3476">            ChemElements[1] = ' ';</a>
<a name="ln3477">            nNumChemElements ++;</a>
<a name="ln3478">        }</a>
<a name="ln3479">        if ( nNumHydrogenAtoms ) {</a>
<a name="ln3480">            ChemElements[ ELEM_NAME_LEN*nNumChemElements   ] = 'H';</a>
<a name="ln3481">            ChemElements[ ELEM_NAME_LEN*nNumChemElements+1 ] = ' ';</a>
<a name="ln3482">            nNumChemElements ++;</a>
<a name="ln3483">        }</a>
<a name="ln3484"> </a>
<a name="ln3485"> </a>
<a name="ln3486">        /* general */</a>
<a name="ln3487">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3488">            memset( &amp;pAtomInvariant[i], 0, sizeof(pAtomInvariant[0]) );</a>
<a name="ln3489">            CurElement[0] = at[i].elname[0];</a>
<a name="ln3490">            CurElement[1] = at[i].elname[1]? at[i].elname[1] : ' ';</a>
<a name="ln3491">            pCurElem = strstr( ChemElements, CurElement );</a>
<a name="ln3492">            if ( pCurElem ) {</a>
<a name="ln3493">                j = (pCurElem - ChemElements)/ELEM_NAME_LEN + 1;</a>
<a name="ln3494">            } else {</a>
<a name="ln3495">                j = nNumChemElements; /* must be D or T */</a>
<a name="ln3496">            }</a>
<a name="ln3497">            /* at[i].hill_type = (U_CHAR) j; */</a>
<a name="ln3498">            pAtomInvariant[i].val[AT_INV_HILL_ORDER] = j;</a>
<a name="ln3499"> </a>
<a name="ln3500">            pAtomInvariant[i].val[AT_INV_NUM_CONNECTIONS] = at[i].valence;</a>
<a name="ln3501">            if ( bHydrogensInRanks ) {</a>
<a name="ln3502">                pAtomInvariant[i].val[AT_INV_NUM_H] = ((t_group &amp;&amp; at[i].endpoint&gt;0)? 0 : at[i].num_H);</a>
<a name="ln3503">            }</a>
<a name="ln3504">            if ( bHydrogensFixedInRanks ) {</a>
<a name="ln3505">                pAtomInvariant[i].val[AT_INV_NUM_H_FIX] = ((t_group &amp;&amp; at[i].endpoint&gt;0)? at[i].num_H : 0);</a>
<a name="ln3506">            }</a>
<a name="ln3507">            if ( !bDigraph &amp;&amp;  t_group &amp;&amp; (i_t_group = (int)at[i].endpoint-1) &gt;= 0 &amp;&amp; i_t_group &lt; num_t_groups ) {</a>
<a name="ln3508">                pAtomInvariant[i].val[AT_INV_NUM_TG_ENDPOINTS]  = t_group[i_t_group].nNumEndpoints;</a>
<a name="ln3509">                for ( j = 0; j &lt; T_NUM_NO_ISOTOPIC; j ++ ) {</a>
<a name="ln3510">                    pAtomInvariant[i].val[AT_INV_TG_NUMBERS+j] = t_group[i_t_group].num[j];</a>
<a name="ln3511">                }</a>
<a name="ln3512">                for ( j = 0; j &lt; num_tautomer_iso; j ++ ) {</a>
<a name="ln3513">                    pAtomInvariant[i].val[AT_INV_TAUT_ISO+j] = t_group[i_t_group].num[j + T_NUM_NO_ISOTOPIC];</a>
<a name="ln3514">                }</a>
<a name="ln3515">            }</a>
<a name="ln3516">            pAtomInvariant[i].iso_sort_key = bIgnoreIsotopic? 0 : at[i].iso_sort_key;</a>
<a name="ln3517">        }</a>
<a name="ln3518">    } else {</a>
<a name="ln3519">        /* fill tautomeric groups only */</a>
<a name="ln3520">        memset ( pAtomInvariant, 0, num_at_tg*sizeof(pAtomInvariant[0]) );</a>
<a name="ln3521">    }</a>
<a name="ln3522">    /**************************************/</a>
<a name="ln3523">    /*          tautomeric groups         */</a>
<a name="ln3524">    /**************************************/</a>
<a name="ln3525">    for ( i = num_atoms; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln3526"> </a>
<a name="ln3527">        k = i - num_atoms;</a>
<a name="ln3528">        memset( &amp;pAtomInvariant[i], 0, sizeof(pAtomInvariant[0]) );</a>
<a name="ln3529">        if ( !t_group )</a>
<a name="ln3530">            continue;</a>
<a name="ln3531">        /* make sure ranks of t-groups are larger than that of any atom */</a>
<a name="ln3532">         /* greater than for any real atom */</a>
<a name="ln3533">        pAtomInvariant[i].val[AT_INV_HILL_ORDER] = bTautGroupsOnly? num_at_tg : nNumChemElements+1;</a>
<a name="ln3534">        /* greater than for any real atom */</a>
<a name="ln3535">        pAtomInvariant[i].val[AT_INV_NUM_CONNECTIONS] = MAXVAL+1;</a>
<a name="ln3536">        if ( k &lt; num_t_groups ) {</a>
<a name="ln3537">            pAtomInvariant[i].val[AT_INV_NUM_TG_ENDPOINTS] = t_group[k].nNumEndpoints;</a>
<a name="ln3538">            for ( j = 0; j &lt; T_NUM_NO_ISOTOPIC; j ++ ) {</a>
<a name="ln3539">                pAtomInvariant[i].val[AT_INV_TAUT_ISO+j] = t_group[k].num[j];</a>
<a name="ln3540">            }</a>
<a name="ln3541">            for ( j = 0; j &lt; num_tautomer_iso; j ++ ) {</a>
<a name="ln3542">                pAtomInvariant[i].val[AT_INV_TAUT_ISO+j] = t_group[k].num[j + T_NUM_NO_ISOTOPIC];</a>
<a name="ln3543">            }</a>
<a name="ln3544">        }</a>
<a name="ln3545">    }</a>
<a name="ln3546">}</a>
<a name="ln3547">/*****************************************************************************/</a>
<a name="ln3548">void CleanNumH( NUM_H *NumH, int len )</a>
<a name="ln3549">{</a>
<a name="ln3550">    int i;</a>
<a name="ln3551">    if ( NumH ) {</a>
<a name="ln3552">        for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln3553">            if ( NumH[i] == EMPTY_H_NUMBER ) {</a>
<a name="ln3554">                NumH[i] = 0;</a>
<a name="ln3555">            } else {</a>
<a name="ln3556">                NumH[i] -= BASE_H_NUMBER;</a>
<a name="ln3557">            }</a>
<a name="ln3558">        }</a>
<a name="ln3559">    }</a>
<a name="ln3560">}</a>
<a name="ln3561">/*****************************************************************************/</a>
<a name="ln3562">int CleanCt( AT_RANK *Ct, int len )</a>
<a name="ln3563">{</a>
<a name="ln3564">    if ( Ct &amp;&amp; Ct[len] == EMPTY_CT ) {</a>
<a name="ln3565">        Ct[len] = 0;</a>
<a name="ln3566">        return 1;</a>
<a name="ln3567">    }</a>
<a name="ln3568">    return 0;</a>
<a name="ln3569">}</a>
<a name="ln3570">/*****************************************************************************/</a>
<a name="ln3571">void CleanIsoSortKeys( AT_ISO_SORT_KEY * isk, int len )</a>
<a name="ln3572">{</a>
<a name="ln3573">    int i;</a>
<a name="ln3574">    if ( isk ) {</a>
<a name="ln3575">        for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln3576">            if ( isk[i] == EMPTY_ISO_SORT_KEY ) {</a>
<a name="ln3577">                isk[i] = 0;</a>
<a name="ln3578">            }</a>
<a name="ln3579">        }</a>
<a name="ln3580">    }</a>
<a name="ln3581">}</a>
<a name="ln3582">/*****************************************************************************/</a>
<a name="ln3583">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln3584">void MergeCleanIsoSortKeys( AT_ISO_SORT_KEY * isk1, AT_ISO_SORT_KEY * isk2, int len )</a>
<a name="ln3585">{</a>
<a name="ln3586">    int i;</a>
<a name="ln3587">    AT_ISO_SORT_KEY k1, k2;</a>
<a name="ln3588">    if ( isk1 &amp;&amp; isk2 ) {</a>
<a name="ln3589">        for ( i = 0; i &lt; len; i ++ ) {</a>
<a name="ln3590">            k1 = (isk1[i] == EMPTY_ISO_SORT_KEY)? 0 : isk1[i];</a>
<a name="ln3591">            k2 = (isk2[i] == EMPTY_ISO_SORT_KEY)? 0 : isk2[i];</a>
<a name="ln3592">            isk1[i] = k1 | k2;</a>
<a name="ln3593">        }</a>
<a name="ln3594">    } else</a>
<a name="ln3595">    if ( isk1 ) {</a>
<a name="ln3596">        CleanIsoSortKeys( isk1, len );</a>
<a name="ln3597">    }</a>
<a name="ln3598">}</a>
<a name="ln3599">#endif</a>
<a name="ln3600">#define FREE_CONTABLE(X) if (X) {CTableFree(X);inchi_free(X);}</a>
<a name="ln3601">#define FREE_ARRAY(X) if (X) inchi_free(X);</a>
<a name="ln3602">/*****************************************************************************/</a>
<a name="ln3603">void DeAllocBCN( BCN *pBCN )</a>
<a name="ln3604">{</a>
<a name="ln3605">    int    i, k;</a>
<a name="ln3606">    FTCN  *ftcn;</a>
<a name="ln3607">    if ( !pBCN )</a>
<a name="ln3608">        return;</a>
<a name="ln3609">    if ( pBCN-&gt;pRankStack ) {</a>
<a name="ln3610">        for ( i = 0; i &lt; pBCN-&gt;nMaxLenRankStack; i ++ ) {</a>
<a name="ln3611">            FREE_ARRAY( pBCN-&gt;pRankStack[i] )</a>
<a name="ln3612">        }</a>
<a name="ln3613">        FREE_ARRAY( pBCN-&gt;pRankStack )</a>
<a name="ln3614">    }</a>
<a name="ln3615">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln3616">        ftcn = pBCN-&gt;ftcn + k;</a>
<a name="ln3617">        FreeNeighList( ftcn-&gt;NeighList );</a>
<a name="ln3618">        FREE_ARRAY( ftcn-&gt;LinearCt )</a>
<a name="ln3619">        PartitionFree( &amp;ftcn-&gt;PartitionCt );</a>
<a name="ln3620">        FREE_ARRAY( ftcn-&gt;nSymmRankCt )</a>
<a name="ln3621">        FREE_ARRAY( ftcn-&gt;nNumHOrig )</a>
<a name="ln3622">        FREE_ARRAY( ftcn-&gt;nNumH )</a>
<a name="ln3623">        FREE_ARRAY( ftcn-&gt;nNumHOrigFixH )</a>
<a name="ln3624">        FREE_ARRAY( ftcn-&gt;nNumHFixH )</a>
<a name="ln3625">        PartitionFree( &amp;ftcn-&gt;PartitionCtIso );</a>
<a name="ln3626">        FREE_ARRAY( ftcn-&gt;nSymmRankCtIso )</a>
<a name="ln3627">        FREE_ARRAY( ftcn-&gt;iso_sort_keys )</a>
<a name="ln3628">        FREE_ARRAY( ftcn-&gt;iso_sort_keysOrig )</a>
<a name="ln3629">        FREE_ARRAY( ftcn-&gt;iso_exchg_atnos )</a>
<a name="ln3630">        FREE_ARRAY( ftcn-&gt;iso_exchg_atnosOrig )</a>
<a name="ln3631">    }</a>
<a name="ln3632">}</a>
<a name="ln3633">#undef FREE_CONTABLE</a>
<a name="ln3634">#undef FREE_ARRAY</a>
<a name="ln3635"> </a>
<a name="ln3636">/*****************************************************************************/</a>
<a name="ln3637">#if ( bRELEASE_VERSION == 0 &amp;&amp; FIND_CANON_NE_EQUITABLE == 1 )</a>
<a name="ln3638">/* debug: find whether canonical equivalence is different from equitable partition */</a>
<a name="ln3639">int bCanonIsFinerThanEquitablePartition( int num_atoms, sp_ATOM* at, AT_RANK *nSymmRank )</a>
<a name="ln3640">{</a>
<a name="ln3641">    AT_RANK *nRank                    = NULL;</a>
<a name="ln3642">    AT_RANK *nAtomNumber              = NULL;</a>
<a name="ln3643">    AT_RANK *nTempRank                = NULL;</a>
<a name="ln3644">    AT_RANK nCurSymm, nCurRank;</a>
<a name="ln3645">    ATOM_INVARIANT2 *pAtomInvariant   = NULL;</a>
<a name="ln3646">    NEIGH_LIST      *NeighList        = NULL;</a>
<a name="ln3647">    int              nNumCurrRanks, i, is, ir, j;</a>
<a name="ln3648">    long             lCount;</a>
<a name="ln3649">    int              bIsNotSame  = 0;</a>
<a name="ln3650">    if ( at &amp;&amp; nSymmRank ) {</a>
<a name="ln3651">        if ( !(nRank          = (AT_RANK*)inchi_calloc( num_atoms, sizeof(nRank[0]))) ||</a>
<a name="ln3652">             !(nAtomNumber    = (AT_RANK*)inchi_calloc( num_atoms, sizeof(nAtomNumber[0]))) ||</a>
<a name="ln3653">             !(nTempRank      = (AT_RANK*)inchi_calloc( num_atoms, sizeof(nTempRank[0]))) ||</a>
<a name="ln3654">             !(pAtomInvariant = (ATOM_INVARIANT2 *)inchi_calloc( num_atoms, sizeof(pAtomInvariant[0])))</a>
<a name="ln3655">            ) {</a>
<a name="ln3656">            goto exit_err;</a>
<a name="ln3657">        }</a>
<a name="ln3658">        if ( !(NeighList = CreateNeighList( num_atoms, num_atoms, at, 0, NULL )) ) {</a>
<a name="ln3659">            goto exit_err;</a>
<a name="ln3660">        }</a>
<a name="ln3661"> </a>
<a name="ln3662">        FillOutAtomInvariant2( at, num_atoms, num_atoms, pAtomInvariant, 1 /*bIgnoreIsotopic*/,</a>
<a name="ln3663">                               1 /*bHydrogensInRanks*/, 1 /*bHydrogensFixedInRanks*/, 0 /*bTaut=bDigraph*/,</a>
<a name="ln3664">                               0 /* bTautGroupsOnly */, NULL /*t_group_info*/ );</a>
<a name="ln3665">        /* initial partitioning of a hydrogenless skeleton: create equitable partition (assign initial ranks) */</a>
<a name="ln3666">        nNumCurrRanks = SetInitialRanks2( num_atoms, pAtomInvariant, nRank, nAtomNumber );</a>
<a name="ln3667"> </a>
<a name="ln3668">        lCount = 0;</a>
<a name="ln3669">        /* make equitable partition in pBCN-&gt;pRankStack[0,1] */</a>
<a name="ln3670">        nNumCurrRanks = DifferentiateRanks2( num_atoms, NeighList,</a>
<a name="ln3671">                                            nNumCurrRanks, nRank,</a>
<a name="ln3672">                                            nTempRank, nAtomNumber, &amp;lCount, 0 /* 0 means use qsort */ );</a>
<a name="ln3673">        /* at this point the equitable partition is in nRank; the order of atoms is in nAtomNumber*/</a>
<a name="ln3674">        /* compare */</a>
<a name="ln3675">        nCurSymm = nCurRank = 0;</a>
<a name="ln3676">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3677">            j = (int)nAtomNumber[i];</a>
<a name="ln3678">            if ( nCurSymm != nSymmRank[j] ) {</a>
<a name="ln3679">                nCurSymm = nSymmRank[j];</a>
<a name="ln3680">                is = i;</a>
<a name="ln3681">            }</a>
<a name="ln3682">            if ( nCurRank != nRank[j] ) {</a>
<a name="ln3683">                nCurRank = nRank[j];</a>
<a name="ln3684">                ir = i;</a>
<a name="ln3685">            }</a>
<a name="ln3686">            if ( is != ir ) {</a>
<a name="ln3687">                bIsNotSame = 1;</a>
<a name="ln3688">                break;</a>
<a name="ln3689">            }</a>
<a name="ln3690">        }</a>
<a name="ln3691">    }</a>
<a name="ln3692">exit_err:</a>
<a name="ln3693">    if ( nRank )</a>
<a name="ln3694">        inchi_free( nRank );</a>
<a name="ln3695">    if ( nAtomNumber )</a>
<a name="ln3696">        inchi_free( nAtomNumber );</a>
<a name="ln3697">    if ( nTempRank )</a>
<a name="ln3698">        inchi_free( nTempRank );</a>
<a name="ln3699">    if ( pAtomInvariant )</a>
<a name="ln3700">        inchi_free( pAtomInvariant );</a>
<a name="ln3701">    if ( NeighList ) </a>
<a name="ln3702">        FreeNeighList( NeighList );</a>
<a name="ln3703">    return bIsNotSame;</a>
<a name="ln3704">}</a>
<a name="ln3705">#endif</a>
<a name="ln3706">/*****************************************************************************/</a>
<a name="ln3707">int GetBaseCanonRanking( int num_atoms, int num_at_tg, sp_ATOM* at[],</a>
<a name="ln3708">                         T_GROUP_INFO *t_group_info, ATOM_SIZES s[], BCN *pBCN, </a>
<a name="ln3709">                         struct tagInchiTime *ulTimeOutTime, int bFixIsoFixedH )</a>
<a name="ln3710">{</a>
<a name="ln3711">    int ret = 0;</a>
<a name="ln3712">    int iBase;                   /* base structure index, always valid; = TAUT_YES except special fully non-taut mode */</a>
<a name="ln3713">    int iOther;                  /* other than basic structure index, usually non-taut; may be = iBase */</a>
<a name="ln3714">    int bReqNonTaut;             /* 1 =&gt; requested non-tautomeric results */</a>
<a name="ln3715">    int bReqTaut;                /* 1 =&gt; requested tautomeric results and the base structure is tautomeric */</a>
<a name="ln3716">    int bChanged;</a>
<a name="ln3717">    sp_ATOM *at_base        = NULL;</a>
<a name="ln3718">    sp_ATOM *at_other       = NULL;</a>
<a name="ln3719">    int bTautIgnoreIsotopic = 0;</a>
<a name="ln3720">    /*int bIgnoreIsotopic     = 0;*/</a>
<a name="ln3721">    int nNumCurrRanks       = 0;</a>
<a name="ln3722">    int nMaxLenRankStack    = 0;</a>
<a name="ln3723">    int num_max             = num_at_tg;</a>
<a name="ln3724">    long lCount;</a>
<a name="ln3725">    /* local allocations */</a>
<a name="ln3726">    ATOM_INVARIANT2 *pAtomInvariant    = NULL;</a>
<a name="ln3727">    NEIGH_LIST     *NeighList[TAUT_NUM];</a>
<a name="ln3728">    ConTable *Ct_Temp                 = NULL;</a>
<a name="ln3729"> </a>
<a name="ln3730">    /* initial partition for canonicalization */</a>
<a name="ln3731">    AT_RANK *nRank                    = NULL;</a>
<a name="ln3732">    AT_NUMB *nAtomNumber              = NULL;</a>
<a name="ln3733"> </a>
<a name="ln3734">    /* canonicalization output */</a>
<a name="ln3735">    </a>
<a name="ln3736">    ConTable *Ct_NoH                  = NULL;</a>
<a name="ln3737">    AT_RANK *nCanonRankNoH            = NULL;</a>
<a name="ln3738">    AT_NUMB *nAtomNumberCanonNoH      = NULL;</a>
<a name="ln3739">    AT_RANK *nSymmRankNoH             = NULL;</a>
<a name="ln3740">    </a>
<a name="ln3741">    ConTable *Ct_NoTautH              = NULL;</a>
<a name="ln3742">    AT_RANK *nSymmRankNoTautH         = NULL;</a>
<a name="ln3743">    AT_RANK *nCanonRankNoTautH        = NULL;</a>
<a name="ln3744">    AT_NUMB *nAtomNumberCanonNoTautH  = NULL;</a>
<a name="ln3745">    NUM_H   *numHNoTautH              = NULL;</a>
<a name="ln3746">    int      lenNumHNoTautH;</a>
<a name="ln3747">    int      maxlenNumHNoTautH;</a>
<a name="ln3748">    </a>
<a name="ln3749">    ConTable *Ct_Base                 = NULL;</a>
<a name="ln3750">    AT_RANK *nSymmRankBase            = NULL;</a>
<a name="ln3751">    AT_RANK *nCanonRankBase           = NULL;</a>
<a name="ln3752">    AT_NUMB *nAtomNumberCanonBase     = NULL;</a>
<a name="ln3753">    NUM_H   *numH                     = NULL;</a>
<a name="ln3754">    int      lenNumH;</a>
<a name="ln3755">    int      maxlenNumH               = 0;</a>
<a name="ln3756"> </a>
<a name="ln3757">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln3758">    AT_RANK *nRankAux                 = NULL;</a>
<a name="ln3759">    AT_NUMB *nAtomNumberAux           = NULL;</a>
<a name="ln3760">    ATOM_INVARIANT2 *pAtomInvariantAux= NULL;</a>
<a name="ln3761">#endif    </a>
<a name="ln3762"> </a>
<a name="ln3763"> </a>
<a name="ln3764">    ConTable *Ct_FixH                 = NULL;</a>
<a name="ln3765">    AT_RANK *nSymmRankFixH            = NULL;</a>
<a name="ln3766">    AT_RANK *nCanonRankFixH           = NULL;</a>
<a name="ln3767">    AT_NUMB *nAtomNumberCanonFixH     = NULL;</a>
<a name="ln3768">    NUM_H   *NumHfixed                = NULL;</a>
<a name="ln3769">    int      maxlenNumHfixed;</a>
<a name="ln3770"> </a>
<a name="ln3771">    /* isotopic canonicalization */</a>
<a name="ln3772">    </a>
<a name="ln3773">    ConTable *Ct_NoTautHIso               = NULL;</a>
<a name="ln3774">    AT_RANK *nSymmRankNoTautHIso          = NULL;</a>
<a name="ln3775">    AT_RANK *nCanonRankNoTautHIso         = NULL;</a>
<a name="ln3776">    AT_NUMB *nAtomNumberCanonNoTautHIso   = NULL;</a>
<a name="ln3777">    AT_ISO_SORT_KEY *iso_sort_key_NoTautH = NULL;</a>
<a name="ln3778">    int              maxlen_iso_sort_key_NoTautH;</a>
<a name="ln3779">    int              len_iso_sort_key_NoTautH;</a>
<a name="ln3780">    int num_iso_NoTautH, num_iso_NoAuxBase;</a>
<a name="ln3781"> </a>
<a name="ln3782">    ConTable *Ct_BaseIso                  = NULL;</a>
<a name="ln3783">    AT_RANK *nSymmRankBaseIso             = NULL;</a>
<a name="ln3784">    AT_RANK *nCanonRankBaseIso            = NULL;</a>
<a name="ln3785">    AT_NUMB *nAtomNumberCanonBaseIso      = NULL;</a>
<a name="ln3786">    </a>
<a name="ln3787">    AT_ISO_SORT_KEY *iso_sort_keyBase     = NULL;</a>
<a name="ln3788">    int              maxlen_iso_sort_keyBase;</a>
<a name="ln3789">    int              len_iso_sort_keyBase;</a>
<a name="ln3790"> </a>
<a name="ln3791">    int              bUseIsoAuxBase[TAUT_NUM];</a>
<a name="ln3792">    S_CHAR          *iso_exchg_atnos      = NULL;</a>
<a name="ln3793">    int              len_iso_exchg_atnos;</a>
<a name="ln3794">    int              maxlen_iso_exchg_atnos;</a>
<a name="ln3795">    int num_iso_Base;</a>
<a name="ln3796"> </a>
<a name="ln3797">    AT_ISO_SORT_KEY  iso_sort_key; </a>
<a name="ln3798"> </a>
<a name="ln3799">    ConTable *Ct_FixHIso                  = NULL;</a>
<a name="ln3800">    AT_RANK *nSymmRankFixHIso             = NULL;</a>
<a name="ln3801">    AT_RANK *nCanonRankFixHIso            = NULL;</a>
<a name="ln3802">    AT_NUMB *nAtomNumberCanonFixHIso      = NULL;</a>
<a name="ln3803"> </a>
<a name="ln3804">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln3805">    AT_ISO_SORT_KEY  iso_sort_key2; </a>
<a name="ln3806">    AT_ISO_SORT_KEY *iso_sort_key_Hfixed  = NULL;</a>
<a name="ln3807">    int              maxlen_iso_sort_key_Hfixed;</a>
<a name="ln3808">    int              len_iso_sort_key_Hfixed;</a>
<a name="ln3809">    int num_iso_Hfixed;</a>
<a name="ln3810">#endif</a>
<a name="ln3811"> </a>
<a name="ln3812">    AT_RANK *nTempRank               = NULL;</a>
<a name="ln3813"> </a>
<a name="ln3814">    CANON_DATA    pCD[3]; /* = &amp;CanonData; */</a>
<a name="ln3815">    CANON_COUNTS  CanonCounts;</a>
<a name="ln3816">    CANON_COUNTS *pCC = &amp;CanonCounts;</a>
<a name="ln3817"> </a>
<a name="ln3818">    int i, j, k, m;</a>
<a name="ln3819">    int nCanonFlags[2];</a>
<a name="ln3820"> </a>
<a name="ln3821">    /*^^^ */</a>
<a name="ln3822">    int iflag;</a>
<a name="ln3823"> </a>
<a name="ln3824">    memset (pCD, 0, sizeof(pCD));</a>
<a name="ln3825">    memset (pCC, 0, sizeof(pCC[0]));</a>
<a name="ln3826">    memset ( bUseIsoAuxBase, 0, sizeof(bUseIsoAuxBase) );</a>
<a name="ln3827">    memset ( nCanonFlags, 0, sizeof(nCanonFlags) );</a>
<a name="ln3828">    NeighList[TAUT_NON] = NULL;</a>
<a name="ln3829">    NeighList[TAUT_YES] = NULL;</a>
<a name="ln3830"> </a>
<a name="ln3831">    /* select base structure, find whether it is tautomeric or not */</a>
<a name="ln3832">    if ( at[TAUT_YES] &amp;&amp; s[TAUT_YES].nLenCT &amp;&amp;</a>
<a name="ln3833">         t_group_info &amp;&amp; ((s[TAUT_YES].nLenLinearCTTautomer &gt; 0 &amp;&amp; /* ordinary tautomerism */</a>
<a name="ln3834">                          t_group_info-&gt;t_group &amp;&amp; t_group_info-&gt;num_t_groups &gt; 0) ||</a>
<a name="ln3835">                          /* protons have been moved */</a>
<a name="ln3836">                          (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_NORM_CONSIDER_TAUT) ||</a>
<a name="ln3837">                          /* tautomerism due to possible isotopic proton exchange */</a>
<a name="ln3838">                          (t_group_info-&gt;nNumIsotopicEndpoints &gt; 1 &amp;&amp;</a>
<a name="ln3839">                          (t_group_info-&gt;bTautFlagsDone &amp; (TG_FLAG_FOUND_ISOTOPIC_H_DONE|TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE))) ) ) {</a>
<a name="ln3840">        /* tautomeric: (1) has tautomeric atoms OR</a>
<a name="ln3841">                       (2) H-atoms have been rearranged due to proton addition/removal OR</a>
<a name="ln3842">                       (3) Found isotopic H-atoms on tautomeric or hetero atoms</a>
<a name="ln3843">         */</a>
<a name="ln3844">        iBase    = TAUT_YES;</a>
<a name="ln3845">        bReqTaut = 1;</a>
<a name="ln3846">        bUseIsoAuxBase[iBase] = (s[iBase].nLenIsotopicEndpoints &gt; 1) &amp;&amp;</a>
<a name="ln3847">                                (t_group_info-&gt;bTautFlagsDone &amp; (TG_FLAG_FOUND_ISOTOPIC_H_DONE|TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE));</a>
<a name="ln3848">        if ( at[TAUT_NON] &amp;&amp; s[TAUT_NON].nLenCT ) {</a>
<a name="ln3849">            iOther      = TAUT_NON; /* tautomeric and non-tautomeric */</a>
<a name="ln3850">            bReqNonTaut = 1;</a>
<a name="ln3851">        } else {</a>
<a name="ln3852">            iOther      = iBase; /* tautomeric only */</a>
<a name="ln3853">            bReqNonTaut = 0;</a>
<a name="ln3854">        }</a>
<a name="ln3855">    } else</a>
<a name="ln3856">    if ( at[TAUT_NON] &amp;&amp; s[TAUT_NON].nLenCT ) {</a>
<a name="ln3857">        /* force pure non-tautomeric processing; happens for testing only */</a>
<a name="ln3858">        iBase       = TAUT_NON;</a>
<a name="ln3859">        bReqTaut    = 0;</a>
<a name="ln3860">        iOther      = iBase;</a>
<a name="ln3861">        bReqNonTaut = 1;</a>
<a name="ln3862">        num_at_tg   = num_atoms;</a>
<a name="ln3863">    } else</a>
<a name="ln3864">    if ( at[TAUT_YES] &amp;&amp; s[TAUT_YES].nLenCT ) {</a>
<a name="ln3865">        /* although the user requested tautomeric processing, tautomerism has not been found */</a>
<a name="ln3866">        /* however, the results should be saved in the TAUT_YES elements of the arrays */</a>
<a name="ln3867">        iBase       = TAUT_YES;</a>
<a name="ln3868">        bReqTaut    = 0;</a>
<a name="ln3869">        bUseIsoAuxBase[iBase] = (s[iBase].nLenIsotopicEndpoints &gt; 1);</a>
<a name="ln3870">        iOther      = iBase;</a>
<a name="ln3871">        bReqNonTaut = 1;</a>
<a name="ln3872">        num_at_tg   = num_atoms;</a>
<a name="ln3873">    } else {</a>
<a name="ln3874">        ret = CT_UNKNOWN_ERR;</a>
<a name="ln3875">        goto exit_error;</a>
<a name="ln3876">    }</a>
<a name="ln3877">    if ( bReqTaut ) {</a>
<a name="ln3878">        /* save &quot;process isotopic&quot; mark; temporarily set it to NO */</a>
<a name="ln3879">        bTautIgnoreIsotopic = t_group_info-&gt;bIgnoreIsotopic;</a>
<a name="ln3880">        t_group_info-&gt;bIgnoreIsotopic = 1;</a>
<a name="ln3881">    }</a>
<a name="ln3882">    lenNumH                  = num_atoms;</a>
<a name="ln3883"> </a>
<a name="ln3884">    /* isotopic canonicalization */</a>
<a name="ln3885">    num_iso_NoTautH             = 0;</a>
<a name="ln3886">    len_iso_sort_key_NoTautH    = 0;</a>
<a name="ln3887">    maxlen_iso_sort_key_NoTautH = 0;</a>
<a name="ln3888">    num_iso_Base                = 0;</a>
<a name="ln3889">    len_iso_sort_keyBase        = 0;</a>
<a name="ln3890">    maxlen_iso_sort_keyBase     = 0;</a>
<a name="ln3891">    len_iso_exchg_atnos         = 0;</a>
<a name="ln3892">    maxlen_iso_exchg_atnos      = 0;</a>
<a name="ln3893">    len_iso_exchg_atnos         = 0;</a>
<a name="ln3894">    maxlen_iso_exchg_atnos      = 0;</a>
<a name="ln3895"> </a>
<a name="ln3896">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln3897">    num_iso_Hfixed              =</a>
<a name="ln3898">    len_iso_sort_key_Hfixed     =</a>
<a name="ln3899">    maxlen_iso_sort_key_Hfixed  = 0;</a>
<a name="ln3900">#endif</a>
<a name="ln3901"> </a>
<a name="ln3902">    /* prepare initial data */</a>
<a name="ln3903">    at_base  = at[iBase];</a>
<a name="ln3904">    at_other = at[iOther];</a>
<a name="ln3905">    pAtomInvariant      = (ATOM_INVARIANT2 *)inchi_calloc( num_max,     sizeof(pAtomInvariant[0]) );</a>
<a name="ln3906">    nSymmRankNoH        = (AT_RANK *)        inchi_calloc( num_max,     sizeof(nSymmRankNoH[0]       ) );</a>
<a name="ln3907">    nCanonRankNoH       = (AT_RANK *)        inchi_calloc( num_max,     sizeof(nCanonRankNoH[0]      ) );</a>
<a name="ln3908">    nAtomNumberCanonNoH = (AT_NUMB *)        inchi_calloc( num_max,     sizeof(nAtomNumberCanonNoH[0]) );</a>
<a name="ln3909">    nRank               = (AT_RANK *)        inchi_calloc( num_max,     sizeof(nRank[0]      ) );</a>
<a name="ln3910">    nAtomNumber         = (AT_NUMB *)        inchi_calloc( num_max,     sizeof(nAtomNumber[0]) );</a>
<a name="ln3911">    nTempRank           = (AT_RANK *)        inchi_calloc( num_max,     sizeof(nTempRank[0]  ) );</a>
<a name="ln3912"> </a>
<a name="ln3913">    if ( !pAtomInvariant ||</a>
<a name="ln3914">         !nSymmRankNoH   || !nCanonRankNoH    || !nAtomNumberCanonNoH ||</a>
<a name="ln3915">         !nRank          || !nAtomNumber      || !nTempRank             ) {</a>
<a name="ln3916">        goto exit_error_alloc;</a>
<a name="ln3917">    }</a>
<a name="ln3918">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln3919">    nRankAux            = (AT_RANK *)  inchi_calloc( num_max, sizeof(nRankAux[0]            ) );</a>
<a name="ln3920">    nAtomNumberAux      = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberAux[0]      ) );</a>
<a name="ln3921">    pAtomInvariantAux   = (ATOM_INVARIANT2 *) inchi_malloc( num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln3922">    if ( !nRankAux || !nAtomNumberAux || !pAtomInvariantAux ) {</a>
<a name="ln3923">        goto exit_error_alloc;</a>
<a name="ln3924">    }</a>
<a name="ln3925">#endif    </a>
<a name="ln3926"> </a>
<a name="ln3927">    if ( bReqTaut ) {</a>
<a name="ln3928">        if ( !(NeighList[TAUT_YES] = CreateNeighList( num_atoms, num_at_tg, at_base, 0, t_group_info )) )</a>
<a name="ln3929">            goto exit_error_alloc;</a>
<a name="ln3930">        /* needed for the hydrogenless structure */</a>
<a name="ln3931">        if ( !(NeighList[TAUT_NON] = CreateNeighList( num_atoms, num_atoms, at_base, 0, NULL )) )</a>
<a name="ln3932">            goto exit_error_alloc;</a>
<a name="ln3933">    } else {</a>
<a name="ln3934">        if ( !(NeighList[TAUT_NON] = CreateNeighList( num_atoms, num_atoms, at_base, 0, NULL )) )</a>
<a name="ln3935">            goto exit_error_alloc;</a>
<a name="ln3936">        NeighList[TAUT_YES] = NULL;</a>
<a name="ln3937">        INCHI_HEAPCHK</a>
<a name="ln3938">    }</a>
<a name="ln3939"> </a>
<a name="ln3940">    /* avoid memory leaks in case of error */</a>
<a name="ln3941">    /*</a>
<a name="ln3942">    pBCN-&gt;ftcn[TAUT_NON].NeighList          = NeighList[TAUT_NON];</a>
<a name="ln3943">    pBCN-&gt;ftcn[TAUT_YES].NeighList          = NeighList[TAUT_YES];</a>
<a name="ln3944">    */</a>
<a name="ln3945">    pBCN-&gt;nMaxLenRankStack                  = 0;</a>
<a name="ln3946">    pBCN-&gt;num_max                           = num_max;        /* allocated nRank[] arrays lengths in pRankStack */</a>
<a name="ln3947">    pBCN-&gt;num_at_tg                         = num_at_tg;  /* all of the following arrays have this length */</a>
<a name="ln3948">    pBCN-&gt;num_atoms                         = num_atoms;</a>
<a name="ln3949">    pBCN-&gt;ulTimeOutTime                     = ulTimeOutTime;</a>
<a name="ln3950"> </a>
<a name="ln3951">    /* initial partitioning of a hydrogenless skeleton: fill out the inveriant */</a>
<a name="ln3952">    FillOutAtomInvariant2( at_base, num_atoms, num_atoms, pAtomInvariant, 1 /*bIgnoreIsotopic*/,</a>
<a name="ln3953">                           0 /*bHydrogensInRanks*/, 0 /*bHydrogensFixedInRanks*/, 0 /*bTaut=bDigraph*/,</a>
<a name="ln3954">                           0 /* bTautGroupsOnly */, NULL /*t_group_info*/ );</a>
<a name="ln3955">    /* initial partitioning of a hydrogenless skeleton: create equitable partition (assign initial ranks) */</a>
<a name="ln3956">    nNumCurrRanks = SetInitialRanks2( num_atoms, pAtomInvariant, nRank, nAtomNumber );</a>
<a name="ln3957"> </a>
<a name="ln3958">    lCount = 0;</a>
<a name="ln3959">    /* make equitable partition in pBCN-&gt;pRankStack[0,1] */</a>
<a name="ln3960">    nNumCurrRanks = DifferentiateRanks2( num_atoms, NeighList[TAUT_NON],</a>
<a name="ln3961">                                        nNumCurrRanks, nRank,</a>
<a name="ln3962">                                        nTempRank, nAtomNumber, &amp;lCount, 0 /* 0 means use qsort */ );</a>
<a name="ln3963"> </a>
<a name="ln3964">    /* allocate partition stack */</a>
<a name="ln3965">    nMaxLenRankStack = 2*(num_at_tg-nNumCurrRanks) + 8;  /* was 2*(...) + 6 */</a>
<a name="ln3966">    pBCN-&gt;pRankStack = (AT_RANK **) inchi_calloc( nMaxLenRankStack, sizeof(pBCN-&gt;pRankStack[0]) );</a>
<a name="ln3967">    if ( !pBCN-&gt;pRankStack ) {</a>
<a name="ln3968">        pBCN-&gt;nMaxLenRankStack = 0; /* avoid memory leaks in case of error */</a>
<a name="ln3969">        goto exit_error_alloc;</a>
<a name="ln3970">    }</a>
<a name="ln3971">    pBCN-&gt;nMaxLenRankStack = nMaxLenRankStack; /* avoid memory leaks in case of error */</a>
<a name="ln3972">    /* init partition stack */</a>
<a name="ln3973">    pBCN-&gt;pRankStack[0] = nRank;</a>
<a name="ln3974">    pBCN-&gt;pRankStack[1] = nAtomNumber;</a>
<a name="ln3975">    </a>
<a name="ln3976">    /********************************************************************************************/</a>
<a name="ln3977">    /* get NoH/no taut groups  canonical numbering, connection table, and equivalence partition */</a>
<a name="ln3978">    /********************************************************************************************/</a>
<a name="ln3979"> </a>
<a name="ln3980">    /* pointers */</a>
<a name="ln3981">    pCD[iOther].LinearCT                   = NULL;</a>
<a name="ln3982">    pCD[iOther].NumH                       = NULL;</a>
<a name="ln3983">    pCD[iOther].NumHfixed                  = NULL;</a>
<a name="ln3984">    pCD[iOther].iso_sort_key               = NULL;</a>
<a name="ln3985">    pCD[iOther].iso_exchg_atnos            = NULL;</a>
<a name="ln3986">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln3987">    pCD[iOther].iso_sort_key_Hfixed        = NULL;</a>
<a name="ln3988">#endif                                     </a>
<a name="ln3989">    /* variables - unchanged */            </a>
<a name="ln3990">    pCD[iOther].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln3991">    pCD[iOther].nMaxLenLinearCT            = s[iOther].nLenCTAtOnly + 1;</a>
<a name="ln3992">    /* return values &amp; input/output */     </a>
<a name="ln3993">    pCD[iOther].nLenLinearCT               = s[iOther].nLenCTAtOnly;</a>
<a name="ln3994">    pCD[iOther].nLenCTAtOnly               = s[iOther].nLenCTAtOnly;</a>
<a name="ln3995">    pCD[iOther].lenNumH                    = 0;</a>
<a name="ln3996">    pCD[iOther].lenNumHfixed               = 0;</a>
<a name="ln3997">    pCD[iOther].len_iso_sort_key           = 0;</a>
<a name="ln3998">    pCD[iOther].maxlen_iso_sort_key        = 0;</a>
<a name="ln3999">    pCD[iOther].len_iso_exchg_atnos        = 0;</a>
<a name="ln4000">    pCD[iOther].maxlen_iso_exchg_atnos     = 0;</a>
<a name="ln4001">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4002">    pCD[iOther].len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln4003">    pCD[iOther].maxlen_iso_sort_key_Hfixed = 0;</a>
<a name="ln4004">#endif</a>
<a name="ln4005">    ret = CanonGraph01( num_atoms, num_atoms, num_max, 0, NeighList[TAUT_NON], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4006">                      nSymmRankNoH,  nCanonRankNoH, nAtomNumberCanonNoH, pCD+iOther, pCC, NULL, &amp;Ct_NoH );</a>
<a name="ln4007">    if ( ret &lt; 0 ) {</a>
<a name="ln4008">        goto exit_error;</a>
<a name="ln4009">    }</a>
<a name="ln4010">    /* update initial partitioning */</a>
<a name="ln4011">    nNumCurrRanks = FixCanonEquivalenceInfo( num_atoms, nSymmRankNoH, nRank, nTempRank, nAtomNumber, &amp;bChanged );</a>
<a name="ln4012">    /* repartition if necessary */</a>
<a name="ln4013">    if ( bChanged &amp; 3 ) {</a>
<a name="ln4014">        if ( Ct_NoH ) {</a>
<a name="ln4015">            CTableFree( Ct_NoH );</a>
<a name="ln4016">            inchi_free( Ct_NoH );</a>
<a name="ln4017">            Ct_NoH = NULL;</a>
<a name="ln4018">        }</a>
<a name="ln4019">        pCD[iOther].nCanonFlags |= CANON_FLAG_NO_H_RECANON;</a>
<a name="ln4020"> </a>
<a name="ln4021">        ret = CanonGraph02( num_atoms, num_atoms, num_max, 0, NeighList[TAUT_NON], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4022">                          nSymmRankNoH,  nCanonRankNoH, nAtomNumberCanonNoH, pCD+iOther, pCC, NULL, &amp;Ct_NoH );</a>
<a name="ln4023">        if ( ret &lt; 0 ) {</a>
<a name="ln4024">            goto exit_error;</a>
<a name="ln4025">        }</a>
<a name="ln4026">    }</a>
<a name="ln4027">    /********************************************************************************/</a>
<a name="ln4028">    /* get NoTautH canonical numbering, connection table, and equivalence partition */</a>
<a name="ln4029">    /********************************************************************************/</a>
<a name="ln4030">    maxlenNumHNoTautH        = num_atoms + 1;</a>
<a name="ln4031">    nSymmRankNoTautH         = (AT_RANK *)  inchi_calloc( num_max, sizeof(nSymmRankNoTautH[0]       ) );</a>
<a name="ln4032">    nCanonRankNoTautH        = (AT_RANK *)  inchi_calloc( num_max, sizeof(nCanonRankNoTautH[0]      ) );</a>
<a name="ln4033">    nAtomNumberCanonNoTautH  = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberCanonNoTautH[0]) );</a>
<a name="ln4034">    numHNoTautH              = (NUM_H *)    inchi_calloc( maxlenNumHNoTautH, sizeof(numHNoTautH[0]) );</a>
<a name="ln4035">    if ( !numHNoTautH || !nSymmRankNoTautH || !nCanonRankNoTautH || !nAtomNumberCanonNoTautH ) {</a>
<a name="ln4036">        goto exit_error_alloc;</a>
<a name="ln4037">    }</a>
<a name="ln4038">    /* find number of H atoms attached to not-a-tautomeric-endpoint atoms */</a>
<a name="ln4039">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4040">        numHNoTautH[i] = (!at_base[i].endpoint &amp;&amp; at_base[i].num_H)? at_base[i].num_H+BASE_H_NUMBER : EMPTY_H_NUMBER;</a>
<a name="ln4041">    }</a>
<a name="ln4042">    /* pointers */</a>
<a name="ln4043">    pCD[iOther].LinearCT                   = NULL;</a>
<a name="ln4044">    pCD[iOther].NumH                       = numHNoTautH;</a>
<a name="ln4045">    pCD[iOther].NumHfixed                  = NULL;</a>
<a name="ln4046">    pCD[iOther].iso_sort_key               = NULL;</a>
<a name="ln4047">    pCD[iOther].iso_exchg_atnos            = NULL;</a>
<a name="ln4048">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4049">    pCD[iOther].iso_sort_key_Hfixed        = NULL;</a>
<a name="ln4050">#endif</a>
<a name="ln4051">    /* variables - unchanged */             </a>
<a name="ln4052">    pCD[iOther].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln4053">    pCD[iOther].nMaxLenLinearCT            = s[iOther].nLenCTAtOnly + 1;</a>
<a name="ln4054">    pCD[iOther].maxlenNumH                 = maxlenNumHNoTautH;</a>
<a name="ln4055">    /* return values &amp; input/output */     </a>
<a name="ln4056">    pCD[iOther].nLenLinearCT               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4057">    pCD[iOther].nLenCTAtOnly               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4058">    pCD[iOther].lenNumH                    = lenNumHNoTautH = num_atoms;</a>
<a name="ln4059">    pCD[iOther].lenNumHfixed               = 0;</a>
<a name="ln4060">    pCD[iOther].len_iso_sort_key           = 0;</a>
<a name="ln4061">    pCD[iOther].maxlen_iso_sort_key        = 0;</a>
<a name="ln4062">    pCD[iOther].len_iso_exchg_atnos        = 0;</a>
<a name="ln4063">    pCD[iOther].maxlen_iso_exchg_atnos     = 0;</a>
<a name="ln4064">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4065">    pCD[iOther].len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln4066">    pCD[iOther].maxlen_iso_sort_key_Hfixed = 0;</a>
<a name="ln4067">#endif</a>
<a name="ln4068">    pCD[iOther].nAuxRank                   = NULL;</a>
<a name="ln4069"> </a>
<a name="ln4070">    /* check whether we need NoTautH cononicalization */</a>
<a name="ln4071">    memset( nTempRank, 0, num_max * sizeof(nTempRank[0]) );</a>
<a name="ln4072">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4073">        if ( nTempRank[nSymmRankNoH[i]-1] &lt; i ) {</a>
<a name="ln4074">            nTempRank[nSymmRankNoH[i]-1] = i; /* greatest class representative */</a>
<a name="ln4075">        }</a>
<a name="ln4076">    }</a>
<a name="ln4077">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4078">        if ( numHNoTautH[i] != numHNoTautH[nTempRank[nSymmRankNoH[i]-1]] ) {</a>
<a name="ln4079">            pCD[iOther].nCanonFlags |= CANON_FLAG_NO_TAUT_H_DIFF;</a>
<a name="ln4080">            break; /* atoms so far found to be equivalent have different number of H; the canonicalization is needed */</a>
<a name="ln4081">        }</a>
<a name="ln4082">    }</a>
<a name="ln4083">    /* i = 0; *//* debug: force to call the canonicalization */</a>
<a name="ln4084">    if ( i &lt; num_atoms ) {</a>
<a name="ln4085">        /* needs canonicalization */</a>
<a name="ln4086">        /* get aux canonical ranking of the structure with attached H */</a>
<a name="ln4087">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln4088">        /* refine no-H partition according to not-a-taut-H distribution */</a>
<a name="ln4089">        memset( pAtomInvariantAux, 0, num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4090">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4091">            pAtomInvariantAux[i].val[0] = nSymmRankNoH[i];</a>
<a name="ln4092">            pAtomInvariantAux[i].val[1] = numHNoTautH[i]; /* additional differentiation: not-a-taut-H distribution */</a>
<a name="ln4093">        }</a>
<a name="ln4094">        /* initial partitioning */</a>
<a name="ln4095">        nNumCurrRanks = SetInitialRanks2( num_atoms, pAtomInvariantAux, nRankAux, nAtomNumberAux );</a>
<a name="ln4096">        /* make equitable partition */</a>
<a name="ln4097">        nNumCurrRanks = DifferentiateRanks2( num_atoms, NeighList[TAUT_NON],</a>
<a name="ln4098">                                            nNumCurrRanks, nRankAux,</a>
<a name="ln4099">                                            nTempRank, nAtomNumberAux, &amp;lCount, 0 /* 0 means use qsort */ );</a>
<a name="ln4100">        /* to accelerate do not call CanonGraph() to find really equivalent atoms */</a>
<a name="ln4101">        pCD[iOther].nAuxRank = nRankAux;</a>
<a name="ln4102">#endif    </a>
<a name="ln4103"> </a>
<a name="ln4104">        ret = CanonGraph03( num_atoms, num_atoms, num_max, 1 /* digraph?? was 0 */, NeighList[TAUT_NON], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4105">                          nSymmRankNoTautH,  nCanonRankNoTautH, nAtomNumberCanonNoTautH, pCD+iOther, pCC, &amp;Ct_NoH, &amp;Ct_NoTautH );</a>
<a name="ln4106">        if ( ret &lt; 0 ) {</a>
<a name="ln4107">            goto exit_error;</a>
<a name="ln4108">        }</a>
<a name="ln4109">        /* in case of non-tautomeric structure the final results are in:</a>
<a name="ln4110"> </a>
<a name="ln4111">                   nSymmRankNoTautH</a>
<a name="ln4112">                   nCanonRankNoTautH</a>
<a name="ln4113">                   nAtomNumberCanonNoTautH</a>
<a name="ln4114">                   Ct_NoTautH</a>
<a name="ln4115">                   numHNoTautH (original H positions)</a>
<a name="ln4116">        */</a>
<a name="ln4117">    } else {</a>
<a name="ln4118">        /* copy the results of the previous (no H) canonicalization */</a>
<a name="ln4119">        /* in this case numHNoTautH[] is not needed for the next canonicalization(s) */</a>
<a name="ln4120">        if ( (Ct_Temp = (ConTable *)inchi_calloc( 1, sizeof( *Ct_Temp ) ) ) &amp;&amp;</a>
<a name="ln4121">             CTableCreate( Ct_Temp, num_atoms, pCD+iOther) ) {</a>
<a name="ln4122">            CtFullCopy( Ct_Temp, Ct_NoH );</a>
<a name="ln4123">            /* since Ct_NoH does not have Ct_NoH-&gt;NumH we have to fill out Ct_Temp-&gt;NumH separately */</a>
<a name="ln4124">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4125">                Ct_Temp-&gt;NumH[nCanonRankNoH[i]-1] = numHNoTautH[i];</a>
<a name="ln4126">                /*Ct_Temp-&gt;NumH[i] = numHNoTautH[nAtomNumberCanonNoH[i]]; -- alternative */</a>
<a name="ln4127">            }</a>
<a name="ln4128">            Ct_Temp-&gt;lenNumH = num_atoms;</a>
<a name="ln4129">        } else {</a>
<a name="ln4130">            goto exit_error_alloc;</a>
<a name="ln4131">        }</a>
<a name="ln4132">        Ct_NoTautH = Ct_Temp;</a>
<a name="ln4133">        Ct_Temp    = NULL;</a>
<a name="ln4134">        memcpy( nSymmRankNoTautH, nSymmRankNoH, num_atoms*sizeof(nSymmRankNoTautH[0]) );</a>
<a name="ln4135">        memcpy( nCanonRankNoTautH, nCanonRankNoH, num_atoms*sizeof(nCanonRankNoTautH[0]) );</a>
<a name="ln4136">        memcpy( nAtomNumberCanonNoTautH, nAtomNumberCanonNoH, num_atoms*sizeof(nAtomNumberCanonNoTautH[0]) );</a>
<a name="ln4137">    }</a>
<a name="ln4138">    /* in case of non-tautomeric component this is the final result */</a>
<a name="ln4139">    /* i = CtFullCompare( Ct_NoTautH, Ct_Temp, num_atoms, 0, 0 );*/</a>
<a name="ln4140"> </a>
<a name="ln4141">    /*******************************************************************************************/</a>
<a name="ln4142">    /* If only Isotopic atoms and isotopic H, tautomerism has not been found:                  */</a>
<a name="ln4143">    /* get isotopic canonical numbering, connection table, and equivalence partition           */</a>
<a name="ln4144">    /*******************************************************************************************/</a>
<a name="ln4145">    </a>
<a name="ln4146">    if ( s[iOther].num_isotopic_atoms &amp;&amp; !s[iOther].bIgnoreIsotopic &amp;&amp; !bReqTaut &amp;&amp; bReqNonTaut ) {</a>
<a name="ln4147">        </a>
<a name="ln4148">        maxlen_iso_sort_key_NoTautH = num_atoms+1;</a>
<a name="ln4149">        nSymmRankNoTautHIso        = (AT_RANK *)  inchi_calloc( num_max, sizeof(nSymmRankNoTautHIso[0]       ) );</a>
<a name="ln4150">        nCanonRankNoTautHIso       = (AT_RANK *)  inchi_calloc( num_max, sizeof(nCanonRankNoTautHIso[0]       ) );</a>
<a name="ln4151">        nAtomNumberCanonNoTautHIso = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberCanonNoTautHIso[0]) );</a>
<a name="ln4152">        iso_sort_key_NoTautH       = (AT_ISO_SORT_KEY *) inchi_calloc( maxlen_iso_sort_key_NoTautH, sizeof(iso_sort_key_NoTautH[0]) );</a>
<a name="ln4153"> </a>
<a name="ln4154">        if ( !nSymmRankNoTautHIso || !nCanonRankNoTautHIso || !nAtomNumberCanonNoTautHIso || !iso_sort_key_NoTautH ) {</a>
<a name="ln4155">            goto exit_error_alloc;</a>
<a name="ln4156">        }</a>
<a name="ln4157"> </a>
<a name="ln4158">        /* fill out isotopic non-tautomeric keys */</a>
<a name="ln4159">        num_iso_NoTautH = 0;</a>
<a name="ln4160">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4161">            if ( at_base[i].endpoint ) {</a>
<a name="ln4162">                /* should not happen */</a>
<a name="ln4163">                iso_sort_key = make_iso_sort_key( at_base[i].iso_atw_diff, 0, 0, 0);</a>
<a name="ln4164">            } else {</a>
<a name="ln4165">                iso_sort_key = make_iso_sort_key( at_base[i].iso_atw_diff, at_base[i].num_iso_H[0], at_base[i].num_iso_H[1], at_base[i].num_iso_H[2]);</a>
<a name="ln4166">            }</a>
<a name="ln4167">            if ( iso_sort_key ) {</a>
<a name="ln4168">                iso_sort_key_NoTautH[i] = iso_sort_key;</a>
<a name="ln4169">                num_iso_NoTautH ++;</a>
<a name="ln4170">            } else {</a>
<a name="ln4171">                iso_sort_key_NoTautH[i] = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4172">            }</a>
<a name="ln4173">        }</a>
<a name="ln4174">        /* pointers */</a>
<a name="ln4175">        pCD[iOther].LinearCT                   = NULL; /* LinearCT; */</a>
<a name="ln4176">        pCD[iOther].NumH                       = numHNoTautH;</a>
<a name="ln4177">        pCD[iOther].NumHfixed                  = NULL;</a>
<a name="ln4178">        pCD[iOther].iso_sort_key               = iso_sort_key_NoTautH;</a>
<a name="ln4179">        pCD[iOther].iso_exchg_atnos            = NULL;</a>
<a name="ln4180">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4181">        pCD[iOther].iso_sort_key_Hfixed        = NULL;</a>
<a name="ln4182">#endif</a>
<a name="ln4183">        /* variables - unchanged */             </a>
<a name="ln4184">        pCD[iOther].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln4185">        pCD[iOther].nMaxLenLinearCT            = s[iOther].nLenCTAtOnly + 1;</a>
<a name="ln4186">        pCD[iOther].maxlenNumH                 = maxlenNumHNoTautH;</a>
<a name="ln4187">        /* return values &amp; input/output */    </a>
<a name="ln4188">        pCD[iOther].nLenLinearCT               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4189">        pCD[iOther].nLenCTAtOnly               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4190">        pCD[iOther].lenNumH                    = lenNumHNoTautH /*= num_atoms*/;</a>
<a name="ln4191">        pCD[iOther].lenNumHfixed               = 0;</a>
<a name="ln4192">        pCD[iOther].len_iso_sort_key           = len_iso_sort_key_NoTautH = num_atoms;</a>
<a name="ln4193">        pCD[iOther].maxlen_iso_sort_key        = maxlen_iso_sort_key_NoTautH;</a>
<a name="ln4194">        pCD[iOther].len_iso_exchg_atnos        = 0;</a>
<a name="ln4195">        pCD[iOther].maxlen_iso_exchg_atnos     = 0;</a>
<a name="ln4196">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4197">        pCD[iOther].len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln4198">        pCD[iOther].maxlen_iso_sort_key_Hfixed = 0;</a>
<a name="ln4199">#endif</a>
<a name="ln4200">        pCD[iOther].nAuxRank                   = NULL;</a>
<a name="ln4201"> </a>
<a name="ln4202">        if ( num_iso_NoTautH ) {</a>
<a name="ln4203">            /* check whether we need NoTautH cononicalization */</a>
<a name="ln4204">            memset( nTempRank, 0, num_max * sizeof(nTempRank[0]) );</a>
<a name="ln4205">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4206">                if ( nTempRank[nSymmRankNoTautH[i]-1] &lt; i ) {</a>
<a name="ln4207">                    nTempRank[nSymmRankNoTautH[i]-1] = i; /* greatest class representative */</a>
<a name="ln4208">                }</a>
<a name="ln4209">            }</a>
<a name="ln4210">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4211">                if ( iso_sort_key_NoTautH[i] != iso_sort_key_NoTautH[nTempRank[nSymmRankNoTautH[i]-1]] ) {</a>
<a name="ln4212">                    pCD[iOther].nCanonFlags |= CANON_FLAG_ISO_ONLY_NON_TAUT_DIFF;</a>
<a name="ln4213">                    break; /* atoms so far found to be equivalent differ in isotopes; the canonicalization is needed */</a>
<a name="ln4214">                }</a>
<a name="ln4215">            }</a>
<a name="ln4216">        } else {</a>
<a name="ln4217">            i = num_atoms;</a>
<a name="ln4218">        }</a>
<a name="ln4219">        /* i = 0; *//* debug: force to call the canonicalization */</a>
<a name="ln4220">        if ( i &lt; num_atoms ) {</a>
<a name="ln4221">            /* we need canonicalization */</a>
<a name="ln4222">            /* get aux canonical ranking of the structure with isotopic non-tautomeric H */</a>
<a name="ln4223"> </a>
<a name="ln4224">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln4225">            /* refine no-taut-H partition according to non-taut H isotopic distribution */</a>
<a name="ln4226">            memset( pAtomInvariantAux, 0, num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4227">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4228">                pAtomInvariantAux[i].val[0] = nSymmRankNoTautH[i];</a>
<a name="ln4229">                pAtomInvariantAux[i].iso_sort_key = iso_sort_key_NoTautH[i]; /* additional differentiation */</a>
<a name="ln4230">            }</a>
<a name="ln4231">            /* initial ranks for non-taut H isotopic distribution */</a>
<a name="ln4232">            nNumCurrRanks = SetInitialRanks2( num_atoms, pAtomInvariantAux, nRankAux, nAtomNumberAux );</a>
<a name="ln4233">            /* make equitable */</a>
<a name="ln4234">            nNumCurrRanks = DifferentiateRanks2( num_atoms, NeighList[TAUT_NON],</a>
<a name="ln4235">                                                nNumCurrRanks, nRankAux,</a>
<a name="ln4236">                                                nTempRank, nAtomNumberAux, &amp;lCount, 0 /* 0 means use qsort */ );</a>
<a name="ln4237">            /* to accelerate do not call CanonGraph() to find really equivalent atoms */</a>
<a name="ln4238">            pCD[iOther].nAuxRank = nRankAux;</a>
<a name="ln4239">#endif    </a>
<a name="ln4240"> </a>
<a name="ln4241">            ret = CanonGraph04( num_atoms, num_atoms, num_max, 1 /* digraph?? was 0 */, NeighList[TAUT_NON], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4242">                              nSymmRankNoTautHIso,  nCanonRankNoTautHIso, nAtomNumberCanonNoTautHIso, pCD+iOther, pCC, &amp;Ct_NoTautH, &amp;Ct_NoTautHIso );</a>
<a name="ln4243">            if ( ret &lt; 0 ) {</a>
<a name="ln4244">                goto exit_error;</a>
<a name="ln4245">            }</a>
<a name="ln4246">            /* in case of non-tautomeric structure the final results are in:</a>
<a name="ln4247"> </a>
<a name="ln4248">                       nSymmRankNoTautHIso</a>
<a name="ln4249">                       nCanonRankNoTautHIso</a>
<a name="ln4250">                       nAtomNumberCanonNoTautHIso</a>
<a name="ln4251">                       Ct_NoTautHIso</a>
<a name="ln4252">                       iso_sort_key_NoTautH (original isotopic atom positions)</a>
<a name="ln4253">            */</a>
<a name="ln4254">        } else {</a>
<a name="ln4255">            /* copy the results of the previous (no taut H) canonicalization */</a>
<a name="ln4256">            /* in this case numHNoTautH[] is not needed for the next canonicalization(s) */</a>
<a name="ln4257">            if ( (Ct_Temp = (ConTable *)inchi_calloc( 1, sizeof( *Ct_Temp ) ) ) &amp;&amp;</a>
<a name="ln4258">                 CTableCreate( Ct_Temp, num_atoms, pCD+iOther) ) {</a>
<a name="ln4259">                CtFullCopy( Ct_Temp, Ct_NoTautH );</a>
<a name="ln4260">                /* since Ct_NoTautH does not have Ct_NoTautH-&gt;iso_sort_key we have to fill out Ct_Temp-&gt;iso_sort_key separately */</a>
<a name="ln4261">                for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4262">                    Ct_Temp-&gt;iso_sort_key[nCanonRankNoTautH[i]-1] = iso_sort_key_NoTautH[i];</a>
<a name="ln4263">                }</a>
<a name="ln4264">                Ct_Temp-&gt;len_iso_sort_key = num_atoms;</a>
<a name="ln4265">            } else {</a>
<a name="ln4266">                goto exit_error_alloc;</a>
<a name="ln4267">            }</a>
<a name="ln4268">            Ct_NoTautHIso = Ct_Temp;</a>
<a name="ln4269">            Ct_Temp    = NULL;</a>
<a name="ln4270">            memcpy( nSymmRankNoTautHIso,  nSymmRankNoTautH, num_atoms*sizeof(nSymmRankNoTautHIso[0]) );</a>
<a name="ln4271">            memcpy( nCanonRankNoTautHIso, nCanonRankNoTautH, num_atoms*sizeof(nCanonRankNoTautHIso[0]) );</a>
<a name="ln4272">            memcpy( nAtomNumberCanonNoTautHIso, nAtomNumberCanonNoTautH, num_atoms*sizeof(nAtomNumberCanonNoTautHIso[0]) );</a>
<a name="ln4273">        }</a>
<a name="ln4274">        /* in case of non-tautomeric component this is the final result */</a>
<a name="ln4275">        /* i = CtFullCompare( Ct_NoTautHIso, Ct_Temp, num_atoms, 0, 0 );*/</a>
<a name="ln4276">    }</a>
<a name="ln4277"> </a>
<a name="ln4278"> </a>
<a name="ln4279">    if ( bReqTaut ) {</a>
<a name="ln4280">        /*****************************************************************************/</a>
<a name="ln4281">        /* Tautomeric Structure Canonicalizaton:                                     */</a>
<a name="ln4282">        /* get base canonical numbering, connection table, and equivalence partition */</a>
<a name="ln4283">        /*****************************************************************************/</a>
<a name="ln4284">        /* find H atoms attached to non-tautomeric-endpoints and to tautomeric endpoints */</a>
<a name="ln4285">        maxlenNumH            = num_atoms + T_NUM_NO_ISOTOPIC*(num_at_tg-num_atoms) + 1; /* including negative charges */</a>
<a name="ln4286">        nSymmRankBase         = (AT_RANK *)  inchi_calloc( num_max, sizeof(nSymmRankBase[0]       ) );</a>
<a name="ln4287">        nCanonRankBase        = (AT_RANK *)  inchi_calloc( num_max, sizeof(nCanonRankBase[0]      ) );</a>
<a name="ln4288">        nAtomNumberCanonBase  = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberCanonBase[0]) );</a>
<a name="ln4289">        numH                  = (NUM_H *)    inchi_calloc( maxlenNumH, sizeof(numH[0]) );</a>
<a name="ln4290">        if ( !numH || !nSymmRankBase || !nCanonRankBase || !nAtomNumberCanonBase ) {</a>
<a name="ln4291">            goto exit_error_alloc;</a>
<a name="ln4292">        }</a>
<a name="ln4293">        /* non-tautomeric H counts */</a>
<a name="ln4294">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4295">            numH[i] = (!at_base[i].endpoint &amp;&amp; at_base[i].num_H)? at_base[i].num_H+BASE_H_NUMBER : EMPTY_H_NUMBER;</a>
<a name="ln4296">        }</a>
<a name="ln4297">        /* tautomeric H and negative charge counts */</a>
<a name="ln4298">        for ( i = k = num_atoms; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4299">            m = i-num_atoms;</a>
<a name="ln4300">            for ( j = 0; j &lt; T_NUM_NO_ISOTOPIC; j ++ ) {</a>
<a name="ln4301">                /* non-zeroes for j=1 are negative charge counts; T_NUM_NO_ISOTOPIC=2 entry per t-group */</a>
<a name="ln4302">                numH[k ++] = t_group_info-&gt;t_group[m].num[j]? t_group_info-&gt;t_group[m].num[j]+BASE_H_NUMBER : EMPTY_H_NUMBER;</a>
<a name="ln4303">            }</a>
<a name="ln4304">        }</a>
<a name="ln4305">        /* pointers */</a>
<a name="ln4306">        pCD[iBase].LinearCT                   = NULL;</a>
<a name="ln4307">        pCD[iBase].NumH                       = numH; /* num_atoms non-tautomeric H; num_tg pairs of H and (-) in t-groups */</a>
<a name="ln4308">        pCD[iBase].NumHfixed                  = NULL;</a>
<a name="ln4309">        pCD[iBase].iso_sort_key               = NULL;</a>
<a name="ln4310">        pCD[iBase].iso_exchg_atnos            = NULL;</a>
<a name="ln4311">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4312">        pCD[iBase].iso_sort_key_Hfixed        = NULL;</a>
<a name="ln4313">#endif</a>
<a name="ln4314">        /* variables - unchanged */              </a>
<a name="ln4315">        pCD[iBase].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln4316">        pCD[iBase].nMaxLenLinearCT            = s[iBase].nLenCT + 1;</a>
<a name="ln4317">        pCD[iBase].maxlenNumH                 = maxlenNumH;</a>
<a name="ln4318">        /* return values &amp; input/output */    </a>
<a name="ln4319">        pCD[iBase].nLenLinearCT               = s[iBase].nLenCT;</a>
<a name="ln4320">        pCD[iBase].nLenCTAtOnly               = s[iBase].nLenCTAtOnly;</a>
<a name="ln4321">        pCD[iBase].lenNumH                    = lenNumH = k;</a>
<a name="ln4322">        pCD[iBase].lenNumHfixed               = 0;</a>
<a name="ln4323">        pCD[iBase].len_iso_sort_key           = 0;</a>
<a name="ln4324">        pCD[iBase].maxlen_iso_sort_key        = 0;</a>
<a name="ln4325">        pCD[iBase].len_iso_exchg_atnos        = 0;</a>
<a name="ln4326">        pCD[iBase].maxlen_iso_exchg_atnos     = 0;</a>
<a name="ln4327">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4328">        pCD[iBase].len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln4329">        pCD[iBase].maxlen_iso_sort_key_Hfixed = 0;</a>
<a name="ln4330">#endif</a>
<a name="ln4331">        pCD[iBase].nAuxRank                   = NULL;</a>
<a name="ln4332"> </a>
<a name="ln4333">        /* make sure the initial partition is equitable (at this point t-groups do not have ranks yet) */</a>
<a name="ln4334">        FillOutAtomInvariant2( at_base, num_atoms, num_at_tg, pAtomInvariant, 1 /*bIgnoreIsotopic*/,</a>
<a name="ln4335">                       0 /*bHydrogensInRanks*/, 0 /*bHydrogensFixedInRanks*/, 1 /*bTaut=bDigraph*/,</a>
<a name="ln4336">                       1 /* bTautGroupsOnly */, t_group_info );</a>
<a name="ln4337">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4338">            pAtomInvariant[i].val[0] = pBCN-&gt;pRankStack[0][i];</a>
<a name="ln4339">        }</a>
<a name="ln4340">        /* initial ranks for t-group(s) only */</a>
<a name="ln4341">        nNumCurrRanks = SetInitialRanks2( num_at_tg, pAtomInvariant, nRank, nAtomNumber );</a>
<a name="ln4342">        /* make equitable, call digraph procedure;</a>
<a name="ln4343">           pBCN-&gt;pRankStack[0] is nRank, pBCN-&gt;pRankStack[1] is nAtomNumber</a>
<a name="ln4344">           This should only split ranks of tautomeric groups */</a>
<a name="ln4345">        nNumCurrRanks = DifferentiateRanks4( num_at_tg, NeighList[TAUT_YES], </a>
<a name="ln4346">                                         nNumCurrRanks, pBCN-&gt;pRankStack[0], nTempRank /* temp array */,</a>
<a name="ln4347">                                         pBCN-&gt;pRankStack[1],  (AT_RANK)num_atoms, &amp;lCount );</a>
<a name="ln4348">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln4349">        /* refine no-H partition according to non-taut H distribution */</a>
<a name="ln4350">        memset( pAtomInvariantAux, 0, num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4351">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4352">            pAtomInvariantAux[i].val[0] = nSymmRankNoTautH[i];</a>
<a name="ln4353">            pAtomInvariantAux[i].val[1] = numH[i]; /* additional differentiation */</a>
<a name="ln4354">        }</a>
<a name="ln4355">        for ( j = i; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4356">            pAtomInvariantAux[i].val[0] = nRank[i];</a>
<a name="ln4357">        }</a>
<a name="ln4358"> </a>
<a name="ln4359">        /* initial ranks for t-group(s) */</a>
<a name="ln4360">        nNumCurrRanks = SetInitialRanks2( num_at_tg, pAtomInvariantAux, nRankAux, nAtomNumberAux );</a>
<a name="ln4361">        /* make equitable, call digraph procedure */</a>
<a name="ln4362">        nNumCurrRanks = DifferentiateRanks4( num_at_tg, NeighList[TAUT_YES], </a>
<a name="ln4363">                                         nNumCurrRanks, nRankAux, nTempRank /* temp array */,</a>
<a name="ln4364">                                         nAtomNumberAux,  (AT_RANK)num_atoms, &amp;lCount );</a>
<a name="ln4365">        /* to accelerate do not call CanonGraph() to find really equivalent atoms */</a>
<a name="ln4366">        pCD[iBase].nAuxRank = nRankAux;</a>
<a name="ln4367">#endif    </a>
<a name="ln4368"> </a>
<a name="ln4369"> </a>
<a name="ln4370">        ret = CanonGraph05( num_atoms, num_at_tg, num_max, 1 /* digraph*/, NeighList[TAUT_YES], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4371">                          nSymmRankBase,  nCanonRankBase, nAtomNumberCanonBase, pCD+iBase, pCC, &amp;Ct_NoTautH, &amp;Ct_Base );</a>
<a name="ln4372">        if ( ret &lt; 0 ) {</a>
<a name="ln4373">            goto exit_error;</a>
<a name="ln4374">        }</a>
<a name="ln4375">    </a>
<a name="ln4376">        /* tautomeric isotopic structure */</a>
<a name="ln4377">        /**************************************************************************************/</a>
<a name="ln4378">        /* Isotopic atoms and isotopic H atoms and isotopic tautomeric groups                 */</a>
<a name="ln4379">        /* get isotopic canonical numbering, connection table, and equivalence partition      */</a>
<a name="ln4380">        /**************************************************************************************/</a>
<a name="ln4381">        if ( (s[iBase].num_isotopic_atoms        &amp;&amp; !s[iBase].bIgnoreIsotopic) ||</a>
<a name="ln4382">             (s[iBase].bHasIsotopicTautGroups    &amp;&amp; !bTautIgnoreIsotopic) || </a>
<a name="ln4383">             (bUseIsoAuxBase[iBase]              &amp;&amp; !bTautIgnoreIsotopic) ) {</a>
<a name="ln4384">                               </a>
<a name="ln4385">            t_group_info-&gt;bIgnoreIsotopic = bTautIgnoreIsotopic;</a>
<a name="ln4386"> </a>
<a name="ln4387">            nSymmRankBaseIso        = (AT_RANK *)  inchi_calloc( num_max, sizeof(nSymmRankBaseIso[0]       ) );</a>
<a name="ln4388">            nCanonRankBaseIso       = (AT_RANK *)  inchi_calloc( num_max, sizeof(nCanonRankBaseIso[0]      ) );</a>
<a name="ln4389">            nAtomNumberCanonBaseIso = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberCanonBaseIso[0]) );</a>
<a name="ln4390">            if ( bUseIsoAuxBase[iBase] ) {</a>
<a name="ln4391">                maxlen_iso_exchg_atnos = num_max+1;</a>
<a name="ln4392">                iso_exchg_atnos     = (S_CHAR  *)  inchi_calloc( maxlen_iso_exchg_atnos, sizeof(iso_exchg_atnos[0]) );</a>
<a name="ln4393">            } </a>
<a name="ln4394">            maxlen_iso_sort_keyBase = num_max+1; /* num_at_tg+1;*/</a>
<a name="ln4395">            iso_sort_keyBase        = (AT_ISO_SORT_KEY *) inchi_calloc( maxlen_iso_sort_keyBase, sizeof(iso_sort_keyBase[0]) );</a>
<a name="ln4396">            if ( !nSymmRankBaseIso || !nCanonRankBaseIso || !nAtomNumberCanonBaseIso ||</a>
<a name="ln4397">                 !iso_sort_keyBase ||</a>
<a name="ln4398">                 (maxlen_iso_exchg_atnos  &amp;&amp; !iso_exchg_atnos) ) {</a>
<a name="ln4399">                goto exit_error_alloc;</a>
<a name="ln4400">            }</a>
<a name="ln4401">            /* atoms */</a>
<a name="ln4402">            num_iso_NoTautH   = 0;</a>
<a name="ln4403">            num_iso_NoAuxBase = 0;</a>
<a name="ln4404">            if ( iso_exchg_atnos ) {</a>
<a name="ln4405">                len_iso_exchg_atnos = num_at_tg;</a>
<a name="ln4406">            }</a>
<a name="ln4407">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4408">                if ( at_base[i].endpoint || (iso_exchg_atnos &amp;&amp; (at_base[i].cFlags &amp; AT_FLAG_ISO_H_POINT)) ) {</a>
<a name="ln4409">                    /* tautomeric or may have exchangeable isotopic H */</a>
<a name="ln4410">                    iso_sort_key = make_iso_sort_key( at_base[i].iso_atw_diff, 0, 0, 0);</a>
<a name="ln4411">                    if ( iso_exchg_atnos ) {</a>
<a name="ln4412">                        num_iso_NoAuxBase += !at_base[i].endpoint; /* these non-taut atom may exchange isotopic H as tautomeric atoms do */</a>
<a name="ln4413">                    }</a>
<a name="ln4414">                } else {</a>
<a name="ln4415">                    /* non-mobile H */</a>
<a name="ln4416">                    iso_sort_key = make_iso_sort_key( at_base[i].iso_atw_diff, at_base[i].num_iso_H[0], at_base[i].num_iso_H[1], at_base[i].num_iso_H[2]);</a>
<a name="ln4417">                    if ( iso_exchg_atnos ) {</a>
<a name="ln4418">                        iso_exchg_atnos[i] = 1; /* atom cannot have exchangable isotopic H atom(s) */</a>
<a name="ln4419">                    }</a>
<a name="ln4420">                }</a>
<a name="ln4421">                if ( iso_sort_key ) {</a>
<a name="ln4422">                    num_iso_NoTautH ++;</a>
<a name="ln4423">                    iso_sort_keyBase[i] = iso_sort_key;</a>
<a name="ln4424">                } else {</a>
<a name="ln4425">                    iso_sort_keyBase[i] = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4426">                }</a>
<a name="ln4427">            }</a>
<a name="ln4428">            /* check marking and count of non-taut atoms that may exchange isotopic H -- debug only */</a>
<a name="ln4429">            if ( iso_exchg_atnos ) {</a>
<a name="ln4430">                if ( num_iso_NoAuxBase != t_group_info-&gt;nIsotopicEndpointAtomNumber[0] ) {</a>
<a name="ln4431">                    ret = CT_ISOCOUNT_ERR;</a>
<a name="ln4432">                    goto exit_error;</a>
<a name="ln4433">                }</a>
<a name="ln4434">                for ( i = 1; i &lt;= num_iso_NoAuxBase; i ++ ) {</a>
<a name="ln4435">                    j = t_group_info-&gt;nIsotopicEndpointAtomNumber[i];</a>
<a name="ln4436">                    if ( at_base[j].endpoint || !(at_base[j].cFlags &amp; AT_FLAG_ISO_H_POINT) ) {</a>
<a name="ln4437">                        ret = CT_ISOCOUNT_ERR;</a>
<a name="ln4438">                        goto exit_error;</a>
<a name="ln4439">                    }</a>
<a name="ln4440">                }</a>
<a name="ln4441">            }</a>
<a name="ln4442">            /* t-groups */</a>
<a name="ln4443">            num_iso_Base = 0;</a>
<a name="ln4444">            if ( iso_exchg_atnos ) {</a>
<a name="ln4445">                for ( i = num_atoms; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4446">                    iso_sort_keyBase[i] = EMPTY_ISO_SORT_KEY; /* new mode: do not provide info about isotopic tautomeric H */</a>
<a name="ln4447">                }</a>
<a name="ln4448">            } else {</a>
<a name="ln4449">                for ( i = num_atoms; i &lt; num_at_tg; i ++ ) { /* should not happen anymore */</a>
<a name="ln4450">                    m = i-num_atoms;</a>
<a name="ln4451">                    if ( (iso_sort_key = t_group_info-&gt;t_group[m].iWeight) ) {</a>
<a name="ln4452">                        /* old approach: each t-group has its own isotopic &quot;weight&quot; */</a>
<a name="ln4453">                        num_iso_Base ++;</a>
<a name="ln4454">                        iso_sort_keyBase[i] = iso_sort_key;</a>
<a name="ln4455">                    } else {</a>
<a name="ln4456">                        iso_sort_keyBase[i] = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4457">                    }</a>
<a name="ln4458">                }</a>
<a name="ln4459">            }</a>
<a name="ln4460">            if ( !num_iso_NoAuxBase &amp;&amp; iso_exchg_atnos ) {</a>
<a name="ln4461">                /* all atoms that may exchange isotopic H are either tautomeric or not present */</a>
<a name="ln4462">                inchi_free( iso_exchg_atnos );</a>
<a name="ln4463">                iso_exchg_atnos = NULL;</a>
<a name="ln4464">                len_iso_exchg_atnos    = 0;</a>
<a name="ln4465">                maxlen_iso_exchg_atnos = 0;</a>
<a name="ln4466">            }</a>
<a name="ln4467">            if ( !num_iso_NoTautH &amp;&amp; !num_iso_Base &amp;&amp; iso_sort_keyBase ) {</a>
<a name="ln4468">                /* no isotopic atoms present */</a>
<a name="ln4469">                inchi_free( iso_sort_keyBase );</a>
<a name="ln4470">                iso_sort_keyBase = NULL;</a>
<a name="ln4471">                maxlen_iso_sort_keyBase = 0;</a>
<a name="ln4472">            } else {</a>
<a name="ln4473">                len_iso_sort_keyBase = num_at_tg;</a>
<a name="ln4474">            }</a>
<a name="ln4475">            if ( !iso_exchg_atnos &amp;&amp; !iso_sort_keyBase ) {</a>
<a name="ln4476">                /* no isotopic part at all or only tautomeric groups */</a>
<a name="ln4477">                inchi_free( nSymmRankBaseIso );        nSymmRankBaseIso        = NULL;</a>
<a name="ln4478">                inchi_free( nCanonRankBaseIso );       nCanonRankBaseIso       = NULL;</a>
<a name="ln4479">                inchi_free( nAtomNumberCanonBaseIso ); nAtomNumberCanonBaseIso = NULL;</a>
<a name="ln4480">            } else {</a>
<a name="ln4481">                /* proceed with tautomeric isotopic canonicalization */</a>
<a name="ln4482">                /* pointers */</a>
<a name="ln4483">                pCD[iBase].LinearCT                   = NULL;</a>
<a name="ln4484">                pCD[iBase].NumH                       = numH; /* num_atoms non-tautomeric H; num_tg pairs of H and (-) in t-groups */</a>
<a name="ln4485">                pCD[iBase].NumHfixed                  = NULL;</a>
<a name="ln4486">                pCD[iBase].iso_sort_key               = iso_sort_keyBase;</a>
<a name="ln4487">                pCD[iBase].iso_exchg_atnos            = iso_exchg_atnos;</a>
<a name="ln4488">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4489">                pCD[iBase].iso_sort_key_Hfixed        = NULL;</a>
<a name="ln4490">#endif</a>
<a name="ln4491">                /* variables - unchanged */              </a>
<a name="ln4492">                pCD[iBase].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln4493">                pCD[iBase].nMaxLenLinearCT            = s[iBase].nLenCT + 1;</a>
<a name="ln4494">                pCD[iBase].maxlenNumH                 = maxlenNumH;</a>
<a name="ln4495">                /* return values &amp; input/output */    </a>
<a name="ln4496">                pCD[iBase].nLenLinearCT               = s[iBase].nLenCT;</a>
<a name="ln4497">                pCD[iBase].nLenCTAtOnly               = s[iBase].nLenCTAtOnly;</a>
<a name="ln4498">                pCD[iBase].lenNumH                    = lenNumH /* = k */;</a>
<a name="ln4499">                pCD[iBase].lenNumHfixed               = 0;</a>
<a name="ln4500">                pCD[iBase].len_iso_sort_key           = len_iso_sort_keyBase;</a>
<a name="ln4501">                pCD[iBase].maxlen_iso_sort_key        = maxlen_iso_sort_keyBase;</a>
<a name="ln4502">                pCD[iBase].len_iso_exchg_atnos        = len_iso_exchg_atnos;</a>
<a name="ln4503">                pCD[iBase].maxlen_iso_exchg_atnos     = maxlen_iso_exchg_atnos;</a>
<a name="ln4504">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4505">                pCD[iBase].len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln4506">                pCD[iBase].maxlen_iso_sort_key_Hfixed = 0;</a>
<a name="ln4507">#endif</a>
<a name="ln4508">                pCD[iBase].nAuxRank                   = NULL;</a>
<a name="ln4509">        </a>
<a name="ln4510">                if ( num_iso_NoTautH || num_iso_Base || num_iso_NoAuxBase ) {</a>
<a name="ln4511">                    /* check whether we need actual canonicalization */</a>
<a name="ln4512">                    memset( nTempRank, 0, num_max * sizeof(nTempRank[0]) );</a>
<a name="ln4513">                    for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4514">                        if ( nTempRank[nSymmRankBase[i]-1] &lt; i ) {</a>
<a name="ln4515">                            nTempRank[nSymmRankBase[i]-1] = i; /* greatest class representative */</a>
<a name="ln4516">                        }</a>
<a name="ln4517">                    }</a>
<a name="ln4518">                    for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4519">                        if ( (iso_sort_keyBase? (iso_sort_keyBase[i] != iso_sort_keyBase[nTempRank[nSymmRankBase[i]-1]]):0) ||</a>
<a name="ln4520">                             (iso_exchg_atnos? (iso_exchg_atnos[i] != iso_exchg_atnos[nTempRank[nSymmRankBase[i]-1]]):0)) {</a>
<a name="ln4521">                            pCD[iBase].nCanonFlags |= CANON_FLAG_ISO_TAUT_DIFF;</a>
<a name="ln4522">                            break; /* atoms so far found to be equivalent have different number of H; the canonicalization is needed */</a>
<a name="ln4523">                        }</a>
<a name="ln4524">                    }</a>
<a name="ln4525">                } else {</a>
<a name="ln4526">                    i = num_at_tg; /* should not happen */</a>
<a name="ln4527">                }</a>
<a name="ln4528">                /* i = 0; *//* debug: force to call the canonicalization */</a>
<a name="ln4529">                if ( i &lt; num_at_tg ) {</a>
<a name="ln4530">                    /* we need canonicalization */</a>
<a name="ln4531">                    /* get aux canonical ranking of the structure with isotopic non-tautomeric H */</a>
<a name="ln4532"> </a>
<a name="ln4533">    #if ( USE_AUX_RANKING == 1 )</a>
<a name="ln4534">                    /* refine no-taut-H partition according to non-taut H + t-groups isotopic distribution */</a>
<a name="ln4535">                    memset( pAtomInvariantAux, 0, num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4536">                    for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4537">                        pAtomInvariantAux[i].val[0] = nSymmRankBase[i];</a>
<a name="ln4538">                        pAtomInvariantAux[i].iso_sort_key = iso_sort_keyBase? iso_sort_keyBase[i] : 0; /* additional differentiation */</a>
<a name="ln4539">                        pAtomInvariantAux[i].iso_aux_key  = iso_exchg_atnos? iso_exchg_atnos[i] : 0;</a>
<a name="ln4540">                    }</a>
<a name="ln4541">                    /* initial ranks for non-taut H isotopic distribution */</a>
<a name="ln4542">                    nNumCurrRanks = SetInitialRanks2( num_at_tg, pAtomInvariantAux, nRankAux, nAtomNumberAux );</a>
<a name="ln4543">                    /* make equitable, not a digraph procedure */</a>
<a name="ln4544">                    nNumCurrRanks = DifferentiateRanks2( num_at_tg, NeighList[TAUT_YES],</a>
<a name="ln4545">                                                        nNumCurrRanks, nRankAux,</a>
<a name="ln4546">                                                        nTempRank, nAtomNumberAux, &amp;lCount, 0 /* 0 means first use qsort */ );</a>
<a name="ln4547">                    /* to accelerate do not call CanonGraph() to find really equivalent atoms */</a>
<a name="ln4548">                    pCD[iBase].nAuxRank = nRankAux;</a>
<a name="ln4549">    #endif    </a>
<a name="ln4550"> </a>
<a name="ln4551"> </a>
<a name="ln4552">                    ret = CanonGraph06( num_atoms, num_at_tg, num_max, 1 /* digraph */, NeighList[TAUT_YES], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4553">                                      nSymmRankBaseIso,  nCanonRankBaseIso, nAtomNumberCanonBaseIso, pCD+iBase, pCC, &amp;Ct_Base, &amp;Ct_BaseIso );</a>
<a name="ln4554">                    if ( ret &lt; 0 ) {</a>
<a name="ln4555">                        goto exit_error;</a>
<a name="ln4556">                    }</a>
<a name="ln4557">                    /* in case of a tautomeric structure the final results are in:</a>
<a name="ln4558"> </a>
<a name="ln4559">                               nSymmRankBaseIso</a>
<a name="ln4560">                               nCanonRankBaseIso</a>
<a name="ln4561">                               nAtomNumberCanonBaseIso</a>
<a name="ln4562">                               Ct_BaseIso</a>
<a name="ln4563">                               iso_sort_keyBase (original isotopic atom &amp; t-group positions)</a>
<a name="ln4564">                               Ct_BaseIso-&gt;iso_exchg_atnos: 0=&gt;can exchange isotopic H, including tautomeric atoms</a>
<a name="ln4565">                               iso_exchg_atnos            : same, in order of t_group_info-&gt;nIsotopicEndpointAtomNumber[]</a>
<a name="ln4566">                    */</a>
<a name="ln4567">                } else {</a>
<a name="ln4568">                    /* copy the results of the previous (no taut H) canonicalization */</a>
<a name="ln4569">                    /* in this case numHNoTautH[] is not needed for the next canonicalization(s) */</a>
<a name="ln4570">                    if ( (Ct_Temp = (ConTable *)inchi_calloc( 1, sizeof( *Ct_Temp ) ) ) &amp;&amp;</a>
<a name="ln4571">                         CTableCreate( Ct_Temp, num_atoms, pCD+iBase) ) {</a>
<a name="ln4572">                        CtFullCopy( Ct_Temp, Ct_Base );</a>
<a name="ln4573">                        /* since Ct_Base does not have Ct_Base-&gt;iso_sort_key we</a>
<a name="ln4574">                           have to fill out Ct_Temp-&gt;iso_sort_key separately */</a>
<a name="ln4575">                        if ( iso_sort_keyBase ) {</a>
<a name="ln4576">                            for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln4577">                                Ct_Temp-&gt;iso_sort_key[nCanonRankBase[i]-1] = iso_sort_keyBase[i];</a>
<a name="ln4578">                            }</a>
<a name="ln4579">                            Ct_Temp-&gt;len_iso_sort_key = num_at_tg;</a>
<a name="ln4580">                        } else {</a>
<a name="ln4581">                            Ct_Temp-&gt;len_iso_sort_key = 0;</a>
<a name="ln4582">                        }</a>
<a name="ln4583">                        if ( iso_exchg_atnos ) {</a>
<a name="ln4584">                            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4585">                                Ct_Temp-&gt;iso_exchg_atnos[nCanonRankBase[i]-1] = iso_exchg_atnos[i];</a>
<a name="ln4586">                            }</a>
<a name="ln4587">                            Ct_Temp-&gt;len_iso_exchg_atnos = num_at_tg;</a>
<a name="ln4588">                        } else {</a>
<a name="ln4589">                            Ct_Temp-&gt;len_iso_exchg_atnos = 0;</a>
<a name="ln4590">                        }</a>
<a name="ln4591">                    } else {</a>
<a name="ln4592">                        goto exit_error_alloc;</a>
<a name="ln4593">                    }</a>
<a name="ln4594">                    Ct_BaseIso = Ct_Temp;</a>
<a name="ln4595">                    Ct_Temp    = NULL;</a>
<a name="ln4596">                    memcpy( nSymmRankBaseIso,  nSymmRankBase, num_at_tg*sizeof(nSymmRankBaseIso[0]) );</a>
<a name="ln4597">                    memcpy( nCanonRankBaseIso, nCanonRankBase, num_at_tg*sizeof(nCanonRankBaseIso[0]) );</a>
<a name="ln4598">                    memcpy( nAtomNumberCanonBaseIso, nAtomNumberCanonBase, num_at_tg*sizeof(nAtomNumberCanonBaseIso[0]) );</a>
<a name="ln4599">                }</a>
<a name="ln4600">                /* in case of non-tautomeric component this is the final result */</a>
<a name="ln4601">                /* i = CtFullCompare( Ct_BaseIso, Ct_Temp, num_at_tg, 0, 0 );*/</a>
<a name="ln4602"> </a>
<a name="ln4603">                t_group_info-&gt;bIgnoreIsotopic = 1;</a>
<a name="ln4604">            }</a>
<a name="ln4605">        }</a>
<a name="ln4606">    }</a>
<a name="ln4607"> </a>
<a name="ln4608">    /**********************************************************************************/</a>
<a name="ln4609">    /* get &quot;fixed H&quot; canonical numbering, connection table, and equivalence partition */</a>
<a name="ln4610">    /**********************************************************************************/</a>
<a name="ln4611"> </a>
<a name="ln4612">    if ( bReqTaut &amp;&amp; bReqNonTaut ) {</a>
<a name="ln4613">        maxlenNumHfixed       = num_atoms + 1;</a>
<a name="ln4614">        nSymmRankFixH         = (AT_RANK *)  inchi_calloc( num_max, sizeof(nSymmRankFixH[0]       ) );</a>
<a name="ln4615">        nCanonRankFixH        = (AT_RANK *)  inchi_calloc( num_max, sizeof(nCanonRankFixH[0]      ) );</a>
<a name="ln4616">        nAtomNumberCanonFixH  = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberCanonFixH[0]) );</a>
<a name="ln4617">        NumHfixed             = (NUM_H *)    inchi_calloc( maxlenNumHfixed, sizeof(NumHfixed[0]) );</a>
<a name="ln4618">        if ( !NumHfixed || !nSymmRankFixH || !nCanonRankFixH || !nAtomNumberCanonFixH ) {</a>
<a name="ln4619">            goto exit_error_alloc;</a>
<a name="ln4620">        }</a>
<a name="ln4621">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4622">            /* fixed and non-tautomeric H different in taut and non-taut structures */</a>
<a name="ln4623">            if ( at_base[i].endpoint ) {</a>
<a name="ln4624">                NumHfixed[i] = at_other[i].num_H? at_other[i].num_H+BASE_H_NUMBER : EMPTY_H_NUMBER;</a>
<a name="ln4625">            } else</a>
<a name="ln4626">            if ( at_other[i].num_H != at_base[i].num_H ) {</a>
<a name="ln4627">                NumHfixed[i] = (NUM_H)at_other[i].num_H - (NUM_H)at_base[i].num_H + BASE_H_NUMBER;</a>
<a name="ln4628">            } else {</a>
<a name="ln4629">                NumHfixed[i] = EMPTY_H_NUMBER;</a>
<a name="ln4630">            }</a>
<a name="ln4631">        }</a>
<a name="ln4632">        /* pointers */</a>
<a name="ln4633">        pCD[iOther].LinearCT                   = NULL; /* LinearCT; */</a>
<a name="ln4634">        pCD[iOther].NumH                       = numHNoTautH;</a>
<a name="ln4635">        pCD[iOther].NumHfixed                  = NumHfixed;/* variables - unchanged */</a>
<a name="ln4636">        pCD[iOther].iso_sort_key               = NULL;</a>
<a name="ln4637">        pCD[iOther].iso_exchg_atnos            = NULL;</a>
<a name="ln4638">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4639">        pCD[iOther].iso_sort_key_Hfixed        = NULL;</a>
<a name="ln4640">#endif</a>
<a name="ln4641">        pCD[iOther].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln4642">        pCD[iOther].nMaxLenLinearCT            = s[iOther].nLenCTAtOnly + 1;</a>
<a name="ln4643">        pCD[iOther].maxlenNumH                 = maxlenNumHNoTautH;</a>
<a name="ln4644">        pCD[iOther].maxlenNumHfixed            = maxlenNumHfixed;</a>
<a name="ln4645">        /* return values &amp; input/output */     </a>
<a name="ln4646">        pCD[iOther].nLenLinearCT               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4647">        pCD[iOther].nLenCTAtOnly               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4648">        pCD[iOther].lenNumH                    = lenNumHNoTautH = num_atoms;</a>
<a name="ln4649">        pCD[iOther].lenNumHfixed               = num_atoms;</a>
<a name="ln4650">        pCD[iOther].len_iso_sort_key           = 0;</a>
<a name="ln4651">        pCD[iOther].maxlen_iso_sort_key        = 0;</a>
<a name="ln4652">        pCD[iOther].len_iso_exchg_atnos        = 0;</a>
<a name="ln4653">        pCD[iOther].maxlen_iso_exchg_atnos     = 0;</a>
<a name="ln4654">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4655">        pCD[iOther].len_iso_sort_key_Hfixed    = 0;</a>
<a name="ln4656">        pCD[iOther].maxlen_iso_sort_key_Hfixed = 0;</a>
<a name="ln4657">#endif</a>
<a name="ln4658">        pCD[iOther].nAuxRank                   = NULL;</a>
<a name="ln4659"> </a>
<a name="ln4660">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln4661">        if ( !nRankAux )</a>
<a name="ln4662">            nRankAux            = (AT_RANK *)  inchi_calloc( num_max, sizeof(nRankAux[0]            ) );</a>
<a name="ln4663">        if ( !nAtomNumberAux )</a>
<a name="ln4664">            nAtomNumberAux      = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberAux[0]      ) );</a>
<a name="ln4665">        if ( !pAtomInvariantAux )</a>
<a name="ln4666">            pAtomInvariantAux   = (ATOM_INVARIANT2 *) inchi_malloc( num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4667"> </a>
<a name="ln4668">        if ( !nRankAux || !nAtomNumberAux ||</a>
<a name="ln4669">             !pAtomInvariantAux ) {</a>
<a name="ln4670">            goto exit_error_alloc;</a>
<a name="ln4671">        }</a>
<a name="ln4672">        /* refine no-H partition according to non-taut H distribution */</a>
<a name="ln4673">        memset( pAtomInvariantAux, 0, num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4674">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4675">            pAtomInvariantAux[i].val[0] = nSymmRankBase[i];</a>
<a name="ln4676">            pAtomInvariantAux[i].val[1] = NumHfixed[i]; /* additional differentiation */</a>
<a name="ln4677">        }</a>
<a name="ln4678"> </a>
<a name="ln4679">        /* initial ranks for t-group(s) */</a>
<a name="ln4680">        nNumCurrRanks = SetInitialRanks2( num_atoms, pAtomInvariantAux, nRankAux, nAtomNumberAux );</a>
<a name="ln4681">        /* make equitable, digraph procedure */</a>
<a name="ln4682">        nNumCurrRanks = DifferentiateRanks2( num_atoms, NeighList[TAUT_NON],</a>
<a name="ln4683">                                            nNumCurrRanks, nRankAux,</a>
<a name="ln4684">                                            nTempRank, nAtomNumberAux, &amp;lCount, 0 /* 0 means use qsort */ );</a>
<a name="ln4685">        /* to accelerate do not call CanonGraph() to find really equivalent atoms */</a>
<a name="ln4686">        pCD[iOther].nAuxRank = nRankAux;</a>
<a name="ln4687">#endif    </a>
<a name="ln4688">    </a>
<a name="ln4689">        ret = CanonGraph07( num_atoms, num_atoms, num_max, 0, NeighList[TAUT_NON], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4690">                          nSymmRankFixH,  nCanonRankFixH, nAtomNumberCanonFixH, pCD+iOther, pCC, &amp;Ct_NoTautH, &amp;Ct_FixH );</a>
<a name="ln4691">        if ( ret &lt; 0 ) {</a>
<a name="ln4692">            goto exit_error;</a>
<a name="ln4693">        }</a>
<a name="ln4694"> </a>
<a name="ln4695">        /*******************************************************************************************/</a>
<a name="ln4696">        /* get &quot;fixed H&quot; isotopic canonical numbering, connection table, and equivalence partition */</a>
<a name="ln4697">        /*******************************************************************************************/</a>
<a name="ln4698">        iflag = (s[iBase].num_isotopic_atoms &amp;&amp; !s[iBase].bIgnoreIsotopic) ||</a>
<a name="ln4699">             (s[iBase].bHasIsotopicTautGroups &amp;&amp; !bTautIgnoreIsotopic);</a>
<a name="ln4700">        if (bFixIsoFixedH) /* #if ( FIX_ISO_FIXEDH_BUG == 1 )  */</a>
<a name="ln4701">             /* fix bug when iso H was removed as a proton and fixed-H isotopic layer is missing -  2008-09-24 DT*/</a>
<a name="ln4702">             iflag = iflag || (s[iOther].num_isotopic_atoms &amp;&amp; !s[iOther].bIgnoreIsotopic);</a>
<a name="ln4703">        if (iflag) {</a>
<a name="ln4704"> </a>
<a name="ln4705">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4706">            maxlen_iso_sort_key_Hfixed  =</a>
<a name="ln4707">#endif</a>
<a name="ln4708">            maxlen_iso_sort_key_NoTautH = num_atoms+1;</a>
<a name="ln4709">            nSymmRankFixHIso        = (AT_RANK *)  inchi_calloc( num_max, sizeof(nSymmRankFixHIso[0]       ) );</a>
<a name="ln4710">            nCanonRankFixHIso       = (AT_RANK *)  inchi_calloc( num_max, sizeof(nCanonRankFixHIso[0]      ) );</a>
<a name="ln4711">            nAtomNumberCanonFixHIso = (AT_NUMB *)  inchi_calloc( num_max, sizeof(nAtomNumberCanonFixHIso[0]) );</a>
<a name="ln4712">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4713">            iso_sort_key_Hfixed     = (AT_ISO_SORT_KEY *) inchi_calloc( maxlen_iso_sort_key_Hfixed, sizeof(iso_sort_key_Hfixed[0]) );</a>
<a name="ln4714">#endif</a>
<a name="ln4715">            iso_sort_key_NoTautH    = (AT_ISO_SORT_KEY *) inchi_calloc( maxlen_iso_sort_key_NoTautH, sizeof(iso_sort_key_NoTautH[0]) );</a>
<a name="ln4716"> </a>
<a name="ln4717">            if ( !nSymmRankFixHIso || !nCanonRankFixHIso || !nAtomNumberCanonFixHIso ||</a>
<a name="ln4718">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4719">                 !iso_sort_key_Hfixed ||</a>
<a name="ln4720">#endif</a>
<a name="ln4721">                 !iso_sort_key_NoTautH ) {</a>
<a name="ln4722">                goto exit_error_alloc;</a>
<a name="ln4723">            }</a>
<a name="ln4724"> </a>
<a name="ln4725">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4726">            /* fill out isotopic non-tautomeric keys */</a>
<a name="ln4727">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4728">                if ( at_base[i].endpoint ) {</a>
<a name="ln4729">                    iso_sort_key  = make_iso_sort_key( at_base[i].iso_atw_diff, 0, 0, 0);</a>
<a name="ln4730">                    iso_sort_key2 = make_iso_sort_key( 0, at_base[i].num_iso_H[0], at_base[i].num_iso_H[1], at_base[i].num_iso_H[2]);</a>
<a name="ln4731">                } else {</a>
<a name="ln4732">                    iso_sort_key  = make_iso_sort_key( at_base[i].iso_atw_diff, at_base[i].num_iso_H[0], at_base[i].num_iso_H[1], at_base[i].num_iso_H[2]);</a>
<a name="ln4733">                    iso_sort_key2 = 0;</a>
<a name="ln4734">                }</a>
<a name="ln4735">                if ( iso_sort_key ) {</a>
<a name="ln4736">                    iso_sort_key_NoTautH[i] = iso_sort_key;</a>
<a name="ln4737">                    num_iso_NoTautH ++;</a>
<a name="ln4738">                } else {</a>
<a name="ln4739">                    iso_sort_key_NoTautH[i] = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4740">                }</a>
<a name="ln4741">                if ( iso_sort_key2 ) {</a>
<a name="ln4742">                    num_iso_Hfixed ++;</a>
<a name="ln4743">                    iso_sort_key_Hfixed[i] = iso_sort_key2;</a>
<a name="ln4744">                } else {</a>
<a name="ln4745">                    iso_sort_key_Hfixed[i] = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4746">                }</a>
<a name="ln4747">            }</a>
<a name="ln4748">#else</a>
<a name="ln4749">            /* fill out isotopic non-tautomeric keys */</a>
<a name="ln4750">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4751"> </a>
<a name="ln4752">                if (bFixIsoFixedH) /* #if ( FIX_ISO_FIXEDH_BUG == 1 )  */</a>
<a name="ln4753">                {</a>
<a name="ln4754">                    /* fix bug when iso H was removed as a proton and fixed-H isotopic layer is missing -  2008-09-24 DT*/</a>
<a name="ln4755">                    if ( at_other ) </a>
<a name="ln4756">                    {</a>
<a name="ln4757">                        iso_sort_key  = make_iso_sort_key( at_other[i].iso_atw_diff, at_other[i].num_iso_H[0], at_other[i].num_iso_H[1], at_other[i].num_iso_H[2]);</a>
<a name="ln4758">                    } </a>
<a name="ln4759">                    else </a>
<a name="ln4760">                    {</a>
<a name="ln4761">                        iso_sort_key  = make_iso_sort_key( at_base[i].iso_atw_diff, at_base[i].num_iso_H[0], at_base[i].num_iso_H[1], at_base[i].num_iso_H[2]);</a>
<a name="ln4762">                    }</a>
<a name="ln4763">                }</a>
<a name="ln4764">                else</a>
<a name="ln4765">                    iso_sort_key  = make_iso_sort_key( at_base[i].iso_atw_diff, at_base[i].num_iso_H[0], at_base[i].num_iso_H[1], at_base[i].num_iso_H[2]);</a>
<a name="ln4766"> </a>
<a name="ln4767"> </a>
<a name="ln4768"> </a>
<a name="ln4769"> </a>
<a name="ln4770">                if ( iso_sort_key ) {</a>
<a name="ln4771">                    iso_sort_key_NoTautH[i] = iso_sort_key;</a>
<a name="ln4772">                    num_iso_NoTautH ++;</a>
<a name="ln4773">                } else {</a>
<a name="ln4774">                    iso_sort_key_NoTautH[i] = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4775">                }</a>
<a name="ln4776">            }</a>
<a name="ln4777">#endif</a>
<a name="ln4778">            /* pointers */</a>
<a name="ln4779">            pCD[iOther].LinearCT                   = NULL; /* LinearCT; */</a>
<a name="ln4780">            pCD[iOther].NumH                       = numHNoTautH;</a>
<a name="ln4781">            pCD[iOther].NumHfixed                  = NumHfixed;/* variables - unchanged */</a>
<a name="ln4782">            pCD[iOther].iso_sort_key               = iso_sort_key_NoTautH;</a>
<a name="ln4783">            pCD[iOther].iso_exchg_atnos            = NULL;</a>
<a name="ln4784">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4785">            pCD[iOther].iso_sort_key_Hfixed        = iso_sort_key_Hfixed;</a>
<a name="ln4786">#endif</a>
<a name="ln4787">            pCD[iOther].ulTimeOutTime              = pBCN-&gt;ulTimeOutTime;</a>
<a name="ln4788">            pCD[iOther].nMaxLenLinearCT            = s[iOther].nLenCTAtOnly + 1;</a>
<a name="ln4789">            pCD[iOther].maxlenNumH                 = maxlenNumHNoTautH;</a>
<a name="ln4790">            pCD[iOther].maxlenNumHfixed            = maxlenNumHfixed;</a>
<a name="ln4791">            /* return values &amp; input/output */     </a>
<a name="ln4792">            pCD[iOther].nLenLinearCT               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4793">            pCD[iOther].nLenCTAtOnly               = s[iOther].nLenCTAtOnly;</a>
<a name="ln4794">            pCD[iOther].lenNumH                    = lenNumHNoTautH = num_atoms;</a>
<a name="ln4795">            pCD[iOther].lenNumHfixed               = num_atoms;</a>
<a name="ln4796">            pCD[iOther].len_iso_sort_key           = len_iso_sort_key_NoTautH = num_atoms;</a>
<a name="ln4797">            pCD[iOther].maxlen_iso_sort_key        = maxlen_iso_sort_key_NoTautH;</a>
<a name="ln4798">            pCD[iOther].len_iso_exchg_atnos        = 0;</a>
<a name="ln4799">            pCD[iOther].maxlen_iso_exchg_atnos     = 0;</a>
<a name="ln4800">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4801">            pCD[iOther].len_iso_sort_key_Hfixed    = len_iso_sort_key_Hfixed  = num_atoms;</a>
<a name="ln4802">            pCD[iOther].maxlen_iso_sort_key_Hfixed = maxlen_iso_sort_key_Hfixed;</a>
<a name="ln4803">#endif</a>
<a name="ln4804">            pCD[iOther].nAuxRank                   = NULL;</a>
<a name="ln4805"> </a>
<a name="ln4806">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4807">            if ( num_iso_Hfixed || num_iso_NoTautH )</a>
<a name="ln4808">#else</a>
<a name="ln4809">            if ( num_iso_NoTautH )</a>
<a name="ln4810">#endif</a>
<a name="ln4811">            {</a>
<a name="ln4812">                /* check whether we need NoTautH cononicalization */</a>
<a name="ln4813">                memset( nTempRank, 0, num_max * sizeof(nTempRank[0]) );</a>
<a name="ln4814">                for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4815">                    if ( nTempRank[nSymmRankFixH[i]-1] &lt; i ) {</a>
<a name="ln4816">                        nTempRank[nSymmRankFixH[i]-1] = i; /* greatest class representative */</a>
<a name="ln4817">                    }</a>
<a name="ln4818">                }</a>
<a name="ln4819">                for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4820">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )       </a>
<a name="ln4821">                    if ( iso_sort_key_Hfixed[i] != iso_sort_key_Hfixed[nTempRank[nSymmRankFixH[i]-1]] )</a>
<a name="ln4822">                        break;</a>
<a name="ln4823">#endif</a>
<a name="ln4824">                    if ( iso_sort_key_NoTautH[i] != iso_sort_key_NoTautH[nTempRank[nSymmRankFixH[i]-1]])</a>
<a name="ln4825">                        break; /* atoms so far found to be equivalent have different isotopic shifts; the canonicalization is needed */</a>
<a name="ln4826">                }</a>
<a name="ln4827">            } else {</a>
<a name="ln4828">                i = num_atoms; /* should not happen */</a>
<a name="ln4829">            }</a>
<a name="ln4830">            /* i = 0; *//* debug: force to call the canonicalization */</a>
<a name="ln4831">            if ( i &lt; num_atoms ) {</a>
<a name="ln4832">                pCD[iOther].nCanonFlags |= CANON_FLAG_ISO_FIXED_H_DIFF;</a>
<a name="ln4833">                /* we need canonicalization */</a>
<a name="ln4834">                /* get aux canonical ranking of the structure with isotopic non-tautomeric H */</a>
<a name="ln4835"> </a>
<a name="ln4836">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln4837">                /* refine fixed-taut-H partition according to the isotopic distribution */</a>
<a name="ln4838">                memset( pAtomInvariantAux, 0, num_max * sizeof(pAtomInvariantAux[0]) );</a>
<a name="ln4839">                for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4840">                    pAtomInvariantAux[i].val[0] = nSymmRankFixH[i];</a>
<a name="ln4841">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln4842">                    iso_sort_key = 0;</a>
<a name="ln4843">                    if (iso_sort_key_NoTautH[i]!=EMPTY_ISO_SORT_KEY)</a>
<a name="ln4844">                        iso_sort_key |= iso_sort_key_NoTautH[i];</a>
<a name="ln4845">                    if (iso_sort_key_Hfixed[i] !=EMPTY_ISO_SORT_KEY)</a>
<a name="ln4846">                        iso_sort_key |= iso_sort_key_Hfixed[i];</a>
<a name="ln4847">                    if ( !iso_sort_key )</a>
<a name="ln4848">                        iso_sort_key = EMPTY_ISO_SORT_KEY;</a>
<a name="ln4849">#else</a>
<a name="ln4850">                    iso_sort_key = iso_sort_key_NoTautH[i];</a>
<a name="ln4851">#endif</a>
<a name="ln4852">                    pAtomInvariantAux[i].iso_sort_key = iso_sort_key; /* additional differentiation */</a>
<a name="ln4853">                }</a>
<a name="ln4854"> </a>
<a name="ln4855">                /* initial ranks for non-taut H isotopic distribution */</a>
<a name="ln4856">                nNumCurrRanks = SetInitialRanks2( num_atoms, pAtomInvariantAux, nRankAux, nAtomNumberAux );</a>
<a name="ln4857">                /* make equitable, digraph procedure */</a>
<a name="ln4858">                nNumCurrRanks = DifferentiateRanks2( num_atoms, NeighList[TAUT_NON],</a>
<a name="ln4859">                                                    nNumCurrRanks, nRankAux,</a>
<a name="ln4860">                                                    nTempRank, nAtomNumberAux, &amp;lCount, 0 /* 0 means use qsort */ );</a>
<a name="ln4861">                /* to accelerate do not call CanonGraph() to find really equivalent atoms */</a>
<a name="ln4862">                pCD[iOther].nAuxRank = nRankAux;</a>
<a name="ln4863">#endif    </a>
<a name="ln4864"> </a>
<a name="ln4865"> </a>
<a name="ln4866">                ret = CanonGraph08( num_atoms, num_atoms, num_max, 1 /* digraph?? was 0 */, NeighList[TAUT_NON], (Partition *)pBCN-&gt;pRankStack,</a>
<a name="ln4867">                                  nSymmRankFixHIso,  nCanonRankFixHIso, nAtomNumberCanonFixHIso, pCD+iOther, pCC, &amp;Ct_FixH, &amp;Ct_FixHIso );</a>
<a name="ln4868">                if ( ret &lt; 0 ) {</a>
<a name="ln4869">                    goto exit_error;</a>
<a name="ln4870">                }</a>
<a name="ln4871">                /* in case of non-tautomeric structure the final results are in:</a>
<a name="ln4872"> </a>
<a name="ln4873">                           nSymmRankFixHIso</a>
<a name="ln4874">                           nCanonRankFixHIso</a>
<a name="ln4875">                           nAtomNumberCanonFixHIso</a>
<a name="ln4876">                           Ct_FixHIso</a>
<a name="ln4877">                           iso_sort_keyBase     ([0..num_atoms] original isotopic atom positions)</a>
<a name="ln4878">                           iso_sort_key_Hfixed  (original fixed tautomeric H distribution)</a>
<a name="ln4879">                */</a>
<a name="ln4880">            } else {</a>
<a name="ln4881">                /* copy the results of the previous (no taut H) canonicalization */</a>
<a name="ln4882">                /* in this case numHNoTautH[] is not needed for the next canonicalization(s) */</a>
<a name="ln4883">                if ( (Ct_Temp = (ConTable *)inchi_calloc( 1, sizeof( *Ct_Temp ) ) ) &amp;&amp;</a>
<a name="ln4884">                     CTableCreate( Ct_Temp, num_atoms, pCD+iOther) ) {</a>
<a name="ln4885">                    CtFullCopy( Ct_Temp, Ct_FixH );</a>
<a name="ln4886">                    /* since Ct_FixH does not have Ct_FixH-&gt;iso_sort_key and Ct_FixH-&gt;iso_sort_key_Hfixed we</a>
<a name="ln4887">                       have to fill out Ct_Temp-&gt;iso_sort_key and Ct_Temp-&gt;iso_sort_key_Hfixed separately */</a>
<a name="ln4888">                    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4889">                        Ct_Temp-&gt;iso_sort_key[nCanonRankFixH[i]-1]        = iso_sort_key_NoTautH[i];</a>
<a name="ln4890">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln4891">                        Ct_Temp-&gt;iso_sort_key_Hfixed[nCanonRankFixH[i]-1] = iso_sort_key_Hfixed[i];</a>
<a name="ln4892">#endif</a>
<a name="ln4893">                    }</a>
<a name="ln4894">                    Ct_Temp-&gt;len_iso_sort_key        = num_atoms;</a>
<a name="ln4895">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln4896">                    Ct_Temp-&gt;len_iso_sort_key_Hfixed = num_atoms;</a>
<a name="ln4897">#endif</a>
<a name="ln4898">                    /*Ct_Temp-&gt;lenNumH = num_atoms;*/</a>
<a name="ln4899">                } else {</a>
<a name="ln4900">                    goto exit_error_alloc;</a>
<a name="ln4901">                }</a>
<a name="ln4902">                Ct_FixHIso = Ct_Temp;</a>
<a name="ln4903">                Ct_Temp    = NULL;</a>
<a name="ln4904">                memcpy( nSymmRankFixHIso,  nSymmRankFixH, num_atoms*sizeof(nSymmRankFixHIso[0]) );</a>
<a name="ln4905">                memcpy( nCanonRankFixHIso, nCanonRankFixH, num_atoms*sizeof(nCanonRankFixHIso[0]) );</a>
<a name="ln4906">                memcpy( nAtomNumberCanonFixHIso, nAtomNumberCanonFixH, num_atoms*sizeof(nAtomNumberCanonFixHIso[0]) );</a>
<a name="ln4907">            }</a>
<a name="ln4908">            /* in case of non-tautomeric component this is the final result */</a>
<a name="ln4909">            /* i = CtFullCompare( Ct_NoTautHIso, Ct_Temp, num_atoms, 0, 0 );*/</a>
<a name="ln4910">        }</a>
<a name="ln4911">    } /* &quot;fixed H&quot; canonical numbering */</a>
<a name="ln4912"> </a>
<a name="ln4913">    /* consistency check: compare canonical connection tables, H-atoms, isotopic H &amp; taut groups */</a>
<a name="ln4914">    ret = 0;</a>
<a name="ln4915">    ret |= (Ct_NoH-&gt;lenCt != Ct_NoTautH-&gt;lenCt) || memcmp(Ct_NoH-&gt;Ctbl, Ct_NoTautH-&gt;Ctbl, Ct_NoH-&gt;lenCt * sizeof(Ct_NoH-&gt;Ctbl[0]));</a>
<a name="ln4916">    if ( bReqTaut ) {</a>
<a name="ln4917">    if ( Ct_FixH ) {</a>
<a name="ln4918">    ret |= (Ct_NoTautH-&gt;lenCt != Ct_FixH-&gt;lenCt) || memcmp(Ct_NoTautH-&gt;Ctbl, Ct_FixH-&gt;Ctbl, Ct_NoTautH-&gt;lenCt * sizeof(Ct_NoTautH-&gt;Ctbl[0]));</a>
<a name="ln4919">    ret |= (Ct_NoTautH-&gt;lenNumH != Ct_FixH-&gt;lenNumH) || memcmp( Ct_NoTautH-&gt;NumH, Ct_FixH-&gt;NumH, Ct_NoTautH-&gt;lenNumH*sizeof(Ct_Base-&gt;NumH[0]));</a>
<a name="ln4920">    }</a>
<a name="ln4921">    ret |= (Ct_NoTautH-&gt;lenCt &gt; Ct_Base-&gt;lenCt) || memcmp(Ct_NoTautH-&gt;Ctbl, Ct_Base-&gt;Ctbl, Ct_NoTautH-&gt;lenCt * sizeof(Ct_NoTautH-&gt;Ctbl[0]));</a>
<a name="ln4922">    ret |= (Ct_NoTautH-&gt;lenNumH &gt; Ct_Base-&gt;lenNumH) || memcmp( Ct_NoTautH-&gt;NumH, Ct_Base-&gt;NumH, Ct_NoTautH-&gt;lenNumH*sizeof(Ct_Base-&gt;NumH[0]));</a>
<a name="ln4923">    }</a>
<a name="ln4924"> </a>
<a name="ln4925">    /* isotopic canonicalization */</a>
<a name="ln4926">    if ( Ct_NoTautHIso ) {</a>
<a name="ln4927">    ret |= (Ct_NoH-&gt;lenCt != Ct_NoTautHIso-&gt;lenCt) || memcmp(Ct_NoH-&gt;Ctbl, Ct_NoTautHIso-&gt;Ctbl, Ct_NoH-&gt;lenCt * sizeof(Ct_NoH-&gt;Ctbl[0]));</a>
<a name="ln4928">    ret |= (Ct_NoTautH-&gt;lenNumH != Ct_NoTautHIso-&gt;lenNumH) || memcmp( Ct_NoTautH-&gt;NumH, Ct_NoTautHIso-&gt;NumH, Ct_NoTautH-&gt;lenNumH*sizeof(Ct_Base-&gt;NumH[0]));</a>
<a name="ln4929">    } else</a>
<a name="ln4930">    if ( Ct_BaseIso ) {</a>
<a name="ln4931">    ret |= (Ct_BaseIso-&gt;lenCt != Ct_Base-&gt;lenCt) || memcmp(Ct_BaseIso-&gt;Ctbl, Ct_Base-&gt;Ctbl, Ct_BaseIso-&gt;lenCt * sizeof(Ct_BaseIso-&gt;Ctbl[0]));</a>
<a name="ln4932">    ret |= (Ct_BaseIso-&gt;lenNumH != Ct_Base-&gt;lenNumH) || memcmp( Ct_BaseIso-&gt;NumH, Ct_Base-&gt;NumH, Ct_BaseIso-&gt;lenNumH*sizeof(Ct_BaseIso-&gt;NumH[0]));</a>
<a name="ln4933">    if ( Ct_FixHIso ) {</a>
<a name="ln4934">    ret |= (Ct_FixHIso-&gt;lenCt &gt; Ct_BaseIso-&gt;lenCt) || memcmp(Ct_FixHIso-&gt;Ctbl, Ct_BaseIso-&gt;Ctbl, Ct_FixHIso-&gt;lenCt * sizeof(Ct_FixHIso-&gt;Ctbl[0]));</a>
<a name="ln4935">    ret |= (Ct_FixHIso-&gt;lenNumH &gt; Ct_BaseIso-&gt;lenNumH) || memcmp( Ct_FixHIso-&gt;NumH, Ct_BaseIso-&gt;NumH, Ct_FixHIso-&gt;lenNumH*sizeof(Ct_BaseIso-&gt;NumH[0]));</a>
<a name="ln4936">    }</a>
<a name="ln4937">    }</a>
<a name="ln4938"> </a>
<a name="ln4939">    if ( ret ) {</a>
<a name="ln4940">        goto exit_error;</a>
<a name="ln4941">    }</a>
<a name="ln4942"> </a>
<a name="ln4943">    if ( bReqTaut ) {</a>
<a name="ln4944">        /* restore save &quot;process isotopic&quot; mark; temporarily set it to NO */</a>
<a name="ln4945">        t_group_info-&gt;bIgnoreIsotopic = bTautIgnoreIsotopic;</a>
<a name="ln4946">    }</a>
<a name="ln4947"> </a>
<a name="ln4948"> </a>
<a name="ln4949">    /* output the canonicalization results */</a>
<a name="ln4950">    pBCN-&gt;num_max          = num_max;</a>
<a name="ln4951">    pBCN-&gt;num_at_tg        = num_at_tg;</a>
<a name="ln4952">    pBCN-&gt;num_atoms        = num_atoms;</a>
<a name="ln4953"> </a>
<a name="ln4954">    pBCN-&gt;ftcn[TAUT_NON].NeighList          = NeighList[TAUT_NON]; NeighList[TAUT_NON] = NULL;</a>
<a name="ln4955">    pBCN-&gt;ftcn[TAUT_YES].NeighList          = NeighList[TAUT_YES]; NeighList[TAUT_YES] = NULL;</a>
<a name="ln4956"> </a>
<a name="ln4957">    if ( bReqTaut ) {  /* tautomeric results */</a>
<a name="ln4958">        /* base tautomeric structure, iBase = TAUT_YES */</a>
<a name="ln4959">    </a>
<a name="ln4960">        pBCN-&gt;ftcn[TAUT_YES].num_at_tg          = num_at_tg;</a>
<a name="ln4961">        pBCN-&gt;ftcn[TAUT_YES].num_atoms          = num_atoms;</a>
<a name="ln4962">                                               </a>
<a name="ln4963">        pBCN-&gt;ftcn[TAUT_YES].LinearCt           = Ct_Base-&gt;Ctbl;            Ct_Base-&gt;Ctbl        = NULL;</a>
<a name="ln4964">        pBCN-&gt;ftcn[TAUT_YES].nLenLinearCtAtOnly = s[iBase].nLenCTAtOnly;</a>
<a name="ln4965">        pBCN-&gt;ftcn[TAUT_YES].nMaxLenLinearCt    = s[iBase].nLenCT+1;</a>
<a name="ln4966">        pBCN-&gt;ftcn[TAUT_YES].nLenLinearCt       = s[iBase].nLenCT;</a>
<a name="ln4967">    </a>
<a name="ln4968">        pBCN-&gt;ftcn[TAUT_YES].PartitionCt.Rank     = nCanonRankBase;        nCanonRankBase       = NULL;</a>
<a name="ln4969">        pBCN-&gt;ftcn[TAUT_YES].PartitionCt.AtNumber = nAtomNumberCanonBase;  nAtomNumberCanonBase = NULL;                     </a>
<a name="ln4970">        pBCN-&gt;ftcn[TAUT_YES].nSymmRankCt          = nSymmRankBase;         nSymmRankBase        = NULL;</a>
<a name="ln4971"> </a>
<a name="ln4972">        pBCN-&gt;ftcn[TAUT_YES].nNumHOrig          = numH;                 numH          = NULL;</a>
<a name="ln4973">        pBCN-&gt;ftcn[TAUT_YES].nNumH              = Ct_Base-&gt;NumH;        Ct_Base-&gt;NumH = NULL;</a>
<a name="ln4974">        pBCN-&gt;ftcn[TAUT_YES].nLenNumH           = inchi_min(maxlenNumH, Ct_Base-&gt;maxlenNumH);</a>
<a name="ln4975"> </a>
<a name="ln4976">        /* fixed H structure: exists only if the structure is tautomeric */</a>
<a name="ln4977">        pBCN-&gt;ftcn[TAUT_YES].nNumHOrigFixH      = NULL;</a>
<a name="ln4978">        pBCN-&gt;ftcn[TAUT_YES].nNumHFixH          = NULL;</a>
<a name="ln4979">        pBCN-&gt;ftcn[TAUT_YES].nLenNumHFixH       = 0;</a>
<a name="ln4980">        pBCN-&gt;ftcn[TAUT_YES].nCanonFlags       |= pCD[iBase].nCanonFlags;</a>
<a name="ln4981">        </a>
<a name="ln4982">        CleanNumH( pBCN-&gt;ftcn[TAUT_YES].nNumHOrig, pBCN-&gt;ftcn[TAUT_YES].nLenNumH );</a>
<a name="ln4983">        CleanNumH( pBCN-&gt;ftcn[TAUT_YES].nNumH,     pBCN-&gt;ftcn[TAUT_YES].nLenNumH );</a>
<a name="ln4984">        CleanCt  ( pBCN-&gt;ftcn[TAUT_YES].LinearCt,  pBCN-&gt;ftcn[TAUT_YES].nLenLinearCt );</a>
<a name="ln4985"> </a>
<a name="ln4986">        /* isotopic canonicalization */</a>
<a name="ln4987">        if ( Ct_BaseIso ) {</a>
<a name="ln4988">            pBCN-&gt;ftcn[TAUT_YES].PartitionCtIso.Rank     = nCanonRankBaseIso;           nCanonRankBaseIso           = NULL;</a>
<a name="ln4989">            pBCN-&gt;ftcn[TAUT_YES].PartitionCtIso.AtNumber = nAtomNumberCanonBaseIso;     nAtomNumberCanonBaseIso     = NULL;</a>
<a name="ln4990">            pBCN-&gt;ftcn[TAUT_YES].nSymmRankCtIso          = nSymmRankBaseIso;            nSymmRankBaseIso            = NULL;</a>
<a name="ln4991">            pBCN-&gt;ftcn[TAUT_YES].iso_sort_keys           = Ct_BaseIso-&gt;iso_sort_key;    Ct_BaseIso-&gt;iso_sort_key    = NULL;</a>
<a name="ln4992">            pBCN-&gt;ftcn[TAUT_YES].iso_sort_keysOrig       = iso_sort_keyBase;            iso_sort_keyBase            = NULL;</a>
<a name="ln4993">            pBCN-&gt;ftcn[TAUT_YES].len_iso_sort_keys       = len_iso_sort_keyBase;</a>
<a name="ln4994">            pBCN-&gt;ftcn[TAUT_YES].iso_exchg_atnos         = Ct_BaseIso-&gt;iso_exchg_atnos; Ct_BaseIso-&gt;iso_exchg_atnos = NULL;</a>
<a name="ln4995">            pBCN-&gt;ftcn[TAUT_YES].iso_exchg_atnosOrig     = iso_exchg_atnos;             iso_exchg_atnos             = NULL;</a>
<a name="ln4996"> </a>
<a name="ln4997">            CleanIsoSortKeys( pBCN-&gt;ftcn[TAUT_YES].iso_sort_keys, pBCN-&gt;ftcn[TAUT_YES].len_iso_sort_keys );</a>
<a name="ln4998">            CleanIsoSortKeys( pBCN-&gt;ftcn[TAUT_YES].iso_sort_keysOrig, pBCN-&gt;ftcn[TAUT_YES].len_iso_sort_keys );</a>
<a name="ln4999">        }</a>
<a name="ln5000"> </a>
<a name="ln5001">    } /* tautomeric results */</a>
<a name="ln5002"> </a>
<a name="ln5003">    if ( bReqNonTaut  ) { /* non-tautomeric results */</a>
<a name="ln5004">        /* TAUT_NON if tautomeric + non-tautomeric or special non-taut request</a>
<a name="ln5005">           TAUT_YES if the structure happened to be non-tautomeric while user requested tautomeric processing</a>
<a name="ln5006">           In both cases the correct index is iOther. TAUT_NON replaced with iOther 4-2-2004 */</a>
<a name="ln5007">    </a>
<a name="ln5008">        if ( !bReqTaut ) {</a>
<a name="ln5009">            /* rearrange the results for a non-tautomeric structure */</a>
<a name="ln5010">            nSymmRankFixH           = nSymmRankNoTautH;           nSymmRankNoTautH        = NULL;</a>
<a name="ln5011">            nCanonRankFixH          = nCanonRankNoTautH;          nCanonRankNoTautH       = NULL;</a>
<a name="ln5012">            nAtomNumberCanonFixH    = nAtomNumberCanonNoTautH;    nAtomNumberCanonNoTautH = NULL;</a>
<a name="ln5013">            Ct_FixH                 = Ct_NoTautH;                 Ct_NoTautH              = NULL;</a>
<a name="ln5014">            /* isotopic canonicalization */</a>
<a name="ln5015">            nSymmRankFixHIso        = nSymmRankNoTautHIso;        nSymmRankNoTautHIso        = NULL;</a>
<a name="ln5016">            nCanonRankFixHIso       = nCanonRankNoTautHIso;       nCanonRankNoTautHIso       = NULL;</a>
<a name="ln5017">            nAtomNumberCanonFixHIso = nAtomNumberCanonNoTautHIso; nAtomNumberCanonNoTautHIso = NULL;</a>
<a name="ln5018">            Ct_FixHIso              = Ct_NoTautHIso;              Ct_NoTautHIso              = NULL;</a>
<a name="ln5019"> </a>
<a name="ln5020">            if ( iOther == TAUT_YES &amp;&amp; pBCN-&gt;ftcn[TAUT_NON].NeighList &amp;&amp; !pBCN-&gt;ftcn[TAUT_YES].NeighList ) {</a>
<a name="ln5021">                /* here only non-taut results go to pBCN-&gt;ftcn[TAUT_YES]</a>
<a name="ln5022">                   Since non-taut NeighList is always in pBCN-&gt;ftcn[TAUT_NON].NeighList, move it to</a>
<a name="ln5023">                   pBCN-&gt;ftcn[TAUT_YES].NeighList. 2004-04-02.</a>
<a name="ln5024">                */</a>
<a name="ln5025">                pBCN-&gt;ftcn[TAUT_YES].NeighList = pBCN-&gt;ftcn[TAUT_NON].NeighList;</a>
<a name="ln5026">                pBCN-&gt;ftcn[TAUT_NON].NeighList = NULL;</a>
<a name="ln5027">            }</a>
<a name="ln5028">        }</a>
<a name="ln5029">        pBCN-&gt;ftcn[iOther].num_at_tg          = num_atoms;</a>
<a name="ln5030">        pBCN-&gt;ftcn[iOther].num_atoms          = num_atoms;</a>
<a name="ln5031">    </a>
<a name="ln5032">        pBCN-&gt;ftcn[iOther].LinearCt           = Ct_FixH-&gt;Ctbl;       Ct_FixH-&gt;Ctbl        = NULL;</a>
<a name="ln5033">        pBCN-&gt;ftcn[iOther].nLenLinearCtAtOnly = s[iOther].nLenCTAtOnly;</a>
<a name="ln5034">        pBCN-&gt;ftcn[iOther].nMaxLenLinearCt    = s[iOther].nLenCTAtOnly+1;</a>
<a name="ln5035">        pBCN-&gt;ftcn[iOther].nLenLinearCt       = s[iOther].nLenCTAtOnly;</a>
<a name="ln5036">    </a>
<a name="ln5037">        pBCN-&gt;ftcn[iOther].PartitionCt.Rank      = nCanonRankFixH;        nCanonRankFixH       = NULL;</a>
<a name="ln5038">        pBCN-&gt;ftcn[iOther].PartitionCt.AtNumber  = nAtomNumberCanonFixH;  nAtomNumberCanonFixH = NULL;                     </a>
<a name="ln5039">        pBCN-&gt;ftcn[iOther].nSymmRankCt           = nSymmRankFixH;         nSymmRankFixH        = NULL;</a>
<a name="ln5040"> </a>
<a name="ln5041">        pBCN-&gt;ftcn[iOther].nNumHOrig          = numHNoTautH;              numHNoTautH          = NULL;</a>
<a name="ln5042">        pBCN-&gt;ftcn[iOther].nNumH              = Ct_FixH-&gt;NumH;            Ct_FixH-&gt;NumH        = NULL;</a>
<a name="ln5043">        pBCN-&gt;ftcn[iOther].nLenNumH           = inchi_min(maxlenNumHNoTautH,Ct_FixH-&gt;maxlenNumH);</a>
<a name="ln5044"> </a>
<a name="ln5045">        /* fixed H structure: exists only if the structure is tautomeric */</a>
<a name="ln5046">        pBCN-&gt;ftcn[iOther].nNumHOrigFixH      = NumHfixed;            NumHfixed          = NULL;</a>
<a name="ln5047">        pBCN-&gt;ftcn[iOther].nNumHFixH          = Ct_FixH-&gt;NumHfixed;   Ct_FixH-&gt;NumHfixed = NULL;</a>
<a name="ln5048">        pBCN-&gt;ftcn[iOther].nLenNumHFixH       = num_atoms;</a>
<a name="ln5049">        pBCN-&gt;ftcn[iOther].nCanonFlags       |= pCD[iOther].nCanonFlags;</a>
<a name="ln5050"> </a>
<a name="ln5051">        /* original H */</a>
<a name="ln5052">        CleanNumH( pBCN-&gt;ftcn[iOther].nNumHOrig,     pBCN-&gt;ftcn[iOther].nLenNumH );</a>
<a name="ln5053">        CleanNumH( pBCN-&gt;ftcn[iOther].nNumHOrigFixH, pBCN-&gt;ftcn[iOther].nLenNumH );</a>
<a name="ln5054">        /* canonical H positions */</a>
<a name="ln5055">        CleanNumH( pBCN-&gt;ftcn[iOther].nNumH,     pBCN-&gt;ftcn[iOther].nLenNumH );</a>
<a name="ln5056">        CleanNumH( pBCN-&gt;ftcn[iOther].nNumHFixH, pBCN-&gt;ftcn[iOther].nLenNumH );</a>
<a name="ln5057">        /* connection table */</a>
<a name="ln5058">        CleanCt( pBCN-&gt;ftcn[iOther].LinearCt, pBCN-&gt;ftcn[iOther].nLenLinearCt );</a>
<a name="ln5059"> </a>
<a name="ln5060">       /* isotopic canonicalization */</a>
<a name="ln5061">        if ( Ct_FixHIso ) {</a>
<a name="ln5062">            pBCN-&gt;ftcn[iOther].PartitionCtIso.Rank     = nCanonRankFixHIso;        nCanonRankFixHIso        = NULL;</a>
<a name="ln5063">            pBCN-&gt;ftcn[iOther].PartitionCtIso.AtNumber = nAtomNumberCanonFixHIso;  nAtomNumberCanonFixHIso  = NULL;</a>
<a name="ln5064">            pBCN-&gt;ftcn[iOther].nSymmRankCtIso          = nSymmRankFixHIso;         nSymmRankFixHIso         = NULL;</a>
<a name="ln5065">            pBCN-&gt;ftcn[iOther].iso_sort_keys           = Ct_FixHIso-&gt;iso_sort_key; Ct_FixHIso-&gt;iso_sort_key = NULL;</a>
<a name="ln5066">            pBCN-&gt;ftcn[iOther].iso_sort_keysOrig       = iso_sort_key_NoTautH;     iso_sort_key_NoTautH     = NULL;</a>
<a name="ln5067">            pBCN-&gt;ftcn[iOther].len_iso_sort_keys       = len_iso_sort_key_NoTautH;</a>
<a name="ln5068">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln5069">            MergeCleanIsoSortKeys( pBCN-&gt;ftcn[iOther].iso_sort_keys, Ct_FixHIso-&gt;iso_sort_key_Hfixed, pBCN-&gt;ftcn[iOther].len_iso_sort_keys );</a>
<a name="ln5070">            MergeCleanIsoSortKeys( pBCN-&gt;ftcn[iOther].iso_sort_keysOrig, iso_sort_key_Hfixed, pBCN-&gt;ftcn[iOther].len_iso_sort_keys );</a>
<a name="ln5071">#else</a>
<a name="ln5072">            CleanIsoSortKeys( pBCN-&gt;ftcn[iOther].iso_sort_keys, pBCN-&gt;ftcn[iOther].len_iso_sort_keys );</a>
<a name="ln5073">            CleanIsoSortKeys( pBCN-&gt;ftcn[iOther].iso_sort_keysOrig, pBCN-&gt;ftcn[iOther].len_iso_sort_keys );</a>
<a name="ln5074">#endif</a>
<a name="ln5075">        }</a>
<a name="ln5076"> </a>
<a name="ln5077">    }  /* non-tautomeric results */</a>
<a name="ln5078">    goto exit_function;</a>
<a name="ln5079"> </a>
<a name="ln5080">exit_error_alloc:</a>
<a name="ln5081">    ret = CT_OUT_OF_RAM;</a>
<a name="ln5082">    goto exit_function;</a>
<a name="ln5083"> </a>
<a name="ln5084">exit_error:</a>
<a name="ln5085">    if ( !RETURNED_ERROR(ret) ) {</a>
<a name="ln5086">        ret = CT_CANON_ERR;</a>
<a name="ln5087">    }</a>
<a name="ln5088">    goto exit_function;</a>
<a name="ln5089"> </a>
<a name="ln5090">exit_function:    </a>
<a name="ln5091"> </a>
<a name="ln5092">#define FREE_CONTABLE(X) if (X) {CTableFree(X);inchi_free(X);}</a>
<a name="ln5093">#define FREE_ARRAY(X) if (X) inchi_free(X);</a>
<a name="ln5094"> </a>
<a name="ln5095">    FreeNeighList( NeighList[TAUT_NON] );</a>
<a name="ln5096">    FreeNeighList( NeighList[TAUT_YES] );</a>
<a name="ln5097"> </a>
<a name="ln5098">    FREE_CONTABLE( Ct_NoH )</a>
<a name="ln5099">    FREE_CONTABLE( Ct_NoTautH )</a>
<a name="ln5100">    FREE_CONTABLE( Ct_Base )</a>
<a name="ln5101">    FREE_CONTABLE( Ct_FixH )</a>
<a name="ln5102">    FREE_CONTABLE( Ct_Temp )</a>
<a name="ln5103">    /* isotopic canonicalization */</a>
<a name="ln5104">    FREE_CONTABLE( Ct_NoTautHIso )</a>
<a name="ln5105">    FREE_CONTABLE( Ct_BaseIso )</a>
<a name="ln5106">    FREE_CONTABLE( Ct_FixHIso )</a>
<a name="ln5107">    </a>
<a name="ln5108">    /* free the first two pointers from pBCN-&gt;pRankStack */</a>
<a name="ln5109">    FREE_ARRAY( nRank )</a>
<a name="ln5110">    FREE_ARRAY( nAtomNumber )</a>
<a name="ln5111">    </a>
<a name="ln5112">    if ( pBCN-&gt;pRankStack ) {</a>
<a name="ln5113">        pBCN-&gt;pRankStack[0] =</a>
<a name="ln5114">        pBCN-&gt;pRankStack[1] = NULL;</a>
<a name="ln5115">    }</a>
<a name="ln5116"> </a>
<a name="ln5117">#if ( USE_AUX_RANKING == 1 )</a>
<a name="ln5118">    FREE_ARRAY( nRankAux            )</a>
<a name="ln5119">    FREE_ARRAY( nAtomNumberAux      )</a>
<a name="ln5120">    FREE_ARRAY( pAtomInvariantAux   )</a>
<a name="ln5121">#endif</a>
<a name="ln5122"> </a>
<a name="ln5123">    FREE_ARRAY( pAtomInvariant )</a>
<a name="ln5124">    </a>
<a name="ln5125">    FREE_ARRAY( nCanonRankNoH )</a>
<a name="ln5126">    FREE_ARRAY( nAtomNumberCanonNoH )</a>
<a name="ln5127">    FREE_ARRAY( nSymmRankNoH )</a>
<a name="ln5128">    </a>
<a name="ln5129">    FREE_ARRAY( nSymmRankNoTautH )</a>
<a name="ln5130">    FREE_ARRAY( nCanonRankNoTautH )</a>
<a name="ln5131">    FREE_ARRAY( nAtomNumberCanonNoTautH )</a>
<a name="ln5132">    FREE_ARRAY( numHNoTautH )</a>
<a name="ln5133"> </a>
<a name="ln5134">    FREE_ARRAY( nSymmRankBase )</a>
<a name="ln5135">    FREE_ARRAY( nCanonRankBase )</a>
<a name="ln5136">    FREE_ARRAY( nAtomNumberCanonBase )</a>
<a name="ln5137">    FREE_ARRAY( numH )</a>
<a name="ln5138"> </a>
<a name="ln5139">    FREE_ARRAY( nSymmRankFixH )</a>
<a name="ln5140">    FREE_ARRAY( nCanonRankFixH )</a>
<a name="ln5141">    FREE_ARRAY( nAtomNumberCanonFixH )</a>
<a name="ln5142">    FREE_ARRAY( NumHfixed )</a>
<a name="ln5143"> </a>
<a name="ln5144">    /* isotopic canonicalization */</a>
<a name="ln5145"> </a>
<a name="ln5146">    FREE_ARRAY( nSymmRankNoTautHIso )</a>
<a name="ln5147">    FREE_ARRAY( nCanonRankNoTautHIso )</a>
<a name="ln5148">    FREE_ARRAY( nAtomNumberCanonNoTautHIso )</a>
<a name="ln5149">    FREE_ARRAY( iso_sort_key_NoTautH )</a>
<a name="ln5150"> </a>
<a name="ln5151">    FREE_ARRAY( nSymmRankBaseIso )</a>
<a name="ln5152">    FREE_ARRAY( nCanonRankBaseIso )</a>
<a name="ln5153">    FREE_ARRAY( nAtomNumberCanonBaseIso )</a>
<a name="ln5154">    FREE_ARRAY( iso_sort_keyBase )</a>
<a name="ln5155">    FREE_ARRAY( iso_exchg_atnos )</a>
<a name="ln5156">    </a>
<a name="ln5157">    FREE_ARRAY( nSymmRankFixHIso )</a>
<a name="ln5158">    FREE_ARRAY( nCanonRankFixHIso )</a>
<a name="ln5159">    FREE_ARRAY( nAtomNumberCanonFixHIso )</a>
<a name="ln5160">#if ( USE_ISO_SORT_KEY_HFIXED == 1 )</a>
<a name="ln5161">    FREE_ARRAY( iso_sort_key_Hfixed )</a>
<a name="ln5162">#endif</a>
<a name="ln5163">    </a>
<a name="ln5164">    FREE_ARRAY( nTempRank )</a>
<a name="ln5165"> </a>
<a name="ln5166">#undef FREE_CONTABLE</a>
<a name="ln5167">#undef FREE_ARRAY</a>
<a name="ln5168"> </a>
<a name="ln5169">    return ret;</a>
<a name="ln5170">}</a>

</code></pre>
<div class="balloon" rel="558"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'Ct->nextAtRank'. Check lines: 558, 522.</p></div>
<div class="balloon" rel="559"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'Ct->nextCtblPos'. Check lines: 559, 521.</p></div>
<div class="balloon" rel="559"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'Ct->nextCtblPos' pointer was utilized before it was verified against nullptr. Check lines: 559, 560.</p></div>
<div class="balloon" rel="608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'p->equ2' is always true.</p></div>
<div class="balloon" rel="1631"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1650"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions '(Ct1->len_iso_sort_key)' to the left and to the right of the '<' operator.</p></div>
<div class="balloon" rel="1650"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: (Ct1->len_iso_sort_key).</p></div>
<div class="balloon" rel="1651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions 'Ct1->Ctbl[endCt1] == 0' to the left and to the right of the '||' operator.</p></div>
<div class="balloon" rel="1861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions 'Ct2->Ctbl[endCt1] == 0' to the left and to the right of the '||' operator.</p></div>
<div class="balloon" rel="1862"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: Ct2->Ctbl[endCt1] == 0.</p></div>
<div class="balloon" rel="1870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions '(Ct1->len_iso_sort_key)' to the left and to the right of the '<' operator.</p></div>
<div class="balloon" rel="1870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: (Ct1->len_iso_sort_key).</p></div>
<div class="balloon" rel="1263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'Ct' might take place. The potential null pointer is passed into 'CtPartFill' function. Inspect the fourth argument. Check lines: 1263, 2801, 2760.</p></div>
<div class="balloon" rel="2824"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'v'. Check lines: 2824, 2749.</p></div>
<div class="balloon" rel="2824"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'W'. Check lines: 2824, 2748.</p></div>
<div class="balloon" rel="2825"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'e'. Check lines: 2825, 2750.</p></div>
<div class="balloon" rel="2820"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'k' of loop is always true.</p></div>
<div class="balloon" rel="2863"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'lab' is always true.</p></div>
<div class="balloon" rel="2974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bRhoIsDiscrete.</p></div>
<div class="balloon" rel="3074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v600/" target="_blank">V600</a> Consider inspecting the condition. The 'kLeast_rho_fix' pointer is always not equal to NULL.</p></div>
<div class="balloon" rel="3076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v600/" target="_blank">V600</a> Consider inspecting the condition. The 'kLeast_rho_fix' pointer is always not equal to NULL.</p></div>
<div class="balloon" rel="3076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'kLeast_rho_fix' condition was already verified in line 3074.</p></div>
<div class="balloon" rel="3114"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v600/" target="_blank">V600</a> Consider inspecting the condition. The 'kLeast_rho' pointer is always not equal to NULL.</p></div>
<div class="balloon" rel="3358"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'W' is always true.</p></div>
<div class="balloon" rel="3359"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'v' is always true.</p></div>
<div class="balloon" rel="3360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'e' is always true.</p></div>
<div class="balloon" rel="3361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'qzb' is always true.</p></div>
<div class="balloon" rel="3565"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'Ct[len]' variable was assigned the same value.</p></div>
<div class="balloon" rel="3893"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'len_iso_exchg_atnos' variable was assigned the same value.</p></div>
<div class="balloon" rel="3894"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'maxlen_iso_exchg_atnos' variable was assigned the same value.</p></div>
<div class="balloon" rel="3968"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pBCN->nMaxLenRankStack' variable was assigned the same value.</p></div>
<div class="balloon" rel="4159"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'num_iso_NoTautH' variable was assigned the same value.</p></div>
<div class="balloon" rel="4443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'num_iso_Base' variable was assigned the same value.</p></div>
<div class="balloon" rel="4467"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: iso_sort_keyBase.</p></div>
<div class="balloon" rel="4648"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'lenNumHNoTautH' variable was assigned the same value.</p></div>
<div class="balloon" rel="4661"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!nRankAux' is always false.</p></div>
<div class="balloon" rel="4663"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!nAtomNumberAux' is always false.</p></div>
<div class="balloon" rel="4665"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!pAtomInvariantAux' is always false.</p></div>
<div class="balloon" rel="4668"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !nRankAux.</p></div>
<div class="balloon" rel="4668"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !nAtomNumberAux.</p></div>
<div class="balloon" rel="4669"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !pAtomInvariantAux.</p></div>
<div class="balloon" rel="4794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'lenNumHNoTautH' variable was assigned the same value.</p></div>
<div class="balloon" rel="4950"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pBCN->num_max' variable was assigned the same value.</p></div>
<div class="balloon" rel="4951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pBCN->num_at_tg' variable was assigned the same value.</p></div>
<div class="balloon" rel="4952"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pBCN->num_atoms' variable was assigned the same value.</p></div>
<div class="balloon" rel="5020"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pBCN->ftcn[0].NeighList.</p></div>
<div class="balloon" rel="3893"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'len_iso_exchg_atnos' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 3891, 3893.</p></div>
<div class="balloon" rel="3894"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'maxlen_iso_exchg_atnos' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 3892, 3894.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichirvr4.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">/*^^^ */</a>
<a name="ln45">/*#define CHECK_WIN32_VC_HEAP*/</a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;ichi.h&quot;</a>
<a name="ln51">#include &quot;ichitime.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;inpdef.h&quot;</a>
<a name="ln54">#include &quot;ichimain.h&quot;</a>
<a name="ln55">#include &quot;ichierr.h&quot;</a>
<a name="ln56">#include &quot;incomdef.h&quot; </a>
<a name="ln57">#include &quot;ichiring.h&quot;</a>
<a name="ln58">#include &quot;extr_ct.h&quot;</a>
<a name="ln59">#include &quot;ichitaut.h&quot;</a>
<a name="ln60">#include &quot;ichinorm.h&quot;</a>
<a name="ln61">#include &quot;util.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;ichicomp.h&quot;</a>
<a name="ln64">#include &quot;ichister.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;ichi_bns.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;strutil.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">#include &quot;ichirvrs.h&quot;</a>
<a name="ln71">/*^^^ */</a>
<a name="ln72"> </a>
<a name="ln73">/********************** Forbid carbon charge edges ***********************************/</a>
<a name="ln74">int ForbidCarbonChargeEdges( BN_STRUCT *pBNS, ALL_TC_GROUPS *pTCGroups, EDGE_LIST *pCarbonChargeEdges, int forbidden_edge_mask  )</a>
<a name="ln75">{</a>
<a name="ln76">#define MAX_NUM_CARBON_CHARGE_EDGES 2</a>
<a name="ln77">    int nType, i, k, ret;</a>
<a name="ln78">    BNS_EDGE   *pEdge;</a>
<a name="ln79">    if ( (ret = AllocEdgeList( pCarbonChargeEdges, MAX_NUM_CARBON_CHARGE_EDGES )) ) {</a>
<a name="ln80">        goto exit_function;</a>
<a name="ln81">    }</a>
<a name="ln82">    pCarbonChargeEdges-&gt;num_edges = 0;</a>
<a name="ln83">    for ( i = 0; i &lt; MAX_NUM_CARBON_CHARGE_EDGES; i ++ ) {</a>
<a name="ln84">        switch( i ) {</a>
<a name="ln85">        case 0:</a>
<a name="ln86">            nType = TCG_Plus_C0;</a>
<a name="ln87">            break;</a>
<a name="ln88">        case 1:</a>
<a name="ln89">            nType = TCG_Minus_C0;</a>
<a name="ln90">            break;</a>
<a name="ln91">        default:</a>
<a name="ln92">            ret = RI_ERR_PROGR;</a>
<a name="ln93">            goto exit_function;</a>
<a name="ln94">        }</a>
<a name="ln95">        if ( (k = pTCGroups-&gt;nGroup[nType]) &gt;= 0 ) {</a>
<a name="ln96">            k = pTCGroups-&gt;pTCG[k].nForwardEdge;</a>
<a name="ln97">            if ( k &gt; 0 ) {</a>
<a name="ln98">                pEdge = pBNS-&gt;edge + k;</a>
<a name="ln99">                if ( !(pEdge-&gt;forbidden &amp; forbidden_edge_mask) ) {</a>
<a name="ln100">                    pEdge-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln101">                    if ( (ret = AddToEdgeList( pCarbonChargeEdges, k, 0 )) ) {</a>
<a name="ln102">                        goto exit_function;</a>
<a name="ln103">                    }</a>
<a name="ln104">                }</a>
<a name="ln105">            } else {</a>
<a name="ln106">                ret = RI_ERR_PROGR;</a>
<a name="ln107">                goto exit_function;</a>
<a name="ln108">            }</a>
<a name="ln109">        }</a>
<a name="ln110">    }</a>
<a name="ln111">    ret = pCarbonChargeEdges-&gt;num_edges;</a>
<a name="ln112">exit_function:</a>
<a name="ln113">    return ret;</a>
<a name="ln114">#undef MAX_NUM_CARBON_CHARGE_EDGES</a>
<a name="ln115">}</a>
<a name="ln116">/******************************************************************************************************/</a>
<a name="ln117">int ForbidNintrogenPlus2BondsInSmallRings( BN_STRUCT *pBNS, inp_ATOM *at, int num_at,</a>
<a name="ln118">                                           VAL_AT *pVA, int min_ring_size, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln119">                                           EDGE_LIST *pNplus2BondsEdges, int forbidden_edge_mask  )</a>
<a name="ln120">{</a>
<a name="ln121">    int i, j, ret;</a>
<a name="ln122">    BNS_EDGE   *e;</a>
<a name="ln123"> </a>
<a name="ln124">    ret = 0;</a>
<a name="ln125">        /* --- forbid edges that allow to make =N(+)= or #N(+)- in small ring */</a>
<a name="ln126">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln127">        if ( at[i].valence == 2 &amp;&amp;</a>
<a name="ln128">             !at[i].num_H &amp;&amp; !at[i].endpoint &amp;&amp;</a>
<a name="ln129">             pVA[i].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln130">             pVA[i].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln131">             !pVA[i].cMaxFlowToMetal &amp;&amp; pVA[i].nCPlusGroupEdge &gt; 0 &amp;&amp;</a>
<a name="ln132">             pVA[i].cnListIndex &gt; 0 &amp;&amp; cnList[pVA[i].cnListIndex-1].bits == cn_bits_MNP &amp;&amp;</a>
<a name="ln133">             pVA[i].cMinRingSize &amp;&amp; pVA[i].cMinRingSize &lt;= min_ring_size ) {</a>
<a name="ln134"> </a>
<a name="ln135">            e = pBNS-&gt;edge + (j = pVA[i].nCPlusGroupEdge - 1);</a>
<a name="ln136">            if ( !(e-&gt;forbidden &amp; forbidden_edge_mask) ) {</a>
<a name="ln137">                e-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln138">                if ( (ret = AddToEdgeList( pNplus2BondsEdges, j, 128 )) ) {</a>
<a name="ln139">                    goto exit_function;</a>
<a name="ln140">                }</a>
<a name="ln141">            }</a>
<a name="ln142">        }</a>
<a name="ln143">    }</a>
<a name="ln144">    ret = 0;</a>
<a name="ln145">exit_function:</a>
<a name="ln146">    return ret;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">/*************************************************************************************************</a>
<a name="ln150">Problem: Formula in InChI from the reversed structure has less H than in the input InChI</a>
<a name="ln151">Solutions:</a>
<a name="ln152"> </a>
<a name="ln153">(a)   |                        |                 </a>
<a name="ln154">     -B(-)-NH-=..-=N(+)&lt;   =&gt; -B(-)-NH(+)=-..=-N&lt;  (H is not removed from the ion pair)</a>
<a name="ln155">      |                        |                 </a>
<a name="ln156"> </a>
<a name="ln157">                  |                      |   </a>
<a name="ln158">(b)  &gt;N(+)=-=...-=N-NH     =&gt;  &gt;N-=-...=-N(+)-NH  (charge from onium cannot be moved to remove H+)</a>
<a name="ln159">                  |                      |   </a>
<a name="ln160">*************************************************************************************************/</a>
<a name="ln161">int FixLessHydrogenInFormula( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct, inp_ATOM *at,</a>
<a name="ln162">                              inp_ATOM *at2, inp_ATOM *atf, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln163">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask )</a>
<a name="ln164">{</a>
<a name="ln165">    int iBPlus=NO_VERTEX, iNV=NO_VERTEX, iNH = NO_VERTEX, neigh;</a>
<a name="ln166">    EDGE_LIST NewlyFixedEdges;</a>
<a name="ln167">    int ret, i, j;</a>
<a name="ln168">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln169">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln170">    /* for RunBnsTestOnce */</a>
<a name="ln171">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln172">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln173"> </a>
<a name="ln174">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln175">    if ( (ret = AllocEdgeList( &amp;NewlyFixedEdges, 2*num_at )) ) {</a>
<a name="ln176">        goto exit_function;</a>
<a name="ln177">    }</a>
<a name="ln178">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln179">        if ( (j = pVA[i].nCMinusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln180">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, j, 0 )) ) {</a>
<a name="ln181">                goto exit_function;</a>
<a name="ln182">            }</a>
<a name="ln183">            pBNS-&gt;edge[j].forbidden |= forbidden_edge_mask;</a>
<a name="ln184">        }</a>
<a name="ln185">        if ( (j = pVA[i].nCPlusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln186">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, j, 0 )) ) {</a>
<a name="ln187">                goto exit_function;</a>
<a name="ln188">            }</a>
<a name="ln189">            pBNS-&gt;edge[j].forbidden |= forbidden_edge_mask;</a>
<a name="ln190">        }</a>
<a name="ln191">    }</a>
<a name="ln192">    /* extra H has been removed; check non-tautomeric atoms */</a>
<a name="ln193">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln194">        if ( !at2[i].endpoint &amp;&amp; !pVA[i].cMetal &amp;&amp;</a>
<a name="ln195">              pVA[i].cNumValenceElectrons == 5 &amp;&amp; pVA[i].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln196">             at2[i].num_H == atf[i].num_H + 1) {</a>
<a name="ln197">            /* H was removed from N */</a>
<a name="ln198">            iNH = i;</a>
<a name="ln199">            break;</a>
<a name="ln200">        }</a>
<a name="ln201">    }</a>
<a name="ln202">    if ( 0 &lt;= iNH &amp;&amp; iNH &lt; num_at ) {</a>
<a name="ln203">        /* check neighbors for  |                 |</a>
<a name="ln204">                          (a)  -B(+)-  or  (b)   =N-</a>
<a name="ln205">                                |                 |</a>
<a name="ln206">        */</a>
<a name="ln207">        for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln208">            neigh = at2[iNH].neighbor[j];</a>
<a name="ln209">            if ( at2[neigh].valence == 4 ) {</a>
<a name="ln210">                if ( at2[neigh].charge == -1 &amp;&amp; at2[neigh].chem_bonds_valence == 4 &amp;&amp;</a>
<a name="ln211">                     !at2[neigh].radical &amp;&amp; !at[neigh].num_H ) {</a>
<a name="ln212">                    iBPlus = neigh;</a>
<a name="ln213">                }</a>
<a name="ln214">            }</a>
<a name="ln215">        }</a>
<a name="ln216">    }</a>
<a name="ln217">    if ( 0 &lt;= iNH &amp;&amp; iNH &lt; num_at ) {</a>
<a name="ln218">        int bond_type_at2;</a>
<a name="ln219">        int bond_type_atf;</a>
<a name="ln220">        int num_bonds_in_path = 0;</a>
<a name="ln221">        int delta = -1, nxt = iNH, prv = NO_VERTEX, nxt_is_NPlus;</a>
<a name="ln222">        /* the changed bond to the dehydrogenated atom H should have greater order */</a>
<a name="ln223">        /* delta = (new bond order in atf[]) - (restored bond order in at2[]) */</a>
<a name="ln224">        nxt_is_NPlus = 0;</a>
<a name="ln225">        do {</a>
<a name="ln226">            i = nxt;</a>
<a name="ln227">            nxt = NO_VERTEX;</a>
<a name="ln228">            delta = -delta;</a>
<a name="ln229">            for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln230">                bond_type_at2 = at2[i].bond_type[j] &amp; BOND_TYPE_MASK; /* restored bond */</a>
<a name="ln231">                bond_type_atf = atf[i].bond_type[j] &amp; BOND_TYPE_MASK; /* normalized bond */</a>
<a name="ln232">                nxt_is_NPlus  = 0;</a>
<a name="ln233">                if ( (bond_type_atf - bond_type_at2 == delta || bond_type_atf == BOND_ALT12NS) &amp;&amp;</a>
<a name="ln234">                     BOND_TYPE_SINGLE &lt;= bond_type_at2 + delta &amp;&amp; bond_type_at2 + delta &lt;= BOND_TYPE_TRIPLE &amp;&amp;</a>
<a name="ln235">                     !at2[(int)at2[i].neighbor[j]].cFlags ) {</a>
<a name="ln236">                    prv = i;</a>
<a name="ln237">                    nxt = at2[i].neighbor[j];</a>
<a name="ln238">                    nxt_is_NPlus = at2[nxt].charge == 1 &amp;&amp; atf[nxt].charge == 0 &amp;&amp;</a>
<a name="ln239">                                   pVA[nxt].cNumValenceElectrons == 5 &amp;&amp; pVA[nxt].cPeriodicRowNumber == 1;</a>
<a name="ln240">                    at2[i].cFlags |= 1;  /* avoid cycling */</a>
<a name="ln241">                    num_bonds_in_path ++;</a>
<a name="ln242">                    if ( delta == -1 &amp;&amp; at2[prv].valence == 4 &amp;&amp; at2[prv].chem_bonds_valence == 5 &amp;&amp;</a>
<a name="ln243">                         !at2[prv].charge &amp;&amp; !at2[prv].radical &amp;&amp; pVA[prv].cNumValenceElectrons == 5 &amp;&amp;</a>
<a name="ln244">                         pVA[prv].nCPlusGroupEdge &gt; 0 ) {</a>
<a name="ln245">                        iNV = prv;</a>
<a name="ln246">                    }</a>
<a name="ln247">                    if ( at2[nxt].charge != atf[nxt].charge ) {</a>
<a name="ln248">                        if ( (at2[nxt].charge == 1 || atf[nxt].charge == 1) &amp;&amp;</a>
<a name="ln249">                              pVA[nxt].nCPlusGroupEdge &gt; 0 ) {</a>
<a name="ln250">                            pBNS-&gt;edge[pVA[nxt].nCPlusGroupEdge-1].forbidden &amp;= inv_forbidden_edge_mask; </a>
<a name="ln251">                        }</a>
<a name="ln252">                        if ( (at2[nxt].charge == -1 || atf[nxt].charge == -1) &amp;&amp;</a>
<a name="ln253">                              pVA[nxt].nCMinusGroupEdge &gt; 0 ) {</a>
<a name="ln254">                            pBNS-&gt;edge[pVA[nxt].nCMinusGroupEdge-1].forbidden &amp;= inv_forbidden_edge_mask; </a>
<a name="ln255">                        }</a>
<a name="ln256">                    }</a>
<a name="ln257">                    break; /* found */</a>
<a name="ln258">                }</a>
<a name="ln259">            }</a>
<a name="ln260">        } while ( nxt &gt;= 0 &amp;&amp; !( nxt_is_NPlus &amp;&amp; delta == -1 ) );</a>
<a name="ln261">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln262">            at2[i].cFlags = 0;</a>
<a name="ln263">        }</a>
<a name="ln264">        if ( nxt &gt;= 0 &amp;&amp; nxt_is_NPlus &amp;&amp; delta == -1 ) {</a>
<a name="ln265">            /* a simple alt path from NH-= to =N(+) has been found */</a>
<a name="ln266">            if ( iBPlus || iNV ) {</a>
<a name="ln267">                /* move (+) charge from N(+) to iNV or, if iBPlus, then to iNH */</a>
<a name="ln268">                if ( (iNV &gt;= 0 &amp;&amp; (j = pVA[iNV].nCPlusGroupEdge-1) &gt; 0 &amp;&amp; pBNS-&gt;edge[j].flow &gt; 0) ||</a>
<a name="ln269">                     (iNH &gt;= 0 &amp;&amp; (j = pVA[iNH].nCPlusGroupEdge-1) &gt; 0 &amp;&amp; pBNS-&gt;edge[j].flow &gt; 0) ) {</a>
<a name="ln270">                    int          ieFlower;</a>
<a name="ln271">                    BNS_EDGE    *pe  = pBNS-&gt;edge + j, *peFlower = NULL;</a>
<a name="ln272">                    Vertex      v1   = pe-&gt;neighbor1;</a>
<a name="ln273">                    Vertex      v2   = v1 ^ pe-&gt;neighbor12;</a>
<a name="ln274">                    BNS_VERTEX  *pv1 = pBNS-&gt;vert + v1;</a>
<a name="ln275">                    BNS_VERTEX  *pv2 = pBNS-&gt;vert + v2;</a>
<a name="ln276"> </a>
<a name="ln277">                    delta = 1;</a>
<a name="ln278">                    /* prevent conversion of &gt;N(+)= into N(V) neutral */</a>
<a name="ln279">                    ieFlower = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[nxt].nCPlusGroupEdge-1 );</a>
<a name="ln280">                    if ( ieFlower &gt;= 0 ) {</a>
<a name="ln281">                        peFlower = pBNS-&gt;edge + ieFlower;</a>
<a name="ln282">                        if ( peFlower-&gt;flow == delta ) {</a>
<a name="ln283">                            peFlower-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln284">                            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, ieFlower, 0 )) ) {</a>
<a name="ln285">                                goto exit_function;</a>
<a name="ln286">                            }</a>
<a name="ln287">                        }</a>
<a name="ln288">                    }</a>
<a name="ln289">                    pe-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln290">                    pe-&gt;flow          -= delta;</a>
<a name="ln291">                    pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln292">                    pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln293">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln294">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln295">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln296">                    if ( ret &lt; 0 ) {</a>
<a name="ln297">                        goto exit_function;</a>
<a name="ln298">                    }</a>
<a name="ln299">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln300">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln301">                                      nDeltaCharge &lt;= 0  /* charge moving to this atom disappers*/ ) {</a>
<a name="ln302">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln303">                        (*pnNumRunBNS) ++;</a>
<a name="ln304">                        if ( ret &lt; 0 ) {</a>
<a name="ln305">                            goto exit_function;</a>
<a name="ln306">                        } else</a>
<a name="ln307">                        if ( ret == 1 ) {</a>
<a name="ln308">                            *pnTotalDelta += ret;</a>
<a name="ln309">                        } else {</a>
<a name="ln310">                            ret = RI_ERR_PROGR;</a>
<a name="ln311">                            goto exit_function;</a>
<a name="ln312">                        }</a>
<a name="ln313">                    } else {</a>
<a name="ln314">                        ret = 0;</a>
<a name="ln315">                        pe-&gt;flow          += delta;</a>
<a name="ln316">                        pv1-&gt;st_edge.flow += delta;</a>
<a name="ln317">                        pv2-&gt;st_edge.flow += delta;</a>
<a name="ln318">                        pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln319">                    }</a>
<a name="ln320"> </a>
<a name="ln321">                }</a>
<a name="ln322"> </a>
<a name="ln323">            }</a>
<a name="ln324">        }</a>
<a name="ln325">    }</a>
<a name="ln326">exit_function:</a>
<a name="ln327">    /* remove bond fixation */</a>
<a name="ln328">    RemoveForbiddenEdgeMask( pBNS, &amp;NewlyFixedEdges, forbidden_edge_mask );</a>
<a name="ln329">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_FREE );</a>
<a name="ln330">    return ret;</a>
<a name="ln331">}</a>
<a name="ln332">/***********************************************************************************************</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">    X=Y-O(-)  =&gt; X(-)-Y=O</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">************************************************************************************************/</a>
<a name="ln339">int FixMoreHydrogenInFormula( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct, inp_ATOM *at,</a>
<a name="ln340">                              inp_ATOM *at2, inp_ATOM *atf, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln341">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask )</a>
<a name="ln342">{</a>
<a name="ln343">    int iNH = NO_VERTEX, neigh, neigh2;</a>
<a name="ln344">    EDGE_LIST NewlyFixedEdges;</a>
<a name="ln345">    int ret, i, j, k, k2, delta;</a>
<a name="ln346">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln347">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln348">    Vertex v1, v2;</a>
<a name="ln349">    /* for RunBnsTestOnce */</a>
<a name="ln350">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln351">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln352">    BNS_EDGE *pe, *pe2;</a>
<a name="ln353"> </a>
<a name="ln354">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln355">    if ( (ret = AllocEdgeList( &amp;NewlyFixedEdges, 2*num_at )) ) {</a>
<a name="ln356">        goto exit_function;</a>
<a name="ln357">    }</a>
<a name="ln358">    /* fix all charges */</a>
<a name="ln359">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln360">        if ( (j = pVA[i].nCMinusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln361">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, j, 0 )) ) {</a>
<a name="ln362">                goto exit_function;</a>
<a name="ln363">            }</a>
<a name="ln364">            pBNS-&gt;edge[j].forbidden |= forbidden_edge_mask;</a>
<a name="ln365">        }</a>
<a name="ln366">        if ( (j = pVA[i].nCPlusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln367">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, j, 0 )) ) {</a>
<a name="ln368">                goto exit_function;</a>
<a name="ln369">            }</a>
<a name="ln370">            pBNS-&gt;edge[j].forbidden |= forbidden_edge_mask;</a>
<a name="ln371">        }</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">    /* H(+) has been added to -O(-); check non-tautomeric atoms */</a>
<a name="ln375">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln376">        if ( !(pStruct-&gt;bMobileH? at2[i].endpoint : pStruct-&gt;endpoint[i]) &amp;&amp; !pVA[i].cMetal &amp;&amp;</a>
<a name="ln377">             at2[i].num_H + 1 == atf[i].num_H &amp;&amp;      /* normalization added H ??? What would happen in Fixed-H case?*/</a>
<a name="ln378">             (k = pVA[i].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln379">             pBNS-&gt;edge[k].flow == 1 &amp;&amp;               /* atom had (-) charge before preprocessing */</a>
<a name="ln380">             at2[i].charge == -1 &amp;&amp; atf[i].charge == 0 &amp;&amp; /* and has no charge after preprocessing */</a>
<a name="ln381">             at2[i].valence == 1 &amp;&amp; at2[i].chem_bonds_valence == 1 &amp;&amp; /* connected by a single bond */</a>
<a name="ln382">             pVA[i].cNumValenceElectrons == 6 &amp;&amp;     /* atom is O, S, Se, Te */</a>
<a name="ln383">             at2[neigh=at2[i].neighbor[0]].chem_bonds_valence &gt; at2[neigh].valence</a>
<a name="ln384">             /* atom's single neighbor has multiple bond(s)*/</a>
<a name="ln385">            ) {</a>
<a name="ln386">            /* H(+) was added to O in Y=X-O(-), where X is the only neighbor of O, X=neigh, Y=neigh2 */</a>
<a name="ln387">            iNH = i;</a>
<a name="ln388">            for ( j = 0; j &lt; at2[neigh].valence; j ++ ) {</a>
<a name="ln389">                neigh2 = at2[neigh].neighbor[j];</a>
<a name="ln390">                if ( neigh2 != iNH &amp;&amp; !at2[neigh2].endpoint &amp;&amp;</a>
<a name="ln391">                     !pBNS-&gt;edge[(int)pBNS-&gt;vert[neigh].iedge[j]].forbidden &amp;&amp;</a>
<a name="ln392">                     4 &lt;= pVA[neigh2].cNumValenceElectrons &amp;&amp;</a>
<a name="ln393">                          pVA[neigh2].cNumValenceElectrons &lt;= 5 &amp;&amp; /* neig2 is C or N */</a>
<a name="ln394">                     (k2 = pVA[neigh2].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln395">                     !pBNS-&gt;edge[k2].flow /* negative charge may be moved to neigh2 */ ) {</a>
<a name="ln396">                    break;</a>
<a name="ln397">                }</a>
<a name="ln398">            }</a>
<a name="ln399">            if ( j &lt; at2[neigh].valence ) {</a>
<a name="ln400">                delta = 1;</a>
<a name="ln401">                pe  = pBNS-&gt;edge + k;  /* -O(-) negative charge edge; flow = 1 */ </a>
<a name="ln402">                pe2 = pBNS-&gt;edge + k2; /* X charge edge; flow = 0 */</a>
<a name="ln403">                v1  = pe-&gt;neighbor1;</a>
<a name="ln404">                v2  = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln405">                pe-&gt;flow                    -= delta;</a>
<a name="ln406">                pBNS-&gt;vert[v1].st_edge.flow -= delta;</a>
<a name="ln407">                pBNS-&gt;vert[v2].st_edge.flow -= delta;</a>
<a name="ln408">                pBNS-&gt;tot_st_flow           -= 2*delta;</a>
<a name="ln409">                pe2-&gt;forbidden              &amp;= inv_forbidden_edge_mask; /* allow the charge to move */</a>
<a name="ln410"> </a>
<a name="ln411">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln412">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln413">                if ( ret &lt; 0 ) {</a>
<a name="ln414">                    goto exit_function;</a>
<a name="ln415">                }</a>
<a name="ln416">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln417">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln418">                                  nDeltaCharge &lt;= 1 ) {</a>
<a name="ln419">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln420">                    (*pnNumRunBNS) ++;</a>
<a name="ln421">                    if ( ret &lt; 0 ) {</a>
<a name="ln422">                        goto exit_function;</a>
<a name="ln423">                    } else</a>
<a name="ln424">                    if ( ret ) {</a>
<a name="ln425">                        *pnTotalDelta += ret;</a>
<a name="ln426">                    } else {</a>
<a name="ln427">                        ret = RI_ERR_PROGR;</a>
<a name="ln428">                    }</a>
<a name="ln429">                    break;</a>
<a name="ln430">                } else {</a>
<a name="ln431">                    /* the attempt has failed; restore the flow */</a>
<a name="ln432">                    ret = 0;</a>
<a name="ln433">                    pe-&gt;flow                    += delta;</a>
<a name="ln434">                    pBNS-&gt;vert[v1].st_edge.flow += delta;</a>
<a name="ln435">                    pBNS-&gt;vert[v2].st_edge.flow += delta;</a>
<a name="ln436">                    pBNS-&gt;tot_st_flow           += 2*delta;</a>
<a name="ln437">                }</a>
<a name="ln438">            }</a>
<a name="ln439">        }</a>
<a name="ln440">    }</a>
<a name="ln441">exit_function:</a>
<a name="ln442">    /* remove bond fixation */</a>
<a name="ln443">    RemoveForbiddenEdgeMask( pBNS, &amp;NewlyFixedEdges, forbidden_edge_mask );</a>
<a name="ln444">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_FREE );</a>
<a name="ln445">    return ret;</a>
<a name="ln446">}</a>
<a name="ln447">#if ( FIX_ADD_PROTON_FOR_ADP == 1 )</a>
<a name="ln448">/******************************************************************************************************/</a>
<a name="ln449">int FixAddProtonForADP( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct, inp_ATOM *at,</a>
<a name="ln450">                              inp_ATOM *at2, inp_ATOM *atf, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups, ICR *picr,</a>
<a name="ln451">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask )</a>
<a name="ln452">{</a>
<a name="ln453">    int iBPlus=NO_VERTEX, iNV=NO_VERTEX, iNH = NO_VERTEX, neigh, neigh2;</a>
<a name="ln454">    EDGE_LIST NewlyFixedEdges;</a>
<a name="ln455">    int ret, i, j, k, k2, delta;</a>
<a name="ln456">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln457">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln458">    Vertex v1, v2;</a>
<a name="ln459">    /* for RunBnsTestOnce */</a>
<a name="ln460">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln461">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln462">    BNS_EDGE *pe, *pe2;</a>
<a name="ln463"> </a>
<a name="ln464">    ret = 0;</a>
<a name="ln465">    /*</a>
<a name="ln466">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln467">    </a>
<a name="ln468">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln469">        if ( at2[i].radical == RADICAL_DOUBLET &amp;&amp; at2[i].endpoint ) {</a>
<a name="ln470">            pStruct-&gt;bExtract |= EXTRACT_STRUCT_NUMBER;</a>
<a name="ln471">            ret = 1;</a>
<a name="ln472">            break;</a>
<a name="ln473">        }</a>
<a name="ln474">    }</a>
<a name="ln475">    */</a>
<a name="ln476">    return ret;</a>
<a name="ln477">}</a>
<a name="ln478">#endif</a>
<a name="ln479">/******************************************************************************************************</a>
<a name="ln480">      OH              OH</a>
<a name="ln481">     /               /</a>
<a name="ln482">  -NH      =&gt;   -NH(+)        to eliminate false tautomerism. S(IV) or N(V) or P(V) may be a centerpoint</a>
<a name="ln483">     \\              \</a>
<a name="ln484">      O               O(-)</a>
<a name="ln485">*******************************************************************************************************/</a>
<a name="ln486">int FixRemoveExtraTautEndpoints( BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct, inp_ATOM *at,</a>
<a name="ln487">                              inp_ATOM *at2, inp_ATOM *atf, inp_ATOM *atn, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups, ICR *picr,</a>
<a name="ln488">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask )</a>
<a name="ln489">{</a>
<a name="ln490">    EDGE_LIST NewlyFixedEdges;</a>
<a name="ln491">    int ret, i, j, k, delta, centerpoint, endpoint1, endpoint2;</a>
<a name="ln492">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln493">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln494">    Vertex v1, v2;</a>
<a name="ln495">    /* for RunBnsTestOnce */</a>
<a name="ln496">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln497">    int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln498">    BNS_EDGE *pe, *pe2;</a>
<a name="ln499"> </a>
<a name="ln500">    ret = 0;</a>
<a name="ln501"> </a>
<a name="ln502">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln503">    if ( (ret = AllocEdgeList( &amp;NewlyFixedEdges, 2*num_at )) ) {</a>
<a name="ln504">        goto exit_function;</a>
<a name="ln505">    }</a>
<a name="ln506">    /* fix all charges */</a>
<a name="ln507">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln508">        if ( (j = pVA[i].nCMinusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln509">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, j, 0 )) ) {</a>
<a name="ln510">                goto exit_function;</a>
<a name="ln511">            }</a>
<a name="ln512">            pBNS-&gt;edge[j].forbidden |= forbidden_edge_mask;</a>
<a name="ln513">        }</a>
<a name="ln514">        if ( (j = pVA[i].nCPlusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln515">            if ( (ret = AddToEdgeList( &amp;NewlyFixedEdges, j, 0 )) ) {</a>
<a name="ln516">                goto exit_function;</a>
<a name="ln517">            }</a>
<a name="ln518">            pBNS-&gt;edge[j].forbidden |= forbidden_edge_mask;</a>
<a name="ln519">        }</a>
<a name="ln520">    }</a>
<a name="ln521"> </a>
<a name="ln522">    for ( i = 0; i &lt; picr-&gt;num_endp_in1_only; i ++ ) {</a>
<a name="ln523">        endpoint1 = picr-&gt;endp_in1_only[i]-1;</a>
<a name="ln524">        if ( at2[endpoint1].valence == at2[endpoint1].chem_bonds_valence ||</a>
<a name="ln525">             pVA[endpoint1].nCMinusGroupEdge &lt;= 0 ) {</a>
<a name="ln526">            continue;</a>
<a name="ln527">        }</a>
<a name="ln528">        /* find centerpoint */</a>
<a name="ln529">        for ( j = 0; j &lt; at2[endpoint1].valence; j ++ ) {</a>
<a name="ln530">            if ( BOND_TYPE_DOUBLE == ( BOND_TYPE_MASK &amp; at2[endpoint1].bond_type[j] ) ) {</a>
<a name="ln531">                centerpoint = at2[endpoint1].neighbor[j];</a>
<a name="ln532">                if ( at2[centerpoint].charge || pVA[centerpoint].nCPlusGroupEdge &lt;= 0 ||</a>
<a name="ln533">                     !is_centerpoint_elem( at2[centerpoint].el_number ) ) {</a>
<a name="ln534">                    continue;</a>
<a name="ln535">                }</a>
<a name="ln536">                /* -- the centerpoint as depicted has no ChargeStruct flower ---</a>
<a name="ln537">                m = GetChargeFlowerUpperEdge( pBNS, pVA, pVA[centerpoint].nCPlusGroupEdge-1 );</a>
<a name="ln538">                if ( m &lt; 0 || pBNS-&gt;edge[m].flow ) {</a>
<a name="ln539">                    continue;</a>
<a name="ln540">                }</a>
<a name="ln541">                */</a>
<a name="ln542">                /* find 2nd endpoint */</a>
<a name="ln543">                for ( k = 0; k &lt; at2[centerpoint].valence; k ++ ) {</a>
<a name="ln544">                    if ( BOND_TYPE_SINGLE != ( BOND_TYPE_MASK &amp; at2[centerpoint].bond_type[k] ) ) {</a>
<a name="ln545">                        continue;</a>
<a name="ln546">                    }</a>
<a name="ln547">                    endpoint2 = at2[centerpoint].neighbor[k];</a>
<a name="ln548">                    if ( !at2[endpoint2].endpoint &amp;&amp; atn[endpoint2].endpoint ) {</a>
<a name="ln549">                        break;</a>
<a name="ln550">                    }</a>
<a name="ln551">                }</a>
<a name="ln552">                if ( k == at2[centerpoint].valence ) {</a>
<a name="ln553">                    continue;</a>
<a name="ln554">                }</a>
<a name="ln555">                /* the centerpoint and two extra endpoints have been found */</a>
<a name="ln556">                pe = pBNS-&gt;edge + pVA[centerpoint].nCPlusGroupEdge - 1;</a>
<a name="ln557">                if ( !pe-&gt;flow  ) {</a>
<a name="ln558">                    continue;</a>
<a name="ln559">                }</a>
<a name="ln560">                pe2 = pBNS-&gt;edge + pVA[endpoint1].nCMinusGroupEdge - 1;</a>
<a name="ln561">                if ( pe2-&gt;flow ) {</a>
<a name="ln562">                    continue;</a>
<a name="ln563">                }</a>
<a name="ln564">                delta = 1;</a>
<a name="ln565">                v1 = pe-&gt;neighbor1;</a>
<a name="ln566">                v2 = pe-&gt;neighbor12 ^ v1;</a>
<a name="ln567">                pe-&gt;flow                    -= delta;</a>
<a name="ln568">                pBNS-&gt;vert[v1].st_edge.flow -= delta;</a>
<a name="ln569">                pBNS-&gt;vert[v2].st_edge.flow -= delta;</a>
<a name="ln570">                pBNS-&gt;tot_st_flow           -= 2*delta;</a>
<a name="ln571">                pe2-&gt;forbidden              &amp;= inv_forbidden_edge_mask; /* allow the charge to move */</a>
<a name="ln572"> </a>
<a name="ln573">                ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln574">                                      &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln575">                if ( ret &lt; 0 ) {</a>
<a name="ln576">                    goto exit_function;</a>
<a name="ln577">                }</a>
<a name="ln578">                if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln579">                                  (vPathEnd == v2 &amp;&amp; vPathStart == v1)) &amp;&amp;</a>
<a name="ln580">                                  nDeltaCharge &lt;= 1 ) {</a>
<a name="ln581">                    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln582">                    (*pnNumRunBNS) ++;</a>
<a name="ln583">                    if ( ret &lt; 0 ) {</a>
<a name="ln584">                        goto exit_function;</a>
<a name="ln585">                    } else</a>
<a name="ln586">                    if ( ret ) {</a>
<a name="ln587">                        *pnTotalDelta += ret;</a>
<a name="ln588">                    } else {</a>
<a name="ln589">                        ret = RI_ERR_PROGR;</a>
<a name="ln590">                    }</a>
<a name="ln591">                    goto exit_function;</a>
<a name="ln592">                } else {</a>
<a name="ln593">                    ret = 0;</a>
<a name="ln594">                    pe-&gt;flow                    += delta;</a>
<a name="ln595">                    pBNS-&gt;vert[v1].st_edge.flow += delta;</a>
<a name="ln596">                    pBNS-&gt;vert[v2].st_edge.flow += delta;</a>
<a name="ln597">                    pBNS-&gt;tot_st_flow           += 2*delta;</a>
<a name="ln598">                    pe2-&gt;forbidden              |= forbidden_edge_mask;</a>
<a name="ln599">                }</a>
<a name="ln600">            }</a>
<a name="ln601">        }</a>
<a name="ln602">    }</a>
<a name="ln603"> </a>
<a name="ln604">exit_function:</a>
<a name="ln605">    /* remove bond fixation */</a>
<a name="ln606">    RemoveForbiddenEdgeMask( pBNS, &amp;NewlyFixedEdges, forbidden_edge_mask );</a>
<a name="ln607">    AllocEdgeList( &amp;NewlyFixedEdges, EDGE_LIST_FREE );</a>
<a name="ln608">    return ret;</a>
<a name="ln609">}</a>
<a name="ln610">/*************************************************************************/</a>
<a name="ln611">int  FillOutExtraFixedHDataRestr( StrFromINChI *pStruct )</a>
<a name="ln612">{</a>
<a name="ln613">    int i, j, k, len, ret = 0;</a>
<a name="ln614">    AT_NUMB *pNum;</a>
<a name="ln615">    for ( i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln616">        if ( pStruct-&gt;pOneINChI_Aux[i] ) {</a>
<a name="ln617">            pNum = (pStruct-&gt;pOneINChI_Aux[i]-&gt;nIsotopicOrigAtNosInCanonOrd &amp;&amp;</a>
<a name="ln618">                    pStruct-&gt;pOneINChI_Aux[i]-&gt;nIsotopicOrigAtNosInCanonOrd[0])?</a>
<a name="ln619">                               pStruct-&gt;pOneINChI_Aux[i]-&gt;nIsotopicOrigAtNosInCanonOrd:</a>
<a name="ln620">                   (pStruct-&gt;pOneINChI_Aux[i]-&gt;nOrigAtNosInCanonOrd &amp;&amp;</a>
<a name="ln621">                    pStruct-&gt;pOneINChI_Aux[i]-&gt;nOrigAtNosInCanonOrd[0])?</a>
<a name="ln622">                               pStruct-&gt;pOneINChI_Aux[i]-&gt;nOrigAtNosInCanonOrd : NULL;</a>
<a name="ln623">        } else {</a>
<a name="ln624">            pNum = NULL;</a>
<a name="ln625">        }</a>
<a name="ln626">        if ( pNum ) {</a>
<a name="ln627">            len = pStruct-&gt;num_atoms * sizeof(pStruct-&gt;nCanon2Atno[0][0]);</a>
<a name="ln628">            if ( (!pStruct-&gt;nCanon2Atno[i] &amp;&amp;</a>
<a name="ln629">                 !(pStruct-&gt;nCanon2Atno[i] = (AT_NUMB *) inchi_malloc( len ))) ||</a>
<a name="ln630">                 (!pStruct-&gt;nAtno2Canon[i] &amp;&amp;</a>
<a name="ln631">                 !(pStruct-&gt;nAtno2Canon[i] = (AT_NUMB *) inchi_malloc( len ))) ) {</a>
<a name="ln632">                ret = RI_ERR_ALLOC;</a>
<a name="ln633">                goto exit_function;</a>
<a name="ln634">            }</a>
<a name="ln635">            </a>
<a name="ln636">            INCHI_HEAPCHK</a>
<a name="ln637"> </a>
<a name="ln638">            memcpy( pStruct-&gt;nCanon2Atno[i], pNum, len ); /* ??? the next for(...) fills it out */</a>
<a name="ln639"> </a>
<a name="ln640">            INCHI_HEAPCHK</a>
<a name="ln641"> </a>
<a name="ln642">            for ( j = 0; j &lt; pStruct-&gt;num_atoms; j ++ ) {</a>
<a name="ln643">                k = pNum[j]-1; /* atom number */</a>
<a name="ln644">                pStruct-&gt;nCanon2Atno[i][j] = (AT_NUMB)k;</a>
<a name="ln645">                pStruct-&gt;nAtno2Canon[i][k] = (AT_NUMB)j;</a>
<a name="ln646">                INCHI_HEAPCHK</a>
<a name="ln647">            }</a>
<a name="ln648">        } else</a>
<a name="ln649">        if ( !i ) {</a>
<a name="ln650">            ret = RI_ERR_PROGR;</a>
<a name="ln651">            goto exit_function;</a>
<a name="ln652">        } else {</a>
<a name="ln653">            if ( pStruct-&gt;nCanon2Atno[i] ) {</a>
<a name="ln654">                inchi_free( pStruct-&gt;nCanon2Atno[i] );</a>
<a name="ln655">                pStruct-&gt;nCanon2Atno[i] = NULL;</a>
<a name="ln656">            }</a>
<a name="ln657">            INCHI_HEAPCHK</a>
<a name="ln658">            if ( pStruct-&gt;nAtno2Canon[i] ) {</a>
<a name="ln659">                inchi_free( pStruct-&gt;nAtno2Canon[i] );</a>
<a name="ln660">                pStruct-&gt;nAtno2Canon[i] = NULL;</a>
<a name="ln661">            }</a>
<a name="ln662">            INCHI_HEAPCHK</a>
<a name="ln663">        }</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">exit_function:</a>
<a name="ln667">    return ret;</a>
<a name="ln668">}</a>
<a name="ln669">/*************************************************************************/</a>
<a name="ln670">int  FillOutExtraFixedHDataInChI( StrFromINChI *pStruct, INChI *pInChI[] )</a>
<a name="ln671">{</a>
<a name="ln672">    int ret = 0;</a>
<a name="ln673">    /*--- allocate memory for Mobile/Fixed-H data from the input InChI ---*/</a>
<a name="ln674">    if ( NULL == pStruct-&gt;endpoint ) {</a>
<a name="ln675">        pStruct-&gt;endpoint = (AT_NUMB *)inchi_calloc(pStruct-&gt;num_atoms, sizeof(pStruct-&gt;endpoint[0]));</a>
<a name="ln676">    } else {</a>
<a name="ln677">        memset( pStruct-&gt;endpoint, 0, pStruct-&gt;num_atoms * sizeof(pStruct-&gt;endpoint[0] ) );</a>
<a name="ln678">    }</a>
<a name="ln679">    if ( NULL == pStruct-&gt;fixed_H ) {</a>
<a name="ln680">        pStruct-&gt;fixed_H = (S_CHAR *) inchi_malloc(pStruct-&gt;num_atoms * sizeof(pStruct-&gt;fixed_H[0]));</a>
<a name="ln681">    }</a>
<a name="ln682">    if ( !pStruct-&gt;endpoint || !pStruct-&gt;fixed_H ) {</a>
<a name="ln683">        ret = RI_ERR_ALLOC;</a>
<a name="ln684">        goto exit_function;</a>
<a name="ln685">    }</a>
<a name="ln686">    /*--- fill out Mobile/Fixed-H data from the input InChI ---*/</a>
<a name="ln687">    GetTgroupInfoFromInChI( &amp;pStruct-&gt;ti, NULL, pStruct-&gt;endpoint, pInChI[1] );</a>
<a name="ln688">    if ( pInChI[0]-&gt;nNum_H_fixed ) {</a>
<a name="ln689">        memcpy( pStruct-&gt;fixed_H, pInChI[0]-&gt;nNum_H_fixed, pStruct-&gt;num_atoms * sizeof(pStruct-&gt;fixed_H[0]) );</a>
<a name="ln690">    } else {</a>
<a name="ln691">        memset( pStruct-&gt;fixed_H, 0, pStruct-&gt;num_atoms * sizeof(pStruct-&gt;fixed_H[0]) );</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">exit_function:</a>
<a name="ln695">    return ret;</a>
<a name="ln696">}</a>
<a name="ln697">/***********************************************************************************************/</a>
<a name="ln698">int FillOutCMP2FHINCHI( StrFromINChI *pStruct, inp_ATOM *at2, VAL_AT *pVA, INChI *pInChI[], CMP2FHINCHI *pc2i )</a>
<a name="ln699">{</a>
<a name="ln700">    int       ret = 0, i, j;</a>
<a name="ln701">    int       bFixHRevrsExists  = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; !pInChI[1]-&gt;bDeleted;</a>
<a name="ln702">    inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[1] &amp;&amp;</a>
<a name="ln703">                                 pStruct-&gt;pOne_norm_data[1]-&gt;at)? pStruct-&gt;pOne_norm_data[1]-&gt;at : NULL;</a>
<a name="ln704">    S_CHAR   *num_Fixed_H_Revrs = pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed? pStruct-&gt;pOneINChI[0]-&gt;nNum_H_fixed : NULL;</a>
<a name="ln705">    /* atom number in structure that produced original InChI is atom number in all inp_ATOM *atoms */</a>
<a name="ln706">    /* atom number in structure that produced restored InChI is in nAtomRevrs[]: */</a>
<a name="ln707">    AT_NUMB  *nAtno2CanonRevrs = pStruct-&gt;nAtno2Canon[0];</a>
<a name="ln708">    S_CHAR   *pnMobHInChI = (pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H)? pInChI[1]-&gt;nNum_H :</a>
<a name="ln709">                            (pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H)? pInChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln710">    S_CHAR   *pnMobHRevrs = (pStruct-&gt;pOneINChI[1] &amp;&amp; pStruct-&gt;pOneINChI[1]-&gt;nNum_H)?</a>
<a name="ln711">                               pStruct-&gt;pOneINChI[1]-&gt;nNum_H : </a>
<a name="ln712">                            (pStruct-&gt;pOneINChI[0] &amp;&amp; pStruct-&gt;pOneINChI[0]-&gt;nNum_H)?</a>
<a name="ln713">                               pStruct-&gt;pOneINChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln714">    int     nNumTgHInChI, nNumTgMInChI, nNumTgHRevrs, nNumTgMRevrs;</a>
<a name="ln715">    memset( pc2i, 0, sizeof(*pc2i) );</a>
<a name="ln716">    pc2i-&gt;nNumTgInChI = pStruct-&gt;ti.num_t_groups;</a>
<a name="ln717">    pc2i-&gt;nNumTgRevrs = pStruct-&gt;One_ti.num_t_groups;</a>
<a name="ln718">    pc2i-&gt;bHasDifference |= pc2i-&gt;nNumTgInChI != pc2i-&gt;nNumTgRevrs;</a>
<a name="ln719"> </a>
<a name="ln720">    pc2i-&gt;nNumRemHInChI = pStruct-&gt;nNumRemovedProtonsMobHInChI;</a>
<a name="ln721">    pc2i-&gt;nNumRemHRevrs = pStruct-&gt;One_ti.tni.nNumRemovedProtons;</a>
<a name="ln722">    pc2i-&gt;bHasDifference |= pc2i-&gt;nNumRemHInChI != pc2i-&gt;nNumRemHRevrs;</a>
<a name="ln723"> </a>
<a name="ln724">    pc2i-&gt;bFixedHLayerExistsRevrs = bFixHRevrsExists;</a>
<a name="ln725">    pc2i-&gt;bHasDifference |= !bFixHRevrsExists;</a>
<a name="ln726"> </a>
<a name="ln727">    for ( i = 0; i &lt; pStruct-&gt;ti.num_t_groups &amp;&amp; i &lt; pStruct-&gt;One_ti.num_t_groups; i ++ ) {</a>
<a name="ln728">        nNumTgHInChI = pStruct-&gt;ti.t_group[i].num[0] - pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln729">        nNumTgMInChI = pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln730">        nNumTgHRevrs = pStruct-&gt;One_ti.t_group[i].num[0] - pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln731">        nNumTgMRevrs = pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln732"> </a>
<a name="ln733">        pc2i-&gt;bHasDifference |= nNumTgHInChI != nNumTgHRevrs;</a>
<a name="ln734">        pc2i-&gt;bHasDifference |= nNumTgMInChI != nNumTgMRevrs;</a>
<a name="ln735"> </a>
<a name="ln736">        if ( pStruct-&gt;ti.t_group[i].nNumEndpoints ==</a>
<a name="ln737">             pStruct-&gt;One_ti.t_group[i].nNumEndpoints ) {</a>
<a name="ln738">            </a>
<a name="ln739">            if ( nNumTgHInChI != nNumTgHRevrs ) {</a>
<a name="ln740">                pc2i-&gt;nNumTgDiffH ++;</a>
<a name="ln741">            }</a>
<a name="ln742">            if ( nNumTgMInChI != nNumTgMRevrs ) {</a>
<a name="ln743">                pc2i-&gt;nNumTgDiffMinus ++;</a>
<a name="ln744">            }</a>
<a name="ln745">        }</a>
<a name="ln746">        pc2i-&gt;bHasDifference |= pStruct-&gt;ti.t_group[i].nNumEndpoints !=</a>
<a name="ln747">                                pStruct-&gt;One_ti.t_group[i].nNumEndpoints;</a>
<a name="ln748"> </a>
<a name="ln749">        pc2i-&gt;nNumTgHInChI += nNumTgHInChI;</a>
<a name="ln750">        pc2i-&gt;nNumTgMInChI += nNumTgMInChI;</a>
<a name="ln751">        pc2i-&gt;nNumTgHRevrs += nNumTgHRevrs;</a>
<a name="ln752">        pc2i-&gt;nNumTgMRevrs += nNumTgMRevrs;</a>
<a name="ln753"> </a>
<a name="ln754">    }</a>
<a name="ln755">    for ( ; i &lt; pStruct-&gt;ti.num_t_groups; i ++ ) {</a>
<a name="ln756">        nNumTgHInChI = pStruct-&gt;ti.t_group[i].num[0] - pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln757">        nNumTgMInChI = pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln758">        pc2i-&gt;nNumTgHInChI += nNumTgHInChI;</a>
<a name="ln759">        pc2i-&gt;nNumTgMInChI += nNumTgMInChI;</a>
<a name="ln760">        pc2i-&gt;bHasDifference |= 1;</a>
<a name="ln761">    }</a>
<a name="ln762">    for ( ; i &lt; pStruct-&gt;One_ti.num_t_groups; i ++ ) {</a>
<a name="ln763">        nNumTgHRevrs = pStruct-&gt;One_ti.t_group[i].num[0] - pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln764">        nNumTgMRevrs = pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln765">        pc2i-&gt;nNumTgHRevrs += nNumTgHRevrs;</a>
<a name="ln766">        pc2i-&gt;nNumTgMRevrs += nNumTgMRevrs;</a>
<a name="ln767">        pc2i-&gt;bHasDifference |= 1;</a>
<a name="ln768"> </a>
<a name="ln769">    }</a>
<a name="ln770">    for ( i = j  = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln771">        /* i = original InChI canonical number - 1 */</a>
<a name="ln772">        /* k = atom number from InChI created out of restored Fixed-H structure */</a>
<a name="ln773">        int iCanonRevrs = nAtno2CanonRevrs[i];</a>
<a name="ln774">        int endptInChI  = pStruct-&gt;endpoint[i]; /* endpoint in InChI */</a>
<a name="ln775">        int endptRevrs  = at_Mobile_H_Revrs? at_Mobile_H_Revrs[i].endpoint : 0;</a>
<a name="ln776">        int nFixHInChI  = pStruct-&gt;fixed_H[i];</a>
<a name="ln777">        int nFixHRevrs  = num_Fixed_H_Revrs? num_Fixed_H_Revrs[iCanonRevrs]:0;</a>
<a name="ln778">        int nMobHInChI  = pnMobHInChI? pnMobHInChI[i]:0;</a>
<a name="ln779">        int nMobHRevrs =  pnMobHRevrs? pnMobHRevrs[iCanonRevrs]:0;</a>
<a name="ln780">        if ( /*(!endptInChI || !endptRevrs) &amp;&amp;*/ (nFixHInChI != nFixHRevrs ) ||</a>
<a name="ln781">             (!endptInChI != !endptRevrs) || nMobHInChI != nMobHRevrs ) {</a>
<a name="ln782">             /* in InChI or reversed InChI atom[i] is not tautomeric */</a>
<a name="ln783">             /* and number of fixed-H on the atom[i] differs */</a>
<a name="ln784">            if ( j &gt;= MAX_DIFF_FIXH ) {</a>
<a name="ln785">                ret = RI_ERR_PROGR;</a>
<a name="ln786">                goto exit_function;</a>
<a name="ln787">            }</a>
<a name="ln788">            pc2i-&gt;c2at[j].endptInChI = endptInChI;</a>
<a name="ln789">            pc2i-&gt;c2at[j].endptRevrs = endptRevrs;</a>
<a name="ln790">            pc2i-&gt;bHasDifference |= !endptInChI != !endptRevrs;</a>
<a name="ln791">            pc2i-&gt;c2at[j].atomNumber = i;</a>
<a name="ln792">            pc2i-&gt;c2at[j].nValElectr = pVA[i].cNumValenceElectrons;</a>
<a name="ln793">            pc2i-&gt;c2at[j].nPeriodNum = pVA[i].cPeriodicRowNumber;</a>
<a name="ln794">            pc2i-&gt;c2at[j].nFixHInChI = nFixHInChI;</a>
<a name="ln795">            pc2i-&gt;c2at[j].nFixHRevrs = nFixHRevrs;</a>
<a name="ln796">            pc2i-&gt;bHasDifference |= nFixHInChI != nFixHRevrs;</a>
<a name="ln797">            pc2i-&gt;c2at[j].nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H[i] :</a>
<a name="ln798">                                       pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H[i] : 0;</a>
<a name="ln799">            pc2i-&gt;c2at[j].nMobHRevrs = (pStruct-&gt;pOneINChI[1] &amp;&amp; pStruct-&gt;pOneINChI[1]-&gt;nNum_H)?</a>
<a name="ln800">                                           pStruct-&gt;pOneINChI[1]-&gt;nNum_H[iCanonRevrs] : </a>
<a name="ln801">                                       (pStruct-&gt;pOneINChI[0] &amp;&amp; pStruct-&gt;pOneINChI[0]-&gt;nNum_H)?</a>
<a name="ln802">                                           pStruct-&gt;pOneINChI[0]-&gt;nNum_H[iCanonRevrs] : 0;</a>
<a name="ln803">            pc2i-&gt;nNumDiffMobH   += (nMobHInChI != nMobHRevrs &amp;&amp; !endptRevrs &amp;&amp; !endptInChI);</a>
<a name="ln804">            pc2i-&gt;bHasDifference |= nMobHInChI != nMobHRevrs;</a>
<a name="ln805">            pc2i-&gt;c2at[j].nNumHRevrs = at2[i].num_H;</a>
<a name="ln806">            pc2i-&gt;c2at[j].nAtChargeRevrs = at2[i].charge;</a>
<a name="ln807">            j ++;</a>
<a name="ln808">        }</a>
<a name="ln809">        pc2i-&gt;nNumEndpInChI += (endptInChI != 0); </a>
<a name="ln810">        pc2i-&gt;nNumEndpRevrs += (endptRevrs != 0);</a>
<a name="ln811"> </a>
<a name="ln812">        if ( !pVA[i].cMetal ) {</a>
<a name="ln813">            pc2i-&gt;nChargeFixHRevrsNonMetal += at2[i].charge;</a>
<a name="ln814">            pc2i-&gt;nChargeMobHRevrsNonMetal += at_Mobile_H_Revrs? at_Mobile_H_Revrs[i].charge : 0;</a>
<a name="ln815">        }</a>
<a name="ln816"> </a>
<a name="ln817">        /*pStruct-&gt;bExtract |= EXTRACT_STRUCT_NUMBER;*/</a>
<a name="ln818">    }</a>
<a name="ln819">    pc2i-&gt;nChargeFixHInChI = pInChI[0]? pInChI[0]-&gt;nTotalCharge : 0;</a>
<a name="ln820">    pc2i-&gt;nChargeMobHInChI = pInChI[1]? pInChI[1]-&gt;nTotalCharge : 0;</a>
<a name="ln821"> </a>
<a name="ln822">    pc2i-&gt;nChargeMobHRevrs = pStruct-&gt;pOneINChI[1]? pStruct-&gt;pOneINChI[1]-&gt;nTotalCharge : </a>
<a name="ln823">                             pStruct-&gt;pOneINChI[0]? pStruct-&gt;pOneINChI[0]-&gt;nTotalCharge : 0;</a>
<a name="ln824">    pc2i-&gt;nChargeFixHRevrs = pStruct-&gt;pOneINChI[0]? pStruct-&gt;pOneINChI[0]-&gt;nTotalCharge : 0;</a>
<a name="ln825">    </a>
<a name="ln826">    pc2i-&gt;bHasDifference |= pc2i-&gt;nChargeFixHInChI != pc2i-&gt;nChargeFixHRevrs;</a>
<a name="ln827">    pc2i-&gt;bHasDifference |= pc2i-&gt;nChargeMobHInChI != pc2i-&gt;nChargeMobHRevrs;</a>
<a name="ln828"> </a>
<a name="ln829">exit_function:</a>
<a name="ln830">    pc2i-&gt;len_c2at = j;</a>
<a name="ln831"> </a>
<a name="ln832">    return ret;</a>
<a name="ln833">}</a>
<a name="ln834">/***********************************************************************************************/</a>
<a name="ln835">int FillOutCMP2MHINCHI( StrFromINChI *pStruct, ALL_TC_GROUPS *pTCGroups, inp_ATOM *at2,</a>
<a name="ln836">                        VAL_AT *pVA, INChI *pInChI[], CMP2MHINCHI *pc2i )</a>
<a name="ln837">{</a>
<a name="ln838">    int       ret = 0, i, j, iat;</a>
<a name="ln839">    int       bFixHRevrsExists  = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; !pInChI[1]-&gt;bDeleted;</a>
<a name="ln840">    inp_ATOM *at_Mobile_H_Revrs = (pStruct-&gt;pOne_norm_data[0] &amp;&amp;</a>
<a name="ln841">                                 pStruct-&gt;pOne_norm_data[0]-&gt;at)? pStruct-&gt;pOne_norm_data[0]-&gt;at : NULL;</a>
<a name="ln842">    /* atom number in structure that produced original InChI is atom number in all inp_ATOM *atoms */</a>
<a name="ln843">    /* atom number in structure that produced restored InChI is in nAtomRevrs[]: */</a>
<a name="ln844">    AT_NUMB  *nCanon2AtnoRevrs = pStruct-&gt;nCanon2Atno[0];</a>
<a name="ln845">    AT_NUMB  *nAtno2CanonRevrs = pStruct-&gt;nAtno2Canon[0];</a>
<a name="ln846">    S_CHAR   *pnMobHInChI = (pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H)? pInChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln847">    S_CHAR   *pnMobHRevrs = (pStruct-&gt;pOneINChI[0] &amp;&amp; pStruct-&gt;pOneINChI[0]-&gt;nNum_H)?</a>
<a name="ln848">                               pStruct-&gt;pOneINChI[0]-&gt;nNum_H : NULL;</a>
<a name="ln849">    int     nNumTgHInChI, nNumTgMInChI, nNumTgHRevrs, nNumTgMRevrs;</a>
<a name="ln850">    memset( pc2i, 0, sizeof(*pc2i) );</a>
<a name="ln851">    pc2i-&gt;nNumTgInChI = pStruct-&gt;ti.num_t_groups;</a>
<a name="ln852">    pc2i-&gt;nNumTgRevrs = pStruct-&gt;One_ti.num_t_groups;</a>
<a name="ln853">    pc2i-&gt;bHasDifference |= pc2i-&gt;nNumTgInChI != pc2i-&gt;nNumTgRevrs;</a>
<a name="ln854"> </a>
<a name="ln855">    pc2i-&gt;nNumRemHInChI = pStruct-&gt;nNumRemovedProtonsMobHInChI;</a>
<a name="ln856">    pc2i-&gt;nNumRemHRevrs = pStruct-&gt;One_ti.tni.nNumRemovedProtons;</a>
<a name="ln857">    /*pc2i-&gt;bHasDifference |= pc2i-&gt;nNumRemHInChI != pc2i-&gt;nNumRemHRevrs;*/</a>
<a name="ln858"> </a>
<a name="ln859">    pc2i-&gt;bFixedHLayerExistsRevrs = bFixHRevrsExists;</a>
<a name="ln860">    /*pc2i-&gt;bHasDifference |= !bFixHRevrsExists;*/</a>
<a name="ln861"> </a>
<a name="ln862">    for ( i = 0; i &lt; pStruct-&gt;ti.num_t_groups; i ++ ) {</a>
<a name="ln863">        int jFst = pStruct-&gt;ti.t_group[i].nFirstEndpointAtNoPos;</a>
<a name="ln864">        int jNum = pStruct-&gt;ti.t_group[i].nNumEndpoints;</a>
<a name="ln865">        int is_N, is_O; </a>
<a name="ln866">        for ( j = 0; j &lt; jNum; j ++ ) {</a>
<a name="ln867">            iat = pStruct-&gt;ti.nEndpointAtomNumber[jFst + j];</a>
<a name="ln868">            is_N = pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1;</a>
<a name="ln869">            is_O = pVA[iat].cNumValenceElectrons == 6;</a>
<a name="ln870">            if ( is_N + is_O != 1 ) {</a>
<a name="ln871">                return RI_ERR_SYNTAX;</a>
<a name="ln872">            }</a>
<a name="ln873">            pc2i-&gt;nNumTgNInChI += is_N;</a>
<a name="ln874">            pc2i-&gt;nNumTgOInChI += is_O;</a>
<a name="ln875">            if ( at2[iat].chem_bonds_valence == at2[iat].valence ) {</a>
<a name="ln876">                /* donor */</a>
<a name="ln877">                if ( is_N ) {</a>
<a name="ln878">                    /* N */</a>
<a name="ln879">                    pc2i-&gt;nNumTgNHInChI      += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln880">                    pc2i-&gt;nNumTgNH2InChI     += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 2;</a>
<a name="ln881">                    pc2i-&gt;nNumTgNMinusInChI  += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln882">                    pc2i-&gt;nNumTgNHMinusInChI += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln883">                } else {</a>
<a name="ln884">                    /* O, S, Se, Te */</a>
<a name="ln885">                    pc2i-&gt;nNumTgOHInChI      += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln886">                    pc2i-&gt;nNumTgOMinusInChI  += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln887">                }</a>
<a name="ln888">            } else</a>
<a name="ln889">            if ( at2[iat].chem_bonds_valence == at2[iat].valence+1 ) {</a>
<a name="ln890">                /* donor */</a>
<a name="ln891">                if ( is_N ) {</a>
<a name="ln892">                    /* N */</a>
<a name="ln893">                    pc2i-&gt;nNumTgDBNHInChI      += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln894">                    pc2i-&gt;nNumTgDBNMinusInChI  += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln895">                    pc2i-&gt;nNumTgDBNInChI       += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln896">                } else {</a>
<a name="ln897">                    /* O, S, Se, Te */</a>
<a name="ln898">                    pc2i-&gt;nNumTgDBOInChI       += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln899">                }</a>
<a name="ln900">            }</a>
<a name="ln901">        }</a>
<a name="ln902">    }</a>
<a name="ln903">    for ( i = 0; i &lt; pStruct-&gt;One_ti.num_t_groups; i ++ ) {</a>
<a name="ln904">        int jFst = pStruct-&gt;One_ti.t_group[i].nFirstEndpointAtNoPos;</a>
<a name="ln905">        int jNum = pStruct-&gt;One_ti.t_group[i].nNumEndpoints;</a>
<a name="ln906">        int is_N, is_O; </a>
<a name="ln907">        for ( j = 0; j &lt; jNum; j ++ ) {</a>
<a name="ln908">            iat = nCanon2AtnoRevrs[(int)pStruct-&gt;One_ti.nEndpointAtomNumber[jFst + j]];</a>
<a name="ln909">            is_N = pVA[iat].cNumValenceElectrons == 5 &amp;&amp; pVA[iat].cPeriodicRowNumber == 1;</a>
<a name="ln910">            is_O = pVA[iat].cNumValenceElectrons == 6;</a>
<a name="ln911">            if ( is_N + is_O != 1 ) {</a>
<a name="ln912">                return RI_ERR_PROGR;</a>
<a name="ln913">            }</a>
<a name="ln914">            pc2i-&gt;nNumTgNRevrs += is_N;</a>
<a name="ln915">            pc2i-&gt;nNumTgORevrs += is_O;</a>
<a name="ln916">            if ( at2[iat].chem_bonds_valence == at2[iat].valence ) {</a>
<a name="ln917">                /* donor */</a>
<a name="ln918">                if ( is_N ) {</a>
<a name="ln919">                    /* N */</a>
<a name="ln920">                    pc2i-&gt;nNumTgNHRevrs      += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln921">                    pc2i-&gt;nNumTgNH2Revrs     += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 2;</a>
<a name="ln922">                    pc2i-&gt;nNumTgNMinusRevrs  += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln923">                    pc2i-&gt;nNumTgNHMinusRevrs += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln924">                } else {</a>
<a name="ln925">                    /* O, S, Se, Te */</a>
<a name="ln926">                    pc2i-&gt;nNumTgOHRevrs      += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln927">                    pc2i-&gt;nNumTgOMinusRevrs  += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln928">                }</a>
<a name="ln929">            } else</a>
<a name="ln930">            if ( at2[iat].chem_bonds_valence == at2[iat].valence+1 ) {</a>
<a name="ln931">                /* donor */</a>
<a name="ln932">                if ( is_N ) {</a>
<a name="ln933">                    /* N */</a>
<a name="ln934">                    pc2i-&gt;nNumTgDBNHRevrs      += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 1;</a>
<a name="ln935">                    pc2i-&gt;nNumTgDBNMinusRevrs  += at2[iat].charge == -1 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln936">                    pc2i-&gt;nNumTgDBNRevrs       += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln937">                } else {</a>
<a name="ln938">                    /* O, S, Se, Te */</a>
<a name="ln939">                    pc2i-&gt;nNumTgDBORevrs       += at2[iat].charge ==  0 &amp;&amp; at2[iat].num_H == 0;</a>
<a name="ln940">                }</a>
<a name="ln941">            }</a>
<a name="ln942">        }</a>
<a name="ln943">    }</a>
<a name="ln944"> </a>
<a name="ln945">    for ( i = 0; i &lt; pStruct-&gt;ti.num_t_groups &amp;&amp; i &lt; pStruct-&gt;One_ti.num_t_groups; i ++ ) {</a>
<a name="ln946">        nNumTgHInChI = pStruct-&gt;ti.t_group[i].num[0] - pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln947">        nNumTgMInChI = pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln948">        nNumTgHRevrs = pStruct-&gt;One_ti.t_group[i].num[0] - pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln949">        nNumTgMRevrs = pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln950"> </a>
<a name="ln951">        pc2i-&gt;bHasDifference |= nNumTgHInChI != nNumTgHRevrs;</a>
<a name="ln952">        pc2i-&gt;bHasDifference |= nNumTgMInChI != nNumTgMRevrs;</a>
<a name="ln953"> </a>
<a name="ln954">        if ( pStruct-&gt;ti.t_group[i].nNumEndpoints ==</a>
<a name="ln955">             pStruct-&gt;One_ti.t_group[i].nNumEndpoints ) {</a>
<a name="ln956">            </a>
<a name="ln957">            if ( nNumTgHInChI != nNumTgHRevrs ) {</a>
<a name="ln958">                pc2i-&gt;nNumTgDiffH ++;</a>
<a name="ln959">            }</a>
<a name="ln960">            if ( nNumTgMInChI != nNumTgMRevrs ) {</a>
<a name="ln961">                pc2i-&gt;nNumTgDiffMinus ++;</a>
<a name="ln962">            }</a>
<a name="ln963">        }</a>
<a name="ln964">        pc2i-&gt;bHasDifference |= pStruct-&gt;ti.t_group[i].nNumEndpoints !=</a>
<a name="ln965">                                pStruct-&gt;One_ti.t_group[i].nNumEndpoints;</a>
<a name="ln966"> </a>
<a name="ln967">        pc2i-&gt;nNumTgHInChI += nNumTgHInChI;</a>
<a name="ln968">        pc2i-&gt;nNumTgMInChI += nNumTgMInChI;</a>
<a name="ln969">        pc2i-&gt;nNumTgHRevrs += nNumTgHRevrs;</a>
<a name="ln970">        pc2i-&gt;nNumTgMRevrs += nNumTgMRevrs;</a>
<a name="ln971"> </a>
<a name="ln972">    }</a>
<a name="ln973">    for ( ; i &lt; pStruct-&gt;ti.num_t_groups; i ++ ) {</a>
<a name="ln974">        nNumTgHInChI = pStruct-&gt;ti.t_group[i].num[0] - pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln975">        nNumTgMInChI = pStruct-&gt;ti.t_group[i].num[1];</a>
<a name="ln976">        pc2i-&gt;nNumTgHInChI += nNumTgHInChI;</a>
<a name="ln977">        pc2i-&gt;nNumTgMInChI += nNumTgMInChI;</a>
<a name="ln978">        pc2i-&gt;bHasDifference |= 1;</a>
<a name="ln979">    }</a>
<a name="ln980">    for ( ; i &lt; pStruct-&gt;One_ti.num_t_groups; i ++ ) {</a>
<a name="ln981">        nNumTgHRevrs = pStruct-&gt;One_ti.t_group[i].num[0] - pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln982">        nNumTgMRevrs = pStruct-&gt;One_ti.t_group[i].num[1];</a>
<a name="ln983">        pc2i-&gt;nNumTgHRevrs += nNumTgHRevrs;</a>
<a name="ln984">        pc2i-&gt;nNumTgMRevrs += nNumTgMRevrs;</a>
<a name="ln985">        pc2i-&gt;bHasDifference |= 1;</a>
<a name="ln986"> </a>
<a name="ln987">    }</a>
<a name="ln988">    for ( i = j  = 0; i &lt; pStruct-&gt;num_atoms; i ++ ) {</a>
<a name="ln989">        /* i = original InChI canonical number - 1 */</a>
<a name="ln990">        /* k = atom number from InChI created out of restored Fixed-H structure */</a>
<a name="ln991">        int iCanonRevrs = nAtno2CanonRevrs[i];</a>
<a name="ln992">        int endptInChI  = at2[i].endpoint; /* endpoint in InChI */</a>
<a name="ln993">        int endptRevrs  = at_Mobile_H_Revrs? at_Mobile_H_Revrs[i].endpoint : 0;</a>
<a name="ln994">        int nMobHInChI  = pnMobHInChI? pnMobHInChI[i]:0;</a>
<a name="ln995">        int nMobHRevrs =  pnMobHRevrs? pnMobHRevrs[iCanonRevrs]:0;</a>
<a name="ln996">        if ( (!endptInChI != !endptRevrs) || nMobHInChI != nMobHRevrs ) {</a>
<a name="ln997">             /* in InChI or reversed InChI atom[i] is not tautomeric */</a>
<a name="ln998">             /* and number of fixed-H on the atom[i] differs */</a>
<a name="ln999">            if ( j &gt;= MAX_DIFF_FIXH ) {</a>
<a name="ln1000">                ret = RI_ERR_PROGR;</a>
<a name="ln1001">                goto exit_function;</a>
<a name="ln1002">            }</a>
<a name="ln1003">            pc2i-&gt;c2at[j].endptInChI = endptInChI;</a>
<a name="ln1004">            pc2i-&gt;c2at[j].endptRevrs = endptRevrs;</a>
<a name="ln1005">            pc2i-&gt;bHasDifference |= !endptInChI != !endptRevrs;</a>
<a name="ln1006">            pc2i-&gt;c2at[j].atomNumber = i;</a>
<a name="ln1007">            pc2i-&gt;c2at[j].nValElectr = pVA[i].cNumValenceElectrons;</a>
<a name="ln1008">            pc2i-&gt;c2at[j].nPeriodNum = pVA[i].cPeriodicRowNumber;</a>
<a name="ln1009">            pc2i-&gt;c2at[j].nMobHInChI = pInChI[1] &amp;&amp; pInChI[1]-&gt;nNum_H? pInChI[1]-&gt;nNum_H[i] :</a>
<a name="ln1010">                                       pInChI[0] &amp;&amp; pInChI[0]-&gt;nNum_H? pInChI[0]-&gt;nNum_H[i] : 0;</a>
<a name="ln1011">            pc2i-&gt;c2at[j].nMobHRevrs = (pStruct-&gt;pOneINChI[1] &amp;&amp; pStruct-&gt;pOneINChI[1]-&gt;nNum_H)?</a>
<a name="ln1012">                                           pStruct-&gt;pOneINChI[1]-&gt;nNum_H[iCanonRevrs] : </a>
<a name="ln1013">                                       (pStruct-&gt;pOneINChI[0] &amp;&amp; pStruct-&gt;pOneINChI[0]-&gt;nNum_H)?</a>
<a name="ln1014">                                           pStruct-&gt;pOneINChI[0]-&gt;nNum_H[iCanonRevrs] : 0;</a>
<a name="ln1015">            </a>
<a name="ln1016">            pc2i-&gt;nNumDiffMobH   += (nMobHInChI != nMobHRevrs &amp;&amp; !endptRevrs &amp;&amp; !endptInChI);</a>
<a name="ln1017">            pc2i-&gt;bHasDifference |= (nMobHInChI != nMobHRevrs);</a>
<a name="ln1018">            pc2i-&gt;c2at[j].nNumHRevrs = at2[i].num_H;</a>
<a name="ln1019">            pc2i-&gt;c2at[j].nAtChargeRevrs = at2[i].charge;</a>
<a name="ln1020">            j ++;</a>
<a name="ln1021">        }</a>
<a name="ln1022">        pc2i-&gt;nNumEndpInChI += (endptInChI != 0); </a>
<a name="ln1023">        pc2i-&gt;nNumEndpRevrs += (endptRevrs != 0);</a>
<a name="ln1024"> </a>
<a name="ln1025">        if ( !pVA[i].cMetal ) {</a>
<a name="ln1026">            pc2i-&gt;nChargeMobHRevrsNonMetal += (at_Mobile_H_Revrs &amp;&amp; !at_Mobile_H_Revrs[i].endpoint)? at_Mobile_H_Revrs[i].charge : 0;</a>
<a name="ln1027">        }</a>
<a name="ln1028"> </a>
<a name="ln1029"> </a>
<a name="ln1030">        /*pStruct-&gt;bExtract |= EXTRACT_STRUCT_NUMBER;*/</a>
<a name="ln1031">    }</a>
<a name="ln1032">    pc2i-&gt;nChargeMobHRevrsNonMetal += pTCGroups-&gt;tgroup_charge;</a>
<a name="ln1033"> </a>
<a name="ln1034">    pc2i-&gt;nChargeMobHInChI = pInChI[0]? pInChI[0]-&gt;nTotalCharge : 0;</a>
<a name="ln1035"> </a>
<a name="ln1036">    pc2i-&gt;nChargeMobHRevrs = pStruct-&gt;pOneINChI[0]? pStruct-&gt;pOneINChI[0]-&gt;nTotalCharge : 0;</a>
<a name="ln1037">    </a>
<a name="ln1038">    pc2i-&gt;bHasDifference |= pc2i-&gt;nChargeMobHInChI != pc2i-&gt;nChargeMobHRevrs;</a>
<a name="ln1039"> </a>
<a name="ln1040">exit_function:</a>
<a name="ln1041">    pc2i-&gt;len_c2at = j;</a>
<a name="ln1042"> </a>
<a name="ln1043">    return ret;</a>
<a name="ln1044">}</a>
<a name="ln1045">/******************************************************************************************************/</a>
<a name="ln1046">int NormalizeAndCompare(ICHICONST INPUT_PARMS *ip, STRUCT_DATA *sd, BN_STRUCT *pBNS, BN_DATA *pBD,</a>
<a name="ln1047">                        StrFromINChI *pStruct, inp_ATOM *at, inp_ATOM *at2, inp_ATOM *at3, VAL_AT *pVA,</a>
<a name="ln1048">                        ALL_TC_GROUPS *pTCGroups, INChI *pInChI[], long num_inp, int bHasSomeFixedH,</a>
<a name="ln1049">                        int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask, int forbidden_stereo_edge_mask)</a>
<a name="ln1050">{</a>
<a name="ln1051">    int i;</a>
<a name="ln1052">    int err;</a>
<a name="ln1053">    ICR icr, icr2;</a>
<a name="ln1054">    int num_norm_endpoints, num_endpoints, num_norm_t_groups, num_mobile, num_norm_mobile, ret = 0;</a>
<a name="ln1055">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1056">#ifndef TARGET_API_LIB</a>
<a name="ln1057">    const char *szCurHdr = (ip-&gt;pSdfValue &amp;&amp; ip-&gt;pSdfValue[0])? ip-&gt;pSdfValue : &quot;???&quot;;</a>
<a name="ln1058">    int         iComponent = pTCGroups-&gt;iComponent;</a>
<a name="ln1059">#endif</a>
<a name="ln1060">#endif</a>
<a name="ln1061">    T_GROUP_INFO *t_group_info = NULL;</a>
<a name="ln1062">    inp_ATOM     *at_norm = NULL; /* normalized */</a>
<a name="ln1063">    inp_ATOM     *at_prep = NULL; /* preprocessed */</a>
<a name="ln1064">    INCHI_MODE  cmpInChI, cmpInChI2;</a>
<a name="ln1065">    int         nDeltaPrev, nDeltaCur;</a>
<a name="ln1066">    int         iOrigInChI, iRevrInChI;</a>
<a name="ln1067"> </a>
<a name="ln1068"> </a>
<a name="ln1069">    /***********************************************************/</a>
<a name="ln1070">    /* normalize and create one component InChI                */</a>
<a name="ln1071">    /***********************************************************/</a>
<a name="ln1072">    ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1073">                                          &amp;t_group_info, &amp;at_norm, &amp;at_prep );</a>
<a name="ln1074">    if ( ret &lt; 0 ) {</a>
<a name="ln1075">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1076">#ifndef TARGET_API_LIB</a>
<a name="ln1077">        fprintf( stdout, &quot;\nERROR in MakeOneInchi-1: %ld %s Comp:%d %c%c Err:%d\n&quot;, num_inp,</a>
<a name="ln1078">                 szCurHdr? szCurHdr: &quot;???&quot;, iComponent, pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F', ret);</a>
<a name="ln1079">#endif</a>
<a name="ln1080">#endif</a>
<a name="ln1081">        goto exit_function;</a>
<a name="ln1082">    }</a>
<a name="ln1083">    if ( pStruct-&gt;bMobileH == TAUT_NON ) {</a>
<a name="ln1084">        /* these indexes are used to compare Mobile-H InChI */</a>
<a name="ln1085">        iOrigInChI = (pInChI[1] &amp;&amp; pInChI[1]-&gt;nNumberOfAtoms &amp;&amp; !pInChI[1]-&gt;bDeleted)? 1 : 0;</a>
<a name="ln1086">        iRevrInChI = (pStruct-&gt;pOneINChI[1] &amp;&amp;pStruct-&gt;pOneINChI[1]-&gt;nNumberOfAtoms &amp;&amp; !pStruct-&gt;pOneINChI[1]-&gt;bDeleted)? 1 : 0;</a>
<a name="ln1087">    } else {</a>
<a name="ln1088">        iOrigInChI = 0;</a>
<a name="ln1089">        iRevrInChI = 0;</a>
<a name="ln1090">    }</a>
<a name="ln1091"> </a>
<a name="ln1092">    /************************************************************/</a>
<a name="ln1093">    /* compare                                                  */</a>
<a name="ln1094">    /************************************************************/</a>
<a name="ln1095">    if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1096">        goto exit_function;</a>
<a name="ln1097">    }</a>
<a name="ln1098">    cmpInChI = CompareReversedINChI2( pStruct-&gt;pOneINChI[iRevrInChI], pInChI[iOrigInChI], pStruct-&gt;pOneINChI_Aux[iRevrInChI], NULL /*INChI_Aux *a2*/, &amp;icr, &amp;err );</a>
<a name="ln1099">    if ( cmpInChI &amp; IDIF_PROBLEM ) {</a>
<a name="ln1100">        ret = RI_ERR_PROGR; /* severe restore problem */</a>
<a name="ln1101">        goto exit_function;</a>
<a name="ln1102">    }</a>
<a name="ln1103">    if ( err ) {</a>
<a name="ln1104">        ret = RI_ERR_ALLOC;</a>
<a name="ln1105">        goto exit_function;</a>
<a name="ln1106">    }</a>
<a name="ln1107">    /********** InChI from restored structure has LESS hydrogen atoms ******************************/</a>
<a name="ln1108">    if ( (cmpInChI &amp; IDIF_LESS_H) &amp;&amp; at_prep &amp;&amp; 0 &lt; (nDeltaCur = icr.tot_num_H2 - icr.tot_num_H1) ) {</a>
<a name="ln1109">        do {</a>
<a name="ln1110">            ret =  FixLessHydrogenInFormula( pBNS, pBD, pStruct, at, at2, at_prep, pVA, pTCGroups,</a>
<a name="ln1111">                                             pnNumRunBNS, pnTotalDelta, forbidden_edge_mask );</a>
<a name="ln1112">            if ( ret &lt; 0 ) {</a>
<a name="ln1113">                goto exit_function;</a>
<a name="ln1114">            }</a>
<a name="ln1115">            if ( ret ) {</a>
<a name="ln1116">                /* Probably success. The changes are in pBNS. Create new InChI out of the new restored structure */</a>
<a name="ln1117">                ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1118">                                                      &amp;t_group_info, &amp;at_norm, &amp;at_prep );</a>
<a name="ln1119">                if ( ret &lt; 0 ) {</a>
<a name="ln1120">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1121">#ifndef TARGET_API_LIB</a>
<a name="ln1122">                    fprintf( stdout, &quot;\nERROR in MakeOneInchi-2: %ld %s Comp:%d %c%c Err:%d\n&quot;, num_inp,</a>
<a name="ln1123">                             szCurHdr? szCurHdr: &quot;???&quot;, iComponent, pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F', ret);</a>
<a name="ln1124">#endif</a>
<a name="ln1125">#endif</a>
<a name="ln1126">                    goto exit_function;</a>
<a name="ln1127">                }</a>
<a name="ln1128">                /* compare new InChI to the original InChI */</a>
<a name="ln1129">                if ( pStruct-&gt;bMobileH == TAUT_NON ) {</a>
<a name="ln1130">                    iRevrInChI = (pStruct-&gt;pOneINChI[1] &amp;&amp;pStruct-&gt;pOneINChI[1]-&gt;nNumberOfAtoms &amp;&amp; !pStruct-&gt;pOneINChI[1]-&gt;bDeleted)? 1 : 0;</a>
<a name="ln1131">                } else {</a>
<a name="ln1132">                    iRevrInChI = 0;</a>
<a name="ln1133">                }</a>
<a name="ln1134">                if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1135">                    goto exit_function;</a>
<a name="ln1136">                }</a>
<a name="ln1137">                cmpInChI = CompareReversedINChI2( pStruct-&gt;pOneINChI[iRevrInChI], pInChI[iOrigInChI], pStruct-&gt;pOneINChI_Aux[iRevrInChI], NULL, &amp;icr, &amp;err );</a>
<a name="ln1138">                nDeltaPrev = nDeltaCur;</a>
<a name="ln1139">                nDeltaCur  = icr.tot_num_H2 - icr.tot_num_H1;</a>
<a name="ln1140">            } else {</a>
<a name="ln1141">                break;</a>
<a name="ln1142">            }</a>
<a name="ln1143">        } while( (cmpInChI &amp; IDIF_LESS_H) &amp;&amp; at_prep &amp;&amp; nDeltaCur &amp;&amp; nDeltaCur &lt; nDeltaPrev );</a>
<a name="ln1144">    }</a>
<a name="ln1145">    /********** InChI from restored structure has MORE hydrogen atoms ******************************/</a>
<a name="ln1146">    if ( (cmpInChI &amp; IDIF_MORE_H) &amp;&amp; at_prep &amp;&amp; 0 &lt; (nDeltaCur = icr.tot_num_H1 - icr.tot_num_H2) ) {</a>
<a name="ln1147">        do {</a>
<a name="ln1148">            ret =  FixMoreHydrogenInFormula( pBNS, pBD, pStruct, at, at2, at_prep, pVA, pTCGroups,</a>
<a name="ln1149">                                             pnNumRunBNS, pnTotalDelta, forbidden_edge_mask );</a>
<a name="ln1150">            if ( ret &lt; 0 ) {</a>
<a name="ln1151">                goto exit_function;</a>
<a name="ln1152">            }</a>
<a name="ln1153">            if ( ret ) {</a>
<a name="ln1154">                /* Probably success. The changes are in pBNS. Create new InChI out of the new restored structure */</a>
<a name="ln1155">                ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1156">                                                      &amp;t_group_info, &amp;at_norm, &amp;at_prep );</a>
<a name="ln1157">                if ( ret &lt; 0 ) {</a>
<a name="ln1158">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1159">#ifndef TARGET_API_LIB</a>
<a name="ln1160">                    fprintf( stdout, &quot;\nERROR in MakeOneInchi-3: %ld %s Comp:%d %c%c Err:%d\n&quot;, num_inp,</a>
<a name="ln1161">                             szCurHdr? szCurHdr: &quot;???&quot;, iComponent, pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F', ret);</a>
<a name="ln1162">#endif</a>
<a name="ln1163">#endif</a>
<a name="ln1164">                    goto exit_function;</a>
<a name="ln1165">                }</a>
<a name="ln1166">                /* compare new InChI to the original InChI */</a>
<a name="ln1167">                if ( pStruct-&gt;bMobileH == TAUT_NON ) {</a>
<a name="ln1168">                    iRevrInChI = (pStruct-&gt;pOneINChI[1] &amp;&amp;pStruct-&gt;pOneINChI[1]-&gt;nNumberOfAtoms &amp;&amp; !pStruct-&gt;pOneINChI[1]-&gt;bDeleted)? 1 : 0;</a>
<a name="ln1169">                } else {</a>
<a name="ln1170">                    iRevrInChI = 0;</a>
<a name="ln1171">                }</a>
<a name="ln1172">                if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1173">                    goto exit_function;</a>
<a name="ln1174">                }</a>
<a name="ln1175">                cmpInChI = CompareReversedINChI2( pStruct-&gt;pOneINChI[iRevrInChI], pInChI[iOrigInChI], pStruct-&gt;pOneINChI_Aux[iRevrInChI], NULL, &amp;icr, &amp;err );</a>
<a name="ln1176">                nDeltaPrev = nDeltaCur;</a>
<a name="ln1177">                nDeltaCur  = icr.tot_num_H1 - icr.tot_num_H2;</a>
<a name="ln1178">            } else {</a>
<a name="ln1179">                break;</a>
<a name="ln1180">            }</a>
<a name="ln1181">        } while( (cmpInChI &amp; IDIF_MORE_H) &amp;&amp; at_prep &amp;&amp; nDeltaCur &amp;&amp; nDeltaCur &lt; nDeltaPrev );</a>
<a name="ln1182">    }</a>
<a name="ln1183">    /***************** Fix non-taut atoms normalized to tautomeric endpoints ***********************/</a>
<a name="ln1184">    if ( (cmpInChI &amp; IDIF_EXTRA_TG_ENDP) &amp;&amp; at_norm &amp;&amp; 0 &lt; (nDeltaCur = icr.num_endp_in1_only) ) {</a>
<a name="ln1185">        do {</a>
<a name="ln1186">            ret = FixRemoveExtraTautEndpoints( pBNS, pBD, pStruct, at, at2, at_prep, at_norm, pVA, pTCGroups, &amp;icr,</a>
<a name="ln1187">                                               pnNumRunBNS, pnTotalDelta, forbidden_edge_mask );</a>
<a name="ln1188">            if ( ret &lt; 0 ) {</a>
<a name="ln1189">                goto exit_function;</a>
<a name="ln1190">            }</a>
<a name="ln1191">            if ( ret ) {</a>
<a name="ln1192">                /* Probably success. The changes are in pBNS. Create new InChI out of the new restored structure */</a>
<a name="ln1193">                ret = MakeOneInChIOutOfStrFromINChI2( ip, sd, pBNS, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1194">                                                      &amp;t_group_info, &amp;at_norm, &amp;at_prep );</a>
<a name="ln1195">                if ( ret &lt; 0 ) {</a>
<a name="ln1196">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1197">#ifndef TARGET_API_LIB</a>
<a name="ln1198">                    fprintf( stdout, &quot;\nERROR in MakeOneInchi-4: %ld %s Comp:%d %c%c Err:%d\n&quot;, num_inp,</a>
<a name="ln1199">                             szCurHdr? szCurHdr: &quot;???&quot;, iComponent, pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F', ret);</a>
<a name="ln1200">#endif</a>
<a name="ln1201">#endif</a>
<a name="ln1202">                    goto exit_function;</a>
<a name="ln1203">                }</a>
<a name="ln1204">                /* compare new InChI to the original InChI */</a>
<a name="ln1205">                if ( pStruct-&gt;bMobileH == TAUT_NON ) {</a>
<a name="ln1206">                    iRevrInChI = (pStruct-&gt;pOneINChI[1] &amp;&amp;pStruct-&gt;pOneINChI[1]-&gt;nNumberOfAtoms &amp;&amp; !pStruct-&gt;pOneINChI[1]-&gt;bDeleted)? 1 : 0;</a>
<a name="ln1207">                } else {</a>
<a name="ln1208">                    iRevrInChI = 0;</a>
<a name="ln1209">                }</a>
<a name="ln1210">                if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; (ret = FillOutExtraFixedHDataRestr( pStruct )) ) {</a>
<a name="ln1211">                    goto exit_function;</a>
<a name="ln1212">                }</a>
<a name="ln1213">                cmpInChI = CompareReversedINChI2( pStruct-&gt;pOneINChI[iRevrInChI], pInChI[iOrigInChI], pStruct-&gt;pOneINChI_Aux[iRevrInChI], NULL, &amp;icr, &amp;err );</a>
<a name="ln1214">                nDeltaPrev = nDeltaCur;</a>
<a name="ln1215">                nDeltaCur  = icr.num_endp_in1_only;</a>
<a name="ln1216">            } else {</a>
<a name="ln1217">                break;</a>
<a name="ln1218">            }</a>
<a name="ln1219">        } while( (cmpInChI &amp; IDIF_EXTRA_TG_ENDP) &amp;&amp; at_norm &amp;&amp; nDeltaCur &amp;&amp; nDeltaCur &lt; nDeltaPrev );</a>
<a name="ln1220">    }</a>
<a name="ln1221">    /************************ case of Fixed-H ******************************************************/</a>
<a name="ln1222"> </a>
<a name="ln1223">    if ( pStruct-&gt;bMobileH == TAUT_NON ) {</a>
<a name="ln1224">        int num_tries = 0;</a>
<a name="ln1225">        do {</a>
<a name="ln1226">            if ( 0 &gt; (ret = FixFixedHRestoredStructure(ip, sd, pBNS, pBD, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1227">                                                  &amp;t_group_info, &amp;at_norm, &amp;at_prep, pInChI,</a>
<a name="ln1228">                                                  num_inp, bHasSomeFixedH, pnNumRunBNS, pnTotalDelta, forbidden_edge_mask,</a>
<a name="ln1229">                                                  forbidden_stereo_edge_mask) ) ) {</a>
<a name="ln1230">                goto exit_function;</a>
<a name="ln1231">            }</a>
<a name="ln1232">        } while( num_tries ++ &lt; 2 &amp;&amp; ret &gt; 0 );</a>
<a name="ln1233">    }</a>
<a name="ln1234">    /************************ case of Fixed-H ******************************************************/</a>
<a name="ln1235">    if ( pStruct-&gt;bMobileH == TAUT_YES ) {</a>
<a name="ln1236">        if ( 0 &gt; (ret = FixMobileHRestoredStructure(ip, sd, pBNS, pBD, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1237">                                              &amp;t_group_info, &amp;at_norm, &amp;at_prep, pInChI,</a>
<a name="ln1238">                                              num_inp, bHasSomeFixedH, pnNumRunBNS, pnTotalDelta, forbidden_edge_mask,</a>
<a name="ln1239">                                              forbidden_stereo_edge_mask) ) ) {</a>
<a name="ln1240">            goto exit_function;</a>
<a name="ln1241">        }</a>
<a name="ln1242">    }</a>
<a name="ln1243">    /**********************************************************************************************/</a>
<a name="ln1244">    /* stereo */</a>
<a name="ln1245">    cmpInChI = CompareReversedINChI2( pStruct-&gt;pOneINChI[0], pInChI[0], pStruct-&gt;pOneINChI_Aux[0], NULL /*INChI_Aux *a2*/, &amp;icr, &amp;err );</a>
<a name="ln1246">    if ( cmpInChI &amp; IDIF_PROBLEM ) {</a>
<a name="ln1247">        ret = RI_ERR_PROGR; /* severe restore problem */</a>
<a name="ln1248">        goto exit_function;</a>
<a name="ln1249">    }</a>
<a name="ln1250">    if ( err ) {</a>
<a name="ln1251">        ret = RI_ERR_ALLOC;</a>
<a name="ln1252">        goto exit_function;</a>
<a name="ln1253">    }</a>
<a name="ln1254">    cmpInChI2 = 0;</a>
<a name="ln1255">    memset ( &amp;icr2, 0, sizeof(icr2) );</a>
<a name="ln1256">    if ( iRevrInChI || iOrigInChI ) {</a>
<a name="ln1257">        /* additional mobile-H compare in case of Fixed-H */</a>
<a name="ln1258">        cmpInChI2 = CompareReversedINChI2( pStruct-&gt;pOneINChI[iRevrInChI], pInChI[iOrigInChI], pStruct-&gt;pOneINChI_Aux[iRevrInChI], NULL /*INChI_Aux *a2*/, &amp;icr2, &amp;err );</a>
<a name="ln1259">        if ( cmpInChI &amp; IDIF_PROBLEM ) {</a>
<a name="ln1260">            ret = RI_ERR_PROGR; /* severe restore problem */</a>
<a name="ln1261">            goto exit_function;</a>
<a name="ln1262">        }</a>
<a name="ln1263">        if ( err ) {</a>
<a name="ln1264">            ret = RI_ERR_ALLOC;</a>
<a name="ln1265">            goto exit_function;</a>
<a name="ln1266">        }</a>
<a name="ln1267">    }</a>
<a name="ln1268">    ret = FixRestoredStructureStereo( cmpInChI, &amp;icr, cmpInChI2, &amp;icr2,</a>
<a name="ln1269">                                          ip, sd, pBNS, pBD, pStruct, at, at2, at3, pVA, pTCGroups,</a>
<a name="ln1270">                                          &amp;t_group_info, &amp;at_norm, &amp;at_prep, pInChI,</a>
<a name="ln1271">                                          num_inp, pnNumRunBNS, pnTotalDelta, forbidden_edge_mask,</a>
<a name="ln1272">                                          forbidden_stereo_edge_mask);</a>
<a name="ln1273"> </a>
<a name="ln1274">    if ( ret &lt; 0 ) {</a>
<a name="ln1275">        goto exit_function;</a>
<a name="ln1276">    }</a>
<a name="ln1277">#if ( FIX_ADD_PROTON_FOR_ADP == 1 )</a>
<a name="ln1278">    /************************ check and fix ADP by adding a proton (dummy) *************************/</a>
<a name="ln1279">    if ( cmpInChI &amp;&amp; pTCGroups-&gt;num_tgroups &amp;&amp; pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow ) {</a>
<a name="ln1280">        ret = FixAddProtonForADP( pBNS, pBD, pStruct, at, at2, at_prep, pVA, pTCGroups, &amp;icr,</a>
<a name="ln1281">                                  pnNumRunBNS, pnTotalDelta, forbidden_edge_mask );</a>
<a name="ln1282">        if ( ret &lt; 0 ) {</a>
<a name="ln1283">            goto exit_function;</a>
<a name="ln1284">        }</a>
<a name="ln1285">    }</a>
<a name="ln1286">#endif</a>
<a name="ln1287">     /* moved to MakeOneInChIOutOfStrFromINChI():</a>
<a name="ln1288">       pStruct-&gt;nNumRemovedProtons = (pStruct-&gt;iMobileH == TAUT_YES)? pStruct-&gt;One_ti.tni.nNumRemovedProtons : 0;</a>
<a name="ln1289">     */</a>
<a name="ln1290"> </a>
<a name="ln1291">    /* count endpoints */</a>
<a name="ln1292">    num_endpoints      = 0;</a>
<a name="ln1293">    num_norm_endpoints = 0;</a>
<a name="ln1294">    num_norm_t_groups  = 0;</a>
<a name="ln1295">    num_mobile         = 0;</a>
<a name="ln1296">    num_norm_mobile    = 0;</a>
<a name="ln1297">    at_norm            = pStruct-&gt;pOne_norm_data[0]-&gt;at;</a>
<a name="ln1298">    for ( i = 0; i &lt; pTCGroups-&gt;num_tgroups; i ++ ) {</a>
<a name="ln1299">        num_endpoints += pTCGroups-&gt;pTCG[i].num_edges;</a>
<a name="ln1300">        num_mobile    += pTCGroups-&gt;pTCG[i].tg_num_H + pTCGroups-&gt;pTCG[i].tg_num_Minus;</a>
<a name="ln1301">    }</a>
<a name="ln1302"> </a>
<a name="ln1303">    if ( t_group_info ) {</a>
<a name="ln1304">        /* after canonicalization, t_group_info-&gt;t_group[i].num[0] = number of H   */</a>
<a name="ln1305">        /*                         t_group_info-&gt;t_group[i].num[1] = number of (-) */</a>
<a name="ln1306">        for ( i = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln1307">            if ( t_group_info-&gt;t_group[i].num[0] ) {</a>
<a name="ln1308">                num_norm_t_groups ++;</a>
<a name="ln1309">                num_norm_endpoints += t_group_info-&gt;t_group[i].nNumEndpoints;</a>
<a name="ln1310">                num_norm_mobile    += t_group_info-&gt;t_group[i].num[0]+t_group_info-&gt;t_group[i].num[1];</a>
<a name="ln1311">            }</a>
<a name="ln1312">        }</a>
<a name="ln1313">    }</a>
<a name="ln1314">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln1315">#ifndef TARGET_API_LIB</a>
<a name="ln1316">    if ( num_norm_t_groups != pTCGroups-&gt;num_tgroups || num_norm_endpoints != num_endpoints ) {</a>
<a name="ln1317">        /* need aggressive (de)protonation */</a>
<a name="ln1318">        /* pStruct-&gt;bExtract |= EXTRACT_STRUCT_NUMBER; */</a>
<a name="ln1319">        fprintf( stdout, &quot;NORMCOMP: %s comp=%d %c%c: InChI/NormRvrs NumTg=%d/%d NumEndp=%d/%d\n&quot;,</a>
<a name="ln1320">                 (*ip).pSdfValue, (*pTCGroups).iComponent,</a>
<a name="ln1321">                 pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F',</a>
<a name="ln1322">                 pTCGroups-&gt;num_tgroups, num_norm_t_groups,</a>
<a name="ln1323">                 num_endpoints, num_norm_endpoints ); </a>
<a name="ln1324">        </a>
<a name="ln1325">    }</a>
<a name="ln1326">#endif</a>
<a name="ln1327">#endif</a>
<a name="ln1328"> </a>
<a name="ln1329">exit_function:</a>
<a name="ln1330">    </a>
<a name="ln1331">    for( i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln1332">        Free_INChI( &amp;pStruct-&gt;pOneINChI[i] );</a>
<a name="ln1333">        Free_INChI_Aux( &amp;pStruct-&gt;pOneINChI_Aux[i] );</a>
<a name="ln1334">        FreeInpAtomData( pStruct-&gt;pOne_norm_data[i] );</a>
<a name="ln1335">        if ( pStruct-&gt;pOne_norm_data[i] ) {</a>
<a name="ln1336">            inchi_free( pStruct-&gt;pOne_norm_data[i] );</a>
<a name="ln1337">            pStruct-&gt;pOne_norm_data[i] = NULL;</a>
<a name="ln1338">        }</a>
<a name="ln1339">    }</a>
<a name="ln1340">    free_t_group_info( &amp;pStruct-&gt;One_ti );</a>
<a name="ln1341">    return ret;</a>
<a name="ln1342">}</a>
<a name="ln1343">/******************************************************************************************************/</a>
<a name="ln1344">/* Find A=X&lt; where all bonds to X except A=X are marked as stereogenic; temporary allow stereobonds   */</a>
<a name="ln1345">/* change and make A=X bonds single                                                                   */</a>
<a name="ln1346">int CheckAndRefixStereobonds(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln1347">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln1348">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln1349">{</a>
<a name="ln1350">    int forbidden_edge_stereo     = BNS_EDGE_FORBIDDEN_MASK;</a>
<a name="ln1351">    int inv_forbidden_edge_stereo = ~forbidden_edge_stereo;</a>
<a name="ln1352"> </a>
<a name="ln1353">    int i, k, ne, j1, j2, num_wrong, num_fixed;</a>
<a name="ln1354">    int ret2, retBNS, ret;</a>
<a name="ln1355">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln1356">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln1357">    int len_at = num_at + num_deleted_H;</a>
<a name="ln1358">    EDGE_LIST FixedEdges, WrongEdges, CarbonChargeEdges;</a>
<a name="ln1359"> </a>
<a name="ln1360">    BNS_EDGE   *pEdge;</a>
<a name="ln1361">    Vertex      v1, v2;</a>
<a name="ln1362">    BNS_VERTEX *pv1, *pv2;</a>
<a name="ln1363"> </a>
<a name="ln1364">    ret = 0;</a>
<a name="ln1365"> </a>
<a name="ln1366">    /* to simplify, prepare new at[] from pBNS */</a>
<a name="ln1367">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln1368">    pStruct-&gt;at = at2;</a>
<a name="ln1369">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln1370">    pStruct-&gt;at = at;</a>
<a name="ln1371">    if ( ret2 &lt; 0 ) {</a>
<a name="ln1372">        return ret;</a>
<a name="ln1373">    }</a>
<a name="ln1374"> </a>
<a name="ln1375">    num_wrong = 0;</a>
<a name="ln1376">    /* find wrong double bonds */</a>
<a name="ln1377">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1378">        if ( at2[i].valence == 3 &amp;&amp;</a>
<a name="ln1379">             at2[i].chem_bonds_valence - at2[i].valence == 1 &amp;&amp;</a>
<a name="ln1380">             at2[i].sb_parity[0] &amp;&amp; at2[i].sb_parity[1] &amp;&amp; !at2[i].sb_parity[2] &amp;&amp;</a>
<a name="ln1381">             (at2[i].bond_type[j1=(int)at2[i].sb_ord[0]] &amp; BOND_TYPE_MASK) == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1382">             (at2[i].bond_type[j2=(int)at2[i].sb_ord[1]] &amp; BOND_TYPE_MASK) == BOND_TYPE_SINGLE  &amp;&amp;</a>
<a name="ln1383">             j1 != j2 ) {</a>
<a name="ln1384"> </a>
<a name="ln1385">            num_wrong ++;</a>
<a name="ln1386">        }</a>
<a name="ln1387">    }</a>
<a name="ln1388">    if ( !num_wrong ) {</a>
<a name="ln1389">        return 0;</a>
<a name="ln1390">    }</a>
<a name="ln1391">    num_fixed = 0;</a>
<a name="ln1392">    for ( i = 0; i &lt; pBNS-&gt;num_bonds; i ++ ) {</a>
<a name="ln1393">        pEdge = pBNS-&gt;edge + i;</a>
<a name="ln1394">        if ( pEdge-&gt;forbidden &amp; forbidden_edge_stereo ) {</a>
<a name="ln1395">            num_fixed ++;</a>
<a name="ln1396">        }</a>
<a name="ln1397">    }</a>
<a name="ln1398"> </a>
<a name="ln1399">    /* there may be no fixed stereo bonds at all, see #87607 */</a>
<a name="ln1400">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1401">    AllocEdgeList( &amp;FixedEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1402">    AllocEdgeList( &amp;WrongEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1403"> </a>
<a name="ln1404">    /* do not goto exit_function before reaching this point: EdgeLists have not been initiated */</a>
<a name="ln1405"> </a>
<a name="ln1406">    if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, forbidden_edge_mask ))) {</a>
<a name="ln1407">        goto exit_function;</a>
<a name="ln1408">    }</a>
<a name="ln1409">    if ( (ret = AllocEdgeList( &amp;FixedEdges, num_fixed )) ||</a>
<a name="ln1410">         (ret = AllocEdgeList( &amp;WrongEdges, num_wrong )) ) {</a>
<a name="ln1411">        goto exit_function;</a>
<a name="ln1412">    }</a>
<a name="ln1413">    /* collect wrong double bonds and set flow=0 */</a>
<a name="ln1414">    for ( i = 0; i &lt; num_at &amp;&amp; WrongEdges.num_edges &lt; num_wrong; i ++ ) {</a>
<a name="ln1415">        if ( at2[i].valence == 3 &amp;&amp;</a>
<a name="ln1416">             at2[i].chem_bonds_valence - at2[i].valence == 1 &amp;&amp;</a>
<a name="ln1417">             at2[i].sb_parity[0] &amp;&amp; at2[i].sb_parity[1] &amp;&amp; !at2[i].sb_parity[2] &amp;&amp;</a>
<a name="ln1418">             (at2[i].bond_type[j1=(int)at2[i].sb_ord[0]] &amp; BOND_TYPE_MASK) == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1419">             (at2[i].bond_type[j2=(int)at2[i].sb_ord[1]] &amp; BOND_TYPE_MASK) == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1420">             j1 != j2 ) {</a>
<a name="ln1421">            switch ( j1 + j2 ) {</a>
<a name="ln1422">            case 1: /* 0, 1 */</a>
<a name="ln1423">                k = 2;</a>
<a name="ln1424">                break;</a>
<a name="ln1425">            case 2: /* 0, 2 */</a>
<a name="ln1426">                k = 1;</a>
<a name="ln1427">                break;</a>
<a name="ln1428">            case 3: /* 1, 2 */</a>
<a name="ln1429">                k = 0;</a>
<a name="ln1430">                break;</a>
<a name="ln1431">            default:</a>
<a name="ln1432">                ret = RI_ERR_PROGR;</a>
<a name="ln1433">                goto exit_function;</a>
<a name="ln1434">            }</a>
<a name="ln1435">            ne = pBNS-&gt;vert[i].iedge[k];</a>
<a name="ln1436">            pEdge = pBNS-&gt;edge + ne;</a>
<a name="ln1437">            v1 = pEdge-&gt;neighbor1;</a>
<a name="ln1438">            v2 = pEdge-&gt;neighbor12 ^ v1;</a>
<a name="ln1439">            pv1 = pBNS-&gt;vert + v1;</a>
<a name="ln1440">            pv2 = pBNS-&gt;vert + v2;</a>
<a name="ln1441"> </a>
<a name="ln1442">            if ( !pEdge-&gt;flow ) {</a>
<a name="ln1443">                ret = RI_ERR_PROGR;</a>
<a name="ln1444">                goto exit_function;</a>
<a name="ln1445">            }</a>
<a name="ln1446">            pEdge-&gt;flow --;</a>
<a name="ln1447">            pEdge-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln1448">            pv1-&gt;st_edge.flow --;</a>
<a name="ln1449">            pv2-&gt;st_edge.flow --;</a>
<a name="ln1450">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln1451">            if ( (ret = AddToEdgeList( &amp;WrongEdges, ne, 0 )) ) {</a>
<a name="ln1452">                goto exit_function;</a>
<a name="ln1453">            }</a>
<a name="ln1454">        }</a>
<a name="ln1455">    }</a>
<a name="ln1456">    /* remove forbidden mark from stereo bonds (unfix stereo bonds) */</a>
<a name="ln1457">    for ( i = 0; i &lt; pBNS-&gt;num_bonds &amp;&amp; FixedEdges.num_edges &lt; num_fixed; i ++ ) {</a>
<a name="ln1458">        pEdge = pBNS-&gt;edge + i;</a>
<a name="ln1459">        if ( pEdge-&gt;forbidden &amp; forbidden_edge_stereo ) {</a>
<a name="ln1460">            pEdge-&gt;forbidden &amp;= inv_forbidden_edge_stereo;</a>
<a name="ln1461">            FixedEdges.pnEdges[FixedEdges.num_edges ++] = i;</a>
<a name="ln1462">        }</a>
<a name="ln1463">    }</a>
<a name="ln1464">    /* Run BNS to move charges and rearrange bond orders */</a>
<a name="ln1465">    retBNS = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1466">    (*pnNumRunBNS) ++;</a>
<a name="ln1467">    if ( retBNS &lt; 0 ) {</a>
<a name="ln1468">        goto exit_function;</a>
<a name="ln1469">    } else</a>
<a name="ln1470">    if ( retBNS &gt; 0 ) {</a>
<a name="ln1471">        *pnTotalDelta += retBNS;</a>
<a name="ln1472">    }</a>
<a name="ln1473">    /* remove forbidden_edge_mask and set forbidden_edge_stereo */</a>
<a name="ln1474">    RemoveForbiddenEdgeMask( pBNS, &amp;WrongEdges, forbidden_edge_mask );</a>
<a name="ln1475">    /* allow carbon charges to change */</a>
<a name="ln1476">    RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, forbidden_edge_mask );</a>
<a name="ln1477">    /* fix previously unfixed stereo bonds */</a>
<a name="ln1478">    SetForbiddenEdgeMask( pBNS, &amp;FixedEdges, forbidden_edge_stereo );</a>
<a name="ln1479">    /* Run BNS again in case not all edge flows are maximal */</a>
<a name="ln1480">    ret2 = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1481">    (*pnNumRunBNS) ++;</a>
<a name="ln1482">    if ( ret2 &lt; 0 ) {</a>
<a name="ln1483">        goto exit_function;</a>
<a name="ln1484">    } else</a>
<a name="ln1485">    if ( ret2 &gt; 0 ) {</a>
<a name="ln1486">        *pnTotalDelta += retBNS;</a>
<a name="ln1487">    }</a>
<a name="ln1488">    ret = retBNS;</a>
<a name="ln1489"> </a>
<a name="ln1490">exit_function:</a>
<a name="ln1491"> </a>
<a name="ln1492">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln1493">    AllocEdgeList( &amp;FixedEdges, EDGE_LIST_FREE );</a>
<a name="ln1494">    AllocEdgeList( &amp;WrongEdges, EDGE_LIST_FREE );</a>
<a name="ln1495"> </a>
<a name="ln1496">    return ret;</a>
<a name="ln1497">}</a>
<a name="ln1498">/******************************************************************************************************/</a>
<a name="ln1499">/* Find and eliminate false Mobile-H groups: Cl(=O)3(-O(-)) =&gt; Cl(-)(=O)4                             */</a>
<a name="ln1500">int MoveChargeToRemoveCenerpoints(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln1501">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln1502">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln1503">{</a>
<a name="ln1504">    int i, j, neigh, num_endpoints, num_success;</a>
<a name="ln1505">    int num_donors, num_acceptors, bond_type, num_donors_O, num_acceptors_O, is_centerpoint_N, num_known_endpoints, num_wrong_neigh;</a>
<a name="ln1506">    int ret2, ret_forbid_edges, ret, delta;</a>
<a name="ln1507">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln1508">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln1509">    int len_at = num_at + num_deleted_H;</a>
<a name="ln1510">    int forbidden_edge_test = BNS_EDGE_FORBIDDEN_TEST;</a>
<a name="ln1511">    int bPossiblyIgnore = pStruct-&gt;charge &gt;= 0 &amp;&amp; (!pTCGroups-&gt;num_tgroups || (pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; pStruct-&gt;ti.num_t_groups));</a>
<a name="ln1512">    S_CHAR MobileChargeNeigh[MAXVAL], DoubleBondAcceptors[MAXVAL], DoubleBondNotONeigh[MAXVAL];</a>
<a name="ln1513">    int    numMobileChargeNeigh, numDoubleBondAcceptors, numDoubleBondNotONeigh, numOtherDoubleBondOAcceptors=0;</a>
<a name="ln1514">    EDGE_LIST ChargeListAllExcept_DB_O;</a>
<a name="ln1515"> </a>
<a name="ln1516"> </a>
<a name="ln1517">    BNS_EDGE   *pEdgeMinus, *pe;</a>
<a name="ln1518">    Vertex      v1m, v2m;</a>
<a name="ln1519">    BNS_VERTEX *pv1m, *pv2m;</a>
<a name="ln1520">    ret = 0;</a>
<a name="ln1521">    num_success = 0;</a>
<a name="ln1522"> </a>
<a name="ln1523">    /* count O(+)H, N(+)H */</a>
<a name="ln1524"> </a>
<a name="ln1525">    /*</a>
<a name="ln1526">    if ( pStruct-&gt;charge &gt;= 0 &amp;&amp; (!pTCGroups-&gt;num_tgroups || pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; pStruct-&gt;ti.num_t_groups) ) {</a>
<a name="ln1527">        goto exit_function;</a>
<a name="ln1528">    }</a>
<a name="ln1529">    */</a>
<a name="ln1530">    if ( (ret = AllocEdgeList( &amp;ChargeListAllExcept_DB_O, EDGE_LIST_CLEAR )) ) {</a>
<a name="ln1531">        goto exit_function;</a>
<a name="ln1532">    }</a>
<a name="ln1533"> </a>
<a name="ln1534"> </a>
<a name="ln1535">    /* to simplify, prepare new at[] from pBNS */</a>
<a name="ln1536">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln1537">    pStruct-&gt;at = at2;</a>
<a name="ln1538">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln1539">    pStruct-&gt;at = at;</a>
<a name="ln1540">    if ( ret2 &lt; 0 ) {</a>
<a name="ln1541">        ret = ret2;</a>
<a name="ln1542">        goto exit_function;</a>
<a name="ln1543">    }</a>
<a name="ln1544">#if ( FIND_RING_SYSTEMS == 1 )</a>
<a name="ln1545">    ret2 = MarkRingSystemsInp( at2, num_at, 0 );</a>
<a name="ln1546">    if ( ret2 &lt; 0 ) {</a>
<a name="ln1547">        ret = ret2;</a>
<a name="ln1548">        goto exit_function;</a>
<a name="ln1549">    }</a>
<a name="ln1550">#endif</a>
<a name="ln1551">    /* mark bonds that cannot be tautomeric; do not forget to remove the marks later */</a>
<a name="ln1552">    ret_forbid_edges = SetForbiddenEdges( pBNS, at2, num_at, forbidden_edge_test );</a>
<a name="ln1553">    if ( ret_forbid_edges &lt; 0 ) {</a>
<a name="ln1554">        ret = ret_forbid_edges;</a>
<a name="ln1555">        goto exit_function;</a>
<a name="ln1556">    }</a>
<a name="ln1557"> </a>
<a name="ln1558">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1559">        if ( pVA[i].cNumValenceElectrons != 4 &amp;&amp; /* not C, Si, Ge */</a>
<a name="ln1560">             !(pVA[i].nTautGroupEdge || (pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;endpoint[i]) ) &amp;&amp;</a>
<a name="ln1561">             !at2[i].num_H &amp;&amp; !at2[i].charge &amp;&amp; at2[i].valence &gt;= 2 &amp;&amp;</a>
<a name="ln1562">             at2[i].valence &lt; at2[i].chem_bonds_valence &amp;&amp;</a>
<a name="ln1563">             is_centerpoint_elem( at2[i].el_number ) ) {</a>
<a name="ln1564">            </a>
<a name="ln1565">            is_centerpoint_N = (pVA[i].cNumValenceElectrons == 5 &amp;&amp; (pVA[i].cPeriodicRowNumber == 1 || pVA[i].cMetal));</a>
<a name="ln1566">            /* look at the neighbors */</a>
<a name="ln1567">            numMobileChargeNeigh = numDoubleBondAcceptors = numDoubleBondNotONeigh = num_donors = num_acceptors = 0;</a>
<a name="ln1568">            num_donors_O = num_acceptors_O = 0;</a>
<a name="ln1569">            num_known_endpoints = num_wrong_neigh = 0;</a>
<a name="ln1570">            for ( j = 0, num_endpoints = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln1571">                neigh = at2[i].neighbor[j];</a>
<a name="ln1572">                if ( (at2[neigh].endpoint || (pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;endpoint[neigh])) ||</a>
<a name="ln1573">                      at2[neigh].charge &gt; 0 ) {</a>
<a name="ln1574">                    num_known_endpoints ++;</a>
<a name="ln1575">                    continue;</a>
<a name="ln1576">                }</a>
<a name="ln1577">                if ( pBNS-&gt;edge[pBNS-&gt;vert[i].iedge[j]].forbidden &amp; forbidden_edge_test ) {</a>
<a name="ln1578">                    continue;</a>
<a name="ln1579">                }</a>
<a name="ln1580">                bond_type = at2[i].bond_type[j] &amp; BOND_TYPE_MASK;</a>
<a name="ln1581">                if ( bond_type &gt; BOND_TYPE_DOUBLE ) {</a>
<a name="ln1582">                    num_wrong_neigh ++;</a>
<a name="ln1583">                    continue;</a>
<a name="ln1584">                }</a>
<a name="ln1585">                if ( at2[neigh].num_H &amp;&amp; bond_type == BOND_TYPE_SINGLE ) {</a>
<a name="ln1586">                    break;  /* not this case */</a>
<a name="ln1587">                }</a>
<a name="ln1588">                if ( at2[neigh].chem_bonds_valence - at2[neigh].charge</a>
<a name="ln1589">                     != get_endpoint_valence( at2[neigh].el_number ) ) {</a>
<a name="ln1590">                    if ( bond_type == BOND_TYPE_DOUBLE &amp;&amp; pVA[neigh].cNumValenceElectrons != 6 ) {</a>
<a name="ln1591">                        DoubleBondNotONeigh[numDoubleBondNotONeigh ++] = j;</a>
<a name="ln1592">                    }</a>
<a name="ln1593">                    continue;</a>
<a name="ln1594">                }</a>
<a name="ln1595">                if ( at2[neigh].charge == -1 &amp;&amp; bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1596">                     (pVA[neigh].nCMinusGroupEdge &lt; 1 || pBNS-&gt;edge[pVA[neigh].nCMinusGroupEdge-1].flow != 1)  ) {</a>
<a name="ln1597">                    break;</a>
<a name="ln1598">                }</a>
<a name="ln1599">                switch( bond_type ) {</a>
<a name="ln1600">                case BOND_TYPE_SINGLE:</a>
<a name="ln1601">                    if ( at2[neigh].charge != -1 || pVA[neigh].nCMinusGroupEdge &lt;= 0 ) {</a>
<a name="ln1602">                        num_wrong_neigh ++;</a>
<a name="ln1603">                        continue;</a>
<a name="ln1604">                    }</a>
<a name="ln1605">                    num_donors ++;</a>
<a name="ln1606">                    num_donors_O += (pVA[neigh].cNumValenceElectrons == 6 &amp;&amp; pVA[neigh].cPeriodicRowNumber &lt;= 4);</a>
<a name="ln1607">                    MobileChargeNeigh[numMobileChargeNeigh ++] = j;</a>
<a name="ln1608">                    break;</a>
<a name="ln1609">                case BOND_TYPE_DOUBLE:</a>
<a name="ln1610">                    if ( at2[neigh].charge ) {</a>
<a name="ln1611">                        num_wrong_neigh ++;</a>
<a name="ln1612">                        continue;</a>
<a name="ln1613">                    }</a>
<a name="ln1614">                    DoubleBondAcceptors[numDoubleBondAcceptors ++]  = j;</a>
<a name="ln1615">                    num_acceptors ++;</a>
<a name="ln1616">                    num_acceptors_O += (pVA[neigh].cNumValenceElectrons == 6 &amp;&amp; pVA[neigh].cPeriodicRowNumber &lt;= 4);</a>
<a name="ln1617">                }</a>
<a name="ln1618">            }</a>
<a name="ln1619">            if ( j != at2[i].valence || !num_donors || !num_acceptors ) {</a>
<a name="ln1620">                continue;</a>
<a name="ln1621">            }</a>
<a name="ln1622">            /* special case NOn(-) */</a>
<a name="ln1623">            if ( is_centerpoint_N &amp;&amp; (num_donors == num_donors_O) &amp;&amp; (num_acceptors == num_acceptors_O) ) {</a>
<a name="ln1624">                continue;</a>
<a name="ln1625">            }</a>
<a name="ln1626">            if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; num_donors == numDoubleBondNotONeigh ) {</a>
<a name="ln1627">                /* fix all charges except on =O */</a>
<a name="ln1628">                Vertex     vPathStart, vPathEnd;</a>
<a name="ln1629">                int        nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln1630">                int k, e, num_MovedCharges = 0;</a>
<a name="ln1631"> </a>
<a name="ln1632">                if ( !ChargeListAllExcept_DB_O.num_edges ) {</a>
<a name="ln1633">                    numOtherDoubleBondOAcceptors = 0;</a>
<a name="ln1634">                    for ( k = 0; k &lt; num_at; k ++ ) {</a>
<a name="ln1635">                        if ( (1 == at2[k].valence &amp;&amp; pBNS-&gt;edge[pBNS-&gt;vert[k].iedge[0]].flow &amp;&amp;</a>
<a name="ln1636">                             !pBNS-&gt;edge[pBNS-&gt;vert[k].iedge[0]].forbidden &amp;&amp;</a>
<a name="ln1637">                             !((e=pVA[k].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; pBNS-&gt;edge[e].flow) &amp;&amp;</a>
<a name="ln1638">                             !((e=pVA[k].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].flow) &amp;&amp;</a>
<a name="ln1639">                             /* 0 == at2[k].charge &amp;&amp; */</a>
<a name="ln1640">                             pVA[k].cNumValenceElectrons == 6 &amp;&amp; !pVA[k].cMetal &amp;&amp;</a>
<a name="ln1641">                             pStruct-&gt;endpoint &amp;&amp; pStruct-&gt;endpoint[k]) ||</a>
<a name="ln1642">                             (pStruct-&gt;fixed_H &amp;&amp; pStruct-&gt;fixed_H[k]) ) {</a>
<a name="ln1643">                            numOtherDoubleBondOAcceptors ++;  /* do not fix this minus edge */</a>
<a name="ln1644">                        } else</a>
<a name="ln1645">                        if ( (e=pVA[k].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[e].flow &amp;&amp;</a>
<a name="ln1646">                             !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln1647">                             ( ret = AddToEdgeList( &amp;ChargeListAllExcept_DB_O, e, 64 )) ) {</a>
<a name="ln1648">                            goto exit_function;</a>
<a name="ln1649">                        }</a>
<a name="ln1650">                        if ( (e=pVA[k].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp;</a>
<a name="ln1651">                             !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln1652">                             ( ret = AddToEdgeList( &amp;ChargeListAllExcept_DB_O, e, 64 )) ) {</a>
<a name="ln1653">                            goto exit_function;</a>
<a name="ln1654">                        }</a>
<a name="ln1655">                    }</a>
<a name="ln1656">                }</a>
<a name="ln1657">                /* fix double bonds to non-O neighbors connected by double bonds;</a>
<a name="ln1658">                   we will try to make these bons single */</a>
<a name="ln1659">                for ( k = 0; k &lt; numDoubleBondNotONeigh; k ++ ) {</a>
<a name="ln1660">                    e = pBNS-&gt;vert[i].iedge[(int)DoubleBondNotONeigh[k]];</a>
<a name="ln1661">                    if ( !pBNS-&gt;edge[e].forbidden &amp;&amp;</a>
<a name="ln1662">                         (ret = AddToEdgeList( &amp;ChargeListAllExcept_DB_O, e, 64 ))) {</a>
<a name="ln1663">                        goto exit_function;</a>
<a name="ln1664">                    }</a>
<a name="ln1665">                }</a>
<a name="ln1666">                /* attempt to make DoubleBondNotONeigh[] single */</a>
<a name="ln1667">                SetForbiddenEdgeMask( pBNS, &amp;ChargeListAllExcept_DB_O, forbidden_edge_mask);</a>
<a name="ln1668">                for ( k = 0; k &lt; numDoubleBondNotONeigh &amp;&amp; num_MovedCharges &lt; numMobileChargeNeigh; k ++ ) {</a>
<a name="ln1669">                    pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[(int)DoubleBondNotONeigh[k]];</a>
<a name="ln1670">                    delta = 1;</a>
<a name="ln1671">                    if ( pe-&gt;flow != delta )</a>
<a name="ln1672">                        continue;</a>
<a name="ln1673">                    pv1m = pBNS-&gt;vert + (v1m = pe-&gt;neighbor1);</a>
<a name="ln1674">                    pv2m = pBNS-&gt;vert + (v2m = pe-&gt;neighbor12 ^ v1m);</a>
<a name="ln1675">                    pv1m-&gt;st_edge.flow -= delta;</a>
<a name="ln1676">                    pv2m-&gt;st_edge.flow -= delta;</a>
<a name="ln1677">                    pe-&gt;flow           -= delta;</a>
<a name="ln1678">                    pBNS-&gt;tot_st_flow  -= 2*delta;</a>
<a name="ln1679">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln1680">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln1681">                    if ( ret &lt; 0 ) {</a>
<a name="ln1682">                        goto exit_function;</a>
<a name="ln1683">                    }</a>
<a name="ln1684">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1m &amp;&amp; vPathStart == v2m) ||</a>
<a name="ln1685">                                      (vPathEnd == v2m &amp;&amp; vPathStart == v1m)) &amp;&amp;</a>
<a name="ln1686">                                      nDeltaCharge == 0  /* (-) moving from one to another atom*/ ) {</a>
<a name="ln1687">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1688">                        (*pnNumRunBNS) ++;</a>
<a name="ln1689">                        if ( ret &lt; 0 ) {</a>
<a name="ln1690">                            goto exit_function;</a>
<a name="ln1691">                        } else</a>
<a name="ln1692">                        if ( ret == 1 ) {</a>
<a name="ln1693">                            *pnTotalDelta += ret;</a>
<a name="ln1694">                            num_MovedCharges ++;</a>
<a name="ln1695">                        } else {</a>
<a name="ln1696">                            ret = RI_ERR_PROGR;</a>
<a name="ln1697">                            goto exit_function;</a>
<a name="ln1698">                        }</a>
<a name="ln1699">                    } else {</a>
<a name="ln1700">                        ret = 0;</a>
<a name="ln1701">                        pv1m-&gt;st_edge.flow += delta;</a>
<a name="ln1702">                        pv2m-&gt;st_edge.flow += delta;</a>
<a name="ln1703">                        pe-&gt;flow           += delta;</a>
<a name="ln1704">                        pBNS-&gt;tot_st_flow  += 2*delta;</a>
<a name="ln1705">                    }</a>
<a name="ln1706">                }</a>
<a name="ln1707">                RemoveForbiddenEdgeMask( pBNS, &amp;ChargeListAllExcept_DB_O, forbidden_edge_mask);</a>
<a name="ln1708">            } else</a>
<a name="ln1709">            if ( !bPossiblyIgnore || (!num_known_endpoints &amp;&amp; !num_wrong_neigh &amp;&amp; (num_acceptors_O + num_donors_O) &gt;=3)  ) {</a>
<a name="ln1710">                /* remove negative charges from the neighbors */</a>
<a name="ln1711">                pBNS-&gt;vert[i].st_edge.cap += num_donors; /* enough to make all bonds to donors double */</a>
<a name="ln1712">                pBNS-&gt;tot_st_cap          += num_donors;</a>
<a name="ln1713">                pVA[i].cInitCharge        -= num_donors; /* work no matter what are known charge/valence */</a>
<a name="ln1714">                for ( j = 0; j &lt; numMobileChargeNeigh; j ++ ) {</a>
<a name="ln1715">                    neigh = at2[i].neighbor[ (int)MobileChargeNeigh[j] ];</a>
<a name="ln1716">                    pEdgeMinus = pBNS-&gt;edge + (pVA[neigh].nCMinusGroupEdge-1);</a>
<a name="ln1717">                    v1m   = pEdgeMinus-&gt;neighbor1;</a>
<a name="ln1718">                    v2m   = pEdgeMinus-&gt;neighbor12 ^ v1m;</a>
<a name="ln1719">                    pv1m  = pBNS-&gt;vert + v1m;</a>
<a name="ln1720">                    pv2m  = pBNS-&gt;vert + v2m;</a>
<a name="ln1721">                    delta = pEdgeMinus-&gt;flow;</a>
<a name="ln1722">                    pv1m-&gt;st_edge.flow -= delta;</a>
<a name="ln1723">                    pv2m-&gt;st_edge.flow -= delta;</a>
<a name="ln1724">                    if ( IS_BNS_VT_C_GR( pv1m-&gt;type ) ) {</a>
<a name="ln1725">                        /* irreversible change to ChargeStruct */</a>
<a name="ln1726">                        pv1m-&gt;st_edge.cap -= delta;</a>
<a name="ln1727">                    } else</a>
<a name="ln1728">                    if ( IS_BNS_VT_C_GR( pv2m-&gt;type ) ) {</a>
<a name="ln1729">                        /* irreversible change to ChargeStruct */</a>
<a name="ln1730">                        pv2m-&gt;st_edge.cap -= delta;</a>
<a name="ln1731">                    } else {</a>
<a name="ln1732">                        ret = RI_ERR_PROGR;</a>
<a name="ln1733">                        goto exit_function;</a>
<a name="ln1734">                    }</a>
<a name="ln1735">                    pBNS-&gt;tot_st_cap  -=   delta;</a>
<a name="ln1736">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln1737">                    pEdgeMinus-&gt;flow  -= delta;</a>
<a name="ln1738">                }</a>
<a name="ln1739">                ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1740">                (*pnNumRunBNS) ++;</a>
<a name="ln1741">                if ( ret &lt; 0 ) {</a>
<a name="ln1742">                    goto exit_function;</a>
<a name="ln1743">                } else</a>
<a name="ln1744">                if ( ret == num_donors ) {</a>
<a name="ln1745">                    *pnTotalDelta += ret;</a>
<a name="ln1746">                    num_success ++;</a>
<a name="ln1747">                    /*pStruct-&gt;bExtract |= EXTRACT_STRUCT_NUMBER;*/</a>
<a name="ln1748">                } else {</a>
<a name="ln1749">                    ret = RI_ERR_PROGR;</a>
<a name="ln1750">                    goto exit_function;</a>
<a name="ln1751">                }</a>
<a name="ln1752">            }</a>
<a name="ln1753">        }</a>
<a name="ln1754">    }</a>
<a name="ln1755">    if ( ret_forbid_edges ) {</a>
<a name="ln1756">        /* remove the marks */</a>
<a name="ln1757">        RemoveForbiddenBondFlowBits( pBNS, forbidden_edge_test );</a>
<a name="ln1758">    }</a>
<a name="ln1759">    ret = num_success;</a>
<a name="ln1760">exit_function:</a>
<a name="ln1761">    AllocEdgeList( &amp;ChargeListAllExcept_DB_O, EDGE_LIST_FREE );</a>
<a name="ln1762">    return ret;</a>
<a name="ln1763">}</a>
<a name="ln1764">/******************************************************************************************************/</a>
<a name="ln1765">/* Find and eliminate cases when Mobile H endpoint has radical on it (typical for wrong P(VI)(=O)3OH  */</a>
<a name="ln1766">int MakeSingleBondsMetal2ChargedHeteroat(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln1767">                              inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln1768">                              int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln1769">{</a>
<a name="ln1770">    int i;</a>
<a name="ln1771">    </a>
<a name="ln1772">    int ret2, ret, pass;</a>
<a name="ln1773">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln1774">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln1775">    int len_at = num_at + num_deleted_H;</a>
<a name="ln1776">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln1777"> </a>
<a name="ln1778">    int         j, k;</a>
<a name="ln1779">    int        cur_num_edges;</a>
<a name="ln1780">    BNS_EDGE  *e;</a>
<a name="ln1781">    Vertex     v1, v2;</a>
<a name="ln1782"> </a>
<a name="ln1783">    EdgeIndex *pFixedEdges;</a>
<a name="ln1784">    int        nNumEdgesToFix;</a>
<a name="ln1785">    </a>
<a name="ln1786">    ret = 0;</a>
<a name="ln1787"> </a>
<a name="ln1788">    /* to simplify, prepare new at[] from pBNS */</a>
<a name="ln1789">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln1790">    pStruct-&gt;at = at2;</a>
<a name="ln1791">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln1792">    pStruct-&gt;at = at;</a>
<a name="ln1793">    if ( ret2 &lt; 0 ) {</a>
<a name="ln1794">        ret = ret2;</a>
<a name="ln1795">        goto exit_function;</a>
<a name="ln1796">    }</a>
<a name="ln1797"> </a>
<a name="ln1798">    pFixedEdges = NULL;</a>
<a name="ln1799"> </a>
<a name="ln1800">    nNumEdgesToFix = 0; /* cpunt nNumEdgesToFix only when pass==0 */</a>
<a name="ln1801">    cur_num_edges  = 0; /* count cur_num_edges  only when pass==1; at the end they must be equal */</a>
<a name="ln1802">    for ( pass = 0; pass &lt; 2; pass ++ ) {</a>
<a name="ln1803">        if ( pass ) {</a>
<a name="ln1804">            /* 2nd pass: allocate edge storage */</a>
<a name="ln1805">            if ( !nNumEdgesToFix ) {</a>
<a name="ln1806">                break; /* nothing to do */</a>
<a name="ln1807">            }</a>
<a name="ln1808">            pFixedEdges = (EdgeIndex *) inchi_malloc(nNumEdgesToFix * sizeof( pFixedEdges[0] ) );</a>
<a name="ln1809">            if ( !pFixedEdges ) {</a>
<a name="ln1810">                ret = RI_ERR_ALLOC;</a>
<a name="ln1811">                goto exit_function;</a>
<a name="ln1812">            }</a>
<a name="ln1813">        }</a>
<a name="ln1814">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1815">            int neigh;</a>
<a name="ln1816">            if ( pVA[i].cMetal ) {</a>
<a name="ln1817">                for ( j = 0; j &lt; at2[i].valence; j ++ ) {</a>
<a name="ln1818">                    neigh = at2[i].neighbor[j];</a>
<a name="ln1819">                    if ( pVA[neigh].cNumValenceElectrons == 4 &amp;&amp;</a>
<a name="ln1820">                         pVA[neigh].cPeriodicRowNumber   == 1  ) {</a>
<a name="ln1821">                        continue; /* ignore carbon */</a>
<a name="ln1822">                    }</a>
<a name="ln1823">                    if ( at2[i].bond_type[j] &gt; BOND_TYPE_SINGLE &amp;&amp; at2[neigh].charge &amp;&amp;</a>
<a name="ln1824">                         !pVA[neigh].cMetal &amp;&amp; pVA[neigh].cnListIndex &gt; 0 ) {</a>
<a name="ln1825">                        int cnBits = at2[neigh].charge &gt; 0? MAKE_CN_BITS(cn_bits_N, cn_bits_P, 0, 0) :</a>
<a name="ln1826">                                                            MAKE_CN_BITS(cn_bits_N, cn_bits_M, 0, 0);</a>
<a name="ln1827">                        int atBits = cnList[pVA[neigh].cnListIndex-1].bits;</a>
<a name="ln1828">                        for ( k = 0; k &lt; MAX_NUM_CN_BITS-1; k ++, atBits &gt;&gt;= cn_bits_shift ) { /* ??? */</a>
<a name="ln1829">                            if ( (atBits &amp; cnBits) == cnBits ) {</a>
<a name="ln1830">                                break;</a>
<a name="ln1831">                            }</a>
<a name="ln1832">                        }</a>
<a name="ln1833">                        if ( k == MAX_NUM_CN_BITS-1 ) {</a>
<a name="ln1834">                            continue;</a>
<a name="ln1835">                        }</a>
<a name="ln1836">                        if ( pass == 0 ) {</a>
<a name="ln1837">                            nNumEdgesToFix ++;</a>
<a name="ln1838">                        } else {</a>
<a name="ln1839">                            pFixedEdges[ cur_num_edges ++ ] = pBNS-&gt;vert[i].iedge[j];</a>
<a name="ln1840">                        }</a>
<a name="ln1841">                    }</a>
<a name="ln1842">                }</a>
<a name="ln1843">            }</a>
<a name="ln1844">        }</a>
<a name="ln1845">    }</a>
<a name="ln1846">    </a>
<a name="ln1847">    /* restore the initial structures */</a>
<a name="ln1848">    memcpy( at2, at, (num_at + num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln1849"> </a>
<a name="ln1850">    if ( nNumEdgesToFix &amp;&amp; pFixedEdges ) {</a>
<a name="ln1851">        if ( nNumEdgesToFix != cur_num_edges ) {</a>
<a name="ln1852">            ret = RI_ERR_PROGR;</a>
<a name="ln1853">            goto exit_function;</a>
<a name="ln1854">        }</a>
<a name="ln1855">        /* change edge flow, fix the edges, and run BNS */</a>
<a name="ln1856">        for ( i = 0; i &lt; nNumEdgesToFix; i ++ ) {</a>
<a name="ln1857">            e = pBNS-&gt;edge + pFixedEdges[i];</a>
<a name="ln1858">            v1 = e-&gt;neighbor1;</a>
<a name="ln1859">            v2 = e-&gt;neighbor12 ^ v1;</a>
<a name="ln1860">            e-&gt;flow --;</a>
<a name="ln1861">            e-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln1862">            pBNS-&gt;vert[v1].st_edge.flow --;</a>
<a name="ln1863">            pBNS-&gt;vert[v2].st_edge.flow --;</a>
<a name="ln1864">            pBNS-&gt;tot_st_flow -= 2;</a>
<a name="ln1865">            (*pnTotalDelta) -= 2;</a>
<a name="ln1866">        }</a>
<a name="ln1867">        /* Run BNS allowing to change any charges */</a>
<a name="ln1868">        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1869">        (*pnNumRunBNS) ++;</a>
<a name="ln1870">        if ( ret &lt; 0 ) {</a>
<a name="ln1871">            goto exit_function;</a>
<a name="ln1872">        } else {</a>
<a name="ln1873">            (*pnTotalDelta) += ret;</a>
<a name="ln1874">        }</a>
<a name="ln1875">        /* unfix the edges */</a>
<a name="ln1876">        for ( i = 0; i &lt; nNumEdgesToFix; i ++ ) {</a>
<a name="ln1877">            e = pBNS-&gt;edge + pFixedEdges[i];</a>
<a name="ln1878">            e-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln1879">        }</a>
<a name="ln1880">        if ( ret &lt; 2 * nNumEdgesToFix ) {</a>
<a name="ln1881">            /* not all fixes succeeded */</a>
<a name="ln1882">            ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln1883">            (*pnNumRunBNS) ++;</a>
<a name="ln1884">            if ( ret &lt; 0 ) {</a>
<a name="ln1885">                goto exit_function;</a>
<a name="ln1886">            } else {</a>
<a name="ln1887">                (*pnTotalDelta) += ret;</a>
<a name="ln1888">            }</a>
<a name="ln1889">        }</a>
<a name="ln1890">    }</a>
<a name="ln1891">    if ( pFixedEdges ) {</a>
<a name="ln1892">        inchi_free( pFixedEdges );</a>
<a name="ln1893">        pFixedEdges = NULL;</a>
<a name="ln1894">    }</a>
<a name="ln1895"> </a>
<a name="ln1896"> </a>
<a name="ln1897">exit_function:</a>
<a name="ln1898">    return ret;</a>
<a name="ln1899">}</a>
<a name="ln1900">/**************************************************************************/</a>
<a name="ln1901">/* In Reconnected structure change 'salt bonds' to 'coordination bonds    */</a>
<a name="ln1902">/* for example, M-O-C=  -&gt;  M(+)-O(-)-C=                                  */</a>
<a name="ln1903">/* Defect: instead of NH2-C=O(+)-M it will restore NH2(+)=C-O(-)-M(+)     */</a>
<a name="ln1904">/* However, in this release metal-organic compounds do not get much care  */</a>
<a name="ln1905">int SaltBondsToCoordBonds(BN_STRUCT *pBNS, BN_DATA *pBD, StrFromINChI *pStruct,</a>
<a name="ln1906">                          inp_ATOM *at, inp_ATOM *at2, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln1907">                          int *pnNumRunBNS, int *pnTotalDelta, int forbidden_edge_mask)</a>
<a name="ln1908">{</a>
<a name="ln1909">    int i;</a>
<a name="ln1910">    </a>
<a name="ln1911">    int ret2, ret, cur_success;</a>
<a name="ln1912">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln1913">    int num_edges = pBNS-&gt;num_bonds + 2 * pBNS-&gt;num_atoms;</a>
<a name="ln1914">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln1915">    int len_at = num_at + num_deleted_H;</a>
<a name="ln1916">    int inv_forbidden_edge_mask = ~forbidden_edge_mask;</a>
<a name="ln1917">    EDGE_LIST AllChargeEdges;</a>
<a name="ln1918"> </a>
<a name="ln1919">    int         j, k, n;</a>
<a name="ln1920">    BNS_EDGE  *pe, *pePlusMetal, *peMinusO;</a>
<a name="ln1921">    BNS_VERTEX *pv1, *pv2, *pvO, *pvM;</a>
<a name="ln1922">    Vertex     v1, v2, vPlusMinus;</a>
<a name="ln1923"> </a>
<a name="ln1924">    EdgeIndex  ie, iePlusMetal, ieMinusO;</a>
<a name="ln1925">    </a>
<a name="ln1926">    Vertex     vPathStart, vPathEnd;</a>
<a name="ln1927">    int        delta, nPathLen, nDeltaH, nDeltaCharge, nNumVisitedAtoms;</a>
<a name="ln1928">    </a>
<a name="ln1929">    ret = 0;</a>
<a name="ln1930">    cur_success = 0;</a>
<a name="ln1931">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln1932"> </a>
<a name="ln1933">    if ( pStruct-&gt;iInchiRec == INCHI_BAS || !pStruct-&gt;pSrm-&gt;bMetalAddFlower || pStruct-&gt;pSrm-&gt;nMetalMinBondOrder ) {</a>
<a name="ln1934">        goto exit_function;</a>
<a name="ln1935">    }</a>
<a name="ln1936"> </a>
<a name="ln1937">    /* to simplify, prepare new at[] from pBNS */</a>
<a name="ln1938">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln1939">    pStruct-&gt;at = at2;</a>
<a name="ln1940">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln1941">    pStruct-&gt;at = at;</a>
<a name="ln1942">    if ( ret2 &lt; 0 ) {</a>
<a name="ln1943">        ret = ret2;</a>
<a name="ln1944">        goto exit_function;</a>
<a name="ln1945">    }</a>
<a name="ln1946">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1947">        if ( bIsMetalSalt( at2, i ) ) {</a>
<a name="ln1948">            if ( !AllChargeEdges.num_edges ) {</a>
<a name="ln1949">                /*--------- one-time action: fix all bonds, charges, taut. group edges ------------*/</a>
<a name="ln1950">                for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln1951">                    /* all bonds */</a>
<a name="ln1952">                    for ( k = 0; k &lt; at2[j].valence; k ++ ) {</a>
<a name="ln1953">                        n = at2[j].neighbor[k];</a>
<a name="ln1954">                        if ( n &lt; j &amp;&amp; !pBNS-&gt;edge[ie = pBNS-&gt;vert[j].iedge[k]].forbidden &amp;&amp;</a>
<a name="ln1955">                             ( ret = AddToEdgeList( &amp;AllChargeEdges, ie, num_edges ) ) ) {</a>
<a name="ln1956">                            goto exit_function;</a>
<a name="ln1957">                        }</a>
<a name="ln1958">                    }</a>
<a name="ln1959">                    /* charge edges */</a>
<a name="ln1960">                    if ( (ie=pVA[j].nCMinusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[ie].forbidden &amp;&amp;</a>
<a name="ln1961">                         (ret = AddToEdgeList( &amp;AllChargeEdges, ie, num_edges ) ) ) {</a>
<a name="ln1962">                        goto exit_function;</a>
<a name="ln1963">                    }</a>
<a name="ln1964">                    if ( (ie=pVA[j].nCPlusGroupEdge-1) &gt;= 0 &amp;&amp; !pBNS-&gt;edge[ie].forbidden &amp;&amp;</a>
<a name="ln1965">                         ( ret = AddToEdgeList( &amp;AllChargeEdges, ie, num_edges ) ) ) {</a>
<a name="ln1966">                            goto exit_function;</a>
<a name="ln1967">                    }</a>
<a name="ln1968">                }</a>
<a name="ln1969">                /* taut group edges */</a>
<a name="ln1970">                for ( j = 0; j &lt; pTCGroups-&gt;num_tgroups; j ++ ) {</a>
<a name="ln1971">                    pv1  = pBNS-&gt;vert + (v1=pTCGroups-&gt;pTCG[j].nVertexNumber); /* t-group vertex */</a>
<a name="ln1972">                    for ( k = 0; k &lt; pv1-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln1973">                        /* ie, pe - tautomeric atom edge; pv2 - endpoint vertex */</a>
<a name="ln1974">                        /* Note: pe, pv2, v1 are not used here; they are to show how to traverse t-group */</a>
<a name="ln1975">                        pv2 = pBNS-&gt;vert + (pe = pBNS-&gt;edge + (ie=pv1-&gt;iedge[k]))-&gt;neighbor1;</a>
<a name="ln1976">                        if ( (ret = AddToEdgeList( &amp;AllChargeEdges, ie, num_edges )) ) {</a>
<a name="ln1977">                            goto exit_function;</a>
<a name="ln1978">                        }</a>
<a name="ln1979">                    }</a>
<a name="ln1980">                }</a>
<a name="ln1981">                /*---------------------------------------------------------------*/</a>
<a name="ln1982">            }</a>
<a name="ln1983">            /* replace all single bonds to neutral neighbors with zero-order bonds</a>
<a name="ln1984">               allow neighbor charge change to (-1) and metal atom charge increment +1 */</a>
<a name="ln1985">            for ( k = 0; k &lt; at2[i].valence; k ++ ) {</a>
<a name="ln1986">                n  = at2[i].neighbor[k];</a>
<a name="ln1987">                pe = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[k];</a>
<a name="ln1988">                if ( at2[n].charge || at2[i].bond_type[k] != BOND_TYPE_SINGLE ) {</a>
<a name="ln1989">                    continue;</a>
<a name="ln1990">                }</a>
<a name="ln1991">                iePlusMetal = pVA[i].nCPlusGroupEdge-1;</a>
<a name="ln1992">                ieMinusO    = pVA[n].nCMinusGroupEdge-1;</a>
<a name="ln1993"> </a>
<a name="ln1994">                if ( pe-&gt;flow != 1 || pe-&gt;forbidden || iePlusMetal &lt; 0 ) {</a>
<a name="ln1995">                    continue;</a>
<a name="ln1996">                }</a>
<a name="ln1997">                pePlusMetal = pBNS-&gt;edge + iePlusMetal;</a>
<a name="ln1998">                if ( pePlusMetal-&gt;flow &lt;= 0 ) {</a>
<a name="ln1999">                    continue; /* to add (+) to metal this flow must be decremented */</a>
<a name="ln2000">                }</a>
<a name="ln2001">                if ( ieMinusO &gt;= 0 ) {</a>
<a name="ln2002">                    /* usually does not happen */</a>
<a name="ln2003">                    peMinusO    = pBNS-&gt;edge + ieMinusO;</a>
<a name="ln2004"> </a>
<a name="ln2005">                    if ( peMinusO-&gt;flow || pePlusMetal-&gt;forbidden || peMinusO-&gt;forbidden ) {</a>
<a name="ln2006">                        continue;</a>
<a name="ln2007">                    }</a>
<a name="ln2008"> </a>
<a name="ln2009">                    /* decrement bond order to 0 */</a>
<a name="ln2010">                    delta = 1;</a>
<a name="ln2011">                    pv1 = pBNS-&gt;vert + (v1 = pe-&gt;neighbor1);</a>
<a name="ln2012">                    pv2 = pBNS-&gt;vert + (v2 = pe-&gt;neighbor12 ^ v1);</a>
<a name="ln2013"> </a>
<a name="ln2014">                    pe-&gt;flow -= delta;</a>
<a name="ln2015">                    pv1-&gt;st_edge.flow -= delta;</a>
<a name="ln2016">                    pv2-&gt;st_edge.flow -= delta;</a>
<a name="ln2017">                    pBNS-&gt;tot_st_flow -= 2*delta;</a>
<a name="ln2018"> </a>
<a name="ln2019">                    SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2020">                    pePlusMetal-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln2021">                    peMinusO-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln2022"> </a>
<a name="ln2023">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2024">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2025"> </a>
<a name="ln2026">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2027">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) /*&amp;&amp; nDeltaCharge &gt; 0*/ ) {</a>
<a name="ln2028">                        /* (+)charge was just moved, no change in number of charges */</a>
<a name="ln2029">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2030">                        if ( ret &gt; 0 ) {</a>
<a name="ln2031">                            (*pnNumRunBNS) ++;</a>
<a name="ln2032">                            cur_success ++; /* 01 */</a>
<a name="ln2033">                        }</a>
<a name="ln2034">                    } else {</a>
<a name="ln2035">                        pe-&gt;flow += delta; /* roll back */</a>
<a name="ln2036">                        pv1-&gt;st_edge.flow += delta;</a>
<a name="ln2037">                        pv2-&gt;st_edge.flow += delta;</a>
<a name="ln2038">                        pBNS-&gt;tot_st_flow += 2*delta;</a>
<a name="ln2039">                    }</a>
<a name="ln2040">                    RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2041">                } else</a>
<a name="ln2042">                if ( NO_VERTEX != (vPlusMinus = GetPlusMinusVertex( pBNS, pTCGroups, 1, 1 ) ) ) {</a>
<a name="ln2043">                    /* manually add (-) charge to O and (+) charge to metal */</a>
<a name="ln2044">                    /* decrement bond order to 0 */</a>
<a name="ln2045">                    /*---------------------------------------------------------------------------*/</a>
<a name="ln2046">                    /*                                                                           */</a>
<a name="ln2047">                    /*      (+/-)*               (+/-)           Result:                         */</a>
<a name="ln2048">                    /*        |                    ||                                            */</a>
<a name="ln2049">                    /*        |                    ||            - Added (+) to M                */</a>
<a name="ln2050">                    /*       (+)super             (+)super       - Incremented bond M-O          */</a>
<a name="ln2051">                    /*        ||                   |                                             */</a>
<a name="ln2052">                    /*        ||          =&gt;       |             To make this attachment H,      */</a>
<a name="ln2053">                    /*       (Y)                  (Y)            increment                       */</a>
<a name="ln2054">                    /*        |                    ||            pTCGroups-&gt;pTCG[itg].tg_num_H   */</a>
<a name="ln2055">                    /*        |                    ||                                            */</a>
<a name="ln2056">                    /*       (+)metal             (+)hetero      Technical details:              */</a>
<a name="ln2057">                    /*         \\                   \            increase capacities of          */</a>
<a name="ln2058">                    /*           M                    M(+)       edges to (+/-) otherwise        */</a>
<a name="ln2059">                    /*           |                    ||         flow may not be able to         */</a>
<a name="ln2060">                    /*          -O*                -O-O          increase                        */</a>
<a name="ln2061">                    /*                                                                           */</a>
<a name="ln2062">                    /*   After that change M=O bond order from 2 to 0                            */</a>
<a name="ln2063">                    /*---------------------------------------------------------------------------*/</a>
<a name="ln2064">                    int i1, j1, k1;</a>
<a name="ln2065">                    delta = 1;</a>
<a name="ln2066">                    pvO = pBNS-&gt;vert + n;</a>
<a name="ln2067">                    pvM = pBNS-&gt;vert + i;</a>
<a name="ln2068">                    /* Increment st_edge.cap on (+/-) vertex */</a>
<a name="ln2069">                    pBNS-&gt;vert[vPlusMinus].st_edge.cap += delta;</a>
<a name="ln2070">                    /* Increment st_edge.cap on O */</a>
<a name="ln2071">                    pvO-&gt;st_edge.cap                   += delta;</a>
<a name="ln2072">                    /* increment cap on M-O edge */</a>
<a name="ln2073">                    pe-&gt;cap += delta;</a>
<a name="ln2074">                    /* total cap count */</a>
<a name="ln2075">                    pBNS-&gt;tot_st_cap                   += 2*delta;</a>
<a name="ln2076"> </a>
<a name="ln2077">                    v1 = vPlusMinus;</a>
<a name="ln2078">                    v2 = n; /* atom O */</a>
<a name="ln2079"> </a>
<a name="ln2080">                    /* increase capacities of edges to Y  */</a>
<a name="ln2081">                    for ( i1 = 0; i1 &lt; pBNS-&gt;vert[vPlusMinus].num_adj_edges; i1 ++ ) {</a>
<a name="ln2082">                        j1 = pBNS-&gt;edge[pBNS-&gt;vert[vPlusMinus].iedge[i1]].neighbor12 ^ vPlusMinus;</a>
<a name="ln2083">                        for ( k1 = 0; k1 &lt; pBNS-&gt;vert[j1].num_adj_edges; k1 ++ ) {</a>
<a name="ln2084">                            pBNS-&gt;edge[pBNS-&gt;vert[j1].iedge[k1]].cap += delta;</a>
<a name="ln2085">                        }</a>
<a name="ln2086">                    }</a>
<a name="ln2087">                    SetForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2088">                    pePlusMetal-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln2089">                    pe-&gt;forbidden          &amp;= inv_forbidden_edge_mask;</a>
<a name="ln2090"> </a>
<a name="ln2091">                    ret = RunBnsTestOnce( pBNS, pBD, pVA, &amp;vPathStart, &amp;vPathEnd, &amp;nPathLen,</a>
<a name="ln2092">                                          &amp;nDeltaH, &amp;nDeltaCharge, &amp;nNumVisitedAtoms );</a>
<a name="ln2093">                    cur_success = 0;</a>
<a name="ln2094">                    if ( ret == 1 &amp;&amp; ((vPathEnd == v1 &amp;&amp; vPathStart == v2) ||</a>
<a name="ln2095">                                      (vPathEnd == v2 &amp;&amp; vPathStart == v1)) /*&amp;&amp; nDeltaCharge == 1*/ ) {</a>
<a name="ln2096">                        /* Added (+)charge to -N&lt; =&gt; nDeltaCharge == 1 */</a>
<a name="ln2097">                        /* Flow change on pe (-)charge edge (atom B-O(-)) is not known to RunBnsTestOnce()) */</a>
<a name="ln2098">                        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2099">                        if ( ret &gt; 0 ) {</a>
<a name="ln2100">                            (*pnNumRunBNS) ++;</a>
<a name="ln2101">                            cur_success ++; /* 01 */</a>
<a name="ln2102">                        }</a>
<a name="ln2103">                    }</a>
<a name="ln2104">                    if ( cur_success ) {</a>
<a name="ln2105">                        /* set bond M=O order = 0 */</a>
<a name="ln2106">                        if ( pe-&gt;flow != 2*delta ) {</a>
<a name="ln2107">                            ret = RI_ERR_PROGR;</a>
<a name="ln2108">                            goto exit_function;</a>
<a name="ln2109">                        }</a>
<a name="ln2110">                        /* reduce pe bond order by 2*delta */</a>
<a name="ln2111">                        pe-&gt;flow            -= 2*delta;</a>
<a name="ln2112">                        pvO-&gt;st_edge.cap    -= 2*delta;</a>
<a name="ln2113">                        pvO-&gt;st_edge.flow   -= 2*delta;</a>
<a name="ln2114">                        pvM-&gt;st_edge.flow   -= 2*delta;</a>
<a name="ln2115">                        pvM-&gt;st_edge.cap    -= 2*delta;</a>
<a name="ln2116">                        pBNS-&gt;tot_st_cap    -= 3*delta;</a>
<a name="ln2117">                        pBNS-&gt;tot_st_flow   -= 4*delta;</a>
<a name="ln2118">                        /* fix M-O bond order to zero */</a>
<a name="ln2119">                        pe-&gt;cap             -= 2*delta;</a>
<a name="ln2120">                        /* add fixed (-) charge to O */</a>
<a name="ln2121">                        pVA[n].cInitCharge -= delta;</a>
<a name="ln2122">                    } else {</a>
<a name="ln2123">                        /* failed */</a>
<a name="ln2124">                        pBNS-&gt;vert[vPlusMinus].st_edge.cap -= delta;</a>
<a name="ln2125">                        pvO-&gt;st_edge.cap                   -= delta;</a>
<a name="ln2126">                        /*pTCGroups-&gt;pTCG[itg].edges_cap     -= delta;*/ /* ???bug??? - commented out 2006-03-22 */</a>
<a name="ln2127">                        pBNS-&gt;tot_st_cap                   -= 2*delta;</a>
<a name="ln2128">                        /* decrease capacities of edges to Y  */</a>
<a name="ln2129">                        for ( i1 = 0; i1 &lt; pBNS-&gt;vert[vPlusMinus].num_adj_edges; i1 ++ ) {</a>
<a name="ln2130">                            j1 = pBNS-&gt;edge[pBNS-&gt;vert[vPlusMinus].iedge[i1]].neighbor12 ^ vPlusMinus;</a>
<a name="ln2131">                            for ( k1 = 0; k1 &lt; pBNS-&gt;vert[j1].num_adj_edges; k1 ++ ) {</a>
<a name="ln2132">                                pBNS-&gt;edge[pBNS-&gt;vert[j1].iedge[k1]].cap -= delta;</a>
<a name="ln2133">                            }</a>
<a name="ln2134">                        }</a>
<a name="ln2135">                    }</a>
<a name="ln2136">                    RemoveForbiddenEdgeMask( pBNS, &amp;AllChargeEdges, forbidden_edge_mask  );</a>
<a name="ln2137">                }</a>
<a name="ln2138">            }</a>
<a name="ln2139">        }</a>
<a name="ln2140">    }</a>
<a name="ln2141"> </a>
<a name="ln2142">exit_function:</a>
<a name="ln2143">    AllocEdgeList( &amp;AllChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln2144">    return ret;</a>
<a name="ln2145">}</a>
<a name="ln2146">#if ( KEEP_METAL_EDGE_FLOW == 1 )</a>
<a name="ln2147">/******************************************************************************************************/</a>
<a name="ln2148">int ForbidMetalCarbonEdges( BN_STRUCT *pBNS, inp_ATOM *at, int num_at, VAL_AT *pVA,</a>
<a name="ln2149">                           ALL_TC_GROUPS *pTCGroups, EDGE_LIST *pMetalCarbonEdges, int forbidden_edge_mask  )</a>
<a name="ln2150">{</a>
<a name="ln2151"> </a>
<a name="ln2152">    int i, j, neigh, nNumEdgeMetalCarbon = 0, pass = 0, ret = 0;</a>
<a name="ln2153">    BNS_VERTEX *pVert, *pNeigh;</a>
<a name="ln2154">    BNS_EDGE   *pEdge;</a>
<a name="ln2155"> </a>
<a name="ln2156">    /* count carbon-metal edges */</a>
<a name="ln2157">    </a>
<a name="ln2158">    if ( pTCGroups-&gt;num_metal_atoms ) {</a>
<a name="ln2159">fill_ForbiddenEdgesMetalCarbon:</a>
<a name="ln2160">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2161">            if ( pVA[i].cMetal &amp;&amp; pVA[i].cNumBondsToMetal ) {</a>
<a name="ln2162">                pVert = pBNS-&gt;vert + i;</a>
<a name="ln2163">                for ( j = 0; j &lt; pVert-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln2164">                    pEdge = pBNS-&gt;edge + pVert-&gt;iedge[j];</a>
<a name="ln2165">                    neigh = pEdge-&gt;neighbor12 ^ i;</a>
<a name="ln2166">                    pNeigh = pBNS-&gt;vert + neigh;</a>
<a name="ln2167">                    if ( !IS_BNS_VT_ATOM(pNeigh-&gt;type) )</a>
<a name="ln2168">                        continue;</a>
<a name="ln2169">                    if ( at[neigh].endpoint )</a>
<a name="ln2170">                        continue;</a>
<a name="ln2171">                    if ( pVA[neigh].cNumValenceElectrons == 4 &amp;&amp; pVA[neigh].cPeriodicRowNumber == 1 &amp;&amp;</a>
<a name="ln2172">                         pNeigh-&gt;st_edge.cap &gt;= at[neigh].valence+1 ) {</a>
<a name="ln2173">                        if ( pass ) {</a>
<a name="ln2174">                            if ( ret = AddToEdgeList( pMetalCarbonEdges, pVert-&gt;iedge[j], 0 ) ) {</a>
<a name="ln2175">                                goto exit_function;</a>
<a name="ln2176">                            }</a>
<a name="ln2177">                            pEdge-&gt;forbidden |= forbidden_edge_mask;</a>
<a name="ln2178">                        } else {</a>
<a name="ln2179">                            nNumEdgeMetalCarbon ++;</a>
<a name="ln2180">                        }</a>
<a name="ln2181">                    }</a>
<a name="ln2182"> </a>
<a name="ln2183">                }</a>
<a name="ln2184">            }</a>
<a name="ln2185">        }</a>
<a name="ln2186">        if ( !pass &amp;&amp; nNumEdgeMetalCarbon ) {</a>
<a name="ln2187">            if ( ret = AllocEdgeList( pMetalCarbonEdges, nNumEdgeMetalCarbon ) ) {</a>
<a name="ln2188">                goto exit_function;</a>
<a name="ln2189">            }</a>
<a name="ln2190">            pass ++;</a>
<a name="ln2191">            goto fill_ForbiddenEdgesMetalCarbon;</a>
<a name="ln2192">        }</a>
<a name="ln2193">    }</a>
<a name="ln2194">exit_function:</a>
<a name="ln2195">    return ret;</a>
<a name="ln2196">}</a>
<a name="ln2197">#endif</a>
<a name="ln2198">/******************************************************************************************************/</a>
<a name="ln2199">int RunBnsRestore1( ICHICONST INPUT_PARMS *ip, STRUCT_DATA *sd, BN_STRUCT *pBNS, BN_DATA *pBD,</a>
<a name="ln2200">                    StrFromINChI *pStruct, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups, INChI *pInChI[],</a>
<a name="ln2201">                    long num_inp, int bHasSomeFixedH )</a>
<a name="ln2202">{</a>
<a name="ln2203">    int        nNumRunBNS = 0;</a>
<a name="ln2204">    </a>
<a name="ln2205">    EDGE_LIST CarbonChargeEdges, MetalCarbonEdges, Nplus2BondsEdges;</a>
<a name="ln2206"> </a>
<a name="ln2207">    int nTotalDelta = 0, ret = 0, tot_num_fixes;</a>
<a name="ln2208">    inp_ATOM *at          = pStruct-&gt;at;</a>
<a name="ln2209">    inp_ATOM *at2         = NULL; /* restored structure */</a>
<a name="ln2210">    inp_ATOM *at3         = NULL; /* structure for calculating one InChI */</a>
<a name="ln2211">    int     num_at        = pStruct-&gt;num_atoms;</a>
<a name="ln2212">    int     num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln2213">#ifdef _DEBUG</a>
<a name="ln2214">    int ret2;</a>
<a name="ln2215">#endif</a>
<a name="ln2216"> </a>
<a name="ln2217">#if ( KEEP_METAL_EDGE_FLOW == 1 )    </a>
<a name="ln2218">    BNS_VERTEX *pVert, *pNeigh;</a>
<a name="ln2219">    int         j, neigh;</a>
<a name="ln2220">#endif</a>
<a name="ln2221"> </a>
<a name="ln2222">    /* Edge lista initialization */</a>
<a name="ln2223">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_CLEAR );</a>
<a name="ln2224">    AllocEdgeList( &amp;MetalCarbonEdges, EDGE_LIST_CLEAR );</a>
<a name="ln2225">    AllocEdgeList( &amp;Nplus2BondsEdges, EDGE_LIST_CLEAR );</a>
<a name="ln2226"> </a>
<a name="ln2227">    if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp;</a>
<a name="ln2228">         ( ret = FillOutExtraFixedHDataInChI( pStruct, pInChI ) ) ) {</a>
<a name="ln2229">        goto exit_function;</a>
<a name="ln2230">    }</a>
<a name="ln2231"> </a>
<a name="ln2232">    if ( (!at2 &amp;&amp; !(at2 = (inp_ATOM *) inchi_malloc((num_at + num_deleted_H)*sizeof(at2[0])))) ||</a>
<a name="ln2233">         (!at3 &amp;&amp; !(at3 = (inp_ATOM *) inchi_malloc((num_at + num_deleted_H)*sizeof(at3[0])))) ) {</a>
<a name="ln2234">        return RI_ERR_ALLOC;</a>
<a name="ln2235">    }</a>
<a name="ln2236"> </a>
<a name="ln2237">    if ( 0 &gt; (ret = ForbidCarbonChargeEdges( pBNS, pTCGroups, &amp;CarbonChargeEdges, BNS_EDGE_FORBIDDEN_TEMP ))) {</a>
<a name="ln2238">        goto exit_function;</a>
<a name="ln2239">    }</a>
<a name="ln2240"> </a>
<a name="ln2241">#if ( KEEP_METAL_EDGE_FLOW == 1 )    </a>
<a name="ln2242">    /* count edges of -C(IV)&lt; carbons connected to metals */</a>
<a name="ln2243">    if ( 0 &gt; (ret = ForbidMetalCarbonEdges( pBNS, at, num_at, pVA, pTCGroups, &amp;MetalCarbonEdges, BNS_EDGE_FORBIDDEN_TEMP ))) {</a>
<a name="ln2244">        goto exit_function;</a>
<a name="ln2245">    }</a>
<a name="ln2246">#endif</a>
<a name="ln2247">    if ( 0 &gt; (ret = ForbidNintrogenPlus2BondsInSmallRings( pBNS, at, num_at, pVA, 6,</a>
<a name="ln2248">                                           pTCGroups, &amp;Nplus2BondsEdges, BNS_EDGE_FORBIDDEN_TEMP ) ) ) {</a>
<a name="ln2249">        goto exit_function;</a>
<a name="ln2250">    }</a>
<a name="ln2251"> </a>
<a name="ln2252">    /*********** Run BNS #1: no charge on carbons and =N= ***************/</a>
<a name="ln2253">    if ( Nplus2BondsEdges.num_edges ) {</a>
<a name="ln2254">        /* Run BNS leaving carbon charges unchanged */</a>
<a name="ln2255">        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2256">        nNumRunBNS ++;</a>
<a name="ln2257">        if ( ret &lt; 0 ) {</a>
<a name="ln2258">            goto exit_function;</a>
<a name="ln2259">        } else {</a>
<a name="ln2260">            nTotalDelta += ret;</a>
<a name="ln2261">        }</a>
<a name="ln2262">        RemoveForbiddenEdgeMask( pBNS, &amp;Nplus2BondsEdges, BNS_EDGE_FORBIDDEN_TEMP );</a>
<a name="ln2263">        AllocEdgeList( &amp;Nplus2BondsEdges, EDGE_LIST_FREE );</a>
<a name="ln2264">    }</a>
<a name="ln2265">#ifdef _DEBUG</a>
<a name="ln2266">    /* debug only */</a>
<a name="ln2267">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln2268">    pStruct-&gt;at = at2;</a>
<a name="ln2269">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2270">    pStruct-&gt;at = at;</a>
<a name="ln2271">#endif    </a>
<a name="ln2272">    /*************************** extend min ring size to 8 ****************************/</a>
<a name="ln2273">    if ( 0 &gt; (ret = ForbidNintrogenPlus2BondsInSmallRings( pBNS, at, num_at, pVA, 8,</a>
<a name="ln2274">                                           pTCGroups, &amp;Nplus2BondsEdges, BNS_EDGE_FORBIDDEN_TEMP ) ) ) {</a>
<a name="ln2275">        goto exit_function;</a>
<a name="ln2276">    }</a>
<a name="ln2277">    if ( Nplus2BondsEdges.num_edges ) {</a>
<a name="ln2278">        /* Run BNS leaving carbon charges unchanged */</a>
<a name="ln2279">        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2280">        nNumRunBNS ++;</a>
<a name="ln2281">        if ( ret &lt; 0 ) {</a>
<a name="ln2282">            goto exit_function;</a>
<a name="ln2283">        } else {</a>
<a name="ln2284">            nTotalDelta += ret;</a>
<a name="ln2285">        }</a>
<a name="ln2286">        RemoveForbiddenEdgeMask( pBNS, &amp;Nplus2BondsEdges, BNS_EDGE_FORBIDDEN_TEMP );</a>
<a name="ln2287">        AllocEdgeList( &amp;Nplus2BondsEdges, EDGE_LIST_FREE );</a>
<a name="ln2288">    }</a>
<a name="ln2289">#ifdef _DEBUG</a>
<a name="ln2290">    /* debug only */</a>
<a name="ln2291">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln2292">    pStruct-&gt;at = at2;</a>
<a name="ln2293">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2294">    pStruct-&gt;at = at;</a>
<a name="ln2295">#endif    </a>
<a name="ln2296">    /*******************************************************************/</a>
<a name="ln2297">    if ( CarbonChargeEdges.num_edges &gt; 0 ) {</a>
<a name="ln2298">        /* Run BNS leaving carbon charges unchanged */</a>
<a name="ln2299">        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2300">        nNumRunBNS ++;</a>
<a name="ln2301">        if ( ret &lt; 0 ) {</a>
<a name="ln2302">            goto exit_function;</a>
<a name="ln2303">        } else {</a>
<a name="ln2304">            nTotalDelta += ret;</a>
<a name="ln2305">        }</a>
<a name="ln2306">        RemoveForbiddenEdgeMask( pBNS, &amp;CarbonChargeEdges, BNS_EDGE_FORBIDDEN_TEMP );</a>
<a name="ln2307">        AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln2308">    }</a>
<a name="ln2309">#ifdef _DEBUG</a>
<a name="ln2310">    /* debug only */</a>
<a name="ln2311">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln2312">    pStruct-&gt;at = at2;</a>
<a name="ln2313">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2314">    pStruct-&gt;at = at;</a>
<a name="ln2315">#endif    </a>
<a name="ln2316">    /*******************************************************************/</a>
<a name="ln2317">    if ( MetalCarbonEdges.num_edges &gt; 0 ) {</a>
<a name="ln2318">        /* Run BNS leaving carbon charges unchanged */</a>
<a name="ln2319">        ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2320">        nNumRunBNS ++;</a>
<a name="ln2321">        if ( ret &lt; 0 ) {</a>
<a name="ln2322">            goto exit_function;</a>
<a name="ln2323">        } else {</a>
<a name="ln2324">            nTotalDelta += ret;</a>
<a name="ln2325">        }</a>
<a name="ln2326">        RemoveForbiddenEdgeMask( pBNS, &amp;MetalCarbonEdges, BNS_EDGE_FORBIDDEN_TEMP );</a>
<a name="ln2327">        AllocEdgeList( &amp;MetalCarbonEdges, EDGE_LIST_FREE );</a>
<a name="ln2328">    }</a>
<a name="ln2329">    /*******************************************************************/</a>
<a name="ln2330">    /* Run BNS allowing to change any charges */</a>
<a name="ln2331">    ret = RunBnsRestoreOnce( pBNS, pBD, pVA, pTCGroups );</a>
<a name="ln2332">    nNumRunBNS ++;</a>
<a name="ln2333">    if ( ret &lt; 0 ) {</a>
<a name="ln2334">        goto exit_function;</a>
<a name="ln2335">    } else {</a>
<a name="ln2336">        nTotalDelta += ret;</a>
<a name="ln2337">    }</a>
<a name="ln2338">#ifdef _DEBUG</a>
<a name="ln2339">    /* debug only */</a>
<a name="ln2340">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln2341">    pStruct-&gt;at = at2;</a>
<a name="ln2342">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2343">    pStruct-&gt;at = at;</a>
<a name="ln2344">#endif</a>
<a name="ln2345"> </a>
<a name="ln2346">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln2347">    /******************************************************************/</a>
<a name="ln2348">    /* move unfulfilled 'radicals' from ChargeStruct to atoms         */</a>
<a name="ln2349">    /* and set change charges of affected atoms to fit total charge   */</a>
<a name="ln2350">     ret = MoveRadToAtomsAddCharges( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups, BNS_EDGE_FORBIDDEN_TEMP );</a>
<a name="ln2351">    if ( ret &lt; 0 ) {</a>
<a name="ln2352">        goto exit_function;</a>
<a name="ln2353">    }</a>
<a name="ln2354">#endif</a>
<a name="ln2355">    /**************************************************************/</a>
<a name="ln2356">    /**************************************************************/</a>
<a name="ln2357">    /*****           fix restore inconsistencies              *****/</a>
<a name="ln2358">    /**************************************************************/</a>
<a name="ln2359">    /**************************************************************/</a>
<a name="ln2360">#ifdef _DEBUG</a>
<a name="ln2361">    /* debug only */</a>
<a name="ln2362">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln2363">    pStruct-&gt;at = at2;</a>
<a name="ln2364">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2365">    pStruct-&gt;at = at;</a>
<a name="ln2366">#endif    </a>
<a name="ln2367"> </a>
<a name="ln2368">    /* rearrange (+) and (-) edges flow so that there is no (+)flow=0 and (-)flow=1 */</a>
<a name="ln2369">    ret = RearrangePlusMinusEdgesFlow( pBNS, pBD, pVA, pTCGroups, BNS_EDGE_FORBIDDEN_TEMP );</a>
<a name="ln2370">    if ( ret &lt; 0 ) {</a>
<a name="ln2371">        goto exit_function;</a>
<a name="ln2372">    }</a>
<a name="ln2373"> </a>
<a name="ln2374">    /*****************************************************************/</a>
<a name="ln2375">    /*       Increment zero order metal bonds to heteroatoms         */</a>
<a name="ln2376">    /*****************************************************************/</a>
<a name="ln2377">    ret = IncrementZeroOrderBondsToHeteroat( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2378">                                             &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2379">    if ( ret &lt; 0 ) {</a>
<a name="ln2380">        goto exit_function;</a>
<a name="ln2381">    }</a>
<a name="ln2382">    </a>
<a name="ln2383">#ifdef _DEBUG</a>
<a name="ln2384">    /* debug only */</a>
<a name="ln2385">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln2386">    pStruct-&gt;at = at2;</a>
<a name="ln2387">    ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2388">    pStruct-&gt;at = at;</a>
<a name="ln2389">#endif</a>
<a name="ln2390"> </a>
<a name="ln2391">#if (MOVE_CHARGES_FROM_HETEREO_TO_METAL == 1 )</a>
<a name="ln2392">    /*****************************************************************/</a>
<a name="ln2393">    /* move charges from heteroatoms to metal atoms                  */</a>
<a name="ln2394">    /*****************************************************************/</a>
<a name="ln2395">    ret = MoveChargeFromHeteroatomsToMetals( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2396">                                             &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2397">    if ( ret &lt; 0 ) {</a>
<a name="ln2398">        goto exit_function;</a>
<a name="ln2399">    }</a>
<a name="ln2400">#endif</a>
<a name="ln2401">    /***********************************************************************</a>
<a name="ln2402">            NH2                NH2</a>
<a name="ln2403">               \                  \</a>
<a name="ln2404">                C==S(+)-   =&gt;      C(+)-S-   where NH2 are not tautomeric</a>
<a name="ln2405">               /                  /</a>
<a name="ln2406">            NH2                NH2</a>
<a name="ln2407">    ************************************************************************/</a>
<a name="ln2408">    ret = MovePlusFromS2DiaminoCarbon( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2409">                                       &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2410">    if ( ret &lt; 0 ) {</a>
<a name="ln2411">        goto exit_function;</a>
<a name="ln2412">    }</a>
<a name="ln2413">    /*****************************************************************/</a>
<a name="ln2414">    /*       Avoid charge separation on heteroatoms                  */</a>
<a name="ln2415">    /*****************************************************************/</a>
<a name="ln2416">    ret = EliminateChargeSeparationOnHeteroatoms( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2417">                                                  &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP, 0);</a>
<a name="ln2418">    if ( ret &lt; 0 ) {</a>
<a name="ln2419">        goto exit_function;</a>
<a name="ln2420">    }</a>
<a name="ln2421">    if ( ret ) {</a>
<a name="ln2422">        /*charge separation remains; allow changes of stereobonds in a ring and try again */</a>
<a name="ln2423">        ret = EliminateChargeSeparationOnHeteroatoms( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2424">                                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP,</a>
<a name="ln2425">                                                      BNS_EDGE_FORBIDDEN_MASK);</a>
<a name="ln2426">        if ( ret &lt; 0 ) {</a>
<a name="ln2427">            goto exit_function;</a>
<a name="ln2428">        }</a>
<a name="ln2429">    }</a>
<a name="ln2430">    /*****************************************************************/</a>
<a name="ln2431">    /*         convert N#N(+)-N= into N(-)=N(+)=N-                   */</a>
<a name="ln2432">    /*****************************************************************/</a>
<a name="ln2433">    ret = RestoreNNNgroup( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2434">                           &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2435">    if ( ret &lt; 0 ) {</a>
<a name="ln2436">        goto exit_function;</a>
<a name="ln2437">    }</a>
<a name="ln2438">    /*****************************************************************/</a>
<a name="ln2439">    /*     convert Metal(q)-N(-)-O(-) Metal(q-2)-N=O (local change)  */</a>
<a name="ln2440">    /*****************************************************************/</a>
<a name="ln2441">    ret = FixMetal_Nminus_Ominus( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2442">                           &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2443">    if ( ret &lt; 0 ) {</a>
<a name="ln2444">        goto exit_function;</a>
<a name="ln2445">    }</a>
<a name="ln2446">    /*****************************************************************/</a>
<a name="ln2447">    /*         convert N(-)=C= into N#C-         -                   */</a>
<a name="ln2448">    /*****************************************************************/</a>
<a name="ln2449">    ret = RestoreCyanoGroup( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2450">                           &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2451">    if ( ret &lt; 0 ) {</a>
<a name="ln2452">        goto exit_function;</a>
<a name="ln2453">    }</a>
<a name="ln2454">    /*****************************************************************/</a>
<a name="ln2455">    /*         convert C(+)#N(+)- into C(-)#N(+)-                    */</a>
<a name="ln2456">    /*****************************************************************/</a>
<a name="ln2457">    ret = RestoreIsoCyanoGroup( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2458">                           &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2459">    if ( ret &lt; 0 ) {</a>
<a name="ln2460">        goto exit_function;</a>
<a name="ln2461">    }</a>
<a name="ln2462">    /*****************************************************************/</a>
<a name="ln2463">    /*         eliminate =N(V)= if possible                          */</a>
<a name="ln2464">    /*                    |                                          */</a>
<a name="ln2465">    /*****************************************************************/</a>
<a name="ln2466">    ret = EliminateNitrogen5Val3Bonds(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2467">                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2468">    if ( ret &lt; 0 ) {</a>
<a name="ln2469">        goto exit_function;</a>
<a name="ln2470">    }</a>
<a name="ln2471"> </a>
<a name="ln2472">    /*****************************************************************/</a>
<a name="ln2473">    /*                    |      |                                   */</a>
<a name="ln2474">    /*         convert   -S- to =S= if possible                      */</a>
<a name="ln2475">    /*                    |      |                                   */</a>
<a name="ln2476">    /*****************************************************************/</a>
<a name="ln2477">    ret = Convert_SIV_to_SVI(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2478">                             &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2479">    if ( ret &lt; 0 ) {</a>
<a name="ln2480">        goto exit_function;</a>
<a name="ln2481">    }</a>
<a name="ln2482"> </a>
<a name="ln2483">    /*****************************************************************/</a>
<a name="ln2484">    /*                  =N(+)=O     =N-O(-)                          */</a>
<a name="ln2485">    /*         convert           =&gt; if possible                      */</a>
<a name="ln2486">    /*                  Metal(q)    Metal(q+2)                       */</a>
<a name="ln2487">    /*****************************************************************/</a>
<a name="ln2488">    ret = PlusFromDB_N_DB_O_to_Metal(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2489">                             &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2490">    if ( ret &lt; 0 ) {</a>
<a name="ln2491">        goto exit_function;</a>
<a name="ln2492">    }</a>
<a name="ln2493"> </a>
<a name="ln2494">    /*****************************************************************/</a>
<a name="ln2495">    /*  forbidden edges prevents required in InChI tautomerism       */</a>
<a name="ln2496">    /*  incorrectly restored mobile H mix separate tautomeric groups */</a>
<a name="ln2497">    /*  because an edge may not become forbidden                     */</a>
<a name="ln2498">    /* note: removes this 'forbidden_edge' bit from ALL edges        */</a>
<a name="ln2499">    /*****************************************************************/</a>
<a name="ln2500">    ret = MoveMobileHToAvoidFixedBonds( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2501">                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2502"> </a>
<a name="ln2503">    if ( ret &lt; 0 ) {</a>
<a name="ln2504">        goto exit_function;</a>
<a name="ln2505">    }</a>
<a name="ln2506">    /**************************************************************************/</a>
<a name="ln2507">    /* 2. Mobile H endpoint has radical on it (typical for wrong P(VI)(=O)3OH */</a>
<a name="ln2508">    tot_num_fixes = 0;</a>
<a name="ln2509">    if ( pStruct-&gt;iMobileH==TAUT_NON ) {</a>
<a name="ln2510">        ret = RemoveRadFromMobileHEndpointFixH( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2511">                                          &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2512">    } else {</a>
<a name="ln2513">        ret = RemoveRadFromMobileHEndpoint( pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2514">                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2515">    }</a>
<a name="ln2516">    if ( ret &lt; 0 ) {</a>
<a name="ln2517">        goto exit_function;</a>
<a name="ln2518">    }</a>
<a name="ln2519">    tot_num_fixes += ret;</a>
<a name="ln2520">    /**************************************************************/</a>
<a name="ln2521">    /* make bonds between a charged heteroatom and a metal single */</a>
<a name="ln2522">    ret = MakeSingleBondsMetal2ChargedHeteroat(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2523">                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2524">    if ( ret &lt; 0 ) {</a>
<a name="ln2525">        goto exit_function;</a>
<a name="ln2526">    }</a>
<a name="ln2527">    /**************************************************************/</a>
<a name="ln2528">    /* move (+) charges to &gt;N- and other centerpoints             */</a>
<a name="ln2529">    ret = MoveChargeToMakeCenerpoints(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2530">                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2531">    if ( ret &lt; 0 ) {</a>
<a name="ln2532">        goto exit_function;</a>
<a name="ln2533">    }</a>
<a name="ln2534"> </a>
<a name="ln2535">    /**************************************************************************/</a>
<a name="ln2536">    /* Find and eliminate false Mobile-H groups: Cl(=O)3(-O(-)) =&gt; Cl(-)(=O)4 */</a>
<a name="ln2537">    ret = MoveChargeToRemoveCenerpoints(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2538">                                      &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2539">    if ( ret &lt; 0 ) {</a>
<a name="ln2540">        goto exit_function;</a>
<a name="ln2541">    }</a>
<a name="ln2542">    /**************************************************************************/</a>
<a name="ln2543">    /* Find A=X&lt; where all bonds to X except A=X are marked as stereogenic    */</a>
<a name="ln2544">    /* make bonds A=X single                                                  */</a>
<a name="ln2545">    ret = CheckAndRefixStereobonds(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2546">                                 &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2547">    if ( ret &lt; 0 ) {</a>
<a name="ln2548">        goto exit_function;</a>
<a name="ln2549">    }</a>
<a name="ln2550">    /**************************************************************************/</a>
<a name="ln2551">    /* In Reconnected structure change 'salt bonds' to 'coordination bonds    */</a>
<a name="ln2552">    /* for example, M-O-C=  -&gt;  M(+)-O(-)-C=                                  */</a>
<a name="ln2553">    /* Defect: instead of NH2-C=O(+)-M it will restore NH2(+)=C-O(-)-M(+)     */</a>
<a name="ln2554">    /* However, in this release metal-organic compounds do not get much care  */</a>
<a name="ln2555">    ret = SaltBondsToCoordBonds(pBNS, pBD, pStruct, at, at2, pVA, pTCGroups,</a>
<a name="ln2556">                               &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP);</a>
<a name="ln2557">    if ( ret &lt; 0 ) {</a>
<a name="ln2558">        goto exit_function;</a>
<a name="ln2559">    }</a>
<a name="ln2560">    /**************************************************************************/</a>
<a name="ln2561">    /* Normalize the structure and compare t-groups and stereobonds           */</a>
<a name="ln2562">    ret = NormalizeAndCompare(ip, sd, pBNS, pBD, pStruct, at, at2, at3, pVA, pTCGroups, pInChI, num_inp, bHasSomeFixedH,</a>
<a name="ln2563">                              &amp;nNumRunBNS, &amp;nTotalDelta, BNS_EDGE_FORBIDDEN_TEMP, BNS_EDGE_FORBIDDEN_MASK);</a>
<a name="ln2564">    if ( ret &lt; 0 ) {</a>
<a name="ln2565">        goto exit_function;</a>
<a name="ln2566">    }</a>
<a name="ln2567">    /**************************************************************************/</a>
<a name="ln2568">    /* Create InChI out of the restored structure                             */</a>
<a name="ln2569"> </a>
<a name="ln2570"> </a>
<a name="ln2571">    /*ret = nTotalDelta;*/</a>
<a name="ln2572"> </a>
<a name="ln2573">exit_function:</a>
<a name="ln2574">    pStruct-&gt;at  = at;</a>
<a name="ln2575">    pStruct-&gt;at2 = at2;</a>
<a name="ln2576">    at2 = NULL;</a>
<a name="ln2577">    AllocEdgeList( &amp;CarbonChargeEdges, EDGE_LIST_FREE );</a>
<a name="ln2578">    AllocEdgeList( &amp;MetalCarbonEdges, EDGE_LIST_FREE );</a>
<a name="ln2579">    AllocEdgeList( &amp;Nplus2BondsEdges, EDGE_LIST_FREE );</a>
<a name="ln2580">    if ( at2 ) {</a>
<a name="ln2581">        inchi_free( at2 );</a>
<a name="ln2582">    }</a>
<a name="ln2583">    if ( at3 ) {</a>
<a name="ln2584">        inchi_free( at3 );</a>
<a name="ln2585">    }</a>
<a name="ln2586"> </a>
<a name="ln2587">    return ret;</a>
<a name="ln2588">}</a>
<a name="ln2589"> </a>
<a name="ln2590">/******************************************************************************************************/</a>
<a name="ln2591">int RestoreAtomMakeBNS( ICHICONST INPUT_PARMS *ip, STRUCT_DATA *sd, StrFromINChI *pStruct, int iComponent,</a>
<a name="ln2592">                        int iAtNoOffset, INChI *pInChI[], const char *szCurHdr, long num_inp, int bHasSomeFixedH )</a>
<a name="ln2593">{</a>
<a name="ln2594">    int i, j, ret = 0, ret2;</a>
<a name="ln2595">    /*int nDelta, nTotalDelta;*/</a>
<a name="ln2596">    VAL_AT   *pVA = NULL;</a>
<a name="ln2597">    VAL_AT    va1;</a>
<a name="ln2598">    int    num_at = pStruct-&gt;num_atoms;</a>
<a name="ln2599">    inp_ATOM *at  = pStruct-&gt;at;</a>
<a name="ln2600">    ALL_TC_GROUPS   TCGroups;</a>
<a name="ln2601">    ALL_TC_GROUPS *pTCGroups = &amp;TCGroups;</a>
<a name="ln2602">    int            nAddEdges2eachAtom = 2, nAddVertices = 0;</a>
<a name="ln2603"> </a>
<a name="ln2604">    BFS_Q bfsq;</a>
<a name="ln2605"> </a>
<a name="ln2606">    /* BNS creation */</a>
<a name="ln2607">    BN_STRUCT     *pBNS = NULL;</a>
<a name="ln2608">    BN_DATA       *pBD  = NULL;</a>
<a name="ln2609">    int            nNum_changed_bonds = 0;</a>
<a name="ln2610">    int            bTreatMoreAtomsAsMetals = 0, bSecondPassNewMetals=0;</a>
<a name="ln2611">    int            nMaxAddAtoms = 2, nMaxAddEdges = 2, max_altp = BN_MAX_ALTP;</a>
<a name="ln2612"> </a>
<a name="ln2613">    memset( pTCGroups, 0, sizeof(pTCGroups[0]) );</a>
<a name="ln2614">    for ( i = 0; i &lt; NUM_TCGROUP_TYPES; i ++ ) {</a>
<a name="ln2615">        pTCGroups-&gt;nGroup[i] = TCG_None; /* unassigned */</a>
<a name="ln2616">    }</a>
<a name="ln2617">    pTCGroups-&gt;iComponent = iComponent;</a>
<a name="ln2618">    pTCGroups-&gt;iAtNoOffset = iAtNoOffset;</a>
<a name="ln2619"> </a>
<a name="ln2620">    if ( num_at == 1 ) {</a>
<a name="ln2621">        /* single atom -- no bonds to restore */</a>
<a name="ln2622">        inp_ATOM *at2 = (inp_ATOM *) inchi_malloc(sizeof(at2[0])*(pStruct-&gt;num_atoms+pStruct-&gt;num_deleted_H));</a>
<a name="ln2623">        inp_ATOM *at3 = (inp_ATOM *) inchi_malloc(sizeof(at3[0])*(pStruct-&gt;num_atoms+pStruct-&gt;num_deleted_H));</a>
<a name="ln2624">        pStruct-&gt;at2 = at2;</a>
<a name="ln2625">        at[0].charge = pInChI[0]-&gt;nTotalCharge;</a>
<a name="ln2626">        if ( at2 ) {</a>
<a name="ln2627">            memcpy( at2, at, sizeof(at2[0])*(pStruct-&gt;num_atoms+pStruct-&gt;num_deleted_H));</a>
<a name="ln2628">        }</a>
<a name="ln2629">        if ( !at2 || !at3 ) {</a>
<a name="ln2630">            if ( at3 ) inchi_free( at3 );</a>
<a name="ln2631">            return RI_ERR_ALLOC;</a>
<a name="ln2632">        }</a>
<a name="ln2633">        ret = MakeOneInChIOutOfStrFromINChI( ip, sd, pStruct, pStruct-&gt;at2, at3, pTCGroups );</a>
<a name="ln2634">        /* clean up */</a>
<a name="ln2635">        for( i = 0; i &lt; TAUT_NUM; i ++ ) {</a>
<a name="ln2636">            Free_INChI( &amp;pStruct-&gt;pOneINChI[i] );</a>
<a name="ln2637">            Free_INChI_Aux( &amp;pStruct-&gt;pOneINChI_Aux[i] );</a>
<a name="ln2638">            FreeInpAtomData( pStruct-&gt;pOne_norm_data[i] );</a>
<a name="ln2639">            if ( pStruct-&gt;pOne_norm_data[i] ) {</a>
<a name="ln2640">                inchi_free( pStruct-&gt;pOne_norm_data[i] );</a>
<a name="ln2641">                pStruct-&gt;pOne_norm_data[i] = NULL;</a>
<a name="ln2642">            }</a>
<a name="ln2643">        }</a>
<a name="ln2644">        free_t_group_info( &amp;pStruct-&gt;One_ti );</a>
<a name="ln2645">        inchi_free( at3 );</a>
<a name="ln2646"> </a>
<a name="ln2647">        return ret;</a>
<a name="ln2648">    }</a>
<a name="ln2649">    </a>
<a name="ln2650">    AllocBfsQueue( &amp;bfsq, BFS_Q_CLEAR, 0 );</a>
<a name="ln2651">    if ( !(pVA = (VAL_AT *) inchi_calloc( num_at, sizeof( pVA[0] ) ) ) ) {</a>
<a name="ln2652">        ret = RI_ERR_ALLOC;</a>
<a name="ln2653">        goto exit_function;</a>
<a name="ln2654">    }</a>
<a name="ln2655">    pStruct-&gt;pVA = pVA;</a>
<a name="ln2656">    memset( &amp;va1, 0, sizeof(va1) );</a>
<a name="ln2657">    pTCGroups-&gt;total_charge = pInChI[0]-&gt;nTotalCharge;</a>
<a name="ln2658">    if ( 0 &gt; ( ret = AllocBfsQueue( &amp;bfsq, num_at, 0 /* min ring size undefined */ ) ) ) {</a>
<a name="ln2659">        goto exit_function;</a>
<a name="ln2660">    }</a>
<a name="ln2661">    pStruct-&gt;pbfsq = &amp;bfsq;</a>
<a name="ln2662">    </a>
<a name="ln2663">    if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; pInChI[1] &amp;&amp; pInChI[1]-&gt;nNumberOfAtoms &gt; 1 &amp;&amp;</a>
<a name="ln2664">        ( ret = FillOutpStructEndpointFromInChI( pInChI[1], &amp;pStruct-&gt;endpoint )) ) {</a>
<a name="ln2665">        goto exit_function;</a>
<a name="ln2666">    }</a>
<a name="ln2667">    </a>
<a name="ln2668">    /* mark metal atoms; find min ring sizes for atoms that have 2 bonds */</a>
<a name="ln2669">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2670">        pVA[i].cNumValenceElectrons = get_sp_element_type( at[i].el_number, &amp;j );</a>
<a name="ln2671">        pVA[i].cPeriodicRowNumber = j;</a>
<a name="ln2672">        pVA[i].cPeriodicNumber    = at[i].el_number;</a>
<a name="ln2673">        pVA[i].cNumValenceElectrons --; /* = -1 d- and f- metals, 0 for H, 1 for Na, 2 for Mg,.. = (ATYPE_Xx-1)  */</a>
<a name="ln2674"> </a>
<a name="ln2675">        if ( is_el_a_metal( at[i].el_number ) ) {</a>
<a name="ln2676">            if ( pStruct-&gt;pSrm-&gt;bStereoRemovesMetalFlag ) {</a>
<a name="ln2677">                /* treat metal as non-metal if it is stereogenic or has a stereobond */</a>
<a name="ln2678">                pVA[i].cMetal = !( at[i].p_parity || at[i].sb_parity[0] );</a>
<a name="ln2679">            } else {</a>
<a name="ln2680">                pVA[i].cMetal = 1;</a>
<a name="ln2681">            }</a>
<a name="ln2682">        }</a>
<a name="ln2683">        if ( at[i].valence == 2 &amp;&amp; !at[i].num_H ) {</a>
<a name="ln2684">            pVA[i].cMinRingSize = is_bond_in_Nmax_memb_ring( at, i, 0, bfsq.q, bfsq.nAtomLevel,</a>
<a name="ln2685">                                                             bfsq.cSource, 99 /* max ring size */ );</a>
<a name="ln2686">        } else {</a>
<a name="ln2687">            pVA[i].cMinRingSize = 0;</a>
<a name="ln2688">        }</a>
<a name="ln2689">    }</a>
<a name="ln2690">    /* AllocBfsQueue( &amp;bfsq, BFS_Q_FREE, 0 ); */</a>
<a name="ln2691"> </a>
<a name="ln2692">repeat_for_new_metals:</a>
<a name="ln2693">    /* set valences for the first time; find ChargeValence structures for each atom */</a>
<a name="ln2694">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2695">        /* get additional fictitious atoms information */</a>
<a name="ln2696">        pVA[i].cInitFreeValences = 0;</a>
<a name="ln2697">        ret = GetAtomRestoreInfo( at, i, pVA, pStruct-&gt;pSrm, pStruct-&gt;bMobileH, pStruct-&gt;endpoint );</a>
<a name="ln2698">        if ( ret &lt; 0 ) {</a>
<a name="ln2699">            goto exit_function;</a>
<a name="ln2700">        }</a>
<a name="ln2701">        if ( ret == TREAT_ATOM_AS_METAL &amp;&amp; !bSecondPassNewMetals &amp;&amp; !pVA[i].cMetal ) {</a>
<a name="ln2702">            if ( pStruct-&gt;pSrm-&gt;bStereoRemovesMetalFlag ) {</a>
<a name="ln2703">                /* treat metal as non-metal if it is stereogenic or has a stereobond */</a>
<a name="ln2704">                pVA[i].cMetal = !( at[i].p_parity || at[i].sb_parity[0] );</a>
<a name="ln2705">            } else {</a>
<a name="ln2706">                pVA[i].cMetal = 1;</a>
<a name="ln2707">            }</a>
<a name="ln2708">            if ( pVA[i].cMetal ) {</a>
<a name="ln2709">                bTreatMoreAtomsAsMetals ++;</a>
<a name="ln2710">            }</a>
<a name="ln2711">        }</a>
<a name="ln2712">        pTCGroups-&gt;charge_on_atoms += pVA[i].cInitCharge;</a>
<a name="ln2713">    }</a>
<a name="ln2714">    if ( bTreatMoreAtomsAsMetals &amp;&amp; !bSecondPassNewMetals ) {</a>
<a name="ln2715">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2716">            /* clear all members of pVA[i] except two */</a>
<a name="ln2717">            pTCGroups-&gt;charge_on_atoms -= pVA[i].cInitCharge;</a>
<a name="ln2718">            va1.cMetal               = pVA[i].cMetal;</a>
<a name="ln2719">            va1.cMinRingSize         = pVA[i].cMinRingSize;</a>
<a name="ln2720">            va1.cNumValenceElectrons = pVA[i].cNumValenceElectrons;</a>
<a name="ln2721">            va1.cPeriodicRowNumber   = pVA[i].cPeriodicRowNumber;</a>
<a name="ln2722">            va1.cPeriodicNumber      = pVA[i].cPeriodicNumber;</a>
<a name="ln2723">            pVA[i]           = va1;</a>
<a name="ln2724">        }</a>
<a name="ln2725">        bSecondPassNewMetals = 1;</a>
<a name="ln2726">        goto repeat_for_new_metals;</a>
<a name="ln2727">    }</a>
<a name="ln2728"> </a>
<a name="ln2729">    /* count atoms, bonds, additional edges and vertices in ChargeValence structures and t-groups */</a>
<a name="ln2730">    ret = nCountBnsSizes( at, num_at,  nAddEdges2eachAtom, nAddVertices, &amp;pStruct-&gt;ti,</a>
<a name="ln2731">                          pVA, pStruct-&gt;pSrm, pTCGroups );</a>
<a name="ln2732">    if ( ret &lt; 0 ) {</a>
<a name="ln2733">        goto exit_function;</a>
<a name="ln2734">    }</a>
<a name="ln2735">    </a>
<a name="ln2736">    /* find and count groups; add counts of all other vertices to be created */</a>
<a name="ln2737">    ret = nAddSuperCGroups( pTCGroups );</a>
<a name="ln2738">    if ( ret &lt; 0 ) {</a>
<a name="ln2739">        goto exit_function;</a>
<a name="ln2740">    }</a>
<a name="ln2741"> </a>
<a name="ln2742">    /* create the BNS and fill it with all real atoms */</a>
<a name="ln2743">    pBNS = AllocateAndInitTCGBnStruct( pStruct, pVA, pTCGroups,</a>
<a name="ln2744">                                       nMaxAddAtoms, nMaxAddEdges, max_altp, &amp;nNum_changed_bonds );</a>
<a name="ln2745">    if ( !pBNS ) {</a>
<a name="ln2746">        ret = BNS_OUT_OF_RAM;</a>
<a name="ln2747">        goto exit_function;</a>
<a name="ln2748">    }</a>
<a name="ln2749">    /* add t-groups to the BNS */</a>
<a name="ln2750">    ret = AddTGroups2TCGBnStruct( pBNS, pStruct, pVA, pTCGroups, nMaxAddEdges );</a>
<a name="ln2751">    if ( ret &lt; 0 ) {</a>
<a name="ln2752">        goto exit_function;</a>
<a name="ln2753">    }</a>
<a name="ln2754"> </a>
<a name="ln2755">    /* add c-groups to the BNS; adjust charges */</a>
<a name="ln2756">    ret = AddCGroups2TCGBnStruct( pBNS, pStruct, pVA, pTCGroups, nMaxAddEdges );</a>
<a name="ln2757">    if ( ret &lt; 0 ) {</a>
<a name="ln2758">        goto exit_function;</a>
<a name="ln2759">    }</a>
<a name="ln2760"> </a>
<a name="ln2761">    /* allocate BNData */</a>
<a name="ln2762">    pBD = AllocateAndInitBnData( pBNS-&gt;max_vertices + pBNS-&gt;max_vertices/2 );</a>
<a name="ln2763">    if ( !pBD ) {</a>
<a name="ln2764">        ret = BNS_OUT_OF_RAM;</a>
<a name="ln2765">        goto exit_function;</a>
<a name="ln2766">    }</a>
<a name="ln2767">    CheckBnsConsistency( pStruct, pBNS, pVA, pTCGroups, 0 );</a>
<a name="ln2768">    </a>
<a name="ln2769">    /* restore bonds &amp; charges */</a>
<a name="ln2770">    ret = RunBnsRestore1( ip, sd, pBNS, pBD, pStruct, pVA, pTCGroups, pInChI, num_inp, bHasSomeFixedH );</a>
<a name="ln2771">    if ( ret &lt; 0 ) {</a>
<a name="ln2772">        goto exit_function;</a>
<a name="ln2773">    }</a>
<a name="ln2774"> </a>
<a name="ln2775">    ret = CheckBnsConsistency( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2776">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2777">#ifndef TARGET_API_LIB</a>
<a name="ln2778">    if ( ret ) {</a>
<a name="ln2779">        fprintf( stdout, &quot;Msg for: %ld %s comp=%d %c%c\n&quot;, num_inp, (szCurHdr &amp;&amp; szCurHdr[0])? szCurHdr : &quot;&quot;, iComponent, pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F' ); </a>
<a name="ln2780">    }</a>
<a name="ln2781">    if ( pStruct-&gt;iMobileH == TAUT_YES &amp;&amp; pStruct-&gt;nNumRemovedProtons ) {</a>
<a name="ln2782">        fprintf( stdout, &quot;REMOVED_PROTONS%+d %ld %s\n&quot;, pStruct-&gt;nNumRemovedProtons, num_inp, (szCurHdr &amp;&amp; szCurHdr[0])? szCurHdr : &quot;&quot; ); </a>
<a name="ln2783">        /*pStruct-&gt;bExtract |= EXTRACT_STRUCT_NUMBER;*/</a>
<a name="ln2784">    }</a>
<a name="ln2785">    if ( pStruct-&gt;bExtract &amp; EXTRACT_STRUCT_NUMBER ) {</a>
<a name="ln2786">        fprintf( stdout, &quot;EXTRACT: %ld: %s\n&quot;, num_inp, (szCurHdr &amp;&amp; szCurHdr[0])? szCurHdr : &quot;&quot; );</a>
<a name="ln2787">    }</a>
<a name="ln2788">#endif</a>
<a name="ln2789">#endif</a>
<a name="ln2790">    {  /* create the final structure in pStruct-&gt;at2 */</a>
<a name="ln2791">        inp_ATOM *at_tmp = pStruct-&gt;at;</a>
<a name="ln2792">        pStruct-&gt;at = pStruct-&gt;at2;</a>
<a name="ln2793">        memcpy( pStruct-&gt;at, at_tmp, sizeof(pStruct-&gt;at[0])*(pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H) );</a>
<a name="ln2794">        ret2 = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln2795">        pStruct-&gt;at2 = pStruct-&gt;at;</a>
<a name="ln2796">        pStruct-&gt;at = at_tmp;</a>
<a name="ln2797">        if ( ret2 &lt; 0 ) {</a>
<a name="ln2798">            ret = ret2;</a>
<a name="ln2799">        }</a>
<a name="ln2800">    }</a>
<a name="ln2801"> </a>
<a name="ln2802">exit_function:</a>
<a name="ln2803"> </a>
<a name="ln2804">    pStruct-&gt;pbfsq = NULL;</a>
<a name="ln2805">    AllocBfsQueue( &amp;bfsq, BFS_Q_FREE, 0 );</a>
<a name="ln2806"> </a>
<a name="ln2807">    pBD = DeAllocateBnData( pBD );</a>
<a name="ln2808">    pBNS = DeAllocateBnStruct( pBNS );</a>
<a name="ln2809">    /*</a>
<a name="ln2810">    if ( pVA ) inchi_free( pVA );</a>
<a name="ln2811">    */</a>
<a name="ln2812">    if ( pTCGroups-&gt;pTCG ) inchi_free( pTCGroups-&gt;pTCG );</a>
<a name="ln2813"> </a>
<a name="ln2814">    return ret;</a>
<a name="ln2815">}</a>
<a name="ln2816">/******************************************************************************************************/</a>
<a name="ln2817">int OneInChI2Atom( ICHICONST INPUT_PARMS *ip_inp, STRUCT_DATA *sd, const char *szCurHdr, long num_inp,</a>
<a name="ln2818">                   StrFromINChI *pStruct, int iComponent, int iAtNoOffset, int bHasSomeFixedH, INChI *pInChI[])</a>
<a name="ln2819">{</a>
<a name="ln2820">    int ret;</a>
<a name="ln2821">    INPUT_PARMS *ip, ip_loc;</a>
<a name="ln2822"> </a>
<a name="ln2823">    ip_loc = *ip_inp;</a>
<a name="ln2824">    ip     = &amp;ip_loc;</a>
<a name="ln2825"> </a>
<a name="ln2826">    sd-&gt;pStrErrStruct[0] = '\0';</a>
<a name="ln2827">    ret = RestoreAtomConnectionsSetStereo( pStruct, iComponent, iAtNoOffset, pInChI[0], pInChI[1]);</a>
<a name="ln2828">    if ( ret &lt; 0 ) {</a>
<a name="ln2829">        goto exit_function;</a>
<a name="ln2830">    }</a>
<a name="ln2831">    ret = SetStereoBondTypesFrom0DStereo( pStruct, pInChI[0]);</a>
<a name="ln2832">    if ( ret &lt; 0 ) {</a>
<a name="ln2833">        goto exit_function;</a>
<a name="ln2834">    }</a>
<a name="ln2835">    ret = ReconcileAllCmlBondParities( pStruct-&gt;at, pStruct-&gt;num_atoms, 0 );</a>
<a name="ln2836">    if ( ret &lt; 0 ) {</a>
<a name="ln2837">        goto exit_function;</a>
<a name="ln2838">    }</a>
<a name="ln2839">    /* main InChI restore function */</a>
<a name="ln2840">    ret = RestoreAtomMakeBNS( ip, sd, pStruct, iComponent, iAtNoOffset, pInChI, szCurHdr, num_inp, bHasSomeFixedH );</a>
<a name="ln2841"> </a>
<a name="ln2842">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln2843">    if ( (pStruct-&gt;num_inp_actual&gt;0? pStruct-&gt;num_inp_actual : num_inp) &gt;= ip-&gt;first_struct_number &amp;&amp;</a>
<a name="ln2844">        ( (/*ret &gt; 0 &amp;&amp;*/ ip-&gt;bDisplayIfRestoreWarnings ) &amp;&amp; pStruct-&gt;pXYZ ) ) {</a>
<a name="ln2845">        inchiTime     ulTStart;</a>
<a name="ln2846">        InchiTimeGet( &amp;ulTStart );</a>
<a name="ln2847">        DisplayRestoredComponent( pStruct, iComponent, iAtNoOffset, pInChI[0], szCurHdr );</a>
<a name="ln2848">        sd-&gt;ulStructTime -= InchiTimeElapsed( &amp;ulTStart ); /* subtract display time */</a>
<a name="ln2849">    }</a>
<a name="ln2850">#endif</a>
<a name="ln2851">    if ( ret &lt; 0 ) {</a>
<a name="ln2852">        goto exit_function;</a>
<a name="ln2853">    }</a>
<a name="ln2854">    if ( (pStruct-&gt;num_inp_actual? pStruct-&gt;num_inp_actual: num_inp) &gt;= ip-&gt;first_struct_number &amp;&amp; ret &gt;= 0 ) {</a>
<a name="ln2855">        /* remove t-group markings and increment zero-order bonds,</a>
<a name="ln2856">           otherwise MakeInChIOutOfStrFromINChI2() woild fail */</a>
<a name="ln2857">        /* --- moved to MakeInChIOutOfStrFromINChI2 ---</a>
<a name="ln2858">        IncrZeroBondsAndClearEndpts(pStruct-&gt;at2, pStruct-&gt;num_atoms, iComponent+1);</a>
<a name="ln2859">        CopySt2At( pStruct-&gt;at2, pStruct-&gt;st, pStruct-&gt;num_atoms );</a>
<a name="ln2860">        */</a>
<a name="ln2861">        /* include all restored structure features in pStruct-&gt;at2 */</a>
<a name="ln2862">        /* make full InChI out of pStruct-&gt;at2, pStruct-&gt;num_atoms */</a>
<a name="ln2863">        /***************************************************************************************/</a>
<a name="ln2864">        /* !!! pStruct-&gt;One_InChI etc. were removed at the exit from NormalizeAndCompare() !!! */</a>
<a name="ln2865">        /***************************************************************************************/</a>
<a name="ln2866">        if ( bHasSomeFixedH &amp;&amp; pStruct-&gt;iInchiRec == INCHI_REC &amp;&amp; pStruct-&gt;iMobileH == TAUT_YES &amp;&amp;</a>
<a name="ln2867">             !pStruct-&gt;bFixedHExists &amp;&amp; !(ip-&gt;nMode &amp; REQ_MODE_BASIC) ) {</a>
<a name="ln2868">            /* reconnected components without Fixed-H layer may produce 'tautomeric' fragments like Cl(-) */</a>
<a name="ln2869">            ip-&gt;nMode |= REQ_MODE_BASIC;</a>
<a name="ln2870">        }</a>
<a name="ln2871">        ret = MakeInChIOutOfStrFromINChI2( ip, sd, pStruct, iComponent, iAtNoOffset, num_inp );</a>
<a name="ln2872">        if ( ret &gt;= 0 ) {</a>
<a name="ln2873">            ;</a>
<a name="ln2874">        } </a>
<a name="ln2875">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2876">#ifndef TARGET_API_LIB</a>
<a name="ln2877">        else {</a>
<a name="ln2878">            fprintf( stdout, &quot;\nERROR in MakeInChI-1: %ld %s Comp:%d %c%c Err:%d\n&quot;, num_inp,</a>
<a name="ln2879">                     szCurHdr? szCurHdr: &quot;???&quot;, iComponent, pStruct-&gt;iInchiRec? 'R':'D', pStruct-&gt;iMobileH?'M':'F', ret);</a>
<a name="ln2880">        }</a>
<a name="ln2881">#endif</a>
<a name="ln2882">#endif</a>
<a name="ln2883">    }</a>
<a name="ln2884"> </a>
<a name="ln2885"> </a>
<a name="ln2886">exit_function:</a>
<a name="ln2887">    return ret;</a>
<a name="ln2888">}</a>
<a name="ln2889">/********************************************************************************************/</a>
<a name="ln2890">int MakeProtonComponent( StrFromINChI *pStruct, int iComponent, int num_prot )</a>
<a name="ln2891">{</a>
<a name="ln2892">    inp_ATOM *at = NULL;</a>
<a name="ln2893">    int        i;</a>
<a name="ln2894"> </a>
<a name="ln2895">    if ( num_prot &lt;= 0 ) {</a>
<a name="ln2896">        return 0;</a>
<a name="ln2897">    }</a>
<a name="ln2898">    /* allocate */</a>
<a name="ln2899">    pStruct-&gt;at  = (inp_ATOM *) inchi_calloc( num_prot, sizeof(pStruct-&gt;at[0]) );</a>
<a name="ln2900">    pStruct-&gt;at2 = (inp_ATOM *) inchi_calloc( num_prot, sizeof(pStruct-&gt;at2[0]) );</a>
<a name="ln2901">    if ( !pStruct-&gt;at || !pStruct-&gt;at2 ) {</a>
<a name="ln2902">        return 0;</a>
<a name="ln2903">    }</a>
<a name="ln2904">    /* create protons */</a>
<a name="ln2905">    at = pStruct-&gt;at;</a>
<a name="ln2906">    /* fill out proton atom info */</a>
<a name="ln2907">    for ( i = 0; i &lt; num_prot; i ++ ) {</a>
<a name="ln2908">        strcpy( at[i].elname, &quot;H&quot; );</a>
<a name="ln2909">        at[i].el_number = EL_NUMBER_H;</a>
<a name="ln2910">        at[i].orig_at_number = i+1;</a>
<a name="ln2911">        /*</a>
<a name="ln2912">        at[i].orig_compt_at_numb = i + 1;</a>
<a name="ln2913">        at[i].component = i + 1;</a>
<a name="ln2914">        */</a>
<a name="ln2915">        at[i].charge    = 1;</a>
<a name="ln2916">    }</a>
<a name="ln2917">    memcpy( pStruct-&gt;at2, at, num_prot * sizeof(pStruct-&gt;at2[0]) );</a>
<a name="ln2918">    pStruct-&gt;bDeleted = 0;</a>
<a name="ln2919">    pStruct-&gt;num_atoms = num_prot;</a>
<a name="ln2920">    pStruct-&gt;bMobileH  = TAUT_YES;</a>
<a name="ln2921">    pStruct-&gt;iMobileH  = TAUT_YES;</a>
<a name="ln2922">    return num_prot; </a>
<a name="ln2923">}</a>
<a name="ln2924">/********************************************************************************************/</a>
<a name="ln2925">int AddRemProtonsInRestrStruct( ICHICONST INPUT_PARMS *ip_inp,  STRUCT_DATA *sd, long num_inp,</a>
<a name="ln2926">                                int bHasSomeFixedH,</a>
<a name="ln2927">                                StrFromINChI *pStruct, int num_components,</a>
<a name="ln2928">                                StrFromINChI *pStructR, int num_componentsR,</a>
<a name="ln2929">                                NUM_H *nProtonsToBeRemovedByNormFromRevrs, int *recmet_change_balance )</a>
<a name="ln2930">{   /* on entry and exit, all at[i].num_H do not include isotopic H  and explicit terminal H are connected */</a>
<a name="ln2931">    int  iComp, q, ret = 0;</a>
<a name="ln2932">    int      num_atoms, tot_num_at, num_deleted_H, num_tg, num_changed, num_deleted_components;</a>
<a name="ln2933">    inp_ATOM *at;</a>
<a name="ln2934">    INPUT_PARMS *ip, ip_loc;</a>
<a name="ln2935">    int      num_prot = *nProtonsToBeRemovedByNormFromRevrs;</a>
<a name="ln2936">    int      delta_recmet_prot, num_prot_prev, bAccumulateChanges=0, nNumProtAddedByRevrs;</a>
<a name="ln2937">    INChI_Aux *pINChI_Aux;</a>
<a name="ln2938">    INCHI_MODE bNormalizationFlags;</a>
<a name="ln2939">    int        nChargeRevrs, nChargeInChI;</a>
<a name="ln2940"> </a>
<a name="ln2941">    if ( !num_prot ) {</a>
<a name="ln2942">        return 0;</a>
<a name="ln2943">    }</a>
<a name="ln2944">    delta_recmet_prot = 0;</a>
<a name="ln2945">    num_changed       = 0;</a>
<a name="ln2946">    num_deleted_components = 0;</a>
<a name="ln2947">    ip_loc = *ip_inp;</a>
<a name="ln2948">    ip     = &amp;ip_loc;</a>
<a name="ln2949">    /*----------------------------------------------------------------------------------</a>
<a name="ln2950">    nLink &lt; 0 &amp;&amp; num_componentsR &gt; 0 =&gt; This is a Disconnected structure component; it is</a>
<a name="ln2951">                                        same as already processed reconnected one</a>
<a name="ln2952">                                        Do no preicess it</a>
<a name="ln2953"> </a>
<a name="ln2954">    nLink &gt; 0 &amp;&amp; num_componentsR &gt; 0 =&gt; This is a Disconnected structure component;</a>
<a name="ln2955">    (should not happen)                 It it is a result of (nLink-1)th Reconeected</a>
<a name="ln2956">                                        component disconnection (NOT IMPLEMENTED YET)</a>
<a name="ln2957"> </a>
<a name="ln2958">    nLink = 0                        =&gt; Process this component. It is either a reconnected</a>
<a name="ln2959">                                        component, or a result of a disconnection (for now)</a>
<a name="ln2960"> </a>
<a name="ln2961">    nLink &gt; 0 &amp;&amp; num_componentsR = 0 =&gt; This is a Reconnected component that is same as</a>
<a name="ln2962">                                        a disconnected one that will not be processed.</a>
<a name="ln2963">                                        Process and save charge delta.</a>
<a name="ln2964">    -----------------------------------------------------------------------------------*/</a>
<a name="ln2965"> </a>
<a name="ln2966">    for ( iComp = 0; iComp &lt; num_components &amp;&amp; num_prot; iComp ++ ) {</a>
<a name="ln2967">        bAccumulateChanges = 0;</a>
<a name="ln2968">        if ( pStruct[iComp].nLink &lt; 0 &amp;&amp; num_componentsR &gt; 0 ) {</a>
<a name="ln2969">            /* check */</a>
<a name="ln2970">            q = -(pStruct[iComp].nLink+1);</a>
<a name="ln2971">            if ( !pStructR || !num_componentsR || q &gt;= num_componentsR || pStructR[q].nLink != (iComp+1) ) {</a>
<a name="ln2972">                ret = RI_ERR_PROGR;</a>
<a name="ln2973">                goto exit_function;</a>
<a name="ln2974">            }</a>
<a name="ln2975">            continue; /* Disconnected structure component has already been processed as a Reconnected one */</a>
<a name="ln2976">        }</a>
<a name="ln2977"> </a>
<a name="ln2978">        at           = pStruct[iComp].at2;</a>
<a name="ln2979">        num_atoms    = pStruct[iComp].num_atoms;</a>
<a name="ln2980">        tot_num_at   = pStruct[iComp].num_atoms+(num_deleted_H=pStruct[iComp].num_deleted_H);</a>
<a name="ln2981">        bAccumulateChanges = ( pStruct[iComp].nLink &gt; 0 &amp;&amp; !num_componentsR );</a>
<a name="ln2982">        nChargeRevrs = pStruct[iComp].nChargeRevrs;</a>
<a name="ln2983">        nChargeInChI = pStruct[iComp].nChargeInChI;</a>
<a name="ln2984">        num_deleted_components += (0 != pStruct[iComp].bDeleted);</a>
<a name="ln2985">        if ( !at || !num_atoms ) {</a>
<a name="ln2986">            continue;</a>
<a name="ln2987">        }</a>
<a name="ln2988">        /* find whether it is a reconnected structure */</a>
<a name="ln2989">        q = bRevInchiComponentExists( pStruct+iComp, INCHI_REC, TAUT_YES, 0 )? INCHI_REC : INCHI_BAS;</a>
<a name="ln2990">        /*</a>
<a name="ln2991">        q = pStruct[iComp].RevInChI.pINChI_Aux[INCHI_REC] &amp;&amp;</a>
<a name="ln2992">            pStruct[iComp].RevInChI.pINChI_Aux[INCHI_REC][0][TAUT_YES] &amp;&amp;</a>
<a name="ln2993">            pStruct[iComp].RevInChI.pINChI_Aux[INCHI_REC][0][TAUT_YES]-&gt;nNumberOfAtoms? INCHI_REC : INCHI_BAS;</a>
<a name="ln2994">        */</a>
<a name="ln2995">        pINChI_Aux = pStruct[iComp].RevInChI.pINChI_Aux[q][0][TAUT_YES]; /* 0 = 1st component in RevInChI */</a>
<a name="ln2996">        /*nNumProtAddedByRevrs = pINChI_Aux-&gt;nNumRemovedProtons;*/</a>
<a name="ln2997">        nNumProtAddedByRevrs = -pStruct[iComp].nNumRemovedProtonsByRevrs;</a>
<a name="ln2998">        bNormalizationFlags  = pINChI_Aux-&gt;bNormalizationFlags;</a>
<a name="ln2999">        num_tg               = pINChI_Aux-&gt;nNumberOfTGroups;</a>
<a name="ln3000"> </a>
<a name="ln3001"> </a>
<a name="ln3002">        /* disconnect all explicit H and add the number of implicit iso H and all explicit terminal H to the number of implicit H */</a>
<a name="ln3003">        if ( 0 &gt; ( ret = DisconnectedConnectedH( at, num_atoms, num_deleted_H ) ) ) {</a>
<a name="ln3004">            goto exit_function;</a>
<a name="ln3005">        }</a>
<a name="ln3006">        num_prot_prev = num_prot;</a>
<a name="ln3007">        ret = AddRemoveProtonsRestr( at, num_atoms, &amp;num_prot, nNumProtAddedByRevrs,</a>
<a name="ln3008">                                     bNormalizationFlags, num_tg, nChargeRevrs, nChargeInChI );</a>
<a name="ln3009">        </a>
<a name="ln3010">        pStruct[iComp].bPostProcessed = ret;</a>
<a name="ln3011">        num_changed += (ret &gt; 0);</a>
<a name="ln3012">        if ( ret &lt; 0 ) {</a>
<a name="ln3013">            goto exit_function;</a>
<a name="ln3014">        }</a>
<a name="ln3015">        if ( ret &gt; 0 ) {</a>
<a name="ln3016">            /* recalculate InChI; it will reconnect at */</a>
<a name="ln3017">            StrFromINChI *pStruct1 = pStruct + iComp;</a>
<a name="ln3018">            INCHI_MODE    nMode = ip-&gt;nMode;</a>
<a name="ln3019">            FreeAllINChIArrays( pStruct1-&gt;RevInChI.pINChI,</a>
<a name="ln3020">                                pStruct1-&gt;RevInChI.pINChI_Aux,</a>
<a name="ln3021">                                pStruct1-&gt;RevInChI.num_components );</a>
<a name="ln3022"> </a>
<a name="ln3023">            if ( bHasSomeFixedH &amp;&amp; pStruct1-&gt;iInchiRec == INCHI_REC &amp;&amp; pStruct1-&gt;iMobileH == TAUT_YES &amp;&amp;</a>
<a name="ln3024">                 !pStruct1-&gt;bFixedHExists &amp;&amp; !(ip-&gt;nMode &amp; REQ_MODE_BASIC) ) {</a>
<a name="ln3025">                /* reconnected components without Fixed-H layer may produce 'tautomeric' fragments like Cl(-) */</a>
<a name="ln3026">                ip-&gt;nMode |= REQ_MODE_BASIC;</a>
<a name="ln3027">            }</a>
<a name="ln3028">            /* calls ConnectDisconnectedH(...): subtracts number of implicit iso H from implicit H */</a>
<a name="ln3029">            ret = MakeInChIOutOfStrFromINChI2( ip, sd, pStruct1, 0, 0, num_inp );</a>
<a name="ln3030">            ip-&gt;nMode = nMode;</a>
<a name="ln3031">            if ( ret &lt; 0 ) {</a>
<a name="ln3032">                goto exit_function;</a>
<a name="ln3033">            }</a>
<a name="ln3034">        } else {</a>
<a name="ln3035">            /* reconnect disconnected terminal H and subtracts number of implicit iso H from implicit H */</a>
<a name="ln3036">            if ( 0 &gt; ( ret = ConnectDisconnectedH( at, num_atoms, num_deleted_H ) ) ) {</a>
<a name="ln3037">                goto exit_function;</a>
<a name="ln3038">            }</a>
<a name="ln3039">        }</a>
<a name="ln3040">        if ( bAccumulateChanges &amp;&amp; recmet_change_balance ) {</a>
<a name="ln3041">            /* processed Reconnected layer component that is also present in Disconnected layer */</a>
<a name="ln3042">            delta_recmet_prot += num_prot - num_prot_prev;</a>
<a name="ln3043">        }</a>
<a name="ln3044">    }</a>
<a name="ln3045"> </a>
<a name="ln3046">    iComp = num_components-1;</a>
<a name="ln3047">    if ( !bHasSomeFixedH &amp;&amp; num_prot &gt; 0 &amp;&amp; 1 == num_deleted_components &amp;&amp; iComp &gt;= 0 &amp;&amp; pStruct[iComp].bDeleted ) {</a>
<a name="ln3048">        /* add bare protons to the deleted Mobile-H component; undelete the component */</a>
<a name="ln3049">        num_prot_prev = num_prot;</a>
<a name="ln3050">        if ( !MakeProtonComponent( pStruct+iComp, iComp, num_prot ) ) {</a>
<a name="ln3051">            goto exit_function;</a>
<a name="ln3052">        } else {</a>
<a name="ln3053">            /* recalculate InChI; it will reconnect at */</a>
<a name="ln3054">            StrFromINChI *pStruct1 = pStruct + iComp;</a>
<a name="ln3055">            INCHI_MODE    nMode = ip-&gt;nMode;</a>
<a name="ln3056">            num_changed ++;</a>
<a name="ln3057">            num_prot = 0;</a>
<a name="ln3058">            FreeAllINChIArrays( pStruct1-&gt;RevInChI.pINChI,</a>
<a name="ln3059">                                pStruct1-&gt;RevInChI.pINChI_Aux,</a>
<a name="ln3060">                                pStruct1-&gt;RevInChI.num_components );</a>
<a name="ln3061"> </a>
<a name="ln3062">            if ( bHasSomeFixedH &amp;&amp; pStruct1-&gt;iInchiRec == INCHI_REC &amp;&amp; pStruct1-&gt;iMobileH == TAUT_YES &amp;&amp;</a>
<a name="ln3063">                 !pStruct1-&gt;bFixedHExists &amp;&amp; !(ip-&gt;nMode &amp; REQ_MODE_BASIC) ) {</a>
<a name="ln3064">                /* reconnected components without Fixed-H layer may produce 'tautomeric' fragments like Cl(-) */</a>
<a name="ln3065">                ip-&gt;nMode |= REQ_MODE_BASIC;</a>
<a name="ln3066">            }</a>
<a name="ln3067">            /* Although MakeInChIOutOfStrFromINChI2() calls ConnectDisconnectedH(...) */</a>
<a name="ln3068">            /* to subtracts number of implicit iso H from implicit H */</a>
<a name="ln3069">            /* this CANNOT have any effect on the deleted H component */</a>
<a name="ln3070">            ret = MakeInChIOutOfStrFromINChI2( ip, sd, pStruct1, 0, 0, num_inp );</a>
<a name="ln3071">            ip-&gt;nMode = nMode;</a>
<a name="ln3072">            if ( ret &lt; 0 ) {</a>
<a name="ln3073">                goto exit_function;</a>
<a name="ln3074">            }</a>
<a name="ln3075">            if ( bAccumulateChanges &amp;&amp; recmet_change_balance ) {</a>
<a name="ln3076">                /* processed Reconnected layer component that is also present in Disconnected layer */</a>
<a name="ln3077">                delta_recmet_prot += num_prot - num_prot_prev;</a>
<a name="ln3078">            }</a>
<a name="ln3079">        }</a>
<a name="ln3080">    }</a>
<a name="ln3081">    *nProtonsToBeRemovedByNormFromRevrs = num_prot;</a>
<a name="ln3082">    if ( recmet_change_balance ) {</a>
<a name="ln3083">        *recmet_change_balance = delta_recmet_prot;</a>
<a name="ln3084">    }</a>
<a name="ln3085"> </a>
<a name="ln3086">exit_function:</a>
<a name="ln3087">    return ret &lt; 0? ret : num_changed;</a>
<a name="ln3088">}</a>
<a name="ln3089">/**********************************************************************************/</a>
<a name="ln3090">int AddRemIsoProtonsInRestrStruct( ICHICONST INPUT_PARMS *ip_inp,  STRUCT_DATA *sd, long num_inp, int bHasSomeFixedH,</a>
<a name="ln3091">                                StrFromINChI *pStruct, int num_components,</a>
<a name="ln3092">                                StrFromINChI *pStructR, int num_componentsR,</a>
<a name="ln3093">                                NUM_H pProtonBalance[], NUM_H recmet_change_balance[] )</a>
<a name="ln3094">{   /* on entry and exit, all at[i].num_H do not include isotopic H and explicit terminal H are connected */</a>
<a name="ln3095">    int  iComp, q, k, ret = 0, bNotEmpty;</a>
<a name="ln3096">    int      num_atoms, tot_num_at, num_deleted_H, num_tg, num_changed;</a>
<a name="ln3097">    inp_ATOM *at;</a>
<a name="ln3098">    NUM_H    num_prot[NUM_H_ISOTOPES], delta_recmet_prot[NUM_H_ISOTOPES], num_prot_prev[NUM_H_ISOTOPES];</a>
<a name="ln3099">    int      bAccumulateChanges;</a>
<a name="ln3100">    INChI_Aux *pINChI_Aux;</a>
<a name="ln3101">    INChI     *pINChI;</a>
<a name="ln3102">    INCHI_MODE bNormalizationFlags;</a>
<a name="ln3103">    INPUT_PARMS *ip, ip_loc;</a>
<a name="ln3104"> </a>
<a name="ln3105">    ip_loc = *ip_inp;</a>
<a name="ln3106">    ip     = &amp;ip_loc;</a>
<a name="ln3107"> </a>
<a name="ln3108">    memcpy( num_prot, pProtonBalance, sizeof(num_prot) );</a>
<a name="ln3109">    for ( bNotEmpty=0, k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln3110">        bNotEmpty |= num_prot[k];</a>
<a name="ln3111">    }</a>
<a name="ln3112">    if ( !bNotEmpty ) {</a>
<a name="ln3113">        return 0;</a>
<a name="ln3114">    }</a>
<a name="ln3115">    memset ( delta_recmet_prot, 0, sizeof(delta_recmet_prot));</a>
<a name="ln3116">    num_changed       = 0;</a>
<a name="ln3117">    /*----------------------------------------------------------------------------------</a>
<a name="ln3118">    nLink &lt; 0 &amp;&amp; num_componentsR &gt; 0 =&gt; This is a Disconnected structure component; it is</a>
<a name="ln3119">                                        same as already processed reconnected one</a>
<a name="ln3120">                                        Do no preicess it</a>
<a name="ln3121"> </a>
<a name="ln3122">    nLink &gt; 0 &amp;&amp; num_componentsR &gt; 0 =&gt; This is a Disconnected structure component;</a>
<a name="ln3123">    (should not happen)                 It it is a result of (nLink-1)th Reconeected</a>
<a name="ln3124">                                        component disconnection (NOT IMPLEMENTED YET)</a>
<a name="ln3125"> </a>
<a name="ln3126">    nLink = 0                        =&gt; Process this component. It is either a reconnected</a>
<a name="ln3127">                                        component, or a result of a disconnection (for now)</a>
<a name="ln3128"> </a>
<a name="ln3129">    nLink &gt; 0 &amp;&amp; num_componentsR = 0 =&gt; This is a Reconnected component that is same as</a>
<a name="ln3130">                                        a disconnected one that will not be processed.</a>
<a name="ln3131">                                        Process and save charge delta.</a>
<a name="ln3132">    -----------------------------------------------------------------------------------*/</a>
<a name="ln3133"> </a>
<a name="ln3134">    for ( iComp = 0; iComp &lt; num_components &amp;&amp; num_prot; iComp ++ ) {</a>
<a name="ln3135">        bAccumulateChanges = 0;</a>
<a name="ln3136">        if ( pStruct[iComp].nLink &lt; 0 &amp;&amp; num_componentsR &gt; 0 ) {</a>
<a name="ln3137">            /* check */</a>
<a name="ln3138">            q = -(pStruct[iComp].nLink+1);</a>
<a name="ln3139">            if ( !pStructR || !num_componentsR || q &gt;= num_componentsR || pStructR[q].nLink != (iComp+1) ) {</a>
<a name="ln3140">                ret = RI_ERR_PROGR;</a>
<a name="ln3141">                goto exit_function;</a>
<a name="ln3142">            }</a>
<a name="ln3143">            continue; /* Disconnected structure component has already been processed as a Reconnected one */</a>
<a name="ln3144">        }</a>
<a name="ln3145"> </a>
<a name="ln3146">        at         = pStruct[iComp].at2;</a>
<a name="ln3147">        num_atoms  = pStruct[iComp].num_atoms;</a>
<a name="ln3148">        tot_num_at = pStruct[iComp].num_atoms+(num_deleted_H=pStruct[iComp].num_deleted_H);</a>
<a name="ln3149">        bAccumulateChanges = ( pStruct[iComp].nLink &gt; 0 &amp;&amp; !num_componentsR );</a>
<a name="ln3150">        </a>
<a name="ln3151">        if ( !at || !num_atoms ) {</a>
<a name="ln3152">            continue;</a>
<a name="ln3153">        }</a>
<a name="ln3154">        /* find whether it is a reconnected structure */</a>
<a name="ln3155">        q = pStruct[iComp].RevInChI.pINChI_Aux[INCHI_REC] &amp;&amp;</a>
<a name="ln3156">            pStruct[iComp].RevInChI.pINChI_Aux[INCHI_REC][0][TAUT_YES] &amp;&amp;</a>
<a name="ln3157">            pStruct[iComp].RevInChI.pINChI_Aux[INCHI_REC][0][TAUT_YES]-&gt;nNumberOfAtoms? INCHI_REC : INCHI_BAS;</a>
<a name="ln3158"> </a>
<a name="ln3159">        pINChI_Aux = pStruct[iComp].RevInChI.pINChI_Aux[q][0][TAUT_YES]; /* 0 = 1st component in RevInChI */</a>
<a name="ln3160">        pINChI     = pStruct[iComp].RevInChI.pINChI[q][0][TAUT_YES]; /* 0 = 1st component in RevInChI */</a>
<a name="ln3161">        bNormalizationFlags  = pINChI_Aux-&gt;bNormalizationFlags;</a>
<a name="ln3162">        num_tg               = pINChI_Aux-&gt;nNumberOfTGroups;</a>
<a name="ln3163">        memcpy( num_prot_prev, num_prot, sizeof(num_prot_prev) );</a>
<a name="ln3164"> </a>
<a name="ln3165">        /* pass CONNECTED explicit H to AddRemoveIsoProtonsRestr() for isotopic H addition */</a>
<a name="ln3166">        ret = AddRemoveIsoProtonsRestr( at, num_atoms, num_prot, num_tg );</a>
<a name="ln3167">        </a>
<a name="ln3168">        pStruct[iComp].bPostProcessed |= ret;</a>
<a name="ln3169">        num_changed += (ret &gt; 0);</a>
<a name="ln3170">        if ( ret &lt; 0 ) {</a>
<a name="ln3171">            goto exit_function;</a>
<a name="ln3172">        }</a>
<a name="ln3173">        if ( ret &gt; 0 ) {</a>
<a name="ln3174">            StrFromINChI *pStruct1 = pStruct+iComp;</a>
<a name="ln3175">            INCHI_MODE    nMode = ip-&gt;nMode;</a>
<a name="ln3176">            /* recalculate InChI; MakeInChIOutOfStrFromINChI2() will reconnect explicit H */</a>
<a name="ln3177">            /* disconnect all explicit H and add the number of implicit iso H and all explicit terminal H to the number of implicit H */</a>
<a name="ln3178">            if ( 0 &gt; ( ret = DisconnectedConnectedH( at, num_atoms, num_deleted_H ) ) ) {</a>
<a name="ln3179">                goto exit_function;</a>
<a name="ln3180">            }</a>
<a name="ln3181">            FreeAllINChIArrays( pStruct1-&gt;RevInChI.pINChI,</a>
<a name="ln3182">                                pStruct1-&gt;RevInChI.pINChI_Aux,</a>
<a name="ln3183">                                pStruct1-&gt;RevInChI.num_components );</a>
<a name="ln3184">            if ( bHasSomeFixedH &amp;&amp; pStruct1-&gt;iInchiRec == INCHI_REC &amp;&amp; pStruct1-&gt;iMobileH == TAUT_YES &amp;&amp;</a>
<a name="ln3185">                 !pStruct1-&gt;bFixedHExists &amp;&amp; !(ip-&gt;nMode &amp; REQ_MODE_BASIC) ) {</a>
<a name="ln3186">                /* reconnected components without Fixed-H layer may produce 'tautomeric' fragments like Cl(-) */</a>
<a name="ln3187">                ip-&gt;nMode |= REQ_MODE_BASIC;</a>
<a name="ln3188">            }</a>
<a name="ln3189">            /* input: disconnected explicit H, output: connected explicit H */</a>
<a name="ln3190">            ret = MakeInChIOutOfStrFromINChI2( ip, sd, pStruct1, 0, 0, num_inp );</a>
<a name="ln3191">            ip-&gt;nMode = nMode;</a>
<a name="ln3192">            if ( ret &lt; 0 ) {</a>
<a name="ln3193">                goto exit_function;</a>
<a name="ln3194">            }</a>
<a name="ln3195">        }</a>
<a name="ln3196">        /* the following was commented out 2007-08-28 by DT. Reason: it's a bug since H must be already connected */</a>
<a name="ln3197">        /* else {</a>
<a name="ln3198">            if ( 0 &gt; ( ret = ConnectDisconnectedH( at, num_atoms, num_deleted_H ) ) ) {</a>
<a name="ln3199">                goto exit_function;</a>
<a name="ln3200">            }</a>
<a name="ln3201">        } */</a>
<a name="ln3202">        if ( bAccumulateChanges ) {</a>
<a name="ln3203">            /* processed Reconnected layer component that is also present in Disconnected layer */</a>
<a name="ln3204">            for ( k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln3205">                delta_recmet_prot[k] += num_prot[k] - num_prot_prev[k];</a>
<a name="ln3206">            }</a>
<a name="ln3207">        }</a>
<a name="ln3208">    }</a>
<a name="ln3209"> </a>
<a name="ln3210">    memcpy ( pProtonBalance, num_prot, sizeof(num_prot) );</a>
<a name="ln3211">    if ( recmet_change_balance ) {</a>
<a name="ln3212">        memcpy ( recmet_change_balance, delta_recmet_prot, sizeof(delta_recmet_prot) );</a>
<a name="ln3213">    }</a>
<a name="ln3214">exit_function:</a>
<a name="ln3215">    return ret &lt; 0? ret : num_changed;</a>
<a name="ln3216">}</a>
<a name="ln3217"> </a>
<a name="ln3218">#endif</a>

</code></pre>
<div class="balloon" rel="269"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: iNH >= 0.</p></div>
<div class="balloon" rel="217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 202, 217.</p></div>
<div class="balloon" rel="704"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pStruct->pOneINChI[0]' pointer was utilized before it was verified against nullptr. Check lines: 704, 712.</p></div>
<div class="balloon" rel="1259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'cmpInChI2' should be checked here.</p></div>
<div class="balloon" rel="2106"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pe->flow != 2 * delta' is always true.</p></div>
<div class="balloon" rel="2232"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !at2.</p></div>
<div class="balloon" rel="2233"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !at3.</p></div>
<div class="balloon" rel="2580"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'at2' is always false.</p></div>
<div class="balloon" rel="2630"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'at3' is always true.</p></div>
<div class="balloon" rel="2812"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pTCGroups->pTCG' is always true.</p></div>
<div class="balloon" rel="2854"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: ret >= 0.</p></div>
<div class="balloon" rel="2971"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !num_componentsR.</p></div>
<div class="balloon" rel="3062"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: bHasSomeFixedH.</p></div>
<div class="balloon" rel="3071"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'ip->nMode' variable was assigned the same value.</p></div>
<div class="balloon" rel="3134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v600/" target="_blank">V600</a> Consider inspecting the condition. The 'num_prot' pointer is always not equal to NULL.</p></div>
<div class="balloon" rel="3139"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !num_componentsR.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

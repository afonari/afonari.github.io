
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>perception.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">  perception.cpp - Stereochemistry perception</a>
<a name="ln3"> </a>
<a name="ln4">  Copyright (C) 2009-2010 by Tim Vandermeersch</a>
<a name="ln5"> </a>
<a name="ln6">  This file is part of the Open Babel project.</a>
<a name="ln7">  For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln8"> </a>
<a name="ln9">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln10">  it under the terms of the GNU General Public License as published by</a>
<a name="ln11">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln12">  (at your option) any later version.</a>
<a name="ln13"> </a>
<a name="ln14">  This program is distributed in the hope that it will be useful,</a>
<a name="ln15">  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln17">  GNU General Public License for more details.</a>
<a name="ln18"> </a>
<a name="ln19">  You should have received a copy of the GNU General Public License</a>
<a name="ln20">  along with this program; if not, write to the Free Software</a>
<a name="ln21">  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</a>
<a name="ln22">  02110-1301, USA.</a>
<a name="ln23"> **********************************************************************/</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;openbabel/stereo/tetrahedral.h&gt;</a>
<a name="ln27">#include &lt;openbabel/stereo/cistrans.h&gt;</a>
<a name="ln28">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln29">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln30">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln31">#include &lt;openbabel/ring.h&gt;</a>
<a name="ln32">#include &lt;openbabel/obutil.h&gt;</a>
<a name="ln33">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln34">#include &lt;openbabel/generic.h&gt;</a>
<a name="ln35">#include &lt;openbabel/graphsym.h&gt;</a>
<a name="ln36">#include &lt;openbabel/math/matrix3x3.h&gt;</a>
<a name="ln37">#include &lt;openbabel/canon.h&gt;</a>
<a name="ln38">#include &lt;openbabel/oberror.h&gt;</a>
<a name="ln39">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln40">#include &lt;cassert&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;stereoutil.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;cmath&gt;</a>
<a name="ln45">#include &lt;limits&gt;</a>
<a name="ln46">#include &lt;set&gt;</a>
<a name="ln47">#include &lt;iterator&gt;</a>
<a name="ln48">#include &lt;functional&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#define DEBUG 0</a>
<a name="ln51">#define DEBUG_INVERSIONS 0</a>
<a name="ln52">#define IMPLICIT_CIS_RING_SIZE 8</a>
<a name="ln53">#define DELTA_ANGLE_FOR_OVERLAPPING_BONDS 4.0 // In degrees</a>
<a name="ln54"> </a>
<a name="ln55">using namespace std;</a>
<a name="ln56"> </a>
<a name="ln57">// debug function</a>
<a name="ln58">template&lt;typename T&gt;</a>
<a name="ln59">void print_vector(const std::string &amp;label, const std::vector&lt;T&gt; &amp;v)</a>
<a name="ln60">{</a>
<a name="ln61">  std::cout &lt;&lt; label &lt;&lt; &quot;: &quot;;</a>
<a name="ln62">  for (std::size_t i = 0; i &lt; v.size(); ++i)</a>
<a name="ln63">    std::cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;</a>
<a name="ln64">  std::cout &lt;&lt; endl;</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">namespace OpenBabel {</a>
<a name="ln68"> </a>
<a name="ln69">  OBAtom* findAtomWithSymmetryClass(OBAtom *atom, unsigned int symClass, const std::vector&lt;unsigned int&gt; &amp;symClasses);</a>
<a name="ln70">  bool containsAtLeast_1true_2para(OBAtom *ligandAtom, OBAtom *atom, const OBStereoUnitSet &amp;units);</a>
<a name="ln71">  bool containsAtLeast_2true_2paraAssemblies(OBAtom *ligandAtom, OBAtom *atom, const OBStereoUnitSet &amp;units, const std::vector&lt;OBBitVec&gt; &amp;mergedRings);</a>
<a name="ln72"> </a>
<a name="ln73">  //////////////////////////////////////////////////////////////////////////////</a>
<a name="ln74">  //</a>
<a name="ln75">  //  General</a>
<a name="ln76">  //</a>
<a name="ln77">  //////////////////////////////////////////////////////////////////////////////</a>
<a name="ln78"> </a>
<a name="ln79">  void PerceiveStereo(OBMol *mol, bool force)</a>
<a name="ln80">  {</a>
<a name="ln81">    switch (mol-&gt;GetDimension()) {</a>
<a name="ln82">      case 3:</a>
<a name="ln83">        StereoFrom3D(mol, force);</a>
<a name="ln84">        break;</a>
<a name="ln85">      case 2:</a>
<a name="ln86">        StereoFrom2D(mol, nullptr, force);</a>
<a name="ln87">        break;</a>
<a name="ln88">      default:</a>
<a name="ln89">        StereoFrom0D(mol);</a>
<a name="ln90">        break;</a>
<a name="ln91">    }</a>
<a name="ln92">    if (obErrorLog.GetOutputLevel() &gt;= obAuditMsg)</a>
<a name="ln93">      obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::PerceiveStereo&quot;, obAuditMsg);</a>
<a name="ln94">  }</a>
<a name="ln95"> </a>
<a name="ln96">  /**</a>
<a name="ln97">   * Perform a quick check for tetrahedral stereo centers. Used by</a>
<a name="ln98">   * FindStereogenicUnits to return quickly if there are no stereogenic units.</a>
<a name="ln99">   */</a>
<a name="ln100">  bool mayHaveTetrahedralCenter(OBMol *mol)</a>
<a name="ln101">  {</a>
<a name="ln102">    std::vector&lt;OBAtom*&gt;::iterator ia;</a>
<a name="ln103">    for (OBAtom *atom = mol-&gt;BeginAtom(ia); atom; atom = mol-&gt;NextAtom(ia))</a>
<a name="ln104">      if (atom-&gt;GetHyb() == 3 &amp;&amp; atom-&gt;GetHvyDegree() &gt;= 3) {</a>
<a name="ln105">        return true;</a>
<a name="ln106">      }</a>
<a name="ln107">    return false;</a>
<a name="ln108">  }</a>
<a name="ln109"> </a>
<a name="ln110">  /**</a>
<a name="ln111">   * Perform a quick check for stereogenic bonds. Used by FindStereogenicUnits</a>
<a name="ln112">   * to return quickly if there are no stereogenic units.</a>
<a name="ln113">   */</a>
<a name="ln114">  bool mayHaveCisTransBond(OBMol *mol)</a>
<a name="ln115">  {</a>
<a name="ln116">    std::vector&lt;OBBond*&gt;::iterator ib;</a>
<a name="ln117">    for (OBBond *bond = mol-&gt;BeginBond(ib); bond; bond = mol-&gt;NextBond(ib))</a>
<a name="ln118">      if (bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln119">        return true;</a>
<a name="ln120">      }</a>
<a name="ln121">    return false;</a>
<a name="ln122">  }</a>
<a name="ln123"> </a>
<a name="ln124">  /**</a>
<a name="ln125">   * Check if the specified atom is a potential stereogenic atom.</a>
<a name="ln126">   *</a>
<a name="ln127">   * Criteria:</a>
<a name="ln128">   * - sp3 hybridization (or P and sp3d hybridization)</a>
<a name="ln129">   * - not connected to more than 4 atoms</a>
<a name="ln130">   * - at least 3 &quot;heavy&quot; neighbors</a>
<a name="ln131">   *</a>
<a name="ln132">   * Nitrogen (neutral) is treated as a special case since the barrier of inversion is</a>
<a name="ln133">   * low in many cases making the atom non-stereogenic. Only bridge-head</a>
<a name="ln134">   * nitrogen atoms (i.e. nitrogen has 3 neighbors in rings) will be</a>
<a name="ln135">   * considered stereogenic.</a>
<a name="ln136">   */</a>
<a name="ln137">  bool isPotentialTetrahedral(OBAtom *atom)</a>
<a name="ln138">  {</a>
<a name="ln139">    // consider only potential steroecenters</a>
<a name="ln140">    if ((atom-&gt;GetHyb() != 3 &amp;&amp; !(atom-&gt;GetHyb() == 5 &amp;&amp; atom-&gt;GetAtomicNum() == OBElements::Phosphorus))</a>
<a name="ln141">        || atom-&gt;GetTotalDegree() &gt; 4 || atom-&gt;GetHvyDegree() &lt; 3 || atom-&gt;GetHvyDegree() &gt; 4)</a>
<a name="ln142">      return false;</a>
<a name="ln143">    // skip non-chiral N</a>
<a name="ln144">    if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; atom-&gt;GetFormalCharge()==0) {</a>
<a name="ln145">      int nbrRingAtomCount = 0;</a>
<a name="ln146">      FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln147">        if (nbr-&gt;IsInRing())</a>
<a name="ln148">          nbrRingAtomCount++;</a>
<a name="ln149">      }</a>
<a name="ln150">      if (nbrRingAtomCount &lt; 3)</a>
<a name="ln151">        return false;</a>
<a name="ln152">    }</a>
<a name="ln153">    if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln154">      if (atom-&gt;GetFormalCharge())</a>
<a name="ln155">        return false;</a>
<a name="ln156">      FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln157">        if (nbr-&gt;GetAtomicNum() == 26 &amp;&amp; nbr-&gt;GetExplicitDegree() &gt; 7)</a>
<a name="ln158">          return false;</a>
<a name="ln159">      }</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">    return true;</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  /**</a>
<a name="ln166">   * Check if the specified bond is a potential stereogenic bond.</a>
<a name="ln167">   *</a>
<a name="ln168">   * Criteria:</a>
<a name="ln169">   * - must be a double bond</a>
<a name="ln170">   * - must not be in a ring</a>
<a name="ln171">   * - both begin and end atom should have at least one single bond</a>
<a name="ln172">   */</a>
<a name="ln173">  bool isPotentialCisTrans(OBBond *bond)</a>
<a name="ln174">  {</a>
<a name="ln175">    if (bond-&gt;GetBondOrder() != 2)</a>
<a name="ln176">      return false;</a>
<a name="ln177">    if (bond-&gt;IsInRing())</a>
<a name="ln178">      return false;</a>
<a name="ln179">    if (!bond-&gt;GetBeginAtom()-&gt;HasSingleBond() || !bond-&gt;GetEndAtom()-&gt;HasSingleBond())</a>
<a name="ln180">      return false;</a>
<a name="ln181">    if (bond-&gt;GetBeginAtom()-&gt;GetHvyDegree() == 1 || bond-&gt;GetEndAtom()-&gt;GetHvyDegree() == 1)</a>
<a name="ln182">      return false;</a>
<a name="ln183">    if (bond-&gt;GetBeginAtom()-&gt;GetHvyDegree() &gt; 3 || bond-&gt;GetEndAtom()-&gt;GetHvyDegree() &gt; 3)</a>
<a name="ln184">      return false;</a>
<a name="ln185">    return true;</a>
<a name="ln186">  }</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln198"> </a>
<a name="ln199"> </a>
<a name="ln200">  /**</a>
<a name="ln201">   * Check if the specified stereogenic unit is in a fragment.</a>
<a name="ln202">   */</a>
<a name="ln203">  bool isUnitInFragment(OBMol *mol, const OBStereoUnit &amp;unit, const OBBitVec &amp;fragment)</a>
<a name="ln204">  {</a>
<a name="ln205">    if (unit.type == OBStereo::Tetrahedral) {</a>
<a name="ln206">      if (fragment.BitIsSet(unit.id))</a>
<a name="ln207">        return true;</a>
<a name="ln208">    } else if(unit.type == OBStereo::CisTrans) {</a>
<a name="ln209">      OBBond *bond = mol-&gt;GetBondById(unit.id);</a>
<a name="ln210">      OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln211">      OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln212">      if (fragment.BitIsSet(begin-&gt;GetId()) || fragment.BitIsSet(end-&gt;GetId()))</a>
<a name="ln213">        return true;</a>
<a name="ln214">    }</a>
<a name="ln215">    return false;</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">  //////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">  /**</a>
<a name="ln233">   * Check if the specified atom is a tetrahedral center (i.e. there is a Tetrahedral</a>
<a name="ln234">   * OBStereoUnit in units with the same id)</a>
<a name="ln235">   */</a>
<a name="ln236">  bool isTetrahedral(OBAtom *atom, const OBStereoUnitSet &amp;units)</a>
<a name="ln237">  {</a>
<a name="ln238">    for (std::size_t i = 0; i &lt; units.size(); ++i) {</a>
<a name="ln239">      const OBStereoUnit &amp;unit = units[i];</a>
<a name="ln240">      if (unit.type != OBStereo::Tetrahedral)</a>
<a name="ln241">        continue;</a>
<a name="ln242">      if (unit.id == atom-&gt;GetId())</a>
<a name="ln243">        return true;</a>
<a name="ln244">    }</a>
<a name="ln245">    return false;</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  /**</a>
<a name="ln249">   * Check if the specified bond is a double bond stereocenter (i.e. there is a CisTrans</a>
<a name="ln250">   * OBStereoUnit in units with the same id)</a>
<a name="ln251">   */</a>
<a name="ln252">  bool isCisTrans(OBBond *bond, const OBStereoUnitSet &amp;units)</a>
<a name="ln253">  {</a>
<a name="ln254">    for (std::size_t i = 0; i &lt; units.size(); ++i) {</a>
<a name="ln255">      const OBStereoUnit &amp;unit = units[i];</a>
<a name="ln256">      if (unit.type != OBStereo::CisTrans)</a>
<a name="ln257">        continue;</a>
<a name="ln258">      if (unit.id == bond-&gt;GetId())</a>
<a name="ln259">        return true;</a>
<a name="ln260">    }</a>
<a name="ln261">    return false;</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">  /**</a>
<a name="ln266">   * Classify the tetrahedral atom using the NeighborSymmetryClasses types.</a>
<a name="ln267">   */</a>
<a name="ln268">  int classifyTetrahedralNbrSymClasses(const std::vector&lt;unsigned int&gt; &amp;symClasses, OBAtom *atom)</a>
<a name="ln269">  {</a>
<a name="ln270">    std::vector&lt;unsigned int&gt; nbrClasses, nbrClassesCopy, uniqueClasses;</a>
<a name="ln271">    FOR_NBORS_OF_ATOM (nbr, atom)</a>
<a name="ln272">      nbrClasses.push_back(symClasses.at(nbr-&gt;GetIndex()));</a>
<a name="ln273">    // add an implicit ref if there are only 3 explicit</a>
<a name="ln274">    if (nbrClasses.size() == 3)</a>
<a name="ln275">      nbrClasses.push_back(OBStereo::ImplicitRef);</a>
<a name="ln276"> </a>
<a name="ln277">    // use some STL to work out the number of unique classes</a>
<a name="ln278">    nbrClassesCopy = nbrClasses; // keep copy for count below</a>
<a name="ln279">    std::sort(nbrClasses.begin(), nbrClasses.end());</a>
<a name="ln280">    std::vector&lt;unsigned int&gt;::iterator endLoc = std::unique(nbrClasses.begin(), nbrClasses.end());</a>
<a name="ln281">    std::copy(nbrClasses.begin(), endLoc, std::back_inserter(uniqueClasses));</a>
<a name="ln282"> </a>
<a name="ln283">    switch (uniqueClasses.size()) {</a>
<a name="ln284">      case 4:</a>
<a name="ln285">        return T1234; // e.g. 1 2 3 4</a>
<a name="ln286">      case 3:</a>
<a name="ln287">        return T1123; // e.g. 1 1 2 3</a>
<a name="ln288">      case 2:</a>
<a name="ln289">        // differentiate between T1122 and T1112</a>
<a name="ln290">        if (std::count(nbrClassesCopy.begin(), nbrClassesCopy.end(), uniqueClasses.at(0)) == 2)</a>
<a name="ln291">          return T1122; // e.g. 1 1 2 2</a>
<a name="ln292">        else</a>
<a name="ln293">          return T1112; // e.g. 1 1 1 2</a>
<a name="ln294">      case 1:</a>
<a name="ln295">	  default:</a>
<a name="ln296">        return T1111; // e.g. 1 1 1 1</a>
<a name="ln297">    }</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  /**</a>
<a name="ln301">   * Classify the cis/trans bond using the NeighborSymmetryClasses types.</a>
<a name="ln302">   */</a>
<a name="ln303">  int classifyCisTransNbrSymClasses(const std::vector&lt;unsigned int&gt; &amp;symClasses, OBBond *doubleBond, OBAtom *atom)</a>
<a name="ln304">  {</a>
<a name="ln305">    std::vector&lt;unsigned int&gt; nbrClasses, uniqueClasses;</a>
<a name="ln306">    FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln307">      if (nbr-&gt;GetIdx() != doubleBond-&gt;GetNbrAtom(atom)-&gt;GetIdx())</a>
<a name="ln308">        nbrClasses.push_back(symClasses.at(nbr-&gt;GetIndex()));</a>
<a name="ln309">    }</a>
<a name="ln310"> </a>
<a name="ln311">    if (nbrClasses.size() == 1)</a>
<a name="ln312">      nbrClasses.push_back(OBStereo::ImplicitRef);</a>
<a name="ln313"> </a>
<a name="ln314">    if (nbrClasses.at(0) == nbrClasses.at(1))</a>
<a name="ln315">      return C11; // e.g. 1 1</a>
<a name="ln316">    else</a>
<a name="ln317">      return C12; // e.g. 1 2</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">  /**</a>
<a name="ln321">   * Merge the rings in a molecule and return the result as OBBitVec objects.</a>
<a name="ln322">   * Rings are merged if they share at least one atom (e.g. bridged, spiro,</a>
<a name="ln323">   * adjacent, ...).</a>
<a name="ln324">   */</a>
<a name="ln325">  std::vector&lt;OBBitVec&gt; mergeRings(OBMol *mol, const std::vector&lt;unsigned int&gt; &amp;symClasses)</a>
<a name="ln326">  {</a>
<a name="ln327">    std::vector&lt;OBRing*&gt; rings = mol-&gt;GetSSSR();</a>
<a name="ln328"> </a>
<a name="ln329">    std::vector&lt;OBBitVec&gt; result;</a>
<a name="ln330">    for (std::size_t i = 0; i &lt; rings.size(); ++i) {</a>
<a name="ln331">      // check if ring shares atom with previously found ring</a>
<a name="ln332">      bool found = false;</a>
<a name="ln333">      for (std::size_t j = 0; j &lt; result.size(); ++j) {</a>
<a name="ln334">        std::vector&lt;unsigned int&gt; shared;</a>
<a name="ln335">        // foreach ring atom</a>
<a name="ln336">        for (std::size_t k = 0; k &lt; rings[i]-&gt;_path.size(); ++k) {</a>
<a name="ln337">          // check if the ring atom is in the current result bitvec</a>
<a name="ln338">          if (result[j].BitIsSet(rings[i]-&gt;_path[k])) {</a>
<a name="ln339">            shared.push_back(rings[i]-&gt;_path[k]);</a>
<a name="ln340">          }</a>
<a name="ln341">        }</a>
<a name="ln342"> </a>
<a name="ln343">        if (shared.size() &gt; 1) {</a>
<a name="ln344">          found = true;</a>
<a name="ln345">        } else if (shared.size() == 1) {</a>
<a name="ln346">          int classification = classifyTetrahedralNbrSymClasses(symClasses, mol-&gt;GetAtom(shared[0]));</a>
<a name="ln347">          if (classification == T1122 || classification == T1111)</a>
<a name="ln348">            found = true;</a>
<a name="ln349">        }</a>
<a name="ln350"> </a>
<a name="ln351">        if (found) {</a>
<a name="ln352">          // add bits for the atoms in the ring</a>
<a name="ln353">          for (std::size_t l = 0; l &lt; rings[i]-&gt;_path.size(); ++l)</a>
<a name="ln354">            result[j].SetBitOn(rings[i]-&gt;_path[l]);</a>
<a name="ln355">          break;</a>
<a name="ln356">        }</a>
<a name="ln357">      }</a>
<a name="ln358"> </a>
<a name="ln359">      // add the ring as a new bitvec if it shares no atom with a previous ring</a>
<a name="ln360">      if (!found) {</a>
<a name="ln361">        OBBitVec r;</a>
<a name="ln362">        for (std::size_t l = 0; l &lt; rings[i]-&gt;_path.size(); ++l)</a>
<a name="ln363">          r.SetBitOn(rings[i]-&gt;_path[l]);</a>
<a name="ln364">        result.push_back(r);</a>
<a name="ln365">      }</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    return result;</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  /*</a>
<a name="ln372">  bool isInSameMergedRing(const std::vector&lt;OBBitVec&gt; &amp;mergedRings, unsigned int idx1, unsigned int idx2)</a>
<a name="ln373">  {</a>
<a name="ln374">    std::vector&lt;OBBitVec&gt;::const_iterator bits;</a>
<a name="ln375">    for (bits = mergedRings.begin(); bits != mergedRings.end(); ++bits)</a>
<a name="ln376">      if ((*bits).BitIsSet( idx1 ) &amp;&amp; (*bits).BitIsSet( idx2 ))</a>
<a name="ln377">        return true;</a>
<a name="ln378">    return false;</a>
<a name="ln379">  }</a>
<a name="ln380">  */</a>
<a name="ln381"> </a>
<a name="ln382">  /**</a>
<a name="ln383">   * Helper function for getFragment below.</a>
<a name="ln384">   */</a>
<a name="ln385">  void addNbrs(OBBitVec &amp;fragment, OBAtom *atom, OBAtom *skip)</a>
<a name="ln386">  {</a>
<a name="ln387">    FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln388">      // don't pass through skip</a>
<a name="ln389">      if (nbr-&gt;GetId() == skip-&gt;GetId())</a>
<a name="ln390">        continue;</a>
<a name="ln391">      // skip visited atoms</a>
<a name="ln392">      if (fragment.BitIsSet(nbr-&gt;GetId()))</a>
<a name="ln393">        continue;</a>
<a name="ln394">      // add the neighbor atom to the fragment</a>
<a name="ln395">      fragment.SetBitOn(nbr-&gt;GetId());</a>
<a name="ln396">      // recurse...</a>
<a name="ln397">      addNbrs(fragment, &amp;*nbr, skip);</a>
<a name="ln398">    }</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  /**</a>
<a name="ln402">   * Create an OBBitVec objects with bets set for the fragment consisting of all</a>
<a name="ln403">   * atoms for which there is a path to atom without going through skip. These</a>
<a name="ln404">   * fragment bitvecs are indexed by unique id (i.e. OBAtom::GetId()).</a>
<a name="ln405">   */</a>
<a name="ln406">  OBBitVec getFragment(OBAtom *atom, OBAtom *skip)</a>
<a name="ln407">  {</a>
<a name="ln408">    OBBitVec fragment;</a>
<a name="ln409">    fragment.SetBitOn(atom-&gt;GetId());</a>
<a name="ln410">    // start the recursion</a>
<a name="ln411">    addNbrs(fragment, atom, skip);</a>
<a name="ln412">    return fragment;</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">  struct StereoRing</a>
<a name="ln417">  {</a>
<a name="ln418">    struct ParaAtom</a>
<a name="ln419">    {</a>
<a name="ln420">      typedef OBAtom CenterType;</a>
<a name="ln421"> </a>
<a name="ln422">      ParaAtom(unsigned long _id, unsigned int idx) : id(_id), inIdx(idx) {}</a>
<a name="ln423">      OBAtom* GetCenter(OBMol *mol) const { return mol-&gt;GetAtomById(id); }</a>
<a name="ln424">      bool isInRing(const StereoRing &amp;ring) const</a>
<a name="ln425">      {</a>
<a name="ln426">        for (std::size_t i = 0; i &lt; ring.paraAtoms.size(); ++i)</a>
<a name="ln427">          if (ring.paraAtoms[i].inIdx == inIdx)</a>
<a name="ln428">            return true;</a>
<a name="ln429">        return false;</a>
<a name="ln430">      }</a>
<a name="ln431"> </a>
<a name="ln432">      unsigned long id;</a>
<a name="ln433">      union {</a>
<a name="ln434">        unsigned int inIdx, outIdx;</a>
<a name="ln435">      };</a>
<a name="ln436">      std::vector&lt;OBAtom*&gt; insideNbrs, outsideNbrs;</a>
<a name="ln437">    };</a>
<a name="ln438">    struct ParaBond</a>
<a name="ln439">    {</a>
<a name="ln440">      typedef OBBond CenterType;</a>
<a name="ln441">      ParaBond(unsigned long _id, unsigned int _inIdx, unsigned int _outIdx) : id(_id), inIdx(_inIdx), outIdx(_outIdx) {}</a>
<a name="ln442">      OBBond* GetCenter(OBMol *mol) const { return mol-&gt;GetBondById(id); }</a>
<a name="ln443">      bool isInRing(const StereoRing &amp;ring) const</a>
<a name="ln444">      {</a>
<a name="ln445">        for (std::size_t i = 0; i &lt; ring.paraBonds.size(); ++i)</a>
<a name="ln446">          if (ring.paraBonds[i].inIdx == inIdx)</a>
<a name="ln447">            return true;</a>
<a name="ln448">        return false;</a>
<a name="ln449">      }</a>
<a name="ln450"> </a>
<a name="ln451">      unsigned long id;</a>
<a name="ln452">      unsigned int inIdx, outIdx;</a>
<a name="ln453">      std::vector&lt;OBAtom*&gt; insideNbrs, outsideNbrs;</a>
<a name="ln454">    };</a>
<a name="ln455"> </a>
<a name="ln456">    StereoRing() : trueCount(0) {}</a>
<a name="ln457"> </a>
<a name="ln458">    std::vector&lt;ParaAtom&gt; paraAtoms;</a>
<a name="ln459">    std::vector&lt;ParaBond&gt; paraBonds;</a>
<a name="ln460">    unsigned int trueCount;</a>
<a name="ln461">  };</a>
<a name="ln462"> </a>
<a name="ln463">  template&lt;typename Type&gt;</a>
<a name="ln464">  bool checkLigands(const Type &amp;currentPara, const OBStereoUnitSet &amp;units)</a>
<a name="ln465">  {</a>
<a name="ln466">    if (currentPara.outsideNbrs.size() == 1) {</a>
<a name="ln467">      //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln468">      return true;</a>
<a name="ln469">    }</a>
<a name="ln470">    OBMol *mol = currentPara.insideNbrs[0]-&gt;GetParent();</a>
<a name="ln471">    assert(mol-&gt;GetAtom(currentPara.outIdx));</a>
<a name="ln472">    OBBitVec ligand = getFragment(currentPara.outsideNbrs[0], mol-&gt;GetAtom(currentPara.outIdx));</a>
<a name="ln473">    for (OBStereoUnitSet::const_iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln474">      if (isUnitInFragment(mol, *u2, ligand)) {</a>
<a name="ln475">        //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln476">        return true;</a>
<a name="ln477">      }</a>
<a name="ln478">    }</a>
<a name="ln479">    //cout &lt;&lt; &quot;NOT OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln480">    return false;</a>
<a name="ln481">  }</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">  template&lt;typename Type&gt;</a>
<a name="ln485">  bool ApplyRule1(const Type &amp;currentPara, const std::vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln486">      const std::vector&lt;StereoRing&gt; &amp;rings, std::vector&lt;bool&gt; &amp;visitedRings, const OBStereoUnitSet &amp;units,</a>
<a name="ln487">      std::vector&lt;unsigned int&gt; stereoAtoms)</a>
<a name="ln488">  {</a>
<a name="ln489">    bool foundRing = false;</a>
<a name="ln490">    unsigned int idx = currentPara.inIdx;</a>
<a name="ln491"> </a>
<a name="ln492">    /*</a>
<a name="ln493">    for (std::size_t i = 0; i &lt; visitedRings.size(); ++i)</a>
<a name="ln494">      if (visitedRings[i])</a>
<a name="ln495">        cout &lt;&lt; &quot;  &quot;;</a>
<a name="ln496">    cout &lt;&lt; &quot;ApplyRule1(&quot; &lt;&lt; currentPara.inIdx &lt;&lt; &quot;, &quot; &lt;&lt; currentPara.outIdx &lt;&lt; &quot;, outside = &quot; &lt;&lt; currentPara.outsideNbrs.size() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln497">    */</a>
<a name="ln498"> </a>
<a name="ln499">    for (std::size_t i = 0; i &lt; rings.size(); ++i) {</a>
<a name="ln500">      // skip visited rings</a>
<a name="ln501">      if (visitedRings[i])</a>
<a name="ln502">        continue;</a>
<a name="ln503"> </a>
<a name="ln504">      // Check if currentPara is in this ring</a>
<a name="ln505">      if (!currentPara.isInRing(rings[i]))</a>
<a name="ln506">        continue;</a>
<a name="ln507"> </a>
<a name="ln508">      //</a>
<a name="ln509">      // A new ring containing currentPara is found</a>
<a name="ln510">      //</a>
<a name="ln511">      foundRing = true;</a>
<a name="ln512"> </a>
<a name="ln513">      // if there are one or more true stereo centers, currentPara is a stereo center</a>
<a name="ln514">      if (rings[i].trueCount) {</a>
<a name="ln515">        //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln516">        return true;</a>
<a name="ln517">      }</a>
<a name="ln518"> </a>
<a name="ln519">      // check if there is at least one other potential atom</a>
<a name="ln520">      for (std::size_t j = 0; j &lt; rings[i].paraAtoms.size(); ++j) {</a>
<a name="ln521">        const StereoRing::ParaAtom &amp;paraAtom = rings[i].paraAtoms[j];</a>
<a name="ln522">        // skip idx</a>
<a name="ln523">        if (paraAtom.inIdx == idx)</a>
<a name="ln524">          continue;</a>
<a name="ln525">        // there is another atom already identified as stereo atom</a>
<a name="ln526">        if (std::find(stereoAtoms.begin(), stereoAtoms.end(), paraAtom.inIdx) != stereoAtoms.end()) {</a>
<a name="ln527">          //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln528">          return true;</a>
<a name="ln529">        }</a>
<a name="ln530"> </a>
<a name="ln531">        if (paraAtom.outsideNbrs.size() == 1) {</a>
<a name="ln532">          // only 1 ring substituent, the other is implicit H -&gt; topologically different</a>
<a name="ln533">          //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln534">          return true;</a>
<a name="ln535">        } else {</a>
<a name="ln536">          if (paraAtom.outsideNbrs.size() != 2)</a>
<a name="ln537">            return false;</a>
<a name="ln538">          // two ring substituents, need to check for topological difference</a>
<a name="ln539">          if (symmetry_classes[paraAtom.outsideNbrs[0]-&gt;GetIndex()] != symmetry_classes[paraAtom.outsideNbrs[1]-&gt;GetIndex()]) {</a>
<a name="ln540">            // they are different</a>
<a name="ln541">            //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln542">            return true;</a>
<a name="ln543">          } else {</a>
<a name="ln544">            // they are the same and they might also be in a ring -&gt; apply rule 1 recursive</a>
<a name="ln545">            visitedRings[i] = true;</a>
<a name="ln546">            if (ApplyRule1(paraAtom, symmetry_classes, rings, visitedRings, units, stereoAtoms)) {</a>
<a name="ln547">              //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln548">              return true;</a>
<a name="ln549">            }</a>
<a name="ln550">          }</a>
<a name="ln551">        }</a>
<a name="ln552">      }</a>
<a name="ln553">      // check if there is at least one other potential bond</a>
<a name="ln554">      for (std::size_t j = 0; j &lt; rings[i].paraBonds.size(); ++j) {</a>
<a name="ln555">        const StereoRing::ParaBond &amp;paraBond = rings[i].paraBonds[j];</a>
<a name="ln556">        // skip idx</a>
<a name="ln557">        if (paraBond.inIdx == idx)</a>
<a name="ln558">          continue;</a>
<a name="ln559">        // there is another atom already identified as stereo atom</a>
<a name="ln560">        if (std::find(stereoAtoms.begin(), stereoAtoms.end(), paraBond.inIdx) != stereoAtoms.end()) {</a>
<a name="ln561">          //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln562">          return true;</a>
<a name="ln563">        }</a>
<a name="ln564"> </a>
<a name="ln565">        if (paraBond.outsideNbrs.size() == 1) {</a>
<a name="ln566">          // only 1 ring substituent, the other is implicit H -&gt; topologically different</a>
<a name="ln567">          //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln568">          return true;</a>
<a name="ln569">        } else {</a>
<a name="ln570">          if (paraBond.outsideNbrs.size() != 2)</a>
<a name="ln571">            continue;</a>
<a name="ln572">          // two ring substituents, need to check for topological difference</a>
<a name="ln573">          if (symmetry_classes[paraBond.outsideNbrs[0]-&gt;GetIndex()] != symmetry_classes[paraBond.outsideNbrs[1]-&gt;GetIndex()]) {</a>
<a name="ln574">            // they are different</a>
<a name="ln575">            //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln576">            return true;</a>
<a name="ln577">          } else {</a>
<a name="ln578">            // they are the same and they might also be in a ring -&gt; apply rule 1 recursive</a>
<a name="ln579">            visitedRings[i] = true;</a>
<a name="ln580">            if (ApplyRule1(paraBond, symmetry_classes, rings, visitedRings, units, stereoAtoms)) {</a>
<a name="ln581">              //cout &lt;&lt; &quot;OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln582">              return true;</a>
<a name="ln583">            }</a>
<a name="ln584">          }</a>
<a name="ln585">        }</a>
<a name="ln586">      }</a>
<a name="ln587"> </a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590">    // if a non-visited ring was found and true was not returned -&gt; it does not</a>
<a name="ln591">    // contain any stereocenters other than idx</a>
<a name="ln592">    if (foundRing) {</a>
<a name="ln593">      //cout &lt;&lt; &quot;NOT OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln594">      return false;</a>
<a name="ln595">    }</a>
<a name="ln596"> </a>
<a name="ln597">    //cout &lt;&lt; &quot;NOT OK: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;</a>
<a name="ln598">    return false;</a>
<a name="ln599">  }</a>
<a name="ln600"> </a>
<a name="ln601">  void StartRule1(const std::vector&lt;unsigned int&gt; &amp;symmetry_classes, const std::vector&lt;StereoRing&gt; &amp;rings,</a>
<a name="ln602">      OBStereoUnitSet &amp;units, std::vector&lt;unsigned int&gt; &amp;stereoAtoms)</a>
<a name="ln603">  {</a>
<a name="ln604">    for (std::size_t i = 0; i &lt; rings.size(); ++i) {</a>
<a name="ln605">      //cout &lt;&lt; &quot;Checking ring: &quot; &lt;&lt; i &lt;&lt; endl;</a>
<a name="ln606"> </a>
<a name="ln607">      // tetrahedral atoms</a>
<a name="ln608">      for (std::size_t j = 0; j &lt; rings[i].paraAtoms.size(); ++j) {</a>
<a name="ln609">        const StereoRing::ParaAtom &amp;paraAtom = rings[i].paraAtoms[j];</a>
<a name="ln610">        // skip the atom if it is already in stereoAtoms</a>
<a name="ln611">        if (std::find(stereoAtoms.begin(), stereoAtoms.end(), paraAtom.inIdx) != stereoAtoms.end())</a>
<a name="ln612">          continue;</a>
<a name="ln613"> </a>
<a name="ln614">        std::vector&lt;bool&gt; visitedRings(rings.size(), false);</a>
<a name="ln615">        //visitedRings[i] = true;</a>
<a name="ln616">        if (ApplyRule1(paraAtom, symmetry_classes, rings, visitedRings, units, stereoAtoms)) {</a>
<a name="ln617">          bool isStereoUnit = false;</a>
<a name="ln618">          if (paraAtom.outsideNbrs.size() == 1)</a>
<a name="ln619">            isStereoUnit = true;</a>
<a name="ln620">          if (paraAtom.outsideNbrs.size() == 2) {</a>
<a name="ln621">            if (symmetry_classes[paraAtom.outsideNbrs[0]-&gt;GetIndex()] == symmetry_classes[paraAtom.outsideNbrs[1]-&gt;GetIndex()]) {</a>
<a name="ln622">              // check for spiro atom</a>
<a name="ln623">              bool isSpiro = false;</a>
<a name="ln624">              for (std::size_t k = 0; k &lt; rings[i].paraAtoms.size(); ++k) {</a>
<a name="ln625">                const StereoRing::ParaAtom &amp;paraAtom2 = rings[i].paraAtoms[k];</a>
<a name="ln626">                if (paraAtom.inIdx == paraAtom2.outIdx &amp;&amp; paraAtom.insideNbrs == paraAtom2.outsideNbrs) {</a>
<a name="ln627">                  isSpiro = true;</a>
<a name="ln628">                  if (ApplyRule1(paraAtom2, symmetry_classes, rings, visitedRings, units, stereoAtoms))</a>
<a name="ln629">                    isStereoUnit = true;</a>
<a name="ln630">                }</a>
<a name="ln631">              }</a>
<a name="ln632">              if (!isSpiro)</a>
<a name="ln633">                isStereoUnit = checkLigands(paraAtom, units);</a>
<a name="ln634">              //cout &lt;&lt; &quot;isStereoUnit = &quot; &lt;&lt; isStereoUnit &lt;&lt; endl;</a>
<a name="ln635">            } else {</a>
<a name="ln636">              isStereoUnit = true;</a>
<a name="ln637">            }</a>
<a name="ln638">          }</a>
<a name="ln639"> </a>
<a name="ln640">          if (isStereoUnit) {</a>
<a name="ln641">            stereoAtoms.push_back(paraAtom.inIdx);</a>
<a name="ln642">            OBAtom *atom = paraAtom.insideNbrs[0]-&gt;GetParent()-&gt;GetAtomById(paraAtom.id);</a>
<a name="ln643">            units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln644">          }</a>
<a name="ln645">        }</a>
<a name="ln646"> </a>
<a name="ln647">      }</a>
<a name="ln648"> </a>
<a name="ln649">      // cistrans bonds</a>
<a name="ln650">      for (std::size_t j = 0; j &lt; rings[i].paraBonds.size(); ++j) {</a>
<a name="ln651">        const StereoRing::ParaBond &amp;paraBond = rings[i].paraBonds[j];</a>
<a name="ln652">        // skip the atom if it is already in stereoAtoms</a>
<a name="ln653">        if (std::find(stereoAtoms.begin(), stereoAtoms.end(), paraBond.inIdx) != stereoAtoms.end())</a>
<a name="ln654">          continue;</a>
<a name="ln655"> </a>
<a name="ln656">        std::vector&lt;bool&gt; visitedRings(rings.size(), false);</a>
<a name="ln657">        //visitedRings[i] = true;</a>
<a name="ln658">        if (ApplyRule1(paraBond, symmetry_classes, rings, visitedRings, units, stereoAtoms)) {</a>
<a name="ln659">          bool isStereoUnit = false;</a>
<a name="ln660">          if (paraBond.outsideNbrs.size() == 1)</a>
<a name="ln661">            isStereoUnit = true;</a>
<a name="ln662">          if (paraBond.outsideNbrs.size() == 2) {</a>
<a name="ln663">            if (symmetry_classes[paraBond.outsideNbrs[0]-&gt;GetIndex()] == symmetry_classes[paraBond.outsideNbrs[1]-&gt;GetIndex()]) {</a>
<a name="ln664">              // check for spiro bond</a>
<a name="ln665">              bool isSpiro = false;</a>
<a name="ln666">              for (std::size_t k = 0; k &lt; rings[i].paraBonds.size(); ++k) {</a>
<a name="ln667">                const StereoRing::ParaBond &amp;paraBond2 = rings[i].paraBonds[k];</a>
<a name="ln668">                if (paraBond.inIdx == paraBond2.outIdx &amp;&amp; paraBond.insideNbrs == paraBond2.outsideNbrs) {</a>
<a name="ln669">                  isSpiro = true;</a>
<a name="ln670">                  if (ApplyRule1(paraBond2, symmetry_classes, rings, visitedRings, units, stereoAtoms))</a>
<a name="ln671">                    isStereoUnit = true;</a>
<a name="ln672">                }</a>
<a name="ln673">              }</a>
<a name="ln674">              if (!isSpiro)</a>
<a name="ln675">                isStereoUnit = checkLigands(paraBond, units);</a>
<a name="ln676">              //cout &lt;&lt; &quot;isStereoUnit = &quot; &lt;&lt; isStereoUnit &lt;&lt; endl;</a>
<a name="ln677">            } else {</a>
<a name="ln678">              isStereoUnit = true;</a>
<a name="ln679">            }</a>
<a name="ln680">          }</a>
<a name="ln681"> </a>
<a name="ln682">          if (isStereoUnit) {</a>
<a name="ln683">            stereoAtoms.push_back(paraBond.inIdx);</a>
<a name="ln684">            stereoAtoms.push_back(paraBond.outIdx);</a>
<a name="ln685">            OBBond *bond = paraBond.insideNbrs[0]-&gt;GetParent()-&gt;GetBondById(paraBond.id);</a>
<a name="ln686">            units.push_back(OBStereoUnit(OBStereo::CisTrans, bond-&gt;GetId(), true));</a>
<a name="ln687">          }</a>
<a name="ln688">        }</a>
<a name="ln689"> </a>
<a name="ln690">      }</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  /**</a>
<a name="ln698">   * Find the stereogenic units in a molecule using a set of rules.</a>
<a name="ln699">   *</a>
<a name="ln700">   * This is a public function: see header for details.</a>
<a name="ln701">   */</a>
<a name="ln702">  OBStereoUnitSet FindStereogenicUnits(OBMol *mol, const std::vector&lt;unsigned int&gt; &amp;symClasses)</a>
<a name="ln703">  {</a>
<a name="ln704">    OBStereoUnitSet units;</a>
<a name="ln705"> </a>
<a name="ln706">    // do quick test to see if there are any possible stereogenic units</a>
<a name="ln707">    if (!mayHaveTetrahedralCenter(mol) &amp;&amp; !mayHaveCisTransBond(mol))</a>
<a name="ln708">      return units;</a>
<a name="ln709"> </a>
<a name="ln710">    // make sure we have symmetry classes for all atoms</a>
<a name="ln711">    if (symClasses.size() != mol-&gt;NumAtoms())</a>
<a name="ln712">      return units;</a>
<a name="ln713"> </a>
<a name="ln714">    // para-stereocenters candidates</a>
<a name="ln715">    std::vector&lt;unsigned int&gt; stereoAtoms; // Tetrahedral = idx, CisTrans = begin &amp; end idx</a>
<a name="ln716">    std::vector&lt;unsigned int&gt; paraAtoms;</a>
<a name="ln717">    std::vector&lt;unsigned int&gt; paraBonds;</a>
<a name="ln718"> </a>
<a name="ln719">    /**</a>
<a name="ln720">     * true Tetrahedral stereocenters:</a>
<a name="ln721">     * - have four different symmetry classes for the ligands to the central atom</a>
<a name="ln722">     */</a>
<a name="ln723">    bool ischiral;</a>
<a name="ln724">    std::vector&lt;OBAtom*&gt;::iterator ia;</a>
<a name="ln725">    for (OBAtom *atom = mol-&gt;BeginAtom(ia); atom; atom = mol-&gt;NextAtom(ia)) {</a>
<a name="ln726">      if (!isPotentialTetrahedral(atom))</a>
<a name="ln727">        continue;</a>
<a name="ln728"> </a>
<a name="ln729">      // list containing neighbor symmetry classes</a>
<a name="ln730">      std::vector&lt;unsigned int&gt; tlist;</a>
<a name="ln731">      ischiral = true;</a>
<a name="ln732"> </a>
<a name="ln733">      // check neighbors to see if this atom is stereogenic</a>
<a name="ln734">      std::vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln735">      for (OBAtom *nbr = atom-&gt;BeginNbrAtom(j); nbr; nbr = atom-&gt;NextNbrAtom(j)) {</a>
<a name="ln736">        // check if we already have a neighbor with this symmetry class</a>
<a name="ln737">        std::vector&lt;unsigned int&gt;::iterator k;</a>
<a name="ln738">        for (k = tlist.begin(); k != tlist.end(); ++k)</a>
<a name="ln739">          if (symClasses[nbr-&gt;GetIndex()] == *k) {</a>
<a name="ln740">            ischiral = false;</a>
<a name="ln741">            // if so, might still be a para-stereocenter</a>
<a name="ln742">            paraAtoms.push_back(atom-&gt;GetIdx());</a>
<a name="ln743">          }</a>
<a name="ln744"> </a>
<a name="ln745">        if (ischiral)</a>
<a name="ln746">          // keep track of all neighbors, so we can detect duplicates</a>
<a name="ln747">          tlist.push_back(symClasses[nbr-&gt;GetIndex()]);</a>
<a name="ln748">        else</a>
<a name="ln749">          break;</a>
<a name="ln750">      }</a>
<a name="ln751"> </a>
<a name="ln752">      if (ischiral) {</a>
<a name="ln753">        // true-stereocenter found</a>
<a name="ln754">        stereoAtoms.push_back(atom-&gt;GetIdx());</a>
<a name="ln755">        units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId()));</a>
<a name="ln756">      }</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    /**</a>
<a name="ln760">     * true CisTrans stereocenters:</a>
<a name="ln761">     * - each terminal has two different symmetry classes for it's ligands</a>
<a name="ln762">     */</a>
<a name="ln763">    bool isCisTransBond;</a>
<a name="ln764">    std::vector&lt;OBBond*&gt;::iterator ib;</a>
<a name="ln765">    for (OBBond *bond = mol-&gt;BeginBond(ib); bond; bond = mol-&gt;NextBond(ib)) {</a>
<a name="ln766">      if (bond-&gt;IsInRing() &amp;&amp; bond-&gt;IsAromatic())</a>
<a name="ln767">        continue; // Exclude C=C in phenyl rings for example</a>
<a name="ln768"> </a>
<a name="ln769">      if (bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln770">        OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln771">        OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln772">        if (!begin || !end)</a>
<a name="ln773">          continue;</a>
<a name="ln774"> </a>
<a name="ln775">        if (begin-&gt;GetTotalDegree() &gt; 3 || end-&gt;GetTotalDegree() &gt; 3)</a>
<a name="ln776">          continue; // e.g. C=Ru where the Ru has four substituents</a>
<a name="ln777"> </a>
<a name="ln778">        // Needs to have at least one explicit single bond at either end</a>
<a name="ln779">        // FIXME: timvdm: what about C=C=C=C</a>
<a name="ln780">        if (!begin-&gt;HasSingleBond() || !end-&gt;HasSingleBond())</a>
<a name="ln781">          continue;</a>
<a name="ln782"> </a>
<a name="ln783">        isCisTransBond = true;</a>
<a name="ln784">        std::vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln785"> </a>
<a name="ln786">        if (begin-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln787">          // Begin atom has two explicit neighbors. One is the end atom. The other should</a>
<a name="ln788">          // be a heavy atom - this is what we test here.</a>
<a name="ln789">          // (There is a third, implicit, neighbor which is either a hydrogen</a>
<a name="ln790">          // or a lone pair.)</a>
<a name="ln791">          if (begin-&gt;ExplicitHydrogenCount() == 1)</a>
<a name="ln792">            isCisTransBond = false;</a>
<a name="ln793">        } else if (begin-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln794">          std::vector&lt;unsigned int&gt; tlist;</a>
<a name="ln795"> </a>
<a name="ln796">          for (OBAtom *nbr = begin-&gt;BeginNbrAtom(j); nbr; nbr = begin-&gt;NextNbrAtom(j)) {</a>
<a name="ln797">            // skip end atom</a>
<a name="ln798">            if (nbr-&gt;GetId() == end-&gt;GetId())</a>
<a name="ln799">              continue;</a>
<a name="ln800">            // do we already have an atom with this symmetry class?</a>
<a name="ln801">            if (tlist.size()) {</a>
<a name="ln802">              // compare second with first</a>
<a name="ln803">              if (symClasses[nbr-&gt;GetIndex()] == tlist.at(0)) {</a>
<a name="ln804">                isCisTransBond = false;</a>
<a name="ln805">                // if same, might still be a para-stereocenter</a>
<a name="ln806">                paraBonds.push_back(bond-&gt;GetIdx());</a>
<a name="ln807">              }</a>
<a name="ln808">              break;</a>
<a name="ln809">            }</a>
<a name="ln810"> </a>
<a name="ln811">            // save first symmetry class</a>
<a name="ln812">            tlist.push_back(symClasses[nbr-&gt;GetIndex()]);</a>
<a name="ln813">          }</a>
<a name="ln814">        } else {</a>
<a name="ln815">          // Valence is not 2 or 3, for example SR3=NR</a>
<a name="ln816">          isCisTransBond = false;</a>
<a name="ln817">        }</a>
<a name="ln818"> </a>
<a name="ln819">        if (!isCisTransBond)</a>
<a name="ln820">          continue;</a>
<a name="ln821"> </a>
<a name="ln822">        if (end-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln823">          // see comment above for begin atom</a>
<a name="ln824">          if (end-&gt;ExplicitHydrogenCount() == 1)</a>
<a name="ln825">            isCisTransBond = false;</a>
<a name="ln826">        } else if (end-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln827">          std::vector&lt;unsigned int&gt; tlist;</a>
<a name="ln828"> </a>
<a name="ln829">          for (OBAtom *nbr = end-&gt;BeginNbrAtom(j); nbr; nbr = end-&gt;NextNbrAtom(j)) {</a>
<a name="ln830">            // skip end atom</a>
<a name="ln831">            if (nbr-&gt;GetId() == begin-&gt;GetId())</a>
<a name="ln832">              continue;</a>
<a name="ln833">            // do we already have an atom with this symmetry class?</a>
<a name="ln834">            if (tlist.size()) {</a>
<a name="ln835">              // compare second with first</a>
<a name="ln836">              if (symClasses[nbr-&gt;GetIndex()] == tlist.at(0)) {</a>
<a name="ln837">                // if same, might still be a para-stereocenter</a>
<a name="ln838">                paraBonds.push_back(bond-&gt;GetIdx());</a>
<a name="ln839">                isCisTransBond = false;</a>
<a name="ln840">              }</a>
<a name="ln841">              break;</a>
<a name="ln842">            }</a>
<a name="ln843"> </a>
<a name="ln844">            // save first symmetry class</a>
<a name="ln845">            tlist.push_back(symClasses[nbr-&gt;GetIndex()]);</a>
<a name="ln846">          }</a>
<a name="ln847">        } else {</a>
<a name="ln848">          // Valence is not 2 or 3, for example SR3=NR</a>
<a name="ln849">          isCisTransBond = false;</a>
<a name="ln850">        }</a>
<a name="ln851"> </a>
<a name="ln852">        if (isCisTransBond)</a>
<a name="ln853">          // true-stereocenter found</a>
<a name="ln854">          units.push_back(OBStereoUnit(OBStereo::CisTrans, bond-&gt;GetId()));</a>
<a name="ln855">      }</a>
<a name="ln856">    }</a>
<a name="ln857"> </a>
<a name="ln858">    /**</a>
<a name="ln859">     * Apply rule 1 from the Razinger paper recusively:</a>
<a name="ln860">     *</a>
<a name="ln861">     * All rings are merged &quot;mergedRings&quot;. A merged ring is simply a fragment consisting</a>
<a name="ln862">     * of all atoms of a ring system (bridged, spiro, adjacent, ...). If two rings in the</a>
<a name="ln863">     * SSSR set share an atom, they are merged.</a>
<a name="ln864">     *</a>
<a name="ln865">     * Each merged must at least have two para-stereocenters (or 1 true + 1 para) in order</a>
<a name="ln866">     * for the para-stereocenter to be valid. This is repeated until no new stereocenters</a>
<a name="ln867">     * are identified.</a>
<a name="ln868">     *</a>
<a name="ln869">     * rule 1a for double bonds:</a>
<a name="ln870">     * - bond atom in ring has two identical symmetry classes for it's neighbor atoms (-&gt; para)</a>
<a name="ln871">     * - other bond atom:</a>
<a name="ln872">     *   - has two different symmetry classes for it's neighbours -&gt; new stereocenter</a>
<a name="ln873">     *   - has two identical symmetry classes, but the ligand contains at least 1 true or para stereocenter -&gt; new stereocenter</a>
<a name="ln874">     *</a>
<a name="ln875">     * rule 1b for tetracoord atoms:</a>
<a name="ln876">     * - at least two neighbour symmetry classes are the same (-&gt; para)</a>
<a name="ln877">     * - other pair:</a>
<a name="ln878">     *   - has two different symmetry classes for it's neighbours -&gt; new stereocenter</a>
<a name="ln879">     *   - has two identical symmetry classes, but the ligand contains at least 1 true or para stereocenter -&gt; new stereocenter</a>
<a name="ln880">     *</a>
<a name="ln881">     * NOTE: there must always be at least 2 new stereocenters (or one existing + 1 newly found) in order for them to be valid</a>
<a name="ln882">     */</a>
<a name="ln883">    std::vector&lt;OBRing*&gt; lssr = mol-&gt;GetLSSR();</a>
<a name="ln884">    std::vector&lt;StereoRing&gt; rings;</a>
<a name="ln885"> </a>
<a name="ln886">    //cout &lt;&lt; &quot;=====================================================&quot; &lt;&lt; endl;</a>
<a name="ln887">    for (std::size_t i = 0; i &lt; lssr.size(); ++i) {</a>
<a name="ln888">      rings.push_back(StereoRing());</a>
<a name="ln889">      StereoRing &amp;ring = rings.back();</a>
<a name="ln890"> </a>
<a name="ln891"> </a>
<a name="ln892">      for (std::size_t j = 0; j &lt; stereoAtoms.size(); ++j)</a>
<a name="ln893">        if (lssr[i]-&gt;_pathset.BitIsSet(stereoAtoms[j]))</a>
<a name="ln894">          ring.trueCount++;</a>
<a name="ln895"> </a>
<a name="ln896">      //cout &lt;&lt; &quot;StereoRing: trueCount = &quot; &lt;&lt; ring.trueCount &lt;&lt; endl;</a>
<a name="ln897">      for (std::size_t j = 0; j &lt; paraAtoms.size(); ++j) {</a>
<a name="ln898">        if (lssr[i]-&gt;_pathset.BitIsSet(paraAtoms[j])) {</a>
<a name="ln899">          OBAtom *atom = mol-&gt;GetAtom(paraAtoms[j]);</a>
<a name="ln900">          ring.paraAtoms.push_back(StereoRing::ParaAtom(atom-&gt;GetId(), paraAtoms[j]));</a>
<a name="ln901"> </a>
<a name="ln902">          FOR_NBORS_OF_ATOM (nbr, mol-&gt;GetAtom(paraAtoms[j])) {</a>
<a name="ln903">            if (lssr[i]-&gt;_pathset.BitIsSet(nbr-&gt;GetIdx()))</a>
<a name="ln904">              ring.paraAtoms.back().insideNbrs.push_back(&amp;*nbr);</a>
<a name="ln905">            else</a>
<a name="ln906">              ring.paraAtoms.back().outsideNbrs.push_back(&amp;*nbr);</a>
<a name="ln907">          }</a>
<a name="ln908"> </a>
<a name="ln909">          //cout &lt;&lt; &quot;  ParaAtom(idx = &quot; &lt;&lt; ring.paraAtoms.back().inIdx &lt;&lt; &quot;, outside = &quot; &lt;&lt; ring.paraAtoms.back().outsideNbrs.size() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln910">          if (ring.paraAtoms.back().insideNbrs.size() != 2)</a>
<a name="ln911">            ring.paraAtoms.pop_back();</a>
<a name="ln912">        }</a>
<a name="ln913">      }</a>
<a name="ln914"> </a>
<a name="ln915">      for (std::size_t j = 0; j &lt; paraBonds.size(); ++j) {</a>
<a name="ln916">        OBBond *bond = mol-&gt;GetBond(paraBonds[j]);</a>
<a name="ln917">        unsigned int beginIdx = bond-&gt;GetBeginAtomIdx();</a>
<a name="ln918">        unsigned int endIdx = bond-&gt;GetEndAtomIdx();</a>
<a name="ln919"> </a>
<a name="ln920">        if (lssr[i]-&gt;_pathset.BitIsSet(beginIdx)) {</a>
<a name="ln921">          ring.paraBonds.push_back(StereoRing::ParaBond(bond-&gt;GetId(), beginIdx, endIdx));</a>
<a name="ln922"> </a>
<a name="ln923">          FOR_NBORS_OF_ATOM (nbr, bond-&gt;GetBeginAtom()) {</a>
<a name="ln924">            if (nbr-&gt;GetIdx() == endIdx)</a>
<a name="ln925">              continue;</a>
<a name="ln926">            ring.paraBonds.back().insideNbrs.push_back(&amp;*nbr);</a>
<a name="ln927">          }</a>
<a name="ln928">          FOR_NBORS_OF_ATOM (nbr, bond-&gt;GetEndAtom()) {</a>
<a name="ln929">            if (nbr-&gt;GetIdx() == beginIdx)</a>
<a name="ln930">              continue;</a>
<a name="ln931">            ring.paraBonds.back().outsideNbrs.push_back(&amp;*nbr);</a>
<a name="ln932">          }</a>
<a name="ln933"> </a>
<a name="ln934">          //cout &lt;&lt; &quot;  ParaBond(inIdx = &quot; &lt;&lt; beginIdx &lt;&lt; &quot;, outIdx = &quot; &lt;&lt; endIdx &lt;&lt; &quot;, outside = &quot; &lt;&lt; ring.paraBonds.back().outsideNbrs.size() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln935">          if (ring.paraBonds.back().insideNbrs.size() != 2)</a>
<a name="ln936">            ring.paraBonds.pop_back();</a>
<a name="ln937">        }</a>
<a name="ln938"> </a>
<a name="ln939">        if (lssr[i]-&gt;_pathset.BitIsSet(endIdx)) {</a>
<a name="ln940">          ring.paraBonds.push_back(StereoRing::ParaBond(bond-&gt;GetId(), endIdx, beginIdx));</a>
<a name="ln941"> </a>
<a name="ln942">          FOR_NBORS_OF_ATOM (nbr, bond-&gt;GetEndAtom()) {</a>
<a name="ln943">            if (nbr-&gt;GetIdx() == beginIdx)</a>
<a name="ln944">              continue;</a>
<a name="ln945">            ring.paraBonds.back().insideNbrs.push_back(&amp;*nbr);</a>
<a name="ln946">          }</a>
<a name="ln947">          FOR_NBORS_OF_ATOM (nbr, bond-&gt;GetBeginAtom()) {</a>
<a name="ln948">            if (nbr-&gt;GetIdx() == endIdx)</a>
<a name="ln949">              continue;</a>
<a name="ln950">            ring.paraBonds.back().outsideNbrs.push_back(&amp;*nbr);</a>
<a name="ln951">          }</a>
<a name="ln952"> </a>
<a name="ln953">          //cout &lt;&lt; &quot;  ParaBond(inIdx = &quot; &lt;&lt; endIdx &lt;&lt; &quot;, outIdx = &quot; &lt;&lt; beginIdx &lt;&lt; &quot;, outside = &quot; &lt;&lt; ring.paraBonds.back().outsideNbrs.size() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln954">          if (ring.paraBonds.back().insideNbrs.size() != 2)</a>
<a name="ln955">            ring.paraBonds.pop_back();</a>
<a name="ln956">        }</a>
<a name="ln957"> </a>
<a name="ln958">      }</a>
<a name="ln959"> </a>
<a name="ln960">      if (ring.paraAtoms.size() + ring.paraBonds.size() == 1) {</a>
<a name="ln961">        ring.paraAtoms.clear();</a>
<a name="ln962">        ring.paraBonds.clear();</a>
<a name="ln963">      }</a>
<a name="ln964"> </a>
<a name="ln965">    }</a>
<a name="ln966">    //cout &lt;&lt; &quot;=====================================================&quot; &lt;&lt; endl;</a>
<a name="ln967"> </a>
<a name="ln968">    unsigned int numStereoUnits;</a>
<a name="ln969">    do {</a>
<a name="ln970">      numStereoUnits = units.size();</a>
<a name="ln971">      StartRule1(symClasses, rings, units, stereoAtoms);</a>
<a name="ln972">    } while (units.size() &gt; numStereoUnits);</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">    std::vector&lt;OBBitVec&gt; mergedRings = mergeRings(mol, symClasses);</a>
<a name="ln976">    /**</a>
<a name="ln977">     * Apply rule 2a for tetracoordinate carbon:</a>
<a name="ln978">     * - 1 or 2 pair identical ligands</a>
<a name="ln979">     * - each pair contains at least 1 true-stereocenter or 2 para-stereocenters</a>
<a name="ln980">     *</a>
<a name="ln981">     * Apply rule 2b for tetracoordinate carbon:</a>
<a name="ln982">     * - 3 or 4 identical ligands with at least</a>
<a name="ln983">     *   - 2 true-stereocenters</a>
<a name="ln984">     *   - 2 separate assemblies of para-stereocenters</a>
<a name="ln985">     */</a>
<a name="ln986">    for (std::vector&lt;unsigned int&gt;::iterator idx = paraAtoms.begin(); idx != paraAtoms.end(); ++idx) {</a>
<a name="ln987">      OBAtom *atom = mol-&gt;GetAtom(*idx);</a>
<a name="ln988">      // make sure we didn't add this atom already from rule 1</a>
<a name="ln989">      bool alreadyAdded = false;</a>
<a name="ln990">      for (OBStereoUnitSet::iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln991">        if ((*u2).type == OBStereo::Tetrahedral)</a>
<a name="ln992">          if (atom-&gt;GetId() == (*u2).id) {</a>
<a name="ln993">            alreadyAdded = true;</a>
<a name="ln994">          }</a>
<a name="ln995">      }</a>
<a name="ln996">      if (alreadyAdded)</a>
<a name="ln997">        continue;</a>
<a name="ln998"> </a>
<a name="ln999"> </a>
<a name="ln1000">      int classification = classifyTetrahedralNbrSymClasses(symClasses, atom);</a>
<a name="ln1001">      switch (classification) {</a>
<a name="ln1002">        case T1123:</a>
<a name="ln1003">          // rule 2a with 1 pair</a>
<a name="ln1004">          {</a>
<a name="ln1005">            unsigned int duplicatedSymClass = findDuplicatedSymmetryClass(atom, symClasses);</a>
<a name="ln1006">            OBAtom *ligandAtom = findAtomWithSymmetryClass(atom, duplicatedSymClass, symClasses);</a>
<a name="ln1007">            if (containsAtLeast_1true_2para(ligandAtom, atom, units)) {</a>
<a name="ln1008">              units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1009">            }</a>
<a name="ln1010">          }</a>
<a name="ln1011">          break;</a>
<a name="ln1012">        case T1122:</a>
<a name="ln1013">          // rule 2a with 2 pairs</a>
<a name="ln1014">          {</a>
<a name="ln1015">            unsigned int duplicatedSymClass1, duplicatedSymClass2;</a>
<a name="ln1016">            findDuplicatedSymmetryClasses(atom, symClasses, duplicatedSymClass1, duplicatedSymClass2);</a>
<a name="ln1017">            OBAtom *ligandAtom1 = findAtomWithSymmetryClass(atom, duplicatedSymClass1, symClasses);</a>
<a name="ln1018">            OBAtom *ligandAtom2 = findAtomWithSymmetryClass(atom, duplicatedSymClass2, symClasses);</a>
<a name="ln1019">            if (containsAtLeast_1true_2para(ligandAtom1, atom, units) &amp;&amp;</a>
<a name="ln1020">                containsAtLeast_1true_2para(ligandAtom2, atom, units))</a>
<a name="ln1021">              units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1022">          }</a>
<a name="ln1023">          break;</a>
<a name="ln1024">        case T1112:</a>
<a name="ln1025">          // rule 2b with 3 identical</a>
<a name="ln1026">          {</a>
<a name="ln1027">            unsigned int duplicatedSymClass = findDuplicatedSymmetryClass(atom, symClasses);</a>
<a name="ln1028">            OBAtom *ligandAtom = findAtomWithSymmetryClass(atom, duplicatedSymClass, symClasses);</a>
<a name="ln1029">            if (containsAtLeast_2true_2paraAssemblies(ligandAtom, atom, units, mergedRings))</a>
<a name="ln1030">              units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1031">          }</a>
<a name="ln1032">          break;</a>
<a name="ln1033">        case T1111:</a>
<a name="ln1034">          // rule 2b with 4 identical</a>
<a name="ln1035">          {</a>
<a name="ln1036">            unsigned int duplicatedSymClass = findDuplicatedSymmetryClass(atom, symClasses);</a>
<a name="ln1037">            OBAtom *ligandAtom = findAtomWithSymmetryClass(atom, duplicatedSymClass, symClasses);</a>
<a name="ln1038">            if (containsAtLeast_2true_2paraAssemblies(ligandAtom, atom, units, mergedRings)) {</a>
<a name="ln1039">              units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1040">            }</a>
<a name="ln1041">          }</a>
<a name="ln1042">          break;</a>
<a name="ln1043"> </a>
<a name="ln1044">      }</a>
<a name="ln1045"> </a>
<a name="ln1046">    }</a>
<a name="ln1047"> </a>
<a name="ln1048">    /**</a>
<a name="ln1049">     * Apply rule 3 for double bonds.</a>
<a name="ln1050">     * - 1 or 2 pair identical ligands (on begin and end atom)</a>
<a name="ln1051">     * - each pair contains at least 1 true-stereocenter or 2 para-stereocenters (from rule1)</a>
<a name="ln1052">     */</a>
<a name="ln1053">    for (std::vector&lt;unsigned int&gt;::iterator idx = paraBonds.begin(); idx != paraBonds.end(); ++idx) {</a>
<a name="ln1054">      OBBond *bond = mol-&gt;GetBond(*idx);</a>
<a name="ln1055"> </a>
<a name="ln1056">      // make sure we didn't add this atom already from rule 1</a>
<a name="ln1057">      bool alreadyAdded = false;</a>
<a name="ln1058">      for (OBStereoUnitSet::iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln1059">        if ((*u2).type == OBStereo::CisTrans)</a>
<a name="ln1060">          if (bond-&gt;GetId() == (*u2).id) {</a>
<a name="ln1061">            alreadyAdded = true;</a>
<a name="ln1062">          }</a>
<a name="ln1063">      }</a>
<a name="ln1064">      if (alreadyAdded)</a>
<a name="ln1065">        continue;</a>
<a name="ln1066"> </a>
<a name="ln1067">      OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln1068">      OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln1069"> </a>
<a name="ln1070">      int beginClassification = classifyCisTransNbrSymClasses(symClasses, bond, bond-&gt;GetBeginAtom());</a>
<a name="ln1071">      bool beginValid = false;</a>
<a name="ln1072">      switch (beginClassification) {</a>
<a name="ln1073">        case C12:</a>
<a name="ln1074">          beginValid = true;</a>
<a name="ln1075">          break;</a>
<a name="ln1076">        case C11:</a>
<a name="ln1077">          {</a>
<a name="ln1078">            // find the ligand</a>
<a name="ln1079">            OBAtom *ligandAtom = nullptr;</a>
<a name="ln1080">            FOR_NBORS_OF_ATOM (nbr, begin) {</a>
<a name="ln1081">              if ((nbr-&gt;GetIdx() != bond-&gt;GetBeginAtomIdx()) &amp;&amp; (nbr-&gt;GetIdx() != bond-&gt;GetEndAtomIdx())) {</a>
<a name="ln1082">                ligandAtom = &amp;*nbr;</a>
<a name="ln1083">                break;</a>
<a name="ln1084">              }</a>
<a name="ln1085">            }</a>
<a name="ln1086"> </a>
<a name="ln1087">            OBBitVec ligand = getFragment(ligandAtom, begin);</a>
<a name="ln1088">            for (OBStereoUnitSet::iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln1089">              if ((*u2).type == OBStereo::Tetrahedral) {</a>
<a name="ln1090">                if (ligand.BitIsSet((*u2).id))</a>
<a name="ln1091">                  beginValid = true;</a>
<a name="ln1092">              } else if((*u2).type == OBStereo::CisTrans) {</a>
<a name="ln1093">                OBBond *bond = mol-&gt;GetBondById((*u2).id);</a>
<a name="ln1094">                OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln1095">                OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln1096">                if (ligand.BitIsSet(begin-&gt;GetId()) || ligand.BitIsSet(end-&gt;GetId()))</a>
<a name="ln1097">                  beginValid = true;</a>
<a name="ln1098">              }</a>
<a name="ln1099">            }</a>
<a name="ln1100">          }</a>
<a name="ln1101">          break;</a>
<a name="ln1102">      }</a>
<a name="ln1103"> </a>
<a name="ln1104">      if (!beginValid)</a>
<a name="ln1105">        continue;</a>
<a name="ln1106"> </a>
<a name="ln1107">      int endClassification = classifyCisTransNbrSymClasses(symClasses, bond, bond-&gt;GetEndAtom());</a>
<a name="ln1108">      bool endValid = false;</a>
<a name="ln1109">      switch (endClassification) {</a>
<a name="ln1110">        case C12:</a>
<a name="ln1111">          endValid = true;</a>
<a name="ln1112">          break;</a>
<a name="ln1113">        case C11:</a>
<a name="ln1114">          {</a>
<a name="ln1115">            // find the ligand</a>
<a name="ln1116">            OBAtom *ligandAtom = nullptr;</a>
<a name="ln1117">            FOR_NBORS_OF_ATOM (nbr, end) {</a>
<a name="ln1118">              if ((nbr-&gt;GetIdx() != bond-&gt;GetBeginAtomIdx()) &amp;&amp; (nbr-&gt;GetIdx() != bond-&gt;GetEndAtomIdx())) {</a>
<a name="ln1119">                ligandAtom = &amp;*nbr;</a>
<a name="ln1120">                break;</a>
<a name="ln1121">              }</a>
<a name="ln1122">            }</a>
<a name="ln1123"> </a>
<a name="ln1124">            OBBitVec ligand = getFragment(ligandAtom, end);</a>
<a name="ln1125">            for (OBStereoUnitSet::iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln1126">              if ((*u2).type == OBStereo::Tetrahedral) {</a>
<a name="ln1127">                if (ligand.BitIsSet((*u2).id))</a>
<a name="ln1128">                  endValid = true;</a>
<a name="ln1129">              } else if((*u2).type == OBStereo::CisTrans) {</a>
<a name="ln1130">                OBBond *bond = mol-&gt;GetBondById((*u2).id);</a>
<a name="ln1131">                OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln1132">                OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln1133">                if (ligand.BitIsSet(begin-&gt;GetId()) || ligand.BitIsSet(end-&gt;GetId()))</a>
<a name="ln1134">                  endValid = true;</a>
<a name="ln1135">              }</a>
<a name="ln1136">            }</a>
<a name="ln1137">          }</a>
<a name="ln1138">          break;</a>
<a name="ln1139">      }</a>
<a name="ln1140"> </a>
<a name="ln1141">      if (endValid)</a>
<a name="ln1142">        units.push_back(OBStereoUnit(OBStereo::CisTrans, bond-&gt;GetId(), true));</a>
<a name="ln1143">    }</a>
<a name="ln1144"> </a>
<a name="ln1145">    if (DEBUG) {</a>
<a name="ln1146">      for (OBStereoUnitSet::iterator unit = units.begin(); unit != units.end(); ++unit) {</a>
<a name="ln1147">        if (unit-&gt;type == OBStereo::Tetrahedral)</a>
<a name="ln1148">          cout &lt;&lt; &quot;Tetrahedral(center = &quot; &lt;&lt; unit-&gt;id &lt;&lt; &quot;, para = &quot; &lt;&lt; unit-&gt;para &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1149">        if (unit-&gt;type == OBStereo::CisTrans)</a>
<a name="ln1150">          cout &lt;&lt; &quot;CisTrans(bond = &quot; &lt;&lt; unit-&gt;id &lt;&lt; &quot;, para = &quot; &lt;&lt; unit-&gt;para &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1151">        if (unit-&gt;type == OBStereo::SquarePlanar)</a>
<a name="ln1152">          cout &lt;&lt; &quot;SquarePlanar(bond = &quot; &lt;&lt; unit-&gt;id &lt;&lt; &quot;, para = &quot; &lt;&lt; unit-&gt;para &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1153">      }</a>
<a name="ln1154">    }</a>
<a name="ln1155"> </a>
<a name="ln1156"> </a>
<a name="ln1157">    return units;</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160"> </a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165"> </a>
<a name="ln1166"> </a>
<a name="ln1167"> </a>
<a name="ln1168"> </a>
<a name="ln1169"> </a>
<a name="ln1170"> </a>
<a name="ln1171"> </a>
<a name="ln1172"> </a>
<a name="ln1173"> </a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176"> </a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179"> </a>
<a name="ln1180">// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183"> </a>
<a name="ln1184"> </a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">  /**</a>
<a name="ln1188">   * Helper function for FindStereogenicUnits using automorphisms.</a>
<a name="ln1189">   *</a>
<a name="ln1190">   * Find the duplicated symmetry class for neighbors of atom. This method only works if there is</a>
<a name="ln1191">   * only one duplicated symmetry class (i.e. T1123, T1112, T1111).</a>
<a name="ln1192">   */</a>
<a name="ln1193">  unsigned int findDuplicatedSymmetryClass(OBAtom *atom, const std::vector&lt;unsigned int&gt; &amp;symClasses)</a>
<a name="ln1194">  {</a>
<a name="ln1195">    // find the duplicated symmetry class</a>
<a name="ln1196">    unsigned int duplicatedSymClass = OBGraphSym::NoSymmetryClass; // FIXME</a>
<a name="ln1197">    std::vector&lt;unsigned int&gt; nbrSymClasses;</a>
<a name="ln1198">    FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1199">      nbrSymClasses.push_back(symClasses.at(nbr-&gt;GetIndex()));</a>
<a name="ln1200">    }</a>
<a name="ln1201">    for (std::size_t i = 0; i &lt; nbrSymClasses.size(); ++i) {</a>
<a name="ln1202">      if (std::count(nbrSymClasses.begin(), nbrSymClasses.end(), nbrSymClasses.at(i)) &gt;= 2) {</a>
<a name="ln1203">        duplicatedSymClass = nbrSymClasses.at(i);</a>
<a name="ln1204">        break;</a>
<a name="ln1205">      }</a>
<a name="ln1206">    }</a>
<a name="ln1207">    return duplicatedSymClass;</a>
<a name="ln1208">  }</a>
<a name="ln1209"> </a>
<a name="ln1210">  /**</a>
<a name="ln1211">   * Helper function for FindStereogenicUnits using automorphisms.</a>
<a name="ln1212">   *</a>
<a name="ln1213">   * Find the duplicated symmetry classes for neighbors of atom. This method only works for the</a>
<a name="ln1214">   * T1122 case.</a>
<a name="ln1215">   */</a>
<a name="ln1216">  void findDuplicatedSymmetryClasses(OBAtom *atom, const std::vector&lt;unsigned int&gt; &amp;symClasses,</a>
<a name="ln1217">      unsigned int &amp;duplicated1, unsigned int &amp;duplicated2)</a>
<a name="ln1218">  {</a>
<a name="ln1219">    std::vector&lt;unsigned int&gt; nbrSymClasses;</a>
<a name="ln1220">    FOR_NBORS_OF_ATOM (nbr, atom)</a>
<a name="ln1221">      nbrSymClasses.push_back(symClasses.at(nbr-&gt;GetIndex()));</a>
<a name="ln1222">    std::sort(nbrSymClasses.begin(), nbrSymClasses.end());</a>
<a name="ln1223">    duplicated1 = nbrSymClasses[0];</a>
<a name="ln1224">    duplicated2 = nbrSymClasses[2];</a>
<a name="ln1225">  }</a>
<a name="ln1226"> </a>
<a name="ln1227">  /**</a>
<a name="ln1228">   * Helper function for FindStereogenicUnits using automorphisms.</a>
<a name="ln1229">   *</a>
<a name="ln1230">   * Find the duplicated symmetry classes for neighbors of atoms. This method works for all</a>
<a name="ln1231">   * cases (i.e. T1234, T1123, T1112, T1111 and T1122).</a>
<a name="ln1232">   */</a>
<a name="ln1233">  std::vector&lt;unsigned int&gt; findDuplicatedSymmetryClasses(OBAtom *atom, const std::vector&lt;unsigned int&gt; &amp;symClasses)</a>
<a name="ln1234">  {</a>
<a name="ln1235">    std::vector&lt;unsigned int&gt; nbrSymClasses, result;</a>
<a name="ln1236">    FOR_NBORS_OF_ATOM (nbr, atom)</a>
<a name="ln1237">      nbrSymClasses.push_back(symClasses.at(nbr-&gt;GetIndex()));</a>
<a name="ln1238"> </a>
<a name="ln1239">    std::sort(nbrSymClasses.begin(), nbrSymClasses.end());</a>
<a name="ln1240">    for (std::size_t i = 0; i &lt; nbrSymClasses.size(); ++i)</a>
<a name="ln1241">      if (std::count(nbrSymClasses.begin(), nbrSymClasses.end(), nbrSymClasses[i]) &gt; 1)</a>
<a name="ln1242">        if (std::find(result.begin(), result.end(), nbrSymClasses[i]) == result.end())</a>
<a name="ln1243">          result.push_back(nbrSymClasses[i]);</a>
<a name="ln1244">    return result;</a>
<a name="ln1245">  }</a>
<a name="ln1246"> </a>
<a name="ln1247">  inline bool ComparePairSecond(const std::pair&lt;unsigned int, unsigned int&gt; &amp;a,</a>
<a name="ln1248">      const std::pair&lt;unsigned int, unsigned int&gt; &amp;b)</a>
<a name="ln1249">  {</a>
<a name="ln1250">    return (a.second &lt; b.second);</a>
<a name="ln1251">  }</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254"> </a>
<a name="ln1255">  /**</a>
<a name="ln1256">   * Helper functions for FindStereogenicUnits (using automorphisms).</a>
<a name="ln1257">   *</a>
<a name="ln1258">   * These functions determine if an automorphism permutation invert the</a>
<a name="ln1259">   * configuration of stereocenters by exchanging equivalent neighbor atoms</a>
<a name="ln1260">   * (i.e. neighbor atoms with the same topological symmetry class).</a>
<a name="ln1261">   *</a>
<a name="ln1262">   * @note: The molecule should be ordered by topological canonical labels.</a>
<a name="ln1263">   */</a>
<a name="ln1264">  struct StereoInverted {</a>
<a name="ln1265">    struct Entry {</a>
<a name="ln1266">      Automorphism p;</a>
<a name="ln1267">      std::vector&lt;OBAtom*&gt; invertedAtoms;</a>
<a name="ln1268">      std::vector&lt;OBBond*&gt; invertedBonds;</a>
<a name="ln1269">    };</a>
<a name="ln1270"> </a>
<a name="ln1271">    /**</a>
<a name="ln1272">     * Check if the specified automorphism causes an inversion of configuration</a>
<a name="ln1273">     * for the specified tetrahedral stereogenic center.</a>
<a name="ln1274">     */</a>
<a name="ln1275">    static bool permutationInvertsTetrahedralCenter(const Automorphism &amp;p,</a>
<a name="ln1276">        OBAtom *center, const std::vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln1277">        const std::vector&lt;unsigned int&gt; &amp;canon_labels)</a>
<a name="ln1278">    {</a>
<a name="ln1279">      // Find the duplicated ligand symmetry class(es)</a>
<a name="ln1280">      std::vector&lt;unsigned int&gt; duplicatedSymClasses = findDuplicatedSymmetryClasses(center, symmetry_classes);</a>
<a name="ln1281"> </a>
<a name="ln1282">      if (DEBUG_INVERSIONS) {</a>
<a name="ln1283">        cout &lt;&lt; &quot;permutationInvertsTetrahedralCenter(&quot; &lt;&lt; center-&gt;GetIndex() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1284">        print_vector(&quot;duplicatedSymClasses&quot;, duplicatedSymClasses);</a>
<a name="ln1285">      }</a>
<a name="ln1286"> </a>
<a name="ln1287">      std::vector&lt; std::vector&lt;OBAtom*&gt; &gt; duplicatedAtoms;</a>
<a name="ln1288"> </a>
<a name="ln1289">      int permutated = 0;</a>
<a name="ln1290">      for (std::size_t i = 0; i &lt; duplicatedSymClasses.size(); ++i) {</a>
<a name="ln1291">        unsigned int duplicatedSymClass = duplicatedSymClasses[i];</a>
<a name="ln1292"> </a>
<a name="ln1293">        duplicatedAtoms.resize(duplicatedAtoms.size()+1);</a>
<a name="ln1294"> </a>
<a name="ln1295">        // Store the ligand indexes for the atoms with the duplicated symmetry class</a>
<a name="ln1296">        std::vector&lt; std::pair&lt;unsigned int, unsigned int&gt; &gt; tlist1;</a>
<a name="ln1297">        FOR_NBORS_OF_ATOM (nbr, center) {</a>
<a name="ln1298">          if (symmetry_classes[nbr-&gt;GetIndex()] == duplicatedSymClass) {</a>
<a name="ln1299">            tlist1.push_back(std::make_pair(nbr-&gt;GetIndex(), canon_labels[nbr-&gt;GetIndex()]));</a>
<a name="ln1300">            duplicatedAtoms.back().push_back(&amp;*nbr);</a>
<a name="ln1301">          }</a>
<a name="ln1302">        }</a>
<a name="ln1303">        // Sort the indexes</a>
<a name="ln1304">        std::sort(tlist1.begin(), tlist1.end(), ComparePairSecond);</a>
<a name="ln1305"> </a>
<a name="ln1306">        //if (DEBUG_INVERSIONS) print_vector(&quot;tlist 1&quot;, tlist1);</a>
<a name="ln1307"> </a>
<a name="ln1308">        // Translate the sorted indexes using the automorphism</a>
<a name="ln1309">        std::vector&lt;unsigned long&gt; tlist2;</a>
<a name="ln1310">        for (std::size_t j = 0; j &lt; tlist1.size(); ++j) {</a>
<a name="ln1311">          unsigned int t;</a>
<a name="ln1312">          if (MapsTo(p, tlist1[j].first, t))</a>
<a name="ln1313">            tlist2.push_back(canon_labels[t]);</a>
<a name="ln1314">        }</a>
<a name="ln1315"> </a>
<a name="ln1316">        if (DEBUG_INVERSIONS) print_vector(&quot;tlist 2&quot;, tlist2);</a>
<a name="ln1317"> </a>
<a name="ln1318">        // Permute the flag</a>
<a name="ln1319">        if (OBStereo::NumInversions(tlist2) % 2)</a>
<a name="ln1320">          //permutated = !permutated;</a>
<a name="ln1321">          permutated++;</a>
<a name="ln1322">      }</a>
<a name="ln1323"> </a>
<a name="ln1324">      if (permutated == 2) {</a>
<a name="ln1325">        std::vector&lt;OBRing*&gt; lssr = center-&gt;GetParent()-&gt;GetLSSR();</a>
<a name="ln1326">        assert( duplicatedAtoms.size() == 2 );</a>
<a name="ln1327">        assert( duplicatedAtoms[0].size() == 2 );</a>
<a name="ln1328">        assert( duplicatedAtoms[1].size() == 2 );</a>
<a name="ln1329">        for (std::size_t i = 0; i &lt; lssr.size(); ++i) {</a>
<a name="ln1330">          if (lssr[i]-&gt;_pathset.BitIsSet(duplicatedAtoms[0][0]-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln1331">              lssr[i]-&gt;_pathset.BitIsSet(duplicatedAtoms[0][1]-&gt;GetIdx()))</a>
<a name="ln1332">            return false;</a>
<a name="ln1333">          if (lssr[i]-&gt;_pathset.BitIsSet(duplicatedAtoms[1][0]-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln1334">              lssr[i]-&gt;_pathset.BitIsSet(duplicatedAtoms[1][1]-&gt;GetIdx()))</a>
<a name="ln1335">            return false;</a>
<a name="ln1336">        }</a>
<a name="ln1337">        return true;</a>
<a name="ln1338">      }</a>
<a name="ln1339"> </a>
<a name="ln1340">      return permutated;</a>
<a name="ln1341">    }</a>
<a name="ln1342"> </a>
<a name="ln1343">    static bool permutationInvertsCisTransBeginOrEndAtom(const Automorphism &amp;p, OBBond *bond, OBAtom *beginOrEnd,</a>
<a name="ln1344">        const std::vector&lt;unsigned int&gt; &amp;canon_labels)</a>
<a name="ln1345">    {</a>
<a name="ln1346">      OBAtom *otherAtom = bond-&gt;GetNbrAtom(beginOrEnd);</a>
<a name="ln1347"> </a>
<a name="ln1348">      std::vector&lt; std::pair&lt;unsigned int, unsigned int&gt; &gt; tlist1;</a>
<a name="ln1349">      // Store the neighbor indexes in tlist1</a>
<a name="ln1350">      FOR_NBORS_OF_ATOM (nbr, beginOrEnd) {</a>
<a name="ln1351">        // skip the other double bond atom</a>
<a name="ln1352">        if (nbr-&gt;GetId() == otherAtom-&gt;GetId())</a>
<a name="ln1353">          continue;</a>
<a name="ln1354">        tlist1.push_back(std::make_pair(nbr-&gt;GetIndex(), canon_labels[nbr-&gt;GetIndex()]));</a>
<a name="ln1355">      }</a>
<a name="ln1356">      // Sort the indexes</a>
<a name="ln1357">      std::sort(tlist1.begin(), tlist1.end(), ComparePairSecond);</a>
<a name="ln1358"> </a>
<a name="ln1359">      // Translate the sorted indexes using the automorphism</a>
<a name="ln1360">      std::vector&lt;unsigned long&gt; tlist2;</a>
<a name="ln1361">      for (std::size_t j = 0; j &lt; tlist1.size(); ++j) {</a>
<a name="ln1362">        unsigned int t;</a>
<a name="ln1363">        if (MapsTo(p, tlist1[j].first, t))</a>
<a name="ln1364">          tlist2.push_back(canon_labels[t]);</a>
<a name="ln1365">      }</a>
<a name="ln1366"> </a>
<a name="ln1367">      return (OBStereo::NumInversions(tlist2) % 2);</a>
<a name="ln1368">    }</a>
<a name="ln1369"> </a>
<a name="ln1370">    /**</a>
<a name="ln1371">     * Check if the specified automorphism causes an inversion of configuration</a>
<a name="ln1372">     * for the specfied stereogenic double bond.</a>
<a name="ln1373">     */</a>
<a name="ln1374">    static bool permutationInvertsCisTransCenter(const Automorphism &amp;p, OBBond *bond,</a>
<a name="ln1375">        const std::vector&lt;unsigned int&gt; &amp;canon_labels)</a>
<a name="ln1376">    {</a>
<a name="ln1377">      // begin atom</a>
<a name="ln1378">      bool beginInverted = permutationInvertsCisTransBeginOrEndAtom(p, bond, bond-&gt;GetBeginAtom(), canon_labels);</a>
<a name="ln1379">      // end atom</a>
<a name="ln1380">      bool endInverted = permutationInvertsCisTransBeginOrEndAtom(p, bond, bond-&gt;GetEndAtom(), canon_labels);</a>
<a name="ln1381"> </a>
<a name="ln1382">      // combine result using xor operation</a>
<a name="ln1383">      if (beginInverted ^ endInverted)</a>
<a name="ln1384">        return true;</a>
<a name="ln1385">      return false;</a>
<a name="ln1386">    }</a>
<a name="ln1387"> </a>
<a name="ln1388">    /**</a>
<a name="ln1389">     * Perform the computation.</a>
<a name="ln1390">     */</a>
<a name="ln1391">    static std::vector&lt;Entry&gt; compute(OBMol *mol, const std::vector&lt;unsigned int&gt; &amp;symClasses,</a>
<a name="ln1392">        const Automorphisms &amp;automorphisms)</a>
<a name="ln1393">    {</a>
<a name="ln1394">      if (DEBUG_INVERSIONS) cout &lt;&lt; &quot;ENTER StereoInverted::compute()&quot; &lt;&lt; endl;</a>
<a name="ln1395"> </a>
<a name="ln1396">      // We need topological canonical labels for this</a>
<a name="ln1397">      std::vector&lt;unsigned int&gt; canon_labels;</a>
<a name="ln1398">      CanonicalLabels(mol, symClasses, canon_labels, OBBitVec(), 5, true);</a>
<a name="ln1399"> </a>
<a name="ln1400">      // the result</a>
<a name="ln1401">      std::vector&lt;Entry&gt; result;</a>
<a name="ln1402"> </a>
<a name="ln1403">      // make a list of stereogenic centers inverted by the automorphism permutations</a>
<a name="ln1404">      for (std::size_t i = 0; i &lt; automorphisms.size(); ++i) {</a>
<a name="ln1405">        Entry entry;</a>
<a name="ln1406">        entry.p = automorphisms[i];</a>
<a name="ln1407"> </a>
<a name="ln1408">        if (DEBUG_INVERSIONS) cout &lt;&lt; &quot;----&gt; Checking automorphism &quot; &lt;&lt; i+1 &lt;&lt; endl;</a>
<a name="ln1409"> </a>
<a name="ln1410">        // Check the atoms</a>
<a name="ln1411">        std::vector&lt;OBAtom*&gt;::iterator ia;</a>
<a name="ln1412">        for (OBAtom *atom = mol-&gt;BeginAtom(ia); atom; atom = mol-&gt;NextAtom(ia)) {</a>
<a name="ln1413">          // consider only potential stereo centers</a>
<a name="ln1414">          if (!isPotentialTetrahedral(atom))</a>
<a name="ln1415">            continue;</a>
<a name="ln1416">          // add the atom to the inverted list if the automorphism inverses it's configuration</a>
<a name="ln1417">          if (permutationInvertsTetrahedralCenter(automorphisms[i], atom, symClasses, canon_labels))</a>
<a name="ln1418">            entry.invertedAtoms.push_back(atom);</a>
<a name="ln1419">        }</a>
<a name="ln1420"> </a>
<a name="ln1421">        // Check the bonds</a>
<a name="ln1422">        std::vector&lt;OBBond*&gt;::iterator ib;</a>
<a name="ln1423">        for (OBBond *bond = mol-&gt;BeginBond(ib); bond; bond = mol-&gt;NextBond(ib)) {</a>
<a name="ln1424">          // consider only potential stereo centers</a>
<a name="ln1425">          if (!isPotentialCisTrans(bond))</a>
<a name="ln1426">            continue;</a>
<a name="ln1427">          // add the bond to the inverted list if the automorphism inverses it's configuration</a>
<a name="ln1428">          if (permutationInvertsCisTransCenter(entry.p, bond, canon_labels))</a>
<a name="ln1429">            entry.invertedBonds.push_back(bond);</a>
<a name="ln1430">        }</a>
<a name="ln1431"> </a>
<a name="ln1432">        if (DEBUG_INVERSIONS) {</a>
<a name="ln1433">          cout &lt;&lt; &quot;automorphism &quot; &lt;&lt; i+1 &lt;&lt; &quot;     &quot;;</a>
<a name="ln1434">          for (std::size_t j = 0; j &lt; mol-&gt;NumAtoms(); ++j) {</a>
<a name="ln1435">            unsigned int t;</a>
<a name="ln1436">            if (MapsTo(entry.p, j, t)) {</a>
<a name="ln1437">              if (t &lt; 10) {</a>
<a name="ln1438">                cout &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; &quot; &quot;;</a>
<a name="ln1439">              } else {</a>
<a name="ln1440">                cout &lt;&lt; t &lt;&lt; &quot; &quot;;</a>
<a name="ln1441">              }</a>
<a name="ln1442">            }</a>
<a name="ln1443">          }</a>
<a name="ln1444">          cout &lt;&lt; endl;</a>
<a name="ln1445">          cout &lt;&lt; &quot;  invertedAtoms: &quot;;</a>
<a name="ln1446">          for (std::size_t l = 0; l &lt; entry.invertedAtoms.size(); ++l)</a>
<a name="ln1447">            cout &lt;&lt; entry.invertedAtoms[l]-&gt;GetId() &lt;&lt; &quot; &quot;;</a>
<a name="ln1448">          cout &lt;&lt; endl;</a>
<a name="ln1449">          cout &lt;&lt; &quot;  invertedBonds: &quot;;</a>
<a name="ln1450">          for (std::size_t l = 0; l &lt; entry.invertedBonds.size(); ++l)</a>
<a name="ln1451">            cout &lt;&lt; entry.invertedBonds[l]-&gt;GetId() &lt;&lt; &quot; &quot;;</a>
<a name="ln1452">          cout &lt;&lt; endl;</a>
<a name="ln1453">        }</a>
<a name="ln1454"> </a>
<a name="ln1455">        result.push_back(entry);</a>
<a name="ln1456">      }</a>
<a name="ln1457"> </a>
<a name="ln1458">      if (DEBUG_INVERSIONS) cout &lt;&lt; &quot;EXIT StereoInverted::compute()&quot; &lt;&lt; endl;</a>
<a name="ln1459"> </a>
<a name="ln1460">      return result;</a>
<a name="ln1461">    }</a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">  };</a>
<a name="ln1465"> </a>
<a name="ln1466">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1467">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1468">  //</a>
<a name="ln1469">  //</a>
<a name="ln1470">  //  FindStereogenicUnits using automorphisms</a>
<a name="ln1471">  //</a>
<a name="ln1472">  //</a>
<a name="ln1473">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1474">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1475"> </a>
<a name="ln1476">  /**</a>
<a name="ln1477">   * Find an atom with the specified symmetry class. The first found atom is returned</a>
<a name="ln1478">   * or 0 when there is no such atom. This function is intended to be used in cases</a>
<a name="ln1479">   * where any atom with the specified symmetry class can be used. For example, when</a>
<a name="ln1480">   * checking a fragments for stereocenters, the result will be the same for any atom</a>
<a name="ln1481">   * with a specified (duplicated) symmetry class.</a>
<a name="ln1482">   */</a>
<a name="ln1483">  OBAtom* findAtomWithSymmetryClass(OBAtom *atom, unsigned int symClass, const std::vector&lt;unsigned int&gt; &amp;symClasses)</a>
<a name="ln1484">  {</a>
<a name="ln1485">    OBAtom *ligandAtom = nullptr;</a>
<a name="ln1486">    FOR_NBORS_OF_ATOM (nbr, atom)</a>
<a name="ln1487">      if (symClasses.at(nbr-&gt;GetIndex()) == symClass)</a>
<a name="ln1488">        ligandAtom = &amp;*nbr;</a>
<a name="ln1489">    return ligandAtom;</a>
<a name="ln1490">  }</a>
<a name="ln1491"> </a>
<a name="ln1492">  /**</a>
<a name="ln1493">   * Helper function to determine if a stereogenic center with duplicated symmetry classes</a>
<a name="ln1494">   * really is a stereogenic center.</a>
<a name="ln1495">   *</a>
<a name="ln1496">   * Check if the ligandAtom's fragment (see getFragment()) contains at least one</a>
<a name="ln1497">   * true- or 1 para-stereocenter. This is rule 1 (a &amp; b) in the Razinger paper on</a>
<a name="ln1498">   * stereoisomer generation.</a>
<a name="ln1499">   */</a>
<a name="ln1500">  bool containsAtLeast_1true_1para(OBAtom *ligandAtom, OBAtom *skip, const OBStereoUnitSet &amp;units)</a>
<a name="ln1501">  {</a>
<a name="ln1502">    OBMol *mol = skip-&gt;GetParent();</a>
<a name="ln1503">    // create the fragment bitvec</a>
<a name="ln1504">    OBBitVec ligand = getFragment(ligandAtom, skip);</a>
<a name="ln1505">    for (OBStereoUnitSet::const_iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln1506">      if (isUnitInFragment(mol, *u2, ligand))</a>
<a name="ln1507">        return true;</a>
<a name="ln1508">    }</a>
<a name="ln1509">    return false;</a>
<a name="ln1510">  }</a>
<a name="ln1511"> </a>
<a name="ln1512">  /**</a>
<a name="ln1513">   * Helper function to determine if a stereogenic center with duplicated symmetry classes</a>
<a name="ln1514">   * really is a stereogenic center.</a>
<a name="ln1515">   *</a>
<a name="ln1516">   * Check if the ligandAtom's fragment (see getFragment()) contains at least one</a>
<a name="ln1517">   * true- or 2 para-stereocenter. This is rule 2a and rule 3 in the Razinger</a>
<a name="ln1518">   * paper on stereoisomer generation.</a>
<a name="ln1519">   */</a>
<a name="ln1520">  bool containsAtLeast_1true_2para(OBAtom *ligandAtom, OBAtom *atom, const OBStereoUnitSet &amp;units)</a>
<a name="ln1521">  {</a>
<a name="ln1522">    OBMol *mol = atom-&gt;GetParent();</a>
<a name="ln1523">    // check if ligand contains at least:</a>
<a name="ln1524">    // - 1 true-stereocenter</a>
<a name="ln1525">    // - 2 para-stereocenters</a>
<a name="ln1526">    OBBitVec ligand = getFragment(ligandAtom, atom);</a>
<a name="ln1527">    bool foundTrueStereoCenter = false;</a>
<a name="ln1528">    int paraStereoCenterCount = 0;</a>
<a name="ln1529">    for (OBStereoUnitSet::const_iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln1530">      if (isUnitInFragment(mol, *u2, ligand)) {</a>
<a name="ln1531">        if ((*u2).para) {</a>
<a name="ln1532">          paraStereoCenterCount++;</a>
<a name="ln1533">        } else {</a>
<a name="ln1534">          foundTrueStereoCenter = true;</a>
<a name="ln1535">        }</a>
<a name="ln1536">      }</a>
<a name="ln1537">    }</a>
<a name="ln1538"> </a>
<a name="ln1539">    if (foundTrueStereoCenter || paraStereoCenterCount &gt;= 2)</a>
<a name="ln1540">      return true;</a>
<a name="ln1541">    if (ligandAtom-&gt;IsInRing() &amp;&amp; atom-&gt;IsInRing() &amp;&amp; paraStereoCenterCount)</a>
<a name="ln1542">      return true;</a>
<a name="ln1543">    return false;</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  /**</a>
<a name="ln1547">   * Helper function to determine if a stereogenic center with duplicated symmetry classes</a>
<a name="ln1548">   * really is a stereogenic center.</a>
<a name="ln1549">   *</a>
<a name="ln1550">   * Check if the ligandAtom's fragment (see getFragment()) contains at least one</a>
<a name="ln1551">   * true- or 2 separate assemblies of at least 2 para-stereocenter. This is rule</a>
<a name="ln1552">   * 2b in the Razinger paper on stereoisomer generation.</a>
<a name="ln1553">   */</a>
<a name="ln1554">  bool containsAtLeast_2true_2paraAssemblies(OBAtom *ligandAtom, OBAtom *atom, const OBStereoUnitSet &amp;units, const std::vector&lt;OBBitVec&gt; &amp;mergedRings)</a>
<a name="ln1555">  {</a>
<a name="ln1556">    OBMol *mol = atom-&gt;GetParent();</a>
<a name="ln1557">    // check if ligand contains at least:</a>
<a name="ln1558">    // - 2 true-stereocenter</a>
<a name="ln1559">    // - 2 separate para-stereocenters assemblies</a>
<a name="ln1560">    OBBitVec ligand = getFragment(ligandAtom, atom);</a>
<a name="ln1561">    int trueStereoCenterCount = 0;</a>
<a name="ln1562">    std::vector&lt;unsigned int&gt; ringIndices;</a>
<a name="ln1563">    for (OBStereoUnitSet::const_iterator u2 = units.begin(); u2 != units.end(); ++u2) {</a>
<a name="ln1564">      if ((*u2).type == OBStereo::Tetrahedral) {</a>
<a name="ln1565">        if (ligand.BitIsSet((*u2).id)) {</a>
<a name="ln1566">          if ((*u2).para) {</a>
<a name="ln1567">            OBAtom *paraAtom = mol-&gt;GetAtomById((*u2).id);</a>
<a name="ln1568">            for (std::size_t ringIdx = 0; ringIdx &lt; mergedRings.size(); ++ringIdx) {</a>
<a name="ln1569">              if (mergedRings.at(ringIdx).BitIsSet(paraAtom-&gt;GetIdx()))</a>
<a name="ln1570">                if (std::find(ringIndices.begin(), ringIndices.end(), ringIdx) == ringIndices.end())</a>
<a name="ln1571">                  ringIndices.push_back(ringIdx);</a>
<a name="ln1572">            }</a>
<a name="ln1573">          } else</a>
<a name="ln1574">            trueStereoCenterCount++;</a>
<a name="ln1575">        }</a>
<a name="ln1576">      } else if((*u2).type == OBStereo::CisTrans) {</a>
<a name="ln1577">        OBBond *bond = mol-&gt;GetBondById((*u2).id);</a>
<a name="ln1578">        OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln1579">        OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln1580">        if (ligand.BitIsSet(begin-&gt;GetId()) || ligand.BitIsSet(end-&gt;GetId())) {</a>
<a name="ln1581">          if ((*u2).para) {</a>
<a name="ln1582">            for (std::size_t ringIdx = 0; ringIdx &lt; mergedRings.size(); ++ringIdx) {</a>
<a name="ln1583">              if (mergedRings.at(ringIdx).BitIsSet(begin-&gt;GetIdx()) || mergedRings.at(ringIdx).BitIsSet(end-&gt;GetIdx())) {</a>
<a name="ln1584">                if (std::find(ringIndices.begin(), ringIndices.end(), ringIdx) == ringIndices.end()) {</a>
<a name="ln1585">                  ringIndices.push_back(ringIdx);</a>
<a name="ln1586">                }</a>
<a name="ln1587">              }</a>
<a name="ln1588">            }</a>
<a name="ln1589">          } else {</a>
<a name="ln1590">            trueStereoCenterCount++;</a>
<a name="ln1591">          }</a>
<a name="ln1592">        }</a>
<a name="ln1593">      }</a>
<a name="ln1594">    }</a>
<a name="ln1595"> </a>
<a name="ln1596">    if (trueStereoCenterCount &gt;= 2 || ringIndices.size() &gt;= 2)</a>
<a name="ln1597">      return true;</a>
<a name="ln1598">    return false;</a>
<a name="ln1599">  }</a>
<a name="ln1600"> </a>
<a name="ln1601">  /**</a>
<a name="ln1602">   * Find the stereogenic units in a molecule using automorphisms.</a>
<a name="ln1603">   *</a>
<a name="ln1604">   * This is a public function: see header for details.</a>
<a name="ln1605">   */</a>
<a name="ln1606">  OBStereoUnitSet FindStereogenicUnits(OBMol *mol,</a>
<a name="ln1607">      const std::vector&lt;unsigned int&gt; &amp;symClasses, const Automorphisms &amp;automorphisms)</a>
<a name="ln1608">  {</a>
<a name="ln1609">    OBStereoUnitSet units;</a>
<a name="ln1610"> </a>
<a name="ln1611">    // do quick test to see if there are any possible stereogenic units</a>
<a name="ln1612">    if (!mayHaveTetrahedralCenter(mol) &amp;&amp; !mayHaveCisTransBond(mol))</a>
<a name="ln1613">      return units;</a>
<a name="ln1614"> </a>
<a name="ln1615">    // make sure we have symmetry classes for all atoms</a>
<a name="ln1616">    if (symClasses.size() != mol-&gt;NumAtoms())</a>
<a name="ln1617">      return units;</a>
<a name="ln1618"> </a>
<a name="ln1619">    // Compute which automorphisms cause inversion of configuration</a>
<a name="ln1620">    // for the stereogenic units</a>
<a name="ln1621">    std::vector&lt;StereoInverted::Entry&gt; inverted = StereoInverted::compute(mol, symClasses, automorphisms);</a>
<a name="ln1622"> </a>
<a name="ln1623">    std::vector&lt;OBBitVec&gt; mergedRings = mergeRings(mol, symClasses);</a>
<a name="ln1624"> </a>
<a name="ln1625">    std::vector&lt;unsigned long&gt; doneAtoms, doneBonds;</a>
<a name="ln1626">    unsigned int lastSize = units.size();</a>
<a name="ln1627">    while (true) {</a>
<a name="ln1628">      std::vector&lt;OBAtom*&gt;::iterator ia;</a>
<a name="ln1629">      for (OBAtom *atom = mol-&gt;BeginAtom(ia); atom; atom = mol-&gt;NextAtom(ia)) {</a>
<a name="ln1630">        if (std::find(doneAtoms.begin(), doneAtoms.end(), atom-&gt;GetId()) != doneAtoms.end())</a>
<a name="ln1631">          continue;</a>
<a name="ln1632">        // consider only potential steroecenters</a>
<a name="ln1633">        if (!isPotentialTetrahedral(atom))</a>
<a name="ln1634">          continue;</a>
<a name="ln1635"> </a>
<a name="ln1636">        // A potential stereocenter is really a stereocenter if there exists no automorphic</a>
<a name="ln1637">        // permutation causing an inversion of the configuration of only the potential</a>
<a name="ln1638">        // stereogenic unit under consideration.</a>
<a name="ln1639">        bool foundPermutation = false; // invert __only__ configuration of atom</a>
<a name="ln1640">        for (std::size_t i = 0; i &lt; inverted.size(); ++i) {</a>
<a name="ln1641">          const std::vector&lt;OBAtom*&gt; &amp;atoms = inverted[i].invertedAtoms;</a>
<a name="ln1642">          if (atoms.size() != 1)</a>
<a name="ln1643">            continue;</a>
<a name="ln1644">          const std::vector&lt;OBBond*&gt; &amp;bonds = inverted[i].invertedBonds;</a>
<a name="ln1645">          if (bonds.size())</a>
<a name="ln1646">            continue;</a>
<a name="ln1647">          if (atoms[0] == atom) {</a>
<a name="ln1648">            foundPermutation = true;</a>
<a name="ln1649">            break;</a>
<a name="ln1650">          }</a>
<a name="ln1651">        }</a>
<a name="ln1652"> </a>
<a name="ln1653">        int classification = classifyTetrahedralNbrSymClasses(symClasses, atom);</a>
<a name="ln1654"> </a>
<a name="ln1655">        if (DEBUG_INVERSIONS)</a>
<a name="ln1656">          cout &lt;&lt; &quot;foundPermutation for id = &quot; &lt;&lt; atom-&gt;GetId() &lt;&lt; &quot;: &quot; &lt;&lt; foundPermutation &lt;&lt; endl;</a>
<a name="ln1657"> </a>
<a name="ln1658">        if (!foundPermutation) {</a>
<a name="ln1659">          // true-stereocenter found</a>
<a name="ln1660">          bool isParaCenter = (classification == T1234) ? false : true;</a>
<a name="ln1661">          //cout &lt;&lt; &quot;found(2) &quot; &lt;&lt; atom-&gt;GetId() &lt;&lt; endl;</a>
<a name="ln1662">          units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), isParaCenter));</a>
<a name="ln1663">          doneAtoms.push_back(atom-&gt;GetId());</a>
<a name="ln1664">        } else {</a>
<a name="ln1665">          // count ligand configurations:</a>
<a name="ln1666">          // If there exists at least one automorphic permutation causing the inversion of the</a>
<a name="ln1667">          // configuration of only the stereogenic unit under consideration, then the potential</a>
<a name="ln1668">          // stereocenter can be a stereocenter if the number of topologically equivalent neighbors</a>
<a name="ln1669">          // (ligands) of potential stereogenic is less than or equal to the number of configurations</a>
<a name="ln1670">          // of these ligands.</a>
<a name="ln1671">          //</a>
<a name="ln1672">          // In practise:</a>
<a name="ln1673">          //    T1123 -&gt; 1 true stereocenter OR 2 para stereocenters</a>
<a name="ln1674">          //    T1122 -&gt; 1 true stereocenter OR 2 para stereocenters (for both)</a>
<a name="ln1675">          //    T1112 -&gt; 2 true stereocenters OR 2 para stereocenter assemblies</a>
<a name="ln1676">          //    T1111 -&gt; 2 true stereocenters OR 2 para stereocenter assemblies</a>
<a name="ln1677">          switch (classification) {</a>
<a name="ln1678">            case T1123:</a>
<a name="ln1679">              {</a>
<a name="ln1680">                unsigned int duplicatedSymClass = findDuplicatedSymmetryClass(atom, symClasses);</a>
<a name="ln1681">                OBAtom *ligandAtom = findAtomWithSymmetryClass(atom, duplicatedSymClass, symClasses);</a>
<a name="ln1682">                if (containsAtLeast_1true_2para(ligandAtom, atom, units)) {</a>
<a name="ln1683">                  units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1684">                  doneAtoms.push_back(atom-&gt;GetId());</a>
<a name="ln1685">                }</a>
<a name="ln1686">              }</a>
<a name="ln1687">              break;</a>
<a name="ln1688">            case T1122:</a>
<a name="ln1689">              {</a>
<a name="ln1690">                unsigned int duplicatedSymClass1, duplicatedSymClass2;</a>
<a name="ln1691">                findDuplicatedSymmetryClasses(atom, symClasses, duplicatedSymClass1, duplicatedSymClass2);</a>
<a name="ln1692">                OBAtom *ligandAtom1 = findAtomWithSymmetryClass(atom, duplicatedSymClass1, symClasses);</a>
<a name="ln1693">                OBAtom *ligandAtom2 = findAtomWithSymmetryClass(atom, duplicatedSymClass2, symClasses);</a>
<a name="ln1694">                if (containsAtLeast_1true_2para(ligandAtom1, atom, units) &amp;&amp;</a>
<a name="ln1695">                    containsAtLeast_1true_2para(ligandAtom2, atom, units)) {</a>
<a name="ln1696">                  units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1697">                  doneAtoms.push_back(atom-&gt;GetId());</a>
<a name="ln1698">                }</a>
<a name="ln1699">              }</a>
<a name="ln1700">              break;</a>
<a name="ln1701">            case T1112:</a>
<a name="ln1702">            case T1111:</a>
<a name="ln1703">              {</a>
<a name="ln1704">                unsigned int duplicatedSymClass = findDuplicatedSymmetryClass(atom, symClasses);</a>
<a name="ln1705">                OBAtom *ligandAtom = findAtomWithSymmetryClass(atom, duplicatedSymClass, symClasses);</a>
<a name="ln1706">                if (containsAtLeast_2true_2paraAssemblies(ligandAtom, atom, units, mergedRings)) {</a>
<a name="ln1707">                  units.push_back(OBStereoUnit(OBStereo::Tetrahedral, atom-&gt;GetId(), true));</a>
<a name="ln1708">                  doneAtoms.push_back(atom-&gt;GetId());</a>
<a name="ln1709">                }</a>
<a name="ln1710">              }</a>
<a name="ln1711">              break;</a>
<a name="ln1712">          }</a>
<a name="ln1713">        }</a>
<a name="ln1714">      }</a>
<a name="ln1715"> </a>
<a name="ln1716">      std::vector&lt;OBBond*&gt;::iterator ib;</a>
<a name="ln1717">      for (OBBond *bond = mol-&gt;BeginBond(ib); bond; bond = mol-&gt;NextBond(ib)) {</a>
<a name="ln1718">        if (std::find(doneBonds.begin(), doneBonds.end(), bond-&gt;GetId()) != doneBonds.end())</a>
<a name="ln1719">          continue;</a>
<a name="ln1720">        if (!isPotentialCisTrans(bond))</a>
<a name="ln1721">          continue;</a>
<a name="ln1722"> </a>
<a name="ln1723">        // A double bond is a stereogenic bond if there exists no automorphic</a>
<a name="ln1724">        // permutation causing an inversion of the configuration of only the potential</a>
<a name="ln1725">        // stereogenic unit under consideration.</a>
<a name="ln1726">        bool foundPermutation = false; // invert __only__ configuration of atom</a>
<a name="ln1727">        for (std::size_t i = 0; i &lt; inverted.size(); ++i) {</a>
<a name="ln1728">          const std::vector&lt;OBAtom*&gt; &amp;atoms = inverted[i].invertedAtoms;</a>
<a name="ln1729">          // if any atoms are inverted, the bond can't be the only inverted stereocenter</a>
<a name="ln1730">          if (atoms.size())</a>
<a name="ln1731">            continue;</a>
<a name="ln1732">          const std::vector&lt;OBBond*&gt; &amp;bonds = inverted[i].invertedBonds;</a>
<a name="ln1733">          // the bond should be the only inverted stereocenter</a>
<a name="ln1734">          if (bonds.size() != 1)</a>
<a name="ln1735">            continue;</a>
<a name="ln1736">          // check if it is this bond</a>
<a name="ln1737">          if (bonds[0] == bond) {</a>
<a name="ln1738">            foundPermutation = true;</a>
<a name="ln1739">            break;</a>
<a name="ln1740">          }</a>
<a name="ln1741">        }</a>
<a name="ln1742"> </a>
<a name="ln1743">        int beginClassification = classifyCisTransNbrSymClasses(symClasses, bond, bond-&gt;GetBeginAtom());</a>
<a name="ln1744">        int endClassification = classifyCisTransNbrSymClasses(symClasses, bond, bond-&gt;GetEndAtom());</a>
<a name="ln1745"> </a>
<a name="ln1746">        if (!foundPermutation) {</a>
<a name="ln1747">          // true-stereocenter found</a>
<a name="ln1748">          bool isParaCenter = (beginClassification == C12) &amp;&amp; (endClassification == C12) ? false : true;</a>
<a name="ln1749">          units.push_back(OBStereoUnit(OBStereo::CisTrans, bond-&gt;GetId(), isParaCenter));</a>
<a name="ln1750">          doneBonds.push_back(bond-&gt;GetId());</a>
<a name="ln1751">        } else {</a>
<a name="ln1752">          // count ligand configurations:</a>
<a name="ln1753">          bool beginValid = false;</a>
<a name="ln1754">          switch (beginClassification) {</a>
<a name="ln1755">            case C12:</a>
<a name="ln1756">              beginValid = true;</a>
<a name="ln1757">              break;</a>
<a name="ln1758">            case C11:</a>
<a name="ln1759">              {</a>
<a name="ln1760">                // find the ligand</a>
<a name="ln1761">                OBAtom *ligandAtom = nullptr;</a>
<a name="ln1762">                FOR_NBORS_OF_ATOM (nbr, bond-&gt;GetBeginAtom()) {</a>
<a name="ln1763">                  if ((nbr-&gt;GetIdx() != bond-&gt;GetBeginAtomIdx()) &amp;&amp; (nbr-&gt;GetIdx() != bond-&gt;GetEndAtomIdx())) {</a>
<a name="ln1764">                    ligandAtom = &amp;*nbr;</a>
<a name="ln1765">                    break;</a>
<a name="ln1766">                  }</a>
<a name="ln1767">                }</a>
<a name="ln1768">                if (ligandAtom)</a>
<a name="ln1769">                  beginValid = containsAtLeast_1true_1para(ligandAtom, bond-&gt;GetBeginAtom(), units);</a>
<a name="ln1770">              }</a>
<a name="ln1771">              break;</a>
<a name="ln1772">          }</a>
<a name="ln1773"> </a>
<a name="ln1774">          if (!beginValid)</a>
<a name="ln1775">            continue;</a>
<a name="ln1776"> </a>
<a name="ln1777">          bool endValid = false;</a>
<a name="ln1778">          switch (endClassification) {</a>
<a name="ln1779">            case C12:</a>
<a name="ln1780">              endValid = true;</a>
<a name="ln1781">              break;</a>
<a name="ln1782">            case C11:</a>
<a name="ln1783">              {</a>
<a name="ln1784">                // find the ligand</a>
<a name="ln1785">                OBAtom *ligandAtom = nullptr;</a>
<a name="ln1786">                FOR_NBORS_OF_ATOM (nbr, bond-&gt;GetEndAtom()) {</a>
<a name="ln1787">                  if ((nbr-&gt;GetIdx() != bond-&gt;GetBeginAtomIdx()) &amp;&amp; (nbr-&gt;GetIdx() != bond-&gt;GetEndAtomIdx())) {</a>
<a name="ln1788">                    ligandAtom = &amp;*nbr;</a>
<a name="ln1789">                    break;</a>
<a name="ln1790">                  }</a>
<a name="ln1791">                }</a>
<a name="ln1792">                if (ligandAtom)</a>
<a name="ln1793">                  endValid = containsAtLeast_1true_1para(ligandAtom, bond-&gt;GetEndAtom(), units);</a>
<a name="ln1794">              }</a>
<a name="ln1795">              break;</a>
<a name="ln1796">          }</a>
<a name="ln1797"> </a>
<a name="ln1798">          if (endValid) {</a>
<a name="ln1799">            units.push_back(OBStereoUnit(OBStereo::CisTrans, bond-&gt;GetId(), true));</a>
<a name="ln1800">            doneBonds.push_back(bond-&gt;GetId());</a>
<a name="ln1801">          }</a>
<a name="ln1802">        }</a>
<a name="ln1803">      }</a>
<a name="ln1804"> </a>
<a name="ln1805"> </a>
<a name="ln1806">      if (units.size() == lastSize)</a>
<a name="ln1807">        break;</a>
<a name="ln1808">      lastSize = units.size();</a>
<a name="ln1809">    }</a>
<a name="ln1810"> </a>
<a name="ln1811">    if (DEBUG) {</a>
<a name="ln1812">      for (OBStereoUnitSet::iterator unit = units.begin(); unit != units.end(); ++unit) {</a>
<a name="ln1813">        if (unit-&gt;type == OBStereo::Tetrahedral)</a>
<a name="ln1814">          cout &lt;&lt; &quot;Tetrahedral(center = &quot; &lt;&lt; unit-&gt;id &lt;&lt; &quot;, para = &quot; &lt;&lt; unit-&gt;para &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1815">        if (unit-&gt;type == OBStereo::CisTrans)</a>
<a name="ln1816">          cout &lt;&lt; &quot;CisTrans(bond = &quot; &lt;&lt; unit-&gt;id &lt;&lt; &quot;, para = &quot; &lt;&lt; unit-&gt;para &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1817">        if (unit-&gt;type == OBStereo::SquarePlanar)</a>
<a name="ln1818">          cout &lt;&lt; &quot;SquarePlanar(bond = &quot; &lt;&lt; unit-&gt;id &lt;&lt; &quot;, para = &quot; &lt;&lt; unit-&gt;para &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln1819">      }</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    return units;</a>
<a name="ln1823">  } // FindStereogenicUnits using automorphisms</a>
<a name="ln1824"> </a>
<a name="ln1825"> </a>
<a name="ln1826">  /**</a>
<a name="ln1827">   * Perform symmetry analysis.</a>
<a name="ln1828">   *</a>
<a name="ln1829">   * @return vector containing symmetry classes index by OBAtom::GetIndex().</a>
<a name="ln1830">   */</a>
<a name="ln1831">  std::vector&lt;unsigned int&gt; FindSymmetry(OBMol *mol)</a>
<a name="ln1832">  {</a>
<a name="ln1833">    OBGraphSym symmetry(mol);</a>
<a name="ln1834">    std::vector&lt;unsigned int&gt; symClasses;</a>
<a name="ln1835">    symmetry.GetSymmetry(symClasses);</a>
<a name="ln1836">    return symClasses;</a>
<a name="ln1837">  }</a>
<a name="ln1838"> </a>
<a name="ln1839">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1840">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1841">  //</a>
<a name="ln1842">  //</a>
<a name="ln1843">  //  From0D</a>
<a name="ln1844">  //</a>
<a name="ln1845">  //</a>
<a name="ln1846">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1847">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1848"> </a>
<a name="ln1849">  void StereoFrom0D(OBMol *mol)</a>
<a name="ln1850">  {</a>
<a name="ln1851">    if (mol-&gt;HasChiralityPerceived())</a>
<a name="ln1852">      return;</a>
<a name="ln1853"> </a>
<a name="ln1854">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::StereoFrom0D&quot;, obAuditMsg);</a>
<a name="ln1855"> </a>
<a name="ln1856">    std::vector&lt;unsigned int&gt; symmetry_classes = FindSymmetry(mol);</a>
<a name="ln1857">    OBStereoUnitSet stereogenicUnits = FindStereogenicUnits(mol, symmetry_classes);</a>
<a name="ln1858"> </a>
<a name="ln1859">    TetrahedralFrom0D(mol, stereogenicUnits);</a>
<a name="ln1860">    CisTransFrom0D(mol, stereogenicUnits);</a>
<a name="ln1861">    mol-&gt;SetChiralityPerceived();</a>
<a name="ln1862">  }</a>
<a name="ln1863"> </a>
<a name="ln1864">  std::vector&lt;OBTetrahedralStereo*&gt; TetrahedralFrom0D(OBMol *mol,</a>
<a name="ln1865">      const OBStereoUnitSet &amp;stereoUnits, bool addToMol)</a>
<a name="ln1866">  {</a>
<a name="ln1867">    std::vector&lt;OBTetrahedralStereo*&gt; configs;</a>
<a name="ln1868">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::TetrahedralFrom0D&quot;, obAuditMsg);</a>
<a name="ln1869"> </a>
<a name="ln1870">    // Delete any existing stereo objects that are not a member of 'centers'</a>
<a name="ln1871">    // and make a map of the remaining ones</a>
<a name="ln1872">    std::map&lt;unsigned long, OBTetrahedralStereo*&gt; existingMap;</a>
<a name="ln1873">    std::vector&lt;OBGenericData*&gt;::iterator data;</a>
<a name="ln1874">    std::vector&lt;OBGenericData*&gt; stereoData = mol-&gt;GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln1875">    for (data = stereoData.begin(); data != stereoData.end(); ++data) {</a>
<a name="ln1876">      if (static_cast&lt;OBStereoBase*&gt;(*data)-&gt;GetType() == OBStereo::Tetrahedral) {</a>
<a name="ln1877">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln1878">        unsigned long center = ts-&gt;GetConfig().center;</a>
<a name="ln1879">        // check if the center is really stereogenic</a>
<a name="ln1880">        bool isStereogenic = false;</a>
<a name="ln1881">        OBStereoUnitSet::const_iterator u;</a>
<a name="ln1882">        for (u = stereoUnits.begin(); u != stereoUnits.end(); ++u) {</a>
<a name="ln1883">          if ((*u).type == OBStereo::Tetrahedral)</a>
<a name="ln1884">            if ((*u).id == center)</a>
<a name="ln1885">              isStereogenic = true;</a>
<a name="ln1886">        }</a>
<a name="ln1887"> </a>
<a name="ln1888">        if (isStereogenic) {</a>
<a name="ln1889">          existingMap[center] = ts;</a>
<a name="ln1890">          configs.push_back(ts);</a>
<a name="ln1891">        } else {</a>
<a name="ln1892">          // According to OpenBabel, this is not a tetrahedral stereo</a>
<a name="ln1893">          obErrorLog.ThrowError(__FUNCTION__, &quot;Removed spurious TetrahedralStereo object&quot;, obAuditMsg);</a>
<a name="ln1894">          mol-&gt;DeleteData(ts);</a>
<a name="ln1895">        }</a>
<a name="ln1896">      }</a>
<a name="ln1897">    }</a>
<a name="ln1898"> </a>
<a name="ln1899">    OBStereoUnitSet::const_iterator u;</a>
<a name="ln1900">    for (u = stereoUnits.begin(); u != stereoUnits.end(); ++u) {</a>
<a name="ln1901">      // skip non-tetrahedral units</a>
<a name="ln1902">      if ((*u).type != OBStereo::Tetrahedral)</a>
<a name="ln1903">        continue;</a>
<a name="ln1904">      // if there already exists a OBTetrahedralStereo object for this</a>
<a name="ln1905">      // center, continue</a>
<a name="ln1906">      if (existingMap.find((*u).id) != existingMap.end())</a>
<a name="ln1907">        continue;</a>
<a name="ln1908"> </a>
<a name="ln1909">      OBAtom *center = mol-&gt;GetAtomById((*u).id);</a>
<a name="ln1910"> </a>
<a name="ln1911">      OBTetrahedralStereo::Config config;</a>
<a name="ln1912">      config.specified = false;</a>
<a name="ln1913">      config.center = (*u).id;</a>
<a name="ln1914">      FOR_NBORS_OF_ATOM(nbr, center) {</a>
<a name="ln1915">        if (config.from == OBStereo::NoRef)</a>
<a name="ln1916">          config.from = nbr-&gt;GetId();</a>
<a name="ln1917">        else</a>
<a name="ln1918">          config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln1919">      }</a>
<a name="ln1920"> </a>
<a name="ln1921">      if ((config.refs.size() == 2))</a>
<a name="ln1922">        config.refs.push_back(OBStereo::ImplicitRef); // need to add largest number on end to work</a>
<a name="ln1923"> </a>
<a name="ln1924">      OBTetrahedralStereo *th = new OBTetrahedralStereo(mol);</a>
<a name="ln1925">      th-&gt;SetConfig(config);</a>
<a name="ln1926"> </a>
<a name="ln1927">      configs.push_back(th);</a>
<a name="ln1928">      // add the data to the molecule if needed</a>
<a name="ln1929">      if (addToMol)</a>
<a name="ln1930">        mol-&gt;SetData(th);</a>
<a name="ln1931">    }</a>
<a name="ln1932"> </a>
<a name="ln1933">    return configs;</a>
<a name="ln1934">  }</a>
<a name="ln1935"> </a>
<a name="ln1936">  std::vector&lt;OBCisTransStereo*&gt; CisTransFrom0D(OBMol *mol,</a>
<a name="ln1937">      const OBStereoUnitSet &amp;stereoUnits,</a>
<a name="ln1938">      bool addToMol)</a>
<a name="ln1939">  {</a>
<a name="ln1940">    std::vector&lt;OBCisTransStereo*&gt; configs;</a>
<a name="ln1941">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::CisTransFrom0D&quot;, obAuditMsg);</a>
<a name="ln1942"> </a>
<a name="ln1943">    std::vector&lt;unsigned long&gt; bonds;</a>
<a name="ln1944">    for (OBStereoUnitSet::const_iterator u = stereoUnits.begin(); u != stereoUnits.end(); ++u)</a>
<a name="ln1945">      if ((*u).type == OBStereo::CisTrans)</a>
<a name="ln1946">        bonds.push_back((*u).id);</a>
<a name="ln1947"> </a>
<a name="ln1948">    // Delete any existing stereo objects that are not a member of 'bonds'</a>
<a name="ln1949">    // and make a map of the remaining ones</a>
<a name="ln1950">    std::map&lt;unsigned long, OBCisTransStereo*&gt; existingMap;</a>
<a name="ln1951">    std::vector&lt;OBGenericData*&gt;::iterator data;</a>
<a name="ln1952">    std::vector&lt;OBGenericData*&gt; stereoData = mol-&gt;GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln1953">    for (data = stereoData.begin(); data != stereoData.end(); ++data) {</a>
<a name="ln1954">      if (static_cast&lt;OBStereoBase*&gt;(*data)-&gt;GetType() == OBStereo::CisTrans) {</a>
<a name="ln1955">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln1956">        OBCisTransStereo::Config config = ct-&gt;GetConfig();</a>
<a name="ln1957">        // find the bond id from begin &amp; end atom ids</a>
<a name="ln1958">        unsigned long id = OBStereo::NoRef;</a>
<a name="ln1959">        OBAtom *a = mol-&gt;GetAtomById(config.begin);</a>
<a name="ln1960">        if (!a)</a>
<a name="ln1961">          continue;</a>
<a name="ln1962">        FOR_BONDS_OF_ATOM (bond, a) {</a>
<a name="ln1963">          unsigned long beginId = bond-&gt;GetBeginAtom()-&gt;GetId();</a>
<a name="ln1964">          unsigned long endId = bond-&gt;GetEndAtom()-&gt;GetId();</a>
<a name="ln1965">          if ((beginId == config.begin &amp;&amp; endId == config.end) ||</a>
<a name="ln1966">              (beginId == config.end &amp;&amp; endId == config.begin)) {</a>
<a name="ln1967">            id = bond-&gt;GetId();</a>
<a name="ln1968">            break;</a>
<a name="ln1969">          }</a>
<a name="ln1970">        }</a>
<a name="ln1971"> </a>
<a name="ln1972">        if (std::find(bonds.begin(), bonds.end(), id) == bonds.end()) {</a>
<a name="ln1973">          // According to OpenBabel, this is not a cis trans stereo</a>
<a name="ln1974">          obErrorLog.ThrowError(__FUNCTION__, &quot;Removed spurious CisTransStereo object&quot;, obAuditMsg);</a>
<a name="ln1975">          mol-&gt;DeleteData(ct);</a>
<a name="ln1976">        }</a>
<a name="ln1977">        else {</a>
<a name="ln1978">          existingMap[id] = ct;</a>
<a name="ln1979">          configs.push_back(ct);</a>
<a name="ln1980">        }</a>
<a name="ln1981">      }</a>
<a name="ln1982">    }</a>
<a name="ln1983"> </a>
<a name="ln1984">    std::vector&lt;unsigned long&gt;::iterator i;</a>
<a name="ln1985">    for (i = bonds.begin(); i != bonds.end(); ++i) {</a>
<a name="ln1986">      // If there already exists a OBCisTransStereo object for this</a>
<a name="ln1987">      // bond, leave it alone unless it's in a ring of small size</a>
<a name="ln1988"> </a>
<a name="ln1989">      bool alreadyExists = (existingMap.find(*i) != existingMap.end());</a>
<a name="ln1990">      OBBond *bond = mol-&gt;GetBondById(*i);</a>
<a name="ln1991"> </a>
<a name="ln1992">      OBCisTransStereo *ct;</a>
<a name="ln1993">      OBCisTransStereo::Config config;</a>
<a name="ln1994">      if (alreadyExists)</a>
<a name="ln1995">      {</a>
<a name="ln1996">        ct = existingMap[*i];</a>
<a name="ln1997">        config = ct-&gt;GetConfig();</a>
<a name="ln1998">      }</a>
<a name="ln1999">      else</a>
<a name="ln2000">      {</a>
<a name="ln2001">        OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln2002">        OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln2003"> </a>
<a name="ln2004">        config.specified = false;</a>
<a name="ln2005">        // begin</a>
<a name="ln2006">        config.begin = begin-&gt;GetId();</a>
<a name="ln2007">        FOR_NBORS_OF_ATOM (nbr, begin) {</a>
<a name="ln2008">          if (nbr-&gt;GetId() == end-&gt;GetId())</a>
<a name="ln2009">            continue;</a>
<a name="ln2010">          config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2011">        }</a>
<a name="ln2012">        if (config.refs.size() == 1) {</a>
<a name="ln2013">          config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2014">        }</a>
<a name="ln2015">        // end</a>
<a name="ln2016">        config.end = end-&gt;GetId();</a>
<a name="ln2017">        FOR_NBORS_OF_ATOM (nbr, end) {</a>
<a name="ln2018">          if (nbr-&gt;GetId() == begin-&gt;GetId())</a>
<a name="ln2019">            continue;</a>
<a name="ln2020">          config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2021">        }</a>
<a name="ln2022">        if (config.refs.size() == 3) {</a>
<a name="ln2023">          config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2024">        }</a>
<a name="ln2025"> </a>
<a name="ln2026">        ct = new OBCisTransStereo(mol);</a>
<a name="ln2027">        ct-&gt;SetConfig(config);</a>
<a name="ln2028">      }</a>
<a name="ln2029"> </a>
<a name="ln2030">      // For a double bond in a ring of size IMPLICIT_CIS_RING_SIZE or less</a>
<a name="ln2031">      // the stereochemistry is implicitly cis (in terms</a>
<a name="ln2032">      // of the ring atoms)</a>
<a name="ln2033">      OBRing* ring = bond-&gt;FindSmallestRing();</a>
<a name="ln2034">      if (ring &amp;&amp; ring-&gt;Size() &lt;= IMPLICIT_CIS_RING_SIZE) {</a>
<a name="ln2035"> </a>
<a name="ln2036">        // Find the ring atoms in the config.refs</a>
<a name="ln2037">        vector&lt;unsigned int&gt; ringrefs(2);</a>
<a name="ln2038">        for (int i = 0; i&lt;2; ++i) {</a>
<a name="ln2039">          if (config.refs[i*2] != OBStereo::ImplicitRef &amp;&amp; ring-&gt;IsMember(mol-&gt;GetAtomById(config.refs[i*2])))</a>
<a name="ln2040">            ringrefs[i] = config.refs[i*2];</a>
<a name="ln2041">          else</a>
<a name="ln2042">            ringrefs[i] = config.refs[i*2 + 1];</a>
<a name="ln2043">        }</a>
<a name="ln2044">        if (!ct-&gt;IsCis(ringrefs[0], ringrefs[1])) // Need to invert the stereo</a>
<a name="ln2045">          config.shape = OBStereo::ShapeZ;</a>
<a name="ln2046"> </a>
<a name="ln2047">        config.specified = true;</a>
<a name="ln2048">        ct-&gt;SetConfig(config);</a>
<a name="ln2049">      }</a>
<a name="ln2050"> </a>
<a name="ln2051">      configs.push_back(ct);</a>
<a name="ln2052">      // add the data to the molecule if needed</a>
<a name="ln2053">      if (addToMol &amp;&amp; !alreadyExists)</a>
<a name="ln2054">        mol-&gt;SetData(ct);</a>
<a name="ln2055"> </a>
<a name="ln2056">    }</a>
<a name="ln2057"> </a>
<a name="ln2058">    return configs;</a>
<a name="ln2059">  }</a>
<a name="ln2060"> </a>
<a name="ln2061">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2062">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2063">  //</a>
<a name="ln2064">  //</a>
<a name="ln2065">  //  From3D</a>
<a name="ln2066">  //</a>
<a name="ln2067">  //</a>
<a name="ln2068">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2069">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2070"> </a>
<a name="ln2071">  void StereoFrom3D(OBMol *mol, bool force)</a>
<a name="ln2072">  {</a>
<a name="ln2073">    if (mol-&gt;HasChiralityPerceived() &amp;&amp; !force)</a>
<a name="ln2074">      return;</a>
<a name="ln2075"> </a>
<a name="ln2076">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::StereoFrom3D&quot;, obAuditMsg);</a>
<a name="ln2077"> </a>
<a name="ln2078">    std::vector&lt;unsigned int&gt; symmetry_classes = FindSymmetry(mol);</a>
<a name="ln2079">    OBStereoUnitSet stereogenicUnits = FindStereogenicUnits(mol, symmetry_classes);</a>
<a name="ln2080"> </a>
<a name="ln2081">    mol-&gt;DeleteData(OBGenericDataType::StereoData);</a>
<a name="ln2082">    TetrahedralFrom3D(mol, stereogenicUnits);</a>
<a name="ln2083">    CisTransFrom3D(mol, stereogenicUnits);</a>
<a name="ln2084">    mol-&gt;SetChiralityPerceived();</a>
<a name="ln2085">  }</a>
<a name="ln2086"> </a>
<a name="ln2087">  //! Calculate the &quot;sign of a volume&quot; given by a set of 4 coordinates</a>
<a name="ln2088">  double VolumeSign(const vector3 &amp;a, const vector3 &amp;b, const vector3 &amp;c, const vector3 &amp;d)</a>
<a name="ln2089">  {</a>
<a name="ln2090">    vector3 A, B, C;</a>
<a name="ln2091">    A = b - a;</a>
<a name="ln2092">    B = c - a;</a>
<a name="ln2093">    C = d - a;</a>
<a name="ln2094">    matrix3x3 m(A, B, C);</a>
<a name="ln2095">    return m.determinant();</a>
<a name="ln2096">  }</a>
<a name="ln2097"> </a>
<a name="ln2098">  std::vector&lt;OBTetrahedralStereo*&gt; TetrahedralFrom3D(OBMol *mol,</a>
<a name="ln2099">      const OBStereoUnitSet &amp;stereoUnits, bool addToMol)</a>
<a name="ln2100">  {</a>
<a name="ln2101">    std::vector&lt;OBTetrahedralStereo*&gt; configs;</a>
<a name="ln2102">    OBUnitCell *uc = (OBUnitCell*)mol-&gt;GetData(OBGenericDataType::UnitCell);</a>
<a name="ln2103">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::TetrahedralFrom3D&quot;, obAuditMsg);</a>
<a name="ln2104"> </a>
<a name="ln2105">    // find all tetrahedral centers</a>
<a name="ln2106">    std::vector&lt;unsigned long&gt; centers;</a>
<a name="ln2107">    for (OBStereoUnitSet::const_iterator u = stereoUnits.begin(); u != stereoUnits.end(); ++u)</a>
<a name="ln2108">      if ((*u).type == OBStereo::Tetrahedral)</a>
<a name="ln2109">        centers.push_back((*u).id);</a>
<a name="ln2110"> </a>
<a name="ln2111">    std::vector&lt;unsigned long&gt;::iterator i;</a>
<a name="ln2112">    for (i = centers.begin(); i != centers.end(); ++i) {</a>
<a name="ln2113">      OBAtom *center = mol-&gt;GetAtomById(*i);</a>
<a name="ln2114"> </a>
<a name="ln2115">      // make sure we have at least 3 heavy atom neighbors</a>
<a name="ln2116">      // timvdm 28 Jun 2009: This is already checked in FindStereogenicUnits</a>
<a name="ln2117">      if (center-&gt;GetHvyDegree() &lt; 3) {</a>
<a name="ln2118">        std::stringstream errorMsg;</a>
<a name="ln2119">        errorMsg &lt;&lt; &quot;Cannot calculate a signed volume for an atom with a heavy atom valence of &quot;</a>
<a name="ln2120">                 &lt;&lt; center-&gt;GetHvyDegree() &lt;&lt; std::endl;</a>
<a name="ln2121">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obInfo);</a>
<a name="ln2122">        continue;</a>
<a name="ln2123">      }</a>
<a name="ln2124"> </a>
<a name="ln2125">      OBTetrahedralStereo::Config config;</a>
<a name="ln2126">      config.center = *i;</a>
<a name="ln2127">      FOR_NBORS_OF_ATOM(nbr, center) {</a>
<a name="ln2128">        if (config.from == OBStereo::NoRef)</a>
<a name="ln2129">          config.from = nbr-&gt;GetId();</a>
<a name="ln2130">        else</a>
<a name="ln2131">          config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2132">      }</a>
<a name="ln2133"> </a>
<a name="ln2134">      bool use_central_atom = false;</a>
<a name="ln2135"> </a>
<a name="ln2136">      // Create a vector with the coordinates of the neighbor atoms</a>
<a name="ln2137">      // and check for a bond that indicates unspecified stereochemistry</a>
<a name="ln2138">      std::vector&lt;vector3&gt; nbrCoords;</a>
<a name="ln2139">      OBAtom *from = mol-&gt;GetAtomById(config.from);</a>
<a name="ln2140">      OBBond *bond = mol-&gt;GetBond(from, center);</a>
<a name="ln2141">      if (bond-&gt;IsWedgeOrHash() &amp;&amp; bond-&gt;GetBeginAtom()==center)</a>
<a name="ln2142">        config.specified = false;</a>
<a name="ln2143"> </a>
<a name="ln2144">      vector3 center_coord = center-&gt;GetVector();</a>
<a name="ln2145"> </a>
<a name="ln2146">      if (uc)</a>
<a name="ln2147">        nbrCoords.push_back(uc-&gt;UnwrapCartesianNear(from-&gt;GetVector(), center_coord));</a>
<a name="ln2148">      else</a>
<a name="ln2149">        nbrCoords.push_back(from-&gt;GetVector());</a>
<a name="ln2150">      for (OBStereo::RefIter id = config.refs.begin(); id != config.refs.end(); ++id) {</a>
<a name="ln2151">        OBAtom *nbr = mol-&gt;GetAtomById(*id);</a>
<a name="ln2152">        if (uc)</a>
<a name="ln2153">          nbrCoords.push_back(uc-&gt;UnwrapCartesianNear(nbr-&gt;GetVector(), center_coord));</a>
<a name="ln2154">        else</a>
<a name="ln2155">          nbrCoords.push_back(nbr-&gt;GetVector());</a>
<a name="ln2156">        OBBond *bond = mol-&gt;GetBond(nbr, center);</a>
<a name="ln2157">        if (bond-&gt;IsWedgeOrHash() &amp;&amp; bond-&gt;GetBeginAtom()==center)</a>
<a name="ln2158">          config.specified = false;</a>
<a name="ln2159">      }</a>
<a name="ln2160"> </a>
<a name="ln2161">        // Checks for a neighbour having 0 co-ords (added hydrogen etc)</a>
<a name="ln2162">        /* FIXME: needed? if the molecule has 3D coords, additional</a>
<a name="ln2163">         * hydrogens will get coords using OBAtom::GetNewBondVector</a>
<a name="ln2164">        for (std::vector&lt;vector3&gt;::iterator coord = nbrCoords.begin(); coord != nbrCoords.end(); ++coord) {</a>
<a name="ln2165">          // are the coordinates zero to 6 or more significant figures</a>
<a name="ln2166">          if (coord-&gt;IsApprox(VZero, 1.0e-6)) {</a>
<a name="ln2167">            if (!use_central_atom) {</a>
<a name="ln2168">              use_central_atom = true;</a>
<a name="ln2169">            } else {</a>
<a name="ln2170">              obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2171">                  &quot;More than 2 neighbours have 0 co-ords when attempting 3D chiral calculation&quot;, obInfo);</a>
<a name="ln2172">            }</a>
<a name="ln2173">          }</a>
<a name="ln2174">        }</a>
<a name="ln2175">        */</a>
<a name="ln2176"> </a>
<a name="ln2177">      // If we have three heavy atoms we can use the chiral center atom itself for the fourth</a>
<a name="ln2178">      // will always give same sign (for tetrahedron), magnitude will be smaller.</a>
<a name="ln2179">      if ((config.refs.size() == 2) || use_central_atom) {</a>
<a name="ln2180">        nbrCoords.push_back(center_coord);</a>
<a name="ln2181">        config.refs.push_back(OBStereo::ImplicitRef); // need to add largest number on end to work</a>
<a name="ln2182">      }</a>
<a name="ln2183"> </a>
<a name="ln2184">      double sign = VolumeSign(nbrCoords[0], nbrCoords[1], nbrCoords[2], nbrCoords[3]);</a>
<a name="ln2185">      if (sign &lt; 0.0)</a>
<a name="ln2186">        config.winding = OBStereo::AntiClockwise;</a>
<a name="ln2187"> </a>
<a name="ln2188">      OBTetrahedralStereo *th = new OBTetrahedralStereo(mol);</a>
<a name="ln2189">      th-&gt;SetConfig(config);</a>
<a name="ln2190"> </a>
<a name="ln2191">      configs.push_back(th);</a>
<a name="ln2192">      // add the data to the molecule if needed</a>
<a name="ln2193">      if (addToMol)</a>
<a name="ln2194">        mol-&gt;SetData(th);</a>
<a name="ln2195">    }</a>
<a name="ln2196"> </a>
<a name="ln2197">    return configs;</a>
<a name="ln2198">  }</a>
<a name="ln2199"> </a>
<a name="ln2200">  std::vector&lt;OBCisTransStereo*&gt; CisTransFrom3D(OBMol *mol,</a>
<a name="ln2201">      const OBStereoUnitSet &amp;stereoUnits, bool addToMol)</a>
<a name="ln2202">  {</a>
<a name="ln2203">    std::vector&lt;OBCisTransStereo*&gt; configs;</a>
<a name="ln2204">    OBUnitCell *uc = (OBUnitCell*)mol-&gt;GetData(OBGenericDataType::UnitCell);</a>
<a name="ln2205">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::CisTransFrom3D&quot;, obAuditMsg);</a>
<a name="ln2206"> </a>
<a name="ln2207">    // find all cis/trans bonds</a>
<a name="ln2208">    std::vector&lt;unsigned long&gt; bonds;</a>
<a name="ln2209">    for (OBStereoUnitSet::const_iterator u = stereoUnits.begin(); u != stereoUnits.end(); ++u)</a>
<a name="ln2210">      if ((*u).type == OBStereo::CisTrans)</a>
<a name="ln2211">        bonds.push_back((*u).id);</a>
<a name="ln2212"> </a>
<a name="ln2213">    std::vector&lt;unsigned long&gt;::iterator i;</a>
<a name="ln2214">    for (i = bonds.begin(); i != bonds.end(); ++i) {</a>
<a name="ln2215">      OBBond *bond = mol-&gt;GetBondById(*i);</a>
<a name="ln2216">      OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln2217">      OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln2218"> </a>
<a name="ln2219">      // Create a vector with the coordinates of the neighbor atoms</a>
<a name="ln2220">      std::vector&lt;vector3&gt; bondVecs;</a>
<a name="ln2221">      OBCisTransStereo::Config config;</a>
<a name="ln2222">      // begin</a>
<a name="ln2223">      config.begin = begin-&gt;GetId();</a>
<a name="ln2224">      FOR_NBORS_OF_ATOM (nbr, begin) {</a>
<a name="ln2225">        if (nbr-&gt;GetId() == end-&gt;GetId())</a>
<a name="ln2226">          continue;</a>
<a name="ln2227">        config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2228">        if (uc)</a>
<a name="ln2229">          bondVecs.push_back(uc-&gt;MinimumImageCartesian(nbr-&gt;GetVector() - begin-&gt;GetVector()));</a>
<a name="ln2230">        else</a>
<a name="ln2231">          bondVecs.push_back(nbr-&gt;GetVector() - begin-&gt;GetVector());</a>
<a name="ln2232">      }</a>
<a name="ln2233">      if (config.refs.size() == 1) {</a>
<a name="ln2234">        config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2235">        vector3 pos;</a>
<a name="ln2236">        begin-&gt;GetNewBondVector(pos, 1.0);</a>
<a name="ln2237">        // WARNING: GetNewBondVector code has not yet been checked, since it's part of builder.cpp</a>
<a name="ln2238">        if (uc)</a>
<a name="ln2239">          bondVecs.push_back(uc-&gt;MinimumImageCartesian(pos - begin-&gt;GetVector()));</a>
<a name="ln2240">        else</a>
<a name="ln2241">          bondVecs.push_back(pos - begin-&gt;GetVector());</a>
<a name="ln2242">      }</a>
<a name="ln2243">      // end</a>
<a name="ln2244">      config.end = end-&gt;GetId();</a>
<a name="ln2245">      vector3 end_vec = end-&gt;GetVector();</a>
<a name="ln2246">      if (uc)</a>
<a name="ln2247">        end_vec = uc-&gt;UnwrapCartesianNear(end_vec, begin-&gt;GetVector());</a>
<a name="ln2248">      FOR_NBORS_OF_ATOM (nbr, end) {</a>
<a name="ln2249">        if (nbr-&gt;GetId() == begin-&gt;GetId())</a>
<a name="ln2250">          continue;</a>
<a name="ln2251">        config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2252">        if (uc)</a>
<a name="ln2253">          bondVecs.push_back(uc-&gt;MinimumImageCartesian(nbr-&gt;GetVector() - end_vec));</a>
<a name="ln2254">        else</a>
<a name="ln2255">          bondVecs.push_back(nbr-&gt;GetVector() - end_vec);</a>
<a name="ln2256">      }</a>
<a name="ln2257">      if (config.refs.size() == 3) {</a>
<a name="ln2258">        config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2259">        vector3 pos;</a>
<a name="ln2260">        end-&gt;GetNewBondVector(pos, 1.0);</a>
<a name="ln2261">        if (uc)</a>
<a name="ln2262">          bondVecs.push_back(uc-&gt;MinimumImageCartesian(pos - end_vec));</a>
<a name="ln2263">        else</a>
<a name="ln2264">          bondVecs.push_back(pos - end_vec);</a>
<a name="ln2265">      }</a>
<a name="ln2266"> </a>
<a name="ln2267">      double tor02, tor03, tor12, tor13;</a>
<a name="ln2268">      if (uc) {</a>
<a name="ln2269">        vector3 v0 = begin-&gt;GetVector() + bondVecs[0];</a>
<a name="ln2270">        vector3 v1 = begin-&gt;GetVector() + bondVecs[1];</a>
<a name="ln2271">        vector3 v2 = end-&gt;GetVector() + bondVecs[2];</a>
<a name="ln2272">        vector3 v3 = end-&gt;GetVector() + bondVecs[3];</a>
<a name="ln2273"> </a>
<a name="ln2274">        vector3 b, c, d;</a>
<a name="ln2275">        b = uc-&gt;UnwrapCartesianNear(begin-&gt;GetVector(), v0);</a>
<a name="ln2276">        c = uc-&gt;UnwrapCartesianNear(end-&gt;GetVector(), b);</a>
<a name="ln2277">        d = uc-&gt;UnwrapCartesianNear(v2, c);</a>
<a name="ln2278">        tor02 = CalcTorsionAngle(v0, b, c, d);</a>
<a name="ln2279"> </a>
<a name="ln2280">        d = uc-&gt;UnwrapCartesianNear(v3, c);</a>
<a name="ln2281">        tor03 = CalcTorsionAngle(v0, b, c, d);</a>
<a name="ln2282"> </a>
<a name="ln2283">        b = uc-&gt;UnwrapCartesianNear(begin-&gt;GetVector(), v1);</a>
<a name="ln2284">        c = uc-&gt;UnwrapCartesianNear(end-&gt;GetVector(), b);</a>
<a name="ln2285">        d = uc-&gt;UnwrapCartesianNear(v2, c);</a>
<a name="ln2286">        tor12 = CalcTorsionAngle(v1, b, c, d);</a>
<a name="ln2287"> </a>
<a name="ln2288">        d = uc-&gt;UnwrapCartesianNear(v3, c);</a>
<a name="ln2289">        tor13 = CalcTorsionAngle(v1, b, c, d);</a>
<a name="ln2290">      } else {</a>
<a name="ln2291">        tor02 = CalcTorsionAngle(begin-&gt;GetVector() + bondVecs[0], begin-&gt;GetVector(), end-&gt;GetVector(), end-&gt;GetVector() + bondVecs[2]);</a>
<a name="ln2292">        tor03 = CalcTorsionAngle(begin-&gt;GetVector() + bondVecs[0], begin-&gt;GetVector(), end-&gt;GetVector(), end-&gt;GetVector() + bondVecs[3]);</a>
<a name="ln2293">        tor12 = CalcTorsionAngle(begin-&gt;GetVector() + bondVecs[1], begin-&gt;GetVector(), end-&gt;GetVector(), end-&gt;GetVector() + bondVecs[2]);</a>
<a name="ln2294">        tor13 = CalcTorsionAngle(begin-&gt;GetVector() + bondVecs[1], begin-&gt;GetVector(), end-&gt;GetVector(), end-&gt;GetVector() + bondVecs[3]);</a>
<a name="ln2295">      }</a>
<a name="ln2296"> </a>
<a name="ln2297">      if (std::abs(tor02) &lt; 90.0 &amp;&amp; std::abs(tor03) &gt; 90.0) {</a>
<a name="ln2298">        // 0      2 //</a>
<a name="ln2299">        //  \    /  //</a>
<a name="ln2300">        //   C==C   //</a>
<a name="ln2301">        //  /    \  //</a>
<a name="ln2302">        // 1      3 //</a>
<a name="ln2303">        config.shape = OBStereo::ShapeZ;</a>
<a name="ln2304"> </a>
<a name="ln2305">        if (std::abs(tor12) &lt; 90.0 || std::abs(tor13) &gt; 90.0) {</a>
<a name="ln2306">          obErrorLog.ThrowError(__FUNCTION__, &quot;Could not determine cis/trans from 3D coordinates, using unspecified&quot;, obInfo);</a>
<a name="ln2307">          config.specified = false;</a>
<a name="ln2308">        }</a>
<a name="ln2309">      } else if (std::abs(tor02) &gt; 90.0 &amp;&amp; std::abs(tor03) &lt; 90.0) {</a>
<a name="ln2310">        // 0      3 //</a>
<a name="ln2311">        //  \    /  //</a>
<a name="ln2312">        //   C==C   //</a>
<a name="ln2313">        //  /    \  //</a>
<a name="ln2314">        // 1      2 //</a>
<a name="ln2315">        config.shape = OBStereo::ShapeU;</a>
<a name="ln2316"> </a>
<a name="ln2317">        if (std::abs(tor12) &gt; 90.0 || std::abs(tor13) &lt; 90.0) {</a>
<a name="ln2318">          obErrorLog.ThrowError(__FUNCTION__, &quot;Could not determine cis/trans from 3D coordinates, using unspecified&quot;, obInfo);</a>
<a name="ln2319">          config.specified = false;</a>
<a name="ln2320">        }</a>
<a name="ln2321">      } else {</a>
<a name="ln2322">        obErrorLog.ThrowError(__FUNCTION__, &quot;Could not determine cis/trans from 3D coordinates, using unspecified&quot;, obInfo);</a>
<a name="ln2323">        config.shape = OBStereo::ShapeU;</a>
<a name="ln2324">        config.specified = false;</a>
<a name="ln2325">      }</a>
<a name="ln2326"> </a>
<a name="ln2327">      OBCisTransStereo *ct = new OBCisTransStereo(mol);</a>
<a name="ln2328">      ct-&gt;SetConfig(config);</a>
<a name="ln2329"> </a>
<a name="ln2330">      configs.push_back(ct);</a>
<a name="ln2331">      // add the data to the molecule if needed</a>
<a name="ln2332">      if (addToMol)</a>
<a name="ln2333">        mol-&gt;SetData(ct);</a>
<a name="ln2334">    }</a>
<a name="ln2335"> </a>
<a name="ln2336">    return configs;</a>
<a name="ln2337">  }</a>
<a name="ln2338"> </a>
<a name="ln2339">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2340">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2341">  //</a>
<a name="ln2342">  //  From2D</a>
<a name="ln2343">  //</a>
<a name="ln2344">  //  Reference:</a>
<a name="ln2345">  //  [1] T. Cieplak, J.L. Wisniewski, A New Effective Algorithm for the</a>
<a name="ln2346">  //  Unambiguous Identification of the Stereochemical Characteristics of</a>
<a name="ln2347">  //  Compounds During Their Registration in Databases. Molecules 2000, 6,</a>
<a name="ln2348">  //  915-926, http://www.mdpi.org/molecules/papers/61100915/61100915.htm</a>
<a name="ln2349">  //</a>
<a name="ln2350">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2351">  ////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2352"> </a>
<a name="ln2353">  void StereoFrom2D(OBMol *mol, std::map&lt;OBBond*, enum OBStereo::BondDirection&gt; *updown, bool force)</a>
<a name="ln2354">  {</a>
<a name="ln2355">    if (mol-&gt;HasChiralityPerceived() &amp;&amp; !force)</a>
<a name="ln2356">      return;</a>
<a name="ln2357"> </a>
<a name="ln2358">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::StereoFrom2D&quot;, obAuditMsg);</a>
<a name="ln2359"> </a>
<a name="ln2360">    std::vector&lt;unsigned int&gt; symmetry_classes = FindSymmetry(mol);</a>
<a name="ln2361">    OBStereoUnitSet stereogenicUnits = FindStereogenicUnits(mol, symmetry_classes);</a>
<a name="ln2362"> </a>
<a name="ln2363">    mol-&gt;DeleteData(OBGenericDataType::StereoData);</a>
<a name="ln2364">    TetrahedralFrom2D(mol, stereogenicUnits);</a>
<a name="ln2365">    CisTransFrom2D(mol, stereogenicUnits, updown);</a>
<a name="ln2366">    mol-&gt;SetChiralityPerceived();</a>
<a name="ln2367">  }</a>
<a name="ln2368">  //! Calculate the &quot;sign of a triangle&quot; given by a set of 3 2D coordinates</a>
<a name="ln2369">  double TriangleSign(const vector3 &amp;a, const vector3 &amp;b, const vector3 &amp;c)</a>
<a name="ln2370">  {</a>
<a name="ln2371">    // equation 6 from [1]</a>
<a name="ln2372">    return (a.x() - c.x()) * (b.y() - c.y()) - (a.y() - c.y()) * (b.x() - c.x());</a>
<a name="ln2373">  }</a>
<a name="ln2374">  //! Calculate whether three vectors are arranged in order of increasing</a>
<a name="ln2375">  //! angle anticlockwise (true) or clockwise (false) relative to a central point.</a>
<a name="ln2376">  bool AngleOrder(const vector3 &amp;a, const vector3 &amp;b, const vector3 &amp;c, const vector3 &amp;center)</a>
<a name="ln2377">  {</a>
<a name="ln2378">    vector3 t, u, v;</a>
<a name="ln2379">    t = a - center;</a>
<a name="ln2380">    t.normalize();</a>
<a name="ln2381">    u = b - center;</a>
<a name="ln2382">    u.normalize();</a>
<a name="ln2383">    v = c - center;</a>
<a name="ln2384">    v.normalize();</a>
<a name="ln2385">    return TriangleSign(t, u, v) &gt; 0;</a>
<a name="ln2386">  }</a>
<a name="ln2387">  //! Get the angle between three atoms (from -180 to +180)</a>
<a name="ln2388">  //! Note: OBAtom.GetAngle just returns 0-&gt;180</a>
<a name="ln2389">  double GetAngle(OBAtom *a, OBAtom *b, OBAtom *c)</a>
<a name="ln2390">  {</a>
<a name="ln2391">   vector3 v1,v2;</a>
<a name="ln2392"> </a>
<a name="ln2393">    v1 = a-&gt;GetVector() - b-&gt;GetVector();</a>
<a name="ln2394">    v2 = c-&gt;GetVector() - b-&gt;GetVector();</a>
<a name="ln2395">    if (a-&gt;IsPeriodic()) {  // Adapted from OBAtom.GetAngle</a>
<a name="ln2396">      OBMol *mol = (OBMol*)a-&gt;GetParent();</a>
<a name="ln2397">      OBUnitCell *box = (OBUnitCell*)mol-&gt;GetData(OBGenericDataType::UnitCell);</a>
<a name="ln2398">      v1 = box-&gt;MinimumImageCartesian(v1);</a>
<a name="ln2399">      v2 = box-&gt;MinimumImageCartesian(v2);</a>
<a name="ln2400">    }</a>
<a name="ln2401">    if (IsNearZero(v1.length(), 1.0e-3)</a>
<a name="ln2402">      || IsNearZero(v2.length(), 1.0e-3)) {</a>
<a name="ln2403">        return(0.0);</a>
<a name="ln2404">    }</a>
<a name="ln2405"> </a>
<a name="ln2406">    double angle = (atan2(v2.y(),v2.x()) - atan2(v1.y(),v1.x())) * RAD_TO_DEG;</a>
<a name="ln2407">    while (angle &lt; -180.0) angle += 360.0;</a>
<a name="ln2408">    while (angle &gt; 180.0) angle -= 360.0;</a>
<a name="ln2409">    return angle;</a>
<a name="ln2410">  }</a>
<a name="ln2411">  std::vector&lt;OBTetrahedralStereo*&gt; TetrahedralFrom2D(OBMol *mol,</a>
<a name="ln2412">      const OBStereoUnitSet &amp;stereoUnits, bool addToMol)</a>
<a name="ln2413">  {</a>
<a name="ln2414">    std::vector&lt;OBTetrahedralStereo*&gt; configs;</a>
<a name="ln2415">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::TetrahedralFrom2D&quot;, obAuditMsg);</a>
<a name="ln2416"> </a>
<a name="ln2417">    // find all tetrahedral centers</a>
<a name="ln2418">    std::vector&lt;unsigned long&gt; centers;</a>
<a name="ln2419">    for (OBStereoUnitSet::const_iterator u = stereoUnits.begin(); u != stereoUnits.end(); ++u)</a>
<a name="ln2420">      if ((*u).type == OBStereo::Tetrahedral)</a>
<a name="ln2421">        centers.push_back((*u).id);</a>
<a name="ln2422"> </a>
<a name="ln2423"> </a>
<a name="ln2424">    std::vector&lt;unsigned long&gt;::iterator i;</a>
<a name="ln2425">    for (i = centers.begin(); i != centers.end(); ++i) {</a>
<a name="ln2426">      OBAtom *center = mol-&gt;GetAtomById(*i);</a>
<a name="ln2427"> </a>
<a name="ln2428">      // make sure we have at least 3 heavy atom neighbors</a>
<a name="ln2429">      if (center-&gt;GetHvyDegree() &lt; 3) {</a>
<a name="ln2430">        std::stringstream errorMsg;</a>
<a name="ln2431">        errorMsg &lt;&lt; &quot;Cannot calculate a signed volume for an atom with a heavy atom valence of &quot;</a>
<a name="ln2432">                 &lt;&lt; center-&gt;GetHvyDegree() &lt;&lt; std::endl;</a>
<a name="ln2433">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obInfo);</a>
<a name="ln2434">        continue;</a>
<a name="ln2435">      }</a>
<a name="ln2436"> </a>
<a name="ln2437">      OBTetrahedralStereo::Config config;</a>
<a name="ln2438">      config.center = *i;</a>
<a name="ln2439"> </a>
<a name="ln2440">      // We assume the 'tip-only' convention. That is, wedge or hash bonds only</a>
<a name="ln2441">      // determine the stereochemistry at their thin end (the BeginAtom)</a>
<a name="ln2442">      bool tiponly = true;</a>
<a name="ln2443"> </a>
<a name="ln2444">      // find the hash, wedge and 2 plane atoms</a>
<a name="ln2445">      std::vector&lt;OBAtom*&gt; planeAtoms;</a>
<a name="ln2446">      std::vector&lt;OBAtom*&gt; wedgeAtoms;</a>
<a name="ln2447">      std::vector&lt;OBAtom*&gt; hashAtoms;</a>
<a name="ln2448">      FOR_BONDS_OF_ATOM(bond, center) {</a>
<a name="ln2449">        OBAtom *nbr = bond-&gt;GetNbrAtom(center);</a>
<a name="ln2450">        // hash bonds</a>
<a name="ln2451">        if (bond-&gt;IsHash()) {</a>
<a name="ln2452">          if (bond-&gt;GetBeginAtom()-&gt;GetId() == center-&gt;GetId()) {</a>
<a name="ln2453">            // this is a 'real' hash bond going from center to nbr</a>
<a name="ln2454">            hashAtoms.push_back(nbr);</a>
<a name="ln2455">          } else {</a>
<a name="ln2456">            // this is an 'inverted' hash bond going from nbr to center</a>
<a name="ln2457">            if (tiponly)</a>
<a name="ln2458">              planeAtoms.push_back(nbr);</a>
<a name="ln2459">            else</a>
<a name="ln2460">              wedgeAtoms.push_back(nbr);</a>
<a name="ln2461">          }</a>
<a name="ln2462">        } else if (bond-&gt;IsWedge()) {</a>
<a name="ln2463">          // wedge bonds</a>
<a name="ln2464">          if (bond-&gt;GetBeginAtom()-&gt;GetId() == center-&gt;GetId()) {</a>
<a name="ln2465">            // this is a 'real' wedge bond going from center to nbr</a>
<a name="ln2466">            wedgeAtoms.push_back(nbr);</a>
<a name="ln2467">          } else {</a>
<a name="ln2468">            // this is an 'inverted' wedge bond going from nbr to center</a>
<a name="ln2469">            if (tiponly)</a>
<a name="ln2470">              planeAtoms.push_back(nbr);</a>
<a name="ln2471">            else</a>
<a name="ln2472">              hashAtoms.push_back(nbr);</a>
<a name="ln2473">          }</a>
<a name="ln2474">        } else if (bond-&gt;IsWedgeOrHash()) {</a>
<a name="ln2475">          if (!tiponly || (tiponly &amp;&amp; bond-&gt;GetBeginAtom()-&gt;GetId() == center-&gt;GetId())) {</a>
<a name="ln2476">            config.specified = true;</a>
<a name="ln2477">            config.winding = OBStereo::UnknownWinding;</a>
<a name="ln2478">            break;</a>
<a name="ln2479">          }</a>
<a name="ln2480">          else</a>
<a name="ln2481">            planeAtoms.push_back(nbr);</a>
<a name="ln2482">        } else {</a>
<a name="ln2483">          // plane bonds</a>
<a name="ln2484">          planeAtoms.push_back(nbr);</a>
<a name="ln2485">        }</a>
<a name="ln2486">      }</a>
<a name="ln2487"> </a>
<a name="ln2488">      // Handle the case of a tet center with four plane atoms or</a>
<a name="ln2489">      //        3 plane atoms with the fourth bond implicit</a>
<a name="ln2490">      if (planeAtoms.size() == 4 || (planeAtoms.size() == 3 &amp;&amp; center-&gt;GetExplicitDegree()==3))</a>
<a name="ln2491">        config.specified = false;</a>
<a name="ln2492"> </a>
<a name="ln2493">      bool success = true;</a>
<a name="ln2494"> </a>
<a name="ln2495">      using namespace std;</a>
<a name="ln2496">      if (!config.specified || (config.specified &amp;&amp; config.winding==OBStereo::UnknownWinding)) {</a>
<a name="ln2497">        // unspecified or specified as unknown</a>
<a name="ln2498">        FOR_NBORS_OF_ATOM (nbr, center)</a>
<a name="ln2499">          if (config.from == OBStereo::NoRef)</a>
<a name="ln2500">            config.from = nbr-&gt;GetId();</a>
<a name="ln2501">          else</a>
<a name="ln2502">            config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2503">        while (config.refs.size() &lt; 3)</a>
<a name="ln2504">          config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2505">      } else {</a>
<a name="ln2506"> </a>
<a name="ln2507">        // config.specified</a>
<a name="ln2508"> </a>
<a name="ln2509">        if (hashAtoms.size() == 4 || wedgeAtoms.size() == 4)</a>
<a name="ln2510">        {</a>
<a name="ln2511">          success = false;</a>
<a name="ln2512">        } else if (planeAtoms.size() + hashAtoms.size() + wedgeAtoms.size() == 4)</a>
<a name="ln2513">        {</a>
<a name="ln2514">          // Handle all explicit tetra with at least one stereobond</a>
<a name="ln2515">          vector&lt;OBAtom*&gt; order;</a>
<a name="ln2516"> </a>
<a name="ln2517">          // First of all, handle the case of three wedge (or three hash) and one other bond</a>
<a name="ln2518">          //          by converting it into a single hash (or single wedge) and three planes</a>
<a name="ln2519">          if (wedgeAtoms.size() == 3 || hashAtoms.size() == 3) {</a>
<a name="ln2520">            vector&lt;OBAtom*&gt; *pwedge, *phash;</a>
<a name="ln2521">            if (wedgeAtoms.size() == 3) {</a>
<a name="ln2522">              pwedge = &amp;wedgeAtoms; phash = &amp;hashAtoms;</a>
<a name="ln2523">            }</a>
<a name="ln2524">            else {</a>
<a name="ln2525">              phash = &amp;wedgeAtoms; pwedge = &amp;hashAtoms;</a>
<a name="ln2526">            }</a>
<a name="ln2527">            if (planeAtoms.size() == 0) { // Already has the hash bond</a>
<a name="ln2528">              planeAtoms.insert(planeAtoms.end(), pwedge-&gt;begin(), pwedge-&gt;end());</a>
<a name="ln2529">              pwedge-&gt;clear();</a>
<a name="ln2530">            }</a>
<a name="ln2531">            else { // Does not already have the hash bond</a>
<a name="ln2532">              phash-&gt;push_back(planeAtoms[0]);</a>
<a name="ln2533">              planeAtoms.clear();</a>
<a name="ln2534">              pwedge-&gt;clear();</a>
<a name="ln2535">            }</a>
<a name="ln2536">          }</a>
<a name="ln2537"> </a>
<a name="ln2538">          // Pick a stereobond on which to base the stereochemistry:</a>
<a name="ln2539">          bool wedge = wedgeAtoms.size() &gt; 0;</a>
<a name="ln2540">          order.push_back(wedge?wedgeAtoms[0]:hashAtoms[0]);</a>
<a name="ln2541">          vector&lt;OBAtom*&gt; nbrs;</a>
<a name="ln2542">          FOR_NBORS_OF_ATOM(nbr, center) {</a>
<a name="ln2543">            if (&amp;*nbr != order[0])</a>
<a name="ln2544">              nbrs.push_back(&amp;*nbr);</a>
<a name="ln2545">          }</a>
<a name="ln2546">          // Add &quot;nbrs&quot; to &quot;order&quot; in order of anticlockwise stereo</a>
<a name="ln2547">          order.push_back(nbrs[0]);</a>
<a name="ln2548">          if (AngleOrder(order[0]-&gt;GetVector(), order[1]-&gt;GetVector(), nbrs[1]-&gt;GetVector(), center-&gt;GetVector()))</a>
<a name="ln2549">            order.push_back(nbrs[1]);</a>
<a name="ln2550">          else</a>
<a name="ln2551">            order.insert(order.begin()+1, nbrs[1]);</a>
<a name="ln2552">          if (AngleOrder(order[0]-&gt;GetVector(), order[2]-&gt;GetVector(), nbrs[2]-&gt;GetVector(), center-&gt;GetVector()))</a>
<a name="ln2553">            order.push_back(nbrs[2]);</a>
<a name="ln2554">          else {</a>
<a name="ln2555">            if (AngleOrder(order[0]-&gt;GetVector(), order[1]-&gt;GetVector(), nbrs[2]-&gt;GetVector(), center-&gt;GetVector()))</a>
<a name="ln2556">              order.insert(order.begin()+2, nbrs[2]);</a>
<a name="ln2557">            else</a>
<a name="ln2558">              order.insert(order.begin()+1, nbrs[2]);</a>
<a name="ln2559">          }</a>
<a name="ln2560"> </a>
<a name="ln2561">          // Handle the case of two planes with a wedge and hash bond opposite each other.</a>
<a name="ln2562">          // This is handled as in the InChI TechMan (Figure 9) by marking it ambiguous if</a>
<a name="ln2563">          // the (small) angle between the plane bonds is &gt; 133, and basing the stereo on</a>
<a name="ln2564">          // the 'inner' bond otherwise. This is commonly used for stereo in rings.</a>
<a name="ln2565">          // See also Get2DTetrahedralAmbiguity() in ichister.c (part of InChI)</a>
<a name="ln2566">          if (planeAtoms.size() == 2 &amp;&amp; wedgeAtoms.size() == 1) { // Two planes, 1 wedge, 1 hash</a>
<a name="ln2567">            if (order[2] == hashAtoms[0]) { // The wedge and hash are opposite</a>
<a name="ln2568">              double angle = GetAngle(order[1], center, order[3]); // The anticlockwise angle between the plane atoms</a>
<a name="ln2569">              if (angle &gt; -133 &amp;&amp; angle &lt; 133) { // This value is from the InChI TechMan Figure 9</a>
<a name="ln2570">                if (angle &gt; 0) { // Change to three planes and the hash bond</a>
<a name="ln2571">                  std::rotate(order.begin(), order.begin() + 2, order.end()); // Change the order so that it begins with the hash bond</a>
<a name="ln2572">                  wedge = false;</a>
<a name="ln2573">                  planeAtoms.push_back(wedgeAtoms[0]);</a>
<a name="ln2574">                  wedgeAtoms.clear();</a>
<a name="ln2575">                }</a>
<a name="ln2576">                else { // Change to three planes and the wedge bond (note: order is already correct)</a>
<a name="ln2577">                  planeAtoms.push_back(hashAtoms[0]);</a>
<a name="ln2578">                  hashAtoms.clear();</a>
<a name="ln2579">                }</a>
<a name="ln2580">              } // No need for &quot;else&quot; statement, as this will be picked up as ambiguous stereo below</a>
<a name="ln2581">            }</a>
<a name="ln2582">          }</a>
<a name="ln2583"> </a>
<a name="ln2584">          config.from = order[0]-&gt;GetId();</a>
<a name="ln2585">          config.refs.resize(3);</a>
<a name="ln2586">          for(int i=0; i&lt;3; ++i)</a>
<a name="ln2587">            config.refs[i] = order[i+1]-&gt;GetId();</a>
<a name="ln2588">          if (wedge)</a>
<a name="ln2589">            config.winding = OBStereo::AntiClockwise;</a>
<a name="ln2590"> </a>
<a name="ln2591">          // Check for ambiguous stereo based on the members of &quot;order&quot;.</a>
<a name="ln2592">          // If the first is a wedge bond, then the next should be a plane/hash, then plane/wedge, then plane/hash</a>
<a name="ln2593">          // If not, then the stereo is considered ambiguous.</a>
<a name="ln2594">          vector&lt;OBAtom*&gt; *pwedge, *phash;</a>
<a name="ln2595">          if (wedge) {</a>
<a name="ln2596">            pwedge = &amp;wedgeAtoms; phash = &amp;hashAtoms;</a>
<a name="ln2597">          }</a>
<a name="ln2598">          else {</a>
<a name="ln2599">            phash = &amp;wedgeAtoms; pwedge = &amp;hashAtoms;</a>
<a name="ln2600">          }</a>
<a name="ln2601">          if (std::find(pwedge-&gt;begin(), pwedge-&gt;end(), order[1]) != pwedge-&gt;end() ||</a>
<a name="ln2602">              std::find(phash-&gt;begin(), phash-&gt;end(), order[2]) != phash-&gt;end()  ||</a>
<a name="ln2603">              std::find(pwedge-&gt;begin(), pwedge-&gt;end(), order[3]) != pwedge-&gt;end()) { // Ambiguous stereo</a>
<a name="ln2604">                success = false;</a>
<a name="ln2605">          }</a>
<a name="ln2606">        } else // 3 explicit bonds from here on</a>
<a name="ln2607">          if(hashAtoms.size() == 0 || wedgeAtoms.size() == 0) {</a>
<a name="ln2608">            // Composed of just wedge bonds and plane bonds, or just hash bonds and plane bonds</a>
<a name="ln2609"> </a>
<a name="ln2610">            // Pick a stereobond on which to base the stereochemistry:</a>
<a name="ln2611">            vector&lt;OBAtom*&gt; order;</a>
<a name="ln2612">            bool wedge = wedgeAtoms.size() &gt; 0;</a>
<a name="ln2613">            order.push_back(wedge?wedgeAtoms[0]:hashAtoms[0]);</a>
<a name="ln2614">            vector&lt;OBAtom*&gt; nbrs;</a>
<a name="ln2615">            FOR_NBORS_OF_ATOM(nbr, center) {</a>
<a name="ln2616">              if (&amp;*nbr != order[0])</a>
<a name="ln2617">                nbrs.push_back(&amp;*nbr);</a>
<a name="ln2618">            }</a>
<a name="ln2619">            // Add &quot;nbrs&quot; to &quot;order&quot; in order of anticlockwise stereo</a>
<a name="ln2620">            order.push_back(nbrs[0]);</a>
<a name="ln2621">            if (AngleOrder(order[0]-&gt;GetVector(), order[1]-&gt;GetVector(), nbrs[1]-&gt;GetVector(), center-&gt;GetVector()))</a>
<a name="ln2622">              order.push_back(nbrs[1]);</a>
<a name="ln2623">            else</a>
<a name="ln2624">              order.insert(order.begin()+1, nbrs[1]);</a>
<a name="ln2625"> </a>
<a name="ln2626">            // Handle the case of two planes with a wedge/hash in the small angle between them.</a>
<a name="ln2627">            // This is handled similar to the InChI TechMan (Figure 10) by treating the stereo bond</a>
<a name="ln2628">            // as being in the large angle. This is consistent with Symyx Draw.</a>
<a name="ln2629">            if (planeAtoms.size() == 2) { // Two planes, 1 stereo</a>
<a name="ln2630">              double angle = GetAngle(order[1], center, order[2]); // The anticlockwise angle between the plane atoms</a>
<a name="ln2631">              if (angle &lt; 0) // Invert the stereo of the stereobond</a>
<a name="ln2632">                wedge = !wedge;</a>
<a name="ln2633">            }</a>
<a name="ln2634"> </a>
<a name="ln2635">            config.from = OBStereo::ImplicitRef;</a>
<a name="ln2636">            config.refs.resize(3);</a>
<a name="ln2637">            for(int i=0; i&lt;3; ++i)</a>
<a name="ln2638">              config.refs[i] = order[i]-&gt;GetId();</a>
<a name="ln2639">            if (!wedge)</a>
<a name="ln2640">              config.winding = OBStereo::AntiClockwise;</a>
<a name="ln2641">        }  else { // 3 explicit bonds with at least one hash and at least one wedge</a>
<a name="ln2642">          success = false;</a>
<a name="ln2643">        }</a>
<a name="ln2644">      } // end of config.specified</a>
<a name="ln2645"> </a>
<a name="ln2646">      if (!success) {</a>
<a name="ln2647">//         std::stringstream errorMsg;</a>
<a name="ln2648">//         errorMsg &lt;&lt; &quot;Symmetry analysis found atom with id &quot; &lt;&lt; center-&gt;GetId()</a>
<a name="ln2649">//             &lt;&lt; &quot; to be a tetrahedral atom but the wedge/hash bonds can't be interpreted.&quot; &lt;&lt; std::endl</a>
<a name="ln2650">//             &lt;&lt; &quot; # in-plane bonds = &quot; &lt;&lt; planeAtoms.size() &lt;&lt; std::endl</a>
<a name="ln2651">//             &lt;&lt; &quot; # wedge bonds = &quot; &lt;&lt; wedgeAtoms.size() &lt;&lt; std::endl</a>
<a name="ln2652">//             &lt;&lt; &quot; # hash bonds = &quot; &lt;&lt; hashAtoms.size() &lt;&lt; std::endl</a>
<a name="ln2653">//             &lt;&lt; std::endl;</a>
<a name="ln2654">//         obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obError);</a>
<a name="ln2655">        continue;</a>
<a name="ln2656">      }</a>
<a name="ln2657"> </a>
<a name="ln2658"> </a>
<a name="ln2659">      OBTetrahedralStereo *th = new OBTetrahedralStereo(mol);</a>
<a name="ln2660">      th-&gt;SetConfig(config);</a>
<a name="ln2661"> </a>
<a name="ln2662">      configs.push_back(th);</a>
<a name="ln2663">      // add the data to the molecule if needed</a>
<a name="ln2664">      if (addToMol)</a>
<a name="ln2665">        mol-&gt;SetData(th);</a>
<a name="ln2666">    }</a>
<a name="ln2667"> </a>
<a name="ln2668">    return configs;</a>
<a name="ln2669">  }</a>
<a name="ln2670"> </a>
<a name="ln2671">  std::vector&lt;OBCisTransStereo*&gt; CisTransFrom2D(OBMol *mol,</a>
<a name="ln2672">      const OBStereoUnitSet &amp;stereoUnits,</a>
<a name="ln2673">      const std::map&lt;OBBond*, enum OBStereo::BondDirection&gt; *updown, bool addToMol)</a>
<a name="ln2674">  {</a>
<a name="ln2675">    std::vector&lt;OBCisTransStereo*&gt; configs;</a>
<a name="ln2676">    std::map&lt;OBBond*, enum OBStereo::BondDirection&gt;::const_iterator ud_cit;</a>
<a name="ln2677">    obErrorLog.ThrowError(__FUNCTION__, &quot;Ran OpenBabel::CisTransFrom2D&quot;, obAuditMsg);</a>
<a name="ln2678"> </a>
<a name="ln2679">    // find all cis/trans bonds</a>
<a name="ln2680">    std::vector&lt;unsigned long&gt; bonds;</a>
<a name="ln2681">    for (OBStereoUnitSet::const_iterator u = stereoUnits.begin(); u != stereoUnits.end(); ++u)</a>
<a name="ln2682">      if ((*u).type == OBStereo::CisTrans)</a>
<a name="ln2683">        bonds.push_back((*u).id);</a>
<a name="ln2684"> </a>
<a name="ln2685">    std::vector&lt;unsigned long&gt;::iterator i;</a>
<a name="ln2686">    for (i = bonds.begin(); i != bonds.end(); ++i) {</a>
<a name="ln2687">      OBBond *bond = mol-&gt;GetBondById(*i);</a>
<a name="ln2688">      OBAtom *begin = bond-&gt;GetBeginAtom();</a>
<a name="ln2689">      OBAtom *end = bond-&gt;GetEndAtom();</a>
<a name="ln2690"> </a>
<a name="ln2691">      // Create a vector with the coordinates of the neighbor atoms</a>
<a name="ln2692">      std::vector&lt;vector3&gt; bondVecs;</a>
<a name="ln2693">      OBCisTransStereo::Config config;</a>
<a name="ln2694">      config.specified = true;</a>
<a name="ln2695"> </a>
<a name="ln2696">      // begin</a>
<a name="ln2697">      config.begin = begin-&gt;GetId();</a>
<a name="ln2698">      FOR_NBORS_OF_ATOM (nbr, begin) {</a>
<a name="ln2699">        if (nbr-&gt;GetId() == end-&gt;GetId())</a>
<a name="ln2700">          continue;</a>
<a name="ln2701">        config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2702">        bondVecs.push_back(nbr-&gt;GetVector());</a>
<a name="ln2703"> </a>
<a name="ln2704">        // Check whether a single bond with unknown dir starts at the dbl bond (tip-only convention)</a>
<a name="ln2705">        OBBond *b = mol-&gt;GetBond(begin, &amp;*nbr);</a>
<a name="ln2706">        if (updown) {</a>
<a name="ln2707">          ud_cit = updown-&gt;find(b);</a>
<a name="ln2708">          if (ud_cit!=updown-&gt;end() &amp;&amp; ud_cit-&gt;second==OBStereo::UnknownDir &amp;&amp; b-&gt;GetBeginAtom()==begin)</a>
<a name="ln2709">            config.specified = false;</a>
<a name="ln2710">        }</a>
<a name="ln2711">      }</a>
<a name="ln2712">      if (config.refs.size() == 1) {</a>
<a name="ln2713">        config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2714">        vector3 pos;</a>
<a name="ln2715">        begin-&gt;GetNewBondVector(pos, 1.0);</a>
<a name="ln2716">        bondVecs.push_back(pos);</a>
<a name="ln2717">      }</a>
<a name="ln2718">      // end</a>
<a name="ln2719">      config.end = end-&gt;GetId();</a>
<a name="ln2720">      FOR_NBORS_OF_ATOM (nbr, end) {</a>
<a name="ln2721">        if (nbr-&gt;GetId() == begin-&gt;GetId())</a>
<a name="ln2722">          continue;</a>
<a name="ln2723">        config.refs.push_back(nbr-&gt;GetId());</a>
<a name="ln2724">        bondVecs.push_back(nbr-&gt;GetVector());</a>
<a name="ln2725"> </a>
<a name="ln2726">        // Check whether a single bond with unknown dir starts at the dbl bond (tip-only convention)</a>
<a name="ln2727">        OBBond *b = mol-&gt;GetBond(end, &amp;*nbr);</a>
<a name="ln2728">        if (updown) {</a>
<a name="ln2729">          ud_cit = updown-&gt;find(b);</a>
<a name="ln2730">          if (ud_cit!=updown-&gt;end() &amp;&amp; ud_cit-&gt;second==OBStereo::UnknownDir &amp;&amp; b-&gt;GetBeginAtom()==end)</a>
<a name="ln2731">            config.specified = false;</a>
<a name="ln2732">        }</a>
<a name="ln2733">      }</a>
<a name="ln2734">      if (config.refs.size() == 3) {</a>
<a name="ln2735">        config.refs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2736">        vector3 pos;</a>
<a name="ln2737">        end-&gt;GetNewBondVector(pos, 1.0);</a>
<a name="ln2738">        bondVecs.push_back(pos);</a>
<a name="ln2739">      }</a>
<a name="ln2740"> </a>
<a name="ln2741">      // Handle the case where the dbl bond is marked as unknown stereo</a>
<a name="ln2742">      if (updown) {</a>
<a name="ln2743">        ud_cit = updown-&gt;find(bond);</a>
<a name="ln2744">        if (ud_cit!=updown-&gt;end() &amp;&amp; ud_cit-&gt;second==OBStereo::UnknownDir)</a>
<a name="ln2745">            config.specified = false;</a>
<a name="ln2746">      }</a>
<a name="ln2747"> </a>
<a name="ln2748">      if (config.specified==true) { // Work out the stereochemistry</a>
<a name="ln2749">        // 0      3</a>
<a name="ln2750">        //  \    /        2 triangles: 0-1-b &amp; 2-3-a</a>
<a name="ln2751">        //   a==b    --&gt;  same sign: U</a>
<a name="ln2752">        //  /    \        opposite sign: Z</a>
<a name="ln2753">        // 1      2</a>
<a name="ln2754">        /*</a>
<a name="ln2755">        double sign1 = TriangleSign(begin-&gt;GetVector(), end-&gt;GetVector(), bondVecs[0]);</a>
<a name="ln2756">        double sign2 = TriangleSign(begin-&gt;GetVector(), end-&gt;GetVector(), bondVecs[2]);</a>
<a name="ln2757">        */</a>
<a name="ln2758">        double sign1 = TriangleSign(bondVecs[0], bondVecs[1], end-&gt;GetVector());</a>
<a name="ln2759">        double sign2 = TriangleSign(bondVecs[2], bondVecs[3], begin-&gt;GetVector());</a>
<a name="ln2760">        double sign = sign1 * sign2;</a>
<a name="ln2761"> </a>
<a name="ln2762">        if (sign &lt; 0.0) // opposite sign</a>
<a name="ln2763">          config.shape = OBStereo::ShapeZ;</a>
<a name="ln2764">      }</a>
<a name="ln2765"> </a>
<a name="ln2766">      OBCisTransStereo *ct = new OBCisTransStereo(mol);</a>
<a name="ln2767">      ct-&gt;SetConfig(config);</a>
<a name="ln2768"> </a>
<a name="ln2769">      configs.push_back(ct);</a>
<a name="ln2770">      // add the data to the molecule if needed</a>
<a name="ln2771">      if (addToMol)</a>
<a name="ln2772">        mol-&gt;SetData(ct);</a>
<a name="ln2773">    }</a>
<a name="ln2774"> </a>
<a name="ln2775">    return configs;</a>
<a name="ln2776">  }</a>
<a name="ln2777"> </a>
<a name="ln2778">  bool TetStereoToWedgeHash(OBMol &amp;mol,</a>
<a name="ln2779">      std::map&lt;OBBond*, enum OBStereo::BondDirection&gt; &amp;updown,</a>
<a name="ln2780">      std::map&lt;OBBond*, OBStereo::Ref&gt; &amp;from)</a>
<a name="ln2781">  {</a>
<a name="ln2782">    // Store the tetcenters for the second loop (below)</a>
<a name="ln2783">    std::set &lt;unsigned long&gt; tetcenters;</a>
<a name="ln2784">    std::vector&lt;OBGenericData*&gt; vdata = mol.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln2785">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data)</a>
<a name="ln2786">      if (((OBStereoBase*)*data)-&gt;GetType() == OBStereo::Tetrahedral) {</a>
<a name="ln2787">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln2788">        OBTetrahedralStereo::Config cfg = ts-&gt;GetConfig();</a>
<a name="ln2789">        tetcenters.insert(cfg.center);</a>
<a name="ln2790">      }</a>
<a name="ln2791"> </a>
<a name="ln2792">    // This loop sets one bond of each tet stereo to up or to down (2D only)</a>
<a name="ln2793">    std::set &lt;OBBond *&gt; alreadyset;</a>
<a name="ln2794">    OBUnitCell *uc = (OBUnitCell*)mol.GetData(OBGenericDataType::UnitCell);</a>
<a name="ln2795">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data)</a>
<a name="ln2796">      if (((OBStereoBase*)*data)-&gt;GetType() == OBStereo::Tetrahedral) {</a>
<a name="ln2797">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln2798">        OBTetrahedralStereo::Config cfg = ts-&gt;GetConfig();</a>
<a name="ln2799"> </a>
<a name="ln2800">        if (cfg.specified) {</a>
<a name="ln2801">          OBBond* chosen = nullptr;</a>
<a name="ln2802">          OBAtom* center = mol.GetAtomById(cfg.center);</a>
<a name="ln2803">          vector3 center_coord = center-&gt;GetVector();</a>
<a name="ln2804"> </a>
<a name="ln2805">          // Find the two bonds closest in angle and remember them if</a>
<a name="ln2806">          // they are closer than DELTA_ANGLE_FOR_OVERLAPPING_BONDS</a>
<a name="ln2807">          vector&lt;OBAtom*&gt; nbrs;</a>
<a name="ln2808">          FOR_NBORS_OF_ATOM(a, center)</a>
<a name="ln2809">            nbrs.push_back(&amp;*a);</a>
<a name="ln2810">          double min_angle = 359.0;</a>
<a name="ln2811">          OBBond *close_bond_a = nullptr;</a>
<a name="ln2812">          OBBond *close_bond_b = nullptr;</a>
<a name="ln2813">          for (unsigned int i=0; i&lt;nbrs.size() - 1; ++i)</a>
<a name="ln2814">            for (unsigned int j=i+1; j&lt;nbrs.size(); ++j) {</a>
<a name="ln2815">              double angle = abs(nbrs[i]-&gt;GetAngle(center, nbrs[j]));</a>
<a name="ln2816">              if (angle &lt; min_angle) {</a>
<a name="ln2817">                min_angle = angle;</a>
<a name="ln2818">                close_bond_a = mol.GetBond(center, nbrs[i]);</a>
<a name="ln2819">                close_bond_b = mol.GetBond(center, nbrs[j]);</a>
<a name="ln2820">              }</a>
<a name="ln2821">            }</a>
<a name="ln2822"> </a>
<a name="ln2823">          if (min_angle &gt; DELTA_ANGLE_FOR_OVERLAPPING_BONDS) {</a>
<a name="ln2824">            close_bond_a = nullptr;</a>
<a name="ln2825">            close_bond_b = nullptr;</a>
<a name="ln2826">          }</a>
<a name="ln2827"> </a>
<a name="ln2828">          // Find the best candidate bond to set to up/down</a>
<a name="ln2829">          // 1. **Should not already be set**</a>
<a name="ln2830">          // 2. Should not be connected to a 2nd tet center</a>
<a name="ln2831">          //    (this is acceptable, as the wedge is only at one end, but will only confuse things)</a>
<a name="ln2832">          // 3. Preferably is not in a cycle</a>
<a name="ln2833">	  // 4. Prefer neighbor with fewer bonds over neighbor with more bonds</a>
<a name="ln2834">          // 5. Preferably is a terminal H, C, or heteroatom (in that order)</a>
<a name="ln2835">          // 6. If two bonds are overlapping, choose one of these</a>
<a name="ln2836">          //    (otherwise the InChI code will mark it as ambiguous)</a>
<a name="ln2837"> </a>
<a name="ln2838">          int max_bond_score = 0;   // The test below (score &gt; max_bond_score)</a>
<a name="ln2839">          // gave incorrect results when score &lt; 0 and max_bond_score was an unsigned int</a>
<a name="ln2840">          // see https://stackoverflow.com/questions/5416414/signed-unsigned-comparisons#5416498</a>
<a name="ln2841">          FOR_BONDS_OF_ATOM(b, center) {</a>
<a name="ln2842">            if (alreadyset.find(&amp;*b) != alreadyset.end()) continue;</a>
<a name="ln2843"> </a>
<a name="ln2844">            OBAtom* nbr = b-&gt;GetNbrAtom(center);</a>
<a name="ln2845">	    int nbr_nbonds = nbr-&gt;GetExplicitDegree();</a>
<a name="ln2846">            int score = 0;</a>
<a name="ln2847">            if (!b-&gt;IsInRing()) {</a>
<a name="ln2848">	      if (!nbr-&gt;IsInRing())</a>
<a name="ln2849">		score += 8;		// non-ring bond to non-ring atom is good</a>
<a name="ln2850">	      else</a>
<a name="ln2851">		score += 2;		// non-ring bond to ring atom is bad</a>
<a name="ln2852">	    }</a>
<a name="ln2853">            if (tetcenters.find(nbr-&gt;GetId()) == tetcenters.end()) // Not a tetcenter</a>
<a name="ln2854">              score += 4;</a>
<a name="ln2855">	    if (nbr_nbonds == 1)	// terminal atom...</a>
<a name="ln2856">		score += 8;		// strongly prefer terminal atoms</a>
<a name="ln2857">	    else</a>
<a name="ln2858">	      score -= nbr_nbonds - 2;	// bond to atom with many bonds is penalized</a>
<a name="ln2859">	    if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln2860">	      score += 2;		// prefer H</a>
<a name="ln2861">	    else if (nbr-&gt;GetAtomicNum() == OBElements::Carbon)</a>
<a name="ln2862">	      score += 1;		// then C</a>
<a name="ln2863">            if (&amp;*b==close_bond_a || &amp;*b==close_bond_b)</a>
<a name="ln2864">              score += 16;</a>
<a name="ln2865"> </a>
<a name="ln2866">            if (score &gt; max_bond_score) {</a>
<a name="ln2867">              max_bond_score = score;</a>
<a name="ln2868">              chosen = &amp;*b;</a>
<a name="ln2869">            }</a>
<a name="ln2870">          }</a>
<a name="ln2871"> </a>
<a name="ln2872">          if (chosen == nullptr) { // There is a remote possibility of this but let's worry about 99.9% of cases first</a>
<a name="ln2873">            obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2874">              &quot;Failed to set stereochemistry as unable to find an available bond&quot;, obError);</a>
<a name="ln2875">            return false;</a>
<a name="ln2876">          }</a>
<a name="ln2877">          alreadyset.insert(chosen);</a>
<a name="ln2878"> </a>
<a name="ln2879">          // Determine whether this bond should be set hash or wedge (or indeed unknown)</a>
<a name="ln2880">          // (Code inspired by perception.cpp, TetrahedralFrom2D: plane1 + plane2 + plane3, wedge)</a>
<a name="ln2881">          OBStereo::BondDirection bonddir = OBStereo::UnknownDir;</a>
<a name="ln2882">          if (cfg.winding != OBStereo::UnknownWinding) {</a>
<a name="ln2883">            OBTetrahedralStereo::Config test_cfg = cfg;</a>
<a name="ln2884"> </a>
<a name="ln2885">            // If there is an implicit ref; let's make that the 'from' atom</a>
<a name="ln2886">            // otherwise use the atom on the chosen bond</a>
<a name="ln2887">            bool implicit = false;</a>
<a name="ln2888">            if (test_cfg.from != OBStereo::ImplicitRef) {</a>
<a name="ln2889">              OBStereo::RefIter ri = std::find(test_cfg.refs.begin(), test_cfg.refs.end(), (unsigned long) OBStereo::ImplicitRef);</a>
<a name="ln2890">              if (ri!=test_cfg.refs.end()) {</a>
<a name="ln2891">                test_cfg = OBTetrahedralStereo::ToConfig(test_cfg, OBStereo::ImplicitRef);</a>
<a name="ln2892">                implicit = true;</a>
<a name="ln2893">              }</a>
<a name="ln2894">            }</a>
<a name="ln2895">            else</a>
<a name="ln2896">              implicit = true;</a>
<a name="ln2897"> </a>
<a name="ln2898">            bool anticlockwise_order;</a>
<a name="ln2899">            bool useup;</a>
<a name="ln2900">            if (implicit) {</a>
<a name="ln2901">              // Put the ref for the stereo bond second</a>
<a name="ln2902">              while (test_cfg.refs[1] != chosen-&gt;GetNbrAtom(center)-&gt;GetId())</a>
<a name="ln2903">                std::rotate(test_cfg.refs.begin(), test_cfg.refs.begin() + 2, test_cfg.refs.end());</a>
<a name="ln2904">              if (uc)</a>
<a name="ln2905">                anticlockwise_order = AngleOrder(</a>
<a name="ln2906">                  uc-&gt;UnwrapCartesianNear(mol.GetAtomById(test_cfg.refs[0])-&gt;GetVector(), center_coord),</a>
<a name="ln2907">                  uc-&gt;UnwrapCartesianNear(mol.GetAtomById(test_cfg.refs[1])-&gt;GetVector(), center_coord),</a>
<a name="ln2908">                  uc-&gt;UnwrapCartesianNear(mol.GetAtomById(test_cfg.refs[2])-&gt;GetVector(), center_coord),</a>
<a name="ln2909">                  center_coord</a>
<a name="ln2910">                  );</a>
<a name="ln2911">              else</a>
<a name="ln2912">                anticlockwise_order = AngleOrder(mol.GetAtomById(test_cfg.refs[0])-&gt;GetVector(),</a>
<a name="ln2913">                  mol.GetAtomById(test_cfg.refs[1])-&gt;GetVector(), mol.GetAtomById(test_cfg.refs[2])-&gt;GetVector(),</a>
<a name="ln2914">                  center-&gt;GetVector());</a>
<a name="ln2915">              // Get the angle between the plane bonds</a>
<a name="ln2916">              double angle = GetAngle(mol.GetAtomById(test_cfg.refs[0]), center, mol.GetAtomById(test_cfg.refs[2]));</a>
<a name="ln2917">              if ((angle&lt;0 &amp;&amp; anticlockwise_order) || (angle&gt;0 &amp;&amp; !anticlockwise_order)) // Is the stereobond in the bigger angle?</a>
<a name="ln2918">                // If the bonds are in anticlockwise order, a clockwise angle (&lt;180) between plane bonds</a>
<a name="ln2919">                // implies that the stereo bond is in the bigger angle. Otherwise it has the opposite meaning.</a>
<a name="ln2920">                useup = anticlockwise_order;</a>
<a name="ln2921">              else</a>
<a name="ln2922">                useup = !anticlockwise_order;</a>
<a name="ln2923">              }</a>
<a name="ln2924">            else {</a>
<a name="ln2925">              test_cfg = OBTetrahedralStereo::ToConfig(test_cfg, chosen-&gt;GetNbrAtom(center)-&gt;GetId());</a>
<a name="ln2926">              if (uc)</a>
<a name="ln2927">                anticlockwise_order = AngleOrder(</a>
<a name="ln2928">                  uc-&gt;UnwrapCartesianNear(mol.GetAtomById(test_cfg.refs[0])-&gt;GetVector(), center_coord),</a>
<a name="ln2929">                  uc-&gt;UnwrapCartesianNear(mol.GetAtomById(test_cfg.refs[1])-&gt;GetVector(), center_coord),</a>
<a name="ln2930">                  uc-&gt;UnwrapCartesianNear(mol.GetAtomById(test_cfg.refs[2])-&gt;GetVector(), center_coord),</a>
<a name="ln2931">                  center_coord</a>
<a name="ln2932">                  );</a>
<a name="ln2933">              else</a>
<a name="ln2934">                anticlockwise_order = AngleOrder(mol.GetAtomById(test_cfg.refs[0])-&gt;GetVector(),</a>
<a name="ln2935">                  mol.GetAtomById(test_cfg.refs[1])-&gt;GetVector(), mol.GetAtomById(test_cfg.refs[2])-&gt;GetVector(),</a>
<a name="ln2936">                  center-&gt;GetVector());</a>
<a name="ln2937">              if (anticlockwise_order)</a>
<a name="ln2938">                useup = false;</a>
<a name="ln2939">              else</a>
<a name="ln2940">                useup = true;</a>
<a name="ln2941">            }</a>
<a name="ln2942"> </a>
<a name="ln2943"> </a>
<a name="ln2944">            // Set to UpBond (filled wedge from cfg.center to chosen_nbr) or DownBond</a>
<a name="ln2945">            bonddir = useup ? OBStereo::UpBond : OBStereo::DownBond;</a>
<a name="ln2946">          }</a>
<a name="ln2947">          updown[chosen] = bonddir;</a>
<a name="ln2948">          from[chosen] = cfg.center;</a>
<a name="ln2949">        }</a>
<a name="ln2950">      }</a>
<a name="ln2951">      return true;</a>
<a name="ln2952">  }</a>
<a name="ln2953"> </a>
<a name="ln2954">  set&lt;OBBond*&gt; GetUnspecifiedCisTrans(OBMol&amp; mol)</a>
<a name="ln2955">  {</a>
<a name="ln2956">    // Get double bonds with unspecified CisTransStereo</a>
<a name="ln2957">    set&lt;OBBond*&gt; unspec_ctstereo;</a>
<a name="ln2958">    std::vector&lt;OBGenericData*&gt; vdata = mol.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln2959">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data)</a>
<a name="ln2960">      if (((OBStereoBase*)*data)-&gt;GetType() == OBStereo::CisTrans) {</a>
<a name="ln2961">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln2962">        OBCisTransStereo::Config cfg = ct-&gt;GetConfig();</a>
<a name="ln2963">        if (!cfg.specified) {</a>
<a name="ln2964">          OBBond* dbl_bond = mol.GetBond(mol.GetAtomById(cfg.begin), mol.GetAtomById(cfg.end));</a>
<a name="ln2965">          unspec_ctstereo.insert(dbl_bond);</a>
<a name="ln2966">        }</a>
<a name="ln2967">      }</a>
<a name="ln2968">    return unspec_ctstereo;</a>
<a name="ln2969">  }</a>
<a name="ln2970"> </a>
<a name="ln2971">  void StereoRefToImplicit(OBMol&amp; mol, OBStereo::Ref atomId) {</a>
<a name="ln2972">    // The following is for use in replace_if(...) below</a>
<a name="ln2973">    const std::binder1st&lt;std::equal_to&lt;OBStereo::Ref&gt; &gt; equal_to_atomId = std::bind1st (equal_to&lt;OBStereo::Ref&gt;(), atomId);</a>
<a name="ln2974"> </a>
<a name="ln2975">    std::vector&lt;OBGenericData*&gt; vdata = mol.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln2976">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data) {</a>
<a name="ln2977">      OBStereo::Type datatype = ((OBStereoBase*)*data)-&gt;GetType();</a>
<a name="ln2978"> </a>
<a name="ln2979">      if (datatype != OBStereo::CisTrans &amp;&amp; datatype != OBStereo::Tetrahedral) {</a>
<a name="ln2980">        // Maybe I should just unset the stereochemistry if this happens?</a>
<a name="ln2981">        obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln2982">            &quot;This function should be updated to handle additional stereo types.\nSome stereochemistry objects may contain explicit refs to hydrogens which have been removed.&quot;, obWarning);</a>
<a name="ln2983">        continue;</a>
<a name="ln2984">      }</a>
<a name="ln2985"> </a>
<a name="ln2986">      // Replace any references to atomId with ImplicitRef</a>
<a name="ln2987">      if (datatype == OBStereo::CisTrans) {</a>
<a name="ln2988">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln2989">        OBCisTransStereo::Config ct_cfg = ct-&gt;GetConfig();</a>
<a name="ln2990">        replace_if(ct_cfg.refs.begin(), ct_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);</a>
<a name="ln2991">        ct-&gt;SetConfig(ct_cfg);</a>
<a name="ln2992">      }</a>
<a name="ln2993">      else if (datatype == OBStereo::Tetrahedral) {</a>
<a name="ln2994">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln2995">        OBTetrahedralStereo::Config ts_cfg = ts-&gt;GetConfig();</a>
<a name="ln2996">        if (ts_cfg.from == atomId) ts_cfg.from = OBStereo::ImplicitRef;</a>
<a name="ln2997">        replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);</a>
<a name="ln2998">        ts-&gt;SetConfig(ts_cfg);</a>
<a name="ln2999">      }</a>
<a name="ln3000">    }</a>
<a name="ln3001">  }</a>
<a name="ln3002"> </a>
<a name="ln3003">  void ImplicitRefToStereo(OBMol&amp; mol, OBStereo::Ref centerId, OBStereo::Ref newId) {</a>
<a name="ln3004">    // The following is for use in replace_if(...) below</a>
<a name="ln3005">    const std::binder1st&lt;std::equal_to&lt;OBStereo::Ref&gt; &gt; equal_to_implicitRef = std::bind1st (equal_to&lt;OBStereo::Ref&gt;(), (OBStereo::Ref) OBStereo::ImplicitRef);</a>
<a name="ln3006"> </a>
<a name="ln3007">    std::vector&lt;OBGenericData*&gt; vdata = mol.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln3008">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data) {</a>
<a name="ln3009">      OBStereo::Type datatype = ((OBStereoBase*)*data)-&gt;GetType();</a>
<a name="ln3010"> </a>
<a name="ln3011">      if (datatype != OBStereo::CisTrans &amp;&amp; datatype != OBStereo::Tetrahedral) {</a>
<a name="ln3012">        // Maybe I should just unset the stereochemistry if this happens?</a>
<a name="ln3013">        obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln3014">            &quot;This function should be updated to handle additional stereo types.\nSome stereochemistry objects may contain implicit refs to hydrogens which need to be converted to explicit.&quot;, obWarning);</a>
<a name="ln3015">        continue;</a>
<a name="ln3016">      }</a>
<a name="ln3017"> </a>
<a name="ln3018">      // Replace any references to ImplicitRef (attached to centerId) with newId</a>
<a name="ln3019">      if (datatype == OBStereo::CisTrans) {</a>
<a name="ln3020">        OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln3021">        OBCisTransStereo::Config ct_cfg = ct-&gt;GetConfig();</a>
<a name="ln3022">        if (ct_cfg.begin == centerId || ct_cfg.end == centerId) {</a>
<a name="ln3023">          // Assumption: the first two refs are on the begin atom, the last two on the end atom</a>
<a name="ln3024">          if (ct_cfg.begin == centerId)</a>
<a name="ln3025">            replace_if(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, equal_to_implicitRef, (OBStereo::Ref) newId);</a>
<a name="ln3026">          if (ct_cfg.end == centerId)</a>
<a name="ln3027">            replace_if(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);</a>
<a name="ln3028">          ct-&gt;SetConfig(ct_cfg);</a>
<a name="ln3029">        }</a>
<a name="ln3030">      }</a>
<a name="ln3031">      else if (datatype == OBStereo::Tetrahedral) {</a>
<a name="ln3032">        OBTetrahedralStereo *ts = dynamic_cast&lt;OBTetrahedralStereo*&gt;(*data);</a>
<a name="ln3033">        OBTetrahedralStereo::Config ts_cfg = ts-&gt;GetConfig();</a>
<a name="ln3034">        if (ts_cfg.center == centerId) {</a>
<a name="ln3035">          if (ts_cfg.from == OBStereo::ImplicitRef) ts_cfg.from = newId;</a>
<a name="ln3036">          replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);</a>
<a name="ln3037">          ts-&gt;SetConfig(ts_cfg);</a>
<a name="ln3038">        }</a>
<a name="ln3039">      }</a>
<a name="ln3040">    }</a>
<a name="ln3041">  }</a>
<a name="ln3042"> </a>
<a name="ln3043">}</a>

</code></pre>
<div class="balloon" rel="2457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'tiponly' is always true.</p></div>
<div class="balloon" rel="2469"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'tiponly' is always true.</p></div>
<div class="balloon" rel="2475"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!tiponly' and 'tiponly'. </p></div>
<div class="balloon" rel="2475"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !tiponly.</p></div>
<div class="balloon" rel="2496"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!config.specified' and 'config.specified'. </p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichirvr1.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">/*^^^ */</a>
<a name="ln45">/*#define CHECK_WIN32_VC_HEAP*/</a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;ichi.h&quot;</a>
<a name="ln51">#include &quot;ichitime.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;inpdef.h&quot;</a>
<a name="ln54">#include &quot;ichimain.h&quot;</a>
<a name="ln55">#include &quot;ichierr.h&quot;</a>
<a name="ln56">#include &quot;incomdef.h&quot; </a>
<a name="ln57">#include &quot;ichiring.h&quot;</a>
<a name="ln58">#include &quot;extr_ct.h&quot;</a>
<a name="ln59">#include &quot;ichitaut.h&quot;</a>
<a name="ln60">#include &quot;ichinorm.h&quot;</a>
<a name="ln61">#include &quot;util.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;ichicomp.h&quot;</a>
<a name="ln64">#include &quot;ichister.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;ichi_bns.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;strutil.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">#include &quot;ichirvrs.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">/**************************************************************************************************</a>
<a name="ln74"> </a>
<a name="ln75">  ChargeStruct fictitios structures MY_CONST CN_LIST cnList[*]</a>
<a name="ln76">  ============================================================</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">  bond         flow      (+)  =&gt; Positive charge c-group</a>
<a name="ln80">  -----------------      (-)  =&gt; Negative charge c-group</a>
<a name="ln81">  Single        0        (+C) =&gt; Positive charge group for C, Si, Ge, Sn, Pb</a>
<a name="ln82">  Double        1        (-C) =&gt; Negative charge group for C, Si, Ge, Sn, Pb</a>
<a name="ln83">  Triple        2        (.)  =&gt; additional one unit of st_cap</a>
<a name="ln84"> </a>
<a name="ln85">  A) Interpretation:</a>
<a name="ln86"> </a>
<a name="ln87">  X-(-)  or X=(+)  =&gt; zero charge</a>
<a name="ln88">  X=(-)  or X-(+)  =&gt; charge = -1 or +1, respectively</a>
<a name="ln89"> </a>
<a name="ln90">  B) Information to keep:</a>
<a name="ln91">  </a>
<a name="ln92">  ordering zero-based number of the edge</a>
<a name="ln93">  to (+) or (-) from the Interpretation (A) section</a>
<a name="ln94"> </a>
<a name="ln95">  vCap  = vertex cap</a>
<a name="ln96">  vFlow = vertex flow</a>
<a name="ln97">  val   = number of edges incident to the vertex</a>
<a name="ln98">  neigh = 1-based ordering number of the adjacent vertex; 0 =&gt; no more adjacent vertices</a>
<a name="ln99">  cap   = cap of the edge to the adjacent vertex</a>
<a name="ln100">  flow  = flow of the edge to the adjacent vertex</a>
<a name="ln101"> </a>
<a name="ln102">  atom (c-point) always has number 1</a>
<a name="ln103">  c-group(s) always are the last vertices</a>
<a name="ln104">  always adjacent_neigh_number &gt; vertex_number, that is, neigh &gt; vertex</a>
<a name="ln105"> </a>
<a name="ln106">  Contribution to the Total Charge:</a>
<a name="ln107">  ----------------------------------</a>
<a name="ln108">  edge_cap(+) - edge_flow(+) - edge_flow(-) - Delta(+) - Delta(-)</a>
<a name="ln109"> </a>
<a name="ln110">  where edge_cap(+)  is edge capacity to c-group (+);</a>
<a name="ln111">        edge_flow(+) is edge capacity to c-group (?), (?)= (+) or (-);</a>
<a name="ln112">        Delta(?) = st_cap(?) - st_floe(?) of the c-group vertex (?), (?)= (+) or (-);</a>
<a name="ln113"> </a>
<a name="ln114">***************************************************************************************************/</a>
<a name="ln115">/**************************************************************************************************</a>
<a name="ln116"> </a>
<a name="ln117"> Important:</a>
<a name="ln118"> vCap and vFlow      Note: since metal charge group (vert. 2-4) MUST be registered before</a>
<a name="ln119"> marked with empty         the &quot;metal flower&quot; (5-8) all charge group vertex numbers are</a>
<a name="ln120"> comments for vertices     less than metal flower vertices: (2,3,4) &lt; (5,6,7,8)</a>
<a name="ln121"> 1 and 5(M) should         This MAY be neded for c-group enumeration. The order is: </a>
<a name="ln122"> be set separately         t-groups, c-groups, M-flower. All types BNS_VT_M_GROUP allow one to avoid duplications.</a>
<a name="ln123"> </a>
<a name="ln124">              3(+)           </a>
<a name="ln125">               ||         (Metal)</a>
<a name="ln126">               ||          \|/       init charge=0; MAX_METAL_CHARGE = 16</a>
<a name="ln127">   4(-)  5(M)  2           -Fe-                     CAP(BOND_TO_BNS_VT_M_GROUP) = NUM_BONDS*CAP</a>
<a name="ln128">      \   |   /             |</a>
<a name="ln129">        \ | /</a>
<a name="ln130">          1              X(V), V=valence</a>
<a name="ln131">*/</a>
<a name="ln132">MY_CONST C_NODE cnMe[5] = {</a>
<a name="ln133">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln134">    { {BNS_VERT_TYPE_ATOM,0/**/ ,0/**/,3}, {{ 2, 16,0, 0 },{ 4,  16,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln135">    { {BNS_VT_CHRG_STRUCT,16,   16,    2}, {{ 3, 16,0,16 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln136">    { {BNS_VT_C_POS_M,    16,   16,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 2 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln137">    { {BNS_VT_C_NEG_M,    0+16,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln138">    { {BNS_VT_M_GROUP,    0/**/ ,0/**/,3}, {{ 1,  3,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln139">};</a>
<a name="ln140">/*</a>
<a name="ln141">#define cn_bits_Me (-1)</a>
<a name="ln142">*/</a>
<a name="ln143"> </a>
<a name="ln144">/**************************************************************************************************</a>
<a name="ln145">     c=2     5(+.)</a>
<a name="ln146">     _____  /          (PNPN)</a>
<a name="ln147">    4=====3             ||||       init charge=0</a>
<a name="ln148"> c=2 \   / c=1          -N-</a>
<a name="ln149">       2                 |</a>
<a name="ln150">      ||||</a>
<a name="ln151">       1              X+(V), X(V+1), X+(V+2), X(V+3); V=valence</a>
<a name="ln152">*/</a>
<a name="ln153">MY_CONST C_NODE cnPNPN[5] = {</a>
<a name="ln154">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln155">    { {BNS_VERT_TYPE_ATOM, 3,    3,    1}, {{ 2,  3,0, 3 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln156">    { {BNS_VT_CHRG_STRUCT, 3,    3,    3}, {{ 3,  1,0, 0 },{ 4,   2,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln157">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 5,  1,0, 0 },{ 4,   2,0, 2 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln158">    { {BNS_VT_CHRG_STRUCT, 2,    2,    2}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln159">    { {BNS_VT_C_POS,       1+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln160">};</a>
<a name="ln161">/*</a>
<a name="ln162">#define cn_bits_PNPN MAKE_CN_BITS(cn_bits_P, cn_bits_N, cn_bits_P, cn_bits_N)</a>
<a name="ln163">*/</a>
<a name="ln164">/**************************************************************************************************</a>
<a name="ln165">             5(+)</a>
<a name="ln166">     c=1   //          (NPNP)</a>
<a name="ln167">    4=====3             ||||       init charge=0</a>
<a name="ln168"> c=1 \   / c=2          -N-</a>
<a name="ln169">       2                 |</a>
<a name="ln170">      ||||</a>
<a name="ln171">       1              X(V), X+(V+1), X(V+2), X+(V+3); V=valence</a>
<a name="ln172">*/</a>
<a name="ln173">MY_CONST C_NODE cnNPNP[5] = {</a>
<a name="ln174">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln175">    { {BNS_VERT_TYPE_ATOM, 3,    3,    1}, {{ 2,  3,0, 3 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln176">    { {BNS_VT_CHRG_STRUCT, 3,    3,    3}, {{ 3,  2,0, 0 },{ 4,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln177">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 5,  1,0, 1 },{ 4,   1,0, 1 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln178">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln179">    { {BNS_VT_C_POS,       0+1,  1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln180">};</a>
<a name="ln181">/*</a>
<a name="ln182">#define cn_bits_NPNP MAKE_CN_BITS(cn_bits_N, cn_bits_P, cn_bits_N, cn_bits_P)</a>
<a name="ln183">*/</a>
<a name="ln184">/********************* end new ********************************************************************/</a>
<a name="ln185"> </a>
<a name="ln186"> </a>
<a name="ln187">/**************************************************************************************************</a>
<a name="ln188">             5(+)</a>
<a name="ln189">           //          (NPN)</a>
<a name="ln190">    4=====3             |||       init charge=0</a>
<a name="ln191">     \   /              -N-</a>
<a name="ln192">       2                 |</a>
<a name="ln193">      |||</a>
<a name="ln194">       1              X(V), X+(V+1), X(V+2); V=valence</a>
<a name="ln195">*/</a>
<a name="ln196">MY_CONST C_NODE cnNPN[5] = {</a>
<a name="ln197">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln198">    { {BNS_VERT_TYPE_ATOM, 2,    2,    1}, {{ 2,  2,0, 2 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln199">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 3,  1,0, 0 },{ 4,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln200">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 5,  1,0, 1 },{ 4,   1,0, 1 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln201">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln202">    { {BNS_VT_C_POS,       1,    1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln203">};</a>
<a name="ln204">/*</a>
<a name="ln205">#define cn_bits_NPN MAKE_CN_BITS(cn_bits_N, cn_bits_P, cn_bits_N, 0)</a>
<a name="ln206">*/</a>
<a name="ln207">/**************************************************************************************************</a>
<a name="ln208">             5(+.)</a>
<a name="ln209">            /          (PNP)</a>
<a name="ln210">    4=====3             |||       init charge=0</a>
<a name="ln211">     \   /             -Cl-</a>
<a name="ln212">       2                /\</a>
<a name="ln213">      |||</a>
<a name="ln214">       1              X+(V), X(V+1), X+(V+2); V=valence</a>
<a name="ln215">*/</a>
<a name="ln216">MY_CONST C_NODE cnPNP[5] = {</a>
<a name="ln217">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln218">    { {BNS_VERT_TYPE_ATOM, 2,    2,    1}, {{ 2,  2,0, 2 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln219">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 3,  1,0, 0 },{ 4,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln220">    { {BNS_VT_CHRG_STRUCT, 1,    1,    3}, {{ 5,  1,0, 0 },{ 4,   1,0, 1 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln221">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln222">    { {BNS_VT_C_POS,       1+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln223">};</a>
<a name="ln224">/*</a>
<a name="ln225">#define cn_bits_PNP MAKE_CN_BITS(cn_bits_P, cn_bits_N, cn_bits_P, 0)</a>
<a name="ln226">*/</a>
<a name="ln227">/**************************************************************************************************</a>
<a name="ln228">                  </a>
<a name="ln229">                      (MNP)</a>
<a name="ln230">                       \ /        init charge=0</a>
<a name="ln231">                        N(.) </a>
<a name="ln232">   3(-)  2(+)          / \</a>
<a name="ln233">      \ //</a>
<a name="ln234">      1(.)           X-(V), X(V+1), X+(V+2); V=valence</a>
<a name="ln235">*/</a>
<a name="ln236">MY_CONST C_NODE cnMNP[3] = {</a>
<a name="ln237">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln238">    { {BNS_VERT_TYPE_ATOM, 2,    1,    2}, {{ 2,  1,0, 1 },{ 3,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln239">    { {BNS_VT_C_POS,       1,    1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln240">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} }   /* 3 */</a>
<a name="ln241">};                                      </a>
<a name="ln242">/*                                        </a>
<a name="ln243">#define cn_bits_MNP  MAKE_CN_BITS(cn_bits_M, cn_bits_N, cn_bits_P, 0)</a>
<a name="ln244">*/</a>
<a name="ln245">#ifdef NEVER</a>
<a name="ln246">/************************** not used **************************************************************</a>
<a name="ln247">                        (PNM)</a>
<a name="ln248"> 5(-)      4(+)         \\ /</a>
<a name="ln249">   \       //             B(.)    init charge=0</a>
<a name="ln250">    3     2              / \</a>
<a name="ln251">     \\  /</a>
<a name="ln252">       1(.)           X+(V), X(V+1), X+(V+2); V=valence</a>
<a name="ln253">*/</a>
<a name="ln254">MY_CONST C_NODE cnPNM[5] = {</a>
<a name="ln255">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln256">    { {BNS_VERT_TYPE_ATOM, 2,    1,    2}, {{ 2,  1,0, 0 },{ 3,   1,0, 1 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln257">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 4,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln258">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 5,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln259">    { {BNS_VT_C_POS,       1,    1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln260">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln261">};</a>
<a name="ln262"> </a>
<a name="ln263">#define cn_bits_PNM  MAKE_CN_BITS(cn_bits_P, cn_bits_N, cn_bits_M, 0)</a>
<a name="ln264"> </a>
<a name="ln265">#endif</a>
<a name="ln266"> </a>
<a name="ln267">/**************************************************************************************************</a>
<a name="ln268">   4(-)   3(+.)        (PNM)</a>
<a name="ln269">     \   /              |||        init charge=0</a>
<a name="ln270">       2               --P--</a>
<a name="ln271">      |||               / \</a>
<a name="ln272">       1              X-(V), X(V+1), X+(V+2); V=valence</a>
<a name="ln273">*/</a>
<a name="ln274">MY_CONST C_NODE cnPNM[4] = {</a>
<a name="ln275">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln276">    { {BNS_VERT_TYPE_ATOM, 2,    2,    1}, {{ 2,  2,0, 2 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln277">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 3,  1,0, 0 },{ 4,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln278">    { {BNS_VT_C_POS,       1+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln279">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln280">}; /* explanaton of vCap:  ^ ^  */      </a>
<a name="ln281">/*         additional dot:/   \ capacity of the edge to (+) or (-) vertex */</a>
<a name="ln282">/*</a>
<a name="ln283">#define cn_bits_PNM  MAKE_CN_BITS(cn_bits_P, cn_bits_N, cn_bits_M, 0)</a>
<a name="ln284">*/</a>
<a name="ln285">/**************************************************************************************************</a>
<a name="ln286">           5(+C)</a>
<a name="ln287">          //                        init charge=0</a>
<a name="ln288"> 6(-C)  4</a>
<a name="ln289">     \ /               (EN)  E=either +1 or -1</a>
<a name="ln290">      3                 |</a>
<a name="ln291">      ||               -C(.)-</a>
<a name="ln292">      2                 |</a>
<a name="ln293">      |  </a>
<a name="ln294">      1(.)            X-(V), X+(V), X(V+1); V=valence</a>
<a name="ln295">*/</a>
<a name="ln296">MY_CONST C_NODE cnEN[6] = {</a>
<a name="ln297">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln298">    { {BNS_VERT_TYPE_ATOM, 1,    0,    1}, {{ 2,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln299">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 3,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln300">    { {BNS_VT_CHRG_STRUCT, 1,    1,    3}, {{ 4,  1,0, 0 },{ 6,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln301">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 5,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln302">    { {BNS_VT_C_POS_C,     0+1,  1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln303">    { {BNS_VT_C_NEG_C,     0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} }   /* 6 */</a>
<a name="ln304">};</a>
<a name="ln305">/*</a>
<a name="ln306">#define cn_bits_EN  MAKE_CN_BITS(cn_bits_P | cn_bits_M, cn_bits_N, 0, 0)</a>
<a name="ln307">*/</a>
<a name="ln308">/**************************************************************************************************</a>
<a name="ln309">             5(-)</a>
<a name="ln310">            /          (NMN)        init charge=0</a>
<a name="ln311">    4=====3             |||</a>
<a name="ln312">     \   /              -X-</a>
<a name="ln313">       2                /\</a>
<a name="ln314">      |||</a>
<a name="ln315">       1              X(V), X-(V+1), X(V+2); V=valence</a>
<a name="ln316">*/</a>
<a name="ln317">MY_CONST C_NODE cnNMN[5] = {</a>
<a name="ln318">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln319">    { {BNS_VERT_TYPE_ATOM, 2,    2,    1}, {{ 2,  2,0, 2 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln320">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 3,  1,0, 0 },{ 4,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln321">    { {BNS_VT_CHRG_STRUCT, 1,    1,    3}, {{ 5,  1,0, 0 },{ 4,   1,0, 1 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln322">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln323">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} }   /* 5 */</a>
<a name="ln324">};</a>
<a name="ln325">/*</a>
<a name="ln326">#define cn_bits_NMN  MAKE_CN_BITS(cn_bits_N, cn_bits_M, cn_bits_N, 0)</a>
<a name="ln327">*/</a>
<a name="ln328">/**************************************************************************************************</a>
<a name="ln329">           4(+)</a>
<a name="ln330">          //           (NE)  E=either +1 or -1  </a>
<a name="ln331">  5(-)  3               ||</a>
<a name="ln332">     \ /               -X-          init charge=0</a>
<a name="ln333">      2                 |                       </a>
<a name="ln334">      ||         </a>
<a name="ln335">      1               X(V), X+(V+1), X-(V+1); V=valence</a>
<a name="ln336">*/</a>
<a name="ln337">MY_CONST C_NODE cnNE[5] = {</a>
<a name="ln338">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln339">    { {BNS_VERT_TYPE_ATOM, 1,    1,    1}, {{ 2,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln340">    { {BNS_VT_CHRG_STRUCT, 1,    1,    3}, {{ 3,  1,0, 0 },{ 5,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln341">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 4,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln342">    { {BNS_VT_C_POS,       0+1,  1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln343">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} }   /* 5 */</a>
<a name="ln344">};</a>
<a name="ln345">/*</a>
<a name="ln346">#define cn_bits_NE  MAKE_CN_BITS(cn_bits_N, cn_bits_P | cn_bits_M, 0, 0)</a>
<a name="ln347">*/</a>
<a name="ln348">/**************************************************************************************************</a>
<a name="ln349">6(-)         5(+)</a>
<a name="ln350">  \        //          (NEN)</a>
<a name="ln351">    4=====3             |||         init charge=0</a>
<a name="ln352">     \   /              -X-</a>
<a name="ln353">       2                 |</a>
<a name="ln354">      |||</a>
<a name="ln355">       1              X(V), X+(V+1), X-(V+1), X(V+2); V=valence</a>
<a name="ln356">*/</a>
<a name="ln357">MY_CONST C_NODE cnNEN[6] = {</a>
<a name="ln358">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln359">    { {BNS_VERT_TYPE_ATOM, 2,    2,    1}, {{ 2,  2,0, 2 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln360">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 3,  1,0, 0 },{ 4,   1,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln361">    { {BNS_VT_CHRG_STRUCT, 2,    2,    3}, {{ 5,  1,0, 1 },{ 4,   1,0, 1 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln362">    { {BNS_VT_CHRG_STRUCT, 1,    1,    3}, {{ 6,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 4 */</a>
<a name="ln363">    { {BNS_VT_C_POS,       0+1,  1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 5 */</a>
<a name="ln364">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 6 */</a>
<a name="ln365">};</a>
<a name="ln366">/*</a>
<a name="ln367">#define cn_bits_NEN  MAKE_CN_BITS(cn_bits_N, cn_bits_M | cn_bits_N, cn_bits_N, 0)</a>
<a name="ln368">*/</a>
<a name="ln369">/*=======================================================*/</a>
<a name="ln370">/**************************************************************************************************</a>
<a name="ln371">                        (NP)</a>
<a name="ln372">                         ||</a>
<a name="ln373">                        -X-         init charge=0</a>
<a name="ln374">      2(+)               |</a>
<a name="ln375">      || </a>
<a name="ln376">       1              X(V), X+(V+1); V=valence</a>
<a name="ln377">*/</a>
<a name="ln378">MY_CONST C_NODE cnNP[2] = {</a>
<a name="ln379">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln380">    { {BNS_VERT_TYPE_ATOM, 1,    1,    1}, {{ 2,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln381">    { {BNS_VT_C_POS,       0+1,  1,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln382">};</a>
<a name="ln383">/*</a>
<a name="ln384">#define cn_bits_NP  MAKE_CN_BITS(cn_bits_N, cn_bits_P, 0, 0)</a>
<a name="ln385">*/</a>
<a name="ln386">/**************************************************************************************************</a>
<a name="ln387">                        (PN)</a>
<a name="ln388">      3(+.)              ||         init charge=0  [because cap(+)-flow(+)-Delta=1-0-1=0]</a>
<a name="ln389">       |                -X-</a>
<a name="ln390">       2                 |</a>
<a name="ln391">      || </a>
<a name="ln392">       1              X+(V), X(V+1); V=valence</a>
<a name="ln393">*/</a>
<a name="ln394">MY_CONST C_NODE cnPN[3] = {</a>
<a name="ln395">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln396">    { {BNS_VERT_TYPE_ATOM, 1,    1,    1}, {{ 2,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln397">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 3,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln398">    { {BNS_VT_C_POS,       1+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln399">};                                      </a>
<a name="ln400">/*                                        </a>
<a name="ln401">#define cn_bits_PN  MAKE_CN_BITS(cn_bits_P, cn_bits_N, 0, 0)</a>
<a name="ln402">*/</a>
<a name="ln403">/**************************************************************************************************</a>
<a name="ln404">                        (NM)</a>
<a name="ln405">      3(-)               ||         init charge=0</a>
<a name="ln406">       |                -X-</a>
<a name="ln407">       2                 |</a>
<a name="ln408">      || </a>
<a name="ln409">       1              X(V), X-(V+1); V=valence</a>
<a name="ln410">*/</a>
<a name="ln411">MY_CONST C_NODE cnNM[3] = {</a>
<a name="ln412">    /*  vertex type       vCap  vFlow; val; neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln413">    { {BNS_VERT_TYPE_ATOM, 1,    1,    1}, {{ 2,  1,0, 1 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln414">    { {BNS_VT_CHRG_STRUCT, 1,    1,    2}, {{ 3,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln415">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 3 */</a>
<a name="ln416">};                                      </a>
<a name="ln417">/*                                        </a>
<a name="ln418">#define cn_bits_NM  MAKE_CN_BITS(cn_bits_N, cn_bits_M, 0, 0)</a>
<a name="ln419">*/</a>
<a name="ln420">/**************************************************************************************************</a>
<a name="ln421">                        (MN)</a>
<a name="ln422">                         | </a>
<a name="ln423">                        -X-         init charge=0</a>
<a name="ln424">      2(-)               |</a>
<a name="ln425">       | </a>
<a name="ln426">       1(.)           X-(V), X(V+1); V=valence</a>
<a name="ln427">*/</a>
<a name="ln428">MY_CONST C_NODE cnMN[2] = {</a>
<a name="ln429">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln430">    { {BNS_VERT_TYPE_ATOM, 1,    0,    1}, {{ 2,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln431">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln432">};</a>
<a name="ln433">/*</a>
<a name="ln434">#define cn_bits_MN  MAKE_CN_BITS(cn_bits_M, cn_bits_N, 0, 0)</a>
<a name="ln435">*/</a>
<a name="ln436">/**************************************************************************************************</a>
<a name="ln437">                        (P)</a>
<a name="ln438">                         | </a>
<a name="ln439">                        -X-         init charge=0</a>
<a name="ln440">      2(+.)              |</a>
<a name="ln441">       | </a>
<a name="ln442">       1              X+(V); V=valence; all chemical (real) bonds to X have cap=0</a>
<a name="ln443">*/</a>
<a name="ln444">MY_CONST C_NODE cnP_[2] = {</a>
<a name="ln445">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln446">    { {BNS_VERT_TYPE_ATOM, 0,    0,    1}, {{ 2,  1,1, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln447">    { {BNS_VT_C_POS,       1+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln448">};</a>
<a name="ln449">/*</a>
<a name="ln450">#define cn_bits_P_  MAKE_CN_BITS(cn_bits_P, 0, 0, 0)</a>
<a name="ln451">*/</a>
<a name="ln452">#ifdef NEVER</a>
<a name="ln453">/**************************************************************************************************</a>
<a name="ln454">                        (M)</a>
<a name="ln455">                         | </a>
<a name="ln456">                        -X-         init charge=-1 on atom</a>
<a name="ln457">      2(-)               |</a>
<a name="ln458">       | </a>
<a name="ln459">       1(.)           X+(V); V=valence; all chemical (real) bonds to X have cap=0</a>
<a name="ln460">*/</a>
<a name="ln461">MY_CONST C_NODE cnM_[2] = {</a>
<a name="ln462">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln463">    { {BNS_VERT_TYPE_ATOM, 1,    0,    1}, {{ 2,  1,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln464">    { {BNS_VT_C_NEG,       0+1,  0,    1}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 2 */</a>
<a name="ln465">};</a>
<a name="ln466">#endif</a>
<a name="ln467"> </a>
<a name="ln468">MY_CONST C_NODE cnM_[1] = {</a>
<a name="ln469">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln470">    { {BNS_VERT_TYPE_ATOM, 0,    0,    0}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln471">};</a>
<a name="ln472">/*</a>
<a name="ln473">#define cn_bits_M_  MAKE_CN_BITS(cn_bits_M, 0, 0, 0)</a>
<a name="ln474">*/</a>
<a name="ln475">/**************************************************************************************************</a>
<a name="ln476">                           </a>
<a name="ln477">                           </a>
<a name="ln478">                        -X-         init charge=0</a>
<a name="ln479">                         |</a>
<a name="ln480">         </a>
<a name="ln481">       1              X(V); V=valence;</a>
<a name="ln482">*/</a>
<a name="ln483">MY_CONST C_NODE cnN_[1] = {</a>
<a name="ln484">    /*  vertex type       vCap  vFlow val;  neigh cap flow; neigh cap flow; neigh cap flow    vertex */</a>
<a name="ln485">    { {BNS_VERT_TYPE_ATOM, 0,    0,    0}, {{ 0,  0,0, 0 },{ 0,   0,0, 0 }, { 0,  0,0, 0 }} },  /* 1 */</a>
<a name="ln486">};</a>
<a name="ln487">/*</a>
<a name="ln488">#define cn_bits_N_  MAKE_CN_BITS(cn_bits_N, 0, 0, 0)</a>
<a name="ln489">*/</a>
<a name="ln490">/**************************************************************************************************/</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">MY_CONST CN_LIST cnList[] = {</a>
<a name="ln494">    {cnPNPN, cn_bits_PNPN, 0, sizeof(cnPNPN)/sizeof(cnPNPN[0])},    /*  0 */</a>
<a name="ln495">    {cnNPNP, cn_bits_NPNP, 0, sizeof(cnNPNP)/sizeof(cnNPNP[0])},    /*  1 */</a>
<a name="ln496">    {cnNPN,  cn_bits_NPN,  0, sizeof(cnNPN)/sizeof(cnNPN[0])},      /*  2 */</a>
<a name="ln497">    {cnPNP,  cn_bits_PNP,  0, sizeof(cnPNP)/sizeof(cnPNP[0])},      /*  3 */</a>
<a name="ln498">    {cnMNP,  cn_bits_MNP,  0, sizeof(cnMNP)/sizeof(cnMNP[0])},      /*  4 */</a>
<a name="ln499">    {cnPNM,  cn_bits_PNM,  0, sizeof(cnPNM)/sizeof(cnPNM[0])},      /*  5 */</a>
<a name="ln500">    {cnEN,   cn_bits_EN ,  0, sizeof(cnEN)/sizeof(cnEN[0])},        /*  6 */</a>
<a name="ln501">    {cnNMN,  cn_bits_NMN,  0, sizeof(cnNMN)/sizeof(cnNMN[0])},      /*  7 */</a>
<a name="ln502">    {cnNE,   cn_bits_NE ,  0, sizeof(cnNE)/sizeof(cnNE[0])},        /*  8 */</a>
<a name="ln503">    {cnNEN,  cn_bits_NEN,  0, sizeof(cnNEN)/sizeof(cnNEN[0])},      /*  9 */</a>
<a name="ln504">    {cnNP,   cn_bits_NP,   0, sizeof(cnNP)/sizeof(cnNP[0])},        /* 10 */</a>
<a name="ln505">    {cnPN,   cn_bits_PN,   0, sizeof(cnPN)/sizeof(cnPN[0])},        /* 11 */</a>
<a name="ln506">    {cnNM,   cn_bits_NM,   0, sizeof(cnNM)/sizeof(cnNM[0])},        /* 12 */</a>
<a name="ln507">    {cnMN,   cn_bits_MN,   0, sizeof(cnMN)/sizeof(cnMN[0])},        /* 13 */</a>
<a name="ln508">    {cnP_,   cn_bits_P_,   0, sizeof(cnP_)/sizeof(cnP_[0])},        /* 14 */</a>
<a name="ln509">    {cnM_,   cn_bits_M_,  -1, sizeof(cnM_)/sizeof(cnM_[0])},        /* 15 */</a>
<a name="ln510">    {cnN_,   cn_bits_N_,   0, sizeof(cnN_)/sizeof(cnN_[0])},        /* 16 */</a>
<a name="ln511">    {cnMe,   cn_bits_Me,   0, sizeof(cnMe)/sizeof(cnMe[0])}         /* 17 */</a>
<a name="ln512">};</a>
<a name="ln513"> </a>
<a name="ln514">#define cnListIndexMe (17)  /* index of {cnMe, cn_bits_Me,... } element of cnList[] */</a>
<a name="ln515"> </a>
<a name="ln516">int cnListNumEl = (int)(sizeof(cnList)/sizeof(cnList[0]));</a>
<a name="ln517">/**********************************************************************/</a>
<a name="ln518">void clear_t_group_info( T_GROUP_INFO *ti )</a>
<a name="ln519">{</a>
<a name="ln520">    if ( !ti ) {</a>
<a name="ln521">        return;</a>
<a name="ln522">    } else {</a>
<a name="ln523">        T_GROUP   *t_group                     = ti-&gt;t_group;</a>
<a name="ln524">        int       max_num_t_groups             = ti-&gt;max_num_t_groups;</a>
<a name="ln525">        AT_NUMB   *tGroupNumber                = ti-&gt;tGroupNumber;</a>
<a name="ln526">        int       num_t_groups                 = ti-&gt;num_t_groups;</a>
<a name="ln527">        AT_NUMB   *nEndpointAtomNumber         = ti-&gt;nEndpointAtomNumber;</a>
<a name="ln528">        int       nNumEndpoints                = ti-&gt;nNumEndpoints;</a>
<a name="ln529">        AT_NUMB   *nIsotopicEndpointAtomNumber = ti-&gt;nIsotopicEndpointAtomNumber;</a>
<a name="ln530">        int       nNumIsotopicEndpoints        = ti-&gt;nNumIsotopicEndpoints;</a>
<a name="ln531">        memset( ti, 0, sizeof(*ti) );</a>
<a name="ln532">        if ( t_group ) {</a>
<a name="ln533">            memset( t_group, 0, sizeof(t_group[0])*max_num_t_groups );</a>
<a name="ln534">        } else {</a>
<a name="ln535">            max_num_t_groups = 0;</a>
<a name="ln536">        }</a>
<a name="ln537">        if ( tGroupNumber ) {</a>
<a name="ln538">            memset( tGroupNumber, 0, sizeof(tGroupNumber[0])*num_t_groups );</a>
<a name="ln539">        } else {</a>
<a name="ln540">            num_t_groups = 0;</a>
<a name="ln541">        }</a>
<a name="ln542">        if ( nEndpointAtomNumber ) {</a>
<a name="ln543">            memset( nEndpointAtomNumber, 0, sizeof(nEndpointAtomNumber[0])*nNumEndpoints );</a>
<a name="ln544">        } else {</a>
<a name="ln545">            nNumEndpoints = 0;</a>
<a name="ln546">        }</a>
<a name="ln547">        if ( nIsotopicEndpointAtomNumber ) {</a>
<a name="ln548">            memset( nIsotopicEndpointAtomNumber, 0, sizeof(nIsotopicEndpointAtomNumber[0])*nNumIsotopicEndpoints );</a>
<a name="ln549">        } else {</a>
<a name="ln550">            nNumIsotopicEndpoints = 0;</a>
<a name="ln551">        }</a>
<a name="ln552">        ti-&gt;t_group                      = t_group;</a>
<a name="ln553">        ti-&gt;max_num_t_groups             = max_num_t_groups;</a>
<a name="ln554">        ti-&gt;tGroupNumber                 = tGroupNumber;</a>
<a name="ln555">        ti-&gt;num_t_groups                 = num_t_groups;</a>
<a name="ln556">        ti-&gt;nEndpointAtomNumber          = nEndpointAtomNumber;</a>
<a name="ln557">        ti-&gt;nNumEndpoints                = nNumEndpoints;</a>
<a name="ln558">        ti-&gt;nIsotopicEndpointAtomNumber  = nIsotopicEndpointAtomNumber;</a>
<a name="ln559">        ti-&gt;nNumIsotopicEndpoints        = nNumIsotopicEndpoints;</a>
<a name="ln560">    }</a>
<a name="ln561">    return;</a>
<a name="ln562">}</a>
<a name="ln563">/******************************************************************************************************/</a>
<a name="ln564">int GetTgroupInfoFromInChI( T_GROUP_INFO *ti, inp_ATOM *at, AT_NUMB *endpoint, INChI *pInChI )</a>
<a name="ln565">{</a>
<a name="ln566">    int ret, i, j, k, itg, num_atoms, len_tg, bIso, num_t_groups;</a>
<a name="ln567">    AT_NUMB   *tGroupNumber      = NULL;</a>
<a name="ln568">    AT_NUMB   *tSymmRank         = NULL;</a>
<a name="ln569">    AT_NUMB   *tiSymmRank        = NULL;</a>
<a name="ln570">    AT_NUMB   *tiGroupNumber     = NULL;</a>
<a name="ln571"> </a>
<a name="ln572">    ret       = 0;</a>
<a name="ln573"> </a>
<a name="ln574">    clear_t_group_info( ti );</a>
<a name="ln575">    if ( pInChI &amp;&amp; pInChI-&gt;lenTautomer &gt; 1 &amp;&amp; pInChI-&gt;nTautomer &amp;&amp; pInChI-&gt;nTautomer[0] &gt; 0 ) {</a>
<a name="ln576">        num_atoms = pInChI-&gt;nNumberOfAtoms;</a>
<a name="ln577">        bIso      = pInChI-&gt;IsotopicAtom &amp;&amp; pInChI-&gt;nNumberOfIsotopicAtoms;</a>
<a name="ln578">        num_t_groups = pInChI-&gt;nTautomer[0];</a>
<a name="ln579">        len_tg = pInChI-&gt;lenTautomer - T_GROUP_HDR_LEN*pInChI-&gt;nTautomer[0] - 1; /* number of endpoints */</a>
<a name="ln580"> </a>
<a name="ln581">        /* allocation ti-&gt;t_group */</a>
<a name="ln582">        if ( ti-&gt;max_num_t_groups != num_atoms/2+1 || !ti-&gt;t_group ) {</a>
<a name="ln583">            ti-&gt;max_num_t_groups = num_atoms/2+1;</a>
<a name="ln584">            if ( ti-&gt;t_group )</a>
<a name="ln585">                inchi_free( ti-&gt;t_group );</a>
<a name="ln586">            ti-&gt;t_group = (T_GROUP *)inchi_calloc( ti-&gt;max_num_t_groups, sizeof(ti-&gt;t_group[0]));</a>
<a name="ln587">        }</a>
<a name="ln588">        /* allocation ti-&gt;tGroupNumber */</a>
<a name="ln589">        if ( ti-&gt;num_t_groups != num_t_groups || !ti-&gt;tGroupNumber ) {</a>
<a name="ln590">            ti-&gt;num_t_groups = num_t_groups;</a>
<a name="ln591">            if ( ti-&gt;tGroupNumber )</a>
<a name="ln592">                inchi_free( ti-&gt;tGroupNumber );</a>
<a name="ln593">            ti-&gt;tGroupNumber = (AT_NUMB *)inchi_calloc((ti-&gt;num_t_groups+1)*TGSO_TOTAL_LEN, sizeof(ti-&gt;tGroupNumber[0]));</a>
<a name="ln594">        }</a>
<a name="ln595">        /* allocation ti-&gt;tGroupNumber */</a>
<a name="ln596">        if ( len_tg != ti-&gt;nNumEndpoints || !ti-&gt;nEndpointAtomNumber ) {</a>
<a name="ln597">            ti-&gt;nNumEndpoints = len_tg;</a>
<a name="ln598">            if ( ti-&gt;nEndpointAtomNumber )</a>
<a name="ln599">                inchi_free( ti-&gt;nEndpointAtomNumber );</a>
<a name="ln600">            ti-&gt;nEndpointAtomNumber = (AT_NUMB *)inchi_calloc(len_tg+1, sizeof(ti-&gt;nEndpointAtomNumber[0]));</a>
<a name="ln601">        }</a>
<a name="ln602">        </a>
<a name="ln603">        </a>
<a name="ln604">        /* check */</a>
<a name="ln605">        if ( !ti-&gt;t_group || !ti-&gt;tGroupNumber || !ti-&gt;nEndpointAtomNumber ) {</a>
<a name="ln606">            ret = RI_ERR_ALLOC;</a>
<a name="ln607">            goto exit_function;</a>
<a name="ln608">        }</a>
<a name="ln609">        tGroupNumber      = ti-&gt;tGroupNumber;</a>
<a name="ln610">        tSymmRank         = tGroupNumber + TGSO_SYMM_RANK   * ti-&gt;num_t_groups;  /*  equivalence; cannot restore */</a>
<a name="ln611">        tiSymmRank        = tGroupNumber + TGSO_SYMM_IRANK  * ti-&gt;num_t_groups;</a>
<a name="ln612">        tiGroupNumber     = tGroupNumber + TGSO_SYMM_IORDER * ti-&gt;num_t_groups;</a>
<a name="ln613"> </a>
<a name="ln614"> </a>
<a name="ln615">        INCHI_HEAPCHK</a>
<a name="ln616">        j = 1; /* index in pInChI-&gt;nTautomer[] */</a>
<a name="ln617">        i = 0; /* index in ti-&gt;nEndpointAtomNumber[] */</a>
<a name="ln618">        for ( itg = 0; itg &lt; pInChI-&gt;nTautomer[0]; itg ++ ) {</a>
<a name="ln619">            len_tg = pInChI-&gt;nTautomer[j]; /* t-group length not including pInChI-&gt;nTautomer[j] */</a>
<a name="ln620">            ti-&gt;t_group[itg].num[0] = pInChI-&gt;nTautomer[j+1]+pInChI-&gt;nTautomer[j+2]; /* num mobile H &amp; (-) */</a>
<a name="ln621">            ti-&gt;t_group[itg].num[1] = pInChI-&gt;nTautomer[j+2]; /* num mobile (-) */</a>
<a name="ln622">            tGroupNumber[itg] = tiGroupNumber[itg] = itg; /* index */</a>
<a name="ln623">            ti-&gt;t_group[itg].nGroupNumber = /*tSymmRank[itg] = tiSymmRank[itg] =*/ itg+1; /* t-group number */</a>
<a name="ln624">            j      += T_GROUP_HDR_LEN;   /* skip t-group header */</a>
<a name="ln625">            len_tg -= T_GROUP_HDR_LEN-1;</a>
<a name="ln626">            </a>
<a name="ln627">            ti-&gt;t_group[itg].nNumEndpoints = len_tg;</a>
<a name="ln628">            ti-&gt;t_group[itg].nFirstEndpointAtNoPos = i;</a>
<a name="ln629"> </a>
<a name="ln630">            for( ; 0 &lt; len_tg --; j ++, i ++ ) {</a>
<a name="ln631">                k = ti-&gt;nEndpointAtomNumber[i] = pInChI-&gt;nTautomer[j]-1;</a>
<a name="ln632">                if ( at ) {</a>
<a name="ln633">                    at[k].endpoint = itg+1;</a>
<a name="ln634">                }</a>
<a name="ln635">                if ( endpoint ) {</a>
<a name="ln636">                    endpoint[k] = itg+1;</a>
<a name="ln637">                }</a>
<a name="ln638">            }</a>
<a name="ln639">        }</a>
<a name="ln640">        if ( i != ti-&gt;nNumEndpoints ) {</a>
<a name="ln641">            ret = RI_ERR_PROGR;</a>
<a name="ln642">        }</a>
<a name="ln643">        INCHI_HEAPCHK</a>
<a name="ln644">    }</a>
<a name="ln645">exit_function:</a>
<a name="ln646">    return ret;</a>
<a name="ln647">}</a>
<a name="ln648">/******************************************************************************************************/</a>
<a name="ln649">int FillOutpStructEndpointFromInChI( INChI *pInChI, AT_NUMB **pEndpoint )</a>
<a name="ln650">{</a>
<a name="ln651">    int num_at = pInChI-&gt;nNumberOfAtoms;</a>
<a name="ln652">    AT_NUMB *endpoint = *pEndpoint;</a>
<a name="ln653">    int     itg, i, j, k, len_tg;</a>
<a name="ln654"> </a>
<a name="ln655">    if ( !endpoint &amp;&amp; !(endpoint = (AT_NUMB*) inchi_malloc(num_at * sizeof(endpoint[0]) ) ) ) {</a>
<a name="ln656">        return RI_ERR_ALLOC;</a>
<a name="ln657">    }</a>
<a name="ln658">    memset( endpoint, 0, num_at * sizeof(endpoint[0]) );</a>
<a name="ln659">    if ( pInChI-&gt;lenTautomer &lt;= 1 || !pInChI-&gt;nTautomer ) {</a>
<a name="ln660">        goto exit_function;</a>
<a name="ln661">    }</a>
<a name="ln662">    j = 1; /* index in pInChI-&gt;nTautomer[] */</a>
<a name="ln663">    i = 0; /* index in ti-&gt;nEndpointAtomNumber[] */</a>
<a name="ln664">    for ( itg = 0; itg &lt; pInChI-&gt;nTautomer[0]; itg ++ ) {</a>
<a name="ln665">        len_tg = pInChI-&gt;nTautomer[j]; /* t-group length not including pInChI-&gt;nTautomer[j] */</a>
<a name="ln666">        j      += T_GROUP_HDR_LEN;   /* skip t-group header */</a>
<a name="ln667">        len_tg -= T_GROUP_HDR_LEN-1;</a>
<a name="ln668">        /* ti-&gt;t_group[itg].nNumEndpoints = len_tg; */</a>
<a name="ln669">        for( ; 0 &lt; len_tg --; j ++, i ++ ) {</a>
<a name="ln670">            k = pInChI-&gt;nTautomer[j]-1;</a>
<a name="ln671">            endpoint[k] = itg+1;</a>
<a name="ln672">        }</a>
<a name="ln673">    }</a>
<a name="ln674">exit_function:</a>
<a name="ln675">    *pEndpoint = endpoint;</a>
<a name="ln676">    return 0;</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">/************************************************************************************/</a>
<a name="ln681">int cmp_charge_val( const void *a1, const void *a2 )</a>
<a name="ln682">{</a>
<a name="ln683">    const CHARGE_VAL *p1 = (const CHARGE_VAL *) a1;</a>
<a name="ln684">    const CHARGE_VAL *p2 = (const CHARGE_VAL *) a2;</a>
<a name="ln685">    int    diff;</a>
<a name="ln686">    </a>
<a name="ln687">    if ( (diff = (int)p1-&gt;nValence - (int)p2-&gt;nValence) )  /* smaller valence first */</a>
<a name="ln688">        return diff;</a>
<a name="ln689">    if ( (diff = abs((int)p1-&gt;nCharge) - abs((int)p2-&gt;nCharge)) ) /* smaller abs charge first */</a>
<a name="ln690">        return diff;</a>
<a name="ln691">    if ( (diff = (int)p2-&gt;nCharge - (int)p1-&gt;nCharge) ) /* (+) first, (-) second */</a>
<a name="ln692">        return diff;</a>
<a name="ln693">    return (int)p1-&gt;nValenceOrderingNumber - (int)p2-&gt;nValenceOrderingNumber;</a>
<a name="ln694">}</a>
<a name="ln695">/************************************************************************************/</a>
<a name="ln696">int bMayBeACationInMobileHLayer( inp_ATOM *at, VAL_AT *pVA, int iat, int bMobileH )</a>
<a name="ln697">{</a>
<a name="ln698">    static const char szEl[] = &quot;N;P;O;S;Se;Te;&quot;;</a>
<a name="ln699">    static const char cVal[] = {4,4,3,3, 3, 3, 0};</a>
<a name="ln700">    static char en[8];</a>
<a name="ln701">    static int  ne;</a>
<a name="ln702">    int    i, j, neigh;</a>
<a name="ln703">    char   *p;</a>
<a name="ln704">    if ( !bMobileH || !at[iat].num_H ) {</a>
<a name="ln705">        return 1;</a>
<a name="ln706">    }</a>
<a name="ln707">    if ( !ne ) { /* one time initialization */</a>
<a name="ln708">        const char *b, *e;</a>
<a name="ln709">        int  len;</a>
<a name="ln710">        char elname[ATOM_EL_LEN];</a>
<a name="ln711">        for ( b = szEl; (e = strchr( b, ';')); b = e+1 ) {</a>
<a name="ln712">            len = e-b;</a>
<a name="ln713">            memcpy( elname, b, len );</a>
<a name="ln714">            elname[len] = '\0';</a>
<a name="ln715">            en[ne++] = get_periodic_table_number( elname );</a>
<a name="ln716">        }</a>
<a name="ln717">        en[ne] = '\0';</a>
<a name="ln718">    }</a>
<a name="ln719">    if ( (p = (char *)memchr( en, at[iat].el_number, ne )) ) {</a>
<a name="ln720">        i = p - en;</a>
<a name="ln721">        /* &gt;B(-)&lt; exception */</a>
<a name="ln722">        if ( at[iat].valence + at[iat].num_H &lt;= cVal[i] ) {</a>
<a name="ln723">            for ( j = 0; j &lt; at[iat].valence; j ++ ) {</a>
<a name="ln724">                neigh = at[iat].neighbor[j];</a>
<a name="ln725">                if ( at[neigh].valence == 4 &amp;&amp; at[neigh].chem_bonds_valence == 4 &amp;&amp; !at[neigh].num_H &amp;&amp;</a>
<a name="ln726">                     pVA[neigh].cNumValenceElectrons == 3 &amp;&amp; pVA[neigh].cPeriodicRowNumber == 1 ) {</a>
<a name="ln727">                    return 1;</a>
<a name="ln728">                }</a>
<a name="ln729">            }</a>
<a name="ln730">            return 0;</a>
<a name="ln731">        }</a>
<a name="ln732">    }</a>
<a name="ln733">    return 1;</a>
<a name="ln734">}</a>
<a name="ln735">/************************************************************************************/</a>
<a name="ln736">int clean_charge_val( CHARGE_VAL *pChargeVal, int len, inp_ATOM *atom, VAL_AT *pVA,</a>
<a name="ln737">                      int iat, int bIsMetal, int bMobileH, AT_NUMB *endpoint )</a>
<a name="ln738">{</a>
<a name="ln739">    inp_ATOM *at      = atom + iat;</a>
<a name="ln740">    int nPeriodicNum  = at-&gt;el_number;</a>
<a name="ln741">    int num_bonds     = at-&gt;valence;</a>
<a name="ln742">    int min_valence   = at-&gt;valence + at-&gt;num_H;</a>
<a name="ln743">    /* in fixed-H case treat tautomeric -O as tautomeric to avoid #O(+) */</a>
<a name="ln744">    int bTautomeric   = (at-&gt;endpoint != 0);</a>
<a name="ln745">    int bFixedHTautomeric = !bMobileH &amp;&amp; (endpoint &amp;&amp; endpoint[iat] &amp;&amp;</a>
<a name="ln746">                            pVA[iat].cNumValenceElectrons == 6 &amp;&amp; 1==num_bonds &amp;&amp;</a>
<a name="ln747">                            !at-&gt;num_H &amp;&amp; !bIsMetal);</a>
<a name="ln748">    /* int bIsMetal      = is_el_a_metal( nPeriodicNum );*/</a>
<a name="ln749">    int bDoNotAddH    = do_not_add_H( nPeriodicNum );</a>
<a name="ln750">    int nPeriod, nNumEqAbsCharges;</a>
<a name="ln751">    int nNumValenceEl = get_sp_element_type( nPeriodicNum, &amp;nPeriod ) - 1;</a>
<a name="ln752"> </a>
<a name="ln753">    int i, j;</a>
<a name="ln754"> </a>
<a name="ln755">    if ( !len )</a>
<a name="ln756">        return len;</a>
<a name="ln757"> </a>
<a name="ln758">    insertions_sort( pChargeVal, len, sizeof(pChargeVal[0]), cmp_charge_val );</a>
<a name="ln759">    /* metals -- very preliminary code */</a>
<a name="ln760">    if ( bIsMetal &amp;&amp; bDoNotAddH ) {</a>
<a name="ln761">        /* keep the 1st found */</a>
<a name="ln762">        return inchi_min( 1, len );</a>
<a name="ln763">    }</a>
<a name="ln764">    /* Mobile-H layer cannot have H on positively charged N, P (all IV), O, S, Se, Te (all III) */</a>
<a name="ln765"> </a>
<a name="ln766">    /*</a>
<a name="ln767">    if ( abs( pChargeVal[0].nCharge ) &gt; 1 &amp;&amp; pChargeVal[0].nValence &gt;= min_valence ) {</a>
<a name="ln768">        return inchi_min( 1, len );</a>
<a name="ln769">    }</a>
<a name="ln770">    */</a>
<a name="ln771">    nNumEqAbsCharges = 0;</a>
<a name="ln772">    for ( i = j = 0; i &lt; len &amp;&amp; j &lt; (nNumEqAbsCharges? 3+nNumEqAbsCharges:4); i ++ ) {</a>
<a name="ln773">        /* for now accept only charge = 0, -1, +1 */</a>
<a name="ln774">        if ( abs( pChargeVal[i].nCharge ) &gt; 1 ) {</a>
<a name="ln775">            continue;</a>
<a name="ln776">        }</a>
<a name="ln777">        if ( BOND_TYPE_TRIPLE + BOND_TYPE_DOUBLE * (min_valence - 1) &lt; pChargeVal[i].nValence ) {</a>
<a name="ln778">            continue; /* not more than one triple and the rest - double bonds per atom */</a>
<a name="ln779">        }</a>
<a name="ln780">        if ( (bTautomeric || (j &amp;&amp; bFixedHTautomeric)) &amp;&amp; pChargeVal[i].nCharge &lt; 0 ) {</a>
<a name="ln781">            continue; /* negative charge must be included in the tautomeric group */</a>
<a name="ln782">        }</a>
<a name="ln783">        if ( (bTautomeric || bFixedHTautomeric) &amp;&amp; pChargeVal[i].nCharge &gt; 0 ) {</a>
<a name="ln784">            continue; /* positive charge for now cannot reach a tautomeric group */</a>
<a name="ln785">        }</a>
<a name="ln786">        if ( j &amp;&amp; !bMayBeACationInMobileHLayer( atom, pVA, iat, bMobileH ) &amp;&amp; pChargeVal[i].nCharge &gt; 0 ) {</a>
<a name="ln787">            if ( i+1 &lt; len &amp;&amp;</a>
<a name="ln788">                 pChargeVal[i].nValence == pChargeVal[i+1].nValence &amp;&amp;</a>
<a name="ln789">                 pChargeVal[i].nCharge == -pChargeVal[i+1].nCharge ) {</a>
<a name="ln790">                /* (-) if exists is always after (+) */</a>
<a name="ln791">                i += 1; /* also skip the next element */</a>
<a name="ln792">            }</a>
<a name="ln793">            continue; /* in case of Mobile-H, a hydrogen cannot be on a (+)-charged heteroatom */</a>
<a name="ln794">        }</a>
<a name="ln795">        /* accept same valence opposite charges only for C and its group in Periodic Table */</a>
<a name="ln796">        if ( j &amp;&amp; !bTautomeric &amp;&amp;</a>
<a name="ln797">             pChargeVal[i].nValence == pChargeVal[j-1].nValence &amp;&amp;</a>
<a name="ln798">             pChargeVal[i].nCharge  == -pChargeVal[j-1].nCharge ) {</a>
<a name="ln799">            if ( nNumValenceEl == VALUE_OCTET/2 &amp;&amp; pChargeVal[i].nCharge &amp;&amp; !nNumEqAbsCharges ) {</a>
<a name="ln800">                pChargeVal[j ++] = pChargeVal[i];</a>
<a name="ln801">                nNumEqAbsCharges ++;</a>
<a name="ln802">            }</a>
<a name="ln803">            continue;</a>
<a name="ln804">        }</a>
<a name="ln805">        /* do not accept valence=5 for neutral NHn in case of not Mobile-H 2005-01-26 ???? */</a>
<a name="ln806">        if ( nNumValenceEl == 5 &amp;&amp; nPeriod == 1 &amp;&amp; at-&gt;num_H &amp;&amp;</a>
<a name="ln807">             j &amp;&amp; !bMobileH &amp;&amp;</a>
<a name="ln808">             pChargeVal[i].nValence == 5 &amp;&amp; !pChargeVal[i].nCharge ) {</a>
<a name="ln809">            continue;</a>
<a name="ln810">        }</a>
<a name="ln811">        /* do not accept gaps in allowed valences */</a>
<a name="ln812">        if ( j &amp;&amp; pChargeVal[i].nValence &gt; pChargeVal[j-1].nValence+1 ) {</a>
<a name="ln813">            break;</a>
<a name="ln814">        }</a>
<a name="ln815">        pChargeVal[j ++] = pChargeVal[i];</a>
<a name="ln816">    }</a>
<a name="ln817">    len = j;</a>
<a name="ln818">    if ( !nNumEqAbsCharges &amp;&amp; num_bonds &lt; 3 &amp;&amp; len == 4 ) {</a>
<a name="ln819">        len --; /* prohibit =S#  where # is a triple bond */</a>
<a name="ln820">    }</a>
<a name="ln821">    return len;</a>
<a name="ln822"> </a>
<a name="ln823"> </a>
<a name="ln824">}</a>
<a name="ln825">/************************************************************************************</a>
<a name="ln826">int GetAtomRestoreInfo( inp_ATOM *atom, int iat, VAL_AT *pVArray )</a>
<a name="ln827"> </a>
<a name="ln828">    pVA-&gt;cDoNotAddH</a>
<a name="ln829">    pVA-&gt;cMetal</a>
<a name="ln830">    pVA-&gt;cNumValenceElectrons</a>
<a name="ln831">    pVA-&gt;cPeriodicRowNumber</a>
<a name="ln832">    pVA-&gt;cInitFreeValences</a>
<a name="ln833">    pVA-&gt;cnListIndex        = index+1</a>
<a name="ln834"> </a>
<a name="ln835">return value:</a>
<a name="ln836">     -1 =&gt; error</a>
<a name="ln837">      0 =&gt; do not know what to do; leave the atom unchanged</a>
<a name="ln838">      1 =&gt; success</a>
<a name="ln839">*************************************************************************************/</a>
<a name="ln840">int GetAtomRestoreInfo( inp_ATOM *atom, int iat, VAL_AT *pVArray, ICHICONST SRM *pSrm, int bMobileH, AT_NUMB *endpoint )</a>
<a name="ln841">{</a>
<a name="ln842">/* #defines from util.c */</a>
<a name="ln843">#define MIN_ATOM_CHARGE        (-2)</a>
<a name="ln844">#define MAX_ATOM_CHARGE         2</a>
<a name="ln845">#define NEUTRAL_STATE          (-MIN_ATOM_CHARGE)  </a>
<a name="ln846">#define NUM_ATOM_CHARGES       (MAX_ATOM_CHARGE - MIN_ATOM_CHARGE + 1)</a>
<a name="ln847">#define MAX_NUM_VALENCES        5  /* max. number + 1 to provide zero termination */</a>
<a name="ln848"> </a>
<a name="ln849">    int i, j, j2, k, k2, charge, cur_charge, num_non_bonding_electrons;</a>
<a name="ln850">    int nNumStates, nNumSelectedStates, num_H, num_bonds;</a>
<a name="ln851">    int nOctetNeutralValenceExcess, nFirstNeutralValenceExcess;</a>
<a name="ln852">    int nFoundNeutralValenceExcess, nFoundNeutralValenceOrdNumber;</a>
<a name="ln853">    int nLastFoundValenceOrdNumber, nLastFoundValenceState;</a>
<a name="ln854">    int cn_bits, cn_bits_array[5], len_cn_bits_array;</a>
<a name="ln855">    inp_ATOM    *at  = atom+iat;</a>
<a name="ln856">    VAL_AT      *pVA = pVArray + iat;</a>
<a name="ln857">    int nPeriodicNum = at-&gt;el_number;</a>
<a name="ln858">    int cur_chem_valence, cur_chem_valence_fixed, min_chem_valence, known_chem_valence;</a>
<a name="ln859">    int metal_bonds_chem_valence, not_metal_bonds_chem_valence, alt_bonds_delta_valence, bonds_chem_valence, bond_type;</a>
<a name="ln860">    CHARGE_VAL  ChargeVal[NUM_ATOM_CHARGES*MAX_NUM_VALENCES];</a>
<a name="ln861"> </a>
<a name="ln862">    memset( ChargeVal, 0, sizeof(ChargeVal) );</a>
<a name="ln863"> </a>
<a name="ln864">    pVA-&gt;cDoNotAddH = do_not_add_H( nPeriodicNum );  /* InChI never adds H to this atom */</a>
<a name="ln865">    /*pVA-&gt;cMetal     = is_el_a_metal( nPeriodicNum );*/ /* the atom is a metal */</a>
<a name="ln866">    </a>
<a name="ln867">    /* count bonds to metal atoms; metals have already been marked */</a>
<a name="ln868">    metal_bonds_chem_valence = not_metal_bonds_chem_valence = alt_bonds_delta_valence = 0;</a>
<a name="ln869">    if ( pVA-&gt;cMetal ) {</a>
<a name="ln870">        j = at-&gt;valence; /* all bonds to metal */</a>
<a name="ln871">        for ( i = k = j2 = k2 = 0; i &lt; at-&gt;valence; i ++ ) {</a>
<a name="ln872">            bond_type = (at-&gt;bond_type[i] &amp; BOND_TYPE_MASK);</a>
<a name="ln873">            if ( bond_type &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln874">                metal_bonds_chem_valence += inchi_max(BOND_TYPE_SINGLE, bond_type);</a>
<a name="ln875">            } else {</a>
<a name="ln876">                metal_bonds_chem_valence += BOND_TYPE_SINGLE;</a>
<a name="ln877">                k ++; /* count alternating bonds */</a>
<a name="ln878">            }</a>
<a name="ln879">        }</a>
<a name="ln880">    } else {</a>
<a name="ln881">        for ( i = j = j2 = k = k2 = 0; i &lt; at-&gt;valence; i ++ ) {</a>
<a name="ln882">            bond_type = (at-&gt;bond_type[i] &amp; BOND_TYPE_MASK);</a>
<a name="ln883">            if ( pVArray[ (int)at-&gt;neighbor[i] ].cMetal ) {</a>
<a name="ln884">                j ++;  /* number of bonds to metal atoms */</a>
<a name="ln885">                if ( bond_type &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln886">                    metal_bonds_chem_valence += inchi_max(BOND_TYPE_SINGLE, bond_type);</a>
<a name="ln887">                } else {</a>
<a name="ln888">                    metal_bonds_chem_valence += BOND_TYPE_SINGLE;</a>
<a name="ln889">                    k ++; /* count alternating bonds */</a>
<a name="ln890">                }</a>
<a name="ln891">            } else {</a>
<a name="ln892">                j2 ++;</a>
<a name="ln893">                if ( bond_type &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln894">                    not_metal_bonds_chem_valence += inchi_max(BOND_TYPE_SINGLE, bond_type);</a>
<a name="ln895">                } else {</a>
<a name="ln896">                    not_metal_bonds_chem_valence += BOND_TYPE_SINGLE;</a>
<a name="ln897">                    k2 ++; /* count alternating bonds */</a>
<a name="ln898">                }</a>
<a name="ln899">            }</a>
<a name="ln900">        }</a>
<a name="ln901">    }</a>
<a name="ln902">    bonds_chem_valence = metal_bonds_chem_valence + not_metal_bonds_chem_valence;</a>
<a name="ln903">    if ( at-&gt;chem_bonds_valence &gt; bonds_chem_valence ) {</a>
<a name="ln904">        if ( at-&gt;chem_bonds_valence - bonds_chem_valence &gt; 1 ) {</a>
<a name="ln905">            at-&gt;chem_bonds_valence = bonds_chem_valence + 1;  /* should not happen */</a>
<a name="ln906">        }</a>
<a name="ln907">        alt_bonds_delta_valence = at-&gt;chem_bonds_valence - bonds_chem_valence;</a>
<a name="ln908">    }</a>
<a name="ln909">   </a>
<a name="ln910">    pVA-&gt;cNumBondsToMetal = j;</a>
<a name="ln911"> </a>
<a name="ln912">    if ( nPeriodicNum == EL_NUMBER_H ) { </a>
<a name="ln913">        /* ignore bridging H; ??? later add ??? */</a>
<a name="ln914">        return 0;</a>
<a name="ln915">    }</a>
<a name="ln916"> </a>
<a name="ln917">    num_H     = at-&gt;num_H;</a>
<a name="ln918">    num_bonds = at-&gt;valence;</a>
<a name="ln919"> </a>
<a name="ln920">    if ( !num_bonds &amp;&amp; !num_H ) {</a>
<a name="ln921">        return 0; /* do not know the answer: isolated atom */</a>
<a name="ln922">    }</a>
<a name="ln923">    /* at the beginning all bonds are single */</a>
<a name="ln924">    min_chem_valence = num_bonds + num_H;</a>
<a name="ln925">    cur_chem_valence = bonds_chem_valence + alt_bonds_delta_valence + num_H; /* includes double &amp; alternating bond contribution */</a>
<a name="ln926"> </a>
<a name="ln927">    /* number of non-bonding electrons in case of all single bonds */</a>
<a name="ln928">    num_non_bonding_electrons = (int)pVA-&gt;cNumValenceElectrons - min_chem_valence;</a>
<a name="ln929">    /* Octet rule: charge = bonds_valence + NumValenceElectrons - 8 */</a>
<a name="ln930">    charge = min_chem_valence + (int)pVA-&gt;cNumValenceElectrons - VALUE_OCTET; /* wrong */</a>
<a name="ln931"> </a>
<a name="ln932">    /* typical (ad hoc) minimal neutral valence */</a>
<a name="ln933">    known_chem_valence = ( pVA-&gt;cNumValenceElectrons &gt; VALUE_OCTET/2 )? </a>
<a name="ln934">                                VALUE_OCTET - pVA-&gt;cNumValenceElectrons :</a>
<a name="ln935">                                pVA-&gt;cNumValenceElectrons;</a>
<a name="ln936">    /* excess of typical valence over all-single-bonds valence */</a>
<a name="ln937">    nOctetNeutralValenceExcess = known_chem_valence - min_chem_valence;</a>
<a name="ln938">    /*  (NB=num.bonds, NV=neutral valence, NVX=neutral valence excess, LFVS=last found valence state, val.=valence)</a>
<a name="ln939"> </a>
<a name="ln940">       element NB  knownFst octet Last  octetNVX  firstNVX foundNVX chargeLFVS  LFVS</a>
<a name="ln941">                   valence  val.  NV&gt;=                                 </a>
<a name="ln942">                                                                     </a>
<a name="ln943">       -B       1    3        3    3        2         2   =     2        +2      </a>
<a name="ln944">       &gt;B       2    3        3    3        1         1   =     1        +1</a>
<a name="ln945">       &gt;B-      3    3        3    3        0         0   =     0         0</a>
<a name="ln946">       &gt;B&lt;      4    3        3    3       -1        -1   &lt;&gt;   N/A       -1</a>
<a name="ln947">                                                                      </a>
<a name="ln948">       -C       1    4        4    4        3         3   =     3        N/A</a>
<a name="ln949">       &gt;C       2    4        4    4        2         2   =     2        +2  (-2)</a>
<a name="ln950">       &gt;C-      3    4        4    4        1         1   =     1        +1  (-1)</a>
<a name="ln951">       &gt;C&lt;      4    4        4    4        0         0   =     0         0</a>
<a name="ln952">       C(V)     5    4        4    N/A     -1        -1   &lt;&gt;   N/A       N/A</a>
<a name="ln953">                                                                     </a>
<a name="ln954">       -Si      1    4        4    4        3         3   =     3        N/A</a>
<a name="ln955">       &gt;Si      2    4        4    4        2         2   =     2        +2  (-2)</a>
<a name="ln956">       &gt;Si-     3    4        4    4        1         1   =     1        +1  (-1)</a>
<a name="ln957">       &gt;Si-     4    4        4    4        0         0   =     0         0</a>
<a name="ln958">       Si(V)    5    4        4    N/A     -1        -1   &lt;&gt;   N/A       -1 </a>
<a name="ln959">                                                                     </a>
<a name="ln960">       -N       1    3        3    3        2         2   =     2        -2</a>
<a name="ln961">       &gt;N       2    3        3    3        1         1   =     1        -1</a>
<a name="ln962">       &gt;N-      3    3        3    3        0         0   =     0         0  (+2)</a>
<a name="ln963">       &gt;N&lt;      4    3        3    5       -1        -1   &lt;&gt;    1        +1</a>
<a name="ln964">       N(V)     5    3        3    5       -2        -2   &lt;&gt;    0         0</a>
<a name="ln965">       N(VI)    6    3        3    N/A     -3        -3   &lt;&gt;   N/A       N/A</a>
<a name="ln966">       N(VII)   7    3        3    N/A     -4        -4   &lt;&gt;   N/A       N/A</a>
<a name="ln967"> </a>
<a name="ln968">       -P       1    3        3    3        2         2   =     2        -2</a>
<a name="ln969">       &gt;P       2    3        3    3        1         1   =     1        -1</a>
<a name="ln970">       &gt;P-      3    3        3    3        0         0   =     0         0  (-2, +2)</a>
<a name="ln971">       &gt;P&lt;      4    3        3    5       -1        -1   &lt;&gt;    1        +1  (-1)</a>
<a name="ln972">       P(V)     5    3        3    5       -2        -2   &lt;&gt;    0         0  (-2)</a>
<a name="ln973">       P(VI)    6    3        3    N/A     -3        -3   &lt;&gt;   N/A       -1</a>
<a name="ln974">       P(VII)   7    3        3    N/A     -4        -4   &lt;&gt;   N/A       -2</a>
<a name="ln975">       P(VIII)  8    3        3    N/A     -5        -5   &lt;&gt;   N/A       N/A</a>
<a name="ln976"> </a>
<a name="ln977">       -O       1    2        2    2        1         1   =     1        -1</a>
<a name="ln978">       &gt;O       2    2        2    2        0         0   =     0         0</a>
<a name="ln979">       &gt;O-      3    2        2    N/A     -1        -1   &lt;&gt;   N/A       +1</a>
<a name="ln980">       &gt;O&lt;      4    2        2    N/A     -2        -2   &lt;&gt;   N/A       +2</a>
<a name="ln981">       O(V)     5    2        2    N/A     -3        -3   &lt;&gt;   N/A       +1</a>
<a name="ln982">       O(VI)    6    2        2    N/A     -4        -4   &lt;&gt;   N/A       N/A</a>
<a name="ln983"> </a>
<a name="ln984">       -S       1    2        2    2        1         1   =     1        -1</a>
<a name="ln985">       &gt;S       2    2        2    2        0         0   =     0         0       NPNP - prohibit</a>
<a name="ln986">       &gt;S-      3    2        2    4       -1        -1   &lt;&gt;    1        +1  (-1) PNPN</a>
<a name="ln987">       &gt;S&lt;      4    2        2    4       -2        -2   &lt;&gt;    0         0  (+2)</a>
<a name="ln988">       S(V)     5    2        2    6       -3        -3   &lt;&gt;    1        +1  (-1)</a>
<a name="ln989">       S(VI)    6    2        2    6       -4        -4   &lt;&gt;    0         0 </a>
<a name="ln990">       S(VII)   7    2        2    N/A     -5        -5   &lt;&gt;    0        -1 </a>
<a name="ln991">       S(VIII)  8    2        2    N/A     -6        -6   &lt;&gt;   N/A       N/A</a>
<a name="ln992"> </a>
<a name="ln993">       -F       1    1        1    1        0         0   =     0         0</a>
<a name="ln994">       &gt;F       2    1        1    1       -1        -1   &lt;&gt;   N/A       +1</a>
<a name="ln995">       &gt;F-      3    1        1    1       -2        -2   &lt;&gt;   N/A       +2</a>
<a name="ln996">       &gt;F&lt;      4    1        1    1       -3        -3   &lt;&gt;   N/A       N/A</a>
<a name="ln997">       F(V)     5    1        1    1       -4        -4   &lt;&gt;   N/A       +2</a>
<a name="ln998">       F(VI)    6    1        1    1       -5        -5   &lt;&gt;   N/A       N/A</a>
<a name="ln999"> </a>
<a name="ln1000">       -Cl      1    1        1    1        0         0   =     0         0      NPNP - prohibit</a>
<a name="ln1001">       &gt;Cl      2    1        1    3       -1        -1   &lt;&gt;    1        +1      PNPN - prohibit</a>
<a name="ln1002">       &gt;Cl-     3    1        1    3       -2        -2   &lt;&gt;    0         0 (+2) NPNP</a>
<a name="ln1003">       &gt;Cl&lt;     4    1        1    5       -3        -3   &lt;&gt;    1        +1      PNPN</a>
<a name="ln1004">       Cl(V)    5    1        1    5       -4        -4   &lt;&gt;    0         0</a>
<a name="ln1005">       Cl(VI)   6    1        1    7       -5        -5   &lt;&gt;    1        +1 </a>
<a name="ln1006">       Cl(VII)  7    1        1    7       -6        -6   &lt;&gt;    0         0</a>
<a name="ln1007">       Cl(VIII) 8    1        1    N/A     -7        -7   &lt;&gt;   N/A       N/A</a>
<a name="ln1008">       </a>
<a name="ln1009"> </a>
<a name="ln1010">      NB                 = num_bonds+num_H</a>
<a name="ln1011"> </a>
<a name="ln1012">      knownFst valence   = nFirstNeutralValenceExcess + min_chem_valence</a>
<a name="ln1013">      octet val.         = nOctetNeutralValenceExcess + min_chem_valence</a>
<a name="ln1014">      Last NV&gt;=          = nFoundNeutralValenceExcess + min_chem_valence</a>
<a name="ln1015"> </a>
<a name="ln1016">      octetNVX           = nOctetNeutralValenceExcess</a>
<a name="ln1017">      firstNVX           = nFirstNeutralValenceExcess</a>
<a name="ln1018">      foundNVX           = nFoundNeutralValenceExcess</a>
<a name="ln1019"> </a>
<a name="ln1020">      chargeLFVS         = ChargeVal[nLastFoundValenceState].nCharge</a>
<a name="ln1021"> </a>
<a name="ln1022">    */</a>
<a name="ln1023">    /* minimal known neutral atom valence; different for Sn(2/4), Tl(1/3), Pb(2/4): (known/typical ad hoc) */</a>
<a name="ln1024">    known_chem_valence = get_el_valence( nPeriodicNum, 0, 0 );</a>
<a name="ln1025"> </a>
<a name="ln1026">    if ( pSrm-&gt;bMetalAddFlower ) {</a>
<a name="ln1027">        /* bond orders of bonds to metal may be as they are (pSrm-&gt;nMetalInitBondOrder==1)</a>
<a name="ln1028">                                        or decreased by one (pSrm-&gt;nMetalInitBondOrder==0)</a>
<a name="ln1029">           nMetalInitBondOrder == nMetalMinBondOrder + nMetalInitEdgeFlow</a>
<a name="ln1030">        */</a>
<a name="ln1031">        cur_chem_valence_fixed = cur_chem_valence - pVA-&gt;cNumBondsToMetal * (1-pSrm-&gt;nMetalInitBondOrder);</a>
<a name="ln1032">        pVA-&gt;cInitOrigValenceToMetal = metal_bonds_chem_valence;</a>
<a name="ln1033">        pVA-&gt;cInitValenceToMetal = metal_bonds_chem_valence - pVA-&gt;cNumBondsToMetal * (1-pSrm-&gt;nMetalInitBondOrder);</a>
<a name="ln1034">        pVA-&gt;cInitFlowToMetal  = pVA-&gt;cInitValenceToMetal - pVA-&gt;cNumBondsToMetal * pSrm-&gt;nMetalMinBondOrder;</a>
<a name="ln1035">        if ( pVA-&gt;cMetal ) {</a>
<a name="ln1036">            pVA-&gt;cInitFreeValences += alt_bonds_delta_valence;</a>
<a name="ln1037">        }</a>
<a name="ln1038">        if ( pSrm-&gt;nMetalInitEdgeFlow &lt; pSrm-&gt;nMetalInitBondOrder - pSrm-&gt;nMetalMinBondOrder ) {</a>
<a name="ln1039">            /* single bond has zero initial flow + 2 radicals at incident atoms */</a>
<a name="ln1040">            if ( pVA-&gt;cInitFlowToMetal &lt;= pVA-&gt;cNumBondsToMetal ) {</a>
<a name="ln1041">                if ( pVA-&gt;cMetal ) {</a>
<a name="ln1042">                    pVA-&gt;cInitFreeValences += pVA-&gt;cInitFlowToMetal;</a>
<a name="ln1043">                }</a>
<a name="ln1044">                pVA-&gt;cInitFlowToMetal = 0;</a>
<a name="ln1045">            } else {</a>
<a name="ln1046">                if ( pVA-&gt;cMetal ) {</a>
<a name="ln1047">                    pVA-&gt;cInitFreeValences += pVA-&gt;cNumBondsToMetal * (1 - pSrm-&gt;nMetalInitEdgeFlow);</a>
<a name="ln1048">                }</a>
<a name="ln1049">                pVA-&gt;cInitFlowToMetal -= pVA-&gt;cNumBondsToMetal * (1 - pSrm-&gt;nMetalInitEdgeFlow);</a>
<a name="ln1050">            }</a>
<a name="ln1051">        }</a>
<a name="ln1052">             </a>
<a name="ln1053">    } else {</a>
<a name="ln1054">        /* treat metal atoms as ordinary non-metal atoms */</a>
<a name="ln1055">        cur_chem_valence_fixed = cur_chem_valence;</a>
<a name="ln1056">        pVA-&gt;cInitFlowToMetal  = metal_bonds_chem_valence - pVA-&gt;cNumBondsToMetal;</a>
<a name="ln1057">        pVA-&gt;cInitValenceToMetal = metal_bonds_chem_valence;</a>
<a name="ln1058">        pVA-&gt;cInitOrigValenceToMetal = metal_bonds_chem_valence;</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061"> </a>
<a name="ln1062">    if ( pVA-&gt;cMetal &amp;&amp; pSrm-&gt;bMetalAddFlower ) {</a>
<a name="ln1063">        pVA-&gt;cnListIndex = cnListIndexMe + 1;</a>
<a name="ln1064">        /*</a>
<a name="ln1065">        pVA-&gt;cInitOrigValenceToMetal += alt_bonds_delta_valence;</a>
<a name="ln1066">        pVA-&gt;cInitValenceToMetal     += alt_bonds_delta_valence;</a>
<a name="ln1067">        pVA-&gt;cInitFreeValences = (pSrm-&gt;nMetalInitBondOrder + alt_bonds_delta_valence</a>
<a name="ln1068">                                 - (pSrm-&gt;nMetalMinBondOrder + pSrm-&gt;nMetalInitEdgeFlow)) * pVA-&gt;cNumBondsToMetal;</a>
<a name="ln1069">        */</a>
<a name="ln1070">        return 0;  /* metal */</a>
<a name="ln1071">    }</a>
<a name="ln1072"> </a>
<a name="ln1073">    if ( !known_chem_valence ) {</a>
<a name="ln1074">        /* a noble gas like He, Ne, ... */</a>
<a name="ln1075">        pVA-&gt;cInitFreeValences = at-&gt;chem_bonds_valence - at-&gt;valence;</a>
<a name="ln1076">        return TREAT_ATOM_AS_METAL; /* do not know anything about this atom; needs 2nd pass */</a>
<a name="ln1077">    }</a>
<a name="ln1078"> </a>
<a name="ln1079">    nFirstNeutralValenceExcess = known_chem_valence - min_chem_valence;</a>
<a name="ln1080">    </a>
<a name="ln1081">    nFoundNeutralValenceExcess    = NO_VALUE_INT;</a>
<a name="ln1082">    nFoundNeutralValenceOrdNumber = NO_VALUE_INT;</a>
<a name="ln1083">    nLastFoundValenceOrdNumber    = NO_VALUE_INT;</a>
<a name="ln1084">    nLastFoundValenceState        = NO_VALUE_INT;</a>
<a name="ln1085">    </a>
<a name="ln1086">    /* find the lowest known valence &gt;= all-single-bonds valence */</a>
<a name="ln1087">    for ( cur_charge = MIN_ATOM_CHARGE, nNumStates = 0; cur_charge &lt;= MAX_ATOM_CHARGE; cur_charge ++ ) {</a>
<a name="ln1088">        for ( i = 0; i &lt; MAX_NUM_VALENCES; i ++ ) {</a>
<a name="ln1089">            known_chem_valence = get_el_valence( nPeriodicNum, cur_charge, i );</a>
<a name="ln1090">            if ( cur_chem_valence_fixed &gt; known_chem_valence || !known_chem_valence ) {</a>
<a name="ln1091">                continue; /* known valence &lt; all-single-bonds valence */</a>
<a name="ln1092">            }</a>
<a name="ln1093">            if ( BOND_TYPE_TRIPLE + BOND_TYPE_DOUBLE * (num_bonds - 1) + num_H &lt; known_chem_valence ) {</a>
<a name="ln1094">                continue; /* not more than one triple and the rest - double bonds per atom */</a>
<a name="ln1095">            }</a>
<a name="ln1096">            /* keep all found */</a>
<a name="ln1097">            ChargeVal[nNumStates].nValence               = known_chem_valence;</a>
<a name="ln1098">            ChargeVal[nNumStates].nCharge                = cur_charge;</a>
<a name="ln1099">            ChargeVal[nNumStates].nValenceOrderingNumber = i;</a>
<a name="ln1100">            if ( !cur_charge &amp;&amp; nFoundNeutralValenceExcess == NO_VALUE_INT ) {</a>
<a name="ln1101">                /* neutral state; compare to the lowest typical valence */</a>
<a name="ln1102">                nFoundNeutralValenceExcess    = known_chem_valence - min_chem_valence;</a>
<a name="ln1103">                nFoundNeutralValenceOrdNumber = i;</a>
<a name="ln1104">            }</a>
<a name="ln1105">            if ( min_chem_valence == known_chem_valence ) {</a>
<a name="ln1106">                if ( nLastFoundValenceState == NO_VALUE_INT ) {</a>
<a name="ln1107">                    /* accept the first found */</a>
<a name="ln1108">                    nLastFoundValenceState = nNumStates;</a>
<a name="ln1109">                } else</a>
<a name="ln1110">                if ( abs( ChargeVal[nLastFoundValenceState].nCharge )  &gt;= abs( cur_charge ) ) {</a>
<a name="ln1111">                    /* accept smaller abs(charge); if abs(charges) are same, accept (+) */</a>
<a name="ln1112">                    nLastFoundValenceState = nNumStates;</a>
<a name="ln1113">                }</a>
<a name="ln1114">            }</a>
<a name="ln1115">            nNumStates ++;</a>
<a name="ln1116">        }</a>
<a name="ln1117">    }</a>
<a name="ln1118">    /***********************************************************************************/</a>
<a name="ln1119">    /* select only appropriate charge &amp; valence so that a suitable ChargeStruct exists */</a>
<a name="ln1120">    /***********************************************************************************/</a>
<a name="ln1121"> </a>
<a name="ln1122">    nNumSelectedStates = clean_charge_val( ChargeVal, nNumStates, atom, pVArray, iat, pVA-&gt;cMetal, bMobileH, endpoint );</a>
<a name="ln1123"> </a>
<a name="ln1124">    if ( !nNumSelectedStates ) {</a>
<a name="ln1125">        return TREAT_ATOM_AS_METAL; /* nothing to do */</a>
<a name="ln1126">    }</a>
<a name="ln1127">    /***********************************************************************************/</a>
<a name="ln1128">    /*       Find an appropriate ChargeStruct index for the ChargeVal found            */</a>
<a name="ln1129">    /***********************************************************************************/</a>
<a name="ln1130">    cn_bits = 0;</a>
<a name="ln1131">    memset( cn_bits_array, 0, sizeof(cn_bits_array) );</a>
<a name="ln1132">    /***** set bits identifying a suitable ChargeStruct ******/ </a>
<a name="ln1133">    for ( i = len_cn_bits_array = 0; i &lt; nNumSelectedStates &amp;&amp; len_cn_bits_array &lt; 4; i ++ ) {</a>
<a name="ln1134">        switch( ChargeVal[i].nCharge ) {</a>
<a name="ln1135">        case -1:</a>
<a name="ln1136">            cn_bits_array[len_cn_bits_array] |= cn_bits_M; /* Minus 1 */</a>
<a name="ln1137">            break;</a>
<a name="ln1138">        case 0:</a>
<a name="ln1139">            cn_bits_array[len_cn_bits_array] |= cn_bits_N; /* Neutral */</a>
<a name="ln1140">            break;</a>
<a name="ln1141">        case 1:</a>
<a name="ln1142">            cn_bits_array[len_cn_bits_array] |= cn_bits_P; /* Plus 1 */</a>
<a name="ln1143">            break;</a>
<a name="ln1144">        default:</a>
<a name="ln1145">            return RI_ERR_PROGR; /* program error */</a>
<a name="ln1146">        }</a>
<a name="ln1147">        if ( i+1 &lt; nNumSelectedStates &amp;&amp;</a>
<a name="ln1148">             ChargeVal[i].nValence == ChargeVal[i+1].nValence &amp;&amp;</a>
<a name="ln1149">             ChargeVal[i].nCharge &amp;&amp;</a>
<a name="ln1150">             ChargeVal[i].nCharge == -ChargeVal[i+1].nCharge ) {</a>
<a name="ln1151">            ; /* add opposite charge to the same element of cn_bits_array[] */</a>
<a name="ln1152">        } else {</a>
<a name="ln1153">            len_cn_bits_array ++;</a>
<a name="ln1154">        }</a>
<a name="ln1155">    }</a>
<a name="ln1156">    if ( !len_cn_bits_array || len_cn_bits_array &gt; 4 ) {</a>
<a name="ln1157">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln1158">    }</a>
<a name="ln1159">    /* accommodate added 4-state ChargeStruct: +/- cannot be in case of 4 states */</a>
<a name="ln1160">    if ( len_cn_bits_array + 1 == nNumSelectedStates &amp;&amp; nNumSelectedStates == 4 ) {</a>
<a name="ln1161">        len_cn_bits_array --;</a>
<a name="ln1162">        nNumSelectedStates --;</a>
<a name="ln1163">        cn_bits_array[len_cn_bits_array] = 0;</a>
<a name="ln1164">    }</a>
<a name="ln1165">    /* fix for terminal hydrogenless -C as in isocyano or CO: there is no just cnE_[] ChargeStruct */</a>
<a name="ln1166">    </a>
<a name="ln1167">    if ( len_cn_bits_array == 1 &amp;&amp;</a>
<a name="ln1168">         cn_bits_array[0] == (cn_bits_P | cn_bits_M) &amp;&amp;</a>
<a name="ln1169">         ChargeVal[0].nValence + 1 &gt; BOND_TYPE_TRIPLE + BOND_TYPE_DOUBLE * (num_bonds - 1) + num_H ) {</a>
<a name="ln1170">        cn_bits_array[len_cn_bits_array ++] = cn_bits_N;</a>
<a name="ln1171">        ChargeVal[nNumSelectedStates].nValence = ChargeVal[nNumSelectedStates-1].nValence;</a>
<a name="ln1172">        ChargeVal[nNumSelectedStates].nCharge  = 0;</a>
<a name="ln1173">        ChargeVal[nNumSelectedStates].nValenceOrderingNumber = 0;</a>
<a name="ln1174">    }</a>
<a name="ln1175">    </a>
<a name="ln1176">make_cn_bits:</a>
<a name="ln1177">    cn_bits = MAKE_CN_BITS(cn_bits_array[0], cn_bits_array[1], cn_bits_array[2], cn_bits_array[3]);</a>
<a name="ln1178">    /*********** find ChargeStructure **************/</a>
<a name="ln1179">    for ( i = 0, j = -1; i &lt; cnListNumEl; i ++ ) {</a>
<a name="ln1180">        if ( cnList[i].bits == cn_bits ) {</a>
<a name="ln1181">            j = i;</a>
<a name="ln1182">            break; /* found */</a>
<a name="ln1183">        }</a>
<a name="ln1184">    }</a>
<a name="ln1185">    if ( j &lt; 0 ) {</a>
<a name="ln1186">        /* ChargeStructure was not found */</a>
<a name="ln1187">        if ( 1 &lt; len_cn_bits_array &amp;&amp; len_cn_bits_array + 1 == nNumSelectedStates ) {</a>
<a name="ln1188">            /* a pair of opposite charges was combined */</a>
<a name="ln1189">            len_cn_bits_array --;</a>
<a name="ln1190">            cn_bits_array[len_cn_bits_array] = 0;</a>
<a name="ln1191">            goto make_cn_bits;</a>
<a name="ln1192">        } else</a>
<a name="ln1193">        if ( nNumSelectedStates == 4 ) {</a>
<a name="ln1194">            /* reduce number of states */</a>
<a name="ln1195">            len_cn_bits_array --;</a>
<a name="ln1196">            cn_bits_array[len_cn_bits_array] = 0;</a>
<a name="ln1197">            nNumSelectedStates --;</a>
<a name="ln1198">            goto make_cn_bits;</a>
<a name="ln1199">        }</a>
<a name="ln1200">        return RI_ERR_PROGR; /* charge structure not found */</a>
<a name="ln1201">    }</a>
<a name="ln1202">    /********** ChargeStructure has been found **********/</a>
<a name="ln1203">    pVA-&gt;cnListIndex = j+1; /* charge structure index + 1 */</a>
<a name="ln1204">    pVA-&gt;cInitCharge = cnList[j].nInitialCharge;</a>
<a name="ln1205">    /********** Calculate &quot;Free Valence&quot; ****************/</a>
<a name="ln1206">#if ( ALLOW_METAL_BOND_ZERO == 1 )</a>
<a name="ln1207"> </a>
<a name="ln1208">#if ( INIT_METAL_BOND_ZERO == 1 )</a>
<a name="ln1209">    if ( pVA-&gt;cMetal ) {</a>
<a name="ln1210">        j = 0;</a>
<a name="ln1211">    } else {</a>
<a name="ln1212">        j = ChargeVal[0].nValence - cur_chem_valence_fixed;</a>
<a name="ln1213">    }</a>
<a name="ln1214">#else</a>
<a name="ln1215">    j = ChargeVal[0].nValence - cur_chem_valence_fixed;</a>
<a name="ln1216">#endif</a>
<a name="ln1217"> </a>
<a name="ln1218">#else</a>
<a name="ln1219">    j = ChargeVal[0].nValence - cur_chem_valence_fixed;</a>
<a name="ln1220">#endif</a>
<a name="ln1221">    if ( j &lt; 0 ) {</a>
<a name="ln1222">        return RI_ERR_PROGR; /* program error */</a>
<a name="ln1223">    }</a>
<a name="ln1224">    pVA-&gt;cInitFreeValences = j; /* number of initial unsatisfied valences; should be combined with */</a>
<a name="ln1225">                                /* (cap - flow) of vertex=0 in the charge structure[pVA-&gt;cnListIndex-1] */ </a>
<a name="ln1226">    return 1; /* success */</a>
<a name="ln1227"> </a>
<a name="ln1228">#undef MIN_ATOM_CHARGE </a>
<a name="ln1229">#undef MAX_ATOM_CHARGE </a>
<a name="ln1230">#undef NEUTRAL_STATE   </a>
<a name="ln1231">#undef NUM_ATOM_CHARGES</a>
<a name="ln1232">#undef MAX_NUM_VALENCES</a>
<a name="ln1233"> </a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236"> </a>
<a name="ln1237">#ifdef NEVER</a>
<a name="ln1238">/******************************************************************************************************/</a>
<a name="ln1239">int get_bonds_valences( int nPeriodicNum, int bonds_valence, int num_H, VAL_AT *pVA )</a>
<a name="ln1240">{</a>
<a name="ln1241">    int i, j, charge, chem_valence, known_chem_valence;</a>
<a name="ln1242">#define MAX_NUM_VALENCES 5  /* defined in util.c */</a>
<a name="ln1243"> </a>
<a name="ln1244">    memset( pVA, 0, sizeof( pVA[0] ) );</a>
<a name="ln1245">    </a>
<a name="ln1246">    if ( !bonds_valence &amp;&amp; !num_H )</a>
<a name="ln1247">        return 0; /* do not know the answer */</a>
<a name="ln1248">    </a>
<a name="ln1249">    chem_valence = bonds_valence + num_H;</a>
<a name="ln1250">    for ( charge = VAL_MIN_CHARGE; charge &lt;= VAL_MAX_CHARGE; charge ++ ) {</a>
<a name="ln1251">        for ( i = 0, j = 0; i &lt; MAX_NUM_VALENCES, j &lt; VAL_NUMBER; i ++ ) {</a>
<a name="ln1252">            if ( chem_valence &lt;= (known_chem_valence = get_el_valence( nPeriodicNum, charge, i ) ) ) {</a>
<a name="ln1253">                if ( !charge ) {</a>
<a name="ln1254">                    pVA-&gt;cValence[j][VAL_NEUTR_ORDER] = i+1;</a>
<a name="ln1255">                }</a>
<a name="ln1256">                pVA-&gt;cValence[j++][charge+VAL_BASE] = known_chem_valence - num_H;</a>
<a name="ln1257">            }</a>
<a name="ln1258">        }</a>
<a name="ln1259">    }</a>
<a name="ln1260">    pVA-&gt;cDoNotAddH = do_not_add_H( nPeriodicNum );</a>
<a name="ln1261">    pVA-&gt;cMetal     = is_el_a_metal( nPeriodicNum );</a>
<a name="ln1262">    return pVA-&gt;cValence[0][VAL_BASE];  /* 0 means do not know the answer */</a>
<a name="ln1263">#undef MAX_NUM_VALENCES</a>
<a name="ln1264">}</a>
<a name="ln1265">#endif</a>
<a name="ln1266">/*********** calculate s or p-element type ************/</a>
<a name="ln1267">int get_sp_element_type( int nPeriodicNumber, int *nRow )</a>
<a name="ln1268">/* </a>
<a name="ln1269">                                                num  el</a>
<a name="ln1270">                                                el   neg</a>
<a name="ln1271">   1 =&gt; H                          ATYPE_H   1    1  21</a>
<a name="ln1272">   2 =&gt; Li, Na, K,  Rb, Cs, Fr     ATYPE_Na  2    1  10 09 08 08 07 </a>
<a name="ln1273">   3 =&gt; Be, Mg, Ca, Sr, Ba, Ra     ATYPE_Mg  3    2  15 12 10 10 09</a>
<a name="ln1274">   4 =&gt; B,  Al, Ga, In, Tl         ATYPE_B   4    3  20 15 18 17 18</a>
<a name="ln1275">   5 =&gt; C,  Si, Ge, Sn, Pb         ATYPE_C   5    4  25 18 18 18 18 </a>
<a name="ln1276">   6 =&gt; N,  P,  As, Sb, Bi         ATYPE_N   6    5  30 21 20 19 19</a>
<a name="ln1277">   7 =&gt; O,  S,  Se, Te, Po         ATYPE_O   7    6  35 25 24 21 20</a>
<a name="ln1278">   8 =&gt; F,  Cl, Br, I,  At         ATYPE_Cl  8    7  40 30 28 25 22</a>
<a name="ln1279"> </a>
<a name="ln1280">number of valence electrons = (type&gt;1)? type-1: type</a>
<a name="ln1281"> </a>
<a name="ln1282">  */</a>
<a name="ln1283">{</a>
<a name="ln1284">    int row = 0, type = 0;</a>
<a name="ln1285">    if ( nPeriodicNumber == 1 ) {</a>
<a name="ln1286">        type = 1; /* H: 1 */</a>
<a name="ln1287">        row  = 0;</a>
<a name="ln1288">    } else</a>
<a name="ln1289">    if ( nPeriodicNumber == 2 ) {</a>
<a name="ln1290">        type = 0; row = 0;</a>
<a name="ln1291">    } else</a>
<a name="ln1292">    if ( nPeriodicNumber &lt;= 10 ) {</a>
<a name="ln1293">        /* Li: 2, Be: 3, B: 4, C: 5, N: 6, O: 7, F: 8, Ne: 9; later subtract 1 */</a>
<a name="ln1294">        type = nPeriodicNumber-1; row = 1;</a>
<a name="ln1295">    } else</a>
<a name="ln1296">    if ( nPeriodicNumber &lt;= 18 ) {</a>
<a name="ln1297">        type = nPeriodicNumber - 9; row = 2;</a>
<a name="ln1298">    } else</a>
<a name="ln1299">    if ( nPeriodicNumber &lt;= 20 ) {</a>
<a name="ln1300">        type = nPeriodicNumber - 17; row = 3;</a>
<a name="ln1301">    } else</a>
<a name="ln1302">    if ( nPeriodicNumber &lt;= 30 ) {</a>
<a name="ln1303">        type = 0; row = 3;</a>
<a name="ln1304">    } else</a>
<a name="ln1305">    if ( nPeriodicNumber &lt;= 36 ) {</a>
<a name="ln1306">        type = nPeriodicNumber - 27; row = 3;</a>
<a name="ln1307">    } else</a>
<a name="ln1308">    if ( nPeriodicNumber &lt;= 38 ) {</a>
<a name="ln1309">        type = nPeriodicNumber - 35; row = 4;</a>
<a name="ln1310">    } else</a>
<a name="ln1311">    if ( nPeriodicNumber &lt;= 48 ) {</a>
<a name="ln1312">        type = 0; row = 4;</a>
<a name="ln1313">    } else</a>
<a name="ln1314">    if ( nPeriodicNumber &lt;= 54 ) {</a>
<a name="ln1315">        type = nPeriodicNumber - 45; row = 4;</a>
<a name="ln1316">    } else</a>
<a name="ln1317">    if ( nPeriodicNumber &lt;= 56 ) {</a>
<a name="ln1318">        type = nPeriodicNumber - 53; row = 5;</a>
<a name="ln1319">    } else</a>
<a name="ln1320">    if ( nPeriodicNumber &lt;= 80 ) {</a>
<a name="ln1321">        type = 0; row = 5;</a>
<a name="ln1322">    } else</a>
<a name="ln1323">    if ( nPeriodicNumber &lt;= 86 ) {</a>
<a name="ln1324">        type = nPeriodicNumber - 77; row = 5;</a>
<a name="ln1325">    } else</a>
<a name="ln1326">    if ( nPeriodicNumber &lt;= 88 ) {</a>
<a name="ln1327">        type = nPeriodicNumber - 85; row = 6;</a>
<a name="ln1328">    } else {</a>
<a name="ln1329">        type = 0; row = 6;</a>
<a name="ln1330">    }</a>
<a name="ln1331">    *nRow = row;</a>
<a name="ln1332">    return type==9? 0 : type;</a>
<a name="ln1333">}</a>
<a name="ln1334">/******************************************************************************************************/</a>
<a name="ln1335">int ReallocTCGroups( ALL_TC_GROUPS *pTCGroups, int nAdd )</a>
<a name="ln1336">{</a>
<a name="ln1337">    TC_GROUP *pTCGroup = (TC_GROUP *) inchi_malloc( sizeof(pTCGroup[0])*(pTCGroups-&gt;max_tc_groups + nAdd) );</a>
<a name="ln1338">    if ( pTCGroup ) {</a>
<a name="ln1339">        if ( pTCGroups-&gt;num_tc_groups ) {</a>
<a name="ln1340">            memcpy( pTCGroup, pTCGroups-&gt;pTCG, sizeof(pTCGroup[0])*pTCGroups-&gt;num_tc_groups );</a>
<a name="ln1341">        }</a>
<a name="ln1342">        memset( pTCGroup + pTCGroups-&gt;max_tc_groups, 0, sizeof(pTCGroup[0])*nAdd );</a>
<a name="ln1343">        if ( pTCGroups-&gt;pTCG ) {</a>
<a name="ln1344">            inchi_free( pTCGroups-&gt;pTCG );</a>
<a name="ln1345">        }</a>
<a name="ln1346">        pTCGroups-&gt;pTCG = pTCGroup;</a>
<a name="ln1347">        pTCGroups-&gt;max_tc_groups += nAdd;</a>
<a name="ln1348">        return 0;</a>
<a name="ln1349">    }</a>
<a name="ln1350">    return RI_ERR_ALLOC;</a>
<a name="ln1351">}</a>
<a name="ln1352">/******************************************************************************************************/</a>
<a name="ln1353">int RegisterTCGroup( ALL_TC_GROUPS *pTCGroups, int nGroupType, int nGroupOrdNum,</a>
<a name="ln1354">                     int nVertexCap, int nVertexFlow, int nEdgeCap, int nEdgeFlow, int nNumEdges)</a>
<a name="ln1355">{</a>
<a name="ln1356">    int i, ret = 0;</a>
<a name="ln1357">    /* search */</a>
<a name="ln1358">    for ( i = 0; i &lt; pTCGroups-&gt;num_tc_groups; i ++ ) {</a>
<a name="ln1359">        if ( pTCGroups-&gt;pTCG[i].type    == nGroupType &amp;&amp;</a>
<a name="ln1360">             pTCGroups-&gt;pTCG[i].ord_num == nGroupOrdNum ) {</a>
<a name="ln1361">            break;</a>
<a name="ln1362">        }</a>
<a name="ln1363">    }</a>
<a name="ln1364">    if ( i == pTCGroups-&gt;num_tc_groups ) {</a>
<a name="ln1365">        /* add one more group */</a>
<a name="ln1366">        if ( pTCGroups-&gt;num_tc_groups == pTCGroups-&gt;max_tc_groups ) {</a>
<a name="ln1367">            ret = ReallocTCGroups( pTCGroups, INC_NUM_TCGROUPS );</a>
<a name="ln1368">            if ( ret ) {</a>
<a name="ln1369">                goto exit_function;</a>
<a name="ln1370">            }</a>
<a name="ln1371">        }</a>
<a name="ln1372">        ret = i+1; /* added new group */</a>
<a name="ln1373">        pTCGroups-&gt;num_tc_groups ++;</a>
<a name="ln1374">        pTCGroups-&gt;pTCG[i].type    = nGroupType;</a>
<a name="ln1375">        pTCGroups-&gt;pTCG[i].ord_num = nGroupOrdNum;</a>
<a name="ln1376">    }</a>
<a name="ln1377">    pTCGroups-&gt;pTCG[i].num_edges  += nNumEdges;</a>
<a name="ln1378"> </a>
<a name="ln1379">    pTCGroups-&gt;pTCG[i].st_cap     += nVertexCap;</a>
<a name="ln1380">    pTCGroups-&gt;pTCG[i].st_flow    += nVertexFlow;</a>
<a name="ln1381"> </a>
<a name="ln1382">    pTCGroups-&gt;pTCG[i].edges_cap  += nEdgeCap;</a>
<a name="ln1383">    pTCGroups-&gt;pTCG[i].edges_flow += nEdgeFlow;</a>
<a name="ln1384"> </a>
<a name="ln1385">exit_function:</a>
<a name="ln1386">    return ret;         </a>
<a name="ln1387">}</a>
<a name="ln1388">/******************************************************************************************************/</a>
<a name="ln1389">int nTautEndpointEdgeCap( inp_ATOM *at, VAL_AT *pVA, int i )</a>
<a name="ln1390">{</a>
<a name="ln1391">    /* There are 3 sources of cap-flow = number of unsatisfied valences:</a>
<a name="ln1392">       -----------------------------------------------------------------</a>
<a name="ln1393">       1. pVA[i].cInitFreeValences </a>
<a name="ln1394">       2. pCN[0].v.cap - pCN[0].v.flow</a>
<a name="ln1395">       3. st[i].chem_bonds_valence - SUM(SINGLE, DOUBLE, TRIPLE bond orders)</a>
<a name="ln1396">          Reasons: (a) This sum will not include 'ALTERN' bonds</a>
<a name="ln1397">                   (b) until now at[i].chem_bonds_valence was used as a</a>
<a name="ln1398">                       number of satisfied valences. In case of adjacent</a>
<a name="ln1399">                       stereobonds marked as BOND_TYPE_ALTERN the value of</a>
<a name="ln1400">                       at[i].chem_bonds_valence may be = at[i].valence+1.</a>
<a name="ln1401">       4. Since tautomerism is defined for a neutral atom, do not add</a>
<a name="ln1402">          initial flows from the atom to the ChargeStruct</a>
<a name="ln1403">          CORRECTION: tautomeric endpoints do not have ChargeStruct.</a>
<a name="ln1404">                       </a>
<a name="ln1405">     */</a>
<a name="ln1406">    int j, k, nEdgeCap, bonds_valence, stereo_bond_excess_valence;</a>
<a name="ln1407">    MY_CONST C_NODE *pCN = pVA[i].cnListIndex&gt;0? cnList[pVA[i].cnListIndex-1].pCN:NULL;</a>
<a name="ln1408"> </a>
<a name="ln1409">    /* 1: free valences to reach the minimum known atom valence */</a>
<a name="ln1410">    nEdgeCap = pVA[i].cInitFreeValences;</a>
<a name="ln1411">    /* 2: atom free valence in the ChargeStruct */</a>
<a name="ln1412">    if ( pCN ) {</a>
<a name="ln1413">        nEdgeCap += pCN[0].v.cap - pCN[0].v.flow; /* normally should not happen */</a>
<a name="ln1414">    }</a>
<a name="ln1415">    /* 3: atom free valence due to known from stereochemistry stereogenic bond types */</a>
<a name="ln1416">    /*</a>
<a name="ln1417">    for ( j = 0, bonds_valence = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1418">        if ( at[i].bond_type[j] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1419">            bonds_valence += at[i].bond_type[j];</a>
<a name="ln1420">        }</a>
<a name="ln1421">    }</a>
<a name="ln1422">    */</a>
<a name="ln1423">    /* bonds &gt; SINGLE are assumed fixed stereobonds; fixed bond cannot increase t-group edge flow */</a>
<a name="ln1424">    for ( stereo_bond_excess_valence=0, j = 0; j &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i].sb_parity[j]; j ++ ) {</a>
<a name="ln1425">        k = at[i].sb_ord[j];</a>
<a name="ln1426">        if ( at[i].bond_type[k] &lt; BOND_TYPE_TRIPLE ) {</a>
<a name="ln1427">            stereo_bond_excess_valence += at[i].bond_type[k] - BOND_TYPE_SINGLE;</a>
<a name="ln1428">        }</a>
<a name="ln1429">    }</a>
<a name="ln1430">    /*</a>
<a name="ln1431">    bonds_valence = (at[i].chem_bonds_valence - bonds_valence) + (bonds_valence -at[i].valence - stereo_bond_excess_valence);</a>
<a name="ln1432">    */</a>
<a name="ln1433">    bonds_valence = (at[i].chem_bonds_valence - at[i].valence) - stereo_bond_excess_valence;</a>
<a name="ln1434"> </a>
<a name="ln1435"> </a>
<a name="ln1436">    /*---- add 1, 2, 3 ----*/</a>
<a name="ln1437">    if ( bonds_valence &gt;= 0 ) {</a>
<a name="ln1438">        nEdgeCap += bonds_valence;</a>
<a name="ln1439">    } else {</a>
<a name="ln1440">        nEdgeCap = RI_ERR_PROGR;</a>
<a name="ln1441">    }</a>
<a name="ln1442">    return nEdgeCap;</a>
<a name="ln1443">}</a>
<a name="ln1444">/******************************************************************************************************/</a>
<a name="ln1445">/* If Metal flowers are allowed ( pSrm-&gt;bMetalAddFlower != 0), then:                                  */</a>
<a name="ln1446">/*                                                                                                    */</a>
<a name="ln1447">/*   bond to a metal atom                min_bond_order[i] = pSrm-&gt;nMetalMinBondOrder                 */</a>
<a name="ln1448">/*   taut endpoint - metal               min_bond_order[i] = pSrm-&gt;nMetal2EndpointMinBondOrder        */</a>
<a name="ln1449">/*   single bond to metal atom:      initial_bond_order[i] = pSrm-&gt;nMetalInitBondOrder                */</a>
<a name="ln1450">/*   n-order bond to metal atom      initial_bond_order[i] = pSrm-&gt;nMetalInitBondOrder + n-1          */</a>
<a name="ln1451">/*                                 = bond_order[i]-BOND_TYPE_SINGLE+pSrm-&gt;nMetalInitBondOrder         */</a>
<a name="ln1452">/*   single t-endpoint--atom bond    initial_bond_order[i] = pSrm-&gt;nMetal2EndpointInitBondOrder       */</a>
<a name="ln1453">/*   n-order t-endpoint--metal bond  initial_bond_order[i] = pSrm-&gt;nMetal2EndpointInitBondOrder+n-1   */</a>
<a name="ln1454">/*                                 = bond_order[i]-BOND_TYPE_SINGLE+pSrm-&gt;nMetal2EndpointInitBondOrder*/</a>
<a name="ln1455">/*                                                                                                    */</a>
<a name="ln1456">/* Exceptions from simple atom-metal conditions:                                                      */</a>
<a name="ln1457">/*   1. Atom is a tautomeric endpoint: use pSrm-&gt;nMetal2Endpoint* instead of pSrm-&gt;nMetal*            */</a>
<a name="ln1458">/*   2. Atom is sp3-stereogenic and pSrm-&gt;bFixStereoBonds != 0: use atom-atom rules                   */</a>
<a name="ln1459">/*   3. Atom has a sp2-stereo   and pSrm-&gt;bFixStereoBonds != 0: use atom-atom rules                   */</a>
<a name="ln1460">/*                                                                                                    */</a>
<a name="ln1461">/* Atom-atom rules (applies to all atoms if pSrm-&gt;bMetalAddFlower=0)                                  */</a>
<a name="ln1462">/*                                                                                                    */</a>
<a name="ln1463">/*   min_bond_order[i]      = BOND_TYPE_SINGLE  (BOND_TYPE_SINGLE = 1)                                */</a>
<a name="ln1464">/*   initial_bond_order[i]  = bond_type[i]                                                            */</a>
<a name="ln1465">/*                                                                                                    */</a>
<a name="ln1466">/* General rules:                                                                                     */</a>
<a name="ln1467">/*   initial_bond_flow[i]   = initial_bond_order[i]-min_bond_order[i]                                 */</a>
<a name="ln1468">/*   atom[k] initial_st_cap = at[k].chem_bonds_valence - SUM{i; initial_bond_order[i]}                */</a>
<a name="ln1469">/*   bond_cap[i]            =  BOND_TYPE_TRIPLE - min_bond_order[i]                                   */</a>
<a name="ln1470">/*     (reason: quadruple and higher order bonds are not allowed)                                     */</a>
<a name="ln1471">/* Exception: in case of metal-atom bond, if pSrm-&gt;nMetal2EndpointInitEdgeFlow = 0 AND                */</a>
<a name="ln1472">/* pSrm-&gt;nMetalInitBondOrder - pSrm-&gt;nMetalMinBondOrder = 1 then                                      */</a>
<a name="ln1473">/*   reduce bond to metal order by 1 and increase st_cap of both neighbors by 1:                      */</a>
<a name="ln1474">/*   initial_bond_flow[i] --; metal_initial_st_cap += num_bonds;                                      */</a>
<a name="ln1475">/* ==== Note: ONLY the INCREASE is already included in pVA-&gt;cInitFreeValences of both atoms           */</a>
<a name="ln1476">/*                                                                                                    */</a>
<a name="ln1477">/* Notes: initial_st_cap does not include:                                                            */</a>
<a name="ln1478">/*   1. atom[k] additional st_cap from ChargeStruct pCN[0].v.cap                                      */</a>
<a name="ln1479">/*   2. pVA[k].cInitFreeValences due to a difference between the smallest known valence and st_cap    */</a>
<a name="ln1480">/*                                                                                                    */</a>
<a name="ln1481">/*  here k=atom at[k] index,                                                                          */</a>
<a name="ln1482">/*       i=bond index; i = 0..at[k].valence;                                                          */</a>
<a name="ln1483">/*       SUM{i; M[i]} is a sum of M[i] over all i                                                     */</a>
<a name="ln1484">/*       bond_order[i] = at[k].bond_type[i] &gt;= BOND_TYPE_SINGLE - input bond order                    */</a>
<a name="ln1485">/******************************************************************************************************/</a>
<a name="ln1486"> </a>
<a name="ln1487">/***************** new *************************************************************************************/</a>
<a name="ln1488"> </a>
<a name="ln1489">int BondFlowMaxcapMinorder( inp_ATOM *atom, VAL_AT *pVA, ICHICONST SRM *pSrm, int iat, int ineigh,</a>
<a name="ln1490">                            int *pnMaxcap, int *pnMinorder, int *pbNeedsFlower )</a>
<a name="ln1491">{</a>
<a name="ln1492">    int nFlow, nMaxcap, nMinorder, nInitorder, bNeedsFlower = 0;</a>
<a name="ln1493">    inp_ATOM *at        = atom + iat;</a>
<a name="ln1494">    int       neigh     = at-&gt;neighbor[ineigh];</a>
<a name="ln1495">    int       bond_type = at-&gt;bond_type[ineigh] &amp; BOND_TYPE_MASK;</a>
<a name="ln1496">    int       nMetal    = (0 != pVA[iat].cMetal) + (0 != pVA[neigh].cMetal);</a>
<a name="ln1497">    int       nEndpoint = (0 != at-&gt;endpoint) + (0 != atom[neigh].endpoint);</a>
<a name="ln1498">    int       nStereo   = (at-&gt;p_parity || at-&gt;sb_parity[0]) + (atom[neigh].p_parity || atom[neigh].sb_parity[0]);</a>
<a name="ln1499"> </a>
<a name="ln1500">    if ( bond_type &gt; BOND_TYPE_TRIPLE ) {</a>
<a name="ln1501">        bond_type = BOND_TYPE_SINGLE;</a>
<a name="ln1502">    }</a>
<a name="ln1503">    /* M=metal, A=non-metal atom, e=endpoint */</a>
<a name="ln1504">    if ( (nStereo &amp;&amp; pSrm-&gt;bFixStereoBonds) || !nMetal || !pSrm-&gt;bMetalAddFlower ) {</a>
<a name="ln1505">        /* atom-atom rules, no metal atoms involved (1: A-A, A-Ae, Ae-Ae) */</a>
<a name="ln1506">        nMinorder  = BOND_TYPE_SINGLE;</a>
<a name="ln1507">        nInitorder = bond_type;</a>
<a name="ln1508">        nFlow      = nInitorder - nMinorder;</a>
<a name="ln1509">    } else</a>
<a name="ln1510">    if ( nMetal &amp;&amp; !nEndpoint ) { </a>
<a name="ln1511">        /* M-a, M-M */</a>
<a name="ln1512">        /* atom - metal or metal-metal, none of them is an endpoint (2: M-M, M-A) */</a>
<a name="ln1513">        nMinorder  = pSrm-&gt;nMetalMinBondOrder;</a>
<a name="ln1514">        nInitorder = pSrm-&gt;nMetalInitBondOrder + bond_type - BOND_TYPE_SINGLE;</a>
<a name="ln1515">        nFlow      = nInitorder - nMinorder;</a>
<a name="ln1516">        if ( !pSrm-&gt;nMetalInitEdgeFlow &amp;&amp;</a>
<a name="ln1517">             pSrm-&gt;nMetalInitBondOrder &gt; pSrm-&gt;nMetalMinBondOrder &amp;&amp;</a>
<a name="ln1518">             nFlow &gt; 0 ) {</a>
<a name="ln1519">            /* reduce initial flow by 1 and increase st_cap on metal by 1 */</a>
<a name="ln1520">            nFlow --;</a>
<a name="ln1521">        }</a>
<a name="ln1522">        bNeedsFlower = (0 != pVA[iat].cMetal);</a>
<a name="ln1523">    } else</a>
<a name="ln1524">    if ( (pVA[iat].cMetal   &amp;&amp; !at-&gt;endpoint         &amp;&amp; !pVA[neigh].cMetal &amp;&amp; atom[neigh].endpoint) ||</a>
<a name="ln1525">         (pVA[neigh].cMetal &amp;&amp; !atom[neigh].endpoint &amp;&amp; !pVA[iat].cMetal   &amp;&amp; at-&gt;endpoint) ) {</a>
<a name="ln1526">        /* M-ae */</a>
<a name="ln1527">        /* metal connected to a non-metal endpoint (3: M-Ae) */</a>
<a name="ln1528">        nMinorder  = pSrm-&gt;nMetal2EndpointMinBondOrder;</a>
<a name="ln1529">        nInitorder = pSrm-&gt;nMetal2EndpointInitBondOrder + bond_type - BOND_TYPE_SINGLE;</a>
<a name="ln1530">        nFlow      = nInitorder - nMinorder;</a>
<a name="ln1531">        if ( !pSrm-&gt;nMetal2EndpointInitEdgeFlow &amp;&amp;</a>
<a name="ln1532">             pSrm-&gt;nMetal2EndpointInitBondOrder &gt; pSrm-&gt;nMetal2EndpointMinBondOrder &amp;&amp;</a>
<a name="ln1533">             nFlow &gt; 0 ) {</a>
<a name="ln1534">            /* reduce initial flow by 1 and increase st_cap on metal by 1 */</a>
<a name="ln1535">            nFlow --;</a>
<a name="ln1536">        }</a>
<a name="ln1537">        bNeedsFlower = (0 != pVA[iat].cMetal);</a>
<a name="ln1538">    } else {</a>
<a name="ln1539">        /* endpoint is metal =&gt; no flower (4: M-Me, Me-Me, Me-A, Me-Ae) */</a>
<a name="ln1540">        nMinorder  = pSrm-&gt;nMetal2EndpointMinBondOrder;</a>
<a name="ln1541">        nInitorder = pSrm-&gt;nMetal2EndpointInitBondOrder + bond_type - BOND_TYPE_SINGLE;</a>
<a name="ln1542">        nFlow      = nInitorder - nMinorder;</a>
<a name="ln1543">        if ( !pSrm-&gt;nMetal2EndpointInitEdgeFlow &amp;&amp;</a>
<a name="ln1544">             pSrm-&gt;nMetal2EndpointInitBondOrder &gt; pSrm-&gt;nMetal2EndpointMinBondOrder &amp;&amp;</a>
<a name="ln1545">             nFlow &gt; 0 ) {</a>
<a name="ln1546">            /* reduce initial flow by 1 and increase st_cap on metal by 1 */</a>
<a name="ln1547">            nFlow --;</a>
<a name="ln1548">        }</a>
<a name="ln1549">        bNeedsFlower = (pVA[iat].cMetal &amp;&amp; !at-&gt;endpoint);</a>
<a name="ln1550">    }</a>
<a name="ln1551">    nMaxcap = BOND_TYPE_TRIPLE - nMinorder;</a>
<a name="ln1552">    if ( pnMaxcap ) {</a>
<a name="ln1553">        *pnMaxcap = nMaxcap;</a>
<a name="ln1554">    }</a>
<a name="ln1555">    if ( pnMinorder ) {</a>
<a name="ln1556">        *pnMinorder = nMinorder;</a>
<a name="ln1557">    }</a>
<a name="ln1558">    if ( pbNeedsFlower ) {</a>
<a name="ln1559">        *pbNeedsFlower = bNeedsFlower;</a>
<a name="ln1560">    }</a>
<a name="ln1561">    return nFlow;</a>
<a name="ln1562">}</a>
<a name="ln1563">/*********** new *******************************************************************************************/</a>
<a name="ln1564">int AtomStcapStflow( inp_ATOM *atom, VAL_AT *pVA, ICHICONST SRM *pSrm, int iat, int *pnStcap, int *pnStflow,</a>
<a name="ln1565">                     EdgeFlow *pnMGroupEdgeCap, EdgeFlow *pnMGroupEdgeFlow )</a>
<a name="ln1566">{</a>
<a name="ln1567">    int ineigh, bFlower;</a>
<a name="ln1568">    int nStflow=0, nMaxBondCap, nMinBondOrder, bNeedsFlower = 0;</a>
<a name="ln1569">    int valence = atom[iat].valence;</a>
<a name="ln1570">    int nStcap  = atom[iat].chem_bonds_valence;</a>
<a name="ln1571">    int nMGroupEdgeCap = 0, nMGroupEdgeFlow = 0, nFlow;</a>
<a name="ln1572"> </a>
<a name="ln1573">    if ( pSrm-&gt;bMetalAddFlower ) {</a>
<a name="ln1574">        nStcap  -= pVA[iat].cInitOrigValenceToMetal - pVA[iat].cInitValenceToMetal;</a>
<a name="ln1575">    }</a>
<a name="ln1576"> </a>
<a name="ln1577">    for ( ineigh = 0; ineigh &lt; valence; ineigh ++ ) {</a>
<a name="ln1578">        nFlow     = BondFlowMaxcapMinorder( atom, pVA, pSrm, iat, ineigh, &amp;nMaxBondCap, &amp;nMinBondOrder, &amp;bFlower );</a>
<a name="ln1579">        nStflow  += nFlow;</a>
<a name="ln1580">        nStcap   -= nMinBondOrder;</a>
<a name="ln1581">        if ( bFlower ) {</a>
<a name="ln1582">            bNeedsFlower ++;</a>
<a name="ln1583">            nMGroupEdgeFlow += nFlow;</a>
<a name="ln1584">            nMGroupEdgeCap  += BOND_TYPE_TRIPLE - nMinBondOrder + pSrm-&gt;nMetalMaxCharge_D; </a>
<a name="ln1585">        }</a>
<a name="ln1586">    }</a>
<a name="ln1587">    if ( pnStcap ) {</a>
<a name="ln1588">        *pnStcap = bNeedsFlower? nStflow : nStcap; /* initially, metal atoms are not radicals */</a>
<a name="ln1589">    }</a>
<a name="ln1590">    if ( pnStflow ) {</a>
<a name="ln1591">        *pnStflow = nStflow;</a>
<a name="ln1592">    }</a>
<a name="ln1593">    if ( pnMGroupEdgeFlow ) {</a>
<a name="ln1594">        *pnMGroupEdgeFlow = nMGroupEdgeCap - nMGroupEdgeFlow;</a>
<a name="ln1595">    }</a>
<a name="ln1596">    if ( pnMGroupEdgeCap ) {</a>
<a name="ln1597">        *pnMGroupEdgeCap = nMGroupEdgeCap;</a>
<a name="ln1598">    }</a>
<a name="ln1599">    return bNeedsFlower; /* number of variable bonds to metal */</a>
<a name="ln1600">}</a>
<a name="ln1601">/**************************************************************************************</a>
<a name="ln1602">int nCountBnsSizes( inp_ATOM *at, int num_at, int nAddEdges2eachAtom, int nAddVertices,</a>
<a name="ln1603">                    T_GROUP_INFO *ti, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln1604"> </a>
<a name="ln1605">fills out totals:</a>
<a name="ln1606"> </a>
<a name="ln1607">  pTCGroups-&gt;num_atoms        = number of atoms</a>
<a name="ln1608">  pTCGroups-&gt;num_bonds        = number of bonds between atoms</a>
<a name="ln1609">  pTCGroups-&gt;num_tgroups      = number of tautomeric groups</a>
<a name="ln1610">  pTCGroups-&gt;num_tgroup_edges = number of edges to tautomeric groups</a>
<a name="ln1611">  pTCGroups-&gt;tgroup_charge    = total charge on thautomeric atoms (negative)</a>
<a name="ln1612">  pTCGroups-&gt;num_tc_groups    = total number of all groups</a>
<a name="ln1613">  pTCGroups-&gt;nVertices        = total number of vertices excluding groups interconnections</a>
<a name="ln1614">  pTCGroups-&gt;nEdges           = total number of edges excluding groups interconnections</a>
<a name="ln1615"> </a>
<a name="ln1616">creates entries for the groups and adds to each group:</a>
<a name="ln1617">    </a>
<a name="ln1618">  TC_GROUP::type       =  BNS_VERT_TYPE_TGROUP, BNS_VT_C_POS, BNS_VT_C_NEG, BNS_VT_C_POS_C, BNS_VT_C_NEG_C </a>
<a name="ln1619">  TC_GROUP::ord_num    =  ordering number within the type, e.g. t-group number</a>
<a name="ln1620">  TC_GROUP::st_cap     =  all from the atoms in ChargeStruct or tautomeric group info.</a>
<a name="ln1621">  TC_GROUP::st_flow    =  all from the atoms in ChargeStruct (0 for t-groups).</a>
<a name="ln1622">  TC_GROUP::num_edges  =  number of edges to the atoms or ChargeStruct vertices.</a>
<a name="ln1623">  TC_GROUP::edges_cap  =  sum of all incoming edge caps; see also nTautEndpointEdgeCap(..).</a>
<a name="ln1624">  TC_GROUP::edges_flow =  sum of all incoming edge flows; 0 for t-groups.</a>
<a name="ln1625"> </a>
<a name="ln1626">  TC_GROUP::nVertexNumber - NO FILLED WITH ANYTHING</a>
<a name="ln1627"> </a>
<a name="ln1628">  Note: the nDelta = st_cap - st_flow needs to be preserved when adding more vertices</a>
<a name="ln1629">  </a>
<a name="ln1630">Return value: =0 =&gt; success</a>
<a name="ln1631">              &lt;0 =&gt; error</a>
<a name="ln1632"> **************************************************************************************/</a>
<a name="ln1633">int nCountBnsSizes( inp_ATOM *at, int num_at, int nAddEdges2eachAtom, int nAddVertices,</a>
<a name="ln1634">                    T_GROUP_INFO *ti, VAL_AT *pVA, ICHICONST SRM *pSrm, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln1635">{</a>
<a name="ln1636">    int i, j, n, k, ret = 0, nBonds, nOtherEdges, nVertices, bMetalAtoms, bNeedsFlower;</a>
<a name="ln1637">    int nTgroupEdges, nTgroupEdgesFromTg, nTotNegChargInTgroups, cap, flow;</a>
<a name="ln1638">    MY_CONST C_NODE *pCN = NULL;</a>
<a name="ln1639">    nVertices = nBonds = nOtherEdges = nTgroupEdges = nTgroupEdgesFromTg = nTotNegChargInTgroups = 0;</a>
<a name="ln1640">    </a>
<a name="ln1641">    /* count metal atoms and electrons */</a>
<a name="ln1642">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1643">        pTCGroups-&gt;num_metal_atoms += (pVA[i].cMetal != 0);</a>
<a name="ln1644">        pTCGroups-&gt;num_metal_bonds += pVA[i].cNumBondsToMetal;</a>
<a name="ln1645">        pTCGroups-&gt;total_electrons += at[i].el_number;</a>
<a name="ln1646">        pTCGroups-&gt;total_electrons_metals += pVA[i].cMetal? at[i].el_number : 0;</a>
<a name="ln1647">    }</a>
<a name="ln1648">    pTCGroups-&gt;total_electrons -= pTCGroups-&gt;total_charge;</a>
<a name="ln1649">    pTCGroups-&gt;num_metal_bonds /= 2;</a>
<a name="ln1650"> </a>
<a name="ln1651">    /* register tautomeric groups */</a>
<a name="ln1652">    for ( i = 0; i &lt; ti-&gt;num_t_groups; i ++ ) {</a>
<a name="ln1653">        ret = RegisterTCGroup( pTCGroups, BNS_VERT_TYPE_TGROUP, ti-&gt;t_group[i].nGroupNumber,</a>
<a name="ln1654">                               ti-&gt;t_group[i].num[0] /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1655">                               0 /* edge cap */, 0 /* edge flow */,  ti-&gt;t_group[i].nNumEndpoints /* num Edges */ );</a>
<a name="ln1656">        if ( ret &lt; 0 ) {</a>
<a name="ln1657">            goto exit_function;</a>
<a name="ln1658">        }</a>
<a name="ln1659">        /* edges to tautomeric groups */</a>
<a name="ln1660">        nOtherEdges           += ti-&gt;t_group[i].nNumEndpoints;</a>
<a name="ln1661">        nTgroupEdgesFromTg    += ti-&gt;t_group[i].nNumEndpoints;</a>
<a name="ln1662">        /* total negative charge in t-groups */</a>
<a name="ln1663">        nTotNegChargInTgroups += ti-&gt;t_group[i].num[1];</a>
<a name="ln1664">        if ( ret &gt; 0 ) {</a>
<a name="ln1665">            /* should always happen since this is the first time this t-group is added */</a>
<a name="ln1666">            j = ret-1;</a>
<a name="ln1667">            pTCGroups-&gt;pTCG[j].tg_num_H     = ti-&gt;t_group[i].num[0] - ti-&gt;t_group[i].num[1];</a>
<a name="ln1668">            pTCGroups-&gt;pTCG[j].tg_num_Minus = ti-&gt;t_group[i].num[1];</a>
<a name="ln1669">        }</a>
<a name="ln1670">    }</a>
<a name="ln1671"> </a>
<a name="ln1672">    bMetalAtoms = 0;</a>
<a name="ln1673"> </a>
<a name="ln1674">repeat_for_metals:    </a>
<a name="ln1675"> </a>
<a name="ln1676">    /* count vertices and register ChargeValence groups */</a>
<a name="ln1677">    /* for now an atom may belong either to a t-group or to a ChargeValence group, but not to both */</a>
<a name="ln1678">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln1679">        /* number of bonds */</a>
<a name="ln1680">        nBonds += at[i].valence;</a>
<a name="ln1681">        /* Process ChargeStruct vertices and edges */</a>
<a name="ln1682">        if ( pVA[i].cnListIndex ) {</a>
<a name="ln1683">            /* count vertices &amp; edges in the ChargeValence Substructure attached to an atom */</a>
<a name="ln1684">            /* Important: unlike inp_ATOM, each edge e appears in pCN[*].e[*] only ONE time */</a>
<a name="ln1685">            int     len     = cnList[j = pVA[i].cnListIndex-1].len;</a>
<a name="ln1686">            int     bits    = cnList[j].bits;</a>
<a name="ln1687">            int     type, neigh_type, metal_group_number;</a>
<a name="ln1688">            pCN     = cnList[j].pCN;</a>
<a name="ln1689">            </a>
<a name="ln1690">            /* first process all non-metals, after that -- all metals */</a>
<a name="ln1691">            if ( (bits != cn_bits_Me) != !bMetalAtoms ) {</a>
<a name="ln1692">                continue;</a>
<a name="ln1693">            }</a>
<a name="ln1694">            metal_group_number = 0;</a>
<a name="ln1695">            for ( j = 0; j &lt; len; j ++) {</a>
<a name="ln1696">                type = pCN[j].v.type; /* ChargeStruct vertex type: atom is the first, c-groups are last */</a>
<a name="ln1697"> </a>
<a name="ln1698">                /* process all pCN[j] neighbors */</a>
<a name="ln1699">                for ( k = 0; k &lt; MAX_CN_VAL &amp;&amp; (n = pCN[j].e[k].neigh); k ++ ) {</a>
<a name="ln1700">                    nOtherEdges ++;  /* edges inside ChargeStruct */</a>
<a name="ln1701">                    n --; /* neighbor vertex position inside cnList[j].pCN */</a>
<a name="ln1702">                    neigh_type = pCN[n].v.type; /* type of the neighboring atom */</a>
<a name="ln1703"> </a>
<a name="ln1704">                    if ( IS_BNS_VT_C_GR(neigh_type) ) {</a>
<a name="ln1705">                        /* register this edge to a CN-group vertex */</a>
<a name="ln1706">                        cap  = !bMetalAtoms? pCN[j].e[k].cap  : pCN[j].e[k].cap?  pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln1707">                        flow = !bMetalAtoms? pCN[j].e[k].flow : pCN[j].e[k].flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln1708"> </a>
<a name="ln1709">                        ret = RegisterTCGroup( pTCGroups, neigh_type, 0 /* ord_num*/,</a>
<a name="ln1710">                                               0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1711">                                               cap /* edge cap*/, flow /* edge flow */, 1 /* nNumEdges*/);</a>
<a name="ln1712">                        if ( ret &lt; 0 ) {</a>
<a name="ln1713">                            goto exit_function;</a>
<a name="ln1714">                        }</a>
<a name="ln1715">                        if ( ret &gt; 0 ) {</a>
<a name="ln1716">                            /* the group has just been created; add one more edge to (+/-) or supergroup */</a>
<a name="ln1717">                            ret = RegisterTCGroup( pTCGroups, neigh_type, 0 /* ord_num*/,</a>
<a name="ln1718">                                                   0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1719">                                                   0 /* edge cap*/, 0/* edge flow*/, 1 /* nNumEdges*/);</a>
<a name="ln1720">                            if ( ret &lt; 0 ) {</a>
<a name="ln1721">                                goto exit_function;</a>
<a name="ln1722">                            }</a>
<a name="ln1723">                            nOtherEdges ++;</a>
<a name="ln1724">                        }</a>
<a name="ln1725">                    }</a>
<a name="ln1726"> </a>
<a name="ln1727">                    if ( IS_BNS_VT_C_GR(type) ) {</a>
<a name="ln1728">                        /* register this edge to a CN-group vertex; normally this does not happen */</a>
<a name="ln1729">                        cap  = !bMetalAtoms? pCN[j].e[k].cap  : pCN[j].e[k].cap?  pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln1730">                        flow = !bMetalAtoms? pCN[j].e[k].flow : pCN[j].e[k].flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln1731">                        ret = RegisterTCGroup( pTCGroups, type, 0 /* ord_num*/,</a>
<a name="ln1732">                                               0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1733">                                               cap /* edge cap*/, flow /* edge flow */, 1 /* nNumEdges*/);</a>
<a name="ln1734">                        if ( ret &lt; 0 ) {</a>
<a name="ln1735">                            goto exit_function;</a>
<a name="ln1736">                        }</a>
<a name="ln1737">                        if ( ret &gt; 0 ) {</a>
<a name="ln1738">                            /* the group has just been created; add one more edge to (+/-) or supergroup */</a>
<a name="ln1739">                            ret = RegisterTCGroup( pTCGroups, type, 0 /* ord_num*/,</a>
<a name="ln1740">                                                   0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1741">                                                   0 /* edge cap*/, 0/* edge flow*/, 1 /* nNumEdges*/);</a>
<a name="ln1742">                            if ( ret &lt; 0 ) {</a>
<a name="ln1743">                                goto exit_function;</a>
<a name="ln1744">                            }</a>
<a name="ln1745">                            nOtherEdges ++;</a>
<a name="ln1746">                        }</a>
<a name="ln1747">                    }</a>
<a name="ln1748">                } /* end of the current vertex pCN[j] neighbors */</a>
<a name="ln1749"> </a>
<a name="ln1750">                /* process  pCN[j] vertex */</a>
<a name="ln1751"> </a>
<a name="ln1752">                if ( type &amp; BNS_VERT_TYPE_ATOM ) {</a>
<a name="ln1753">                    continue;  /* do not count regular atoms here */</a>
<a name="ln1754">                }</a>
<a name="ln1755">                if ( IS_BNS_VT_CHRG_STRUCT(type) ) {</a>
<a name="ln1756">                    nVertices ++;</a>
<a name="ln1757">                    continue;</a>
<a name="ln1758">                }</a>
<a name="ln1759"> </a>
<a name="ln1760">                if ( pSrm-&gt;bMetalAddFlower &amp;&amp; IS_BNS_VT_M_GR( type ) ) {</a>
<a name="ln1761">                    /* special treatment: flow and cap are known as well as structure */</a>
<a name="ln1762">                    /* initial bond valence to metal is either 0 or 1 */</a>
<a name="ln1763">                    EdgeFlow nEdgeFlow, nEdgeCap;</a>
<a name="ln1764">                    bNeedsFlower = AtomStcapStflow( at, pVA, pSrm, i, NULL /*pnStcap*/, NULL /*pnStflow*/,</a>
<a name="ln1765">                                                    &amp;nEdgeCap, &amp;nEdgeFlow );</a>
<a name="ln1766">                    if ( !bNeedsFlower ) {</a>
<a name="ln1767">                        ret = RI_ERR_PROGR;</a>
<a name="ln1768">                        goto exit_function;</a>
<a name="ln1769">                    }</a>
<a name="ln1770">                    /*</a>
<a name="ln1771">                    GetAtomToMCGroupInitEdgeCapFlow( &amp;nEdgeCap, &amp;nEdgeFlow, pSrm, at,  pVA, i );</a>
<a name="ln1772">                    GetAtomToMCGroupInitEdgeCapFlow( &amp;nEdgeCap, &amp;nEdgeFlow, pSrm );</a>
<a name="ln1773">                    */</a>
<a name="ln1774">                    /* the 1st is the flower base */</a>
<a name="ln1775">                    /* atom - G0 edge and G0 vertex */</a>
<a name="ln1776">                    ret = RegisterTCGroup( pTCGroups, type, 0 /* ord_num*/,</a>
<a name="ln1777">                                           /*pVA[i].cInitFreeValences*/ 0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1778">                                           (int)nEdgeCap, (int)nEdgeFlow, 1 /* nNumEdges*/);</a>
<a name="ln1779">                    if ( ret &lt; 0 ) {</a>
<a name="ln1780">                        goto exit_function;</a>
<a name="ln1781">                    }</a>
<a name="ln1782">                    /* count edge atom-G0 */</a>
<a name="ln1783">                    nOtherEdges ++;</a>
<a name="ln1784">                    if ( ret &gt; 0 ) {</a>
<a name="ln1785">                        /* first time registration: add G0-G1 and G0-G2 edges to G0 */</a>
<a name="ln1786">                        ret = RegisterTCGroup( pTCGroups, type, 0 /* ord_num*/,</a>
<a name="ln1787">                                               0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1788">                                               0,/* edge cap*/ 0 /*edge flow*/, 2 /* nNumEdges*/);</a>
<a name="ln1789">                        </a>
<a name="ln1790">                        if ( ret &lt; 0 ) {</a>
<a name="ln1791">                            goto exit_function;</a>
<a name="ln1792">                        }</a>
<a name="ln1793">                        /* first time registration: add G1; it has 3 edges */</a>
<a name="ln1794">                        ret = RegisterTCGroup( pTCGroups, type, 1 /* ord_num*/,</a>
<a name="ln1795">                                               0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1796">                                               0,/* edge cap*/ 0 /*edge flow*/, 3 /* nNumEdges*/);</a>
<a name="ln1797">                        </a>
<a name="ln1798">                        if ( ret &lt;= 0 ) {</a>
<a name="ln1799">                            ret = !ret? RI_ERR_PROGR : ret;</a>
<a name="ln1800">                            goto exit_function;</a>
<a name="ln1801">                        }</a>
<a name="ln1802">                        /* first time registration: add G2; it has 3 edges */</a>
<a name="ln1803">                        ret = RegisterTCGroup( pTCGroups, type, 2 /* ord_num*/,</a>
<a name="ln1804">                                               0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1805">                                               0,/* edge cap*/ 0 /*edge flow*/, 3 /* nNumEdges*/);</a>
<a name="ln1806">                        </a>
<a name="ln1807">                        if ( ret &lt;= 0 ) {</a>
<a name="ln1808">                            ret = !ret? RI_ERR_PROGR : ret;</a>
<a name="ln1809">                            goto exit_function;</a>
<a name="ln1810">                        }</a>
<a name="ln1811">                        /* first time registration: add G3; it has 2 edges */</a>
<a name="ln1812">                        ret = RegisterTCGroup( pTCGroups, type, 3 /* ord_num*/,</a>
<a name="ln1813">                                               0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1814">                                               0,/* edge cap*/ 0 /*edge flow*/, 2 /* nNumEdges*/);</a>
<a name="ln1815">                        </a>
<a name="ln1816">                        if ( ret &lt;= 0 ) {</a>
<a name="ln1817">                            ret = !ret? RI_ERR_PROGR : ret;</a>
<a name="ln1818">                            goto exit_function;</a>
<a name="ln1819">                        }</a>
<a name="ln1820">                        /* count added metal flower vertices: G0, G1, G2, G3 */</a>
<a name="ln1821">                        nVertices += 4;</a>
<a name="ln1822">                        /* count added metal flower edges: C0-C1, C0-C2, C1-C2, C1-C3, C2-C3 */</a>
<a name="ln1823">                        nOtherEdges += 5;</a>
<a name="ln1824">                        /* add connections of G0 to G1 and G2 */</a>
<a name="ln1825">                    }</a>
<a name="ln1826">                    continue;</a>
<a name="ln1827">                }</a>
<a name="ln1828"> </a>
<a name="ln1829">                nVertices ++; /* count BNS_VT_C_POS* types; all contain BNS_VERT_TYPE_C_GROUP bit */</a>
<a name="ln1830">                if ( !IS_BNS_VT_C_GR(type) ) {  /* check */</a>
<a name="ln1831">                    ret = RI_ERR_PROGR;</a>
<a name="ln1832">                    goto exit_function;</a>
<a name="ln1833">                }</a>
<a name="ln1834">                /* add st_cap and st_flow for a charge group */</a>
<a name="ln1835">                cap  = !bMetalAtoms? pCN[j].v.cap  : pCN[j].v.cap?  pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln1836">                flow = !bMetalAtoms? pCN[j].v.flow : pCN[j].v.flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln1837">                ret = RegisterTCGroup( pTCGroups, type, 0 /* ord_num*/,</a>
<a name="ln1838">                                       cap /* st-cap*/, flow /* st-flow */,</a>
<a name="ln1839">                                       0 /* edge cap */, 0 /* edge flow */, 0 /* edges already counted */ );</a>
<a name="ln1840">                if ( ret &lt; 0 ) {</a>
<a name="ln1841">                    goto exit_function;</a>
<a name="ln1842">                }</a>
<a name="ln1843">            }</a>
<a name="ln1844">        } else {</a>
<a name="ln1845">            pCN = NULL;</a>
<a name="ln1846">        }</a>
<a name="ln1847">        /* count edge caps to t-groups */</a>
<a name="ln1848">        if ( at[i].endpoint ) {</a>
<a name="ln1849">            int nEdgeCap = nTautEndpointEdgeCap( at, pVA, i );</a>
<a name="ln1850">            nTgroupEdges ++;</a>
<a name="ln1851">            if ( nEdgeCap &lt; 0 ) {</a>
<a name="ln1852">                ret = nEdgeCap;</a>
<a name="ln1853">                goto exit_function;</a>
<a name="ln1854">            }</a>
<a name="ln1855">            /* add number of unsatisfied valences for a t-group; the unknown flow = 0 */</a>
<a name="ln1856">            ret = RegisterTCGroup( pTCGroups, BNS_VERT_TYPE_TGROUP, at[i].endpoint,</a>
<a name="ln1857">                                   0 /* st_cap */, 0 /* st_flow */,</a>
<a name="ln1858">                                   nEdgeCap /* edge cap */, 0 /* edge flow */,</a>
<a name="ln1859">                                   0 /* t-group edges have already been counted */ );</a>
<a name="ln1860">            if ( ret &lt; 0 ) {</a>
<a name="ln1861">                goto exit_function;</a>
<a name="ln1862">            }</a>
<a name="ln1863"> </a>
<a name="ln1864">        }</a>
<a name="ln1865">    }</a>
<a name="ln1866">    if ( !bMetalAtoms &amp;&amp; pTCGroups-&gt;num_metal_atoms ) {</a>
<a name="ln1867">        bMetalAtoms = 1;</a>
<a name="ln1868">        nBonds      = 0; /* added 2006-05-15 */</a>
<a name="ln1869">        goto repeat_for_metals;</a>
<a name="ln1870">    }</a>
<a name="ln1871"> </a>
<a name="ln1872">    /* count real atoms and bonds */</a>
<a name="ln1873">    nBonds /= 2;</a>
<a name="ln1874">    pTCGroups-&gt;num_atoms        = num_at;</a>
<a name="ln1875">    pTCGroups-&gt;num_bonds        = nBonds;</a>
<a name="ln1876"> </a>
<a name="ln1877">    pTCGroups-&gt;num_tgroups      = ti-&gt;num_t_groups;</a>
<a name="ln1878">    pTCGroups-&gt;num_tgroup_edges = nTgroupEdges;</a>
<a name="ln1879">    pTCGroups-&gt;tgroup_charge    = -nTotNegChargInTgroups;</a>
<a name="ln1880"> </a>
<a name="ln1881">    if ( 0 &lt;= ret &amp;&amp; nTgroupEdgesFromTg != nTgroupEdges ) {</a>
<a name="ln1882">        ret = BNS_PROGRAM_ERR;</a>
<a name="ln1883">    }</a>
<a name="ln1884"> </a>
<a name="ln1885">    nVertices += num_at;</a>
<a name="ln1886"> </a>
<a name="ln1887"> </a>
<a name="ln1888">    /* count other vertices */</a>
<a name="ln1889">    nVertices += ti-&gt;num_t_groups;</a>
<a name="ln1890">    nBonds    += nOtherEdges;</a>
<a name="ln1891"> </a>
<a name="ln1892">    /* return edges and vertices */</a>
<a name="ln1893">    pTCGroups-&gt;nVertices     = nVertices;</a>
<a name="ln1894">    pTCGroups-&gt;nEdges        = nBonds;</a>
<a name="ln1895"> </a>
<a name="ln1896">exit_function:</a>
<a name="ln1897">    return ret;</a>
<a name="ln1898">}</a>
<a name="ln1899"> </a>
<a name="ln1900">/****************************************************************</a>
<a name="ln1901">  int nAddSuperCGroups( ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln1902"> </a>
<a name="ln1903">  1. adds BNS_VT_C_POS_ALL and BNS_VT_C_NEG_ALL ONLY if both</a>
<a name="ln1904">     {TCG_Plus0  and TCG_Plus_C0} and/or</a>
<a name="ln1905">     {TCG_Minus0 and TCG_Minus_C0} are present, respectively</a>
<a name="ln1906">    </a>
<a name="ln1907">  2. fills pTCGroups-&gt;nGroup[]:</a>
<a name="ln1908"> </a>
<a name="ln1909">  pTCGroups-&gt;nGroup[k] &lt; 0  =&gt; does not exist</a>
<a name="ln1910">  pTCGroups-&gt;nGroup[k] = i  =&gt; the group is pTCGroups-&gt;pTCG[i]</a>
<a name="ln1911"> </a>
<a name="ln1912">    where           group           group </a>
<a name="ln1913">      k =           type            number</a>
<a name="ln1914">    TCG_Plus0       BNS_VT_C_POS      0 </a>
<a name="ln1915">    TCG_Plus1,      BNS_VT_C_POS      1 </a>
<a name="ln1916">    TCG_Minus0,     BNS_VT_C_NEG      0 </a>
<a name="ln1917">    TCG_Minus1,     BNS_VT_C_NEG      1 </a>
<a name="ln1918">    TCG_Plus_C0,    BNS_VT_C_POS_C    0 </a>
<a name="ln1919">    TCG_Plus_C1,    BNS_VT_C_POS_C    1 </a>
<a name="ln1920">    TCG_Minus_C0,   BNS_VT_C_NEG_C    0 </a>
<a name="ln1921">    TCG_Minus_C1,   BNS_VT_C_NEG_C    1 </a>
<a name="ln1922">    TCG_Plus,       BNS_VT_C_POS_ALL  0 </a>
<a name="ln1923">    TCG_Minus,      BNS_VT_C_NEG_ALL  0 </a>
<a name="ln1924"> </a>
<a name="ln1925">only groups with number 0 are processed</a>
<a name="ln1926"> </a>
<a name="ln1927">  3. If only one of the groups in pairs mentioned in (1) above</a>
<a name="ln1928">     is present then </a>
<a name="ln1929">     </a>
<a name="ln1930">     pTCGroups-&gt;nGroup[TCG_Plus] := pTCGroups-&gt;nGroup[TCG_Plus0] or</a>
<a name="ln1931">     pTCGroups-&gt;nGroup[TCG_Plus] := pTCGroups-&gt;nGroup[TCG_Plus_C0];</a>
<a name="ln1932">     an additional BNS_VT_C_POS_ALL vertex is not created</a>
<a name="ln1933"> </a>
<a name="ln1934">     same for pTCGroups-&gt;nGroup[TCG_Minus] and BNS_VT_C_NEG_ALL</a>
<a name="ln1935"> </a>
<a name="ln1936">  4. Adds to these new &quot;supergroups&quot; (TCG_Plus, TCG_Minus)</a>
<a name="ln1937">     descriptions in pTCGroups-&gt;pTCG[k]</a>
<a name="ln1938">     st_cap, st_flow, edges cap and flow from the corresponding</a>
<a name="ln1939">     groups {TCG_Plus0  and TCG_Plus_C0}. Same for the Minus groups.</a>
<a name="ln1940">     Stores indexes k in</a>
<a name="ln1941">     pTCGroups-&gt;nGroup[TCG_Plus], pTCGroups-&gt;nGroup[TCG_Minus]</a>
<a name="ln1942"> </a>
<a name="ln1943"> ****************************************************************/</a>
<a name="ln1944">int nAddSuperCGroups( ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln1945">{</a>
<a name="ln1946">    int i, k, n, n1, n2, n3, nNumTg = 0, ret = 0, nNumToConnect;</a>
<a name="ln1947"> </a>
<a name="ln1948">    for ( i = 0; i &lt; pTCGroups-&gt;num_tc_groups; i ++ ) {</a>
<a name="ln1949">        if ( pTCGroups-&gt;pTCG[i].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln1950">            nNumTg ++;</a>
<a name="ln1951">            continue; /* t-group */</a>
<a name="ln1952">        }</a>
<a name="ln1953">        if ( IS_BNS_VT_C_GR(pTCGroups-&gt;pTCG[i].type) ||</a>
<a name="ln1954">             IS_BNS_VT_M_GR(pTCGroups-&gt;pTCG[i].type) ) {</a>
<a name="ln1955">            /* ChargeValence (cn) group */</a>
<a name="ln1956">            switch( pTCGroups-&gt;pTCG[i].type ) {</a>
<a name="ln1957">            case BNS_VT_C_POS:</a>
<a name="ln1958">                k = TCG_Plus0;</a>
<a name="ln1959">                break;</a>
<a name="ln1960">            case BNS_VT_C_NEG:</a>
<a name="ln1961">                k = TCG_Minus0;</a>
<a name="ln1962">                break;</a>
<a name="ln1963">            case BNS_VT_C_POS_C:</a>
<a name="ln1964">                k = TCG_Plus_C0;</a>
<a name="ln1965">                break;</a>
<a name="ln1966">            case BNS_VT_C_NEG_C:</a>
<a name="ln1967">                k = TCG_Minus_C0;</a>
<a name="ln1968">                break;</a>
<a name="ln1969">            case BNS_VT_C_POS_M:</a>
<a name="ln1970">                k = TCG_Plus_M0;</a>
<a name="ln1971">                break;</a>
<a name="ln1972">            case BNS_VT_C_NEG_M:</a>
<a name="ln1973">                k = TCG_Minus_M0;</a>
<a name="ln1974">                break;</a>
<a name="ln1975">            case BNS_VT_M_GROUP:</a>
<a name="ln1976">                switch( pTCGroups-&gt;pTCG[i].ord_num ) {</a>
<a name="ln1977">                case 0:</a>
<a name="ln1978">                    k = TCG_MeFlower0;</a>
<a name="ln1979">                    break;</a>
<a name="ln1980">                case 1:</a>
<a name="ln1981">                    k = TCG_MeFlower1;</a>
<a name="ln1982">                    break;</a>
<a name="ln1983">                case 2:</a>
<a name="ln1984">                    k = TCG_MeFlower2;</a>
<a name="ln1985">                    break;</a>
<a name="ln1986">                case 3:</a>
<a name="ln1987">                    k = TCG_MeFlower3;</a>
<a name="ln1988">                    break;</a>
<a name="ln1989">                default:</a>
<a name="ln1990">                    ret = RI_ERR_PROGR; /* unexpected group type */</a>
<a name="ln1991">                    goto exit_function;</a>
<a name="ln1992">                }</a>
<a name="ln1993">                break;</a>
<a name="ln1994"> </a>
<a name="ln1995">            default:</a>
<a name="ln1996">                ret = RI_ERR_PROGR; /* unexpected group type */</a>
<a name="ln1997">                goto exit_function;</a>
<a name="ln1998">            }</a>
<a name="ln1999">            if ( pTCGroups-&gt;nGroup[k] &gt;= 0 || (pTCGroups-&gt;pTCG[i].ord_num &amp;&amp; !IS_BNS_VT_M_GR(pTCGroups-&gt;pTCG[i].type)) ) {</a>
<a name="ln2000">                ret = RI_ERR_PROGR;</a>
<a name="ln2001">                goto exit_function;</a>
<a name="ln2002">            }</a>
<a name="ln2003">            pTCGroups-&gt;nGroup[k] = i; /* ordering number of the Charge group, starting from 0 */</a>
<a name="ln2004">        }</a>
<a name="ln2005">    }</a>
<a name="ln2006">    /* add (+) supergroup */</a>
<a name="ln2007">    n1 = pTCGroups-&gt;nGroup[TCG_Plus0];</a>
<a name="ln2008">    n2 = pTCGroups-&gt;nGroup[TCG_Plus_C0];</a>
<a name="ln2009">    n3 = pTCGroups-&gt;nGroup[TCG_Plus_M0];</a>
<a name="ln2010">    nNumToConnect = (n1&gt;=0) + (n2&gt;=0) + (n3&gt;=0);</a>
<a name="ln2011">    if ( nNumToConnect ) {</a>
<a name="ln2012">        /* if both groups are present then add a supergroup */</a>
<a name="ln2013">        ret = RegisterTCGroup( pTCGroups, BNS_VT_C_POS_ALL, 0,</a>
<a name="ln2014">                               0 /* st_cap */,</a>
<a name="ln2015">                               0 /* st_flow */,</a>
<a name="ln2016">                               0 /* edge cap */,</a>
<a name="ln2017">                               0 /* edge flow */,</a>
<a name="ln2018">                               1+nNumToConnect /* one more edge to connect to an additional (+/-) vertex */ );</a>
<a name="ln2019"> </a>
<a name="ln2020">        if ( ret &lt;= 0 ) {</a>
<a name="ln2021">            ret = !ret? RI_ERR_PROGR : ret;</a>
<a name="ln2022">            goto exit_function;</a>
<a name="ln2023">        }</a>
<a name="ln2024">        pTCGroups-&gt;nGroup[TCG_Plus] = ret - 1; /* newly added group number */</a>
<a name="ln2025">        pTCGroups-&gt;nVertices += 2; /* two vertices including itself */</a>
<a name="ln2026">        pTCGroups-&gt;nEdges    += 1 + nNumToConnect; /* one more edge to connect to an additional (+/-) vertex */</a>
<a name="ln2027">    }</a>
<a name="ln2028">    /* add (-) supergroup */</a>
<a name="ln2029">    n1 = pTCGroups-&gt;nGroup[TCG_Minus0];</a>
<a name="ln2030">    n2 = pTCGroups-&gt;nGroup[TCG_Minus_C0];</a>
<a name="ln2031">    n3 = pTCGroups-&gt;nGroup[TCG_Minus_M0];</a>
<a name="ln2032">    nNumToConnect = (n1&gt;=0) + (n2&gt;=0) + (n3&gt;=0);</a>
<a name="ln2033">    if ( nNumToConnect ) {</a>
<a name="ln2034">        /* if both groups are present then add a supergroup */</a>
<a name="ln2035">        ret = RegisterTCGroup( pTCGroups, BNS_VT_C_NEG_ALL, 0,</a>
<a name="ln2036">                               0 /* st_cap */,</a>
<a name="ln2037">                               0 /* st_flow */,</a>
<a name="ln2038">                               0 /* edge cap */,</a>
<a name="ln2039">                               0 /* edge flow */,</a>
<a name="ln2040">                               1+nNumToConnect /* one more edge to connect to an additional (+/-) vertex */ );</a>
<a name="ln2041"> </a>
<a name="ln2042">        if ( ret &lt; 0 ) {</a>
<a name="ln2043">            goto exit_function;</a>
<a name="ln2044">        }</a>
<a name="ln2045">        pTCGroups-&gt;nGroup[TCG_Minus] = ret - 1; /* newly added group number */</a>
<a name="ln2046">        pTCGroups-&gt;nVertices += 2; /* needs two vertices including itself */</a>
<a name="ln2047">        pTCGroups-&gt;nEdges    += 1 + nNumToConnect; /* one more edge to connect to an additional (+/-) vertex */</a>
<a name="ln2048">    }</a>
<a name="ln2049"> </a>
<a name="ln2050">    /* add neutralization vertex: (+)-()=(-) connection */</a>
<a name="ln2051">    k = pTCGroups-&gt;nGroup[TCG_Minus];</a>
<a name="ln2052">    n = pTCGroups-&gt;nGroup[TCG_Plus];</a>
<a name="ln2053">    nNumToConnect = (k&gt;=0) + (n&gt;=0);</a>
<a name="ln2054">    if ( nNumToConnect ) {</a>
<a name="ln2055">        pTCGroups-&gt;nVertices += 1;</a>
<a name="ln2056">        pTCGroups-&gt;nEdges    += nNumToConnect; /* one edge per super-c-group */</a>
<a name="ln2057">    }</a>
<a name="ln2058"> </a>
<a name="ln2059">    ret = 0;</a>
<a name="ln2060"> </a>
<a name="ln2061">exit_function:</a>
<a name="ln2062">    return ret;</a>
<a name="ln2063">}</a>
<a name="ln2064">/*********************************************************************************/</a>
<a name="ln2065">int AddTGroups2TCGBnStruct( BN_STRUCT *pBNS, StrFromINChI *pStruct, VAL_AT *pVA,</a>
<a name="ln2066">                            ALL_TC_GROUPS *pTCGroups, int nMaxAddEdges )</a>
<a name="ln2067">{</a>
<a name="ln2068">    int ret = 0;</a>
<a name="ln2069">    inp_ATOM *at        = pStruct-&gt;at;</a>
<a name="ln2070">    int       num_atoms = pStruct-&gt;num_atoms;</a>
<a name="ln2071">    int tot_st_cap, tot_st_flow;</a>
<a name="ln2072">    /* ret = ReInitBnStruct( pBNS ); */</a>
<a name="ln2073">    if ( pTCGroups-&gt;num_tgroups /* tgi &amp;&amp; tgi-&gt;num_t_groups &amp;&amp; tgi-&gt;t_group*/ ) {</a>
<a name="ln2074">        int         i, k, endpoint, /*centerpoint,*/ fictpoint;</a>
<a name="ln2075">        int         num_tg       = pTCGroups-&gt;num_tgroups;</a>
<a name="ln2076">        int         num_edges    = pBNS-&gt;num_edges;</a>
<a name="ln2077">        int         num_vertices = pBNS-&gt;num_vertices;</a>
<a name="ln2078">        BNS_VERTEX *vert_ficpoint, *vert_ficpoint_prev;  /* fictitious vertex describing t-group */</a>
<a name="ln2079">        BNS_VERTEX *vert_endpoint;</a>
<a name="ln2080">        BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric endpoint */</a>
<a name="ln2081">        int        nMaxTGroupNumber = 0;</a>
<a name="ln2082">        /*ENDPOINT_INFO eif;*/</a>
<a name="ln2083"> </a>
<a name="ln2084">        /* Debug: check overflow */</a>
<a name="ln2085">        if ( num_vertices + num_tg &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln2086">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2087">        }</a>
<a name="ln2088">        if ( num_edges + pTCGroups-&gt;num_tgroup_edges &gt;= pBNS-&gt;max_edges ) {</a>
<a name="ln2089">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2090">        }</a>
<a name="ln2091">        /* find the largest t-group ID */</a>
<a name="ln2092">        for ( i = 0; i &lt; pTCGroups-&gt;num_tc_groups; i ++ ) {</a>
<a name="ln2093">            if ( pTCGroups-&gt;pTCG[i].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln2094">                k = pTCGroups-&gt;pTCG[i].ord_num;</a>
<a name="ln2095">                if ( k &lt;= 0 ) {</a>
<a name="ln2096">                    return BNS_CPOINT_ERR; /* t-group does not have a number or has a wrong number */</a>
<a name="ln2097">                }</a>
<a name="ln2098">                if ( k &gt; pTCGroups-&gt;num_tc_groups ) {</a>
<a name="ln2099">                    return BNS_CPOINT_ERR; /* t-group has a wrong number */</a>
<a name="ln2100">                }</a>
<a name="ln2101">                if ( k != nMaxTGroupNumber + 1 ) {</a>
<a name="ln2102">                    return BNS_CPOINT_ERR; /* t-group numbers are not contiguously ascending */</a>
<a name="ln2103">                }</a>
<a name="ln2104">                nMaxTGroupNumber = k;</a>
<a name="ln2105">            } else {</a>
<a name="ln2106">                break; /* t-groups are contiguous and first in the list */</a>
<a name="ln2107">            }</a>
<a name="ln2108">        }</a>
<a name="ln2109">        if ( i != num_tg ) {</a>
<a name="ln2110">            return BNS_CPOINT_ERR; /* number of t-groups is wrong */</a>
<a name="ln2111">        }</a>
<a name="ln2112">        /* since t-group IDs may be not contiguous, clear all vertices that will be added.</a>
<a name="ln2113">           all-zeroes-vertex will be ignored by the BNS</a>
<a name="ln2114">        */</a>
<a name="ln2115">        memset( pBNS-&gt;vert+num_vertices, 0, nMaxTGroupNumber*sizeof(pBNS-&gt;vert[0]) );</a>
<a name="ln2116">        /* initialize new fictitious vertices */</a>
<a name="ln2117">        vert_ficpoint_prev = pBNS-&gt;vert+num_vertices - 1;</a>
<a name="ln2118"> </a>
<a name="ln2119">        tot_st_cap = tot_st_flow = 0;</a>
<a name="ln2120"> </a>
<a name="ln2121">        for ( i = 0; i &lt; num_tg; i ++, vert_ficpoint_prev = vert_ficpoint ) {</a>
<a name="ln2122">            /*</a>
<a name="ln2123">              vert_ficpoint-1 is the last vertex;</a>
<a name="ln2124">              vert_ficpoint   is the vertex that is being added</a>
<a name="ln2125">              Note: nGroupNumber are not contiguous</a>
<a name="ln2126">            */</a>
<a name="ln2127">            vert_ficpoint                = pBNS-&gt;vert+num_vertices + pTCGroups-&gt;pTCG[i].ord_num - 1;</a>
<a name="ln2128">            vert_ficpoint-&gt;iedge         = vert_ficpoint_prev-&gt;iedge + vert_ficpoint_prev-&gt;max_adj_edges;</a>
<a name="ln2129">            vert_ficpoint-&gt;max_adj_edges = pTCGroups-&gt;pTCG[i].num_edges+nMaxAddEdges+BNS_ADD_SUPER_TGROUP;</a>
<a name="ln2130">            vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln2131">            vert_ficpoint-&gt;st_edge.flow  = vert_ficpoint-&gt;st_edge.flow0  = 0;</a>
<a name="ln2132">            vert_ficpoint-&gt;st_edge.cap   = vert_ficpoint-&gt;st_edge.cap0   = pTCGroups-&gt;pTCG[i].st_cap;</a>
<a name="ln2133">            tot_st_cap                   += pTCGroups-&gt;pTCG[i].st_cap;</a>
<a name="ln2134">            vert_ficpoint-&gt;type          = pTCGroups-&gt;pTCG[i].type;</a>
<a name="ln2135">            pTCGroups-&gt;pTCG[i].nVertexNumber = vert_ficpoint - pBNS-&gt;vert;</a>
<a name="ln2136">        }</a>
<a name="ln2137"> </a>
<a name="ln2138">        for ( endpoint = 0; endpoint &lt; num_atoms; endpoint ++ ) {</a>
<a name="ln2139">            if ( !at[endpoint].endpoint )</a>
<a name="ln2140">                continue;</a>
<a name="ln2141">            fictpoint = at[endpoint].endpoint + num_vertices - 1;</a>
<a name="ln2142">            vert_ficpoint = pBNS-&gt;vert + fictpoint;  /* t-group vertex */</a>
<a name="ln2143">            vert_endpoint = pBNS-&gt;vert + endpoint;   /* endpoint vertex */</a>
<a name="ln2144">            /* Debug: check overflow */</a>
<a name="ln2145">            if ( fictpoint &gt;= pBNS-&gt;max_vertices ||</a>
<a name="ln2146">                 num_edges &gt;= pBNS-&gt;max_edges    ||</a>
<a name="ln2147">                 vert_ficpoint-&gt;num_adj_edges &gt;= vert_ficpoint-&gt;max_adj_edges ||</a>
<a name="ln2148">                 vert_endpoint-&gt;num_adj_edges &gt;= vert_endpoint-&gt;max_adj_edges ) {</a>
<a name="ln2149">                ret = BNS_VERT_EDGE_OVFL;</a>
<a name="ln2150">                break;</a>
<a name="ln2151">            }</a>
<a name="ln2152">#ifdef NEVER</a>
<a name="ln2153">            /* obtain donor/acceptor info */</a>
<a name="ln2154">            if ( !nGetEndpointInfo( at, endpoint, &amp;eif ) ) {</a>
<a name="ln2155">                ret = BNS_BOND_ERR;</a>
<a name="ln2156">                break;</a>
<a name="ln2157">            }</a>
<a name="ln2158">#endif</a>
<a name="ln2159">            vert_endpoint-&gt;type |= BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln2160">#ifdef NEVER</a>
<a name="ln2161">            /* set capacity = 1 to the edges from the endpoint to the centerpoint(s) */</a>
<a name="ln2162">            for ( k = 0; k &lt; vert_endpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln2163">                int iedge = vert_endpoint-&gt;iedge[k];</a>
<a name="ln2164">                if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln2165">                    /* single bond, possibly between endpoint and centerpoint */</a>
<a name="ln2166">                    centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ endpoint);</a>
<a name="ln2167">                    if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln2168">                         pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln2169">                        int bond_type = (at[endpoint].bond_type[k] &amp; BOND_TYPE_MASK);</a>
<a name="ln2170">                        if (bond_type == BOND_TAUTOM  ||</a>
<a name="ln2171">                            bond_type == BOND_ALTERN  ||</a>
<a name="ln2172">                            bond_type == BOND_ALT12NS ||</a>
<a name="ln2173">                            bond_type == BOND_SINGLE ) {</a>
<a name="ln2174">                            pBNS-&gt;edge[iedge].cap = 1;</a>
<a name="ln2175">                        }</a>
<a name="ln2176">                    }</a>
<a name="ln2177">                }</a>
<a name="ln2178">            }</a>
<a name="ln2179">#endif</a>
<a name="ln2180">            /* create a new edge connecting endpoint to the new fictitious t-group vertex vert_ficpoint */</a>
<a name="ln2181">            edge = pBNS-&gt;edge + num_edges;</a>
<a name="ln2182">            edge-&gt;cap       = vert_endpoint-&gt;st_edge.cap - vert_endpoint-&gt;st_edge.flow;</a>
<a name="ln2183">            edge-&gt;cap       = inchi_min( edge-&gt;cap, MAX_TGROUP_EDGE_CAP );</a>
<a name="ln2184">            edge-&gt;cap       = inchi_max( edge-&gt;cap, 0 );</a>
<a name="ln2185">            edge-&gt;flow      = 0;</a>
<a name="ln2186">            edge-&gt;pass      = 0;</a>
<a name="ln2187">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln2188">            edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln2189">#endif</a>
<a name="ln2190"> </a>
<a name="ln2191">#ifdef NEVER</a>
<a name="ln2192">            /* later include case when the charge change allows the endpoint to become tautomeric */</a>
<a name="ln2193">            /* mark endoint having moveable H atom with flow=1 */</a>
<a name="ln2194"> </a>
<a name="ln2195">            /* -- old &quot;no charges&quot; version -- */</a>
<a name="ln2196">            /* if (at[endpoint].chem_bonds_valence == at[endpoint].valence) */</a>
<a name="ln2197">            /* -- the following line takes charges into account -- */</a>
<a name="ln2198">            if ( eif.cDonor ) /* means the endpoint has an H-atom to donate */</a>
<a name="ln2199">            {</a>
<a name="ln2200">                /* increment edge flow */</a>
<a name="ln2201">                edge-&gt;flow ++;</a>
<a name="ln2202">                /* increment one vertex st-flow &amp; cap */</a>
<a name="ln2203">                vert_ficpoint-&gt;st_edge.flow ++;</a>
<a name="ln2204">                vert_ficpoint-&gt;st_edge.cap ++;</a>
<a name="ln2205">                /* increment another vertex st-flow &amp; cap */</a>
<a name="ln2206">                vert_endpoint-&gt;st_edge.flow ++;</a>
<a name="ln2207">                vert_endpoint-&gt;st_edge.cap ++;</a>
<a name="ln2208">            }</a>
<a name="ln2209">#endif</a>
<a name="ln2210">            /* connect edge to endpoint and fictpoint and increment the counters of neighbors and edges */</a>
<a name="ln2211">            ret = ConnectTwoVertices( vert_endpoint, vert_ficpoint, edge, pBNS, 0 );</a>
<a name="ln2212">            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2213">                break;</a>
<a name="ln2214">            }</a>
<a name="ln2215">            num_edges ++;</a>
<a name="ln2216">            edge-&gt;cap0  = edge-&gt;cap;</a>
<a name="ln2217">            edge-&gt;flow0 = edge-&gt;flow;</a>
<a name="ln2218">            pVA[endpoint].nTautGroupEdge = num_edges; /* edge index + 1 */</a>
<a name="ln2219">        }</a>
<a name="ln2220"> </a>
<a name="ln2221">        pBNS-&gt;num_edges     = num_edges;</a>
<a name="ln2222">        pBNS-&gt;num_vertices += nMaxTGroupNumber;</a>
<a name="ln2223">        pBNS-&gt;num_t_groups  = num_tg;</a>
<a name="ln2224">        pBNS-&gt;tot_st_cap   += tot_st_cap;</a>
<a name="ln2225">        pBNS-&gt;tot_st_flow  += tot_st_flow;</a>
<a name="ln2226"> </a>
<a name="ln2227">    }</a>
<a name="ln2228">    return ret;</a>
<a name="ln2229">}</a>
<a name="ln2230">/*****************************************************************************************************/</a>
<a name="ln2231">int ConnectTwoVertices( BNS_VERTEX *p1, BNS_VERTEX *p2, BNS_EDGE *e, BN_STRUCT *pBNS, int bClearEdge )</a>
<a name="ln2232">{</a>
<a name="ln2233">    int ip1 = p1 - pBNS-&gt;vert;</a>
<a name="ln2234">    int ip2 = p2 - pBNS-&gt;vert;</a>
<a name="ln2235">    int ie  = e  - pBNS-&gt;edge;</a>
<a name="ln2236">    /* debug: check bounds */</a>
<a name="ln2237">    if ( ip1 &gt;= pBNS-&gt;max_vertices || ip1 &lt; 0 ||</a>
<a name="ln2238">         ip2 &gt;= pBNS-&gt;max_vertices || ip2 &lt; 0 ||</a>
<a name="ln2239">         ie  &gt;= pBNS-&gt;max_edges    || ie  &lt; 0 ||</a>
<a name="ln2240">         (p1-&gt;iedge - pBNS-&gt;iedge) &lt; 0 ||</a>
<a name="ln2241">         (p1-&gt;iedge - pBNS-&gt;iedge) + p1-&gt;max_adj_edges &gt; pBNS-&gt;max_iedges ||</a>
<a name="ln2242">         (p2-&gt;iedge - pBNS-&gt;iedge) &lt; 0 ||</a>
<a name="ln2243">         (p2-&gt;iedge - pBNS-&gt;iedge) + p2-&gt;max_adj_edges &gt; pBNS-&gt;max_iedges ||</a>
<a name="ln2244">         p1-&gt;num_adj_edges &gt;= p1-&gt;max_adj_edges ||</a>
<a name="ln2245">         p2-&gt;num_adj_edges &gt;= p2-&gt;max_adj_edges  ) {</a>
<a name="ln2246">        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2247">    }</a>
<a name="ln2248">    /* clear the edge */</a>
<a name="ln2249">    if ( bClearEdge ) {</a>
<a name="ln2250">        memset( e, 0, sizeof(*e) );</a>
<a name="ln2251">    } else</a>
<a name="ln2252">    if ( e-&gt;neighbor1 || e-&gt;neighbor12 ) {</a>
<a name="ln2253">        return BNS_PROGRAM_ERR;</a>
<a name="ln2254">    }</a>
<a name="ln2255">    /* connect */</a>
<a name="ln2256">    e-&gt;neighbor1  = inchi_min( ip1, ip2 );</a>
<a name="ln2257">    e-&gt;neighbor12 = ip1 ^ ip2;</a>
<a name="ln2258">    p1-&gt;iedge[p1-&gt;num_adj_edges] = ie;</a>
<a name="ln2259">    p2-&gt;iedge[p2-&gt;num_adj_edges] = ie;</a>
<a name="ln2260">    e-&gt;neigh_ord[ip1 &gt; ip2] = p1-&gt;num_adj_edges ++;</a>
<a name="ln2261">    e-&gt;neigh_ord[ip1 &lt; ip2] = p2-&gt;num_adj_edges ++;</a>
<a name="ln2262">    return 0;</a>
<a name="ln2263">}</a>
<a name="ln2264"> </a>
<a name="ln2265">/***********************************************************************************************************</a>
<a name="ln2266">                     METAL ATOMS' FLOWER - Provides a source/sink of &quot;free valences&quot;</a>
<a name="ln2267"> ***********************************************************************************************************</a>
<a name="ln2268"> </a>
<a name="ln2269">                    c1+...+cn = 2c+dc  - total cap and flow of edges to the flower base from metal atoms</a>
<a name="ln2270">                    f1+...+fn = 2f+df    they should allow changing bonds to metals from 0-order to triple</a>
<a name="ln2271">                    dc,df = 0 or 1       hence c=3*n, f=0 (initial zero bond order) or n</a>
<a name="ln2272"> Gi=vertex(M-group)</a>
<a name="ln2273"> Ci=its st_cap                  [C3,F3]  C0 = F0 = 2c + 2D + dc    (st_cap &amp; st_flow)</a>
<a name="ln2274"> Fi=its st_flow               G3         C2 = F2 =  c + 2D                           </a>
<a name="ln2275">                              / \        C1 = F1 =  c + 2D + dc-df                   </a>
<a name="ln2276"> ci=cap of edge i       cx,fx/   \cy,fy  C3 = F3 =  0                                 </a>
<a name="ln2277"> fi=edge flow               /     \                                             Constraints</a>
<a name="ln2278">                    [C2,F2]/ cd,fd \[C1,F1]                                     -----------------</a>
<a name="ln2279">                         G2--------G1                                           fa+fb+2f+df=F0=C0</a>
<a name="ln2280">                          \        /          ca =  c + 2D         (edge cap)   fa+fd      =F2=C2</a>
<a name="ln2281">                      ca,fa \    / cb,fb      fa =  c +  D - f     (edge flow)  fb+fd      =C1=F1</a>
<a name="ln2282">                             \  /                                               fi &lt;= ci</a>
<a name="ln2283">                              G0 [C0,F0]      cb =  c + 2D + dc                 -----------------</a>
<a name="ln2284">                              /\              fb =  c +  D + dc - (f + df)    </a>
<a name="ln2285">   ci=3, fi=0 or 1   c1,f1  /... \ cn,fn                            ------------------------------------</a>
<a name="ln2286">                          /       \           cd =  c + 2D          D is an arbitrary integer &gt; 0</a>
<a name="ln2287">   all n Metal atoms:    M1 ...    Mn         fd =  f +  D          it allows one to apply</a>
<a name="ln2288">                                                                    C3++ (add st_flow to cancel radicals)</a>
<a name="ln2289">  For each Mi add cap and flow=cap            cx = cy = D           D times.</a>
<a name="ln2290">  to M-charge group                           fx = fy = 0</a>
<a name="ln2291">       --------------------------------------------------------------------------------------</a>
<a name="ln2292">                 |  f=0                   |  f=c, dc&gt;=df         |  0 &lt;= 2f+df &lt;= 2c+dc</a>
<a name="ln2293">         edge    +------------------------+-----------+----------+-------------+-------------</a>
<a name="ln2294">                 |  flow      |  rescap   |  flow     |  rescap  |  flow       |  rescap  </a>
<a name="ln2295">       ----------+------------+-----------+-----------+----------+-------------+-------------</a>
<a name="ln2296">        f1+..+fn |  df        |  2c+dc-df |  2c+df    |  dc-df   |  2f+df      |  2c-2f+dc-df</a>
<a name="ln2297">              fa |  c+D       |  D        |  D        |  c+D     |  c+D-f      |  c+D     </a>
<a name="ln2298">              fb |  c+D+dc-df |  D+df     |  D+dc-df  |  c+D+df  |  c+D+dc-f-df|  c+D+df  </a>
<a name="ln2299">              fd |  D         |  c+D      |  c+D      |  D       |  f+D        |  D       </a>
<a name="ln2300">       --------------------------------------------------------------------------------------</a>
<a name="ln2301">***********************************************************************************************************/</a>
<a name="ln2302">int AddRadicalToMetal( int *tot_st_cap, int *tot_st_flow, ICHICONST SRM *pSrm, BN_STRUCT *pBNS, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln2303">{</a>
<a name="ln2304">    int iG0 = pTCGroups-&gt;nGroup[TCG_MeFlower0]; /* index in pTCGroups-&gt;pTCG[] */</a>
<a name="ln2305">    int iG1 = pTCGroups-&gt;nGroup[TCG_MeFlower1];</a>
<a name="ln2306">    int iG2 = pTCGroups-&gt;nGroup[TCG_MeFlower2];</a>
<a name="ln2307">    int iG3 = pTCGroups-&gt;nGroup[TCG_MeFlower3];</a>
<a name="ln2308">    int n   = (iG0&gt;=0) + (iG1&gt;=0) + (iG2&gt;=0) + (iG3&gt;=0);</a>
<a name="ln2309">    int vG0, vG1, vG2, vG3;  /* M-vertex number */</a>
<a name="ln2310">    BNS_VERTEX *pG0=NULL, *pG1=NULL, *pG2=NULL, *pG3=NULL;</a>
<a name="ln2311"> </a>
<a name="ln2312">    if ( pTCGroups-&gt;num_metal_atoms &amp;&amp;</a>
<a name="ln2313">         pSrm-&gt;bMetalAddFlower      &amp;&amp;</a>
<a name="ln2314">         *tot_st_cap % 2            &amp;&amp;</a>
<a name="ln2315">         n == 4 ) {</a>
<a name="ln2316">        vG0 = pTCGroups-&gt;pTCG[iG0].nVertexNumber;</a>
<a name="ln2317">        vG1 = pTCGroups-&gt;pTCG[iG1].nVertexNumber;</a>
<a name="ln2318">        vG2 = pTCGroups-&gt;pTCG[iG2].nVertexNumber;</a>
<a name="ln2319">        vG3 = pTCGroups-&gt;pTCG[iG3].nVertexNumber;</a>
<a name="ln2320"> </a>
<a name="ln2321">        pG0 = pBNS-&gt;vert+vG0;</a>
<a name="ln2322">        pG1 = pBNS-&gt;vert+vG1;</a>
<a name="ln2323">        pG2 = pBNS-&gt;vert+vG2;</a>
<a name="ln2324">        pG3 = pBNS-&gt;vert+vG3;</a>
<a name="ln2325"> </a>
<a name="ln2326">        /* add 1 unit to metal flower st_cap */</a>
<a name="ln2327">        pG3-&gt;st_edge.cap  ++;</a>
<a name="ln2328">        pG3-&gt;st_edge.cap0 ++;</a>
<a name="ln2329">        (*tot_st_cap)     ++;</a>
<a name="ln2330">        return 1;</a>
<a name="ln2331">    }</a>
<a name="ln2332">    return 0;</a>
<a name="ln2333">}</a>
<a name="ln2334">/***********************************************************************************************************/</a>
<a name="ln2335">int ConnectMetalFlower( int *pcur_num_vertices, int *pcur_num_edges,</a>
<a name="ln2336">                        int *tot_st_cap, int *tot_st_flow, ICHICONST SRM *pSrm,</a>
<a name="ln2337">                        BN_STRUCT *pBNS, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln2338">{</a>
<a name="ln2339">    int iG0 = pTCGroups-&gt;nGroup[TCG_MeFlower0]; /* index in pTCGroups-&gt;pTCG[] */</a>
<a name="ln2340">    int iG1 = pTCGroups-&gt;nGroup[TCG_MeFlower1];</a>
<a name="ln2341">    int iG2 = pTCGroups-&gt;nGroup[TCG_MeFlower2];</a>
<a name="ln2342">    int iG3 = pTCGroups-&gt;nGroup[TCG_MeFlower3];</a>
<a name="ln2343">    int n   = (iG0&gt;=0) + (iG1&gt;=0) + (iG2&gt;=0) + (iG3&gt;=0);</a>
<a name="ln2344">    int vG0, vG1, vG2, vG3;  /* M-vertex number */</a>
<a name="ln2345">    int cur_num_edges    = *pcur_num_edges;</a>
<a name="ln2346">    int cur_num_vertices = *pcur_num_vertices;</a>
<a name="ln2347">    BNS_VERTEX *pG0=NULL, *pG1=NULL, *pG2=NULL, *pG3=NULL;</a>
<a name="ln2348">    BNS_EDGE   *ea=NULL, *eb=NULL, *ed=NULL, *ex=NULL, *ey=NULL, *e;</a>
<a name="ln2349">    int         ia, ib, id, ix, iy;</a>
<a name="ln2350">    int         c, f, dc, df, ca, fa, cb, fb, cd, fd, cx, fx, cy, fy;</a>
<a name="ln2351">    int         C0, F0, C1, F1, C2, F2, C3, F3, D;</a>
<a name="ln2352">    int         ret = 0, i;</a>
<a name="ln2353"> </a>
<a name="ln2354">    if ( 0 == n ) {</a>
<a name="ln2355">        goto exit_function;</a>
<a name="ln2356">    }</a>
<a name="ln2357">    if ( 4 != n ) {</a>
<a name="ln2358">        ret = RI_ERR_PROGR;</a>
<a name="ln2359">        goto exit_function;</a>
<a name="ln2360">    }</a>
<a name="ln2361">    vG0 = pTCGroups-&gt;pTCG[iG0].nVertexNumber;</a>
<a name="ln2362">    vG1 = pTCGroups-&gt;pTCG[iG1].nVertexNumber;</a>
<a name="ln2363">    vG2 = pTCGroups-&gt;pTCG[iG2].nVertexNumber;</a>
<a name="ln2364">    vG3 = pTCGroups-&gt;pTCG[iG3].nVertexNumber;</a>
<a name="ln2365"> </a>
<a name="ln2366">    pG0 = pBNS-&gt;vert+vG0;</a>
<a name="ln2367">    pG1 = pBNS-&gt;vert+vG1;</a>
<a name="ln2368">    pG2 = pBNS-&gt;vert+vG2;</a>
<a name="ln2369">    pG3 = pBNS-&gt;vert+vG3;</a>
<a name="ln2370"> </a>
<a name="ln2371">    /* count G0 edges cap and flow (currently only atoms are connected to G0) */</a>
<a name="ln2372">    for ( i = 0, c = 0, f = 0; i &lt; pG0-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln2373">        e = pBNS-&gt;edge + pG0-&gt;iedge[i];</a>
<a name="ln2374">        c += e-&gt;cap;</a>
<a name="ln2375">        f += e-&gt;flow;</a>
<a name="ln2376">    }</a>
<a name="ln2377"> </a>
<a name="ln2378">    /* consistency checks */</a>
<a name="ln2379">    if ( !IS_BNS_VT_M_GR(pTCGroups-&gt;pTCG[iG0].type) &amp;&amp;</a>
<a name="ln2380">         (pTCGroups-&gt;pTCG[iG0].edges_cap != pG0-&gt;st_edge.cap ||</a>
<a name="ln2381">          pTCGroups-&gt;pTCG[iG0].edges_flow != pG0-&gt;st_edge.flow) ) {</a>
<a name="ln2382">        ret = RI_ERR_PROGR;</a>
<a name="ln2383">        goto exit_function;</a>
<a name="ln2384">    }</a>
<a name="ln2385">    if ( pTCGroups-&gt;pTCG[iG0].edges_cap  != c ||</a>
<a name="ln2386">         pTCGroups-&gt;pTCG[iG0].edges_flow != f ) {</a>
<a name="ln2387">        ret = RI_ERR_PROGR;</a>
<a name="ln2388">        goto exit_function;</a>
<a name="ln2389">    }</a>
<a name="ln2390">    </a>
<a name="ln2391">    /* get new edges */</a>
<a name="ln2392"> </a>
<a name="ln2393">    ea = pBNS-&gt;edge + (ia=cur_num_edges++);</a>
<a name="ln2394">    eb = pBNS-&gt;edge + (ib=cur_num_edges++);</a>
<a name="ln2395">    ed = pBNS-&gt;edge + (id=cur_num_edges++);</a>
<a name="ln2396">    ex = pBNS-&gt;edge + (ix=cur_num_edges++);</a>
<a name="ln2397">    ey = pBNS-&gt;edge + (iy=cur_num_edges++);</a>
<a name="ln2398"> </a>
<a name="ln2399">    /* connect vertices with edges */</a>
<a name="ln2400">    ret = ConnectTwoVertices( pG0, pG1, eb, pBNS, 1 );</a>
<a name="ln2401">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2402">        goto exit_function;</a>
<a name="ln2403">    }</a>
<a name="ln2404">    ret = ConnectTwoVertices( pG0, pG2, ea, pBNS, 1 );</a>
<a name="ln2405">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2406">        goto exit_function;</a>
<a name="ln2407">    }</a>
<a name="ln2408">    ret = ConnectTwoVertices( pG1, pG2, ed, pBNS, 1 );</a>
<a name="ln2409">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2410">        goto exit_function;</a>
<a name="ln2411">    }</a>
<a name="ln2412">    ret = ConnectTwoVertices( pG1, pG3, ey, pBNS, 1 );</a>
<a name="ln2413">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2414">        goto exit_function;</a>
<a name="ln2415">    }</a>
<a name="ln2416">    ret = ConnectTwoVertices( pG2, pG3, ex, pBNS, 1 );</a>
<a name="ln2417">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2418">        goto exit_function;</a>
<a name="ln2419">    }</a>
<a name="ln2420"> </a>
<a name="ln2421">    /* calculate caps and flows */</a>
<a name="ln2422"> </a>
<a name="ln2423">    dc  = c % 2;</a>
<a name="ln2424">    c  /= 2;</a>
<a name="ln2425">    df  = f % 2;</a>
<a name="ln2426">    f  /= 2;</a>
<a name="ln2427"> </a>
<a name="ln2428">    D = pSrm-&gt;nMetalFlowerParam_D;</a>
<a name="ln2429">    </a>
<a name="ln2430">    C0 = F0 = 2*c + 2*D + dc;</a>
<a name="ln2431">    C1 = F1 =   c + 2*D + dc - df;</a>
<a name="ln2432">    C2 = F2 =   c + 2*D;</a>
<a name="ln2433">    C3 = F3 =   0;</a>
<a name="ln2434">    </a>
<a name="ln2435">    ca =  c + 2*D;</a>
<a name="ln2436">    fa =  c +   D - f;</a>
<a name="ln2437">    </a>
<a name="ln2438">    cb =  c + 2*D + dc;</a>
<a name="ln2439">    fb =  c +   D + dc - ( f + df );</a>
<a name="ln2440">    </a>
<a name="ln2441">    cd =  c + 2*D;</a>
<a name="ln2442">    fd =  f +   D;</a>
<a name="ln2443">    </a>
<a name="ln2444">    cx = cy = D;</a>
<a name="ln2445">    fx = fy = 0;</a>
<a name="ln2446"> </a>
<a name="ln2447">    /* check overflow */</a>
<a name="ln2448">    if ( C0 &gt;= EDGE_FLOW_ST_MASK || F0 &gt;= EDGE_FLOW_ST_MASK ||</a>
<a name="ln2449">         C1 &gt;= EDGE_FLOW_ST_MASK || F1 &gt;= EDGE_FLOW_ST_MASK ||</a>
<a name="ln2450">         C2 &gt;= EDGE_FLOW_ST_MASK || F2 &gt;= EDGE_FLOW_ST_MASK ||</a>
<a name="ln2451">         C3 &gt;= EDGE_FLOW_ST_MASK || F3 &gt;= EDGE_FLOW_ST_MASK ) {</a>
<a name="ln2452">        return BNS_PROGRAM_ERR; /* cannot handle too large st-cap or st-flow */</a>
<a name="ln2453">    }</a>
<a name="ln2454"> </a>
<a name="ln2455">    /* set st caps and flows */</a>
<a name="ln2456"> </a>
<a name="ln2457">    SetStCapFlow( pG0, tot_st_flow, tot_st_cap, C0, F0 );</a>
<a name="ln2458">    SetStCapFlow( pG1, tot_st_flow, tot_st_cap, C1, F1 );</a>
<a name="ln2459">    SetStCapFlow( pG2, tot_st_flow, tot_st_cap, C2, F2 );</a>
<a name="ln2460">    SetStCapFlow( pG3, tot_st_flow, tot_st_cap, C3, F3 );</a>
<a name="ln2461"> </a>
<a name="ln2462">    SetEdgeCapFlow( ea, ca, fa );</a>
<a name="ln2463">    SetEdgeCapFlow( eb, cb, fb );</a>
<a name="ln2464">    SetEdgeCapFlow( ed, cd, fd );</a>
<a name="ln2465">    SetEdgeCapFlow( ex, cx, fx );</a>
<a name="ln2466">    SetEdgeCapFlow( ey, cy, fy );</a>
<a name="ln2467"> </a>
<a name="ln2468"> </a>
<a name="ln2469">    *pcur_num_edges    = cur_num_edges;</a>
<a name="ln2470">    *pcur_num_vertices = cur_num_vertices;</a>
<a name="ln2471"> </a>
<a name="ln2472">    ret = 0;</a>
<a name="ln2473">    </a>
<a name="ln2474">exit_function:</a>
<a name="ln2475"> </a>
<a name="ln2476">    return ret;</a>
<a name="ln2477">}</a>
<a name="ln2478">/********************************************************************************/</a>
<a name="ln2479">void SetEdgeCapFlow( BNS_EDGE *e, int edge_cap, int edge_flow )</a>
<a name="ln2480">{</a>
<a name="ln2481">    e-&gt;cap  = e-&gt;cap0  = edge_cap;</a>
<a name="ln2482">    e-&gt;flow = e-&gt;flow0 = edge_flow;</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">/*********************************************************************************</a>
<a name="ln2486">  Add cap and flow to an edge</a>
<a name="ln2487">  Add edge flow to the source vertex st_flow</a>
<a name="ln2488">  Add edge cap &amp; flow to the destination vertex cap and flow</a>
<a name="ln2489"> *********************************************************************************/</a>
<a name="ln2490">int AddEdgeFlow( int edge_cap, int edge_flow, BNS_EDGE *e01, BNS_VERTEX *pSrc /*src*/,</a>
<a name="ln2491">                  BNS_VERTEX *pDst/*dest*/, int *tot_st_cap, int *tot_st_flow )</a>
<a name="ln2492">{</a>
<a name="ln2493">    /* overflow chaeck */</a>
<a name="ln2494">    if ( e01-&gt;cap &lt; 0 || edge_cap &lt; 0 ||  (int)e01-&gt;cap + edge_cap &gt;= EDGE_FLOW_MASK ) {</a>
<a name="ln2495">        return BNS_PROGRAM_ERR;</a>
<a name="ln2496">    }</a>
<a name="ln2497">    if ( pDst-&gt;st_edge.cap  &lt; 0 || (int)pDst-&gt;st_edge.cap  + edge_cap  &gt;= EDGE_FLOW_ST_MASK ||</a>
<a name="ln2498">         pDst-&gt;st_edge.flow &lt; 0 || (int)pDst-&gt;st_edge.flow + edge_flow &gt;= EDGE_FLOW_ST_MASK ||</a>
<a name="ln2499">         pSrc-&gt;st_edge.cap  &lt; 0 || pSrc-&gt;st_edge.flow &lt; 0 ||</a>
<a name="ln2500">                                   (int)pSrc-&gt;st_edge.flow + edge_flow &gt;= EDGE_FLOW_ST_MASK ) {</a>
<a name="ln2501">        return BNS_PROGRAM_ERR;</a>
<a name="ln2502">    }</a>
<a name="ln2503">    /* add flow */</a>
<a name="ln2504">    e01-&gt;cap    += edge_cap;</a>
<a name="ln2505">    e01-&gt;flow   += edge_flow;</a>
<a name="ln2506">    e01-&gt;cap0    = e01-&gt;cap;</a>
<a name="ln2507">    e01-&gt;flow0   = e01-&gt;flow;</a>
<a name="ln2508"> </a>
<a name="ln2509">    pDst-&gt;st_edge.cap  += edge_cap;</a>
<a name="ln2510">    pDst-&gt;st_edge.cap0  = pDst-&gt;st_edge.cap;</a>
<a name="ln2511">    *tot_st_cap        += edge_cap;</a>
<a name="ln2512"> </a>
<a name="ln2513">    pDst-&gt;st_edge.flow += edge_flow;</a>
<a name="ln2514">    pDst-&gt;st_edge.flow0 = pDst-&gt;st_edge.flow;</a>
<a name="ln2515">    *tot_st_flow       += edge_flow;</a>
<a name="ln2516"> </a>
<a name="ln2517">    pSrc-&gt;st_edge.flow += edge_flow;</a>
<a name="ln2518">    pSrc-&gt;st_edge.flow0 = pSrc-&gt;st_edge.flow;</a>
<a name="ln2519">    *tot_st_flow       += edge_flow;</a>
<a name="ln2520"> </a>
<a name="ln2521">/*</a>
<a name="ln2522">    pDst-&gt;st_edge.cap  += e01-&gt;cap;</a>
<a name="ln2523">    pDst-&gt;st_edge.cap0  = pDst-&gt;st_edge.cap;</a>
<a name="ln2524">    *tot_st_cap       += e01-&gt;cap;</a>
<a name="ln2525"> </a>
<a name="ln2526">    pDst-&gt;st_edge.flow += e01-&gt;flow;</a>
<a name="ln2527">    pDst-&gt;st_edge.flow0 = pDst-&gt;st_edge.flow;</a>
<a name="ln2528">    *tot_st_flow      += e01-&gt;flow;</a>
<a name="ln2529"> </a>
<a name="ln2530">    pSrc-&gt;st_edge.flow += e01-&gt;flow;</a>
<a name="ln2531">    pSrc-&gt;st_edge.flow0 = pSrc-&gt;st_edge.flow;</a>
<a name="ln2532">    *tot_st_flow      += e01-&gt;flow;</a>
<a name="ln2533">*/</a>
<a name="ln2534">    return 0;</a>
<a name="ln2535">}</a>
<a name="ln2536">/**************************************************************</a>
<a name="ln2537">     (+) and (-) group V - connection</a>
<a name="ln2538">     ================================</a>
<a name="ln2539"> </a>
<a name="ln2540">  BNS_VERT_TYPE__AUX    (+/-)-connection</a>
<a name="ln2541">                    (v)  st_cap  = </a>
<a name="ln2542">                    / \  st_flow = (cap0 - Delta0 - flow0) + (cap1 - Delta1 -flow1)</a>
<a name="ln2543">                   /   \   </a>
<a name="ln2544">                  /     \   cap  =  cap1</a>
<a name="ln2545">                 /       \  flow = (cap1 - Delta1 - flow1)</a>
<a name="ln2546">                /         \</a>
<a name="ln2547">              (-)         (+)  st_cap  = cap1</a>
<a name="ln2548">             /   \       /   \ st_flow = cap1 - Delta1</a>
<a name="ln2549">            /cap0 \     /cap1 \</a>
<a name="ln2550">             flow0       flow1</a>
<a name="ln2551">    </a>
<a name="ln2552">***************************************************************</a>
<a name="ln2553"> </a>
<a name="ln2554">     (+) supergroup Y - connection</a>
<a name="ln2555">     ==============================</a>
<a name="ln2556">     </a>
<a name="ln2557">                           (+) BNS_VT_C_POS_ALL  (+) supergroup</a>
<a name="ln2558">      Delta0                |                    ==============</a>
<a name="ln2559">      not shown             |  cap  = cap0+cap1</a>
<a name="ln2560">                            |  flow = flow0+flow1-Delta0-Delta1</a>
<a name="ln2561">       BNS_VERT_TYPE__AUX  (y) &lt;------------------ additional vertex: st_cap  = cap0+cap1</a>
<a name="ln2562">                           / \                                        st_flow = cap0+cap1</a>
<a name="ln2563">         cap=cap0         /   \  cap  = cap1</a>
<a name="ln2564">         flow=cap0-flow0 /     \ flow = cap1 - flow1 - Delta1</a>
<a name="ln2565">             -Delta0    /       \</a>
<a name="ln2566">                not-C (+)       (+) Carbons         st_cap  = cap1</a>
<a name="ln2567">         BNS_VT_C_POS / \       / \ BNS_VT_C_POS_C  st_flow = cap1 - Delta1</a>
<a name="ln2568">                     /   \     /   \</a>
<a name="ln2569">        totals      cap0        cap1 = sum of all cap  going up into (+) from atoms or ChargeStruct</a>
<a name="ln2570">        to (+):     flow0       flow1= sum of all flow going up into (+)</a>
<a name="ln2571">                   Delta0       Delta1 = st_cap(+)-st_flow(+) before connection</a>
<a name="ln2572">  Observations</a>
<a name="ln2573">  ============</a>
<a name="ln2574">  A. Any Delta &gt; 0 on (+) or (-) group decreases total (signed) charge by Delta</a>
<a name="ln2575"> </a>
<a name="ln2576">  B. Any alt path from an atom through ChargeStruct to an atom</a>
<a name="ln2577">     does not change the total charge</a>
<a name="ln2578"> </a>
<a name="ln2579">  C. st_flow(+/-) = cap(+)-flow(+)-Delta(+) + cap(-)-flow(-)-Delta(-) =</a>
<a name="ln2580">                  = charge(+) + |max (-) charge| + charge(-) = const</a>
<a name="ln2581">     (charge conservation)</a>
<a name="ln2582"> </a>
<a name="ln2583">  D. To decrease total charge: increase st_cap on (+) or (-) group, including supergroup</a>
<a name="ln2584">  E. To increase total charge: increase st_cap on any (y) or (v)-connecting vertex</a>
<a name="ln2585"> </a>
<a name="ln2586">  F. To cancel charges: </a>
<a name="ln2587">       1. Forbid (+/-)-(+) or (+/-)-(-) edge</a>
<a name="ln2588">       2. Add delta&gt;0 to (+/-) st_cap</a>
<a name="ln2589">       3. Add same delta to (+) or (-) st_cap</a>
<a name="ln2590"> </a>
<a name="ln2591"> </a>
<a name="ln2592">****************************************************************/</a>
<a name="ln2593"> </a>
<a name="ln2594">/************************************************************************************</a>
<a name="ln2595">     j2,j3 &lt; j1 &lt; j0</a>
<a name="ln2596"> </a>
<a name="ln2597">                                (+/-) &lt;---- next step; if does not exist then </a>
<a name="ln2598">                                /   \                  st_cap1' := st_flow1'</a>
<a name="ln2599">                               /     \</a>
<a name="ln2600">                              /       \ st_cap1' := cap01'</a>
<a name="ln2601">                        pv1 (+)super    st_flow1':= cap01'-flow01' = flow02'+flow03'     </a>
<a name="ln2602">                        j1   |</a>
<a name="ln2603">                             |           cap01' := st_cap0'</a>
<a name="ln2604">                             |           flow01':= st_cap0'-flow02'-flow03'</a>
<a name="ln2605">                             |</a>
<a name="ln2606">                             |           st_cap0' :=</a>
<a name="ln2607">                            ( )  pv0,j0  st_flow0':= cap2+st_cap3</a>
<a name="ln2608">                           /   \</a>
<a name="ln2609">                          /     \   cap03'  = cap3</a>
<a name="ln2610">                         /       \  flow03' = cap3 - flow3 - Delta3</a>
<a name="ln2611">                        /         \</a>
<a name="ln2612">   st_cap2, st_flow2  (+)         (+C)        st_cap3'  := cap3</a>
<a name="ln2613">                      pv2,j2      pv3,j3      st_flow3' := cap3-Delta3</a>
<a name="ln2614">                    /    \       /    \       Delta3    := st_cap3 - st_flow3</a>
<a name="ln2615">                cap2, flow2     cap3, flow3 = sums of incoming</a>
<a name="ln2616"> **************************************************************************************/</a>
<a name="ln2617"> </a>
<a name="ln2618">int ConnectSuperCGroup( int nSuperCGroup, int nAddGroups[], int num_add,</a>
<a name="ln2619">                        int *pcur_num_vertices, int *pcur_num_edges,</a>
<a name="ln2620">                        int *tot_st_cap, int *tot_st_flow,</a>
<a name="ln2621">                        BN_STRUCT *pBNS, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln2622">{</a>
<a name="ln2623">    BNS_EDGE   **e0X = NULL, *e;</a>
<a name="ln2624">    BNS_VERTEX **pvX = NULL, *pv0=NULL, *pv1=NULL, *pv=NULL;</a>
<a name="ln2625">    int         *jX  = NULL, *iX = NULL;</a>
<a name="ln2626">    int        i, j, num_groups, j0, i1, j1, iXX, ret = 0, fst=0;</a>
<a name="ln2627">    int        cur_num_vertices = *pcur_num_vertices;</a>
<a name="ln2628">    int        cur_num_edges    = *pcur_num_edges;</a>
<a name="ln2629"> </a>
<a name="ln2630">    if ( nSuperCGroup &gt;= 0 ) {</a>
<a name="ln2631">        i1 = pTCGroups-&gt;nGroup[nSuperCGroup]; /* the supergroup */</a>
<a name="ln2632">        if ( i1 &lt; 0 )</a>
<a name="ln2633">            return 0;</a>
<a name="ln2634">    } else {</a>
<a name="ln2635">        i1 = -1;</a>
<a name="ln2636">        fst = 1;</a>
<a name="ln2637">    }</a>
<a name="ln2638"> </a>
<a name="ln2639">    for ( i = num_groups = 0; i &lt; num_add; i ++ ) {</a>
<a name="ln2640">        iXX = pTCGroups-&gt;nGroup[nAddGroups[i]];</a>
<a name="ln2641">        num_groups += (iXX &gt;= 0 &amp;&amp; iXX != i1);</a>
<a name="ln2642">    }</a>
<a name="ln2643">    if ( num_groups &lt; 1 ) {  /* Y connect only 2 or more groups; V connects even 1 group */</a>
<a name="ln2644">        return 0;</a>
<a name="ln2645">    }</a>
<a name="ln2646"> </a>
<a name="ln2647">    e0X = (BNS_EDGE   **)inchi_calloc( num_groups + 1, sizeof(e0X[0]) );</a>
<a name="ln2648">    pvX = (BNS_VERTEX **)inchi_calloc( num_groups + 1, sizeof(pvX[0]) );</a>
<a name="ln2649">    jX  = (int         *)inchi_calloc( num_groups + 1, sizeof(jX[0]) );</a>
<a name="ln2650">    iX  = (int         *)inchi_calloc( num_groups + 1, sizeof(iX[0]) );</a>
<a name="ln2651">    if ( !e0X || !pvX || !jX || !iX ) {</a>
<a name="ln2652">        ret = RI_ERR_ALLOC;</a>
<a name="ln2653">        goto exit_function;</a>
<a name="ln2654">    }</a>
<a name="ln2655">    /* create vert_ficpoint -- central Y-connection vertex */</a>
<a name="ln2656">    j0 = cur_num_vertices;</a>
<a name="ln2657">    pv0 = pBNS-&gt;vert + j0; /* center of the Y-connection; has number j0 */</a>
<a name="ln2658">    pv0-&gt;iedge = (pv0 - 1)-&gt;iedge + (pv0 - 1)-&gt;max_adj_edges;</a>
<a name="ln2659">    pv0-&gt;max_adj_edges = num_groups + 1 + BNS_ADD_EDGES; /* Y-connection num. edges */</a>
<a name="ln2660">    pv0-&gt;num_adj_edges = 0; /* nothing connected yet */</a>
<a name="ln2661">    pv0-&gt;type          = BNS_VT_YVCONNECTOR;</a>
<a name="ln2662">    cur_num_vertices ++;</a>
<a name="ln2663"> </a>
<a name="ln2664">    if ( fst == 0 ) {</a>
<a name="ln2665">        /* find super c-group vertex pv1, number j1 */</a>
<a name="ln2666">        jX[0]  = j1 = pTCGroups-&gt;pTCG[i1].nVertexNumber;</a>
<a name="ln2667">        iX[0]  = i1;</a>
<a name="ln2668">        pvX[0] = pv1 = pBNS-&gt;vert + j1;</a>
<a name="ln2669">    }</a>
<a name="ln2670">    /* find other c-group vertices */</a>
<a name="ln2671">    for( i = 0, j = 1; i &lt; num_add; i ++ ) {</a>
<a name="ln2672">        iXX = pTCGroups-&gt;nGroup[nAddGroups[i]];</a>
<a name="ln2673">        if ( (iXX &gt;= 0) &amp;&amp; (iXX != i1) ) {</a>
<a name="ln2674">            iX[j] = iXX;</a>
<a name="ln2675">            jX[j] = pTCGroups-&gt;pTCG[iXX].nVertexNumber;</a>
<a name="ln2676">            pvX[j] = pBNS-&gt;vert + jX[j];</a>
<a name="ln2677">            j ++;</a>
<a name="ln2678">        }</a>
<a name="ln2679">    }</a>
<a name="ln2680"> </a>
<a name="ln2681">    /* grab (num_groups+1) free edges */</a>
<a name="ln2682">    for ( i = fst; i &lt;= num_groups; i ++ ) {</a>
<a name="ln2683">        e = e0X[i] = pBNS-&gt;edge + cur_num_edges;</a>
<a name="ln2684">        pv = pvX[i];</a>
<a name="ln2685">        j  = jX[i];</a>
<a name="ln2686">        iXX = iX[i];</a>
<a name="ln2687">        /* connect all to pv0 */</a>
<a name="ln2688">        ret = ConnectTwoVertices( pv0, pv, e, pBNS, 1 );</a>
<a name="ln2689">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2690">            goto exit_function;</a>
<a name="ln2691">        }</a>
<a name="ln2692">        if ( i ) {</a>
<a name="ln2693">            /* from c-group to central Y-connecting vertex of from supergroup to (+/-) vertex */</a>
<a name="ln2694">            pTCGroups-&gt;pTCG[iX[i]].nForwardEdge = cur_num_edges;</a>
<a name="ln2695">        } else {</a>
<a name="ln2696">            /* from central Y-connecting vertex to supergroup */</a>
<a name="ln2697">            pTCGroups-&gt;pTCG[iX[i]].nBackwardEdge = cur_num_edges;</a>
<a name="ln2698">        }</a>
<a name="ln2699">        cur_num_edges ++;</a>
<a name="ln2700">    }</a>
<a name="ln2701">    /* set flow and cap for incoming into pv0 edges */</a>
<a name="ln2702">    for ( i = 1; i &lt;= num_groups; i ++ ) {</a>
<a name="ln2703">        int nDelta    = pTCGroups-&gt;pTCG[iX[i]].st_cap - pTCGroups-&gt;pTCG[iX[i]].edges_cap;</a>
<a name="ln2704">        int edge_cap  = pTCGroups-&gt;pTCG[iX[i]].edges_cap + nDelta; /* added nDelta */</a>
<a name="ln2705">        int edge_flow = pTCGroups-&gt;pTCG[iX[i]].edges_cap-pTCGroups-&gt;pTCG[iX[i]].edges_flow /*-nDelta*/;</a>
<a name="ln2706">        ret = AddEdgeFlow( edge_cap, edge_flow,</a>
<a name="ln2707">                     e0X[i], pvX[i]/*src*/, pv0 /* dest*/, tot_st_cap, tot_st_flow );</a>
<a name="ln2708">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2709">            goto exit_function;</a>
<a name="ln2710">        }</a>
<a name="ln2711">    }</a>
<a name="ln2712">    if ( fst == 0 ) {</a>
<a name="ln2713">        /* set flow and cap for going out of pv0 and into pv1 edge */</a>
<a name="ln2714">        int edge_cap  = pv0-&gt;st_edge.cap;</a>
<a name="ln2715">        int edge_flow = pv0-&gt;st_edge.cap - pv0-&gt;st_edge.flow;</a>
<a name="ln2716">        ret = AddEdgeFlow( pv0-&gt;st_edge.cap, pv0-&gt;st_edge.cap - pv0-&gt;st_edge.flow,</a>
<a name="ln2717">                     e0X[0], pv0/*src*/, pv1 /* dest*/, tot_st_cap, tot_st_flow );</a>
<a name="ln2718">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln2719">            goto exit_function;</a>
<a name="ln2720">        }</a>
<a name="ln2721">        pTCGroups-&gt;pTCG[iX[0]].edges_cap  += edge_cap;</a>
<a name="ln2722">        pTCGroups-&gt;pTCG[iX[0]].edges_flow += edge_flow;</a>
<a name="ln2723">        pTCGroups-&gt;pTCG[iX[0]].st_cap     += edge_cap;</a>
<a name="ln2724">        pTCGroups-&gt;pTCG[iX[0]].st_flow    += edge_flow;</a>
<a name="ln2725">    } else {</a>
<a name="ln2726">        /* no supergroup =&gt; change cap to flow */</a>
<a name="ln2727">        *tot_st_cap      += pv0-&gt;st_edge.flow - pv0-&gt;st_edge.cap;</a>
<a name="ln2728">        pv0-&gt;st_edge.cap += pv0-&gt;st_edge.flow - pv0-&gt;st_edge.cap;</a>
<a name="ln2729">        pv0-&gt;st_edge.cap0 = pv0-&gt;st_edge.cap;</a>
<a name="ln2730">    }</a>
<a name="ln2731"> </a>
<a name="ln2732">    *pcur_num_vertices = cur_num_vertices;</a>
<a name="ln2733">    *pcur_num_edges    = cur_num_edges;</a>
<a name="ln2734">    ret = num_groups;</a>
<a name="ln2735">exit_function:</a>
<a name="ln2736">    if ( e0X ) inchi_free( e0X );</a>
<a name="ln2737">    if ( pvX ) inchi_free( pvX );</a>
<a name="ln2738">    if ( jX  ) inchi_free( jX  );</a>
<a name="ln2739">    if ( iX  ) inchi_free( iX  );</a>
<a name="ln2740">    return ret;</a>
<a name="ln2741">}</a>
<a name="ln2742">/*********************************************************************************/</a>
<a name="ln2743">void AddStCapFlow( BNS_VERTEX *vert_ficpoint, int *tot_st_flow, int *tot_st_cap, int cap, int flow )</a>
<a name="ln2744">{</a>
<a name="ln2745">    vert_ficpoint-&gt;st_edge.flow += flow;</a>
<a name="ln2746">    *tot_st_flow                += flow;</a>
<a name="ln2747">    vert_ficpoint-&gt;st_edge.cap  += cap;</a>
<a name="ln2748">    *tot_st_cap                 += cap;</a>
<a name="ln2749"> </a>
<a name="ln2750">    vert_ficpoint-&gt;st_edge.flow0 = vert_ficpoint-&gt;st_edge.flow;</a>
<a name="ln2751">    vert_ficpoint-&gt;st_edge.cap0  = vert_ficpoint-&gt;st_edge.cap;</a>
<a name="ln2752">}</a>
<a name="ln2753">/*********************************************************************************/</a>
<a name="ln2754">void SetStCapFlow( BNS_VERTEX *vert_ficpoint, int *tot_st_flow, int *tot_st_cap, int cap, int flow )</a>
<a name="ln2755">{</a>
<a name="ln2756">    *tot_st_flow                += flow - vert_ficpoint-&gt;st_edge.flow;</a>
<a name="ln2757">    vert_ficpoint-&gt;st_edge.flow  = flow;</a>
<a name="ln2758">    *tot_st_cap                 += cap - vert_ficpoint-&gt;st_edge.cap;</a>
<a name="ln2759">    vert_ficpoint-&gt;st_edge.cap   = cap;</a>
<a name="ln2760"> </a>
<a name="ln2761">    vert_ficpoint-&gt;st_edge.flow0 = vert_ficpoint-&gt;st_edge.flow;</a>
<a name="ln2762">    vert_ficpoint-&gt;st_edge.cap0  = vert_ficpoint-&gt;st_edge.cap;</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765">/*********************************************************************************</a>
<a name="ln2766">int AddCGroups2TCGBnStruct( BN_STRUCT *pBNS, StrFromINChI *pStruct,</a>
<a name="ln2767">                            VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln2768"> </a>
<a name="ln2769"> </a>
<a name="ln2770"> *********************************************************************************/</a>
<a name="ln2771">int AddCGroups2TCGBnStruct( BN_STRUCT *pBNS, StrFromINChI *pStruct, VAL_AT *pVA,</a>
<a name="ln2772">                            ALL_TC_GROUPS *pTCGroups, int nMaxAddEdges )</a>
<a name="ln2773">{</a>
<a name="ln2774">    int ret = 0, ret1, ret2, ret3, bNeedsFlower;</a>
<a name="ln2775">    inp_ATOM *at               = pStruct-&gt;at;</a>
<a name="ln2776">    int       num_atoms        = pStruct-&gt;num_atoms;</a>
<a name="ln2777">    /*int       num_tg           = pTCGroups-&gt;num_tgroups;*/</a>
<a name="ln2778">    int       num_cg           = pTCGroups-&gt;num_tc_groups - pTCGroups-&gt;num_tgroups;</a>
<a name="ln2779">    int       fst_cg_vertex    = pBNS-&gt;num_vertices;</a>
<a name="ln2780">    int       fst_cg_group     = pTCGroups-&gt;num_tgroups;</a>
<a name="ln2781">    int       num_vertices     = pBNS-&gt;num_vertices;</a>
<a name="ln2782">    int       num_edges        = pBNS-&gt;num_edges;</a>
<a name="ln2783">    int       cg_charge        = 0;</a>
<a name="ln2784">    ICHICONST SRM *pSrm        = pStruct-&gt;pSrm;</a>
<a name="ln2785">    /* ret = ReInitBnStruct( pBNS ); */</a>
<a name="ln2786">    if ( num_cg &gt; 0 ) {</a>
<a name="ln2787">    /* if ( cgi &amp;&amp; cgi-&gt;num_c_groups &amp;&amp; cgi-&gt;c_group ) */</a>
<a name="ln2788">        int         i, i1, i2, j, j1, j2, k, k1, k2, n, c_point, c_neigh, cap, flow;</a>
<a name="ln2789">        int         cur_num_vertices, cur_num_edges;</a>
<a name="ln2790">        BNS_VERTEX *vert_ficpoint, *vert_ficpoint_prev, *vert_ficpoint_base;  /* fictitious vertex describing charge c-group */</a>
<a name="ln2791">        BNS_VERTEX *pv1, *pv2;</a>
<a name="ln2792">        BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric c_point */</a>
<a name="ln2793">        int        nMaxCGroupNumber = 0;</a>
<a name="ln2794">        MY_CONST C_NODE *pCN;</a>
<a name="ln2795">        int              cn_len, cn_bits, bMetalAtoms;</a>
<a name="ln2796">        int              type;</a>
<a name="ln2797">        int        tot_st_cap, tot_st_flow;</a>
<a name="ln2798">        int        nAddGroups[16];</a>
<a name="ln2799"> </a>
<a name="ln2800"> </a>
<a name="ln2801">        /* Debug: check overflow */</a>
<a name="ln2802">        if ( num_vertices &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln2803">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2804">        }</a>
<a name="ln2805">        nMaxCGroupNumber = num_cg;</a>
<a name="ln2806">        /* clear all vertices not used until now */</a>
<a name="ln2807">        memset( pBNS-&gt;vert+num_vertices, 0, (pBNS-&gt;max_vertices - num_vertices)*sizeof(pBNS-&gt;vert[0]) );</a>
<a name="ln2808">        tot_st_cap  = pBNS-&gt;tot_st_cap;</a>
<a name="ln2809">        tot_st_flow = pBNS-&gt;tot_st_flow;</a>
<a name="ln2810">        /*****************************************/</a>
<a name="ln2811">        /* initialize new fictitious vertices    */</a>
<a name="ln2812">        /* representing c-point groups, c-groups */</a>
<a name="ln2813">        /*****************************************/</a>
<a name="ln2814">        vert_ficpoint_prev = pBNS-&gt;vert + fst_cg_vertex - 1;</a>
<a name="ln2815">        </a>
<a name="ln2816">        for ( i = 0; i &lt; num_cg; i ++ ) {</a>
<a name="ln2817">            /*</a>
<a name="ln2818">              vert_ficpoint-1 is the last vertex;</a>
<a name="ln2819">              vert_ficpoint   is the being added vertex</a>
<a name="ln2820">              Note: nGroupNumber are not contiguous</a>
<a name="ln2821">            */</a>
<a name="ln2822">            vert_ficpoint                = vert_ficpoint_prev + 1;</a>
<a name="ln2823">            vert_ficpoint-&gt;iedge         = vert_ficpoint_prev-&gt;iedge + vert_ficpoint_prev-&gt;max_adj_edges;</a>
<a name="ln2824">            vert_ficpoint-&gt;max_adj_edges = pTCGroups-&gt;pTCG[i+fst_cg_group].num_edges+nMaxAddEdges;</a>
<a name="ln2825">            vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln2826"> </a>
<a name="ln2827">            vert_ficpoint-&gt;st_edge.flow += pTCGroups-&gt;pTCG[i+fst_cg_group].st_flow;</a>
<a name="ln2828">            tot_st_flow                 += pTCGroups-&gt;pTCG[i+fst_cg_group].st_flow;</a>
<a name="ln2829">            vert_ficpoint-&gt;st_edge.cap  += pTCGroups-&gt;pTCG[i+fst_cg_group].st_cap;</a>
<a name="ln2830">            tot_st_cap                  += pTCGroups-&gt;pTCG[i+fst_cg_group].st_cap;</a>
<a name="ln2831">            </a>
<a name="ln2832">            vert_ficpoint-&gt;st_edge.flow0 = vert_ficpoint-&gt;st_edge.flow;</a>
<a name="ln2833">            vert_ficpoint-&gt;st_edge.cap0  = vert_ficpoint-&gt;st_edge.cap;</a>
<a name="ln2834">            </a>
<a name="ln2835">            vert_ficpoint-&gt;type          = pTCGroups-&gt;pTCG[i+fst_cg_group].type;</a>
<a name="ln2836">            /* save the vertex number */</a>
<a name="ln2837">            pTCGroups-&gt;pTCG[i+fst_cg_group].nVertexNumber = vert_ficpoint - pBNS-&gt;vert;</a>
<a name="ln2838"> </a>
<a name="ln2839">            vert_ficpoint_prev             = vert_ficpoint; /* keep track of iedges */</a>
<a name="ln2840">        }</a>
<a name="ln2841">        cur_num_vertices = (vert_ficpoint_prev - pBNS-&gt;vert) + 1;</a>
<a name="ln2842">        cur_num_edges    = num_edges;</a>
<a name="ln2843">        </a>
<a name="ln2844">        /*************************************************************/</a>
<a name="ln2845">        /* pass 1:                                                   */</a>
<a name="ln2846">        /* create ChargeStruct for c-points and connect them to      */</a>
<a name="ln2847">        /* the vertices representing c-point groups;                 */</a>
<a name="ln2848">        /* set final atom st_cap, st_flow                            */</a>
<a name="ln2849">        /*************************************************************/</a>
<a name="ln2850">        for ( c_point = 0; c_point &lt; num_atoms; c_point ++ ) {</a>
<a name="ln2851">            if ( !(k=pVA[c_point].cnListIndex) )</a>
<a name="ln2852">                continue;  /* not a c-point */</a>
<a name="ln2853">            k --;</a>
<a name="ln2854">            pCN     = cnList[k].pCN;   /* pointer to the ChargeStruct */</a>
<a name="ln2855">            cn_len  = cnList[k].len;   /* length of the ChargeStruct  */</a>
<a name="ln2856">            cn_bits = cnList[k].bits;  /* bits: for M-recognition */</a>
<a name="ln2857">            /* cn_bits = cnList[k].bits; */ /* ChargeStruct type */</a>
<a name="ln2858">            bMetalAtoms = (cn_bits == cn_bits_Me);</a>
<a name="ln2859">            vert_ficpoint_base = vert_ficpoint_prev; /* add aux vertices after this */</a>
<a name="ln2860">            /* create disconnected auxiliary vertices of the at[c_point] ChargeStruct; add to them st_flow &amp; st_cap */</a>
<a name="ln2861">            for ( i1 = 0; i1 &lt; cn_len; i1 ++ ) {</a>
<a name="ln2862">                if ( !IS_BNS_VT_CHRG_STRUCT(pCN[i1].v.type) ) {</a>
<a name="ln2863">                    continue;</a>
<a name="ln2864">                }</a>
<a name="ln2865">                /* the atom is always the first; the attached c-points are always the last */</a>
<a name="ln2866">                vert_ficpoint                = vert_ficpoint_base + i1; /* i1 = 1, 2,.. less number of attached c-points */</a>
<a name="ln2867">                vert_ficpoint-&gt;iedge         = vert_ficpoint_prev-&gt;iedge + vert_ficpoint_prev-&gt;max_adj_edges;</a>
<a name="ln2868">                vert_ficpoint-&gt;max_adj_edges = pCN[i1].v.valence; /* do not add additional edges to aux vertices */</a>
<a name="ln2869">                vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln2870"> </a>
<a name="ln2871">                cap  = !bMetalAtoms? pCN[i1].v.cap : pCN[i1].v.cap? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln2872">                flow = !bMetalAtoms? pCN[i1].v.flow : pCN[i1].v.flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln2873"> </a>
<a name="ln2874">                AddStCapFlow( vert_ficpoint, &amp;tot_st_flow, &amp;tot_st_cap, cap, flow );</a>
<a name="ln2875">                vert_ficpoint-&gt;type          = pCN[i1].v.type; /* =BNS_VERT_TYPE__AUX */</a>
<a name="ln2876"> </a>
<a name="ln2877">                vert_ficpoint_prev = vert_ficpoint; /* the last one will be vert_ficpoint for the next c-point */</a>
<a name="ln2878">                cur_num_vertices   = (vert_ficpoint - pBNS-&gt;vert) + 1;</a>
<a name="ln2879"> </a>
<a name="ln2880">                if ( vert_ficpoint-&gt;iedge + vert_ficpoint-&gt;max_adj_edges - pBNS-&gt;iedge &gt;= pBNS-&gt;max_iedges ) {</a>
<a name="ln2881">                    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2882">                }</a>
<a name="ln2883">                if ( cur_num_vertices &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln2884">                    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2885">                }</a>
<a name="ln2886">            }</a>
<a name="ln2887">            /* connect the vertices with new edges, add edge flow and cap */</a>
<a name="ln2888">            for ( i1 = 0; i1 &lt; cn_len; i1 ++ ) {</a>
<a name="ln2889">                pv1 = NULL;</a>
<a name="ln2890">                k1  = -1;</a>
<a name="ln2891">                /* find vertex cooresponding to i1 */</a>
<a name="ln2892">                if ( pCN[i1].v.type &amp; BNS_VERT_TYPE_ATOM ) {</a>
<a name="ln2893">                    pv1 = pBNS-&gt;vert+c_point; /* may be only one atom -- the current c_point at i1==0 */</a>
<a name="ln2894">                    /* add atom vertex st_cap and st_flow */</a>
<a name="ln2895">                    cap  = !bMetalAtoms? pCN[i1].v.cap : pCN[i1].v.cap? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln2896">                    flow = !bMetalAtoms? pCN[i1].v.flow : pCN[i1].v.flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln2897">                    AddStCapFlow( pv1, &amp;tot_st_flow, &amp;tot_st_cap, cap, flow );</a>
<a name="ln2898">                } else</a>
<a name="ln2899">                if ( IS_BNS_VT_C_GR(pCN[i1].v.type) ) {</a>
<a name="ln2900">                    /* find c-group vertex by looking for its type */</a>
<a name="ln2901">                    for( j = 0; j &lt; num_cg; j ++ ) {</a>
<a name="ln2902">                        if ( pCN[i1].v.type == pBNS-&gt;vert[fst_cg_vertex + j].type ) {</a>
<a name="ln2903">                            pv1 = pBNS-&gt;vert + fst_cg_vertex + j;</a>
<a name="ln2904">                            break;</a>
<a name="ln2905">                        }</a>
<a name="ln2906">                    }</a>
<a name="ln2907">                    /* index of the pTCGroups-&gt;pTCG[] */</a>
<a name="ln2908">                    if ( pv1 ) {</a>
<a name="ln2909">                        k1 = j + fst_cg_group;</a>
<a name="ln2910">                        if ( pTCGroups-&gt;pTCG[k1].type != pCN[i1].v.type ||</a>
<a name="ln2911">                             pTCGroups-&gt;pTCG[k1].ord_num ) {</a>
<a name="ln2912">                            return RI_ERR_PROGR;</a>
<a name="ln2913">                        }</a>
<a name="ln2914">                    }</a>
<a name="ln2915">                } else</a>
<a name="ln2916">                if ( IS_BNS_VT_M_GR( pCN[i1].v.type ) ) {</a>
<a name="ln2917">                    k1 = pTCGroups-&gt;nGroup[TCG_MeFlower0];</a>
<a name="ln2918">                    if ( k1 &lt; 0 ||</a>
<a name="ln2919">                         pTCGroups-&gt;pTCG[k1].type != pCN[i1].v.type  ||</a>
<a name="ln2920">                             pTCGroups-&gt;pTCG[k1].ord_num ||</a>
<a name="ln2921">                             !pSrm-&gt;bMetalAddFlower ) {</a>
<a name="ln2922">                            return RI_ERR_PROGR;</a>
<a name="ln2923">                    }</a>
<a name="ln2924">                    pv1 = pBNS-&gt;vert + pTCGroups-&gt;pTCG[k1].nVertexNumber;</a>
<a name="ln2925">                } else</a>
<a name="ln2926">                if ( IS_BNS_VT_CHRG_STRUCT(pCN[i1].v.type) ) {</a>
<a name="ln2927">                    /* aux vertex */</a>
<a name="ln2928">                    pv1 = vert_ficpoint_base + i1;</a>
<a name="ln2929">                }</a>
<a name="ln2930">                if ( !pv1 ) {</a>
<a name="ln2931">                    return BNS_BOND_ERR;</a>
<a name="ln2932">                }</a>
<a name="ln2933"> </a>
<a name="ln2934">                /* connect pairs of vertices with new edges */</a>
<a name="ln2935">                for ( k = 0; k &lt; MAX_CN_VAL &amp;&amp; (i2=pCN[i1].e[k].neigh); k ++ ) {</a>
<a name="ln2936">                    pv2 = NULL;</a>
<a name="ln2937">                    k2  = -1;</a>
<a name="ln2938">                    i2 --; /* neighbor */</a>
<a name="ln2939">                    /* find vertex cooresponding to i2 */</a>
<a name="ln2940">                    if ( pCN[i2].v.type &amp; BNS_VERT_TYPE_ATOM ) {</a>
<a name="ln2941">                        pv2 = pBNS-&gt;vert+c_point;</a>
<a name="ln2942">                        cap  = !bMetalAtoms? pCN[i2].v.cap : pCN[i2].v.cap? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln2943">                        flow = !bMetalAtoms? pCN[i2].v.flow : pCN[i2].v.flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln2944">                        /* add atom vertex st_cap and st_flow; this normally should not happen */</a>
<a name="ln2945">                        AddStCapFlow( pv2, &amp;tot_st_flow, &amp;tot_st_cap, cap, flow );</a>
<a name="ln2946">                    } else</a>
<a name="ln2947">                    if ( IS_BNS_VT_C_GR(pCN[i2].v.type) ) {</a>
<a name="ln2948">                        /* find c-group vertex by looking for its type */</a>
<a name="ln2949">                        for( j = 0; j &lt; num_cg; j ++ ) {</a>
<a name="ln2950">                            if ( pCN[i2].v.type == pBNS-&gt;vert[fst_cg_vertex + j].type ) {</a>
<a name="ln2951">                                pv2 = pBNS-&gt;vert + fst_cg_vertex + j;</a>
<a name="ln2952">                                break;</a>
<a name="ln2953">                            }</a>
<a name="ln2954">                        }</a>
<a name="ln2955">                        if ( pv2 ) {</a>
<a name="ln2956">                            k2 = j + fst_cg_group;</a>
<a name="ln2957">                            if ( pTCGroups-&gt;pTCG[k2].type != pCN[i2].v.type ||</a>
<a name="ln2958">                                 pTCGroups-&gt;pTCG[k2].ord_num ) {</a>
<a name="ln2959">                                return RI_ERR_PROGR;</a>
<a name="ln2960">                            }</a>
<a name="ln2961">                        }</a>
<a name="ln2962">                    } else</a>
<a name="ln2963">                    if ( IS_BNS_VT_M_GR( pCN[i2].v.type ) ) {</a>
<a name="ln2964">                        k2 = pTCGroups-&gt;nGroup[TCG_MeFlower0];</a>
<a name="ln2965">                        if ( k2 &lt; 0 ||</a>
<a name="ln2966">                             pTCGroups-&gt;pTCG[k2].type != pCN[i2].v.type  ||</a>
<a name="ln2967">                                 pTCGroups-&gt;pTCG[k2].ord_num ||</a>
<a name="ln2968">                                 !pSrm-&gt;bMetalAddFlower ) {</a>
<a name="ln2969">                                return RI_ERR_PROGR;</a>
<a name="ln2970">                        }</a>
<a name="ln2971">                        pv2 = pBNS-&gt;vert + pTCGroups-&gt;pTCG[k2].nVertexNumber;</a>
<a name="ln2972">                    } else</a>
<a name="ln2973">                    if ( IS_BNS_VT_CHRG_STRUCT(pCN[i2].v.type) ){</a>
<a name="ln2974">                        pv2 = vert_ficpoint_base + i2;</a>
<a name="ln2975">                    }</a>
<a name="ln2976">                    </a>
<a name="ln2977">                    /* connect pv1 and pv2 */</a>
<a name="ln2978">                    if ( !pv1 || !pv2 || pv1 == pv2 ) {</a>
<a name="ln2979">                        return BNS_BOND_ERR;</a>
<a name="ln2980">                    }</a>
<a name="ln2981">                    j1 = pv1 - pBNS-&gt;vert;</a>
<a name="ln2982">                    j2 = pv2 - pBNS-&gt;vert;</a>
<a name="ln2983">                    /* create a new edge connecting pv1 and pv2 */</a>
<a name="ln2984">                    edge = pBNS-&gt;edge + cur_num_edges;</a>
<a name="ln2985">                    if ( (IS_BNS_VT_M_GR( pCN[i1].v.type ) &amp;&amp; IS_BNS_VT_ATOM( pCN[i2].v.type )) ||</a>
<a name="ln2986">                         (IS_BNS_VT_M_GR( pCN[i2].v.type ) &amp;&amp; IS_BNS_VT_ATOM( pCN[i1].v.type )) ) {</a>
<a name="ln2987">                        /* at[c_point] is a metal or is treated as a metal; connect it to M-group */</a>
<a name="ln2988">                        /* metal - M-group (i.e. Metal-Flower) edge */</a>
<a name="ln2989">                        int nStCap, nStFlow;</a>
<a name="ln2990">                        bNeedsFlower = AtomStcapStflow( at, pVA, pSrm, c_point, &amp;nStCap, &amp;nStFlow, &amp;edge-&gt;cap, &amp;edge-&gt;flow );</a>
<a name="ln2991">                        /* GetAtomToMCGroupInitEdgeCapFlow( &amp;edge-&gt;cap, &amp;edge-&gt;flow, pSrm, at, pVA, c_point ); */</a>
<a name="ln2992">                        if ( !bNeedsFlower ) {</a>
<a name="ln2993">                            return RI_ERR_PROGR;</a>
<a name="ln2994">                        }</a>
<a name="ln2995">                        pVA[c_point].nMetalGroupEdge = cur_num_edges + 1;</a>
<a name="ln2996">                        /* pBNS-&gt;vert[c_point].st_edge.cap  += edge-&gt;flow;*/ /* where was this done ???*/</a>
<a name="ln2997">                        pBNS-&gt;vert[c_point].st_edge.flow += edge-&gt;flow;</a>
<a name="ln2998">                        pBNS-&gt;vert[c_point].st_edge.cap  += edge-&gt;flow + pVA[c_point].cInitFreeValences;</a>
<a name="ln2999">                        pBNS-&gt;vert[c_point].st_edge.flow0 = pBNS-&gt;vert[c_point].st_edge.flow;</a>
<a name="ln3000">                        pBNS-&gt;vert[c_point].st_edge.cap0  = pBNS-&gt;vert[c_point].st_edge.cap;</a>
<a name="ln3001">                        tot_st_flow += edge-&gt;flow;</a>
<a name="ln3002">                        tot_st_cap  += edge-&gt;flow + pVA[c_point].cInitFreeValences;</a>
<a name="ln3003">                    } else {</a>
<a name="ln3004">                        edge-&gt;cap     = !bMetalAtoms? pCN[i1].e[k].cap : pCN[i1].e[k].cap? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln3005">                        edge-&gt;flow    = !bMetalAtoms? pCN[i1].e[k].flow : pCN[i1].e[k].flow? pSrm-&gt;nMetalMaxCharge_D : 0;</a>
<a name="ln3006">                    }</a>
<a name="ln3007">                    edge-&gt;forbidden = pCN[i1].e[k].bForbiddenEdge? BNS_EDGE_FORBIDDEN_MASK : 0;</a>
<a name="ln3008">                    /* c-group incoming edges cap and flow needed in ConnectSuperCGroup() */</a>
<a name="ln3009">                    /*</a>
<a name="ln3010">                    if ( k1 &gt;= 0 ) {</a>
<a name="ln3011">                        pTCGroups-&gt;pTCG[k1].edges_cap  += pCN[i1].e[k].cap;</a>
<a name="ln3012">                        pTCGroups-&gt;pTCG[k1].edges_flow += pCN[i1].e[k].flow;</a>
<a name="ln3013">                    }</a>
<a name="ln3014">                    if ( k2 &gt;= 0 ) {</a>
<a name="ln3015">                        pTCGroups-&gt;pTCG[k2].edges_cap  += pCN[i1].e[k].cap;</a>
<a name="ln3016">                        pTCGroups-&gt;pTCG[k2].edges_flow += pCN[i1].e[k].flow;</a>
<a name="ln3017">                    }</a>
<a name="ln3018">                    */</a>
<a name="ln3019">                    edge-&gt;pass      = 0;</a>
<a name="ln3020">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln3021">                    edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln3022">#endif</a>
<a name="ln3023">                    /* check edge overflow */</a>
<a name="ln3024">                    if ( pv1-&gt;num_adj_edges &gt;= pv1-&gt;max_adj_edges ||</a>
<a name="ln3025">                         pv2-&gt;num_adj_edges &gt;= pv2-&gt;max_adj_edges ||</a>
<a name="ln3026">                         cur_num_edges      &gt;= pBNS-&gt;max_edges     ) {</a>
<a name="ln3027">                        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3028">                    }</a>
<a name="ln3029">                    </a>
<a name="ln3030">                    /* connect edge to the incident vertices and increment the counters of neighbors and edges */</a>
<a name="ln3031">                    ret = ConnectTwoVertices( pv1, pv2, edge, pBNS, 0 );</a>
<a name="ln3032">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3033">                        return ret;</a>
<a name="ln3034">                    }</a>
<a name="ln3035">                    edge-&gt;cap0  = edge-&gt;cap;</a>
<a name="ln3036">                    edge-&gt;flow0 = edge-&gt;flow;</a>
<a name="ln3037">                    /* save the edge index */</a>
<a name="ln3038">                    type = IS_BNS_VT_C_GR(pv1-&gt;type)? pv1-&gt;type :</a>
<a name="ln3039">                           IS_BNS_VT_C_GR(pv2-&gt;type)? pv2-&gt;type : 0;</a>
<a name="ln3040">                    if ( type ) {</a>
<a name="ln3041">                        /* the edge connects to a c-group */</a>
<a name="ln3042">                        if ( type &amp; BNS_VERT_TYPE_C_NEGATIVE ) {</a>
<a name="ln3043">                            pVA[c_point].nCMinusGroupEdge = cur_num_edges+1;</a>
<a name="ln3044">                        } else {</a>
<a name="ln3045">                            pVA[c_point].nCPlusGroupEdge  = cur_num_edges+1;</a>
<a name="ln3046">                        }</a>
<a name="ln3047">                    }</a>
<a name="ln3048">                    cur_num_edges ++; /* end of new edge creation */</a>
<a name="ln3049">                }</a>
<a name="ln3050">            }</a>
<a name="ln3051">        }</a>
<a name="ln3052">        /*************************************************************/</a>
<a name="ln3053">        /* pass 2:                                                   */</a>
<a name="ln3054">        /* adjust bond cap, flow from the final atom st_cap, st_flow */</a>
<a name="ln3055">        /*************************************************************/</a>
<a name="ln3056">        for ( c_point = 0; c_point &lt; num_atoms; c_point ++ ) {</a>
<a name="ln3057">            int st_cap, st_cap2, max_edge_flow;</a>
<a name="ln3058">            pv1 = pBNS-&gt;vert + c_point;  /* atom vertex */</a>
<a name="ln3059">            st_cap = pv1-&gt;st_edge.cap;</a>
<a name="ln3060">            for ( k = 0; k &lt; pv1-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln3061">                edge = pBNS-&gt;edge + pv1-&gt;iedge[k];      /* incident edge */</a>
<a name="ln3062">                c_neigh = edge-&gt;neighbor12 ^ c_point;   /* adjacent vertex */</a>
<a name="ln3063">                pv2 = pBNS-&gt;vert + c_neigh;</a>
<a name="ln3064">                if ( c_neigh &gt; c_point || !(pv2-&gt;type &amp; BNS_VERT_TYPE_ATOM) ) {</a>
<a name="ln3065">                    continue;</a>
<a name="ln3066">                }</a>
<a name="ln3067">                /* adjacent vertex is an atom; the edge is a bond; process each bond only once */</a>
<a name="ln3068">                st_cap2 = pv2-&gt;st_edge.cap;</a>
<a name="ln3069">                /* the edge flow &lt;= min( incident atom st_caps) */</a>
<a name="ln3070">                max_edge_flow = inchi_min( st_cap, st_cap2 );</a>
<a name="ln3071">                /* bond order &lt;= triple bond (flow=2) */</a>
<a name="ln3072">                if ( pSrm-&gt;bMetalAddFlower &amp;&amp; !pSrm-&gt;nMetalMinBondOrder &amp;&amp;</a>
<a name="ln3073">                    ((pVA[c_point].cMetal &amp;&amp; pVA[c_point].cNumBondsToMetal) ||</a>
<a name="ln3074">                     (pVA[c_neigh].cMetal &amp;&amp; pVA[c_neigh].cNumBondsToMetal)) ) {</a>
<a name="ln3075">                    max_edge_flow = inchi_min( max_edge_flow, MAX_BOND_EDGE_CAP+1 );</a>
<a name="ln3076">                } else {</a>
<a name="ln3077">                    max_edge_flow = inchi_min( max_edge_flow, MAX_BOND_EDGE_CAP );</a>
<a name="ln3078">                }</a>
<a name="ln3079">                if ( at[c_point].bond_type[k] == BOND_TYPE_SINGLE ) {</a>
<a name="ln3080">                    /* the bond has not been changed due to stereo */</a>
<a name="ln3081">                    edge-&gt;cap = edge-&gt;cap0 = max_edge_flow;</a>
<a name="ln3082">                }</a>
<a name="ln3083">            }</a>
<a name="ln3084">        }</a>
<a name="ln3085">        /***********************************************************/</a>
<a name="ln3086">        /**************                                 ************/</a>
<a name="ln3087">        /************** connect M-flower with new edges ************/</a>
<a name="ln3088">        /**************                                 ************/</a>
<a name="ln3089">        /***********************************************************/</a>
<a name="ln3090">        ret = ConnectMetalFlower(&amp;cur_num_vertices, &amp;cur_num_edges, &amp;tot_st_cap, &amp;tot_st_flow, pSrm, pBNS, pTCGroups);</a>
<a name="ln3091">        if ( ret &lt; 0 ) {</a>
<a name="ln3092">            goto exit_function;</a>
<a name="ln3093">        }</a>
<a name="ln3094">        /***********************************************************/</a>
<a name="ln3095">        /**************                                 ************/</a>
<a name="ln3096">        /************** add additional vertices &amp; edges ************/</a>
<a name="ln3097">        /************** to connect c-groups             ************/</a>
<a name="ln3098">        /**************                                 ************/</a>
<a name="ln3099">        /***********************************************************/</a>
<a name="ln3100">        /* (+) supergroup, Y-connection */</a>
<a name="ln3101">        k = 0;</a>
<a name="ln3102">        nAddGroups[k ++] = TCG_Plus0;</a>
<a name="ln3103">        nAddGroups[k ++] = TCG_Plus_C0;</a>
<a name="ln3104">        nAddGroups[k ++] = TCG_Plus_M0;</a>
<a name="ln3105">        ret1 = ConnectSuperCGroup( TCG_Plus, nAddGroups, k, &amp;cur_num_vertices, &amp;cur_num_edges,</a>
<a name="ln3106">                              &amp;tot_st_cap, &amp;tot_st_flow, pBNS, pTCGroups );</a>
<a name="ln3107">        /* (-) supergroup, Y-connection */</a>
<a name="ln3108">        k = 0;</a>
<a name="ln3109">        nAddGroups[k ++] = TCG_Minus0;</a>
<a name="ln3110">        nAddGroups[k ++] = TCG_Minus_C0;</a>
<a name="ln3111">        nAddGroups[k ++] = TCG_Minus_M0;</a>
<a name="ln3112">        ret2 = ConnectSuperCGroup( TCG_Minus, nAddGroups, k, &amp;cur_num_vertices, &amp;cur_num_edges,</a>
<a name="ln3113">                              &amp;tot_st_cap, &amp;tot_st_flow, pBNS, pTCGroups );</a>
<a name="ln3114">        /******** connect (+) and (-) ***************/</a>
<a name="ln3115">        k = 0;</a>
<a name="ln3116">        nAddGroups[k ++] = TCG_Plus;</a>
<a name="ln3117">        nAddGroups[k ++] = TCG_Minus;</a>
<a name="ln3118">        ret3 = ConnectSuperCGroup( -1, nAddGroups, k, &amp;cur_num_vertices, &amp;cur_num_edges,</a>
<a name="ln3119">                              &amp;tot_st_cap, &amp;tot_st_flow, pBNS, pTCGroups );</a>
<a name="ln3120"> </a>
<a name="ln3121">        /* Take care of the full charge */</a>
<a name="ln3122">        cg_charge = pTCGroups-&gt;total_charge - pTCGroups-&gt;tgroup_charge - pTCGroups-&gt;charge_on_atoms;</a>
<a name="ln3123">        ret = 1;</a>
<a name="ln3124">        if ( ret3 &gt; 0 ) {</a>
<a name="ln3125">            /* (+) and (-) or at least one of them have been connected */</a>
<a name="ln3126">            int nVertPlusMinus = cur_num_vertices - 1;</a>
<a name="ln3127">            BNS_VERTEX *pVertPlusMinus = pBNS-&gt;vert + nVertPlusMinus;</a>
<a name="ln3128">            BNS_VERTEX *pVertPlus = NULL, *pVertMinus = NULL, *pVert=NULL;</a>
<a name="ln3129">            BNS_EDGE   *pEdgePlus = NULL, *pEdgeMinus = NULL, *pEdge=NULL;</a>
<a name="ln3130">            n = pTCGroups-&gt;nGroup[TCG_Plus] &gt;= 0;   /* (+)-supergroup exists */</a>
<a name="ln3131">            k = pTCGroups-&gt;nGroup[TCG_Minus] &gt;= 0;  /* (-)-supergroup exists */</a>
<a name="ln3132">            if ( pVertPlusMinus-&gt;num_adj_edges == 2 &amp;&amp; k+n==2 ) {</a>
<a name="ln3133">                pEdgePlus      = pBNS-&gt;edge + pVertPlusMinus-&gt;iedge[0];  /* TCG_Plus was the 1st */</a>
<a name="ln3134">                pEdgeMinus     = pBNS-&gt;edge + pVertPlusMinus-&gt;iedge[1];  /* TCG_Minus was the 2nd */</a>
<a name="ln3135">            } else</a>
<a name="ln3136">            if ( pVertPlusMinus-&gt;num_adj_edges == 1 &amp;&amp; k+n==1 ) {</a>
<a name="ln3137">                if ( pTCGroups-&gt;nGroup[TCG_Plus] &gt;= 0 ) {</a>
<a name="ln3138">                    pEdgePlus      = pBNS-&gt;edge + pVertPlusMinus-&gt;iedge[0];</a>
<a name="ln3139">                } else</a>
<a name="ln3140">                if ( pTCGroups-&gt;nGroup[TCG_Minus] &gt;= 0 ) {</a>
<a name="ln3141">                    pEdgeMinus     = pBNS-&gt;edge + pVertPlusMinus-&gt;iedge[0];</a>
<a name="ln3142">                }</a>
<a name="ln3143">            } else</a>
<a name="ln3144">            if ( k+n ) {</a>
<a name="ln3145">                /* program error check */</a>
<a name="ln3146">                ret = BNS_BOND_ERR;</a>
<a name="ln3147">                goto exit_function;</a>
<a name="ln3148">            }</a>
<a name="ln3149">            if ( pEdgePlus ) {</a>
<a name="ln3150">                pVertPlus  = pBNS-&gt;vert + (pEdgePlus-&gt;neighbor12 ^ nVertPlusMinus);</a>
<a name="ln3151">            }</a>
<a name="ln3152">            if ( pEdgeMinus ) {</a>
<a name="ln3153">                pVertMinus = pBNS-&gt;vert + (pEdgeMinus-&gt;neighbor12 ^ nVertPlusMinus);</a>
<a name="ln3154">            }</a>
<a name="ln3155">            pVert = pVertPlus? pVertPlus : pVertMinus? pVertMinus : NULL;</a>
<a name="ln3156">            pEdge = pEdgePlus? pEdgePlus : pEdgeMinus? pEdgeMinus : NULL;</a>
<a name="ln3157">            if ( pEdgeMinus ) {</a>
<a name="ln3158">                pTCGroups-&gt;nEdgeMinus = pEdgeMinus - pBNS-&gt;edge;</a>
<a name="ln3159">            }</a>
<a name="ln3160">            if ( pEdgePlus ) {</a>
<a name="ln3161">                pTCGroups-&gt;nEdgePlus = pEdgePlus - pBNS-&gt;edge;</a>
<a name="ln3162">            }</a>
<a name="ln3163">            if ( pEdge ) {</a>
<a name="ln3164">                pTCGroups-&gt;nEdge4charge = pEdge - pBNS-&gt;edge;</a>
<a name="ln3165">            }</a>
<a name="ln3166">            /* set total charge */</a>
<a name="ln3167">            if ( pVert &amp;&amp; pEdge ) {</a>
<a name="ln3168">                /* do not check rescaps for now */</a>
<a name="ln3169">                if ( cg_charge &gt; 0 ) {</a>
<a name="ln3170">                    pVertPlusMinus-&gt;st_edge.cap += cg_charge;</a>
<a name="ln3171">                    tot_st_cap                  += cg_charge;</a>
<a name="ln3172">                    pVertPlusMinus-&gt;st_edge.cap0 = pVertPlusMinus-&gt;st_edge.cap;</a>
<a name="ln3173">                }</a>
<a name="ln3174">                if ( cg_charge &lt; 0 ) {</a>
<a name="ln3175">                    pVert-&gt;st_edge.cap -= cg_charge;</a>
<a name="ln3176">                    tot_st_cap         -= cg_charge;</a>
<a name="ln3177">                    pVert-&gt;st_edge.cap0 = pVert-&gt;st_edge.cap;</a>
<a name="ln3178"> </a>
<a name="ln3179">                    if ( pEdge-&gt;cap - pEdge-&gt;flow + cg_charge &lt; 0 ) {</a>
<a name="ln3180">                        /* 2006-02-06: increase edge capacity to avoid clogging */</a>
<a name="ln3181">                        pEdge-&gt;cap = pEdge-&gt;flow - cg_charge;</a>
<a name="ln3182">                    }</a>
<a name="ln3183">                }</a>
<a name="ln3184">                pTCGroups-&gt;added_charge = cg_charge;</a>
<a name="ln3185">                </a>
<a name="ln3186">            }</a>
<a name="ln3187">            if ( !cg_charge || (pVert &amp;&amp; pEdge) ) {</a>
<a name="ln3188">                ret = 2;</a>
<a name="ln3189">            }</a>
<a name="ln3190">        }</a>
<a name="ln3191"> </a>
<a name="ln3192">        AddRadicalToMetal( &amp;tot_st_cap, &amp;tot_st_flow, pSrm, pBNS, pTCGroups );</a>
<a name="ln3193"> </a>
<a name="ln3194"> </a>
<a name="ln3195">        pBNS-&gt;num_edges     = cur_num_edges;</a>
<a name="ln3196">        pBNS-&gt;num_vertices  = cur_num_vertices;</a>
<a name="ln3197">        pBNS-&gt;num_c_groups  = num_cg;</a>
<a name="ln3198">        pBNS-&gt;tot_st_cap    = tot_st_cap;</a>
<a name="ln3199">        pBNS-&gt;tot_st_flow   = tot_st_flow;</a>
<a name="ln3200"> </a>
<a name="ln3201">    }</a>
<a name="ln3202">exit_function:</a>
<a name="ln3203">    return ret;</a>
<a name="ln3204">}</a>
<a name="ln3205">/********************************************************************************/</a>
<a name="ln3206">int nNumEdgesToCnVertex( MY_CONST C_NODE *pCN, int len, int v )</a>
<a name="ln3207">{</a>
<a name="ln3208">    int i, j, n, num_edges, v1 = v+1;</a>
<a name="ln3209">    for ( i = 0, num_edges = 0; i &lt; len; i ++ ) {</a>
<a name="ln3210">        for ( j = 0; j &lt; MAX_CN_VAL &amp;&amp; (n = pCN[i].e[j].neigh); j ++ ) {</a>
<a name="ln3211">            num_edges += ( i == v || n == v1 );</a>
<a name="ln3212">        }</a>
<a name="ln3213">    }</a>
<a name="ln3214">    return num_edges;</a>
<a name="ln3215">}</a>
<a name="ln3216"> </a>
<a name="ln3217">/*********************************************************************************</a>
<a name="ln3218">BN_STRUCT* AllocateAndInitTCGBnStruct( StrFromINChI *pStruct, VAL_AT *pVA,</a>
<a name="ln3219">                                       ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3220">                                       int nMaxAddAtoms, int nMaxAddEdges,</a>
<a name="ln3221">                                       int max_altp, int *pNum_changed_bonds )</a>
<a name="ln3222">allocate BN_STRUCT that has:</a>
<a name="ln3223"> </a>
<a name="ln3224">  pBNS-&gt;max_vertices = pTCGroups-&gt;nVertices + nMaxAddAtoms   </a>
<a name="ln3225">  pBNS-&gt;max_edges    = pTCGroups-&gt;nEdges +</a>
<a name="ln3226">                       pBNS-&gt;max_vertices * (nMaxAddEdges + NUM_KINDS_OF_GROUPS)</a>
<a name="ln3227">  pBNS-&gt;max_iedges   = 2*pBNS-&gt;max_edges + pTCGroups-&gt;nAddIedges</a>
<a name="ln3228"> </a>
<a name="ln3229">  pBNS-&gt;len_alt_path = pBNS-&gt;max_vertices + iALTP_HDR_LEN + 1 +</a>
<a name="ln3230">                       max( pBNS-&gt;max_vertices/2, 16 )</a>
<a name="ln3231">  pBNS-&gt;max_altp     = max_altp</a>
<a name="ln3232">  </a>
<a name="ln3233">other members:</a>
<a name="ln3234"> </a>
<a name="ln3235">  pBNS-&gt;num_atoms       = num_atoms;</a>
<a name="ln3236">  pBNS-&gt;num_bonds       = num_bonds;</a>
<a name="ln3237">  pBNS-&gt;num_added_atoms = 0;           </a>
<a name="ln3238">  pBNS-&gt;num_t_groups    = 0;           </a>
<a name="ln3239">  pBNS-&gt;num_c_groups    = 0;           </a>
<a name="ln3240">  pBNS-&gt;nMaxAddAtoms    = nMaxAddAtoms;</a>
<a name="ln3241">  pBNS-&gt;nMaxAddEdges    = nMaxAddEdges;</a>
<a name="ln3242"> </a>
<a name="ln3243">atom vertices and bond edges:</a>
<a name="ln3244">  --- vertex(atom) ---</a>
<a name="ln3245">  st_cap  = (at[].chem_bonds_valence - at[].valence) + pVA[].cInitFreeValences</a>
<a name="ln3246">  st_flow = SUM{bond_orders; ALT_BOND counted as SINGLE} - at[].valence</a>
<a name="ln3247">  --- edge(bond) ---</a>
<a name="ln3248">  flow    = bond_order - 1; for ALT_BOND flow = 0</a>
<a name="ln3249">  cap     = min(min(st_cap of neighbors),2); for ALT_BOND cap = 1</a>
<a name="ln3250">  max number of edges per atom = number of bonds +</a>
<a name="ln3251">                             number of edges to ChargeStruct +</a>
<a name="ln3252">                             1 (if atom is a tautomeric endpoint) +</a>
<a name="ln3253">                             nMaxAddEdges</a>
<a name="ln3254">  --- NOTE ---</a>
<a name="ln3255">  Here are not included nDelta(dots) from ChargeStruct and flow to ChargeStruct</a>
<a name="ln3256"> </a>
<a name="ln3257"> *********************************************************************************/</a>
<a name="ln3258">BN_STRUCT* AllocateAndInitTCGBnStruct( StrFromINChI *pStruct, VAL_AT *pVA,</a>
<a name="ln3259">                                       ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln3260">                                       int nMaxAddAtoms, int nMaxAddEdges,</a>
<a name="ln3261">                                       int max_altp, int *pNum_changed_bonds )</a>
<a name="ln3262">{</a>
<a name="ln3263">    inp_ATOM    *at        = pStruct-&gt;at;</a>
<a name="ln3264">    int          num_atoms = pStruct-&gt;num_atoms;</a>
<a name="ln3265">    ICHICONST SRM *pSrm    = pStruct-&gt;pSrm;</a>
<a name="ln3266">    </a>
<a name="ln3267">    BN_STRUCT   *pBNS      = NULL;</a>
<a name="ln3268">    BNS_VERTEX  *vert;</a>
<a name="ln3269">    BNS_IEDGE   *iedge;</a>
<a name="ln3270"> </a>
<a name="ln3271">    int    neigh, num_changed_bonds=0;</a>
<a name="ln3272">    U_CHAR bond_type, bond_mark;</a>
<a name="ln3273">    int bNeedsFlower1, bNeedsFlower2, min_order;</a>
<a name="ln3274"> </a>
<a name="ln3275">    int i, j, k, m, n_edges, num_bonds, num_edges;</a>
<a name="ln3276">    int f1, f2, c1, c2, edge_cap, edge_flow, st_cap, st_flow, flag_alt_bond;</a>
<a name="ln3277">    int tot_st_cap, tot_st_flow;</a>
<a name="ln3278">    int max_tg, max_edges, max_vertices, len_alt_path, max_iedges, num_iedges, num_altp;</a>
<a name="ln3279"> </a>
<a name="ln3280">    /* count vertices */</a>
<a name="ln3281">    max_tg = pTCGroups-&gt;num_tgroups;</a>
<a name="ln3282">    /* +1 for a super-tautomeric group */</a>
<a name="ln3283">    /* max_vertices = num_atoms + nMaxAddAtoms + max_tg + 1; */</a>
<a name="ln3284">    max_vertices = pTCGroups-&gt;nVertices + nMaxAddAtoms;</a>
<a name="ln3285">    </a>
<a name="ln3286">    /* count edges */</a>
<a name="ln3287">    num_changed_bonds = 0;</a>
<a name="ln3288">    num_bonds = pTCGroups-&gt;num_bonds;</a>
<a name="ln3289"> </a>
<a name="ln3290">    /* each atom has enough edges to belong to a tautomeric group + nMaxAddEdges */</a>
<a name="ln3291">    /* number of atoms is large enough to accommodate max. possible number of t-groups + nMaxAddAtoms */</a>
<a name="ln3292">    /* max_altp cannot be larger than BN_MAX_ALTP = 16 */</a>
<a name="ln3293">    num_edges    = pTCGroups-&gt;nEdges;</a>
<a name="ln3294">    /* +max_tg for edges between t-groups and super-tautomeric group */</a>
<a name="ln3295">    max_edges    = num_edges + (nMaxAddEdges + NUM_KINDS_OF_GROUPS)*max_vertices;</a>
<a name="ln3296">    max_iedges   = 2*max_edges + pTCGroups-&gt;nAddIedges;</a>
<a name="ln3297">    len_alt_path = max_vertices+iALTP_HDR_LEN + 1; /* may overflow if an edge is traversed in 2 directions */</a>
<a name="ln3298">    len_alt_path += inchi_max( max_vertices/2, 16 ); /* to avoid the overflow */</a>
<a name="ln3299"> </a>
<a name="ln3300">    if ( !( pBNS           = (BN_STRUCT   *)inchi_calloc( 1,           sizeof(BN_STRUCT)) )  ||</a>
<a name="ln3301">         !( pBNS-&gt;edge     = (BNS_EDGE    *)inchi_calloc( max_edges,   sizeof(BNS_EDGE)) )   ||</a>
<a name="ln3302">         !( pBNS-&gt;vert     = (BNS_VERTEX  *)inchi_calloc( max_vertices,sizeof(BNS_VERTEX)) ) ||</a>
<a name="ln3303">         !( pBNS-&gt;iedge    = (BNS_IEDGE   *)inchi_calloc( max_iedges,  sizeof(BNS_IEDGE)) ) ) { </a>
<a name="ln3304">        return DeAllocateBnStruct( pBNS );</a>
<a name="ln3305">    }</a>
<a name="ln3306">    /* alt path init (standard spell) */</a>
<a name="ln3307">    for ( num_altp = 0; num_altp &lt; max_altp &amp;&amp; num_altp &lt; BN_MAX_ALTP; num_altp ++ ) {</a>
<a name="ln3308">        if ( !( pBNS-&gt;altp[num_altp] = (BNS_ALT_PATH*)inchi_calloc( len_alt_path,sizeof(BNS_ALT_PATH))) ) {</a>
<a name="ln3309">            return DeAllocateBnStruct( pBNS );</a>
<a name="ln3310">        }</a>
<a name="ln3311">        ALTP_ALLOCATED_LEN(pBNS-&gt;altp[num_altp]) = len_alt_path;</a>
<a name="ln3312">        pBNS-&gt;len_alt_path                 = len_alt_path;  /* ??? duplication ??? */</a>
<a name="ln3313">        /* re-init */</a>
<a name="ln3314">        ALTP_DELTA(pBNS-&gt;altp[num_altp])         = 0;</a>
<a name="ln3315">        ALTP_START_ATOM(pBNS-&gt;altp[num_altp])    = NO_VERTEX;</a>
<a name="ln3316">        ALTP_END_ATOM(pBNS-&gt;altp[num_altp])      = NO_VERTEX;</a>
<a name="ln3317">        ALTP_PATH_LEN(pBNS-&gt;altp[num_altp])      = 0;</a>
<a name="ln3318">    }</a>
<a name="ln3319">    pBNS-&gt;alt_path = NULL;</a>
<a name="ln3320">    pBNS-&gt;num_altp = 0;</a>
<a name="ln3321">    pBNS-&gt;max_altp = num_altp;</a>
<a name="ln3322"> </a>
<a name="ln3323"> </a>
<a name="ln3324">    /* fill vertices (no connectivity) */</a>
<a name="ln3325">    iedge = pBNS-&gt;iedge;</a>
<a name="ln3326">    num_iedges = 0;</a>
<a name="ln3327">    tot_st_cap = tot_st_flow = 0;</a>
<a name="ln3328">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3329">        /* count edges incident to pBNS-&gt;vert[i] */</a>
<a name="ln3330">        k = at[i].valence + (at[i].endpoint != 0) +  (nMaxAddEdges /*+ NUM_KINDS_OF_GROUPS*/);</a>
<a name="ln3331">        if ( (j = pVA[i].cnListIndex-1) &gt;= 0 ) {</a>
<a name="ln3332">            /* add number of neighbors in the ChargeStruct */</a>
<a name="ln3333">            k += nNumEdgesToCnVertex( cnList[j].pCN, cnList[j].len, 0 );</a>
<a name="ln3334">        }</a>
<a name="ln3335">        /* set max number of edges for the vertex */</a>
<a name="ln3336">        pBNS-&gt;vert[i].max_adj_edges = k;</a>
<a name="ln3337">        pBNS-&gt;vert[i].iedge = iedge;</a>
<a name="ln3338">        iedge += k;</a>
<a name="ln3339">        /* add atom vertex cap */</a>
<a name="ln3340">        st_cap  = 0;</a>
<a name="ln3341">        st_flow = 0;</a>
<a name="ln3342">        bNeedsFlower1 = AtomStcapStflow( at, pVA, pSrm, i, &amp;c1, &amp;f1, NULL, NULL );</a>
<a name="ln3343">        /* pVA[i].cNumBondsToMetal = bNeedsFlower1; */</a>
<a name="ln3344">        /* GetAtomStCapFlow( at, pVA, pSrm, i, &amp;c1, &amp;f1 ); */</a>
<a name="ln3345">        st_cap += c1;</a>
<a name="ln3346">        st_cap += bNeedsFlower1? 0 : pVA[i].cInitFreeValences;</a>
<a name="ln3347">        pBNS-&gt;vert[i].st_edge.cap = st_cap; /* the 1st time st_cap is set */</a>
<a name="ln3348">        pBNS-&gt;vert[i].st_edge.cap0 = pBNS-&gt;vert[i].st_edge.cap;</a>
<a name="ln3349">        tot_st_cap += st_cap;</a>
<a name="ln3350">    }</a>
<a name="ln3351">    num_iedges = iedge - pBNS-&gt;iedge;</a>
<a name="ln3352">    if ( max_iedges - num_iedges &lt; (nMaxAddEdges + NUM_KINDS_OF_GROUPS)*max_vertices ) {</a>
<a name="ln3353">        return DeAllocateBnStruct( pBNS );</a>
<a name="ln3354">    }</a>
<a name="ln3355">    </a>
<a name="ln3356">    pBNS-&gt;num_atoms       = num_atoms;      /* number of real atoms */</a>
<a name="ln3357">    pBNS-&gt;num_added_atoms = 0;</a>
<a name="ln3358">    pBNS-&gt;num_t_groups    = 0;              /* number of added t-groups */</a>
<a name="ln3359">    pBNS-&gt;num_c_groups    = 0;</a>
<a name="ln3360">    pBNS-&gt;nMaxAddAtoms    = nMaxAddAtoms;</a>
<a name="ln3361">    pBNS-&gt;nMaxAddEdges    = nMaxAddEdges;</a>
<a name="ln3362"> </a>
<a name="ln3363">    pBNS-&gt;num_vertices    = num_atoms;      /* current number of vertices, in general a sum of</a>
<a name="ln3364">                                               pBNS-&gt;num_atoms</a>
<a name="ln3365">                                               pBNS-&gt;num_t_groups</a>
<a name="ln3366">                                               number of c-groups</a>
<a name="ln3367">                                               number of auxiliary vertices</a>
<a name="ln3368">                                               pBNS-&gt;num_added_atoms</a>
<a name="ln3369">                                            */</a>
<a name="ln3370">    pBNS-&gt;max_vertices    = max_vertices;</a>
<a name="ln3371">    </a>
<a name="ln3372"> </a>
<a name="ln3373">    pBNS-&gt;num_bonds       = num_bonds;      /* number of real edges (bonds) */</a>
<a name="ln3374">    pBNS-&gt;max_edges       = max_edges;</a>
<a name="ln3375">    pBNS-&gt;max_iedges      = max_iedges;</a>
<a name="ln3376"> </a>
<a name="ln3377"> </a>
<a name="ln3378">    /* </a>
<a name="ln3379">       To remove t-groups and added atoms:</a>
<a name="ln3380"> </a>
<a name="ln3381">        for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln3382">            for ( j = pBNS-&gt;vert[i].num_adj_edges-1; 0 &lt;= j; j -- ) {</a>
<a name="ln3383">                k = pBNS-&gt;edge[pBNS-&gt;vert[i].iedge[j]].neighbor12 ^ i;</a>
<a name="ln3384">                if ( pBNS-&gt;vert[k].type &amp; BNS_VERT_TYPE_ATOM ) {</a>
<a name="ln3385">                    pBNS-&gt;vert[i].num_adj_edges = j+1;</a>
<a name="ln3386">                    break;</a>
<a name="ln3387">                }</a>
<a name="ln3388">            }</a>
<a name="ln3389">        }</a>
<a name="ln3390"> </a>
<a name="ln3391">       pBNS-&gt;num_vertices    = pBNS-&gt;num_atoms;</a>
<a name="ln3392">       pBNS-&gt;num_edges       = pBNS-&gt;num_bonds;</a>
<a name="ln3393">       pBNS-&gt;num_added_atoms = 0;</a>
<a name="ln3394">       pBNS-&gt;num_t_groups    = 0;</a>
<a name="ln3395">       pBNS-&gt;num_added_edges = 0;</a>
<a name="ln3396"> </a>
<a name="ln3397">       ALTP_DELTA(pBNS-&gt;alt_path)      = 0;</a>
<a name="ln3398">       ALTP_START_ATOM(pBNS-&gt;alt_path) = NO_VERTEX;</a>
<a name="ln3399">       ALTP_END_ATOM(pBNS-&gt;alt_path)   = NO_VERTEX;</a>
<a name="ln3400">       ALTP_PATH_LEN(pBNS-&gt;alt_path)   = 0;</a>
<a name="ln3401"> </a>
<a name="ln3402">    */</a>
<a name="ln3403"> </a>
<a name="ln3404"> </a>
<a name="ln3405">    /* add and fill edges and connectivity */</a>
<a name="ln3406">    for ( i = 0, n_edges = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3407">        vert    = pBNS-&gt;vert + i; /* pointer to the ith vertex */</a>
<a name="ln3408">        st_cap  = 0;</a>
<a name="ln3409">        st_flow = 0;</a>
<a name="ln3410">        flag_alt_bond = 0;</a>
<a name="ln3411">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln3412">            neigh = at[i].neighbor[j];</a>
<a name="ln3413">            /* find this bond at the neighbor */</a>
<a name="ln3414">            for ( k = 0; k &lt; at[neigh].valence; k ++ ) {</a>
<a name="ln3415">                if ( at[neigh].neighbor[k] == i ) {</a>
<a name="ln3416">                    break;</a>
<a name="ln3417">                }</a>
<a name="ln3418">            }</a>
<a name="ln3419">            bond_type = (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln3420">            bond_mark = (at[i].bond_type[j] &amp; ~BOND_TYPE_MASK);</a>
<a name="ln3421">            if ( bond_type != BOND_SINGLE &amp;&amp; bond_type != BOND_DOUBLE &amp;&amp; bond_type != BOND_TRIPLE ) {</a>
<a name="ln3422">                /* make unknown bonds single */</a>
<a name="ln3423">                bond_type = BOND_SINGLE;</a>
<a name="ln3424">                at[i].bond_type[j] = bond_mark | bond_type;</a>
<a name="ln3425">                num_changed_bonds ++;</a>
<a name="ln3426">            }</a>
<a name="ln3427">            if ( neigh &gt; i ) {</a>
<a name="ln3428">                /* this is the first time we encounter this bond */</a>
<a name="ln3429">                bNeedsFlower1 = AtomStcapStflow( at, pVA, pSrm, i, &amp;c1, &amp;f1, NULL, NULL );</a>
<a name="ln3430">                /* GetAtomStCapFlow( at, pVA, pSrm, i, &amp;c1, &amp;f1 ); */</a>
<a name="ln3431">                c1 += bNeedsFlower1? 0 : pVA[i].cInitFreeValences;  /* elevate cap to the lowest valence in ChargeStruct */</a>
<a name="ln3432">                bNeedsFlower2 = AtomStcapStflow( at, pVA, pSrm, neigh, &amp;c2, &amp;f2, NULL, NULL );</a>
<a name="ln3433">                /* GetAtomStCapFlow( at, pVA, pSrm, neigh, &amp;c2, &amp;f2 ); */</a>
<a name="ln3434">                c2 += bNeedsFlower2? 0 : pVA[neigh].cInitFreeValences; /* elevate cap to the lowest valence in ChargeStruct */</a>
<a name="ln3435">                /* at this point -O would have st_cap=st_flow=0 because the lowest valence=1 for charge=-1 */</a>
<a name="ln3436">                /* however, if -O belongs to a t-group its cap would be 1, flow = 0 */</a>
<a name="ln3437">                /*f1 = MAX_AT_FLOW(at[i]);*/</a>
<a name="ln3438">                /*f2 = MAX_AT_FLOW(at[neigh]);*/</a>
<a name="ln3439">                edge_flow = BondFlowMaxcapMinorder( at, pVA, pSrm, i, j, &amp;edge_cap, &amp;min_order, NULL);</a>
<a name="ln3440"> </a>
<a name="ln3441">                pBNS-&gt;edge[n_edges].neighbor1    = (AT_NUMB)i;</a>
<a name="ln3442">                pBNS-&gt;edge[n_edges].neighbor12   = (AT_NUMB)(i ^ neigh);</a>
<a name="ln3443">                pBNS-&gt;edge[n_edges].flow =</a>
<a name="ln3444">                pBNS-&gt;edge[n_edges].flow0        = edge_flow;</a>
<a name="ln3445">                pBNS-&gt;edge[n_edges].cap  =</a>
<a name="ln3446">                pBNS-&gt;edge[n_edges].cap0         = edge_cap;</a>
<a name="ln3447">                pBNS-&gt;edge[n_edges].neigh_ord[0] = j;  /* iedge to neigh index at vertex[i],     i &lt; neigh */</a>
<a name="ln3448">                pBNS-&gt;edge[n_edges].neigh_ord[1] = k;  /* iedge to i     index at vertex[neigh], i &lt; neigh */</a>
<a name="ln3449">                pBNS-&gt;edge[n_edges].pass         = 0;</a>
<a name="ln3450">                pBNS-&gt;edge[n_edges].forbidden    = 0; /* may be forbidden if edge_flow = 1: stereogenic fixed double bond */</a>
<a name="ln3451">                if ( bond_type == BOND_TYPE_DOUBLE ) {</a>
<a name="ln3452">                    /* forbid changing stereogenic double bonds */</a>
<a name="ln3453">                    for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[i].sb_parity[m]; m ++ ) {</a>
<a name="ln3454">                        if ( at[i].sb_ord[m] == j ) {</a>
<a name="ln3455">                            pBNS-&gt;edge[n_edges].forbidden |= BNS_EDGE_FORBIDDEN_MASK;</a>
<a name="ln3456">                            break;</a>
<a name="ln3457">                        }</a>
<a name="ln3458">                    }</a>
<a name="ln3459">                }</a>
<a name="ln3460">                vert-&gt;iedge[j] = pBNS-&gt;vert[neigh].iedge[k] = n_edges ++; /* same iedge index as neighbor index in at[] */</a>
<a name="ln3461">            } else {</a>
<a name="ln3462">                /* this is the second time we encounter this bond. It was stored at */</a>
<a name="ln3463">                int  iedge2 = pBNS-&gt;vert[neigh].iedge[k];</a>
<a name="ln3464">                edge_cap    = pBNS-&gt;edge[iedge2].cap;</a>
<a name="ln3465">                edge_flow   = pBNS-&gt;edge[iedge2].flow;</a>
<a name="ln3466">            }</a>
<a name="ln3467">            st_flow += edge_flow;</a>
<a name="ln3468">            /*</a>
<a name="ln3469">            st_cap  += edge_cap;</a>
<a name="ln3470">            */</a>
<a name="ln3471">        }</a>
<a name="ln3472">        vert-&gt;num_adj_edges = j;</a>
<a name="ln3473">        /*</a>
<a name="ln3474">        vert-&gt;st_edge.cap   =</a>
<a name="ln3475">        vert-&gt;st_edge.cap0  = st_cap;</a>
<a name="ln3476">        */</a>
<a name="ln3477">        vert-&gt;st_edge.flow  =</a>
<a name="ln3478">        vert-&gt;st_edge.flow0 = st_flow;</a>
<a name="ln3479">        vert-&gt;type          = BNS_VERT_TYPE_ATOM;</a>
<a name="ln3480">        /*</a>
<a name="ln3481">        tot_st_cap  += vert-&gt;st_edge.cap;</a>
<a name="ln3482">        */</a>
<a name="ln3483">        tot_st_flow += vert-&gt;st_edge.flow;</a>
<a name="ln3484">    }</a>
<a name="ln3485">    *pNum_changed_bonds = num_changed_bonds/2;</a>
<a name="ln3486"> </a>
<a name="ln3487">    pBNS-&gt;num_edges       = n_edges;   /* number of edges */</a>
<a name="ln3488">    pBNS-&gt;num_iedges      = num_iedges;</a>
<a name="ln3489">    pBNS-&gt;num_added_edges = 0;</a>
<a name="ln3490"> </a>
<a name="ln3491">    pBNS-&gt;tot_st_cap  = tot_st_cap;</a>
<a name="ln3492">    pBNS-&gt;tot_st_flow = tot_st_flow;</a>
<a name="ln3493"> </a>
<a name="ln3494">/* exit_function: */</a>
<a name="ln3495"> </a>
<a name="ln3496">    return pBNS;</a>
<a name="ln3497">}</a>
<a name="ln3498">/******************************************************************************************************/</a>
<a name="ln3499">void IncrZeroBondsAndClearEndpts(inp_ATOM *at, int num_at, int iComponent )</a>
<a name="ln3500">{</a>
<a name="ln3501">    int i, j;</a>
<a name="ln3502">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3503">        at[i].endpoint = 0;</a>
<a name="ln3504">        at[i].component = iComponent;</a>
<a name="ln3505">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln3506">            if ( !at[i].bond_type[j] ) {</a>
<a name="ln3507">                at[i].bond_type[j]        = BOND_TYPE_SINGLE;</a>
<a name="ln3508">                at[i].chem_bonds_valence += BOND_TYPE_SINGLE;</a>
<a name="ln3509">            }</a>
<a name="ln3510">        }</a>
<a name="ln3511">    }</a>
<a name="ln3512">}</a>
<a name="ln3513">void IncrZeroBonds(inp_ATOM *at, int num_at, int iComponent )</a>
<a name="ln3514">{</a>
<a name="ln3515">    int i, j;</a>
<a name="ln3516">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3517">        at[i].component = iComponent;</a>
<a name="ln3518">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln3519">            if ( !at[i].bond_type[j] ) {</a>
<a name="ln3520">                at[i].bond_type[j]        = BOND_TYPE_SINGLE;</a>
<a name="ln3521">                at[i].chem_bonds_valence += BOND_TYPE_SINGLE;</a>
<a name="ln3522">            }</a>
<a name="ln3523">        }</a>
<a name="ln3524">    }</a>
<a name="ln3525">}</a>
<a name="ln3526">void ClearEndpts(inp_ATOM *at, int num_at )</a>
<a name="ln3527">{</a>
<a name="ln3528">    int i;</a>
<a name="ln3529">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3530">        at[i].endpoint = 0;</a>
<a name="ln3531">    }</a>
<a name="ln3532">}</a>
<a name="ln3533"> </a>
<a name="ln3534"> </a>
<a name="ln3535">/******************************************************************************************************/</a>
<a name="ln3536">#define ANY_VERT_TYPE(X) (((X) &amp; (BNS_VERT_TYPE_ATOM | BNS_VERT_TYPE_TGROUP | BNS_VERT_TYPE_C_GROUP)) &amp;&amp; \</a>
<a name="ln3537">                           !((X) &amp; (BNS_VERT_TYPE_SUPER_TGROUP)))</a>
<a name="ln3538">#define GRP_VERT_TYPE(X) (((X) &amp; (BNS_VERT_TYPE_TGROUP | BNS_VERT_TYPE_C_GROUP)) &amp;&amp; \</a>
<a name="ln3539">                           !((X) &amp; (BNS_VERT_TYPE_SUPER_TGROUP)))</a>
<a name="ln3540">typedef struct tagVertexFlow {</a>
<a name="ln3541">    int        type;</a>
<a name="ln3542">    Vertex     v;</a>
<a name="ln3543">    EdgeIndex  e_In;</a>
<a name="ln3544">    EdgeIndex  e_Out;</a>
<a name="ln3545">    EdgeFlow   delta_In;</a>
<a name="ln3546">    EdgeFlow   delta_Out;</a>
<a name="ln3547">    Vertex     bUsed; /* indicates the charge edge belongs to already processed atom */</a>
<a name="ln3548">} VF;</a>
<a name="ln3549">#define NUM_VF 3</a>
<a name="ln3550">#define VF_USED_IN  1</a>
<a name="ln3551">#define VF_USED_OUT 2</a>
<a name="ln3552">#define VF_USED_ALL (VF_USED_IN | VF_USED_OUT)</a>
<a name="ln3553"> </a>
<a name="ln3554">int GetDeltaChargeFromVF( BN_STRUCT *pBNS, VAL_AT *pVA, VF *vf );</a>
<a name="ln3555">/******************************************************************************************************/</a>
<a name="ln3556">int GetDeltaChargeFromVF( BN_STRUCT *pBNS, VAL_AT *pVA, VF *vf )</a>
<a name="ln3557">{</a>
<a name="ln3558">    int i, v = NO_VERTEX;</a>
<a name="ln3559">    int ieIn1  = (!(vf-&gt;bUsed &amp; VF_USED_IN)  &amp;&amp; vf-&gt;e_In  &gt;= 0 &amp;&amp; vf-&gt;delta_In )? vf-&gt;e_In+1  : NO_VERTEX;</a>
<a name="ln3560">    int ieOut1 = (!(vf-&gt;bUsed &amp; VF_USED_OUT) &amp;&amp; vf-&gt;e_Out &gt;= 0 &amp;&amp; vf-&gt;delta_Out)? vf-&gt;e_Out+1 : NO_VERTEX;</a>
<a name="ln3561">    int nInitCharge, nPlusFlow, nMinusFlow, nDeltaCharge, nNumDeltaCharge, eCPlus, eCMinus;</a>
<a name="ln3562"> </a>
<a name="ln3563">    if ( !(vf-&gt;type &amp; BNS_VERT_TYPE_C_GROUP) ||</a>
<a name="ln3564">          (vf-&gt;type &amp; BNS_VERT_TYPE_SUPER_TGROUP) ||</a>
<a name="ln3565">          (ieIn1 == NO_VERTEX &amp;&amp; ieOut1 == NO_VERTEX ) ) {</a>
<a name="ln3566">        return 0;</a>
<a name="ln3567">    }</a>
<a name="ln3568">    if ( vf-&gt;type &amp; BNS_VERT_TYPE_C_NEGATIVE ) {</a>
<a name="ln3569">        /* negative charge edge */</a>
<a name="ln3570">        for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln3571">            if ( pVA[i].nCMinusGroupEdge == ieIn1 || pVA[i].nCMinusGroupEdge == ieOut1 ) {</a>
<a name="ln3572">                v = i;</a>
<a name="ln3573">                break;</a>
<a name="ln3574">            }</a>
<a name="ln3575">        }</a>
<a name="ln3576">    } else {</a>
<a name="ln3577">        /* positive charge edge */</a>
<a name="ln3578">        for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln3579">            if ( pVA[i].nCPlusGroupEdge == ieIn1 || pVA[i].nCPlusGroupEdge == ieOut1 ) {</a>
<a name="ln3580">                v = i;</a>
<a name="ln3581">                break;</a>
<a name="ln3582">            }</a>
<a name="ln3583">        }</a>
<a name="ln3584">    }</a>
<a name="ln3585">    if ( v == NO_VERTEX )</a>
<a name="ln3586">        return 0;</a>
<a name="ln3587">    </a>
<a name="ln3588">    nInitCharge = pVA[v].cInitCharge;</a>
<a name="ln3589">    nPlusFlow = nMinusFlow = 0;</a>
<a name="ln3590">    nNumDeltaCharge = 0;</a>
<a name="ln3591"> </a>
<a name="ln3592">    if ( (eCPlus = pVA[v].nCPlusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln3593">        nPlusFlow = pBNS-&gt;edge[eCPlus].cap</a>
<a name="ln3594">                  - pBNS-&gt;edge[eCPlus].flow;</a>
<a name="ln3595">    }</a>
<a name="ln3596">    if ( (eCMinus = pVA[v].nCMinusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln3597">        nMinusFlow = -pBNS-&gt;edge[eCMinus].flow;</a>
<a name="ln3598">    }</a>
<a name="ln3599">    nInitCharge += nPlusFlow + nMinusFlow;</a>
<a name="ln3600"> </a>
<a name="ln3601">    nDeltaCharge = 0;</a>
<a name="ln3602">    </a>
<a name="ln3603">    if ( !(vf[0].bUsed &amp; VF_USED_OUT) ) {</a>
<a name="ln3604">        if ( vf[0].e_Out==eCPlus || vf[0].e_Out==eCMinus ) {</a>
<a name="ln3605">            nDeltaCharge -= vf[0].delta_Out;</a>
<a name="ln3606">            vf[0].bUsed  |= VF_USED_OUT;</a>
<a name="ln3607">        }</a>
<a name="ln3608">    }</a>
<a name="ln3609">    </a>
<a name="ln3610">    if ( !(vf[0].bUsed &amp; VF_USED_IN) ) {</a>
<a name="ln3611">        if ( vf[0].e_In==eCPlus || vf[0].e_In==eCMinus ) {</a>
<a name="ln3612">            nDeltaCharge -= vf[0].delta_In;</a>
<a name="ln3613">            vf[0].bUsed |= VF_USED_IN;</a>
<a name="ln3614">        }</a>
<a name="ln3615">    }</a>
<a name="ln3616">    if ( !nInitCharge &amp;&amp; nDeltaCharge ) {</a>
<a name="ln3617">        nNumDeltaCharge ++;</a>
<a name="ln3618">    } else</a>
<a name="ln3619">    if ( nInitCharge &amp;&amp; 0 == nInitCharge + nDeltaCharge ) {</a>
<a name="ln3620">        nNumDeltaCharge --;</a>
<a name="ln3621">    }</a>
<a name="ln3622">    return nNumDeltaCharge;</a>
<a name="ln3623">}</a>
<a name="ln3624">/******************************************************************************************************/</a>
<a name="ln3625">int EvaluateChargeChanges( BN_STRUCT *pBNS, VAL_AT *pVA, int *pnDeltaH, int *pnDeltaCharge, int *pnNumVisitedAtoms )</a>
<a name="ln3626">{</a>
<a name="ln3627">    int       pass, i, j, v0, v1, v2, v, ineigh1, /*ineigh2,*/ vLast, n, delta, ret, ie, err = 0;</a>
<a name="ln3628">    BNS_EDGE *edge;</a>
<a name="ln3629">    int       nDeltaH, nDeltaCharge, iPrev, nInitCharge, nPlusFlow, nMinusFlow;</a>
<a name="ln3630">    int       nNumDeltaH = 0;</a>
<a name="ln3631">    int       nNumDeltaCharge = 0;</a>
<a name="ln3632">    int       nNumVisitedAtoms = 0;</a>
<a name="ln3633">    VF   vf[NUM_VF+1];</a>
<a name="ln3634">    </a>
<a name="ln3635">    *pnDeltaH           = 0;</a>
<a name="ln3636">    *pnDeltaCharge      = 0;</a>
<a name="ln3637">    *pnNumVisitedAtoms  = 0;</a>
<a name="ln3638"> </a>
<a name="ln3639">    for ( pass = pBNS-&gt;num_altp-1, ret = 0; 0 &lt;= pass; pass -- ) {</a>
<a name="ln3640">        </a>
<a name="ln3641">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln3642">        v1 = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln3643">        n  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln3644">        delta  = ALTP_DELTA(pBNS-&gt;alt_path);</a>
<a name="ln3645">        vLast = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln3646">        v0 = v2 = NO_VERTEX;</a>
<a name="ln3647"> </a>
<a name="ln3648">        memset( vf, 0, sizeof(vf) );</a>
<a name="ln3649">        for ( i = 0; i &lt; (int)(sizeof(vf)/sizeof(vf[0])); i ++ ) {</a>
<a name="ln3650">            vf[i].v      = NO_VERTEX; /* = -2 */</a>
<a name="ln3651">            vf[i].e_In   = NO_VERTEX;</a>
<a name="ln3652">            vf[i].e_Out  = NO_VERTEX;</a>
<a name="ln3653">        }</a>
<a name="ln3654">        iPrev = 0;</a>
<a name="ln3655">        /* add to the queue */</a>
<a name="ln3656">        if ( ANY_VERT_TYPE(pBNS-&gt;vert[v1].type) ) {</a>
<a name="ln3657">            if (pBNS-&gt;vert[v1].type &amp; BNS_VERT_TYPE_ATOM) {</a>
<a name="ln3658">                nNumVisitedAtoms ++;</a>
<a name="ln3659">            }</a>
<a name="ln3660">            vf[2].type = pBNS-&gt;vert[v1].type;</a>
<a name="ln3661">            vf[2].v    = v1;</a>
<a name="ln3662">            iPrev = 2;</a>
<a name="ln3663">        }</a>
<a name="ln3664"> </a>
<a name="ln3665">        nNumDeltaH = 0;      </a>
<a name="ln3666">        nNumDeltaCharge = 0; </a>
<a name="ln3667">        nNumVisitedAtoms = 0;</a>
<a name="ln3668"> </a>
<a name="ln3669">        for ( i = 0; i &lt; n; i ++, delta = -delta, v0 = v1, v1 = v2 ) {</a>
<a name="ln3670">            ineigh1 = ALTP_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v1-&gt;v2 neighbor */</a>
<a name="ln3671">            /*ineigh2 = ALTP_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);*/  /* v2-&gt;v1 neighbor */</a>
<a name="ln3672">            edge = pBNS-&gt;edge + (ie=pBNS-&gt;vert[v1].iedge[ineigh1]);</a>
<a name="ln3673">            /* follow the BN Structure, not the inp_ATOM, to take care of swithching to</a>
<a name="ln3674">               t-groups, c-groups or other fictitious edges/vertices</a>
<a name="ln3675">            */</a>
<a name="ln3676">            </a>
<a name="ln3677">            if ( iPrev ) {</a>
<a name="ln3678">                /* add exit delta and edge */</a>
<a name="ln3679">                vf[2].e_Out     = ie;</a>
<a name="ln3680">                vf[2].delta_Out = delta;</a>
<a name="ln3681">            }</a>
<a name="ln3682">            </a>
<a name="ln3683">            v2 = edge-&gt;neighbor12 ^ v1;  /* next vertex */</a>
<a name="ln3684">            if (pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_ATOM) {</a>
<a name="ln3685">                nNumVisitedAtoms ++;</a>
<a name="ln3686">            }</a>
<a name="ln3687"> </a>
<a name="ln3688">            if ( (ANY_VERT_TYPE(pBNS-&gt;vert[v2].type) || i == n-1) &amp;&amp;</a>
<a name="ln3689">                 (vf[0].type &amp; BNS_VERT_TYPE_C_GROUP) &amp;&amp; vf[0].bUsed != VF_USED_ALL ) {</a>
<a name="ln3690">                /* unused vertex is about to be discarded */</a>
<a name="ln3691">                nNumDeltaCharge += GetDeltaChargeFromVF( pBNS, pVA, &amp;vf[0] );</a>
<a name="ln3692">            }</a>
<a name="ln3693"> </a>
<a name="ln3694">            if ( ANY_VERT_TYPE(pBNS-&gt;vert[v2].type) ) {</a>
<a name="ln3695">                /* shift the queue */</a>
<a name="ln3696">                vf[0] = vf[1];</a>
<a name="ln3697">                vf[1] = vf[2];</a>
<a name="ln3698">                vf[2] = vf[3]; /* make vf[2] empty */</a>
<a name="ln3699">                /* add next vertex */</a>
<a name="ln3700">                vf[2].v        = v2;</a>
<a name="ln3701">                vf[2].type     = pBNS-&gt;vert[v2].type;</a>
<a name="ln3702">                vf[2].e_In     = ie;</a>
<a name="ln3703">                vf[2].delta_In = delta;</a>
<a name="ln3704">                iPrev = 2; /* indicates a newly added vertex */</a>
<a name="ln3705">            } else</a>
<a name="ln3706">            if ( i == n-1 ) {</a>
<a name="ln3707">                /* shift the queue */</a>
<a name="ln3708">                vf[0] = vf[1];</a>
<a name="ln3709">                vf[1] = vf[2];</a>
<a name="ln3710">                vf[2] = vf[3]; /* make vf[2] empty */</a>
<a name="ln3711">                iPrev = 1; /* indicates the last vertex */</a>
<a name="ln3712">            } else {</a>
<a name="ln3713">                iPrev = 0; /* no new vertex has been added */</a>
<a name="ln3714">            }</a>
<a name="ln3715">            </a>
<a name="ln3716">            if ( iPrev &amp;&amp; (vf[1].type &amp; BNS_VERT_TYPE_ATOM)) {</a>
<a name="ln3717">                /* a new vertex has just been added and  */</a>
<a name="ln3718">                /* an atom is in the middle of the queue */</a>
<a name="ln3719">                EdgeIndex eCPlus, eCMinus;</a>
<a name="ln3720">                v = vf[1].v;</a>
<a name="ln3721">                nInitCharge = pVA[v].cInitCharge;</a>
<a name="ln3722">                nPlusFlow = nMinusFlow = 0;</a>
<a name="ln3723">                if ( (eCPlus = pVA[v].nCPlusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln3724">                    nPlusFlow = pBNS-&gt;edge[eCPlus].cap</a>
<a name="ln3725">                              - pBNS-&gt;edge[eCPlus].flow;</a>
<a name="ln3726">                }</a>
<a name="ln3727">                if ( (eCMinus = pVA[v].nCMinusGroupEdge-1) &gt;= 0 ) {</a>
<a name="ln3728">                    nMinusFlow = -pBNS-&gt;edge[eCMinus].flow;</a>
<a name="ln3729">                }</a>
<a name="ln3730">                nInitCharge += nPlusFlow + nMinusFlow;</a>
<a name="ln3731"> </a>
<a name="ln3732">                nDeltaH = nDeltaCharge = 0;</a>
<a name="ln3733">                </a>
<a name="ln3734">                if ( vf[0].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln3735">                    nDeltaH -= delta;</a>
<a name="ln3736">                } else</a>
<a name="ln3737">                if ( (vf[0].type &amp; BNS_VERT_TYPE_C_GROUP) &amp;&amp; !(vf[0].bUsed &amp; VF_USED_OUT) ) {</a>
<a name="ln3738">                    if ( vf[0].e_Out==eCPlus || vf[0].e_Out==eCMinus ) {</a>
<a name="ln3739">                        nDeltaCharge -= vf[0].delta_Out;</a>
<a name="ln3740">                        vf[0].bUsed  |= VF_USED_OUT;</a>
<a name="ln3741">                    }</a>
<a name="ln3742">                }</a>
<a name="ln3743">                </a>
<a name="ln3744">                if ( vf[2].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln3745">                    nDeltaH += delta;</a>
<a name="ln3746">                } else</a>
<a name="ln3747">                if ( (vf[2].type &amp; BNS_VERT_TYPE_C_GROUP) &amp;&amp; !(vf[2].bUsed &amp; VF_USED_IN) ) {</a>
<a name="ln3748">                    if ( vf[2].e_In==eCPlus || vf[2].e_In==eCMinus ) {</a>
<a name="ln3749">                        nDeltaCharge -= vf[2].delta_In;</a>
<a name="ln3750">                        vf[2].bUsed |= VF_USED_IN;</a>
<a name="ln3751">                    }</a>
<a name="ln3752">                }</a>
<a name="ln3753">                if ( !nInitCharge &amp;&amp; nDeltaCharge ) {</a>
<a name="ln3754">                    nNumDeltaCharge ++;</a>
<a name="ln3755">                } else</a>
<a name="ln3756">                if ( nInitCharge &amp;&amp; 0 == nInitCharge + nDeltaCharge ) {</a>
<a name="ln3757">                    nNumDeltaCharge --;</a>
<a name="ln3758">                }</a>
<a name="ln3759">                </a>
<a name="ln3760">                nNumDeltaH      += abs(nDeltaH);</a>
<a name="ln3761">                /* nNumDeltaCharge += abs(nDeltaCharge); */</a>
<a name="ln3762">                vf[1].bUsed = VF_USED_ALL;</a>
<a name="ln3763">            }</a>
<a name="ln3764">        }</a>
<a name="ln3765">        for ( j = 0; j &lt; 3; j ++ ) {</a>
<a name="ln3766">            nNumDeltaCharge += GetDeltaChargeFromVF( pBNS, pVA, &amp;vf[j] );</a>
<a name="ln3767">        }</a>
<a name="ln3768">       </a>
<a name="ln3769">        *pnDeltaH           += nNumDeltaH;</a>
<a name="ln3770">        *pnDeltaCharge      += nNumDeltaCharge;</a>
<a name="ln3771">        *pnNumVisitedAtoms  += nNumVisitedAtoms;</a>
<a name="ln3772"> </a>
<a name="ln3773"> </a>
<a name="ln3774">        if ( v2 != vLast ) {</a>
<a name="ln3775">            err = BNS_PROGRAM_ERR;</a>
<a name="ln3776">        }</a>
<a name="ln3777">    }</a>
<a name="ln3778">    return err? err : ret;</a>
<a name="ln3779">}</a>
<a name="ln3780"> </a>
<a name="ln3781">/******************************************************************************************************/</a>
<a name="ln3782">int RunBnsTestOnce( BN_STRUCT *pBNS, BN_DATA *pBD, VAL_AT *pVA, Vertex *pvFirst, Vertex *pvLast,</a>
<a name="ln3783">                    int *pPathLen, int *pnDeltaH, int *pnDeltaCharge, int *pnNumVisitedAtoms  )</a>
<a name="ln3784">{</a>
<a name="ln3785">    int bChangeFlow = 0; /* do not change flow */</a>
<a name="ln3786">    int delta, ret, ret2, pass;</a>
<a name="ln3787">    </a>
<a name="ln3788">    ReInitBnStructAltPaths( pBNS );</a>
<a name="ln3789">    pass = 0;</a>
<a name="ln3790">    pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln3791">    pBNS-&gt;num_altp = 0;</a>
<a name="ln3792">    pBNS-&gt;bChangeFlow = 0;</a>
<a name="ln3793">    delta=BalancedNetworkSearch ( pBNS, pBD, bChangeFlow );</a>
<a name="ln3794">    if ( delta &gt; 0 ) {</a>
<a name="ln3795">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln3796">        *pvFirst   = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln3797">        *pPathLen  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln3798">        *pvLast    = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln3799">        pBNS-&gt;num_altp ++;</a>
<a name="ln3800">        ret2 = EvaluateChargeChanges( pBNS, pVA, pnDeltaH, pnDeltaCharge, pnNumVisitedAtoms );</a>
<a name="ln3801">    } else {</a>
<a name="ln3802">        *pvFirst   = NO_VERTEX;</a>
<a name="ln3803">        *pPathLen  = 0;</a>
<a name="ln3804">        *pvLast    = NO_VERTEX;</a>
<a name="ln3805">        ret2       = 0;</a>
<a name="ln3806">    }</a>
<a name="ln3807">    ReInitBnStructAltPaths( pBNS );</a>
<a name="ln3808">    ret = ReInitBnData( pBD );</a>
<a name="ln3809">    return (delta &gt;= 0 &amp;&amp; ret &gt; 0 )? -ret : delta;</a>
<a name="ln3810"> </a>
<a name="ln3811">}</a>
<a name="ln3812">/******************************************************************************************************/</a>
<a name="ln3813">int RunBnsRestoreOnce( BN_STRUCT *pBNS, BN_DATA *pBD, VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln3814">{</a>
<a name="ln3815">    /* run BNS for the first time */</a>
<a name="ln3816">    int nTotalDelta = 0, ret = 0;</a>
<a name="ln3817">    int nDelta;</a>
<a name="ln3818">    ReInitBnStructAltPaths( pBNS );</a>
<a name="ln3819">    do {</a>
<a name="ln3820">        nDelta = RunBalancedNetworkSearch( pBNS, pBD, BNS_EF_CHNG_FLOW );</a>
<a name="ln3821">        if ( IS_BNS_ERROR(nDelta) ) {</a>
<a name="ln3822">            ret = nDelta;</a>
<a name="ln3823">            goto exit_function;</a>
<a name="ln3824">        }</a>
<a name="ln3825">        nTotalDelta += nDelta;</a>
<a name="ln3826">        ReInitBnStructAltPaths( pBNS );</a>
<a name="ln3827">        ret    = ReInitBnData( pBD );</a>
<a name="ln3828">        if ( ret &gt; 0 ) {</a>
<a name="ln3829">            ret = -ret;</a>
<a name="ln3830">            goto exit_function;</a>
<a name="ln3831">        }</a>
<a name="ln3832">    } while( nDelta &gt; 0 &amp;&amp; ret == 0 );</a>
<a name="ln3833">    pBNS-&gt;tot_st_flow += 2*nTotalDelta;</a>
<a name="ln3834">    ret = nTotalDelta;</a>
<a name="ln3835">exit_function:</a>
<a name="ln3836">    return ret;</a>
<a name="ln3837">}</a>
<a name="ln3838">/******************************************************************************************************/</a>
<a name="ln3839">int comp_cc_cand( const void *a1, const void *a2 )</a>
<a name="ln3840">{</a>
<a name="ln3841">    const CC_CAND *p1 = (const CC_CAND *) a1;</a>
<a name="ln3842">    const CC_CAND *p2 = (const CC_CAND *) a2;</a>
<a name="ln3843">    int            ret;</a>
<a name="ln3844">    if ( (ret = (int)p2-&gt;cMetal - (int)p1-&gt;cMetal) )</a>
<a name="ln3845">        return ret; /* metal first */</a>
<a name="ln3846">    if ( (ret = (int)p2-&gt;cNumBondsToMetal - (int)p1-&gt;cNumBondsToMetal) )</a>
<a name="ln3847">        return ret; /* connected to metal first */</a>
<a name="ln3848">    if ( (ret = (int)p2-&gt;cPeriodicRowNumber - (int)p1-&gt;cPeriodicRowNumber) )</a>
<a name="ln3849">        return ret; /* heaviest first */</a>
<a name="ln3850">    if ( (ret = (int)p2-&gt;num_bonds - (int)p1-&gt;num_bonds) )</a>
<a name="ln3851">        return ret; /* more bonds first */</a>
<a name="ln3852">    if ( (ret = (int)p1-&gt;chem_valence - (int)p2-&gt;chem_valence) )</a>
<a name="ln3853">        return ret; /* less bond order first */</a>
<a name="ln3854">    if ( !p1-&gt;cNumValenceElectrons &amp;&amp; p2-&gt;cNumValenceElectrons )</a>
<a name="ln3855">        return -1; /* no valence electrons first */</a>
<a name="ln3856">    if ( !p2-&gt;cNumValenceElectrons &amp;&amp; p1-&gt;cNumValenceElectrons )</a>
<a name="ln3857">        return -1; /* no valence electrons first */</a>
<a name="ln3858">    if ( (int)p2-&gt;cNumValenceElectrons - (int)p1-&gt;cNumValenceElectrons )</a>
<a name="ln3859">        return ret; /* more valence electrons first */</a>
<a name="ln3860">    ret = (int)p2-&gt;iat - (int)p1-&gt;iat; /* greater canon number first */</a>
<a name="ln3861">    return ret;</a>
<a name="ln3862">}</a>
<a name="ln3863">/*****************************************************************************************************</a>
<a name="ln3864">Locate E1=C-E2 where</a>
<a name="ln3865">         e ev  are the edges</a>
<a name="ln3866"> </a>
<a name="ln3867">       E1 and E2 are atoms that belong to the same t-group</a>
<a name="ln3868">       C         is an atom that does not belong to any t-group</a>
<a name="ln3869">       e         is a forbidden edge</a>
<a name="ln3870">       ev        is not a forbidden edge</a>
<a name="ln3871"> </a>
<a name="ln3872">  Make changes so that:</a>
<a name="ln3873">       E1(d)-C(d)-E2</a>
<a name="ln3874"> </a>
<a name="ln3875">       where (d) means doublet radical</a>
<a name="ln3876"> </a>
<a name="ln3877">*/</a>
<a name="ln3878">/**************************************************************************************************/</a>
<a name="ln3879">int get_pVA_atom_type( VAL_AT *pVA, inp_ATOM *at, int iat, int bond_type )</a>
<a name="ln3880">{</a>
<a name="ln3881">    int type = 0, val;</a>
<a name="ln3882">    if ( pVA[iat].cNumValenceElectrons == 4 ) {</a>
<a name="ln3883">        if ( pVA[iat].cPeriodicRowNumber == 1 ) {</a>
<a name="ln3884">            type |= EL_TYPE_C;</a>
<a name="ln3885">        }</a>
<a name="ln3886">    } else</a>
<a name="ln3887">    if ( pVA[iat].cNumValenceElectrons == 6 ) {</a>
<a name="ln3888">        if ( pVA[iat].cPeriodicRowNumber == 1 ) {</a>
<a name="ln3889">            type |= EL_TYPE_O;</a>
<a name="ln3890">        } else</a>
<a name="ln3891">        if ( pVA[iat].cPeriodicRowNumber &lt; 5 ) {</a>
<a name="ln3892">            type |= EL_TYPE_S;</a>
<a name="ln3893">        }</a>
<a name="ln3894">        if ( bond_type == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln3895">             (type &amp; (EL_TYPE_O | EL_TYPE_S)) &amp;&amp;</a>
<a name="ln3896">             1 == nNoMetalBondsValence(at, iat ) &amp;&amp;</a>
<a name="ln3897">             1 == nNoMetalNumBonds(at, iat) ) {</a>
<a name="ln3898">            type |= EL_TYPE_OSt;</a>
<a name="ln3899">        }</a>
<a name="ln3900">    } else</a>
<a name="ln3901">    if ( pVA[iat].cNumValenceElectrons == 5 ) {</a>
<a name="ln3902">        if ( pVA[iat].cPeriodicRowNumber == 1 ) {</a>
<a name="ln3903">            type |= EL_TYPE_N;</a>
<a name="ln3904">        } else {</a>
<a name="ln3905">            type |= EL_TYPE_P;</a>
<a name="ln3906">        }</a>
<a name="ln3907">    } else</a>
<a name="ln3908">    if ( !is_el_a_metal(pVA[iat].cPeriodicNumber) ) {</a>
<a name="ln3909">        type |= EL_TYPE_X;</a>
<a name="ln3910">    }</a>
<a name="ln3911">    /* check for possibility to be a tautomeric endpoint (that is, be a Mobile H site) */</a>
<a name="ln3912">    val = get_endpoint_valence( at[iat].el_number );</a>
<a name="ln3913">    if ( val &amp;&amp; val &gt; at[iat].valence &amp;&amp; !at[iat].radical &amp;&amp;</a>
<a name="ln3914">         -1 &lt;= at[iat].charge &amp;&amp; at[iat].charge &lt;= 0 &amp;&amp;</a>
<a name="ln3915">         val == at[iat].chem_bonds_valence - at[iat].charge + at[iat].num_H ) {</a>
<a name="ln3916">        type |= EL_TYPE_PT;</a>
<a name="ln3917">    }</a>
<a name="ln3918">    return type;</a>
<a name="ln3919">}</a>
<a name="ln3920"> </a>
<a name="ln3921">/*************************************************************************************/</a>
<a name="ln3922">int AllocEdgeList( EDGE_LIST *pEdges, int nLen )</a>
<a name="ln3923">{</a>
<a name="ln3924">    switch( nLen ) {</a>
<a name="ln3925">    case EDGE_LIST_FREE:</a>
<a name="ln3926">        if ( NULL != pEdges-&gt;pnEdges ) {</a>
<a name="ln3927">            inchi_free( pEdges-&gt;pnEdges );</a>
<a name="ln3928">        }</a>
<a name="ln3929">        /* fall through */</a>
<a name="ln3930">    case EDGE_LIST_CLEAR:</a>
<a name="ln3931">        memset( pEdges, 0, sizeof(*pEdges) );</a>
<a name="ln3932">        break;</a>
<a name="ln3933">    default:</a>
<a name="ln3934">        if ( nLen &gt; 0 &amp;&amp; nLen != pEdges-&gt;num_alloc ) {</a>
<a name="ln3935">            EdgeIndex *tmp_edges = pEdges-&gt;pnEdges;</a>
<a name="ln3936">            int        tmp_num   = pEdges-&gt;num_edges;</a>
<a name="ln3937">            pEdges-&gt;pnEdges = (EdgeIndex *)inchi_calloc( nLen, sizeof(pEdges-&gt;pnEdges[0]));</a>
<a name="ln3938">            if ( !pEdges-&gt;pnEdges ) {</a>
<a name="ln3939">                return RI_ERR_ALLOC;</a>
<a name="ln3940">            }</a>
<a name="ln3941">            tmp_num = inchi_min( tmp_num, nLen );</a>
<a name="ln3942">            if ( tmp_edges &amp;&amp; tmp_num &gt; 0 ) {</a>
<a name="ln3943">                memcpy( pEdges-&gt;pnEdges, tmp_edges, tmp_num * sizeof(pEdges-&gt;pnEdges[0]) );</a>
<a name="ln3944">                pEdges-&gt;num_edges = tmp_num;</a>
<a name="ln3945">            } else {</a>
<a name="ln3946">                pEdges-&gt;num_edges = 0;</a>
<a name="ln3947">            }</a>
<a name="ln3948">            if ( tmp_edges ) {</a>
<a name="ln3949">                inchi_free( tmp_edges );</a>
<a name="ln3950">            }</a>
<a name="ln3951">            pEdges-&gt;num_alloc = nLen;</a>
<a name="ln3952">            return 0;</a>
<a name="ln3953">        }</a>
<a name="ln3954">        break;</a>
<a name="ln3955">    }</a>
<a name="ln3956">    return 0;</a>
<a name="ln3957">}</a>
<a name="ln3958">/********************************************************************/</a>
<a name="ln3959">int AddToEdgeList( EDGE_LIST *pEdges, int iedge, int nAddLen )</a>
<a name="ln3960">{</a>
<a name="ln3961">    if ( pEdges-&gt;num_alloc == pEdges-&gt;num_edges ) {</a>
<a name="ln3962">        int ret;</a>
<a name="ln3963">        if ( nAddLen &lt;= 0 ) {</a>
<a name="ln3964">            return RI_ERR_PROGR;</a>
<a name="ln3965">        }</a>
<a name="ln3966">        if ( (ret = AllocEdgeList( pEdges, pEdges-&gt;num_alloc + nAddLen )) ) {</a>
<a name="ln3967">            return ret;</a>
<a name="ln3968">        }</a>
<a name="ln3969">    }</a>
<a name="ln3970">    pEdges-&gt;pnEdges[pEdges-&gt;num_edges ++] = (EdgeIndex)iedge;</a>
<a name="ln3971">    return 0;</a>
<a name="ln3972">}</a>
<a name="ln3973">/********************************************************************/</a>
<a name="ln3974">int RemoveFromEdgeListByIndex( EDGE_LIST *pEdges, int index )</a>
<a name="ln3975">{</a>
<a name="ln3976">    int len;</a>
<a name="ln3977">    if ( 0 &lt;= (len = pEdges-&gt;num_edges - index - 1) ) {</a>
<a name="ln3978">        if ( len ) {</a>
<a name="ln3979">            memmove( pEdges-&gt;pnEdges+index, pEdges-&gt;pnEdges+index+1, len*sizeof(pEdges-&gt;pnEdges[0]));</a>
<a name="ln3980">        }</a>
<a name="ln3981">        pEdges-&gt;num_edges --;</a>
<a name="ln3982">        pEdges-&gt;pnEdges[pEdges-&gt;num_edges] = 0;</a>
<a name="ln3983">        return 0;</a>
<a name="ln3984">    }</a>
<a name="ln3985">    return -1;</a>
<a name="ln3986">}</a>
<a name="ln3987">/********************************************************************/</a>
<a name="ln3988">int FindInEdgeList( EDGE_LIST *pEdges, int iedge )</a>
<a name="ln3989">{</a>
<a name="ln3990">    int i;</a>
<a name="ln3991">    EdgeIndex ie = iedge;</a>
<a name="ln3992">    for ( i = pEdges-&gt;num_edges-1; 0 &lt;= i; i -- ) {</a>
<a name="ln3993">        if ( ie == pEdges-&gt;pnEdges[i] ) {</a>
<a name="ln3994">                return i;</a>
<a name="ln3995">        }</a>
<a name="ln3996">    }</a>
<a name="ln3997">    return -1;</a>
<a name="ln3998">}</a>
<a name="ln3999">/********************************************************************/</a>
<a name="ln4000">int RemoveFromEdgeListByValue( EDGE_LIST *pEdges, int iedge )</a>
<a name="ln4001">{</a>
<a name="ln4002">    int i, ret, n = 0;</a>
<a name="ln4003">    EdgeIndex ie = iedge;</a>
<a name="ln4004">    for ( i = pEdges-&gt;num_edges-1; 0 &lt;= i; i -- ) {</a>
<a name="ln4005">        if ( ie == pEdges-&gt;pnEdges[i] ) {</a>
<a name="ln4006">            if ( (ret = RemoveFromEdgeListByIndex( pEdges, i )) ) {</a>
<a name="ln4007">                return ret;</a>
<a name="ln4008">            }</a>
<a name="ln4009">            n ++;</a>
<a name="ln4010">        }</a>
<a name="ln4011">    }</a>
<a name="ln4012">    return n;</a>
<a name="ln4013">}</a>
<a name="ln4014">/********************************************************************/</a>
<a name="ln4015">int AllocBfsQueue( BFS_Q *pQ, int num_at, int min_ring_size )</a>
<a name="ln4016">{</a>
<a name="ln4017">    int ret = 0;</a>
<a name="ln4018">    switch( num_at ) {</a>
<a name="ln4019">    case BFS_Q_FREE:</a>
<a name="ln4020">        if ( pQ-&gt;q ) {</a>
<a name="ln4021">            pQ-&gt;q = QueueDelete( pQ-&gt;q );</a>
<a name="ln4022">        }</a>
<a name="ln4023">        if ( pQ-&gt;nAtomLevel ) {</a>
<a name="ln4024">            inchi_free( pQ-&gt;nAtomLevel );</a>
<a name="ln4025">        }</a>
<a name="ln4026">        if ( pQ-&gt;cSource ) {</a>
<a name="ln4027">            inchi_free( pQ-&gt;cSource );</a>
<a name="ln4028">        }</a>
<a name="ln4029">        /* fall through */</a>
<a name="ln4030">    case BFS_Q_CLEAR:</a>
<a name="ln4031">        memset( pQ, 0, sizeof( *pQ ) );</a>
<a name="ln4032">        return 0;</a>
<a name="ln4033">    default:</a>
<a name="ln4034">        if ( num_at &lt;= 0 ) {</a>
<a name="ln4035">            ret = RI_ERR_PROGR;</a>
<a name="ln4036">            goto exit_function;</a>
<a name="ln4037">        }</a>
<a name="ln4038">        if ( num_at &gt; pQ-&gt;num_at ) {</a>
<a name="ln4039">            if ( pQ-&gt;num_at ) {</a>
<a name="ln4040">                AllocBfsQueue( pQ, BFS_Q_FREE, 0 );</a>
<a name="ln4041">            }</a>
<a name="ln4042">            pQ-&gt;q          = QueueCreate( num_at+1, sizeof(qInt) );</a>
<a name="ln4043">            pQ-&gt;nAtomLevel = (AT_RANK*)inchi_calloc( sizeof(pQ-&gt;nAtomLevel[0]), num_at );</a>
<a name="ln4044">            pQ-&gt;cSource    = (S_CHAR *)inchi_calloc( sizeof(pQ-&gt;cSource[0]), num_at );</a>
<a name="ln4045">            if ( !pQ-&gt;q || !pQ-&gt;cSource || !pQ-&gt;nAtomLevel ) {</a>
<a name="ln4046">                ret = RI_ERR_ALLOC;</a>
<a name="ln4047">                goto exit_function;</a>
<a name="ln4048">            }</a>
<a name="ln4049">            pQ-&gt;num_at = num_at;</a>
<a name="ln4050">        }</a>
<a name="ln4051">        pQ-&gt;min_ring_size = min_ring_size;</a>
<a name="ln4052">    }</a>
<a name="ln4053">exit_function:</a>
<a name="ln4054">    return ret;</a>
<a name="ln4055">}</a>
<a name="ln4056">/*************************************************************************************/</a>
<a name="ln4057">void RemoveForbiddenEdgeMask( BN_STRUCT *pBNS, EDGE_LIST *pEdges, int forbidden_edge_mask  )</a>
<a name="ln4058">{</a>
<a name="ln4059">    int i, mask = ~forbidden_edge_mask;</a>
<a name="ln4060">    for ( i = 0; i &lt; pEdges-&gt;num_edges; i ++ ) {</a>
<a name="ln4061">        pBNS-&gt;edge[pEdges-&gt;pnEdges[i]].forbidden &amp;= mask;</a>
<a name="ln4062">    }</a>
<a name="ln4063">}</a>
<a name="ln4064">/*************************************************************************************/</a>
<a name="ln4065">void SetForbiddenEdgeMask( BN_STRUCT *pBNS, EDGE_LIST *pEdges, int forbidden_edge_mask  )</a>
<a name="ln4066">{</a>
<a name="ln4067">    int i;</a>
<a name="ln4068">    for ( i = 0; i &lt; pEdges-&gt;num_edges; i ++ ) {</a>
<a name="ln4069">        pBNS-&gt;edge[pEdges-&gt;pnEdges[i]].forbidden |= forbidden_edge_mask;</a>
<a name="ln4070">    }</a>
<a name="ln4071">}</a>
<a name="ln4072">/******************************************************************************************************/</a>
<a name="ln4073">void RemoveForbiddenBondFlowBits( BN_STRUCT *pBNS, int forbidden_edge_mask_int )</a>
<a name="ln4074">{</a>
<a name="ln4075">    BNS_EDGE   *e;</a>
<a name="ln4076">    int         i;</a>
<a name="ln4077">    int         inv_forbidden_edge_mask = ~forbidden_edge_mask_int;</a>
<a name="ln4078">    for ( i = 0, e = pBNS-&gt;edge; i &lt; pBNS-&gt;num_bonds; i ++, e ++ ) {</a>
<a name="ln4079">        e-&gt;forbidden &amp;= inv_forbidden_edge_mask;</a>
<a name="ln4080">    }</a>
<a name="ln4081">}</a>
<a name="ln4082">/******************************************************************************************************</a>
<a name="ln4083">         upper   vc</a>
<a name="ln4084">         edge   /</a>
<a name="ln4085">     v1[i0]---v0</a>
<a name="ln4086">       \     /</a>
<a name="ln4087">        \   /</a>
<a name="ln4088">         \ /</a>
<a name="ln4089">          v1[i1]</a>
<a name="ln4090">          |</a>
<a name="ln4091">          |</a>
<a name="ln4092">          atom</a>
<a name="ln4093">*/</a>
<a name="ln4094">int GetChargeFlowerUpperEdge( BN_STRUCT *pBNS, VAL_AT *pVA, int nChargeEdge )</a>
<a name="ln4095">{</a>
<a name="ln4096">    int ret = NO_VERTEX, i, j, k, i0, i1;</a>
<a name="ln4097">    Vertex  v0, v1[3], vc, v_t, v;</a>
<a name="ln4098">    BNS_EDGE   *pe, *pe1[3], *pe_t;</a>
<a name="ln4099">    BNS_VERTEX *pv0, *pv1[3], *pv_t;</a>
<a name="ln4100"> </a>
<a name="ln4101">    if ( nChargeEdge &lt; 0 ) {</a>
<a name="ln4102">        goto exit_function;</a>
<a name="ln4103">    }</a>
<a name="ln4104">    pe = pBNS-&gt;edge + nChargeEdge;</a>
<a name="ln4105">    vc = pe-&gt;neighbor1; /* charge vertex */</a>
<a name="ln4106">    if ( !IS_BNS_VT_C_GR(pBNS-&gt;vert[vc].type) ) {</a>
<a name="ln4107">        vc = vc ^ pe-&gt;neighbor12;</a>
<a name="ln4108">    }</a>
<a name="ln4109">    v0 = vc ^ pe-&gt;neighbor12; /* ChargeStruct vertex ? */</a>
<a name="ln4110">    pv0 = pBNS-&gt;vert + v0;</a>
<a name="ln4111">    if ( IS_BNS_VT_ATOM(pv0-&gt;type) ) {</a>
<a name="ln4112">        goto exit_function; /* no charge flower exists */</a>
<a name="ln4113">    }</a>
<a name="ln4114">    /* 2 edges from v0 */</a>
<a name="ln4115">    for ( i = j = 0; i &lt; pv0-&gt;num_adj_edges &amp;&amp; j &lt; 3; i ++ ) {</a>
<a name="ln4116">        pe1[j] = pBNS-&gt;edge + pv0-&gt;iedge[i];</a>
<a name="ln4117">        if ( vc != ( v1[j] = pe1[j]-&gt;neighbor12 ^ v0 ) &amp;&amp;</a>
<a name="ln4118">             (pv1[j] = pBNS-&gt;vert + v1[j], </a>
<a name="ln4119">              !IS_BNS_VT_ATOM(pv1[j]-&gt;type) &amp;&amp; !IS_BNS_VT_C_GR(pv1[j]-&gt;type)) ) {</a>
<a name="ln4120">            j ++;</a>
<a name="ln4121">        }</a>
<a name="ln4122">    }</a>
<a name="ln4123">    if ( j != 2 || i != pv0-&gt;num_adj_edges ) {</a>
<a name="ln4124">        goto exit_function;</a>
<a name="ln4125">    }</a>
<a name="ln4126">    </a>
<a name="ln4127">    if ( pv1[1]-&gt;num_adj_edges == 2 &amp;&amp;</a>
<a name="ln4128">         pv1[0]-&gt;num_adj_edges == 3 ) {</a>
<a name="ln4129">        i0 = 1;</a>
<a name="ln4130">        i1 = 0;</a>
<a name="ln4131">    } else</a>
<a name="ln4132">    if ( pv1[0]-&gt;num_adj_edges == 2 &amp;&amp;</a>
<a name="ln4133">         pv1[1]-&gt;num_adj_edges == 3 ) {</a>
<a name="ln4134">        i0 = 0;</a>
<a name="ln4135">        i1 = 1;</a>
<a name="ln4136">    } else {</a>
<a name="ln4137">        goto exit_function;</a>
<a name="ln4138">    }</a>
<a name="ln4139">    /* additional check: traverse edges around v1[i1] */</a>
<a name="ln4140">    pv_t = pv1[i1];</a>
<a name="ln4141">    v_t  = v1[i1];</a>
<a name="ln4142">    for ( i = k = 0; i &lt; pv_t-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln4143">        pe_t = pBNS-&gt;edge + pv_t-&gt;iedge[i];</a>
<a name="ln4144">        v  = pe_t-&gt;neighbor12 ^ v_t; /* v1[i1] neighbor */</a>
<a name="ln4145">        if ( v == v0 ) {</a>
<a name="ln4146">            k += 1;</a>
<a name="ln4147">        }</a>
<a name="ln4148">        if ( v == v1[i0] ) {</a>
<a name="ln4149">            k += 2;</a>
<a name="ln4150">        }</a>
<a name="ln4151">        if ( IS_BNS_VT_ATOM(pBNS-&gt;vert[v].type) ) {</a>
<a name="ln4152">            k += 4;</a>
<a name="ln4153">        }</a>
<a name="ln4154">    }</a>
<a name="ln4155">    if ( k != 7 ) {</a>
<a name="ln4156">        goto exit_function;</a>
<a name="ln4157">    }</a>
<a name="ln4158">    ret = pe1[i0] - pBNS-&gt;edge;</a>
<a name="ln4159">        </a>
<a name="ln4160">exit_function:</a>
<a name="ln4161">    return ret;</a>
<a name="ln4162"> </a>
<a name="ln4163">}</a>
<a name="ln4164">#if (INCLUDE_NORMALIZATION_ENTRY_POINT == 1 )</a>
<a name="ln4165">/********************************************************************************************</a>
<a name="ln4166">input: allocate (num_at+num_deleted_H) atoms in inp_ATOM *at_norm, *at_fixed_bonds_out</a>
<a name="ln4167">       allocate t_group_info</a>
<a name="ln4168">*********************************************************************************************/</a>
<a name="ln4169">int NormalizeStructure( ICHICONST INPUT_PARMS *ip, STRUCT_DATA *sd, BN_STRUCT *pBNS, </a>
<a name="ln4170">                        StrFromINChI *pStruct, inp_ATOM *at, inp_ATOM *at2,</a>
<a name="ln4171">                        VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln4172">                        inp_ATOM *at_norm, inp_ATOM *at_fixed_bonds_out, T_GROUP_INFO *t_group_info )</a>
<a name="ln4173">{</a>
<a name="ln4174">    int i, ret, num_endpoints, nLenTaut;</a>
<a name="ln4175">    int num_at = pStruct-&gt;num_atoms;</a>
<a name="ln4176">    int num_deleted_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln4177">    int len_at = num_at + num_deleted_H;</a>
<a name="ln4178">    /*</a>
<a name="ln4179">    T_GROUP_INFO tgi;</a>
<a name="ln4180">    T_GROUP_INFO *t_group_info = &amp;tgi;</a>
<a name="ln4181">    inp_ATOM *at_fixed_bonds_out = NULL;</a>
<a name="ln4182">    inp_ATOM *at_norm = NULL;</a>
<a name="ln4183"> </a>
<a name="ln4184">    at_norm = (inp_ATOM *)inchi_calloc( len_at, sizeof(at_norm[0]) );</a>
<a name="ln4185">    at_fixed_bonds_out = (inp_ATOM *)inchi_calloc( len_at, sizeof(at_fixed_bonds_out[0]) );</a>
<a name="ln4186">    if ( !at_norm || !at_fixed_bonds_out ) {</a>
<a name="ln4187">        if ( at_norm ) inchi_free( at_norm );</a>
<a name="ln4188">        if ( at_fixed_bonds_out ) inchi_free( at_fixed_bonds_out );</a>
<a name="ln4189">        ret = RI_ERR_ALLOC;</a>
<a name="ln4190">        goto exit_function;</a>
<a name="ln4191">    }</a>
<a name="ln4192">    */</a>
<a name="ln4193">/* call normalization only */</a>
<a name="ln4194">    memset( t_group_info, 0, sizeof(t_group_info[0]) );</a>
<a name="ln4195">    t_group_info-&gt;tni.nNumRemovedExplicitH = pStruct-&gt;num_deleted_H;</a>
<a name="ln4196">    t_group_info-&gt;bTautFlags     = ip-&gt;bTautFlags;</a>
<a name="ln4197">    t_group_info-&gt;bTautFlagsDone = 0; /* (ip-&gt;bTautFlagsDone | sd-&gt;bTautFlagsDone[INCHI_BAS]);*/</a>
<a name="ln4198">    </a>
<a name="ln4199">    memcpy( at2, at, len_at*sizeof(at2[0]));</a>
<a name="ln4200">    pStruct-&gt;at = at2;</a>
<a name="ln4201">    ret = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4202">    pStruct-&gt;at = at;</a>
<a name="ln4203">    if ( ret &lt; 0 ) {</a>
<a name="ln4204">        goto exit_function;</a>
<a name="ln4205">    }</a>
<a name="ln4206">#if ( FIND_RING_SYSTEMS == 1 )</a>
<a name="ln4207">    ret = MarkRingSystemsInp( at2, num_at, 0 );</a>
<a name="ln4208">    if ( ret &lt; 0 ) {</a>
<a name="ln4209">        goto exit_function;</a>
<a name="ln4210">    }</a>
<a name="ln4211">#endif</a>
<a name="ln4212">    memcpy( at_norm, at2, len_at * sizeof(at_norm[0]) );</a>
<a name="ln4213">    for ( i = 0, num_endpoints = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln4214">        num_endpoints += (0 != at_norm[i].endpoint);</a>
<a name="ln4215">        at_norm[i].endpoint = 0;</a>
<a name="ln4216">    }</a>
<a name="ln4217">    </a>
<a name="ln4218">    ret = mark_alt_bonds_and_taut_groups ( at_norm, at_fixed_bonds_out, num_at, t_group_info,</a>
<a name="ln4219">                                           NULL /* &amp;inpbTautFlags*/, NULL /*inpbTautFlagsDone*/ );</a>
<a name="ln4220">    if ( ret &lt; 0 ) {</a>
<a name="ln4221">        goto exit_function;/*  out of RAM or other normalization problem */</a>
<a name="ln4222">    }</a>
<a name="ln4223">    /* after normalization, t_group_info-&gt;t_group[i].num[0] = number of H + number of (-)   */</a>
<a name="ln4224">    /*                         t_group_info-&gt;t_group[i].num[1] = number of (-)              */</a>
<a name="ln4225"> </a>
<a name="ln4226">    /* --- count t-groups, remove (-)-only t-groups, replace -------------------------------*/</a>
<a name="ln4227">    /* t_group_info-&gt;t_group[i].num[0] with                                                 */</a>
<a name="ln4228">    /* t_group_info-&gt;t_group[i].num[0]-t_group_info-&gt;t_group[i].num[1]                      */</a>
<a name="ln4229">    nLenTaut = CountTautomerGroupsInpAt( at_norm, num_at, t_group_info );</a>
<a name="ln4230">    ret = nLenTaut;</a>
<a name="ln4231">exit_function:</a>
<a name="ln4232">    return ret;</a>
<a name="ln4233">}</a>
<a name="ln4234">#endif</a>
<a name="ln4235">/******************************************************************************************************/</a>
<a name="ln4236">int MakeOneInChIOutOfStrFromINChI2(ICHICONST INPUT_PARMS *ip_inp, STRUCT_DATA *sd_inp, </a>
<a name="ln4237">                                   BN_STRUCT *pBNS, StrFromINChI *pStruct,</a>
<a name="ln4238">                                   inp_ATOM *at, inp_ATOM *at2, inp_ATOM *at3, </a>
<a name="ln4239">                                   VAL_AT *pVA, ALL_TC_GROUPS *pTCGroups,</a>
<a name="ln4240">                                   T_GROUP_INFO **t_group_info, </a>
<a name="ln4241">                                   inp_ATOM **at_norm, inp_ATOM **at_prep )</a>
<a name="ln4242">{ </a>
<a name="ln4243">    int ret;</a>
<a name="ln4244">    INPUT_PARMS ip_loc, *ip;</a>
<a name="ln4245">    STRUCT_DATA sd_loc, *sd;</a>
<a name="ln4246"> </a>
<a name="ln4247">    ip_loc = *ip_inp;</a>
<a name="ln4248">    sd_loc = *sd_inp;</a>
<a name="ln4249">    ip = &amp;ip_loc;</a>
<a name="ln4250">    sd = &amp;sd_loc;</a>
<a name="ln4251">    memset( sd, 0, sizeof(*sd) );</a>
<a name="ln4252">    /* create structure out of BNS */</a>
<a name="ln4253">    memcpy( at2, at, (pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H)*sizeof(at2[0]));</a>
<a name="ln4254">    pStruct-&gt;at = at2;</a>
<a name="ln4255">    ret = CopyBnsToAtom( pStruct, pBNS, pVA, pTCGroups, 1 );</a>
<a name="ln4256">    pStruct-&gt;at = at;</a>
<a name="ln4257">    if ( ret &lt; 0 ) {</a>
<a name="ln4258">        goto exit_function;/*  out of RAM or other normalization problem */</a>
<a name="ln4259">    }</a>
<a name="ln4260">    pStruct-&gt;at = at;</a>
<a name="ln4261">    ret = MakeOneInChIOutOfStrFromINChI( ip, sd, pStruct, at2, at3, pTCGroups );</a>
<a name="ln4262">    if ( ret &lt; 0 ) {</a>
<a name="ln4263">        goto exit_function;/*  out of RAM or other normalization problem */</a>
<a name="ln4264">    }</a>
<a name="ln4265">    if ( at_norm ) {</a>
<a name="ln4266">        *at_norm        = pStruct-&gt;pOne_norm_data[0]-&gt;at;</a>
<a name="ln4267">    }</a>
<a name="ln4268">    if ( at_prep ) {</a>
<a name="ln4269">        if ( pStruct-&gt;pOne_norm_data[0]-&gt;bTautPreprocessed &amp;&amp; pStruct-&gt;pOne_norm_data[0]-&gt;at_fixed_bonds ) {</a>
<a name="ln4270">            *at_prep = pStruct-&gt;pOne_norm_data[0]-&gt;at_fixed_bonds;</a>
<a name="ln4271">        } else</a>
<a name="ln4272">        /* get preprocessed structure in case of Fixed-H */</a>
<a name="ln4273">        if ( pStruct-&gt;iMobileH == TAUT_NON &amp;&amp; pStruct-&gt;pOne_norm_data[1] &amp;&amp; pStruct-&gt;pOne_norm_data[1]-&gt;bTautPreprocessed ) {</a>
<a name="ln4274">            *at_prep = pStruct-&gt;pOne_norm_data[1]-&gt;at_fixed_bonds;</a>
<a name="ln4275">        } else {</a>
<a name="ln4276">            *at_prep = NULL;</a>
<a name="ln4277">        }</a>
<a name="ln4278">    }</a>
<a name="ln4279">    if ( t_group_info ) {</a>
<a name="ln4280">        if ( pStruct-&gt;iMobileH == TAUT_YES &amp;&amp;</a>
<a name="ln4281">             pStruct-&gt;One_ti.num_t_groups &amp;&amp;</a>
<a name="ln4282">             pStruct-&gt;One_ti.t_group &amp;&amp; pStruct-&gt;One_ti.nEndpointAtomNumber ) {</a>
<a name="ln4283">            *t_group_info   = &amp;pStruct-&gt;One_ti;</a>
<a name="ln4284">        } else {</a>
<a name="ln4285">            *t_group_info   = NULL;</a>
<a name="ln4286">        }</a>
<a name="ln4287">    }</a>
<a name="ln4288">exit_function:</a>
<a name="ln4289">    return ret;</a>
<a name="ln4290">}</a>
<a name="ln4291"> </a>
<a name="ln4292">/******************************************************************************************************/</a>
<a name="ln4293">int MakeOneInChIOutOfStrFromINChI( ICHICONST INPUT_PARMS *ip, STRUCT_DATA *sd, StrFromINChI *pStruct,</a>
<a name="ln4294">                                   inp_ATOM *at2, inp_ATOM *at3, ALL_TC_GROUPS *pTCGroups )</a>
<a name="ln4295">{</a>
<a name="ln4296"> </a>
<a name="ln4297">    INCHI_MODE     bTautFlags     = ip-&gt;bTautFlags | TG_FLAG_H_ALREADY_REMOVED;</a>
<a name="ln4298">    INCHI_MODE     bTautFlagsDone = 0; /*(ip-&gt;bTautFlagsDone | sd-&gt;bTautFlagsDone[INCHI_BAS]);*/</a>
<a name="ln4299">    INChI       *cur_INChI[TAUT_NUM];</a>
<a name="ln4300">    INChI_Aux   *cur_INChI_Aux[TAUT_NUM];</a>
<a name="ln4301">    int           i, j, k;</a>
<a name="ln4302">    int           iComponent  = pTCGroups-&gt;iComponent;</a>
<a name="ln4303">    int           len_at = pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H;</a>
<a name="ln4304">    int           num_atoms = pStruct-&gt;num_atoms;</a>
<a name="ln4305">    long          ulStructTime;</a>
<a name="ln4306">    </a>
<a name="ln4307">    INP_ATOM_DATA InpCurAtData;</a>
<a name="ln4308">    INP_ATOM_DATA *inp_cur_data;</a>
<a name="ln4309"> </a>
<a name="ln4310">    INP_ATOM_DATA InpNormAtData, InpNormTautData;</a>
<a name="ln4311">    INP_ATOM_DATA *inp_norm_data[TAUT_NUM]; /*  = { &amp;InpNormAtData, &amp;InpNormTautData }; */</a>
<a name="ln4312"> </a>
<a name="ln4313">    int            bOrigCoord = 0;</a>
<a name="ln4314">    int            num_at, ret = RI_ERR_PROGR;</a>
<a name="ln4315">    struct tagInchiTime ulMaxTime;</a>
<a name="ln4316"> </a>
<a name="ln4317">    T_GROUP_INFO *t_group_info = NULL;</a>
<a name="ln4318">    /* initialization */</a>
<a name="ln4319">    inp_cur_data     = &amp;InpCurAtData;</a>
<a name="ln4320">    inp_norm_data[TAUT_NON] = &amp;InpNormAtData;</a>
<a name="ln4321">    inp_norm_data[TAUT_YES] = &amp;InpNormTautData;</a>
<a name="ln4322"> </a>
<a name="ln4323">    memset( inp_cur_data      , 0, sizeof( *inp_cur_data     ) );</a>
<a name="ln4324">    memset( inp_norm_data[TAUT_NON], 0, sizeof( *inp_norm_data[0] ) );</a>
<a name="ln4325">    memset( inp_norm_data[TAUT_YES], 0, sizeof( *inp_norm_data[0] ) );</a>
<a name="ln4326">    ulStructTime = sd-&gt;ulStructTime;</a>
<a name="ln4327">    memset( sd, 0, sizeof(*sd) );</a>
<a name="ln4328">    </a>
<a name="ln4329">    /* deallocate old results */</a>
<a name="ln4330">    free_t_group_info( &amp;pStruct-&gt;One_ti );</a>
<a name="ln4331">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln4332">        Free_INChI( &amp;pStruct-&gt;pOneINChI[k] );</a>
<a name="ln4333">        Free_INChI_Aux( &amp;pStruct-&gt;pOneINChI_Aux[k] );</a>
<a name="ln4334">        if ( pStruct-&gt;pOne_norm_data[k] ) {</a>
<a name="ln4335">            FreeInpAtomData( pStruct-&gt;pOne_norm_data[k] );</a>
<a name="ln4336">            inchi_free( pStruct-&gt;pOne_norm_data[k] );</a>
<a name="ln4337">            pStruct-&gt;pOne_norm_data[k] = NULL;</a>
<a name="ln4338">        }</a>
<a name="ln4339">        cur_INChI[k]      = NULL;</a>
<a name="ln4340">        cur_INChI_Aux[k]  = NULL;</a>
<a name="ln4341">    }</a>
<a name="ln4342">    memcpy( at3, at2, sizeof(at3[0])*len_at );</a>
<a name="ln4343">    /* prepare the structure */</a>
<a name="ln4344">    IncrZeroBondsAndClearEndpts(at3, num_atoms, iComponent+1);</a>
<a name="ln4345">    CopySt2At( at3, pStruct-&gt;st, pStruct-&gt;num_atoms );</a>
<a name="ln4346">    FixUnkn0DStereoBonds( at3, pStruct-&gt;num_atoms);</a>
<a name="ln4347">    ret = ReconcileAllCmlBondParities( at3, pStruct-&gt;num_atoms, 0 );</a>
<a name="ln4348">    if ( ret &lt; 0 ) {</a>
<a name="ln4349">        goto exit_function;</a>
<a name="ln4350">    }</a>
<a name="ln4351">    if ( 0 &lt; fix_odd_things( num_atoms, at3, 1, ip-&gt;bFixNonUniformDraw ) ) </a>
<a name="ln4352">    {</a>
<a name="ln4353">        if ( sd-&gt;nErrorType &lt; _IS_WARNING ) </a>
<a name="ln4354">        {</a>
<a name="ln4355">            sd-&gt;nErrorType = _IS_WARNING;</a>
<a name="ln4356">        }</a>
<a name="ln4357">        sd-&gt;bTautFlagsDone[INCHI_BAS] |= TG_FLAG_FIX_ODD_THINGS_DONE;</a>
<a name="ln4358">    }</a>
<a name="ln4359">    /* allocate and set parameters */</a>
<a name="ln4360">    inp_cur_data-&gt;at = at3;</a>
<a name="ln4361">    inp_cur_data-&gt;num_at = num_atoms;</a>
<a name="ln4362">    inp_cur_data-&gt;num_removed_H = pStruct-&gt;num_deleted_H;</a>
<a name="ln4363"> </a>
<a name="ln4364">    bTautFlagsDone &amp;= ~(TG_FLAG_FOUND_ISOTOPIC_H_DONE | TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE);</a>
<a name="ln4365"> </a>
<a name="ln4366">    if ( (i = bNumHeterAtomHasIsotopicH( at3, num_atoms )) ) {</a>
<a name="ln4367">        if ( i &amp; 1 ) {</a>
<a name="ln4368">            bTautFlagsDone |= TG_FLAG_FOUND_ISOTOPIC_H_DONE;</a>
<a name="ln4369">        }</a>
<a name="ln4370">        if ( i &amp; 2 ) {</a>
<a name="ln4371">            bTautFlagsDone |= TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE;</a>
<a name="ln4372">        }</a>
<a name="ln4373">    }</a>
<a name="ln4374"> </a>
<a name="ln4375">    memset( &amp;ulMaxTime, 0, sizeof(ulMaxTime));</a>
<a name="ln4376"> </a>
<a name="ln4377">    /*  allocate memory for non-tautimeric (k=0) and tautomeric (k=1) results */</a>
<a name="ln4378">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln4379"> </a>
<a name="ln4380">        if ( !pStruct-&gt;bMobileH || k == pStruct-&gt;bMobileH ) {</a>
<a name="ln4381">            /* pStruct-&gt;bMobileH=0: k = 0, 1   =&gt; allow allocation of both Fixed-H and Mobile-H InChI</a>
<a name="ln4382">               pStruct-&gt;bMobileH=1: k = 1 only =&gt; allow allocation of only Mobile-H InChI              */ </a>
<a name="ln4383">            int nAllocMode = (k==TAUT_YES? REQ_MODE_TAUT:0) |</a>
<a name="ln4384">                             (bTautFlagsDone &amp; ( TG_FLAG_FOUND_ISOTOPIC_H_DONE |</a>
<a name="ln4385">                                                 TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE ))?</a>
<a name="ln4386">                             (ip-&gt;nMode &amp; REQ_MODE_ISO):0;</a>
<a name="ln4387"> </a>
<a name="ln4388">            if ( (k==TAUT_NON &amp;&amp; (ip-&gt;nMode &amp; REQ_MODE_BASIC )) ||</a>
<a name="ln4389">                 (k==TAUT_YES &amp;&amp; (ip-&gt;nMode &amp; REQ_MODE_TAUT ))     ) {</a>
<a name="ln4390">                /*  alloc INChI and INChI_Aux only if ip-&gt;nMode allows this */</a>
<a name="ln4391">                cur_INChI[k]     = Alloc_INChI( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at, &amp;inp_cur_data-&gt;num_bonds,</a>
<a name="ln4392">                                              &amp;inp_cur_data-&gt;num_isotopic, nAllocMode );</a>
<a name="ln4393">                cur_INChI_Aux[k] = Alloc_INChI_Aux( inp_cur_data-&gt;num_at,</a>
<a name="ln4394">                                              inp_cur_data-&gt;num_isotopic, nAllocMode, bOrigCoord );</a>
<a name="ln4395">                if ( cur_INChI_Aux[k] ) {</a>
<a name="ln4396">                    cur_INChI_Aux[k]-&gt;bIsIsotopic = inp_cur_data-&gt;num_isotopic;</a>
<a name="ln4397">                }</a>
<a name="ln4398">                /*  alloc memory for the output structure: non-tautomeric and tautomeric (for displaying) */</a>
<a name="ln4399">                CreateInpAtomData( inp_norm_data[k], inp_cur_data-&gt;num_at+inp_cur_data-&gt;num_removed_H, k );</a>
<a name="ln4400">                inp_norm_data[k]-&gt;num_removed_H = inp_cur_data-&gt;num_removed_H;</a>
<a name="ln4401">            } else {</a>
<a name="ln4402">                FreeInpAtomData( inp_norm_data[k] );</a>
<a name="ln4403">            }</a>
<a name="ln4404">        } else {</a>
<a name="ln4405">            FreeInpAtomData( inp_norm_data[k] );</a>
<a name="ln4406">        }</a>
<a name="ln4407">    }</a>
<a name="ln4408">    k = pStruct-&gt;bMobileH;</a>
<a name="ln4409">    /* In case of Fixed-H we have to create InChI for both Fixed-H and Mobile-H */</a>
<a name="ln4410">    num_at = Create_INChI( cur_INChI, cur_INChI_Aux, NULL/* not used */, inp_cur_data-&gt;at,</a>
<a name="ln4411">                          inp_norm_data,</a>
<a name="ln4412">                          inp_cur_data-&gt;num_at+inp_cur_data-&gt;num_removed_H,</a>
<a name="ln4413">                          ip-&gt;nMode, &amp;bTautFlags, &amp;bTautFlagsDone, NULL /* &amp;ulMaxTime*/, &amp;pStruct-&gt;One_ti, sd-&gt;pStrErrStruct);</a>
<a name="ln4414">    SetConnectedComponentNumber( inp_cur_data-&gt;at, inp_cur_data-&gt;num_at, iComponent+1 ); /*  normalization alters structure component number */</a>
<a name="ln4415">    </a>
<a name="ln4416">    /* detect InChI errors */</a>
<a name="ln4417"> </a>
<a name="ln4418">    if ( num_at &lt; 0 ) {</a>
<a name="ln4419">        ret = num_at;</a>
<a name="ln4420">    } else</a>
<a name="ln4421">    if ( cur_INChI[k] &amp;&amp; cur_INChI[k]-&gt;nErrorCode ) {</a>
<a name="ln4422">        ret = cur_INChI[k]-&gt;nErrorCode;</a>
<a name="ln4423">    } else</a>
<a name="ln4424">    if ( cur_INChI_Aux[k] &amp;&amp; cur_INChI_Aux[k]-&gt;nErrorCode ) {</a>
<a name="ln4425">        ret = cur_INChI_Aux[k]-&gt;nErrorCode;</a>
<a name="ln4426">    } else {</a>
<a name="ln4427">        ret = 0;</a>
<a name="ln4428">    }</a>
<a name="ln4429"> </a>
<a name="ln4430">    /* fill out the output */</a>
<a name="ln4431"> </a>
<a name="ln4432">    if ( !ret ) {</a>
<a name="ln4433">        int bMobileH = pStruct-&gt;bMobileH;</a>
<a name="ln4434">        if ( bMobileH == TAUT_NON &amp;&amp;</a>
<a name="ln4435">             0 == cur_INChI[TAUT_NON]-&gt;nNumberOfAtoms &amp;&amp;</a>
<a name="ln4436">             0 &lt;  cur_INChI[TAUT_YES]-&gt;nNumberOfAtoms ) {</a>
<a name="ln4437">            /* tautomerism or H(+) removal/addition was not discovered */</a>
<a name="ln4438">            bMobileH = TAUT_YES;</a>
<a name="ln4439">        }</a>
<a name="ln4440">        pStruct-&gt;nChargeRevrs = cur_INChI[TAUT_YES]-&gt;nTotalCharge;</a>
<a name="ln4441"> </a>
<a name="ln4442">        pStruct-&gt;pOneINChI[0]       = cur_INChI[bMobileH];</a>
<a name="ln4443">        pStruct-&gt;pOneINChI_Aux[0]   = cur_INChI_Aux[bMobileH];</a>
<a name="ln4444">        pStruct-&gt;nOneINChI_bMobileH = bMobileH;</a>
<a name="ln4445">        cur_INChI[bMobileH]         = NULL;  /* remove pointer to avoid deallocation at exit_function */</a>
<a name="ln4446">        cur_INChI_Aux[bMobileH]     = NULL;  /* remove pointer to avoid deallocation at exit_function */</a>
<a name="ln4447"> </a>
<a name="ln4448">        pStruct-&gt;nNumRemovedProtons = (pStruct-&gt;iMobileH == TAUT_YES)? pStruct-&gt;One_ti.tni.nNumRemovedProtons : 0;</a>
<a name="ln4449"> </a>
<a name="ln4450"> </a>
<a name="ln4451">        /* set correct t-group numbers to endpoints */</a>
<a name="ln4452">        t_group_info       = &amp;pStruct-&gt;One_ti;</a>
<a name="ln4453">        if ( t_group_info-&gt;num_t_groups &amp;&amp; t_group_info-&gt;t_group &amp;&amp; t_group_info-&gt;nEndpointAtomNumber ) {</a>
<a name="ln4454">            inp_ATOM     *at_norm      = inp_norm_data[TAUT_YES]-&gt;at;</a>
<a name="ln4455">            int          num_at_norm   = inp_norm_data[TAUT_YES]-&gt;num_at;</a>
<a name="ln4456">            for ( i = 0; i &lt; num_at_norm; i ++ ) {</a>
<a name="ln4457">                at_norm[i].endpoint = 0;</a>
<a name="ln4458">            }</a>
<a name="ln4459">            for ( i = 0; i &lt; t_group_info-&gt;num_t_groups; i ++ ) {</a>
<a name="ln4460">                k = t_group_info-&gt;t_group[i].nFirstEndpointAtNoPos;</a>
<a name="ln4461">                /* add number of mobile (-) to the number of mobile H */</a>
<a name="ln4462">                t_group_info-&gt;t_group[i].num[0] += t_group_info-&gt;t_group[i].num[1];</a>
<a name="ln4463">                for ( j = 0; j &lt; t_group_info-&gt;t_group[i].nNumEndpoints; j ++, k ++ ) {</a>
<a name="ln4464">                    at_norm[t_group_info-&gt;nEndpointAtomNumber[k]].endpoint = t_group_info-&gt;t_group[i].nGroupNumber;</a>
<a name="ln4465">                }</a>
<a name="ln4466">            }</a>
<a name="ln4467">        }</a>
<a name="ln4468">        pStruct-&gt;pOne_norm_data[0] = (INP_ATOM_DATA *) inchi_malloc( sizeof(pStruct-&gt;pOne_norm_data[0][0]) );</a>
<a name="ln4469">        if ( pStruct-&gt;pOne_norm_data[0] ) {</a>
<a name="ln4470">            memcpy( pStruct-&gt;pOne_norm_data[0], inp_norm_data[bMobileH], sizeof(pStruct-&gt;pOne_norm_data[0][0]));</a>
<a name="ln4471">            memset( inp_norm_data[bMobileH], 0, sizeof(*inp_norm_data[0]) );</a>
<a name="ln4472">        } else {</a>
<a name="ln4473">            ret = RI_ERR_ALLOC;</a>
<a name="ln4474">        }</a>
<a name="ln4475">        if ( bMobileH == TAUT_NON &amp;&amp; cur_INChI[TAUT_YES]-&gt;nNumberOfAtoms &gt; 0 ) {</a>
<a name="ln4476">            int bMobileHalt = ALT_TAUT(bMobileH); /* = TAUT_YES */</a>
<a name="ln4477">            pStruct-&gt;pOneINChI[1]       = cur_INChI[bMobileHalt];</a>
<a name="ln4478">            pStruct-&gt;pOneINChI_Aux[1]   = cur_INChI_Aux[bMobileHalt];</a>
<a name="ln4479">            cur_INChI[bMobileHalt]         = NULL;</a>
<a name="ln4480">            cur_INChI_Aux[bMobileHalt]     = NULL;</a>
<a name="ln4481">            pStruct-&gt;pOne_norm_data[1] = (INP_ATOM_DATA *) inchi_malloc( sizeof(pStruct-&gt;pOne_norm_data[0][0]) );</a>
<a name="ln4482">            if ( pStruct-&gt;pOne_norm_data[1] ) {</a>
<a name="ln4483">                memcpy( pStruct-&gt;pOne_norm_data[1], inp_norm_data[bMobileHalt], sizeof(pStruct-&gt;pOne_norm_data[0][0]));</a>
<a name="ln4484">                memset( inp_norm_data[bMobileHalt], 0, sizeof(*inp_norm_data[0]) );</a>
<a name="ln4485">            } else {</a>
<a name="ln4486">                ret = RI_ERR_ALLOC;</a>
<a name="ln4487">            }</a>
<a name="ln4488">        }</a>
<a name="ln4489">    } else {</a>
<a name="ln4490">#if ( bRELEASE_VERSION != 1 )</a>
<a name="ln4491">#ifndef TARGET_API_LIB</a>
<a name="ln4492">        fprintf( stdout, &quot;ERROR: Create_INChI returned %d\n&quot;, ret );</a>
<a name="ln4493">#endif</a>
<a name="ln4494">#endif</a>
<a name="ln4495">    }</a>
<a name="ln4496"> </a>
<a name="ln4497">exit_function:</a>
<a name="ln4498">    /* deallocate unused */</a>
<a name="ln4499">    for ( k = 0; k &lt; TAUT_NUM; k ++ ) {</a>
<a name="ln4500">        Free_INChI( &amp;cur_INChI[k] );</a>
<a name="ln4501">        Free_INChI_Aux( &amp;cur_INChI_Aux[k] );</a>
<a name="ln4502">        FreeInpAtomData( inp_norm_data[k] );</a>
<a name="ln4503">    }</a>
<a name="ln4504">    sd-&gt;ulStructTime = ulStructTime;</a>
<a name="ln4505"> </a>
<a name="ln4506">    return ret;</a>
<a name="ln4507">}</a>
<a name="ln4508"> </a>
<a name="ln4509">/******************************************************************************************************</a>
<a name="ln4510">Input: </a>
<a name="ln4511">       at[].num_H       = total number of all terminal H connected to the atom</a>
<a name="ln4512">       at[].num_iso_H[] = numbers of isotopic H among at[].num_H</a>
<a name="ln4513">       Explicit H are disconnected</a>
<a name="ln4514">       Calculate InChI with normalization only in MakeOneInChIOutOfStrFromINChI()</a>
<a name="ln4515">       with (TG_FLAG_H_ALREADY_REMOVED &amp; bTautFlags) != 0</a>
<a name="ln4516">Output:</a>
<a name="ln4517">       at[].num_H       = number of implicit non-isotopic H connected to the atom</a>
<a name="ln4518">       at[].num_iso_H[] = numbers of implicit isotopic H (not included in at[].num_H)</a>
<a name="ln4519">       Explicit H are connected</a>
<a name="ln4520">       Calculate InChI with full preprocessing MakeInChIOutOfStrFromINChI2()</a>
<a name="ln4521">       with (TG_FLAG_H_ALREADY_REMOVED &amp; bTautFlags) == 0</a>
<a name="ln4522">*******************************************************************************************************/</a>
<a name="ln4523">int ConnectDisconnectedH( inp_ATOM *at, int num_atoms, int num_deleted_H )</a>
<a name="ln4524">{</a>
<a name="ln4525">    int i, j, k, n, m, num_H;</a>
<a name="ln4526">    int tot_atoms = num_atoms + num_deleted_H;</a>
<a name="ln4527">    </a>
<a name="ln4528">    for ( i = num_atoms; i &lt; tot_atoms; i = j ) {</a>
<a name="ln4529">        k = at[i].neighbor[0]; /* a[k] is the atom connected to the explicit hydrogen at[i] */</a>
<a name="ln4530">        for ( j = i; j &lt; tot_atoms &amp;&amp; at[j].neighbor[0] == k; j ++ )</a>
<a name="ln4531">            ;</a>
<a name="ln4532">        num_H = j-i; /* number of explicit H for at[k] */</a>
<a name="ln4533">        if ( num_H &gt; at[k].num_H ) {</a>
<a name="ln4534">            return RI_ERR_PROGR;</a>
<a name="ln4535">        }</a>
<a name="ln4536">        if ( num_H + at[k].valence &gt; MAXVAL ) {</a>
<a name="ln4537">            return RI_ERR_SYNTAX;</a>
<a name="ln4538">        }</a>
<a name="ln4539">        /* insert links to explicit H before all other links in the connection list */</a>
<a name="ln4540">        n = at[k].valence;</a>
<a name="ln4541">        memmove( at[k].neighbor   +num_H, at[k].neighbor,    sizeof(at[k].neighbor[0]) * n );</a>
<a name="ln4542">        memmove( at[k].bond_stereo+num_H, at[k].bond_stereo, sizeof(at[k].bond_stereo[0]) * n );</a>
<a name="ln4543">        memmove( at[k].bond_type  +num_H, at[k].bond_type   , sizeof(at[k].bond_type[0]) * n );</a>
<a name="ln4544">        for ( n = 0; n &lt; num_H; n ++ ) {</a>
<a name="ln4545">            at[k].neighbor[n]    = i + n;</a>
<a name="ln4546">            at[k].bond_stereo[n] = 0;</a>
<a name="ln4547">            at[k].bond_type[n]   = BOND_TYPE_SINGLE;</a>
<a name="ln4548">        }</a>
<a name="ln4549">        for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[k].sb_parity[m]; m ++ ) {</a>
<a name="ln4550">            at[k].sb_ord[m] += num_H;</a>
<a name="ln4551">            if ( at[k].sn_ord[m] &lt; 0 ) {</a>
<a name="ln4552">                for ( n = i; n &lt; j; n ++ ) {</a>
<a name="ln4553">                    if ( at[n].orig_at_number == at[k].sn_orig_at_num[m] ) {</a>
<a name="ln4554">                        at[k].sn_ord[m] = n-i;</a>
<a name="ln4555">                        break;</a>
<a name="ln4556">                    }</a>
<a name="ln4557">                }</a>
<a name="ln4558">                if ( n == j ) {</a>
<a name="ln4559">                    return RI_ERR_PROGR;</a>
<a name="ln4560">                }</a>
<a name="ln4561">            } else {</a>
<a name="ln4562">                at[k].sn_ord[m] += num_H;</a>
<a name="ln4563">            }</a>
<a name="ln4564">        }</a>
<a name="ln4565">        at[k].valence            += num_H;</a>
<a name="ln4566">        at[k].chem_bonds_valence += num_H;</a>
<a name="ln4567">        at[k].num_H -= num_H; /* cannot be negative */</a>
<a name="ln4568">        /*memset( at[k].num_iso_H, 0, sizeof(at[0].num_iso_H) );*/ /* attached H must carry all isotopic shifts */</a>
<a name="ln4569">        for ( n = i; n &lt; j; n ++ ) {</a>
<a name="ln4570">            at[n].chem_bonds_valence = BOND_TYPE_SINGLE;</a>
<a name="ln4571">        }</a>
<a name="ln4572">        /* isotopic H */</a>
<a name="ln4573">        for ( m = j-1; i &lt;= m &amp;&amp; at[m].iso_atw_diff &gt; 0 ; m -- ) {</a>
<a name="ln4574">            if ( at[m].iso_atw_diff &gt; NUM_H_ISOTOPES ) {</a>
<a name="ln4575">                return RI_ERR_PROGR;</a>
<a name="ln4576">            }</a>
<a name="ln4577">            if ( 0 &gt;= at[k].num_iso_H[(int)at[m].iso_atw_diff-1] -- ) {</a>
<a name="ln4578">                return RI_ERR_PROGR;</a>
<a name="ln4579">            }</a>
<a name="ln4580">        }</a>
<a name="ln4581"> </a>
<a name="ln4582">    }</a>
<a name="ln4583">    /* subtract isotopic H */</a>
<a name="ln4584">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4585">        for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln4586">            at[i].num_H -= at[i].num_iso_H[m];</a>
<a name="ln4587">        }</a>
<a name="ln4588">        if ( 0 &gt; at[i].num_H ) {</a>
<a name="ln4589">            return RI_ERR_PROGR;</a>
<a name="ln4590">        }</a>
<a name="ln4591">    }</a>
<a name="ln4592"> </a>
<a name="ln4593">    return tot_atoms;</a>
<a name="ln4594">}</a>
<a name="ln4595">/******************************************************************************************************</a>
<a name="ln4596">Input:</a>
<a name="ln4597">       at[].num_H       = number of implicit non-isotopic H connected to the atom</a>
<a name="ln4598">       at[].num_iso_H[] = numbers of implicit isotopic H (not included in at[].num_H)</a>
<a name="ln4599">       Explicit H are connected</a>
<a name="ln4600">       Calculate InChI with (TG_FLAG_H_ALREADY_REMOVED &amp; bTautFlags) == 0</a>
<a name="ln4601">Output:</a>
<a name="ln4602">       at[].num_H       = total number of all terminal H connected to the atom</a>
<a name="ln4603">       at[].num_iso_H[] = numbers of isotopic H among at[].num_H</a>
<a name="ln4604">       Explicit H are disconnected</a>
<a name="ln4605">       Calculate InChI with (TG_FLAG_H_ALREADY_REMOVED &amp; bTautFlags) != 0</a>
<a name="ln4606">*******************************************************************************************************/</a>
<a name="ln4607">int DisconnectedConnectedH( inp_ATOM *at, int num_atoms, int num_deleted_H )</a>
<a name="ln4608">{</a>
<a name="ln4609">    int i, j, k, n, m, num_H, num_iso_H;</a>
<a name="ln4610">    int tot_atoms = num_atoms + num_deleted_H;</a>
<a name="ln4611">    </a>
<a name="ln4612">    /* add implicit isotopic H to total implicit H */</a>
<a name="ln4613">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln4614">        for ( m = 0; m &lt; NUM_H_ISOTOPES; m ++ ) {</a>
<a name="ln4615">            at[i].num_H += at[i].num_iso_H[m];</a>
<a name="ln4616">        }</a>
<a name="ln4617">    }</a>
<a name="ln4618">    for ( i = num_atoms; i &lt; tot_atoms; i = j ) {</a>
<a name="ln4619">        k = at[i].neighbor[0]; /* a[k] is the atom connected to the explicit hydrogen at[i] */</a>
<a name="ln4620">        for ( j = i; j &lt; tot_atoms &amp;&amp; at[j].neighbor[0] == k; j ++ ) {</a>
<a name="ln4621">            at[j].chem_bonds_valence = 0;</a>
<a name="ln4622">        }</a>
<a name="ln4623">        num_H = j-i; /* number of explicit H for at[k] */</a>
<a name="ln4624">        /* verify correct number of explicit H */</a>
<a name="ln4625">        for ( n = 0; n &lt; at[k].valence &amp;&amp; at[k].neighbor[n] &gt;= num_atoms; n ++ )</a>
<a name="ln4626">            ;</a>
<a name="ln4627">        if ( n != num_H ) {</a>
<a name="ln4628">            return RI_ERR_PROGR;</a>
<a name="ln4629">        }</a>
<a name="ln4630">        /* remove bonds to explicit H located in front of all other bonds in the connection list */</a>
<a name="ln4631">        n = (at[k].valence -= num_H); /* new number of bonds */</a>
<a name="ln4632">        at[k].chem_bonds_valence -= num_H; /* new no-H valence */</a>
<a name="ln4633">        if ( n ) {</a>
<a name="ln4634">            memmove( at[k].neighbor,    at[k].neighbor    + num_H, sizeof(at[k].neighbor[0]) * n );</a>
<a name="ln4635">            memmove( at[k].bond_stereo, at[k].bond_stereo + num_H, sizeof(at[k].bond_stereo[0]) * n );</a>
<a name="ln4636">            memmove( at[k].bond_type,   at[k].bond_type   + num_H, sizeof(at[k].bond_type[0]) * n );</a>
<a name="ln4637">        }</a>
<a name="ln4638">        /* clear the 'tails' */</a>
<a name="ln4639">        memset( at[k].neighbor+n,    0, sizeof(at[k].neighbor[0]) * num_H );</a>
<a name="ln4640">        memset( at[k].bond_stereo+n, 0, sizeof(at[k].bond_stereo[0]) * num_H );</a>
<a name="ln4641">        memset( at[k].bond_type+n,   0, sizeof(at[k].bond_type[0]) * num_H );</a>
<a name="ln4642"> </a>
<a name="ln4643">        for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[k].sb_parity[m]; m ++ ) {</a>
<a name="ln4644">            at[k].sb_ord[m] -= num_H;</a>
<a name="ln4645">            if ( 0 &lt;= at[k].sn_ord[m] &amp;&amp; at[k].sn_ord[m] &lt; num_H ) {</a>
<a name="ln4646">                at[k].sn_ord[m] = -1; /* disconnected explicit H */</a>
<a name="ln4647">            }</a>
<a name="ln4648">        }</a>
<a name="ln4649">        /* add explicit isotopic H (already included in num_H) */</a>
<a name="ln4650">        for ( num_iso_H = 0, m = j-1; i &lt;= m &amp;&amp; at[m].iso_atw_diff &gt; 0 ; m -- ) {</a>
<a name="ln4651">            if ( at[m].iso_atw_diff &gt; NUM_H_ISOTOPES ) {</a>
<a name="ln4652">                return RI_ERR_PROGR;</a>
<a name="ln4653">            }</a>
<a name="ln4654">            at[k].num_iso_H[(int)at[m].iso_atw_diff-1] ++;</a>
<a name="ln4655">        }</a>
<a name="ln4656">        at[k].num_H += num_H; /* add all explicit H including isotopic */</a>
<a name="ln4657">    }</a>
<a name="ln4658">    return tot_atoms;</a>
<a name="ln4659">}</a>
<a name="ln4660">/******************************************************************************************************/</a>
<a name="ln4661">int MakeInChIOutOfStrFromINChI2( ICHICONST INPUT_PARMS *ip_inp, STRUCT_DATA *sd_inp, StrFromINChI *pStruct,</a>
<a name="ln4662">                                 int iComponent, int iAtNoOffset, long num_inp )</a>
<a name="ln4663">{</a>
<a name="ln4664">    char szTitle[MAX_SDF_HEADER+MAX_SDF_VALUE+256];</a>
<a name="ln4665"> </a>
<a name="ln4666">    int   len, ret;</a>
<a name="ln4667">    /*</a>
<a name="ln4668">    PINChI2     *pINChI[INCHI_NUM];</a>
<a name="ln4669">    PINChI_Aux2 *pINChI_Aux[INCHI_NUM];</a>
<a name="ln4670">    */</a>
<a name="ln4671">    char        pStr[256];</a>
<a name="ln4672">    INPUT_PARMS local_ip;</a>
<a name="ln4673">    STRUCT_DATA local_sd;</a>
<a name="ln4674">    INPUT_PARMS *ip = &amp;local_ip;</a>
<a name="ln4675">    STRUCT_DATA *sd = &amp;local_sd;</a>
<a name="ln4676">    </a>
<a name="ln4677">    ORIG_ATOM_DATA OrigAtData; /* 0=&gt; disconnected, 1=&gt; original */</a>
<a name="ln4678">    ORIG_ATOM_DATA *orig_inp_data = &amp;OrigAtData;</a>
<a name="ln4679">    ORIG_ATOM_DATA PrepAtData[2]; /* 0=&gt; disconnected, 1=&gt; original */</a>
<a name="ln4680">    ORIG_ATOM_DATA *prep_inp_data = PrepAtData;</a>
<a name="ln4681">    </a>
<a name="ln4682">    *ip = *ip_inp;</a>
<a name="ln4683">    ip-&gt;bDisplay = 0;</a>
<a name="ln4684">    ip-&gt;bDisplayCompositeResults = 0;</a>
<a name="ln4685">    ip-&gt;bDisplayEachComponentINChI = 0;</a>
<a name="ln4686">    ip-&gt;bDisplayIfRestoreWarnings  = 0;</a>
<a name="ln4687">    ip-&gt;bINChIOutputOptions = INCHI_OUT_NO_AUX_INFO;</a>
<a name="ln4688">    /*</a>
<a name="ln4689">    if ( pStruct-&gt;bMobileH ) {</a>
<a name="ln4690">        ip-&gt;nMode &amp;= ~REQ_MODE_BASIC;</a>
<a name="ln4691">        ip-&gt;nMode |= REQ_MODE_TAUT;</a>
<a name="ln4692">    } else {</a>
<a name="ln4693">        ip-&gt;nMode |= (REQ_MODE_TAUT | REQ_MODE_BASIC);</a>
<a name="ln4694">    }</a>
<a name="ln4695">    */</a>
<a name="ln4696">    memset( sd, 0, sizeof(*sd) );</a>
<a name="ln4697">    sd-&gt;fPtrStart = -1;</a>
<a name="ln4698">    sd-&gt;fPtrEnd = -1;</a>
<a name="ln4699">    /*</a>
<a name="ln4700">    if ( ip-&gt;nMode &amp; REQ_MODE_STEREO ) {</a>
<a name="ln4701">        if ( ip-&gt;nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO) ) {</a>
<a name="ln4702">            sd-&gt;bChiralFlag |= FLAG_INP_AT_NONCHIRAL;</a>
<a name="ln4703">        } else {</a>
<a name="ln4704">            sd-&gt;bChiralFlag |= FLAG_INP_AT_CHIRAL;</a>
<a name="ln4705">        }</a>
<a name="ln4706">    }</a>
<a name="ln4707">    */</a>
<a name="ln4708">    memset( orig_inp_data     , 0,   sizeof( *orig_inp_data  ) );</a>
<a name="ln4709">    memset( prep_inp_data     , 0, 2*sizeof( *prep_inp_data  ) );</a>
<a name="ln4710">    memset( pStruct-&gt;RevInChI.pINChI,     0, sizeof(pStruct-&gt;RevInChI.pINChI    ) );</a>
<a name="ln4711">    memset( pStruct-&gt;RevInChI.pINChI_Aux, 0, sizeof(pStruct-&gt;RevInChI.pINChI_Aux) );</a>
<a name="ln4712">    memset( pStr, 0, sizeof(pStr) );</a>
<a name="ln4713">    memset( szTitle, 0, sizeof(szTitle) );</a>
<a name="ln4714">    </a>
<a name="ln4715">    len = sizeof(orig_inp_data-&gt;at[0])*(pStruct-&gt;num_atoms + pStruct-&gt;num_deleted_H);</a>
<a name="ln4716">    orig_inp_data-&gt;at = (inp_ATOM *) inchi_malloc( len );</a>
<a name="ln4717">    if ( orig_inp_data-&gt;at ) {</a>
<a name="ln4718">        /*memcpy( orig_inp_data-&gt;at, pStruct-&gt;at2, len );*/</a>
<a name="ln4719">        /*ret = ConnectDisconnectedH( orig_inp_data-&gt;at, pStruct-&gt;num_atoms, pStruct-&gt;num_deleted_H );*/</a>
<a name="ln4720">        CopySt2At( pStruct-&gt;at2, pStruct-&gt;st, pStruct-&gt;num_atoms );</a>
<a name="ln4721">        ret = ConnectDisconnectedH( pStruct-&gt;at2, pStruct-&gt;num_atoms, pStruct-&gt;num_deleted_H );</a>
<a name="ln4722">        if ( ret &lt; 0 ) {</a>
<a name="ln4723">            goto exit_error;</a>
<a name="ln4724">        }</a>
<a name="ln4725">        orig_inp_data-&gt;num_inp_atoms = ret;</a>
<a name="ln4726">        /* connections changed =&gt; reconcile parities even if they were reconciled before */</a>
<a name="ln4727">        /* remove t-group markings and increment zero-order bonds,</a>
<a name="ln4728">           otherwise MakeInChIOutOfStrFromINChI2() woild fail */</a>
<a name="ln4729">        /*</a>
<a name="ln4730">        IncrZeroBondsAndClearEndpts(pStruct-&gt;at2, pStruct-&gt;num_atoms, iComponent+1);</a>
<a name="ln4731">        */</a>
<a name="ln4732">        IncrZeroBonds(pStruct-&gt;at2, pStruct-&gt;num_atoms, iComponent+1);</a>
<a name="ln4733">        </a>
<a name="ln4734">        /* CopySt2At() moved to the position before ConnectDisconnectedH() because </a>
<a name="ln4735">           in case stereo exists only in Mobile-H layer and the processd here</a>
<a name="ln4736">           component is restored in Fixed-H layer the parities needed by</a>
<a name="ln4737">           ConnectDisconnectedH() must be there before calling</a>
<a name="ln4738">           ConnectDisconnectedH()</a>
<a name="ln4739">        */</a>
<a name="ln4740">        /*CopySt2At( pStruct-&gt;at2, pStruct-&gt;st, pStruct-&gt;num_atoms );*/</a>
<a name="ln4741"> </a>
<a name="ln4742">        ret = ReconcileAllCmlBondParities( pStruct-&gt;at2, orig_inp_data-&gt;num_inp_atoms, 0 );</a>
<a name="ln4743">        if ( ret &lt; 0 ) {</a>
<a name="ln4744">            goto exit_error;</a>
<a name="ln4745">        }</a>
<a name="ln4746">        memcpy( orig_inp_data-&gt;at, pStruct-&gt;at2, len );</a>
<a name="ln4747">        ClearEndpts(orig_inp_data-&gt;at, pStruct-&gt;num_atoms);</a>
<a name="ln4748">        if ( FixUnkn0DStereoBonds(orig_inp_data-&gt;at, pStruct-&gt;num_atoms) ) {</a>
<a name="ln4749">            ret = ReconcileAllCmlBondParities( pStruct-&gt;at2, orig_inp_data-&gt;num_inp_atoms, 0 );</a>
<a name="ln4750">            if ( ret &lt; 0 ) {</a>
<a name="ln4751">                goto exit_error;</a>
<a name="ln4752">            }</a>
<a name="ln4753">        }</a>
<a name="ln4754">        /* keep endpoint[] markings in at2[] for subsequent add/remove protons */</a>
<a name="ln4755">    } else {</a>
<a name="ln4756">        ret = RI_ERR_ALLOC;</a>
<a name="ln4757">        goto exit_error;</a>
<a name="ln4758">    }</a>
<a name="ln4759">    memset( sd-&gt;num_components, 0, sizeof(sd-&gt;num_components) );</a>
<a name="ln4760">    memset( sd-&gt;num_taut, 0, sizeof(sd-&gt;num_taut) );</a>
<a name="ln4761">    memset( sd-&gt;num_non_taut, 0, sizeof(sd-&gt;num_non_taut) );</a>
<a name="ln4762">    memset( sd-&gt;bTautFlagsDone, 0, sizeof(sd-&gt;bTautFlagsDone) );</a>
<a name="ln4763">    memset( sd-&gt;bTautFlags, 0, sizeof(sd-&gt;bTautFlags) );</a>
<a name="ln4764"> </a>
<a name="ln4765">    ret = ProcessOneStructure( sd, ip, szTitle, pStruct-&gt;RevInChI.pINChI, pStruct-&gt;RevInChI.pINChI_Aux,</a>
<a name="ln4766">                             NULL /*inp_file*/, NULL /*log_file*/, NULL /*output_file*/, NULL /*prb_file*/,</a>
<a name="ln4767">                             orig_inp_data, prep_inp_data,</a>
<a name="ln4768">                             num_inp, pStr, sizeof(pStr), </a>
<a name="ln4769">                             0 /* save_opt_bits */);</a>
<a name="ln4770"> </a>
<a name="ln4771">    memcpy(pStruct-&gt;RevInChI.num_components, sd-&gt;num_components, sizeof(pStruct-&gt;RevInChI.num_components) );</a>
<a name="ln4772">    memcpy(sd_inp-&gt;pStrErrStruct, sd-&gt;pStrErrStruct, sizeof(sd_inp-&gt;pStrErrStruct) );</a>
<a name="ln4773">    pStruct-&gt;RevInChI.nRetVal = ret;</a>
<a name="ln4774">    /* translate returned value */</a>
<a name="ln4775">    if ( ret == _IS_ERROR || ret == _IS_FATAL || ret == _IS_UNKNOWN ) {</a>
<a name="ln4776">        ret = RI_ERR_PROGR;</a>
<a name="ln4777">    } else</a>
<a name="ln4778">    if ( ret == _IS_OKAY ) {</a>
<a name="ln4779">        ret = 0;</a>
<a name="ln4780">    } else</a>
<a name="ln4781">    if ( ret == _IS_WARNING ) {</a>
<a name="ln4782">        ret = 1;</a>
<a name="ln4783">    } else {</a>
<a name="ln4784">        ret = RI_ERR_PROGR;</a>
<a name="ln4785">    }</a>
<a name="ln4786">    /* save total charge from Mobile-H layer */</a>
<a name="ln4787">    pStruct-&gt;nChargeRevrs = 0;</a>
<a name="ln4788">    if ( ret &gt;= 0 ) {</a>
<a name="ln4789">        if ( bRevInchiComponentExists( pStruct, INCHI_REC, TAUT_YES, 0 ) ) {</a>
<a name="ln4790">            pStruct-&gt;nChargeRevrs = pStruct-&gt;RevInChI.pINChI[INCHI_REC][0][TAUT_YES]-&gt;nTotalCharge;</a>
<a name="ln4791">        } else</a>
<a name="ln4792">        if ( bRevInchiComponentExists( pStruct, INCHI_BAS, TAUT_YES, 0 ) ) {</a>
<a name="ln4793">            pStruct-&gt;nChargeRevrs = pStruct-&gt;RevInChI.pINChI[INCHI_BAS][0][TAUT_YES]-&gt;nTotalCharge;</a>
<a name="ln4794">        }</a>
<a name="ln4795">    }</a>
<a name="ln4796">    </a>
<a name="ln4797">    /* free structure data */</a>
<a name="ln4798">    FreeOrigAtData( orig_inp_data );</a>
<a name="ln4799">    FreeOrigAtData( prep_inp_data );</a>
<a name="ln4800">    FreeOrigAtData( prep_inp_data+1 );</a>
<a name="ln4801"> </a>
<a name="ln4802">exit_error:</a>
<a name="ln4803">    return ret;</a>
<a name="ln4804">}</a>
<a name="ln4805">/******************************************************************************************************/</a>
<a name="ln4806">int OutputInChIOutOfStrFromINChI(ICHICONST INPUT_PARMS *ip_inp, STRUCT_DATA *sd_inp, </a>
<a name="ln4807">                                 long num_inp, int bINChIOutputOptions,</a>
<a name="ln4808">                                 INCHI_IOSTREAM *pout, INCHI_IOSTREAM *plog, </a>
<a name="ln4809">                                 InpInChI *pOneInput, int bHasSomeFixedH,</a>
<a name="ln4810">                                 unsigned char save_opt_bits)</a>
<a name="ln4811">{</a>
<a name="ln4812">    char szTitle[MAX_SDF_HEADER+MAX_SDF_VALUE+256];</a>
<a name="ln4813"> </a>
<a name="ln4814">    int   len, ret;</a>
<a name="ln4815">/*    </a>
<a name="ln4816">    PINChI2     *pINChI[INCHI_NUM];</a>
<a name="ln4817">    PINChI_Aux2 *pINChI_Aux[INCHI_NUM];</a>
<a name="ln4818">*/    </a>
<a name="ln4819">    REV_INCHI   RevInChI;</a>
<a name="ln4820">    int nStrLen = INCHI_SEGM_BUFLEN;</a>
<a name="ln4821">    char *pStr  = NULL;</a>
<a name="ln4822"> </a>
<a name="ln4823">    INPUT_PARMS local_ip;</a>
<a name="ln4824">    STRUCT_DATA local_sd;</a>
<a name="ln4825">    INPUT_PARMS *ip = &amp;local_ip;</a>
<a name="ln4826">    STRUCT_DATA *sd = &amp;local_sd;</a>
<a name="ln4827">    </a>
<a name="ln4828">    ORIG_ATOM_DATA OrigAtData; /* 0=&gt; disconnected, 1=&gt; original */</a>
<a name="ln4829">    ORIG_ATOM_DATA *orig_inp_data = &amp;OrigAtData;</a>
<a name="ln4830">    ORIG_ATOM_DATA PrepAtData[2]; /* 0=&gt; disconnected, 1=&gt; original */</a>
<a name="ln4831">    ORIG_ATOM_DATA *prep_inp_data = PrepAtData;</a>
<a name="ln4832">    </a>
<a name="ln4833">    *ip = *ip_inp;</a>
<a name="ln4834">    ip-&gt;bNoStructLabels = 1;</a>
<a name="ln4835">    ip-&gt;bDisplay = 0;</a>
<a name="ln4836">    ip-&gt;bDisplayCompositeResults = 0;</a>
<a name="ln4837">    ip-&gt;bDisplayEachComponentINChI = 0;</a>
<a name="ln4838">    ip-&gt;bDisplayIfRestoreWarnings  = 0;</a>
<a name="ln4839">#if ( I2S_MODIFY_OUTPUT == 1 )</a>
<a name="ln4840">    if ( bINChIOutputOptions &amp; INCHI_OUT_SDFILE_ONLY )</a>
<a name="ln4841">        ip-&gt;bINChIOutputOptions = bINChIOutputOptions &amp; ~(INCHI_OUT_PLAIN_TEXT | INCHI_OUT_XML | INCHI_OUT_PLAIN_TEXT_COMMENTS | INCHI_OUT_XML_TEXT_COMMENTS);</a>
<a name="ln4842">    else</a>
<a name="ln4843">    if ( bINChIOutputOptions &amp; INCHI_OUT_XML )</a>
<a name="ln4844">        ip-&gt;bINChIOutputOptions = bINChIOutputOptions &amp; ~(INCHI_OUT_PLAIN_TEXT | INCHI_OUT_SDFILE_ONLY) | INCHI_OUT_EMBED_REC;</a>
<a name="ln4845">    else</a>
<a name="ln4846">    if ( bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT )</a>
<a name="ln4847">        ip-&gt;bINChIOutputOptions = bINChIOutputOptions &amp; ~(INCHI_OUT_XML | INCHI_OUT_SDFILE_ONLY) | INCHI_OUT_EMBED_REC;</a>
<a name="ln4848">    else</a>
<a name="ln4849">    if ( bINChIOutputOptions &amp; (INCHI_OUT_NO_AUX_INFO | INCHI_OUT_SHORT_AUX_INFO | INCHI_OUT_ONLY_AUX_INFO | INCHI_OUT_TABBED_OUTPUT))</a>
<a name="ln4850">        ip-&gt;bINChIOutputOptions = (INCHI_OUT_PLAIN_TEXT | INCHI_OUT_EMBED_REC | bINChIOutputOptions);</a>
<a name="ln4851">    else</a>
<a name="ln4852">        ip-&gt;bINChIOutputOptions = (INCHI_OUT_PLAIN_TEXT | INCHI_OUT_EMBED_REC);</a>
<a name="ln4853">#else</a>
<a name="ln4854">    ip-&gt;bINChIOutputOptions = (INCHI_OUT_PLAIN_TEXT | INCHI_OUT_EMBED_REC );</a>
<a name="ln4855">#endif</a>
<a name="ln4856"> </a>
<a name="ln4857">    if ( bHasSomeFixedH ) </a>
<a name="ln4858">    {</a>
<a name="ln4859">        ip-&gt;nMode |= (REQ_MODE_TAUT | REQ_MODE_BASIC);</a>
<a name="ln4860">    } else </a>
<a name="ln4861">    {</a>
<a name="ln4862">        ip-&gt;nMode &amp;= ~REQ_MODE_BASIC;</a>
<a name="ln4863">        ip-&gt;nMode |= REQ_MODE_TAUT;</a>
<a name="ln4864">    }</a>
<a name="ln4865"> </a>
<a name="ln4866">    memset( sd, 0, sizeof(*sd) );</a>
<a name="ln4867">    sd-&gt;fPtrStart = -1;</a>
<a name="ln4868">    sd-&gt;fPtrEnd = -1;</a>
<a name="ln4869">    /*</a>
<a name="ln4870">    if ( ip-&gt;nMode &amp; REQ_MODE_STEREO ) {</a>
<a name="ln4871">        if ( ip-&gt;nMode &amp; (REQ_MODE_RELATIVE_STEREO | REQ_MODE_RACEMIC_STEREO) ) {</a>
<a name="ln4872">            sd-&gt;bChiralFlag |= FLAG_INP_AT_NONCHIRAL;</a>
<a name="ln4873">        } else {</a>
<a name="ln4874">            sd-&gt;bChiralFlag |= FLAG_INP_AT_CHIRAL;</a>
<a name="ln4875">        }</a>
<a name="ln4876">    }</a>
<a name="ln4877">    */</a>
<a name="ln4878">    memset( orig_inp_data,       0,   sizeof( *orig_inp_data  ) );</a>
<a name="ln4879">    memset( prep_inp_data,       0, 2*sizeof( *prep_inp_data  ) );</a>
<a name="ln4880">    memset( RevInChI.pINChI,     0, sizeof(RevInChI.pINChI    ) );</a>
<a name="ln4881">    memset( RevInChI.pINChI_Aux, 0, sizeof(RevInChI.pINChI_Aux) );</a>
<a name="ln4882">    </a>
<a name="ln4883">    len = sizeof(orig_inp_data-&gt;at[0]) * pOneInput-&gt;num_atoms;</a>
<a name="ln4884">    orig_inp_data-&gt;at = (inp_ATOM *) inchi_malloc( len );</a>
<a name="ln4885">    orig_inp_data-&gt;szCoord = (MOL_COORD *)inchi_calloc( pOneInput-&gt;num_atoms, sizeof(orig_inp_data-&gt;szCoord[0]));</a>
<a name="ln4886">    pStr  = (char *)inchi_calloc( nStrLen, sizeof(char) );</a>
<a name="ln4887">    if ( orig_inp_data-&gt;at &amp;&amp; orig_inp_data-&gt;szCoord &amp;&amp; pStr ) {</a>
<a name="ln4888">        int i, k;</a>
<a name="ln4889">        memcpy( orig_inp_data-&gt;at, pOneInput-&gt;atom, len );</a>
<a name="ln4890">        orig_inp_data-&gt;num_inp_atoms = pOneInput-&gt;num_atoms;</a>
<a name="ln4891">        ClearEndpts( orig_inp_data-&gt;at, orig_inp_data-&gt;num_inp_atoms );</a>
<a name="ln4892">        /* otherwise fails on CID=450438 */</a>
<a name="ln4893">        if ( FixUnkn0DStereoBonds(orig_inp_data-&gt;at, orig_inp_data-&gt;num_inp_atoms) ) {</a>
<a name="ln4894">            ret = ReconcileAllCmlBondParities( orig_inp_data-&gt;at, orig_inp_data-&gt;num_inp_atoms, 0 );</a>
<a name="ln4895">            if ( ret &lt; 0 ) {</a>
<a name="ln4896">                goto exit_error;</a>
<a name="ln4897">            }</a>
<a name="ln4898">        }</a>
<a name="ln4899">        /* To obtain rA,rB,rC in AuxInfo we have to emulate input coordinates; make all of them zeroes */</a>
<a name="ln4900">        for ( i = 0; i &lt; pOneInput-&gt;num_atoms; i ++ ) {</a>
<a name="ln4901">            for ( k = 0; k &lt; NUM_COORD*LEN_COORD; k += LEN_COORD ) {</a>
<a name="ln4902">                orig_inp_data-&gt;szCoord[i][k] = '0';</a>
<a name="ln4903">            }</a>
<a name="ln4904">        }</a>
<a name="ln4905">    } else {</a>
<a name="ln4906">        ret = RI_ERR_ALLOC;</a>
<a name="ln4907">        goto exit_error;</a>
<a name="ln4908">    }</a>
<a name="ln4909">    memset( sd-&gt;num_components, 0, sizeof(sd-&gt;num_components) );</a>
<a name="ln4910">    memset( sd-&gt;num_taut, 0, sizeof(sd-&gt;num_taut) );</a>
<a name="ln4911">    memset( sd-&gt;num_non_taut, 0, sizeof(sd-&gt;num_non_taut) );</a>
<a name="ln4912">    memset( sd-&gt;bTautFlagsDone, 0, sizeof(sd-&gt;bTautFlagsDone) );</a>
<a name="ln4913">    memset( sd-&gt;bTautFlags, 0, sizeof(sd-&gt;bTautFlags) );</a>
<a name="ln4914">    memset( szTitle, 0, sizeof(szTitle) );</a>
<a name="ln4915"> </a>
<a name="ln4916">    ret = ProcessOneStructure(sd, ip, szTitle, RevInChI.pINChI, RevInChI.pINChI_Aux,</a>
<a name="ln4917">                             NULL /*inp_file*/, plog /*log_file*/, pout /*output_file*/, NULL /*prb_file*/,</a>
<a name="ln4918">                             orig_inp_data, prep_inp_data,</a>
<a name="ln4919">                             num_inp, pStr, nStrLen,</a>
<a name="ln4920">                             save_opt_bits);</a>
<a name="ln4921">    memcpy(RevInChI.num_components, sd-&gt;num_components, sizeof(RevInChI.num_components) );</a>
<a name="ln4922">    /*</a>
<a name="ln4923">    memcpy(sd_inp-&gt;pStrErrStruct, sd-&gt;pStrErrStruct, sizeof(sd_inp-&gt;pStrErrStruct) );</a>
<a name="ln4924">    */</a>
<a name="ln4925">    RevInChI.nRetVal = ret;</a>
<a name="ln4926">    /* translate returned value */</a>
<a name="ln4927">    if ( ret == _IS_ERROR || ret == _IS_FATAL || ret == _IS_UNKNOWN ) {</a>
<a name="ln4928">        ret = RI_ERR_PROGR;</a>
<a name="ln4929">    } else</a>
<a name="ln4930">    if ( ret == _IS_OKAY ) {</a>
<a name="ln4931">        ret = 0;</a>
<a name="ln4932">    } else</a>
<a name="ln4933">    if ( ret == _IS_WARNING ) {</a>
<a name="ln4934">        ret = 1;</a>
<a name="ln4935">    } else {</a>
<a name="ln4936">        ret = RI_ERR_PROGR;</a>
<a name="ln4937">    }</a>
<a name="ln4938">    </a>
<a name="ln4939">    /* free structure data */</a>
<a name="ln4940">    FreeOrigAtData( orig_inp_data );</a>
<a name="ln4941">    FreeOrigAtData( prep_inp_data );</a>
<a name="ln4942">    FreeOrigAtData( prep_inp_data+1 );</a>
<a name="ln4943">    FreeAllINChIArrays( RevInChI.pINChI,</a>
<a name="ln4944">                        RevInChI.pINChI_Aux,</a>
<a name="ln4945">                        RevInChI.num_components );</a>
<a name="ln4946"> </a>
<a name="ln4947"> </a>
<a name="ln4948">exit_error:</a>
<a name="ln4949">    if ( pStr ) inchi_free( pStr );</a>
<a name="ln4950">    return ret;</a>
<a name="ln4951">}</a>
<a name="ln4952">#endif</a>

</code></pre>
<div class="balloon" rel="1340"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pTCGroups->pTCG' pointer was utilized before it was verified against nullptr. Check lines: 1340, 1343.</p></div>
<div class="balloon" rel="1510"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: nMetal.</p></div>
<div class="balloon" rel="2451"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: C3 >= 0x3fff.</p></div>
<div class="balloon" rel="2451"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: F3 >= 0x3fff.</p></div>
<div class="balloon" rel="2470"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The '* pcur_num_vertices' variable was assigned the same value.</p></div>
<div class="balloon" rel="2736"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'e0X' is always true.</p></div>
<div class="balloon" rel="2737"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pvX' is always true.</p></div>
<div class="balloon" rel="2738"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'jX' is always true.</p></div>
<div class="balloon" rel="2739"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'iX' is always true.</p></div>
<div class="balloon" rel="2978"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !pv1.</p></div>
<div class="balloon" rel="3144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'k + n' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="3351"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'num_iedges' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 3326, 3351.</p></div>
<div class="balloon" rel="3667"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'nNumVisitedAtoms' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 3658, 3667.</p></div>
<div class="balloon" rel="4260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'pStruct->at' variable was assigned the same value.</p></div>
<div class="balloon" rel="4779"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'ret' variable was assigned the same value.</p></div>
<div class="balloon" rel="4782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'ret' variable was assigned the same value.</p></div>
<div class="balloon" rel="4931"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'ret' variable was assigned the same value.</p></div>
<div class="balloon" rel="4934"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'ret' variable was assigned the same value.</p></div>
<div class="balloon" rel="4949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pStr' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

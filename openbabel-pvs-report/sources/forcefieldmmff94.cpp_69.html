
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>forcefieldmmff94.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*********************************************************************</a>
<a name="ln2">forcefieldmmff94.cpp - MMFF94 force field</a>
<a name="ln3"> </a>
<a name="ln4">Copyright (C) 2006-2008 by Tim Vandermeersch &lt;tim.vandermeersch@gmail.com&gt;</a>
<a name="ln5"> </a>
<a name="ln6">This file is part of the Open Babel project.</a>
<a name="ln7">For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln8"> </a>
<a name="ln9">This program is free software; you can redistribute it and/or modify</a>
<a name="ln10">it under the terms of the GNU General Public License as published by</a>
<a name="ln11">the Free Software Foundation version 2 of the License.</a>
<a name="ln12"> </a>
<a name="ln13">This program is distributed in the hope that it will be useful,</a>
<a name="ln14">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln16">GNU General Public License for more details.</a>
<a name="ln17">***********************************************************************/</a>
<a name="ln18"> </a>
<a name="ln19">/*</a>
<a name="ln20"> * Source code layout:</a>
<a name="ln21"> * - Functions to calculate the actual interactions</a>
<a name="ln22"> * - Parse parameter files</a>
<a name="ln23"> * - Setup Functions</a>
<a name="ln24"> * - Validation functions</a>
<a name="ln25"> * - Calculate bond type, angle type, stretch-bend type, torsion type</a>
<a name="ln26"> * - Various tables &amp; misc. functions</a>
<a name="ln27"> *</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln31">#include &lt;openbabel/obconversion.h&gt;</a>
<a name="ln32">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln33">#include &lt;openbabel/locale.h&gt;</a>
<a name="ln34">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln35">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln36">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln37">#include &lt;openbabel/ring.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#ifndef M_PI</a>
<a name="ln40">#define M_PI 3.14159265358979323846</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;iomanip&gt;</a>
<a name="ln44">#include &quot;forcefieldmmff94.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">using namespace std;</a>
<a name="ln47"> </a>
<a name="ln48">namespace OpenBabel</a>
<a name="ln49">{</a>
<a name="ln50">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln51">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln52">  //</a>
<a name="ln53">  //  Functions to calculate the actual interactions</a>
<a name="ln54">  //</a>
<a name="ln55">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln56">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln57"> </a>
<a name="ln58">  double OBForceFieldMMFF94::Energy(bool gradients)</a>
<a name="ln59">  {</a>
<a name="ln60">    double energy;</a>
<a name="ln61"> </a>
<a name="ln62">    IF_OBFF_LOGLVL_MEDIUM</a>
<a name="ln63">      OBFFLog(&quot;\nE N E R G Y\n\n&quot;);</a>
<a name="ln64"> </a>
<a name="ln65">    if (gradients) {</a>
<a name="ln66">      ClearGradients();</a>
<a name="ln67">      energy  = E_Bond&lt;true&gt;();</a>
<a name="ln68">      energy += E_Angle&lt;true&gt;();</a>
<a name="ln69">      energy += E_StrBnd&lt;true&gt;();</a>
<a name="ln70">      energy += E_Torsion&lt;true&gt;();</a>
<a name="ln71">      energy += E_OOP&lt;true&gt;();</a>
<a name="ln72">      energy += E_VDW&lt;true&gt;();</a>
<a name="ln73">      energy += E_Electrostatic&lt;true&gt;();</a>
<a name="ln74">    } else {</a>
<a name="ln75">      energy  = E_Bond&lt;false&gt;();</a>
<a name="ln76">      energy += E_Angle&lt;false&gt;();</a>
<a name="ln77">      energy += E_StrBnd&lt;false&gt;();</a>
<a name="ln78">      energy += E_Torsion&lt;false&gt;();</a>
<a name="ln79">      energy += E_OOP&lt;false&gt;();</a>
<a name="ln80">      energy += E_VDW&lt;false&gt;();</a>
<a name="ln81">      energy += E_Electrostatic&lt;false&gt;();</a>
<a name="ln82">    }</a>
<a name="ln83"> </a>
<a name="ln84">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln85">      snprintf(_logbuf, BUFF_SIZE, &quot;\nTOTAL ENERGY = %8.5f %s\n&quot;, energy, GetUnit().c_str());</a>
<a name="ln86">      OBFFLog(_logbuf);</a>
<a name="ln87">    }</a>
<a name="ln88"> </a>
<a name="ln89">    return energy;</a>
<a name="ln90">  }</a>
<a name="ln91"> </a>
<a name="ln92">  //</a>
<a name="ln93">  // MMFF part I - page 494</a>
<a name="ln94">  //</a>
<a name="ln95">  //                   kb_ij                              7</a>
<a name="ln96">  // EB_ij = 143.9325 ------- /\r_ij^2 (1 + cs /\_rij + ---- cs^2 r_ij^2)</a>
<a name="ln97">  //                     2                               12</a>
<a name="ln98">  //</a>
<a name="ln99">  // kb_ij	force constant (md/A)</a>
<a name="ln100">  //</a>
<a name="ln101">  // /\r_ij 	r_ij - r0_ij (A)</a>
<a name="ln102">  //</a>
<a name="ln103">  // cs		cubic stretch constant = -2 A^(-1)</a>
<a name="ln104">  //</a>
<a name="ln105">  template&lt;bool gradients&gt;</a>
<a name="ln106">  inline void OBFFBondCalculationMMFF94::Compute()</a>
<a name="ln107">  {</a>
<a name="ln108">    if (OBForceField::IgnoreCalculation(idx_a, idx_b)) {</a>
<a name="ln109">      energy = 0.0;</a>
<a name="ln110">      return;</a>
<a name="ln111">    }</a>
<a name="ln112"> </a>
<a name="ln113">    double delta2;</a>
<a name="ln114"> </a>
<a name="ln115">    if (gradients) {</a>
<a name="ln116">      rab = OBForceField::VectorBondDerivative(pos_a, pos_b, force_a, force_b);</a>
<a name="ln117">      delta = rab - r0;</a>
<a name="ln118">      delta2 = delta * delta;</a>
<a name="ln119"> </a>
<a name="ln120">      const double dE = 143.9325 * kb * delta * (1.0 - 3.0 * delta + 14.0/3.0 * delta2);</a>
<a name="ln121"> </a>
<a name="ln122">      OBForceField::VectorSelfMultiply(force_a, dE);</a>
<a name="ln123">      OBForceField::VectorSelfMultiply(force_b, dE);</a>
<a name="ln124">    } else {</a>
<a name="ln125">      rab = OBForceField::VectorDistance(pos_a, pos_b);</a>
<a name="ln126">      delta = rab - r0;</a>
<a name="ln127">      delta2 = delta * delta;</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">    energy = kb * delta2 * (1.0 - 2.0 * delta + 7.0/3.0 * delta2);</a>
<a name="ln131">  }</a>
<a name="ln132"> </a>
<a name="ln133">  template&lt;bool gradients&gt;</a>
<a name="ln134">  double OBForceFieldMMFF94::E_Bond()</a>
<a name="ln135">  {</a>
<a name="ln136">    double energy = 0.0;</a>
<a name="ln137"> </a>
<a name="ln138">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln139">      OBFFLog(&quot;\nB O N D   S T R E T C H I N G\n\n&quot;);</a>
<a name="ln140">      OBFFLog(&quot;ATOM TYPES   FF    BOND       IDEAL       FORCE\n&quot;);</a>
<a name="ln141">      OBFFLog(&quot; I    J     CLASS  LENGTH     LENGTH     CONSTANT      DELTA      ENERGY\n&quot;);</a>
<a name="ln142">      OBFFLog(&quot;------------------------------------------------------------------------\n&quot;);</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    #ifdef _OPENMP</a>
<a name="ln146">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln147">    #endif</a>
<a name="ln148">    for (int i = 0; i &lt; _bondcalculations.size(); ++i) {</a>
<a name="ln149">      _bondcalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln150">      energy += _bondcalculations[i].energy;</a>
<a name="ln151"> </a>
<a name="ln152">      #ifndef _OPENMP</a>
<a name="ln153">      if (gradients) {</a>
<a name="ln154">        AddGradient(_bondcalculations[i].force_a, _bondcalculations[i].idx_a);</a>
<a name="ln155">        AddGradient(_bondcalculations[i].force_b, _bondcalculations[i].idx_b);</a>
<a name="ln156">      }</a>
<a name="ln157">      #endif</a>
<a name="ln158"> </a>
<a name="ln159">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln160">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d      %d   %8.3f   %8.3f     %8.3f   %8.3f   %8.3f\n&quot;,</a>
<a name="ln161">                atoi(_bondcalculations[i].a-&gt;GetType()), atoi(_bondcalculations[i].b-&gt;GetType()),</a>
<a name="ln162">                _bondcalculations[i].bt, _bondcalculations[i].rab, _bondcalculations[i].r0,</a>
<a name="ln163">                _bondcalculations[i].kb, _bondcalculations[i].delta,</a>
<a name="ln164">                143.9325 * 0.5 * _bondcalculations[i].energy);</a>
<a name="ln165">        OBFFLog(_logbuf);</a>
<a name="ln166">      }</a>
<a name="ln167">    }</a>
<a name="ln168"> </a>
<a name="ln169">    #ifdef _OPENMP</a>
<a name="ln170">    for (int i = 0; i &lt; _bondcalculations.size(); ++i) {</a>
<a name="ln171">      if (gradients) {</a>
<a name="ln172">        AddGradient(_bondcalculations[i].force_a, _bondcalculations[i].idx_a);</a>
<a name="ln173">        AddGradient(_bondcalculations[i].force_b, _bondcalculations[i].idx_b);</a>
<a name="ln174">      }</a>
<a name="ln175">    }</a>
<a name="ln176">    #endif</a>
<a name="ln177"> </a>
<a name="ln178">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln179">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL BOND STRETCHING ENERGY = %8.5f %s\n&quot;,  143.9325 * 0.5 * energy, GetUnit().c_str());</a>
<a name="ln180">      OBFFLog(_logbuf);</a>
<a name="ln181">    }</a>
<a name="ln182"> </a>
<a name="ln183">    return (143.9325 * 0.5 * energy);</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  //</a>
<a name="ln187">  // MMFF part I - page 495</a>
<a name="ln188">  //</a>
<a name="ln189">  //                       ka_ijk</a>
<a name="ln190">  // EA_ijk = 0.438449325 -------- /\0_ijk^2 (1 + cs /\0_ijk)</a>
<a name="ln191">  //                         2</a>
<a name="ln192">  //</a>
<a name="ln193">  // ka_ijk	force constant (md A/rad^2)</a>
<a name="ln194">  //</a>
<a name="ln195">  // /\0_ijk 	0_ijk - 00_ijk (degrees)</a>
<a name="ln196">  //</a>
<a name="ln197">  // cs		cubic bend constant = -0.007 deg^-1 = -0.4 rad^-1</a>
<a name="ln198">  //</a>
<a name="ln199">  template&lt;bool gradients&gt;</a>
<a name="ln200">  inline void OBFFAngleCalculationMMFF94::Compute()</a>
<a name="ln201">  {</a>
<a name="ln202">    if (OBForceField::IgnoreCalculation(idx_a, idx_b, idx_c)) {</a>
<a name="ln203">      energy = 0.0;</a>
<a name="ln204">      return;</a>
<a name="ln205">    }</a>
<a name="ln206"> </a>
<a name="ln207">    double delta2, dE;</a>
<a name="ln208"> </a>
<a name="ln209">    if (gradients) {</a>
<a name="ln210">      theta = OBForceField::VectorAngleDerivative(pos_a, pos_b, pos_c, force_a, force_b, force_c);</a>
<a name="ln211"> </a>
<a name="ln212">      if (!isfinite(theta))</a>
<a name="ln213">        theta = 0.0; // doesn't explain why GetAngle is returning NaN but solves it for us;</a>
<a name="ln214"> </a>
<a name="ln215">      delta = theta - theta0;</a>
<a name="ln216"> </a>
<a name="ln217">      if (linear) {</a>
<a name="ln218">        energy = 143.9325 * ka * (1.0 + cos((theta) * DEG_TO_RAD));</a>
<a name="ln219">        dE = -sin((theta) * DEG_TO_RAD) * 143.9325 * ka;</a>
<a name="ln220">      } else {</a>
<a name="ln221">        delta2 = delta * delta;</a>
<a name="ln222">        energy = 0.043844 * 0.5 * ka * delta2 * (1.0 - 0.007 * delta);</a>
<a name="ln223">        dE = RAD_TO_DEG * 0.043844 * ka * delta * (1.0 - 1.5 * 0.007 * delta);</a>
<a name="ln224">      }</a>
<a name="ln225"> </a>
<a name="ln226">      OBForceField::VectorSelfMultiply(force_a, dE);</a>
<a name="ln227">      OBForceField::VectorSelfMultiply(force_b, dE);</a>
<a name="ln228">      OBForceField::VectorSelfMultiply(force_c, dE);</a>
<a name="ln229">    } else {</a>
<a name="ln230">      theta = OBForceField::VectorAngle(pos_a, pos_b, pos_c);</a>
<a name="ln231"> </a>
<a name="ln232">      if (!isfinite(theta))</a>
<a name="ln233">        theta = 0.0; // doesn't explain why GetAngle is returning NaN but solves it for us;</a>
<a name="ln234"> </a>
<a name="ln235">      delta = theta - theta0;</a>
<a name="ln236"> </a>
<a name="ln237">      if (linear) {</a>
<a name="ln238">        energy = 143.9325 * ka * (1.0 + cos(theta * DEG_TO_RAD));</a>
<a name="ln239">      } else {</a>
<a name="ln240">        delta2 = delta * delta;</a>
<a name="ln241">        energy = 0.043844 * 0.5 * ka * delta2 * (1.0 - 0.007 * delta);</a>
<a name="ln242">      }</a>
<a name="ln243"> </a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  template&lt;bool gradients&gt;</a>
<a name="ln249">  double OBForceFieldMMFF94::E_Angle()</a>
<a name="ln250">  {</a>
<a name="ln251">    double energy = 0.0;</a>
<a name="ln252"> </a>
<a name="ln253">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln254">      OBFFLog(&quot;\nA N G L E   B E N D I N G\n\n&quot;);</a>
<a name="ln255">      OBFFLog(&quot;ATOM TYPES        FF    VALENCE     IDEAL      FORCE\n&quot;);</a>
<a name="ln256">      OBFFLog(&quot; I    J    K     CLASS   ANGLE      ANGLE     CONSTANT      DELTA      ENERGY\n&quot;);</a>
<a name="ln257">      OBFFLog(&quot;-----------------------------------------------------------------------------\n&quot;);</a>
<a name="ln258">    }</a>
<a name="ln259"> </a>
<a name="ln260">    #ifdef _OPENMP</a>
<a name="ln261">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln262">    #endif</a>
<a name="ln263">    for (int i = 0; i &lt; _anglecalculations.size(); ++i) {</a>
<a name="ln264"> </a>
<a name="ln265">      _anglecalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln266">      energy += _anglecalculations[i].energy;</a>
<a name="ln267"> </a>
<a name="ln268">      #ifndef _OPENMP</a>
<a name="ln269">      if (gradients) {</a>
<a name="ln270">        AddGradient(_anglecalculations[i].force_a, _anglecalculations[i].idx_a);</a>
<a name="ln271">        AddGradient(_anglecalculations[i].force_b, _anglecalculations[i].idx_b);</a>
<a name="ln272">        AddGradient(_anglecalculations[i].force_c, _anglecalculations[i].idx_c);</a>
<a name="ln273">      }</a>
<a name="ln274">      #endif</a>
<a name="ln275"> </a>
<a name="ln276">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln277">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d   %2d      %d   %8.3f   %8.3f     %8.3f   %8.3f   %8.3f\n&quot;,</a>
<a name="ln278">                atoi(_anglecalculations[i].a-&gt;GetType()), atoi(_anglecalculations[i].b-&gt;GetType()),</a>
<a name="ln279">                atoi(_anglecalculations[i].c-&gt;GetType()), _anglecalculations[i].at,</a>
<a name="ln280">                _anglecalculations[i].theta, _anglecalculations[i].theta0,</a>
<a name="ln281">                _anglecalculations[i].ka, _anglecalculations[i].delta,</a>
<a name="ln282">                _anglecalculations[i].energy);</a>
<a name="ln283">        OBFFLog(_logbuf);</a>
<a name="ln284">      }</a>
<a name="ln285">    }</a>
<a name="ln286"> </a>
<a name="ln287">    #ifdef _OPENMP</a>
<a name="ln288">    for (int i = 0; i &lt; _anglecalculations.size(); ++i) {</a>
<a name="ln289">      if (gradients) {</a>
<a name="ln290">        AddGradient(_anglecalculations[i].force_a, _anglecalculations[i].idx_a);</a>
<a name="ln291">        AddGradient(_anglecalculations[i].force_b, _anglecalculations[i].idx_b);</a>
<a name="ln292">        AddGradient(_anglecalculations[i].force_c, _anglecalculations[i].idx_c);</a>
<a name="ln293">      }</a>
<a name="ln294">    }</a>
<a name="ln295">    #endif</a>
<a name="ln296"> </a>
<a name="ln297">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln298">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL ANGLE BENDING ENERGY = %8.5f %s\n&quot;, energy, GetUnit().c_str());</a>
<a name="ln299">      OBFFLog(_logbuf);</a>
<a name="ln300">    }</a>
<a name="ln301"> </a>
<a name="ln302">    return energy;</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  //</a>
<a name="ln306">  // MMFF part I - page 495</a>
<a name="ln307">  //</a>
<a name="ln308">  // EBA_ijk = 2.51210 (kba_ijk /\r_ij + kba_kji /\r_kj) /\0_ijk</a>
<a name="ln309">  //</a>
<a name="ln310">  // kba_ijk	force constant (md/rad)</a>
<a name="ln311">  // kba_kji	force constant (md/rad)</a>
<a name="ln312">  //</a>
<a name="ln313">  // /\r_xx 	see above</a>
<a name="ln314">  // /\0_ijk 	see above</a>
<a name="ln315">  //</a>
<a name="ln316">  template&lt;bool gradients&gt;</a>
<a name="ln317">  inline void OBFFStrBndCalculationMMFF94::Compute()</a>
<a name="ln318">  {</a>
<a name="ln319">    if (OBForceField::IgnoreCalculation(idx_a, idx_b, idx_c)) {</a>
<a name="ln320">      energy = 0.0;</a>
<a name="ln321">      return;</a>
<a name="ln322">    }</a>
<a name="ln323"> </a>
<a name="ln324">    if (gradients) {</a>
<a name="ln325">      theta = OBForceField::VectorAngleDerivative(pos_a, pos_b, pos_c,</a>
<a name="ln326">                                                  force_abc_a, force_abc_b, force_abc_c);</a>
<a name="ln327">      rab = OBForceField::VectorDistanceDerivative(pos_a, pos_b, force_ab_a, force_ab_b);</a>
<a name="ln328">      rbc = OBForceField::VectorDistanceDerivative(pos_b, pos_c, force_bc_b, force_bc_c);</a>
<a name="ln329">    } else {</a>
<a name="ln330">      theta = OBForceField::VectorAngle(pos_a, pos_b, pos_c);</a>
<a name="ln331">      rab = OBForceField::VectorDistance(pos_a, pos_b);</a>
<a name="ln332">      rbc = OBForceField::VectorDistance(pos_b, pos_c);</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">    if (!isfinite(theta))</a>
<a name="ln336">      theta = 0.0; // doesn't explain why GetAngle is returning NaN but solves it for us;</a>
<a name="ln337"> </a>
<a name="ln338">    delta_theta = theta - theta0;</a>
<a name="ln339">    delta_rab = rab - rab0;</a>
<a name="ln340">    delta_rbc = rbc - rbc0;</a>
<a name="ln341">    const double factor = RAD_TO_DEG * (kbaABC * delta_rab + kbaCBA * delta_rbc);</a>
<a name="ln342"> </a>
<a name="ln343">    energy = DEG_TO_RAD * factor * delta_theta;</a>
<a name="ln344">    if (gradients) {</a>
<a name="ln345">      //grada = 2.51210 * (kbaABC * rab_da * delta_theta + RAD_TO_DEG * theta_da * (kbaABC * delta_rab + kbaCBA * delta_rbc));</a>
<a name="ln346">      OBForceField::VectorSelfMultiply(force_ab_a, (kbaABC*delta_theta));</a>
<a name="ln347">      OBForceField::VectorSelfMultiply(force_abc_a, factor);</a>
<a name="ln348">      OBForceField::VectorAdd(force_ab_a, force_abc_a, force_ab_a);</a>
<a name="ln349">      OBForceField::VectorMultiply(force_ab_a, 2.51210, force_a);</a>
<a name="ln350">      //gradc = 2.51210 * (kbaCBA * rbc_dc * delta_theta + RAD_TO_DEG * theta_dc * (kbaABC * delta_rab + kbaCBA * delta_rbc));</a>
<a name="ln351">      OBForceField::VectorSelfMultiply(force_bc_c, (kbaCBA*delta_theta));</a>
<a name="ln352">      OBForceField::VectorSelfMultiply(force_abc_c, factor);</a>
<a name="ln353">      OBForceField::VectorAdd(force_bc_c, force_abc_c, force_bc_c);</a>
<a name="ln354">      OBForceField::VectorMultiply(force_bc_c, 2.51210, force_c);</a>
<a name="ln355">      //gradb = -grada - gradc;</a>
<a name="ln356">      OBForceField::VectorAdd(force_a, force_c, force_b);</a>
<a name="ln357">      OBForceField::VectorSelfMultiply(force_b, -1.0);</a>
<a name="ln358">    }</a>
<a name="ln359">  }</a>
<a name="ln360"> </a>
<a name="ln361">  template&lt;bool gradients&gt;</a>
<a name="ln362">  double OBForceFieldMMFF94::E_StrBnd()</a>
<a name="ln363">  {</a>
<a name="ln364">    double energy = 0.0;</a>
<a name="ln365"> </a>
<a name="ln366">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln367">      OBFFLog(&quot;\nS T R E T C H   B E N D I N G\n\n&quot;);</a>
<a name="ln368">      OBFFLog(&quot;ATOM TYPES        FF    VALENCE     DELTA        FORCE CONSTANT\n&quot;);</a>
<a name="ln369">      OBFFLog(&quot; I    J    K     CLASS   ANGLE      ANGLE        I J        J K      ENERGY\n&quot;);</a>
<a name="ln370">      OBFFLog(&quot;---------------------------------------------------------------------------\n&quot;);</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    #ifdef _OPENMP</a>
<a name="ln374">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln375">    #endif</a>
<a name="ln376">    for (int i = 0; i &lt; _strbndcalculations.size(); ++i) {</a>
<a name="ln377"> </a>
<a name="ln378">      _strbndcalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln379">      energy += _strbndcalculations[i].energy;</a>
<a name="ln380"> </a>
<a name="ln381">      #ifndef _OPENMP</a>
<a name="ln382">      if (gradients) {</a>
<a name="ln383">        AddGradient(_strbndcalculations[i].force_a, _strbndcalculations[i].idx_a);</a>
<a name="ln384">        AddGradient(_strbndcalculations[i].force_b, _strbndcalculations[i].idx_b);</a>
<a name="ln385">        AddGradient(_strbndcalculations[i].force_c, _strbndcalculations[i].idx_c);</a>
<a name="ln386">      }</a>
<a name="ln387">      #endif</a>
<a name="ln388"> </a>
<a name="ln389">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln390">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d   %2d     %2d   %8.3f   %8.3f   %8.3f   %8.3f   %8.3f\n&quot;,</a>
<a name="ln391">                atoi(_strbndcalculations[i].a-&gt;GetType()), atoi(_strbndcalculations[i].b-&gt;GetType()),</a>
<a name="ln392">                atoi(_strbndcalculations[i].c-&gt;GetType()), _strbndcalculations[i].sbt,</a>
<a name="ln393">                _strbndcalculations[i].theta, _strbndcalculations[i].delta_theta,</a>
<a name="ln394">                _strbndcalculations[i].kbaABC, _strbndcalculations[i].kbaCBA,</a>
<a name="ln395">                2.51210 * _strbndcalculations[i].energy);</a>
<a name="ln396">        OBFFLog(_logbuf);</a>
<a name="ln397">      }</a>
<a name="ln398">    }</a>
<a name="ln399"> </a>
<a name="ln400">    #ifdef _OPENMP</a>
<a name="ln401">    for (int i = 0; i &lt; _strbndcalculations.size(); ++i) {</a>
<a name="ln402">      if (gradients) {</a>
<a name="ln403">        AddGradient(_strbndcalculations[i].force_a, _strbndcalculations[i].idx_a);</a>
<a name="ln404">        AddGradient(_strbndcalculations[i].force_b, _strbndcalculations[i].idx_b);</a>
<a name="ln405">        AddGradient(_strbndcalculations[i].force_c, _strbndcalculations[i].idx_c);</a>
<a name="ln406">      }</a>
<a name="ln407">    }</a>
<a name="ln408">    #endif</a>
<a name="ln409"> </a>
<a name="ln410">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln411">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL STRETCH BENDING ENERGY = %8.5f %s\n&quot;, 2.51210 * energy, GetUnit().c_str());</a>
<a name="ln412">      OBFFLog(_logbuf);</a>
<a name="ln413">    }</a>
<a name="ln414"> </a>
<a name="ln415">    return (2.51210 * energy);</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  int OBForceFieldMMFF94::GetElementRow(OBAtom *atom)</a>
<a name="ln419">  {</a>
<a name="ln420">    int row;</a>
<a name="ln421"> </a>
<a name="ln422">    row = 0;</a>
<a name="ln423"> </a>
<a name="ln424">    if (atom-&gt;GetAtomicNum() &gt; 2)</a>
<a name="ln425">      row++;</a>
<a name="ln426">    if (atom-&gt;GetAtomicNum() &gt; 10)</a>
<a name="ln427">      row++;</a>
<a name="ln428">    if (atom-&gt;GetAtomicNum() &gt; 18)</a>
<a name="ln429">      row++;</a>
<a name="ln430">    if (atom-&gt;GetAtomicNum() &gt; 36)</a>
<a name="ln431">      row++;</a>
<a name="ln432">    if (atom-&gt;GetAtomicNum() &gt; 54)</a>
<a name="ln433">      row++;</a>
<a name="ln434">    if (atom-&gt;GetAtomicNum() &gt; 86)</a>
<a name="ln435">      row++;</a>
<a name="ln436"> </a>
<a name="ln437">    return row;</a>
<a name="ln438">  }</a>
<a name="ln439"> </a>
<a name="ln440">  //</a>
<a name="ln441">  // MMFF part I - page 495</a>
<a name="ln442">  //</a>
<a name="ln443">  // ET_ijkl = 0.5 ( V1 (1 + cos(0_ijkl)) + V2 (1 - cos(2 0_ijkl)) + V3 (1 + cos(3 0_ijkl)) )</a>
<a name="ln444">  //</a>
<a name="ln445">  // V1		force constant (md/rad)</a>
<a name="ln446">  // V2		force constant (md/rad)</a>
<a name="ln447">  // V3		force constant (md/rad)</a>
<a name="ln448">  //</a>
<a name="ln449">  // 0_ijkl 	torsion angle (degrees)</a>
<a name="ln450">  //</a>
<a name="ln451">  template&lt;bool gradients&gt;</a>
<a name="ln452">  inline void OBFFTorsionCalculationMMFF94::Compute()</a>
<a name="ln453">  {</a>
<a name="ln454">    if (OBForceField::IgnoreCalculation(idx_a, idx_b, idx_c, idx_d)) {</a>
<a name="ln455">      energy = 0.0;</a>
<a name="ln456">      return;</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">    double cosine, cosine2, cosine3;</a>
<a name="ln460">    double phi1, phi2, phi3;</a>
<a name="ln461">    double dE, sine, sine2, sine3;</a>
<a name="ln462"> </a>
<a name="ln463">    if (gradients) {</a>
<a name="ln464">      tor = OBForceField::VectorTorsionDerivative(pos_a, pos_b, pos_c, pos_d,</a>
<a name="ln465">                                                  force_a, force_b, force_c, force_d);</a>
<a name="ln466">      if (!isfinite(tor))</a>
<a name="ln467">        tor = 1.0e-3;</a>
<a name="ln468"> </a>
<a name="ln469">      sine = sin(DEG_TO_RAD * tor);</a>
<a name="ln470">      sine2 = sin(2.0 * DEG_TO_RAD * tor);</a>
<a name="ln471">      sine3 = sin(3.0 * DEG_TO_RAD * tor);</a>
<a name="ln472"> </a>
<a name="ln473">      dE = 0.5 * (v1 * sine - 2.0 * v2 * sine2 + 3.0 * v3 * sine3); // MMFF</a>
<a name="ln474"> </a>
<a name="ln475">      OBForceField::VectorSelfMultiply(force_a, dE);</a>
<a name="ln476">      OBForceField::VectorSelfMultiply(force_b, dE);</a>
<a name="ln477">      OBForceField::VectorSelfMultiply(force_c, dE);</a>
<a name="ln478">      OBForceField::VectorSelfMultiply(force_d, dE);</a>
<a name="ln479">    } else {</a>
<a name="ln480">      tor = OBForceField::VectorTorsion(pos_a, pos_b, pos_c, pos_d);</a>
<a name="ln481">      if (!isfinite(tor))</a>
<a name="ln482">        tor = 1.0e-3;</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">    cosine = cos(DEG_TO_RAD * tor);</a>
<a name="ln486">    cosine2 = cos(DEG_TO_RAD * 2 * tor);</a>
<a name="ln487">    cosine3 = cos(DEG_TO_RAD * 3 * tor);</a>
<a name="ln488"> </a>
<a name="ln489">    phi1 = 1.0 + cosine;</a>
<a name="ln490">    phi2 = 1.0 - cosine2;</a>
<a name="ln491">    phi3 = 1.0 + cosine3;</a>
<a name="ln492"> </a>
<a name="ln493">    energy = (v1 * phi1 + v2 * phi2 + v3 * phi3);</a>
<a name="ln494"> </a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  template&lt;bool gradients&gt;</a>
<a name="ln498">  double OBForceFieldMMFF94::E_Torsion()</a>
<a name="ln499">  {</a>
<a name="ln500">    double energy = 0.0;</a>
<a name="ln501"> </a>
<a name="ln502">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln503">      OBFFLog(&quot;\nT O R S I O N A L\n\n&quot;);</a>
<a name="ln504">      OBFFLog(&quot;ATOM TYPES             FF     TORSION       FORCE CONSTANT\n&quot;);</a>
<a name="ln505">      OBFFLog(&quot; I    J    K    L     CLASS    ANGLE         V1   V2   V3     ENERGY\n&quot;);</a>
<a name="ln506">      OBFFLog(&quot;--------------------------------------------------------------------\n&quot;);</a>
<a name="ln507">    }</a>
<a name="ln508"> </a>
<a name="ln509">    #ifdef _OPENMP</a>
<a name="ln510">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln511">    #endif</a>
<a name="ln512">    for (int i = 0; i &lt; _torsioncalculations.size(); ++i) {</a>
<a name="ln513"> </a>
<a name="ln514">      _torsioncalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln515">      energy += _torsioncalculations[i].energy;</a>
<a name="ln516"> </a>
<a name="ln517">      #ifndef _OPENMP</a>
<a name="ln518">      if (gradients) {</a>
<a name="ln519">        AddGradient(_torsioncalculations[i].force_a, _torsioncalculations[i].idx_a);</a>
<a name="ln520">        AddGradient(_torsioncalculations[i].force_b, _torsioncalculations[i].idx_b);</a>
<a name="ln521">        AddGradient(_torsioncalculations[i].force_c, _torsioncalculations[i].idx_c);</a>
<a name="ln522">        AddGradient(_torsioncalculations[i].force_d, _torsioncalculations[i].idx_d);</a>
<a name="ln523">      }</a>
<a name="ln524">      #endif</a>
<a name="ln525"> </a>
<a name="ln526">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln527">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d   %2d   %2d      %d   %8.3f   %6.3f   %6.3f   %6.3f   %8.3f\n&quot;,</a>
<a name="ln528">                atoi(_torsioncalculations[i].a-&gt;GetType()), atoi(_torsioncalculations[i].b-&gt;GetType()),</a>
<a name="ln529">                atoi(_torsioncalculations[i].c-&gt;GetType()), atoi(_torsioncalculations[i].d-&gt;GetType()),</a>
<a name="ln530">                _torsioncalculations[i].tt, _torsioncalculations[i].tor, _torsioncalculations[i].v1,</a>
<a name="ln531">                _torsioncalculations[i].v2, _torsioncalculations[i].v3, 0.5 * _torsioncalculations[i].energy);</a>
<a name="ln532">        OBFFLog(_logbuf);</a>
<a name="ln533">      }</a>
<a name="ln534"> </a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">    #ifdef _OPENMP</a>
<a name="ln538">    for (int i = 0; i &lt; _torsioncalculations.size(); ++i) {</a>
<a name="ln539">      if (gradients) {</a>
<a name="ln540">        AddGradient(_torsioncalculations[i].force_a, _torsioncalculations[i].idx_a);</a>
<a name="ln541">        AddGradient(_torsioncalculations[i].force_b, _torsioncalculations[i].idx_b);</a>
<a name="ln542">        AddGradient(_torsioncalculations[i].force_c, _torsioncalculations[i].idx_c);</a>
<a name="ln543">        AddGradient(_torsioncalculations[i].force_d, _torsioncalculations[i].idx_d);</a>
<a name="ln544">      }</a>
<a name="ln545">    }</a>
<a name="ln546">    #endif</a>
<a name="ln547"> </a>
<a name="ln548">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln549">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL TORSIONAL ENERGY = %8.5f %s\n&quot;, 0.5 * energy, GetUnit().c_str());</a>
<a name="ln550">      OBFFLog(_logbuf);</a>
<a name="ln551">    }</a>
<a name="ln552"> </a>
<a name="ln553">    return (0.5 * energy);</a>
<a name="ln554">  }</a>
<a name="ln555"> </a>
<a name="ln556">  //						//</a>
<a name="ln557">  //  a						//</a>
<a name="ln558">  //   \  					//</a>
<a name="ln559">  //    b---d      plane = a-b-c		//</a>
<a name="ln560">  //   / 					//</a>
<a name="ln561">  //  c						//</a>
<a name="ln562">  //						//</a>
<a name="ln563">  template&lt;bool gradients&gt;</a>
<a name="ln564">  void OBFFOOPCalculationMMFF94::Compute()</a>
<a name="ln565">  {</a>
<a name="ln566">    if (OBForceField::IgnoreCalculation(idx_a, idx_b, idx_c, idx_d)) {</a>
<a name="ln567">      energy = 0.0;</a>
<a name="ln568">      return;</a>
<a name="ln569">    }</a>
<a name="ln570"> </a>
<a name="ln571">    double angle2, dE;</a>
<a name="ln572"> </a>
<a name="ln573">    if (gradients) {</a>
<a name="ln574">      angle = OBForceField::VectorOOPDerivative(pos_a, pos_b, pos_c, pos_d,</a>
<a name="ln575">                                                force_a, force_b, force_c, force_d);</a>
<a name="ln576"> </a>
<a name="ln577">      dE =  (-1.0 * RAD_TO_DEG * 0.043844 * angle * koop) / cos(angle * DEG_TO_RAD);</a>
<a name="ln578"> </a>
<a name="ln579">      OBForceField::VectorSelfMultiply(force_a, dE);</a>
<a name="ln580">      OBForceField::VectorSelfMultiply(force_b, dE);</a>
<a name="ln581">      OBForceField::VectorSelfMultiply(force_c, dE);</a>
<a name="ln582">      OBForceField::VectorSelfMultiply(force_d, dE);</a>
<a name="ln583">    } else {</a>
<a name="ln584">      angle = OBForceField::VectorOOP(pos_a, pos_b, pos_c, pos_d);</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    if (!isfinite(angle))</a>
<a name="ln588">      angle = 0.0; // doesn't explain why GetAngle is returning NaN but solves it for us;</a>
<a name="ln589"> </a>
<a name="ln590">    angle2 = angle * angle;</a>
<a name="ln591">    energy = koop * angle2;</a>
<a name="ln592"> </a>
<a name="ln593">  }</a>
<a name="ln594"> </a>
<a name="ln595">  template&lt;bool gradients&gt;</a>
<a name="ln596">  double OBForceFieldMMFF94::E_OOP()</a>
<a name="ln597">  {</a>
<a name="ln598">    double energy = 0.0;</a>
<a name="ln599"> </a>
<a name="ln600">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln601">      OBFFLog(&quot;\nO U T - O F - P L A N E   B E N D I N G\n\n&quot;);</a>
<a name="ln602">      OBFFLog(&quot;ATOM TYPES             FF       OOP     FORCE\n&quot;);</a>
<a name="ln603">      OBFFLog(&quot; I    J    K    L     CLASS    ANGLE   CONSTANT     ENERGY\n&quot;);</a>
<a name="ln604">      OBFFLog(&quot;----------------------------------------------------------\n&quot;);</a>
<a name="ln605">    }</a>
<a name="ln606"> </a>
<a name="ln607">    #ifdef _OPENMP</a>
<a name="ln608">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln609">    #endif</a>
<a name="ln610">    for (int i = 0; i &lt; _oopcalculations.size(); ++i) {</a>
<a name="ln611"> </a>
<a name="ln612">      _oopcalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln613">      energy += _oopcalculations[i].energy;</a>
<a name="ln614"> </a>
<a name="ln615">      #ifndef _OPENMP</a>
<a name="ln616">      if (gradients) {</a>
<a name="ln617">        AddGradient(_oopcalculations[i].force_a, _oopcalculations[i].idx_a);</a>
<a name="ln618">        AddGradient(_oopcalculations[i].force_b, _oopcalculations[i].idx_b);</a>
<a name="ln619">        AddGradient(_oopcalculations[i].force_c, _oopcalculations[i].idx_c);</a>
<a name="ln620">        AddGradient(_oopcalculations[i].force_d, _oopcalculations[i].idx_d);</a>
<a name="ln621">      }</a>
<a name="ln622">      #endif</a>
<a name="ln623"> </a>
<a name="ln624">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln625">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d   %2d   %2d      0   %8.3f   %8.3f     %8.3f\n&quot;,</a>
<a name="ln626">                atoi(_oopcalculations[i].a-&gt;GetType()), atoi(_oopcalculations[i].b-&gt;GetType()),</a>
<a name="ln627">                atoi(_oopcalculations[i].c-&gt;GetType()), atoi(_oopcalculations[i].d-&gt;GetType()),</a>
<a name="ln628">                _oopcalculations[i].angle, _oopcalculations[i].koop,</a>
<a name="ln629">                0.043844 * 0.5 * _oopcalculations[i].energy);</a>
<a name="ln630">        OBFFLog(_logbuf);</a>
<a name="ln631">      }</a>
<a name="ln632">    }</a>
<a name="ln633"> </a>
<a name="ln634">    #ifdef _OPENMP</a>
<a name="ln635">    for (int i = 0; i &lt; _oopcalculations.size(); ++i) {</a>
<a name="ln636">      if (gradients) {</a>
<a name="ln637">        AddGradient(_oopcalculations[i].force_a, _oopcalculations[i].idx_a);</a>
<a name="ln638">        AddGradient(_oopcalculations[i].force_b, _oopcalculations[i].idx_b);</a>
<a name="ln639">        AddGradient(_oopcalculations[i].force_c, _oopcalculations[i].idx_c);</a>
<a name="ln640">        AddGradient(_oopcalculations[i].force_d, _oopcalculations[i].idx_d);</a>
<a name="ln641">      }</a>
<a name="ln642">    }</a>
<a name="ln643">    #endif</a>
<a name="ln644"> </a>
<a name="ln645">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln646">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL OUT-OF-PLANE BENDING ENERGY = %8.5f %s\n&quot;, 0.043844 * 0.5 * energy, GetUnit().c_str());</a>
<a name="ln647">      OBFFLog(_logbuf);</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">    return (0.043844 * 0.5 * energy);</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  template&lt;bool gradients&gt;</a>
<a name="ln654">  inline void OBFFVDWCalculationMMFF94::Compute()</a>
<a name="ln655">  {</a>
<a name="ln656">    if (OBForceField::IgnoreCalculation(idx_a, idx_b)) {</a>
<a name="ln657">      energy = 0.0;</a>
<a name="ln658">      return;</a>
<a name="ln659">    }</a>
<a name="ln660"> </a>
<a name="ln661">    if (gradients) {</a>
<a name="ln662">      rab = OBForceField::VectorDistanceDerivative(pos_a, pos_b, force_a, force_b);</a>
<a name="ln663">    } else {</a>
<a name="ln664">      rab = OBForceField::VectorDistance(pos_a, pos_b);</a>
<a name="ln665">    }</a>
<a name="ln666"> </a>
<a name="ln667">    const double rab7 = rab*rab*rab*rab*rab*rab*rab;</a>
<a name="ln668"> </a>
<a name="ln669">    double erep = (1.07 * R_AB) / (rab + 0.07 * R_AB); //***</a>
<a name="ln670">    double erep7 = erep*erep*erep*erep*erep*erep*erep;</a>
<a name="ln671"> </a>
<a name="ln672">    double eattr = (((1.12 * R_AB7) / (rab7 + 0.12 * R_AB7)) - 2.0);</a>
<a name="ln673"> </a>
<a name="ln674">    energy = epsilon * erep7 * eattr;</a>
<a name="ln675"> </a>
<a name="ln676">    if (gradients) {</a>
<a name="ln677">      const double q = rab / R_AB;</a>
<a name="ln678">      const double q6 = q*q*q*q*q*q;</a>
<a name="ln679">      const double q7 = q6 * q;</a>
<a name="ln680">      erep = 1.07 / (q + 0.07);</a>
<a name="ln681">      erep7 = erep*erep*erep*erep*erep*erep*erep;</a>
<a name="ln682">      const double term = q7 + 0.12;</a>
<a name="ln683">      const double term2 = term * term;</a>
<a name="ln684">      eattr = (-7.84 * q6) / term2 + ((-7.84 / term) + 14) / (q + 0.07);</a>
<a name="ln685">      const double dE = (epsilon / R_AB) * erep7 * eattr;</a>
<a name="ln686">      OBForceField::VectorSelfMultiply(force_a, dE);</a>
<a name="ln687">      OBForceField::VectorSelfMultiply(force_b, dE);</a>
<a name="ln688">    }</a>
<a name="ln689">  }</a>
<a name="ln690"> </a>
<a name="ln691">  template&lt;bool gradients&gt;</a>
<a name="ln692">  double OBForceFieldMMFF94::E_VDW()</a>
<a name="ln693">  {</a>
<a name="ln694">    double energy = 0.0;</a>
<a name="ln695"> </a>
<a name="ln696">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln697">      OBFFLog(&quot;\nV A N   D E R   W A A L S\n\n&quot;);</a>
<a name="ln698">      OBFFLog(&quot;ATOM TYPES\n&quot;);</a>
<a name="ln699">      OBFFLog(&quot; I    J        Rij       R*IJ    EPSILON    ENERGY\n&quot;);</a>
<a name="ln700">      OBFFLog(&quot;--------------------------------------------------\n&quot;);</a>
<a name="ln701">      //       XX   XX     -000.000  -000.000  -000.000  -000.000</a>
<a name="ln702">    }</a>
<a name="ln703"> </a>
<a name="ln704">    #ifdef _OPENMP</a>
<a name="ln705">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln706">    #endif</a>
<a name="ln707">    for (int i = 0; i &lt; _vdwcalculations.size(); ++i) {</a>
<a name="ln708">      // Cut-off check</a>
<a name="ln709">      if (_cutoff)</a>
<a name="ln710">        if (!_vdwpairs.BitIsSet(_vdwcalculations[i].pairIndex))</a>
<a name="ln711">          continue;</a>
<a name="ln712"> </a>
<a name="ln713">      _vdwcalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln714">      energy += _vdwcalculations[i].energy;</a>
<a name="ln715"> </a>
<a name="ln716">      #ifndef _OPENMP</a>
<a name="ln717">      if (gradients) {</a>
<a name="ln718">        AddGradient(_vdwcalculations[i].force_a, _vdwcalculations[i].idx_a);</a>
<a name="ln719">        AddGradient(_vdwcalculations[i].force_b, _vdwcalculations[i].idx_b);</a>
<a name="ln720">      }</a>
<a name="ln721">      #endif</a>
<a name="ln722"> </a>
<a name="ln723">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln724">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d     %8.3f  %8.3f  %8.3f  %8.3f\n&quot;,</a>
<a name="ln725">                atoi(_vdwcalculations[i].a-&gt;GetType()), atoi(_vdwcalculations[i].b-&gt;GetType()),</a>
<a name="ln726">                _vdwcalculations[i].rab, _vdwcalculations[i].R_AB, _vdwcalculations[i].epsilon, _vdwcalculations[i].energy);</a>
<a name="ln727">        OBFFLog(_logbuf);</a>
<a name="ln728">      }</a>
<a name="ln729"> </a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    #ifdef _OPENMP</a>
<a name="ln733">    for (int i = 0; i &lt; _vdwcalculations.size(); ++i) {</a>
<a name="ln734">      // Cut-off check</a>
<a name="ln735">      if (_cutoff)</a>
<a name="ln736">        if (!_vdwpairs.BitIsSet(i))</a>
<a name="ln737">          continue;</a>
<a name="ln738"> </a>
<a name="ln739">      if (gradients) {</a>
<a name="ln740">        AddGradient(_vdwcalculations[i].force_a, _vdwcalculations[i].idx_a);</a>
<a name="ln741">        AddGradient(_vdwcalculations[i].force_b, _vdwcalculations[i].idx_b);</a>
<a name="ln742">      }</a>
<a name="ln743">    }</a>
<a name="ln744">    #endif</a>
<a name="ln745"> </a>
<a name="ln746">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln747">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL VAN DER WAALS ENERGY = %8.5f %s\n&quot;, energy, GetUnit().c_str());</a>
<a name="ln748">      OBFFLog(_logbuf);</a>
<a name="ln749">    }</a>
<a name="ln750"> </a>
<a name="ln751">    return energy;</a>
<a name="ln752">  }</a>
<a name="ln753"> </a>
<a name="ln754">  template&lt;bool gradients&gt;</a>
<a name="ln755">  inline void OBFFElectrostaticCalculationMMFF94::Compute()</a>
<a name="ln756">  {</a>
<a name="ln757">    if (OBForceField::IgnoreCalculation(idx_a, idx_b)) {</a>
<a name="ln758">      energy = 0.0;</a>
<a name="ln759">      return;</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">    if (gradients) {</a>
<a name="ln763">      rab = OBForceField::VectorDistanceDerivative(pos_a, pos_b, force_a, force_b);</a>
<a name="ln764">      rab += 0.05; // ??</a>
<a name="ln765">      const double rab2 = rab * rab;</a>
<a name="ln766">      const double dE = -qq / rab2;</a>
<a name="ln767">      OBForceField::VectorSelfMultiply(force_a, dE);</a>
<a name="ln768">      OBForceField::VectorSelfMultiply(force_b, dE);</a>
<a name="ln769">    } else {</a>
<a name="ln770">      rab = OBForceField::VectorDistance(pos_a, pos_b);</a>
<a name="ln771">      rab += 0.05; // ??</a>
<a name="ln772">    }</a>
<a name="ln773"> </a>
<a name="ln774">    energy = qq / rab;</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777">  template&lt;bool gradients&gt;</a>
<a name="ln778">  double OBForceFieldMMFF94::E_Electrostatic()</a>
<a name="ln779">  {</a>
<a name="ln780">    double energy = 0.0;</a>
<a name="ln781"> </a>
<a name="ln782">    IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln783">      OBFFLog(&quot;\nE L E C T R O S T A T I C   I N T E R A C T I O N S\n\n&quot;);</a>
<a name="ln784">      OBFFLog(&quot;ATOM TYPES\n&quot;);</a>
<a name="ln785">      OBFFLog(&quot; I    J        Rij        Qi         Qj        ENERGY\n&quot;);</a>
<a name="ln786">      OBFFLog(&quot;-----------------------------------------------------\n&quot;);</a>
<a name="ln787">      //       XX   XX     XXXXXXXX   XXXXXXXX   XXXXXXXX   XXXXXXXX</a>
<a name="ln788">    }</a>
<a name="ln789"> </a>
<a name="ln790">    #ifdef _OPENMP</a>
<a name="ln791">    #pragma omp parallel for reduction(+:energy)</a>
<a name="ln792">    #endif</a>
<a name="ln793">    for (int i = 0; i &lt; _electrostaticcalculations.size(); ++i) {</a>
<a name="ln794">      // Cut-off check</a>
<a name="ln795">      if (_cutoff)</a>
<a name="ln796">        if (!_elepairs.BitIsSet(_electrostaticcalculations[i].pairIndex))</a>
<a name="ln797">          continue;</a>
<a name="ln798"> </a>
<a name="ln799">      _electrostaticcalculations[i].template Compute&lt;gradients&gt;();</a>
<a name="ln800">      energy += _electrostaticcalculations[i].energy;</a>
<a name="ln801"> </a>
<a name="ln802">      #ifndef _OPENMP</a>
<a name="ln803">      if (gradients) {</a>
<a name="ln804">        AddGradient(_electrostaticcalculations[i].force_a, _electrostaticcalculations[i].idx_a);</a>
<a name="ln805">        AddGradient(_electrostaticcalculations[i].force_b, _electrostaticcalculations[i].idx_b);</a>
<a name="ln806">      }</a>
<a name="ln807">      #endif</a>
<a name="ln808"> </a>
<a name="ln809">      IF_OBFF_LOGLVL_HIGH {</a>
<a name="ln810">        snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %2d   %8.3f  %8.3f  %8.3f  %8.3f\n&quot;,</a>
<a name="ln811">                atoi(_electrostaticcalculations[i].a-&gt;GetType()), atoi(_electrostaticcalculations[i].b-&gt;GetType()),</a>
<a name="ln812">                _electrostaticcalculations[i].rab, _electrostaticcalculations[i].a-&gt;GetPartialCharge(),</a>
<a name="ln813">                _electrostaticcalculations[i].b-&gt;GetPartialCharge(), _electrostaticcalculations[i].energy);</a>
<a name="ln814">        OBFFLog(_logbuf);</a>
<a name="ln815">      }</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    #ifdef _OPENMP</a>
<a name="ln819">    for (int i = 0; i &lt; _electrostaticcalculations.size(); ++i) {</a>
<a name="ln820">      // Cut-off check</a>
<a name="ln821">      if (_cutoff)</a>
<a name="ln822">        if (!_elepairs.BitIsSet(i))</a>
<a name="ln823">          continue;</a>
<a name="ln824"> </a>
<a name="ln825">      if (gradients) {</a>
<a name="ln826">        AddGradient(_electrostaticcalculations[i].force_a, _electrostaticcalculations[i].idx_a);</a>
<a name="ln827">        AddGradient(_electrostaticcalculations[i].force_b, _electrostaticcalculations[i].idx_b);</a>
<a name="ln828">      }</a>
<a name="ln829">    }</a>
<a name="ln830">    #endif</a>
<a name="ln831"> </a>
<a name="ln832">    IF_OBFF_LOGLVL_MEDIUM {</a>
<a name="ln833">      snprintf(_logbuf, BUFF_SIZE, &quot;     TOTAL ELECTROSTATIC ENERGY = %8.5f %s\n&quot;, energy, GetUnit().c_str());</a>
<a name="ln834">      OBFFLog(_logbuf);</a>
<a name="ln835">    }</a>
<a name="ln836"> </a>
<a name="ln837">    return energy;</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  //</a>
<a name="ln841">  // OBForceFieldMMFF member functions</a>
<a name="ln842">  //</a>
<a name="ln843">  //***********************************************</a>
<a name="ln844">  //Make a global instance</a>
<a name="ln845">  OBForceFieldMMFF94 theForceFieldMMFF94(&quot;MMFF94&quot;, false);</a>
<a name="ln846">  OBForceFieldMMFF94 theForceFieldMMFF94s(&quot;MMFF94s&quot;, false);</a>
<a name="ln847">  //***********************************************</a>
<a name="ln848"> </a>
<a name="ln849">  OBForceFieldMMFF94::~OBForceFieldMMFF94()</a>
<a name="ln850">  {</a>
<a name="ln851">  }</a>
<a name="ln852"> </a>
<a name="ln853">  OBForceFieldMMFF94 &amp;OBForceFieldMMFF94::operator=(OBForceFieldMMFF94 &amp;src)</a>
<a name="ln854">  {</a>
<a name="ln855">    _mol = src._mol;</a>
<a name="ln856">    _init = src._init;</a>
<a name="ln857">    return *this;</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln861">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln862">  //</a>
<a name="ln863">  //  Parse parameter files</a>
<a name="ln864">  //</a>
<a name="ln865">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln866">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln867"> </a>
<a name="ln868">  bool OBForceFieldMMFF94::ParseParamFile()</a>
<a name="ln869">  {</a>
<a name="ln870">    // Set the locale for number parsing to avoid locale issues: PR#1785463</a>
<a name="ln871">    obLocale.SetLocale();</a>
<a name="ln872"> </a>
<a name="ln873">    vector&lt;string&gt; vs;</a>
<a name="ln874">    char buffer[80];</a>
<a name="ln875"> </a>
<a name="ln876">    // open data/_parFile</a>
<a name="ln877">    ifstream ifs;</a>
<a name="ln878">    if (OpenDatafile(ifs, _parFile).length() == 0) {</a>
<a name="ln879">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open parameter file&quot;, obError);</a>
<a name="ln880">      return false;</a>
<a name="ln881">    }</a>
<a name="ln882"> </a>
<a name="ln883">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln884">      if (EQn(buffer, &quot;#&quot;, 1)) continue;</a>
<a name="ln885"> </a>
<a name="ln886">      tokenize(vs, buffer);</a>
<a name="ln887">      if (vs.size() &lt; 2)</a>
<a name="ln888">        continue;</a>
<a name="ln889"> </a>
<a name="ln890">      if (vs[0] == &quot;prop&quot;)</a>
<a name="ln891">        ParseParamProp(vs[1]);</a>
<a name="ln892">      if (vs[0] == &quot;def&quot;)</a>
<a name="ln893">        ParseParamDef(vs[1]);</a>
<a name="ln894">      if (vs[0] == &quot;bond&quot;)</a>
<a name="ln895">        ParseParamBond(vs[1]);</a>
<a name="ln896">      if (vs[0] == &quot;ang&quot;)</a>
<a name="ln897">        ParseParamAngle(vs[1]);</a>
<a name="ln898">      if (vs[0] == &quot;bndk&quot;)</a>
<a name="ln899">        ParseParamBndk(vs[1]);</a>
<a name="ln900">      if (vs[0] == &quot;chg&quot;)</a>
<a name="ln901">        ParseParamCharge(vs[1]);</a>
<a name="ln902">      if (vs[0] == &quot;dfsb&quot;)</a>
<a name="ln903">        ParseParamDfsb(vs[1]);</a>
<a name="ln904">      if (vs[0] == &quot;oop&quot;)</a>
<a name="ln905">        ParseParamOOP(vs[1]);</a>
<a name="ln906">      if (vs[0] == &quot;pbci&quot;)</a>
<a name="ln907">        ParseParamPbci(vs[1]);</a>
<a name="ln908">      if (vs[0] == &quot;stbn&quot;)</a>
<a name="ln909">        ParseParamStrBnd(vs[1]);</a>
<a name="ln910">      if (vs[0] == &quot;tor&quot;)</a>
<a name="ln911">        ParseParamTorsion(vs[1]);</a>
<a name="ln912">      if (vs[0] == &quot;vdw&quot;)</a>
<a name="ln913">        ParseParamVDW(vs[1]);</a>
<a name="ln914">    }</a>
<a name="ln915"> </a>
<a name="ln916">    if (ifs)</a>
<a name="ln917">      ifs.close();</a>
<a name="ln918"> </a>
<a name="ln919">    // return the locale to the original one</a>
<a name="ln920">    obLocale.RestoreLocale();</a>
<a name="ln921">    return true;</a>
<a name="ln922">  }</a>
<a name="ln923"> </a>
<a name="ln924">  bool OBForceFieldMMFF94::ParseParamBond(std::string &amp;filename)</a>
<a name="ln925">  {</a>
<a name="ln926">    vector&lt;string&gt; vs;</a>
<a name="ln927">    char buffer[80];</a>
<a name="ln928"> </a>
<a name="ln929">    OBFFParameter parameter;</a>
<a name="ln930"> </a>
<a name="ln931">    // open data/mmffbond.par</a>
<a name="ln932">    ifstream ifs;</a>
<a name="ln933">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln934">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffbond.par&quot;, obError);</a>
<a name="ln935">      return false;</a>
<a name="ln936">    }</a>
<a name="ln937"> </a>
<a name="ln938">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln939">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln940">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln941"> </a>
<a name="ln942">      tokenize(vs, buffer);</a>
<a name="ln943"> </a>
<a name="ln944">      parameter.clear();</a>
<a name="ln945">      parameter._ipar.push_back(atoi(vs[0].c_str()));  // FF class</a>
<a name="ln946">      parameter.a = atoi(vs[1].c_str());</a>
<a name="ln947">      parameter.b = atoi(vs[2].c_str());</a>
<a name="ln948">      parameter._dpar.push_back(atof(vs[3].c_str()));  // kb</a>
<a name="ln949">      parameter._dpar.push_back(atof(vs[4].c_str()));  // r0</a>
<a name="ln950">      _ffbondparams.push_back(parameter);</a>
<a name="ln951">    }</a>
<a name="ln952"> </a>
<a name="ln953">    if (ifs)</a>
<a name="ln954">      ifs.close();</a>
<a name="ln955"> </a>
<a name="ln956">    return 0;</a>
<a name="ln957">  }</a>
<a name="ln958"> </a>
<a name="ln959">  bool OBForceFieldMMFF94::ParseParamBndk(std::string &amp;filename)</a>
<a name="ln960">  {</a>
<a name="ln961">    vector&lt;string&gt; vs;</a>
<a name="ln962">    char buffer[80];</a>
<a name="ln963"> </a>
<a name="ln964">    OBFFParameter parameter;</a>
<a name="ln965"> </a>
<a name="ln966">    // open data/mmffbndk.par</a>
<a name="ln967">    ifstream ifs;</a>
<a name="ln968">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln969">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffbndk.par&quot;, obError);</a>
<a name="ln970">      return false;</a>
<a name="ln971">    }</a>
<a name="ln972"> </a>
<a name="ln973">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln974">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln975">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln976"> </a>
<a name="ln977">      tokenize(vs, buffer);</a>
<a name="ln978"> </a>
<a name="ln979">      parameter.clear();</a>
<a name="ln980">      parameter.a = atoi(vs[0].c_str());</a>
<a name="ln981">      parameter.b = atoi(vs[1].c_str());</a>
<a name="ln982">      parameter._dpar.push_back(atof(vs[2].c_str()));  // r0-ref</a>
<a name="ln983">      parameter._dpar.push_back(atof(vs[3].c_str()));  // kb-ref</a>
<a name="ln984">      _ffbndkparams.push_back(parameter);</a>
<a name="ln985">    }</a>
<a name="ln986"> </a>
<a name="ln987">    if (ifs)</a>
<a name="ln988">      ifs.close();</a>
<a name="ln989"> </a>
<a name="ln990">    return 0;</a>
<a name="ln991">  }</a>
<a name="ln992"> </a>
<a name="ln993">  bool OBForceFieldMMFF94::ParseParamAngle(std::string &amp;filename)</a>
<a name="ln994">  {</a>
<a name="ln995">    vector&lt;string&gt; vs;</a>
<a name="ln996">    char buffer[80];</a>
<a name="ln997"> </a>
<a name="ln998">    OBFFParameter parameter;</a>
<a name="ln999"> </a>
<a name="ln1000">    // open data/mmffang.par</a>
<a name="ln1001">    ifstream ifs;</a>
<a name="ln1002">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1003">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffang.par&quot;, obError);</a>
<a name="ln1004">      return false;</a>
<a name="ln1005">    }</a>
<a name="ln1006"> </a>
<a name="ln1007">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1008">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1009">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1010"> </a>
<a name="ln1011">      tokenize(vs, buffer);</a>
<a name="ln1012"> </a>
<a name="ln1013">      parameter.clear();</a>
<a name="ln1014">      parameter._ipar.push_back(atoi(vs[0].c_str()));  // FF class</a>
<a name="ln1015">      parameter.a = atoi(vs[1].c_str());</a>
<a name="ln1016">      parameter.b = atoi(vs[2].c_str());</a>
<a name="ln1017">      parameter.c = atoi(vs[3].c_str());</a>
<a name="ln1018">      parameter._dpar.push_back(atof(vs[4].c_str()));  // ka</a>
<a name="ln1019">      parameter._dpar.push_back(atof(vs[5].c_str()));  // theta0</a>
<a name="ln1020">      _ffangleparams.push_back(parameter);</a>
<a name="ln1021">    }</a>
<a name="ln1022"> </a>
<a name="ln1023">    if (ifs)</a>
<a name="ln1024">      ifs.close();</a>
<a name="ln1025"> </a>
<a name="ln1026">    return 0;</a>
<a name="ln1027">  }</a>
<a name="ln1028"> </a>
<a name="ln1029">  bool OBForceFieldMMFF94::ParseParamStrBnd(std::string &amp;filename)</a>
<a name="ln1030">  {</a>
<a name="ln1031">    vector&lt;string&gt; vs;</a>
<a name="ln1032">    char buffer[80];</a>
<a name="ln1033"> </a>
<a name="ln1034">    OBFFParameter parameter;</a>
<a name="ln1035"> </a>
<a name="ln1036">    // open data/mmffstbn.par</a>
<a name="ln1037">    ifstream ifs;</a>
<a name="ln1038">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1039">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffstbn.par&quot;, obError);</a>
<a name="ln1040">      return false;</a>
<a name="ln1041">    }</a>
<a name="ln1042"> </a>
<a name="ln1043">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1044">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1045">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1046"> </a>
<a name="ln1047">      tokenize(vs, buffer);</a>
<a name="ln1048"> </a>
<a name="ln1049">      parameter.clear();</a>
<a name="ln1050">      parameter._ipar.push_back(atoi(vs[0].c_str()));  // FF class</a>
<a name="ln1051">      parameter.a = atoi(vs[1].c_str());</a>
<a name="ln1052">      parameter.b = atoi(vs[2].c_str());</a>
<a name="ln1053">      parameter.c = atoi(vs[3].c_str());</a>
<a name="ln1054">      parameter._dpar.push_back(atof(vs[4].c_str()));  // kbaIJK</a>
<a name="ln1055">      parameter._dpar.push_back(atof(vs[5].c_str()));  // kbaKJI</a>
<a name="ln1056">      _ffstrbndparams.push_back(parameter);</a>
<a name="ln1057">    }</a>
<a name="ln1058"> </a>
<a name="ln1059">    if (ifs)</a>
<a name="ln1060">      ifs.close();</a>
<a name="ln1061"> </a>
<a name="ln1062">    return 0;</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  bool OBForceFieldMMFF94::ParseParamDfsb(std::string &amp;filename)</a>
<a name="ln1066">  {</a>
<a name="ln1067">    vector&lt;string&gt; vs;</a>
<a name="ln1068">    char buffer[80];</a>
<a name="ln1069"> </a>
<a name="ln1070">    OBFFParameter parameter;</a>
<a name="ln1071"> </a>
<a name="ln1072">    // open data/mmffdfsb.par</a>
<a name="ln1073">    ifstream ifs;</a>
<a name="ln1074">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1075">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffdfsb.par&quot;, obError);</a>
<a name="ln1076">      return false;</a>
<a name="ln1077">    }</a>
<a name="ln1078"> </a>
<a name="ln1079">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1080">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1081">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1082"> </a>
<a name="ln1083">      tokenize(vs, buffer);</a>
<a name="ln1084"> </a>
<a name="ln1085">      parameter.clear();</a>
<a name="ln1086">      parameter.a = atoi(vs[0].c_str());</a>
<a name="ln1087">      parameter.b = atoi(vs[1].c_str());</a>
<a name="ln1088">      parameter.c = atoi(vs[2].c_str());</a>
<a name="ln1089">      parameter._dpar.push_back(atof(vs[3].c_str()));  // kbaIJK</a>
<a name="ln1090">      parameter._dpar.push_back(atof(vs[4].c_str()));  // kbaKJI</a>
<a name="ln1091">      _ffdfsbparams.push_back(parameter);</a>
<a name="ln1092">    }</a>
<a name="ln1093"> </a>
<a name="ln1094">    if (ifs)</a>
<a name="ln1095">      ifs.close();</a>
<a name="ln1096"> </a>
<a name="ln1097">    return 0;</a>
<a name="ln1098">  }</a>
<a name="ln1099"> </a>
<a name="ln1100">  bool OBForceFieldMMFF94::ParseParamOOP(std::string &amp;filename)</a>
<a name="ln1101">  {</a>
<a name="ln1102">    vector&lt;string&gt; vs;</a>
<a name="ln1103">    char buffer[80];</a>
<a name="ln1104"> </a>
<a name="ln1105">    OBFFParameter parameter;</a>
<a name="ln1106"> </a>
<a name="ln1107">    // open data/mmffoop.par</a>
<a name="ln1108">    ifstream ifs;</a>
<a name="ln1109">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1110">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffoop.par&quot;, obError);</a>
<a name="ln1111">      return false;</a>
<a name="ln1112">    }</a>
<a name="ln1113"> </a>
<a name="ln1114">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1115">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1116">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1117"> </a>
<a name="ln1118">      tokenize(vs, buffer);</a>
<a name="ln1119"> </a>
<a name="ln1120">      parameter.clear();</a>
<a name="ln1121">      parameter.a = atoi(vs[0].c_str());</a>
<a name="ln1122">      parameter.b = atoi(vs[1].c_str());</a>
<a name="ln1123">      parameter.c = atoi(vs[2].c_str());</a>
<a name="ln1124">      parameter.d = atoi(vs[3].c_str());</a>
<a name="ln1125">      parameter._dpar.push_back(atof(vs[4].c_str()));  // koop</a>
<a name="ln1126">      _ffoopparams.push_back(parameter);</a>
<a name="ln1127">    }</a>
<a name="ln1128"> </a>
<a name="ln1129">    if (ifs)</a>
<a name="ln1130">      ifs.close();</a>
<a name="ln1131"> </a>
<a name="ln1132">    return 0;</a>
<a name="ln1133">  }</a>
<a name="ln1134"> </a>
<a name="ln1135">  bool OBForceFieldMMFF94::ParseParamTorsion(std::string &amp;filename)</a>
<a name="ln1136">  {</a>
<a name="ln1137">    vector&lt;string&gt; vs;</a>
<a name="ln1138">    char buffer[80];</a>
<a name="ln1139"> </a>
<a name="ln1140">    OBFFParameter parameter;</a>
<a name="ln1141"> </a>
<a name="ln1142">    // open data/mmfftor.par</a>
<a name="ln1143">    ifstream ifs;</a>
<a name="ln1144">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1145">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmfftor.par&quot;, obError);</a>
<a name="ln1146">      return false;</a>
<a name="ln1147">    }</a>
<a name="ln1148"> </a>
<a name="ln1149">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1150">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1151">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1152"> </a>
<a name="ln1153">      tokenize(vs, buffer);</a>
<a name="ln1154"> </a>
<a name="ln1155">      parameter.clear();</a>
<a name="ln1156">      parameter._ipar.push_back(atoi(vs[0].c_str()));  // FF class</a>
<a name="ln1157">      parameter.a = atoi(vs[1].c_str());</a>
<a name="ln1158">      parameter.b = atoi(vs[2].c_str());</a>
<a name="ln1159">      parameter.c = atoi(vs[3].c_str());</a>
<a name="ln1160">      parameter.d = atoi(vs[4].c_str());</a>
<a name="ln1161">      parameter._dpar.push_back(atof(vs[5].c_str()));  // v1</a>
<a name="ln1162">      parameter._dpar.push_back(atof(vs[6].c_str()));  // v2</a>
<a name="ln1163">      parameter._dpar.push_back(atof(vs[7].c_str()));  // v3</a>
<a name="ln1164">      _fftorsionparams.push_back(parameter);</a>
<a name="ln1165">    }</a>
<a name="ln1166"> </a>
<a name="ln1167">    if (ifs)</a>
<a name="ln1168">      ifs.close();</a>
<a name="ln1169"> </a>
<a name="ln1170">    return 0;</a>
<a name="ln1171">  }</a>
<a name="ln1172"> </a>
<a name="ln1173">  bool OBForceFieldMMFF94::ParseParamVDW(std::string &amp;filename)</a>
<a name="ln1174">  {</a>
<a name="ln1175">    vector&lt;string&gt; vs;</a>
<a name="ln1176">    char buffer[80];</a>
<a name="ln1177"> </a>
<a name="ln1178">    OBFFParameter parameter;</a>
<a name="ln1179"> </a>
<a name="ln1180">    // open data/mmffvdw.par</a>
<a name="ln1181">    ifstream ifs;</a>
<a name="ln1182">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1183">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffvdw.par&quot;, obError);</a>
<a name="ln1184">      return false;</a>
<a name="ln1185">    }</a>
<a name="ln1186"> </a>
<a name="ln1187">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1188">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1189">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1190"> </a>
<a name="ln1191">      tokenize(vs, buffer);</a>
<a name="ln1192"> </a>
<a name="ln1193">      parameter.clear();</a>
<a name="ln1194">      parameter.a = atoi(vs[0].c_str());</a>
<a name="ln1195">      parameter._dpar.push_back(atof(vs[1].c_str()));  // alpha-i</a>
<a name="ln1196">      parameter._dpar.push_back(atof(vs[2].c_str()));  // N-i</a>
<a name="ln1197">      parameter._dpar.push_back(atof(vs[3].c_str()));  // A-i</a>
<a name="ln1198">      parameter._dpar.push_back(atof(vs[4].c_str()));  // G-i</a>
<a name="ln1199">      if (EQn(vs[5].c_str(), &quot;-&quot;, 1))</a>
<a name="ln1200">        parameter._ipar.push_back(0);</a>
<a name="ln1201">      else if (EQn(vs[5].c_str(), &quot;D&quot;, 1))</a>
<a name="ln1202">        parameter._ipar.push_back(1);  // hydrogen bond donor</a>
<a name="ln1203">      else if (EQn(vs[5].c_str(), &quot;A&quot;, 1))</a>
<a name="ln1204">        parameter._ipar.push_back(2);  // hydrogen bond acceptor</a>
<a name="ln1205">      _ffvdwparams.push_back(parameter);</a>
<a name="ln1206">    }</a>
<a name="ln1207"> </a>
<a name="ln1208">    if (ifs)</a>
<a name="ln1209">      ifs.close();</a>
<a name="ln1210"> </a>
<a name="ln1211">    return 0;</a>
<a name="ln1212">  }</a>
<a name="ln1213"> </a>
<a name="ln1214">  bool OBForceFieldMMFF94::ParseParamCharge(std::string &amp;filename)</a>
<a name="ln1215">  {</a>
<a name="ln1216">    vector&lt;string&gt; vs;</a>
<a name="ln1217">    char buffer[80];</a>
<a name="ln1218"> </a>
<a name="ln1219">    OBFFParameter parameter;</a>
<a name="ln1220"> </a>
<a name="ln1221">    // open data/mmffchg.par</a>
<a name="ln1222">    ifstream ifs;</a>
<a name="ln1223">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1224">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffchg.par&quot;, obError);</a>
<a name="ln1225">      return false;</a>
<a name="ln1226">    }</a>
<a name="ln1227"> </a>
<a name="ln1228">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1229">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1230">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1231"> </a>
<a name="ln1232">      tokenize(vs, buffer);</a>
<a name="ln1233"> </a>
<a name="ln1234">      parameter.clear();</a>
<a name="ln1235">      parameter._ipar.push_back(atoi(vs[0].c_str()));  // FF class</a>
<a name="ln1236">      parameter.a = atoi(vs[1].c_str());</a>
<a name="ln1237">      parameter.b = atoi(vs[2].c_str());</a>
<a name="ln1238">      parameter._dpar.push_back(atof(vs[3].c_str()));  // bci</a>
<a name="ln1239">      _ffchgparams.push_back(parameter);</a>
<a name="ln1240">    }</a>
<a name="ln1241"> </a>
<a name="ln1242">    if (ifs)</a>
<a name="ln1243">      ifs.close();</a>
<a name="ln1244"> </a>
<a name="ln1245">    return 0;</a>
<a name="ln1246">  }</a>
<a name="ln1247"> </a>
<a name="ln1248">  bool OBForceFieldMMFF94::ParseParamPbci(std::string &amp;filename)</a>
<a name="ln1249">  {</a>
<a name="ln1250">    vector&lt;string&gt; vs;</a>
<a name="ln1251">    char buffer[80];</a>
<a name="ln1252"> </a>
<a name="ln1253">    OBFFParameter parameter;</a>
<a name="ln1254"> </a>
<a name="ln1255">    // open data/mmffpbci.par</a>
<a name="ln1256">    ifstream ifs;</a>
<a name="ln1257">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1258">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffpbci&quot;, obError);</a>
<a name="ln1259">      return false;</a>
<a name="ln1260">    }</a>
<a name="ln1261"> </a>
<a name="ln1262">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1263">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1264">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1265"> </a>
<a name="ln1266">      tokenize(vs, buffer);</a>
<a name="ln1267"> </a>
<a name="ln1268">      parameter.clear();</a>
<a name="ln1269">      parameter.a = atoi(vs[1].c_str());</a>
<a name="ln1270">      parameter._dpar.push_back(atof(vs[2].c_str()));  // pbci</a>
<a name="ln1271">      parameter._dpar.push_back(atof(vs[3].c_str()));  // fcadj</a>
<a name="ln1272">      _ffpbciparams.push_back(parameter);</a>
<a name="ln1273">    }</a>
<a name="ln1274"> </a>
<a name="ln1275">    if (ifs)</a>
<a name="ln1276">      ifs.close();</a>
<a name="ln1277"> </a>
<a name="ln1278">    return 0;</a>
<a name="ln1279">  }</a>
<a name="ln1280"> </a>
<a name="ln1281">  bool OBForceFieldMMFF94::ParseParamProp(std::string &amp;filename)</a>
<a name="ln1282">  {</a>
<a name="ln1283">    vector&lt;string&gt; vs;</a>
<a name="ln1284">    char buffer[80];</a>
<a name="ln1285"> </a>
<a name="ln1286">    OBFFParameter parameter;</a>
<a name="ln1287"> </a>
<a name="ln1288">    // open data/mmffprop.par</a>
<a name="ln1289">    ifstream ifs;</a>
<a name="ln1290">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1291">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffprop.par&quot;, obError);</a>
<a name="ln1292">      return false;</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1296">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1297">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1298"> </a>
<a name="ln1299">      tokenize(vs, buffer);</a>
<a name="ln1300"> </a>
<a name="ln1301">      parameter.clear();</a>
<a name="ln1302">      parameter.a = atoi(vs[0].c_str()); // atom type</a>
<a name="ln1303">      parameter._ipar.push_back(atoi(vs[1].c_str()));  // at.no</a>
<a name="ln1304">      parameter._ipar.push_back(atoi(vs[2].c_str()));  // crd</a>
<a name="ln1305">      parameter._ipar.push_back(atoi(vs[3].c_str()));  // val</a>
<a name="ln1306">      parameter._ipar.push_back(atoi(vs[4].c_str()));  // pilp</a>
<a name="ln1307">      parameter._ipar.push_back(atoi(vs[5].c_str()));  // mltb</a>
<a name="ln1308">      parameter._ipar.push_back(atoi(vs[6].c_str()));  // arom</a>
<a name="ln1309">      parameter._ipar.push_back(atoi(vs[7].c_str()));  // linh</a>
<a name="ln1310">      parameter._ipar.push_back(atoi(vs[8].c_str()));  // sbmb</a>
<a name="ln1311"> </a>
<a name="ln1312">      if (parameter._ipar[3])</a>
<a name="ln1313">        _ffpropPilp.SetBitOn(parameter.a);</a>
<a name="ln1314">      if (parameter._ipar[5])</a>
<a name="ln1315">        _ffpropArom.SetBitOn(parameter.a);</a>
<a name="ln1316">      if (parameter._ipar[6])</a>
<a name="ln1317">        _ffpropLin.SetBitOn(parameter.a);</a>
<a name="ln1318">      if (parameter._ipar[7])</a>
<a name="ln1319">        _ffpropSbmb.SetBitOn(parameter.a);</a>
<a name="ln1320"> </a>
<a name="ln1321">      _ffpropparams.push_back(parameter);</a>
<a name="ln1322">    }</a>
<a name="ln1323"> </a>
<a name="ln1324">    if (ifs)</a>
<a name="ln1325">      ifs.close();</a>
<a name="ln1326"> </a>
<a name="ln1327">    return 0;</a>
<a name="ln1328">  }</a>
<a name="ln1329"> </a>
<a name="ln1330">  bool OBForceFieldMMFF94::ParseParamDef(std::string &amp;filename)</a>
<a name="ln1331">  {</a>
<a name="ln1332">    vector&lt;string&gt; vs;</a>
<a name="ln1333">    char buffer[80];</a>
<a name="ln1334"> </a>
<a name="ln1335">    OBFFParameter parameter;</a>
<a name="ln1336"> </a>
<a name="ln1337">    // open data/mmffdef.par</a>
<a name="ln1338">    ifstream ifs;</a>
<a name="ln1339">    if (OpenDatafile(ifs, filename).length() == 0) {</a>
<a name="ln1340">      obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot open mmffdef.par&quot;, obError);</a>
<a name="ln1341">      return false;</a>
<a name="ln1342">    }</a>
<a name="ln1343"> </a>
<a name="ln1344">    while (ifs.getline(buffer, 80)) {</a>
<a name="ln1345">      if (EQn(buffer, &quot;*&quot;, 1)) continue;</a>
<a name="ln1346">      if (EQn(buffer, &quot;$&quot;, 1)) continue;</a>
<a name="ln1347"> </a>
<a name="ln1348">      tokenize(vs, buffer);</a>
<a name="ln1349"> </a>
<a name="ln1350">      parameter.clear();</a>
<a name="ln1351">      parameter._ipar.push_back(atoi(vs[1].c_str()));  // level 1</a>
<a name="ln1352">      parameter._ipar.push_back(atoi(vs[2].c_str()));  // level 2</a>
<a name="ln1353">      parameter._ipar.push_back(atoi(vs[3].c_str()));  // level 3</a>
<a name="ln1354">      parameter._ipar.push_back(atoi(vs[4].c_str()));  // level 4</a>
<a name="ln1355">      parameter._ipar.push_back(atoi(vs[5].c_str()));  // level 5</a>
<a name="ln1356">      _ffdefparams.push_back(parameter);</a>
<a name="ln1357">    }</a>
<a name="ln1358"> </a>
<a name="ln1359">    if (ifs)</a>
<a name="ln1360">      ifs.close();</a>
<a name="ln1361"> </a>
<a name="ln1362">    return 0;</a>
<a name="ln1363">  }</a>
<a name="ln1364"> </a>
<a name="ln1365">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1366">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1367">  //</a>
<a name="ln1368">  //  Setup Functions</a>
<a name="ln1369">  //</a>
<a name="ln1370">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1371">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1372"> </a>
<a name="ln1373">  // The MMFF94 article doesn't seem to include information about how</a>
<a name="ln1374">  // aromaticity is perceived. This function was written by studying the</a>
<a name="ln1375">  // MMFF_opti.log file, trail-and-error and using the MMFF94 validation</a>
<a name="ln1376">  // set to check the results (If all atom types are assigned correctly,</a>
<a name="ln1377">  // aromatic rings are probably detected correctly)</a>
<a name="ln1378">  bool OBForceFieldMMFF94::PerceiveAromatic()</a>
<a name="ln1379">  {</a>
<a name="ln1380">    bool done = false; // not done actually....</a>
<a name="ln1381">    OBAtom *ringatom;</a>
<a name="ln1382">    OBBond *ringbond;</a>
<a name="ln1383">    vector&lt;OBRing*&gt; vr;</a>
<a name="ln1384">    vr = _mol.GetSSSR();</a>
<a name="ln1385"> </a>
<a name="ln1386">    vector&lt;OBRing*&gt;::iterator ri;</a>
<a name="ln1387">    vector&lt;int&gt;::iterator rj;</a>
<a name="ln1388">    int n, index, ringsize, first_rj, prev_rj, pi_electrons, c60;</a>
<a name="ln1389">    for (ri = vr.begin();ri != vr.end();++ri) { // for each ring</a>
<a name="ln1390">      ringsize = (*ri)-&gt;Size();</a>
<a name="ln1391"> </a>
<a name="ln1392">      n = 1;</a>
<a name="ln1393">      pi_electrons = 0;</a>
<a name="ln1394">      c60 = 0; // we have a special case to get c60 right (all atom type 37)</a>
<a name="ln1395">      for(rj = (*ri)-&gt;_path.begin();rj != (*ri)-&gt;_path.end();++rj) { // for each ring atom</a>
<a name="ln1396">        index = *rj;</a>
<a name="ln1397">        ringatom = _mol.GetAtom(index);</a>
<a name="ln1398"> </a>
<a name="ln1399">        // is the bond to the previous ring atom double?</a>
<a name="ln1400">        if (n &gt; 1) {</a>
<a name="ln1401">          ringbond = _mol.GetBond(prev_rj, index);</a>
<a name="ln1402">          if (!ringbond) {</a>
<a name="ln1403">            prev_rj = index;</a>
<a name="ln1404">            continue;</a>
<a name="ln1405">          }</a>
<a name="ln1406">          if (ringbond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1407">            pi_electrons += 2;</a>
<a name="ln1408">            prev_rj = index;</a>
<a name="ln1409">            n++;</a>
<a name="ln1410">            continue;</a>
<a name="ln1411">          }</a>
<a name="ln1412">          prev_rj = index;</a>
<a name="ln1413">        } else {</a>
<a name="ln1414">          prev_rj = index;</a>
<a name="ln1415">          first_rj = index;</a>
<a name="ln1416">        }</a>
<a name="ln1417"> </a>
<a name="ln1418">        // does the current ring atom have a exocyclic double bond?</a>
<a name="ln1419">        FOR_NBORS_OF_ATOM (nbr, ringatom) {</a>
<a name="ln1420">          if ((*ri)-&gt;IsInRing(nbr-&gt;GetIdx()))</a>
<a name="ln1421">            continue;</a>
<a name="ln1422"> </a>
<a name="ln1423">          if (!nbr-&gt;IsAromatic()) {</a>
<a name="ln1424">            if (ringatom-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; ringatom-&gt;IsInRingSize(5)</a>
<a name="ln1425">                &amp;&amp; ringatom-&gt;IsInRingSize(6) &amp;&amp; nbr-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; nbr-&gt;IsInRingSize(5)</a>
<a name="ln1426">                &amp;&amp; nbr-&gt;IsInRingSize(6)) {</a>
<a name="ln1427">              c60++;</a>
<a name="ln1428">            } else {</a>
<a name="ln1429">              continue;</a>
<a name="ln1430">            }</a>
<a name="ln1431">          }</a>
<a name="ln1432"> </a>
<a name="ln1433">          ringbond = _mol.GetBond(nbr-&gt;GetIdx(), index);</a>
<a name="ln1434">          if (!ringbond) {</a>
<a name="ln1435">            continue;</a>
<a name="ln1436">          }</a>
<a name="ln1437">          if (ringbond-&gt;GetBondOrder() == 2)</a>
<a name="ln1438">            pi_electrons++;</a>
<a name="ln1439">        }</a>
<a name="ln1440"> </a>
<a name="ln1441">        // is the atom N, O or S in 5 rings</a>
<a name="ln1442">        if (ringsize == 5 &amp;&amp;</a>
<a name="ln1443">            ringatom-&gt;GetIdx() == (*ri)-&gt;GetRootAtom())</a>
<a name="ln1444">          pi_electrons += 2;</a>
<a name="ln1445"> </a>
<a name="ln1446">        n++;</a>
<a name="ln1447"> </a>
<a name="ln1448">      } // for each ring atom</a>
<a name="ln1449"> </a>
<a name="ln1450">      // is the bond from the first to the last atom double?</a>
<a name="ln1451">      ringbond = _mol.GetBond(first_rj, index);</a>
<a name="ln1452">      if (ringbond) {</a>
<a name="ln1453">        if (ringbond-&gt;GetBondOrder() == 2)</a>
<a name="ln1454">          pi_electrons += 2;</a>
<a name="ln1455">      }</a>
<a name="ln1456"> </a>
<a name="ln1457">      if (((pi_electrons == 6) &amp;&amp; ((ringsize == 5) || (ringsize == 6)))</a>
<a name="ln1458">        || ((pi_electrons == 5) &amp;&amp; (c60 == 5))) {</a>
<a name="ln1459">        // mark ring atoms as aromatic</a>
<a name="ln1460">        for(rj = (*ri)-&gt;_path.begin();rj != (*ri)-&gt;_path.end();++rj) {</a>
<a name="ln1461">          if (!_mol.GetAtom(*rj)-&gt;IsAromatic())</a>
<a name="ln1462">            done = true;</a>
<a name="ln1463">          _mol.GetAtom(*rj)-&gt;SetAromatic();</a>
<a name="ln1464">        }</a>
<a name="ln1465">        // mark all ring bonds as aromatic</a>
<a name="ln1466">        FOR_BONDS_OF_MOL (bond, _mol)</a>
<a name="ln1467">          if((*ri)-&gt;IsMember(&amp;*bond))</a>
<a name="ln1468">            bond-&gt;SetAromatic();</a>
<a name="ln1469">      }</a>
<a name="ln1470">    }</a>
<a name="ln1471"> </a>
<a name="ln1472">    return done;</a>
<a name="ln1473">  }</a>
<a name="ln1474"> </a>
<a name="ln1475">  // Symbolic atom typing is skipped</a>
<a name="ln1476">  //</a>
<a name="ln1477">  // atom typing is based on:</a>
<a name="ln1478">  //   MMFF94 I - Table III</a>
<a name="ln1479">  //   MMFF94 V - Table I</a>
<a name="ln1480">  //</a>
<a name="ln1481">  int OBForceFieldMMFF94::GetType(OBAtom *atom)</a>
<a name="ln1482">  {</a>
<a name="ln1483">    OBBond *bond;</a>
<a name="ln1484">    int oxygenCount, nitrogenCount, sulphurCount, doubleBondTo;</a>
<a name="ln1485">    ////////////////////////////////</a>
<a name="ln1486">    // Aromatic Atoms</a>
<a name="ln1487">    ////////////////////////////////</a>
<a name="ln1488">    if (atom-&gt;IsAromatic()) {</a>
<a name="ln1489">      if (atom-&gt;IsInRingSize(5)) {</a>
<a name="ln1490">        bool IsAromatic = false;</a>
<a name="ln1491">        vector&lt;OBAtom*&gt; alphaPos, betaPos;</a>
<a name="ln1492">        vector&lt;OBAtom*&gt; alphaAtoms, betaAtoms;</a>
<a name="ln1493"> </a>
<a name="ln1494">        if (atom-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1495">          return 44; // Aromatic 5-ring sulfur with pi lone pair (STHI)</a>
<a name="ln1496">        }</a>
<a name="ln1497">        if (atom-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1498">          return 59; // Aromatic 5-ring oxygen with pi lone pair (OFUR)</a>
<a name="ln1499">        }</a>
<a name="ln1500">        if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1501">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1502">            if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1503">              return 82; // N-oxide nitrogen in 5-ring alpha position,</a>
<a name="ln1504">              // N-oxide nitrogen in 5-ring beta position,</a>
<a name="ln1505">              // N-oxide nitrogen in other 5-ring  position,</a>
<a name="ln1506">              // (N5AX, N5BX, N5OX)</a>
<a name="ln1507">            }</a>
<a name="ln1508">          }</a>
<a name="ln1509">        }</a>
<a name="ln1510">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1511">          if (!((_mol.GetBond(atom, &amp;*nbr))-&gt;IsAromatic()) || !nbr-&gt;IsInRingSize(5))</a>
<a name="ln1512">            continue;</a>
<a name="ln1513"> </a>
<a name="ln1514">          if (IsInSameRing(atom, &amp;*nbr)) {</a>
<a name="ln1515">            alphaPos.push_back(&amp;*nbr);</a>
<a name="ln1516">          }</a>
<a name="ln1517"> </a>
<a name="ln1518">          FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln1519">            if (nbrNbr-&gt;GetIdx() == atom-&gt;GetIdx())</a>
<a name="ln1520">              continue;</a>
<a name="ln1521">            if (!((_mol.GetBond(&amp;*nbr, &amp;*nbrNbr))-&gt;IsAromatic()) || !nbrNbr-&gt;IsInRingSize(5))</a>
<a name="ln1522">              continue;</a>
<a name="ln1523"> </a>
<a name="ln1524">            IsAromatic = true;</a>
<a name="ln1525"> </a>
<a name="ln1526">            if (IsInSameRing(atom, &amp;*nbrNbr)) {</a>
<a name="ln1527">              betaPos.push_back(&amp;*nbrNbr);</a>
<a name="ln1528">            }</a>
<a name="ln1529">          }</a>
<a name="ln1530">        }</a>
<a name="ln1531"> </a>
<a name="ln1532">        if (IsAromatic) {</a>
<a name="ln1533"> </a>
<a name="ln1534"> </a>
<a name="ln1535">          for (unsigned int i = 0; i &lt; alphaPos.size(); i++) {</a>
<a name="ln1536">            if (alphaPos[i]-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1537">              alphaAtoms.push_back(alphaPos[i]);</a>
<a name="ln1538">            } else if (alphaPos[i]-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1539">              alphaAtoms.push_back(alphaPos[i]);</a>
<a name="ln1540">            } else if (alphaPos[i]-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (alphaPos[i]-&gt;GetExplicitDegree() == 3)) {</a>
<a name="ln1541">              bool IsNOxide = false;</a>
<a name="ln1542">              FOR_NBORS_OF_ATOM (nbr, alphaPos[i]) {</a>
<a name="ln1543">                if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1544">                  IsNOxide = true;</a>
<a name="ln1545">                }</a>
<a name="ln1546">              }</a>
<a name="ln1547"> </a>
<a name="ln1548">              if (!IsNOxide) {</a>
<a name="ln1549">                alphaAtoms.push_back(alphaPos[i]);</a>
<a name="ln1550">              }</a>
<a name="ln1551">            }</a>
<a name="ln1552">          }</a>
<a name="ln1553">          for (unsigned int i = 0; i &lt; betaPos.size(); i++) {</a>
<a name="ln1554">            if (betaPos[i]-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1555">              betaAtoms.push_back(betaPos[i]);</a>
<a name="ln1556">            } else if (betaPos[i]-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1557">              betaAtoms.push_back(betaPos[i]);</a>
<a name="ln1558">            } else if (betaPos[i]-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (betaPos[i]-&gt;GetExplicitDegree() == 3)) {</a>
<a name="ln1559">              bool IsNOxide = false;</a>
<a name="ln1560">              FOR_NBORS_OF_ATOM (nbr, betaPos[i]) {</a>
<a name="ln1561">                if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1562">                  IsNOxide = true;</a>
<a name="ln1563">                }</a>
<a name="ln1564">              }</a>
<a name="ln1565"> </a>
<a name="ln1566">              if (!IsNOxide) {</a>
<a name="ln1567">                betaAtoms.push_back(betaPos[i]);</a>
<a name="ln1568">              }</a>
<a name="ln1569">            }</a>
<a name="ln1570">          }</a>
<a name="ln1571">          if (!betaAtoms.size()) {</a>
<a name="ln1572">            nitrogenCount = 0;</a>
<a name="ln1573">            FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1574">              if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 3)) {</a>
<a name="ln1575">                if ((nbr-&gt;GetExplicitValence() == 4) &amp;&amp; nbr-&gt;IsAromatic()) {</a>
<a name="ln1576">                  nitrogenCount++;</a>
<a name="ln1577">                } else if ((nbr-&gt;GetExplicitValence() == 3) &amp;&amp; !nbr-&gt;IsAromatic()) {</a>
<a name="ln1578">                  nitrogenCount++;</a>
<a name="ln1579">                }</a>
<a name="ln1580">              }</a>
<a name="ln1581">            }</a>
<a name="ln1582">            if (nitrogenCount &gt;= 2) {</a>
<a name="ln1583">              return 80; // Aromatic carbon between N's in imidazolium (CIM+)</a>
<a name="ln1584">            }</a>
<a name="ln1585">          }</a>
<a name="ln1586">          if (!alphaAtoms.size() &amp;&amp; !betaAtoms.size()) {</a>
<a name="ln1587">            if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1588">              bool c60 = true; // special case to ensure c60 is typed correctly -- Paolo Tosco</a>
<a name="ln1589">              FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1590">                if (!(nbr-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; nbr-&gt;IsAromatic() &amp;&amp; nbr-&gt;IsInRingSize(6)))</a>
<a name="ln1591">                  c60 = false;</a>
<a name="ln1592">              }</a>
<a name="ln1593">              if (c60)</a>
<a name="ln1594">                return 37; // correct atom type for c in c60 (all atoms symmetric)</a>
<a name="ln1595">              // there is no S:, O:, or N:</a>
<a name="ln1596">              // this is the case for anions with only carbon and nitrogen in the ring</a>
<a name="ln1597">              return 78; // General carbon in 5-membered aromatic ring (C5)</a>
<a name="ln1598">            } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1599">              if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1600">                // this is the N: atom</a>
<a name="ln1601">                return 39; // Aromatic 5 ring nitrogen with pi lone pair (NPYL)</a>
<a name="ln1602">              } else {</a>
<a name="ln1603">                // again, no S:, O:, or N:</a>
<a name="ln1604">                return 76; // Nitrogen in 5-ring aromatic anion (N5M)</a>
<a name="ln1605">              }</a>
<a name="ln1606">            }</a>
<a name="ln1607">          }</a>
<a name="ln1608">          if (alphaAtoms.size() == 2) {</a>
<a name="ln1609">            if (atom-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; IsInSameRing(alphaAtoms[0], alphaAtoms[1])) {</a>
<a name="ln1610">              if (alphaAtoms[0]-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; alphaAtoms[1]-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1611">                if ((alphaAtoms[0]-&gt;GetExplicitDegree() == 3) &amp;&amp; (alphaAtoms[1]-&gt;GetExplicitDegree() == 3)) {</a>
<a name="ln1612">                  return 80; // Aromatic carbon between N's in imidazolium (CIM+)</a>
<a name="ln1613">                }</a>
<a name="ln1614">              }</a>
<a name="ln1615">            }</a>
<a name="ln1616">          }</a>
<a name="ln1617">          if (alphaAtoms.size() &amp;&amp; !betaAtoms.size()) {</a>
<a name="ln1618">            if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1619">              return 63; // Aromatic 5-ring C, alpha to N:, O:, or S: (C5A)</a>
<a name="ln1620">            } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1621">              if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1622">                return 81; // Posivite nitrogen in 5-ring alpha position (N5A+)</a>
<a name="ln1623">              } else {</a>
<a name="ln1624">                return 65; // Aromatic 5-ring N, alpha to N:, O:, or S: (N5A)</a>
<a name="ln1625">              }</a>
<a name="ln1626">            }</a>
<a name="ln1627">          }</a>
<a name="ln1628">          if (!alphaAtoms.size() &amp;&amp; betaAtoms.size()) {</a>
<a name="ln1629">            if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1630">              return 64; // Aromatic 5-ring C, beta to N:, O:, or S: (C5B)</a>
<a name="ln1631">            } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1632">              if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1633">                return 81; // Posivite nitrogen in 5-ring beta position (N5B+)</a>
<a name="ln1634">              } else {</a>
<a name="ln1635">                return 66; // Aromatic 5-ring N, beta to N:, O:, or S: (N5B)</a>
<a name="ln1636">              }</a>
<a name="ln1637">            }</a>
<a name="ln1638">          }</a>
<a name="ln1639">          if (alphaAtoms.size() &amp;&amp; betaAtoms.size()) {</a>
<a name="ln1640">            for (unsigned int i = 0; i &lt; alphaAtoms.size(); i++) {</a>
<a name="ln1641">              for (unsigned int j = 0; j &lt; betaAtoms.size(); j++) {</a>
<a name="ln1642">                if (!IsInSameRing(alphaAtoms[i], betaAtoms[j])) {</a>
<a name="ln1643">                  if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1644">                    return 78; // General carbon in 5-membered aromatic ring (C5)</a>
<a name="ln1645">                  } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1646">                    return 79; // General nitrogen in 5-membered aromatic ring (N5)</a>
<a name="ln1647">                  }</a>
<a name="ln1648">                }</a>
<a name="ln1649">              }</a>
<a name="ln1650">            }</a>
<a name="ln1651">            for (unsigned int i = 0; i &lt; alphaAtoms.size(); i++) {</a>
<a name="ln1652">              if (alphaAtoms[i]-&gt;GetAtomicNum() == OBElements::Sulfur || alphaAtoms[i]-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1653">                if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1654">                  return 63; // Aromatic 5-ring C, alpha to N:, O:, or S: (C5A)</a>
<a name="ln1655">                } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1656">                  return 65; // Aromatic 5-ring N, alpha to N:, O:, or S: (N5A)</a>
<a name="ln1657">                }</a>
<a name="ln1658">              }</a>
<a name="ln1659">            }</a>
<a name="ln1660">            for (unsigned int i = 0; i &lt; betaAtoms.size(); i++) {</a>
<a name="ln1661">              if (betaAtoms[i]-&gt;GetAtomicNum() == OBElements::Sulfur || betaAtoms[i]-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1662">                if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1663">                  return 64; // Aromatic 5-ring C, beta to N:, O:, or S: (C5B)</a>
<a name="ln1664">                } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1665">                  return 66; // Aromatic 5-ring N, beta to N:, O:, or S: (N5B)</a>
<a name="ln1666">                }</a>
<a name="ln1667">              }</a>
<a name="ln1668">            }</a>
<a name="ln1669"> </a>
<a name="ln1670">            if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1671">              return 78; // General carbon in 5-membered aromatic ring (C5)</a>
<a name="ln1672">            } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1673">              return 79; // General nitrogen in 5-membered aromatic ring (N5)</a>
<a name="ln1674">            }</a>
<a name="ln1675">          }</a>
<a name="ln1676">        }</a>
<a name="ln1677">      }</a>
<a name="ln1678"> </a>
<a name="ln1679">      if (atom-&gt;IsInRingSize(6)) {</a>
<a name="ln1680"> </a>
<a name="ln1681">        if (atom-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1682">          return 37; // Aromatic carbon, e.g., in benzene (CB)</a>
<a name="ln1683">        } else if (atom-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1684">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1685">            if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1686">              return 69; // Pyridinium N-oxide nitrogen (NPOX)</a>
<a name="ln1687">            }</a>
<a name="ln1688">          }</a>
<a name="ln1689"> </a>
<a name="ln1690">          if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1691">            return 58; // Aromatic nitrogen in pyridinium (NPD+)</a>
<a name="ln1692">          } else {</a>
<a name="ln1693">            return 38; // Aromatic nitrogen with sigma lone pair (NPYD)</a>
<a name="ln1694">          }</a>
<a name="ln1695">        }</a>
<a name="ln1696">      }</a>
<a name="ln1697">    }</a>
<a name="ln1698"> </a>
<a name="ln1699">    ////////////////////////////////</a>
<a name="ln1700">    // Hydrogen</a>
<a name="ln1701">    ////////////////////////////////</a>
<a name="ln1702">    if (atom-&gt;GetAtomicNum() == 1) {</a>
<a name="ln1703">      FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1704">        if (nbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1705">          return 5; // Hydrogen attatched to carbon (HC)</a>
<a name="ln1706">        }</a>
<a name="ln1707">        if (nbr-&gt;GetAtomicNum() == 14) {</a>
<a name="ln1708">          return 5; // Hydrogen attatched to silicon (HSI)</a>
<a name="ln1709">        }</a>
<a name="ln1710">        if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1711">          if (nbr-&gt;GetExplicitValence() == 3) {</a>
<a name="ln1712">            if (nbr-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1713">              return 50; // Hydrogen on oxonium oxygen (HO+)</a>
<a name="ln1714">            } else {</a>
<a name="ln1715">              return 52; // Hydrogen on oxenium oxygen (HO=+)</a>
<a name="ln1716">            }</a>
<a name="ln1717">          }</a>
<a name="ln1718"> </a>
<a name="ln1719">          int hydrogenCount = 0;</a>
<a name="ln1720">          FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln1721">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Hydrogen) {</a>
<a name="ln1722">              hydrogenCount++;</a>
<a name="ln1723">              continue;</a>
<a name="ln1724">            }</a>
<a name="ln1725">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1726">              if (nbrNbr-&gt;IsAromatic()) {</a>
<a name="ln1727">                return 29; // phenol</a>
<a name="ln1728">              }</a>
<a name="ln1729"> </a>
<a name="ln1730">              FOR_NBORS_OF_ATOM (nbrNbrNbr, &amp;*nbrNbr) {</a>
<a name="ln1731">                if (nbrNbrNbr-&gt;GetIdx() == nbr-&gt;GetIdx())</a>
<a name="ln1732">                  continue;</a>
<a name="ln1733"> </a>
<a name="ln1734">                bond = _mol.GetBond(&amp;*nbrNbr, &amp;*nbrNbrNbr);</a>
<a name="ln1735">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1736">                  if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1737">                    return 24; // Hydroxyl hydrogen in carboxylic acids (HOCO)</a>
<a name="ln1738">                  }</a>
<a name="ln1739">                  if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Carbon || nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1740">                    return 29; // Enolic or phenolic hydroxyl hydrogen,</a>
<a name="ln1741">                    // Hydroxyl hydrogen in HO-C=N moiety (HOCC, HOCN)</a>
<a name="ln1742">                  }</a>
<a name="ln1743">                }</a>
<a name="ln1744">              }</a>
<a name="ln1745">            }</a>
<a name="ln1746">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Phosphorus) {</a>
<a name="ln1747">              return 24; // Hydroxyl hydrogen in H-O-P moiety (HOP)</a>
<a name="ln1748">            }</a>
<a name="ln1749">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1750">              return 33; // Hydrogen on oxygen attached to sulfur (HOS)</a>
<a name="ln1751">            }</a>
<a name="ln1752"> </a>
<a name="ln1753">          }</a>
<a name="ln1754">          if (hydrogenCount == 2) {</a>
<a name="ln1755">            return 31; // Hydroxyl hydrogen in water (HOH)</a>
<a name="ln1756">          }</a>
<a name="ln1757"> </a>
<a name="ln1758">          return 21; // Hydroxyl hydrogen in alcohols, Generic hydroxyl hydrogen (HOR, HO)</a>
<a name="ln1759">        }</a>
<a name="ln1760">        if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1761">          switch (GetType(&amp;*nbr)) {</a>
<a name="ln1762">          case 81:</a>
<a name="ln1763">            return 36; // Hydrogen on imidazolium nitrogen (HIM+)</a>
<a name="ln1764">          case 68:</a>
<a name="ln1765">            return 23; // Hydrogen on N in N-oxide (HNOX)</a>
<a name="ln1766">          case 67:</a>
<a name="ln1767">            return 23; // Hydrogen on N in N-oxide (HNOX)</a>
<a name="ln1768">          case 62:</a>
<a name="ln1769">            return 23; // Generic hydrogen on sp3 nitrogen, e.g., in amines (HNR)</a>
<a name="ln1770">          case 56:</a>
<a name="ln1771">            return 36; // Hydrogen on guanimdinium nitrogen (HGD+)</a>
<a name="ln1772">          case 55:</a>
<a name="ln1773">            return 36; // Hydrogen on amidinium nitrogen (HNN+)</a>
<a name="ln1774">          case 43:</a>
<a name="ln1775">            return 28; // Hydrogen on NSO, NSO2, or NSO3 nitrogen, Hydrogen on N triply bonded to C (HNSO, HNC%)</a>
<a name="ln1776">          case 39:</a>
<a name="ln1777">            return 23; // Hydrogen on nitrogen in pyrrole (HPYL)</a>
<a name="ln1778">          case 8:</a>
<a name="ln1779">            return 23; // Generic hydrogen on sp3 nitrogen, e.g., in amines, Hydrogen on nitrogen in ammonia (HNR, H3N)</a>
<a name="ln1780">          }</a>
<a name="ln1781"> </a>
<a name="ln1782">          if (nbr-&gt;GetExplicitValence() == 4) {</a>
<a name="ln1783">            if (nbr-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln1784">              return 28; // Hydrogen on N triply bonded to C (HNC%)</a>
<a name="ln1785">            } else {</a>
<a name="ln1786">              return 36; // Hydrogen on pyridinium nitrogen, Hydrogen on protonated imine nitrogen (HPD+, HNC+)</a>
<a name="ln1787">            }</a>
<a name="ln1788">          }</a>
<a name="ln1789"> </a>
<a name="ln1790">          if (nbr-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln1791">            FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln1792">              if (nbrNbr-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln1793">                continue;</a>
<a name="ln1794"> </a>
<a name="ln1795">              bond = _mol.GetBond(&amp;*nbr, &amp;*nbrNbr);</a>
<a name="ln1796">              if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1797">                if (nbrNbr-&gt;GetAtomicNum() == OBElements::Carbon || nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1798">                  return 27; // Hydrogen on imine nitrogen, Hydrogen on azo nitrogen (HN=C, HN=N)</a>
<a name="ln1799">                }</a>
<a name="ln1800"> </a>
<a name="ln1801">                return 28; // Generic hydrogen on sp2 nitrogen (HSP2)</a>
<a name="ln1802">              }</a>
<a name="ln1803">            }</a>
<a name="ln1804">          }</a>
<a name="ln1805"> </a>
<a name="ln1806">          FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln1807">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln1808">              continue;</a>
<a name="ln1809"> </a>
<a name="ln1810">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1811">              if (nbrNbr-&gt;IsAromatic()) {</a>
<a name="ln1812">                return 28; // deloc. lp pair</a>
<a name="ln1813">              }</a>
<a name="ln1814"> </a>
<a name="ln1815">              FOR_NBORS_OF_ATOM (nbrNbrNbr, &amp;*nbrNbr) {</a>
<a name="ln1816">                if (nbrNbrNbr-&gt;GetIdx() == nbr-&gt;GetIdx())</a>
<a name="ln1817">                  continue;</a>
<a name="ln1818"> </a>
<a name="ln1819">                bond = _mol.GetBond(&amp;*nbrNbr, &amp;*nbrNbrNbr);</a>
<a name="ln1820">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1821">                  if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Carbon || nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen || nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen || nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1822">                    return 28; // Hydrogen on amide nitrogen, Hydrogen on thioamide nitrogen,</a>
<a name="ln1823">                    // Hydrogen on enamine nitrogen, Hydrogen in H-N-C=N moiety (HNCO, HNCS, HNCC, HNCN)</a>
<a name="ln1824">                  }</a>
<a name="ln1825">                }</a>
<a name="ln1826">              }</a>
<a name="ln1827">            }</a>
<a name="ln1828">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1829">              FOR_NBORS_OF_ATOM (nbrNbrNbr, &amp;*nbrNbr) {</a>
<a name="ln1830">                if (nbrNbrNbr-&gt;GetIdx() == nbr-&gt;GetIdx())</a>
<a name="ln1831">                  continue;</a>
<a name="ln1832"> </a>
<a name="ln1833">                bond = _mol.GetBond(&amp;*nbrNbr, &amp;*nbrNbrNbr);</a>
<a name="ln1834">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1835">                  if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Carbon || nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1836">                    return 28; // Hydrogen in H-N-N=C moiety, Hydrogen in H-N-N=N moiety (HNNC, HNNN)</a>
<a name="ln1837">                  }</a>
<a name="ln1838">                }</a>
<a name="ln1839">              }</a>
<a name="ln1840">            }</a>
<a name="ln1841">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1842">              FOR_NBORS_OF_ATOM (nbrNbrNbr, &amp;*nbrNbr) {</a>
<a name="ln1843">                if (nbrNbrNbr-&gt;GetIdx() == nbr-&gt;GetIdx())</a>
<a name="ln1844">                  continue;</a>
<a name="ln1845"> </a>
<a name="ln1846">                if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen || (nbrNbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1847">                  return 28; // Hydrogen on NSO, NSO2 or NSO3 nitrogen (HNSO)</a>
<a name="ln1848">                }</a>
<a name="ln1849">              }</a>
<a name="ln1850">            }</a>
<a name="ln1851">          }</a>
<a name="ln1852"> </a>
<a name="ln1853">          return 23; // Generic hydrogen on sp3 nitrogen e.g., in amines,</a>
<a name="ln1854">          // Hydrogen on nitrogen in pyrrole, Hydrogen in ammonia,</a>
<a name="ln1855">          // Hydrogen on N in N-oxide (HNR, HPYL, H3N, HNOX)</a>
<a name="ln1856">        }</a>
<a name="ln1857">        if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur || nbr-&gt;GetAtomicNum() == OBElements::Phosphorus) {</a>
<a name="ln1858">          return 71; // Hydrogen attached to sulfur, Hydrogen attached to &gt;S= sulfur doubly bonded to N,</a>
<a name="ln1859">          // Hydrogen attached to phosphorus (HS, HS=N, HP)</a>
<a name="ln1860">        }</a>
<a name="ln1861">      }</a>
<a name="ln1862">    }</a>
<a name="ln1863"> </a>
<a name="ln1864">    ////////////////////////////////</a>
<a name="ln1865">    // Lithium</a>
<a name="ln1866">    ////////////////////////////////</a>
<a name="ln1867">    if (atom-&gt;GetAtomicNum() == 3) {</a>
<a name="ln1868">      // 0 neighbours</a>
<a name="ln1869">      if (atom-&gt;GetExplicitDegree() == 0) {</a>
<a name="ln1870">        return 92; // Lithium cation (LI+)</a>
<a name="ln1871">      }</a>
<a name="ln1872">    }</a>
<a name="ln1873"> </a>
<a name="ln1874">    ////////////////////////////////</a>
<a name="ln1875">    // Carbon</a>
<a name="ln1876">    ////////////////////////////////</a>
<a name="ln1877">    if (atom-&gt;GetAtomicNum() == 6) {</a>
<a name="ln1878">      // 4 neighbours</a>
<a name="ln1879">      if (atom-&gt;GetExplicitDegree() == 4) {</a>
<a name="ln1880">        if (atom-&gt;IsInRingSize(3)) {</a>
<a name="ln1881">          return 22; // Aliphatic carbon in 3-membered ring (CR3R)</a>
<a name="ln1882">        }</a>
<a name="ln1883"> </a>
<a name="ln1884">        if (atom-&gt;IsInRingSize(4)) {</a>
<a name="ln1885">          return 20; // Aliphatic carbon in 4-membered ring (CR4R)</a>
<a name="ln1886">        }</a>
<a name="ln1887"> </a>
<a name="ln1888">        return 1; // Alkyl carbon (CR)</a>
<a name="ln1889">      }</a>
<a name="ln1890">      // 3 neighbours</a>
<a name="ln1891">      if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1892">        int N2count = 0;</a>
<a name="ln1893">        int N3count = 0;</a>
<a name="ln1894">        int N3fcharge = 0;</a>
<a name="ln1895">        oxygenCount = sulphurCount = doubleBondTo = 0;</a>
<a name="ln1896"> </a>
<a name="ln1897">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1898">          bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln1899">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1900">            doubleBondTo = nbr-&gt;GetAtomicNum();</a>
<a name="ln1901">          }</a>
<a name="ln1902"> </a>
<a name="ln1903">          if (nbr-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln1904">            if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln1905">              oxygenCount++;</a>
<a name="ln1906">            } else if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln1907">              sulphurCount++;</a>
<a name="ln1908">            }</a>
<a name="ln1909">          } else if (nbr-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1910">            if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1911">              N3fcharge += nbr-&gt;GetFormalCharge();</a>
<a name="ln1912">              N3count++;</a>
<a name="ln1913">            }</a>
<a name="ln1914">          } else if ((nbr-&gt;GetExplicitDegree() == 2) &amp;&amp; !bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1915">            if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1916">              N2count++;</a>
<a name="ln1917">            }</a>
<a name="ln1918">          }</a>
<a name="ln1919">        }</a>
<a name="ln1920">        if ((N3count &gt;= 2) &amp;&amp; (doubleBondTo == 7 || (!(doubleBondTo == 6) &amp;&amp; atom-&gt;GetExplicitDegree() == 3</a>
<a name="ln1921">          &amp;&amp; N3fcharge == 1)) &amp;&amp; !N2count &amp;&amp; !oxygenCount &amp;&amp; !sulphurCount) {</a>
<a name="ln1922">          // N3==C--N3</a>
<a name="ln1923">          return 57; // Guanidinium carbon, Carbon in +N=C-N: resonance structures (CGD+, CNN+)</a>
<a name="ln1924">        }</a>
<a name="ln1925">        if ((oxygenCount == 2) || (sulphurCount == 2)) {</a>
<a name="ln1926">          // O1-?-C-?-O1 or S1-?-C-?-S1</a>
<a name="ln1927">          return 41; // Carbon in carboxylate anion, Carbon in thiocarboxylate anion (CO2M, CS2M)</a>
<a name="ln1928">        }</a>
<a name="ln1929">        if (atom-&gt;IsInRingSize(4) &amp;&amp; (doubleBondTo == 6)) {</a>
<a name="ln1930">	        return 30; // Olefinic carbon in 4-membered ring (CR4E)</a>
<a name="ln1931">        }</a>
<a name="ln1932">        if ((doubleBondTo ==  7) || (doubleBondTo ==  8) ||</a>
<a name="ln1933">            (doubleBondTo == 15) || (doubleBondTo == 16)) {</a>
<a name="ln1934">          // C==N, C==O, C==P, C==S</a>
<a name="ln1935">          return 3; // Generic carbonyl carbon, Imine-type carbon, Guanidine carbon,</a>
<a name="ln1936">          // Ketone or aldehyde carbonyl carbon, Amide carbonyl carbon,</a>
<a name="ln1937">          // Carboxylic acid or ester carbonyl carbon, Carbamate carbonyl carbon,</a>
<a name="ln1938">          // Carbonic acid or ester carbonyl carbon, Thioester carbonyl (double</a>
<a name="ln1939">          // bonded to O or S), Thioamide carbon (double bonded to S), Carbon</a>
<a name="ln1940">          // in &gt;C=SO2, Sulfinyl carbon in &gt;C=S=O, Thiocarboxylic acid or ester</a>
<a name="ln1941">          // carbon, Carbon doubly bonded to P (C=O, C=N, CGD, C=OR, C=ON, COO,</a>
<a name="ln1942">          // COON, COOO, C=OS, C=S, C=SN, CSO2, CS=O, CSS, C=P)</a>
<a name="ln1943">        }</a>
<a name="ln1944"> </a>
<a name="ln1945">        return 2; // Vinylic Carbon, Generic sp2 carbon (C=C, CSP2)</a>
<a name="ln1946"> </a>
<a name="ln1947">      }</a>
<a name="ln1948">      // 2 neighbours</a>
<a name="ln1949">      if (atom-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln1950">        return 4; // Acetylenic carbon, Allenic caron (CSP, =C=)</a>
<a name="ln1951">      }</a>
<a name="ln1952">      // 1 neighbours</a>
<a name="ln1953">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln1954">        return 60; // Isonitrile carbon (C%-)</a>
<a name="ln1955">      }</a>
<a name="ln1956">    }</a>
<a name="ln1957"> </a>
<a name="ln1958">    ////////////////////////////////</a>
<a name="ln1959">    // Nitrogen</a>
<a name="ln1960">    ////////////////////////////////</a>
<a name="ln1961">    if (atom-&gt;GetAtomicNum() == 7) {</a>
<a name="ln1962">      // 4 neighbours</a>
<a name="ln1963">      if (atom-&gt;GetExplicitDegree() == 4) {</a>
<a name="ln1964">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1965">          if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1966">            return 68; // sp3-hybridized N-oxide nitrogen (N3OX)</a>
<a name="ln1967">          }</a>
<a name="ln1968">        }</a>
<a name="ln1969"> </a>
<a name="ln1970">        return 34; // Quaternary nitrogen (NR+)</a>
<a name="ln1971">      }</a>
<a name="ln1972">      // 3 neighbours</a>
<a name="ln1973">      if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln1974">        if (atom-&gt;GetExplicitValence() &gt;= 4) { // &gt; because we accept -N(=O)=O as a valid nitro group</a>
<a name="ln1975">          oxygenCount = nitrogenCount = doubleBondTo = 0;</a>
<a name="ln1976"> </a>
<a name="ln1977">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln1978">            if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln1979">              oxygenCount++;</a>
<a name="ln1980">            }</a>
<a name="ln1981">            if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln1982">              bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln1983">              if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1984">                doubleBondTo = 7;</a>
<a name="ln1985">              }</a>
<a name="ln1986">            }</a>
<a name="ln1987">            if (nbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln1988">              bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln1989">              if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln1990">                FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln1991">                  if (nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 3)) {</a>
<a name="ln1992">                    nitrogenCount++;</a>
<a name="ln1993">                  }</a>
<a name="ln1994">                }</a>
<a name="ln1995">              }</a>
<a name="ln1996">            }</a>
<a name="ln1997">          }</a>
<a name="ln1998"> </a>
<a name="ln1999">          if (oxygenCount == 1) {</a>
<a name="ln2000">            return 67; // sp2-hybridized N-oxide nitrogen (N2OX)</a>
<a name="ln2001">          }</a>
<a name="ln2002">          if (oxygenCount &gt;= 2) {</a>
<a name="ln2003">            return 45; // Nitrogen in nitro group, Nitrogen in nitrate group (NO2, NO3)</a>
<a name="ln2004">          }</a>
<a name="ln2005"> </a>
<a name="ln2006">          if (nitrogenCount == 1) {</a>
<a name="ln2007">            return 54; // Iminium nitrogen (N+=C)</a>
<a name="ln2008">          }</a>
<a name="ln2009">          if (nitrogenCount == 2) {</a>
<a name="ln2010">            return 55; // Either nitrogen in N+=C-N: (NCN+)</a>
<a name="ln2011">          }</a>
<a name="ln2012">          if (nitrogenCount == 3) {</a>
<a name="ln2013">            return 56; // Guanidinium nitrogen (NGD+)</a>
<a name="ln2014">          }</a>
<a name="ln2015"> </a>
<a name="ln2016">          if (doubleBondTo == 7) {</a>
<a name="ln2017">            return 54; // Positivly charged nitrogen doubly bonded to nitrogen (N+=N)</a>
<a name="ln2018">          }</a>
<a name="ln2019">        }</a>
<a name="ln2020"> </a>
<a name="ln2021">        if (atom-&gt;GetExplicitValence() == 3) {</a>
<a name="ln2022">          bool IsAmide = false;</a>
<a name="ln2023">          bool IsSulfonAmide = false;</a>
<a name="ln2024">          bool IsNNNorNNC = false;</a>
<a name="ln2025">          int tripleBondTo = 0;</a>
<a name="ln2026">          doubleBondTo = 0;</a>
<a name="ln2027"> </a>
<a name="ln2028">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2029">            if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur || nbr-&gt;GetAtomicNum() == OBElements::Phosphorus) {</a>
<a name="ln2030">              oxygenCount = 0;</a>
<a name="ln2031"> </a>
<a name="ln2032">              FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2033">                if (nbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2034">                  oxygenCount++;</a>
<a name="ln2035">                }</a>
<a name="ln2036">              }</a>
<a name="ln2037">              if (oxygenCount &gt;= 2) {</a>
<a name="ln2038">                IsSulfonAmide = true;</a>
<a name="ln2039">                //return 43; // Sulfonamide nitrogen (NSO2, NSO3)</a>
<a name="ln2040">              }</a>
<a name="ln2041">            }</a>
<a name="ln2042">          }</a>
<a name="ln2043"> </a>
<a name="ln2044">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2045">            if (nbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln2046">              FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2047">                bond = _mol.GetBond(&amp;*nbr, &amp;*nbrNbr);</a>
<a name="ln2048">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2 &amp;&amp; (nbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen || nbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur)) {</a>
<a name="ln2049">                  IsAmide = true;</a>
<a name="ln2050">                  //return 10; // Amide nitrogen, Thioamide nitrogen (NC=O, NC=S)</a>
<a name="ln2051">                }</a>
<a name="ln2052">              }</a>
<a name="ln2053">            }</a>
<a name="ln2054">          }</a>
<a name="ln2055"> </a>
<a name="ln2056">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2057">            if (nbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln2058">              int N2count = 0;</a>
<a name="ln2059">              int N3count = 0;</a>
<a name="ln2060">              oxygenCount = sulphurCount = 0;</a>
<a name="ln2061"> </a>
<a name="ln2062">              FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2063">                bond = _mol.GetBond(&amp;*nbr, &amp;*nbrNbr);</a>
<a name="ln2064">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln2065">                  doubleBondTo = nbrNbr-&gt;GetAtomicNum();</a>
<a name="ln2066">                }</a>
<a name="ln2067">                if (bond-&gt;IsAromatic()) {</a>
<a name="ln2068">                  if ((nbrNbr-&gt;GetAtomicNum() == 7) || (nbrNbr-&gt;GetAtomicNum() == 6)) {</a>
<a name="ln2069">                    doubleBondTo = nbrNbr-&gt;GetAtomicNum();</a>
<a name="ln2070">                  }</a>
<a name="ln2071">                }</a>
<a name="ln2072">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 3) {</a>
<a name="ln2073">                  tripleBondTo = nbrNbr-&gt;GetAtomicNum();</a>
<a name="ln2074">                }</a>
<a name="ln2075">                if (nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 3)) {</a>
<a name="ln2076">                  int nbrOxygen = 0;</a>
<a name="ln2077">                  FOR_NBORS_OF_ATOM (nbrNbrNbr, &amp;*nbrNbr) {</a>
<a name="ln2078">                    if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln2079">                      nbrOxygen++;</a>
<a name="ln2080">                    }</a>
<a name="ln2081">                  }</a>
<a name="ln2082">                  if (nbrOxygen &lt; 2) {</a>
<a name="ln2083">                    N3count++;</a>
<a name="ln2084">                  }</a>
<a name="ln2085">                }</a>
<a name="ln2086">                if (nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 2) &amp;&amp; (bond-&gt;GetBondOrder() == 2 || bond-&gt;IsAromatic())) {</a>
<a name="ln2087">                  N2count++;</a>
<a name="ln2088">                }</a>
<a name="ln2089">                if (nbrNbr-&gt;IsAromatic()) {</a>
<a name="ln2090">                  if (nbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln2091">                    oxygenCount++;</a>
<a name="ln2092">                  }</a>
<a name="ln2093">                  if (nbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2094">                    sulphurCount++;</a>
<a name="ln2095">                  }</a>
<a name="ln2096">                }</a>
<a name="ln2097">              }</a>
<a name="ln2098">              if (N3count == 3) {</a>
<a name="ln2099">                return 56; // Guanidinium nitrogen (NGD+)</a>
<a name="ln2100">              }</a>
<a name="ln2101"> </a>
<a name="ln2102">              if (!IsAmide &amp;&amp; !IsSulfonAmide &amp;&amp; !oxygenCount &amp;&amp; !sulphurCount &amp;&amp; nbr-&gt;IsAromatic()) {</a>
<a name="ln2103">                return 40;</a>
<a name="ln2104">              }</a>
<a name="ln2105"> </a>
<a name="ln2106">              if ((N3count == 2) &amp;&amp; (doubleBondTo == 7) &amp;&amp; !N2count) {</a>
<a name="ln2107">                return 55; // Either nitrogen in N+=C-N: (NCN+)</a>
<a name="ln2108">              }</a>
<a name="ln2109">            }</a>
<a name="ln2110"> </a>
<a name="ln2111">            if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln2112">              nitrogenCount = 0;</a>
<a name="ln2113">              FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2114">                bond = _mol.GetBond(&amp;*nbr, &amp;*nbrNbr);</a>
<a name="ln2115">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln2116">                  if (nbrNbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln2117">                    oxygenCount = sulphurCount = 0;</a>
<a name="ln2118">                    FOR_NBORS_OF_ATOM (nbrNbrNbr, &amp;*nbrNbr) {</a>
<a name="ln2119">                      if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln2120">                        oxygenCount++;</a>
<a name="ln2121">                      }</a>
<a name="ln2122">                      if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2123">                        sulphurCount++;</a>
<a name="ln2124">                      }</a>
<a name="ln2125">                      if (nbrNbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2126">                        nitrogenCount++;</a>
<a name="ln2127">                      }</a>
<a name="ln2128">                    }</a>
<a name="ln2129">                    if (!oxygenCount &amp;&amp; !sulphurCount &amp;&amp; (nitrogenCount == 1)) {</a>
<a name="ln2130">                      bool bondToAromC = false;</a>
<a name="ln2131">                      FOR_NBORS_OF_ATOM (nbr2, atom) {</a>
<a name="ln2132">                        if (nbr2-&gt;IsAromatic() &amp;&amp; nbr2-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; nbr2-&gt;IsInRingSize(6)) {</a>
<a name="ln2133">                          bondToAromC = true;</a>
<a name="ln2134">                        }</a>
<a name="ln2135">                      }</a>
<a name="ln2136">                      if (!bondToAromC) {</a>
<a name="ln2137">                        IsNNNorNNC = true;</a>
<a name="ln2138">                      }</a>
<a name="ln2139">                    }</a>
<a name="ln2140">                  }</a>
<a name="ln2141">                  if (nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln2142">                    bool bondToAromC = false;</a>
<a name="ln2143">                    FOR_NBORS_OF_ATOM (nbr2, atom) {</a>
<a name="ln2144">                      if (nbr2-&gt;IsAromatic() &amp;&amp; nbr2-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; nbr2-&gt;IsInRingSize(6)) {</a>
<a name="ln2145">                        bondToAromC = true;</a>
<a name="ln2146">                      }</a>
<a name="ln2147">                    }</a>
<a name="ln2148">                    if (!bondToAromC) {</a>
<a name="ln2149">                      IsNNNorNNC = true;</a>
<a name="ln2150">                    }</a>
<a name="ln2151">                  }</a>
<a name="ln2152">                }</a>
<a name="ln2153">              }</a>
<a name="ln2154">            }</a>
<a name="ln2155">          }</a>
<a name="ln2156"> </a>
<a name="ln2157">          if (IsSulfonAmide) {</a>
<a name="ln2158">            return 43; // Sulfonamide nitrogen (NSO2, NSO3)</a>
<a name="ln2159">          }</a>
<a name="ln2160">          if (IsAmide) {</a>
<a name="ln2161">            return 10; // Amide nitrogen, Thioamide nitrogen (NC=O, NC=S)</a>
<a name="ln2162">          }</a>
<a name="ln2163"> </a>
<a name="ln2164">          if ((doubleBondTo ==  6) || (doubleBondTo == 7) ||(doubleBondTo == 15) || (tripleBondTo == 6)) {</a>
<a name="ln2165">            return 40; // Enamine or aniline nitrogen (deloc. lp), Nitrogen in N-C=N with deloc. lp,</a>
<a name="ln2166">            // Nitrogen in N-C=N with deloc. lp, Nitrogen attached to C-C triple bond</a>
<a name="ln2167">            // (NC=C, NC=N, NC=P, NC%C)</a>
<a name="ln2168">          }</a>
<a name="ln2169">          if (tripleBondTo == 7) {</a>
<a name="ln2170">            return 43; // Nitrogen attached to cyano group (NC%N)</a>
<a name="ln2171">          }</a>
<a name="ln2172">          if (IsNNNorNNC) {</a>
<a name="ln2173">            return 10; // Nitrogen in N-N=C moiety with deloc. lp</a>
<a name="ln2174">            // Nitrogen in N-N=N moiety with deloc. lp (NN=C, NN=N)</a>
<a name="ln2175">          }</a>
<a name="ln2176"> </a>
<a name="ln2177">          return 8; // Amine nitrogen (NR)</a>
<a name="ln2178">        }</a>
<a name="ln2179">      }</a>
<a name="ln2180">      // 2 neighbours</a>
<a name="ln2181">      if (atom-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln2182">        if (atom-&gt;GetExplicitValence() &gt;= 4) {</a>
<a name="ln2183">          bool isNbrCarbon = false;</a>
<a name="ln2184">          bool isBondTriple = false;</a>
<a name="ln2185">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2186">            if (!isNbrCarbon)</a>
<a name="ln2187">              isNbrCarbon = nbr-&gt;GetAtomicNum() == OBElements::Carbon;</a>
<a name="ln2188">            bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2189">            if (!isBondTriple)</a>
<a name="ln2190">              isBondTriple = !bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 3;</a>
<a name="ln2191">          }</a>
<a name="ln2192">          if (isBondTriple &amp;&amp; isNbrCarbon)</a>
<a name="ln2193">            return 61; // Isonitrile nitrogen (NR%)</a>
<a name="ln2194"> </a>
<a name="ln2195">          return 53; // Central nitrogen in C=N=N or N=N=N (=N=)</a>
<a name="ln2196">        }</a>
<a name="ln2197"> </a>
<a name="ln2198">        if (atom-&gt;GetExplicitValence() == 3) {</a>
<a name="ln2199">          doubleBondTo = 0;</a>
<a name="ln2200"> </a>
<a name="ln2201">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2202">            bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2203">            if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; !bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2 &amp;&amp; (nbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2204">              return 46; // Nitrogen in nitroso group (N=O)</a>
<a name="ln2205">            }</a>
<a name="ln2206">            if ((nbr-&gt;GetAtomicNum() == OBElements::Carbon || nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) &amp;&amp; !bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln2207">              return 9; // Iminie nitrogen, Azo-group nitrogen (N=C, N=N)</a>
<a name="ln2208">            }</a>
<a name="ln2209">          }</a>
<a name="ln2210">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2211">            if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2212">              oxygenCount = 0;</a>
<a name="ln2213"> </a>
<a name="ln2214">              FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2215">                if (nbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2216">                  oxygenCount++;</a>
<a name="ln2217">                }</a>
<a name="ln2218">              }</a>
<a name="ln2219">              if (oxygenCount &gt;= 2) {</a>
<a name="ln2220">                return 43; // Sulfonamide nitrogen (NSO2, NSO3)</a>
<a name="ln2221">              }</a>
<a name="ln2222">            }</a>
<a name="ln2223">          }</a>
<a name="ln2224">        }</a>
<a name="ln2225"> </a>
<a name="ln2226">        if (atom-&gt;GetExplicitValence() &gt;= 2) { // Bug reported by Paolo Tosco</a>
<a name="ln2227">          oxygenCount = sulphurCount = 0;</a>
<a name="ln2228"> </a>
<a name="ln2229">          FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2230">            if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2231">              FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2232">                if (nbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2233">                  oxygenCount++;</a>
<a name="ln2234">                }</a>
<a name="ln2235">              }</a>
<a name="ln2236">              if (oxygenCount == 1) {</a>
<a name="ln2237">                return 48; // Divalent nitrogen replacing monovalent O in SO2 group (NSO)</a>
<a name="ln2238">              }</a>
<a name="ln2239">            }</a>
<a name="ln2240">          }</a>
<a name="ln2241"> </a>
<a name="ln2242">          return 62; // Anionic divalent nitrogen (NM)</a>
<a name="ln2243">        }</a>
<a name="ln2244">      }</a>
<a name="ln2245">      // 1 neighbours</a>
<a name="ln2246">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2247">       	FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2248">          bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2249">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 3) {</a>
<a name="ln2250">            FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2251">              if (atom != &amp;*nbrNbr &amp;&amp; !(nbr-&gt;GetAtomicNum() == OBElements::Nitrogen</a>
<a name="ln2252">                &amp;&amp; nbrNbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; nbrNbr-&gt;GetExplicitDegree() == 2)) {</a>
<a name="ln2253">                return 42; // Triply bonded nitrogen (NSP)</a>
<a name="ln2254">              }</a>
<a name="ln2255">            }</a>
<a name="ln2256">          }</a>
<a name="ln2257">          if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (nbr-&gt;GetExplicitDegree() == 2)) {</a>
<a name="ln2258">            return 47; // Terminal nitrogen in azido group (NAZT)</a>
<a name="ln2259">          }</a>
<a name="ln2260">        }</a>
<a name="ln2261">      }</a>
<a name="ln2262">      return 8; // generic amine nitrogen</a>
<a name="ln2263">    }</a>
<a name="ln2264"> </a>
<a name="ln2265">    ////////////////////////////////</a>
<a name="ln2266">    // Oxygen</a>
<a name="ln2267">    ////////////////////////////////</a>
<a name="ln2268">    if (atom-&gt;GetAtomicNum() == 8) {</a>
<a name="ln2269">      // 3 neighbours</a>
<a name="ln2270">      if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln2271">        return 49; // Oxonium oxygen (O+)</a>
<a name="ln2272">      }</a>
<a name="ln2273">      // 2 neighbours</a>
<a name="ln2274">      if (atom-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln2275">        int hydrogenCount = 0;</a>
<a name="ln2276">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2277">          if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen) {</a>
<a name="ln2278">            hydrogenCount++;</a>
<a name="ln2279">          }</a>
<a name="ln2280">        }</a>
<a name="ln2281"> </a>
<a name="ln2282">        if (hydrogenCount == 2) {</a>
<a name="ln2283">          // H--O--H</a>
<a name="ln2284">          return 70; // Oxygen in water (OH2)</a>
<a name="ln2285">        }</a>
<a name="ln2286">        if (atom-&gt;GetExplicitValence() == 3) {</a>
<a name="ln2287">          return 51; // Oxenium oxygen (O=+)</a>
<a name="ln2288">        }</a>
<a name="ln2289"> </a>
<a name="ln2290">        return 6; // Generic divalent oxygen, Ether oxygen, Carboxylic acid or ester oxygen,</a>
<a name="ln2291">        // Enolic or phenolic oxygen, Oxygen in -O-C=N- moiety, Divalent oxygen in</a>
<a name="ln2292">        // thioacid or ester, Divalent nitrate &quot;ether&quot; oxygen, Divalent oxygen in</a>
<a name="ln2293">        // sulfate group, Divalent oxygen in sulfite group, One of two divalent</a>
<a name="ln2294">        // oxygens attached to sulfur, Divalent oxygen in R(RO)S=O, Other divalent</a>
<a name="ln2295">        // oxygen attached to sulfur, Divalent oxygen in phosphate group, Divalent</a>
<a name="ln2296">        // oxygen in phosphite group, Divalent oxygen (one of two oxygens attached</a>
<a name="ln2297">        // to P), Other divalent oxygen (-O-, OR, OC=O, OC=C, OC=N, OC=S, ONO2,</a>
<a name="ln2298">        // ON=O, OSO3, OSO2, OSO, OS=O, -OS, OPO3, OPO2, OPO, -OP)</a>
<a name="ln2299"> </a>
<a name="ln2300">        // 59 ar</a>
<a name="ln2301">      }</a>
<a name="ln2302">      // 1 neighbour</a>
<a name="ln2303">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2304">        oxygenCount = sulphurCount = 0;</a>
<a name="ln2305"> </a>
<a name="ln2306">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2307">          bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2308"> </a>
<a name="ln2309">          if (nbr-&gt;GetAtomicNum() == OBElements::Carbon || nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln2310">            FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2311">              if (nbrNbr-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2312">                oxygenCount++;</a>
<a name="ln2313">              }</a>
<a name="ln2314">              if (nbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2315">                sulphurCount++;</a>
<a name="ln2316">              }</a>
<a name="ln2317">            }</a>
<a name="ln2318">          }</a>
<a name="ln2319">          // O---H</a>
<a name="ln2320">          if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen) {</a>
<a name="ln2321">            return 35;</a>
<a name="ln2322">          }</a>
<a name="ln2323">          // O-?-C</a>
<a name="ln2324">          if (nbr-&gt;GetAtomicNum() == OBElements::Carbon) {</a>
<a name="ln2325">            if (oxygenCount == 2) {</a>
<a name="ln2326">              // O-?-C-?-O</a>
<a name="ln2327">              return 32; // Oxygen in carboxylate group (O2CM)</a>
<a name="ln2328">            }</a>
<a name="ln2329">            if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 1) {</a>
<a name="ln2330">              // O--C</a>
<a name="ln2331">              return 35; // Oxide oxygen on sp3 carbon, Oxide oxygen on sp2 carbon (OM, OM2)</a>
<a name="ln2332">            } else {</a>
<a name="ln2333">              // O==C</a>
<a name="ln2334">              return 7; // Generic carbonyl oxygen, Carbonyl oxygen in amides,</a>
<a name="ln2335">              // Carbonyl oxygen in aldehydes and ketones, Carbonyl</a>
<a name="ln2336">              // oxygen in acids or esters (O=C, O=CN, O=CR, O=CO)</a>
<a name="ln2337">            }</a>
<a name="ln2338">          }</a>
<a name="ln2339">          // O-?-N</a>
<a name="ln2340">          if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln2341">            if (oxygenCount &gt;= 2) {</a>
<a name="ln2342">              // O-?-N-?-O</a>
<a name="ln2343">              return 32; // Oxygen in nitro group, Nitro-group oxygen in nitrate,</a>
<a name="ln2344">              // Nitrate anion oxygen (O2N, O2NO, O3N)</a>
<a name="ln2345">            }</a>
<a name="ln2346">            if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 1) {</a>
<a name="ln2347">	      if ((nbr-&gt;GetExplicitDegree() == 2) || (nbr-&gt;GetExplicitValence() == 3))</a>
<a name="ln2348">	      // O(-)--N</a>
<a name="ln2349">	        return 35;</a>
<a name="ln2350">	      else</a>
<a name="ln2351">              // O--N</a>
<a name="ln2352">                return 32; // Oxygen in N-oxides (ONX)</a>
<a name="ln2353">            } else {</a>
<a name="ln2354">              // sometimes ONX bonds are labelled as double bonds</a>
<a name="ln2355">              // (e.g. by MOE, noticed by Paolo Tosco)</a>
<a name="ln2356">              int ndab = 0;</a>
<a name="ln2357">              FOR_BONDS_OF_ATOM(bond2, &amp;*nbr) {</a>
<a name="ln2358">                if (bond2-&gt;GetBondOrder() == 2 || bond2-&gt;GetBondOrder() == 5)</a>
<a name="ln2359">                  ndab++;</a>
<a name="ln2360">              }</a>
<a name="ln2361">              if (ndab + nbr-&gt;GetExplicitDegree() == 5)</a>
<a name="ln2362">                // O--N</a>
<a name="ln2363">                return 32; // Oxygen in N-oxides (ONX)</a>
<a name="ln2364">              else</a>
<a name="ln2365">                // O==N</a>
<a name="ln2366">                return 7; // Nitroso oxygen (O=N)</a>
<a name="ln2367">            }</a>
<a name="ln2368">          }</a>
<a name="ln2369">          // O-?-S</a>
<a name="ln2370">          if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2371">            if (sulphurCount == 1) {</a>
<a name="ln2372">              // O1-?-S-?-S1</a>
<a name="ln2373">              return 32; // Terminal oxygen in thiosulfinate anion (OSMS)</a>
<a name="ln2374">            }</a>
<a name="ln2375">            if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 1) {</a>
<a name="ln2376">              // O--S</a>
<a name="ln2377">              return 32; // Single terminal oxygen on sulfur, One of 2 terminal O's on sulfur,</a>
<a name="ln2378">              // One of 3 terminal O's on sulfur, Terminal O in sulfate anion,</a>
<a name="ln2379">              // (O-S, O2S, O3S, O4S)</a>
<a name="ln2380">            } else {</a>
<a name="ln2381">              // O==S</a>
<a name="ln2382"> </a>
<a name="ln2383">              // are all sulfur nbr atoms carbon?</a>
<a name="ln2384">              bool isSulfoxide = true;</a>
<a name="ln2385">              int oxygenBoundToSulfur = 0;</a>
<a name="ln2386">              FOR_NBORS_OF_ATOM (nbr2, &amp;*nbr) {</a>
<a name="ln2387">                if (atom == &amp;*nbr2)</a>
<a name="ln2388">                  continue;</a>
<a name="ln2389"> </a>
<a name="ln2390">                if (nbr2-&gt;GetAtomicNum() == OBElements::Oxygen)</a>
<a name="ln2391">                  ++oxygenBoundToSulfur;</a>
<a name="ln2392">              }</a>
<a name="ln2393">              FOR_NBORS_OF_ATOM (nbr2, &amp;*nbr) {</a>
<a name="ln2394">                if (atom == &amp;*nbr2)</a>
<a name="ln2395">                  continue;</a>
<a name="ln2396">                OBBond* bond = nbr-&gt;GetBond(&amp;*nbr2);</a>
<a name="ln2397">                if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2</a>
<a name="ln2398">                  &amp;&amp; nbr2-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; oxygenBoundToSulfur == 1)</a>
<a name="ln2399">                  isSulfoxide = false; // O=S on sulfur doubly bonded to, e.g., C (O=S=)</a>
<a name="ln2400"> </a>
<a name="ln2401">                if ((nbr2-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; nbr2-&gt;GetExplicitDegree() == 1)</a>
<a name="ln2402">		  || (nbr2-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; nbr2-&gt;GetExplicitDegree() == 2))</a>
<a name="ln2403">                  isSulfoxide = false;</a>
<a name="ln2404">              }</a>
<a name="ln2405"> </a>
<a name="ln2406">              if (isSulfoxide)</a>
<a name="ln2407">                return 7; // Doubly bonded sulfoxide oxygen (O=S)</a>
<a name="ln2408">              else</a>
<a name="ln2409">                return 32; // (O2S, O2S=C, O3S, O4S)</a>
<a name="ln2410">            }</a>
<a name="ln2411">          }</a>
<a name="ln2412"> </a>
<a name="ln2413">          return 32; // Oxygen in phosphine oxide, One of 2 terminal O's on sulfur,</a>
<a name="ln2414">          // One of 3 terminal O's on sulfur, One of 4 terminal O's on sulfur,</a>
<a name="ln2415">          // Oxygen in perchlorate anion (OP, O2P, O3P, O4P, O4Cl)</a>
<a name="ln2416">        }</a>
<a name="ln2417">      }</a>
<a name="ln2418">    }</a>
<a name="ln2419"> </a>
<a name="ln2420">    ////////////////////////////////</a>
<a name="ln2421">    // Flourine</a>
<a name="ln2422">    ////////////////////////////////</a>
<a name="ln2423">    if (atom-&gt;GetAtomicNum() == 9) {</a>
<a name="ln2424">      // 1 neighbour</a>
<a name="ln2425">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2426">        return 11; // Fluorine (F)</a>
<a name="ln2427">      }</a>
<a name="ln2428">      // 0 neighbours</a>
<a name="ln2429">      if (atom-&gt;GetExplicitDegree() == 0) {</a>
<a name="ln2430">        return 89; // Fluoride anion (F-)</a>
<a name="ln2431">      }</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    ////////////////////////////////</a>
<a name="ln2435">    // Sodium</a>
<a name="ln2436">    ////////////////////////////////</a>
<a name="ln2437">    if (atom-&gt;GetAtomicNum() == 11) {</a>
<a name="ln2438">      return 93; // Sodium cation (NA+)</a>
<a name="ln2439">    }</a>
<a name="ln2440"> </a>
<a name="ln2441">    ////////////////////////////////</a>
<a name="ln2442">    // Magnesium</a>
<a name="ln2443">    ////////////////////////////////</a>
<a name="ln2444">    if (atom-&gt;GetAtomicNum() == 12) {</a>
<a name="ln2445">      return 99; // Dipositive magnesium cation (MG+2)</a>
<a name="ln2446">    }</a>
<a name="ln2447"> </a>
<a name="ln2448">    ////////////////////////////////</a>
<a name="ln2449">    // Silicon</a>
<a name="ln2450">    ////////////////////////////////</a>
<a name="ln2451">    if (atom-&gt;GetAtomicNum() == 14) {</a>
<a name="ln2452">      return 19; // Silicon (SI)</a>
<a name="ln2453">    }</a>
<a name="ln2454"> </a>
<a name="ln2455">    ////////////////////////////////</a>
<a name="ln2456">    // Phosphorus</a>
<a name="ln2457">    ////////////////////////////////</a>
<a name="ln2458">    if (atom-&gt;GetAtomicNum() == 15) {</a>
<a name="ln2459">      if (atom-&gt;GetExplicitDegree() == 4) {</a>
<a name="ln2460">        return 25; // Phosphate group phosphorus, Phosphorus with 3 attached oxygens,</a>
<a name="ln2461">        // Phosphorus with 2 attached oxygens, Phosphine oxide phosphorus,</a>
<a name="ln2462">        // General tetracoordinate phosphorus (PO4, PO3, PO2, PO, PTET)</a>
<a name="ln2463">      }</a>
<a name="ln2464">      if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln2465">        return 26; // Phosphorus in phosphines (P)</a>
<a name="ln2466">      }</a>
<a name="ln2467">      if (atom-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln2468">        return 75; // Phosphorus doubly bonded to C (-P=C)</a>
<a name="ln2469">      }</a>
<a name="ln2470">    }</a>
<a name="ln2471"> </a>
<a name="ln2472">    ////////////////////////////////</a>
<a name="ln2473">    // Sulfur</a>
<a name="ln2474">    ////////////////////////////////</a>
<a name="ln2475">    if (atom-&gt;GetAtomicNum() == 16) {</a>
<a name="ln2476">      // 4 neighbours</a>
<a name="ln2477">      if (atom-&gt;GetExplicitDegree() == 4) {</a>
<a name="ln2478">        return 18; // Sulfone sulfur, Sulfonamide sulfur, Sulfonate group sulfur,</a>
<a name="ln2479">        // Sulfate group sulfur, Sulfur in nitrogen analog of sulfone</a>
<a name="ln2480">        // (SO2, SO2N, SO3, SO4, SNO)</a>
<a name="ln2481">      }</a>
<a name="ln2482">      // 3 neighbours</a>
<a name="ln2483">      if (atom-&gt;GetExplicitDegree() == 3) {</a>
<a name="ln2484">        oxygenCount = sulphurCount = doubleBondTo = 0;</a>
<a name="ln2485"> </a>
<a name="ln2486">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2487">          bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2488">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln2489">            if (nbr-&gt;GetAtomicNum() == 6)</a>
<a name="ln2490">	            doubleBondTo = 6;</a>
<a name="ln2491">          }</a>
<a name="ln2492"> </a>
<a name="ln2493">          if (nbr-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2494">            if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln2495">              oxygenCount++;</a>
<a name="ln2496">            } else if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln2497">              sulphurCount++;</a>
<a name="ln2498">            }</a>
<a name="ln2499">          }</a>
<a name="ln2500">        }</a>
<a name="ln2501"> </a>
<a name="ln2502">        if (oxygenCount == 2) {</a>
<a name="ln2503">          if (doubleBondTo == 6) {</a>
<a name="ln2504">            return 18; // Sulfone sulfur, doubly bonded to carbon (=SO2)</a>
<a name="ln2505">          }</a>
<a name="ln2506">          return 73; // Sulfur in anionic sulfinate group (SO2M)</a>
<a name="ln2507">        }</a>
<a name="ln2508">        if (oxygenCount &amp;&amp; sulphurCount)</a>
<a name="ln2509">          return 73; // Tricoordinate sulfur in anionic thiosulfinate group (SSOM)</a>
<a name="ln2510"> </a>
<a name="ln2511">        //if ((doubleBondTo == 6) || (doubleBondTo == 8))</a>
<a name="ln2512">        return 17; // Sulfur doubly bonded to carbon, Sulfoxide sulfur (S=C, S=O)</a>
<a name="ln2513">      }</a>
<a name="ln2514">      // 2 neighbours</a>
<a name="ln2515">      if (atom-&gt;GetExplicitDegree() == 2) {</a>
<a name="ln2516">        doubleBondTo = 0;</a>
<a name="ln2517"> </a>
<a name="ln2518">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2519">          if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln2520">            bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2521">            if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln2522">              doubleBondTo = 8;</a>
<a name="ln2523">            }</a>
<a name="ln2524">          }</a>
<a name="ln2525">        }</a>
<a name="ln2526"> </a>
<a name="ln2527">        if (doubleBondTo == 8)</a>
<a name="ln2528">          return 74; // Sulfinyl sulfur, e.g., in C=S=O (=S=O)</a>
<a name="ln2529"> </a>
<a name="ln2530">        return 15; // Thiol, sulfide, or disulfide sulfor (S)</a>
<a name="ln2531">      }</a>
<a name="ln2532">      // 1 neighbour</a>
<a name="ln2533">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2534">        sulphurCount = doubleBondTo = 0;</a>
<a name="ln2535"> </a>
<a name="ln2536">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2537">          FOR_NBORS_OF_ATOM (nbrNbr, &amp;*nbr) {</a>
<a name="ln2538">            if (nbrNbr-&gt;GetAtomicNum() == OBElements::Sulfur &amp;&amp; (nbrNbr-&gt;GetExplicitDegree() == 1)) {</a>
<a name="ln2539">              sulphurCount++;</a>
<a name="ln2540">            }</a>
<a name="ln2541">          }</a>
<a name="ln2542">          bond = _mol.GetBond(&amp;*nbr, atom);</a>
<a name="ln2543">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2) {</a>
<a name="ln2544">            doubleBondTo = nbr-&gt;GetAtomicNum();</a>
<a name="ln2545">          }</a>
<a name="ln2546">        }</a>
<a name="ln2547"> </a>
<a name="ln2548">        if ((doubleBondTo == 6) &amp;&amp; (sulphurCount != 2)) {</a>
<a name="ln2549">          return 16; // Sulfur doubly bonded to carbon (S=C)</a>
<a name="ln2550">        }</a>
<a name="ln2551"> </a>
<a name="ln2552">        return 72; // Terminal sulfur bonded to P, Anionic terminal sulfur,</a>
<a name="ln2553">        // Terminal sulfur in thiosulfinate group (S-P, SM, SSMO)</a>
<a name="ln2554">      }</a>
<a name="ln2555"> </a>
<a name="ln2556">      // 44 ar</a>
<a name="ln2557">    }</a>
<a name="ln2558"> </a>
<a name="ln2559">    ////////////////////////////////</a>
<a name="ln2560">    // Clorine</a>
<a name="ln2561">    ////////////////////////////////</a>
<a name="ln2562">    if (atom-&gt;GetAtomicNum() == 17) {</a>
<a name="ln2563">      // 4 neighbour</a>
<a name="ln2564">      if (atom-&gt;GetExplicitDegree() == 4) {</a>
<a name="ln2565">        oxygenCount = 0;</a>
<a name="ln2566"> </a>
<a name="ln2567">        FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln2568">          if (nbr-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln2569">            oxygenCount++;</a>
<a name="ln2570">          }</a>
<a name="ln2571">        }</a>
<a name="ln2572">        if (oxygenCount == 4)</a>
<a name="ln2573">          return 77; // Perchlorate anion chlorine (CLO4)</a>
<a name="ln2574">      }</a>
<a name="ln2575">      // 1 neighbour</a>
<a name="ln2576">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2577">        return 12; // Chlorine (CL)</a>
<a name="ln2578">      }</a>
<a name="ln2579">      // 0 neighbours</a>
<a name="ln2580">      if (atom-&gt;GetExplicitDegree() == 0) {</a>
<a name="ln2581">        return 90; // Chloride anion (CL-)</a>
<a name="ln2582">      }</a>
<a name="ln2583">    }</a>
<a name="ln2584"> </a>
<a name="ln2585">    ////////////////////////////////</a>
<a name="ln2586">    // Potasium</a>
<a name="ln2587">    ////////////////////////////////</a>
<a name="ln2588">    if (atom-&gt;GetAtomicNum() == 19) {</a>
<a name="ln2589">      return 94; // Potasium cation (K+)</a>
<a name="ln2590">    }</a>
<a name="ln2591"> </a>
<a name="ln2592">    ////////////////////////////////</a>
<a name="ln2593">    // Calcium</a>
<a name="ln2594">    ////////////////////////////////</a>
<a name="ln2595">    if (atom-&gt;GetAtomicNum() == 20) {</a>
<a name="ln2596">      // 0 neighbours</a>
<a name="ln2597">      if (atom-&gt;GetExplicitDegree() == 0) {</a>
<a name="ln2598">        return 96; // Dipositive calcium cation (CA+2)</a>
<a name="ln2599">      }</a>
<a name="ln2600">    }</a>
<a name="ln2601"> </a>
<a name="ln2602">    ////////////////////////////////</a>
<a name="ln2603">    // Iron</a>
<a name="ln2604">    ////////////////////////////////</a>
<a name="ln2605">    if (atom-&gt;GetAtomicNum() == 26) {</a>
<a name="ln2606">      if (atom-&gt;GetFormalCharge() == 2)</a>
<a name="ln2607">        return 87; // Dipositive iron (FE+2)</a>
<a name="ln2608">      else</a>
<a name="ln2609">        return 88; // Tripositive iron (FE+3)</a>
<a name="ln2610">    }</a>
<a name="ln2611"> </a>
<a name="ln2612">    ////////////////////////////////</a>
<a name="ln2613">    // Copper</a>
<a name="ln2614">    ////////////////////////////////</a>
<a name="ln2615">    if (atom-&gt;GetAtomicNum() == 29) {</a>
<a name="ln2616">      if (atom-&gt;GetFormalCharge() == 1)</a>
<a name="ln2617">        return 97; // Monopositive copper cation (CU+1)</a>
<a name="ln2618">      else</a>
<a name="ln2619">        return 98; // Dipositive copper cation (CU+2)</a>
<a name="ln2620">    }</a>
<a name="ln2621"> </a>
<a name="ln2622">    ////////////////////////////////</a>
<a name="ln2623">    // Zinc</a>
<a name="ln2624">    ////////////////////////////////</a>
<a name="ln2625">    if (atom-&gt;GetAtomicNum() == 30) {</a>
<a name="ln2626">      return 95; // Dipositive zinc cation (ZN+2)</a>
<a name="ln2627">    }</a>
<a name="ln2628"> </a>
<a name="ln2629">    ////////////////////////////////</a>
<a name="ln2630">    // Bromine</a>
<a name="ln2631">    ////////////////////////////////</a>
<a name="ln2632">    if (atom-&gt;GetAtomicNum() == 35) {</a>
<a name="ln2633">      // 1 neighbour</a>
<a name="ln2634">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2635">        return 13; // Bromine (BR)</a>
<a name="ln2636">      }</a>
<a name="ln2637">      // 0 neighbours</a>
<a name="ln2638">      if (atom-&gt;GetExplicitDegree() == 0) {</a>
<a name="ln2639">        return 91; // Bromide anion (BR-)</a>
<a name="ln2640">      }</a>
<a name="ln2641">    }</a>
<a name="ln2642"> </a>
<a name="ln2643">    ////////////////////////////////</a>
<a name="ln2644">    // Iodine</a>
<a name="ln2645">    ////////////////////////////////</a>
<a name="ln2646">    if (atom-&gt;GetAtomicNum() == 53) {</a>
<a name="ln2647">      // 1 neighbour</a>
<a name="ln2648">      if (atom-&gt;GetExplicitDegree() == 1) {</a>
<a name="ln2649">        return 14; // Iodine (I)</a>
<a name="ln2650">      }</a>
<a name="ln2651">    }</a>
<a name="ln2652"> </a>
<a name="ln2653"> </a>
<a name="ln2654"> </a>
<a name="ln2655">    return 0;</a>
<a name="ln2656">  }</a>
<a name="ln2657"> </a>
<a name="ln2658">  bool OBForceFieldMMFF94::SetTypes()</a>
<a name="ln2659">  {</a>
<a name="ln2660">    char type[4];</a>
<a name="ln2661"> </a>
<a name="ln2662">    _mol.SetAtomTypesPerceived();</a>
<a name="ln2663"> </a>
<a name="ln2664">    // mark all atoms and bonds as non-aromatic</a>
<a name="ln2665">    _mol.SetAromaticPerceived();</a>
<a name="ln2666">    FOR_BONDS_OF_MOL (bond, _mol)</a>
<a name="ln2667">      bond-&gt;SetAromatic(false);</a>
<a name="ln2668">    FOR_ATOMS_OF_MOL (atom, _mol)</a>
<a name="ln2669">      atom-&gt;SetAromatic(false);</a>
<a name="ln2670"> </a>
<a name="ln2671">    // It might be needed to run this function more than once...</a>
<a name="ln2672">    bool done = true;</a>
<a name="ln2673">    while (done) {</a>
<a name="ln2674">      done = PerceiveAromatic();</a>
<a name="ln2675">    }</a>
<a name="ln2676"> </a>
<a name="ln2677">    FOR_ATOMS_OF_MOL (atom, _mol) {</a>
<a name="ln2678">      snprintf(type, 3, &quot;%d&quot;, GetType(&amp;*atom));</a>
<a name="ln2679">      atom-&gt;SetType(type);</a>
<a name="ln2680">    }</a>
<a name="ln2681"> </a>
<a name="ln2682">    PrintTypes();</a>
<a name="ln2683"> </a>
<a name="ln2684">    return true;</a>
<a name="ln2685">  }</a>
<a name="ln2686"> </a>
<a name="ln2687">  bool OBForceFieldMMFF94::SetupCalculations()</a>
<a name="ln2688">  {</a>
<a name="ln2689">    OBFFParameter *parameter;</a>
<a name="ln2690">    OBAtom *a, *b, *c, *d;</a>
<a name="ln2691">    int type_a, type_b, type_c, type_d;</a>
<a name="ln2692">    bool found;</a>
<a name="ln2693">    int order;</a>
<a name="ln2694"> </a>
<a name="ln2695">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln2696">      OBFFLog(&quot;\nS E T T I N G   U P   C A L C U L A T I O N S\n\n&quot;);</a>
<a name="ln2697"> </a>
<a name="ln2698">    //</a>
<a name="ln2699">    // Bond Calculations</a>
<a name="ln2700">    //</a>
<a name="ln2701">    // no &quot;step-down&quot; procedure</a>
<a name="ln2702">    // MMFF part V - page 625 (empirical rule)</a>
<a name="ln2703">    //</a>
<a name="ln2704">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln2705">      OBFFLog(&quot;SETTING UP BOND CALCULATIONS...\n&quot;);</a>
<a name="ln2706"> </a>
<a name="ln2707">    OBFFBondCalculationMMFF94 bondcalc;</a>
<a name="ln2708">    int bondtype;</a>
<a name="ln2709"> </a>
<a name="ln2710">    _bondcalculations.clear();</a>
<a name="ln2711"> </a>
<a name="ln2712">    FOR_BONDS_OF_MOL(bond, _mol) {</a>
<a name="ln2713">      a = bond-&gt;GetBeginAtom();</a>
<a name="ln2714">      b = bond-&gt;GetEndAtom();</a>
<a name="ln2715"> </a>
<a name="ln2716">      // skip this bond if the atoms are ignored</a>
<a name="ln2717">      if ( _constraints.IsIgnored(a-&gt;GetIdx()) || _constraints.IsIgnored(b-&gt;GetIdx()) )</a>
<a name="ln2718">        continue;</a>
<a name="ln2719"> </a>
<a name="ln2720">      // if there are any groups specified, check if the two bond atoms are in a single intraGroup</a>
<a name="ln2721">      if (HasGroups()) {</a>
<a name="ln2722">        bool validBond = false;</a>
<a name="ln2723">        for (unsigned int i=0; i &lt; _intraGroup.size(); ++i) {</a>
<a name="ln2724">          if (_intraGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp; _intraGroup[i].BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln2725">            validBond = true;</a>
<a name="ln2726">            break;</a>
<a name="ln2727">          }</a>
<a name="ln2728">        }</a>
<a name="ln2729">        if (!validBond)</a>
<a name="ln2730">          continue;</a>
<a name="ln2731">      }</a>
<a name="ln2732"> </a>
<a name="ln2733">      bondtype = GetBondType(a, b);</a>
<a name="ln2734"> </a>
<a name="ln2735">      parameter = GetTypedParameter2Atom(bondtype, atoi(a-&gt;GetType()), atoi(b-&gt;GetType()), _ffbondparams); // from mmffbond.par</a>
<a name="ln2736">      if (parameter == nullptr) {</a>
<a name="ln2737">        parameter = GetParameter2Atom(a-&gt;GetAtomicNum(), b-&gt;GetAtomicNum(), _ffbndkparams); // from mmffbndk.par - emperical rules</a>
<a name="ln2738">        if (parameter == nullptr) {</a>
<a name="ln2739">          IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2740">            // This should never happen</a>
<a name="ln2741">            snprintf(_logbuf, BUFF_SIZE, &quot;    COULD NOT FIND PARAMETERS FOR BOND %d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx());</a>
<a name="ln2742">            OBFFLog(_logbuf);</a>
<a name="ln2743">          }</a>
<a name="ln2744">          return false;</a>
<a name="ln2745">        } else {</a>
<a name="ln2746">          IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2747">            snprintf(_logbuf, BUFF_SIZE, &quot;   USING EMPIRICAL RULE FOR BOND STRETCHING %d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx());</a>
<a name="ln2748">            OBFFLog(_logbuf);</a>
<a name="ln2749">          }</a>
<a name="ln2750"> </a>
<a name="ln2751">          double rr, rr2, rr4, rr6;</a>
<a name="ln2752">          bondcalc.a = a;</a>
<a name="ln2753">          bondcalc.b = b;</a>
<a name="ln2754">          bondcalc.r0 = GetRuleBondLength(a, b);</a>
<a name="ln2755"> </a>
<a name="ln2756">          rr = parameter-&gt;_dpar[0] / bondcalc.r0; // parameter-&gt;_dpar[0]  = r0-ref</a>
<a name="ln2757">          rr2 = rr * rr;</a>
<a name="ln2758">          rr4 = rr2 * rr2;</a>
<a name="ln2759">          rr6 = rr4 * rr2;</a>
<a name="ln2760"> </a>
<a name="ln2761">          bondcalc.kb = parameter-&gt;_dpar[1] * rr6; // parameter-&gt;_dpar[1]  = kb-ref</a>
<a name="ln2762">          bondcalc.bt = bondtype;</a>
<a name="ln2763">          bondcalc.SetupPointers();</a>
<a name="ln2764"> </a>
<a name="ln2765">          _bondcalculations.push_back(bondcalc);</a>
<a name="ln2766">        }</a>
<a name="ln2767">      } else {</a>
<a name="ln2768">        bondcalc.a = a;</a>
<a name="ln2769">        bondcalc.b = b;</a>
<a name="ln2770">        bondcalc.kb = parameter-&gt;_dpar[0];</a>
<a name="ln2771">        bondcalc.r0 = parameter-&gt;_dpar[1];</a>
<a name="ln2772">        bondcalc.bt = bondtype;</a>
<a name="ln2773">        bondcalc.SetupPointers();</a>
<a name="ln2774"> </a>
<a name="ln2775">        _bondcalculations.push_back(bondcalc);</a>
<a name="ln2776">      }</a>
<a name="ln2777">    }</a>
<a name="ln2778"> </a>
<a name="ln2779">    //</a>
<a name="ln2780">    // Angle Calculations</a>
<a name="ln2781">    //</a>
<a name="ln2782">    // MMFF part I - page 513 (&quot;step-down&quot; prodedure)</a>
<a name="ln2783">    // MMFF part I - page 519 (reference 68 is actually a footnote)</a>
<a name="ln2784">    // MMFF part V - page 627 (empirical rule)</a>
<a name="ln2785">    //</a>
<a name="ln2786">    // First try and find an exact match, if this fails, step down using the equivalences from mmffdef.par</a>
<a name="ln2787">    // five-stage protocol: 1-1-1, 2-2-2, 3-2-3, 4-2-4, 5-2-5</a>
<a name="ln2788">    // If this fails, use empirical rules</a>
<a name="ln2789">    // Since 1-1-1 = 2-2-2, we will only try 1-1-1 before going to 3-2-3</a>
<a name="ln2790">    //</a>
<a name="ln2791">    // Stretch-Bend Calculations</a>
<a name="ln2792">    //</a>
<a name="ln2793">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln2794">      OBFFLog(&quot;SETTING UP ANGLE &amp; STRETCH-BEND CALCULATIONS...\n&quot;);</a>
<a name="ln2795"> </a>
<a name="ln2796">    OBFFAngleCalculationMMFF94 anglecalc;</a>
<a name="ln2797">    OBFFStrBndCalculationMMFF94 strbndcalc;</a>
<a name="ln2798">    int angletype, strbndtype, bondtype1, bondtype2;</a>
<a name="ln2799"> </a>
<a name="ln2800">    _anglecalculations.clear();</a>
<a name="ln2801">    _strbndcalculations.clear();</a>
<a name="ln2802"> </a>
<a name="ln2803">    FOR_ANGLES_OF_MOL(angle, _mol) {</a>
<a name="ln2804">      b = _mol.GetAtom((*angle)[0] + 1);</a>
<a name="ln2805">      a = _mol.GetAtom((*angle)[1] + 1);</a>
<a name="ln2806">      c = _mol.GetAtom((*angle)[2] + 1);</a>
<a name="ln2807"> </a>
<a name="ln2808">      type_a = atoi(a-&gt;GetType());</a>
<a name="ln2809">      type_b = atoi(b-&gt;GetType());</a>
<a name="ln2810">      type_c = atoi(c-&gt;GetType());</a>
<a name="ln2811"> </a>
<a name="ln2812">      // skip this angle if the atoms are ignored</a>
<a name="ln2813">      if ( _constraints.IsIgnored(a-&gt;GetIdx()) || _constraints.IsIgnored(b-&gt;GetIdx()) || _constraints.IsIgnored(c-&gt;GetIdx()) )</a>
<a name="ln2814">        continue;</a>
<a name="ln2815"> </a>
<a name="ln2816">      // if there are any groups specified, check if the three angle atoms are in a single intraGroup</a>
<a name="ln2817">      if (HasGroups()) {</a>
<a name="ln2818">        bool validAngle = false;</a>
<a name="ln2819">        for (unsigned int i=0; i &lt; _intraGroup.size(); ++i) {</a>
<a name="ln2820">          if (_intraGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp; _intraGroup[i].BitIsSet(b-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln2821">              _intraGroup[i].BitIsSet(c-&gt;GetIdx())) {</a>
<a name="ln2822">            validAngle = true;</a>
<a name="ln2823">            break;</a>
<a name="ln2824">          }</a>
<a name="ln2825">        }</a>
<a name="ln2826">        if (!validAngle)</a>
<a name="ln2827">          continue;</a>
<a name="ln2828">      }</a>
<a name="ln2829"> </a>
<a name="ln2830">      angletype = GetAngleType(a, b, c);</a>
<a name="ln2831">      strbndtype = GetStrBndType(a, b, c);</a>
<a name="ln2832">      bondtype1 = GetBondType(a, b);</a>
<a name="ln2833">      bondtype2 = GetBondType(b, c);</a>
<a name="ln2834"> </a>
<a name="ln2835">      if (HasLinSet(type_b)) {</a>
<a name="ln2836">        anglecalc.linear = true;</a>
<a name="ln2837">      } else {</a>
<a name="ln2838">        anglecalc.linear = false;</a>
<a name="ln2839">      }</a>
<a name="ln2840"> </a>
<a name="ln2841">      // try exact match</a>
<a name="ln2842">      parameter = GetTypedParameter3Atom(angletype, type_a, type_b, type_c, _ffangleparams);</a>
<a name="ln2843">      if (parameter == nullptr) // try 3-2-3</a>
<a name="ln2844">        parameter = GetTypedParameter3Atom(angletype, EqLvl3(type_a), type_b, EqLvl3(type_c), _ffangleparams);</a>
<a name="ln2845">      if (parameter == nullptr) // try 4-2-4</a>
<a name="ln2846">        parameter = GetTypedParameter3Atom(angletype, EqLvl4(type_a), type_b, EqLvl4(type_c), _ffangleparams);</a>
<a name="ln2847">      if (parameter == nullptr) // try 5-2-5</a>
<a name="ln2848">        parameter = GetTypedParameter3Atom(angletype, EqLvl5(type_a), type_b, EqLvl5(type_c), _ffangleparams);</a>
<a name="ln2849"> </a>
<a name="ln2850">      if (parameter) {</a>
<a name="ln2851">        anglecalc.ka = parameter-&gt;_dpar[0];</a>
<a name="ln2852">        anglecalc.theta0 = parameter-&gt;_dpar[1];</a>
<a name="ln2853">        strbndcalc.theta0 = parameter-&gt;_dpar[1]; // **</a>
<a name="ln2854">      } else {</a>
<a name="ln2855">        IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2856">          snprintf(_logbuf, BUFF_SIZE, &quot;   USING DEFAULT ANGLE FOR %d-%d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx());</a>
<a name="ln2857">          snprintf(_logbuf, BUFF_SIZE, &quot;   USING EMPIRICAL RULE FOR ANGLE BENDING %d-%d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx());</a>
<a name="ln2858">          OBFFLog(_logbuf);</a>
<a name="ln2859">        }</a>
<a name="ln2860"> </a>
<a name="ln2861">        anglecalc.ka = 0.0;</a>
<a name="ln2862">        anglecalc.theta0 = 120.0;</a>
<a name="ln2863"> </a>
<a name="ln2864">        if (GetCrd(type_b) == 4)</a>
<a name="ln2865">          anglecalc.theta0 = 109.45;</a>
<a name="ln2866"> </a>
<a name="ln2867">        if ((GetCrd(type_b) == 2) &amp;&amp; b-&gt;GetAtomicNum() == OBElements::Oxygen)</a>
<a name="ln2868">          anglecalc.theta0 = 105.0;</a>
<a name="ln2869"> </a>
<a name="ln2870">        if (b-&gt;GetAtomicNum() &gt; 10)</a>
<a name="ln2871">          anglecalc.theta0 = 95.0;</a>
<a name="ln2872"> </a>
<a name="ln2873">        if (HasLinSet(type_b))</a>
<a name="ln2874">          anglecalc.theta0 = 180.0;</a>
<a name="ln2875"> </a>
<a name="ln2876">        if ((GetCrd(type_b) == 3) &amp;&amp; (GetVal(type_b) == 3) &amp;&amp; !GetMltb(type_b)) {</a>
<a name="ln2877">          if (b-&gt;GetAtomicNum() == OBElements::Nitrogen) {</a>
<a name="ln2878">            anglecalc.theta0 = 107.0;</a>
<a name="ln2879">          } else {</a>
<a name="ln2880">            anglecalc.theta0 = 92.0;</a>
<a name="ln2881">          }</a>
<a name="ln2882">        }</a>
<a name="ln2883"> </a>
<a name="ln2884">        if (a-&gt;IsInRingSize(3) &amp;&amp; b-&gt;IsInRingSize(3) &amp;&amp; c-&gt;IsInRingSize(3) &amp;&amp; IsInSameRing(a, c))</a>
<a name="ln2885">          anglecalc.theta0 = 60.0;</a>
<a name="ln2886"> </a>
<a name="ln2887">        if (a-&gt;IsInRingSize(4) &amp;&amp; b-&gt;IsInRingSize(4) &amp;&amp; c-&gt;IsInRingSize(4) &amp;&amp; IsInSameRing(a, c))</a>
<a name="ln2888">          anglecalc.theta0 = 90.0;</a>
<a name="ln2889"> </a>
<a name="ln2890">        strbndcalc.theta0 = anglecalc.theta0; // **</a>
<a name="ln2891">      }</a>
<a name="ln2892"> </a>
<a name="ln2893">      // empirical rule for 0-b-0 and standard angles</a>
<a name="ln2894">      if (anglecalc.ka == 0.0) {</a>
<a name="ln2895">        IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2896">          snprintf(_logbuf, BUFF_SIZE, &quot;   USING EMPIRICAL RULE FOR ANGLE BENDING FORCE CONSTANT %d-%d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx());</a>
<a name="ln2897">          OBFFLog(_logbuf);</a>
<a name="ln2898">        }</a>
<a name="ln2899"> </a>
<a name="ln2900">        double beta, Za, Zc, Cb, r0ab, r0bc, theta, theta2, D, rr, rr2;</a>
<a name="ln2901">        Za = GetZParam(a);</a>
<a name="ln2902">        Cb = GetCParam(b); // Fixed typo -- PR#2741658</a>
<a name="ln2903">        Zc = GetZParam(c);</a>
<a name="ln2904"> </a>
<a name="ln2905">        r0ab = GetBondLength(a, b);</a>
<a name="ln2906">        r0bc = GetBondLength(b, c);</a>
<a name="ln2907">        rr = r0ab + r0bc;</a>
<a name="ln2908">        rr2 = rr * rr;</a>
<a name="ln2909">        D = (r0ab - r0bc) / rr2;</a>
<a name="ln2910"> </a>
<a name="ln2911">        theta = anglecalc.theta0;</a>
<a name="ln2912">        theta2 = theta * theta;</a>
<a name="ln2913"> </a>
<a name="ln2914">        beta = 1.75;</a>
<a name="ln2915">        if (a-&gt;IsInRingSize(4) &amp;&amp; b-&gt;IsInRingSize(4) &amp;&amp; c-&gt;IsInRingSize(4) &amp;&amp; IsInSameRing(a, c))</a>
<a name="ln2916">          beta = 0.85 * beta;</a>
<a name="ln2917">        if (a-&gt;IsInRingSize(3) &amp;&amp; b-&gt;IsInRingSize(3) &amp;&amp; c-&gt;IsInRingSize(3) &amp;&amp; IsInSameRing(a, c))</a>
<a name="ln2918">          beta = 0.05 * beta;</a>
<a name="ln2919"> </a>
<a name="ln2920">        // Theta2 is in Degrees^2, but parameters are expecting radians</a>
<a name="ln2921">        // PR#2741669</a>
<a name="ln2922">        anglecalc.ka = (beta * Za * Cb * Zc * exp(-2 * D)) / (rr * theta2 * DEG_TO_RAD * DEG_TO_RAD);</a>
<a name="ln2923">      }</a>
<a name="ln2924"> </a>
<a name="ln2925">      anglecalc.a = a;</a>
<a name="ln2926">      anglecalc.b = b;</a>
<a name="ln2927">      anglecalc.c = c;</a>
<a name="ln2928">      anglecalc.at = angletype;</a>
<a name="ln2929"> </a>
<a name="ln2930">      anglecalc.SetupPointers();</a>
<a name="ln2931">      _anglecalculations.push_back(anglecalc);</a>
<a name="ln2932"> </a>
<a name="ln2933">      if (anglecalc.linear)</a>
<a name="ln2934">        continue;</a>
<a name="ln2935"> </a>
<a name="ln2936">      parameter = GetTypedParameter3Atom(strbndtype, type_a, type_b, type_c, _ffstrbndparams);</a>
<a name="ln2937">      if (parameter == nullptr) {</a>
<a name="ln2938">        int rowa, rowb, rowc;</a>
<a name="ln2939"> </a>
<a name="ln2940">        // This is not a real empirical rule...</a>
<a name="ln2941">        //IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2942">        //  snprintf(_logbuf, BUFF_SIZE, &quot;   USING EMPIRICAL RULE FOR STRETCH-BENDING FORCE CONSTANT %d-%d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx());</a>
<a name="ln2943">        //  OBFFLog(_logbuf);</a>
<a name="ln2944">        //}</a>
<a name="ln2945"> </a>
<a name="ln2946">        rowa = GetElementRow(a);</a>
<a name="ln2947">        rowb = GetElementRow(b);</a>
<a name="ln2948">        rowc = GetElementRow(c);</a>
<a name="ln2949"> </a>
<a name="ln2950">        parameter = GetParameter3Atom(rowa, rowb, rowc, _ffdfsbparams);</a>
<a name="ln2951"> </a>
<a name="ln2952">        if (parameter == nullptr) {</a>
<a name="ln2953">          // This should never happen</a>
<a name="ln2954">          IF_OBFF_LOGLVL_LOW {</a>
<a name="ln2955">            snprintf(_logbuf, BUFF_SIZE, &quot;    COULD NOT FIND PARAMETERS FOR STRETCH-BEND %d-%d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx());</a>
<a name="ln2956">            OBFFLog(_logbuf);</a>
<a name="ln2957">          }</a>
<a name="ln2958">          return false;</a>
<a name="ln2959">        }</a>
<a name="ln2960"> </a>
<a name="ln2961">        if (rowa == parameter-&gt;a) {</a>
<a name="ln2962">          strbndcalc.kbaABC = parameter-&gt;_dpar[0];</a>
<a name="ln2963">          strbndcalc.kbaCBA = parameter-&gt;_dpar[1];</a>
<a name="ln2964">        } else {</a>
<a name="ln2965">          strbndcalc.kbaABC = parameter-&gt;_dpar[1];</a>
<a name="ln2966">          strbndcalc.kbaCBA = parameter-&gt;_dpar[0];</a>
<a name="ln2967">        }</a>
<a name="ln2968">      } else {</a>
<a name="ln2969">        if (type_a == parameter-&gt;a) {</a>
<a name="ln2970">          strbndcalc.kbaABC = parameter-&gt;_dpar[0];</a>
<a name="ln2971">          strbndcalc.kbaCBA = parameter-&gt;_dpar[1];</a>
<a name="ln2972">        } else {</a>
<a name="ln2973">          strbndcalc.kbaABC = parameter-&gt;_dpar[1];</a>
<a name="ln2974">          strbndcalc.kbaCBA = parameter-&gt;_dpar[0];</a>
<a name="ln2975">        }</a>
<a name="ln2976">      }</a>
<a name="ln2977"> </a>
<a name="ln2978">      strbndcalc.rab0 = GetBondLength(a, b);</a>
<a name="ln2979">      strbndcalc.rbc0 = GetBondLength(b ,c);</a>
<a name="ln2980">      strbndcalc.a = a;</a>
<a name="ln2981">      strbndcalc.b = b;</a>
<a name="ln2982">      strbndcalc.c = c;</a>
<a name="ln2983">      strbndcalc.sbt = strbndtype;</a>
<a name="ln2984">      strbndcalc.SetupPointers();</a>
<a name="ln2985">      // Set the pointers to addresses in the anglecalc, find the matching bondcalcs and do the same.</a>
<a name="ln2986">      // This should improve performance by not calculating all this twice. We could do the same</a>
<a name="ln2987">      // for torsion and angles since the bond lengths are calculated for bond stretching first.</a>
<a name="ln2988">      //bool found_angle = false;</a>
<a name="ln2989">      /*</a>
<a name="ln2990">        for (unsigned int ai = 0; ai &lt; _anglecalculations.size(); ++ai) {</a>
<a name="ln2991">        if ( (_anglecalculations[ai].a-&gt;GetIdx() == a-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln2992">        (_anglecalculations[ai].b-&gt;GetIdx() == b-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln2993">        (_anglecalculations[ai].c-&gt;GetIdx() == c-&gt;GetIdx()) ) {</a>
<a name="ln2994">        strbndcalc.theta = &amp;(_anglecalculations[ai].theta);</a>
<a name="ln2995">        strbndcalc.force_abc_a = _anglecalculations[ai].force_a;</a>
<a name="ln2996">        strbndcalc.force_abc_b = _anglecalculations[ai].force_b;</a>
<a name="ln2997">        strbndcalc.force_abc_c = _anglecalculations[ai].force_c;</a>
<a name="ln2998">        found_angle = true;</a>
<a name="ln2999">        break;</a>
<a name="ln3000">        } else if ( (_anglecalculations[ai].a-&gt;GetIdx() == c-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln3001">        (_anglecalculations[ai].b-&gt;GetIdx() == b-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln3002">        (_anglecalculations[ai].c-&gt;GetIdx() == a-&gt;GetIdx()) ) {</a>
<a name="ln3003">        strbndcalc.theta = &amp;(_anglecalculations[ai].theta);</a>
<a name="ln3004">        strbndcalc.force_abc_a = _anglecalculations[ai].force_c;</a>
<a name="ln3005">        strbndcalc.force_abc_b = _anglecalculations[ai].force_b;</a>
<a name="ln3006">        strbndcalc.force_abc_c = _anglecalculations[ai].force_a;</a>
<a name="ln3007">        found_angle = true;</a>
<a name="ln3008">        break;</a>
<a name="ln3009">        }</a>
<a name="ln3010">        }</a>
<a name="ln3011">      */</a>
<a name="ln3012"> </a>
<a name="ln3013">      /*</a>
<a name="ln3014">        vector&lt;OBFFAngleCalculationMMFF94&gt;::iterator ai;</a>
<a name="ln3015">        for (ai = _anglecalculations.begin(); ai != _anglecalculations.end(); ++ai) {</a>
<a name="ln3016">        if ( (((*ai).a)-&gt;GetIdx() == a-&gt;GetIdx()) &amp;&amp; (((*ai).b)-&gt;GetIdx() == b-&gt;GetIdx()) &amp;&amp; (((*ai).c)-&gt;GetIdx() == c-&gt;GetIdx()) ) {</a>
<a name="ln3017">        strbndcalc.theta = (*ai).theta;</a>
<a name="ln3018">        cout &lt;&lt; &quot;theta prt       = &quot; &lt;&lt; (*ai).theta &lt;&lt; endl;</a>
<a name="ln3019">        cout &lt;&lt; &quot;delta prt       = &quot; &lt;&lt; &amp;((*ai).delta) &lt;&lt; endl;</a>
<a name="ln3020">        cout &lt;&lt; &quot;GetThetaPointer = &quot; &lt;&lt; ai-&gt;GetThetaPointer() &lt;&lt; endl;</a>
<a name="ln3021">        strbndcalc.force_abc_a = (*ai).force_a;</a>
<a name="ln3022">        strbndcalc.force_abc_b = (*ai).force_b;</a>
<a name="ln3023">        strbndcalc.force_abc_c = (*ai).force_c;</a>
<a name="ln3024">        found_angle = true;</a>
<a name="ln3025">        break;</a>
<a name="ln3026">        } else if ( (((*ai).a)-&gt;GetIdx() == c-&gt;GetIdx()) &amp;&amp; (((*ai).b)-&gt;GetIdx() == b-&gt;GetIdx()) &amp;&amp; (((*ai).c)-&gt;GetIdx() == a-&gt;GetIdx()) ) {</a>
<a name="ln3027">        strbndcalc.theta = (*ai).theta;</a>
<a name="ln3028">        strbndcalc.force_abc_a = (*ai).force_c;</a>
<a name="ln3029">        strbndcalc.force_abc_b = (*ai).force_b;</a>
<a name="ln3030">        strbndcalc.force_abc_c = (*ai).force_a;</a>
<a name="ln3031">        found_angle = true;</a>
<a name="ln3032">        break;</a>
<a name="ln3033">        }</a>
<a name="ln3034">        }</a>
<a name="ln3035">        if (!found_angle) // didn't find matching angle, shouldn't happen, but continue to be safe</a>
<a name="ln3036">        continue;</a>
<a name="ln3037"> </a>
<a name="ln3038"> </a>
<a name="ln3039">        bool found_rab = false;</a>
<a name="ln3040">        bool found_rbc = false;</a>
<a name="ln3041">        vector&lt;OBFFBondCalculationMMFF94&gt;::iterator bi;</a>
<a name="ln3042">        for (bi = _bondcalculations.begin(); bi != _bondcalculations.end(); ++bi) {</a>
<a name="ln3043">        // find rab</a>
<a name="ln3044">        if ( (((*bi).a)-&gt;GetIdx() == a-&gt;GetIdx()) &amp;&amp; (((*bi).b)-&gt;GetIdx() == b-&gt;GetIdx()) ) {</a>
<a name="ln3045">        strbndcalc.rab = &amp;((*bi).rab);</a>
<a name="ln3046">        strbndcalc.force_ab_a = (*bi).force_a;</a>
<a name="ln3047">        strbndcalc.force_ab_b = (*bi).force_b;</a>
<a name="ln3048">        found_rab = true;</a>
<a name="ln3049">        } else if ( (((*bi).a)-&gt;GetIdx() == b-&gt;GetIdx()) &amp;&amp; (((*bi).b)-&gt;GetIdx() == a-&gt;GetIdx()) ) {</a>
<a name="ln3050">        strbndcalc.rab = &amp;((*bi).rab);</a>
<a name="ln3051">        strbndcalc.force_ab_a = (*bi).force_b;</a>
<a name="ln3052">        strbndcalc.force_ab_b = (*bi).force_a;</a>
<a name="ln3053">        found_rab = true;</a>
<a name="ln3054">        }</a>
<a name="ln3055">        // find rbc</a>
<a name="ln3056">        if ( (((*bi).a)-&gt;GetIdx() == b-&gt;GetIdx()) &amp;&amp; (((*bi).b)-&gt;GetIdx() == c-&gt;GetIdx()) ) {</a>
<a name="ln3057">        strbndcalc.rbc = &amp;(bondcalc.rab);</a>
<a name="ln3058">        strbndcalc.force_ab_a = (*bi).force_a;</a>
<a name="ln3059">        strbndcalc.force_ab_b = (*bi).force_b;</a>
<a name="ln3060">        found_rbc = true;</a>
<a name="ln3061">        } else if ( (((*bi).a)-&gt;GetIdx() == c-&gt;GetIdx()) &amp;&amp; (((*bi).b)-&gt;GetIdx() == b-&gt;GetIdx()) ) {</a>
<a name="ln3062">        strbndcalc.rbc = &amp;(bondcalc.rab);</a>
<a name="ln3063">        strbndcalc.force_ab_a = (*bi).force_b;</a>
<a name="ln3064">        strbndcalc.force_ab_b = (*bi).force_a;</a>
<a name="ln3065">        found_rbc = true;</a>
<a name="ln3066">        }</a>
<a name="ln3067"> </a>
<a name="ln3068">        if (found_rab &amp;&amp; found_rbc)</a>
<a name="ln3069">        break;</a>
<a name="ln3070">        }</a>
<a name="ln3071">        if (!found_rab || !found_rbc) // didn't find matching bond, or atoms overlap</a>
<a name="ln3072">        continue;</a>
<a name="ln3073">      */</a>
<a name="ln3074">      _strbndcalculations.push_back(strbndcalc);</a>
<a name="ln3075"> </a>
<a name="ln3076">    }</a>
<a name="ln3077"> </a>
<a name="ln3078">    //</a>
<a name="ln3079">    // Torsion Calculations</a>
<a name="ln3080">    //</a>
<a name="ln3081">    // MMFF part I - page 513 (&quot;step-down&quot; prodedure)</a>
<a name="ln3082">    // MMFF part I - page 519 (reference 68 is actually a footnote)</a>
<a name="ln3083">    // MMFF part IV - page 631 (empirical rule)</a>
<a name="ln3084">    //</a>
<a name="ln3085">    // First try and find an exact match, if this fails, step down using the equivalences from mmffdef.par</a>
<a name="ln3086">    // five-stage protocol: 1-1-1-1, 2-2-2-2, 3-2-2-5, 5-2-2-3, 5-2-2-5</a>
<a name="ln3087">    // If this fails, use empirical rules</a>
<a name="ln3088">    // Since 1-1-1-1 = 2-2-2-2, we will only try 1-1-1-1 before going to 3-2-2-5</a>
<a name="ln3089">    //</a>
<a name="ln3090">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln3091">      OBFFLog(&quot;SETTING UP TORSION CALCULATIONS...\n&quot;);</a>
<a name="ln3092"> </a>
<a name="ln3093">    OBFFTorsionCalculationMMFF94 torsioncalc;</a>
<a name="ln3094">    int torsiontype;</a>
<a name="ln3095"> </a>
<a name="ln3096">    _torsioncalculations.clear();</a>
<a name="ln3097"> </a>
<a name="ln3098">    FOR_TORSIONS_OF_MOL(t, _mol) {</a>
<a name="ln3099">      a = _mol.GetAtom((*t)[0] + 1);</a>
<a name="ln3100">      b = _mol.GetAtom((*t)[1] + 1);</a>
<a name="ln3101">      c = _mol.GetAtom((*t)[2] + 1);</a>
<a name="ln3102">      d = _mol.GetAtom((*t)[3] + 1);</a>
<a name="ln3103"> </a>
<a name="ln3104">      type_a = atoi(a-&gt;GetType());</a>
<a name="ln3105">      type_b = atoi(b-&gt;GetType());</a>
<a name="ln3106">      type_c = atoi(c-&gt;GetType());</a>
<a name="ln3107">      type_d = atoi(d-&gt;GetType());</a>
<a name="ln3108"> </a>
<a name="ln3109">      // skip this torsion if the atoms are ignored</a>
<a name="ln3110">      if ( _constraints.IsIgnored(a-&gt;GetIdx()) || _constraints.IsIgnored(b-&gt;GetIdx()) ||</a>
<a name="ln3111">           _constraints.IsIgnored(c-&gt;GetIdx()) || _constraints.IsIgnored(d-&gt;GetIdx()) )</a>
<a name="ln3112">        continue;</a>
<a name="ln3113"> </a>
<a name="ln3114">      // if there are any groups specified, check if the four torsion atoms are in a single intraGroup</a>
<a name="ln3115">      if (HasGroups()) {</a>
<a name="ln3116">        bool validTorsion = false;</a>
<a name="ln3117">        for (unsigned int i=0; i &lt; _intraGroup.size(); ++i) {</a>
<a name="ln3118">          if (_intraGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp; _intraGroup[i].BitIsSet(b-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln3119">              _intraGroup[i].BitIsSet(c-&gt;GetIdx()) &amp;&amp; _intraGroup[i].BitIsSet(d-&gt;GetIdx())) {</a>
<a name="ln3120">            validTorsion = true;</a>
<a name="ln3121">            break;</a>
<a name="ln3122">          }</a>
<a name="ln3123">        }</a>
<a name="ln3124">        if (!validTorsion)</a>
<a name="ln3125">          continue;</a>
<a name="ln3126">      }</a>
<a name="ln3127"> </a>
<a name="ln3128">      torsiontype = GetTorsionType(a, b, c, d);</a>
<a name="ln3129">      // CXT = MC*(J*MA**3 + K*MA**2 + I*MA + L) + TTijkl  MC = 6, MA = 136</a>
<a name="ln3130">      order = (type_c*2515456 + type_b*18496 + type_d*136 + type_a)</a>
<a name="ln3131">        - (type_b*2515456 + type_c*18496 + type_a*136 + type_d);</a>
<a name="ln3132"> </a>
<a name="ln3133">      if (order &gt;= 0) {</a>
<a name="ln3134">        // try exact match</a>
<a name="ln3135">        parameter = GetTypedParameter4Atom(torsiontype, type_a, type_b, type_c, type_d, _fftorsionparams);</a>
<a name="ln3136">        if (parameter == nullptr) // try 3-2-2-5</a>
<a name="ln3137">          parameter = GetTypedParameter4Atom(torsiontype, EqLvl3(type_a), type_b, type_c, EqLvl5(type_d), _fftorsionparams);</a>
<a name="ln3138">        if (parameter == nullptr) // try 5-2-2-3</a>
<a name="ln3139">          parameter = GetTypedParameter4Atom(torsiontype, EqLvl5(type_a), type_b, type_c, EqLvl3(type_d), _fftorsionparams);</a>
<a name="ln3140">        if (parameter == nullptr) // try 5-2-2-5</a>
<a name="ln3141">          parameter = GetTypedParameter4Atom(torsiontype, EqLvl5(type_a), type_b, type_c, EqLvl5(type_d), _fftorsionparams);</a>
<a name="ln3142">      } else {</a>
<a name="ln3143">        // try exact match</a>
<a name="ln3144">        parameter = GetTypedParameter4Atom(torsiontype, type_d, type_c, type_b, type_a, _fftorsionparams);</a>
<a name="ln3145">        if (parameter == nullptr) // try 3-2-2-5</a>
<a name="ln3146">          parameter = GetTypedParameter4Atom(torsiontype, EqLvl3(type_d), type_c, type_b, EqLvl5(type_a), _fftorsionparams);</a>
<a name="ln3147">        if (parameter == nullptr) // try 5-2-2-3</a>
<a name="ln3148">          parameter = GetTypedParameter4Atom(torsiontype, EqLvl5(type_d), type_c, type_b, EqLvl3(type_a), _fftorsionparams);</a>
<a name="ln3149">        if (parameter == nullptr) // try 5-2-2-5</a>
<a name="ln3150">          parameter = GetTypedParameter4Atom(torsiontype, EqLvl5(type_d), type_c, type_b, EqLvl5(type_a), _fftorsionparams);</a>
<a name="ln3151">      }</a>
<a name="ln3152"> </a>
<a name="ln3153">      if (parameter) {</a>
<a name="ln3154">        torsioncalc.v1 = parameter-&gt;_dpar[0];</a>
<a name="ln3155">        torsioncalc.v2 = parameter-&gt;_dpar[1];</a>
<a name="ln3156">        torsioncalc.v3 = parameter-&gt;_dpar[2];</a>
<a name="ln3157">      } else {</a>
<a name="ln3158">        bool found_rule = false;</a>
<a name="ln3159"> </a>
<a name="ln3160">        //IF_OBFF_LOGLVL_LOW {</a>
<a name="ln3161">        //  snprintf(_logbuf, BUFF_SIZE, &quot;   USING EMPIRICAL RULE FOR TORSION FORCE CONSTANT %d-%d-%d-%d (IDX)...\n&quot;,</a>
<a name="ln3162">        //    a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx(), d-&gt;GetIdx());</a>
<a name="ln3163">        //  OBFFLog(_logbuf);</a>
<a name="ln3164">        //}</a>
<a name="ln3165"> </a>
<a name="ln3166">        // rule (a) page 631</a>
<a name="ln3167">        if (HasLinSet(type_b) || HasLinSet(type_c))</a>
<a name="ln3168">          continue;</a>
<a name="ln3169"> </a>
<a name="ln3170">        // rule (b) page 631</a>
<a name="ln3171">        if (b-&gt;GetBond(c)-&gt;IsAromatic()) {</a>
<a name="ln3172">          double Ub, Uc, pi_bc, beta;</a>
<a name="ln3173">          Ub = GetUParam(b);</a>
<a name="ln3174">          Uc = GetUParam(c);</a>
<a name="ln3175"> </a>
<a name="ln3176">          if (!HasPilpSet(type_b) &amp;&amp; !HasPilpSet(type_c))</a>
<a name="ln3177">            pi_bc = 0.5;</a>
<a name="ln3178">          else</a>
<a name="ln3179">            pi_bc = 0.3;</a>
<a name="ln3180"> </a>
<a name="ln3181">          if (((GetVal(type_b) == 3) &amp;&amp; (GetVal(type_c) == 4)) ||</a>
<a name="ln3182">              ((GetVal(type_b) == 4) &amp;&amp; (GetVal(type_c) == 3)))</a>
<a name="ln3183">            beta = 3.0;</a>
<a name="ln3184">          else</a>
<a name="ln3185">            beta = 6.0;</a>
<a name="ln3186"> </a>
<a name="ln3187">          torsioncalc.v1 = 0.0;</a>
<a name="ln3188">          torsioncalc.v2 = beta * pi_bc * sqrt(Ub * Uc);</a>
<a name="ln3189">          torsioncalc.v3 = 0.0;</a>
<a name="ln3190">          found_rule = true;</a>
<a name="ln3191">        } else {</a>
<a name="ln3192">          // rule (c) page 631</a>
<a name="ln3193">       	  double Ub, Uc, pi_bc, beta;</a>
<a name="ln3194">          Ub = GetUParam(b);</a>
<a name="ln3195">          Uc = GetUParam(c);</a>
<a name="ln3196">          OBBond *bond = a-&gt;GetBond(b);</a>
<a name="ln3197">          if (((GetMltb(type_b) == 2) &amp;&amp; (GetMltb(type_c) == 2)) &amp;&amp; !bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2)</a>
<a name="ln3198">            pi_bc = 1.0;</a>
<a name="ln3199">          else</a>
<a name="ln3200">            pi_bc = 0.4;</a>
<a name="ln3201"> </a>
<a name="ln3202">          beta = 6.0;</a>
<a name="ln3203">          torsioncalc.v1 = 0.0;</a>
<a name="ln3204">          torsioncalc.v2 = beta * pi_bc * sqrt(Ub * Uc);</a>
<a name="ln3205">          torsioncalc.v3 = 0.0;</a>
<a name="ln3206">          found_rule = true;</a>
<a name="ln3207">        }</a>
<a name="ln3208"> </a>
<a name="ln3209">        // rule (d) page 632</a>
<a name="ln3210">        if (!found_rule)</a>
<a name="ln3211">          if (((GetCrd(type_b) == 4) &amp;&amp; (GetCrd(type_c) == 4))) {</a>
<a name="ln3212">            double Vb, Vc;</a>
<a name="ln3213">            Vb = GetVParam(b);</a>
<a name="ln3214">            Vc = GetVParam(c);</a>
<a name="ln3215"> </a>
<a name="ln3216">            torsioncalc.v1 = 0.0;</a>
<a name="ln3217">            torsioncalc.v2 = 0.0;</a>
<a name="ln3218">            torsioncalc.v3 = sqrt(Vb * Vc) / 9.0;</a>
<a name="ln3219">            found_rule = true;</a>
<a name="ln3220">          }</a>
<a name="ln3221"> </a>
<a name="ln3222">        // rule (e) page 632</a>
<a name="ln3223">        if (!found_rule)</a>
<a name="ln3224">          if (((GetCrd(type_b) == 4) &amp;&amp; (GetCrd(type_c) != 4))) {</a>
<a name="ln3225">            if (GetCrd(type_c) == 3) // case (1)</a>
<a name="ln3226">              if ((GetVal(type_c) == 4) || (GetVal(type_c) == 34) || (GetMltb(type_c) != 0))</a>
<a name="ln3227">                continue;</a>
<a name="ln3228"> </a>
<a name="ln3229">            if (GetCrd(type_c) == 2) // case (2)</a>
<a name="ln3230">              if ((GetVal(type_c) == 3) || (GetMltb(type_c) != 0))</a>
<a name="ln3231">                continue;</a>
<a name="ln3232"> </a>
<a name="ln3233">            // case (3) saturated bonds -- see rule (h)</a>
<a name="ln3234">          }</a>
<a name="ln3235"> </a>
<a name="ln3236">        // rule (f) page 632</a>
<a name="ln3237">        if (!found_rule)</a>
<a name="ln3238">          if (((GetCrd(type_b) != 4) &amp;&amp; (GetCrd(type_c) == 4))) {</a>
<a name="ln3239">            if (GetCrd(type_b) == 3) // case (1)</a>
<a name="ln3240">              if ((GetVal(type_b) == 4) || (GetVal(type_b) == 34) || (GetMltb(type_b) != 0))</a>
<a name="ln3241">                continue;</a>
<a name="ln3242"> </a>
<a name="ln3243">            if (GetCrd(type_b) == 2) // case (2)</a>
<a name="ln3244">              if ((GetVal(type_b) == 3) || (GetMltb(type_b) != 0))</a>
<a name="ln3245">                continue;</a>
<a name="ln3246"> </a>
<a name="ln3247">            // case (3) saturated bonds</a>
<a name="ln3248">          }</a>
<a name="ln3249"> </a>
<a name="ln3250">        // rule (g) page 632</a>
<a name="ln3251">        if (!found_rule) {</a>
<a name="ln3252">          OBBond *bond = b-&gt;GetBond(c);</a>
<a name="ln3253">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 1 &amp;&amp; (</a>
<a name="ln3254">            (GetMltb(type_b) &amp;&amp; GetMltb(type_c)) ||</a>
<a name="ln3255">            (GetMltb(type_b) &amp;&amp; HasPilpSet(type_c)) ||</a>
<a name="ln3256">            (GetMltb(type_c) &amp;&amp; HasPilpSet(type_b)))) {</a>
<a name="ln3257">            if (HasPilpSet(type_b) &amp;&amp; HasPilpSet(type_c)) // case (1)</a>
<a name="ln3258">              continue;</a>
<a name="ln3259"> </a>
<a name="ln3260">            double Ub, Uc, pi_bc, beta;</a>
<a name="ln3261">            Ub = GetUParam(b);</a>
<a name="ln3262">            Uc = GetUParam(c);</a>
<a name="ln3263">            beta = 6.0;</a>
<a name="ln3264"> </a>
<a name="ln3265">            if (HasPilpSet(type_b) &amp;&amp; GetMltb(type_c)) { // case (2)</a>
<a name="ln3266">              if (GetMltb(type_c) == 1)</a>
<a name="ln3267">                pi_bc = 0.5;</a>
<a name="ln3268">              else if ((GetElementRow(b) == 1) &amp;&amp; (GetElementRow(c) == 1))</a>
<a name="ln3269">                pi_bc = 0.3;</a>
<a name="ln3270">              else</a>
<a name="ln3271">                pi_bc = 0.15;</a>
<a name="ln3272">              found_rule = true;</a>
<a name="ln3273">            }</a>
<a name="ln3274"> </a>
<a name="ln3275">            if (HasPilpSet(type_c) &amp;&amp; GetMltb(type_b)) { // case (3)</a>
<a name="ln3276">              if (GetMltb(type_b) == 1)</a>
<a name="ln3277">                pi_bc = 0.5;</a>
<a name="ln3278">              else if ((GetElementRow(b) == 1) &amp;&amp; (GetElementRow(c) == 1))</a>
<a name="ln3279">                pi_bc = 0.3;</a>
<a name="ln3280">              else</a>
<a name="ln3281">                pi_bc = 0.15;</a>
<a name="ln3282">              found_rule = true;</a>
<a name="ln3283">            }</a>
<a name="ln3284"> </a>
<a name="ln3285">            if (!found_rule)</a>
<a name="ln3286">              if (((GetMltb(type_b) == 1) || (GetMltb(type_c) == 1)) &amp;&amp; (b-&gt;GetAtomicNum() != OBElements::Carbon || c-&gt;GetAtomicNum() != OBElements::Carbon)) {</a>
<a name="ln3287">                pi_bc = 0.4;</a>
<a name="ln3288">                found_rule = true;</a>
<a name="ln3289">              }</a>
<a name="ln3290"> </a>
<a name="ln3291">            if (!found_rule)</a>
<a name="ln3292">              pi_bc = 0.15;</a>
<a name="ln3293"> </a>
<a name="ln3294">            torsioncalc.v1 = 0.0;</a>
<a name="ln3295">            torsioncalc.v2 = beta * pi_bc * sqrt(Ub * Uc);</a>
<a name="ln3296">            torsioncalc.v3 = 0.0;</a>
<a name="ln3297">            found_rule = true;</a>
<a name="ln3298">          }</a>
<a name="ln3299">        }</a>
<a name="ln3300"> </a>
<a name="ln3301">        // rule (h) page 632</a>
<a name="ln3302">        if (!found_rule) {</a>
<a name="ln3303">          if ((b-&gt;GetAtomicNum() == OBElements::Oxygen || b-&gt;GetAtomicNum() == OBElements::Sulfur) &amp;&amp; (c-&gt;GetAtomicNum() == OBElements::Oxygen || c-&gt;GetAtomicNum() == OBElements::Sulfur)) {</a>
<a name="ln3304">            double Wb, Wc;</a>
<a name="ln3305"> </a>
<a name="ln3306">            if (b-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln3307">              Wb = 2.0;</a>
<a name="ln3308">            }</a>
<a name="ln3309">            else {</a>
<a name="ln3310">              Wb = 8.0;</a>
<a name="ln3311">            }</a>
<a name="ln3312"> </a>
<a name="ln3313">            if (c-&gt;GetAtomicNum() == OBElements::Oxygen) {</a>
<a name="ln3314">              Wc = 2.0;</a>
<a name="ln3315">            }</a>
<a name="ln3316">            else {</a>
<a name="ln3317">              Wc = 8.0;</a>
<a name="ln3318">            }</a>
<a name="ln3319"> </a>
<a name="ln3320">            torsioncalc.v1 = 0.0;</a>
<a name="ln3321">            torsioncalc.v2 = -sqrt(Wb * Wc);</a>
<a name="ln3322">            torsioncalc.v3 = 0.0;</a>
<a name="ln3323">          } else {</a>
<a name="ln3324">            double Vb, Vc, Nbc;</a>
<a name="ln3325">            Vb = GetVParam(b);</a>
<a name="ln3326">            Vc = GetVParam(c);</a>
<a name="ln3327"> </a>
<a name="ln3328">            IF_OBFF_LOGLVL_LOW {</a>
<a name="ln3329">              snprintf(_logbuf, BUFF_SIZE, &quot;   USING EMPIRICAL RULE FOR TORSION FORCE CONSTANT %d-%d-%d-%d (IDX)...\n&quot;,</a>
<a name="ln3330">                      a-&gt;GetIdx(), b-&gt;GetIdx(), c-&gt;GetIdx(), d-&gt;GetIdx());</a>
<a name="ln3331">              OBFFLog(_logbuf);</a>
<a name="ln3332">            }</a>
<a name="ln3333"> </a>
<a name="ln3334">            Nbc = GetCrd(type_b) * GetCrd(type_c);</a>
<a name="ln3335"> </a>
<a name="ln3336">            torsioncalc.v1 = 0.0;</a>
<a name="ln3337">            torsioncalc.v2 = 0.0;</a>
<a name="ln3338">            torsioncalc.v3 = sqrt(Vb * Vc) / Nbc;</a>
<a name="ln3339">          }</a>
<a name="ln3340">        }</a>
<a name="ln3341">      }</a>
<a name="ln3342"> </a>
<a name="ln3343">      torsioncalc.a = a;</a>
<a name="ln3344">      torsioncalc.b = b;</a>
<a name="ln3345">      torsioncalc.c = c;</a>
<a name="ln3346">      torsioncalc.d = d;</a>
<a name="ln3347">      torsioncalc.SetupPointers();</a>
<a name="ln3348">      torsioncalc.tt = torsiontype;</a>
<a name="ln3349"> </a>
<a name="ln3350">      _torsioncalculations.push_back(torsioncalc);</a>
<a name="ln3351">    }</a>
<a name="ln3352"> </a>
<a name="ln3353">    //</a>
<a name="ln3354">    // Out-Of-Plane Calculations</a>
<a name="ln3355">    //</a>
<a name="ln3356">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln3357">      OBFFLog(&quot;SETTING UP OOP CALCULATIONS...\n&quot;);</a>
<a name="ln3358"> </a>
<a name="ln3359">    OBFFOOPCalculationMMFF94 oopcalc;</a>
<a name="ln3360"> </a>
<a name="ln3361">    _oopcalculations.clear();</a>
<a name="ln3362"> </a>
<a name="ln3363">    FOR_ATOMS_OF_MOL(atom, _mol) {</a>
<a name="ln3364">      b = (OBAtom*) &amp;*atom;</a>
<a name="ln3365"> </a>
<a name="ln3366">      found = false;</a>
<a name="ln3367"> </a>
<a name="ln3368">      type_b = atoi(b-&gt;GetType());</a>
<a name="ln3369"> </a>
<a name="ln3370">      for (unsigned int idx=0; idx &lt; _ffoopparams.size(); idx++) {</a>
<a name="ln3371">        if (type_b == _ffoopparams[idx].b) {</a>
<a name="ln3372">          a = nullptr;</a>
<a name="ln3373">          c = nullptr;</a>
<a name="ln3374">          d = nullptr;</a>
<a name="ln3375"> </a>
<a name="ln3376">          FOR_NBORS_OF_ATOM(nbr, b) {</a>
<a name="ln3377">            if (a ==nullptr)</a>
<a name="ln3378">              a = (OBAtom*) &amp;*nbr;</a>
<a name="ln3379">            else if (c == nullptr)</a>
<a name="ln3380">              c = (OBAtom*) &amp;*nbr;</a>
<a name="ln3381">            else</a>
<a name="ln3382">              d = (OBAtom*) &amp;*nbr;</a>
<a name="ln3383">          }</a>
<a name="ln3384"> </a>
<a name="ln3385">          if (a == nullptr || c == nullptr || d == nullptr)</a>
<a name="ln3386">            break;</a>
<a name="ln3387"> </a>
<a name="ln3388">          type_a = atoi(a-&gt;GetType());</a>
<a name="ln3389">          type_c = atoi(c-&gt;GetType());</a>
<a name="ln3390">          type_d = atoi(d-&gt;GetType());</a>
<a name="ln3391"> </a>
<a name="ln3392">          // skip this oop if the atoms are ignored</a>
<a name="ln3393">          if ( _constraints.IsIgnored(a-&gt;GetIdx()) || _constraints.IsIgnored(b-&gt;GetIdx()) ||</a>
<a name="ln3394">               _constraints.IsIgnored(c-&gt;GetIdx()) || _constraints.IsIgnored(d-&gt;GetIdx()) )</a>
<a name="ln3395">            continue;</a>
<a name="ln3396"> </a>
<a name="ln3397">          // if there are any groups specified, check if the four oop atoms are in a single intraGroup</a>
<a name="ln3398">          if (HasGroups()) {</a>
<a name="ln3399">            bool validOOP = false;</a>
<a name="ln3400">            for (unsigned int i=0; i &lt; _intraGroup.size(); ++i) {</a>
<a name="ln3401">              if (_intraGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp; _intraGroup[i].BitIsSet(b-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln3402">                  _intraGroup[i].BitIsSet(c-&gt;GetIdx()) &amp;&amp; _intraGroup[i].BitIsSet(d-&gt;GetIdx())) {</a>
<a name="ln3403">                validOOP = true;</a>
<a name="ln3404">                break;</a>
<a name="ln3405">              }</a>
<a name="ln3406">            }</a>
<a name="ln3407">            if (!validOOP)</a>
<a name="ln3408">              continue;</a>
<a name="ln3409">          }</a>
<a name="ln3410"> </a>
<a name="ln3411">          if (((type_a == _ffoopparams[idx].a) &amp;&amp; (type_c == _ffoopparams[idx].c) &amp;&amp; (type_d == _ffoopparams[idx].d)) ||</a>
<a name="ln3412">              ((type_c == _ffoopparams[idx].a) &amp;&amp; (type_a == _ffoopparams[idx].c) &amp;&amp; (type_d == _ffoopparams[idx].d)) ||</a>
<a name="ln3413">              ((type_c == _ffoopparams[idx].a) &amp;&amp; (type_d == _ffoopparams[idx].c) &amp;&amp; (type_a == _ffoopparams[idx].d)) ||</a>
<a name="ln3414">              ((type_d == _ffoopparams[idx].a) &amp;&amp; (type_c == _ffoopparams[idx].c) &amp;&amp; (type_a == _ffoopparams[idx].d)) ||</a>
<a name="ln3415">              ((type_a == _ffoopparams[idx].a) &amp;&amp; (type_d == _ffoopparams[idx].c) &amp;&amp; (type_c == _ffoopparams[idx].d)) ||</a>
<a name="ln3416">              ((type_d == _ffoopparams[idx].a) &amp;&amp; (type_a == _ffoopparams[idx].c) &amp;&amp; (type_c == _ffoopparams[idx].d)))</a>
<a name="ln3417">            {</a>
<a name="ln3418">              found = true;</a>
<a name="ln3419"> </a>
<a name="ln3420">              oopcalc.koop = _ffoopparams[idx]._dpar[0];</a>
<a name="ln3421"> </a>
<a name="ln3422">              // A-B-CD || C-B-AD  PLANE = ABC</a>
<a name="ln3423">              oopcalc.a = a;</a>
<a name="ln3424">              oopcalc.b = b;</a>
<a name="ln3425">              oopcalc.c = c;</a>
<a name="ln3426">              oopcalc.d = d;</a>
<a name="ln3427"> </a>
<a name="ln3428">              oopcalc.SetupPointers();</a>
<a name="ln3429">              _oopcalculations.push_back(oopcalc);</a>
<a name="ln3430"> </a>
<a name="ln3431">              // C-B-DA || D-B-CA  PLANE BCD</a>
<a name="ln3432">              oopcalc.a = d;</a>
<a name="ln3433">              oopcalc.d = a;</a>
<a name="ln3434"> </a>
<a name="ln3435">              oopcalc.SetupPointers();</a>
<a name="ln3436">              _oopcalculations.push_back(oopcalc);</a>
<a name="ln3437"> </a>
<a name="ln3438">              // A-B-DC || D-B-AC  PLANE ABD</a>
<a name="ln3439">              oopcalc.a = a;</a>
<a name="ln3440">              oopcalc.c = d;</a>
<a name="ln3441">              oopcalc.d = c;</a>
<a name="ln3442"> </a>
<a name="ln3443">              oopcalc.SetupPointers();</a>
<a name="ln3444">              _oopcalculations.push_back(oopcalc);</a>
<a name="ln3445">            }</a>
<a name="ln3446"> </a>
<a name="ln3447">          if ((_ffoopparams[idx].a == 0) &amp;&amp; (_ffoopparams[idx].c == 0) &amp;&amp; (_ffoopparams[idx].d == 0) &amp;&amp; !found) // *-XX-*-*</a>
<a name="ln3448">            {</a>
<a name="ln3449">              oopcalc.koop = _ffoopparams[idx]._dpar[0];</a>
<a name="ln3450"> </a>
<a name="ln3451">              // A-B-CD || C-B-AD  PLANE = ABC</a>
<a name="ln3452">              oopcalc.a = a;</a>
<a name="ln3453">              oopcalc.b = b;</a>
<a name="ln3454">              oopcalc.c = c;</a>
<a name="ln3455">              oopcalc.d = d;</a>
<a name="ln3456"> </a>
<a name="ln3457">              oopcalc.SetupPointers();</a>
<a name="ln3458">              _oopcalculations.push_back(oopcalc);</a>
<a name="ln3459"> </a>
<a name="ln3460">              // C-B-DA || D-B-CA  PLANE BCD</a>
<a name="ln3461">              oopcalc.a = d;</a>
<a name="ln3462">              oopcalc.d = a;</a>
<a name="ln3463"> </a>
<a name="ln3464">              oopcalc.SetupPointers();</a>
<a name="ln3465">              _oopcalculations.push_back(oopcalc);</a>
<a name="ln3466"> </a>
<a name="ln3467">              // A-B-DC || D-B-AC  PLANE ABD</a>
<a name="ln3468">              oopcalc.a = a;</a>
<a name="ln3469">              oopcalc.c = d;</a>
<a name="ln3470">              oopcalc.d = c;</a>
<a name="ln3471"> </a>
<a name="ln3472">              oopcalc.SetupPointers();</a>
<a name="ln3473">              _oopcalculations.push_back(oopcalc);</a>
<a name="ln3474">            }</a>
<a name="ln3475">        }</a>
<a name="ln3476">      }</a>
<a name="ln3477">    }</a>
<a name="ln3478"> </a>
<a name="ln3479">    //</a>
<a name="ln3480">    // VDW Calculations</a>
<a name="ln3481">    //</a>
<a name="ln3482">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln3483">      OBFFLog(&quot;SETTING UP VAN DER WAALS CALCULATIONS...\n&quot;);</a>
<a name="ln3484"> </a>
<a name="ln3485">    OBFFVDWCalculationMMFF94 vdwcalc;</a>
<a name="ln3486"> </a>
<a name="ln3487">    _vdwcalculations.clear();</a>
<a name="ln3488"> </a>
<a name="ln3489">    int pairIndex = -1;</a>
<a name="ln3490">    FOR_PAIRS_OF_MOL(p, _mol) {</a>
<a name="ln3491">      ++pairIndex;</a>
<a name="ln3492">      a = _mol.GetAtom((*p)[0]);</a>
<a name="ln3493">      b = _mol.GetAtom((*p)[1]);</a>
<a name="ln3494"> </a>
<a name="ln3495">      // skip this vdw if the atoms are ignored</a>
<a name="ln3496">      if ( _constraints.IsIgnored(a-&gt;GetIdx()) || _constraints.IsIgnored(b-&gt;GetIdx()) )</a>
<a name="ln3497">        continue;</a>
<a name="ln3498"> </a>
<a name="ln3499">      // if there are any groups specified, check if the two atoms are in a single _interGroup or if</a>
<a name="ln3500">      // two two atoms are in one of the _interGroups pairs.</a>
<a name="ln3501">      if (HasGroups()) {</a>
<a name="ln3502">        bool validVDW = false;</a>
<a name="ln3503">        for (unsigned int i=0; i &lt; _interGroup.size(); ++i) {</a>
<a name="ln3504">          if (_interGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp; _interGroup[i].BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln3505">            validVDW = true;</a>
<a name="ln3506">            break;</a>
<a name="ln3507">          }</a>
<a name="ln3508">        }</a>
<a name="ln3509">        if (!validVDW) {</a>
<a name="ln3510">          for (unsigned int i=0; i &lt; _interGroups.size(); ++i) {</a>
<a name="ln3511">            if (_interGroups[i].first.BitIsSet(a-&gt;GetIdx()) &amp;&amp; _interGroups[i].second.BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln3512">              validVDW = true;</a>
<a name="ln3513">              break;</a>
<a name="ln3514">            }</a>
<a name="ln3515">            if (_interGroups[i].first.BitIsSet(b-&gt;GetIdx()) &amp;&amp; _interGroups[i].second.BitIsSet(a-&gt;GetIdx())) {</a>
<a name="ln3516">              validVDW = true;</a>
<a name="ln3517">              break;</a>
<a name="ln3518">            }</a>
<a name="ln3519">          }</a>
<a name="ln3520">        }</a>
<a name="ln3521"> </a>
<a name="ln3522">        if (!validVDW)</a>
<a name="ln3523">          continue;</a>
<a name="ln3524">      }</a>
<a name="ln3525"> </a>
<a name="ln3526">      OBFFParameter *parameter_a, *parameter_b;</a>
<a name="ln3527">      parameter_a = GetParameter1Atom(atoi(a-&gt;GetType()), _ffvdwparams);</a>
<a name="ln3528">      parameter_b = GetParameter1Atom(atoi(b-&gt;GetType()), _ffvdwparams);</a>
<a name="ln3529">      if (parameter_a == nullptr || parameter_b == nullptr) {</a>
<a name="ln3530">        IF_OBFF_LOGLVL_LOW {</a>
<a name="ln3531">          snprintf(_logbuf, BUFF_SIZE, &quot;   COULD NOT FIND VAN DER WAALS PARAMETERS FOR %d-%d (IDX)...\n&quot;, a-&gt;GetIdx(), b-&gt;GetIdx());</a>
<a name="ln3532">          OBFFLog(_logbuf);</a>
<a name="ln3533">        }</a>
<a name="ln3534"> </a>
<a name="ln3535">        return false;</a>
<a name="ln3536">      }</a>
<a name="ln3537"> </a>
<a name="ln3538">      vdwcalc.a = a;</a>
<a name="ln3539">      vdwcalc.alpha_a = parameter_a-&gt;_dpar[0];</a>
<a name="ln3540">      vdwcalc.Na = parameter_a-&gt;_dpar[1];</a>
<a name="ln3541">      vdwcalc.Aa = parameter_a-&gt;_dpar[2];</a>
<a name="ln3542">      vdwcalc.Ga = parameter_a-&gt;_dpar[3];</a>
<a name="ln3543">      vdwcalc.aDA = parameter_a-&gt;_ipar[0];</a>
<a name="ln3544"> </a>
<a name="ln3545">      vdwcalc.b = b;</a>
<a name="ln3546">      vdwcalc.alpha_b = parameter_b-&gt;_dpar[0];</a>
<a name="ln3547">      vdwcalc.Nb = parameter_b-&gt;_dpar[1];</a>
<a name="ln3548">      vdwcalc.Ab = parameter_b-&gt;_dpar[2];</a>
<a name="ln3549">      vdwcalc.Gb = parameter_b-&gt;_dpar[3];</a>
<a name="ln3550">      vdwcalc.bDA = parameter_b-&gt;_ipar[0];</a>
<a name="ln3551"> </a>
<a name="ln3552">      //these calculations only need to be done once for each pair,</a>
<a name="ln3553">      //we do them now and save them for later use</a>
<a name="ln3554">      double R_AA, R_BB, R_AB6, g_AB, g_AB2;</a>
<a name="ln3555">      double R_AB2, R_AB4, /*R_AB7,*/ sqrt_a, sqrt_b;</a>
<a name="ln3556"> </a>
<a name="ln3557">      R_AA = vdwcalc.Aa * pow(vdwcalc.alpha_a, 0.25);</a>
<a name="ln3558">      R_BB = vdwcalc.Ab * pow(vdwcalc.alpha_b, 0.25);</a>
<a name="ln3559">      sqrt_a = sqrt(vdwcalc.alpha_a / vdwcalc.Na);</a>
<a name="ln3560">      sqrt_b = sqrt(vdwcalc.alpha_b / vdwcalc.Nb);</a>
<a name="ln3561"> </a>
<a name="ln3562">      if (vdwcalc.aDA == 1) { // hydrogen bond donor</a>
<a name="ln3563">        vdwcalc.R_AB = 0.5 * (R_AA + R_BB);</a>
<a name="ln3564">        R_AB2 = vdwcalc.R_AB * vdwcalc.R_AB;</a>
<a name="ln3565">        R_AB4 = R_AB2 * R_AB2;</a>
<a name="ln3566">        R_AB6 = R_AB4 * R_AB2;</a>
<a name="ln3567"> </a>
<a name="ln3568">        if (vdwcalc.bDA == 2) { // hydrogen bond acceptor</a>
<a name="ln3569">          vdwcalc.epsilon = 0.5 * (181.16 * vdwcalc.Ga * vdwcalc.Gb * vdwcalc.alpha_a * vdwcalc.alpha_b) / (sqrt_a + sqrt_b) * (1.0 / R_AB6);</a>
<a name="ln3570">          // R_AB is scaled to 0.8 for D-A interactions. The value used in the calculation of epsilon is not scaled.</a>
<a name="ln3571">          vdwcalc.R_AB = 0.8 * vdwcalc.R_AB;</a>
<a name="ln3572">        } else</a>
<a name="ln3573">          vdwcalc.epsilon = (181.16 * vdwcalc.Ga * vdwcalc.Gb * vdwcalc.alpha_a * vdwcalc.alpha_b) / (sqrt_a + sqrt_b) * (1.0 / R_AB6);</a>
<a name="ln3574"> </a>
<a name="ln3575">        R_AB2 = vdwcalc.R_AB * vdwcalc.R_AB;</a>
<a name="ln3576">        R_AB4 = R_AB2 * R_AB2;</a>
<a name="ln3577">        R_AB6 = R_AB4 * R_AB2;</a>
<a name="ln3578">        vdwcalc.R_AB7 = R_AB6 * vdwcalc.R_AB;</a>
<a name="ln3579">      } else if (vdwcalc.bDA == 1) { // hydrogen bond donor</a>
<a name="ln3580">        vdwcalc.R_AB = 0.5 * (R_AA + R_BB);</a>
<a name="ln3581">       	R_AB2 = vdwcalc.R_AB * vdwcalc.R_AB;</a>
<a name="ln3582">        R_AB4 = R_AB2 * R_AB2;</a>
<a name="ln3583">        R_AB6 = R_AB4 * R_AB2;</a>
<a name="ln3584"> </a>
<a name="ln3585">        if (vdwcalc.aDA == 2) { // hydrogen bond acceptor</a>
<a name="ln3586">          vdwcalc.epsilon = 0.5 * (181.16 * vdwcalc.Ga * vdwcalc.Gb * vdwcalc.alpha_a * vdwcalc.alpha_b) / (sqrt_a + sqrt_b) * (1.0 / R_AB6);</a>
<a name="ln3587">          // R_AB is scaled to 0.8 for D-A interactions. The value used in the calculation of epsilon is not scaled.</a>
<a name="ln3588">          vdwcalc.R_AB = 0.8 * vdwcalc.R_AB;</a>
<a name="ln3589">        } else</a>
<a name="ln3590">          vdwcalc.epsilon = (181.16 * vdwcalc.Ga * vdwcalc.Gb * vdwcalc.alpha_a * vdwcalc.alpha_b) / (sqrt_a + sqrt_b) * (1.0 / R_AB6);</a>
<a name="ln3591"> </a>
<a name="ln3592">        R_AB2 = vdwcalc.R_AB * vdwcalc.R_AB;</a>
<a name="ln3593">        R_AB4 = R_AB2 * R_AB2;</a>
<a name="ln3594">        R_AB6 = R_AB4 * R_AB2;</a>
<a name="ln3595">        vdwcalc.R_AB7 = R_AB6 * vdwcalc.R_AB;</a>
<a name="ln3596">      } else {</a>
<a name="ln3597">        g_AB = (R_AA - R_BB) / ( R_AA + R_BB);</a>
<a name="ln3598">        g_AB2 = g_AB * g_AB;</a>
<a name="ln3599">        vdwcalc.R_AB =  0.5 * (R_AA + R_BB) * (1.0 + 0.2 * (1.0 - exp(-12.0 * g_AB2)));</a>
<a name="ln3600">        R_AB2 = vdwcalc.R_AB * vdwcalc.R_AB;</a>
<a name="ln3601">        R_AB4 = R_AB2 * R_AB2;</a>
<a name="ln3602">        R_AB6 = R_AB4 * R_AB2;</a>
<a name="ln3603">        vdwcalc.R_AB7 = R_AB6 * vdwcalc.R_AB;</a>
<a name="ln3604">        vdwcalc.epsilon = (181.16 * vdwcalc.Ga * vdwcalc.Gb * vdwcalc.alpha_a * vdwcalc.alpha_b) / (sqrt_a + sqrt_b) * (1.0 / R_AB6);</a>
<a name="ln3605">      }</a>
<a name="ln3606"> </a>
<a name="ln3607">      vdwcalc.pairIndex = pairIndex;</a>
<a name="ln3608">      vdwcalc.SetupPointers();</a>
<a name="ln3609">      _vdwcalculations.push_back(vdwcalc);</a>
<a name="ln3610">    }</a>
<a name="ln3611"> </a>
<a name="ln3612">    //</a>
<a name="ln3613">    // Electrostatic Calculations</a>
<a name="ln3614">    //</a>
<a name="ln3615">    IF_OBFF_LOGLVL_LOW</a>
<a name="ln3616">      OBFFLog(&quot;SETTING UP ELECTROSTATIC CALCULATIONS...\n&quot;);</a>
<a name="ln3617"> </a>
<a name="ln3618">    OBFFElectrostaticCalculationMMFF94 elecalc;</a>
<a name="ln3619"> </a>
<a name="ln3620">    _electrostaticcalculations.clear();</a>
<a name="ln3621"> </a>
<a name="ln3622">    pairIndex = -1;</a>
<a name="ln3623">    FOR_PAIRS_OF_MOL(p, _mol) {</a>
<a name="ln3624">      ++pairIndex;</a>
<a name="ln3625">      a = _mol.GetAtom((*p)[0]);</a>
<a name="ln3626">      b = _mol.GetAtom((*p)[1]);</a>
<a name="ln3627"> </a>
<a name="ln3628">      // skip this ele if the atoms are ignored</a>
<a name="ln3629">      if ( _constraints.IsIgnored(a-&gt;GetIdx()) || _constraints.IsIgnored(b-&gt;GetIdx()) )</a>
<a name="ln3630">        continue;</a>
<a name="ln3631"> </a>
<a name="ln3632">      // if there are any groups specified, check if the two atoms are in a single _interGroup or if</a>
<a name="ln3633">      // two two atoms are in one of the _interGroups pairs.</a>
<a name="ln3634">      if (HasGroups()) {</a>
<a name="ln3635">        bool validEle = false;</a>
<a name="ln3636">        for (unsigned int i=0; i &lt; _interGroup.size(); ++i) {</a>
<a name="ln3637">          if (_interGroup[i].BitIsSet(a-&gt;GetIdx()) &amp;&amp; _interGroup[i].BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln3638">            validEle = true;</a>
<a name="ln3639">            break;</a>
<a name="ln3640">          }</a>
<a name="ln3641">        }</a>
<a name="ln3642">        if (!validEle) {</a>
<a name="ln3643">          for (unsigned int i=0; i &lt; _interGroups.size(); ++i) {</a>
<a name="ln3644">            if (_interGroups[i].first.BitIsSet(a-&gt;GetIdx()) &amp;&amp; _interGroups[i].second.BitIsSet(b-&gt;GetIdx())) {</a>
<a name="ln3645">              validEle = true;</a>
<a name="ln3646">              break;</a>
<a name="ln3647">            }</a>
<a name="ln3648">            if (_interGroups[i].first.BitIsSet(b-&gt;GetIdx()) &amp;&amp; _interGroups[i].second.BitIsSet(a-&gt;GetIdx())) {</a>
<a name="ln3649">              validEle = true;</a>
<a name="ln3650">              break;</a>
<a name="ln3651">            }</a>
<a name="ln3652">          }</a>
<a name="ln3653">        }</a>
<a name="ln3654"> </a>
<a name="ln3655">        if (!validEle)</a>
<a name="ln3656">          continue;</a>
<a name="ln3657">      }</a>
<a name="ln3658"> </a>
<a name="ln3659">      elecalc.qq = 332.0716 * a-&gt;GetPartialCharge() * b-&gt;GetPartialCharge() / _epsilon;</a>
<a name="ln3660"> </a>
<a name="ln3661">      if (elecalc.qq) {</a>
<a name="ln3662">        elecalc.a = &amp;*a;</a>
<a name="ln3663">        elecalc.b = &amp;*b;</a>
<a name="ln3664"> </a>
<a name="ln3665">        // 1-4 scaling</a>
<a name="ln3666">        if (a-&gt;IsOneFour(b))</a>
<a name="ln3667">          elecalc.qq *= 0.75;</a>
<a name="ln3668"> </a>
<a name="ln3669">        elecalc.pairIndex = pairIndex;</a>
<a name="ln3670">        elecalc.SetupPointers();</a>
<a name="ln3671">        _electrostaticcalculations.push_back(elecalc);</a>
<a name="ln3672">      }</a>
<a name="ln3673">    }</a>
<a name="ln3674"> </a>
<a name="ln3675">    return true;</a>
<a name="ln3676">  }</a>
<a name="ln3677"> </a>
<a name="ln3678">  bool OBForceFieldMMFF94::SetupPointers()</a>
<a name="ln3679">  {</a>
<a name="ln3680">    for (unsigned int i = 0; i &lt; _bondcalculations.size(); ++i)</a>
<a name="ln3681">      _bondcalculations[i].SetupPointers();</a>
<a name="ln3682">    for (unsigned int i = 0; i &lt; _anglecalculations.size(); ++i)</a>
<a name="ln3683">      _anglecalculations[i].SetupPointers();</a>
<a name="ln3684">    for (unsigned int i = 0; i &lt; _strbndcalculations.size(); ++i)</a>
<a name="ln3685">      _strbndcalculations[i].SetupPointers();</a>
<a name="ln3686">    for (unsigned int i = 0; i &lt; _torsioncalculations.size(); ++i)</a>
<a name="ln3687">      _torsioncalculations[i].SetupPointers();</a>
<a name="ln3688">    for (unsigned int i = 0; i &lt; _oopcalculations.size(); ++i)</a>
<a name="ln3689">      _oopcalculations[i].SetupPointers();</a>
<a name="ln3690">    for (unsigned int i = 0; i &lt; _vdwcalculations.size(); ++i)</a>
<a name="ln3691">      _vdwcalculations[i].SetupPointers();</a>
<a name="ln3692">    for (unsigned int i = 0; i &lt; _electrostaticcalculations.size(); ++i)</a>
<a name="ln3693">      _electrostaticcalculations[i].SetupPointers();</a>
<a name="ln3694"> </a>
<a name="ln3695">    return true;</a>
<a name="ln3696">  }</a>
<a name="ln3697"> </a>
<a name="ln3698"> </a>
<a name="ln3699">  // we set the the formal charge with SetPartialCharge because formal charges</a>
<a name="ln3700">  // in MMFF94 are not always and integer</a>
<a name="ln3701">  bool OBForceFieldMMFF94::SetFormalCharges()</a>
<a name="ln3702">  {</a>
<a name="ln3703">    _mol.SetAutomaticPartialCharge(false);</a>
<a name="ln3704"> </a>
<a name="ln3705">    FOR_ATOMS_OF_MOL (atom, _mol) {</a>
<a name="ln3706">      int type = atoi(atom-&gt;GetType());</a>
<a name="ln3707">      atom-&gt;SetPartialCharge(0.0);</a>
<a name="ln3708"> </a>
<a name="ln3709">      bool done = false;</a>
<a name="ln3710">      switch (type) {</a>
<a name="ln3711">      case 34:</a>
<a name="ln3712">      case 49:</a>
<a name="ln3713">      case 51:</a>
<a name="ln3714">      case 54:</a>
<a name="ln3715">      case 58:</a>
<a name="ln3716">      case 92:</a>
<a name="ln3717">      case 93:</a>
<a name="ln3718">      case 94:</a>
<a name="ln3719">      case 97:</a>
<a name="ln3720">        atom-&gt;SetPartialCharge(1.0);</a>
<a name="ln3721">        done = true;</a>
<a name="ln3722">        break;</a>
<a name="ln3723">      case 35:</a>
<a name="ln3724">      case 62:</a>
<a name="ln3725">      case 89:</a>
<a name="ln3726">      case 90:</a>
<a name="ln3727">      case 91:</a>
<a name="ln3728">        atom-&gt;SetPartialCharge(-1.0);</a>
<a name="ln3729">        done = true;</a>
<a name="ln3730">        break;</a>
<a name="ln3731">      case 55:</a>
<a name="ln3732">        atom-&gt;SetPartialCharge(0.5);</a>
<a name="ln3733">        done = true;</a>
<a name="ln3734">        break;</a>
<a name="ln3735">      case 87:</a>
<a name="ln3736">      case 95:</a>
<a name="ln3737">      case 96:</a>
<a name="ln3738">      case 98:</a>
<a name="ln3739">      case 99:</a>
<a name="ln3740">        atom-&gt;SetPartialCharge(2.0);</a>
<a name="ln3741">        done = true;</a>
<a name="ln3742">        break;</a>
<a name="ln3743">      case 88:</a>
<a name="ln3744">        atom-&gt;SetPartialCharge(3.0);</a>
<a name="ln3745">        done = true;</a>
<a name="ln3746">        break;</a>
<a name="ln3747">        //case 98:</a>
<a name="ln3748">        //  atom-&gt;SetPartialCharge(3.0);</a>
<a name="ln3749">      default:</a>
<a name="ln3750">        break;</a>
<a name="ln3751">      }</a>
<a name="ln3752"> </a>
<a name="ln3753">      if (done)</a>
<a name="ln3754">        continue;</a>
<a name="ln3755"> </a>
<a name="ln3756">      if (type == 56) {</a>
<a name="ln3757">        int n_count = 0;</a>
<a name="ln3758">        int temp_type;</a>
<a name="ln3759">        FOR_ATOMS_OF_MOL (atom2, _mol) {</a>
<a name="ln3760">          temp_type = atoi(atom2-&gt;GetType());</a>
<a name="ln3761">          if (temp_type == 56 || temp_type == 81)</a>
<a name="ln3762">            ++n_count;</a>
<a name="ln3763">        }</a>
<a name="ln3764">        atom-&gt;SetPartialCharge((double)((n_count + 1) / 3) / (double)n_count);</a>
<a name="ln3765">      } else if (type == 32) {</a>
<a name="ln3766">        int o_count = 0;</a>
<a name="ln3767">        bool sulfonamide = false;</a>
<a name="ln3768">        bool sulfone_s_c = false;</a>
<a name="ln3769">        int s_count = 0;</a>
<a name="ln3770"> </a>
<a name="ln3771">        FOR_NBORS_OF_ATOM(nbr, &amp;*atom) {</a>
<a name="ln3772">          FOR_NBORS_OF_ATOM(nbr2, &amp;*nbr) {</a>
<a name="ln3773">            if (nbr2-&gt;GetAtomicNum() == OBElements::Oxygen &amp;&amp; (nbr2-&gt;GetExplicitDegree() == 1))</a>
<a name="ln3774">              o_count++;</a>
<a name="ln3775">            if (nbr2-&gt;GetAtomicNum() == OBElements::Sulfur &amp;&amp; (nbr2-&gt;GetExplicitDegree() == 1))</a>
<a name="ln3776">              s_count++;</a>
<a name="ln3777">            if (nbr2-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; !nbr2-&gt;IsAromatic())</a>
<a name="ln3778">              sulfonamide = true;</a>
<a name="ln3779">            OBBond *bond = nbr-&gt;GetBond(&amp;*nbr2);</a>
<a name="ln3780">            if (nbr2-&gt;GetAtomicNum() == OBElements::Carbon &amp;&amp; !bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2)</a>
<a name="ln3781">              sulfone_s_c = true;</a>
<a name="ln3782">          }</a>
<a name="ln3783"> </a>
<a name="ln3784">          if (nbr-&gt;GetAtomicNum() == OBElements::Carbon)</a>
<a name="ln3785">            atom-&gt;SetPartialCharge(-0.5); // O2CM</a>
<a name="ln3786"> </a>
<a name="ln3787">          if (nbr-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (o_count == 3))</a>
<a name="ln3788">            atom-&gt;SetPartialCharge(-1.0 / o_count);  // O3N</a>
<a name="ln3789"> </a>
<a name="ln3790">          if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur &amp;&amp; !sulfonamide) {</a>
<a name="ln3791">            if (((o_count + s_count) == 2) &amp;&amp; (nbr-&gt;GetExplicitDegree() == 3)</a>
<a name="ln3792">                &amp;&amp; (nbr-&gt;GetExplicitValence() &gt;= 3) &amp;&amp; !sulfone_s_c) {</a>
<a name="ln3793">              atom-&gt;SetPartialCharge(-0.5); // O2S (sulfinate)</a>
<a name="ln3794">            }</a>
<a name="ln3795">            else if ((o_count + s_count) == 3) {</a>
<a name="ln3796">              atom-&gt;SetPartialCharge(-1.0 / 3.0); // O3S</a>
<a name="ln3797">            }</a>
<a name="ln3798">            else if ((o_count + s_count) == 4) {</a>
<a name="ln3799">              atom-&gt;SetPartialCharge(-0.5); // O4S</a>
<a name="ln3800">            }</a>
<a name="ln3801">          }</a>
<a name="ln3802"> </a>
<a name="ln3803">          if (nbr-&gt;GetAtomicNum() == OBElements::Phosphorus) {</a>
<a name="ln3804">            if ((o_count + s_count) == 2) {</a>
<a name="ln3805">              atom-&gt;SetPartialCharge(-0.5); // O2P</a>
<a name="ln3806">            }</a>
<a name="ln3807">            else if ((o_count + s_count) == 3) {</a>
<a name="ln3808">              atom-&gt;SetPartialCharge(-2.0 / 3.0); // O3P</a>
<a name="ln3809">            }</a>
<a name="ln3810">            else if ((o_count + s_count) == 4) {</a>
<a name="ln3811">              atom-&gt;SetPartialCharge(-0.25); // O4P</a>
<a name="ln3812">            }</a>
<a name="ln3813">          }</a>
<a name="ln3814"> </a>
<a name="ln3815">          if (atoi(nbr-&gt;GetType()) == 77)</a>
<a name="ln3816">            atom-&gt;SetPartialCharge(-0.25); // O4CL</a>
<a name="ln3817">        }</a>
<a name="ln3818">      } else if (type == 61) {</a>
<a name="ln3819">        FOR_BONDS_OF_ATOM(bond, &amp;*atom) {</a>
<a name="ln3820">          OBAtom *nbr = bond-&gt;GetNbrAtom(&amp;*atom);</a>
<a name="ln3821">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 3 &amp;&amp; nbr-&gt;GetAtomicNum() == OBElements::Nitrogen)</a>
<a name="ln3822">            atom-&gt;SetPartialCharge(1.0);</a>
<a name="ln3823">        }</a>
<a name="ln3824">      } else if (type == 72) {</a>
<a name="ln3825">        int s_count = 0;</a>
<a name="ln3826"> </a>
<a name="ln3827">        FOR_NBORS_OF_ATOM(nbr, &amp;*atom) {</a>
<a name="ln3828">          if (nbr-&gt;GetAtomicNum() == OBElements::Sulfur)</a>
<a name="ln3829">            s_count++;</a>
<a name="ln3830"> </a>
<a name="ln3831">          if (nbr-&gt;GetAtomicNum() == OBElements::Phosphorus || nbr-&gt;GetAtomicNum() == OBElements::Sulfur) {</a>
<a name="ln3832">            FOR_NBORS_OF_ATOM(nbr2, &amp;*nbr)</a>
<a name="ln3833">              if ((nbr2-&gt;GetAtomicNum() == OBElements::Sulfur || nbr2-&gt;GetAtomicNum() == OBElements::Oxygen) &amp;&amp; (nbr2-&gt;GetExplicitDegree() == 1) &amp;&amp; (atom-&gt;GetIdx() != nbr2-&gt;GetIdx()))</a>
<a name="ln3834">                atom-&gt;SetPartialCharge(-0.5);</a>
<a name="ln3835">          } else</a>
<a name="ln3836">            atom-&gt;SetPartialCharge(-1.0);</a>
<a name="ln3837"> </a>
<a name="ln3838">          if (nbr-&gt;GetAtomicNum() == OBElements::Carbon)</a>
<a name="ln3839">            FOR_NBORS_OF_ATOM(nbr2, &amp;*nbr)</a>
<a name="ln3840">              if (nbr2-&gt;GetAtomicNum() == OBElements::Sulfur &amp;&amp; (nbr2-&gt;GetExplicitDegree() == 1) &amp;&amp; (atom-&gt;GetIdx() != nbr2-&gt;GetIdx()))</a>
<a name="ln3841">                atom-&gt;SetPartialCharge(-0.5); // SSMO</a>
<a name="ln3842"> </a>
<a name="ln3843">          if (s_count &gt;= 2)</a>
<a name="ln3844">            atom-&gt;SetPartialCharge(-0.5); // SSMO</a>
<a name="ln3845">        }</a>
<a name="ln3846">      } else if (type == 76) {</a>
<a name="ln3847">       	vector&lt;OBRing*&gt; vr;</a>
<a name="ln3848">        vr = _mol.GetSSSR();</a>
<a name="ln3849">        vector&lt;OBRing*&gt;::iterator ri;</a>
<a name="ln3850">        vector&lt;int&gt;::iterator rj;</a>
<a name="ln3851">        int n_count;</a>
<a name="ln3852"> </a>
<a name="ln3853">        for (ri = vr.begin();ri != vr.end();++ri) { // for each ring</a>
<a name="ln3854">          n_count = 0;</a>
<a name="ln3855"> </a>
<a name="ln3856">          if ((*ri)-&gt;IsAromatic() &amp;&amp; (*ri)-&gt;IsMember(&amp;*atom) &amp;&amp; ((*ri)-&gt;Size() == 5)) {</a>
<a name="ln3857">            for(rj = (*ri)-&gt;_path.begin();rj != (*ri)-&gt;_path.end();++rj) // for each ring atom</a>
<a name="ln3858">              if (_mol.GetAtom(*rj)-&gt;GetAtomicNum() == OBElements::Nitrogen)</a>
<a name="ln3859">                n_count++;</a>
<a name="ln3860"> </a>
<a name="ln3861">            if (n_count &gt; 1)</a>
<a name="ln3862">              atom-&gt;SetPartialCharge(-1.0 / n_count);</a>
<a name="ln3863">          }</a>
<a name="ln3864">        }</a>
<a name="ln3865">      } else if (type == 81) {</a>
<a name="ln3866">        atom-&gt;SetPartialCharge(1.0);</a>
<a name="ln3867"> </a>
<a name="ln3868">        vector&lt;OBRing*&gt; vr;</a>
<a name="ln3869">        vr = _mol.GetSSSR();</a>
<a name="ln3870">        vector&lt;OBRing*&gt;::iterator ri;</a>
<a name="ln3871">        vector&lt;int&gt;::iterator rj;</a>
<a name="ln3872">        for (ri = vr.begin();ri != vr.end();++ri) // for each ring</a>
<a name="ln3873">          if ((*ri)-&gt;IsAromatic() &amp;&amp; (*ri)-&gt;IsMember(&amp;*atom) &amp;&amp; ((*ri)-&gt;Size() == 5)) {</a>
<a name="ln3874">            int n_count = 0;</a>
<a name="ln3875">            for(rj = (*ri)-&gt;_path.begin();rj != (*ri)-&gt;_path.end();++rj) // for each ring atom</a>
<a name="ln3876">              if (_mol.GetAtom(*rj)-&gt;GetAtomicNum() == OBElements::Nitrogen &amp;&amp; (_mol.GetAtom(*rj)-&gt;GetExplicitDegree() == 3))</a>
<a name="ln3877">                n_count++;</a>
<a name="ln3878"> </a>
<a name="ln3879">            if (n_count) // coverity defensive testing</a>
<a name="ln3880">              atom-&gt;SetPartialCharge(1.0 / n_count); // NIM+</a>
<a name="ln3881"> </a>
<a name="ln3882">            FOR_NBORS_OF_ATOM(nbr, &amp;*atom)</a>
<a name="ln3883">              FOR_NBORS_OF_ATOM(nbr2, &amp;*nbr)</a>
<a name="ln3884">              if (atoi(nbr2-&gt;GetType()) == 56)</a>
<a name="ln3885">                atom-&gt;SetPartialCharge(1.0 / 3.0);</a>
<a name="ln3886"> </a>
<a name="ln3887">            FOR_NBORS_OF_ATOM(nbr, &amp;*atom)</a>
<a name="ln3888">              FOR_NBORS_OF_ATOM(nbr2, &amp;*nbr)</a>
<a name="ln3889">              if (atoi(nbr2-&gt;GetType()) == 55)</a>
<a name="ln3890">                atom-&gt;SetPartialCharge(1.0 / (1.0 + n_count));</a>
<a name="ln3891">          }</a>
<a name="ln3892">      }</a>
<a name="ln3893"> </a>
<a name="ln3894">    }</a>
<a name="ln3895"> </a>
<a name="ln3896">    PrintFormalCharges();</a>
<a name="ln3897"> </a>
<a name="ln3898">    return true;</a>
<a name="ln3899">  }</a>
<a name="ln3900"> </a>
<a name="ln3901">  bool OBForceFieldMMFF94::SetPartialCharges()</a>
<a name="ln3902">  {</a>
<a name="ln3903">    vector&lt;double&gt; charges(_mol.NumAtoms()+1, 0);</a>
<a name="ln3904">    double M, Wab, factor, q0a, q0b, Pa, Pb;</a>
<a name="ln3905"> </a>
<a name="ln3906">    FOR_ATOMS_OF_MOL (atom, _mol) {</a>
<a name="ln3907">      int type = atoi(atom-&gt;GetType());</a>
<a name="ln3908"> </a>
<a name="ln3909">      switch (type) {</a>
<a name="ln3910">      case 32:</a>
<a name="ln3911">      case 35:</a>
<a name="ln3912">      case 72:</a>
<a name="ln3913">        factor = 0.5;</a>
<a name="ln3914">        break;</a>
<a name="ln3915">      case 62:</a>
<a name="ln3916">      case 76:</a>
<a name="ln3917">        factor = 0.25;</a>
<a name="ln3918">        break;</a>
<a name="ln3919">      default:</a>
<a name="ln3920">        factor = 0.0;</a>
<a name="ln3921">        break;</a>
<a name="ln3922">      }</a>
<a name="ln3923"> </a>
<a name="ln3924">      M = GetCrd(type);</a>
<a name="ln3925">      q0a = atom-&gt;GetPartialCharge();</a>
<a name="ln3926"> </a>
<a name="ln3927">      // charge sharing</a>
<a name="ln3928">      if (!factor)</a>
<a name="ln3929">        FOR_NBORS_OF_ATOM (nbr, &amp;*atom)</a>
<a name="ln3930">          if (nbr-&gt;GetPartialCharge() &lt; 0.0)</a>
<a name="ln3931">            q0a += nbr-&gt;GetPartialCharge() / (2.0 * (double)(nbr-&gt;GetExplicitDegree()));</a>
<a name="ln3932"> </a>
<a name="ln3933">      // needed for SEYWUO, positive charge sharing?</a>
<a name="ln3934">      if (type == 62)</a>
<a name="ln3935">        FOR_NBORS_OF_ATOM (nbr, &amp;*atom)</a>
<a name="ln3936">          if (nbr-&gt;GetPartialCharge() &gt; 0.0)</a>
<a name="ln3937">            q0a -= nbr-&gt;GetPartialCharge() / 2.0;</a>
<a name="ln3938"> </a>
<a name="ln3939">      q0b = 0.0;</a>
<a name="ln3940">      Wab = 0.0;</a>
<a name="ln3941">      Pa = Pb = 0.0;</a>
<a name="ln3942">      FOR_NBORS_OF_ATOM (nbr, &amp;*atom) {</a>
<a name="ln3943">        int nbr_type = atoi(nbr-&gt;GetType());</a>
<a name="ln3944"> </a>
<a name="ln3945">        q0b += nbr-&gt;GetPartialCharge();</a>
<a name="ln3946"> </a>
<a name="ln3947">        bool bci_found = false;</a>
<a name="ln3948">        for (unsigned int idx=0; idx &lt; _ffchgparams.size(); idx++)</a>
<a name="ln3949">          if (GetBondType(&amp;*atom, &amp;*nbr) == _ffchgparams[idx]._ipar[0]) {</a>
<a name="ln3950">            if ((type == _ffchgparams[idx].a) &amp;&amp; (nbr_type == _ffchgparams[idx].b)) {</a>
<a name="ln3951">              Wab += -_ffchgparams[idx]._dpar[0];</a>
<a name="ln3952">              bci_found = true;</a>
<a name="ln3953">            } else if  ((type == _ffchgparams[idx].b) &amp;&amp; (nbr_type == _ffchgparams[idx].a)) {</a>
<a name="ln3954">              Wab += _ffchgparams[idx]._dpar[0];</a>
<a name="ln3955">              bci_found = true;</a>
<a name="ln3956">            }</a>
<a name="ln3957">	  }</a>
<a name="ln3958"> </a>
<a name="ln3959">        if (!bci_found) {</a>
<a name="ln3960">          for (unsigned int idx=0; idx &lt; _ffpbciparams.size(); idx++) {</a>
<a name="ln3961">            if (type == _ffpbciparams[idx].a)</a>
<a name="ln3962">              Pa = _ffpbciparams[idx]._dpar[0];</a>
<a name="ln3963">            if (nbr_type == _ffpbciparams[idx].a)</a>
<a name="ln3964">              Pb = _ffpbciparams[idx]._dpar[0];</a>
<a name="ln3965">          }</a>
<a name="ln3966">          Wab += Pa - Pb;</a>
<a name="ln3967">        }</a>
<a name="ln3968">      }</a>
<a name="ln3969">      if (factor)</a>
<a name="ln3970">        charges[atom-&gt;GetIdx()] = (1.0 - M * factor) * q0a + factor * q0b + Wab;</a>
<a name="ln3971">      else</a>
<a name="ln3972">        charges[atom-&gt;GetIdx()] = q0a + Wab;</a>
<a name="ln3973">    }</a>
<a name="ln3974"> </a>
<a name="ln3975">    FOR_ATOMS_OF_MOL (atom, _mol)</a>
<a name="ln3976">      atom-&gt;SetPartialCharge(charges[atom-&gt;GetIdx()]);</a>
<a name="ln3977"> </a>
<a name="ln3978">    PrintPartialCharges();</a>
<a name="ln3979"> </a>
<a name="ln3980">    return true;</a>
<a name="ln3981">  }</a>
<a name="ln3982"> </a>
<a name="ln3983">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3984">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3985">  //</a>
<a name="ln3986">  //  Validation functions</a>
<a name="ln3987">  //</a>
<a name="ln3988">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3989">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3990"> </a>
<a name="ln3991">  // used to validate the implementation</a>
<a name="ln3992">  bool OBForceFieldMMFF94::Validate ()</a>
<a name="ln3993">  {</a>
<a name="ln3994">    OBConversion conv;</a>
<a name="ln3995">    OBFormat *format_in = conv.FindFormat(&quot;mol2&quot;);</a>
<a name="ln3996">    vector&lt;string&gt; vs;</a>
<a name="ln3997">    vector&lt;int&gt; types;</a>
<a name="ln3998">    vector&lt;double&gt; fcharges, pcharges;</a>
<a name="ln3999">    vector&lt;double&gt; bond_lengths;</a>
<a name="ln4000">    char buffer[150];</a>
<a name="ln4001">    bool molfound, atomfound, bondfound, fchgfound, pchgfound;</a>
<a name="ln4002">    double etot, ebond, eangle, eoop, estbn, etor, evdw, eeq;</a>
<a name="ln4003">    double termcount; //1=bond, 2=angle, 3=strbnd, 4=torsion, 5=oop</a>
<a name="ln4004">    int n = 0;</a>
<a name="ln4005"> </a>
<a name="ln4006">    if (!format_in || !conv.SetInFormat(format_in)) {</a>
<a name="ln4007">      obErrorLog.ThrowError(__FUNCTION__, &quot;Could not set mol2 input format&quot;, obError);</a>
<a name="ln4008">      return false;</a>
<a name="ln4009">    }</a>
<a name="ln4010"> </a>
<a name="ln4011">    ifstream ifs, ifs2;</a>
<a name="ln4012">    ofstream ofs;</a>
<a name="ln4013"> </a>
<a name="ln4014">    ifs.open(&quot;MMFF94_dative.mol2&quot;);</a>
<a name="ln4015">    if (!ifs) {</a>
<a name="ln4016">      obErrorLog.ThrowError(__FUNCTION__, &quot;Could not open ./MMFF94_dative.mol2&quot;, obError);</a>
<a name="ln4017">      return false;</a>
<a name="ln4018">    }</a>
<a name="ln4019"> </a>
<a name="ln4020">    ifs2.open(&quot;MMFF94_opti.log&quot;);</a>
<a name="ln4021">    if (!ifs2) {</a>
<a name="ln4022">      obErrorLog.ThrowError(__FUNCTION__, &quot;Coulg not open ./MMFF_opti.log&quot;, obError);</a>
<a name="ln4023">      return false;</a>
<a name="ln4024">    }</a>
<a name="ln4025"> </a>
<a name="ln4026">    ofs.open(&quot;MMFF94_openbabel.log&quot;);</a>
<a name="ln4027">    if (!ofs) {</a>
<a name="ln4028">      obErrorLog.ThrowError(__FUNCTION__, &quot;Coulg not open ./MMFF_openbabel.log&quot;, obError);</a>
<a name="ln4029">      return false;</a>
<a name="ln4030">    }</a>
<a name="ln4031"> </a>
<a name="ln4032">    if (!_init) {</a>
<a name="ln4033">      ParseParamFile();</a>
<a name="ln4034">      _init = true;</a>
<a name="ln4035">    }</a>
<a name="ln4036"> </a>
<a name="ln4037"> </a>
<a name="ln4038">    SetLogFile(&amp;ofs);</a>
<a name="ln4039">    SetLogLevel(OBFF_LOGLVL_HIGH);</a>
<a name="ln4040"> </a>
<a name="ln4041">    for (unsigned int c=1;; c++) {</a>
<a name="ln4042">      _mol.Clear();</a>
<a name="ln4043">      types.clear();</a>
<a name="ln4044">      fcharges.clear();</a>
<a name="ln4045">      pcharges.clear();</a>
<a name="ln4046">      bond_lengths.clear();</a>
<a name="ln4047"> </a>
<a name="ln4048">      if (!conv.Read(&amp;_mol, &amp;ifs))</a>
<a name="ln4049">        break;</a>
<a name="ln4050">      if (_mol.Empty())</a>
<a name="ln4051">        break;</a>
<a name="ln4052"> </a>
<a name="ln4053">      _ncoords = _mol.NumAtoms() * 3;</a>
<a name="ln4054">      _gradientPtr = new double[_ncoords];</a>
<a name="ln4055"> </a>
<a name="ln4056">      SetTypes();</a>
<a name="ln4057"> </a>
<a name="ln4058">      if ((c == 98) || (c == 692)) // CUDPAS &amp; VUWXUG</a>
<a name="ln4059">        continue;</a>
<a name="ln4060"> </a>
<a name="ln4061">      termcount = 0;</a>
<a name="ln4062">      molfound = false;</a>
<a name="ln4063">      atomfound = false;</a>
<a name="ln4064">      bondfound = false;</a>
<a name="ln4065">      fchgfound = false;</a>
<a name="ln4066">      pchgfound = false;</a>
<a name="ln4067"> </a>
<a name="ln4068">      while (ifs2.getline(buffer, 150)) {</a>
<a name="ln4069">        tokenize(vs, buffer);</a>
<a name="ln4070">        if (vs.size() == 0) {</a>
<a name="ln4071">          bondfound = false;</a>
<a name="ln4072">          continue;</a>
<a name="ln4073">        }</a>
<a name="ln4074"> </a>
<a name="ln4075">        string str(buffer);</a>
<a name="ln4076">        if (string::npos != str.find(_mol.GetTitle(),0))</a>
<a name="ln4077">          molfound = true;</a>
<a name="ln4078"> </a>
<a name="ln4079">        if (atomfound) {</a>
<a name="ln4080">          if (n) {</a>
<a name="ln4081">            types.push_back(atoi(vs[2].c_str()));</a>
<a name="ln4082">            types.push_back(atoi(vs[5].c_str()));</a>
<a name="ln4083">            types.push_back(atoi(vs[8].c_str()));</a>
<a name="ln4084">            types.push_back(atoi(vs[11].c_str()));</a>
<a name="ln4085">          } else {</a>
<a name="ln4086">            if (vs.size() &gt; 2)</a>
<a name="ln4087">              types.push_back(atoi(vs[2].c_str()));</a>
<a name="ln4088">            if (vs.size() &gt; 5)</a>
<a name="ln4089">              types.push_back(atoi(vs[5].c_str()));</a>
<a name="ln4090">            if (vs.size() &gt; 8)</a>
<a name="ln4091">              types.push_back(atoi(vs[8].c_str()));</a>
<a name="ln4092"> </a>
<a name="ln4093">            atomfound = false;</a>
<a name="ln4094">          }</a>
<a name="ln4095">          n--;</a>
<a name="ln4096">        }</a>
<a name="ln4097"> </a>
<a name="ln4098">        if (fchgfound) {</a>
<a name="ln4099">          if (n) {</a>
<a name="ln4100">            fcharges.push_back(atof(vs[2].c_str()));</a>
<a name="ln4101">            fcharges.push_back(atof(vs[5].c_str()));</a>
<a name="ln4102">            fcharges.push_back(atof(vs[8].c_str()));</a>
<a name="ln4103">            fcharges.push_back(atof(vs[11].c_str()));</a>
<a name="ln4104">          } else {</a>
<a name="ln4105">            if (vs.size() &gt; 2)</a>
<a name="ln4106">              fcharges.push_back(atof(vs[2].c_str()));</a>
<a name="ln4107">            if (vs.size() &gt; 5)</a>
<a name="ln4108">              fcharges.push_back(atof(vs[5].c_str()));</a>
<a name="ln4109">            if (vs.size() &gt; 8)</a>
<a name="ln4110">              fcharges.push_back(atof(vs[8].c_str()));</a>
<a name="ln4111"> </a>
<a name="ln4112">            fchgfound = false;</a>
<a name="ln4113">          }</a>
<a name="ln4114">          n--;</a>
<a name="ln4115">        }</a>
<a name="ln4116"> </a>
<a name="ln4117">        if (pchgfound) {</a>
<a name="ln4118">          if (n) {</a>
<a name="ln4119">            pcharges.push_back(atof(vs[2].c_str()));</a>
<a name="ln4120">            pcharges.push_back(atof(vs[5].c_str()));</a>
<a name="ln4121">            pcharges.push_back(atof(vs[8].c_str()));</a>
<a name="ln4122">            pcharges.push_back(atof(vs[11].c_str()));</a>
<a name="ln4123">          } else {</a>
<a name="ln4124">            if (vs.size() &gt; 2)</a>
<a name="ln4125">              pcharges.push_back(atof(vs[2].c_str()));</a>
<a name="ln4126">            if (vs.size() &gt; 5)</a>
<a name="ln4127">              pcharges.push_back(atof(vs[5].c_str()));</a>
<a name="ln4128">            if (vs.size() &gt; 8)</a>
<a name="ln4129">              pcharges.push_back(atof(vs[8].c_str()));</a>
<a name="ln4130"> </a>
<a name="ln4131">            pchgfound = false;</a>
<a name="ln4132">          }</a>
<a name="ln4133">          n--;</a>
<a name="ln4134">        }</a>
<a name="ln4135"> </a>
<a name="ln4136">        if (molfound &amp;&amp; EQn(buffer, &quot; ATOM NAME  TYPE&quot;, 16)) {</a>
<a name="ln4137">          atomfound = true;</a>
<a name="ln4138">          n = _mol.NumAtoms() / 4;</a>
<a name="ln4139">        }</a>
<a name="ln4140">        if (molfound &amp;&amp; EQn(buffer, &quot;   ATOM   FCHARGE&quot;, 17)) {</a>
<a name="ln4141">          fchgfound = true;</a>
<a name="ln4142">          n = _mol.NumAtoms() / 4;</a>
<a name="ln4143">        }</a>
<a name="ln4144">        if (molfound &amp;&amp; EQn(buffer, &quot;   ATOM    CHARGE&quot;, 17)) {</a>
<a name="ln4145">          pchgfound = true;</a>
<a name="ln4146">          n = _mol.NumAtoms() / 4;</a>
<a name="ln4147">        }</a>
<a name="ln4148"> </a>
<a name="ln4149">        if (bondfound)</a>
<a name="ln4150">          bond_lengths.push_back(atof(vs[7].c_str()));</a>
<a name="ln4151"> </a>
<a name="ln4152">        if (molfound) {</a>
<a name="ln4153">          if (EQn(buffer, &quot; Total ENERGY&quot;, 13))</a>
<a name="ln4154">            etot = atof(vs[3].c_str());</a>
<a name="ln4155">          if (EQn(buffer, &quot; Bond Stretching&quot;, 16))</a>
<a name="ln4156">            ebond = atof(vs[2].c_str());</a>
<a name="ln4157">          if (EQn(buffer, &quot; Angle Bending&quot;, 14))</a>
<a name="ln4158">            eangle = atof(vs[2].c_str());</a>
<a name="ln4159">          if (EQn(buffer, &quot; Out-of-Plane Bending&quot;, 21))</a>
<a name="ln4160">            eoop = atof(vs[2].c_str());</a>
<a name="ln4161">          if (EQn(buffer, &quot; Stretch-Bend&quot;, 13))</a>
<a name="ln4162">            estbn = atof(vs[1].c_str());</a>
<a name="ln4163">          if (EQn(buffer, &quot;     Total Torsion&quot;, 18))</a>
<a name="ln4164">            etor = atof(vs[2].c_str());</a>
<a name="ln4165">          if (EQn(buffer, &quot;     Net vdW&quot;, 12))</a>
<a name="ln4166">            evdw = atof(vs[2].c_str());</a>
<a name="ln4167">          if (EQn(buffer, &quot; Electrostatic&quot;, 14))</a>
<a name="ln4168">            eeq = atof(vs[1].c_str());</a>
<a name="ln4169">          if (EQn(buffer, &quot; ---------------------&quot;, 22) &amp;&amp; (termcount == 0)) {</a>
<a name="ln4170">            termcount++;</a>
<a name="ln4171">            bondfound = true;</a>
<a name="ln4172">          }</a>
<a name="ln4173">          if (EQn(buffer, &quot; OPTIMOL&gt;  # read next&quot;, 22))</a>
<a name="ln4174">            break;</a>
<a name="ln4175">        }</a>
<a name="ln4176"> </a>
<a name="ln4177"> </a>
<a name="ln4178"> </a>
<a name="ln4179">      } // while (getline)</a>
<a name="ln4180"> </a>
<a name="ln4181">      vector&lt;int&gt;::iterator i;</a>
<a name="ln4182">      vector&lt;double&gt;::iterator di;</a>
<a name="ln4183">      unsigned int ni;</a>
<a name="ln4184">      bool failed;</a>
<a name="ln4185"> </a>
<a name="ln4186">      cout &lt;&lt; &quot;--------------------------------------------------------------------------------&quot; &lt;&lt; endl;</a>
<a name="ln4187">      cout &lt;&lt; &quot;                                                                                &quot; &lt;&lt; endl;</a>
<a name="ln4188">      cout &lt;&lt; &quot;  VALIDATE MOLECULE &quot; &lt;&lt; c &lt;&lt; &quot;: &quot; &lt;&lt; _mol.GetTitle() &lt;&lt; endl;</a>
<a name="ln4189">      cout &lt;&lt; &quot;                                                                                &quot; &lt;&lt; endl;</a>
<a name="ln4190">      cout &lt;&lt; &quot;IDX  HYB  AROM  OB_TYPE  LOG_TYPE       RESULT                                  &quot; &lt;&lt; endl;</a>
<a name="ln4191">      cout &lt;&lt; &quot;----------------------------------------------                                  &quot; &lt;&lt; endl;</a>
<a name="ln4192"> </a>
<a name="ln4193">      ni = 1;</a>
<a name="ln4194">      failed = false;</a>
<a name="ln4195">      for (i = types.begin(); i != types.end();++i) {</a>
<a name="ln4196">        if (ni &gt; _mol.NumAtoms())</a>
<a name="ln4197">          continue;</a>
<a name="ln4198"> </a>
<a name="ln4199">        if ( (atoi(_mol.GetAtom(ni)-&gt;GetType()) == 87) ||</a>
<a name="ln4200">             (atoi(_mol.GetAtom(ni)-&gt;GetType()) == 97)</a>
<a name="ln4201">             ) continue;</a>
<a name="ln4202"> </a>
<a name="ln4203">        if (atoi(_mol.GetAtom(ni)-&gt;GetType()) == (*i))</a>
<a name="ln4204">          snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %3d  %4d    %3d      %3d          PASSED&quot;, _mol.GetAtom(ni)-&gt;GetIdx(), _mol.GetAtom(ni)-&gt;GetHyb(),</a>
<a name="ln4205">                  _mol.GetAtom(ni)-&gt;IsAromatic(), atoi(_mol.GetAtom(ni)-&gt;GetType()), *i);</a>
<a name="ln4206">        else {</a>
<a name="ln4207">          snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %3d  %4d    %3d      %3d      XXX FAILED XXX&quot;, _mol.GetAtom(ni)-&gt;GetIdx(), _mol.GetAtom(ni)-&gt;GetHyb(),</a>
<a name="ln4208">                  _mol.GetAtom(ni)-&gt;IsAromatic(), atoi(_mol.GetAtom(ni)-&gt;GetType()), *i);</a>
<a name="ln4209">          failed = true;</a>
<a name="ln4210">        }</a>
<a name="ln4211"> </a>
<a name="ln4212">        cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4213"> </a>
<a name="ln4214">        ni++;</a>
<a name="ln4215">      }</a>
<a name="ln4216"> </a>
<a name="ln4217">      if (failed) {</a>
<a name="ln4218">        cout &lt;&lt; &quot;Could not successfully assign atom types&quot; &lt;&lt; endl;</a>
<a name="ln4219">        return false;</a>
<a name="ln4220">        //continue;</a>
<a name="ln4221">      }</a>
<a name="ln4222"> </a>
<a name="ln4223">      SetFormalCharges();</a>
<a name="ln4224">      cout &lt;&lt; endl;</a>
<a name="ln4225">      cout &lt;&lt; &quot;IDX  OB_FCARGE  LOG_FCHARGE       RESULT&quot; &lt;&lt; endl;</a>
<a name="ln4226">      cout &lt;&lt; &quot;----------------------------------------&quot; &lt;&lt; endl;</a>
<a name="ln4227"> </a>
<a name="ln4228">      ni = 1;</a>
<a name="ln4229">      for (di = fcharges.begin(); di != fcharges.end(); ++di) {</a>
<a name="ln4230">        if (ni &gt; _mol.NumAtoms())</a>
<a name="ln4231">          continue;</a>
<a name="ln4232"> </a>
<a name="ln4233">        if ( (atoi(_mol.GetAtom(ni)-&gt;GetType()) == 87) ||</a>
<a name="ln4234">             (atoi(_mol.GetAtom(ni)-&gt;GetType()) == 97)</a>
<a name="ln4235">             ) continue;</a>
<a name="ln4236"> </a>
<a name="ln4237">        if (fabs((*di) - _mol.GetAtom(ni)-&gt;GetPartialCharge()) &lt;= 0.001)</a>
<a name="ln4238">          snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %7.4f     %7.4f          PASSED&quot;, _mol.GetAtom(ni)-&gt;GetIdx(), _mol.GetAtom(ni)-&gt;GetPartialCharge(), *di);</a>
<a name="ln4239">        else {</a>
<a name="ln4240">          snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %7.4f     %7.4f      XXX FAILED XXX&quot;, _mol.GetAtom(ni)-&gt;GetIdx(), _mol.GetAtom(ni)-&gt;GetPartialCharge(), *di);</a>
<a name="ln4241">          failed = true;</a>
<a name="ln4242">        }</a>
<a name="ln4243"> </a>
<a name="ln4244">        cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4245"> </a>
<a name="ln4246">        ni++;</a>
<a name="ln4247">      }</a>
<a name="ln4248"> </a>
<a name="ln4249">      if (failed) {</a>
<a name="ln4250">        cout &lt;&lt; &quot;Could not successfully assign formal charges&quot; &lt;&lt; endl;</a>
<a name="ln4251">        //return false;</a>
<a name="ln4252">        continue;</a>
<a name="ln4253">      }</a>
<a name="ln4254"> </a>
<a name="ln4255">      SetPartialCharges();</a>
<a name="ln4256">      cout &lt;&lt; endl;</a>
<a name="ln4257">      cout &lt;&lt; &quot;IDX  OB_PCARGE  LOG_PCHARGE       RESULT&quot; &lt;&lt; endl;</a>
<a name="ln4258">      cout &lt;&lt; &quot;----------------------------------------&quot; &lt;&lt; endl;</a>
<a name="ln4259"> </a>
<a name="ln4260">      ni = 1;</a>
<a name="ln4261">      for (di = pcharges.begin(); di != pcharges.end(); ++di) {</a>
<a name="ln4262">        if (ni &gt; _mol.NumAtoms())</a>
<a name="ln4263">          continue;</a>
<a name="ln4264"> </a>
<a name="ln4265">        if ( (atoi(_mol.GetAtom(ni)-&gt;GetType()) == 87) ||</a>
<a name="ln4266">             (atoi(_mol.GetAtom(ni)-&gt;GetType()) == 97)</a>
<a name="ln4267">             ) continue;</a>
<a name="ln4268"> </a>
<a name="ln4269">        if (fabs((*di) - _mol.GetAtom(ni)-&gt;GetPartialCharge()) &lt;= 0.001)</a>
<a name="ln4270">          snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %7.4f     %7.4f          PASSED&quot;, _mol.GetAtom(ni)-&gt;GetIdx(), _mol.GetAtom(ni)-&gt;GetPartialCharge(), *di);</a>
<a name="ln4271">        else {</a>
<a name="ln4272">          snprintf(_logbuf, BUFF_SIZE, &quot;%2d   %7.4f     %7.4f      XXX FAILED XXX&quot;, _mol.GetAtom(ni)-&gt;GetIdx(), _mol.GetAtom(ni)-&gt;GetPartialCharge(), *di);</a>
<a name="ln4273">          failed = true;</a>
<a name="ln4274">        }</a>
<a name="ln4275"> </a>
<a name="ln4276">        cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4277"> </a>
<a name="ln4278">        ni++;</a>
<a name="ln4279">      }</a>
<a name="ln4280"> </a>
<a name="ln4281">      if (failed) {</a>
<a name="ln4282">        cout &lt;&lt; &quot;Could not successfully assign partial charges&quot; &lt;&lt; endl;</a>
<a name="ln4283">        //return false;</a>
<a name="ln4284">        continue;</a>
<a name="ln4285">      }</a>
<a name="ln4286"> </a>
<a name="ln4287"> </a>
<a name="ln4288"> </a>
<a name="ln4289">      if (!SetupCalculations()) {</a>
<a name="ln4290">        cout &lt;&lt; &quot;Could not setup calculations (missing parameters...)&quot; &lt;&lt; endl;</a>
<a name="ln4291">        return false;</a>
<a name="ln4292">        //continue;</a>
<a name="ln4293">      }</a>
<a name="ln4294"> </a>
<a name="ln4295">      double delta;</a>
<a name="ln4296">      cout &lt;&lt; endl;</a>
<a name="ln4297">      cout &lt;&lt; &quot;TERM                     OB ENERGY     LOG ENERGY         DELTA&quot; &lt;&lt; endl;</a>
<a name="ln4298">      cout &lt;&lt; &quot;---------------------------------------------------------------&quot; &lt;&lt; endl;</a>
<a name="ln4299"> </a>
<a name="ln4300">      delta = (E_Bond() - ebond);</a>
<a name="ln4301">      snprintf(_logbuf, BUFF_SIZE, &quot;Bond Stretching        %11.5f    %11.5f   %11.5f&quot;, E_Bond(), ebond, delta);</a>
<a name="ln4302">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4303"> </a>
<a name="ln4304">      delta = (E_Angle() - eangle);</a>
<a name="ln4305">      snprintf(_logbuf, BUFF_SIZE, &quot;Angle Bending          %11.5f    %11.5f   %11.5f&quot;, E_Angle(), eangle, delta);</a>
<a name="ln4306">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4307"> </a>
<a name="ln4308">      delta = (E_StrBnd() - estbn);</a>
<a name="ln4309">      snprintf(_logbuf, BUFF_SIZE, &quot;Stretch-Bending        %11.5f    %11.5f   %11.5f&quot;, E_StrBnd(), estbn, delta);</a>
<a name="ln4310">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4311"> </a>
<a name="ln4312">      delta = (E_OOP() - eoop);</a>
<a name="ln4313">      snprintf(_logbuf, BUFF_SIZE, &quot;Out-Of-Plane Bending   %11.5f    %11.5f   %11.5f&quot;, E_OOP(), eoop, delta);</a>
<a name="ln4314">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4315"> </a>
<a name="ln4316">      delta = (E_Torsion() - etor);</a>
<a name="ln4317">      snprintf(_logbuf, BUFF_SIZE, &quot;Torsional              %11.5f    %11.5f   %11.5f&quot;, E_Torsion(), etor, delta);</a>
<a name="ln4318">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4319"> </a>
<a name="ln4320">      delta = (E_VDW() - evdw);</a>
<a name="ln4321">      snprintf(_logbuf, BUFF_SIZE, &quot;Van der Waals          %11.5f    %11.5f   %11.5f&quot;, E_VDW(), evdw, delta);</a>
<a name="ln4322">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4323"> </a>
<a name="ln4324">      delta = (E_Electrostatic() - eeq);</a>
<a name="ln4325">      snprintf(_logbuf, BUFF_SIZE, &quot;Electrostatic          %11.5f    %11.5f   %11.5f&quot;, E_Electrostatic(), eeq, delta);</a>
<a name="ln4326">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4327"> </a>
<a name="ln4328">      cout &lt;&lt; endl;</a>
<a name="ln4329">      delta = (Energy() - etot);</a>
<a name="ln4330">      snprintf(_logbuf, BUFF_SIZE, &quot;Total ENERGY           %11.5f    %11.5f   %11.5f&quot;, Energy(), etot, delta);</a>
<a name="ln4331">      cout &lt;&lt; _logbuf &lt;&lt; endl;</a>
<a name="ln4332"> </a>
<a name="ln4333">    } // for (unsigned int c;; c++ )</a>
<a name="ln4334"> </a>
<a name="ln4335">    if (ifs)</a>
<a name="ln4336">      ifs.close();</a>
<a name="ln4337">    if (ifs2)</a>
<a name="ln4338">      ifs2.close();</a>
<a name="ln4339"> </a>
<a name="ln4340">    return true;</a>
<a name="ln4341">  }</a>
<a name="ln4342"> </a>
<a name="ln4343">  bool OBForceFieldMMFF94::ValidateGradients ()</a>
<a name="ln4344">  {</a>
<a name="ln4345">    vector3 numgrad, anagrad, err;</a>
<a name="ln4346">    int coordIdx;</a>
<a name="ln4347"> </a>
<a name="ln4348">    bool passed = true; // set to false if any component fails</a>
<a name="ln4349"> </a>
<a name="ln4350">    cout &lt;&lt; &quot;----------------------------------------------------------------------------------------&quot; &lt;&lt; endl;</a>
<a name="ln4351">    cout &lt;&lt; &quot;                                                                                        &quot; &lt;&lt; endl;</a>
<a name="ln4352">    cout &lt;&lt; &quot;  VALIDATE GRADIENTS : &quot; &lt;&lt; _mol.GetTitle() &lt;&lt; endl;</a>
<a name="ln4353">    cout &lt;&lt; &quot;                                                                                        &quot; &lt;&lt; endl;</a>
<a name="ln4354">    cout &lt;&lt; &quot;                                                                                        &quot; &lt;&lt; endl;</a>
<a name="ln4355">    cout &lt;&lt; &quot;ATOM IDX      NUMERICAL GRADIENT           ANALYTICAL GRADIENT        REL. ERROR (%)   &quot; &lt;&lt; endl;</a>
<a name="ln4356">    cout &lt;&lt; &quot;----------------------------------------------------------------------------------------&quot; &lt;&lt; endl;</a>
<a name="ln4357">    //     &quot;XX       (000.000, 000.000, 000.000)  (000.000, 000.000, 000.000)  (00.00, 00.00, 00.00)&quot;</a>
<a name="ln4358"> </a>
<a name="ln4359">    FOR_ATOMS_OF_MOL (a, _mol) {</a>
<a name="ln4360">      coordIdx = (a-&gt;GetIdx() - 1) * 3;</a>
<a name="ln4361"> </a>
<a name="ln4362">      // OBFF_ENERGY</a>
<a name="ln4363">      numgrad = NumericalDerivative(&amp;*a, OBFF_ENERGY);</a>
<a name="ln4364">      Energy(); // compute</a>
<a name="ln4365">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4366">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4367"> </a>
<a name="ln4368">      snprintf(_logbuf, BUFF_SIZE, &quot;%2d       (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, a-&gt;GetIdx(), numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4369">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4370">      OBFFLog(_logbuf);</a>
<a name="ln4371"> </a>
<a name="ln4372">      // OBFF_EBOND</a>
<a name="ln4373">      numgrad = NumericalDerivative(&amp;*a, OBFF_EBOND);</a>
<a name="ln4374">      ClearGradients();</a>
<a name="ln4375">      E_Bond(); // compute</a>
<a name="ln4376">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4377">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4378"> </a>
<a name="ln4379">      snprintf(_logbuf, BUFF_SIZE, &quot;    bond    (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4380">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4381">      OBFFLog(_logbuf);</a>
<a name="ln4382">      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4383">        passed = false;</a>
<a name="ln4384"> </a>
<a name="ln4385">      // OBFF_EANGLE</a>
<a name="ln4386">      numgrad = NumericalDerivative(&amp;*a, OBFF_EANGLE);</a>
<a name="ln4387">      ClearGradients();</a>
<a name="ln4388">      E_Angle(); // compute</a>
<a name="ln4389">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4390">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4391"> </a>
<a name="ln4392">      snprintf(_logbuf, BUFF_SIZE, &quot;    angle   (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4393">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4394">      OBFFLog(_logbuf);</a>
<a name="ln4395">      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4396">        passed = false;</a>
<a name="ln4397"> </a>
<a name="ln4398">      // OBFF_ESTRBND</a>
<a name="ln4399">      numgrad = NumericalDerivative(&amp;*a, OBFF_ESTRBND);</a>
<a name="ln4400">      ClearGradients();</a>
<a name="ln4401">      E_StrBnd(); // compute</a>
<a name="ln4402">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4403">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4404"> </a>
<a name="ln4405">      snprintf(_logbuf, BUFF_SIZE, &quot;    strbnd  (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4406">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4407">      OBFFLog(_logbuf);</a>
<a name="ln4408">      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4409">        passed = false;</a>
<a name="ln4410"> </a>
<a name="ln4411">      // OBFF_ETORSION</a>
<a name="ln4412">      numgrad = NumericalDerivative(&amp;*a, OBFF_ETORSION);</a>
<a name="ln4413">      ClearGradients();</a>
<a name="ln4414">      E_Torsion(); // compute</a>
<a name="ln4415">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4416">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4417"> </a>
<a name="ln4418">      snprintf(_logbuf, BUFF_SIZE, &quot;    torsion (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4419">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4420">      OBFFLog(_logbuf);</a>
<a name="ln4421">      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4422">        passed = false;</a>
<a name="ln4423"> </a>
<a name="ln4424">      // OBFF_EOOP</a>
<a name="ln4425">      numgrad = NumericalDerivative(&amp;*a, OBFF_EOOP);</a>
<a name="ln4426">      ClearGradients();</a>
<a name="ln4427">      E_OOP(); // compute</a>
<a name="ln4428">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4429">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4430"> </a>
<a name="ln4431">      snprintf(_logbuf, BUFF_SIZE, &quot;    oop     (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4432">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4433">      OBFFLog(_logbuf);</a>
<a name="ln4434">      // disable OOP gradient validation for now -- some small errors, but nothing major</a>
<a name="ln4435">      //      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4436">      //        passed = false;</a>
<a name="ln4437"> </a>
<a name="ln4438">      // OBFF_EVDW</a>
<a name="ln4439">      numgrad = NumericalDerivative(&amp;*a, OBFF_EVDW);</a>
<a name="ln4440">      ClearGradients();</a>
<a name="ln4441">      E_VDW(); // compute</a>
<a name="ln4442">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4443">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4444"> </a>
<a name="ln4445">      snprintf(_logbuf, BUFF_SIZE, &quot;    vdw     (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4446">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4447">      OBFFLog(_logbuf);</a>
<a name="ln4448">      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4449">        passed = false;</a>
<a name="ln4450"> </a>
<a name="ln4451">      // OBFF_EELECTROSTATIC</a>
<a name="ln4452">      numgrad = NumericalDerivative(&amp;*a, OBFF_EELECTROSTATIC);</a>
<a name="ln4453">      ClearGradients();</a>
<a name="ln4454">      E_Electrostatic(); // compute</a>
<a name="ln4455">      anagrad.Set(_gradientPtr[coordIdx], _gradientPtr[coordIdx+1], _gradientPtr[coordIdx+2]);</a>
<a name="ln4456">      err = ValidateGradientError(numgrad, anagrad);</a>
<a name="ln4457"> </a>
<a name="ln4458">      snprintf(_logbuf, BUFF_SIZE, &quot;    electro (%7.3f, %7.3f, %7.3f)  (%7.3f, %7.3f, %7.3f)  (%5.2f, %5.2f, %5.2f)\n&quot;, numgrad.x(), numgrad.y(), numgrad.z(),</a>
<a name="ln4459">              anagrad.x(), anagrad.y(), anagrad.z(), err.x(), err.y(), err.z());</a>
<a name="ln4460">      OBFFLog(_logbuf);</a>
<a name="ln4461">      if (err.x() &gt; 5.0 || err.y() &gt; 5.0 || err.z() &gt; 5.0)</a>
<a name="ln4462">        passed = false;</a>
<a name="ln4463">    }</a>
<a name="ln4464"> </a>
<a name="ln4465">    return passed; // did we pass every single component?</a>
<a name="ln4466">  }</a>
<a name="ln4467"> </a>
<a name="ln4468">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4469">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4470">  //</a>
<a name="ln4471">  //  Calculate bond type, angle type, stretch-bend type, torsion type</a>
<a name="ln4472">  //</a>
<a name="ln4473">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4474">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4475"> </a>
<a name="ln4476">  //</a>
<a name="ln4477">  // MMFF part V - page 620</a>
<a name="ln4478">  //</a>
<a name="ln4479">  // BTij is 1 when:</a>
<a name="ln4480">  // a) single bond between atoms i and j, both i and j are not aromatic and both types have sbmb set in mmffprop.par, or</a>
<a name="ln4481">  // b) bewtween two aromatic atoms, but the bond is not aromatic (e.g. connecting bond in biphenyl)</a>
<a name="ln4482">  //</a>
<a name="ln4483">  int OBForceFieldMMFF94::GetBondType(OBAtom* a, OBAtom* b)</a>
<a name="ln4484">  {</a>
<a name="ln4485">    OBBond *bond = _mol.GetBond(a, b);</a>
<a name="ln4486">    if (bond-&gt;GetBondOrder() != 1 || bond-&gt;IsAromatic())</a>
<a name="ln4487">      return 0;</a>
<a name="ln4488"> </a>
<a name="ln4489">    if (HasAromSet(atoi(a-&gt;GetType())) &amp;&amp; HasAromSet(atoi(b-&gt;GetType())))</a>
<a name="ln4490">      return 1;</a>
<a name="ln4491"> </a>
<a name="ln4492">    if (HasSbmbSet(atoi(a-&gt;GetType())) &amp;&amp; HasSbmbSet(atoi(b-&gt;GetType())))</a>
<a name="ln4493">      return 1;</a>
<a name="ln4494"> </a>
<a name="ln4495">    return 0;</a>
<a name="ln4496">  }</a>
<a name="ln4497"> </a>
<a name="ln4498">  int OBForceFieldMMFF94::GetAngleType(OBAtom* a, OBAtom* b, OBAtom *c)</a>
<a name="ln4499">  {</a>
<a name="ln4500">    int sumbondtypes;</a>
<a name="ln4501"> </a>
<a name="ln4502">    sumbondtypes = GetBondType(a,b) + GetBondType(b, c);</a>
<a name="ln4503"> </a>
<a name="ln4504">    if (a-&gt;IsInRingSize(3) &amp;&amp; b-&gt;IsInRingSize(3) &amp;&amp; c-&gt;IsInRingSize(3) &amp;&amp; IsInSameRing(a, c))</a>
<a name="ln4505">      switch (sumbondtypes) {</a>
<a name="ln4506">      case 0:</a>
<a name="ln4507">        return 3;</a>
<a name="ln4508">      case 1:</a>
<a name="ln4509">        return 5;</a>
<a name="ln4510">      case 2:</a>
<a name="ln4511">        return 6;</a>
<a name="ln4512">      }</a>
<a name="ln4513"> </a>
<a name="ln4514">    if (a-&gt;IsInRingSize(4) &amp;&amp; b-&gt;IsInRingSize(4) &amp;&amp; c-&gt;IsInRingSize(4) &amp;&amp; IsInSameRing(a, c))</a>
<a name="ln4515">      switch (sumbondtypes) {</a>
<a name="ln4516">      case 0:</a>
<a name="ln4517">        return 4;</a>
<a name="ln4518">      case 1:</a>
<a name="ln4519">        return 7;</a>
<a name="ln4520">      case 2:</a>
<a name="ln4521">        return 8;</a>
<a name="ln4522">      }</a>
<a name="ln4523"> </a>
<a name="ln4524">    return sumbondtypes;</a>
<a name="ln4525">  }</a>
<a name="ln4526"> </a>
<a name="ln4527">  int OBForceFieldMMFF94::GetStrBndType(OBAtom* a, OBAtom* b, OBAtom *c)</a>
<a name="ln4528">  {</a>
<a name="ln4529">    int btab, btbc, atabc;</a>
<a name="ln4530">    bool inverse;</a>
<a name="ln4531"> </a>
<a name="ln4532">    btab = GetBondType(a, b);</a>
<a name="ln4533">    btbc = GetBondType(b, c);</a>
<a name="ln4534">    atabc = GetAngleType(a, b, c);</a>
<a name="ln4535"> </a>
<a name="ln4536">    if (atoi(a-&gt;GetType()) &lt;= atoi(c-&gt;GetType()))</a>
<a name="ln4537">      inverse = false;</a>
<a name="ln4538">    else</a>
<a name="ln4539">      inverse = true;</a>
<a name="ln4540"> </a>
<a name="ln4541">    switch (atabc) {</a>
<a name="ln4542">    case 0:</a>
<a name="ln4543">      return 0;</a>
<a name="ln4544"> </a>
<a name="ln4545">    case 1:</a>
<a name="ln4546">      if (btab) {</a>
<a name="ln4547">        if (!inverse) {</a>
<a name="ln4548">          return 1;</a>
<a name="ln4549">        } else {</a>
<a name="ln4550">          return 2;</a>
<a name="ln4551">        }</a>
<a name="ln4552">      }</a>
<a name="ln4553">      if (btbc) {</a>
<a name="ln4554">        if (!inverse) {</a>
<a name="ln4555">          return 2;</a>
<a name="ln4556">        } else {</a>
<a name="ln4557">          return 1;</a>
<a name="ln4558">        }</a>
<a name="ln4559">      }</a>
<a name="ln4560"> </a>
<a name="ln4561">    case 2:</a>
<a name="ln4562">      return 3;</a>
<a name="ln4563"> </a>
<a name="ln4564">    case 3:</a>
<a name="ln4565">      return 5;</a>
<a name="ln4566"> </a>
<a name="ln4567">    case 4:</a>
<a name="ln4568">      return 4;</a>
<a name="ln4569"> </a>
<a name="ln4570">    case 5:</a>
<a name="ln4571">      if (btab) {</a>
<a name="ln4572">        if (!inverse) {</a>
<a name="ln4573">          return 6;</a>
<a name="ln4574">        } else {</a>
<a name="ln4575">          return 7;</a>
<a name="ln4576">        }</a>
<a name="ln4577">      }</a>
<a name="ln4578">      if (btbc) {</a>
<a name="ln4579">        if (!inverse) {</a>
<a name="ln4580">          return 7;</a>
<a name="ln4581">        } else {</a>
<a name="ln4582">          return 6;</a>
<a name="ln4583">        }</a>
<a name="ln4584">      }</a>
<a name="ln4585"> </a>
<a name="ln4586">    case 6:</a>
<a name="ln4587">      return 8;</a>
<a name="ln4588"> </a>
<a name="ln4589">    case 7:</a>
<a name="ln4590">      if (btab) {</a>
<a name="ln4591">        if (!inverse) {</a>
<a name="ln4592">          return 9;</a>
<a name="ln4593">        } else {</a>
<a name="ln4594">          return 10;</a>
<a name="ln4595">        }</a>
<a name="ln4596">      }</a>
<a name="ln4597">      if (btbc) {</a>
<a name="ln4598">        if (!inverse) {</a>
<a name="ln4599">          return 10;</a>
<a name="ln4600">        } else {</a>
<a name="ln4601">          return 9;</a>
<a name="ln4602">        }</a>
<a name="ln4603">      }</a>
<a name="ln4604"> </a>
<a name="ln4605">    case 8:</a>
<a name="ln4606">      return 11;</a>
<a name="ln4607">    }</a>
<a name="ln4608"> </a>
<a name="ln4609">    return 0;</a>
<a name="ln4610">  }</a>
<a name="ln4611"> </a>
<a name="ln4612">  //</a>
<a name="ln4613">  // MMFF part IV - page 609</a>
<a name="ln4614">  //</a>
<a name="ln4615">  // TTijkl = 1 when BTjk = 1</a>
<a name="ln4616">  // TTijkl = 2 when BTjk = 0 but BTij and/or BTkl = 1</a>
<a name="ln4617">  // TTijkl = 4 when i, j, k and l are all members of the same four-membered ring</a>
<a name="ln4618">  // TTijkl = 5 when i, j, k and l are members of a five-membered ring and at least one is a sp3-hybridized carbon (MMFF atom type 1)</a>
<a name="ln4619">  //</a>
<a name="ln4620">  int OBForceFieldMMFF94::GetTorsionType(OBAtom* a, OBAtom* b, OBAtom *c, OBAtom *d)</a>
<a name="ln4621">  {</a>
<a name="ln4622">    int btab, btbc, btcd;</a>
<a name="ln4623"> </a>
<a name="ln4624">    btab = GetBondType(a, b);</a>
<a name="ln4625">    btbc = GetBondType(b, c);</a>
<a name="ln4626">    btcd = GetBondType(c, d);</a>
<a name="ln4627"> </a>
<a name="ln4628">    if (btbc == 1)</a>
<a name="ln4629">      return 1;</a>
<a name="ln4630"> </a>
<a name="ln4631">    if (a-&gt;IsInRingSize(4) &amp;&amp; b-&gt;IsInRingSize(4) &amp;&amp; c-&gt;IsInRingSize(4) &amp;&amp; d-&gt;IsInRingSize(4))</a>
<a name="ln4632">      if (IsInSameRing(a,b) &amp;&amp; IsInSameRing(b,c) &amp;&amp; IsInSameRing(c,d))</a>
<a name="ln4633">        return 4;</a>
<a name="ln4634"> </a>
<a name="ln4635">    OBBond *bond = _mol.GetBond(b, c);</a>
<a name="ln4636">    if (bond-&gt;GetBondOrder() == 1 &amp;&amp; !bond-&gt;IsAromatic()) {</a>
<a name="ln4637">      if (btab || btcd)</a>
<a name="ln4638">        return 2;</a>
<a name="ln4639">      /*</a>
<a name="ln4640">        unsigned int order1 = GetCXT(0, atoi(d-&gt;GetType()), atoi(c-&gt;GetType()), atoi(b-&gt;GetType()), atoi(a-&gt;GetType()));</a>
<a name="ln4641">        unsigned int order2 = GetCXT(0, atoi(a-&gt;GetType()), atoi(b-&gt;GetType()), atoi(c-&gt;GetType()), atoi(d-&gt;GetType()));</a>
<a name="ln4642"> </a>
<a name="ln4643">        cout &lt;&lt; &quot;GetTorsionType(&quot; &lt;&lt; a-&gt;GetType() &lt;&lt; &quot;, &quot; &lt;&lt; b-&gt;GetType() &lt;&lt; &quot;, &quot; &lt;&lt; c-&gt;GetType() &lt;&lt; &quot;, &quot; &lt;&lt; d-&gt;GetType() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln4644">        cout &lt;&lt; &quot;    order1 = &quot; &lt;&lt; order1 &lt;&lt; endl;</a>
<a name="ln4645">        cout &lt;&lt; &quot;    order2 = &quot; &lt;&lt; order2 &lt;&lt; endl;</a>
<a name="ln4646">        cout &lt;&lt; &quot;    btab = &quot; &lt;&lt; btab &lt;&lt; endl;</a>
<a name="ln4647">        cout &lt;&lt; &quot;    btbc = &quot; &lt;&lt; btbc &lt;&lt; endl;</a>
<a name="ln4648">        cout &lt;&lt; &quot;    btcd = &quot; &lt;&lt; btcd &lt;&lt; endl;</a>
<a name="ln4649">      */</a>
<a name="ln4650">    }</a>
<a name="ln4651"> </a>
<a name="ln4652">    if (a-&gt;IsInRingSize(5) &amp;&amp; b-&gt;IsInRingSize(5) &amp;&amp; c-&gt;IsInRingSize(5) &amp;&amp; d-&gt;IsInRingSize(5)) {</a>
<a name="ln4653">      vector&lt;OBRing*&gt; vr;</a>
<a name="ln4654">      vr = _mol.GetSSSR();</a>
<a name="ln4655"> </a>
<a name="ln4656">      if( !((atoi(a-&gt;GetType()) == 1) || (atoi(b-&gt;GetType()) == 1) || (atoi(c-&gt;GetType()) == 1) || (atoi(d-&gt;GetType()) == 1)) )</a>
<a name="ln4657">        return 0;</a>
<a name="ln4658"> </a>
<a name="ln4659">      vector&lt;OBRing*&gt;::iterator ri;</a>
<a name="ln4660">      vector&lt;int&gt;::iterator rj;</a>
<a name="ln4661">      for (ri = vr.begin();ri != vr.end();++ri) { // for each ring</a>
<a name="ln4662">        if ((*ri)-&gt;IsAromatic())</a>
<a name="ln4663">          continue;</a>
<a name="ln4664"> </a>
<a name="ln4665">        if ((*ri)-&gt;Size() != 5)</a>
<a name="ln4666">          continue;</a>
<a name="ln4667"> </a>
<a name="ln4668">        if (!(*ri)-&gt;IsMember(a) || !(*ri)-&gt;IsMember(b) || !(*ri)-&gt;IsMember(c) || !(*ri)-&gt;IsMember(d))</a>
<a name="ln4669">          continue;</a>
<a name="ln4670"> </a>
<a name="ln4671">        return 5;</a>
<a name="ln4672">      }</a>
<a name="ln4673">    }</a>
<a name="ln4674"> </a>
<a name="ln4675"> </a>
<a name="ln4676">    return 0;</a>
<a name="ln4677">  }</a>
<a name="ln4678"> </a>
<a name="ln4679">  // CXB = MC * (I * MA + J) + BTij</a>
<a name="ln4680">  unsigned int OBForceFieldMMFF94::GetCXB(int type, int a, int b)</a>
<a name="ln4681">  {</a>
<a name="ln4682">    unsigned int cxb;</a>
<a name="ln4683">    cxb = 2 * (a * 136 + b) + type;</a>
<a name="ln4684">    return cxb;</a>
<a name="ln4685">  }</a>
<a name="ln4686"> </a>
<a name="ln4687">  // CXA = MC * (J * MA^2 + I * MA + K) + ATijk</a>
<a name="ln4688">  unsigned int OBForceFieldMMFF94::GetCXA(int type, int a, int b, int c)</a>
<a name="ln4689">  {</a>
<a name="ln4690">    unsigned int cxa;</a>
<a name="ln4691">    cxa = 9 * (b * 18496 + a * 136 + c) + type;</a>
<a name="ln4692">    return cxa;</a>
<a name="ln4693">  }</a>
<a name="ln4694"> </a>
<a name="ln4695">  // CXS = MC * (J * MA^2 + I * MA + K) + STijk</a>
<a name="ln4696">  unsigned int OBForceFieldMMFF94::GetCXS(int type, int a, int b, int c)</a>
<a name="ln4697">  {</a>
<a name="ln4698">    unsigned int cxs;</a>
<a name="ln4699">    cxs = 12 * (b * 18496 + a * 136 + c) + type;</a>
<a name="ln4700">    return cxs;</a>
<a name="ln4701">  }</a>
<a name="ln4702"> </a>
<a name="ln4703">  // CXO = J * MA^3 + I * MA^2 + K * MA + L</a>
<a name="ln4704">  unsigned int OBForceFieldMMFF94::GetCXO(int a, int b, int c, int d)</a>
<a name="ln4705">  {</a>
<a name="ln4706">    unsigned int cxo;</a>
<a name="ln4707">    cxo = b * 2515456 + a * 18496 + c * 136 + d;</a>
<a name="ln4708">    return cxo;</a>
<a name="ln4709">  }</a>
<a name="ln4710"> </a>
<a name="ln4711">  // CXT = MC * (J * MA^3 + K * MA^2 + I * MA + L) + TTijkl</a>
<a name="ln4712">  unsigned int OBForceFieldMMFF94::GetCXT(int type, int a, int b, int c, int d)</a>
<a name="ln4713">  {</a>
<a name="ln4714">    unsigned int cxt;</a>
<a name="ln4715">    cxt = 6 * (b * 2515456 + c * 18496 + a * 136 + d) + type;</a>
<a name="ln4716">    return cxt;</a>
<a name="ln4717">  }</a>
<a name="ln4718"> </a>
<a name="ln4719">  // CXQ = MC * (I * MA + J) + BTij</a>
<a name="ln4720">  unsigned int OBForceFieldMMFF94::GetCXQ(int type, int a, int b)</a>
<a name="ln4721">  {</a>
<a name="ln4722">    unsigned int cxq;</a>
<a name="ln4723">    cxq = 2 * (a * 136 + b) + type;</a>
<a name="ln4724">    return cxq;</a>
<a name="ln4725">  }</a>
<a name="ln4726"> </a>
<a name="ln4727">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4728">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4729">  //</a>
<a name="ln4730">  //  Various tables &amp; misc. functions</a>
<a name="ln4731">  //</a>
<a name="ln4732">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4733">  ////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4734"> </a>
<a name="ln4735">  // MMFF part V - TABLE I</a>
<a name="ln4736">  bool OBForceFieldMMFF94::HasLinSet(int atomtype)</a>
<a name="ln4737">  {</a>
<a name="ln4738">    return _ffpropLin.BitIsSet(atomtype);</a>
<a name="ln4739">  }</a>
<a name="ln4740"> </a>
<a name="ln4741">  // MMFF part V - TABLE I</a>
<a name="ln4742">  bool OBForceFieldMMFF94::HasPilpSet(int atomtype)</a>
<a name="ln4743">  {</a>
<a name="ln4744">    return _ffpropPilp.BitIsSet(atomtype);</a>
<a name="ln4745">  }</a>
<a name="ln4746"> </a>
<a name="ln4747">  // MMFF part V - TABLE I</a>
<a name="ln4748">  bool OBForceFieldMMFF94::HasAromSet(int atomtype)</a>
<a name="ln4749">  {</a>
<a name="ln4750">    return _ffpropArom.BitIsSet(atomtype);</a>
<a name="ln4751">  }</a>
<a name="ln4752"> </a>
<a name="ln4753">  // MMFF part V - TABLE I</a>
<a name="ln4754">  bool OBForceFieldMMFF94::HasSbmbSet(int atomtype)</a>
<a name="ln4755">  {</a>
<a name="ln4756">    return _ffpropSbmb.BitIsSet(atomtype);</a>
<a name="ln4757">  }</a>
<a name="ln4758"> </a>
<a name="ln4759">  // MMFF part V - TABLE I</a>
<a name="ln4760">  int OBForceFieldMMFF94::GetCrd(int atomtype)</a>
<a name="ln4761">  {</a>
<a name="ln4762">    OBFFParameter *par;</a>
<a name="ln4763"> </a>
<a name="ln4764">    par = GetParameter1Atom(atomtype, _ffpropparams); // from mmffprop.par</a>
<a name="ln4765">    if (par)</a>
<a name="ln4766">      return par-&gt;_ipar[1];</a>
<a name="ln4767"> </a>
<a name="ln4768">    return 0;</a>
<a name="ln4769">  }</a>
<a name="ln4770"> </a>
<a name="ln4771">  // MMFF part V - TABLE I</a>
<a name="ln4772">  int OBForceFieldMMFF94::GetVal(int atomtype)</a>
<a name="ln4773">  {</a>
<a name="ln4774">    OBFFParameter *par;</a>
<a name="ln4775"> </a>
<a name="ln4776">    par = GetParameter1Atom(atomtype, _ffpropparams); // from mmffprop.par</a>
<a name="ln4777">    if (par)</a>
<a name="ln4778">      return par-&gt;_ipar[2];</a>
<a name="ln4779"> </a>
<a name="ln4780">    return 0;</a>
<a name="ln4781">  }</a>
<a name="ln4782"> </a>
<a name="ln4783">  // MMFF part V - TABLE I</a>
<a name="ln4784">  int OBForceFieldMMFF94::GetMltb(int atomtype)</a>
<a name="ln4785">  {</a>
<a name="ln4786">    OBFFParameter *par;</a>
<a name="ln4787"> </a>
<a name="ln4788">    par = GetParameter1Atom(atomtype, _ffpropparams); // from mmffprop.par</a>
<a name="ln4789">    if (par)</a>
<a name="ln4790">      return par-&gt;_ipar[4];</a>
<a name="ln4791"> </a>
<a name="ln4792">    return 0;</a>
<a name="ln4793">  }</a>
<a name="ln4794"> </a>
<a name="ln4795">  // MMFF part I - TABLE IV</a>
<a name="ln4796">  int OBForceFieldMMFF94::EqLvl2(int type)</a>
<a name="ln4797">  {</a>
<a name="ln4798">    for (unsigned int idx=0; idx &lt; _ffdefparams.size(); idx++)</a>
<a name="ln4799">      if (_ffdefparams[idx]._ipar[0] == type)</a>
<a name="ln4800">        return _ffdefparams[idx]._ipar[1];</a>
<a name="ln4801"> </a>
<a name="ln4802">    return type;</a>
<a name="ln4803">  }</a>
<a name="ln4804"> </a>
<a name="ln4805">  // MMFF part I - TABLE IV</a>
<a name="ln4806">  int OBForceFieldMMFF94::EqLvl3(int type)</a>
<a name="ln4807">  {</a>
<a name="ln4808">    for (unsigned int idx=0; idx &lt; _ffdefparams.size(); idx++)</a>
<a name="ln4809">      if (_ffdefparams[idx]._ipar[0] == type)</a>
<a name="ln4810">        return _ffdefparams[idx]._ipar[2];</a>
<a name="ln4811"> </a>
<a name="ln4812">    return type;</a>
<a name="ln4813">  }</a>
<a name="ln4814"> </a>
<a name="ln4815">  // MMFF part I - TABLE IV</a>
<a name="ln4816">  int OBForceFieldMMFF94::EqLvl4(int type)</a>
<a name="ln4817">  {</a>
<a name="ln4818">    for (unsigned int idx=0; idx &lt; _ffdefparams.size(); idx++)</a>
<a name="ln4819">      if (_ffdefparams[idx]._ipar[0] == type)</a>
<a name="ln4820">        return _ffdefparams[idx]._ipar[3];</a>
<a name="ln4821"> </a>
<a name="ln4822">    return type;</a>
<a name="ln4823">  }</a>
<a name="ln4824"> </a>
<a name="ln4825">  // MMFF part I - TABLE IV</a>
<a name="ln4826">  int OBForceFieldMMFF94::EqLvl5(int type)</a>
<a name="ln4827">  {</a>
<a name="ln4828">    for (unsigned int idx=0; idx &lt; _ffdefparams.size(); idx++)</a>
<a name="ln4829">      if (_ffdefparams[idx]._ipar[0] == type)</a>
<a name="ln4830">        return _ffdefparams[idx]._ipar[4];</a>
<a name="ln4831"> </a>
<a name="ln4832">    return type;</a>
<a name="ln4833">  }</a>
<a name="ln4834"> </a>
<a name="ln4835">  // MMFF part V - TABLE VI</a>
<a name="ln4836">  double OBForceFieldMMFF94::GetZParam(OBAtom* atom)</a>
<a name="ln4837">  {</a>
<a name="ln4838">    switch (atom-&gt;GetAtomicNum()) {</a>
<a name="ln4839">    case OBElements::Hydrogen:</a>
<a name="ln4840">      return 1.395;</a>
<a name="ln4841">    case OBElements::Carbon:</a>
<a name="ln4842">      return 2.494;</a>
<a name="ln4843">    case OBElements::Nitrogen:</a>
<a name="ln4844">      return 2.711;</a>
<a name="ln4845">    case OBElements::Oxygen:</a>
<a name="ln4846">      return 3.045;</a>
<a name="ln4847">    case OBElements::Fluorine:</a>
<a name="ln4848">      return 2.847;</a>
<a name="ln4849">    case OBElements::Silicon:</a>
<a name="ln4850">      return 2.350;</a>
<a name="ln4851">    case OBElements::Phosphorus:</a>
<a name="ln4852">      return 2.350;</a>
<a name="ln4853">    case OBElements::Sulfur:</a>
<a name="ln4854">      return 2.980;</a>
<a name="ln4855">    case OBElements::Chlorine:</a>
<a name="ln4856">      return 2.909;</a>
<a name="ln4857">    case OBElements::Bromine:</a>
<a name="ln4858">      return 3.017;</a>
<a name="ln4859">    case OBElements::Iodine:</a>
<a name="ln4860">      return 3.086;</a>
<a name="ln4861">    }</a>
<a name="ln4862"> </a>
<a name="ln4863">    return 0.0;</a>
<a name="ln4864">  }</a>
<a name="ln4865"> </a>
<a name="ln4866">  // MMFF part V - TABLE VI</a>
<a name="ln4867">  double OBForceFieldMMFF94::GetCParam(OBAtom* atom)</a>
<a name="ln4868">  {</a>
<a name="ln4869">    switch (atom-&gt;GetAtomicNum()) {</a>
<a name="ln4870">    case OBElements::Boron:</a>
<a name="ln4871">      return 0.704;</a>
<a name="ln4872">    case OBElements::Carbon:</a>
<a name="ln4873">      return 1.016;</a>
<a name="ln4874">    case OBElements::Nitrogen:</a>
<a name="ln4875">      return 1.113;</a>
<a name="ln4876">    case OBElements::Oxygen:</a>
<a name="ln4877">      return 1.337;</a>
<a name="ln4878">    case OBElements::Silicon:</a>
<a name="ln4879">      return 0.811;</a>
<a name="ln4880">    case OBElements::Phosphorus:</a>
<a name="ln4881">      return 1.068;</a>
<a name="ln4882">    case OBElements::Sulfur:</a>
<a name="ln4883">      return 1.249;</a>
<a name="ln4884">    case OBElements::Chlorine:</a>
<a name="ln4885">      return 1.078;</a>
<a name="ln4886">    case OBElements::Arsenic:</a>
<a name="ln4887">      return 0.825;</a>
<a name="ln4888">    }</a>
<a name="ln4889"> </a>
<a name="ln4890">    return 0.0;</a>
<a name="ln4891">  }</a>
<a name="ln4892"> </a>
<a name="ln4893">  // MMFF part V - TABLE X</a>
<a name="ln4894">  double OBForceFieldMMFF94::GetUParam(OBAtom* atom)</a>
<a name="ln4895">  {</a>
<a name="ln4896">    switch (atom-&gt;GetAtomicNum()) {</a>
<a name="ln4897">    case OBElements::Carbon:</a>
<a name="ln4898">      return 2.0;</a>
<a name="ln4899">    case OBElements::Nitrogen:</a>
<a name="ln4900">      return 2.0;</a>
<a name="ln4901">    case OBElements::Oxygen:</a>
<a name="ln4902">      return 2.0;</a>
<a name="ln4903">    case OBElements::Silicon:</a>
<a name="ln4904">      return 1.25;</a>
<a name="ln4905">    case OBElements::Phosphorus:</a>
<a name="ln4906">      return 1.25;</a>
<a name="ln4907">    case OBElements::Sulfur:</a>
<a name="ln4908">      return 1.25;</a>
<a name="ln4909">    }</a>
<a name="ln4910"> </a>
<a name="ln4911">    return 0.0;</a>
<a name="ln4912">  }</a>
<a name="ln4913"> </a>
<a name="ln4914">  // MMFF part V - TABLE X</a>
<a name="ln4915">  double OBForceFieldMMFF94::GetVParam(OBAtom* atom)</a>
<a name="ln4916">  {</a>
<a name="ln4917">    switch (atom-&gt;GetAtomicNum()) {</a>
<a name="ln4918">    case OBElements::Carbon:</a>
<a name="ln4919">      return 2.12;</a>
<a name="ln4920">    case OBElements::Nitrogen:</a>
<a name="ln4921">      return 1.5;</a>
<a name="ln4922">    case OBElements::Oxygen:</a>
<a name="ln4923">      return 0.2;</a>
<a name="ln4924">    case OBElements::Silicon:</a>
<a name="ln4925">      return 1.22;</a>
<a name="ln4926">    case OBElements::Phosphorus:</a>
<a name="ln4927">      return 2.4;</a>
<a name="ln4928">    case OBElements::Sulfur:</a>
<a name="ln4929">      return 0.49;</a>
<a name="ln4930">    }</a>
<a name="ln4931"> </a>
<a name="ln4932">    return 0.0;</a>
<a name="ln4933">  }</a>
<a name="ln4934"> </a>
<a name="ln4935">  // R Blom and A Haaland, J. Mol. Struct., 128, 21-27 (1985)</a>
<a name="ln4936">  double OBForceFieldMMFF94::GetCovalentRadius(OBAtom* a) {</a>
<a name="ln4937"> </a>
<a name="ln4938">    switch (a-&gt;GetAtomicNum()) {</a>
<a name="ln4939">    case 1:</a>
<a name="ln4940">      return 0.33; // corrected value from MMFF part V</a>
<a name="ln4941">    case 5:</a>
<a name="ln4942">      return 0.81;</a>
<a name="ln4943">    case 6:</a>
<a name="ln4944">      return 0.77; // corrected value from MMFF part V</a>
<a name="ln4945">    case 7:</a>
<a name="ln4946">      return 0.73;</a>
<a name="ln4947">    case 8:</a>
<a name="ln4948">      return 0.72;</a>
<a name="ln4949">    case 9:</a>
<a name="ln4950">      return 0.74;</a>
<a name="ln4951">    case 13:</a>
<a name="ln4952">      return 1.22;</a>
<a name="ln4953">    case 14:</a>
<a name="ln4954">      return 1.15;</a>
<a name="ln4955">    case 15:</a>
<a name="ln4956">      return 1.09;</a>
<a name="ln4957">    case 16:</a>
<a name="ln4958">      return 1.03;</a>
<a name="ln4959">    case 17:</a>
<a name="ln4960">      return 1.01;</a>
<a name="ln4961">    case 31:</a>
<a name="ln4962">      return 1.19;</a>
<a name="ln4963">    case 32:</a>
<a name="ln4964">      return 1.20;</a>
<a name="ln4965">    case 33:</a>
<a name="ln4966">      return 1.20;</a>
<a name="ln4967">    case 34:</a>
<a name="ln4968">      return 1.16;</a>
<a name="ln4969">    case 35:</a>
<a name="ln4970">      return 1.15;</a>
<a name="ln4971">    case 44:</a>
<a name="ln4972">      return 1.46;</a>
<a name="ln4973">    case 50:</a>
<a name="ln4974">      return 1.40;</a>
<a name="ln4975">    case 51:</a>
<a name="ln4976">      return 1.41;</a>
<a name="ln4977">    case 52:</a>
<a name="ln4978">      return 1.35;</a>
<a name="ln4979">    case 53:</a>
<a name="ln4980">      return 1.33;</a>
<a name="ln4981">    case 81:</a>
<a name="ln4982">      return 1.51;</a>
<a name="ln4983">    case 82:</a>
<a name="ln4984">      return 1.53;</a>
<a name="ln4985">    case 83:</a>
<a name="ln4986">      return 1.55;</a>
<a name="ln4987">    default:</a>
<a name="ln4988">      return OBElements::GetCovalentRad(a-&gt;GetAtomicNum());</a>
<a name="ln4989">    }</a>
<a name="ln4990">  }</a>
<a name="ln4991"> </a>
<a name="ln4992">  double OBForceFieldMMFF94::GetBondLength(OBAtom* a, OBAtom* b)</a>
<a name="ln4993">  {</a>
<a name="ln4994">    OBFFParameter *parameter;</a>
<a name="ln4995">    double rab;</a>
<a name="ln4996"> </a>
<a name="ln4997">    parameter = GetTypedParameter2Atom(GetBondType(a, b), atoi(a-&gt;GetType()), atoi(b-&gt;GetType()), _ffbondparams);</a>
<a name="ln4998">    if (parameter == nullptr)</a>
<a name="ln4999">      rab = GetRuleBondLength(a, b);</a>
<a name="ln5000">    else</a>
<a name="ln5001">      rab = parameter-&gt;_dpar[1];</a>
<a name="ln5002"> </a>
<a name="ln5003">    return rab;</a>
<a name="ln5004">  }</a>
<a name="ln5005"> </a>
<a name="ln5006">  // MMFF part V - page 625</a>
<a name="ln5007">  double OBForceFieldMMFF94::GetRuleBondLength(OBAtom* a, OBAtom* b)</a>
<a name="ln5008">  {</a>
<a name="ln5009">    double r0ab, r0a, r0b, c, Xa, Xb;</a>
<a name="ln5010">    int Ha, Hb, BOab;</a>
<a name="ln5011">    r0a = GetCovalentRadius(a);</a>
<a name="ln5012">    r0b = GetCovalentRadius(b);</a>
<a name="ln5013">    Xa = OBElements::GetAllredRochowElectroNeg(a-&gt;GetAtomicNum());</a>
<a name="ln5014">    Xb = OBElements::GetAllredRochowElectroNeg(b-&gt;GetAtomicNum());</a>
<a name="ln5015"> </a>
<a name="ln5016"> </a>
<a name="ln5017">    if (a-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln5018">      r0a = 0.33;</a>
<a name="ln5019">    if (b-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln5020">      r0b = 0.33;</a>
<a name="ln5021"> </a>
<a name="ln5022">    if (a-&gt;GetAtomicNum() == OBElements::Hydrogen || b-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln5023">      c = 0.050;</a>
<a name="ln5024">    else</a>
<a name="ln5025">      c = 0.085;</a>
<a name="ln5026"> </a>
<a name="ln5027">    if (GetMltb(atoi(a-&gt;GetType()) == 3))</a>
<a name="ln5028">      Ha = 1;</a>
<a name="ln5029">    else if ((GetMltb(atoi(a-&gt;GetType())) == 1) || (GetMltb(atoi(a-&gt;GetType())) == 2))</a>
<a name="ln5030">      Ha = 2;</a>
<a name="ln5031">    else</a>
<a name="ln5032">      Ha = 3;</a>
<a name="ln5033"> </a>
<a name="ln5034">    if (GetMltb(atoi(b-&gt;GetType()) == 3))</a>
<a name="ln5035">      Hb = 1;</a>
<a name="ln5036">    else if ((GetMltb(atoi(b-&gt;GetType())) == 1) || (GetMltb(atoi(b-&gt;GetType())) == 2))</a>
<a name="ln5037">      Hb = 2;</a>
<a name="ln5038">    else</a>
<a name="ln5039">      Hb = 3;</a>
<a name="ln5040"> </a>
<a name="ln5041">    BOab = a-&gt;GetBond(b)-&gt;GetBondOrder();</a>
<a name="ln5042">    if ((GetMltb(atoi(a-&gt;GetType())) == 1) &amp;&amp; (GetMltb(atoi(b-&gt;GetType())) == 1))</a>
<a name="ln5043">      BOab = 4;</a>
<a name="ln5044">    if ((GetMltb(atoi(a-&gt;GetType())) == 1) &amp;&amp; (GetMltb(atoi(b-&gt;GetType())) == 2))</a>
<a name="ln5045">      BOab = 5;</a>
<a name="ln5046">    if ((GetMltb(atoi(a-&gt;GetType())) == 2) &amp;&amp; (GetMltb(atoi(b-&gt;GetType())) == 1))</a>
<a name="ln5047">      BOab = 5;</a>
<a name="ln5048">    if (a-&gt;GetBond(b)-&gt;IsAromatic()) {</a>
<a name="ln5049">      if (!HasPilpSet(atoi(a-&gt;GetType())) &amp;&amp; !HasPilpSet(atoi(b-&gt;GetType()))) {</a>
<a name="ln5050">        BOab = 4;</a>
<a name="ln5051">      } else {</a>
<a name="ln5052">        BOab = 5;</a>
<a name="ln5053">      }</a>
<a name="ln5054">    }</a>
<a name="ln5055"> </a>
<a name="ln5056">    switch (BOab) {</a>
<a name="ln5057">    case 5:</a>
<a name="ln5058">      r0a -= 0.04;</a>
<a name="ln5059">      r0b -= 0.04;</a>
<a name="ln5060">      break;</a>
<a name="ln5061">    case 4:</a>
<a name="ln5062">      r0a -= 0.075;</a>
<a name="ln5063">      r0b -= 0.075;</a>
<a name="ln5064">      break;</a>
<a name="ln5065">    case 3:</a>
<a name="ln5066">      r0a -= 0.17;</a>
<a name="ln5067">      r0b -= 0.17;</a>
<a name="ln5068">      break;</a>
<a name="ln5069">    case 2:</a>
<a name="ln5070">      r0a -= 0.10;</a>
<a name="ln5071">      r0b -= 0.10;</a>
<a name="ln5072">      break;</a>
<a name="ln5073">    case 1:</a>
<a name="ln5074">      if (Ha == 1)</a>
<a name="ln5075">        r0a -= 0.08;</a>
<a name="ln5076">      if (Ha == 2)</a>
<a name="ln5077">        r0a -= 0.03;</a>
<a name="ln5078">      if (Hb == 1)</a>
<a name="ln5079">        r0b -= 0.08;</a>
<a name="ln5080">      if (Hb == 2)</a>
<a name="ln5081">        r0b -= 0.03;</a>
<a name="ln5082">    }</a>
<a name="ln5083"> </a>
<a name="ln5084">    /*</a>
<a name="ln5085">      cout &lt;&lt; &quot;Ha=&quot; &lt;&lt; Ha &lt;&lt; &quot;  Hb=&quot; &lt;&lt; Hb &lt;&lt; &quot;  BOab=&quot; &lt;&lt; BOab &lt;&lt; endl;</a>
<a name="ln5086">      cout &lt;&lt; &quot;r0a=&quot; &lt;&lt; r0a &lt;&lt; &quot;  Xa=&quot; &lt;&lt; Xa &lt;&lt; endl;</a>
<a name="ln5087">      cout &lt;&lt; &quot;r0b=&quot; &lt;&lt; r0b &lt;&lt; &quot;  Xb=&quot; &lt;&lt; Xb &lt;&lt; endl;</a>
<a name="ln5088">      cout &lt;&lt; &quot;r0a + r0b=&quot; &lt;&lt; r0a +r0b &lt;&lt; endl;</a>
<a name="ln5089">      cout &lt;&lt; &quot;c=&quot; &lt;&lt; c &lt;&lt; &quot;  |Xa-Xb|=&quot; &lt;&lt; fabs(Xa-Xb) &lt;&lt; &quot;  |Xa-Xb|^1.4=&quot; &lt;&lt; pow(fabs(Xa-Xb), 1.4) &lt;&lt; endl;</a>
<a name="ln5090">    */</a>
<a name="ln5091">    r0ab = r0a + r0b - c * pow(fabs(Xa - Xb), 1.4) - 0.008;</a>
<a name="ln5092"> </a>
<a name="ln5093">    return r0ab;</a>
<a name="ln5094">  }</a>
<a name="ln5095"> </a>
<a name="ln5096">  OBFFParameter* OBForceFieldMMFF94::GetParameter1Atom(int a, std::vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln5097">  {</a>
<a name="ln5098">    OBFFParameter *par;</a>
<a name="ln5099"> </a>
<a name="ln5100">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln5101">      if (a == parameter[idx].a) {</a>
<a name="ln5102">        par = &amp;parameter[idx];</a>
<a name="ln5103">        return par;</a>
<a name="ln5104">      }</a>
<a name="ln5105"> </a>
<a name="ln5106">    return nullptr;</a>
<a name="ln5107">  }</a>
<a name="ln5108"> </a>
<a name="ln5109">  OBFFParameter* OBForceFieldMMFF94::GetParameter2Atom(int a, int b, std::vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln5110">  {</a>
<a name="ln5111">    OBFFParameter *par;</a>
<a name="ln5112"> </a>
<a name="ln5113">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln5114">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b)) ||</a>
<a name="ln5115">          ((a == parameter[idx].b) &amp;&amp; (b == parameter[idx].a)))</a>
<a name="ln5116">        {</a>
<a name="ln5117">          par = &amp;parameter[idx];</a>
<a name="ln5118">          return par;</a>
<a name="ln5119">        }</a>
<a name="ln5120"> </a>
<a name="ln5121">    return nullptr;</a>
<a name="ln5122">  }</a>
<a name="ln5123"> </a>
<a name="ln5124">  OBFFParameter* OBForceFieldMMFF94::GetParameter3Atom(int a, int b, int c, std::vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln5125">  {</a>
<a name="ln5126">    OBFFParameter *par;</a>
<a name="ln5127"> </a>
<a name="ln5128">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln5129">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].c)) ||</a>
<a name="ln5130">          ((a == parameter[idx].c) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].a)))</a>
<a name="ln5131">        {</a>
<a name="ln5132">          par = &amp;parameter[idx];</a>
<a name="ln5133">          return par;</a>
<a name="ln5134">        }</a>
<a name="ln5135"> </a>
<a name="ln5136">    return nullptr;</a>
<a name="ln5137">  }</a>
<a name="ln5138"> </a>
<a name="ln5139">  OBFFParameter* OBForceFieldMMFF94::GetTypedParameter2Atom(int ffclass, int a, int b, std::vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln5140">  {</a>
<a name="ln5141">    OBFFParameter *par;</a>
<a name="ln5142"> </a>
<a name="ln5143">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln5144">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (ffclass == parameter[idx]._ipar[0])) ||</a>
<a name="ln5145">          ((a == parameter[idx].b) &amp;&amp; (b == parameter[idx].a) &amp;&amp; (ffclass == parameter[idx]._ipar[0])))</a>
<a name="ln5146">        {</a>
<a name="ln5147">          par = &amp;parameter[idx];</a>
<a name="ln5148">          return par;</a>
<a name="ln5149">        }</a>
<a name="ln5150"> </a>
<a name="ln5151">    return nullptr;</a>
<a name="ln5152">  }</a>
<a name="ln5153"> </a>
<a name="ln5154">  OBFFParameter* OBForceFieldMMFF94::GetTypedParameter3Atom(int ffclass, int a, int b, int c, std::vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln5155">  {</a>
<a name="ln5156">    OBFFParameter *par;</a>
<a name="ln5157"> </a>
<a name="ln5158">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln5159">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].c) &amp;&amp; (ffclass == parameter[idx]._ipar[0])) ||</a>
<a name="ln5160">          ((a == parameter[idx].c) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].a) &amp;&amp; (ffclass == parameter[idx]._ipar[0])) )</a>
<a name="ln5161">        {</a>
<a name="ln5162">          par = &amp;parameter[idx];</a>
<a name="ln5163">          return par;</a>
<a name="ln5164">        }</a>
<a name="ln5165"> </a>
<a name="ln5166">    return nullptr;</a>
<a name="ln5167">  }</a>
<a name="ln5168"> </a>
<a name="ln5169">  OBFFParameter* OBForceFieldMMFF94::GetTypedParameter4Atom(int ffclass, int a, int b, int c, int d, std::vector&lt;OBFFParameter&gt; &amp;parameter)</a>
<a name="ln5170">  {</a>
<a name="ln5171">    OBFFParameter *par;</a>
<a name="ln5172"> </a>
<a name="ln5173">    for (unsigned int idx=0; idx &lt; parameter.size(); idx++)</a>
<a name="ln5174">      if (((a == parameter[idx].a) &amp;&amp; (b == parameter[idx].b) &amp;&amp; (c == parameter[idx].c) &amp;&amp;</a>
<a name="ln5175">           (d == parameter[idx].d) &amp;&amp; (ffclass == parameter[idx]._ipar[0]))</a>
<a name="ln5176">          /* || ((a == parameter[idx].d) &amp;&amp; (b == parameter[idx].c) &amp;&amp; (c == parameter[idx].b) &amp;&amp;</a>
<a name="ln5177">             (d == parameter[idx].a) &amp;&amp; (ffclass == parameter[idx]._ipar[0])) */ )</a>
<a name="ln5178">        {</a>
<a name="ln5179">          par = &amp;parameter[idx];</a>
<a name="ln5180">          return par;</a>
<a name="ln5181">        }</a>
<a name="ln5182"> </a>
<a name="ln5183">    return nullptr;</a>
<a name="ln5184">  }</a>
<a name="ln5185"> </a>
<a name="ln5186">} // end namespace OpenBabel</a>
<a name="ln5187"> </a>
<a name="ln5188">//! \file forcefieldmmff94.cpp</a>
<a name="ln5189">//! \brief MMFF94 force field</a>

</code></pre>
<div class="balloon" rel="3144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'GetTypedParameter4Atom' function: 'type_c' and 'type_b'.</p></div>
<div class="balloon" rel="3210"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!found_rule' is always false.</p></div>
<div class="balloon" rel="3223"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!found_rule' is always false.</p></div>
<div class="balloon" rel="3237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!found_rule' is always false.</p></div>
<div class="balloon" rel="3251"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!found_rule' is always false.</p></div>
<div class="balloon" rel="3302"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!found_rule' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>strutil.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44">#include &lt;math.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#include &quot;inpdef.h&quot;</a>
<a name="ln49">#include &quot;util.h&quot;</a>
<a name="ln50">#include &quot;ichi.h&quot;</a>
<a name="ln51">#include &quot;strutil.h&quot;</a>
<a name="ln52">#include &quot;ichierr.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;ichicomp.h&quot;</a>
<a name="ln55">#include &quot;extr_ct.h&quot;</a>
<a name="ln56">#include &quot;ichister.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ichi_io.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">#define FIX_P_IV_Plus_O_Minus    /* added fix to remove_ion_pairs() -- 2010-03-17 DT */</a>
<a name="ln62"> </a>
<a name="ln63">/* local prototypes */</a>
<a name="ln64">int cmp_components( const void *a1, const void *a2 );</a>
<a name="ln65">/*int mark_one_struct_component( inp_ATOM* at, int j, AT_NUMB *mark, AT_NUMB num_disconnected_components );*/</a>
<a name="ln66">INChI_Stereo *Alloc_INChI_Stereo(int num_at, int num_bonds);</a>
<a name="ln67">int RemoveInpAtBond( inp_ATOM *at, int iat, int k );</a>
<a name="ln68">int DisconnectInpAtBond( inp_ATOM *at, AT_NUMB *nOldCompNumber, int iat, int neigh_ord );</a>
<a name="ln69">int move_explicit_Hcation(inp_ATOM *at, int num_at, int iat, int iat_H, int bInAllComponents);</a>
<a name="ln70">int DisconnectOneLigand( inp_ATOM *at, AT_NUMB *nOldCompNumber, S_CHAR *bMetal, char *elnumber_Heteroat,</a>
<a name="ln71">                         int num_halogens, int num_atoms, int iMetal, int jLigand, INCHI_MODE *bTautFlagsDone );</a>
<a name="ln72">int bIsAmmoniumSalt( inp_ATOM *at, int i, int *piO, int *pk, S_CHAR *num_explicit_H );</a>
<a name="ln73">int DisconnectAmmoniumSalt ( inp_ATOM *at, int i, int iO, int k, S_CHAR *num_explicit_H );</a>
<a name="ln74">/*int bIsMetalSalt( inp_ATOM *at, int i ); - moved to strutil,h */</a>
<a name="ln75">int DisconnectMetalSalt( inp_ATOM *at, int i );</a>
<a name="ln76">int bIsMetalToDisconnect(inp_ATOM *at, int i, int bCheckMetalValence);</a>
<a name="ln77"> </a>
<a name="ln78">int get_iat_number( int el_number, const int el_num[], int el_num_len );</a>
<a name="ln79">int tot_unsat( int unsat[] );</a>
<a name="ln80">int max_unsat( int unsat[] );</a>
<a name="ln81"> </a>
<a name="ln82">double dist3D( inp_ATOM *at1, inp_ATOM *at2 );</a>
<a name="ln83">double dist2D( inp_ATOM *at1, inp_ATOM *at2 );</a>
<a name="ln84">double dist_from_segm( double x, double y, double x1, double y1, double x2, double y2);</a>
<a name="ln85">int segments_intersect( double x11, double y11, double x12, double y12, /* segment #1 */</a>
<a name="ln86">                        double x21, double y21, double x22, double y22 );</a>
<a name="ln87">double GetMinDistDistribution( inp_ATOM *at, int num_at, int iat, int iat_H,</a>
<a name="ln88">                                int bInAllComponents, double min_dist[], int num_segm );</a>
<a name="ln89"> </a>
<a name="ln90">int nFindOneOM(inp_ATOM *at, int at_no, int ord_OM[], int num_OM);</a>
<a name="ln91">int the_only_doublet_neigh(inp_ATOM *at, int i1, int *ineigh1, int *ineigh2);</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">#ifndef NUMH</a>
<a name="ln95">#define NUM_ISO_H(AT,N) (AT[N].num_iso_H[0]+AT[N].num_iso_H[1]+AT[N].num_iso_H[2])</a>
<a name="ln96">#define NUMH(AT,N)     (AT[N].num_H+NUM_ISO_H(AT,N))</a>
<a name="ln97">#endif</a>
<a name="ln98"> </a>
<a name="ln99">/************************************************************************/</a>
<a name="ln100">int the_only_doublet_neigh(inp_ATOM *at, int i1, int *ineigh1, int *ineigh2)</a>
<a name="ln101">{</a>
<a name="ln102">    int i, neigh1, num_rad1=0, num_rad2=0;</a>
<a name="ln103">    inp_ATOM *a = at+i1, *b;</a>
<a name="ln104">    if ( RADICAL_DOUBLET != a-&gt;radical )</a>
<a name="ln105">        return -1;</a>
<a name="ln106">    for ( i = 0; i &lt; a-&gt;valence; i ++ ) {</a>
<a name="ln107">        b = at + (neigh1 = (int)a-&gt;neighbor[i]);</a>
<a name="ln108">        if ( RADICAL_DOUBLET == b-&gt;radical ) {</a>
<a name="ln109">            num_rad1 ++;</a>
<a name="ln110">            *ineigh1 = i;</a>
<a name="ln111">        }</a>
<a name="ln112">    }</a>
<a name="ln113">    if ( 1 == num_rad1 ) {</a>
<a name="ln114">        a = at + (neigh1 = (int)a-&gt;neighbor[*ineigh1]);</a>
<a name="ln115">        for ( i = 0; i &lt; a-&gt;valence; i ++ ) {</a>
<a name="ln116">            b = at +(int)a-&gt;neighbor[i];</a>
<a name="ln117">            if ( RADICAL_DOUBLET == b-&gt;radical ) {</a>
<a name="ln118">                num_rad2 ++;</a>
<a name="ln119">                *ineigh2 = i;</a>
<a name="ln120">            }</a>
<a name="ln121">        }</a>
<a name="ln122">        if ( 1 == num_rad2 ) {</a>
<a name="ln123">            return neigh1;</a>
<a name="ln124">        }</a>
<a name="ln125">    }</a>
<a name="ln126">    return -1;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/************************************************************************/</a>
<a name="ln130">int fix_odd_things( int num_atoms, inp_ATOM *at, int bFixBug, int bFixNonUniformDraw )</a>
<a name="ln131">{   /*                           0 1 2  3  4 5 6  7                       8  9  */</a>
<a name="ln132">    static const char    el[] = &quot;N;P;As;Sb;O;S;Se;Te;&quot;;   /* 8 elements + C, Si */</a>
<a name="ln133">    static U_CHAR  en[10];              /* same number: 8 elements */</a>
<a name="ln134">    static int     ne=0, ne2;           /* will be 8 and 10 */</a>
<a name="ln135">    static int     el_number_P;</a>
<a name="ln136">    static int     el_number_H;</a>
<a name="ln137">    static int     el_number_C;</a>
<a name="ln138">    static int     el_number_O;</a>
<a name="ln139">    static int     el_number_Si;</a>
<a name="ln140"> </a>
<a name="ln141">#define FIRST_NEIGHB2  4</a>
<a name="ln142">#define FIRST_CENTER2  5</a>
<a name="ln143">#define NUM_CENTERS_N  4</a>
<a name="ln144"> </a>
<a name="ln145">    int i1, i2, k1, k2, c, num_changes = 0;</a>
<a name="ln146">    char elname[ATOM_EL_LEN];</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">    /* constants for element numbers */</a>
<a name="ln150">    enum elems { dNone, dCl=17,dBr=35,dI=53,dAt=85,dO=8,dS=16,dSe=34,dTe=52, dP=15, dC=6, dN=7 } ; </a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">    if (bFixNonUniformDraw)</a>
<a name="ln156">    {</a>
<a name="ln157">    </a>
<a name="ln158"> </a>
<a name="ln159">        /* Correct non-uniformly drawn oxoanions and amidinium cations. */                </a>
<a name="ln160">        {</a>
<a name="ln161"> </a>
<a name="ln162">            /* For central halogen, apply the following correftion rules:</a>
<a name="ln163">    </a>
<a name="ln164">                O                             O(-)</a>
<a name="ln165">                ||                            |</a>
<a name="ln166">              O=Hal(-)=O         ===&gt;        O=Hal=O</a>
<a name="ln167">                ||                            ||</a>
<a name="ln168">                O                             O</a>
<a name="ln169">        </a>
<a name="ln170">            (perchlorate, etc.)</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">                O                             O(-)</a>
<a name="ln174">                ||                            |</a>
<a name="ln175">                Hal(-)=O         ===&gt;         Hal=O</a>
<a name="ln176">                ||                            ||</a>
<a name="ln177">                O                             O</a>
<a name="ln178"> </a>
<a name="ln179">            (chlorate, etc.)</a>
<a name="ln180"> </a>
<a name="ln181">                O                             O(-)</a>
<a name="ln182">                ||                            |</a>
<a name="ln183">                Hal(-)=O         ===&gt;         Hal=O</a>
<a name="ln184">            </a>
<a name="ln185"> </a>
<a name="ln186">            (chlorite, etc.)</a>
<a name="ln187"> </a>
<a name="ln188">                Hal(-)=O         ===&gt;         Hal-O(-)</a>
<a name="ln189">    </a>
<a name="ln190"> </a>
<a name="ln191">            (hypochlorite, etc.)</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194"> </a>
<a name="ln195">            For halcogenes (S, Se, Te)</a>
<a name="ln196">                Y                               Y(-)</a>
<a name="ln197">                ||                              |</a>
<a name="ln198">              RnX(-)            ===&gt;          RnX</a>
<a name="ln199"> </a>
<a name="ln200">           if:</a>
<a name="ln201">           1) (X = S, Y = O) || (X = Se, Y = S, O) || (X = Te, Y = O, S, Se)</a>
<a name="ln202">           2) valence of X exceeds 6, in initially drawn form </a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">            So the following is corrected:  </a>
<a name="ln206"> </a>
<a name="ln207">                O                               O(-)</a>
<a name="ln208">                ||                              |</a>
<a name="ln209">              O=S(-)-R            ===&gt;        O=S-R</a>
<a name="ln210">                ||                              ||</a>
<a name="ln211">                O                               O</a>
<a name="ln212"> </a>
<a name="ln213">            or</a>
<a name="ln214"> </a>
<a name="ln215">                  O                              O-</a>
<a name="ln216">                  ||                             |</a>
<a name="ln217">                F5Te(-)            ===&gt;        F5Te</a>
<a name="ln218"> </a>
<a name="ln219">            but the following remains unchanged:</a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222">                O                </a>
<a name="ln223">                ||               </a>
<a name="ln224">              O=S(-)-R           </a>
<a name="ln225"> </a>
<a name="ln226"> </a>
<a name="ln227">            The central atom (of IUPAC Group 16-17) is shown as negative but it contains double bond(s) </a>
<a name="ln228">            to terminal atom of greater electronegativity (of Group 16).</a>
<a name="ln229">            The central atom is halcogen (S,Se,Te) in highest oxidation state or halogen.</a>
<a name="ln230"> </a>
<a name="ln231">            Fix:</a>
<a name="ln232">            move negative charge to terminal atom and change double bond to a single one.</a>
<a name="ln233"> </a>
<a name="ln234">            Eligible central atom    Eligible terminal atom at double bond's end</a>
<a name="ln235">                        Cl              O</a>
<a name="ln236">                        Br              O</a>
<a name="ln237">                        I               O</a>
<a name="ln238">                       [At              S,Se,Te]</a>
<a name="ln239">                        S               O</a>
<a name="ln240">                        Se              O,S</a>
<a name="ln241">                        Te              O, S, Se</a>
<a name="ln242">          </a>
<a name="ln243">            Comments: </a>
<a name="ln244">            1. Central atoms of Groups 13-15 are not considered.</a>
<a name="ln245">            2. Pauling electronegativities are: </a>
<a name="ln246">            F(3.98) &gt; O(3.44) &gt; Cl (3.16) &gt; N (3.04) &gt; Br(2.96) &gt; I(2.66) &gt; S(2.58) &gt; Se(2.55) &gt; At (2.2) &gt; Te(2.1)</a>
<a name="ln247"> </a>
<a name="ln248"> </a>
<a name="ln249">            */</a>
<a name="ln250">    </a>
<a name="ln251"> </a>
<a name="ln252">            static U_CHAR  allowed_elnums_center_halogen[] = {dCl, dBr, dI, dAt} ; </a>
<a name="ln253">            static U_CHAR  allowed_elnums_center_halcogen[] = {dS, dSe, dTe} ; </a>
<a name="ln254">   </a>
<a name="ln255">            int en_center;</a>
<a name="ln256">            int i, j, k; </a>
<a name="ln257"> </a>
<a name="ln258">            for (i=0; i&lt;num_atoms; i++)</a>
<a name="ln259">            {</a>
<a name="ln260">                /* Find appropriate central atom. This center should be: ...*/ </a>
<a name="ln261">        </a>
<a name="ln262">                /* charged exactly (-1) ... */</a>
<a name="ln263">                if ( at[i].charge != -1 ) </a>
<a name="ln264">                    continue;</a>
<a name="ln265">                en_center = at[i].el_number;</a>
<a name="ln266">                /*  from eligible element list ... */</a>
<a name="ln267">                if (!memchr(allowed_elnums_center_halogen, en_center , sizeof(allowed_elnums_center_halogen)) ) </a>
<a name="ln268">                {</a>
<a name="ln269">                    /* central atom is not not halogen; check if it is halcogen */</a>
<a name="ln270">                    if ( memchr(allowed_elnums_center_halcogen, en_center , sizeof(allowed_elnums_center_halcogen)) ) </a>
<a name="ln271">                    {</a>
<a name="ln272">    </a>
<a name="ln273">                        if (at[i].chem_bonds_valence&lt;7)</a>
<a name="ln274">                        /* central atom is anionic halcogen, but not in the highest oxidation state */</a>
<a name="ln275">                            continue;</a>
<a name="ln276">                    }</a>
<a name="ln277">                    else</a>
<a name="ln278">                        continue;</a>
<a name="ln279">                } </a>
<a name="ln280">        </a>
<a name="ln281">                /* OK, found central halogen or eligible central halcogen. */            </a>
<a name="ln282">            </a>
<a name="ln283">                /* non-radical... */</a>
<a name="ln284">                if ( at[i].radical &amp;&amp; (at[i].radical!=RADICAL_SINGLET) ) </a>
<a name="ln285">                    continue;        </a>
<a name="ln286"> </a>
<a name="ln287">                /* Center found, now examine the adjacent terminals... */    </a>
<a name="ln288">                {            </a>
<a name="ln289">                    int en_term, kk=0, jj=0, min_en=999, iso=0, min_iso=999;</a>
<a name="ln290">                    jj = -1;</a>
<a name="ln291">                    for (k=0; k&lt;at[i].valence; k++)</a>
<a name="ln292">                    {</a>
<a name="ln293">                        j = at[i].neighbor[k];</a>
<a name="ln294">                </a>
<a name="ln295">                        /* Terminal should be: ... */ </a>
<a name="ln296"> </a>
<a name="ln297">                        /* terminal... */</a>
<a name="ln298">                        if ( at[j].valence!=1 ) </a>
<a name="ln299">                            continue;</a>
<a name="ln300">                        /* double-bonded ... */</a>
<a name="ln301">                        if ( at[i].bond_type[k] != BOND_TYPE_DOUBLE ) </a>
<a name="ln302">                            continue;</a>
<a name="ln303">                        /* zero-charged ... */</a>
<a name="ln304">                        if ( at[j].charge != 0 ) </a>
<a name="ln305">                            continue;</a>
<a name="ln306">                        /* non-radical */</a>
<a name="ln307">                        if ( at[j].radical &amp;&amp; (at[j].radical!=RADICAL_SINGLET) ) </a>
<a name="ln308">                            continue;</a>
<a name="ln309">                        /*  of eligible elements list ... */</a>
<a name="ln310">                        en_term = at[j].el_number;</a>
<a name="ln311">                        switch (en_term)</a>
<a name="ln312">                        {</a>
<a name="ln313">                        case dO:    break;</a>
<a name="ln314">                        case dS:    if ( (en_center==dSe)||(en_center==dAt)||(en_center==dTe) ) break;  continue;</a>
<a name="ln315">                        case dSe:   if ( (en_center==dAt)||(en_center==dTe) ) break;  continue;</a>
<a name="ln316">                        case dTe:   if ( en_center==dAt ) break; continue;</a>
<a name="ln317">                        default:    continue;</a>
<a name="ln318">                        }</a>
<a name="ln319">                </a>
<a name="ln320">                        /* From several candidates, select one with less el. number (==more electronegative). */</a>
<a name="ln321">                        if ( en_term &lt; min_en)  </a>
<a name="ln322">                        { </a>
<a name="ln323">                            min_en = en_term; kk = k; jj = j; </a>
<a name="ln324">                            min_iso = at[j].iso_atw_diff &gt; 0? at[i].iso_atw_diff-1 : at[i].iso_atw_diff;</a>
<a name="ln325">                            continue; </a>
<a name="ln326">                        }   </a>
<a name="ln327">                        /* From same-element candidates, select one with less isotopic mass (arbitrary choice). */</a>
<a name="ln328">                        else if (en_term==min_en)</a>
<a name="ln329">                        {</a>
<a name="ln330">                            iso = at[j].iso_atw_diff &gt; 0? at[i].iso_atw_diff-1 : at[i].iso_atw_diff;</a>
<a name="ln331">                            if ( iso &lt;min_iso )</a>
<a name="ln332">                            { </a>
<a name="ln333">                                min_iso = iso; kk = k; jj = j; continue; </a>
<a name="ln334">                            }</a>
<a name="ln335">                        }</a>
<a name="ln336">                    } /* end of checking nbrs. */</a>
<a name="ln337">            </a>
<a name="ln338">                    /* If OK, apply changes. */</a>
<a name="ln339">                    if (jj&gt;=0)</a>
<a name="ln340">                    {</a>
<a name="ln341">                        at[i].charge = 0; </a>
<a name="ln342">                        at[jj].charge = -1;</a>
<a name="ln343">                        at[i].bond_type[kk] = BOND_TYPE_SINGLE; </a>
<a name="ln344">                        at[jj].bond_type[0] = BOND_TYPE_SINGLE;</a>
<a name="ln345">                        at[i].bond_stereo[kk] = at[jj].bond_stereo[0] = 0;</a>
<a name="ln346">                        at[i].chem_bonds_valence--; </a>
<a name="ln347">                        at[jj].chem_bonds_valence--;</a>
<a name="ln348">                        num_changes ++;</a>
<a name="ln349">                    }</a>
<a name="ln350">                }  </a>
<a name="ln351"> </a>
<a name="ln352">            }  /* end of search for candidate centers. */    </a>
<a name="ln353"> </a>
<a name="ln354">        } /* end of correcting oxoanions */</a>
<a name="ln355"> </a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">        /* Correct non-uniformly drawn amidinium cations. */</a>
<a name="ln360">        {   </a>
<a name="ln361"> </a>
<a name="ln362">            /* Amidines include carboxamidines RC(=NR)NR2, </a>
<a name="ln363">            sulfinamidines RS(=NR)NR2 and phosphinamidines, R2P(=NR)NR2.</a>
<a name="ln364">            </a>
<a name="ln365">            </a>
<a name="ln366">            NR                              NR</a>
<a name="ln367">            |                               |</a>
<a name="ln368">            R&quot;-Y-NHR'         ===&gt;          R&quot;-Y=N(+)HR'        </a>
<a name="ln369">            (+)                              </a>
<a name="ln370"> </a>
<a name="ln371">    </a>
<a name="ln372">            Y = C, S, P</a>
<a name="ln373">                                 </a>
<a name="ln374"> </a>
<a name="ln375">            Fix:            </a>
<a name="ln376">            move positive charge to nitrogen and change single bond to a double one.</a>
<a name="ln377"> </a>
<a name="ln378">          </a>
<a name="ln379">            Comment: </a>
<a name="ln380">            Fix is applied only if at least one of R's at N is hydrogen </a>
<a name="ln381">            (otherwise we have just a '+' delocalization which is already recognized).</a>
<a name="ln382"> </a>
<a name="ln383"> </a>
<a name="ln384">            */</a>
<a name="ln385"> </a>
<a name="ln386">            static U_CHAR  allowed_elnums_center[] = {dC, dS, dP} ; </a>
<a name="ln387">            int en_center;</a>
<a name="ln388">            int i, j, k, jj, kk; </a>
<a name="ln389">            int mismatch = 0, nuH=0, nuN = 0, nitrogens[MAXVAL];</a>
<a name="ln390"> </a>
<a name="ln391">            for (i=0; i&lt;num_atoms; i++)</a>
<a name="ln392">            {</a>
<a name="ln393">                /* Find appropriate central atom. This center should be: ...*/ </a>
<a name="ln394">        </a>
<a name="ln395">                /* charged exactly (+1) ... */</a>
<a name="ln396">                if ( at[i].charge != 1 ) </a>
<a name="ln397">                    continue;</a>
<a name="ln398">                en_center = at[i].el_number;</a>
<a name="ln399">                /*  from eligible element list ... */</a>
<a name="ln400">                if ( !memchr(allowed_elnums_center, en_center , sizeof(allowed_elnums_center)) ) </a>
<a name="ln401">                    continue;</a>
<a name="ln402">                /* has exactly 3 neighbours connected by single bonds*/</a>
<a name="ln403">                if ( at[i].valence != 3 ) </a>
<a name="ln404">                    continue;</a>
<a name="ln405">                if ( at[i].chem_bonds_valence != 3 ) </a>
<a name="ln406">                    continue;</a>
<a name="ln407"> </a>
<a name="ln408">                /* non-radical. */</a>
<a name="ln409">                if ( at[i].radical &amp;&amp; (at[i].radical!=RADICAL_SINGLET) ) </a>
<a name="ln410">                    continue;        </a>
<a name="ln411">        </a>
<a name="ln412">                /* NB: center must have neutral neighbours, two of them are aliphatic N's of which at least one bears H. */</a>
<a name="ln413">                mismatch = nuH = nuN = jj = kk = 0;</a>
<a name="ln414">                memset(nitrogens, 0, sizeof(nitrogens));           </a>
<a name="ln415">                jj = -1;</a>
<a name="ln416">                for (k=0; k&lt;at[i].valence; k++)</a>
<a name="ln417">                {            </a>
<a name="ln418">                    j = at[i].neighbor[k];</a>
<a name="ln419">                </a>
<a name="ln420">                    if ( at[j].charge != 0 ) </a>
<a name="ln421">                    { </a>
<a name="ln422">                        mismatch = 1; </a>
<a name="ln423">                        break; </a>
<a name="ln424">                    }</a>
<a name="ln425">                    if ( at[j].el_number == dN) </a>
<a name="ln426">                    {</a>
<a name="ln427">                        if ( ( at[j].valence &gt; 3 ) || ( at[j].chem_bonds_valence &gt; 3 ) )</a>
<a name="ln428">                        { </a>
<a name="ln429">                            mismatch = 1; </a>
<a name="ln430">                            break; </a>
<a name="ln431">                        }</a>
<a name="ln432">                        nuH+= NUMH(at,j);</a>
<a name="ln433">                        nuN++;</a>
<a name="ln434">                        if (jj&lt;0) </a>
<a name="ln435">                        {</a>
<a name="ln436">                            jj = j;               </a>
<a name="ln437">                            kk = k;</a>
<a name="ln438">                        }</a>
<a name="ln439">                    }</a>
<a name="ln440">                }</a>
<a name="ln441"> </a>
<a name="ln442">                /* If OK, apply changes. */</a>
<a name="ln443">                if (mismatch)   continue;</a>
<a name="ln444">                if (nuN!=2)     continue;</a>
<a name="ln445">                if (nuH&lt;1)      continue;</a>
<a name="ln446">                if (jj&gt;=0)</a>
<a name="ln447">                {</a>
<a name="ln448">                    at[i].charge = 0; </a>
<a name="ln449">                    at[jj].charge = 1;</a>
<a name="ln450">                    at[i].bond_type[kk] = BOND_TYPE_DOUBLE; </a>
<a name="ln451">                    for ( k1 = 0; k1 &lt; at[jj].valence &amp;&amp; i != at[jj].neighbor[k1]; k1 ++ ) </a>
<a name="ln452">                        ;</a>
<a name="ln453">                    at[jj].bond_type[k1] = BOND_TYPE_DOUBLE; </a>
<a name="ln454">                    at[i].chem_bonds_valence++; </a>
<a name="ln455">                    at[jj].chem_bonds_valence++;</a>
<a name="ln456">                    /* NB: do nothing with wedge stereo bonds (retain wedge) */</a>
<a name="ln457">                    num_changes ++;</a>
<a name="ln458">                }</a>
<a name="ln459"> </a>
<a name="ln460">            }  /* end of search for candidate centers. */    </a>
<a name="ln461">    </a>
<a name="ln462">        } /* end of correcting amidiniums */</a>
<a name="ln463"> </a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">    } /*( if (bFixNonUniformDraw) */</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">    if ( !ne ) </a>
<a name="ln472">    { </a>
<a name="ln473">        /* one time initialization */</a>
<a name="ln474">        const char *b, *e;</a>
<a name="ln475">        int  len;</a>
<a name="ln476">        for ( b = el; (e = strchr( b, ';')); b = e+1 )</a>
<a name="ln477">        {</a>
<a name="ln478">            len = e-b;</a>
<a name="ln479">            memcpy( elname, b, len );</a>
<a name="ln480">            elname[len] = '\0';</a>
<a name="ln481">            en[ne++] = get_periodic_table_number( elname );</a>
<a name="ln482">        }</a>
<a name="ln483">        ne2 = ne;</a>
<a name="ln484">        el_number_P  = get_periodic_table_number( &quot;P&quot; );</a>
<a name="ln485">        el_number_H  = get_periodic_table_number( &quot;H&quot; );</a>
<a name="ln486">        el_number_O  = get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln487">        en[ne2++] = el_number_C  = get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln488">        en[ne2++] = el_number_Si = get_periodic_table_number( &quot;Si&quot; );</a>
<a name="ln489">    }</a>
<a name="ln490">    </a>
<a name="ln491">    /* H(-)-X  -&gt; H-X(-);  H(+)-X  -&gt; H-X(+) */</a>
<a name="ln492">    for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) </a>
<a name="ln493">    {</a>
<a name="ln494">        if ( 1 == at[i1].valence &amp;&amp;</a>
<a name="ln495">             1 == abs(at[i1].charge)  &amp;&amp;</a>
<a name="ln496">             (0 == at[i1].radical || RADICAL_SINGLET == at[i1].radical) &amp;&amp;</a>
<a name="ln497">             BOND_TYPE_SINGLE == at[i1].bond_type[0] &amp;&amp;</a>
<a name="ln498">             el_number_H == at[i1].el_number &amp;&amp;</a>
<a name="ln499">             el_number_H != at[i2=(int)at[i1].neighbor[0]].el_number &amp;&amp;</a>
<a name="ln500">             !NUMH(at,i1) &amp;&amp;</a>
<a name="ln501">             !NUMH(at,i2)</a>
<a name="ln502">             ) </a>
<a name="ln503">        {</a>
<a name="ln504">            at[i2].charge += at[i1].charge;</a>
<a name="ln505">            at[i1].charge  = 0;</a>
<a name="ln506">        }</a>
<a name="ln507">    }</a>
<a name="ln508"> </a>
<a name="ln509">    /* replace XHm(-)--Y==XHn(+) with XHm==Y--XHn, (n&gt;=0 ,m&gt;=0, X=N,P,As,Sb,O,S,Se,Te) */</a>
<a name="ln510">    for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) </a>
<a name="ln511">    {</a>
<a name="ln512">        if ( 1 != at[i1].charge ||</a>
<a name="ln513">             (at[i1].radical &amp;&amp; RADICAL_SINGLET != at[i1].radical) ||</a>
<a name="ln514">             at[i1].chem_bonds_valence == at[i1].valence ||</a>
<a name="ln515">             !memchr(en, at[i1].el_number, ne) ||</a>
<a name="ln516">             get_el_valence( at[i1].el_number, at[i1].charge, 0 ) != at[i1].chem_bonds_valence+NUMH(at,i1) ) </a>
<a name="ln517">        {</a>
<a name="ln518">            continue;</a>
<a name="ln519">        }</a>
<a name="ln520">        </a>
<a name="ln521">        /* found a candidate at[i1] for X in XHn(+) */</a>
<a name="ln522">        if ( 1 == at[i1].valence &amp;&amp;</a>
<a name="ln523">             BOND_TYPE_DOUBLE == at[i1].bond_type[0] ) </a>
<a name="ln524">        {</a>
<a name="ln525">            c = (int)at[i1].neighbor[0];</a>
<a name="ln526">            for ( k2 = 0; k2 &lt; at[c].valence; k2 ++ ) </a>
<a name="ln527">            {</a>
<a name="ln528">                i2 = at[c].neighbor[k2];</a>
<a name="ln529">                if ( 1 == at[i2].valence &amp;&amp;</a>
<a name="ln530">                    -1 == at[i2].charge  &amp;&amp;</a>
<a name="ln531">                     at[i2].el_number == at[i1].el_number &amp;&amp; /* exact match */</a>
<a name="ln532">                     (0 == at[i2].radical || RADICAL_SINGLET == at[i2].radical) &amp;&amp;</a>
<a name="ln533">                     BOND_TYPE_SINGLE == at[i2].bond_type[0] &amp;&amp;</a>
<a name="ln534">                     /*memchr(en, at[i2].el_number, ne) &amp;&amp;*/</a>
<a name="ln535">                     get_el_valence( at[i2].el_number, at[i2].charge, 0 ) == at[i2].chem_bonds_valence+NUMH(at,i2) ) {</a>
<a name="ln536">                    /* found both X(-) and X(+); change bonds and remove charges */</a>
<a name="ln537">                    for ( k1 = 0; k1 &lt; at[c].valence &amp;&amp; i1 != at[c].neighbor[k1]; k1 ++ )</a>
<a name="ln538">                        ;</a>
<a name="ln539">                    at[i1].charge = at[i2].charge = 0;</a>
<a name="ln540">                    at[i1].bond_type[0] = at[c].bond_type[k1] = BOND_TYPE_SINGLE;</a>
<a name="ln541">                    at[i1].chem_bonds_valence --;</a>
<a name="ln542">                    at[i2].bond_type[0] = at[c].bond_type[k2] = BOND_TYPE_DOUBLE;</a>
<a name="ln543">                    at[i2].chem_bonds_valence ++;</a>
<a name="ln544">                    num_changes ++;</a>
<a name="ln545">                    break;</a>
<a name="ln546">                }</a>
<a name="ln547">            }</a>
<a name="ln548">        }</a>
<a name="ln549">        else </a>
<a name="ln550">        {</a>
<a name="ln551">            /* explicit H case: detect H-neighbors and Y */</a>
<a name="ln552">            int ineigh, neigh, i1_c, i2_c, num_H_i1, num_H_i2;</a>
<a name="ln553">            for ( ineigh = 0, num_H_i1 = 0, i1_c = -1; ineigh &lt; at[i1].valence; ineigh ++ ) </a>
<a name="ln554">            {</a>
<a name="ln555">                neigh = at[i1].neighbor[ineigh];</a>
<a name="ln556">                if ( at[neigh].el_number == el_number_H ) </a>
<a name="ln557">                {</a>
<a name="ln558">                    if ( at[neigh].chem_bonds_valence == 1  &amp;&amp;</a>
<a name="ln559">                         (0 == at[neigh].radical || RADICAL_SINGLET == at[neigh].radical) ) </a>
<a name="ln560">                    {</a>
<a name="ln561">                        num_H_i1 ++; /* found H-neighbor */</a>
<a name="ln562">                    } </a>
<a name="ln563">                    else </a>
<a name="ln564">                    {</a>
<a name="ln565">                        break;  /* wrong neighbor */</a>
<a name="ln566">                    }</a>
<a name="ln567">                } </a>
<a name="ln568">                else if ( at[i1].bond_type[ineigh] == BOND_TYPE_DOUBLE ) </a>
<a name="ln569">                {</a>
<a name="ln570">                    /* found a candidate for Y; bond must be double */</a>
<a name="ln571">                    i1_c = ineigh;</a>
<a name="ln572">                    c    = neigh;</a>
<a name="ln573">                }</a>
<a name="ln574">            }</a>
<a name="ln575">            if ( i1_c &lt; 0 || num_H_i1 + 1 != at[i1].valence ) </a>
<a name="ln576">            {</a>
<a name="ln577">                continue;</a>
<a name="ln578">            }</a>
<a name="ln579">            for ( k2 = 0; k2 &lt; at[c].valence; k2 ++ ) </a>
<a name="ln580">            {</a>
<a name="ln581">                i2 = at[c].neighbor[k2];</a>
<a name="ln582">                if (-1 == at[i2].charge  &amp;&amp;</a>
<a name="ln583">                     at[i2].el_number == at[i1].el_number &amp;&amp; /* exact match */</a>
<a name="ln584">                     (0 == at[i2].radical || RADICAL_SINGLET == at[i2].radical) &amp;&amp;</a>
<a name="ln585">                     get_el_valence( at[i2].el_number, at[i2].charge, 0 ) == at[i2].chem_bonds_valence+NUMH(at,i2) ) </a>
<a name="ln586">                {</a>
<a name="ln587">                    for ( ineigh = 0, num_H_i2 = 0, i2_c = -1; ineigh &lt; at[i2].valence; ineigh ++ ) </a>
<a name="ln588">                    {</a>
<a name="ln589">                        neigh = at[i2].neighbor[ineigh];</a>
<a name="ln590">                        if ( at[neigh].el_number == el_number_H ) </a>
<a name="ln591">                        {</a>
<a name="ln592">                            if ( at[neigh].chem_bonds_valence == 1  &amp;&amp;</a>
<a name="ln593">                                 (0 == at[neigh].radical || RADICAL_SINGLET == at[neigh].radical) ) </a>
<a name="ln594">                            {</a>
<a name="ln595">                                num_H_i2 ++;  /* found H-neighbor */</a>
<a name="ln596">                            } </a>
<a name="ln597">                            else </a>
<a name="ln598">                            {</a>
<a name="ln599">                                break; /* wrong neighbor */</a>
<a name="ln600">                            }</a>
<a name="ln601">                        } </a>
<a name="ln602">                        else</a>
<a name="ln603">                        if ( c == neigh &amp;&amp; at[i2].bond_type[ineigh] == BOND_TYPE_SINGLE ) </a>
<a name="ln604">                        { </a>
<a name="ln605">                            i2_c = ineigh; /* position of Y neighbor; bond must be single */</a>
<a name="ln606">                        } </a>
<a name="ln607">                        else </a>
<a name="ln608">                        {</a>
<a name="ln609">                            break;</a>
<a name="ln610">                        }</a>
<a name="ln611">                    }</a>
<a name="ln612">                    if ( num_H_i2 + (i2_c &gt;= 0) != at[i2].valence ) </a>
<a name="ln613">                    {</a>
<a name="ln614">                        continue;</a>
<a name="ln615">                    }</a>
<a name="ln616">                    /* found both X(-) and X(+); change bonds and remove charges */</a>
<a name="ln617">                    for ( k1 = 0; k1 &lt; at[c].valence &amp;&amp; i1 != at[c].neighbor[k1]; k1 ++ )</a>
<a name="ln618">                        ;</a>
<a name="ln619">                    at[i1].charge = at[i2].charge = 0;</a>
<a name="ln620">                    at[i1].bond_type[i1_c] = at[c].bond_type[k1] = BOND_TYPE_SINGLE;</a>
<a name="ln621">                    at[i1].chem_bonds_valence --;</a>
<a name="ln622">                    at[i2].bond_type[i2_c] = at[c].bond_type[k2] = BOND_TYPE_DOUBLE;</a>
<a name="ln623">                    at[i2].chem_bonds_valence ++;</a>
<a name="ln624">                    num_changes ++;</a>
<a name="ln625">                    break;</a>
<a name="ln626">                }</a>
<a name="ln627">            }</a>
<a name="ln628">        }</a>
<a name="ln629">    }</a>
<a name="ln630"> </a>
<a name="ln631">    /* Replace</a>
<a name="ln632">                                                                             </a>
<a name="ln633">          X-                X        X=O,S,Se,Te -- terminal atoms  (NEIGHB2)         </a>
<a name="ln634">        \ |               \ ||                                               </a>
<a name="ln635">         &gt;Y++    with      &gt;Y        Y=S,Se,Te   -- central cation  (CENTER2)          </a>
<a name="ln636">        / |               / ||                                               </a>
<a name="ln637">          X-                X        Y valence=4, original Y bond valence = 4</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">       --- the following case of P is processed separately in remove_ion_pairs()</a>
<a name="ln641">       --- therefire, it has been disabled here, see #ifndef FIX_P_IV_Plus_O_Minus -- 2010-03-17 DT</a>
<a name="ln642"> </a>
<a name="ln643">          X-                X        X=O,S,Se,Te -- terminal atoms  (NEIGHB2)         </a>
<a name="ln644">        \ |               \ ||                                               </a>
<a name="ln645">         &gt;P+     with      &gt;P                 </a>
<a name="ln646">        / |               / |                                                </a>
<a name="ln647">          X-                X-       Y valence=4, original Y bond valence = 4</a>
<a name="ln648"> </a>
<a name="ln649">    */</a>
<a name="ln650"> </a>
<a name="ln651">    for ( i1 = 0; i1 &lt; num_atoms; i1 ++ ) </a>
<a name="ln652">    {</a>
<a name="ln653">        if ( 1 == at[i1].valence &amp;&amp;</a>
<a name="ln654">             -1 == at[i1].charge  &amp;&amp;</a>
<a name="ln655">             (0 == at[i1].radical || RADICAL_SINGLET == at[i1].radical) &amp;&amp;</a>
<a name="ln656">              !NUMH(at,i1) &amp;&amp;</a>
<a name="ln657">             BOND_TYPE_SINGLE == at[i1].bond_type[0] &amp;&amp;</a>
<a name="ln658">             memchr( en+FIRST_NEIGHB2, at[i1].el_number, ne-FIRST_NEIGHB2 ) ) </a>
<a name="ln659">        {</a>
<a name="ln660">            int charge, i;</a>
<a name="ln661">            /* found a candidate for X */</a>
<a name="ln662">            c = (int)at[i1].neighbor[0]; /* candidate for Y */</a>
<a name="ln663">            if ( ((charge=2) == at[c].charge &amp;&amp; memchr( en+FIRST_CENTER2, at[c].el_number, ne-FIRST_CENTER2) </a>
<a name="ln664">#ifndef FIX_P_IV_Plus_O_Minus                 </a>
<a name="ln665">                 || (charge=1) == at[c].charge &amp;&amp; el_number_P==at[c].el_number</a>
<a name="ln666">#endif</a>
<a name="ln667">                 ) &amp;&amp;</a>
<a name="ln668">                 4 == at[c].valence &amp;&amp;</a>
<a name="ln669">                 (0 == at[c].radical || RADICAL_SINGLET == at[c].radical ) &amp;&amp;</a>
<a name="ln670">                 at[c].valence == at[c].chem_bonds_valence &amp;&amp;</a>
<a name="ln671">                 !NUMH(at,c) ) </a>
<a name="ln672">            {</a>
<a name="ln673">                ;  /* accept */</a>
<a name="ln674">            } </a>
<a name="ln675">            else </a>
<a name="ln676">            {</a>
<a name="ln677">                continue; /* ignore at[i1] */</a>
<a name="ln678">            }</a>
<a name="ln679">            for ( k2 = 0; k2 &lt; at[c].valence; k2 ++ ) </a>
<a name="ln680">            {</a>
<a name="ln681">                i2 = at[c].neighbor[k2];</a>
<a name="ln682">                if ( i2 == i1 ) </a>
<a name="ln683">                {</a>
<a name="ln684">                    continue;</a>
<a name="ln685">                }</a>
<a name="ln686">                if ( 1 == at[i2].valence &amp;&amp;</a>
<a name="ln687">                    -1 == at[i2].charge  &amp;&amp;</a>
<a name="ln688">                     memchr( en+FIRST_NEIGHB2, at[i2].el_number, ne-FIRST_NEIGHB2 ) &amp;&amp;</a>
<a name="ln689">                     /*at[i2].el_number == at[i1].el_number &amp;&amp;*/ /* exact match */</a>
<a name="ln690">                     (0 == at[i2].radical || RADICAL_SINGLET == at[i2].radical) &amp;&amp;</a>
<a name="ln691">                     !NUMH(at,i2) &amp;&amp;</a>
<a name="ln692">                     BOND_TYPE_SINGLE == at[i2].bond_type[0]  ) </a>
<a name="ln693">                {</a>
<a name="ln694">                    /* found both X(-) and X(-); change bonds and remove charges */</a>
<a name="ln695">                    for ( k1 = 0; k1 &lt; at[c].valence &amp;&amp; i1 != at[c].neighbor[k1]; k1 ++ )</a>
<a name="ln696">                        ;</a>
<a name="ln697">                    for ( i = 0; i &lt; charge; i ++ ) </a>
<a name="ln698">                    {</a>
<a name="ln699">                        /* in case of P it does not matter which X atom is neutralized</a>
<a name="ln700">                           because of tautomerism. However, neutral central atom is important</a>
<a name="ln701">                           for the neutralization of the components */</a>
<a name="ln702">                        switch ( i ) </a>
<a name="ln703">                        {</a>
<a name="ln704">                        case 0:</a>
<a name="ln705">                            at[i1].charge ++; /* = 0; changed 2010-03-17 DT*/</a>
<a name="ln706">                            at[i1].bond_type[0] = at[c].bond_type[k1] = BOND_TYPE_DOUBLE;</a>
<a name="ln707">                            at[i1].bond_stereo[0] = at[c].bond_stereo[k1] = 0;</a>
<a name="ln708">                            at[i1].chem_bonds_valence ++;</a>
<a name="ln709">                            at[c].chem_bonds_valence ++;</a>
<a name="ln710">                            if ( bFixBug ) at[c].charge --; /* added 2010-03-17 DT*/</a>
<a name="ln711">                            num_changes ++;</a>
<a name="ln712">                            break;</a>
<a name="ln713">                        case 1:</a>
<a name="ln714">                            at[i2].charge ++; /*= 0; changed 2010-03-17 DT*/</a>
<a name="ln715">                            at[i2].bond_type[0] = at[c].bond_type[k2] = BOND_TYPE_DOUBLE;</a>
<a name="ln716">                            at[i2].bond_stereo[0] = at[c].bond_stereo[k2] = 0;</a>
<a name="ln717">                            at[i2].chem_bonds_valence ++;</a>
<a name="ln718">                            at[c].chem_bonds_valence ++;</a>
<a name="ln719">                            if ( bFixBug ) at[c].charge --; /* added 2010-03-17 DT */</a>
<a name="ln720">                            num_changes ++;</a>
<a name="ln721">                            break;</a>
<a name="ln722">                        }</a>
<a name="ln723">                    }</a>
<a name="ln724">/*   -- removed -- 2010-03-17 DT</a>
<a name="ln725">#if ( FIX_ODD_THINGS_REM_Plus_BUG == 1 )</a>
<a name="ln726">                    at[c].charge -= charge;</a>
<a name="ln727">#else</a>
<a name="ln728">                    if ( bFixBug ) </a>
<a name="ln729">                    {</a>
<a name="ln730">                        at[c].charge -= charge;</a>
<a name="ln731">                    }</a>
<a name="ln732">#endif</a>
<a name="ln733">*/</a>
<a name="ln734">                    break;</a>
<a name="ln735">                }</a>
<a name="ln736">            }</a>
<a name="ln737">        }</a>
<a name="ln738">    }</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741"> </a>
<a name="ln742"> </a>
<a name="ln743">    /* A(doublet)-B(doublet) -&gt; A=B  (A and B have no other doublet neighbors) */</a>
<a name="ln744">    /* A(doublet)=B(doublet) -&gt; A#B  (A and B have no other doublet neighbors) */</a>
<a name="ln745">    for( i1 = 0; i1 &lt; num_atoms; i1 ++ ) </a>
<a name="ln746">    {</a>
<a name="ln747">        if ( RADICAL_DOUBLET == at[i1].radical &amp;&amp;</a>
<a name="ln748">             0 &lt;= (i2=the_only_doublet_neigh(at, i1, &amp;k1, &amp;k2)) ) </a>
<a name="ln749">        {</a>
<a name="ln750">            if ( at[i1].bond_type[k1] &lt;= BOND_TYPE_DOUBLE ) </a>
<a name="ln751">            {</a>
<a name="ln752">                at[i1].bond_type[k1] ++;</a>
<a name="ln753">                at[i1].chem_bonds_valence ++;</a>
<a name="ln754">                at[i2].bond_type[k2] ++;</a>
<a name="ln755">                at[i2].chem_bonds_valence ++;</a>
<a name="ln756">                at[i1].radical = 0;</a>
<a name="ln757">                at[i2].radical = 0;</a>
<a name="ln758">            }</a>
<a name="ln759">        }</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">#if ( REMOVE_ION_PAIRS_EARLY == 1 )</a>
<a name="ln763">    num_changes += remove_ion_pairs( num_atoms, at );</a>
<a name="ln764">#endif</a>
<a name="ln765"> </a>
<a name="ln766"> </a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">    return num_changes;</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778"> </a>
<a name="ln779">/************************************************************************/</a>
<a name="ln780">int post_fix_odd_things( int num_atoms, inp_ATOM *at )</a>
<a name="ln781">{   </a>
<a name="ln782">    int num_changes = 0;</a>
<a name="ln783">    /* currently does nothing */</a>
<a name="ln784">    return num_changes;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">/************************************************************************/</a>
<a name="ln790">int nFindOneOM(inp_ATOM *at, int at_no, int ord_OM[], int num_OM)</a>
<a name="ln791">{</a>
<a name="ln792">    int i, n_OM, n_OM_best, best_value, cur_value, diff;</a>
<a name="ln793">    int num_best;</a>
<a name="ln794"> </a>
<a name="ln795">    if ( 1 == num_OM ) {</a>
<a name="ln796">        return ord_OM[0];</a>
<a name="ln797">    }</a>
<a name="ln798">    if ( 1 &gt; num_OM ) {</a>
<a name="ln799">        return -1;</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">    /* select neighbors with min. number of bonds */</a>
<a name="ln803">    num_best = 1;</a>
<a name="ln804">    n_OM       = (int)at[at_no].neighbor[ord_OM[0]];</a>
<a name="ln805">    best_value = (int)at[n_OM].valence;</a>
<a name="ln806">    /* compare number of bonds; move indexes of the best neighbors to the first elements of ord_OM[] */</a>
<a name="ln807">    for ( i = 1; i &lt; num_OM; i ++ ) {</a>
<a name="ln808">        n_OM = at[at_no].neighbor[ord_OM[i]];</a>
<a name="ln809">        cur_value = (int)at[n_OM].valence;</a>
<a name="ln810">        diff = cur_value - best_value;</a>
<a name="ln811">        if ( diff &lt; 0 ) {</a>
<a name="ln812">            n_OM_best  = n_OM;</a>
<a name="ln813">            best_value = cur_value;</a>
<a name="ln814">            ord_OM[0]  = ord_OM[i];</a>
<a name="ln815">            num_best   = 1;</a>
<a name="ln816">        } else</a>
<a name="ln817">        if ( diff == 0 ) {  /* was '=', pointed by WDI */</a>
<a name="ln818">            ord_OM[num_best ++] = ord_OM[i];</a>
<a name="ln819">        }</a>
<a name="ln820">    }</a>
<a name="ln821">    num_OM = num_best;</a>
<a name="ln822">    if ( 1 == num_OM ) {</a>
<a name="ln823">        return ord_OM[0];</a>
<a name="ln824">    }</a>
<a name="ln825">    /* select neighbors with min. periodic numbers */</a>
<a name="ln826">    num_best = 1;</a>
<a name="ln827">    n_OM       = (int)at[at_no].neighbor[ord_OM[0]];</a>
<a name="ln828">    best_value = (int)at[n_OM].el_number;</a>
<a name="ln829">    /* compare periodic numbers; move indexes of the best neighbors to the first elements of ord_OM[] */</a>
<a name="ln830">    for ( i = 1; i &lt; num_OM; i ++ ) {</a>
<a name="ln831">        n_OM = at[at_no].neighbor[ord_OM[i]];</a>
<a name="ln832">        cur_value = (int)at[n_OM].el_number;</a>
<a name="ln833">        diff = cur_value - best_value;</a>
<a name="ln834">        if ( diff &lt; 0 ) {</a>
<a name="ln835">            n_OM_best  = n_OM;</a>
<a name="ln836">            best_value = cur_value;</a>
<a name="ln837">            ord_OM[0]  = ord_OM[i];</a>
<a name="ln838">            num_best   = 1;</a>
<a name="ln839">        } else</a>
<a name="ln840">        if ( diff == 0 ) {  /* was '=', pointed by WDI */</a>
<a name="ln841">            ord_OM[num_best ++] = ord_OM[i];</a>
<a name="ln842">        }</a>
<a name="ln843">    }</a>
<a name="ln844">    num_OM = num_best;</a>
<a name="ln845">    if ( 1 == num_OM ) {</a>
<a name="ln846">        return ord_OM[0];</a>
<a name="ln847">    }</a>
<a name="ln848">    /* if neighbors are not terminal atoms then reject */</a>
<a name="ln849">    if ( 1 &lt; at[n_OM].valence ) {</a>
<a name="ln850">        return -1;</a>
<a name="ln851">    }</a>
<a name="ln852">    /* if neighbors are terminal atoms then the one without isotope or with lightest isotope */</a>
<a name="ln853">    num_best = 1;</a>
<a name="ln854">    n_OM       = (int)at[at_no].neighbor[ord_OM[0]];</a>
<a name="ln855">    best_value = (int)at[n_OM].iso_atw_diff;</a>
<a name="ln856">    /* compare periodic numbers; move indexes of the best neighbors to the first elements of ord_OM[] */</a>
<a name="ln857">    for ( i = 1; i &lt; num_OM; i ++ ) {</a>
<a name="ln858">        n_OM = at[at_no].neighbor[ord_OM[i]];</a>
<a name="ln859">        cur_value = (int)at[n_OM].el_number;</a>
<a name="ln860">        diff = cur_value - best_value;</a>
<a name="ln861">        if ( (!cur_value &amp;&amp; best_value) || diff &lt; 0 ) {</a>
<a name="ln862">            n_OM_best  = n_OM;</a>
<a name="ln863">            best_value = cur_value;</a>
<a name="ln864">            ord_OM[0]  = ord_OM[i];</a>
<a name="ln865">            num_best   = 1;</a>
<a name="ln866">        } else</a>
<a name="ln867">        if ( diff == 0 ) {    /* was '=', pointed by WDI */</a>
<a name="ln868">            ord_OM[num_best ++] = ord_OM[i];</a>
<a name="ln869">        }</a>
<a name="ln870">    }</a>
<a name="ln871">    num_OM = num_best;</a>
<a name="ln872">    if ( 1 == num_OM ) {</a>
<a name="ln873">        return ord_OM[0];</a>
<a name="ln874">    }</a>
<a name="ln875">    /* return any */</a>
<a name="ln876">    return ord_OM[0];</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879"> </a>
<a name="ln880"> </a>
<a name="ln881">/************************************************************************/</a>
<a name="ln882">/* the bonds are fixed in fix_special_bonds() */</a>
<a name="ln883">int remove_ion_pairs( int num_atoms, inp_ATOM *at )</a>
<a name="ln884">{   </a>
<a name="ln885">    int num_changes = 0;</a>
<a name="ln886"> </a>
<a name="ln887">    /*                           0 1 2  3  4 5 6  7  8  9                   8  9  */</a>
<a name="ln888">#if ( FIX_REM_ION_PAIRS_Si_BUG == 1 )</a>
<a name="ln889">    static const char    el[] = &quot;N;P;As;Sb;O;S;Se;Te;C;Si;&quot;;   /* 8 elements + C, Si */</a>
<a name="ln890">#else</a>
<a name="ln891">    static const char    el[] = &quot;N;P;As;Sb;O;S;Se;Te;C;Si&quot;;   /* 8 elements + C, Si */</a>
<a name="ln892">#endif</a>
<a name="ln893">    static char    en[12];         /* same number: 8 elements */</a>
<a name="ln894">    static int     ne=0;           /* will be 8 and 10 */</a>
<a name="ln895"> </a>
<a name="ln896">#define ELEM_N_FST  0</a>
<a name="ln897">#define ELEM_N_LEN  4</a>
<a name="ln898">#define ELEM_O_FST  4</a>
<a name="ln899">#define ELEM_O_LEN  4</a>
<a name="ln900">#define ELEM_C_FST  8</a>
<a name="ln901">#define ELEM_C_LEN  2</a>
<a name="ln902"> </a>
<a name="ln903">#define MAX_NEIGH 6</a>
<a name="ln904"> </a>
<a name="ln905">    int i, n, n2, i1, i2, i3, i4, type, chrg;</a>
<a name="ln906">    int num_C_II=0, num_C_plus=0, num_C_minus=0, num_N_plus=0, num_N_minus=0, num_O_plus=0, num_O_minus=0, num_All;</a>
<a name="ln907">#ifdef FIX_P_IV_Plus_O_Minus</a>
<a name="ln908">    int num_P_IV_plus=0; /* added 2010-03-17 DT */</a>
<a name="ln909">#endif</a>
<a name="ln910">    inp_ATOM *a;</a>
<a name="ln911">    char elname[ATOM_EL_LEN], *p;</a>
<a name="ln912">    if ( !ne ) { /* one time initialization */</a>
<a name="ln913">        const char *b, *e;</a>
<a name="ln914">        int  len;</a>
<a name="ln915">        for ( b = el; (e = strchr( b, ';')); b = e+1 ) {</a>
<a name="ln916">            len = e-b;</a>
<a name="ln917">            memcpy( elname, b, len );</a>
<a name="ln918">            elname[len] = '\0';</a>
<a name="ln919">            en[ne++] = get_periodic_table_number( elname );</a>
<a name="ln920">        }</a>
<a name="ln921">        en[ne] = '\0';</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">    /****** count candidates ********/</a>
<a name="ln925">    for ( i = 0, a = at; i &lt; num_atoms; i ++, a++ ) {</a>
<a name="ln926">        if ( 1 == (chrg=a-&gt;charge) || -1 == chrg ) {</a>
<a name="ln927">            if ( (p = (char*)memchr( en, a-&gt;el_number, ne)) ) {</a>
<a name="ln928">                n = p - en;</a>
<a name="ln929">                if ( n &gt;= ELEM_C_FST ) {</a>
<a name="ln930">                    if ( chrg &gt; 0 )</a>
<a name="ln931">                        num_C_plus ++;</a>
<a name="ln932">                    else</a>
<a name="ln933">                        num_C_minus ++;</a>
<a name="ln934">                } else</a>
<a name="ln935">                if ( n &gt;= ELEM_O_FST ) {</a>
<a name="ln936">                    if ( chrg &gt; 0 )</a>
<a name="ln937">                        num_O_plus ++;</a>
<a name="ln938">                    else</a>
<a name="ln939">                        num_O_minus ++;</a>
<a name="ln940">                } else {</a>
<a name="ln941">                    if ( chrg &gt; 0 )</a>
<a name="ln942">                        num_N_plus ++;</a>
<a name="ln943">                    else</a>
<a name="ln944">                        num_N_minus ++;</a>
<a name="ln945">#ifdef FIX_P_IV_Plus_O_Minus</a>
<a name="ln946">                    num_P_IV_plus += n &gt; 0 &amp;&amp; chrg == 1 &amp;&amp; a-&gt;valence == 4 &amp;&amp; a-&gt;chem_bonds_valence == 4; /* added 2010-03-17 DT */</a>
<a name="ln947">#endif</a>
<a name="ln948">                }</a>
<a name="ln949">            }</a>
<a name="ln950">        } else</a>
<a name="ln951">        if ( !chrg &amp;&amp; a-&gt;chem_bonds_valence + NUMH(a, 0) == 2 &amp;&amp;</a>
<a name="ln952">             get_el_valence( a-&gt;el_number, 0, 0 ) == 4     &amp;&amp;</a>
<a name="ln953">             NULL != memchr( en+ELEM_C_FST, a-&gt;el_number, ELEM_C_LEN) ) {</a>
<a name="ln954">            num_C_II ++;</a>
<a name="ln955">        }</a>
<a name="ln956">    }</a>
<a name="ln957">    num_All = num_C_II + num_C_plus + num_C_minus + num_N_plus + num_N_minus + num_O_plus + num_O_minus;</a>
<a name="ln958">    /* do not add num_P_IV_plus ! -- 2010-03-17 DT */</a>
<a name="ln959">    if ( !num_All ) {</a>
<a name="ln960">        return 0;</a>
<a name="ln961">    }</a>
<a name="ln962"> </a>
<a name="ln963">    /**************************************************************************/</a>
<a name="ln964">    /*************************** Terminal ion pairs ***************************/</a>
<a name="ln965">    /**************************************************************************/</a>
<a name="ln966"> </a>
<a name="ln967">    /*-------------------------------------------------------------------------</a>
<a name="ln968">       Pair type 1            N=N,P,As,Sb; O=O,S,Se,Te</a>
<a name="ln969">       ===========</a>
<a name="ln970"> </a>
<a name="ln971">         X              X     if X is another -O(-) then neutralize O(-) </a>
<a name="ln972">         |              |     that has the smallest periodic table number</a>
<a name="ln973">       O=N(+)-O(-) =&gt; O=N=O</a>
<a name="ln974">         i    n</a>
<a name="ln975">     --------------------------------------------------------------------------*/</a>
<a name="ln976">    for ( type = 1; type &lt;= 18; type ++ ) {</a>
<a name="ln977">        if ( (!type || 1 == type) ) {</a>
<a name="ln978">            for ( i = 0; i &lt; num_atoms &amp;&amp; 0 &lt; num_N_plus &amp;&amp; 0 &lt; num_O_minus; i ++ ) {</a>
<a name="ln979">                if ( 1 == at[i].charge &amp;&amp; 3 == nNoMetalNumBonds(at, i) &amp;&amp;</a>
<a name="ln980">                     4 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln981">                     NULL != memchr( en+ELEM_N_FST, at[i].el_number, ELEM_N_LEN) ) {</a>
<a name="ln982">                    int num_OM = 0, ord_OM[3]; /* -O(-) */</a>
<a name="ln983">                    int num_O  = 0; /* =O    */</a>
<a name="ln984">                    int num_O_other = 0;</a>
<a name="ln985">                    for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln986">                        n = at[i].neighbor[i1];</a>
<a name="ln987">                        if ( 1 == nNoMetalNumBonds(at, n) &amp;&amp; 0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln988">                             NULL != (p = (char*)memchr( en+ELEM_O_FST, at[n].el_number, ELEM_O_LEN)) ) {</a>
<a name="ln989">                            if ( BOND_TYPE_SINGLE == at[i].bond_type[i1] &amp;&amp;</a>
<a name="ln990">                                 -1               == at[n].charge       ) {</a>
<a name="ln991">                                ord_OM[num_OM ++]  = i1;</a>
<a name="ln992">                            } else</a>
<a name="ln993">                            if ( BOND_TYPE_DOUBLE == at[n].bond_type[0] &amp;&amp;</a>
<a name="ln994">                                 0                == at[n].charge       ) {</a>
<a name="ln995">                                num_O ++;</a>
<a name="ln996">                            } else {</a>
<a name="ln997">                                num_O_other ++;</a>
<a name="ln998">                            }</a>
<a name="ln999">                        }</a>
<a name="ln1000">                    }</a>
<a name="ln1001">                    if ( num_OM &gt; 0 &amp;&amp; num_O &gt; 0 &amp;&amp; !num_O_other &amp;&amp;</a>
<a name="ln1002">                         0 &lt;= (i1=nFindOneOM(at, i, ord_OM, num_OM)) ) {</a>
<a name="ln1003">                        /* remove charges and increase bond order */</a>
<a name="ln1004">                        n = at[i].neighbor[i1];</a>
<a name="ln1005">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1006">                        at[i].bond_type[i1] ++;</a>
<a name="ln1007">                        at[n].bond_type[i2] ++;</a>
<a name="ln1008">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1009">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1010">                        at[i].charge --;</a>
<a name="ln1011">                        at[n].charge ++;</a>
<a name="ln1012">                        at[i].radical = 0;</a>
<a name="ln1013">                        at[n].radical = 0;</a>
<a name="ln1014">                        num_changes ++;</a>
<a name="ln1015">                        num_N_plus --;</a>
<a name="ln1016">                        num_O_minus --;</a>
<a name="ln1017">                        num_All -= 2;</a>
<a name="ln1018">                    }</a>
<a name="ln1019">                }</a>
<a name="ln1020">            }</a>
<a name="ln1021">#ifdef FIX_P_IV_Plus_O_Minus</a>
<a name="ln1022">    /*-------------------------------------------------------------------------</a>
<a name="ln1023">       Pair type 1a           P=P,As,Sb; O=O,S,Se,Te  -- added 2010-03-17</a>
<a name="ln1024">       =============</a>
<a name="ln1025"> </a>
<a name="ln1026">         X              X     if X, Y, or Z is another -O(-) then neutralize O(-) </a>
<a name="ln1027">         |              |     that has the smallest periodic table number</a>
<a name="ln1028">       Y-P(+)-O(-) =&gt; Y-P=O</a>
<a name="ln1029">         |i   n         |</a>
<a name="ln1030">         Z              Z</a>
<a name="ln1031">         </a>
<a name="ln1032">     --------------------------------------------------------------------------*/</a>
<a name="ln1033">            for ( i = 0; i &lt; num_atoms &amp;&amp; 0 &lt; num_P_IV_plus /*&amp;&amp; 0 &lt; num_N_plus*/ &amp;&amp; 0 &lt; num_O_minus; i ++ ) {</a>
<a name="ln1034">                if ( 1 == at[i].charge &amp;&amp; 4 == nNoMetalNumBonds(at, i) &amp;&amp;</a>
<a name="ln1035">                     4 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1036">                     NULL != memchr( en+ELEM_N_FST+1, at[i].el_number, ELEM_N_LEN-1) ) {</a>
<a name="ln1037">                    int num_OM = 0, ord_OM[4]; /* -O(-) */</a>
<a name="ln1038">                    /*int num_O  = 0;*/ /* =O    */</a>
<a name="ln1039">                    int num_O_other = 0;</a>
<a name="ln1040">                    for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1041">                        n = at[i].neighbor[i1];</a>
<a name="ln1042">                        if ( 1 == nNoMetalNumBonds(at, n) &amp;&amp; 0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1043">                             NULL != (p = (char*)memchr( en+ELEM_O_FST, at[n].el_number, ELEM_O_LEN)) ) {</a>
<a name="ln1044">                            if ( BOND_TYPE_SINGLE == at[i].bond_type[i1] &amp;&amp;</a>
<a name="ln1045">                                 -1               == at[n].charge       ) {</a>
<a name="ln1046">                                ord_OM[num_OM ++]  = i1;</a>
<a name="ln1047">                            /*</a>
<a name="ln1048">                            }</a>
<a name="ln1049">                            if ( BOND_TYPE_DOUBLE == at[n].bond_type[0] &amp;&amp;</a>
<a name="ln1050">                                 0                == at[n].charge       ) {</a>
<a name="ln1051">                                num_O ++;</a>
<a name="ln1052">                            */</a>
<a name="ln1053">                            } else {</a>
<a name="ln1054">                                num_O_other ++;</a>
<a name="ln1055">                            }</a>
<a name="ln1056">                        }</a>
<a name="ln1057">                    }</a>
<a name="ln1058">                    if ( num_OM &gt; 0 /*&amp;&amp; num_O &gt; 0 &amp;&amp; !num_O_other*/ &amp;&amp;</a>
<a name="ln1059">                         0 &lt;= (i1=nFindOneOM(at, i, ord_OM, num_OM)) ) {</a>
<a name="ln1060">                        /* remove charges and increase bond order */</a>
<a name="ln1061">                        n = at[i].neighbor[i1];</a>
<a name="ln1062">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1063">                        at[i].bond_type[i1] ++;</a>
<a name="ln1064">                        at[n].bond_type[i2] ++;</a>
<a name="ln1065">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1066">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1067">                        at[i].charge --;</a>
<a name="ln1068">                        at[n].charge ++;</a>
<a name="ln1069">                        at[i].radical = 0;</a>
<a name="ln1070">                        at[n].radical = 0;</a>
<a name="ln1071">                        num_changes ++;</a>
<a name="ln1072">                        num_N_plus --;</a>
<a name="ln1073">                        num_O_minus --;</a>
<a name="ln1074">                        num_P_IV_plus --;</a>
<a name="ln1075">                        num_All -= 2;</a>
<a name="ln1076">                    }</a>
<a name="ln1077">                }</a>
<a name="ln1078">            }</a>
<a name="ln1079">#endif /* FIX_P_IV_Plus_O_Minus */</a>
<a name="ln1080">        }</a>
<a name="ln1081">        /*-------------------------------------------------------------------------</a>
<a name="ln1082">           Terminal pair types: 2,3,4,5,6,7,8,9   N=N,P,As,Sb; O=O,S,Se,Te; C=C,Si</a>
<a name="ln1083">           ====================================</a>
<a name="ln1084">    type #</a>
<a name="ln1085">       2 2:  O=N-C(II)-     =&gt; O=N#C-      N=N,P,As,Sb; O=O,S,Se,Te; C=C,Si</a>
<a name="ln1086">       3 9:  O=O(+)-C(-)(III) =&gt; O=O=C(IV)</a>
<a name="ln1087">       4 3:  O(-)-N(+)(IV)  =&gt; O=N(V)  (input structure has at least 1 double bond)</a>
<a name="ln1088">       5 4:  O(-)-O(+)(III) =&gt; O=O(IV)</a>
<a name="ln1089">       6 8:  O(-)-O-C(+)(III) =&gt; O=O=C(IV)</a>
<a name="ln1090">       7 5:  N(-)=N(+)(IV)  =&gt; N#N(V)    allow terminal H on N(-)</a>
<a name="ln1091">       8 6:  N(-)=O(+)(III) =&gt; N#O-</a>
<a name="ln1092">       9 7:  N(-)=C(+)(III) =&gt; N#C-</a>
<a name="ln1093">         --------------------------------------------------------------------------*/</a>
<a name="ln1094">        if ( !type || (2 &lt;= type &amp;&amp; type &lt;= 9) ) {</a>
<a name="ln1095">            for ( i = 0; i &lt; num_atoms &amp;&amp; 0 &lt; num_All; i ++ ) {</a>
<a name="ln1096">                if ( 0 == at[i].charge &amp;&amp; 1 == nNoMetalNumBonds(at, i) &amp;&amp; 2 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1097">                     0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1098">                     NULL != memchr( en+ELEM_O_FST, at[i].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln1099">                     0 &lt;= ( i1 = nNoMetalNeighIndex(at, i)) &amp;&amp;</a>
<a name="ln1100">                     at[i].bond_type[i1] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1101">                    /* terminal O= */</a>
<a name="ln1102">                    n = at[i].neighbor[i1];</a>
<a name="ln1103">                    if ( (!type || type == 2) &amp;&amp; 0 &lt; num_C_II ) {   /* avoid alternating bonds */</a>
<a name="ln1104">                        if ( 0 == at[n].charge &amp;&amp;</a>
<a name="ln1105">                             2 == nNoMetalNumBonds(at, n) &amp;&amp; 3 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1106">                             0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1107">                             NULL != memchr( en+ELEM_N_FST, at[n].el_number, ELEM_N_LEN) &amp;&amp;</a>
<a name="ln1108">                             0 &lt;= (i2 = nNoMetalOtherNeighIndex( at, n, i ) ) &amp;&amp;</a>
<a name="ln1109">                             at[n].bond_type[i2] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1110">                            /* i2 = index of opposite to at[i] neighbor of at[n] */</a>
<a name="ln1111">                            /*i2 = (at[n].neighbor[0] == i);*/</a>
<a name="ln1112">                            n2 = at[n].neighbor[i2];</a>
<a name="ln1113">                            if ( 0 == at[n2].charge &amp;&amp;</a>
<a name="ln1114">                                 2 == at[n2].valence &amp;&amp; 2 == at[n2].chem_bonds_valence &amp;&amp;</a>
<a name="ln1115">                                 0 == num_of_H( at, n2 ) &amp;&amp;</a>
<a name="ln1116">                                 NULL != memchr( en+ELEM_C_FST, at[n2].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1117">                                 /*       i n n2     */</a>
<a name="ln1118">                                 /* found O=N-C(II)- */</a>
<a name="ln1119">                                 /* convert O=N-C(II)-     =&gt; O=N#C- */</a>
<a name="ln1120">                                i3 = (at[n2].neighbor[0] != n); /* index of at[n] neighbor of n2 */</a>
<a name="ln1121">                                at[ n].chem_bonds_valence = 5; /* N */</a>
<a name="ln1122">                                at[n2].chem_bonds_valence = 4; /* C */</a>
<a name="ln1123">                                at[ n].bond_type[i2] = BOND_TYPE_TRIPLE;</a>
<a name="ln1124">                                at[n2].bond_type[i3] = BOND_TYPE_TRIPLE;</a>
<a name="ln1125">                                at[n2].radical = 0;</a>
<a name="ln1126">                                num_changes ++;</a>
<a name="ln1127">                                num_C_II --;</a>
<a name="ln1128">                                num_All --;</a>
<a name="ln1129">                                continue;</a>
<a name="ln1130">                            }</a>
<a name="ln1131">                        }</a>
<a name="ln1132">                    }</a>
<a name="ln1133">                    if ( (!type || type == 3) &amp;&amp; 0 &lt; num_O_plus &amp;&amp; 0 &lt; num_C_minus ) {</a>
<a name="ln1134">                        if ( 1 == at[n].charge &amp;&amp; 2 == nNoMetalNumBonds(at, n) &amp;&amp; 3 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1135">                             0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1136">                             NULL != memchr( en+ELEM_O_FST, at[n].el_number, ELEM_O_LEN)  &amp;&amp;</a>
<a name="ln1137">                             0 &lt;= (i2 = nNoMetalOtherNeighIndex( at, n, i ) ) &amp;&amp;</a>
<a name="ln1138">                             at[n].bond_type[i2] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1139">                            /* found O=O(+)- */</a>
<a name="ln1140">                            /* i2 = index of opposite to at[i] neighbor of at[n] */</a>
<a name="ln1141">                            /*i2 = (at[n].neighbor[0] == i);*/</a>
<a name="ln1142">                            n2 = at[n].neighbor[i2];</a>
<a name="ln1143">                            if ( -1 == at[n2].charge &amp;&amp; 3 &gt;= nNoMetalNumBonds(at, n2) &amp;&amp; 3 == nNoMetalBondsValence(at, n2)+NUMH(at,n2) &amp;&amp;</a>
<a name="ln1144">                                 NULL != memchr( en+ELEM_C_FST, at[n2].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1145">                                 /*             i n    n2        */</a>
<a name="ln1146">                                 /* found found O=O(+)-C(-)(III) */</a>
<a name="ln1147">                                 /* convert O=O(+)-C(-)(III)     =&gt; O=O=C(IV) */</a>
<a name="ln1148">                                i3 = (at[n2].neighbor[0] != n); /* index of at[n] neighbor of n2 */</a>
<a name="ln1149">                                at[ n].charge --;</a>
<a name="ln1150">                                at[n2].charge ++;</a>
<a name="ln1151">                                at[ n].chem_bonds_valence += 1; /* =O- =&gt; =O= */</a>
<a name="ln1152">                                at[n2].chem_bonds_valence += 1; /* -C  =&gt; =C  */</a>
<a name="ln1153">                                at[ n].bond_type[i2] = BOND_TYPE_DOUBLE;</a>
<a name="ln1154">                                at[n2].bond_type[i3] = BOND_TYPE_DOUBLE;</a>
<a name="ln1155">                                num_changes ++;</a>
<a name="ln1156">                                num_O_plus --;</a>
<a name="ln1157">                                num_C_minus --;</a>
<a name="ln1158">                                num_All -= 2;</a>
<a name="ln1159">                                continue;</a>
<a name="ln1160">                            }</a>
<a name="ln1161">                        }</a>
<a name="ln1162">                    }</a>
<a name="ln1163">                } else</a>
<a name="ln1164">                if ( -1 == at[i].charge &amp;&amp;</a>
<a name="ln1165">                      0 &lt; num_O_minus + num_N_minus &amp;&amp;</a>
<a name="ln1166">                      0 &lt; num_N_plus + num_O_plus + num_C_plus &amp;&amp;</a>
<a name="ln1167">                      1 == nNoMetalNumBonds(at, i) &amp;&amp; 1 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1168">                      0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1169">                     NULL != memchr( en+ELEM_O_FST, at[i].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln1170">                     0 &lt;= (i1 = nNoMetalNeighIndex( at, i )) &amp;&amp;</a>
<a name="ln1171">                     at[i].bond_type[i1] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1172">                    </a>
<a name="ln1173">                    /* terminal O(-)- */</a>
<a name="ln1174">                    </a>
<a name="ln1175">                    n = at[i].neighbor[i1];</a>
<a name="ln1176">                    </a>
<a name="ln1177">                    if ( (!type || type == 4) &amp;&amp; 0 &lt; num_O_minus &amp;&amp; 0 &lt; num_N_plus &amp;&amp; /* O(-)-N(+)(IV) */</a>
<a name="ln1178">                         1 == at[n].charge &amp;&amp; 3 &gt;= nNoMetalNumBonds(at, n) &amp;&amp; 4 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1179">                         0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1180">                         NULL != memchr( en+ELEM_N_FST, at[n].el_number, ELEM_N_LEN) /* except &gt;O(+)- */</a>
<a name="ln1181">                       ) {</a>
<a name="ln1182">                         /* found O(-)-N(+)(IV) */</a>
<a name="ln1183">                         /* convert O(-)-N(+)(IV)     =&gt; O=N(V)  */</a>
<a name="ln1184"> </a>
<a name="ln1185">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor; /* index of at[i] neighbor of at[n] */</a>
<a name="ln1186">                        at[i].charge ++;</a>
<a name="ln1187">                        at[n].charge --;</a>
<a name="ln1188">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1189">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1190">                        at[i].bond_type[i1] ++;</a>
<a name="ln1191">                        at[n].bond_type[i2] ++;</a>
<a name="ln1192">                        num_changes ++;</a>
<a name="ln1193">                        num_O_minus --;</a>
<a name="ln1194">                        num_N_plus --;</a>
<a name="ln1195">                        num_All -= 2;</a>
<a name="ln1196">                        continue;</a>
<a name="ln1197">                    }</a>
<a name="ln1198">                    </a>
<a name="ln1199">                    if ( (!type || type == 5) &amp;&amp; 0 &lt; num_O_minus &amp;&amp; 0 &lt; num_O_plus &amp;&amp;/* O(-)-O(+)(III) */</a>
<a name="ln1200">                         1 == at[n].charge &amp;&amp; 3 &gt;= nNoMetalNumBonds(at, n) &amp;&amp; 3 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1201">                         0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1202">                         NULL != memchr( en+ELEM_O_FST, at[n].el_number, ELEM_O_LEN) /* except &gt;O(+)- */</a>
<a name="ln1203">                       ) {</a>
<a name="ln1204">                         /* found  O(+)(III) */</a>
<a name="ln1205">                         /* convert O(-)-O(+)(III)    =&gt; O=O(IV) */</a>
<a name="ln1206"> </a>
<a name="ln1207">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor; /* index of at[i] neighbor of at[n] */</a>
<a name="ln1208">                        at[i].charge ++;</a>
<a name="ln1209">                        at[n].charge --;</a>
<a name="ln1210">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1211">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1212">                        at[i].bond_type[i1] ++;</a>
<a name="ln1213">                        at[n].bond_type[i2] ++;</a>
<a name="ln1214">                        num_changes ++;</a>
<a name="ln1215">                        num_O_minus --;</a>
<a name="ln1216">                        num_O_plus --;</a>
<a name="ln1217">                        num_All -= 2;</a>
<a name="ln1218">                        continue;</a>
<a name="ln1219">                    }</a>
<a name="ln1220">                                                 /* i    n n2        */</a>
<a name="ln1221">                    if ( (!type || type == 6) &amp;&amp; /* O(-)-O-C(+)(III) */</a>
<a name="ln1222">                         0 &lt; num_O_minus &amp;&amp; 0 &lt; num_C_plus &amp;&amp;</a>
<a name="ln1223">                         0 == at[n].charge &amp;&amp; 2 == nNoMetalNumBonds(at, n) &amp;&amp; 2 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1224">                         0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1225">                         NULL != memchr( en+ELEM_O_FST, at[n].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln1226">                         0 &lt;= (i2=nNoMetalOtherNeighIndex( at, n, i )) &amp;&amp;</a>
<a name="ln1227">                         at[n].bond_type[i2] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1228">                        /* found O(-)-O- */</a>
<a name="ln1229">                        /* i2 = index of opposite to at[i] neighbor of at[n] */</a>
<a name="ln1230">                        /*i2 = (at[n].neighbor[0] == i);*/</a>
<a name="ln1231">                        n2 = at[n].neighbor[i2];</a>
<a name="ln1232">                        if ( 1 == at[n2].charge &amp;&amp; 3 &gt;= nNoMetalNumBonds(at, n2) &amp;&amp;</a>
<a name="ln1233">                             3 == nNoMetalBondsValence(at, n2)+NUMH(at,n2) &amp;&amp;</a>
<a name="ln1234">                             NULL != memchr( en+ELEM_C_FST, at[n2].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1235">                            /*       i    n n2  */</a>
<a name="ln1236">                            /* found O(-)-O-C(+)(III) */</a>
<a name="ln1237">                            /* convert O(-)-O-C(+)(III)     =&gt; O=O=C(IV) */</a>
<a name="ln1238">                            /*i3 = (at[n2].neighbor[0] != n);*/ /* i3 = index of at[n] neighbor of at[n2] */</a>
<a name="ln1239">                            i3 = is_in_the_list( at[n2].neighbor, (AT_NUMB)n, at[n2].valence ) - at[n2].neighbor;</a>
<a name="ln1240">                            /*i4 = index of at[i] in the adjacency list of at[n] */</a>
<a name="ln1241">                            i4 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1242">                            at[ i].charge ++;</a>
<a name="ln1243">                            at[n2].charge --;</a>
<a name="ln1244">                            at[ i].chem_bonds_valence += 1; /* O-  =&gt; O=  */</a>
<a name="ln1245">                            at[ n].chem_bonds_valence += 2; /* -O- =&gt; =O= */</a>
<a name="ln1246">                            at[n2].chem_bonds_valence += 1; /* -C  =&gt; =C  */</a>
<a name="ln1247">                            at[ i].bond_type[i1]   = BOND_TYPE_DOUBLE;</a>
<a name="ln1248">                            at[ n].bond_type[i4]   = BOND_TYPE_DOUBLE;</a>
<a name="ln1249">                            at[ n].bond_type[i2]   = BOND_TYPE_DOUBLE;</a>
<a name="ln1250">                            at[n2].bond_type[i3]   = BOND_TYPE_DOUBLE;</a>
<a name="ln1251">                            num_changes ++;</a>
<a name="ln1252">                            num_O_minus --;</a>
<a name="ln1253">                            num_C_plus --;</a>
<a name="ln1254">                            num_All -= 2;</a>
<a name="ln1255">                            continue;</a>
<a name="ln1256">                        }</a>
<a name="ln1257">                    }</a>
<a name="ln1258">                } else</a>
<a name="ln1259">                if ( -1 == at[i].charge &amp;&amp; 0 &lt; num_N_minus &amp;&amp; 0 &lt; num_N_plus+num_O_plus+num_C_plus &amp;&amp;</a>
<a name="ln1260">                      1 == nNoMetalNumBonds(at, i) &amp;&amp; 2 == nNoMetalBondsValence(at, i)+NUMH(at, i) &amp;&amp;</a>
<a name="ln1261">                      /*0 == num_of_H( at, i ) &amp;&amp;*/</a>
<a name="ln1262">                     NULL != memchr( en+ELEM_N_FST, at[i].el_number, ELEM_N_LEN) &amp;&amp;</a>
<a name="ln1263">                     0 &lt;= (i1 = nNoMetalNeighIndex( at, i )) &amp;&amp;</a>
<a name="ln1264">                     at[i].bond_type[i1] &lt;= BOND_TYPE_TRIPLE ) {</a>
<a name="ln1265">                    /* terminal N(-)= */</a>
<a name="ln1266">                    n = at[i].neighbor[i1 = 0];</a>
<a name="ln1267">                    if ( (!type || type == 7) &amp;&amp; 0 &lt; num_N_plus &amp;&amp; /* N(-)=N(+)(IV) */</a>
<a name="ln1268">                         1 == at[n].charge &amp;&amp; 3 &gt;= nNoMetalNumBonds(at, n) &amp;&amp; 4 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1269">                         0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1270">                         NULL != memchr( en+ELEM_N_FST, at[n].el_number, ELEM_N_LEN)</a>
<a name="ln1271">                       ) {</a>
<a name="ln1272">                         /* found N(-)-N(+)(IV) */</a>
<a name="ln1273">                         /* convert N(-)=N(+)(IV)     =&gt; N#N(V)  */</a>
<a name="ln1274"> </a>
<a name="ln1275">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor; /* index of at[i] neighbor of at[n] */</a>
<a name="ln1276">                        at[i].charge ++;</a>
<a name="ln1277">                        at[n].charge --;</a>
<a name="ln1278">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1279">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1280">                        at[i].bond_type[i1] ++;</a>
<a name="ln1281">                        at[n].bond_type[i2] ++;</a>
<a name="ln1282">                        num_changes ++;</a>
<a name="ln1283">                        num_N_minus --;</a>
<a name="ln1284">                        num_N_plus --;</a>
<a name="ln1285">                        num_All -= 2;</a>
<a name="ln1286">                        continue;</a>
<a name="ln1287">                    }</a>
<a name="ln1288">                    if ( (!type || type == 8) &amp;&amp; 0 &lt; num_O_plus &amp;&amp; /* N(-)=O(+)(III) */</a>
<a name="ln1289">                         1 == at[n].charge &amp;&amp; 2 == nNoMetalNumBonds(at, n) &amp;&amp; 3 == nNoMetalBondsValence(at, n) &amp;&amp;</a>
<a name="ln1290">                         0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1291">                         NULL != memchr( en+ELEM_O_FST, at[n].el_number, ELEM_O_LEN)</a>
<a name="ln1292">                         ) {</a>
<a name="ln1293">                         /* found N(-)-O(+)(III) */</a>
<a name="ln1294">                         /* convert N(-)=O(+)(III)    =&gt; N#O(IV)- */</a>
<a name="ln1295">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor; /* index of at[i] neighbor of at[n] */</a>
<a name="ln1296">                        at[i].charge ++;</a>
<a name="ln1297">                        at[n].charge --;</a>
<a name="ln1298">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1299">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1300">                        at[i].bond_type[i1] ++;</a>
<a name="ln1301">                        at[n].bond_type[i2] ++;</a>
<a name="ln1302">                        num_changes ++;</a>
<a name="ln1303">                        num_N_minus --;</a>
<a name="ln1304">                        num_O_plus --;</a>
<a name="ln1305">                        num_All -= 2;</a>
<a name="ln1306">                        continue;</a>
<a name="ln1307">                    }</a>
<a name="ln1308">                    if ( (!type || type == 9) &amp;&amp; 0 &lt; num_C_plus &amp;&amp; /* N(-)=C(+)(III) */</a>
<a name="ln1309">                         1 == at[n].charge &amp;&amp; 2 == at[n].valence &amp;&amp; 3 == at[n].chem_bonds_valence &amp;&amp;</a>
<a name="ln1310">                         0 == num_of_H( at, n ) &amp;&amp;</a>
<a name="ln1311">                         NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN)</a>
<a name="ln1312">                         ) {</a>
<a name="ln1313">                         /* found N(-)=C(+)(III) */</a>
<a name="ln1314">                         /* convert N(-)=C(+)(III)    =&gt; N#C(IV)- */</a>
<a name="ln1315"> </a>
<a name="ln1316">                        i2 =  is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor; /* index of at[i] neighbor of at[n] */</a>
<a name="ln1317">                        at[i].charge ++;</a>
<a name="ln1318">                        at[n].charge --;</a>
<a name="ln1319">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1320">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1321">                        at[i].bond_type[i1] ++;</a>
<a name="ln1322">                        at[n].bond_type[i2] ++;</a>
<a name="ln1323">                        num_changes ++;</a>
<a name="ln1324">                        num_N_minus --;</a>
<a name="ln1325">                        num_C_plus --;</a>
<a name="ln1326">                        num_All -= 2;</a>
<a name="ln1327">                        continue;</a>
<a name="ln1328">                    }</a>
<a name="ln1329">                }</a>
<a name="ln1330">            }</a>
<a name="ln1331">        }</a>
<a name="ln1332"> </a>
<a name="ln1333">        /**************************************************************************/</a>
<a name="ln1334">        /*********************** NON-Terminal ion pairs ***************************/</a>
<a name="ln1335">        /**************************************************************************/</a>
<a name="ln1336">        /*-------------------------------------------------------------------------</a>
<a name="ln1337">           Non-Terminal pair types: 10,11,12,13,14   N=N,P,As,Sb; O=O,S,Se,Te; C=C,Si</a>
<a name="ln1338">           ========================================</a>
<a name="ln1339"> </a>
<a name="ln1340">        10:  N(+)(IV)-C(-)(III)     =&gt; N(V)=C(IV)  (N has 3 or 2 bonds)</a>
<a name="ln1341">        11:  N(+)(IV)=C(-)(III)     =&gt; N(V)#C(IV)  (N has 3 or 2 bonds)</a>
<a name="ln1342">        12:  N(+)(IV)-N(-)(II)      =&gt; N(V)=N(III) (allow terminal H on N(-))</a>
<a name="ln1343">        13: -O(+)-C(-)(III)         =&gt; -O=C-</a>
<a name="ln1344">        14: -O(+)=C(-)(III)         =&gt; -O#C-</a>
<a name="ln1345">        15:  O(+)(III)-N(-)(II)     =&gt; O(IV)=N(III) (allow terminal H on N(-))</a>
<a name="ln1346">         --------------------------------------------------------------------------*/</a>
<a name="ln1347">        if ( !type || (10 &lt;= type &amp;&amp; type &lt;= 15) ) {</a>
<a name="ln1348">            for ( i = 0; i &lt; num_atoms &amp;&amp; 0 &lt; num_All; i ++ ) {</a>
<a name="ln1349">                if ( 1 == at[i].charge &amp;&amp;</a>
<a name="ln1350">                     0 &lt; num_N_plus + num_O_plus &amp;&amp; 0 &lt; num_C_minus + num_N_minus &amp;&amp;</a>
<a name="ln1351">                     4 &gt;= nNoMetalNumBonds(at, i) &amp;&amp; 4 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1352">                     0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1353">                     NULL != memchr( en+ELEM_N_FST, at[i].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1354">                    /* found non-terminal N(+)(IV) */</a>
<a name="ln1355">                    if ( (!type || 10 == type) &amp;&amp; 0 &lt; num_N_plus &amp;&amp; 0 &lt; num_C_minus ) {</a>
<a name="ln1356">                        int num_neigh = 0, pos_neigh = -1;</a>
<a name="ln1357">                        for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1358">                            n = at[i].neighbor[i1];</a>
<a name="ln1359">                            if ( -1 == at[n].charge &amp;&amp; 3 &gt;= at[n].valence &amp;&amp; 3 == at[n].chem_bonds_valence+NUMH(at,n) &amp;&amp;</a>
<a name="ln1360">                                  /*0 == at[n].num_H &amp;&amp;*/</a>
<a name="ln1361">                                  at[i].bond_type[i1] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1362">                                  NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1363">                                /* found N(+)(IV)-C(-)(III); prepare conversion to N(V)=C(IV) */</a>
<a name="ln1364">                                num_neigh ++;</a>
<a name="ln1365">                                pos_neigh = i1;</a>
<a name="ln1366">                            }</a>
<a name="ln1367">                        }</a>
<a name="ln1368">                        i1=pos_neigh;</a>
<a name="ln1369">                        if ( 1 == num_neigh &amp;&amp;</a>
<a name="ln1370">                             at[i].bond_type[i1] &lt;= BOND_TYPE_TRIPLE &amp;&amp;</a>
<a name="ln1371">                             !has_other_ion_neigh( at, i, n=at[i].neighbor[i1], en, ne ) &amp;&amp;</a>
<a name="ln1372">                             !has_other_ion_neigh( at, n, i, en, ne )) {</a>
<a name="ln1373">                            /*n = at[i].neighbor[i1=pos_neigh];*/</a>
<a name="ln1374">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1375">                            at[i].charge --;</a>
<a name="ln1376">                            at[n].charge ++;</a>
<a name="ln1377">                            at[i].chem_bonds_valence ++;</a>
<a name="ln1378">                            at[n].chem_bonds_valence ++;</a>
<a name="ln1379">                            at[i].bond_type[i1] ++;</a>
<a name="ln1380">                            at[n].bond_type[i2] ++;</a>
<a name="ln1381">                            num_changes ++;</a>
<a name="ln1382">                            num_C_minus --;</a>
<a name="ln1383">                            num_N_plus --;</a>
<a name="ln1384">                            num_All -= 2;</a>
<a name="ln1385">                            continue;</a>
<a name="ln1386">                        }</a>
<a name="ln1387">                    }</a>
<a name="ln1388">                    if ( (!type || 11 == type) &amp;&amp; 0 &lt; num_N_plus &amp;&amp; 0 &lt; num_C_minus ) {</a>
<a name="ln1389">                        int num_neigh = 0, pos_neigh = -1;</a>
<a name="ln1390">                        for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1391">                            n = at[i].neighbor[i1];</a>
<a name="ln1392">                            if ( -1 == at[n].charge &amp;&amp; 3 &gt;= at[n].valence &amp;&amp; 3 == at[n].chem_bonds_valence+NUMH(at,n) &amp;&amp;</a>
<a name="ln1393">                                  /*0 == at[n].num_H &amp;&amp;*/</a>
<a name="ln1394">                                  at[i].bond_type[i1] == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1395">                                  NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1396">                                /* found N(+)(IV)=C(-)(III); prepare conversion to N(V)#C(IV) */</a>
<a name="ln1397">                                num_neigh ++;</a>
<a name="ln1398">                                pos_neigh = i1;</a>
<a name="ln1399">                            }</a>
<a name="ln1400">                        }</a>
<a name="ln1401">                        if ( 1 == num_neigh  &amp;&amp;</a>
<a name="ln1402">                             !has_other_ion_neigh( at, i, n=at[i].neighbor[i1=pos_neigh], en, ne ) &amp;&amp;</a>
<a name="ln1403">                             !has_other_ion_neigh( at, n, i, en, ne )) {</a>
<a name="ln1404">                            /*n = at[i].neighbor[i1=pos_neigh];*/</a>
<a name="ln1405">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1406">                            at[i].charge --;</a>
<a name="ln1407">                            at[n].charge ++;</a>
<a name="ln1408">                            at[i].chem_bonds_valence ++;</a>
<a name="ln1409">                            at[n].chem_bonds_valence ++;</a>
<a name="ln1410">                            at[i].bond_type[i1] ++;</a>
<a name="ln1411">                            at[n].bond_type[i2] ++;</a>
<a name="ln1412">                            num_changes ++;</a>
<a name="ln1413">                            num_C_minus --;</a>
<a name="ln1414">                            num_N_plus --;</a>
<a name="ln1415">                            num_All -= 2;</a>
<a name="ln1416">                            continue;</a>
<a name="ln1417">                        }</a>
<a name="ln1418">                    }</a>
<a name="ln1419">                    if ( !type || (12 == type &amp;&amp; 0 &lt; num_N_plus &amp;&amp; 0 &lt; num_N_minus) ) {</a>
<a name="ln1420">                        int num_neigh = 0, pos_neigh = -1;</a>
<a name="ln1421">                        for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1422">                            n = at[i].neighbor[i1];</a>
<a name="ln1423">                            if ( -1 == at[n].charge &amp;&amp; 2 &gt;= nNoMetalNumBonds(at, n) &amp;&amp;</a>
<a name="ln1424">                                  2 == nNoMetalBondsValence(at, n)+NUMH(at, n) &amp;&amp;</a>
<a name="ln1425">                                  /*0 == num_of_H( at, n ) &amp;&amp;*/</a>
<a name="ln1426">                                  at[i].bond_type[i1] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1427">                                  NULL != memchr( en+ELEM_N_FST, at[n].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1428">                                /* found N(+)(IV)=N(-)(II); prepare conversion to N(V)#N(III) */</a>
<a name="ln1429">                                num_neigh ++;</a>
<a name="ln1430">                                pos_neigh = i1;</a>
<a name="ln1431">                            }</a>
<a name="ln1432">                        }</a>
<a name="ln1433">                        if ( 1 == num_neigh  &amp;&amp;</a>
<a name="ln1434">                             !has_other_ion_neigh( at, i, n=at[i].neighbor[i1=pos_neigh], en, ne ) &amp;&amp;</a>
<a name="ln1435">                             !has_other_ion_neigh( at, n, i, en, ne )) {</a>
<a name="ln1436">                            /*n = at[i].neighbor[i1=pos_neigh];*/</a>
<a name="ln1437">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1438">                            at[i].charge --;</a>
<a name="ln1439">                            at[n].charge ++;</a>
<a name="ln1440">                            at[i].chem_bonds_valence ++;</a>
<a name="ln1441">                            at[n].chem_bonds_valence ++;</a>
<a name="ln1442">                            at[i].bond_type[i1] ++;</a>
<a name="ln1443">                            at[n].bond_type[i2] ++;</a>
<a name="ln1444">                            num_changes ++;</a>
<a name="ln1445">                            num_N_minus --;</a>
<a name="ln1446">                            num_N_plus --;</a>
<a name="ln1447">                            num_All -= 2;</a>
<a name="ln1448">                            continue;</a>
<a name="ln1449">                        }</a>
<a name="ln1450">                    }</a>
<a name="ln1451">                } else</a>
<a name="ln1452">                if ( 1 == at[i].charge &amp;&amp;</a>
<a name="ln1453">                     0 &lt; num_O_plus &amp;&amp; 0 &lt; num_C_minus + num_N_minus &amp;&amp;</a>
<a name="ln1454">                     3 &gt;= nNoMetalNumBonds(at, i) &amp;&amp; 3 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1455">                     0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1456">                     NULL != memchr( en+ELEM_O_FST, at[i].el_number, ELEM_O_LEN) ) {</a>
<a name="ln1457">                    /* found non-terminal O(+)(III) */</a>
<a name="ln1458">                    if ( (!type || 13 == type) &amp;&amp; 0 &lt; num_C_minus ) {</a>
<a name="ln1459">                        int num_neigh = 0, pos_neigh = -1;</a>
<a name="ln1460">                        for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1461">                            n = at[i].neighbor[i1];</a>
<a name="ln1462">                            if ( -1 == at[n].charge &amp;&amp; 3 &gt;= at[n].valence &amp;&amp; 3 == at[n].chem_bonds_valence+NUMH(at,n) &amp;&amp;</a>
<a name="ln1463">                                  /*0 == at[n].num_H &amp;&amp;*/</a>
<a name="ln1464">                                  at[i].bond_type[i1] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1465">                                  NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1466">                                /* found O(+)(III)-C(-)(II); prepare conversion to O(IV)=C(IV) */</a>
<a name="ln1467">                                num_neigh ++;</a>
<a name="ln1468">                                pos_neigh = i1;</a>
<a name="ln1469">                            }</a>
<a name="ln1470">                        }</a>
<a name="ln1471">                        if ( 1 == num_neigh  &amp;&amp;</a>
<a name="ln1472">                             !has_other_ion_neigh( at, i, n=at[i].neighbor[i1=pos_neigh], en, ne ) &amp;&amp;</a>
<a name="ln1473">                             !has_other_ion_neigh( at, n, i, en, ne )) {</a>
<a name="ln1474">                            /*n = at[i].neighbor[i1=pos_neigh];*/</a>
<a name="ln1475">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1476">                            at[i].charge --;</a>
<a name="ln1477">                            at[n].charge ++;</a>
<a name="ln1478">                            at[i].chem_bonds_valence ++;</a>
<a name="ln1479">                            at[n].chem_bonds_valence ++;</a>
<a name="ln1480">                            at[i].bond_type[i1] ++;</a>
<a name="ln1481">                            at[n].bond_type[i2] ++;</a>
<a name="ln1482">                            num_changes ++;</a>
<a name="ln1483">                            num_C_minus --;</a>
<a name="ln1484">                            num_O_plus --;</a>
<a name="ln1485">                            num_All -= 2;</a>
<a name="ln1486">                            continue;</a>
<a name="ln1487">                        }</a>
<a name="ln1488">                    }</a>
<a name="ln1489">                    if ( (!type || 14 == type) &amp;&amp; 0 &lt; num_C_minus ) {</a>
<a name="ln1490">                        int num_neigh = 0, pos_neigh = -1;</a>
<a name="ln1491">                        for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1492">                            n = at[i].neighbor[i1];</a>
<a name="ln1493">                            if ( -1 == at[n].charge &amp;&amp; 3 &gt;= at[n].valence &amp;&amp; 3 == at[n].chem_bonds_valence+NUMH(at,n) &amp;&amp;</a>
<a name="ln1494">                                  /*0 == at[n].num_H &amp;&amp;*/</a>
<a name="ln1495">                                  at[i].bond_type[i1] == BOND_TYPE_DOUBLE &amp;&amp;</a>
<a name="ln1496">                                  NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1497">                                /* found O(+)(III)=C(-)(III); prepare conversion to O(IV)#C(IV) */</a>
<a name="ln1498">                                num_neigh ++;</a>
<a name="ln1499">                                pos_neigh = i1;</a>
<a name="ln1500">                            }</a>
<a name="ln1501">                        }</a>
<a name="ln1502">                        if ( 1 == num_neigh  &amp;&amp;</a>
<a name="ln1503">                             !has_other_ion_neigh( at, i, n=at[i].neighbor[i1=pos_neigh], en, ne ) &amp;&amp;</a>
<a name="ln1504">                             !has_other_ion_neigh( at, n, i, en, ne )) {</a>
<a name="ln1505">                            /*n = at[i].neighbor[i1=pos_neigh];*/</a>
<a name="ln1506">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1507">                            at[i].charge --;</a>
<a name="ln1508">                            at[n].charge ++;</a>
<a name="ln1509">                            at[i].chem_bonds_valence ++;</a>
<a name="ln1510">                            at[n].chem_bonds_valence ++;</a>
<a name="ln1511">                            at[i].bond_type[i1] ++;</a>
<a name="ln1512">                            at[n].bond_type[i2] ++;</a>
<a name="ln1513">                            num_changes ++;</a>
<a name="ln1514">                            num_C_minus --;</a>
<a name="ln1515">                            num_O_plus --;</a>
<a name="ln1516">                            num_All -= 2;</a>
<a name="ln1517">                            continue;</a>
<a name="ln1518">                        }</a>
<a name="ln1519">                    }</a>
<a name="ln1520">                    if ( (!type || 15 == type) &amp;&amp; 0 &lt; num_N_minus ) {</a>
<a name="ln1521">                        int num_neigh = 0, pos_neigh = -1;</a>
<a name="ln1522">                        for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1523">                            n = at[i].neighbor[i1];</a>
<a name="ln1524">                            if ( -1 == at[n].charge &amp;&amp; 2 &gt;= nNoMetalNumBonds(at, n) &amp;&amp;</a>
<a name="ln1525">                                  2 == nNoMetalBondsValence(at, n)+NUMH(at, n) &amp;&amp;</a>
<a name="ln1526">                                  /*0 == num_of_H( at, n ) &amp;&amp;*/</a>
<a name="ln1527">                                  at[i].bond_type[i1] == BOND_TYPE_SINGLE &amp;&amp;</a>
<a name="ln1528">                                  NULL != memchr( en+ELEM_N_FST, at[n].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1529">                                /* found O(+)(III)=N(-)(II); prepare conversion to O(IV)#N(III) */</a>
<a name="ln1530">                                num_neigh ++;</a>
<a name="ln1531">                                pos_neigh = i1;</a>
<a name="ln1532">                            }</a>
<a name="ln1533">                        }</a>
<a name="ln1534">                        if ( 1 == num_neigh  &amp;&amp;</a>
<a name="ln1535">                             !has_other_ion_neigh( at, i, n=at[i].neighbor[i1=pos_neigh], en, ne ) &amp;&amp;</a>
<a name="ln1536">                             !has_other_ion_neigh( at, n, i, en, ne )) {</a>
<a name="ln1537">                            /*n = at[i].neighbor[i1=pos_neigh];*/</a>
<a name="ln1538">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1539">                            at[i].charge --;</a>
<a name="ln1540">                            at[n].charge ++;</a>
<a name="ln1541">                            at[i].chem_bonds_valence ++;</a>
<a name="ln1542">                            at[n].chem_bonds_valence ++;</a>
<a name="ln1543">                            at[i].bond_type[i1] ++;</a>
<a name="ln1544">                            at[n].bond_type[i2] ++;</a>
<a name="ln1545">                            num_changes ++;</a>
<a name="ln1546">                            num_N_minus --;</a>
<a name="ln1547">                            num_O_plus --;</a>
<a name="ln1548">                            num_All -= 2;</a>
<a name="ln1549">                            continue;</a>
<a name="ln1550">                        }</a>
<a name="ln1551">                    }</a>
<a name="ln1552">                }</a>
<a name="ln1553">            }</a>
<a name="ln1554">        }</a>
<a name="ln1555">        /**************************************************************************/</a>
<a name="ln1556">        /*********************** NON-Terminal ion triples *************************/</a>
<a name="ln1557">        /**************************************************************************/</a>
<a name="ln1558">        /*-------------------------------------------------------------------------</a>
<a name="ln1559">           Non-Terminal triple types: 16, 17, 18   N=N,P,As,Sb; O=O,S,Se,Te; C=C,Si</a>
<a name="ln1560">           ========================================</a>
<a name="ln1561">          16: C(+)(III)-O-N(-)(II)  =&gt; C(IV)=O=N(III)  (allow terminal H on N(-))</a>
<a name="ln1562"> </a>
<a name="ln1563">                        |                     |      </a>
<a name="ln1564">          17: C(+)(III)-N-C(-)(III)  =&gt; C(IV)=N=C(IV)</a>
<a name="ln1565"> </a>
<a name="ln1566">          18: C(-)(III)-N=C(+)(III)  =&gt; C(IV)=N#C(IV)   (may have two or no charges)</a>
<a name="ln1567">              C(IV)=N-C(II)          =&gt; C(IV)=N#C(IV)</a>
<a name="ln1568"> </a>
<a name="ln1569">        */</a>
<a name="ln1570">        if ( (!type || 16 == type) &amp;&amp; 0 &lt; num_C_plus &amp;&amp; 0 &lt; num_N_minus ) {</a>
<a name="ln1571">            int m[2], j[2], k;</a>
<a name="ln1572">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1573">                if ( 0 == at[i].charge &amp;&amp; 2 == nNoMetalNumBonds(at, i) &amp;&amp; 2 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1574">                     0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1575">                     0 &lt;= (j[0] = nNoMetalNeighIndex( at, i )) &amp;&amp;</a>
<a name="ln1576">                     at[m[0]=at[i].neighbor[j[0]]].charge &amp;&amp;</a>
<a name="ln1577">                     0 &lt;= (j[1] = nNoMetalOtherNeighIndex( at, i, m[0] )) &amp;&amp;</a>
<a name="ln1578">                     0 == at[m[0]].charge + at[m[1]=at[i].neighbor[j[1]]].charge &amp;&amp;</a>
<a name="ln1579">                     5 &gt;= nNoMetalBondsValence(at, m[0]) + nNoMetalBondsValence(at, m[1]) &amp;&amp;</a>
<a name="ln1580">                     /*5 &gt;= at[m[0]].chem_bonds_valence + at[m[1]].chem_bonds_valence &amp;&amp;*/</a>
<a name="ln1581">                     NULL != memchr( en+ELEM_O_FST, at[i].el_number, ELEM_O_LEN) ) {</a>
<a name="ln1582">                    /* found non-terminal A(+)-O-B(-); chem_bond_val of A+B &lt;= 5 */</a>
<a name="ln1583">                    int n_N=-1, n_C=-1, i_C=-1;</a>
<a name="ln1584">                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1585">                        n = m[k];</a>
<a name="ln1586">                        if ( -1 == at[n].charge &amp;&amp; 2 == nNoMetalNumBonds(at, n)+NUMH(at, n) &amp;&amp;</a>
<a name="ln1587">                             /*0 == num_of_H( at, n ) &amp;&amp;*/</a>
<a name="ln1588">                             NULL != memchr( en+ELEM_N_FST, at[n].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1589">                            n_N = n;</a>
<a name="ln1590">                        } else</a>
<a name="ln1591">                        if ( 1 == at[n].charge &amp;&amp; 3 == at[n].chem_bonds_valence+NUMH(at,n) &amp;&amp;</a>
<a name="ln1592">                             NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1593">                            n_C = n;</a>
<a name="ln1594">                            i_C = k;</a>
<a name="ln1595">                        }</a>
<a name="ln1596">                    }</a>
<a name="ln1597">                    if ( n_C &lt; 0 || n_N &lt; 0 ||</a>
<a name="ln1598">                         has_other_ion_in_sphere_2(at, n_C, n_N, en, ne ) ||</a>
<a name="ln1599">                         has_other_ion_in_sphere_2(at, n_N, n_C, en, ne ) ) {</a>
<a name="ln1600">                        continue;</a>
<a name="ln1601">                    }</a>
<a name="ln1602">                    /* C(+)(III)-O-N(-)(II)  =&gt; C(IV)=O=N(III) */</a>
<a name="ln1603">                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1604">                        n  = k? n_C : n_N;</a>
<a name="ln1605">                        i1 = k? j[i_C] : j[1-i_C];</a>
<a name="ln1606">                        i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1607">                        at[i].bond_type[i1] ++;</a>
<a name="ln1608">                        at[n].bond_type[i2] ++;</a>
<a name="ln1609">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1610">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1611">                        at[n].charge += (k? -1:1);</a>
<a name="ln1612">                    }</a>
<a name="ln1613">                    num_changes ++;</a>
<a name="ln1614">                    num_N_minus --;</a>
<a name="ln1615">                    num_C_plus --;</a>
<a name="ln1616">                    num_All -= 2;</a>
<a name="ln1617">                }</a>
<a name="ln1618">            }</a>
<a name="ln1619">        }</a>
<a name="ln1620">        if ( (!type || 17 == type) &amp;&amp; 0 &lt; num_C_plus &amp;&amp; 0 &lt; num_C_minus ) {</a>
<a name="ln1621">            int m[3], c[3], j[3], k;</a>
<a name="ln1622">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1623">                if ( 0 == at[i].charge &amp;&amp; 3 == nNoMetalNumBonds(at, i) &amp;&amp; 3 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1624">                     0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1625">                     0 &lt;= ( j[0] = nNoMetalNeighIndex(at, i) ) &amp;&amp;</a>
<a name="ln1626">                     0 &lt;= ( j[1] = nNoMetalOtherNeighIndex( at, i, m[0] = at[i].neighbor[j[0]] ) ) &amp;&amp;</a>
<a name="ln1627">                     0 &lt;= ( j[2] = nNoMetalOtherNeighIndex2( at, i, m[0], m[1] = at[i].neighbor[j[1]] ) ) &amp;&amp;</a>
<a name="ln1628">                     1 == !(c[0]=at[m[0]].charge) </a>
<a name="ln1629">                        + !(c[1]=at[m[1]].charge)</a>
<a name="ln1630">                        + !(c[2]=at[m[2]=at[i].neighbor[j[2]]].charge) &amp;&amp;</a>
<a name="ln1631">                     0 == c[0] + c[1] + c[2] &amp;&amp;</a>
<a name="ln1632">                     2 == (3== (c[0]? at[m[0]].chem_bonds_valence+NUMH(at,m[0]):0))</a>
<a name="ln1633">                        + (3== (c[1]? at[m[1]].chem_bonds_valence+NUMH(at,m[1]):0))</a>
<a name="ln1634">                        + (3== (c[2]? at[m[2]].chem_bonds_valence+NUMH(at,m[2]):0)) &amp;&amp;</a>
<a name="ln1635">                     NULL != memchr( en+ELEM_N_FST, at[i].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1636">                    /* found non-terminal A(+)-O-B(-) */</a>
<a name="ln1637">                    int n_Cp=-1, n_Cm=-1, i_Cp=-1, i_Cm=-1; /* p = positive, m = negatice ion C */</a>
<a name="ln1638">                    for ( k = 0; k &lt; 3; k ++ ) {</a>
<a name="ln1639">                        if ( c[k] ) {</a>
<a name="ln1640">                            n = m[k];</a>
<a name="ln1641">                            if ( -1 == at[n].charge &amp;&amp;</a>
<a name="ln1642">                                 NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1643">                                n_Cm = n;</a>
<a name="ln1644">                                i_Cm = k;</a>
<a name="ln1645">                            } else</a>
<a name="ln1646">                            if ( 1 == at[n].charge &amp;&amp;</a>
<a name="ln1647">                                 NULL != memchr( en+ELEM_C_FST, at[n].el_number, ELEM_C_LEN) ) {</a>
<a name="ln1648">                                n_Cp = n;</a>
<a name="ln1649">                                i_Cp = k;</a>
<a name="ln1650">                            }</a>
<a name="ln1651">                        }</a>
<a name="ln1652">                    }</a>
<a name="ln1653">                    if ( n_Cp &lt; 0 || n_Cm &lt; 0 ||</a>
<a name="ln1654">                         has_other_ion_in_sphere_2(at, n_Cp, n_Cm, en, ne ) ||</a>
<a name="ln1655">                         has_other_ion_in_sphere_2(at, n_Cm, n_Cp, en, ne )) {</a>
<a name="ln1656">                        continue;</a>
<a name="ln1657">                    }</a>
<a name="ln1658">                    /*           |                     |       */</a>
<a name="ln1659">                    /* C(+)(III)-N-C(-)(III)  =&gt; C(IV)=N=C(IV) */</a>
<a name="ln1660">                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1661">                        n  = k? n_Cp : n_Cm;</a>
<a name="ln1662">                        i1 = k? j[i_Cp] : j[i_Cm];</a>
<a name="ln1663">                        i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1664">                        at[i].bond_type[i1] ++;</a>
<a name="ln1665">                        at[n].bond_type[i2] ++;</a>
<a name="ln1666">                        at[i].chem_bonds_valence ++;</a>
<a name="ln1667">                        at[n].chem_bonds_valence ++;</a>
<a name="ln1668">                        at[n].charge += (k? -1:1);</a>
<a name="ln1669">                    }</a>
<a name="ln1670">                    num_changes ++;</a>
<a name="ln1671">                    num_C_minus --;</a>
<a name="ln1672">                    num_C_plus --;</a>
<a name="ln1673">                    num_All -= 2;</a>
<a name="ln1674">                }</a>
<a name="ln1675">            }</a>
<a name="ln1676">        }</a>
<a name="ln1677">        if ( (!type || 18 == type) &amp;&amp; ((0 &lt; num_C_plus &amp;&amp; 0 &lt; num_C_minus) || 0 &lt; num_C_II) ) {</a>
<a name="ln1678">            int m[2], v[2], j[2], k;</a>
<a name="ln1679">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1680">                if ( 0 == at[i].charge &amp;&amp; 2 == nNoMetalNumBonds(at, i) &amp;&amp; 3 == nNoMetalBondsValence(at, i) &amp;&amp;</a>
<a name="ln1681">                     0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1682">                     0 &lt;= (j[0] = nNoMetalNeighIndex( at, i )) &amp;&amp;</a>
<a name="ln1683">                     0 &lt;= (j[1] = nNoMetalOtherNeighIndex( at, i, m[0] = at[i].neighbor[j[0]] )) &amp;&amp;</a>
<a name="ln1684">                     0 == at[m[0]].charge</a>
<a name="ln1685">                         +at[m[1]=at[i].neighbor[j[1]]].charge &amp;&amp;</a>
<a name="ln1686">                     6 == (v[0]=at[m[0]].chem_bonds_valence+NUMH(at,m[0]))</a>
<a name="ln1687">                         +(v[1]=at[m[1]].chem_bonds_valence+NUMH(at,m[1])) &amp;&amp;</a>
<a name="ln1688">                     2 &gt;= abs(v[0]-v[1]) &amp;&amp;</a>
<a name="ln1689">                     NULL != memchr( en+ELEM_N_FST, at[i].el_number, ELEM_N_LEN) &amp;&amp;</a>
<a name="ln1690">                     NULL != memchr( en+ELEM_C_FST, at[m[0]].el_number, ELEM_C_LEN) &amp;&amp;</a>
<a name="ln1691">                     NULL != memchr( en+ELEM_C_FST, at[m[1]].el_number, ELEM_C_LEN)</a>
<a name="ln1692">                    ) {</a>
<a name="ln1693">                    /*                    n_Cm      i n_Cp */</a>
<a name="ln1694">                    /* found non-terminal C(-)(III)-N=C(+)(III) or C(IV)=N-C(II): Cm-N-Cp */</a>
<a name="ln1695">                    /* convert to C(IV)=N#C(IV) */</a>
<a name="ln1696">                    int n_Cp=-1, n_Cm=-1, i_Cp=-1, i_Cm=-1; /* p = positive, m = negatice ion C */</a>
<a name="ln1697">                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1698">                        n = m[k];</a>
<a name="ln1699">                        if ( v[k] == 4 || (v[k] == 3 &amp;&amp; at[i].bond_type[j[k]] == BOND_TYPE_SINGLE) ) {</a>
<a name="ln1700">                            n_Cm = n;</a>
<a name="ln1701">                            i_Cm = k;</a>
<a name="ln1702">                        } else</a>
<a name="ln1703">                        if ( v[k] == 2 || (v[k] == 3 &amp;&amp; at[i].bond_type[j[k]] == BOND_TYPE_DOUBLE) ) {</a>
<a name="ln1704">                            n_Cp = n;</a>
<a name="ln1705">                            i_Cp = k;</a>
<a name="ln1706">                        }</a>
<a name="ln1707">                    }</a>
<a name="ln1708">                    if ( n_Cp &lt; 0 || n_Cm &lt; 0 || at[n_Cp].valence+NUMH(at,n_Cp) != 2 ) {</a>
<a name="ln1709">                        continue; /* guarantees at[n_Cp].valence &lt;= 2 */</a>
<a name="ln1710">                    }</a>
<a name="ln1711">                    if ( v[i_Cp] == 2 || !at[n_Cp].charge ) {</a>
<a name="ln1712">                        if ( at[n_Cp].valence == 2 ) {</a>
<a name="ln1713">                            /* neighbor of at[n_Cp] opposite to at[i] */</a>
<a name="ln1714">                            k = at[n_Cp].neighbor[at[n_Cp].neighbor[0]==i];</a>
<a name="ln1715">                            if ( NULL != memchr( en+ELEM_N_FST, at[k].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1716">                                continue;</a>
<a name="ln1717">                            }</a>
<a name="ln1718">                        }</a>
<a name="ln1719">                    } else</a>
<a name="ln1720">                    if ( at[n_Cp].charge ) {</a>
<a name="ln1721">                        if ( has_other_ion_in_sphere_2(at, n_Cp, n_Cm, en, ne ) ||</a>
<a name="ln1722">                             has_other_ion_in_sphere_2(at, n_Cm, n_Cp, en, ne )) {</a>
<a name="ln1723">                            continue;</a>
<a name="ln1724">                        }</a>
<a name="ln1725">                    } else {</a>
<a name="ln1726">                        continue; /* unknown case */</a>
<a name="ln1727">                    }</a>
<a name="ln1728">                    /*                                         */</a>
<a name="ln1729">                    /* C(-)(III)-N=C(+)(III)  =&gt; C(IV)=N#C(IV) */</a>
<a name="ln1730">                    /* C(IV)=N-C(II)          =&gt; C(IV)=N#C(IV) */</a>
<a name="ln1731">                    if ( at[n_Cp].charge ) {</a>
<a name="ln1732">                        num_C_minus --;</a>
<a name="ln1733">                        num_C_plus --;</a>
<a name="ln1734">                        num_All -= 2;</a>
<a name="ln1735">                    } else {</a>
<a name="ln1736">                        num_C_II --;</a>
<a name="ln1737">                        num_All --;</a>
<a name="ln1738">                    }</a>
<a name="ln1739">                    </a>
<a name="ln1740">                    for ( k = 0; k &lt; 2; k ++ ) {</a>
<a name="ln1741">                        n  = k? n_Cp : n_Cm;</a>
<a name="ln1742">                        i3 = k? i_Cp : i_Cm; /* added to fix the bug */</a>
<a name="ln1743">                        /*i1 = k? j[i_Cp] : j[i_Cm];*/ /* replaced with next line */</a>
<a name="ln1744">                        i1 = j[i3];</a>
<a name="ln1745">                        if ( v[i3 /*was i1*/] &lt; 4 ) { /* WDI found a bug here: bounds violation */</a>
<a name="ln1746">                            int delta = 4 - v[i3 /*was i1*/];</a>
<a name="ln1747">                            i2 = is_in_the_list( at[n].neighbor, (AT_NUMB)i, at[n].valence ) - at[n].neighbor;</a>
<a name="ln1748">                            at[i].bond_type[i1] += delta;</a>
<a name="ln1749">                            at[n].bond_type[i2] += delta;</a>
<a name="ln1750">                            at[i].chem_bonds_valence += delta;</a>
<a name="ln1751">                            at[n].chem_bonds_valence += delta;</a>
<a name="ln1752">                            at[n].charge = 0;</a>
<a name="ln1753">                            at[n].radical = 0;</a>
<a name="ln1754">                        }</a>
<a name="ln1755">                    }</a>
<a name="ln1756">                    at[i].charge = 0;</a>
<a name="ln1757">                    at[i].radical = 0;</a>
<a name="ln1758">                    num_changes ++;</a>
<a name="ln1759">                }</a>
<a name="ln1760">            }</a>
<a name="ln1761">        }</a>
<a name="ln1762">    }</a>
<a name="ln1763"> </a>
<a name="ln1764">    return num_changes;</a>
<a name="ln1765">}</a>
<a name="ln1766"> </a>
<a name="ln1767">/*#if ( DISCONNECT_SALTS == 1 )*/ /* { */</a>
<a name="ln1768"> </a>
<a name="ln1769"> </a>
<a name="ln1770"> </a>
<a name="ln1771">/*************************************************************************************************/</a>
<a name="ln1772">int RemoveInpAtBond( inp_ATOM *atom, int iat, int k )</a>
<a name="ln1773">{</a>
<a name="ln1774">    int      i, j, m, m2, k2;</a>
<a name="ln1775">    inp_ATOM *at = atom + iat;</a>
<a name="ln1776">    inp_ATOM *at2 = NULL;</a>
<a name="ln1777">    int      val = at-&gt;valence - 1;</a>
<a name="ln1778">    if ( val &gt;= 0 ) {</a>
<a name="ln1779">        int bond = at-&gt;bond_type[k];</a>
<a name="ln1780">        if ( bond &gt; BOND_TYPE_TRIPLE )</a>
<a name="ln1781">            bond = BOND_TYPE_SINGLE; /* added 08-06-2003 */</a>
<a name="ln1782">        </a>
<a name="ln1783">        /* update CML tetrahedral atom parity. */</a>
<a name="ln1784">        if ( at-&gt;p_parity ) {</a>
<a name="ln1785">            for( m = 0; m &lt; MAX_NUM_STEREO_ATOM_NEIGH; m ++ ) {</a>
<a name="ln1786">                if ( at-&gt;p_orig_at_num[m] == at-&gt;orig_at_number ) {</a>
<a name="ln1787">                    at-&gt;p_parity = 0;</a>
<a name="ln1788">                    break; /* only 3 bonds are present; removing one bond removes stereo */</a>
<a name="ln1789">                }</a>
<a name="ln1790">            }</a>
<a name="ln1791">            if ( at-&gt;p_parity /* at-&gt;valence == MAX_NUM_STEREO_ATOM_NEIGH*/ ) {</a>
<a name="ln1792">                for ( m = 0; m &lt; at-&gt;valence; m ++ ) {</a>
<a name="ln1793">                    if ( atom[(int)at-&gt;neighbor[k]].orig_at_number == at-&gt;p_orig_at_num[m] ) {</a>
<a name="ln1794">                        break;</a>
<a name="ln1795">                    }</a>
<a name="ln1796">                }</a>
<a name="ln1797">                if ( m &lt; at-&gt;valence ) {</a>
<a name="ln1798">                    at-&gt;p_orig_at_num[m] = at-&gt;orig_at_number;</a>
<a name="ln1799">                } else {</a>
<a name="ln1800">                    at-&gt;p_parity = 0; /* wrong neighbors: at-&gt;neighbor[k] is not in the list of a stereo neighbors */</a>
<a name="ln1801">                }</a>
<a name="ln1802">            }</a>
<a name="ln1803">        }</a>
<a name="ln1804">        </a>
<a name="ln1805">        /* update CML stereogenic bond parities; at this point no removed explicit H exist yet */</a>
<a name="ln1806">        if ( at-&gt;sb_parity[0] ) {</a>
<a name="ln1807">            for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at-&gt;sb_parity[m]; ) {</a>
<a name="ln1808">                if ( k == at-&gt;sb_ord[m] || (k == at-&gt;sn_ord[m] &amp;&amp; val &lt; 2 &amp;&amp; ATOM_PARITY_WELL_DEF(at-&gt;sb_parity[m])) ) {</a>
<a name="ln1809">                    /* !!! FLAW: does take into account removed H !!! */</a>
<a name="ln1810">                    /* stereogenic bond is being removed OR */</a>
<a name="ln1811">                    /* remove stereogenic bond because its only neighbor is being removed */</a>
<a name="ln1812">                    int pnxt_atom, pinxt2cur, pinxt_sb_parity_ord;</a>
<a name="ln1813">                    int len= get_opposite_sb_atom( atom, iat, at-&gt;sb_ord[m], &amp;pnxt_atom, &amp;pinxt2cur, &amp;pinxt_sb_parity_ord );</a>
<a name="ln1814">                    if ( len ) {</a>
<a name="ln1815">                        i   = pinxt_sb_parity_ord;</a>
<a name="ln1816">                        at2 = atom + pnxt_atom;</a>
<a name="ln1817">                        k2  = pinxt2cur;</a>
<a name="ln1818">                    } else {</a>
<a name="ln1819">                        i = MAX_NUM_STEREO_BONDS;</a>
<a name="ln1820">                    }</a>
<a name="ln1821">                    /*</a>
<a name="ln1822">                    at2 = atom + at-&gt;neighbor[ (int)at-&gt;sb_ord[m] ];</a>
<a name="ln1823">                    for ( i = 0; i &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at2-&gt;sb_parity[i]; i ++ ) {</a>
<a name="ln1824">                        if ( iat == at2-&gt;neighbor[ (int)at2-&gt;sb_ord[i] ] )</a>
<a name="ln1825">                            break;</a>
<a name="ln1826">                    }</a>
<a name="ln1827">                    */</a>
<a name="ln1828">                    if ( i &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at2-&gt;sb_parity[i] ) {</a>
<a name="ln1829">                        m2 = i;</a>
<a name="ln1830">                        /* remove bond parity from at */</a>
<a name="ln1831">                        if ( m &lt; MAX_NUM_STEREO_BONDS-1 ) {</a>
<a name="ln1832">                            memmove( at-&gt;sb_parity+m, at-&gt;sb_parity+m+1, (MAX_NUM_STEREO_BONDS-1 - m) * sizeof(at-&gt;sb_parity[0]));</a>
<a name="ln1833">                            memmove( at-&gt;sb_ord+m, at-&gt;sb_ord+m+1, (MAX_NUM_STEREO_BONDS-1 - m) * sizeof(at-&gt;sb_ord[0]));</a>
<a name="ln1834">                            memmove( at-&gt;sn_ord+m, at-&gt;sn_ord+m+1, (MAX_NUM_STEREO_BONDS-1 - m) * sizeof(at-&gt;sn_ord[0]));</a>
<a name="ln1835">                            memmove( at-&gt;sn_orig_at_num+m, at-&gt;sn_orig_at_num+m+1, (MAX_NUM_STEREO_BONDS-1 - m) * sizeof(at-&gt;sn_orig_at_num[0]));</a>
<a name="ln1836">                        }</a>
<a name="ln1837">                        at-&gt;sb_parity[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1838">                        at-&gt;sb_ord[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1839">                        at-&gt;sn_ord[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1840">                        at-&gt;sn_orig_at_num[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1841">                        /* remove bond parity from at2 */</a>
<a name="ln1842">                        if ( m2 &lt; MAX_NUM_STEREO_BONDS-1 ) {</a>
<a name="ln1843">                            memmove( at2-&gt;sb_parity+m2, at2-&gt;sb_parity+m2+1, (MAX_NUM_STEREO_BONDS-1 - m2) * sizeof(at2-&gt;sb_parity[0]));</a>
<a name="ln1844">                            memmove( at2-&gt;sb_ord+m2, at2-&gt;sb_ord+m2+1, (MAX_NUM_STEREO_BONDS-1 - m2) * sizeof(at2-&gt;sb_ord[0]));</a>
<a name="ln1845">                            memmove( at2-&gt;sn_ord+m2, at2-&gt;sn_ord+m2+1, (MAX_NUM_STEREO_BONDS-1 - m2) * sizeof(at2-&gt;sn_ord[0]));</a>
<a name="ln1846">                            memmove( at2-&gt;sn_orig_at_num+m2, at2-&gt;sn_orig_at_num+m2+1, (MAX_NUM_STEREO_BONDS-1 - m2) * sizeof(at2-&gt;sn_orig_at_num[0]));</a>
<a name="ln1847">                        }</a>
<a name="ln1848">                        at2-&gt;sb_parity[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1849">                        at2-&gt;sb_ord[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1850">                        at2-&gt;sn_ord[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1851">                        at2-&gt;sn_orig_at_num[MAX_NUM_STEREO_BONDS-1] = 0;</a>
<a name="ln1852">                        /* do not increment m here because the array elements have been shifted */</a>
<a name="ln1853">                    } else {</a>
<a name="ln1854">                        m ++; /* program error: inconsistent stereobond parity */</a>
<a name="ln1855">                    }</a>
<a name="ln1856">                } else</a>
<a name="ln1857">                if ( k == at-&gt;sn_ord[m] ) {</a>
<a name="ln1858">                    /* stereogenic bond neighbor is being removed; another neighbor remains */</a>
<a name="ln1859">                    /* !!! FLAW: does take into account removed H !!! */</a>
<a name="ln1860">                    for ( j = 0, i = -1; j &lt; at-&gt;valence; j ++ ) {</a>
<a name="ln1861">                        if ( j != k &amp;&amp; j != at-&gt;sb_ord[m] ) {</a>
<a name="ln1862">                            i = j;</a>
<a name="ln1863">                            break;</a>
<a name="ln1864">                        }</a>
<a name="ln1865">                    }</a>
<a name="ln1866">                    /* i is the position of the neighbor that will become a new neighbor */</a>
<a name="ln1867">                    /***************************************************************************</a>
<a name="ln1868">                     *  at-&gt;sb_parity[m] is the direction (EVEN=clockwise, ODD=counterclockwise)</a>
<a name="ln1869">                     *  from stereobond to the neighbor. If the neighbor is removed then</a>
<a name="ln1870">                     *  the parity should invert, otherwise it should be unchanged.</a>
<a name="ln1871">                     ***************************************************************************/</a>
<a name="ln1872">                    if ( i &lt; 0 ) {</a>
<a name="ln1873">                        /* no alternative neighbor is available */</a>
<a name="ln1874">                        if ( ATOM_PARITY_WELL_DEF(at-&gt;sb_parity[m] ) ) {</a>
<a name="ln1875">                            /* parity cannot be not well-defined anymore */</a>
<a name="ln1876">                            int pnxt_atom, pinxt2cur, pinxt_sb_parity_ord;</a>
<a name="ln1877">                            int len= get_opposite_sb_atom( atom, iat, at-&gt;sb_ord[m], &amp;pnxt_atom, &amp;pinxt2cur, &amp;pinxt_sb_parity_ord );</a>
<a name="ln1878">                            if ( len &gt; 0 ) {</a>
<a name="ln1879">                                atom[pnxt_atom].sb_parity[pinxt_sb_parity_ord] = at-&gt;sb_parity[m] = AB_PARITY_UNDF;</a>
<a name="ln1880">                            }</a>
<a name="ln1881">#ifdef _DEBUG</a>
<a name="ln1882">                            else {</a>
<a name="ln1883">                                int stop = 1; /* sb parities error */</a>
<a name="ln1884">                            }</a>
<a name="ln1885">#endif</a>
<a name="ln1886">                        }</a>
<a name="ln1887">                        at-&gt;sn_ord[m]         = -99; /* sb neighbor has been disconnected */</a>
<a name="ln1888">                        at-&gt;sb_ord[m]        -= (at-&gt;sb_ord[m] &gt; k); /* same as above */</a>
<a name="ln1889">                        at-&gt;sn_orig_at_num[m] = 0;</a>
<a name="ln1890">                    } else</a>
<a name="ln1891">                    if ( i &lt; at-&gt;valence ) {</a>
<a name="ln1892">                        /* choose another stereogenic bond neighbor, its ord. number is i before bond removal */</a>
<a name="ln1893">                        if ( ATOM_PARITY_WELL_DEF(at-&gt;sb_parity[m]) ) {</a>
<a name="ln1894">                            /* ALL WRONG: 'move' previous stereo bond neighbor to the last position (pos. 2 out of 0,1,2) */</a>
<a name="ln1895">                            /* the parity of the transpositions is (2 - at-&gt;sn_ord[m])%2 = at-&gt;sn_ord[m] % 2 */</a>
<a name="ln1896">                            /* and replace the neighbor with another; the contribution to the parity is 1 */</a>
<a name="ln1897">                            </a>
<a name="ln1898">                            /*at-&gt;sb_parity[m]      =  2 - ( at-&gt;sb_parity[m] + at-&gt;sn_ord[m] + 1 ) % 2;*/</a>
<a name="ln1899">                            </a>
<a name="ln1900">                            /*at-&gt;sb_parity[m]      =  2 - ( at-&gt;sb_parity[m] + k + i +</a>
<a name="ln1901">                                                           (i &gt; k) + (i &gt; at-&gt;sb_ord[m]) ) % 2;*/</a>
<a name="ln1902">                            /*=== parity should be INVERTED ===*/</a>
<a name="ln1903">                            at-&gt;sb_parity[m] = 3 - at-&gt;sb_parity[m];</a>
<a name="ln1904">                        }</a>
<a name="ln1905">                        at-&gt;sn_ord[m]         = i - (i &gt; k); /* ord. number shifted because preceding bond is removed */</a>
<a name="ln1906">                        at-&gt;sb_ord[m]        -= (at-&gt;sb_ord[m] &gt; k); /* same as above */</a>
<a name="ln1907">                        at-&gt;sn_orig_at_num[m] = atom[(int)at-&gt;neighbor[i]].orig_at_number;</a>
<a name="ln1908">                        /*at-&gt;sb_parity[m]      =  2 - ( at-&gt;sb_parity[m] + 1 ) % 2;*/</a>
<a name="ln1909">                    } else {</a>
<a name="ln1910">                        at-&gt;sb_parity[m] = 0; /* program error: inconsistent stereobond parity */</a>
<a name="ln1911">                    }</a>
<a name="ln1912">                    m ++;</a>
<a name="ln1913">                } else {</a>
<a name="ln1914">                    /* removing another neighbor, k: first move it to the last position (pos. 2 out of 0,1,2) */</a>
<a name="ln1915">                    if ( k &lt; 2 &amp;&amp; ATOM_PARITY_WELL_DEF(at-&gt;sb_parity[m]) ) {</a>
<a name="ln1916">                        /*at-&gt;sb_parity[m] =  2 - ( at-&gt;sb_parity[m] + k ) % 2;*/</a>
<a name="ln1917">                        /*at-&gt;sb_parity[m] =  2 - ( at-&gt;sb_parity[m] + (at-&gt;sn_ord[m] &gt; k) + (at-&gt;sb_ord[m] &gt; k) ) % 2;*/</a>
<a name="ln1918">                        ;/*==== Parity should remain UNCHANGED ===*/</a>
<a name="ln1919">                    }</a>
<a name="ln1920">                    if ( at-&gt;sb_ord[m] &gt; k ) {</a>
<a name="ln1921">                        at-&gt;sb_ord[m] --;</a>
<a name="ln1922">                    }</a>
<a name="ln1923">                    if ( at-&gt;sn_ord[m] &gt; k ) {</a>
<a name="ln1924">                        at-&gt;sn_ord[m] --;</a>
<a name="ln1925">                    }</a>
<a name="ln1926">                    m ++;</a>
<a name="ln1927">                }</a>
<a name="ln1928">            }</a>
<a name="ln1929">        }</a>
<a name="ln1930"> </a>
<a name="ln1931">        if ( k &lt; val ) {</a>
<a name="ln1932">            memmove( at-&gt;neighbor+k, at-&gt;neighbor+k+1, sizeof(at-&gt;neighbor[0])*(val-k) );</a>
<a name="ln1933">            memmove( at-&gt;bond_stereo+k, at-&gt;bond_stereo+k+1, sizeof(at-&gt;bond_stereo[0])*(val-k) );</a>
<a name="ln1934">            memmove( at-&gt;bond_type+k, at-&gt;bond_type+k+1, sizeof(at-&gt;bond_type[0])*(val-k) );</a>
<a name="ln1935">        }</a>
<a name="ln1936">        at-&gt;neighbor[val]    = 0;</a>
<a name="ln1937">        at-&gt;bond_stereo[val] = 0;</a>
<a name="ln1938">        at-&gt;bond_type[val]   = 0;</a>
<a name="ln1939">        at-&gt;valence = val;</a>
<a name="ln1940">        at-&gt;chem_bonds_valence -= bond;</a>
<a name="ln1941">        return 1;</a>
<a name="ln1942">    }</a>
<a name="ln1943">    return 0;</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946"> </a>
<a name="ln1947"> </a>
<a name="ln1948">/*************************************************************************************************/</a>
<a name="ln1949">int DisconnectInpAtBond( inp_ATOM *at, AT_NUMB *nOldCompNumber, int iat, int neigh_ord )</a>
<a name="ln1950">{</a>
<a name="ln1951">    int neigh, i, ret = 0;</a>
<a name="ln1952">    int component;</a>
<a name="ln1953">    neigh = at[iat].neighbor[neigh_ord];</a>
<a name="ln1954">    for ( i = 0; i &lt; at[neigh].valence; i ++ ) {</a>
<a name="ln1955">        if ( iat == (int)at[neigh].neighbor[i] )</a>
<a name="ln1956">            break;</a>
<a name="ln1957">    }</a>
<a name="ln1958">    if ( i &lt; at[neigh].valence ) {</a>
<a name="ln1959">        ret += RemoveInpAtBond( at, iat, neigh_ord );</a>
<a name="ln1960">        ret += RemoveInpAtBond( at, neigh, i );</a>
<a name="ln1961">        if ( nOldCompNumber &amp;&amp; ret ) {</a>
<a name="ln1962">            if ( (component = at[iat].component) ) {</a>
<a name="ln1963">                nOldCompNumber[component-1] = 0;</a>
<a name="ln1964">            }</a>
<a name="ln1965">            if ( (component = at[neigh].component) ) {</a>
<a name="ln1966">                nOldCompNumber[component-1] = 0;</a>
<a name="ln1967">            }</a>
<a name="ln1968">        }</a>
<a name="ln1969">    }</a>
<a name="ln1970">    return (ret == 2);</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973"> </a>
<a name="ln1974"> </a>
<a name="ln1975">/*************************************************************************************************/</a>
<a name="ln1976">int bIsAmmoniumSalt( inp_ATOM *at, int i, int *piO, int *pk, S_CHAR *num_explicit_H ) </a>
<a name="ln1977">{</a>
<a name="ln1978">    /* NH4(+charge)-O(-charge)-C -&gt; NH3 + HO-C; any charge including 0, any C except charged or radical */</a>
<a name="ln1979">    /* F, Cl, Br, I */</a>
<a name="ln1980">    static U_CHAR el_number_C=0, el_number_O=0, el_number_H=0, el_number_N=0;</a>
<a name="ln1981">    static U_CHAR el_number_F=0, el_number_Cl=0, el_number_Br=0, el_number_I=0;</a>
<a name="ln1982">    int num_H, num_non_iso_H, num_impl_iso_H, bDisconnect = 1;</a>
<a name="ln1983">    int j, val, neigh, iO=-1, iC, k=-1;</a>
<a name="ln1984">    if ( 0 == el_number_C ) {</a>
<a name="ln1985">        /* one time initialization */</a>
<a name="ln1986">        el_number_C = get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln1987">        el_number_O = get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln1988">        el_number_H = get_periodic_table_number( &quot;H&quot; );</a>
<a name="ln1989">        el_number_N = get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln1990">        el_number_F = get_periodic_table_number( &quot;F&quot; );</a>
<a name="ln1991">        el_number_Cl= get_periodic_table_number( &quot;Cl&quot; );</a>
<a name="ln1992">        el_number_Br= get_periodic_table_number( &quot;Br&quot; );</a>
<a name="ln1993">        el_number_I = get_periodic_table_number( &quot;I&quot; );</a>
<a name="ln1994">    }</a>
<a name="ln1995">    if ( at[i].el_number != el_number_N )</a>
<a name="ln1996">        return 0;</a>
<a name="ln1997"> </a>
<a name="ln1998">    /* check for NH4-O-C... -&gt; NH3 + HO-C... */</a>
<a name="ln1999">    val            = at[i].valence;</a>
<a name="ln2000">    num_impl_iso_H = NUM_ISO_H(at,i);</a>
<a name="ln2001">    num_non_iso_H  = at[i].num_H;</a>
<a name="ln2002">    num_H = num_non_iso_H + num_impl_iso_H;</a>
<a name="ln2003">    if ( val + num_H == 5 ) {</a>
<a name="ln2004">        int num_O = 0;</a>
<a name="ln2005">        memset( num_explicit_H, 0, (NUM_H_ISOTOPES+1)*sizeof(num_explicit_H[0]) );</a>
<a name="ln2006">        for ( j = 0; j &lt; val; j ++ ) { /* looking for O: H4N-O-C... */</a>
<a name="ln2007">            neigh = at[i].neighbor[j];</a>
<a name="ln2008">            if ( at[neigh].num_H ||</a>
<a name="ln2009">                 (at[neigh].charge &amp;&amp; (at[neigh].el_number != el_number_O || at[neigh].charge + at[i].charge)) ||</a>
<a name="ln2010">                 (at[neigh].radical &amp;&amp; at[neigh].radical != RADICAL_SINGLET) ) {</a>
<a name="ln2011">                bDisconnect = 0;</a>
<a name="ln2012">                break; /* reject */</a>
<a name="ln2013">            }</a>
<a name="ln2014">            if ( at[neigh].el_number == el_number_H &amp;&amp; at[neigh].valence == 1 &amp;&amp;</a>
<a name="ln2015">                 !at[neigh].charge &amp;&amp; !at[neigh].radical ) {</a>
<a name="ln2016">                num_H ++; /* at this point at[].num_H does not include explicit H count */</a>
<a name="ln2017">                num_non_iso_H += (0==at[neigh].iso_atw_diff);</a>
<a name="ln2018">                num_explicit_H[at[neigh].iso_atw_diff] ++;  /* explicit H on N */</a>
<a name="ln2019">            } else</a>
<a name="ln2020">            if ( at[neigh].el_number == el_number_O &amp;&amp; at[neigh].valence == 2 &amp;&amp; !num_O ) {</a>
<a name="ln2021">                num_O ++; /* found O: N-O- */</a>
<a name="ln2022">                iO = neigh;</a>
<a name="ln2023">                k  = j;</a>
<a name="ln2024">                iC = at[iO].neighbor[at[iO].neighbor[0] == i];</a>
<a name="ln2025">                if ( at[iC].el_number != el_number_C || /*</a>
<a name="ln2026">                     at[iC].num_H ||</a>
<a name="ln2027">                     at[iC].chem_bonds_valence != 4 || */</a>
<a name="ln2028">                     at[iC].charge         ||</a>
<a name="ln2029">                     (at[iC].radical &amp;&amp; at[iC].radical != RADICAL_SINGLET) /*||</a>
<a name="ln2030">                     at[iC].valence == at[iC].chem_bonds_valence*/ ) {</a>
<a name="ln2031">                    bDisconnect = 0;</a>
<a name="ln2032">                    break; /* reject */</a>
<a name="ln2033">                }</a>
<a name="ln2034">            } else</a>
<a name="ln2035">            if ( (at[neigh].el_number == el_number_F  ||</a>
<a name="ln2036">                  at[neigh].el_number == el_number_Cl ||</a>
<a name="ln2037">                  at[neigh].el_number == el_number_Br ||</a>
<a name="ln2038">                  at[neigh].el_number == el_number_I ) &amp;&amp;</a>
<a name="ln2039">                  at[neigh].valence == 1 &amp;&amp; at[neigh].chem_bonds_valence == 1 &amp;&amp;</a>
<a name="ln2040">                  !at[neigh].charge &amp;&amp; !NUMH(at,neigh) &amp;&amp; !num_O ) {</a>
<a name="ln2041">                num_O ++; /* found O: N-O- */</a>
<a name="ln2042">                iO = neigh;</a>
<a name="ln2043">                k  = j;</a>
<a name="ln2044">                iC = -1;</a>
<a name="ln2045">            } else {</a>
<a name="ln2046">                bDisconnect = 0;</a>
<a name="ln2047">                break;  /* reject */</a>
<a name="ln2048">            }</a>
<a name="ln2049">        }</a>
<a name="ln2050">        if ( bDisconnect &amp;&amp; (num_O != 1 || num_H != 4) ) {</a>
<a name="ln2051">            bDisconnect = 0; /* reject */</a>
<a name="ln2052">        }</a>
<a name="ln2053">    } else {</a>
<a name="ln2054">        bDisconnect = 0;</a>
<a name="ln2055">    }</a>
<a name="ln2056">    if ( bDisconnect ) {</a>
<a name="ln2057">        *piO = iO;</a>
<a name="ln2058">        *pk  = k;</a>
<a name="ln2059">    }</a>
<a name="ln2060">    return bDisconnect;</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063"> </a>
<a name="ln2064"> </a>
<a name="ln2065">/*************************************************************************************************/</a>
<a name="ln2066">int DisconnectAmmoniumSalt ( inp_ATOM *at, int iN, int iO, int k, S_CHAR *num_explicit_H )</a>
<a name="ln2067">{</a>
<a name="ln2068">    /* disconnect NH4-O from O */</a>
<a name="ln2069">    /* Note: iO = at[iN].neighbor[k], at[iN] is N, at[iO].neighbor[0] is either N=at[iN] or C=at[iC] */</a>
<a name="ln2070">    int nMove_H_iso_diff = -1; /* do not move explicit H */</a>
<a name="ln2071">    int j, neigh, iso_diff, neigh_pos;</a>
<a name="ln2072">    static U_CHAR el_number_H = 0;</a>
<a name="ln2073">    int    val = at[iN].valence;</a>
<a name="ln2074"> </a>
<a name="ln2075">    if ( !el_number_H ) {</a>
<a name="ln2076">        el_number_H = get_periodic_table_number( &quot;H&quot; );</a>
<a name="ln2077">    }</a>
<a name="ln2078">    if ( at[iN].charge &amp;&amp; !(at[iN].charge + at[iO].charge) ) {</a>
<a name="ln2079">        at[iN].charge = at[iO].charge = 0; /* remove charges */</a>
<a name="ln2080">    }</a>
<a name="ln2081">    neigh_pos = (at[iO].valence == 2)? (at[iO].neighbor[1] == iN) : 0; /* position of at[iN] in the neigh list of iO */</a>
<a name="ln2082">    /* disconnect bond O-N */</a>
<a name="ln2083">    RemoveInpAtBond( at, iO, neigh_pos );</a>
<a name="ln2084">    RemoveInpAtBond( at, iN, k );</a>
<a name="ln2085">    val --;</a>
<a name="ln2086"> </a>
<a name="ln2087">    /* move 1 H from NH4 to O- or Cl */</a>
<a name="ln2088"> </a>
<a name="ln2089">    /* find non-isotopic or the lightest isotopic H to move from N to O */</a>
<a name="ln2090">    for ( iso_diff = 0; iso_diff &lt;= NUM_H_ISOTOPES; iso_diff ++ ) {</a>
<a name="ln2091">        if ( !iso_diff ) {</a>
<a name="ln2092">            /* find non-isotopic H */</a>
<a name="ln2093">            if ( at[iN].num_H ) {</a>
<a name="ln2094">                at[iN].num_H --;  /* move non-isotopic implicit H */</a>
<a name="ln2095">                at[iO].num_H ++;</a>
<a name="ln2096">                break;</a>
<a name="ln2097">            } else</a>
<a name="ln2098">            if ( num_explicit_H[0] ) {</a>
<a name="ln2099">                nMove_H_iso_diff = 0; /* flag: move explicit non-isotopic H */</a>
<a name="ln2100">                break;</a>
<a name="ln2101">            }</a>
<a name="ln2102">        } else {</a>
<a name="ln2103">            /* find isotopic H */</a>
<a name="ln2104">            if ( at[iN].num_iso_H[iso_diff] ) {</a>
<a name="ln2105">                at[iN].num_iso_H[iso_diff] --; /* move implicit isotopic H, atw = 1 */</a>
<a name="ln2106">                at[iO].num_iso_H[iso_diff] ++;</a>
<a name="ln2107">                break;</a>
<a name="ln2108">            } else</a>
<a name="ln2109">            if ( num_explicit_H[iso_diff] ) {</a>
<a name="ln2110">                nMove_H_iso_diff = iso_diff; /* flag: move explicit isotopic H, atw = 1 */</a>
<a name="ln2111">                break;</a>
<a name="ln2112">            }</a>
<a name="ln2113">        }</a>
<a name="ln2114">    }</a>
<a name="ln2115">    if ( nMove_H_iso_diff &gt;= 0 ) {</a>
<a name="ln2116">        /* move explicit H, it is isotopic if nMove_H_iso_diff &gt; 0 */</a>
<a name="ln2117">        double dist2_H_O, min_dist2_H_O = -1.0;</a>
<a name="ln2118">        int    jH = -1, iH = -1;</a>
<a name="ln2119">        for ( j = 0; j &lt; val; j ++ ) { /* looking H in N-H such that H-O is shortest */</a>
<a name="ln2120">            neigh = at[iN].neighbor[j];</a>
<a name="ln2121">            if ( at[neigh].el_number    == el_number_H &amp;&amp;</a>
<a name="ln2122">                at[neigh].iso_atw_diff == nMove_H_iso_diff ) {</a>
<a name="ln2123">                dist2_H_O =  (at[neigh].x - at[iO].x) * (at[neigh].x - at[iO].x) +</a>
<a name="ln2124">                             (at[neigh].y - at[iO].y) * (at[neigh].y - at[iO].y) +</a>
<a name="ln2125">                             (at[neigh].z - at[iO].z) * (at[neigh].z - at[iO].z);</a>
<a name="ln2126">                if ( min_dist2_H_O &lt; 0.0 || min_dist2_H_O &gt; dist2_H_O ) {</a>
<a name="ln2127">                    min_dist2_H_O = dist2_H_O;</a>
<a name="ln2128">                    iH = neigh;</a>
<a name="ln2129">                    jH = j;</a>
<a name="ln2130">                }</a>
<a name="ln2131">            }</a>
<a name="ln2132">        }</a>
<a name="ln2133">        /* reconnect; bonds do not need changes except stereo */</a>
<a name="ln2134">        neigh_pos = at[iO].valence;</a>
<a name="ln2135">        at[iO].neighbor[neigh_pos]         = iH;</a>
<a name="ln2136">        at[iO].bond_stereo[neigh_pos]      = 0;</a>
<a name="ln2137">        at[iO].bond_type[neigh_pos]        = at[iH].bond_type[0];</a>
<a name="ln2138">        at[iO].chem_bonds_valence         += at[iH].bond_type[0];</a>
<a name="ln2139">        at[iO].valence ++;</a>
<a name="ln2140">        at[iH].neighbor[0]                 = iO;</a>
<a name="ln2141">        at[iH].bond_stereo[0]              = 0;</a>
<a name="ln2142">        /* disconnect H from N */</a>
<a name="ln2143">        RemoveInpAtBond( at, iN, jH );</a>
<a name="ln2144">        val --;</a>
<a name="ln2145">        if ( k &gt; jH ) {</a>
<a name="ln2146">            k --;</a>
<a name="ln2147">        }</a>
<a name="ln2148">    }</a>
<a name="ln2149">    return 1;</a>
<a name="ln2150">}</a>
<a name="ln2151"> </a>
<a name="ln2152"> </a>
<a name="ln2153"> </a>
<a name="ln2154">/*************************************************************************************************/</a>
<a name="ln2155">int bIsMetalSalt( inp_ATOM *at, int i ) </a>
<a name="ln2156">{</a>
<a name="ln2157">    int type, val, k, iO, iC, j, neigh;</a>
<a name="ln2158">    int bDisconnect = 1;</a>
<a name="ln2159">    static U_CHAR el_number_C=0, el_number_O=0, el_number_H=0;</a>
<a name="ln2160">    static U_CHAR el_number_F=0, el_number_Cl=0, el_number_Br=0, el_number_I=0;</a>
<a name="ln2161">    if ( 0 == el_number_C ) {</a>
<a name="ln2162">        /* one time initialization */</a>
<a name="ln2163">        el_number_C = get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln2164">        el_number_O = get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln2165">        el_number_H = get_periodic_table_number( &quot;H&quot; );</a>
<a name="ln2166">        el_number_F = get_periodic_table_number( &quot;F&quot; );</a>
<a name="ln2167">        el_number_Cl= get_periodic_table_number( &quot;Cl&quot; );</a>
<a name="ln2168">        el_number_Br= get_periodic_table_number( &quot;Br&quot; );</a>
<a name="ln2169">        el_number_I = get_periodic_table_number( &quot;I&quot; );</a>
<a name="ln2170">    }</a>
<a name="ln2171">    /* check for a metal atom:</a>
<a name="ln2172">       metal atom should be connected and be a metal */</a>
<a name="ln2173">    if ( !(val = at[i].valence) ||</a>
<a name="ln2174">         !(type = get_el_type( at[i].el_number )) ||</a>
<a name="ln2175">         !(type &amp; IS_METAL) ) {</a>
<a name="ln2176">        bDisconnect = 0;  /* reject */</a>
<a name="ln2177">    } else</a>
<a name="ln2178">    /* metal atom should not have adjacent H or multiple bonds or radical */</a>
<a name="ln2179">    if ( at[i].num_H ) {</a>
<a name="ln2180">        bDisconnect = 0; /* reject */</a>
<a name="ln2181">    } else</a>
<a name="ln2182">    /* check valence */</a>
<a name="ln2183">    if ( (at[i].charge == 0 &amp;&amp;</a>
<a name="ln2184">         ( ((type &amp; 1) &amp;&amp; val == get_el_valence( at[i].el_number, 0, 0 ))   ||</a>
<a name="ln2185">           ((type &amp; 2) &amp;&amp; val == get_el_valence( at[i].el_number, 0, 1 )) )) ||</a>
<a name="ln2186">         (at[i].charge &gt; 0 &amp;&amp;</a>
<a name="ln2187">         (type &amp; 1) &amp;&amp; val == get_el_valence( at[i].el_number, at[i].charge, 0 )) ) {</a>
<a name="ln2188">        ; /* accept */</a>
<a name="ln2189">    } else {</a>
<a name="ln2190">        bDisconnect = 0; /* reject */</a>
<a name="ln2191">    }</a>
<a name="ln2192">    if ( bDisconnect ) {</a>
<a name="ln2193">        /*************************************************************************</a>
<a name="ln2194">         *                                                                  |    *</a>
<a name="ln2195">         * check M neighbors. Disconnect if all neighbors are M-O-C# or M-O-C=   *</a>
<a name="ln2196">         *                                                                  |    *</a>
<a name="ln2197">         *************************************************************************/</a>
<a name="ln2198">        for ( k = 0; k &lt; at[i].valence; k ++ ) {</a>
<a name="ln2199">            iO = at[i].neighbor[k];</a>
<a name="ln2200">            /* halogenide 2004-07-08 */</a>
<a name="ln2201">            if ( (at[iO].el_number == el_number_F  ||</a>
<a name="ln2202">                  at[iO].el_number == el_number_Cl ||</a>
<a name="ln2203">                  at[iO].el_number == el_number_Br ||</a>
<a name="ln2204">                  at[iO].el_number == el_number_I ) &amp;&amp;</a>
<a name="ln2205">                  at[iO].valence == 1 &amp;&amp; at[iO].chem_bonds_valence == 1 &amp;&amp;</a>
<a name="ln2206">                  !at[iO].charge &amp;&amp; !(at[iO].radical &amp;&amp; at[iO].radical != RADICAL_SINGLET) &amp;&amp; !NUMH(at,iO) ) {</a>
<a name="ln2207">                    ; /* found */</a>
<a name="ln2208">                  } else {</a>
<a name="ln2209">                /* -O-C= */</a>
<a name="ln2210">                if ( at[iO].el_number != el_number_O ||</a>
<a name="ln2211">                    NUMH(at, iO) ||</a>
<a name="ln2212">                    at[iO].valence   != 2 ||</a>
<a name="ln2213">                    at[iO].charge         ||</a>
<a name="ln2214">                    (at[iO].radical &amp;&amp; at[iO].radical != RADICAL_SINGLET) ||</a>
<a name="ln2215">                    at[iO].valence != at[iO].chem_bonds_valence ) {</a>
<a name="ln2216">                    bDisconnect = 0; /* reject */</a>
<a name="ln2217">                    break;</a>
<a name="ln2218">                }</a>
<a name="ln2219">                iC = at[iO].neighbor[at[iO].neighbor[0] == i];</a>
<a name="ln2220">                if ( at[iC].el_number != el_number_C ||</a>
<a name="ln2221">                    at[iC].num_H ||</a>
<a name="ln2222">                    at[iC].chem_bonds_valence != 4 ||</a>
<a name="ln2223">                    at[iC].charge         ||</a>
<a name="ln2224">                    (at[iC].radical &amp;&amp; at[iC].radical != RADICAL_SINGLET) ||</a>
<a name="ln2225">                    at[iC].valence == at[iC].chem_bonds_valence ) {</a>
<a name="ln2226">                    bDisconnect = 0; /* reject */</a>
<a name="ln2227">                    break;</a>
<a name="ln2228">                }</a>
<a name="ln2229">                for ( j = 0; j &lt; at[iC].valence; j ++ ) {</a>
<a name="ln2230">                    neigh = at[iC].neighbor[j];</a>
<a name="ln2231">                    if ( at[neigh].el_number == el_number_H ) {</a>
<a name="ln2232">                        break;</a>
<a name="ln2233">                    }</a>
<a name="ln2234">                }</a>
<a name="ln2235">                if ( j != at[iC].valence ) {</a>
<a name="ln2236">                    bDisconnect = 0; /* reject */</a>
<a name="ln2237">                    break;</a>
<a name="ln2238">                }</a>
<a name="ln2239">            }</a>
<a name="ln2240">        }</a>
<a name="ln2241">    }</a>
<a name="ln2242">    return bDisconnect;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245"> </a>
<a name="ln2246"> </a>
<a name="ln2247">/*************************************************************************************************/</a>
<a name="ln2248">int DisconnectMetalSalt( inp_ATOM *at, int i )</a>
<a name="ln2249">{</a>
<a name="ln2250">    int k, iO;</a>
<a name="ln2251">    /* disconnect metal atom or ion at[i] */</a>
<a name="ln2252">    for ( k = 0; k &lt; at[i].valence; k ++ ) {</a>
<a name="ln2253">        iO = at[i].neighbor[k];</a>
<a name="ln2254">        if ( at[iO].valence == 2 ) {</a>
<a name="ln2255">            if ( at[iO].neighbor[0] == i ) { /* assuming atom O always has 2 bonds */</a>
<a name="ln2256">                /* copy the remaining neighbor to the 0 position */</a>
<a name="ln2257">                at[iO].neighbor[0]    = at[iO].neighbor[1];</a>
<a name="ln2258">                at[iO].bond_stereo[0] = at[iO].bond_stereo[1];</a>
<a name="ln2259">                at[iO].bond_type[0]   = at[iO].bond_type[1];</a>
<a name="ln2260">            }</a>
<a name="ln2261">            /* clear neighbor at position 1 */</a>
<a name="ln2262">            at[iO].neighbor[1]    = 0;</a>
<a name="ln2263">            at[iO].bond_stereo[1] = 0;</a>
<a name="ln2264">            at[iO].bond_type[1]   = 0;</a>
<a name="ln2265">        } else {</a>
<a name="ln2266">            /* clear neighbor at position 1 */</a>
<a name="ln2267">            at[iO].neighbor[0]    = 0;</a>
<a name="ln2268">            at[iO].bond_stereo[0] = 0;</a>
<a name="ln2269">            at[iO].bond_type[0]   = 0;</a>
<a name="ln2270">        }</a>
<a name="ln2271">        /* make O negatively charged */</a>
<a name="ln2272">        at[iO].charge = -1;</a>
<a name="ln2273">        /* reduce O valence to account for the removed single bond */</a>
<a name="ln2274">        at[iO].valence --;</a>
<a name="ln2275">        at[iO].chem_bonds_valence --;</a>
<a name="ln2276"> </a>
<a name="ln2277">        /* clear metal neighbor (O) */</a>
<a name="ln2278">        at[i].neighbor[k]    = 0;</a>
<a name="ln2279">        at[i].bond_stereo[k] = 0;</a>
<a name="ln2280">        at[i].bond_type[k]   = 0;</a>
<a name="ln2281">        /* add a positive charge to the metal */</a>
<a name="ln2282">        at[i].charge ++;</a>
<a name="ln2283">    }</a>
<a name="ln2284">    /* set metal valence to zero because it has been disconnected */</a>
<a name="ln2285">    at[i].valence            = 0;</a>
<a name="ln2286">    at[i].chem_bonds_valence = 0;</a>
<a name="ln2287">    return k;</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290"> </a>
<a name="ln2291"> </a>
<a name="ln2292">/*************************************************************************************************/</a>
<a name="ln2293">int DisconnectSalts( ORIG_ATOM_DATA *orig_inp_data, int bDisconnect )</a>
<a name="ln2294">{</a>
<a name="ln2295">    int i, k, iO, num_changes, val;</a>
<a name="ln2296">    S_CHAR    num_explicit_H[NUM_H_ISOTOPES+1];</a>
<a name="ln2297">    inp_ATOM *at = orig_inp_data-&gt;at;</a>
<a name="ln2298">    int num_at   = orig_inp_data-&gt;num_inp_atoms;</a>
<a name="ln2299"> </a>
<a name="ln2300">    /* check each atom */</a>
<a name="ln2301">    for ( i = 0, num_changes = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2302"> </a>
<a name="ln2303">        if ( !(val = at[i].valence) || /* disconnected atom */</a>
<a name="ln2304">             val != at[i].chem_bonds_valence || /* a bond has higher multiplicity than 1 */</a>
<a name="ln2305">             (at[i].radical &amp;&amp; at[i].radical != RADICAL_SINGLET) /* radical */ ) {</a>
<a name="ln2306">            continue;   /* reject */</a>
<a name="ln2307">        }</a>
<a name="ln2308">        if ( bIsAmmoniumSalt( at, i, &amp;iO, &amp;k, num_explicit_H ) ) {</a>
<a name="ln2309">            if ( bDisconnect ) {</a>
<a name="ln2310">                DisconnectAmmoniumSalt ( at, i, iO, k, num_explicit_H );</a>
<a name="ln2311">                orig_inp_data-&gt;num_inp_bonds --;</a>
<a name="ln2312">            }</a>
<a name="ln2313">            /* count disconnected atoms */</a>
<a name="ln2314">            num_changes ++;</a>
<a name="ln2315">        } else</a>
<a name="ln2316">        if ( bIsMetalSalt( at, i ) ) {</a>
<a name="ln2317">            if ( bDisconnect ) {</a>
<a name="ln2318">                k = DisconnectMetalSalt( at, i );</a>
<a name="ln2319">                orig_inp_data-&gt;num_inp_bonds -= k;</a>
<a name="ln2320">            }</a>
<a name="ln2321">            num_changes ++;</a>
<a name="ln2322">        }</a>
<a name="ln2323">    }   </a>
<a name="ln2324">    return num_changes;</a>
<a name="ln2325">}</a>
<a name="ln2326"> </a>
<a name="ln2327"> </a>
<a name="ln2328"> </a>
<a name="ln2329">/*****************************************************************************/</a>
<a name="ln2330">/* Important: Salt disconnection is independent from coord. disconnection:   */</a>
<a name="ln2331">/* because different atoms are disconnected.                                 */</a>
<a name="ln2332">/* However, sal disconnection may need to be rerun after metal disconnection */</a>
<a name="ln2333">/* because metal disconnection may make certain atoms be eligible for salt   */</a>
<a name="ln2334">/* disconnection                                                             */</a>
<a name="ln2335">/*****************************************************************************/</a>
<a name="ln2336">int bIsMetalToDisconnect(inp_ATOM *at, int i, int bCheckMetalValence)</a>
<a name="ln2337">{</a>
<a name="ln2338">    int type, at_valence, num_H;</a>
<a name="ln2339">/*</a>
<a name="ln2340">    if ( !at[i].valence )</a>
<a name="ln2341">*/</a>
<a name="ln2342">    if ( !(type = get_el_type( at[i].el_number )) ||</a>
<a name="ln2343">         !(type &amp; IS_METAL ) ) {</a>
<a name="ln2344">        return 0;</a>
<a name="ln2345">    }</a>
<a name="ln2346">    num_H      = NUMH(at,i);</a>
<a name="ln2347">    at_valence = num_H + at[i].chem_bonds_valence;</a>
<a name="ln2348">    if ( !at_valence ) {</a>
<a name="ln2349">        return 0; /* nothing to disconnect */</a>
<a name="ln2350">    }</a>
<a name="ln2351">    if ( bCheckMetalValence ) {</a>
<a name="ln2352">        if ( abs(at[i].charge) &gt; 1 ) {</a>
<a name="ln2353">            return 1; /* multiple charges */</a>
<a name="ln2354">        }</a>
<a name="ln2355">        for ( i = 0; i &lt; 2 &amp;&amp; (i &amp; type); i ++ ) {</a>
<a name="ln2356">            if ( at_valence ==  get_el_valence( at[i].el_number, at[i].charge, i ) ) {</a>
<a name="ln2357">                return 2; /* atom has normal valence */</a>
<a name="ln2358">            }</a>
<a name="ln2359">        }</a>
<a name="ln2360">    }</a>
<a name="ln2361">    return 1;</a>
<a name="ln2362"> </a>
<a name="ln2363">}</a>
<a name="ln2364"> </a>
<a name="ln2365"> </a>
<a name="ln2366"> </a>
<a name="ln2367">/*****************************************************************************/</a>
<a name="ln2368">int bMayDisconnectMetals( ORIG_ATOM_DATA *orig_inp_data, int bCheckMetalValence, INCHI_MODE *bTautFlagsDone )</a>
<a name="ln2369">{</a>
<a name="ln2370">    int i, j, k, iO, num_changes, val, bRadOrMultBonds, num_impl_H = 0;</a>
<a name="ln2371">    S_CHAR    num_explicit_H[NUM_H_ISOTOPES+1];</a>
<a name="ln2372">    inp_ATOM *at   =  orig_inp_data-&gt;at;</a>
<a name="ln2373">    int num_at     =  orig_inp_data-&gt;num_inp_atoms;</a>
<a name="ln2374">    int *nNumImplH = &amp;orig_inp_data-&gt;bDisconnectCoord;</a>
<a name="ln2375">    /* check each atom */</a>
<a name="ln2376">    for ( i = 0, num_changes = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2377"> </a>
<a name="ln2378">        if ( !(val = at[i].valence) &amp;&amp; !NUMH(at,i) ) {</a>
<a name="ln2379">            continue; /* disconnected atom */</a>
<a name="ln2380">        }</a>
<a name="ln2381">        bRadOrMultBonds = (val == 0) ||</a>
<a name="ln2382">             (val != at[i].chem_bonds_valence) || /* a bond has higher multiplicity than 1 */</a>
<a name="ln2383">             (at[i].radical &amp;&amp; at[i].radical != RADICAL_SINGLET); /* radical */</a>
<a name="ln2384">        </a>
<a name="ln2385">        if ( !bRadOrMultBonds &amp;&amp; bIsAmmoniumSalt( at, i, &amp;iO, &amp;k, num_explicit_H ) ) {</a>
<a name="ln2386">            ;</a>
<a name="ln2387">        } else</a>
<a name="ln2388">        if ( !bRadOrMultBonds &amp;&amp; bIsMetalSalt( at, i ) ) {</a>
<a name="ln2389">            ;</a>
<a name="ln2390">        } else</a>
<a name="ln2391">        if ( 1 == (j = bIsMetalToDisconnect(at, i, bCheckMetalValence)) ) {</a>
<a name="ln2392">            num_impl_H += NUMH(at,i);</a>
<a name="ln2393">            num_changes ++;</a>
<a name="ln2394">        } else</a>
<a name="ln2395">        if ( 2 == j &amp;&amp; bTautFlagsDone ) {</a>
<a name="ln2396">            *bTautFlagsDone |= TG_FLAG_CHECK_VALENCE_COORD_DONE;</a>
<a name="ln2397">        }</a>
<a name="ln2398">    }</a>
<a name="ln2399">    if ( nNumImplH )</a>
<a name="ln2400">        *nNumImplH = num_changes? num_impl_H+1 : 0;</a>
<a name="ln2401">    return num_changes;</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404"> </a>
<a name="ln2405"> </a>
<a name="ln2406">/*****************************************************************************/</a>
<a name="ln2407">#if ( bRELEASE_VERSION == 0 &amp;&amp; (EXTR_HAS_METAL_ATOM &amp; (EXTR_MASK | EXTR_FLAG) ) )</a>
<a name="ln2408">int bHasMetalAtom( ORIG_ATOM_DATA *orig_inp_data )</a>
<a name="ln2409">{</a>
<a name="ln2410">    int i;</a>
<a name="ln2411">    inp_ATOM *at;</a>
<a name="ln2412">    if ( orig_inp_data &amp;&amp; (at   =  orig_inp_data-&gt;at) ) {</a>
<a name="ln2413">        int num_at     =  orig_inp_data-&gt;num_inp_atoms;</a>
<a name="ln2414">        /* check each atom */</a>
<a name="ln2415">        for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2416">            if ( IS_METAL &amp; get_el_type( at[i].el_number ) ) {</a>
<a name="ln2417">                return 1;</a>
<a name="ln2418">            }</a>
<a name="ln2419">        }</a>
<a name="ln2420">    }</a>
<a name="ln2421">    return 0;</a>
<a name="ln2422">}</a>
<a name="ln2423">#endif</a>
<a name="ln2424">/*****************************************************************************</a>
<a name="ln2425">{ &quot;F&quot;,   19,  19,  18.998403220,     0 ,  0, {{0,},       {0,},       {1,},       {2,},       {3,5},      },},</a>
<a name="ln2426">{ &quot;Cl&quot;,  35,  35,  34.968852730,     0 ,  0, {{0,},       {0,},       {1,3,5,7},  {2,4,6},    {3,5,},     },},</a>
<a name="ln2427">{ &quot;Br&quot;,  80,  79,  78.918336100,     0 ,  0, {{0,},       {0,},       {1,3,5,7,}, {2,4,6,},   {3,5,},     },},</a>
<a name="ln2428">{ &quot;I&quot;,  127, 127, 126.904500000,     0 ,  0, {{0,},       {0,},       {1,3,5,7,}, {2,4,6},    {3,5,},     },},</a>
<a name="ln2429">{ &quot;At&quot;, 210, 210, 209.987100000,     0 ,  0, {{0,},       {0,},       {1,3,5,7,}, {2,4,6},    {3,5,},     },},</a>
<a name="ln2430">{ &quot;N&quot;,   14,  14,  14.003074000,     0 ,  0, {{1,},       {2,},       {3,5},      {4,},       {3,},       },},</a>
<a name="ln2431">{ &quot;P&quot;,   31,  31,  30.973762000,     0 ,  0, {{1,3,5,7,}, {2,4,6,},   {3,5,},     {4,},       {3,},       },},</a>
<a name="ln2432">{ &quot;As&quot;,  75,  75,  74.921594200,     0 ,  0, {{0,},       {2,4,6,},   {3,5,},     {4,},       {3,},       },},</a>
<a name="ln2433">{ &quot;Sb&quot;, 122, 121, 120.903800000,     0 ,  0, {{1,3,5,7,}, {2,4,6,},   {3,5,},     {2,4,},     {3,},       },},</a>
<a name="ln2434">{ &quot;O&quot;,   16,  16,  15.994914630,     0 ,  0, {{0,},       {1,},       {2,},       {3,5,},     {4,},       },},</a>
<a name="ln2435">{ &quot;S&quot;,   32,  32,  31.972070700,     0 ,  0, {{0,},       {1,3,5,7,}, {2,4,6},    {3,5,},     {4,},       },},</a>
<a name="ln2436">{ &quot;Se&quot;,  79,  80,  79.916519600,     0 ,  0, {{0,},       {1,3,5,7,}, {2,4,6,},   {3,5,},     {4,},       },},</a>
<a name="ln2437">{ &quot;Te&quot;, 128, 130, 129.906200000,     0 ,  0, {{0,},       {1,3,5,7,}, {2,4,6,},   {3,5,},     {2,4,},     },},</a>
<a name="ln2438">{ &quot;Po&quot;, 209, 209, 208.982400000,     0 ,  0, {{0,},       {1,3,5,7,}, {2,4,6,},   {3,5,},     {2,4,},     },},</a>
<a name="ln2439">{ &quot;B&quot;,   11,  11,  11.009300000,     0 ,  0, {{3,},       {4,},       {3,},       {2,},       {1,},       },},</a>
<a name="ln2440">*****************************************************************************/</a>
<a name="ln2441"> </a>
<a name="ln2442"> </a>
<a name="ln2443"> </a>
<a name="ln2444">int DisconnectMetals( ORIG_ATOM_DATA *orig_inp_data, int bCheckMetalValence, INCHI_MODE *bTautFlagsDone ) </a>
<a name="ln2445">                           /*inp_ATOM *atom, int num_atoms, int nNumExplH, int *new_num_atoms */</a>
<a name="ln2446">{</a>
<a name="ln2447">    int i, j, k, n, iO, num_changes, val, bRadOrMultBonds;</a>
<a name="ln2448">    int num_impl_H, num_at, err, num_disconnected;</a>
<a name="ln2449">    S_CHAR num_explicit_H[NUM_H_ISOTOPES+1];</a>
<a name="ln2450">    static char elnumber_Heteroat[16] = {'\0', };</a>
<a name="ln2451">    static int  num_halogens;</a>
<a name="ln2452">    inp_ATOM  *at             = NULL;</a>
<a name="ln2453">    S_CHAR    *bMetal         = NULL;</a>
<a name="ln2454">    inp_ATOM  *atom           = orig_inp_data-&gt;at;</a>
<a name="ln2455">    int        num_atoms      = orig_inp_data-&gt;num_inp_atoms;</a>
<a name="ln2456">    int        nNumExplH      = (orig_inp_data-&gt;bDisconnectCoord &gt; 0)? orig_inp_data-&gt;bDisconnectCoord - 1 : 0;</a>
<a name="ln2457">    AT_NUMB   *nOldCompNumber = orig_inp_data-&gt;nOldCompNumber;</a>
<a name="ln2458"> </a>
<a name="ln2459">    err              = 0;</a>
<a name="ln2460">    num_impl_H       = 0;</a>
<a name="ln2461">    num_at           = num_atoms;</a>
<a name="ln2462">    num_disconnected = 0;</a>
<a name="ln2463">    if ( !(at     = (inp_ATOM *)inchi_calloc( num_at + nNumExplH, sizeof(at[0]    ) )) ||</a>
<a name="ln2464">         !(bMetal = ( S_CHAR    *)inchi_calloc( num_at + nNumExplH, sizeof(bMetal[0]) )) ) {</a>
<a name="ln2465">        err = 1;</a>
<a name="ln2466">        goto exit_function;</a>
<a name="ln2467">    }</a>
<a name="ln2468">    if (!elnumber_Heteroat[0] ) {</a>
<a name="ln2469">        i = 0;</a>
<a name="ln2470">        /* halogens */</a>
<a name="ln2471">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;F&quot;  ); /* 0 */</a>
<a name="ln2472">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;Cl&quot; );</a>
<a name="ln2473">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;Br&quot; );</a>
<a name="ln2474">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;I&quot;  );</a>
<a name="ln2475">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;At&quot; ); /* 4 */</a>
<a name="ln2476">        num_halogens = i;</a>
<a name="ln2477">        /* other non-metal */</a>
<a name="ln2478">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;N&quot;  );</a>
<a name="ln2479">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;P&quot;  );</a>
<a name="ln2480">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;As&quot; );</a>
<a name="ln2481">        /*elnumber_Heteroat[i++] = get_periodic_table_number( &quot;Sb&quot; );*/ /* metal 10-28-2003 */</a>
<a name="ln2482">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;O&quot;  );</a>
<a name="ln2483">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;S&quot;  );</a>
<a name="ln2484">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln2485">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln2486">        /*elnumber_Heteroat[i++] = get_periodic_table_number( &quot;Po&quot; );*/ /* metal 10-28-2003 */</a>
<a name="ln2487">        elnumber_Heteroat[i++] = (char)get_periodic_table_number( &quot;B&quot;  );</a>
<a name="ln2488">        elnumber_Heteroat[i++] = 0;</a>
<a name="ln2489">    }</a>
<a name="ln2490"> </a>
<a name="ln2491">    memcpy( at, atom, num_atoms * sizeof(at[0]) );</a>
<a name="ln2492">    </a>
<a name="ln2493">    /* check each atom, mark metals */</a>
<a name="ln2494">    for ( i = 0, k = 0, num_changes = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2495"> </a>
<a name="ln2496">        if ( !(val = at[i].valence) &amp;&amp; !NUMH(at,i) ) {</a>
<a name="ln2497">            continue; /* disconnected atom */</a>
<a name="ln2498">        }</a>
<a name="ln2499">        bRadOrMultBonds = (val == 0) ||</a>
<a name="ln2500">             (val != at[i].chem_bonds_valence) || /* a bond has higher multiplicity than 1 */</a>
<a name="ln2501">             (at[i].radical &amp;&amp; at[i].radical != RADICAL_SINGLET); /* radical */</a>
<a name="ln2502">        </a>
<a name="ln2503">        if ( !bRadOrMultBonds &amp;&amp; bIsAmmoniumSalt( at, i, &amp;iO, &amp;k, num_explicit_H ) ) {</a>
<a name="ln2504">            ;</a>
<a name="ln2505">        } else</a>
<a name="ln2506">        if ( !bRadOrMultBonds &amp;&amp; bIsMetalSalt( at, i ) ) {</a>
<a name="ln2507">            ;</a>
<a name="ln2508">        } else</a>
<a name="ln2509">        if ( 1 == (j = bIsMetalToDisconnect(at, i, bCheckMetalValence)) ) {</a>
<a name="ln2510">            num_impl_H += (k = NUMH(at,i));</a>
<a name="ln2511">            bMetal[i] = 1+k;</a>
<a name="ln2512">            num_changes ++;</a>
<a name="ln2513">        } else</a>
<a name="ln2514">        if ( 2 == j &amp;&amp; bTautFlagsDone ) {</a>
<a name="ln2515">            *bTautFlagsDone |= TG_FLAG_CHECK_VALENCE_COORD_DONE;</a>
<a name="ln2516">        }</a>
<a name="ln2517">    }</a>
<a name="ln2518">    if ( num_impl_H != nNumExplH ) {</a>
<a name="ln2519">        err = 2;</a>
<a name="ln2520">        goto exit_function;</a>
<a name="ln2521">    }</a>
<a name="ln2522"> </a>
<a name="ln2523"> </a>
<a name="ln2524">    /* replace implicit H atoms with explicit H atoms */</a>
<a name="ln2525">    for ( i = 0; i &lt; num_atoms &amp;&amp; 0 &lt; num_impl_H; i ++ ) {</a>
<a name="ln2526">        if ( bMetal[i] &lt;= 1 ) {</a>
<a name="ln2527">            continue;</a>
<a name="ln2528">        }</a>
<a name="ln2529">        for ( k = 0; k &lt; NUM_H_ISOTOPES+1; k ++ ) {</a>
<a name="ln2530">            n = k? at[i].num_iso_H[k-1] : at[i].num_H;</a>
<a name="ln2531">            for ( j = 0; j &lt; n; j ++ ) {</a>
<a name="ln2532">                if ( num_at &gt;= num_atoms + nNumExplH ) {</a>
<a name="ln2533">                    err = 3;</a>
<a name="ln2534">                    goto exit_function;</a>
<a name="ln2535">                }</a>
<a name="ln2536">                at[num_at].elname[0] = 'H';</a>
<a name="ln2537">                at[num_at].el_number = get_periodic_table_number(at[num_at].elname);</a>
<a name="ln2538">                at[num_at].iso_atw_diff = k;</a>
<a name="ln2539">                at[num_at].component = at[i].component;</a>
<a name="ln2540">                move_explicit_Hcation(at, num_at+1, i, num_at, 1);</a>
<a name="ln2541">                at[num_at].orig_at_number = num_at+1;</a>
<a name="ln2542">                num_at ++;</a>
<a name="ln2543">                num_impl_H --;</a>
<a name="ln2544">                bMetal[i] --;</a>
<a name="ln2545">                if ( k ) {</a>
<a name="ln2546">                    at[i].num_iso_H[k-1] --;</a>
<a name="ln2547">                } else {</a>
<a name="ln2548">                    at[i].num_H --;</a>
<a name="ln2549">                }</a>
<a name="ln2550">            }</a>
<a name="ln2551">        }</a>
<a name="ln2552">        if ( bMetal[i] != 1 ) {</a>
<a name="ln2553">            err = 4;</a>
<a name="ln2554">            goto exit_function;</a>
<a name="ln2555">        }</a>
<a name="ln2556">    }</a>
<a name="ln2557">    if ( num_at != num_atoms + nNumExplH ) {</a>
<a name="ln2558">        err = 5;</a>
<a name="ln2559">        goto exit_function;</a>
<a name="ln2560">    }</a>
<a name="ln2561"> </a>
<a name="ln2562">    /* disconnect metal - ligand bonds */</a>
<a name="ln2563">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2564">        if ( !bMetal[i] ) {</a>
<a name="ln2565">            continue;</a>
<a name="ln2566">        }</a>
<a name="ln2567">        /* disconnect metal atom M</a>
<a name="ln2568"> </a>
<a name="ln2569">        Note: Defect in case of bridging ligands:</a>
<a name="ln2570"> </a>
<a name="ln2571">        M     M                          M     M             M     M(+)</a>
<a name="ln2572">          \  /   will be transformed to            , not to         </a>
<a name="ln2573">           N(+)                             N(+)                N(-)</a>
<a name="ln2574">          / \                              / \                 / \  </a>
<a name="ln2575">         R   R                            R   R               R   R</a>
<a name="ln2576">         </a>
<a name="ln2577">        Non-bridging are OK:</a>
<a name="ln2578"> </a>
<a name="ln2579">        M     R           M(+)  R</a>
<a name="ln2580">          \  /                 / </a>
<a name="ln2581">           N(+)    ---&gt;      N   </a>
<a name="ln2582">          / \               / \  </a>
<a name="ln2583">         R   R             R   R</a>
<a name="ln2584">         </a>
<a name="ln2585">        */</a>
<a name="ln2586">        for ( j = at[i].valence-1; 0 &lt;= j; j -- ) {</a>
<a name="ln2587">            if ( j &lt; at[i].valence &amp;&amp; !bMetal[ (int)at[i].neighbor[j] ] ) {</a>
<a name="ln2588">                /* do not break metal-metal bond here */</a>
<a name="ln2589">                num_disconnected += DisconnectOneLigand( at, nOldCompNumber, bMetal, elnumber_Heteroat,</a>
<a name="ln2590">                                                         num_halogens, num_atoms, i, j, bTautFlagsDone );</a>
<a name="ln2591">            }</a>
<a name="ln2592">        }</a>
<a name="ln2593">    }</a>
<a name="ln2594">    /* disconnect metal-metal bonds */</a>
<a name="ln2595">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2596">        if ( !bMetal[i] ) {</a>
<a name="ln2597">            continue;</a>
<a name="ln2598">        }</a>
<a name="ln2599">        for ( j = at[i].valence-1; 0 &lt;= j; j --  ) {</a>
<a name="ln2600">            if ( j &lt; at[i].valence &amp;&amp; bMetal[ (int)at[i].neighbor[j] ] ) {</a>
<a name="ln2601">                /* break metal-metal bond here */</a>
<a name="ln2602">                num_disconnected += DisconnectOneLigand( at, nOldCompNumber, bMetal, elnumber_Heteroat,</a>
<a name="ln2603">                                                         num_halogens, num_atoms, i, j, bTautFlagsDone );</a>
<a name="ln2604">            }</a>
<a name="ln2605">        }</a>
<a name="ln2606">    }</a>
<a name="ln2607"> </a>
<a name="ln2608"> </a>
<a name="ln2609">exit_function:</a>
<a name="ln2610">    if ( !num_disconnected ) {</a>
<a name="ln2611">        err = 6;</a>
<a name="ln2612">    }</a>
<a name="ln2613">    if ( at &amp;&amp; err ) {</a>
<a name="ln2614">        inchi_free( at );</a>
<a name="ln2615">        at = NULL;</a>
<a name="ln2616">    }</a>
<a name="ln2617">    if ( atom &amp;&amp; at ) { /* changed if ( at ) to if ( atom &amp;&amp; at ) 2004-04-03 */</a>
<a name="ln2618">        inchi_free( atom );</a>
<a name="ln2619">        atom = NULL;</a>
<a name="ln2620">    }</a>
<a name="ln2621">    if ( bMetal )</a>
<a name="ln2622">        inchi_free( bMetal );</a>
<a name="ln2623">    </a>
<a name="ln2624">    if ( at ) {</a>
<a name="ln2625">        orig_inp_data-&gt;at = at;</a>
<a name="ln2626">        orig_inp_data-&gt;num_inp_atoms = num_at;</a>
<a name="ln2627">    }</a>
<a name="ln2628">    return err? -err : num_disconnected;</a>
<a name="ln2629">}</a>
<a name="ln2630"> </a>
<a name="ln2631"> </a>
<a name="ln2632"> </a>
<a name="ln2633">/*****************************************************************************/</a>
<a name="ln2634">int DisconnectOneLigand( inp_ATOM *at, AT_NUMB *nOldCompNumber, S_CHAR *bMetal, char *elnumber_Heteroat,</a>
<a name="ln2635">                         int num_halogens, int num_atoms, int iMetal, int jLigand, INCHI_MODE *bTautFlagsDone )</a>
<a name="ln2636">{</a>
<a name="ln2637">    int i, j, iLigand, neigh, val;</a>
<a name="ln2638">    int metal_neigh_ord[MAXVAL], num_neigh_arom_bonds[MAXVAL];</a>
<a name="ln2639">    int num_metal_neigh, num_disconnections;</a>
<a name="ln2640">    int num_del_arom_bonds, num_tot_arom_bonds, new_charge;</a>
<a name="ln2641">    char *p;</a>
<a name="ln2642"> </a>
<a name="ln2643">    iLigand = at[iMetal].neighbor[jLigand];</a>
<a name="ln2644">    num_metal_neigh    = 0;</a>
<a name="ln2645">    num_disconnections = 0;</a>
<a name="ln2646">    num_del_arom_bonds  = num_tot_arom_bonds = 0;</a>
<a name="ln2647"> </a>
<a name="ln2648">    /* find bonds to disconnect */</a>
<a name="ln2649">    for ( i = 0; i &lt; at[iLigand].valence; i ++ ) {</a>
<a name="ln2650">        num_neigh_arom_bonds[i] = 0;</a>
<a name="ln2651">        neigh = (int)at[iLigand].neighbor[i];</a>
<a name="ln2652">        if ( neigh &lt; num_atoms &amp;&amp; bMetal[ neigh ] ) {</a>
<a name="ln2653">            metal_neigh_ord[ num_metal_neigh ++ ] = i;</a>
<a name="ln2654">            if ( at[iLigand].bond_type[i] &gt; BOND_TYPE_TRIPLE ) {</a>
<a name="ln2655">                /* aromatic bond */</a>
<a name="ln2656">                for ( j = 0; j &lt; at[neigh].valence; j ++ ) {</a>
<a name="ln2657">                    num_neigh_arom_bonds[i] += ( at[neigh].bond_type[j] &gt; BOND_TYPE_TRIPLE );</a>
<a name="ln2658">                }</a>
<a name="ln2659">                num_del_arom_bonds ++;</a>
<a name="ln2660">            }</a>
<a name="ln2661">        }</a>
<a name="ln2662">        num_tot_arom_bonds += (at[iLigand].bond_type[i] &gt; BOND_TYPE_TRIPLE);</a>
<a name="ln2663">    }</a>
<a name="ln2664">    /* Disconnect */</a>
<a name="ln2665">    if ( num_del_arom_bonds ) {</a>
<a name="ln2666">        /* fix chem_valence of the ligand and its neighbors in case of disconnecting arom. bonds */</a>
<a name="ln2667">        /* because in this case special care should be taken of updating at[].chem_bonds_valence */</a>
<a name="ln2668">        for ( i = 0; i &lt; num_metal_neigh; i ++ ) {</a>
<a name="ln2669">            j = metal_neigh_ord[i];</a>
<a name="ln2670">            if ( num_neigh_arom_bonds[j] ) {</a>
<a name="ln2671">                neigh = at[iLigand].neighbor[j];</a>
<a name="ln2672">                at[neigh].chem_bonds_valence -= num_neigh_arom_bonds[j]/2 - (num_neigh_arom_bonds[j]-1)/2;</a>
<a name="ln2673">            }</a>
<a name="ln2674">        }</a>
<a name="ln2675">        at[iLigand].chem_bonds_valence -= num_tot_arom_bonds/2 - (num_tot_arom_bonds-num_del_arom_bonds)/2;</a>
<a name="ln2676">    }</a>
<a name="ln2677">    /* disconnect in reverse order, otherwise the metal_neigh_ord[i]</a>
<a name="ln2678">       becomes invalid after the first disconnection</a>
<a name="ln2679">    */</a>
<a name="ln2680">    for ( i = num_metal_neigh-1; 0 &lt;= i; i -- ) {</a>
<a name="ln2681">        num_disconnections += DisconnectInpAtBond( at, nOldCompNumber, iLigand, metal_neigh_ord[i] );</a>
<a name="ln2682">    }</a>
<a name="ln2683"> </a>
<a name="ln2684">    /* attempt to change ligand charge to make its valence 'natural' */</a>
<a name="ln2685">    i = num_tot_arom_bonds - num_del_arom_bonds;</a>
<a name="ln2686">    if ( (i  &amp;&amp; i != 2 &amp;&amp; i != 3) ||</a>
<a name="ln2687">         (at[iLigand].radical &amp;&amp; at[iLigand].radical != RADICAL_SINGLET) ||</a>
<a name="ln2688">         !(p = strchr( elnumber_Heteroat, at[iLigand].el_number ) ) ) {</a>
<a name="ln2689">        goto exit_function;  /* non-standard atom */</a>
<a name="ln2690">    }</a>
<a name="ln2691">    val = at[iLigand].chem_bonds_valence + NUMH(at, iLigand);</a>
<a name="ln2692">    new_charge = MAX_ATOMS; /* impossible value */</a>
<a name="ln2693">    if ( !val ) {</a>
<a name="ln2694">        if ( p - elnumber_Heteroat &lt; num_halogens ) {</a>
<a name="ln2695">            new_charge = -1;</a>
<a name="ln2696">        }</a>
<a name="ln2697">    } else {</a>
<a name="ln2698">        for ( i = -1; i &lt;= 1; i ++ ) {</a>
<a name="ln2699">            if ( val == get_el_valence( at[iLigand].el_number, i, 0 ) ) {</a>
<a name="ln2700">                new_charge = i; /* found charge that fits chem. valence */</a>
<a name="ln2701">                break;</a>
<a name="ln2702">            }</a>
<a name="ln2703">        }</a>
<a name="ln2704">    }</a>
<a name="ln2705">    if ( new_charge != MAX_ATOMS ) {</a>
<a name="ln2706">        if ( (new_charge != at[iLigand].charge ||</a>
<a name="ln2707">              (at[iLigand].radical &amp;&amp; at[iLigand].radical != RADICAL_SINGLET)) &amp;&amp;</a>
<a name="ln2708">             1 == num_metal_neigh ) {</a>
<a name="ln2709">            if ( 1 == new_charge &amp;&amp; 4 == val &amp;&amp; 2 == at[iLigand].valence &amp;&amp;</a>
<a name="ln2710">                 4 == at[iLigand].chem_bonds_valence &amp;&amp;</a>
<a name="ln2711">                at[iLigand].bond_type[0] == at[iLigand].bond_type[1] ) {</a>
<a name="ln2712">                ; /* do not add +1 charge to disconnected =N=, etc. 2004-10-27 */</a>
<a name="ln2713">            } else {</a>
<a name="ln2714">                if ( bTautFlagsDone &amp;&amp; new_charge != at[iLigand].charge ) {</a>
<a name="ln2715">                    *bTautFlagsDone |= TG_FLAG_MOVE_CHARGE_COORD_DONE;</a>
<a name="ln2716">                }</a>
<a name="ln2717">                at[iMetal].charge -= new_charge - at[iLigand].charge;</a>
<a name="ln2718">                at[iLigand].charge = new_charge;</a>
<a name="ln2719">                /*at[iLigand].radical = 0;*/</a>
<a name="ln2720">            }</a>
<a name="ln2721">        }</a>
<a name="ln2722">    }</a>
<a name="ln2723">exit_function:</a>
<a name="ln2724">    return num_disconnections; /* ret;*/</a>
<a name="ln2725">}</a>
<a name="ln2726"> </a>
<a name="ln2727"> </a>
<a name="ln2728"> </a>
<a name="ln2729"> </a>
<a name="ln2730">/****************************************************************************************/</a>
<a name="ln2731">double dist3D( inp_ATOM *at1, inp_ATOM *at2 )</a>
<a name="ln2732">{</a>
<a name="ln2733">    double dx = at1-&gt;x - at2-&gt;x;</a>
<a name="ln2734">    double dy = at1-&gt;y - at2-&gt;y;</a>
<a name="ln2735">    double dz = at1-&gt;z - at2-&gt;z;</a>
<a name="ln2736">    return sqrt( dx*dx+dy*dy+dz*dz );</a>
<a name="ln2737">}</a>
<a name="ln2738">/****************************************************************************************/</a>
<a name="ln2739">#define MIN_BOND_LENGTH   (1.0e-6)</a>
<a name="ln2740">#define MIN_COS           (1.0e-6)</a>
<a name="ln2741">#define MIN_BOND_LENGTH2  (MIN_BOND_LENGTH*MIN_BOND_LENGTH)</a>
<a name="ln2742">#define MAX_BOND_LENGTH   (1.0e30)</a>
<a name="ln2743">/****************************************************************************************/</a>
<a name="ln2744">double GetMinDistDistribution( inp_ATOM *at, int num_at, int iat, int iat_H,</a>
<a name="ln2745">                                int bInAllComponents, double min_dist[], int num_segm )</a>
<a name="ln2746">{</a>
<a name="ln2747">/*	const double one_pi = 2.0*atan2(1.0 , 0.0 ); */</a>
<a name="ln2748">    const double one_pi = 3.14159265358979323846; /* M_PI */</a>
<a name="ln2749">    const double two_pi = 2.0*one_pi;</a>
<a name="ln2750">    const double f_step = two_pi / num_segm;</a>
<a name="ln2751">    const double h_step = f_step/2.0;</a>
<a name="ln2752"> </a>
<a name="ln2753">    int i, j, k, kk, ki, kn, n, num_bonds;</a>
<a name="ln2754">    double xi, yi, xn, yn, cross_prod_in, dot_prod_in, xni, yni, rni, tni, rmin;</a>
<a name="ln2755">    double fi, fk, fn, ft, rt, rk, ri, rn, c, ave_bond_len;</a>
<a name="ln2756"> </a>
<a name="ln2757">    for ( i = 0; i &lt; num_segm; i ++ ) {</a>
<a name="ln2758">        min_dist[i] = MAX_BOND_LENGTH; /* more than any distance */</a>
<a name="ln2759">    }</a>
<a name="ln2760">    num_bonds    = 0;</a>
<a name="ln2761">    ave_bond_len = 0.0;</a>
<a name="ln2762">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln2763">        if ( i != iat &amp;&amp; i != iat_H &amp;&amp; (bInAllComponents || at[i].component == at[iat].component) ) {</a>
<a name="ln2764">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln2765">                n = at[i].neighbor[j];</a>
<a name="ln2766">                if ( (n &gt; i &amp;&amp; n != iat) || n == iat_H )</a>
<a name="ln2767">                    continue;</a>
<a name="ln2768">#if ( bRELEASE_VERSION != 1 &amp;&amp; defined(_DEBUG) )</a>
<a name="ln2769">                if ( n == iat ) {</a>
<a name="ln2770">                    int stop = 1;  /* &lt;BRKPT&gt; */</a>
<a name="ln2771">                }</a>
<a name="ln2772">#endif</a>
<a name="ln2773">                xi = at[i].x - at[iat].x;  /* ri; i != iat */</a>
<a name="ln2774">                yi = at[i].y - at[iat].y;</a>
<a name="ln2775">                xn = at[n].x - at[iat].x;  /* rn; possibly n == iat */</a>
<a name="ln2776">                yn = at[n].y - at[iat].y;</a>
<a name="ln2777">                cross_prod_in = xi*yn - xn*yi; /* ((r(i)-r(iat)) x (r(n)-r(iat)) */</a>
<a name="ln2778">                if ( cross_prod_in &lt; -0.01*MIN_BOND_LENGTH2 ) {</a>
<a name="ln2779">                    /* make sure the r(i)-&gt;r(n) vector is counterclockwise around at[iat] */</a>
<a name="ln2780">                    inchi_swap( (char*)&amp;xi, (char*)&amp;xn, sizeof(xi) );</a>
<a name="ln2781">                    inchi_swap( (char*)&amp;yi, (char*)&amp;yn, sizeof(yi) );</a>
<a name="ln2782">                    cross_prod_in = -cross_prod_in;</a>
<a name="ln2783">                }</a>
<a name="ln2784">                xni = xn - xi; /* r(n)-&gt;r(i) */</a>
<a name="ln2785">                yni = yn - yi;</a>
<a name="ln2786">                rni = xni*xni + yni*yni;</a>
<a name="ln2787">                if ( rni &gt; 0.01*MIN_BOND_LENGTH2 ) {</a>
<a name="ln2788">                    /* vector length |ri-&gt;rn| is not too small */</a>
<a name="ln2789">                    /* arrowhead of the vector r(t) = ri + (rn-ri)*t; 0 &lt;= t &lt;= 1 points to the bond ri-&gt;rn */</a>
<a name="ln2790">                    /* r(tni) is perpendicular to the bond ri-&gt;rn so that min|r(t)| = r(tni) = |tni|*rni */</a>
<a name="ln2791">                    tni = -(xni*xi + yni*yi)/rni;</a>
<a name="ln2792">                    /* find min. distance from n-i bond to at[iat] */</a>
<a name="ln2793">                    if ( tni &lt; 0.0 ) {</a>
<a name="ln2794">                        rmin = sqrt( xi*xi + yi*yi );</a>
<a name="ln2795">                    } else</a>
<a name="ln2796">                    if ( tni &gt; 1.0 ) {</a>
<a name="ln2797">                        rmin = sqrt( xn*xn + yn*yn );</a>
<a name="ln2798">                    } else {</a>
<a name="ln2799">                        rmin = sqrt(tni*tni*rni);</a>
<a name="ln2800">                    }</a>
<a name="ln2801">                    ave_bond_len += sqrt( rni );</a>
<a name="ln2802">                    num_bonds ++;</a>
<a name="ln2803">                } else {</a>
<a name="ln2804">                    /* zero length i-n bond */</a>
<a name="ln2805">                    tni  = 0.5; /* fake */</a>
<a name="ln2806">                    rmin = sqrt( xi*xi + yi*yi ); /* arbitrarily choose one */</a>
<a name="ln2807">                }</a>
<a name="ln2808">                if ( rmin &gt;= 0.1*MIN_BOND_LENGTH ) {</a>
<a name="ln2809">                    /* at[iat] does not belong to at[i]-at[n] bond */</a>
<a name="ln2810">                    int    bCalc_rt = 1;</a>
<a name="ln2811">                    fi = atan2( yi, xi );</a>
<a name="ln2812">                    fn = (n == iat)? fi : atan2( yn, xn );</a>
<a name="ln2813">                    if ( fi &gt; fn ) {</a>
<a name="ln2814">                        /* make sure fn - fi &gt;= 0 */</a>
<a name="ln2815">                        fn += two_pi;</a>
<a name="ln2816">                    }</a>
<a name="ln2817">                    if ( fi &lt; 0.0 ) {</a>
<a name="ln2818">                        fi += two_pi;</a>
<a name="ln2819">                        fn += two_pi;</a>
<a name="ln2820">                    }</a>
<a name="ln2821">                    ki = (int)floor((fi+h_step)/f_step);  /* cast does not match function type */</a>
<a name="ln2822">                    kn = (int)floor((fn+h_step)/f_step);</a>
<a name="ln2823">                    /* the bond may affect several segments */</a>
<a name="ln2824">                    for ( k = ki; k &lt;= kn; k ++ ) {</a>
<a name="ln2825">                        kk = k % num_segm;</a>
<a name="ln2826">                        if ( min_dist[kk] &lt; rmin )</a>
<a name="ln2827">                            continue;</a>
<a name="ln2828">                        if ( bCalc_rt ) {</a>
<a name="ln2829">                            if ( n == iat ) {</a>
<a name="ln2830">                                ft = fi;</a>
<a name="ln2831">                                rt = rmin;</a>
<a name="ln2832">                            } else {</a>
<a name="ln2833">                                double xt, yt;</a>
<a name="ln2834">                                xt  = xi + xni*tni;</a>
<a name="ln2835">                                yt  = yi + yni*tni;</a>
<a name="ln2836">                                ft  = atan2( yt, xt );</a>
<a name="ln2837">                                rt  = sqrt(xt*xt + yt*yt);</a>
<a name="ln2838">                            }</a>
<a name="ln2839">                            bCalc_rt = 0;</a>
<a name="ln2840">                        }</a>
<a name="ln2841">                        fk = f_step * kk;</a>
<a name="ln2842">                        c  = fabs(cos( fk - ft ));</a>
<a name="ln2843">                        if ( c &lt; MIN_COS )</a>
<a name="ln2844">                            c = MIN_COS;</a>
<a name="ln2845">                        rk = rt / c;</a>
<a name="ln2846">                        if ( min_dist[kk] &gt; rk ) {</a>
<a name="ln2847">                            min_dist[kk] = rk;</a>
<a name="ln2848">                        }</a>
<a name="ln2849">                    }</a>
<a name="ln2850">                } else {</a>
<a name="ln2851">                    /* rmin &lt; 0.1*MIN_BOND_LENGTH */</a>
<a name="ln2852">                    ri = xi*xi + yi*yi;</a>
<a name="ln2853">                    rn = xn*xn + yn*yn;</a>
<a name="ln2854">                    if ( ri &gt; MIN_BOND_LENGTH2 &amp;&amp; rn &gt; MIN_BOND_LENGTH2 ) {</a>
<a name="ln2855">                        dot_prod_in = xn*xi + yn*yi;</a>
<a name="ln2856">                        /* a very short bond */</a>
<a name="ln2857">                        if ( dot_prod_in &gt; 0.01*MIN_BOND_LENGTH2 ) {</a>
<a name="ln2858">                            /* bond does not cross at[iat] */</a>
<a name="ln2859">                            double fyixi = atan2( yi, xi );</a>
<a name="ln2860">                            if ( fyixi &lt; 0.0 ) fyixi += two_pi;</a>
<a name="ln2861">                            kk = (int)floor((fyixi+h_step)/f_step) % num_segm; </a>
<a name="ln2862">                            if ( min_dist[kk] &gt; rmin ) {</a>
<a name="ln2863">                                min_dist[kk] = rmin;</a>
<a name="ln2864">                            }</a>
<a name="ln2865">                        } else</a>
<a name="ln2866">                        if ( dot_prod_in &lt; -0.01*MIN_BOND_LENGTH2 ) {</a>
<a name="ln2867">                            /* bond does cross at[iat] */</a>
<a name="ln2868">                            double fyixi = atan2( yi, xi );</a>
<a name="ln2869">                            if ( fyixi &lt; 0.0 ) fyixi += two_pi;</a>
<a name="ln2870">                            kk = (int)floor((fyixi+h_step)/f_step) % num_segm; </a>
<a name="ln2871">                            if ( min_dist[kk] &gt; rmin ) {</a>
<a name="ln2872">                                min_dist[kk] = rmin;</a>
<a name="ln2873">                            }</a>
<a name="ln2874">                            fyixi += one_pi;</a>
<a name="ln2875">                            kk = (int)floor((fyixi+h_step)/f_step) % num_segm; </a>
<a name="ln2876">                            if ( min_dist[kk] &gt; rmin ) {</a>
<a name="ln2877">                                min_dist[kk] = rmin;</a>
<a name="ln2878">                            }</a>
<a name="ln2879">                        } else {</a>
<a name="ln2880">                            ; /* error, should not happen */</a>
<a name="ln2881">                        }</a>
<a name="ln2882">                    } else</a>
<a name="ln2883">                    if ( ri &lt;= MIN_BOND_LENGTH2 &amp;&amp; rn &lt;= MIN_BOND_LENGTH2 ) {</a>
<a name="ln2884">                        /* a very short bond coincides with at[iat]; ignore */</a>
<a name="ln2885">                        ;</a>
<a name="ln2886">                    } else {</a>
<a name="ln2887">                        /* one end of the bond coincides with at[iat] */</a>
<a name="ln2888">                        fi = ri&gt;rn? atan2( yi, xi) : atan2( yn, xn );</a>
<a name="ln2889">                        if ( fi &lt; 0.0 ) fi += two_pi;</a>
<a name="ln2890">                        kk = (int)floor((fi+h_step)/f_step) % num_segm; </a>
<a name="ln2891">                        if ( min_dist[kk] &gt; rmin ) {</a>
<a name="ln2892">                            min_dist[kk] = rmin;</a>
<a name="ln2893">                        }</a>
<a name="ln2894">                    }</a>
<a name="ln2895">                }</a>
<a name="ln2896">            }</a>
<a name="ln2897">        }</a>
<a name="ln2898">    }</a>
<a name="ln2899">    if ( num_bonds ) {</a>
<a name="ln2900">        return  ave_bond_len / (double)num_bonds;</a>
<a name="ln2901">    } else {</a>
<a name="ln2902">        return 0.0;</a>
<a name="ln2903">    }</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906"> </a>
<a name="ln2907"> </a>
<a name="ln2908">/****************************************************************************************/</a>
<a name="ln2909">int move_explicit_Hcation(inp_ATOM *at, int num_at, int iat, int iat_H, int bInAllComponents)</a>
<a name="ln2910">{</a>
<a name="ln2911">#define NUM_SEGM 20</a>
<a name="ln2912">    /*	const double one_pi = 2.0*atan2(1.0 , 0.0 ); */</a>
<a name="ln2913">    const double one_pi = 3.14159265358979323846; /* M_PI */</a>
<a name="ln2914">    const double two_pi = 2.0*one_pi;</a>
<a name="ln2915">    const double f_step = two_pi / NUM_SEGM;</a>
<a name="ln2916">    const double h_step = f_step/2.0;</a>
<a name="ln2917">    double min_dist[NUM_SEGM];</a>
<a name="ln2918">    int nB, i, k, kk, next, val;</a>
<a name="ln2919">    double r, r0, xd, yd, zd, xr, yr, zr, ave_bond_len;</a>
<a name="ln2920">    /*double step = 4.0*atan(1.0)/NUM_SEGM;*/</a>
<a name="ln2921">    /* find at[iat] neighbors coordinates */</a>
<a name="ln2922">    xd=yd=zd=0.0;</a>
<a name="ln2923">    if ( at[iat].valence ) {</a>
<a name="ln2924">        for ( i = 0, nB=0, r = 0.0; i &lt; at[iat].valence; i ++ ) {</a>
<a name="ln2925">            next = at[iat].neighbor[i];</a>
<a name="ln2926">            xd += at[next].x;</a>
<a name="ln2927">            yd += at[next].y;</a>
<a name="ln2928">            zd += at[next].z;</a>
<a name="ln2929">            r  += dist3D( at+iat, at+next );</a>
<a name="ln2930">            nB ++;</a>
<a name="ln2931">        }</a>
<a name="ln2932">        xd /= (double)nB;</a>
<a name="ln2933">        yd /= (double)nB;</a>
<a name="ln2934">        zd /= (double)nB;</a>
<a name="ln2935">        r  /= (double)nB;</a>
<a name="ln2936">        r0 = sqrt((double)(xd-at[iat].x)*(xd-at[iat].x)  </a>
<a name="ln2937">                + (double)(yd-at[iat].y)*(yd-at[iat].y));</a>
<a name="ln2938">    } else {</a>
<a name="ln2939">        if ( at[iat_H].valence ) {</a>
<a name="ln2940">            r = dist3D( at+iat_H, at+ (int)at[iat_H].neighbor[0] );</a>
<a name="ln2941">        } else {</a>
<a name="ln2942">            r = 0.0;</a>
<a name="ln2943">        }</a>
<a name="ln2944">        r0 = 0.0;</a>
<a name="ln2945">    }</a>
<a name="ln2946">    ave_bond_len = GetMinDistDistribution( at, num_at, iat, iat_H, bInAllComponents, min_dist, NUM_SEGM );</a>
<a name="ln2947">    if ( r &lt; MIN_BOND_LENGTH &amp;&amp; ave_bond_len &gt; MIN_BOND_LENGTH ) {</a>
<a name="ln2948">            r = ave_bond_len; /* ave_bond_len = 0.0 may mean that it is 0D structure */</a>
<a name="ln2949">    }</a>
<a name="ln2950">    if ( r &gt; MIN_BOND_LENGTH ) {</a>
<a name="ln2951">        /* process non-zero bond lengths */</a>
<a name="ln2952">        double f;</a>
<a name="ln2953">        if ( 10.0*r0 &lt; r ) {</a>
<a name="ln2954">            xr =  -r;     /* arbitrary */</a>
<a name="ln2955">            yr =  0.0;</a>
<a name="ln2956">            zr =  0.0;</a>
<a name="ln2957">        } else {</a>
<a name="ln2958">            /*</a>
<a name="ln2959">            if ( r0 &lt; MIN_BOND_LENGTH ) {</a>
<a name="ln2960">                r0 = 1.0;</a>
<a name="ln2961">            }</a>
<a name="ln2962">            */</a>
<a name="ln2963">            xr =   r * ( at[iat].x - xd )/r0;</a>
<a name="ln2964">            yr =   r * ( at[iat].y - yd )/r0; /* length = r */</a>
<a name="ln2965">            zr =   r * ( at[iat].z - zd )/r0;</a>
<a name="ln2966"> </a>
<a name="ln2967">/*          -- test: opposire direction --</a>
<a name="ln2968">            xr =   -r * ( at[iat].x - xd )/r0;</a>
<a name="ln2969">            yr =   -r * ( at[iat].y - yd )/r0;</a>
<a name="ln2970">            zr =   -r * ( at[iat].z - zd )/r0;</a>
<a name="ln2971">*/            </a>
<a name="ln2972">            if ( xr*xr + yr*yr &lt; 0.04*r*r ) {</a>
<a name="ln2973">                xr = -r;</a>
<a name="ln2974">                yr = 0.0;</a>
<a name="ln2975">            }</a>
<a name="ln2976">        }</a>
<a name="ln2977">        r = sqrt( xr*xr + yr*yr );</a>
<a name="ln2978">        f = atan2( yr, xr );</a>
<a name="ln2979"> </a>
<a name="ln2980">        if ( f &lt; 0.0 )</a>
<a name="ln2981">            f += two_pi;</a>
<a name="ln2982"> </a>
<a name="ln2983">        </a>
<a name="ln2984">        </a>
<a name="ln2985">        kk = (int)floor((f+h_step)/f_step) % NUM_SEGM; /* cast does not match function type by design */</a>
<a name="ln2986">        if ( min_dist[kk] &lt; 1.5* r ) {</a>
<a name="ln2987">            double dist = 1.5*r;</a>
<a name="ln2988">            int start=-1, len=0, start_max=-1, len_max=0;</a>
<a name="ln2989">again:</a>
<a name="ln2990">            /* look for longest kk interval with min_dist[kk] &gt;= dist */</a>
<a name="ln2991">            for ( k = 0, start = 0, len = 0, len_max = 0; k &lt; 2*NUM_SEGM; k ++ ) {</a>
<a name="ln2992">                kk = k % NUM_SEGM;</a>
<a name="ln2993">                if ( min_dist[kk] &gt;= dist ) {</a>
<a name="ln2994">                    if ( !len ++) {</a>
<a name="ln2995">                        start = k;</a>
<a name="ln2996">                    }</a>
<a name="ln2997">                } else {</a>
<a name="ln2998">                    if ( len &gt; len_max ) {</a>
<a name="ln2999">                        len_max = len;</a>
<a name="ln3000">                        start_max = start;</a>
<a name="ln3001">                    }</a>
<a name="ln3002">                    len = 0;</a>
<a name="ln3003">                }</a>
<a name="ln3004">            }</a>
<a name="ln3005">            if ( !len_max ) {</a>
<a name="ln3006">                if ( dist &gt; 0.1*r ) {</a>
<a name="ln3007">                    dist *= 0.75;</a>
<a name="ln3008">                    goto again;</a>
<a name="ln3009">                } else {</a>
<a name="ln3010">                    goto done; /* do it anyway */</a>
<a name="ln3011">                }</a>
<a name="ln3012">            } else {</a>
<a name="ln3013">                /* found a good sector */</a>
<a name="ln3014">                f = f_step * (start_max + (double)(len_max - 1)/2.0);</a>
<a name="ln3015">                r0 = dist / 1.5;</a>
<a name="ln3016">                xr = r0 * cos(f);</a>
<a name="ln3017">                yr = r0 * sin(f);</a>
<a name="ln3018">                zr = zr/r*r0;</a>
<a name="ln3019">            }</a>
<a name="ln3020">        }</a>
<a name="ln3021">    } else {</a>
<a name="ln3022">        xr = yr = zr = 0;</a>
<a name="ln3023">    }</a>
<a name="ln3024"> </a>
<a name="ln3025">done:</a>
<a name="ln3026"> </a>
<a name="ln3027">    if ( at[iat_H].valence ) {</a>
<a name="ln3028">        /* disconnect H */</a>
<a name="ln3029">        next = at[iat_H].neighbor[0];</a>
<a name="ln3030">        for ( i = 0; i &lt; at[next].valence; i ++ ) {</a>
<a name="ln3031">            if ( at[next].neighbor[i] == iat_H ) {</a>
<a name="ln3032">                RemoveInpAtBond( at, next, i );</a>
<a name="ln3033">                i = 0; /* success */</a>
<a name="ln3034">                break;</a>
<a name="ln3035">            }</a>
<a name="ln3036">        }</a>
<a name="ln3037">    } else {</a>
<a name="ln3038">        /* isolated H+ cation */</a>
<a name="ln3039">        next = iat_H;</a>
<a name="ln3040">        i    = 0;</a>
<a name="ln3041">        at[iat_H].valence = 1;</a>
<a name="ln3042">        at[iat_H].chem_bonds_valence = 1;</a>
<a name="ln3043">        at[iat_H].bond_type[0] = BOND_TYPE_SINGLE;</a>
<a name="ln3044">    }</a>
<a name="ln3045">    if ( 0 == i /*i &lt; at[next].valence*/ ) {</a>
<a name="ln3046">        /* move charge */</a>
<a name="ln3047">        if ( at[next].charge &gt; 0 &amp;&amp; at[iat].charge &lt; 0 ) {</a>
<a name="ln3048">            at[next].charge --;</a>
<a name="ln3049">            at[iat].charge ++;</a>
<a name="ln3050">        }</a>
<a name="ln3051">        /* connect H to at[iat] */</a>
<a name="ln3052">        val = at[iat].valence;</a>
<a name="ln3053">        at[iat].neighbor[val] = iat_H;</a>
<a name="ln3054">        at[iat].bond_type[val] = at[iat_H].bond_type[0];</a>
<a name="ln3055">        at[iat].bond_stereo[val] = 0;</a>
<a name="ln3056">        at[iat].chem_bonds_valence += at[iat_H].bond_type[0];</a>
<a name="ln3057">        at[iat].valence = val+1;</a>
<a name="ln3058"> </a>
<a name="ln3059">        at[iat_H].component = at[iat].component;</a>
<a name="ln3060">        at[iat_H].neighbor[0] = iat;</a>
<a name="ln3061">        at[iat_H].bond_stereo[0] = 0; /* possible loss of stereo info */</a>
<a name="ln3062">        at[iat_H].x = at[iat].x + xr;</a>
<a name="ln3063">        at[iat_H].y = at[iat].y + yr;</a>
<a name="ln3064">        at[iat_H].z = at[iat].z + zr;</a>
<a name="ln3065">        return 1; /* success */</a>
<a name="ln3066">    }</a>
<a name="ln3067">    return 0; /* failed */</a>
<a name="ln3068">}</a>
<a name="ln3069">/****************************************************************************************/</a>
<a name="ln3070">int get_iat_number( int el_number, const int el_num[], int el_num_len )</a>
<a name="ln3071">{</a>
<a name="ln3072">    int i;</a>
<a name="ln3073">    for ( i = 0; i &lt; el_num_len; i ++ ) {</a>
<a name="ln3074">        if ( el_num[i] == el_number )</a>
<a name="ln3075">            return i;</a>
<a name="ln3076">    }</a>
<a name="ln3077">    return -1;</a>
<a name="ln3078">}</a>
<a name="ln3079"> </a>
<a name="ln3080"> </a>
<a name="ln3081">/*#endif*/ /* } DISCONNECT_SALTS */</a>
<a name="ln3082"> typedef enum tagIonAtomType {</a>
<a name="ln3083">     IAT_H=0,</a>
<a name="ln3084">     IAT_C,</a>
<a name="ln3085">     IAT_N,</a>
<a name="ln3086">     IAT_P,</a>
<a name="ln3087">     IAT_O,</a>
<a name="ln3088">     IAT_S,</a>
<a name="ln3089">     IAT_Se,</a>
<a name="ln3090">     IAT_Te,</a>
<a name="ln3091">     IAT_F,</a>
<a name="ln3092">     IAT_Cl,</a>
<a name="ln3093">     IAT_Br,</a>
<a name="ln3094">     IAT_I,</a>
<a name="ln3095">     IAT_MAX</a>
<a name="ln3096"> } ION_ATOM_TYPE;</a>
<a name="ln3097"> </a>
<a name="ln3098">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln3099">/****************************************************************************************/</a>
<a name="ln3100">int bHeteroAtomMayHaveXchgIsoH( inp_ATOM *atom, int iat )</a>
<a name="ln3101">{</a>
<a name="ln3102">    inp_ATOM *at = atom + iat, *at2;</a>
<a name="ln3103">    static int el_num[IAT_MAX];</a>
<a name="ln3104">    int j, val, is_O=0, is_Cl=0, is_N=0, is_H=0, num_H, iat_numb, bAccept, cur_num_iso_H;</a>
<a name="ln3105">    </a>
<a name="ln3106">    if ( !el_num[IAT_H]) {</a>
<a name="ln3107">        el_num[IAT_H ] = get_periodic_table_number( &quot;H&quot; ); </a>
<a name="ln3108">        el_num[IAT_C ] = get_periodic_table_number( &quot;C&quot; ); </a>
<a name="ln3109">        el_num[IAT_N ] = get_periodic_table_number( &quot;N&quot; ); </a>
<a name="ln3110">        el_num[IAT_P ] = get_periodic_table_number( &quot;P&quot; ); </a>
<a name="ln3111">        el_num[IAT_O ] = get_periodic_table_number( &quot;O&quot; ); </a>
<a name="ln3112">        el_num[IAT_S ] = get_periodic_table_number( &quot;S&quot; ); </a>
<a name="ln3113">        el_num[IAT_Se] = get_periodic_table_number( &quot;Se&quot;); </a>
<a name="ln3114">        el_num[IAT_Te] = get_periodic_table_number( &quot;Te&quot;); </a>
<a name="ln3115">        el_num[IAT_F ] = get_periodic_table_number( &quot;F&quot; ); </a>
<a name="ln3116">        el_num[IAT_Cl] = get_periodic_table_number( &quot;Cl&quot;); </a>
<a name="ln3117">        el_num[IAT_Br] = get_periodic_table_number( &quot;Br&quot;); </a>
<a name="ln3118">        el_num[IAT_I ] = get_periodic_table_number( &quot;I&quot; ); </a>
<a name="ln3119">    }</a>
<a name="ln3120">    if ( 0 &gt; (iat_numb = get_iat_number( at-&gt;el_number, el_num, IAT_MAX )) ) {</a>
<a name="ln3121">        return 0;</a>
<a name="ln3122">    }</a>
<a name="ln3123">    if ( abs(at-&gt;charge) &gt; 1 || (at-&gt;radical &amp;&amp; RADICAL_SINGLET != at-&gt;radical) ) {</a>
<a name="ln3124">        return 0;</a>
<a name="ln3125">    }</a>
<a name="ln3126">    val = -1;</a>
<a name="ln3127">    switch( iat_numb ) {</a>
<a name="ln3128">    case IAT_N:</a>
<a name="ln3129">    case IAT_P:</a>
<a name="ln3130">        is_N = 1;</a>
<a name="ln3131">        val  = 3+at-&gt;charge;</a>
<a name="ln3132">        break;</a>
<a name="ln3133">    case IAT_O:</a>
<a name="ln3134">    case IAT_S:</a>
<a name="ln3135">    case IAT_Se:</a>
<a name="ln3136">    case IAT_Te:</a>
<a name="ln3137">        is_O = 1;</a>
<a name="ln3138">        val  = 2+at-&gt;charge;</a>
<a name="ln3139">        break;</a>
<a name="ln3140">    case IAT_F:</a>
<a name="ln3141">    case IAT_Cl:</a>
<a name="ln3142">    case IAT_Br:</a>
<a name="ln3143">    case IAT_I:</a>
<a name="ln3144">        if ( at-&gt;charge == 0 ) {</a>
<a name="ln3145">            is_Cl = 1; /* isolated HCl */</a>
<a name="ln3146">            val   = 1;</a>
<a name="ln3147">        }</a>
<a name="ln3148">        break;</a>
<a name="ln3149">    case IAT_H:</a>
<a name="ln3150">        if ( at-&gt;valence   == 0 &amp;&amp;</a>
<a name="ln3151">             at-&gt;charge    == 1 ) {</a>
<a name="ln3152">            is_H = 1; /* isolated proton */</a>
<a name="ln3153">            val  = 0;</a>
<a name="ln3154">        }</a>
<a name="ln3155">    }</a>
<a name="ln3156">    if ( val &lt; 0 ) {</a>
<a name="ln3157">        return 0;</a>
<a name="ln3158">    }</a>
<a name="ln3159">    num_H = NUMH(at,0);</a>
<a name="ln3160">    if ( val != at-&gt;chem_bonds_valence + num_H ) {</a>
<a name="ln3161">        return 0;</a>
<a name="ln3162">    }</a>
<a name="ln3163">    if ( is_H ) {</a>
<a name="ln3164">        return 2; /* H atom */</a>
<a name="ln3165">    } else {</a>
<a name="ln3166">        cur_num_iso_H = 0;</a>
<a name="ln3167">        for ( j = 0, bAccept = 1; j &lt; at-&gt;valence &amp;&amp; bAccept; j ++ ) {</a>
<a name="ln3168">            at2 = atom + (int)at-&gt;neighbor[j];</a>
<a name="ln3169">            if ( (at2-&gt;charge &amp;&amp; at-&gt;charge) || (at2-&gt;radical &amp;&amp; RADICAL_SINGLET != at2-&gt;radical ) ) {</a>
<a name="ln3170">                return 0; /* adjacent charged/radical atoms: do not neutralizate */</a>
<a name="ln3171">            }</a>
<a name="ln3172">        }</a>
<a name="ln3173">    }</a>
<a name="ln3174">    return 1;</a>
<a name="ln3175">}</a>
<a name="ln3176">#endif</a>
<a name="ln3177">/****************************************************************************************/</a>
<a name="ln3178">int bNumHeterAtomHasIsotopicH( inp_ATOM *atom, int num_atoms )</a>
<a name="ln3179">{</a>
<a name="ln3180">    static int el_num[IAT_MAX];</a>
<a name="ln3181">    int i, j, val, is_O=0, is_Cl=0, is_N=0, is_H=0, num_H, iat_numb, bAccept, num_iso_H, cur_num_iso_H, num_iso_atoms;</a>
<a name="ln3182">    inp_ATOM *at, *at2;</a>
<a name="ln3183">    /* one time initialization */</a>
<a name="ln3184">    if ( !el_num[IAT_H]) {</a>
<a name="ln3185">        el_num[IAT_H ] = get_periodic_table_number( &quot;H&quot; ); </a>
<a name="ln3186">        el_num[IAT_C ] = get_periodic_table_number( &quot;C&quot; ); </a>
<a name="ln3187">        el_num[IAT_N ] = get_periodic_table_number( &quot;N&quot; ); </a>
<a name="ln3188">        el_num[IAT_P ] = get_periodic_table_number( &quot;P&quot; ); </a>
<a name="ln3189">        el_num[IAT_O ] = get_periodic_table_number( &quot;O&quot; ); </a>
<a name="ln3190">        el_num[IAT_S ] = get_periodic_table_number( &quot;S&quot; ); </a>
<a name="ln3191">        el_num[IAT_Se] = get_periodic_table_number( &quot;Se&quot;); </a>
<a name="ln3192">        el_num[IAT_Te] = get_periodic_table_number( &quot;Te&quot;); </a>
<a name="ln3193">        el_num[IAT_F ] = get_periodic_table_number( &quot;F&quot; ); </a>
<a name="ln3194">        el_num[IAT_Cl] = get_periodic_table_number( &quot;Cl&quot;); </a>
<a name="ln3195">        el_num[IAT_Br] = get_periodic_table_number( &quot;Br&quot;); </a>
<a name="ln3196">        el_num[IAT_I ] = get_periodic_table_number( &quot;I&quot; ); </a>
<a name="ln3197">    }</a>
<a name="ln3198">    num_iso_H     = 0;</a>
<a name="ln3199">    num_iso_atoms = 0;</a>
<a name="ln3200">    for ( i = 0, at = atom; i &lt; num_atoms; i ++, at ++ ) {</a>
<a name="ln3201"> </a>
<a name="ln3202">        num_iso_atoms += ( at-&gt;iso_atw_diff != 0 || NUM_ISO_H(at,0) ); /* isotopic atoms and implicit isotopic H */</a>
<a name="ln3203"> </a>
<a name="ln3204">        if ( 0 &gt; (iat_numb = get_iat_number( at-&gt;el_number, el_num, IAT_MAX )) ) {</a>
<a name="ln3205">            continue;</a>
<a name="ln3206">        }</a>
<a name="ln3207">        </a>
<a name="ln3208">        if ( abs(at-&gt;charge) &gt; 1 || (at-&gt;radical &amp;&amp; RADICAL_SINGLET != at-&gt;radical) ) {</a>
<a name="ln3209">            continue;</a>
<a name="ln3210">        }</a>
<a name="ln3211"> </a>
<a name="ln3212">        val = -1;</a>
<a name="ln3213">        switch( iat_numb ) {</a>
<a name="ln3214">        case IAT_N:</a>
<a name="ln3215">        case IAT_P:</a>
<a name="ln3216">            is_N = 1;</a>
<a name="ln3217">            val  = 3+at-&gt;charge;</a>
<a name="ln3218">            break;</a>
<a name="ln3219">        case IAT_O:</a>
<a name="ln3220">        case IAT_S:</a>
<a name="ln3221">        case IAT_Se:</a>
<a name="ln3222">        case IAT_Te:</a>
<a name="ln3223">            is_O = 1;</a>
<a name="ln3224">            val  = 2+at-&gt;charge;</a>
<a name="ln3225">            break;</a>
<a name="ln3226">        case IAT_F:</a>
<a name="ln3227">        case IAT_Cl:</a>
<a name="ln3228">        case IAT_Br:</a>
<a name="ln3229">        case IAT_I:</a>
<a name="ln3230">            if ( at-&gt;charge == 0 ) {</a>
<a name="ln3231">                is_Cl = 1; /* isolated HCl */</a>
<a name="ln3232">                val   = 1;</a>
<a name="ln3233">            }</a>
<a name="ln3234">            break;</a>
<a name="ln3235">        case IAT_H:</a>
<a name="ln3236">            if ( at-&gt;valence   == 0 &amp;&amp;</a>
<a name="ln3237">                 at-&gt;charge    == 1 ) {</a>
<a name="ln3238">                is_H = 1; /* isolated proton */</a>
<a name="ln3239">                val  = 0;</a>
<a name="ln3240">            }</a>
<a name="ln3241">        }</a>
<a name="ln3242">        if ( val &lt; 0 ) {</a>
<a name="ln3243">            continue;</a>
<a name="ln3244">        }</a>
<a name="ln3245">        num_H = NUMH(at,0);</a>
<a name="ln3246">        if ( val != at-&gt;chem_bonds_valence + num_H ) {</a>
<a name="ln3247">            continue;</a>
<a name="ln3248">        }</a>
<a name="ln3249">        if ( is_H ) {</a>
<a name="ln3250">            bAccept = 1;</a>
<a name="ln3251">            cur_num_iso_H = (at-&gt;iso_atw_diff != 0);</a>
<a name="ln3252">        } else {</a>
<a name="ln3253">            cur_num_iso_H = 0;</a>
<a name="ln3254">            for ( j = 0, bAccept = 1; j &lt; at-&gt;valence &amp;&amp; bAccept; j ++ ) {</a>
<a name="ln3255">                at2 = atom + (int)at-&gt;neighbor[j];</a>
<a name="ln3256">                if ( (at2-&gt;charge &amp;&amp; at-&gt;charge) || (at2-&gt;radical &amp;&amp; RADICAL_SINGLET != at2-&gt;radical ) ) {</a>
<a name="ln3257">                    bAccept = 0; /* adjacent charged/radical atoms: do not neutralizate */</a>
<a name="ln3258">                    break;</a>
<a name="ln3259">                } else</a>
<a name="ln3260">                if ( at2-&gt;el_number == el_num[IAT_H ] &amp;&amp; at2-&gt;valence == 1 &amp;&amp; at2-&gt;iso_atw_diff ) {</a>
<a name="ln3261">                    cur_num_iso_H ++; /* isotopic explicit H */</a>
<a name="ln3262">                }</a>
<a name="ln3263">            }</a>
<a name="ln3264">            if ( bAccept ) {</a>
<a name="ln3265">                num_iso_atoms -= cur_num_iso_H;  /* avoid counting explicit H as isotopic atom */</a>
<a name="ln3266">                cur_num_iso_H += NUM_ISO_H(at,0);</a>
<a name="ln3267">            }</a>
<a name="ln3268">            </a>
<a name="ln3269">        }</a>
<a name="ln3270">        num_iso_H += (bAccept &amp;&amp; cur_num_iso_H); /* number of acceptable heteroatoms that have isotopic H */</a>
<a name="ln3271">    }</a>
<a name="ln3272">    return ((num_iso_H? 1:0) | (num_iso_atoms? 2:0));</a>
<a name="ln3273">}</a>
<a name="ln3274"> </a>
<a name="ln3275"> </a>
<a name="ln3276">/****************************************************/</a>
<a name="ln3277">/* Mark and count disconnected structure components */</a>
<a name="ln3278">/* by Depth-first searching each component          */</a>
<a name="ln3279">/****************************************************/</a>
<a name="ln3280">int cmp_components( const void *a1, const void *a2 )</a>
<a name="ln3281">{</a>
<a name="ln3282">    int ret;</a>
<a name="ln3283">    AT_NUMB n1;</a>
<a name="ln3284">    AT_NUMB n2;</a>
<a name="ln3285"> </a>
<a name="ln3286">    n1 = ((const AT_NUMB *)a1)[0];     /* number of atoms in the component -- descending order */</a>
<a name="ln3287">    n2 = ((const AT_NUMB *)a2)[0];</a>
<a name="ln3288">    if ( (ret = (int)n2 - (int)n1) ) {</a>
<a name="ln3289">        return ret;</a>
<a name="ln3290">    }</a>
<a name="ln3291">    /* stable sort */</a>
<a name="ln3292">    n1 = ((const AT_NUMB *)a1)[1];    /* component ordering number -- ascending order */</a>
<a name="ln3293">    n2 = ((const AT_NUMB *)a2)[1];</a>
<a name="ln3294">    ret = (int)n1 - (int)n2;</a>
<a name="ln3295"> </a>
<a name="ln3296">    return ret;</a>
<a name="ln3297">    </a>
<a name="ln3298">}</a>
<a name="ln3299">/*************************************************************************************************/</a>
<a name="ln3300">int MarkDisconnectedComponents( ORIG_ATOM_DATA *orig_at_data, int bProcessOldCompNumbers )</a>
<a name="ln3301">{</a>
<a name="ln3302">    typedef AT_NUMB AT_TRIPLE[3];</a>
<a name="ln3303"> </a>
<a name="ln3304">    inp_ATOM  *at                  = orig_at_data-&gt;at;</a>
<a name="ln3305">    int        num_at              = orig_at_data-&gt;num_inp_atoms;</a>
<a name="ln3306">    AT_NUMB *nCurAtLen           = NULL;</a>
<a name="ln3307">    </a>
<a name="ln3308">    AT_NUMB *nNewCompNumber      = NULL;</a>
<a name="ln3309">    AT_NUMB *nPrevAtom           = NULL;</a>
<a name="ln3310">    S_CHAR  *iNeigh              = NULL;</a>
<a name="ln3311"> </a>
<a name="ln3312">    AT_NUMB *nOldCompNumber      = NULL;</a>
<a name="ln3313">    int i, j, num_components, ret;</a>
<a name="ln3314">    int new_comp_no;</a>
<a name="ln3315">    AT_NUMB old_comp_no, another_comp_no, no_component;</a>
<a name="ln3316"> </a>
<a name="ln3317">    /* component_nbr[i][0] = number of atoms in the component i-1</a>
<a name="ln3318">     * component_nbr[i][1] = original component number (id-1) = i</a>
<a name="ln3319">     * after sorting:</a>
<a name="ln3320">     * component_nbr[j][2] = new number of component #(component_nbr[i][1]+1)</a>
<a name="ln3321">     */</a>
<a name="ln3322">    AT_TRIPLE *component_nbr = NULL;</a>
<a name="ln3323"> </a>
<a name="ln3324">    /* initialize */</a>
<a name="ln3325">    if ( bProcessOldCompNumbers &amp;&amp; !orig_at_data-&gt;nOldCompNumber ) {</a>
<a name="ln3326">        bProcessOldCompNumbers = 0; </a>
<a name="ln3327">    }</a>
<a name="ln3328">    num_components = 0;</a>
<a name="ln3329">    /*</a>
<a name="ln3330">    for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln3331">        at[j].component = 0;</a>
<a name="ln3332">    }</a>
<a name="ln3333">    */</a>
<a name="ln3334">    ret = -1;</a>
<a name="ln3335">    if ( !num_at ) {</a>
<a name="ln3336">        return 0;</a>
<a name="ln3337">    }</a>
<a name="ln3338">    if ( !( nNewCompNumber = (AT_NUMB *) inchi_calloc( num_at, sizeof(nNewCompNumber[0]) ) ) ||</a>
<a name="ln3339">         /* for non-recursive DFS only: */</a>
<a name="ln3340">         !( nPrevAtom      = (AT_NUMB *) inchi_calloc( num_at, sizeof(nPrevAtom[0]) ) ) ||</a>
<a name="ln3341">         !( iNeigh         = (S_CHAR  *) inchi_calloc( num_at, sizeof(iNeigh[0]) ) )) {</a>
<a name="ln3342">        goto exit_function;</a>
<a name="ln3343">    }</a>
<a name="ln3344">    /* mark and count; avoid deep DFS recursion: it may make verifying software unhappy */</a>
<a name="ln3345">    /* nNewCompNumber[i] will contain new component number for atoms at[i], i=0..num_at-1 */</a>
<a name="ln3346">    for ( j = 0; j &lt; num_at; j++ ) {</a>
<a name="ln3347">        if ( !nNewCompNumber[j] ) {</a>
<a name="ln3348">            /* mark starting with at[j] */</a>
<a name="ln3349">            int fst_at, nxt_at, cur_at = j;</a>
<a name="ln3350">            num_components ++;</a>
<a name="ln3351">            /* first time at at[j] */</a>
<a name="ln3352">            nNewCompNumber[fst_at = cur_at] = (AT_NUMB) num_components;</a>
<a name="ln3353">            /* find next neighbor */</a>
<a name="ln3354">            while ( 1 ) {</a>
<a name="ln3355">                if ( iNeigh[cur_at] &lt; at[cur_at].valence ) {</a>
<a name="ln3356">                    nxt_at = at[cur_at].neighbor[(int)iNeigh[cur_at] ++];</a>
<a name="ln3357">                    if ( !nNewCompNumber[nxt_at] ) {</a>
<a name="ln3358">                        /* forward edge: found new atom */</a>
<a name="ln3359">                        nNewCompNumber[nxt_at] = (AT_NUMB) num_components;</a>
<a name="ln3360">                        nPrevAtom[nxt_at]      = (AT_NUMB) cur_at;</a>
<a name="ln3361">                        cur_at = nxt_at;</a>
<a name="ln3362">                    }</a>
<a name="ln3363">                } else</a>
<a name="ln3364">                if ( cur_at == fst_at ) {</a>
<a name="ln3365">                    break; /* done */</a>
<a name="ln3366">                } else {</a>
<a name="ln3367">                    cur_at = nPrevAtom[cur_at]; /* retract */</a>
<a name="ln3368">                }</a>
<a name="ln3369">            }</a>
<a name="ln3370">        }</a>
<a name="ln3371">    }</a>
<a name="ln3372">    inchi_free( nPrevAtom ); nPrevAtom = NULL;</a>
<a name="ln3373">    inchi_free( iNeigh );    iNeigh    = NULL;</a>
<a name="ln3374"> </a>
<a name="ln3375">    /* Allocate more memory */</a>
<a name="ln3376">    i = inchi_max( num_components, orig_at_data-&gt;num_components ); </a>
<a name="ln3377">    if ( !(nCurAtLen      = (AT_NUMB *) inchi_calloc( num_components+1, sizeof(nCurAtLen[0]) ) ) ||</a>
<a name="ln3378">         !(nOldCompNumber = (AT_NUMB *) inchi_calloc( i             +1, sizeof(nOldCompNumber[0]) ) ) ||</a>
<a name="ln3379">         !(component_nbr  = (AT_TRIPLE *) inchi_calloc( num_components+1, sizeof(component_nbr[0]) ) ) ) {</a>
<a name="ln3380">        goto exit_function;</a>
<a name="ln3381">    }</a>
<a name="ln3382"> </a>
<a name="ln3383">    /* count atoms per component and renumber the components */</a>
<a name="ln3384">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln3385">        component_nbr[i][0] = 0; /* number of atoms in the component */</a>
<a name="ln3386">        component_nbr[i][1] = i; /* component ordering number */</a>
<a name="ln3387">    }</a>
<a name="ln3388">    for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln3389">        component_nbr[(int)nNewCompNumber[j]-1][0] ++; /* count atoms in each component */</a>
<a name="ln3390">    }</a>
<a name="ln3391">    /* sort key: number of atoms; order: descending */</a>
<a name="ln3392">    qsort( (void*)component_nbr[0], num_components,</a>
<a name="ln3393">           sizeof(component_nbr[0]), cmp_components);</a>
<a name="ln3394">    /* invert the transposition */</a>
<a name="ln3395">    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln3396">        nCurAtLen[i] = component_nbr[i][0];</a>
<a name="ln3397">        component_nbr[ component_nbr[i][1] ][2] = i+1;</a>
<a name="ln3398">    }</a>
<a name="ln3399">    /* renumber the components so that the component with the greatest number of atoms is the first */</a>
<a name="ln3400">    no_component = num_at+1;</a>
<a name="ln3401">    for ( j = 0; j &lt; num_at; j ++ ) {</a>
<a name="ln3402">        /* new component number for at[j] */</a>
<a name="ln3403">        new_comp_no = component_nbr[(int)nNewCompNumber[j]-1][2]-1; /* starts from 0 */</a>
<a name="ln3404">        if ( bProcessOldCompNumbers ) {</a>
<a name="ln3405">            /* old component number for at[j] */</a>
<a name="ln3406">            old_comp_no = at[j].component;</a>
<a name="ln3407">            /* fill out nOldCompNumber[]; initially it contains zeroes */</a>
<a name="ln3408">            if ( !old_comp_no ) {</a>
<a name="ln3409">                nOldCompNumber[new_comp_no] = no_component; /* atom did not have component number */</a>
<a name="ln3410">            } else</a>
<a name="ln3411">            if ( nOldCompNumber[new_comp_no] !=  old_comp_no ) {</a>
<a name="ln3412">                if ( !nOldCompNumber[new_comp_no] ) {</a>
<a name="ln3413">                    nOldCompNumber[new_comp_no] = old_comp_no;</a>
<a name="ln3414">                } else {</a>
<a name="ln3415">                    /* at[j] moved from old comp #old_comp_no to old comp #nOldCompNumber[new_comp_no]</a>
<a name="ln3416">                       Both components cannot be equal to any current component */</a>
<a name="ln3417">                    another_comp_no = nOldCompNumber[new_comp_no];</a>
<a name="ln3418">                    for ( i = 0; i &lt; num_components; i ++ ) {</a>
<a name="ln3419">                        if ( nOldCompNumber[i] == old_comp_no ||</a>
<a name="ln3420">                             nOldCompNumber[i] == another_comp_no ) {</a>
<a name="ln3421">                            nOldCompNumber[i] = no_component;</a>
<a name="ln3422">                        }</a>
<a name="ln3423">                    }</a>
<a name="ln3424">                    /* nOldCompNumber[new_comp_no] = num_at+1; */</a>
<a name="ln3425">                }</a>
<a name="ln3426">            }</a>
<a name="ln3427">        }</a>
<a name="ln3428">        /* orig_at_data-&gt;nOldCompNumber */</a>
<a name="ln3429">        at[j].component = new_comp_no+1;  /* starts from 1 */</a>
<a name="ln3430">    }</a>
<a name="ln3431">    if ( bProcessOldCompNumbers ) { </a>
<a name="ln3432">        for ( j = 0; j &lt; num_components; j ++ ) {</a>
<a name="ln3433">            if ( nOldCompNumber[j] == no_component ) {</a>
<a name="ln3434">                /* the component has atom from another component */</a>
<a name="ln3435">                nOldCompNumber[j] = 0;</a>
<a name="ln3436">            } else</a>
<a name="ln3437">            if ( nOldCompNumber[j] &amp;&amp; </a>
<a name="ln3438">                 !orig_at_data-&gt;nOldCompNumber[nOldCompNumber[j]-1] ) {</a>
<a name="ln3439">                /* the component has changed in the previous processing  */</a>
<a name="ln3440">                nOldCompNumber[j] = 0;</a>
<a name="ln3441">            }</a>
<a name="ln3442">        }</a>
<a name="ln3443">    } else {</a>
<a name="ln3444">        for ( j = 0; j &lt; num_components; j ++ ) {</a>
<a name="ln3445">            nOldCompNumber[j] = j + 1;</a>
<a name="ln3446">        }</a>
<a name="ln3447">    }</a>
<a name="ln3448">    ret = num_components;</a>
<a name="ln3449">exit_function:</a>
<a name="ln3450">    if ( nNewCompNumber )</a>
<a name="ln3451">        inchi_free( nNewCompNumber );</a>
<a name="ln3452">    if ( component_nbr )</a>
<a name="ln3453">        inchi_free( component_nbr );</a>
<a name="ln3454"> </a>
<a name="ln3455">    if ( ret &lt; 0 ) {</a>
<a name="ln3456">        if ( nPrevAtom ) {</a>
<a name="ln3457">            inchi_free( nPrevAtom );</a>
<a name="ln3458">            nPrevAtom = NULL;</a>
<a name="ln3459">        }</a>
<a name="ln3460">        if ( iNeigh ) {</a>
<a name="ln3461">            inchi_free( iNeigh );</a>
<a name="ln3462">            iNeigh = NULL;</a>
<a name="ln3463">        }</a>
<a name="ln3464">        if ( nCurAtLen ) {</a>
<a name="ln3465">            inchi_free( nCurAtLen );</a>
<a name="ln3466">            nCurAtLen = NULL;</a>
<a name="ln3467">        }</a>
<a name="ln3468">        if ( nOldCompNumber ) {</a>
<a name="ln3469">            inchi_free( nOldCompNumber );</a>
<a name="ln3470">            nOldCompNumber = NULL;</a>
<a name="ln3471">        }</a>
<a name="ln3472">        num_components = ret;</a>
<a name="ln3473">    }</a>
<a name="ln3474">    /* avoid memory leaks */</a>
<a name="ln3475">    if ( orig_at_data-&gt;nCurAtLen )</a>
<a name="ln3476">        inchi_free ( orig_at_data-&gt;nCurAtLen );</a>
<a name="ln3477">    if ( orig_at_data-&gt;nOldCompNumber )</a>
<a name="ln3478">        inchi_free ( orig_at_data-&gt;nOldCompNumber );</a>
<a name="ln3479"> </a>
<a name="ln3480">    orig_at_data-&gt;nCurAtLen      = nCurAtLen;</a>
<a name="ln3481">    orig_at_data-&gt;nOldCompNumber = nOldCompNumber;</a>
<a name="ln3482"> </a>
<a name="ln3483">    orig_at_data-&gt;num_components = num_components;</a>
<a name="ln3484"> </a>
<a name="ln3485">    return ret;  /* number of disconnected components; 1=&gt;single connected structure*/</a>
<a name="ln3486">}</a>
<a name="ln3487">/******************************************************************************/</a>
<a name="ln3488">/*                        Extract one (connected) component                   */</a>
<a name="ln3489">/******************************************************************************/</a>
<a name="ln3490">int ExtractConnectedComponent(  inp_ATOM *at, int num_at, int component_number, inp_ATOM *component_at )</a>
<a name="ln3491">{</a>
<a name="ln3492">    int i, j, num_component_at;</a>
<a name="ln3493">    AT_NUMB *number;</a>
<a name="ln3494">    if ( NULL == (number = (AT_NUMB*)inchi_calloc(num_at, sizeof(AT_NUMB)))){</a>
<a name="ln3495">        return CT_OUT_OF_RAM; /* out of memory */  /*   &lt;BRKPT&gt; */</a>
<a name="ln3496">    }</a>
<a name="ln3497">    /* copy atoms */</a>
<a name="ln3498">    for ( i = 0, num_component_at = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3499">        if ( at[i].component == component_number ) {</a>
<a name="ln3500">            number[i] = num_component_at;</a>
<a name="ln3501">            component_at[num_component_at ++] = at[i];</a>
<a name="ln3502">        }</a>
<a name="ln3503">    }</a>
<a name="ln3504">    /* renumber neighbors */</a>
<a name="ln3505">    for ( i = 0; i &lt; num_component_at; i ++ ) {</a>
<a name="ln3506">        component_at[i].orig_compt_at_numb = (AT_NUMB)(i + 1);</a>
<a name="ln3507">        for ( j = 0; j &lt; component_at[i].valence; j ++ ) {</a>
<a name="ln3508">            component_at[i].neighbor[j] = number[(int)component_at[i].neighbor[j]];</a>
<a name="ln3509">        }</a>
<a name="ln3510">    }</a>
<a name="ln3511">    inchi_free( number );</a>
<a name="ln3512">    return num_component_at;</a>
<a name="ln3513">}</a>
<a name="ln3514">/****************************************************************/</a>
<a name="ln3515">int SetConnectedComponentNumber( inp_ATOM *at, int num_at, int component_number )</a>
<a name="ln3516">{</a>
<a name="ln3517">    int i;</a>
<a name="ln3518">    for ( i = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3519">        at[i].component = (AT_NUMB)component_number;</a>
<a name="ln3520">    }</a>
<a name="ln3521">    return 0;</a>
<a name="ln3522">}</a>
<a name="ln3523">/****************************************************************/</a>
<a name="ln3524"> </a>
<a name="ln3525">int Free_INChI_Stereo( INChI_Stereo *pINChI_Stereo )</a>
<a name="ln3526">{</a>
<a name="ln3527">    if ( pINChI_Stereo ) {</a>
<a name="ln3528">        qzfree( pINChI_Stereo-&gt;nNumber );</a>
<a name="ln3529">        qzfree( pINChI_Stereo-&gt;t_parity );</a>
<a name="ln3530">        qzfree( pINChI_Stereo-&gt;nNumberInv );</a>
<a name="ln3531">        qzfree( pINChI_Stereo-&gt;t_parityInv );</a>
<a name="ln3532">        qzfree( pINChI_Stereo-&gt;nBondAtom1 );</a>
<a name="ln3533">        qzfree( pINChI_Stereo-&gt;nBondAtom2 );</a>
<a name="ln3534">        qzfree( pINChI_Stereo-&gt;b_parity );</a>
<a name="ln3535">    }</a>
<a name="ln3536">    return 0;</a>
<a name="ln3537">}</a>
<a name="ln3538"> </a>
<a name="ln3539">/****************************************************************/</a>
<a name="ln3540">INChI_Stereo *Alloc_INChI_Stereo(int num_at, int num_bonds)</a>
<a name="ln3541">{</a>
<a name="ln3542">    INChI_Stereo *pINChI_Stereo = (INChI_Stereo *)inchi_calloc(1, sizeof(INChI_Stereo));</a>
<a name="ln3543">    if ( pINChI_Stereo ) {</a>
<a name="ln3544">        if ( num_at &amp;&amp;</a>
<a name="ln3545">             (pINChI_Stereo-&gt;nNumber  = (AT_NUMB *)inchi_calloc(num_at, sizeof(pINChI_Stereo-&gt;nNumber[0]))) &amp;&amp;</a>
<a name="ln3546">             (pINChI_Stereo-&gt;t_parity = (S_CHAR  *)inchi_calloc(num_at, sizeof(pINChI_Stereo-&gt;t_parity[0]))) </a>
<a name="ln3547">             &amp;&amp; (pINChI_Stereo-&gt;nNumberInv  = (AT_NUMB *)inchi_calloc(num_at, sizeof(pINChI_Stereo-&gt;nNumberInv[0])))</a>
<a name="ln3548">             &amp;&amp; (pINChI_Stereo-&gt;t_parityInv = (S_CHAR  *)inchi_calloc(num_at, sizeof(pINChI_Stereo-&gt;t_parityInv[0]))) </a>
<a name="ln3549">             ) {</a>
<a name="ln3550">            ;</a>
<a name="ln3551">        } else</a>
<a name="ln3552">        if ( num_at ) {</a>
<a name="ln3553">            goto out_of_RAM;</a>
<a name="ln3554">        }</a>
<a name="ln3555">        if ( num_bonds &amp;&amp;</a>
<a name="ln3556">             (pINChI_Stereo-&gt;nBondAtom1 =(AT_NUMB *)inchi_calloc(num_bonds, sizeof(pINChI_Stereo-&gt;nBondAtom1[0]))) &amp;&amp;</a>
<a name="ln3557">             (pINChI_Stereo-&gt;nBondAtom2 =(AT_NUMB *)inchi_calloc(num_bonds, sizeof(pINChI_Stereo-&gt;nBondAtom2[0]))) &amp;&amp;</a>
<a name="ln3558">             (pINChI_Stereo-&gt;b_parity   =(S_CHAR  *)inchi_calloc(num_bonds, sizeof(pINChI_Stereo-&gt;b_parity[0]))) ) {</a>
<a name="ln3559">            ;</a>
<a name="ln3560">        } else</a>
<a name="ln3561">        if ( num_bonds ) {</a>
<a name="ln3562">            goto out_of_RAM;</a>
<a name="ln3563">        }</a>
<a name="ln3564">        return pINChI_Stereo;</a>
<a name="ln3565"> </a>
<a name="ln3566">out_of_RAM:</a>
<a name="ln3567">        Free_INChI_Stereo( pINChI_Stereo );</a>
<a name="ln3568">        qzfree( pINChI_Stereo );</a>
<a name="ln3569">    }</a>
<a name="ln3570">    return NULL;</a>
<a name="ln3571">}</a>
<a name="ln3572">/****************************************************************/</a>
<a name="ln3573">int Free_INChI(INChI **ppINChI)</a>
<a name="ln3574">{</a>
<a name="ln3575">    INChI *pINChI;</a>
<a name="ln3576"> </a>
<a name="ln3577">    if ( (pINChI = *ppINChI) ) {</a>
<a name="ln3578">#if ( bREUSE_INCHI == 1 )</a>
<a name="ln3579">        if ( pINChI-&gt;nRefCount -- &gt; 0 )</a>
<a name="ln3580">            return 1;</a>
<a name="ln3581">#endif</a>
<a name="ln3582">        Free_INChI_Members(pINChI);</a>
<a name="ln3583"> </a>
<a name="ln3584">        qzfree( pINChI );</a>
<a name="ln3585">        *ppINChI = NULL;</a>
<a name="ln3586"> </a>
<a name="ln3587">    }</a>
<a name="ln3588">    return 0;</a>
<a name="ln3589">}</a>
<a name="ln3590">/****************************************************************/</a>
<a name="ln3591">int Free_INChI_Members(INChI *pINChI)</a>
<a name="ln3592">{</a>
<a name="ln3593">    if ( pINChI ) {</a>
<a name="ln3594">        </a>
<a name="ln3595">        Free_INChI_Stereo(pINChI-&gt;Stereo           );</a>
<a name="ln3596">        Free_INChI_Stereo(pINChI-&gt;StereoIsotopic   );</a>
<a name="ln3597">        qzfree(pINChI-&gt;nAtom                    );</a>
<a name="ln3598">        qzfree(pINChI-&gt;nConnTable               );</a>
<a name="ln3599">        qzfree(pINChI-&gt;nTautomer                );</a>
<a name="ln3600">        qzfree(pINChI-&gt;nNum_H                   );</a>
<a name="ln3601">        qzfree(pINChI-&gt;nNum_H_fixed             );</a>
<a name="ln3602">        qzfree(pINChI-&gt;IsotopicAtom             );</a>
<a name="ln3603">        qzfree(pINChI-&gt;IsotopicTGroup           );</a>
<a name="ln3604">        qzfree(pINChI-&gt;nPossibleLocationsOfIsotopicH);</a>
<a name="ln3605">        qzfree(pINChI-&gt;Stereo           );</a>
<a name="ln3606">        qzfree(pINChI-&gt;StereoIsotopic   );</a>
<a name="ln3607">        qzfree(pINChI-&gt;szHillFormula );</a>
<a name="ln3608">    }</a>
<a name="ln3609">    return 0;</a>
<a name="ln3610">}</a>
<a name="ln3611">/****************************************************************/</a>
<a name="ln3612">INChI *Alloc_INChI( inp_ATOM *at, int num_at, int *found_num_bonds, int *found_num_isotopic, int nAllocMode )</a>
<a name="ln3613">{</a>
<a name="ln3614">    int    i, num_bonds, num_isotopic_atoms;</a>
<a name="ln3615">    INChI  *pINChI;</a>
<a name="ln3616">    int    bIsotopic   = (nAllocMode &amp; REQ_MODE_ISO);</a>
<a name="ln3617">    /* int    bTautomeric = (nAllocMode &amp; REQ_MODE_TAUT); */</a>
<a name="ln3618"> </a>
<a name="ln3619">    if ( num_at &lt;= 0 || NULL == (pINChI = (INChI *)inchi_calloc( 1, sizeof(INChI)))) {</a>
<a name="ln3620">        return NULL;</a>
<a name="ln3621">    }</a>
<a name="ln3622"> </a>
<a name="ln3623">    for ( i = 0, num_bonds = 0, num_isotopic_atoms = 0; i &lt; num_at; i ++ ) {</a>
<a name="ln3624">        num_bonds += at[i].valence;</a>
<a name="ln3625">        /* if ( bIsotopic ) { */</a>
<a name="ln3626">            num_isotopic_atoms += (0 != at[i].iso_atw_diff ||</a>
<a name="ln3627">                                   !strcmp(at[i].elname, &quot;D&quot;) ||</a>
<a name="ln3628">                                   !strcmp(at[i].elname, &quot;T&quot;) ||</a>
<a name="ln3629">                                    at[i].num_iso_H[0] ||</a>
<a name="ln3630">                                    at[i].num_iso_H[1] ||</a>
<a name="ln3631">                                    at[i].num_iso_H[2]);</a>
<a name="ln3632">        /* } */</a>
<a name="ln3633"> </a>
<a name="ln3634">    }</a>
<a name="ln3635">    num_bonds /= 2;</a>
<a name="ln3636"> </a>
<a name="ln3637">    *found_num_bonds    = num_bonds;</a>
<a name="ln3638">    *found_num_isotopic = num_isotopic_atoms;</a>
<a name="ln3639"> </a>
<a name="ln3640"> </a>
<a name="ln3641">    if ( (pINChI-&gt;nAtom       = (U_CHAR*) inchi_calloc( num_at, sizeof(pINChI-&gt;nAtom[0]))) &amp;&amp;</a>
<a name="ln3642">         (pINChI-&gt;nConnTable  = (AT_NUMB*)inchi_calloc( num_at+num_bonds, sizeof(pINChI-&gt;nConnTable[0]))) &amp;&amp;</a>
<a name="ln3643">         (pINChI-&gt;nTautomer   = (AT_NUMB*)inchi_calloc( ((3+INCHI_T_NUM_MOVABLE)*num_at)/2+1, sizeof(pINChI-&gt;nTautomer[0]))) &amp;&amp;</a>
<a name="ln3644">         (pINChI-&gt;nNum_H      = (S_CHAR*) inchi_calloc( num_at, sizeof(pINChI-&gt;nNum_H[0]))) &amp;&amp;</a>
<a name="ln3645">         (pINChI-&gt;nNum_H_fixed= (S_CHAR*) inchi_calloc( num_at, sizeof(pINChI-&gt;nNum_H_fixed[0])))</a>
<a name="ln3646">         ) {</a>
<a name="ln3647">        ; /* nTautomer length: max. number of tautomeric groups is num_at/2</a>
<a name="ln3648">           </a>
<a name="ln3649">           1 word                     -&gt; number of t-groups</a>
<a name="ln3650">           </a>
<a name="ln3651">           each group has:</a>
<a name="ln3652"> </a>
<a name="ln3653">           1 word                     -&gt; number of endpoints+INCHI_T_NUM_MOVABLE</a>
<a name="ln3654">           INCHI_T_NUM_MOVABLE words   -&gt; number(s) of moveable attachments</a>
<a name="ln3655">           numbers of endpoints words -&gt; canon. numbers</a>
<a name="ln3656"> </a>
<a name="ln3657">           max. occurs if each t-group has 2 atoms (num_at/2 t-groups) and all atoms</a>
<a name="ln3658">                          belong to t-groups (num_at endpoints)</a>
<a name="ln3659"> </a>
<a name="ln3660">           Total: 1 + (number of t-groups)*(1+INCHI_T_NUM_MOVABLE) + (number of endpoints) &lt;=</a>
<a name="ln3661">                  1 + (num_at/2) * (1+INCHI_T_NUM_MOVABLE) + num_at &lt;=</a>
<a name="ln3662">                  1 + (3+INCHI_T_NUM_MOVABLE)*num_at/2 words.</a>
<a name="ln3663">           */</a>
<a name="ln3664"> </a>
<a name="ln3665">    } else {</a>
<a name="ln3666">        goto out_of_RAM;</a>
<a name="ln3667">    }</a>
<a name="ln3668">    pINChI-&gt;szHillFormula = NULL; /*  the length is unknown */</a>
<a name="ln3669">    if ( bIsotopic ) {</a>
<a name="ln3670">        if ( num_isotopic_atoms &amp;&amp;</a>
<a name="ln3671">             (pINChI-&gt;IsotopicAtom              = (INChI_IsotopicAtom *)inchi_calloc(num_isotopic_atoms, sizeof(INChI_IsotopicAtom) )) &amp;&amp;</a>
<a name="ln3672">             (pINChI-&gt;IsotopicTGroup            = (INChI_IsotopicTGroup *)inchi_calloc(num_isotopic_atoms, sizeof(INChI_IsotopicTGroup) ))</a>
<a name="ln3673">            ) {</a>
<a name="ln3674">            ;</a>
<a name="ln3675">        } else</a>
<a name="ln3676">        if ( num_isotopic_atoms ) {</a>
<a name="ln3677">            goto out_of_RAM;</a>
<a name="ln3678">        }</a>
<a name="ln3679">        if ( !(pINChI-&gt;nPossibleLocationsOfIsotopicH = (AT_NUMB *)inchi_calloc( num_at+1, sizeof(pINChI-&gt;nPossibleLocationsOfIsotopicH[0]) ) ) ) {</a>
<a name="ln3680">            goto out_of_RAM;</a>
<a name="ln3681">        }</a>
<a name="ln3682">    }</a>
<a name="ln3683"> </a>
<a name="ln3684">    if ((pINChI-&gt;Stereo            = Alloc_INChI_Stereo(num_at, num_bonds))</a>
<a name="ln3685">       ) {</a>
<a name="ln3686">        ;</a>
<a name="ln3687">    } else {</a>
<a name="ln3688">        goto out_of_RAM;</a>
<a name="ln3689">    }</a>
<a name="ln3690">    if ( bIsotopic ) {</a>
<a name="ln3691">        if ((pINChI-&gt;StereoIsotopic    = Alloc_INChI_Stereo(num_at, num_bonds))</a>
<a name="ln3692">           ) {</a>
<a name="ln3693">            ;</a>
<a name="ln3694">        } else {</a>
<a name="ln3695">            goto out_of_RAM;</a>
<a name="ln3696">        }</a>
<a name="ln3697">    }</a>
<a name="ln3698">    return pINChI;</a>
<a name="ln3699"> </a>
<a name="ln3700">out_of_RAM:</a>
<a name="ln3701">    if ( pINChI ) {</a>
<a name="ln3702">        Free_INChI(&amp;pINChI);</a>
<a name="ln3703">        /*</a>
<a name="ln3704">        inchi_free(pINChI);</a>
<a name="ln3705">        */</a>
<a name="ln3706">    }</a>
<a name="ln3707">    return NULL;</a>
<a name="ln3708">}</a>
<a name="ln3709">/****************************************************************/</a>
<a name="ln3710">int Free_INChI_Aux( INChI_Aux **ppINChI_Aux )</a>
<a name="ln3711">{</a>
<a name="ln3712">    INChI_Aux *pINChI_Aux = *ppINChI_Aux;</a>
<a name="ln3713">    if ( pINChI_Aux ) {</a>
<a name="ln3714">#if ( bREUSE_INCHI == 1 )</a>
<a name="ln3715">        if ( pINChI_Aux-&gt;nRefCount -- &gt; 0 )</a>
<a name="ln3716">            return 1;</a>
<a name="ln3717">#endif</a>
<a name="ln3718"> </a>
<a name="ln3719">        qzfree( pINChI_Aux-&gt;nOrigAtNosInCanonOrd            );</a>
<a name="ln3720">        qzfree( pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd    );</a>
<a name="ln3721">        qzfree( pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv         );</a>
<a name="ln3722">        qzfree( pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv );</a>
<a name="ln3723">        qzfree( pINChI_Aux-&gt;szOrigCoord );</a>
<a name="ln3724">        qzfree( pINChI_Aux-&gt;OrigInfo );</a>
<a name="ln3725">/*</a>
<a name="ln3726">        qzfree( pINChI_Aux-&gt;nOriginalAtomNumber          );</a>
<a name="ln3727">        qzfree( pINChI_Aux-&gt;nCanonicalTGroupNumbers      );</a>
<a name="ln3728">        qzfree( pINChI_Aux-&gt;nIsotopicCanonicalTGroupNumbers);</a>
<a name="ln3729">        qzfree( pINChI_Aux-&gt;nTautomer                    );</a>
<a name="ln3730">        qzfree( pINChI_Aux-&gt;nNontautomericCanonicalNumbers         );</a>
<a name="ln3731">        qzfree( pINChI_Aux-&gt;nIsotopicCanonicalNumbers    );</a>
<a name="ln3732">        qzfree( pINChI_Aux-&gt;nNontautomericIsotopicCanonicalNumbers );</a>
<a name="ln3733">        qzfree( pINChI_Aux-&gt;nNontautomericEquNumbers               );</a>
<a name="ln3734">        qzfree( pINChI_Aux-&gt;nNontautomericIsotopicEquNumbers       );</a>
<a name="ln3735">*/</a>
<a name="ln3736">        qzfree( pINChI_Aux-&gt;nConstitEquNumbers                  );</a>
<a name="ln3737">        qzfree( pINChI_Aux-&gt;nConstitEquTGroupNumbers             );</a>
<a name="ln3738">        qzfree( pINChI_Aux-&gt;nConstitEquIsotopicNumbers          );</a>
<a name="ln3739">        qzfree( pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers     );</a>
<a name="ln3740">        qzfree( pINChI_Aux );</a>
<a name="ln3741">        *ppINChI_Aux = NULL;</a>
<a name="ln3742">    }</a>
<a name="ln3743">    return 0;</a>
<a name="ln3744">}</a>
<a name="ln3745">/****************************************************************/</a>
<a name="ln3746">INChI_Aux *Alloc_INChI_Aux( int num_at, int num_isotopic_atoms, int nAllocMode, int bOrigCoord )</a>
<a name="ln3747">{</a>
<a name="ln3748">    INChI_Aux     *pINChI_Aux;</a>
<a name="ln3749">    int    bIsotopic   = (nAllocMode &amp; REQ_MODE_ISO);</a>
<a name="ln3750">    int    num_at_tg   = num_at + num_at/2;</a>
<a name="ln3751">    /* int    bTautomeric = (nAllocMode &amp; REQ_MODE_TAUT); */</a>
<a name="ln3752"> </a>
<a name="ln3753">    if ( num_at &lt;= 0 || NULL == (pINChI_Aux = (INChI_Aux *)inchi_calloc(sizeof(INChI_Aux), 1))) {</a>
<a name="ln3754">        return NULL;</a>
<a name="ln3755">    }</a>
<a name="ln3756">    if ( (pINChI_Aux-&gt;nOrigAtNosInCanonOrd      = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nOrigAtNosInCanonOrd[0]), num_at_tg)) &amp;&amp;</a>
<a name="ln3757">         (pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv   = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nOrigAtNosInCanonOrd[0]), num_at_tg)) &amp;&amp;</a>
<a name="ln3758">         (pINChI_Aux-&gt;nConstitEquNumbers        = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nConstitEquNumbers[0]), num_at_tg)) ) {</a>
<a name="ln3759">        ;</a>
<a name="ln3760">    } else {</a>
<a name="ln3761">        goto out_of_RAM;</a>
<a name="ln3762">    }</a>
<a name="ln3763"> </a>
<a name="ln3764">    if ( num_at &gt; 1 &amp;&amp;</a>
<a name="ln3765">         (pINChI_Aux-&gt;nConstitEquTGroupNumbers  = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nConstitEquTGroupNumbers[0]), num_at/2+1)) ) {</a>
<a name="ln3766">        ;</a>
<a name="ln3767">    } else</a>
<a name="ln3768">    if ( num_at &gt; 1 ) {</a>
<a name="ln3769">        goto out_of_RAM;</a>
<a name="ln3770">    }</a>
<a name="ln3771">    </a>
<a name="ln3772">    if ( num_at &gt; 0 ) {</a>
<a name="ln3773">        pINChI_Aux-&gt;OrigInfo    = (ORIG_INFO *)inchi_calloc(sizeof(pINChI_Aux-&gt;OrigInfo[0]), num_at);</a>
<a name="ln3774">        if ( !pINChI_Aux-&gt;OrigInfo )</a>
<a name="ln3775">            goto out_of_RAM;</a>
<a name="ln3776">    }</a>
<a name="ln3777">    if ( bOrigCoord &amp;&amp; num_at &gt; 0 ) {</a>
<a name="ln3778">        pINChI_Aux-&gt;szOrigCoord = (MOL_COORD *)inchi_calloc(sizeof(pINChI_Aux-&gt;szOrigCoord[0]), num_at);</a>
<a name="ln3779">        if ( !pINChI_Aux-&gt;szOrigCoord )</a>
<a name="ln3780">            goto out_of_RAM;</a>
<a name="ln3781">    }</a>
<a name="ln3782">    if ( bIsotopic ) {</a>
<a name="ln3783">        if ( /*num_isotopic_atoms &amp;&amp;*/</a>
<a name="ln3784">             (pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd    = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd[0]), num_at_tg)) &amp;&amp;</a>
<a name="ln3785">             (pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd[0]), num_at_tg)) &amp;&amp;</a>
<a name="ln3786">             (pINChI_Aux-&gt;nConstitEquIsotopicNumbers      = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nConstitEquIsotopicNumbers[0]), num_at_tg)) ) {</a>
<a name="ln3787">            ;</a>
<a name="ln3788">        } else</a>
<a name="ln3789">        if ( num_isotopic_atoms ) {</a>
<a name="ln3790">            goto out_of_RAM;</a>
<a name="ln3791">        }</a>
<a name="ln3792">        if ( /*num_isotopic_atoms &amp;&amp; num_at &gt; 1 &amp;&amp;*/</a>
<a name="ln3793">             (pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers = (AT_NUMB*)inchi_calloc(sizeof(pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers[0]), num_at/2+1)) ) {</a>
<a name="ln3794">            ;</a>
<a name="ln3795">        } else</a>
<a name="ln3796">        if ( num_isotopic_atoms &amp;&amp; num_at &gt; 1 ) {</a>
<a name="ln3797">            goto out_of_RAM;</a>
<a name="ln3798">        }</a>
<a name="ln3799">    }</a>
<a name="ln3800">    return pINChI_Aux;</a>
<a name="ln3801"> </a>
<a name="ln3802"> </a>
<a name="ln3803">out_of_RAM:</a>
<a name="ln3804">    if ( pINChI_Aux ) {</a>
<a name="ln3805">        Free_INChI_Aux(&amp;pINChI_Aux);</a>
<a name="ln3806">        /*</a>
<a name="ln3807">        inchi_free(pINChI_Aux);</a>
<a name="ln3808">        */</a>
<a name="ln3809">    }</a>
<a name="ln3810">    return NULL;</a>
<a name="ln3811">}</a>
<a name="ln3812">/***********************************************************************************/</a>
<a name="ln3813"> </a>
<a name="ln3814">#define IS_DEUTERIUM(i) (!strcmp( at[i].elname, &quot;D&quot; ) || at[i].iso_atw_diff == 2 &amp;&amp; !strcmp( at[i].elname, &quot;H&quot; ))</a>
<a name="ln3815">#define IS_TRITIUM(i)   (!strcmp( at[i].elname, &quot;T&quot; ) || at[i].iso_atw_diff == 3 &amp;&amp; !strcmp( at[i].elname, &quot;H&quot; ))</a>
<a name="ln3816"> </a>
<a name="ln3817">#define ABNORMAL_ISO(i) (at[i].iso_atw_diff == 1 || at[i].iso_atw_diff &lt; -3 || at[i].iso_atw_diff &gt; 5 )</a>
<a name="ln3818">#define ABNORMAL_CHG(i) (abs(at[i].charge) &gt; 3)</a>
<a name="ln3819">#define ABNORMAL_RAD(i) (RADICAL_SINGLET &lt;= at[i].radical &amp;&amp; at[i].radical &lt;= RADICAL_TRIPLET )</a>
<a name="ln3820"> </a>
<a name="ln3821">#define ANY_ISO(i, X)   ((X)? (at[i].iso_atw_diff &amp;&amp; !IS_DEUTERIUM(i) &amp;&amp; !IS_TRITIUM(i)) :\</a>
<a name="ln3822">                              (at[i].iso_atw_diff ||  IS_DEUTERIUM(i) ||  IS_TRITIUM(i)))</a>
<a name="ln3823">#define ANY_CHG(i)      (0 != at[i].charge)</a>
<a name="ln3824">#define ANY_RAD(i)      (RADICAL_SINGLET &lt;= at[i].radical &amp;&amp; at[i].radical &lt;= RADICAL_TRIPLET )</a>
<a name="ln3825"> </a>
<a name="ln3826">#define NORMAL_ISO(i, X)   (ANY_ISO(i, X) &amp;&amp; !ABNORMAL_ISO(i))</a>
<a name="ln3827"> </a>
<a name="ln3828"> </a>
<a name="ln3829">/* needs additional M  CHG. M  RAD, M  ISO line */</a>
<a name="ln3830">/* due to ISIS/Draw feature always include M  RAD for any radical */</a>
<a name="ln3831">#define ABNORMAL_AT(i) ( at[i].radical || abs(at[i].charge) &gt; 3 || \</a>
<a name="ln3832">                         ABNORMAL_ISO(i) )</a>
<a name="ln3833"> </a>
<a name="ln3834">/* always add M  ISO, M  RAD, M  CHG; Except: (bAtomsDT &amp;&amp; D or T) */</a>
<a name="ln3835">#define ADD_LINE_AT(i) ( at[i].charge  || \</a>
<a name="ln3836">                         at[i].radical || \</a>
<a name="ln3837">                         at[i].iso_atw_diff &amp;&amp; (bAtomsDT? (at[i].iso_atw_diff != 1 || strcmp(at[i].elname, &quot;H&quot;)) : 1) )</a>
<a name="ln3838">#define ALIASED_AT(i) (0 &lt; NUM_ISO_H(at, i))</a>
<a name="ln3839">/***********************************************************************************/</a>
<a name="ln3840">#if ( TEST_RENUMB_ATOMS_SAVE_LONGEST == 1 || TEST_RENUMB_SWITCH == 1 )</a>
<a name="ln3841">int WriteToSDfile( const INP_ATOM_DATA *inp_at_data, INCHI_IOSTREAM* fcb, const char* name, const char* comment,</a>
<a name="ln3842">                   const char *szLabel, const char *szValue)</a>
<a name="ln3843">{</a>
<a name="ln3844">    int i, j, k, num_bonds=0, ret=0, bAtomsDT = 1 /* treat D, T as normal atoms */, bV2000 = 0 /*V2000 Molfile */;</a>
<a name="ln3845">    int bAtomNeedsAlias;</a>
<a name="ln3846">    int flag_bad_charge=0, flag_bad_iso=0, nNumAddLines=0, nNumIsoLines=0, nNumChargeLines=0, nNumRadicalLines=0, nNumAliasLines=0;</a>
<a name="ln3847">    int nNumNecessaryIsoLines = 0, nNumNecessaryChgLines = 0, nNumNecessaryRadLines = 0;</a>
<a name="ln3848">    /*sp_ATOM *at; */</a>
<a name="ln3849">    /*float fzero=0.0F;*/</a>
<a name="ln3850">    double x, y, z;</a>
<a name="ln3851">    int bNext /*, s*/;</a>
<a name="ln3852">    const inp_ATOM *at = inp_at_data-&gt;at_fixed_bonds? inp_at_data-&gt;at_fixed_bonds : inp_at_data-&gt;at;</a>
<a name="ln3853">    int num_atoms      = inp_at_data-&gt;num_at;</a>
<a name="ln3854">    /*at = species-&gt;atom;*/</a>
<a name="ln3855">    </a>
<a name="ln3856">    /*inchi_ios_eprint(fcb,&quot;%ld.MOL\n&quot;,species-&gt;casno);*/</a>
<a name="ln3857">    {   /* block start */</a>
<a name="ln3858">        char strLocName[82];</a>
<a name="ln3859">        memset(strLocName, 0, sizeof(strLocName) );</a>
<a name="ln3860">        if ( name &amp;&amp; *name ) {</a>
<a name="ln3861">            strncpy( strLocName, name, 80 );</a>
<a name="ln3862">        }</a>
<a name="ln3863">        inchi_ios_print_nodisplay( fcb,&quot;%s\n&quot;, strLocName );</a>
<a name="ln3864">    }   /* block end */</a>
<a name="ln3865">    /**********************************************************************/</a>
<a name="ln3866">    /**                                                                  **/</a>
<a name="ln3867">    /** Important: Atoms with alias cannot have charge, radical, or      **/</a>
<a name="ln3868">    /**            isotope differences.                                  **/</a>
<a name="ln3869">    /**                                                                  **/</a>
<a name="ln3870">    /**            Atoms with alias cannot be abnormal.                  **/</a>
<a name="ln3871">    /**                                                                  **/</a>
<a name="ln3872">    /** Abnormal atoms are atoms which need M  CHG, M RAD, M  ISO        **/</a>
<a name="ln3873">    /**                                                                  **/</a>
<a name="ln3874">    /**********************************************************************/</a>
<a name="ln3875"> </a>
<a name="ln3876">    /*                                    F10.5     F12.5       I6</a>
<a name="ln3877">                     IIPPPPPPPPMMDDYYHHmmddSSssssssssssEEEEEEEEEEEERRRRRR</a>
<a name="ln3878">    inchi_ios_eprint( fcb,&quot;NISTTRANHP09089809272D 1   1.0         0.0    %6ld\n&quot;, lEpa);*/</a>
<a name="ln3879"> </a>
<a name="ln3880">    /*^^^</a>
<a name="ln3881">    inchi_ios_print_nodisplay( fcb,&quot;  -%s v%s SDfile Output                         \n&quot;, INCHI_NAME, INCHI_VERSION);</a>
<a name="ln3882"> </a>
<a name="ln3883">    Changed 01/10/2009 to conform CTFile specification (by Symyx request)*/</a>
<a name="ln3884">    inchi_ios_print_nodisplay( fcb,</a>
<a name="ln3885">    /*   IIPPPPPPPPMMDDYYHHmmddSSssssssssssEEEEEEEEEEEERRRRRR*/</a>
<a name="ln3886">        &quot;  InChIV10                                     \n&quot;);</a>
<a name="ln3887"> </a>
<a name="ln3888"> </a>
<a name="ln3889"> </a>
<a name="ln3890">    /*y_fprintf(fcb, &quot;  -CPSS-  1213981200n\n&quot;);*/</a>
<a name="ln3891"> </a>
<a name="ln3892">    {   /*block start*/</a>
<a name="ln3893">        char strLocName[82];</a>
<a name="ln3894">        </a>
<a name="ln3895">        memset(strLocName, 0, sizeof(strLocName) );</a>
<a name="ln3896">        if ( comment &amp;&amp; *comment ) {</a>
<a name="ln3897">            strncpy( strLocName, comment, 80 );</a>
<a name="ln3898">        }</a>
<a name="ln3899">        inchi_ios_print_nodisplay( fcb,&quot;%s\n&quot;, strLocName );</a>
<a name="ln3900">    }   /*block end*/</a>
<a name="ln3901">    for (i=0; i&lt; num_atoms; i++)</a>
<a name="ln3902">        num_bonds += at[i].valence;</a>
<a name="ln3903">    num_bonds /= 2;</a>
<a name="ln3904">    </a>
<a name="ln3905">    /*find if we need &quot;M  CHG&quot;, &quot;M  RAD&quot;, &quot;M  ISO&quot; */</a>
<a name="ln3906">    for (i=0, nNumAddLines = 0; i &lt; num_atoms; i++) {</a>
<a name="ln3907">        if ( bAtomNeedsAlias = ALIASED_AT(i) ) {</a>
<a name="ln3908">            nNumAliasLines  += 2 * bAtomNeedsAlias;</a>
<a name="ln3909">        } else {</a>
<a name="ln3910">            nNumNecessaryIsoLines += ABNORMAL_ISO(i);</a>
<a name="ln3911">            nNumNecessaryChgLines += ABNORMAL_CHG(i);</a>
<a name="ln3912">            nNumNecessaryRadLines += ABNORMAL_RAD(i);</a>
<a name="ln3913">            nNumIsoLines          += ANY_ISO(i, bAtomsDT); </a>
<a name="ln3914">            nNumChargeLines       += ANY_CHG(i);</a>
<a name="ln3915">            nNumRadicalLines      += ANY_RAD(i);</a>
<a name="ln3916">        }</a>
<a name="ln3917">    }</a>
<a name="ln3918">    if ( !bV2000 ) {</a>
<a name="ln3919">        if ( !nNumNecessaryRadLines &amp;&amp; !nNumNecessaryChgLines ) {</a>
<a name="ln3920">            nNumRadicalLines = 0;</a>
<a name="ln3921">            nNumChargeLines  = 0;</a>
<a name="ln3922">        }</a>
<a name="ln3923">        if ( !nNumNecessaryIsoLines ) {</a>
<a name="ln3924">            nNumIsoLines = 0;</a>
<a name="ln3925">        }</a>
<a name="ln3926">    }</a>
<a name="ln3927"> </a>
<a name="ln3928"> </a>
<a name="ln3929">    /* count additional M lines*/</a>
<a name="ln3930">    nNumChargeLines  = ( nNumChargeLines  + 7 ) / 8;</a>
<a name="ln3931">    nNumRadicalLines = ( nNumRadicalLines + 7 ) / 8;</a>
<a name="ln3932">    nNumIsoLines     = ( nNumIsoLines     + 7 ) / 8;</a>
<a name="ln3933">    </a>
<a name="ln3934">    nNumAddLines = nNumChargeLines + nNumRadicalLines + nNumIsoLines + nNumAliasLines; /* 1 for M  END*/</a>
<a name="ln3935">    </a>
<a name="ln3936">    if ( nNumAddLines || bV2000 ) {</a>
<a name="ln3937">        nNumAddLines += 1; /* add 1 for &quot;M  END&quot; line*/</a>
<a name="ln3938">    }</a>
<a name="ln3939">    </a>
<a name="ln3940">    /*                         aaabbblllfffcccsssxxxrrrpppiiimmmvvvvvv*/</a>
<a name="ln3941">    inchi_ios_print_nodisplay(fcb,&quot;%3d%3d  0  0  0  0  0  0  0  0%3d%s\n&quot;,num_atoms, num_bonds, nNumAddLines,nNumAddLines?&quot; V2000&quot;:&quot;&quot;);</a>
<a name="ln3942">    /* atoms block*/</a>
<a name="ln3943">    for (i=0; i &lt; num_atoms; i++)  {</a>
<a name="ln3944">        char elname[ATOM_EL_LEN];</a>
<a name="ln3945">        int  iso       = 0;</a>
<a name="ln3946">        int  charge    = 0;</a>
<a name="ln3947">        int  valence   = 0;</a>
<a name="ln3948">        int  nIsotopeH = IS_DEUTERIUM(i)? 1 : IS_TRITIUM(i)? 2 : 0;</a>
<a name="ln3949">        bAtomNeedsAlias = ALIASED_AT(i);   /* Has implicit D and/or T neighbors */</a>
<a name="ln3950">        memset( elname, 0, sizeof(elname) );</a>
<a name="ln3951">        </a>
<a name="ln3952">        if ( bAtomNeedsAlias ) {</a>
<a name="ln3953">            /* alias */</a>
<a name="ln3954">            strcpy ( elname, &quot;C&quot; );</a>
<a name="ln3955">        } else {</a>
<a name="ln3956">            /* isotope*/</a>
<a name="ln3957">            if ( nIsotopeH ) {</a>
<a name="ln3958">                strcpy( elname, bAtomsDT? ( nIsotopeH==1? &quot;D&quot; : &quot;T&quot; ) : &quot;H&quot; );</a>
<a name="ln3959">            } else {</a>
<a name="ln3960">                strncpy ( elname, at[i].elname, sizeof(elname)-1 );</a>
<a name="ln3961">            }</a>
<a name="ln3962">            if ( !ABNORMAL_CHG(i) &amp;&amp; !ANY_RAD(i) ) {</a>
<a name="ln3963">                /* charge*/</a>
<a name="ln3964">                /* Only atoms without alias can be here*/</a>
<a name="ln3965">                switch ( at[i].charge ) {</a>
<a name="ln3966">                   case  3: charge = 1; break;</a>
<a name="ln3967">                   case  2: charge = 2; break;</a>
<a name="ln3968">                   case  1: charge = 3; break;</a>
<a name="ln3969">                   case -1: charge = 5; break;</a>
<a name="ln3970">                   case -2: charge = 6; break;</a>
<a name="ln3971">                   case -3: charge = 7; break;</a>
<a name="ln3972">                   case  0: charge = 0; break;</a>
<a name="ln3973">                   default: flag_bad_charge = 1; break;</a>
<a name="ln3974">                };</a>
<a name="ln3975">            }</a>
<a name="ln3976">            /* radical*/</a>
<a name="ln3977">            if ( ANY_RAD(i) &amp;&amp; !ANY_CHG(i) ) {</a>
<a name="ln3978">                if ( at[i].radical == RADICAL_DOUBLET ) {</a>
<a name="ln3979">                    charge = 4;</a>
<a name="ln3980">                }</a>
<a name="ln3981">            }</a>
<a name="ln3982">        }</a>
<a name="ln3983">        /* allow isotopic shift for aliased atoms */</a>
<a name="ln3984">        if ( NORMAL_ISO(i, bAtomsDT) ) {</a>
<a name="ln3985">            iso = at[i].iso_atw_diff &gt; 0? at[i].iso_atw_diff-1:</a>
<a name="ln3986">                  at[i].iso_atw_diff &lt; 0? at[i].iso_atw_diff  :</a>
<a name="ln3987">                  nIsotopeH? nIsotopeH : (flag_bad_iso ++, 0);</a>
<a name="ln3988">        }</a>
<a name="ln3989">        </a>
<a name="ln3990">        x = at[i].x;</a>
<a name="ln3991">        y = at[i].y;</a>
<a name="ln3992">        z = at[i].z;</a>
<a name="ln3993"> </a>
<a name="ln3994">        if( at[i].num_H &gt; 0 ) {</a>
<a name="ln3995">            for ( j = 0, valence = 0; j &lt; at[i].valence; j++ ) {</a>
<a name="ln3996">                switch( k = at[i].bond_type[j] ) { /* fixed valence calculation 12-23-99 DCh.*/</a>
<a name="ln3997">                case 2:</a>
<a name="ln3998">                case 3:</a>
<a name="ln3999">                    valence += 2*k;</a>
<a name="ln4000">                    break;</a>
<a name="ln4001">                case 4:</a>
<a name="ln4002">                    valence += 3;</a>
<a name="ln4003">                    break;</a>
<a name="ln4004">                default:</a>
<a name="ln4005">                    valence += 2;</a>
<a name="ln4006">                }</a>
<a name="ln4007">            }</a>
<a name="ln4008">            valence = valence/2 + at[i].num_H;</a>
<a name="ln4009">        } else</a>
<a name="ln4010">        /* Added 07-09-2003 DCh*/</a>
<a name="ln4011">        if ( at[i].chem_bonds_valence &gt; 0 ) {</a>
<a name="ln4012">            valence = at[i].chem_bonds_valence;</a>
<a name="ln4013">        } else</a>
<a name="ln4014">        /* Added 07-09-2003 DCh*/</a>
<a name="ln4015">        if ( !at[i].valence &amp;&amp; !at[i].num_H &amp;&amp; !at[i].chem_bonds_valence ) {</a>
<a name="ln4016">            valence = 15;</a>
<a name="ln4017">        }</a>
<a name="ln4018">        /*inchi_ios_eprint(fcb,&quot;%10.4f%10.4f%10.4f %-3.3s%2d%3d  0     0  0  0  0  0  0\n&quot;,*/</a>
<a name="ln4019">        /*    (float)at[i].x, (float)(-at[i].y), fzero, at[i].elname, iso, charge);*/</a>
<a name="ln4020">        /*              xxxxxxyyyyyyzzzzzz aaa____ddcccsssnnnbbbvvvrrriiimmmeee  */</a>
<a name="ln4021">        inchi_ios_print_nodisplay(fcb,&quot;%10.4f%10.4f%10.4f %-3.3s%2d%3d  0     0%3d  0  0  0  0\n&quot;,</a>
<a name="ln4022">                   x, y, z, elname, (int)iso, (int)charge, valence /* at[i].special*/);</a>
<a name="ln4023">            /* reflect image against x-axis;</a>
<a name="ln4024">               when transforming MOLfile back to STDATA in mol_to_stdata(...),</a>
<a name="ln4025">               make one more reflection to restore original orientation.</a>
<a name="ln4026">               Reason: in MS Search y-axis is directed from top to bottom,</a>
<a name="ln4027">                       while in MOLfile y-axis goes from bottom to top.</a>
<a name="ln4028">             */</a>
<a name="ln4029">    }        </a>
<a name="ln4030">    bNext = 0; /* debug only*/</a>
<a name="ln4031">    </a>
<a name="ln4032">    /* bonds*/</a>
<a name="ln4033">    for (i=0; i&lt; num_atoms; i++) {</a>
<a name="ln4034">        for (j=0; j&lt;at[i].valence; j++) {</a>
<a name="ln4035">            if (i &lt; at[i].neighbor[j]) {</a>
<a name="ln4036">                if ( k=at[i].bond_stereo[j] ) {</a>
<a name="ln4037">                    /* bond stereo */</a>
<a name="ln4038">                    if ( k &lt; 0 ) {</a>
<a name="ln4039">                        /* transposition */</a>
<a name="ln4040">                        inchi_ios_print_nodisplay(fcb,&quot;%3u%3u%3u%3u  0  0  0\n&quot;,</a>
<a name="ln4041">                            (unsigned)(at[i].neighbor[j]+1), (unsigned)(i+1), (unsigned)(at[i].bond_type[j]), (unsigned)abs(k));</a>
<a name="ln4042">                    } else {</a>
<a name="ln4043">                        /* no transposition*/</a>
<a name="ln4044">                        inchi_ios_print_nodisplay(fcb,&quot;%3u%3u%3u%3u  0  0  0\n&quot;,</a>
<a name="ln4045">                            (unsigned)(i+1), (unsigned)(at[i].neighbor[j]+1), (unsigned)(at[i].bond_type[j]), (unsigned)abs(k));</a>
<a name="ln4046">                    }</a>
<a name="ln4047">                } else {</a>
<a name="ln4048">                    inchi_ios_print_nodisplay(fcb,&quot;%3u%3u%3u  0  0  0  0\n&quot;,</a>
<a name="ln4049">                        (unsigned)(i+1), (unsigned)(at[i].neighbor[j]+1), (unsigned)(at[i].bond_type[j]));</a>
<a name="ln4050">                }</a>
<a name="ln4051">            }</a>
<a name="ln4052">        }</a>
<a name="ln4053">    }</a>
<a name="ln4054">    if ( nNumAddLines ) {</a>
<a name="ln4055">        char str_m[66], entry[10];</a>
<a name="ln4056">        int  num_m;</a>
<a name="ln4057">        </a>
<a name="ln4058">        /* Aliases. 5-3-99 DCh.*/</a>
<a name="ln4059">        if ( nNumAliasLines ) {</a>
<a name="ln4060">            num_m = 0;</a>
<a name="ln4061">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4062">                if ( ALIASED_AT(i) ) {</a>
<a name="ln4063">                    int num_H;</a>
<a name="ln4064">                    inchi_ios_print_nodisplay( fcb, &quot;A  %d\n&quot;, i+1 );</a>
<a name="ln4065">                    num_m ++;</a>
<a name="ln4066">                    strcpy( str_m, at[i].elname );</a>
<a name="ln4067">                    /* Add H, D, T */</a>
<a name="ln4068">                    if ( num_H = at[i].num_H + at[i].num_iso_H[0] ) { /* protium is lost here */</a>
<a name="ln4069">                        strcat( str_m, &quot;H&quot; );</a>
<a name="ln4070">                        if ( num_H &gt; 1 ) {</a>
<a name="ln4071">                            sprintf( str_m + strlen(str_m), &quot;%d&quot;, num_H );</a>
<a name="ln4072">                        }</a>
<a name="ln4073">                    }</a>
<a name="ln4074">                    if ( num_H = at[i].num_iso_H[1] ) { /* deuterium */</a>
<a name="ln4075">                        strcat( str_m, &quot;D&quot; );</a>
<a name="ln4076">                        if ( num_H &gt; 1 ) {</a>
<a name="ln4077">                            sprintf( str_m + strlen(str_m), &quot;%d&quot;, num_H );</a>
<a name="ln4078">                        }</a>
<a name="ln4079">                    }</a>
<a name="ln4080">                    if ( num_H = at[i].num_iso_H[2] ) { /* Tritium */</a>
<a name="ln4081">                        strcat( str_m, &quot;T&quot; );</a>
<a name="ln4082">                        if ( num_H &gt; 1 ) {</a>
<a name="ln4083">                            sprintf( str_m + strlen(str_m), &quot;%d&quot;, num_H );</a>
<a name="ln4084">                        }</a>
<a name="ln4085">                    }</a>
<a name="ln4086">                    /* Add charge to the Alias */</a>
<a name="ln4087">                    if ( at[i].charge){</a>
<a name="ln4088">                        strcat(str_m, at[i].charge&gt;0? &quot;+&quot; : &quot;-&quot;);</a>
<a name="ln4089">                        if ( 1 &lt; (j=abs(at[i].charge)) )</a>
<a name="ln4090">                            sprintf( str_m+strlen(str_m), &quot;%d&quot;, j );</a>
<a name="ln4091">                    }</a>
<a name="ln4092">                    /* Add radical to the Alias */</a>
<a name="ln4093">                    switch( at[i].radical ) {</a>
<a name="ln4094">                    case RADICAL_SINGLET:</a>
<a name="ln4095">                        strcat( str_m, &quot;:&quot; );</a>
<a name="ln4096">                        break;</a>
<a name="ln4097">                    case RADICAL_DOUBLET:</a>
<a name="ln4098">                        strcat( str_m, &quot;^&quot; );</a>
<a name="ln4099">                        break;</a>
<a name="ln4100">                    case RADICAL_TRIPLET:</a>
<a name="ln4101">                        strcat( str_m, &quot;^^&quot; );</a>
<a name="ln4102">                        break;</a>
<a name="ln4103">                    }</a>
<a name="ln4104">                    inchi_ios_print_nodisplay( fcb, &quot;%s\n&quot;, str_m );</a>
<a name="ln4105">                    num_m ++;</a>
<a name="ln4106">                }</a>
<a name="ln4107">            }</a>
<a name="ln4108">            if ( num_m != nNumAliasLines ) {</a>
<a name="ln4109">                /* error in lines counting*/</a>
<a name="ln4110">                ret ++;</a>
<a name="ln4111">            }</a>
<a name="ln4112">        }</a>
<a name="ln4113">        /* charges*/</a>
<a name="ln4114">        str_m[0] = 0;</a>
<a name="ln4115">        num_m    = 0;</a>
<a name="ln4116">        if ( nNumChargeLines ) {</a>
<a name="ln4117">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4118">                if ( ANY_CHG(i) &amp;&amp; !ALIASED_AT(i) ) {</a>
<a name="ln4119">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, (int)at[i].charge );</a>
<a name="ln4120">                    strcat( str_m, entry );</a>
<a name="ln4121">                    num_m ++;</a>
<a name="ln4122">                }</a>
<a name="ln4123">                if ( i == num_atoms-1 &amp;&amp; num_m || num_m == 8 ) {</a>
<a name="ln4124">                    inchi_ios_print_nodisplay( fcb, &quot;M  CHG%3d%s\n&quot;, num_m, str_m );</a>
<a name="ln4125">                    str_m[0] = 0;</a>
<a name="ln4126">                    num_m    = 0;</a>
<a name="ln4127">                }</a>
<a name="ln4128">            }</a>
<a name="ln4129">        }</a>
<a name="ln4130">        /* radicals*/</a>
<a name="ln4131">        str_m[0] = 0;</a>
<a name="ln4132">        num_m    = 0;</a>
<a name="ln4133">        if ( nNumRadicalLines ) {</a>
<a name="ln4134">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4135">                if ( ANY_RAD(i) &amp;&amp; !ALIASED_AT(i) ) {</a>
<a name="ln4136">                    int radical = (at[i].radical==RADICAL_SINGLET ||</a>
<a name="ln4137">                                   at[i].radical==RADICAL_DOUBLET ||</a>
<a name="ln4138">                                   at[i].radical==RADICAL_TRIPLET)? at[i].radical : 0;</a>
<a name="ln4139">                    if ( radical ) {</a>
<a name="ln4140">                        sprintf( entry, &quot; %3d %3d&quot;, i+1, radical );</a>
<a name="ln4141">                        strcat( str_m, entry );</a>
<a name="ln4142">                        num_m ++;</a>
<a name="ln4143">                    }</a>
<a name="ln4144">                }</a>
<a name="ln4145">                if ( i == num_atoms-1 &amp;&amp; num_m || num_m == 8 ) {</a>
<a name="ln4146">                    inchi_ios_print_nodisplay( fcb, &quot;M  RAD%3d%s\n&quot;, num_m, str_m );</a>
<a name="ln4147">                    str_m[0] = 0;</a>
<a name="ln4148">                    num_m    = 0;</a>
<a name="ln4149">                }</a>
<a name="ln4150">            }</a>
<a name="ln4151">        }</a>
<a name="ln4152">        /* isotopes*/</a>
<a name="ln4153">        str_m[0] = 0;</a>
<a name="ln4154">        num_m    = 0;</a>
<a name="ln4155">        if ( nNumIsoLines ) {</a>
<a name="ln4156">            int el_num, iso;</a>
<a name="ln4157">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4158">                if ( ANY_ISO(i,bAtomsDT) &amp;&amp; !ALIASED_AT(i) ) {</a>
<a name="ln4159">                    if ( IS_DEUTERIUM(i) ) {</a>
<a name="ln4160">                        iso = 1;</a>
<a name="ln4161">                        el_num = 1;</a>
<a name="ln4162">                    } else</a>
<a name="ln4163">                    if ( IS_TRITIUM(i) ) {</a>
<a name="ln4164">                        iso = 2;</a>
<a name="ln4165">                        el_num = 1;</a>
<a name="ln4166">                    } else {</a>
<a name="ln4167">                        iso = at[i].iso_atw_diff &gt; 0? at[i].iso_atw_diff-1 : at[i].iso_atw_diff;</a>
<a name="ln4168">                        el_num = at[i].el_number;</a>
<a name="ln4169">                    }</a>
<a name="ln4170">                    iso += get_atw_from_elnum( el_num );</a>
<a name="ln4171"> </a>
<a name="ln4172">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, iso );</a>
<a name="ln4173">                    strcat( str_m, entry );</a>
<a name="ln4174">                    num_m ++;</a>
<a name="ln4175">                }</a>
<a name="ln4176"> </a>
<a name="ln4177">                if ( i == num_atoms-1 &amp;&amp; num_m || num_m == 8 ) {</a>
<a name="ln4178">                    inchi_ios_print_nodisplay( fcb, &quot;M  ISO%3d%s\n&quot;, num_m, str_m );</a>
<a name="ln4179">                    str_m[0] = 0;</a>
<a name="ln4180">                    num_m    = 0;</a>
<a name="ln4181">                }</a>
<a name="ln4182">            }</a>
<a name="ln4183">        }</a>
<a name="ln4184">        inchi_ios_print_nodisplay( fcb, &quot;M  END\n&quot; );</a>
<a name="ln4185">    }</a>
<a name="ln4186">    if ( szValue &amp;&amp; szValue[0] ) {</a>
<a name="ln4187">        if ( szLabel &amp;&amp; szLabel[0] ) {</a>
<a name="ln4188">            inchi_ios_print_nodisplay( fcb, &quot;&gt;  &lt;%s&gt;\n&quot;, szLabel );</a>
<a name="ln4189">        } else {</a>
<a name="ln4190">            inchi_ios_print_nodisplay( fcb, &quot;&gt;  &lt;ID&gt;\n&quot; );</a>
<a name="ln4191">        }</a>
<a name="ln4192">        inchi_ios_print_nodisplay( fcb, &quot;%s\n\n&quot;, szValue );</a>
<a name="ln4193">    }</a>
<a name="ln4194">    inchi_ios_print_nodisplay(fcb, &quot;$$$$\n&quot;);</a>
<a name="ln4195">    </a>
<a name="ln4196">    </a>
<a name="ln4197">    return ret;</a>
<a name="ln4198">    </a>
<a name="ln4199">}</a>
<a name="ln4200">#endif</a>
<a name="ln4201">/***************************************************************************************************/</a>
<a name="ln4202">int WriteOrigAtomDataToSDfile(const ORIG_ATOM_DATA *inp_at_data, INCHI_IOSTREAM * fcb, const char* name, </a>
<a name="ln4203">                              const char* comment, int bChiralFlag, int bAtomsDT, const char *szLabel, const char *szValue)</a>
<a name="ln4204">{</a>
<a name="ln4205">    int i, j, k, num_bonds=0, ret=0;</a>
<a name="ln4206">    int bAtomNeedsAlias;</a>
<a name="ln4207">    int flag_bad_charge=0, flag_bad_iso = 0;</a>
<a name="ln4208">    int nNumAddLines=0, nNumIsoLines=0, nNumChargeLines=0, nNumRadicalLines=0, nNumAliasLines=0;</a>
<a name="ln4209">    int nNumNecessaryIsoLines = 0, nNumNecessaryChgLines = 0, nNumNecessaryRadLines = 0;</a>
<a name="ln4210">    int bV2000 = SDF_OUTPUT_V2000;</a>
<a name="ln4211">    double x, y, z;</a>
<a name="ln4212">    int bNext /*, s*/;</a>
<a name="ln4213">    const inp_ATOM *at = inp_at_data-&gt;at;</a>
<a name="ln4214">    int num_atoms      = inp_at_data-&gt;num_inp_atoms;</a>
<a name="ln4215">    /*at = species-&gt;atom;*/</a>
<a name="ln4216">    </a>
<a name="ln4217">    /*inchi_ios_eprint(fcb,&quot;%ld.MOL\n&quot;,species-&gt;casno);*/</a>
<a name="ln4218">    {   /* block start */</a>
<a name="ln4219">        char strLocName[82];</a>
<a name="ln4220">        memset(strLocName, 0, sizeof(strLocName) );</a>
<a name="ln4221">        if ( name &amp;&amp; *name ) {</a>
<a name="ln4222">            strncpy( strLocName, name, 80 );</a>
<a name="ln4223">             /* --- debug only ---</a>
<a name="ln4224">            if ( strstr( name, &quot;#3959&quot; ) ) {</a>
<a name="ln4225">                int stop = 1;</a>
<a name="ln4226">            }</a>
<a name="ln4227">            */</a>
<a name="ln4228">        }</a>
<a name="ln4229">        inchi_ios_print_nodisplay( fcb,&quot;%s\n&quot;, strLocName );</a>
<a name="ln4230">    }   /* block end */</a>
<a name="ln4231">    /**********************************************************************/</a>
<a name="ln4232">    /**                                                                  **/</a>
<a name="ln4233">    /** Important: Atoms with alias cannot have charge, radical          **/</a>
<a name="ln4234">    /**            isotope differences are allowed                       **/</a>
<a name="ln4235">    /**                                                                  **/</a>
<a name="ln4236">    /**            Atoms with alias cannot be abnormal.                  **/</a>
<a name="ln4237">    /**                                                                  **/</a>
<a name="ln4238">    /** Abnormal atoms are atoms which need M  CHG, M RAD, M  ISO        **/</a>
<a name="ln4239">    /**                                                                  **/</a>
<a name="ln4240">    /** Output aliased atoms if they have implicit D or T                **/</a>
<a name="ln4241">    /**                                                                  **/</a>
<a name="ln4242">    /**********************************************************************/</a>
<a name="ln4243"> </a>
<a name="ln4244">    /*                                    F10.5     F12.5       I6</a>
<a name="ln4245">                     IIPPPPPPPPMMDDYYHHmmddSSssssssssssEEEEEEEEEEEERRRRRR</a>
<a name="ln4246">    inchi_ios_eprint( fcb,&quot;NISTTRANHP09089809272D 1   1.0         0.0    %6ld\n&quot;, lEpa);*/</a>
<a name="ln4247">    /*^^^</a>
<a name="ln4248">    inchi_ios_print_nodisplay( fcb,&quot;  %s v%s SDfile Output                       \n&quot;, INCHI_NAME, INCHI_VERSION);</a>
<a name="ln4249">    </a>
<a name="ln4250">    Changed 01/10/2009 to conform CTFile specification (by Symyx request)*/</a>
<a name="ln4251">    inchi_ios_print_nodisplay( fcb,</a>
<a name="ln4252">    /*   IIPPPPPPPPMMDDYYHHmmddSSssssssssssEEEEEEEEEEEERRRRRR*/</a>
<a name="ln4253">        &quot;  InChIV10                                     \n&quot;);</a>
<a name="ln4254">    /*y_fprintf(fcb, &quot;  -CPSS-  1213981200n\n&quot;);*/</a>
<a name="ln4255"> </a>
<a name="ln4256">    {   /*block start*/</a>
<a name="ln4257">        char strLocName[82];</a>
<a name="ln4258">        </a>
<a name="ln4259">        memset(strLocName, 0, sizeof(strLocName) );</a>
<a name="ln4260">        if ( comment &amp;&amp; *comment ) {</a>
<a name="ln4261">            strncpy( strLocName, comment, 80 );</a>
<a name="ln4262">        }</a>
<a name="ln4263">        inchi_ios_print_nodisplay( fcb,&quot;%s\n&quot;, strLocName );</a>
<a name="ln4264">    }   /*block end*/</a>
<a name="ln4265">    for (i=0; i&lt; num_atoms; i++)</a>
<a name="ln4266">        num_bonds += at[i].valence;</a>
<a name="ln4267">    num_bonds /= 2;</a>
<a name="ln4268">    </a>
<a name="ln4269">    /*find if we need &quot;M  CHG&quot; and &quot;M  RAD&quot;*/</a>
<a name="ln4270">    for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4271">        if ( (bAtomNeedsAlias = ALIASED_AT(i)) ) {     /* has isotopic implicit D or T; ignoring pure 1H */</a>
<a name="ln4272">            nNumAliasLines  += 2 * bAtomNeedsAlias;</a>
<a name="ln4273">        } else {</a>
<a name="ln4274">        /* abnormal means atom needs CHG, RAD, or ISO entry */</a>
<a name="ln4275">        /* nNumAddLines    += ABNORMAL_AT(i); */ </a>
<a name="ln4276">        /* nNumIso         += ( 0 == strcmp( at[i].elname, &quot;D&quot; ) || ( 0 == strcmp( at[i].elname, &quot;T&quot; ) || at[i].iso_atw_diff ) ); */</a>
<a name="ln4277">        /* nNumAddIso      += at[i].iso_atw_diff &amp;&amp; (at[i].iso_atw_diff == 1 || at[i].iso_atw_diff &lt; -3 || at[i].iso_atw_diff &gt; 5 ); */</a>
<a name="ln4278">            nNumNecessaryIsoLines += ABNORMAL_ISO(i);</a>
<a name="ln4279">            nNumNecessaryChgLines += ABNORMAL_CHG(i);</a>
<a name="ln4280">            nNumNecessaryRadLines += ABNORMAL_RAD(i);</a>
<a name="ln4281">            nNumIsoLines          += ANY_ISO(i, bAtomsDT); </a>
<a name="ln4282">            nNumChargeLines       += ANY_CHG(i);</a>
<a name="ln4283">            nNumRadicalLines      += ANY_RAD(i);</a>
<a name="ln4284">        }</a>
<a name="ln4285">    }</a>
<a name="ln4286">    nNumChargeLines  = ( nNumChargeLines  + 7 ) / 8;</a>
<a name="ln4287">    nNumRadicalLines = ( nNumRadicalLines + 7 ) / 8;</a>
<a name="ln4288">    nNumIsoLines     = ( nNumIsoLines     + 7 ) / 8;</a>
<a name="ln4289"> </a>
<a name="ln4290">    if ( !bV2000 ) {</a>
<a name="ln4291">        if ( !nNumNecessaryRadLines &amp;&amp; !nNumNecessaryChgLines ) {</a>
<a name="ln4292">            nNumRadicalLines = 0;</a>
<a name="ln4293">            nNumChargeLines  = 0;</a>
<a name="ln4294">        }</a>
<a name="ln4295">        if ( !nNumNecessaryIsoLines ) {</a>
<a name="ln4296">            nNumIsoLines = 0;</a>
<a name="ln4297">        }</a>
<a name="ln4298">    }</a>
<a name="ln4299"> </a>
<a name="ln4300"> </a>
<a name="ln4301">    /* recalculate number of added lines */</a>
<a name="ln4302">    nNumAddLines = nNumChargeLines + nNumRadicalLines + nNumIsoLines + nNumAliasLines; /* 1 for M  END*/</a>
<a name="ln4303">    </a>
<a name="ln4304">    if ( nNumAddLines || bV2000 ) {</a>
<a name="ln4305">        nNumAddLines += 1; /* add 1 for &quot;M  END&quot; line*/</a>
<a name="ln4306">    }</a>
<a name="ln4307">    </a>
<a name="ln4308">    /*                         aaabbblllfffcccsssxxxrrrpppiiimmmvvvvvv*/</a>
<a name="ln4309">    inchi_ios_print_nodisplay(fcb,&quot;%3d%3d  0  0%3d  0  0  0  0  0%3d%s\n&quot;,</a>
<a name="ln4310">                          num_atoms, num_bonds, bChiralFlag?1:0, nNumAddLines,nNumAddLines?&quot; V2000&quot;:&quot;&quot;);</a>
<a name="ln4311">    /* atoms block*/</a>
<a name="ln4312">    for (i=0; i &lt; num_atoms; i++)  {</a>
<a name="ln4313">        char elname[ATOM_EL_LEN] = &quot;\0\0\0\0\0&quot;;</a>
<a name="ln4314">        int  iso       = 0;</a>
<a name="ln4315">        int  charge    = 0;</a>
<a name="ln4316">        int  valence   = 0;</a>
<a name="ln4317">        int  nIsotopeH = IS_DEUTERIUM(i)? 1 : IS_TRITIUM(i)? 2 : 0;</a>
<a name="ln4318">        int  bonds_val;</a>
<a name="ln4319">        bAtomNeedsAlias = ALIASED_AT(i);</a>
<a name="ln4320">        memset( elname, 0, sizeof(elname) );</a>
<a name="ln4321">        </a>
<a name="ln4322">        if ( bAtomNeedsAlias ) {</a>
<a name="ln4323">            /* alias */</a>
<a name="ln4324">            strcpy ( elname, &quot;C&quot; );</a>
<a name="ln4325">        } else {</a>
<a name="ln4326">            /* isotope*/</a>
<a name="ln4327">            if ( nIsotopeH ) {</a>
<a name="ln4328">                strcpy( elname, bAtomsDT? ( nIsotopeH==1? &quot;D&quot; : &quot;T&quot; ) : &quot;H&quot; );</a>
<a name="ln4329">            } else {</a>
<a name="ln4330">                strncpy ( elname, at[i].elname, sizeof(elname)-1 );</a>
<a name="ln4331">            }</a>
<a name="ln4332">            if ( !ABNORMAL_CHG(i) &amp;&amp; !ANY_RAD(i) ) {</a>
<a name="ln4333">                /* charge*/</a>
<a name="ln4334">                /* Only atoms without alias can be here*/</a>
<a name="ln4335">                switch ( at[i].charge ) {</a>
<a name="ln4336">                   case  3: charge = 1; break;</a>
<a name="ln4337">                   case  2: charge = 2; break;</a>
<a name="ln4338">                   case  1: charge = 3; break;</a>
<a name="ln4339">                   case -1: charge = 5; break;</a>
<a name="ln4340">                   case -2: charge = 6; break;</a>
<a name="ln4341">                   case -3: charge = 7; break;</a>
<a name="ln4342">                   case  0: charge = 0; break;</a>
<a name="ln4343">                   default: flag_bad_charge = 1; break;</a>
<a name="ln4344">                };</a>
<a name="ln4345">            }</a>
<a name="ln4346">            /* radical*/</a>
<a name="ln4347">            if ( ANY_RAD(i) &amp;&amp; !ANY_CHG(i) ) {</a>
<a name="ln4348">                if ( at[i].radical == RADICAL_DOUBLET ) {</a>
<a name="ln4349">                    charge = 4;</a>
<a name="ln4350">                }</a>
<a name="ln4351">            }</a>
<a name="ln4352">        }</a>
<a name="ln4353">        /* allow isotopic shift for aliased atoms */</a>
<a name="ln4354">        if ( NORMAL_ISO(i, bAtomsDT) ) {</a>
<a name="ln4355">            iso = at[i].iso_atw_diff &gt; 0? at[i].iso_atw_diff-1:</a>
<a name="ln4356">                  at[i].iso_atw_diff &lt; 0? at[i].iso_atw_diff  :</a>
<a name="ln4357">                  nIsotopeH? nIsotopeH : (flag_bad_iso ++, 0);</a>
<a name="ln4358">        }</a>
<a name="ln4359">        </a>
<a name="ln4360">        x = at[i].x;</a>
<a name="ln4361">        y = at[i].y;</a>
<a name="ln4362">        z = at[i].z;</a>
<a name="ln4363"> </a>
<a name="ln4364">        /* valence -- set only if needed */</a>
<a name="ln4365">        bonds_val = nBondsValenceInpAt( at+i, NULL, NULL );</a>
<a name="ln4366">        valence=needed_unusual_el_valence( at[i].el_number, at[i].charge, at[i].radical,</a>
<a name="ln4367">                                 at[i].chem_bonds_valence, bonds_val, NUMH(at, i), at[i].valence );</a>
<a name="ln4368">        if ( valence &lt; 0 ) {</a>
<a name="ln4369">            valence = 15;  /* means no bonds nor H */</a>
<a name="ln4370">        }</a>
<a name="ln4371"> </a>
<a name="ln4372">        /*inchi_ios_eprint(fcb,&quot;%10.4f%10.4f%10.4f %-3.3s%2d%3d  0     0  0  0  0  0  0\n&quot;,*/</a>
<a name="ln4373">        /*    (float)at[i].x, (float)(-at[i].y), fzero, at[i].elname, iso, charge);*/</a>
<a name="ln4374">        /*              xxxxxxyyyyyyzzzzzz aaa____ddcccsssnnnbbbvvvrrriiimmmeee  */</a>
<a name="ln4375">        inchi_ios_print_nodisplay(fcb,&quot;%10.4f%10.4f%10.4f %-3.3s%2d%3d  0     0%3d  0  0  0  0\n&quot;,</a>
<a name="ln4376">                   x, y, z, elname, (int)iso, (int)charge, valence /* at[i].special*/);</a>
<a name="ln4377">            /* reflect image against x-axis;</a>
<a name="ln4378">               when transforming MOLfile back to STDATA in mol_to_stdata(...),</a>
<a name="ln4379">               make one more reflection to restore original orientation.</a>
<a name="ln4380">               Reason: in MS Search y-axis is directed from top to bottom,</a>
<a name="ln4381">                       while in MOLfile y-axis goes from bottom to top.</a>
<a name="ln4382">             */</a>
<a name="ln4383">    }        </a>
<a name="ln4384">    bNext = 0; /* debug only*/</a>
<a name="ln4385">    </a>
<a name="ln4386">    /* bonds*/</a>
<a name="ln4387">    for (i=0; i&lt; num_atoms; i++) {</a>
<a name="ln4388">        for (j=0; j&lt;at[i].valence; j++) {</a>
<a name="ln4389">            if (i &lt; at[i].neighbor[j]) {</a>
<a name="ln4390">                if ( (k=at[i].bond_stereo[j]) ) {</a>
<a name="ln4391">                    /* bond stereo */</a>
<a name="ln4392">                    if ( k &lt; 0 ) {</a>
<a name="ln4393">                        /* transposition */</a>
<a name="ln4394">                        inchi_ios_print_nodisplay(fcb,&quot;%3u%3u%3u%3u  0  0  0\n&quot;,</a>
<a name="ln4395">                            (unsigned)(at[i].neighbor[j]+1), (unsigned)(i+1), (unsigned)(at[i].bond_type[j]), (unsigned)abs(k));</a>
<a name="ln4396">                    } else {</a>
<a name="ln4397">                        /* no transposition*/</a>
<a name="ln4398">                        inchi_ios_print_nodisplay(fcb,&quot;%3u%3u%3u%3u  0  0  0\n&quot;,</a>
<a name="ln4399">                            (unsigned)(i+1), (unsigned)(at[i].neighbor[j]+1), (unsigned)(at[i].bond_type[j]), (unsigned)abs(k));</a>
<a name="ln4400">                    }</a>
<a name="ln4401">                } else {</a>
<a name="ln4402">                    inchi_ios_print_nodisplay(fcb,&quot;%3u%3u%3u  0  0  0  0\n&quot;,</a>
<a name="ln4403">                        (unsigned)(i+1), (unsigned)(at[i].neighbor[j]+1), (unsigned)(at[i].bond_type[j]));</a>
<a name="ln4404">                }</a>
<a name="ln4405">            }</a>
<a name="ln4406">        }</a>
<a name="ln4407">    }</a>
<a name="ln4408">    if ( nNumAddLines ) {</a>
<a name="ln4409">        char str_m[66], entry[10];</a>
<a name="ln4410">        int  num_m;</a>
<a name="ln4411">        </a>
<a name="ln4412">        /* Aliases. 5-3-99 DCh.*/</a>
<a name="ln4413">        if ( nNumAliasLines ) {</a>
<a name="ln4414">            num_m = 0;</a>
<a name="ln4415">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4416">                if ( ALIASED_AT(i) ) {</a>
<a name="ln4417">                    int len;</a>
<a name="ln4418">                    inchi_ios_print_nodisplay( fcb, &quot;A  %d\n&quot;, i+1 );</a>
<a name="ln4419">                    num_m ++;</a>
<a name="ln4420">                    len = sprintf( str_m, &quot;%s&quot;, at[i].elname );</a>
<a name="ln4421">                    /* add isotopic H to the alias */</a>
<a name="ln4422">                    for ( k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln4423">                        int num_H = at[i].num_iso_H[k] + (k? 0:at[i].num_H);</a>
<a name="ln4424">                        if ( num_H ) {</a>
<a name="ln4425">                            len += sprintf( str_m+len, &quot;%s&quot;, k == 0? &quot;H&quot; : k==1? &quot;D&quot; : k==2? &quot;T&quot; : &quot;?&quot; );</a>
<a name="ln4426">                            if ( num_H != 1 ) {</a>
<a name="ln4427">                                len += sprintf( str_m+len, &quot;%d&quot;, num_H );</a>
<a name="ln4428">                            }</a>
<a name="ln4429">                        }</a>
<a name="ln4430">                    }</a>
<a name="ln4431">                    /* Add charge to the Alias */</a>
<a name="ln4432">                    if ( at[i].charge){</a>
<a name="ln4433">                        len += sprintf(str_m+len, &quot;%s&quot;, at[i].charge&gt;0? &quot;+&quot; : &quot;-&quot;);</a>
<a name="ln4434">                        if ( 1 &lt; (j=abs(at[i].charge)) ) {</a>
<a name="ln4435">                            len += sprintf( str_m+len, &quot;%d&quot;, j );</a>
<a name="ln4436">                        }</a>
<a name="ln4437">                    }</a>
<a name="ln4438">                    /* Add radical to the Alias */</a>
<a name="ln4439">                    if ( at[i].radical == RADICAL_SINGLET ) {</a>
<a name="ln4440">                        len += sprintf( str_m+len, &quot;%s&quot;, &quot;:&quot; );</a>
<a name="ln4441">                    } else</a>
<a name="ln4442">                    if ( at[i].radical == RADICAL_DOUBLET ) {</a>
<a name="ln4443">                        len += sprintf( str_m+len, &quot;%s&quot;, &quot;^&quot; );</a>
<a name="ln4444">                    } else</a>
<a name="ln4445">                    if ( at[i].radical == RADICAL_TRIPLET ) {</a>
<a name="ln4446">                        len += sprintf( str_m+len, &quot;%s&quot;, &quot;^^&quot; );</a>
<a name="ln4447">                    }</a>
<a name="ln4448">                    inchi_ios_print_nodisplay( fcb, &quot;%s\n&quot;, str_m );</a>
<a name="ln4449">                    num_m ++;</a>
<a name="ln4450">                }</a>
<a name="ln4451">            }</a>
<a name="ln4452">            if ( num_m != nNumAliasLines ) {</a>
<a name="ln4453">                /* error in lines counting*/</a>
<a name="ln4454">                ret ++;</a>
<a name="ln4455">            }</a>
<a name="ln4456">        }</a>
<a name="ln4457">        /* charges*/</a>
<a name="ln4458">        str_m[0] = 0;</a>
<a name="ln4459">        num_m    = 0;</a>
<a name="ln4460">        if ( nNumChargeLines ) {</a>
<a name="ln4461">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4462">                if ( at[i].charge &amp;&amp; !ALIASED_AT(i) ) {</a>
<a name="ln4463">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, (int)at[i].charge );</a>
<a name="ln4464">                    strcat( str_m, entry );</a>
<a name="ln4465">                    num_m ++;</a>
<a name="ln4466">                }</a>
<a name="ln4467">                if ( (i == num_atoms-1 &amp;&amp; num_m) || num_m == 8 ) {</a>
<a name="ln4468">                    inchi_ios_print_nodisplay( fcb, &quot;M  CHG%3d%s\n&quot;, num_m, str_m );</a>
<a name="ln4469">                    str_m[0] = 0;</a>
<a name="ln4470">                    num_m    = 0;</a>
<a name="ln4471">                }</a>
<a name="ln4472">            }</a>
<a name="ln4473">        }</a>
<a name="ln4474">        /* radicals*/</a>
<a name="ln4475">        str_m[0] = 0;</a>
<a name="ln4476">        num_m    = 0;</a>
<a name="ln4477">        if ( nNumRadicalLines ) {</a>
<a name="ln4478">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4479">                if ( at[i].radical &amp;&amp; !ALIASED_AT(i) ) {</a>
<a name="ln4480">                    int radical = (at[i].radical==RADICAL_SINGLET ||</a>
<a name="ln4481">                                   at[i].radical==RADICAL_DOUBLET ||</a>
<a name="ln4482">                                   at[i].radical==RADICAL_TRIPLET)? at[i].radical : 0;</a>
<a name="ln4483">                    if ( radical ) {</a>
<a name="ln4484">                        sprintf( entry, &quot; %3d %3d&quot;, i+1, radical );</a>
<a name="ln4485">                        strcat( str_m, entry );</a>
<a name="ln4486">                        num_m ++;</a>
<a name="ln4487">                    }</a>
<a name="ln4488">                }</a>
<a name="ln4489">                if ( (i == num_atoms-1 &amp;&amp; num_m) || num_m == 8 ) {</a>
<a name="ln4490">                    inchi_ios_print_nodisplay( fcb, &quot;M  RAD%3d%s\n&quot;, num_m, str_m );</a>
<a name="ln4491">                    str_m[0] = 0;</a>
<a name="ln4492">                    num_m    = 0;</a>
<a name="ln4493">                }</a>
<a name="ln4494">            }</a>
<a name="ln4495">        }</a>
<a name="ln4496">        /* isotopes*/</a>
<a name="ln4497">        str_m[0] = 0;</a>
<a name="ln4498">        num_m    = 0;</a>
<a name="ln4499">        if ( nNumIsoLines ) {</a>
<a name="ln4500">            int el_num, iso;</a>
<a name="ln4501">            for (i=0; i &lt; num_atoms; i++) {</a>
<a name="ln4502">                /*</a>
<a name="ln4503">                if ( 0 == strcmp( at[i].elname, &quot;D&quot; ) ) {</a>
<a name="ln4504">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, 2 );</a>
<a name="ln4505">                    strcat( str_m, entry );</a>
<a name="ln4506">                    num_m ++;</a>
<a name="ln4507">                } else</a>
<a name="ln4508">                if ( 0 == strcmp( at[i].elname, &quot;T&quot; ) ) {</a>
<a name="ln4509">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, 3 );</a>
<a name="ln4510">                    strcat( str_m, entry );</a>
<a name="ln4511">                    num_m ++;</a>
<a name="ln4512">                } else</a>
<a name="ln4513">                if ( k = at[i].iso_atw_diff ) {</a>
<a name="ln4514">                    int mw = get_atw_from_elnum( at[i].el_number );</a>
<a name="ln4515">                    mw += (k &gt; 0)? k-1 : k;</a>
<a name="ln4516">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, mw );</a>
<a name="ln4517">                    strcat( str_m, entry );</a>
<a name="ln4518">                    num_m ++;</a>
<a name="ln4519">                }</a>
<a name="ln4520">                */</a>
<a name="ln4521">                if ( ANY_ISO(i, bAtomsDT) &amp;&amp; !ALIASED_AT(i) ) {</a>
<a name="ln4522">                    if ( IS_DEUTERIUM(i) ) {</a>
<a name="ln4523">                        iso = 1;</a>
<a name="ln4524">                        el_num = 1;</a>
<a name="ln4525">                    } else</a>
<a name="ln4526">                    if ( IS_TRITIUM(i) ) {</a>
<a name="ln4527">                        iso = 2;</a>
<a name="ln4528">                        el_num = 1;</a>
<a name="ln4529">                    } else {</a>
<a name="ln4530">                        iso = at[i].iso_atw_diff &gt; 0? at[i].iso_atw_diff-1 : at[i].iso_atw_diff;</a>
<a name="ln4531">                        el_num = at[i].el_number;</a>
<a name="ln4532">                    }</a>
<a name="ln4533">                    iso += get_atw_from_elnum( el_num );</a>
<a name="ln4534"> </a>
<a name="ln4535">                    sprintf( entry, &quot; %3d %3d&quot;, i+1, iso );</a>
<a name="ln4536">                    strcat( str_m, entry );</a>
<a name="ln4537">                    num_m ++;</a>
<a name="ln4538">                }</a>
<a name="ln4539"> </a>
<a name="ln4540"> </a>
<a name="ln4541">                if ( (i == num_atoms-1 &amp;&amp; num_m) || num_m == 8 ) {</a>
<a name="ln4542">                    inchi_ios_print_nodisplay( fcb, &quot;M  ISO%3d%s\n&quot;, num_m, str_m );</a>
<a name="ln4543">                    str_m[0] = 0;</a>
<a name="ln4544">                    num_m    = 0;</a>
<a name="ln4545">                }</a>
<a name="ln4546">            }</a>
<a name="ln4547">        }</a>
<a name="ln4548">        inchi_ios_print_nodisplay( fcb, &quot;M  END\n&quot; );</a>
<a name="ln4549">    }</a>
<a name="ln4550">    if ( szValue &amp;&amp; szValue[0] ) {</a>
<a name="ln4551">        if ( szLabel &amp;&amp; szLabel[0] ) {</a>
<a name="ln4552">            inchi_ios_print_nodisplay( fcb, &quot;&gt; &lt;%s&gt;\n&quot;, szLabel );</a>
<a name="ln4553">        } else {</a>
<a name="ln4554">            inchi_ios_print_nodisplay( fcb, &quot;&gt; &lt;ID&gt;\n&quot; );</a>
<a name="ln4555">        }</a>
<a name="ln4556">        inchi_ios_print_nodisplay( fcb, &quot; %s\n\n&quot;, szValue );</a>
<a name="ln4557">    }</a>
<a name="ln4558">    inchi_ios_print_nodisplay(fcb, &quot;$$$$\n&quot;);</a>
<a name="ln4559">    </a>
<a name="ln4560">    </a>
<a name="ln4561">    return ret;</a>
<a name="ln4562">    </a>
<a name="ln4563">}</a>
<a name="ln4564">#if ( FIX_ADJ_RAD == 1 )</a>
<a name="ln4565">/*************************************************************************/</a>
<a name="ln4566">int FixNextRadicals( int cur_at, inp_ATOM *at );</a>
<a name="ln4567">int FixNextRadicals( int cur_at, inp_ATOM *at )</a>
<a name="ln4568">{</a>
<a name="ln4569">    int j, neigh, num_found = 0;</a>
<a name="ln4570">    for ( j = 0; j &lt; at[cur_at].valence; j ++ ) {</a>
<a name="ln4571">        neigh = at[cur_at].neighbor[j];</a>
<a name="ln4572">        if ( at[neigh].radical == RADICAL_DOUBLET ) {</a>
<a name="ln4573">            at[neigh].radical = 0;</a>
<a name="ln4574">            num_found ++;</a>
<a name="ln4575">            num_found += FixNextRadicals( neigh, at );</a>
<a name="ln4576">        }</a>
<a name="ln4577">    }</a>
<a name="ln4578">    return num_found;</a>
<a name="ln4579">}</a>
<a name="ln4580">/*************************************************************************/</a>
<a name="ln4581">int FixAdjacentRadicals( int num_inp_atoms, inp_ATOM *at )</a>
<a name="ln4582">{</a>
<a name="ln4583">    int i, j;</a>
<a name="ln4584">    char *bVisited = NULL;</a>
<a name="ln4585">    int  nNumFound = 0, neigh, cur_found;</a>
<a name="ln4586">    for ( i = 0; i &lt; num_inp_atoms; i ++ ) {</a>
<a name="ln4587">        if ( at[i].radical == RADICAL_DOUBLET ) {</a>
<a name="ln4588">            cur_found = 1;</a>
<a name="ln4589">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln4590">                neigh = at[i].neighbor[j];</a>
<a name="ln4591">                if ( at[neigh].radical == RADICAL_DOUBLET ) {</a>
<a name="ln4592">                    cur_found ++;</a>
<a name="ln4593">                }</a>
<a name="ln4594">            }</a>
<a name="ln4595">            if ( cur_found &gt;= 3 ) {</a>
<a name="ln4596">                nNumFound ++;</a>
<a name="ln4597">                at[i].radical = 0;</a>
<a name="ln4598">                nNumFound += FixNextRadicals( i, at );</a>
<a name="ln4599">            }</a>
<a name="ln4600">        }</a>
<a name="ln4601">    }</a>
<a name="ln4602">    return nNumFound;</a>
<a name="ln4603">}</a>
<a name="ln4604">#endif</a>
<a name="ln4605"> </a>
<a name="ln4606">#ifdef COMPILE_ANSI_ONLY</a>
<a name="ln4607">#ifndef TARGET_API_LIB</a>
<a name="ln4608">/*</a>
<a name="ln4609">#include &lt;stdio.h&gt;</a>
<a name="ln4610">#include &quot;inpdef.h&quot;</a>
<a name="ln4611">*/</a>
<a name="ln4612">void PrintFileName( const char *fmt, </a>
<a name="ln4613">                   FILE *output_file, /* INCHI_IOSTREAM *output_file,  */</a>
<a name="ln4614">                   const char *szFname )</a>
<a name="ln4615">{</a>
<a name="ln4616">    inchi_print_nodisplay( output_file, fmt, szFname );</a>
<a name="ln4617">}</a>
<a name="ln4618">#endif</a>
<a name="ln4619">#endif</a>

</code></pre>
<div class="balloon" rel="977"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="981"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="977"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((!type || 1 == type))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1094"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1103"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1107"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1177"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1180"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1199"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1221"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1262"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1270"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1288"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1308"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1347"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1355"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1388"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1419"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1427"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1458"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1520"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1528"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1570"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1588"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1620"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1635"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !type.</p></div>
<div class="balloon" rel="1714"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="1715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="2009"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'at[neigh].charge + at[i].charge' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="2024"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="2104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'iso_diff' index could reach 3.</p></div>
<div class="balloon" rel="2105"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'iso_diff' index could reach 3.</p></div>
<div class="balloon" rel="2106"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'iso_diff' index could reach 3.</p></div>
<div class="balloon" rel="2219"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v661/" target="_blank">V661</a> A suspicious expression 'A[B == C]'. Probably meant 'A[B] == C'.</p></div>
<div class="balloon" rel="2399"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nNumImplH' is always true.</p></div>
<div class="balloon" rel="3460"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'iNeigh' is always false.</p></div>
<div class="balloon" rel="3701"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pINChI' is always true.</p></div>
<div class="balloon" rel="3772"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'num_at > 0' is always true.</p></div>
<div class="balloon" rel="3777"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: num_at > 0.</p></div>
<div class="balloon" rel="3804"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pINChI_Aux' is always true.</p></div>
<div class="balloon" rel="4281"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4290"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!bV2000' is always false.</p></div>
<div class="balloon" rel="4317"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4425"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'k == 2' is always true.</p></div>
<div class="balloon" rel="4521"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

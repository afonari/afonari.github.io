
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichimap2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;incomdef.h&quot;</a>
<a name="ln48">#include &quot;extr_ct.h&quot;</a>
<a name="ln49">#include &quot;ichitaut.h&quot;</a>
<a name="ln50">#include &quot;ichicant.h&quot;</a>
<a name="ln51">#include &quot;ichicomn.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;ichicomp.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">#define MAP_MODE_STD  0 /* Standard approach: switch 2 neighbors */</a>
<a name="ln56">#define MAP_MODE_C2v  1 /* Check for C2v reflection leading to parity inversion */</a>
<a name="ln57">#define MAP_MODE_C2   2 /* Check for C2 rotation preserving parities */</a>
<a name="ln58">#define MAP_MODE_S4   3 /* Check for S4 rotation/reflection leading to parity inversion */</a>
<a name="ln59">/* important: MAP_MODE_STD &lt; (MAP_MODE_C2v, MAP_MODE_C2) &lt; MAP_MODE_S4 */</a>
<a name="ln60"> </a>
<a name="ln61">/* local prototypes */</a>
<a name="ln62">void DeAllocateForNonStereoRemoval( AT_RANK **nAtomNumberCanon1, AT_RANK **nAtomNumberCanon2,</a>
<a name="ln63">                                    NEIGH_LIST **nl, NEIGH_LIST **nl1, NEIGH_LIST **nl2, AT_RANK **nVisited1, AT_RANK **nVisited2 );</a>
<a name="ln64">int AllocateForNonStereoRemoval( sp_ATOM *at, int num_atoms, const AT_RANK *nSymmRank, AT_RANK *nCanonRank,</a>
<a name="ln65">                            AT_RANK **nAtomNumberCanon1, AT_RANK **nAtomNumberCanon2,</a>
<a name="ln66">                            NEIGH_LIST **nl, NEIGH_LIST **nl1, NEIGH_LIST **nl2, AT_RANK **nVisited1, AT_RANK **nVisited2 );</a>
<a name="ln67">AT_RANK GetMinNewRank(AT_RANK *nAtomRank, AT_RANK *nAtomNumb, AT_RANK nRank1 );</a>
<a name="ln68">int BreakNeighborsTie(  sp_ATOM *at, int num_atoms, int num_at_tg, int ib, int ia,</a>
<a name="ln69">                        AT_RANK *neigh_num, int in1, int in2, int mode,</a>
<a name="ln70">                        AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln71">                        const AT_RANK *nSymmRank, AT_RANK *nCanonRank, NEIGH_LIST *nl1, NEIGH_LIST *nl2, long *lNumIter );</a>
<a name="ln72">int CheckNextSymmNeighborsAndBonds( sp_ATOM *at, AT_RANK cur1, AT_RANK cur2, AT_RANK n1, AT_RANK n2,</a>
<a name="ln73">                                    AT_RANK *nAvoidCheckAtom, AT_RANK *nVisited1, AT_RANK *nVisited2,</a>
<a name="ln74">                                    AT_RANK *nVisitOrd1, AT_RANK *nVisitOrd2, const AT_RANK *nRank1, const AT_RANK *nRank2 );</a>
<a name="ln75">int CreateCheckSymmPaths( sp_ATOM *at, AT_RANK prev1, AT_RANK cur1, AT_RANK prev2, AT_RANK cur2,</a>
<a name="ln76">                         AT_RANK *nAvoidCheckAtom, AT_RANK *nVisited1, AT_RANK *nVisited2,</a>
<a name="ln77">                         AT_RANK *nVisitOrd1, AT_RANK *nVisitOrd2,</a>
<a name="ln78">                         NEIGH_LIST *nl1, NEIGH_LIST *nl2, const AT_RANK *nRank1, const AT_RANK *nRank2,</a>
<a name="ln79">                         AT_RANK *nCanonRank, AT_RANK *nLength, int *bParitiesInverted, int mode );</a>
<a name="ln80">int CalculatedPathsParitiesAreIdentical( sp_ATOM *at, int num_atoms, const AT_RANK *nSymmRank,</a>
<a name="ln81">                         AT_RANK *nCanonRank, AT_RANK *nAtomNumberCanon, AT_RANK *nAtomNumberCanon1, AT_RANK *nAtomNumberCanon2,</a>
<a name="ln82">                         AT_RANK *nVisited1, AT_RANK *nVisited2,</a>
<a name="ln83">                         AT_RANK prev_sb_neigh, AT_RANK cur, AT_RANK next1, AT_RANK next2, int nNeighMode,</a>
<a name="ln84">                         int bParitiesInverted, int mode, CANON_STAT *pCS,</a>
<a name="ln85">                         int vABParityUnknown);</a>
<a name="ln86">int RemoveCalculatedNonStereoBondParities( sp_ATOM *at, int num_atoms, int num_at_tg,</a>
<a name="ln87">                                          AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln88">                                          AT_RANK *nCanonRank, const AT_RANK *nSymmRank,</a>
<a name="ln89">                                          AT_RANK *nAtomNumberCanon, AT_RANK *nAtomNumberCanon1, AT_RANK *nAtomNumberCanon2,</a>
<a name="ln90">                                          NEIGH_LIST *nl, NEIGH_LIST *nl1, NEIGH_LIST *nl2,</a>
<a name="ln91">                                          AT_RANK *nVisited1, AT_RANK *nVisited2, CANON_STAT *pCS,</a>
<a name="ln92">                                          int vABParityUnknown);</a>
<a name="ln93">int RemoveCalculatedNonStereoCenterParities( sp_ATOM *at, int num_atoms, int num_at_tg,</a>
<a name="ln94">                                          AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln95">                                          AT_RANK *nCanonRank, const AT_RANK *nSymmRank,</a>
<a name="ln96">                                          AT_RANK *nAtomNumberCanon, AT_RANK *nAtomNumberCanon1, AT_RANK *nAtomNumberCanon2,</a>
<a name="ln97">                                          NEIGH_LIST *nl, NEIGH_LIST *nl1, NEIGH_LIST *nl2, </a>
<a name="ln98">                                          AT_RANK *nVisited1, AT_RANK *nVisited2, CANON_STAT *pCS,</a>
<a name="ln99">                                          int vABParityUnknown);</a>
<a name="ln100"> </a>
<a name="ln101">int SortNeighLists3( int num_atoms, AT_RANK *nRank, NEIGH_LIST *NeighList, AT_RANK *nAtomNumber );</a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">/**************************************************************************************</a>
<a name="ln108"> *</a>
<a name="ln109"> *   Convert sorted equivalence information (nSymmRank) to ranks (nRank)</a>
<a name="ln110"> *   nSymmRank and nRank may point to the same array</a>
<a name="ln111"> *</a>
<a name="ln112"> */</a>
<a name="ln113">int SortedEquInfoToRanks( const AT_RANK* nSymmRank, AT_RANK* nRank, const AT_RANK* nAtomNumber, int num_atoms, int *bChanged )</a>
<a name="ln114">{</a>
<a name="ln115">    AT_RANK        rNew, rOld, nNumDiffRanks;</a>
<a name="ln116">    int            i, j, nNumChanges = 0;</a>
<a name="ln117">    for ( i = num_atoms-1, j = (int)nAtomNumber[i],</a>
<a name="ln118">          rOld = nSymmRank[j], rNew = nRank[j] = (AT_RANK)num_atoms,</a>
<a name="ln119">          nNumDiffRanks = 1;</a>
<a name="ln120">             i &gt; 0;</a>
<a name="ln121">                 i -- ) {</a>
<a name="ln122"> </a>
<a name="ln123">        j = (int)nAtomNumber[i-1];</a>
<a name="ln124">        </a>
<a name="ln125">        if ( nSymmRank[j] != rOld ) {</a>
<a name="ln126">            nNumDiffRanks ++;</a>
<a name="ln127">            rNew = (AT_RANK)i;</a>
<a name="ln128">            nNumChanges += (rOld != rNew+1);</a>
<a name="ln129">            rOld = nSymmRank[j];</a>
<a name="ln130">        }</a>
<a name="ln131"> </a>
<a name="ln132">        nRank[j] = rNew;</a>
<a name="ln133">    }</a>
<a name="ln134">    if ( bChanged ) {</a>
<a name="ln135">        *bChanged = (0 != nNumChanges);</a>
<a name="ln136">    }</a>
<a name="ln137">    return nNumDiffRanks;</a>
<a name="ln138">}</a>
<a name="ln139">/**************************************************************************************</a>
<a name="ln140"> *</a>
<a name="ln141"> *   Convert sorted ranks (nRank) to sorted equivalence information (nSymmRank)</a>
<a name="ln142"> *   nSymmRank and nRank may point to the same array</a>
<a name="ln143"> *</a>
<a name="ln144"> */</a>
<a name="ln145">int SortedRanksToEquInfo( AT_RANK* nSymmRank, const AT_RANK* nRank, const AT_RANK* nAtomNumber, int num_atoms )</a>
<a name="ln146">{</a>
<a name="ln147">    AT_RANK        rNew, rOld, nNumDiffRanks;</a>
<a name="ln148">    int            i, j;</a>
<a name="ln149">    for ( i = 1, j = (int)nAtomNumber[0],</a>
<a name="ln150">          rOld = nRank[j], rNew = nSymmRank[j] = 1,</a>
<a name="ln151">          nNumDiffRanks = 1;</a>
<a name="ln152">          i &lt; num_atoms;</a>
<a name="ln153">          i ++ ) {</a>
<a name="ln154">        j = (int)nAtomNumber[i];</a>
<a name="ln155">        if ( nRank[j] != rOld ) {</a>
<a name="ln156">            nNumDiffRanks ++;</a>
<a name="ln157">            rNew = (AT_RANK)(i+1);</a>
<a name="ln158">            rOld = nRank[j];</a>
<a name="ln159">        }</a>
<a name="ln160">        nSymmRank[j] = rNew;</a>
<a name="ln161">    }</a>
<a name="ln162">    return nNumDiffRanks;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">/**************************************************************************************/</a>
<a name="ln166">void switch_ptrs( AT_RANK **p1, AT_RANK **p2 )</a>
<a name="ln167">{</a>
<a name="ln168">    AT_RANK *tmp = *p1;</a>
<a name="ln169">    *p1 = *p2;</a>
<a name="ln170">    *p2 = tmp;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/**************************************************************************************/</a>
<a name="ln174">/*  Set ranks from the products vector and previous ranks                             */</a>
<a name="ln175">/*  nRank[] and nNewRank[] should refer to different arrays for now                   */</a>
<a name="ln176">/**************************************************************************************/</a>
<a name="ln177">int SetNewRanksFromNeighLists3( int num_atoms, NEIGH_LIST *NeighList, AT_RANK *nRank,</a>
<a name="ln178">                                AT_RANK *nNewRank, AT_RANK *nAtomNumber )</a>
<a name="ln179">{</a>
<a name="ln180">    int     i, j, nNumDiffRanks, nNumNewRanks;</a>
<a name="ln181">    AT_RANK r1, r2;</a>
<a name="ln182">    /*  -- nAtomNumber[] is already properly set --</a>
<a name="ln183">    for ( i = 0; i &lt; num_atoms; i++ ) {</a>
<a name="ln184">        nAtomNumber[i] = (AT_RANK)i;</a>
<a name="ln185">    }</a>
<a name="ln186">    */</a>
<a name="ln187">    /*  set globals for qsort */</a>
<a name="ln188">    pNeighList_RankForSort = NeighList;</a>
<a name="ln189">    pn_RankForSort         = nRank;</a>
<a name="ln190">    nNumDiffRanks          = 0;</a>
<a name="ln191">    nNumNewRanks           = 0;</a>
<a name="ln192"> </a>
<a name="ln193">    memset(nNewRank, 0, num_atoms*sizeof(nNewRank[0]));</a>
<a name="ln194">    </a>
<a name="ln195">    /*  sorting */</a>
<a name="ln196">    for ( i = 0, r1 = 1; i &lt; num_atoms; r1++ ) {</a>
<a name="ln197">        if ( r1 == (r2 = nRank[j=(int)nAtomNumber[i]]) ) {</a>
<a name="ln198">            nNewRank[j] = r2;</a>
<a name="ln199">            nNumDiffRanks ++;</a>
<a name="ln200">            i ++;</a>
<a name="ln201">            continue;</a>
<a name="ln202">        }</a>
<a name="ln203">        r1 = r2;</a>
<a name="ln204">        insertions_sort_AT_NUMBERS( nAtomNumber+i, (int)r2-i, CompNeighLists );</a>
<a name="ln205">        /*insertions_sort( nAtomNumber+i, r2-i, sizeof( nAtomNumber[0] ), CompNeighLists );*/</a>
<a name="ln206">        j = r2-1;</a>
<a name="ln207">        nNewRank[(int)nAtomNumber[j]] = r2;</a>
<a name="ln208">        nNumDiffRanks ++;</a>
<a name="ln209">        while( j &gt; i ) {</a>
<a name="ln210">            if ( CompareNeighListLex( NeighList[(int)nAtomNumber[j-1]],</a>
<a name="ln211">                                      NeighList[(int)nAtomNumber[j]], nRank ) ) {</a>
<a name="ln212">                r2 = j;</a>
<a name="ln213">                nNumDiffRanks ++;</a>
<a name="ln214">                nNumNewRanks ++;</a>
<a name="ln215">            }</a>
<a name="ln216">            j --;</a>
<a name="ln217">            nNewRank[(int)nAtomNumber[j]] = r2;</a>
<a name="ln218">        }</a>
<a name="ln219">        i = r1;</a>
<a name="ln220">    }</a>
<a name="ln221">    return nNumNewRanks? -nNumDiffRanks : nNumDiffRanks;</a>
<a name="ln222">}</a>
<a name="ln223">/**************************************************************************************/</a>
<a name="ln224">/*  Set ranks from the products vector and previous ranks                             */</a>
<a name="ln225">/*  When comparing neigh lists ignore ranks &gt; max_at_no                               */</a>
<a name="ln226">/*  nRank[] and nNewRank[] should refer to different arrays for now                   */</a>
<a name="ln227">/**************************************************************************************/</a>
<a name="ln228">int SetNewRanksFromNeighLists4( int num_atoms, NEIGH_LIST *NeighList, AT_RANK *nRank,</a>
<a name="ln229">                                AT_RANK *nNewRank, AT_RANK *nAtomNumber, AT_RANK nMaxAtRank )</a>
<a name="ln230">{</a>
<a name="ln231">    int     i, j, nNumDiffRanks, nNumNewRanks;</a>
<a name="ln232">    AT_RANK r1, r2;</a>
<a name="ln233">    /*  -- nAtomNumber[] is already properly set --</a>
<a name="ln234">    for ( i = 0; i &lt; num_atoms; i++ ) {</a>
<a name="ln235">        nAtomNumber[i] = (AT_RANK)i;</a>
<a name="ln236">    }</a>
<a name="ln237">    */</a>
<a name="ln238">    /*  set globals for CompNeighListsUpToMaxRank */</a>
<a name="ln239">    pNeighList_RankForSort = NeighList;</a>
<a name="ln240">    pn_RankForSort         = nRank;</a>
<a name="ln241">    nNumDiffRanks          = 0;</a>
<a name="ln242">    nNumNewRanks           = 0;</a>
<a name="ln243">    nMaxAtNeighRankForSort = nMaxAtRank;</a>
<a name="ln244"> </a>
<a name="ln245">    memset(nNewRank, 0, num_atoms*sizeof(nNewRank[0]));</a>
<a name="ln246">    </a>
<a name="ln247">    /*  sorting */</a>
<a name="ln248">    for ( i = 0, r1 = 1; i &lt; num_atoms; r1++ ) {</a>
<a name="ln249">        if ( r1 == (r2 = nRank[j=(int)nAtomNumber[i]]) ) {</a>
<a name="ln250">            /* non-tied rank: singleton */</a>
<a name="ln251">            nNewRank[j] = r2;</a>
<a name="ln252">            nNumDiffRanks ++;</a>
<a name="ln253">            i ++;</a>
<a name="ln254">            continue;</a>
<a name="ln255">        }</a>
<a name="ln256">        /* tied rank r2</a>
<a name="ln257">           r2-i atoms have rank r2</a>
<a name="ln258">           next atom after them is in position r2</a>
<a name="ln259">        */</a>
<a name="ln260">        r1 = r2;</a>
<a name="ln261">        insertions_sort_AT_NUMBERS( nAtomNumber+i, (int)r2-i, CompNeighListsUpToMaxRank );</a>
<a name="ln262">        /*insertions_sort( nAtomNumber+i, r2-i, sizeof( nAtomNumber[0] ),  CompNeighListsUpToMaxRank );*/</a>
<a name="ln263">        j = r2-1; /* prepare cycle backward, from j to i step -1 */</a>
<a name="ln264">        nNewRank[(int)nAtomNumber[j]] = r2;</a>
<a name="ln265">        nNumDiffRanks ++;</a>
<a name="ln266">        while( j &gt; i ) {</a>
<a name="ln267">            if ( CompareNeighListLexUpToMaxRank( NeighList[nAtomNumber[j-1]],</a>
<a name="ln268">                                                 NeighList[nAtomNumber[j]], nRank, nMaxAtRank ) ) {</a>
<a name="ln269">                r2 = j;</a>
<a name="ln270">                nNumDiffRanks ++;</a>
<a name="ln271">                nNumNewRanks ++;</a>
<a name="ln272">            }</a>
<a name="ln273">            j --;</a>
<a name="ln274">            nNewRank[(int)nAtomNumber[j]] = r2;</a>
<a name="ln275">        }</a>
<a name="ln276">        i = r1;</a>
<a name="ln277">    }</a>
<a name="ln278">    return nNumNewRanks? -nNumDiffRanks : nNumDiffRanks;</a>
<a name="ln279">}</a>
<a name="ln280">/**************************************************************************************/</a>
<a name="ln281">/*  Set ranks from the products vector and previous ranks                             */</a>
<a name="ln282">/*  nRank[] and nNewRank[] should refer to different arrays for now                   */</a>
<a name="ln283">/**************************************************************************************/</a>
<a name="ln284">int SetNewRanksFromNeighLists( int num_atoms, NEIGH_LIST *NeighList, AT_RANK *nRank, AT_RANK *nNewRank,</a>
<a name="ln285">                             AT_RANK *nAtomNumber, int bUseAltSort, int ( *comp )(const void *, const void *) )</a>
<a name="ln286">{</a>
<a name="ln287">    int     i,  nNumDiffRanks;</a>
<a name="ln288">    AT_RANK nCurrentRank;</a>
<a name="ln289">    /*  -- nAtomNumber[] is already properly set --</a>
<a name="ln290">    for ( i = 0; i &lt; num_atoms; i++ ) {</a>
<a name="ln291">        nAtomNumber[i] = (AT_RANK)i;</a>
<a name="ln292">    }</a>
<a name="ln293">    */</a>
<a name="ln294">    /*  set globals for qsort */</a>
<a name="ln295">    pNeighList_RankForSort = NeighList;</a>
<a name="ln296">    pn_RankForSort         = nRank;</a>
<a name="ln297">    </a>
<a name="ln298">    /*  sorting */</a>
<a name="ln299">    if ( bUseAltSort &amp; 1 )</a>
<a name="ln300">        tsort( nAtomNumber, num_atoms, sizeof( nAtomNumber[0] ), comp /*CompNeighListRanksOrd*/ );</a>
<a name="ln301">    else</a>
<a name="ln302">        qsort( nAtomNumber, num_atoms, sizeof( nAtomNumber[0] ), comp /*CompNeighListRanksOrd*/ );</a>
<a name="ln303"> </a>
<a name="ln304">    for ( i=num_atoms-1, nCurrentRank=nNewRank[(int)nAtomNumber[i]] = (AT_RANK)num_atoms, nNumDiffRanks = 1;</a>
<a name="ln305">          0 &lt; i ;</a>
<a name="ln306">          i -- ) {</a>
<a name="ln307">        /*  Note: CompNeighListRanks() in following line implicitly reads nRank pointed by pn_RankForSort */</a>
<a name="ln308">        if ( CompNeighListRanks( &amp;nAtomNumber[i-1], &amp;nAtomNumber[i] ) ) {</a>
<a name="ln309">            nNumDiffRanks ++;</a>
<a name="ln310">            nCurrentRank = (AT_RANK)i;</a>
<a name="ln311">        }</a>
<a name="ln312">        nNewRank[(int)nAtomNumber[i - 1]] = nCurrentRank;</a>
<a name="ln313">    }</a>
<a name="ln314">    </a>
<a name="ln315">    return nNumDiffRanks;</a>
<a name="ln316">}</a>
<a name="ln317">/**************************************************************************************/</a>
<a name="ln318">/*   Sort NeighList[] lists of neighbors according to the ranks of the neighbors      */</a>
<a name="ln319">/**************************************************************************************/</a>
<a name="ln320">void SortNeighListsBySymmAndCanonRank( int num_atoms, NEIGH_LIST *NeighList, const AT_RANK *nSymmRank, const AT_RANK *nCanonRank )</a>
<a name="ln321">{</a>
<a name="ln322">    int i;</a>
<a name="ln323">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln324">        insertions_sort_NeighListBySymmAndCanonRank( NeighList[i], nSymmRank, nCanonRank );</a>
<a name="ln325">    }</a>
<a name="ln326">}</a>
<a name="ln327">/**************************************************************************************/</a>
<a name="ln328">int SortNeighLists2( int num_atoms, AT_RANK *nRank, NEIGH_LIST *NeighList, AT_RANK *nAtomNumber )</a>
<a name="ln329">{</a>
<a name="ln330">    int k, i;</a>
<a name="ln331">    AT_RANK nPrevRank = 0;</a>
<a name="ln332">    /*</a>
<a name="ln333">     * on entry nRank[nAtomNumber[k]] &lt;= nRank[nAtomNumber[k+1]]  ( k &lt; num_atoms-1 )</a>
<a name="ln334">     *          nRank[nAtomNumber[k]] &gt;= k+1                      ( k &lt; num_atoms )</a>
<a name="ln335">     *          nRank[nAtomNumber[k]] == k+1 if this nRank value is not tied OR if</a>
<a name="ln336">     *                nRank[nAtomNumber[k]] &lt; nRank[nAtomNumber[k+1]] OR if k = num_atoms-1.</a>
<a name="ln337">     *</a>
<a name="ln338">     */</a>
<a name="ln339">    for ( k = 0; k &lt; num_atoms; k ++ ) {</a>
<a name="ln340">        i = nAtomNumber[k];</a>
<a name="ln341">        if ( (nRank[i] != k+1 || nRank[i] == nPrevRank) &amp;&amp; NeighList[i][0] &gt; 1 ) {</a>
<a name="ln342">            /*  nRank[i] is tied (duplicated) */</a>
<a name="ln343">            insertions_sort_NeighList_AT_NUMBERS( NeighList[i], nRank );</a>
<a name="ln344">        }</a>
<a name="ln345">        nPrevRank = nRank[i];</a>
<a name="ln346">    }</a>
<a name="ln347">    return 0;</a>
<a name="ln348">}</a>
<a name="ln349">/**************************************************************************************/</a>
<a name="ln350">int SortNeighLists3( int num_atoms, AT_RANK *nRank, NEIGH_LIST *NeighList, AT_RANK *nAtomNumber )</a>
<a name="ln351">{</a>
<a name="ln352">    int k, i;</a>
<a name="ln353">    AT_RANK nPrevRank = 0;</a>
<a name="ln354">    /*</a>
<a name="ln355">     * on entry nRank[nAtomNumber[k]] &lt;= nRank[nAtomNumber[k+1]]  ( k &lt; num_atoms-1 )</a>
<a name="ln356">     *          nRank[nAtomNumber[k]] &gt;= k+1                      ( k &lt; num_atoms )</a>
<a name="ln357">     *          nRank[nAtomNumber[k]] == k+1 if this nRank value is not tied OR if</a>
<a name="ln358">     *                nRank[nAtomNumber[k]] &lt; nRank[nAtomNumber[k+1]] OR if k = num_atoms-1.</a>
<a name="ln359">     *</a>
<a name="ln360">     */</a>
<a name="ln361">    for ( k = 0; k &lt; num_atoms; k ++ ) {</a>
<a name="ln362">        i = nAtomNumber[k];</a>
<a name="ln363">        if ( (nRank[i] != k+1 || nRank[i] == nPrevRank) &amp;&amp; NeighList[i][0] &gt; 1 ) {</a>
<a name="ln364">            /*  nRank[i] is tied (duplicated) */</a>
<a name="ln365">            insertions_sort_NeighList_AT_NUMBERS3( NeighList[i], nRank );</a>
<a name="ln366">        }</a>
<a name="ln367">        nPrevRank = nRank[i];</a>
<a name="ln368">    }</a>
<a name="ln369">    return 0;</a>
<a name="ln370">}</a>
<a name="ln371">/**************************************************************************************</a>
<a name="ln372"> *</a>
<a name="ln373"> *  Differentiate2</a>
<a name="ln374"> *</a>
<a name="ln375"> * Note: on entry nAtomNumber[] must contain a valid transposition of num_atoms length</a>
<a name="ln376"> *       for example, nAtomNumber[i] = i;</a>
<a name="ln377"> * Note2: this version does not calculate neighbor lists for non-tied ranks</a>
<a name="ln378"> */</a>
<a name="ln379">int  DifferentiateRanks2( int num_atoms, NEIGH_LIST *NeighList,</a>
<a name="ln380">                                 int nNumCurrRanks, AT_RANK *pnCurrRank, AT_RANK *pnPrevRank,</a>
<a name="ln381">                                 AT_RANK *nAtomNumber, long *lNumIter, int bUseAltSort )</a>
<a name="ln382">{</a>
<a name="ln383">    /*int nNumPrevRanks;*/</a>
<a name="ln384"> </a>
<a name="ln385">    /*  SortNeighLists2 needs sorted ranks */</a>
<a name="ln386">    pn_RankForSort = pnCurrRank;</a>
<a name="ln387">    if ( bUseAltSort &amp; 1 )</a>
<a name="ln388">        tsort( nAtomNumber, num_atoms, sizeof(nAtomNumber[0]), CompRank /* CompRanksOrd*/ );</a>
<a name="ln389">    else</a>
<a name="ln390">        qsort( nAtomNumber, num_atoms, sizeof(nAtomNumber[0]), CompRanksOrd );</a>
<a name="ln391"> </a>
<a name="ln392">    do {</a>
<a name="ln393">        *lNumIter += 1;</a>
<a name="ln394">        /*nNumPrevRanks = nNumCurrRanks;*/</a>
<a name="ln395">        switch_ptrs( &amp;pnCurrRank, &amp;pnPrevRank );</a>
<a name="ln396">        SortNeighLists2( num_atoms, pnPrevRank, NeighList, nAtomNumber );</a>
<a name="ln397">        /*  the following call creates pnCurrRank out of pnPrevRank */</a>
<a name="ln398">        nNumCurrRanks = SetNewRanksFromNeighLists( num_atoms, NeighList, pnPrevRank, pnCurrRank, nAtomNumber,</a>
<a name="ln399">                                                 1, CompNeighListRanksOrd );</a>
<a name="ln400">    } while ( /*nNumPrevRanks != nNumCurrRanks ||*/ memcmp( pnPrevRank, pnCurrRank, num_atoms*sizeof(pnCurrRank[0]) ) );</a>
<a name="ln401"> </a>
<a name="ln402">    return nNumCurrRanks;</a>
<a name="ln403">}</a>
<a name="ln404">/**************************************************************************************</a>
<a name="ln405"> *</a>
<a name="ln406"> *  Differentiate3</a>
<a name="ln407"> *</a>
<a name="ln408"> * Note: on entry nAtomNumber[] must contain a valid transposition of num_atoms length</a>
<a name="ln409"> *       for example, nAtomNumber[i] = i;</a>
<a name="ln410"> * Note2: this version does not calculate neighbor lists for non-tied ranks</a>
<a name="ln411"> */</a>
<a name="ln412">int  DifferentiateRanks3( int num_atoms, NEIGH_LIST *NeighList,</a>
<a name="ln413">                          int nNumCurrRanks, AT_RANK *pnCurrRank, AT_RANK *pnPrevRank,</a>
<a name="ln414">                          AT_RANK *nAtomNumber, long *lNumIter )</a>
<a name="ln415">{</a>
<a name="ln416">/*    </a>
<a name="ln417">    static long count = 0;</a>
<a name="ln418">    count ++;</a>
<a name="ln419">    if ( count == 103 ) {</a>
<a name="ln420">        int stop=1;</a>
<a name="ln421">    }</a>
<a name="ln422">*/</a>
<a name="ln423"> </a>
<a name="ln424">    /*  SortNeighLists3 needs sorted ranks: ranks/atnumbers must have been already sorted */</a>
<a name="ln425">    do {</a>
<a name="ln426">        *lNumIter += 1;</a>
<a name="ln427">        switch_ptrs( &amp;pnCurrRank, &amp;pnPrevRank );</a>
<a name="ln428">        SortNeighLists3( num_atoms, pnPrevRank, NeighList, nAtomNumber );</a>
<a name="ln429">        /*  the following call creates pnCurrRank out of pnPrevRank */</a>
<a name="ln430">        nNumCurrRanks = SetNewRanksFromNeighLists3( num_atoms, NeighList, pnPrevRank,</a>
<a name="ln431">                                                    pnCurrRank, nAtomNumber);</a>
<a name="ln432">    } while ( nNumCurrRanks &lt; 0 /* memcmp( pnPrevRank, pnCurrRank, num_atoms*sizeof(pnCurrRank[0]) )*/ );</a>
<a name="ln433"> </a>
<a name="ln434">    return nNumCurrRanks;</a>
<a name="ln435">}</a>
<a name="ln436">/**************************************************************************************</a>
<a name="ln437"> *</a>
<a name="ln438"> *  Differentiate4: ignore neighbors with rank &gt; num_atoms</a>
<a name="ln439"> *</a>
<a name="ln440"> * Note: on entry nAtomNumber[] must contain a valid transposition of num_atoms length</a>
<a name="ln441"> *       for example, nAtomNumber[i] = i;</a>
<a name="ln442"> * Note2: this version does not sort neighbor lists for non-tied ranks</a>
<a name="ln443"> */</a>
<a name="ln444">int  DifferentiateRanks4( int num_atoms, NEIGH_LIST *NeighList,</a>
<a name="ln445">                          int nNumCurrRanks, AT_RANK *pnCurrRank, AT_RANK *pnPrevRank,</a>
<a name="ln446">                          AT_RANK *nAtomNumber, AT_RANK nMaxAtRank, long *lNumIter )</a>
<a name="ln447">{</a>
<a name="ln448">/*    </a>
<a name="ln449">    static long count = 0;</a>
<a name="ln450">    count ++;</a>
<a name="ln451">    if ( count == 103 ) {</a>
<a name="ln452">        int stop=1;</a>
<a name="ln453">    }</a>
<a name="ln454">*/</a>
<a name="ln455">    /*  SortNeighLists4 needs sorted ranks: ranks/atnumbers must have been already sorted */</a>
<a name="ln456">    do {</a>
<a name="ln457">        *lNumIter += 1;</a>
<a name="ln458">        switch_ptrs( &amp;pnCurrRank, &amp;pnPrevRank );</a>
<a name="ln459">        SortNeighLists3( num_atoms, pnPrevRank, NeighList, nAtomNumber );</a>
<a name="ln460">        /*  the following call creates pnCurrRank out of pnPrevRank */</a>
<a name="ln461">        nNumCurrRanks = SetNewRanksFromNeighLists4( num_atoms, NeighList, pnPrevRank,</a>
<a name="ln462">                                                    pnCurrRank, nAtomNumber, nMaxAtRank );</a>
<a name="ln463">    } while ( nNumCurrRanks &lt; 0 /* memcmp( pnPrevRank, pnCurrRank, num_atoms*sizeof(pnCurrRank[0]) )*/ );</a>
<a name="ln464"> </a>
<a name="ln465">    return nNumCurrRanks;</a>
<a name="ln466">}</a>
<a name="ln467">/**************************************************************************************</a>
<a name="ln468"> *</a>
<a name="ln469"> *  DifferentiateBasic (sort according to ranks only)</a>
<a name="ln470"> *</a>
<a name="ln471"> * Note: on entry nAtomNumber[] must contain a valid transposition of num_atoms length</a>
<a name="ln472"> *       for example, nAtomNumber[i] = i;</a>
<a name="ln473"> * Note2: this version does not calculate neighbor lists for non-tied ranks</a>
<a name="ln474"> */</a>
<a name="ln475">int  DifferentiateRanksBasic( int num_atoms, NEIGH_LIST *NeighList,</a>
<a name="ln476">                                 int nNumCurrRanks, AT_RANK *pnCurrRank, AT_RANK *pnPrevRank,</a>
<a name="ln477">                                 AT_RANK *nAtomNumber, long *lNumIter, int bUseAltSort )</a>
<a name="ln478">{</a>
<a name="ln479">    int nNumPrevRanks;</a>
<a name="ln480"> </a>
<a name="ln481">    /*  SortNeighLists2 needs sorted ranks */</a>
<a name="ln482">    pn_RankForSort     = pnCurrRank;</a>
<a name="ln483">    if ( bUseAltSort &amp; 1 )</a>
<a name="ln484">        tsort( nAtomNumber, num_atoms, sizeof(nAtomNumber[0]), CompRank );</a>
<a name="ln485">    else</a>
<a name="ln486">        qsort( nAtomNumber, num_atoms, sizeof(nAtomNumber[0]), CompRank );</a>
<a name="ln487"> </a>
<a name="ln488">    do {</a>
<a name="ln489">        *lNumIter += 1;</a>
<a name="ln490">        nNumPrevRanks = nNumCurrRanks;</a>
<a name="ln491">        switch_ptrs( &amp;pnCurrRank, &amp;pnPrevRank );</a>
<a name="ln492">        SortNeighLists2( num_atoms, pnPrevRank, NeighList, nAtomNumber );</a>
<a name="ln493">        /*  the following call creates pnCurrRank out of pnPrevRank */</a>
<a name="ln494">        nNumCurrRanks = SetNewRanksFromNeighLists( num_atoms, NeighList, pnPrevRank, pnCurrRank, nAtomNumber, bUseAltSort, CompNeighListRanks );</a>
<a name="ln495">    } while ( nNumPrevRanks != nNumCurrRanks || memcmp( pnPrevRank, pnCurrRank, num_atoms*sizeof(pnCurrRank[0]) ) );</a>
<a name="ln496">    return nNumCurrRanks;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/**************************************************************************************</a>
<a name="ln500"> * For the purpose of mapping an atom to an atom:</a>
<a name="ln501"> * (a) find number of tied ranks</a>
<a name="ln502"> * (b) if number of tied ranks &gt; 1 then:</a>
<a name="ln503"> *    1) find the rank for breaking a tie</a>
<a name="ln504"> *    2) allocate memory for breaking the tie if it has not been allocated</a>
<a name="ln505"> *    3) find out if atom 1 (&quot;from&quot;) has already been mapped</a>
<a name="ln506"> * Return value:</a>
<a name="ln507"> *  &lt; 0: error</a>
<a name="ln508"> *  = 1: has already been mapped, to tie to break</a>
<a name="ln509"> *  &gt; 1: we need to break a tie</a>
<a name="ln510"> */</a>
<a name="ln511">int NumberOfTies( AT_RANK **pRankStack1, AT_RANK **pRankStack2, int length,</a>
<a name="ln512">                  int at_no1, int at_no2, AT_RANK *nNewRank, int *bAddStack, int *bMapped1 )</a>
<a name="ln513">{</a>
<a name="ln514"> </a>
<a name="ln515">    AT_RANK *nRank1       = *pRankStack1++;</a>
<a name="ln516">    AT_RANK *nAtomNumber1 = *pRankStack1++;  /*  ranks for mapping &quot;1&quot;, &quot;from&quot; */</a>
<a name="ln517"> </a>
<a name="ln518">    AT_RANK *nRank2       = *pRankStack2++;</a>
<a name="ln519">    AT_RANK *nAtomNumber2 = *pRankStack2++;  /*  ranks for mapping &quot;2&quot;, &quot;to&quot; */</a>
<a name="ln520"> </a>
<a name="ln521">    AT_RANK r, *pTempArray;</a>
<a name="ln522"> </a>
<a name="ln523">    int iMax, i, i1, i2;</a>
<a name="ln524"> </a>
<a name="ln525">    *bAddStack = 0;</a>
<a name="ln526">    *bMapped1  = 0;</a>
<a name="ln527">    *nNewRank  = 0;</a>
<a name="ln528">    r = nRank1[at_no1];</a>
<a name="ln529">    if ( r != nRank2[at_no2] )</a>
<a name="ln530">        return CT_MAPCOUNT_ERR; /*  atoms cannot be mapped onto each other: they have different ranks */ /*   &lt;BRKPT&gt; */</a>
<a name="ln531">    iMax = r - 1;</a>
<a name="ln532">    /*  find i1 and i2 = numbers of ranks in nRank1[] and nRank2[] equal to r:  */</a>
<a name="ln533">    for ( i1 = 1; i1 &lt;= iMax &amp;&amp; r == nRank1[nAtomNumber1[iMax-i1]]; i1 ++ )</a>
<a name="ln534">        ;</a>
<a name="ln535">    for ( i2 = 1; i2 &lt;= iMax &amp;&amp; r == nRank2[nAtomNumber2[iMax-i2]]; i2 ++ )</a>
<a name="ln536">        ;</a>
<a name="ln537">    if ( i2 != i1 )</a>
<a name="ln538">        return CT_MAPCOUNT_ERR; /*  program error: must be identical number of equal ranks */ /*   &lt;BRKPT&gt; */</a>
<a name="ln539">    /*  found i1 equal rank(s); preceding (smaller) non-equal rank is r-i1 */</a>
<a name="ln540">    /*  To break the tie we have to reduce the rank r to r-i1+1 */</a>
<a name="ln541"> </a>
<a name="ln542">    /************ Note *******************************</a>
<a name="ln543">     * IF ( i=r-1 &amp;&amp; 0 &lt;= i &amp;&amp; i &lt; num_atoms AND </a>
<a name="ln544">     *      nRank[nAtomNumber1[i]] == r )</a>
<a name="ln545">     * THEN:</a>
<a name="ln546">     * nRank[nAtomNumber1[i+1]] &gt;  r; (if i+1 &lt; num_atoms)</a>
<a name="ln547">     * nRank[nAtomNumber1[i-1]] &lt;= r; (if i &gt; 0)</a>
<a name="ln548">     *</a>
<a name="ln549">     * IF r = nRank[i] THEN</a>
<a name="ln550">     * nRank[nAtomNumber1[r-1]] == r</a>
<a name="ln551">     * nRank[nAtomNumber1[r-i-1]] &lt;= nRank[nAtomNumber1[r-i]] (for 1 &lt;= i &lt; r )</a>
<a name="ln552">     */</a>
<a name="ln553">    if ( i1 &gt; 1 ) {</a>
<a name="ln554">        /* int bAtFromHasAlreadyBeenMapped = 0; */</a>
<a name="ln555">        *nNewRank = r - i1 + 1;</a>
<a name="ln556">        /*  grab an existing or allocate a new array */</a>
<a name="ln557">        /*  we need 4 arrays: 2 for ranks + 2 for numbers */</a>
<a name="ln558">        for ( i = 0; i &lt; 4; i ++ ) {</a>
<a name="ln559">            if ( i &lt; 2 ) {</a>
<a name="ln560">                pTempArray = *pRankStack1;</a>
<a name="ln561">                *bMapped1 += (pTempArray &amp;&amp; pTempArray[0]);</a>
<a name="ln562">            } else {</a>
<a name="ln563">                pTempArray = *pRankStack2;</a>
<a name="ln564">            }</a>
<a name="ln565">            if ( !pTempArray &amp;&amp; !(pTempArray = (AT_RANK *) inchi_malloc(length)))</a>
<a name="ln566">                return CT_OUT_OF_RAM;  /*  out of RAM */ /*   &lt;BRKPT&gt; */</a>
<a name="ln567">            /*  copy &quot;to&quot; contents */</a>
<a name="ln568">            switch( i ) {</a>
<a name="ln569">            case 2:</a>
<a name="ln570">                memcpy( pTempArray, nRank2, length );</a>
<a name="ln571">                break;</a>
<a name="ln572">            case 3:</a>
<a name="ln573">                memcpy( pTempArray, nAtomNumber2, length );</a>
<a name="ln574">                break;</a>
<a name="ln575">            }</a>
<a name="ln576">            if ( i &lt; 2 )</a>
<a name="ln577">                *pRankStack1 ++ = pTempArray;</a>
<a name="ln578">            else {</a>
<a name="ln579">                *pRankStack2 ++ = pTempArray;</a>
<a name="ln580">            }</a>
<a name="ln581">        }</a>
<a name="ln582">        *bAddStack = 2; /*  to break the tie we added 2 more arrays to pRankStack1 and pRankStack2 */</a>
<a name="ln583">    }</a>
<a name="ln584">    return i1;</a>
<a name="ln585">}    </a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">/**************************************************************************************</a>
<a name="ln589"> *</a>
<a name="ln590"> *</a>
<a name="ln591"> *</a>
<a name="ln592"> *               Stereo Mappings</a>
<a name="ln593"> *</a>
<a name="ln594"> *</a>
<a name="ln595"> *</a>
<a name="ln596"> **************************************************************************************/</a>
<a name="ln597"> </a>
<a name="ln598">/**************************************************************************************</a>
<a name="ln599"> * Parity for a half of a stereo bond. If both halfs have the same parity</a>
<a name="ln600"> * then the bond is &quot;trans&quot; (E,-,1), otherwise it is &quot;cis&quot; (Z,+,2).</a>
<a name="ln601"> * The advantage of this approach is: The bond parity does not depend on the</a>
<a name="ln602"> * rank of the atom located on the opposite end of the stereogenic bond.</a>
<a name="ln603"> * As the result all bond parities of, for example, benzene, can be calculated</a>
<a name="ln604"> * from equivalence ranks only, without any mappings.</a>
<a name="ln605"> *</a>
<a name="ln606"> * Input: at_no1     = number of atom for which the half-bond parity is calculated</a>
<a name="ln607"> *        i_sb_neigh = ordering number of the stereo bond in at-&gt;stereo_bond_neighbor[]</a>
<a name="ln608"> *</a>
<a name="ln609"> * Returns: 0=&gt; no parity can be found; 1=&gt; odd parity; 2=&gt; even parity</a>
<a name="ln610"> *</a>
<a name="ln611"> */</a>
<a name="ln612">int HalfStereoBondParity( sp_ATOM *at, int at_no1, int i_sb_neigh, const AT_RANK *nRank )</a>
<a name="ln613">{</a>
<a name="ln614">/*</a>
<a name="ln615">   Suppose neighbors #0,#1,#2 have ranks a, b, c. Remove rank of the neighbor connected</a>
<a name="ln616">   by the stereogenic bond (NCSB) from the a, b, c list and denote the two left as r[0], r[1],</a>
<a name="ln617">   in the same order. Let iNCSB be an ordering number (0,1,or 2) of the NCSB.</a>
<a name="ln618">   Assume the neighbor connected by the stereogenic bond has infinite positive rank.</a>
<a name="ln619">   Position the half-bond so that the stereogenic bond neighbor is to the right from the atom (see below)</a>
<a name="ln620">   </a>
<a name="ln621">   Definition.</a>
<a name="ln622">   ===========</a>
<a name="ln623">                   if rank(X) != rank(Y) then Half-bond parity = (rank(X) &gt; rank(Y)), that is,</a>
<a name="ln624">    Y              </a>
<a name="ln625">     \             if ( rank(X) &lt; rank(Y) ) then Half-bond parity is Even</a>
<a name="ln626">      C==NCSB      if ( rank(X) &gt; rank(Y) ) then Half-bond parity is Odd</a>
<a name="ln627">     /             if ( rank(X) = rank(Y) ) then Half-bond parity cannot be defined</a>
<a name="ln628">    X</a>
<a name="ln629">    </a>
<a name="ln630">    1                          2             1         </a>
<a name="ln631">     \                          \             \        </a>
<a name="ln632">      C==NCSB       C==NCSB      C==NCSB       C==NCSB </a>
<a name="ln633">     /             /            /                      </a>
<a name="ln634">    2             1            1                       </a>
<a name="ln635">                                                       </a>
<a name="ln636">    Parity = 1    Parity = 1   Parity = 2    Parity = 2</a>
<a name="ln637">    (Odd)         (Odd)       (Even) or 0   (Even) or 0</a>
<a name="ln638">    </a>
<a name="ln639">   Half-bond parity =  (iNCSB + (r[0] &gt; r[1]) + (Atom C geometric parity))%2</a>
<a name="ln640"> </a>
<a name="ln641">   Consider the following cases to prove the formula:</a>
<a name="ln642"> </a>
<a name="ln643">   Case 1: 3 explicit neighbors</a>
<a name="ln644">   ============================</a>
<a name="ln645">   If  (1) atom's geometric parity = even (which means neighbors #0, #1, #2 are located clockwise),</a>
<a name="ln646">   and (2) neighbors other than NCSB have different ranks, then,</a>
<a name="ln647">   assuming that NCSB always has the largest (infinite) rank (this is consistent with</a>
<a name="ln648">   the assumption that implicit hydrogens have smallest ranks), we have 3 possibilities:</a>
<a name="ln649"> </a>
<a name="ln650">                             c         a          b       </a>
<a name="ln651">                              \         \          \      </a>
<a name="ln652">                               C==a      C==b       C==c  </a>
<a name="ln653">                              /         /          /      </a>
<a name="ln654">                             b         c          a       </a>
<a name="ln655">                                                          </a>
<a name="ln656">            iNCSB      =      0          1          2    </a>
<a name="ln657">       Half-bond parity =     b&gt;c        a&lt;c        a&gt;b     (0=even, 1=odd)</a>
<a name="ln658">                           r[0]&gt;r[1]  r[0]&lt;r[1]  r[0]&gt;r[1]</a>
<a name="ln659">       Half-bond parity</a>
<a name="ln660">       for all 3 cases      =    (iNCSB + (r[0] &gt; r[1]))%2</a>
<a name="ln661"> </a>
<a name="ln662">       The following slight modification will work for both odd and even geometric parity:</a>
<a name="ln663"> </a>
<a name="ln664">       Half-bond parity     =    (iNCSB + (r[0] &gt; r[1]) + (Atom C geometric parity))%2</a>
<a name="ln665"> </a>
<a name="ln666">       even parity (0) =&gt; atom above the bond has lower rank than the atom below the bond.</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">   Case 2: 2 explicit neighbors</a>
<a name="ln670">   ============================</a>
<a name="ln671">   One implicit hydrogen atom H or hydrogen isotope (implicit rank=0). Assume r[1]=0</a>
<a name="ln672"> </a>
<a name="ln673">                             H         a            Note. The same method </a>
<a name="ln674">                              \         \                 works for              </a>
<a name="ln675">                               C==a      C==b                 </a>
<a name="ln676">                              /         /             N==a   and   a     </a>
<a name="ln677">                             b         H             /              \    </a>
<a name="ln678">                                                    b                N==b</a>
<a name="ln679">            iNCSB       =      0         1     </a>
<a name="ln680">       Half-bond parity =     b&gt;0       a&lt;0    </a>
<a name="ln681">       (r[1]=0, r[0]&gt;0)    r[0]&gt;r[1]  r[0]&lt;r[1] </a>
<a name="ln682"> </a>
<a name="ln683">       Half-bond parity =  (iNCSB + (r[0] &gt; r[1]) + (Atom C geometric parity))%2</a>
<a name="ln684"> </a>
<a name="ln685">   Case 3: 1 explicit neighbor (NCSB)</a>
<a name="ln686">   ==================================</a>
<a name="ln687">   Two implicit hydrogens, (number of neighbors on non-streogenic bonds)==0:</a>
<a name="ln688"> </a>
<a name="ln689">   Atom C geometric parity:  Even               Odd          Note. The same method</a>
<a name="ln690">                                                                   works for                          </a>
<a name="ln691">                             D                  H                       </a>
<a name="ln692">                              \                  \           Even   and   Odd               </a>
<a name="ln693">                               C==a               C==a                                      </a>
<a name="ln694">                              /                  /           H               N==a           </a>
<a name="ln695">                             H                  D             \             /               </a>
<a name="ln696">                                                               N==a        H     </a>
<a name="ln697">            iNCSB =           0                0</a>
<a name="ln698">       Half-bond parity =    (0&lt;0)=0         (0&lt;0)+1 = 1</a>
<a name="ln699">       (r[1]=0, r[0]=0)    r[1]&lt;r[0]         (r[1]&lt;r[0])+atom_parity</a>
<a name="ln700"> </a>
<a name="ln701">       Half-parity</a>
<a name="ln702">       for this case  =    (iNCSB + (r[0] &gt; r[1]) + (Atom C geometric parity))%2</a>
<a name="ln703"> </a>
<a name="ln704">*/</a>
<a name="ln705">    int i, j, k, iNeigh, parity, at1_parity, at_no2;</a>
<a name="ln706">    AT_RANK r[MAX_NUM_STEREO_BOND_NEIGH];</a>
<a name="ln707"> </a>
<a name="ln708">    if ( at[at_no1].valence &gt; MAX_NUM_STEREO_BOND_NEIGH || ( at1_parity = at[at_no1].parity ) &lt;= 0 ) {</a>
<a name="ln709">        return 0;</a>
<a name="ln710">    }</a>
<a name="ln711">    if ( !PARITY_WELL_DEF( at1_parity ) ) {</a>
<a name="ln712">        if ( PARITY_KNOWN( at1_parity ) ) {</a>
<a name="ln713">            return at1_parity;</a>
<a name="ln714">        }</a>
<a name="ln715">        return -at1_parity;</a>
<a name="ln716">    }</a>
<a name="ln717">    if ( 0 &gt; i_sb_neigh || i_sb_neigh &gt;= MAX_NUM_STEREO_BOND_NEIGH ) {</a>
<a name="ln718">        return CT_STEREOBOND_ERROR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln719">    }</a>
<a name="ln720">    for ( i = 0; i &lt;= i_sb_neigh; i ++ ) {</a>
<a name="ln721">        if ( !at[at_no1].stereo_bond_neighbor[i] ) {</a>
<a name="ln722">            return CT_STEREOBOND_ERROR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln723">        }</a>
<a name="ln724">    }</a>
<a name="ln725">    at_no2 = at[at_no1].neighbor[(int)at[at_no1].stereo_bond_ord[i_sb_neigh]];</a>
<a name="ln726">    memset( r, 0, sizeof( r ) ); </a>
<a name="ln727">    for ( i = j = 0, iNeigh = -1; i &lt; at[at_no1].valence; i ++ ) {</a>
<a name="ln728">        if ( (k = (int)at[at_no1].neighbor[i]) == at_no2 ) {</a>
<a name="ln729">            iNeigh = i;</a>
<a name="ln730">        } else {</a>
<a name="ln731">            r[j++] = nRank[k];</a>
<a name="ln732">        }</a>
<a name="ln733">    }</a>
<a name="ln734">    if ( iNeigh &lt; 0 || iNeigh != at[at_no1].stereo_bond_ord[i_sb_neigh] ) {</a>
<a name="ln735">        return CT_STEREOBOND_ERROR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln736">    }</a>
<a name="ln737">    if ( (j &gt; 0 &amp;&amp; !r[0]) || (j &gt; 1 &amp;&amp; !r[1]) )</a>
<a name="ln738">        return 0; /*  undefined ranks */</a>
<a name="ln739"> </a>
<a name="ln740">    if ( (j == 2 &amp;&amp; r[0] == r[1]) || iNeigh &lt; 0 ) {</a>
<a name="ln741">        parity = AB_PARITY_CALC;  /*  cannot calculate bond parity without additional breaking ties. */</a>
<a name="ln742">    } else {</a>
<a name="ln743">        parity = 2 - (at[at_no1].parity + iNeigh + (r[1] &lt; r[0])) % 2;</a>
<a name="ln744">    }</a>
<a name="ln745">    return parity;</a>
<a name="ln746">}</a>
<a name="ln747">/**************************************************************************************/</a>
<a name="ln748">int parity_of_mapped_half_bond( int from_at, int to_at, int from_neigh, int to_neigh,</a>
<a name="ln749">                           sp_ATOM *at, EQ_NEIGH *pEN,</a>
<a name="ln750">                           const AT_RANK *nCanonRankFrom, const AT_RANK *nRankFrom, const AT_RANK *nRankTo )</a>
<a name="ln751">{</a>
<a name="ln752">    int     i, j, k, num_neigh;</a>
<a name="ln753">    int     to_sb_neigh_ord, from_sb_neigh_ord, parity;</a>
<a name="ln754">    AT_RANK r_to[MAX_NUM_STEREO_BOND_NEIGH], at_no_to[MAX_NUM_STEREO_BOND_NEIGH];</a>
<a name="ln755">    AT_RANK r_canon_from[MAX_NUM_STEREO_BOND_NEIGH], at_no_from[MAX_NUM_STEREO_BOND_NEIGH];</a>
<a name="ln756">    AT_RANK r, r_sb_neigh;</a>
<a name="ln757"> </a>
<a name="ln758">    for ( i = 0; i &lt; MAX_NUM_STEREO_BOND_NEIGH; i ++ ) {</a>
<a name="ln759">        r_to[i] = r_canon_from[i] = 0;</a>
<a name="ln760">    }</a>
<a name="ln761">    </a>
<a name="ln762">    if ( pEN ) {</a>
<a name="ln763">        memset( pEN, 0, sizeof(*pEN));</a>
<a name="ln764">    }</a>
<a name="ln765"> </a>
<a name="ln766">    /*  for debug only */</a>
<a name="ln767">    if ( nRankFrom[from_at] != nRankTo[to_at] ||</a>
<a name="ln768">         nRankFrom[from_neigh] != nRankTo[to_neigh] ||</a>
<a name="ln769">         at[to_at].valence != at[from_at].valence ) {</a>
<a name="ln770">        return 0;  /*  program error: both atoms must be mapped */ /*   &lt;BRKPT&gt; */</a>
<a name="ln771">    }</a>
<a name="ln772"> </a>
<a name="ln773">    parity = PARITY_VAL(at[to_at].parity);</a>
<a name="ln774">    num_neigh = at[to_at].valence;</a>
<a name="ln775">    </a>
<a name="ln776">    if ( num_neigh &gt; MAX_NUM_STEREO_BOND_NEIGH || num_neigh &lt; MIN_NUM_STEREO_BOND_NEIGH ) {</a>
<a name="ln777">        /*  2 neighbors are possible in case of stereo bond with implicit H */</a>
<a name="ln778">        /*  or a stereocenter -CHD- with an implicit H */</a>
<a name="ln779">        if ( num_neigh == 1 &amp;&amp; at[to_at].stereo_bond_neighbor[0] ) {</a>
<a name="ln780">            /*  1 neighbor can happen in case of a terminal =CHD */</a>
<a name="ln781">            if ( PARITY_WELL_DEF(parity) )</a>
<a name="ln782">                return 2 - parity % 2;</a>
<a name="ln783">            else</a>
<a name="ln784">            if ( parity )</a>
<a name="ln785">                return parity;</a>
<a name="ln786">            else</a>
<a name="ln787">                return AB_PARITY_UNDF; /*  undefined parity */</a>
<a name="ln788">        }</a>
<a name="ln789">        return 0;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln790">    }</a>
<a name="ln791">    if ( ATOM_PARITY_KNOWN(parity) ) {</a>
<a name="ln792">        if ( !ATOM_PARITY_WELL_DEF(parity) )</a>
<a name="ln793">            return parity;</a>
<a name="ln794">    } else</a>
<a name="ln795">    if ( parity ) {</a>
<a name="ln796">        return 0; /* parity; */</a>
<a name="ln797">    } else {</a>
<a name="ln798">        return 0; /* AB_PARITY_UNDF; */ /*  possibly program error: undefined parity */</a>
<a name="ln799">    }</a>
<a name="ln800">    /*  locate at[to_at].stereo_bond_neighbor[] ordering numbers */</a>
<a name="ln801">    for ( i = 0, to_sb_neigh_ord=-1; i &lt; MAX_NUM_STEREO_BONDS &amp;&amp; (k=(int)at[to_at].stereo_bond_neighbor[i]); i ++ ) {</a>
<a name="ln802">        if ( k == to_neigh+1 ) {</a>
<a name="ln803">            to_sb_neigh_ord = i;</a>
<a name="ln804">            break;</a>
<a name="ln805">        }</a>
<a name="ln806">    }</a>
<a name="ln807">    if ( to_sb_neigh_ord &lt; 0 ) {</a>
<a name="ln808">        return 0;  /*  program error: not a stereo bond */ /*   &lt;BRKPT&gt; */</a>
<a name="ln809">    }</a>
<a name="ln810">    to_sb_neigh_ord = (int)at[to_at].stereo_bond_ord[to_sb_neigh_ord];</a>
<a name="ln811">    r_sb_neigh   = nRankTo[(int)at[to_at].neighbor[to_sb_neigh_ord]];</a>
<a name="ln812">    for ( i = j = 0; i &lt; num_neigh; i ++ ) {</a>
<a name="ln813">        if ( i != to_sb_neigh_ord ) {</a>
<a name="ln814">            r_to[j] = nRankTo[(int)(at_no_to[j]=at[to_at].neighbor[i])];</a>
<a name="ln815">            if ( r_sb_neigh == r_to[j] ) {</a>
<a name="ln816">                return 0; /*  stereo bond atoms are not fully mapped */</a>
<a name="ln817">            }</a>
<a name="ln818">            j ++;</a>
<a name="ln819">        }</a>
<a name="ln820">    }</a>
<a name="ln821">    if ( j+1 != num_neigh ) {</a>
<a name="ln822">        return 0; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln823">    }</a>
<a name="ln824">    if ( j == 1 ) {</a>
<a name="ln825">        /*  only one neighbor; no mapping needed */</a>
<a name="ln826">        return 2-(parity+1+to_sb_neigh_ord)%2;</a>
<a name="ln827">    }</a>
<a name="ln828">    if ( j != 2 ) {</a>
<a name="ln829">        return 0; /*  program error: j can be only 0, 1, or 2 */ /*   &lt;BRKPT&gt; */</a>
<a name="ln830">    }</a>
<a name="ln831">    </a>
<a name="ln832">    if ( r_to[0] == r_to[1] ) {</a>
<a name="ln833">        /*  double bond neighbors need to be mapped */</a>
<a name="ln834">        j = 0;</a>
<a name="ln835">        from_sb_neigh_ord = -1;</a>
<a name="ln836">        for ( i = 0; i &lt; num_neigh; i ++ ) {</a>
<a name="ln837">            k = at[from_at].neighbor[i];</a>
<a name="ln838">            r = nRankFrom[k];</a>
<a name="ln839">            if ( r == r_sb_neigh ) {</a>
<a name="ln840">                from_sb_neigh_ord = i;   /*  we need this value only for error-checking */</a>
<a name="ln841">            } else</a>
<a name="ln842">            if ( r == r_to[0] ) {</a>
<a name="ln843">                r_canon_from[j] = nCanonRankFrom[k];</a>
<a name="ln844">                at_no_from[j]   = (AT_RANK)k;</a>
<a name="ln845">                j ++;</a>
<a name="ln846">            } else {</a>
<a name="ln847">                return 0; /*  program error: unexpected rank, not fully mapped adjacent to the stereo bond atoms */ /*   &lt;BRKPT&gt; */</a>
<a name="ln848">            }</a>
<a name="ln849">        }</a>
<a name="ln850">        if ( from_sb_neigh_ord &lt; 0 || j != 2 ) {</a>
<a name="ln851">            return 0; /*  program error: rank of a neighbor not found */ /*   &lt;BRKPT&gt; */</a>
<a name="ln852">        }</a>
<a name="ln853">        if ( pEN ) { /*  j == 2 */</a>
<a name="ln854">            pEN-&gt;to_at[0] = at_no_to[0];</a>
<a name="ln855">            pEN-&gt;to_at[1] = at_no_to[1];</a>
<a name="ln856">            pEN-&gt;num_to   = 2;           /*  number of stored in pEN-&gt;to_at[] central atom neighbors */</a>
<a name="ln857">            pEN-&gt;rank     = r_to[0];     /*  mapping rank of the tied neighbors */</a>
<a name="ln858">             /*  i := index of the smaller out of r_canon_from[1] and r_canon_from[0] */</a>
<a name="ln859">            i = (r_canon_from[1] &lt; r_canon_from[0]);</a>
<a name="ln860">            pEN-&gt;from_at    = at_no_from[i];</a>
<a name="ln861">            pEN-&gt;canon_rank = r_canon_from[i];</a>
<a name="ln862">        }</a>
<a name="ln863">        return -((int)r_to[0]);</a>
<a name="ln864">    }</a>
<a name="ln865">    /*  double bond neighbors a mapped: r_to[0] != r_to[1] */</a>
<a name="ln866">    from_sb_neigh_ord = -1;</a>
<a name="ln867">    for ( i = 0; i &lt; num_neigh; i ++ ) {</a>
<a name="ln868">        k = at[from_at].neighbor[i];</a>
<a name="ln869">        r = nRankFrom[k];</a>
<a name="ln870">        if ( r == r_sb_neigh ) {</a>
<a name="ln871">            from_sb_neigh_ord = i;  /*  we need this value only for error-checking */</a>
<a name="ln872">        } else</a>
<a name="ln873">        if ( r == r_to[0] ) {</a>
<a name="ln874">            r_canon_from[0] = nCanonRankFrom[k];</a>
<a name="ln875">            /* at_no_from[0]   = (AT_RANK)k; */</a>
<a name="ln876">        } else</a>
<a name="ln877">        if ( r == r_to[1] ) {</a>
<a name="ln878">            r_canon_from[1] = nCanonRankFrom[k];</a>
<a name="ln879">            /* at_no_from[1]   = (AT_RANK)k; */</a>
<a name="ln880">        } else {</a>
<a name="ln881">            return 0; /*  program error: unexpected rank, not fully mapped adjacent to the stereo bond atoms */ /*   &lt;BRKPT&gt; */</a>
<a name="ln882">        }</a>
<a name="ln883">    }</a>
<a name="ln884">    if ( !r_canon_from[0] || !r_canon_from[1] || from_sb_neigh_ord &lt; 0 ) {</a>
<a name="ln885">        return 0; /*  program error: neighbor rank not found */ /*   &lt;BRKPT&gt; */</a>
<a name="ln886">    }</a>
<a name="ln887">    return 2 - (parity + to_sb_neigh_ord + (r_canon_from[1]&lt;r_canon_from[0]))%2;</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">/**************************************************************************************/</a>
<a name="ln891">int parity_of_mapped_atom2( int from_at, int to_at, const sp_ATOM *at, EQ_NEIGH *pEN,</a>
<a name="ln892">                           const AT_RANK *nCanonRankFrom, const AT_RANK *nRankFrom, const AT_RANK *nRankTo )</a>
<a name="ln893">{</a>
<a name="ln894">    AT_RANK nNeighRankFrom[4], nNeighNumberFrom[4], nNeighRankTo[4], nNeighNumberTo[4];</a>
<a name="ln895">    AT_RANK nNeighRankFromCanon[4], nNeighRankToCanon[4];</a>
<a name="ln896">    int     i, j, k, num_neigh;</a>
<a name="ln897">    int     r1, r2, r, r_canon_from_min, neigh_canon_from_min, r_canon_from;</a>
<a name="ln898">    int     num_trans_to, num_trans_from, neigh1, neigh2;</a>
<a name="ln899"> </a>
<a name="ln900"> </a>
<a name="ln901">    num_neigh = at[to_at].valence;</a>
<a name="ln902">    </a>
<a name="ln903">    if ( pEN ) {</a>
<a name="ln904">        memset( pEN, 0, sizeof(*pEN));</a>
<a name="ln905">    }</a>
<a name="ln906"> </a>
<a name="ln907">    /*  for debug only */</a>
<a name="ln908">    if ( nRankFrom[from_at] != nRankTo[to_at] )</a>
<a name="ln909">        return 0;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln910">    if ( num_neigh &gt; MAX_NUM_STEREO_ATOM_NEIGH || num_neigh &lt; 2 ) {</a>
<a name="ln911">        /*  2 neighbors are possible in case of stereo bond with implicit H */</a>
<a name="ln912">        /*  or a stereocenter &gt;CHD with two implicit H */</a>
<a name="ln913">        if ( num_neigh == 1 ) {</a>
<a name="ln914">            /*  1 neighbor can happen in case of a terminal -CHDT or =CHD */</a>
<a name="ln915">            if ( at[to_at].parity )</a>
<a name="ln916">                return at[to_at].parity;</a>
<a name="ln917">            else</a>
<a name="ln918">                return AB_PARITY_UNDF; /*  undefined parity */</a>
<a name="ln919">        }</a>
<a name="ln920">        return 0;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln921">    }</a>
<a name="ln922">    for ( i = 0; i &lt; num_neigh; i ++ ) { /*  initialization of locals */</a>
<a name="ln923">        nNeighNumberTo[i]      =</a>
<a name="ln924">        nNeighNumberFrom[i]    = i;</a>
<a name="ln925">        nNeighRankTo[i]        = nRankTo[(int)at[to_at].neighbor[i]];       /* mapping rank */</a>
<a name="ln926">        nNeighRankFrom[i]      = nRankFrom[j=(int)at[from_at].neighbor[i]]; /* mapping rank */</a>
<a name="ln927">        nNeighRankFromCanon[i] = nCanonRankFrom[j];                     /* canonical number */</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">    pn_RankForSort = nNeighRankFrom;</a>
<a name="ln931">    nNumCompNeighborsRanksCountEql = 0; /*  sort mapping ranks-from */</a>
<a name="ln932">    num_trans_from = insertions_sort( nNeighNumberFrom, num_neigh, sizeof(nNeighNumberFrom[0]), CompNeighborsRanksCountEql );</a>
<a name="ln933"> </a>
<a name="ln934">    if ( nNumCompNeighborsRanksCountEql ) {</a>
<a name="ln935">        /*  At least 2 neighbors have equal mapping ranks (are tied). */</a>
<a name="ln936">        /*  Find tied from-neighbors with minimal canonical rank (nCanonRankFrom[]) */</a>
<a name="ln937">        r_canon_from_min = MAX_ATOMS+1; /*  max possible rank + 1 */</a>
<a name="ln938">        for ( i = 1, r = 0, r1 = nNeighRankFrom[neigh1=nNeighNumberFrom[0]]; i &lt; num_neigh; i ++, r1 = r2, neigh1 = neigh2 ) {</a>
<a name="ln939">            r2 = nNeighRankFrom[neigh2=nNeighNumberFrom[i]];</a>
<a name="ln940">            if ( r2 == r1 ) {</a>
<a name="ln941">                /*  found neighbors with tied ranks */</a>
<a name="ln942">                if ( r != r2 ) {</a>
<a name="ln943">                    /*  the 1st pair of neighbor with this rank */</a>
<a name="ln944">                    r = r2;</a>
<a name="ln945">                    if ( (r_canon_from=nNeighRankFromCanon[neigh1]) &lt; r_canon_from_min ) {</a>
<a name="ln946">                        r_canon_from_min     = r_canon_from; /*  min canon rank */</a>
<a name="ln947">                        neigh_canon_from_min = neigh1;       /*  neighbor number */</a>
<a name="ln948">                    }</a>
<a name="ln949">                }</a>
<a name="ln950">                if ( (r_canon_from=nNeighRankFromCanon[neigh2]) &lt; r_canon_from_min ) {</a>
<a name="ln951">                    r_canon_from_min     = r_canon_from;</a>
<a name="ln952">                    neigh_canon_from_min = neigh2;</a>
<a name="ln953">                }</a>
<a name="ln954">            }</a>
<a name="ln955">        }</a>
<a name="ln956">        if ( r ) {</a>
<a name="ln957">            /*  neighbors with tied ranks have been found =&gt; parity cannot be determined without additional mapping */</a>
<a name="ln958">            /*  find to-neighbors on which neigh_canon_from_min can be mapped */</a>
<a name="ln959">            r1 = nNeighRankFrom[neigh_canon_from_min];</a>
<a name="ln960">            if ( pEN ) {</a>
<a name="ln961">                for ( i = j = 0; i &lt; num_neigh; i ++ ) {</a>
<a name="ln962">                    if ( r1 == nNeighRankTo[i] ) {</a>
<a name="ln963">                        pEN-&gt;to_at[j++] = at[to_at].neighbor[i];</a>
<a name="ln964">                    }</a>
<a name="ln965">                }</a>
<a name="ln966">                insertions_sort( pEN-&gt;to_at, j, sizeof(pEN-&gt;to_at[0]), CompRanksInvOrd );</a>
<a name="ln967">                pEN-&gt;num_to     = j;  /*  number of stored in pEN-&gt;to_at[] central atom neighbors */</a>
<a name="ln968">                pEN-&gt;from_at    = at[from_at].neighbor[neigh_canon_from_min]; /*  neighbor with min. canon number */</a>
<a name="ln969">                pEN-&gt;rank       = r1; /*  mapping rank of the tied neighbors */</a>
<a name="ln970">                pEN-&gt;canon_rank = r_canon_from_min;  /*  canon. rank of the pEN-&gt;from_at */</a>
<a name="ln971">            } else {</a>
<a name="ln972">                /*  debug only */</a>
<a name="ln973">                for ( i = j = 0; i &lt; num_neigh; i ++ ) {</a>
<a name="ln974">                    if ( r1 == nNeighRankTo[i] ) {</a>
<a name="ln975">                        j++;</a>
<a name="ln976">                    }</a>
<a name="ln977">                }</a>
<a name="ln978">            }</a>
<a name="ln979">            /*  debug only */</a>
<a name="ln980">            if ( j &lt;= 1 || !r1 || r_canon_from_min &gt; MAX_ATOMS ) {</a>
<a name="ln981">                return 0; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln982">            }</a>
<a name="ln983">            return -r; /*  means parity cannot be determined */</a>
<a name="ln984">        }</a>
<a name="ln985">        return 0; /* program error */</a>
<a name="ln986">    }</a>
<a name="ln987">    /*  All neighbors have different mapping ranks; */</a>
<a name="ln988">    /*  therefore no additional mapping of the neighbors is necessary */</a>
<a name="ln989">    if ( !ATOM_PARITY_WELL_DEF(at[to_at].parity) )</a>
<a name="ln990">        return at[to_at].parity; /*  unknown parity or cannot be determined */</a>
<a name="ln991"> </a>
<a name="ln992">    pn_RankForSort = nNeighRankTo;</a>
<a name="ln993">    num_trans_to   = insertions_sort( nNeighNumberTo, num_neigh, sizeof(nNeighNumberTo[0]), CompNeighborsRanksCountEql );</a>
<a name="ln994">    </a>
<a name="ln995">    /*  Map canonical ranks of neighbors. Mapped on each other &quot;to&quot; and &quot;from&quot; atoms have equal mapping ranks */</a>
<a name="ln996">    for ( i = 0; i &lt; num_neigh; i ++ ) {</a>
<a name="ln997">        if ( nNeighRankTo[j=nNeighNumberTo[i]] != nNeighRankFrom[k=nNeighNumberFrom[i]] )</a>
<a name="ln998">            return 0; /*  program error: mapping ranks not equal, from_at neigborhood cannot be mapped on to_at neighbood. */ /*   &lt;BRKPT&gt; */</a>
<a name="ln999">        nNeighRankToCanon[j] = nNeighRankFromCanon[k]; /*  potential problem: other atom(s) may have same mapping rank and */</a>
<a name="ln1000">                                                       /*  different canon. rank(s). */</a>
<a name="ln1001">        /*  we may save some memory by eliminating nNeighRankFromCanon[]: */</a>
<a name="ln1002">        /*  nNeighRankToCanon[j] = nCanonRankFrom[at[from_at].neighbor[k]] */</a>
<a name="ln1003">    }</a>
<a name="ln1004"> </a>
<a name="ln1005">    pn_RankForSort  = nNeighRankToCanon;</a>
<a name="ln1006">    num_trans_to   += insertions_sort( nNeighNumberTo, num_neigh, sizeof(nNeighNumberTo[0]), CompNeighborsRanksCountEql );</a>
<a name="ln1007">#ifndef CT_NEIGH_INCREASE</a>
<a name="ln1008">    num_trans_to   += ((num_neigh*(num_neigh-1))/2)%2;  /*  get correct parity for ascending order of canon. numbers */</a>
<a name="ln1009">#endif</a>
<a name="ln1010"> </a>
<a name="ln1011">    return 2 - (num_trans_to + at[to_at].parity)%2;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">/**************************************************************************************</a>
<a name="ln1015"> *</a>
<a name="ln1016"> *   Phase II: map canonicaly numbrered structure onto itself</a>
<a name="ln1017"> *             to obtain a minimal or maximal stereo part of the CT</a>
<a name="ln1018"> *</a>
<a name="ln1019"> **************************************************************************************/</a>
<a name="ln1020"> </a>
<a name="ln1021">int ClearPreviousMappings( AT_RANK **pRankStack1 )</a>
<a name="ln1022">{</a>
<a name="ln1023">    int i;</a>
<a name="ln1024">    for ( i = 0; pRankStack1[i]; i ++ ) {</a>
<a name="ln1025">        pRankStack1[i][0] = 0;</a>
<a name="ln1026">    }</a>
<a name="ln1027">    return i;</a>
<a name="ln1028"> </a>
<a name="ln1029">}</a>
<a name="ln1030">/**************************************************************************************/</a>
<a name="ln1031">/*  map one atom (&quot;from&quot;) onto another (&quot;to&quot;): untie their mapping ranks if they are tied. */</a>
<a name="ln1032">int map_an_atom2( int num_atoms, int num_max, int at_no1/*from*/, int at_no2/*to*/,</a>
<a name="ln1033">                AT_RANK *nTempRank,</a>
<a name="ln1034">                int nNumMappedRanks, int *pnNewNumMappedRanks,</a>
<a name="ln1035">                CANON_STAT *pCS,</a>
<a name="ln1036">                NEIGH_LIST    *NeighList,</a>
<a name="ln1037">                AT_RANK  **pRankStack1, AT_RANK  **pRankStack2, int *bAddStack )</a>
<a name="ln1038">{</a>
<a name="ln1039">    AT_RANK *nRank1,  *nAtomNumber1;  /*  ranks for mapping &quot;1&quot;, &quot;from&quot; */</a>
<a name="ln1040">    AT_RANK *nRank2,  *nAtomNumber2;  /*  ranks for mapping &quot;2&quot;, &quot;to&quot; */</a>
<a name="ln1041">    AT_RANK *nNewRank1=NULL,  *nNewAtomNumber1=NULL;  /*  ranks for mapping &quot;1&quot;, &quot;from&quot; */</a>
<a name="ln1042">    AT_RANK *nNewRank2=NULL,  *nNewAtomNumber2=NULL;  /*  ranks for mapping &quot;2&quot;, &quot;to&quot; */</a>
<a name="ln1043">    int     length = num_max*sizeof(AT_RANK);</a>
<a name="ln1044">    int     nNewNumRanks2, nNewNumRanks1;</a>
<a name="ln1045">    int     i, bAtFromHasAlreadyBeenMapped, nNumTies;</a>
<a name="ln1046">    AT_RANK nNewRank;</a>
<a name="ln1047"> </a>
<a name="ln1048">    nNumTies = NumberOfTies( pRankStack1, pRankStack2, length, at_no1, at_no2, &amp;nNewRank, bAddStack, &amp;bAtFromHasAlreadyBeenMapped );</a>
<a name="ln1049">    </a>
<a name="ln1050">    if ( RETURNED_ERROR(nNumTies) )</a>
<a name="ln1051">        return nNumTies;  /*  error */</a>
<a name="ln1052"> </a>
<a name="ln1053">    nRank1       = *pRankStack1++;</a>
<a name="ln1054">    nAtomNumber1 = *pRankStack1++;  /*  ranks for mapping &quot;1&quot;, &quot;from&quot; */</a>
<a name="ln1055"> </a>
<a name="ln1056">    nRank2       = *pRankStack2++;</a>
<a name="ln1057">    nAtomNumber2 = *pRankStack2++;  /*  ranks for mapping &quot;2&quot;, &quot;to&quot; */</a>
<a name="ln1058">    </a>
<a name="ln1059">    if ( nNumTies &gt; 1 ) {</a>
<a name="ln1060"> </a>
<a name="ln1061">        nNewRank1       = *pRankStack1++;</a>
<a name="ln1062">        nNewAtomNumber1 = *pRankStack1++;  /*  ranks for mapping &quot;1&quot;, &quot;from&quot; */</a>
<a name="ln1063"> </a>
<a name="ln1064">        nNewRank2       = *pRankStack2++;</a>
<a name="ln1065">        nNewAtomNumber2 = *pRankStack2++;  /*  ranks for mapping &quot;2&quot;, &quot;to&quot; */</a>
<a name="ln1066">        /*  break a tie for &quot;to&quot; */</a>
<a name="ln1067">        memcpy( nNewRank2, nRank2, length );</a>
<a name="ln1068">        memcpy( nNewAtomNumber2, nAtomNumber2, length );</a>
<a name="ln1069">        nNewRank2[at_no2] = nNewRank;</a>
<a name="ln1070">        nNewNumRanks2 = DifferentiateRanks2( num_atoms, NeighList,</a>
<a name="ln1071">                                         nNumMappedRanks, nNewRank2, nTempRank,</a>
<a name="ln1072">                                         nNewAtomNumber2, &amp;pCS-&gt;lNumNeighListIter, 1 );</a>
<a name="ln1073">        pCS-&gt;lNumBreakTies ++;</a>
<a name="ln1074"> </a>
<a name="ln1075">        /*  Check whether the old mapping can be reused */</a>
<a name="ln1076">        if ( 2 == bAtFromHasAlreadyBeenMapped &amp;&amp; nNewRank == nNewRank1[at_no1] ) {</a>
<a name="ln1077">            for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1078">                if ( nNewRank1[nNewAtomNumber1[i]] != nNewRank2[nNewAtomNumber2[i]] ) {</a>
<a name="ln1079">                    bAtFromHasAlreadyBeenMapped = 0; /*  It cannot. */</a>
<a name="ln1080">                    break;</a>
<a name="ln1081">                }</a>
<a name="ln1082">            }</a>
<a name="ln1083">        } else {</a>
<a name="ln1084">            bAtFromHasAlreadyBeenMapped = 0;</a>
<a name="ln1085">        }</a>
<a name="ln1086">        if ( 2 != bAtFromHasAlreadyBeenMapped ) {</a>
<a name="ln1087">            /*  break a tie for &quot;from&quot; */</a>
<a name="ln1088">            for ( i = 0; pRankStack1[i]; i ++ ) {</a>
<a name="ln1089">                pRankStack1[i][0] = 0;</a>
<a name="ln1090">            }</a>
<a name="ln1091">            memcpy( nNewRank1, nRank1, length );</a>
<a name="ln1092">            memcpy( nNewAtomNumber1, nAtomNumber1, length );  /* GPF: bad nAtomNumber1 */</a>
<a name="ln1093">            nNewRank1[at_no1] = nNewRank;</a>
<a name="ln1094">            nNewNumRanks1 = DifferentiateRanks2( num_atoms, NeighList,</a>
<a name="ln1095">                                             nNumMappedRanks, nNewRank1, nTempRank,</a>
<a name="ln1096">                                             nNewAtomNumber1, &amp;pCS-&gt;lNumNeighListIter, 1 );</a>
<a name="ln1097">            pCS-&gt;lNumBreakTies ++;</a>
<a name="ln1098">        } else {</a>
<a name="ln1099">            nNewNumRanks1 = nNewNumRanks2;</a>
<a name="ln1100">        }</a>
<a name="ln1101"> </a>
<a name="ln1102">        if ( nNewNumRanks1 != nNewNumRanks2 )</a>
<a name="ln1103">            return CT_MAPCOUNT_ERR; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1104">        *pnNewNumMappedRanks = nNewNumRanks2;</a>
<a name="ln1105">        /*  debug only */</a>
<a name="ln1106">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1107">            if ( nNewRank1[nNewAtomNumber1[i]] != nNewRank2[nNewAtomNumber2[i]] ) {</a>
<a name="ln1108">                return CT_MAPCOUNT_ERR; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1109">            }</a>
<a name="ln1110">        }</a>
<a name="ln1111">    } else {</a>
<a name="ln1112">        *pnNewNumMappedRanks = nNumMappedRanks;</a>
<a name="ln1113">    }</a>
<a name="ln1114">    return ( nNewRank1 )? nNewRank1[at_no1] : nRank1[at_no1]; /*  mapping rank value */</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">/**************************************************************************************/</a>
<a name="ln1118">int might_change_other_atom_parity( sp_ATOM *at, int num_atoms, int at_no, AT_RANK *nRank2, AT_RANK *nRank1 )</a>
<a name="ln1119">{</a>
<a name="ln1120">    int     i, j, neighbor_no;</a>
<a name="ln1121">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1122">        if ( nRank2[i] != nRank1[i] ) {</a>
<a name="ln1123">            if ( i != at_no /*&amp;&amp; ATOM_PARITY_WELL_DEF(at[i].parity)*/</a>
<a name="ln1124">                &amp;&amp; at[i].bHasStereoOrEquToStereo</a>
<a name="ln1125">                &amp;&amp; !(at[i].stereo_atom_parity &amp; KNOWN_PARITIES_EQL )</a>
<a name="ln1126">                &amp;&amp; !at[i].stereo_bond_neighbor[0]</a>
<a name="ln1127">                ) {</a>
<a name="ln1128"> </a>
<a name="ln1129">                return 1; /*  may have changed stereo atoms order */</a>
<a name="ln1130">            }</a>
<a name="ln1131">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1132">                neighbor_no = at[i].neighbor[j];</a>
<a name="ln1133">                if ( neighbor_no != at_no</a>
<a name="ln1134">                     /*&amp;&amp; ATOM_PARITY_WELL_DEF(at[neighbor_no].parity)*/ </a>
<a name="ln1135">                     &amp;&amp; at[neighbor_no].bHasStereoOrEquToStereo</a>
<a name="ln1136">                     &amp;&amp; !(at[neighbor_no].stereo_atom_parity &amp; KNOWN_PARITIES_EQL )</a>
<a name="ln1137">                     &amp;&amp; !at[neighbor_no].stereo_bond_neighbor[0]</a>
<a name="ln1138">                   )</a>
<a name="ln1139">                    return 1; /*  may have changed stereo atom parity */</a>
<a name="ln1140">            }</a>
<a name="ln1141">        }</a>
<a name="ln1142">    }</a>
<a name="ln1143">    return 0;</a>
<a name="ln1144">}</a>
<a name="ln1145">/**************************************************************************************/</a>
<a name="ln1146">#if ( REMOVE_CALC_NONSTEREO == 1 ) /* { */</a>
<a name="ln1147">/**************************************************************************************/</a>
<a name="ln1148">void DeAllocateForNonStereoRemoval( AT_RANK **nAtomNumberCanon1, AT_RANK **nAtomNumberCanon2,</a>
<a name="ln1149">                                    NEIGH_LIST **nl, NEIGH_LIST **nl1, NEIGH_LIST **nl2, AT_RANK **nVisited1, AT_RANK **nVisited2 )</a>
<a name="ln1150">{</a>
<a name="ln1151">    if ( *nAtomNumberCanon1 ) {</a>
<a name="ln1152">        inchi_free( *nAtomNumberCanon1 );</a>
<a name="ln1153">        *nAtomNumberCanon1 = NULL;</a>
<a name="ln1154">    }</a>
<a name="ln1155">    if ( *nAtomNumberCanon2 ) {</a>
<a name="ln1156">        inchi_free( *nAtomNumberCanon2 );</a>
<a name="ln1157">        *nAtomNumberCanon2 = NULL;</a>
<a name="ln1158">    }</a>
<a name="ln1159">    if ( *nl ) {</a>
<a name="ln1160">        FreeNeighList( *nl );</a>
<a name="ln1161">        *nl = 0;</a>
<a name="ln1162">    }</a>
<a name="ln1163">    if ( *nl1 ) {</a>
<a name="ln1164">        FreeNeighList( *nl1 );</a>
<a name="ln1165">        *nl1 = 0;</a>
<a name="ln1166">    }</a>
<a name="ln1167">    if ( *nl2 ) {</a>
<a name="ln1168">        FreeNeighList( *nl2 );</a>
<a name="ln1169">        *nl2 = 0;</a>
<a name="ln1170">    }</a>
<a name="ln1171">    if ( *nVisited1 ) {</a>
<a name="ln1172">        inchi_free( *nVisited1 );</a>
<a name="ln1173">        *nVisited1 = NULL;</a>
<a name="ln1174">    }</a>
<a name="ln1175">    if ( *nVisited2 ) {</a>
<a name="ln1176">        inchi_free( *nVisited2 );</a>
<a name="ln1177">        *nVisited2 = NULL;</a>
<a name="ln1178">    }</a>
<a name="ln1179"> </a>
<a name="ln1180">}</a>
<a name="ln1181">/**************************************************************************************/</a>
<a name="ln1182">int AllocateForNonStereoRemoval( sp_ATOM *at, int num_atoms, const AT_RANK *nSymmRank, AT_RANK *nCanonRank,</a>
<a name="ln1183">                            AT_RANK **nAtomNumberCanon1, AT_RANK **nAtomNumberCanon2,</a>
<a name="ln1184">                            NEIGH_LIST **nl, NEIGH_LIST **nl1, NEIGH_LIST **nl2, AT_RANK **nVisited1, AT_RANK **nVisited2 )</a>
<a name="ln1185">{</a>
<a name="ln1186">    DeAllocateForNonStereoRemoval( nAtomNumberCanon1, nAtomNumberCanon2, nl, nl1, nl2, nVisited1, nVisited2 );</a>
<a name="ln1187">    *nAtomNumberCanon1 = (AT_RANK *) inchi_malloc( num_atoms * sizeof(**nAtomNumberCanon1) );</a>
<a name="ln1188">    *nAtomNumberCanon2 = (AT_RANK *) inchi_malloc( num_atoms * sizeof(**nAtomNumberCanon2) );</a>
<a name="ln1189">    *nl                = CreateNeighList( num_atoms, num_atoms, at, 0, NULL );</a>
<a name="ln1190">    *nl1               = CreateNeighList( num_atoms, num_atoms, at, 0, NULL );</a>
<a name="ln1191">    *nl2               = CreateNeighList( num_atoms, num_atoms, at, 0, NULL );</a>
<a name="ln1192">    *nVisited1         = (AT_RANK *) inchi_malloc( num_atoms * sizeof(**nVisited1) );</a>
<a name="ln1193">    *nVisited2         = (AT_RANK *) inchi_malloc( num_atoms * sizeof(**nVisited2) );</a>
<a name="ln1194"> </a>
<a name="ln1195">    if ( !*nl || !*nl1 || !*nl2 || !*nVisited1 || !*nVisited2 || !*nAtomNumberCanon1 || !*nAtomNumberCanon2 ) {</a>
<a name="ln1196">        DeAllocateForNonStereoRemoval( nAtomNumberCanon1, nAtomNumberCanon2, nl, nl1, nl2, nVisited1, nVisited2 );</a>
<a name="ln1197">        return 0;</a>
<a name="ln1198">    }</a>
<a name="ln1199">    /*  Sort neighbors according to symm. ranks (primary key) and canon. ranks (secondary key), in descending order */</a>
<a name="ln1200">    SortNeighListsBySymmAndCanonRank( num_atoms, *nl,  nSymmRank, nCanonRank );</a>
<a name="ln1201">    SortNeighListsBySymmAndCanonRank( num_atoms, *nl1, nSymmRank, nCanonRank );</a>
<a name="ln1202">    SortNeighListsBySymmAndCanonRank( num_atoms, *nl2, nSymmRank, nCanonRank );</a>
<a name="ln1203">    return 1;</a>
<a name="ln1204">}</a>
<a name="ln1205">/**************************************************************************************/</a>
<a name="ln1206">AT_RANK GetMinNewRank(AT_RANK *nAtomRank, AT_RANK *nAtomNumb, AT_RANK nRank1 )</a>
<a name="ln1207">{</a>
<a name="ln1208">    int i;</a>
<a name="ln1209">    AT_RANK nRank2;</a>
<a name="ln1210">    for ( i = (int)nRank1-1; 0 &lt;= i &amp;&amp; nRank1 == (nRank2 = nAtomRank[(int)nAtomNumb[i]]); i -- )</a>
<a name="ln1211">        ;</a>
<a name="ln1212">    if ( i &gt;= 0 )</a>
<a name="ln1213">        nRank2 ++;</a>
<a name="ln1214">    else</a>
<a name="ln1215">        nRank2 = 1;</a>
<a name="ln1216">    return nRank2;</a>
<a name="ln1217">}</a>
<a name="ln1218">/**************************************************************************************/</a>
<a name="ln1219">int BreakNeighborsTie(  sp_ATOM *at, int num_atoms, int num_at_tg, int ib, int ia,</a>
<a name="ln1220">                        AT_RANK *neigh_num, int in1, int in2, int mode,</a>
<a name="ln1221">                        AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln1222">                        const AT_RANK *nSymmRank, AT_RANK *nCanonRank, NEIGH_LIST *nl1, NEIGH_LIST *nl2, long *lNumIter )</a>
<a name="ln1223">{</a>
<a name="ln1224">    AT_RANK nRank1, nRank2;</a>
<a name="ln1225">    int     nNumDiffRanks, nNumDiffRanks1, nNumDiffRanks2, i;</a>
<a name="ln1226">    int n1  = (int)neigh_num[in1];</a>
<a name="ln1227">    int n2  = (int)neigh_num[in2];</a>
<a name="ln1228">    int other_neigh[2], other_neig_ord[2], num_other_neigh;</a>
<a name="ln1229">    /*  asymmetric calculation */</a>
<a name="ln1230"> </a>
<a name="ln1231">    if ( (mode == MAP_MODE_S4  &amp;&amp; in1) || /* for S4 we need only (in1,in2) = (0,1) (0,2) (0,3) pairs of neighbors */</a>
<a name="ln1232">         (mode != MAP_MODE_STD &amp;&amp; at[ia].valence != MAX_NUM_STEREO_ATOM_NEIGH) ||</a>
<a name="ln1233">         (mode != MAP_MODE_STD &amp;&amp; nSymmRank[n1]  != nSymmRank[n2]) ) {</a>
<a name="ln1234">        return 0;</a>
<a name="ln1235">    }</a>
<a name="ln1236">    /*  1. Create initial ranks from equivalence information stored in nSymmRank */</a>
<a name="ln1237">    memcpy( pRankStack1[0], nSymmRank, num_at_tg * sizeof(pRankStack1[0][0]) );</a>
<a name="ln1238">    pn_RankForSort = pRankStack1[0];</a>
<a name="ln1239">    tsort( pRankStack1[1], num_at_tg, sizeof(pRankStack1[1][0]), CompRanksOrd );</a>
<a name="ln1240">    nNumDiffRanks = SortedEquInfoToRanks( pRankStack1[0]/*inp*/, pRankStack1[0]/*out*/, pRankStack1[1], num_at_tg, NULL );</a>
<a name="ln1241">    </a>
<a name="ln1242">    /* other neighbors */</a>
<a name="ln1243">    num_other_neigh = 0;</a>
<a name="ln1244">    if ( at[ia].valence &lt;= MAX_NUM_STEREO_ATOM_NEIGH &amp;&amp; mode ) {</a>
<a name="ln1245">        for ( i = 0; i &lt; at[ia].valence; i ++ ) {</a>
<a name="ln1246">            if ( i != in1 &amp;&amp; i != in2 ) {</a>
<a name="ln1247">                other_neigh[num_other_neigh]    = (int)neigh_num[i];</a>
<a name="ln1248">                other_neig_ord[num_other_neigh] = i;</a>
<a name="ln1249">                num_other_neigh ++;</a>
<a name="ln1250">            }</a>
<a name="ln1251">        }</a>
<a name="ln1252">    }</a>
<a name="ln1253">    if ( (mode != MAP_MODE_STD &amp;&amp; nSymmRank[other_neigh[0]] != nSymmRank[other_neigh[1]]) ||</a>
<a name="ln1254">         (mode == MAP_MODE_S4  &amp;&amp; nSymmRank[n1]             != nSymmRank[other_neigh[1]]) ) {</a>
<a name="ln1255">        return 0;</a>
<a name="ln1256">    }</a>
<a name="ln1257"> </a>
<a name="ln1258">    /*  2. Fix at[ia] */</a>
<a name="ln1259">    if ( pRankStack1[0][ia] != nSymmRank[ia] ) {</a>
<a name="ln1260">        /*  at[ia] is constitutionally equivalent to some other atom. Fix at[ia]. */</a>
<a name="ln1261">        pRankStack1[0][ia] = nSymmRank[ia];</a>
<a name="ln1262">        nNumDiffRanks = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1263">                                     nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1264">                                     pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1265">    }</a>
<a name="ln1266">    /*  3. In case of a double bond/cumulene only: */</a>
<a name="ln1267">    /*     fix at[ib] -- the opposite double bond/cumulene atom */</a>
<a name="ln1268">    if ( ib &lt; num_atoms ) {</a>
<a name="ln1269">        /*  find the smallest possible rank */</a>
<a name="ln1270">        nRank1 = pRankStack1[0][ib];</a>
<a name="ln1271">        nRank2 = GetMinNewRank(pRankStack1[0], pRankStack1[1], nRank1 );</a>
<a name="ln1272">        /*  if the rank is smaller than pRankStack1[0][ib] then fix at[ib] */</a>
<a name="ln1273">        if ( nRank2 != nRank1 ) {</a>
<a name="ln1274">            pRankStack1[0][ib] = nRank2;</a>
<a name="ln1275">            nNumDiffRanks = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1276">                                         nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1277">                                         pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1278">        }</a>
<a name="ln1279">    }</a>
<a name="ln1280">    </a>
<a name="ln1281">    /**************************************************************************************</a>
<a name="ln1282">     * Note: It may (or may not?) make sense to fix &quot;other neighbors&quot;:</a>
<a name="ln1283">     *       in case of a stereo center fix neighbors other than n1, n2</a>
<a name="ln1284">     *       in case of a double bond/cumulene fix the opposite atom neighbors</a>
<a name="ln1285">     *       The ranks assigned to the other neighbors in case of their equivalence</a>
<a name="ln1286">     *       should be in the ascending order of their canonical ranks ????</a>
<a name="ln1287">     *       *** For now we do not fix other neighbors ***</a>
<a name="ln1288">     **************************************************************************************/</a>
<a name="ln1289"> </a>
<a name="ln1290">    /*  4. Check whether the neighbors still have equal ranks */</a>
<a name="ln1291">    if ( pRankStack1[0][n1] != pRankStack1[0][n2] ) {</a>
<a name="ln1292">        return 0; /*  the two neighbors are not constitutionally equivalent */</a>
<a name="ln1293">    }</a>
<a name="ln1294">    /*  5. Find new smallest possible rank for n1 and n2 */</a>
<a name="ln1295">    nRank1 = pRankStack1[0][n1];</a>
<a name="ln1296">    nRank2 = GetMinNewRank(pRankStack1[0], pRankStack1[1], nRank1 );</a>
<a name="ln1297"> </a>
<a name="ln1298">    /*  6. Copy the results to the 2nd eq. rank arrays */</a>
<a name="ln1299">    memcpy( pRankStack2[0], pRankStack1[0], num_at_tg * sizeof(pRankStack2[0][0]) );</a>
<a name="ln1300">    memcpy( pRankStack2[1], pRankStack1[1], num_at_tg * sizeof(pRankStack2[0][0]) );</a>
<a name="ln1301"> </a>
<a name="ln1302">    /*  7. Break neighbor tie: map n1(1) &lt;--&gt; n2(2) */</a>
<a name="ln1303">    pRankStack1[0][n1] = nRank2;</a>
<a name="ln1304">    nNumDiffRanks1 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1305">                                 nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1306">                                 pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1307">    </a>
<a name="ln1308">    pRankStack2[0][n2] = nRank2;</a>
<a name="ln1309">    nNumDiffRanks2 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1310">                                 nNumDiffRanks, pRankStack2[0], nTempRank,</a>
<a name="ln1311">                                 pRankStack2[1], lNumIter, 1 );</a>
<a name="ln1312"> </a>
<a name="ln1313">    if ( nNumDiffRanks1 != nNumDiffRanks2 ) {</a>
<a name="ln1314">        return -1; /*  &lt;BRKPT&gt; */</a>
<a name="ln1315">    }</a>
<a name="ln1316">    if ( mode == MAP_MODE_C2v || mode == MAP_MODE_C2 ) {</a>
<a name="ln1317">        /* Check for C2v reflection leading to parity inversion (mode=1) or C2 rotation (mode=2) */</a>
<a name="ln1318">        AT_RANK nRank10, nRank20;</a>
<a name="ln1319">        int     nn1, nn2;</a>
<a name="ln1320">        /*</a>
<a name="ln1321">         * C2v &amp; C2: map</a>
<a name="ln1322">         * n1(1) &lt;--&gt; n2(2) -- at this point already done</a>
<a name="ln1323">         * n1(2) &lt;--&gt; n2(1) --&gt; do at i = 0</a>
<a name="ln1324">         *</a>
<a name="ln1325">         * C2v: other neighbors must be unmoved: map</a>
<a name="ln1326">         * other_neigh[0](1) &lt;--&gt; other_neigh[0](2)</a>
<a name="ln1327">         * other_neigh[1](1) &lt;--&gt; other_neigh[1](2)</a>
<a name="ln1328">         *</a>
<a name="ln1329">         * C2:  other neighbors should be mapped on each other</a>
<a name="ln1330">         * other_neigh[0](1) &lt;--&gt; other_neigh[1](2)</a>
<a name="ln1331">         * other_neigh[1](1) &lt;--&gt; other_neigh[0](2)</a>
<a name="ln1332">         */</a>
<a name="ln1333">        for ( i = 0; i &lt;= 2; i ++ ) {</a>
<a name="ln1334">            if ( i == 0 ) {</a>
<a name="ln1335">                /* C2v &amp; C2. Map n2(1) &lt;--&gt; n1(2) */</a>
<a name="ln1336">                nn1     = n2;</a>
<a name="ln1337">                nn2     = n1;</a>
<a name="ln1338">            } else</a>
<a name="ln1339">            if ( mode == MAP_MODE_C2v ) {   /* was '=', pointed by WDI */</a>
<a name="ln1340">                /* i = 1 or 2</a>
<a name="ln1341">                 * C2v. Other neighbors must be unmoved: map</a>
<a name="ln1342">                 * i=1: other_neigh[0](1) &lt;--&gt; other_neigh[0](2)</a>
<a name="ln1343">                 * i=2: other_neigh[1](1) &lt;--&gt; other_neigh[1](2)</a>
<a name="ln1344">                 */</a>
<a name="ln1345">                nn1 = other_neigh[i-1]; /* 0 or 1 */</a>
<a name="ln1346">                nn2 = other_neigh[i-1]; /* 0 or 1 */</a>
<a name="ln1347">            } else</a>
<a name="ln1348">            if ( mode == MAP_MODE_C2 ) {  /* was '=', pointed by WDI */</a>
<a name="ln1349">                /* i = 1 or 2</a>
<a name="ln1350">                 * C2.  Other neighbors should be mapped on each other</a>
<a name="ln1351">                 * i=1: other_neigh[0](1) &lt;--&gt; other_neigh[1](2)</a>
<a name="ln1352">                 * i=2: other_neigh[1](1) &lt;--&gt; other_neigh[0](2)</a>
<a name="ln1353">                 */</a>
<a name="ln1354">                nn1 = other_neigh[i-1]; /* 0 or 1 */</a>
<a name="ln1355">                nn2 = other_neigh[2-i]; /* 1 or 0 */</a>
<a name="ln1356">            } else {</a>
<a name="ln1357">                return -1; /* program error */</a>
<a name="ln1358">            }</a>
<a name="ln1359">            /* map nn1(1) &lt;--&gt; nn2(2) */</a>
<a name="ln1360">            nRank10 = pRankStack1[0][nn1];</a>
<a name="ln1361">            nRank20 = pRankStack2[0][nn2];</a>
<a name="ln1362">            nRank1 = GetMinNewRank(pRankStack1[0], pRankStack1[1], nRank10 );</a>
<a name="ln1363">            nRank2 = GetMinNewRank(pRankStack2[0], pRankStack2[1], nRank20 );</a>
<a name="ln1364">            if ( nRank10 == nRank20 &amp;&amp; nRank1 == nRank2 ) {</a>
<a name="ln1365">                if ( nRank10 == nRank1 ) {</a>
<a name="ln1366">                    ;/* atoms are already mapped */</a>
<a name="ln1367">                } else {</a>
<a name="ln1368">                    /* need additional mapping: ranks are not fixed yet */</a>
<a name="ln1369">                    pRankStack1[0][nn1] = nRank1;</a>
<a name="ln1370">                    nNumDiffRanks1 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1371">                                                 nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1372">                                                 pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1373">                    pRankStack2[0][nn2] = nRank2;</a>
<a name="ln1374">                    nNumDiffRanks2 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1375">                                                 nNumDiffRanks, pRankStack2[0], nTempRank,</a>
<a name="ln1376">                                                 pRankStack2[1], lNumIter, 1 );</a>
<a name="ln1377">                    if ( nNumDiffRanks1 != nNumDiffRanks2 ) {</a>
<a name="ln1378">                        return -1; /*  &lt;BRKPT&gt; */</a>
<a name="ln1379">                    }</a>
<a name="ln1380">                }</a>
<a name="ln1381">            } else {</a>
<a name="ln1382">                return 0;  /* mapping is not possible */</a>
<a name="ln1383">            }</a>
<a name="ln1384">        }</a>
<a name="ln1385">    }</a>
<a name="ln1386">    if ( mode == MAP_MODE_S4 ) {</a>
<a name="ln1387">        /* </a>
<a name="ln1388">         *  Check for S4 reflection/rotation leading to parity inversion (mode=3)</a>
<a name="ln1389">         *</a>
<a name="ln1390">         * At this point n1(1) &lt;--&gt; n2(2) have been mapped and n1 has index in1 = 0</a>
<a name="ln1391">         * Below indexes in neigh_num[] are in brackets; [i] means neigh_num[i].</a>
<a name="ln1392">         * Numbers (#) in parentheses refer to pRankStack#</a>
<a name="ln1393">         *</a>
<a name="ln1394">         * in2=1: [0](1) &lt;--&gt; [1](2)  mapping has been done; add more mappings:</a>
<a name="ln1395">         *        [1](1) &lt;--&gt; [2](2)  [x]=[2]</a>
<a name="ln1396">         *        [2](1) &lt;--&gt; [3](2)  [y]=[3]</a>
<a name="ln1397">         *        [3](1) &lt;--&gt; [0](2)</a>
<a name="ln1398">         *        this will succeed if C2 axis crosses middle of [0]-[2] and [1]-[3] lines </a>
<a name="ln1399">         *</a>
<a name="ln1400">         * in2=2: [0](1) &lt;--&gt; [2](2) mapping has been done; add more mappings:</a>
<a name="ln1401">         *        [2](1) &lt;--&gt; [3](2)  [x]=[3]</a>
<a name="ln1402">         *        [3](1) &lt;--&gt; [1](2)  [y]=[1]</a>
<a name="ln1403">         *        [1](1) &lt;--&gt; [0](2)</a>
<a name="ln1404">         *        this will succeed if C2 axis crosses middle of [0]-[3] and [1]-[2] lines</a>
<a name="ln1405">         *</a>
<a name="ln1406">         * in2=3: [0](1) &lt;--&gt; [3](2) mapping has been done; add more mappings:</a>
<a name="ln1407">         *        [3](1) &lt;--&gt; [1](2)  [x]=[1]</a>
<a name="ln1408">         *        [1](1) &lt;--&gt; [2](2)  [y]=[2]</a>
<a name="ln1409">         *        [2](1) &lt;--&gt; [0](2)</a>
<a name="ln1410">         *        this will succeed if C2 axis crosses middle of [0]-[1] and [2]-[3] lines</a>
<a name="ln1411">         *</a>
<a name="ln1412">         * In general:</a>
<a name="ln1413">         *        [in1](1) &lt;--&gt; [in2](2)</a>
<a name="ln1414">         *        [in2](1) &lt;--&gt; [x]  (2)  i=0</a>
<a name="ln1415">         *        [x]  (1) &lt;--&gt; [y]  (2)  i=1</a>
<a name="ln1416">         *        [y]  (1) &lt;--&gt; [in1](2)  i=2</a>
<a name="ln1417">         *</a>
<a name="ln1418">         *    in1=0    always</a>
<a name="ln1419">         *    ===== how to find x, y from in2 ====</a>
<a name="ln1420">         *    in2=1 =&gt; x,y = 2, 3  or [x] = other_neigh[0], [y] = other_neigh[1] </a>
<a name="ln1421">         *    in2=2 =&gt; x,y = 3, 1  or [x] = other_neigh[1], [y] = other_neigh[0]</a>
<a name="ln1422">         *    in2=3 =&gt; x,y = 1, 2  or [x] = other_neigh[0], [y] = other_neigh[1]</a>
<a name="ln1423">         *    ====================================</a>
<a name="ln1424">         */</a>
<a name="ln1425">        AT_RANK nRank10, nRank20;</a>
<a name="ln1426">        int     nn1, nn2;</a>
<a name="ln1427">        for ( i = 0; i &lt;= 2; i ++ ) {</a>
<a name="ln1428">            switch( i ) {</a>
<a name="ln1429">            case 0:  /* [in2](1) &lt;--&gt; [x](2);  */</a>
<a name="ln1430">                nn1 = n2;                    /* [in2] */</a>
<a name="ln1431">                nn2 = other_neigh[1-in2%2];  /* [x]   */</a>
<a name="ln1432">                break;</a>
<a name="ln1433">            case 1:  /* [x](1) &lt;--&gt; [y](2) */</a>
<a name="ln1434">                nn1 = other_neigh[1-in2%2];  /* [x]   */</a>
<a name="ln1435">                nn2 = other_neigh[  in2%2];  /* [y]   */</a>
<a name="ln1436">                break;</a>
<a name="ln1437">            case 2:</a>
<a name="ln1438">                nn1 = other_neigh[  in2%2];  /* [y]   */</a>
<a name="ln1439">                nn2 = n1;                    /* [in1] */</a>
<a name="ln1440">                break;</a>
<a name="ln1441">            default:</a>
<a name="ln1442">                return -1; /* program error */</a>
<a name="ln1443">            }</a>
<a name="ln1444">            /* map nn1(1) &lt;--&gt; nn2(2) */</a>
<a name="ln1445">            nRank10 = pRankStack1[0][nn1];</a>
<a name="ln1446">            nRank20 = pRankStack2[0][nn2];</a>
<a name="ln1447">            nRank1 = GetMinNewRank(pRankStack1[0], pRankStack1[1], nRank10 );</a>
<a name="ln1448">            nRank2 = GetMinNewRank(pRankStack2[0], pRankStack2[1], nRank20 );</a>
<a name="ln1449">            if ( nRank10 == nRank20 &amp;&amp; nRank1 == nRank2 ) {</a>
<a name="ln1450">                if ( nRank10 == nRank1 ) {</a>
<a name="ln1451">                    ;/* atoms are already mapped */</a>
<a name="ln1452">                } else {</a>
<a name="ln1453">                    /* need additional mapping: ranks are not fixed yet */</a>
<a name="ln1454">                    pRankStack1[0][nn1] = nRank1;</a>
<a name="ln1455">                    nNumDiffRanks1 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1456">                                                 nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1457">                                                 pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1458">                    pRankStack2[0][nn2] = nRank2;</a>
<a name="ln1459">                    nNumDiffRanks2 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1460">                                                 nNumDiffRanks, pRankStack2[0], nTempRank,</a>
<a name="ln1461">                                                 pRankStack2[1], lNumIter, 1 );</a>
<a name="ln1462">                    if ( nNumDiffRanks1 != nNumDiffRanks2 ) {</a>
<a name="ln1463">                        return -1; /*  &lt;BRKPT&gt; */</a>
<a name="ln1464">                    }</a>
<a name="ln1465">                }</a>
<a name="ln1466">            } else {</a>
<a name="ln1467">                return 0;  /* mapping is not possible */</a>
<a name="ln1468">            }</a>
<a name="ln1469">        }</a>
<a name="ln1470">    }</a>
<a name="ln1471"> </a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">#if ( BREAK_ONE_MORE_SC_TIE == 1 ) /* { */</a>
<a name="ln1475">    /* Check for a very highly symmetrical stereo center 12-06-2002 */</a>
<a name="ln1476">    if ( ib &gt;= num_atoms &amp;&amp; at[ia].valence == MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln1477">        int num_eq;</a>
<a name="ln1478">        nRank1 = pRankStack1[0][n2];</a>
<a name="ln1479">        for ( i = 0, num_eq = 0; i &lt; at[ia].valence; i ++ ) {</a>
<a name="ln1480">            num_eq += ( nRank1 == pRankStack1[0][at[ia].neighbor[i]]);</a>
<a name="ln1481">        }</a>
<a name="ln1482">        if ( num_eq == MAX_NUM_STEREO_ATOM_NEIGH-1 ) {</a>
<a name="ln1483">            for ( i = (int)nRank1-1; 0 &lt;= i &amp;&amp; nRank1 == (nRank2 = pRankStack1[0][(int)pRankStack1[1][i]]); i -- )</a>
<a name="ln1484">                ;</a>
<a name="ln1485">            if ( i &gt;= 0 )</a>
<a name="ln1486">                nRank2 ++;</a>
<a name="ln1487">            else</a>
<a name="ln1488">                nRank2 = 1;</a>
<a name="ln1489"> </a>
<a name="ln1490">            /*  7a. Break another neighbor tie */</a>
<a name="ln1491"> </a>
<a name="ln1492">            nNumDiffRanks = nNumDiffRanks1;</a>
<a name="ln1493"> </a>
<a name="ln1494">            pRankStack1[0][n2] = nRank2;</a>
<a name="ln1495">            nNumDiffRanks1 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1496">                                         nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1497">                                         pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1498">    </a>
<a name="ln1499">            pRankStack2[0][n1] = nRank2;</a>
<a name="ln1500">            nNumDiffRanks2 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1501">                                         nNumDiffRanks, pRankStack2[0], nTempRank,</a>
<a name="ln1502">                                         pRankStack2[1], lNumIter, 1 );</a>
<a name="ln1503">        }</a>
<a name="ln1504">    }</a>
<a name="ln1505"> </a>
<a name="ln1506">    if ( nNumDiffRanks1 != nNumDiffRanks2 ) {</a>
<a name="ln1507">        return -1; /*  &lt;BRKPT&gt; */</a>
<a name="ln1508">    }</a>
<a name="ln1509">#endif /* } BREAK_ONE_MORE_SC_TIE */</a>
<a name="ln1510"> </a>
<a name="ln1511">#if ( BREAK_ALSO_NEIGH_TIE == 1 )</a>
<a name="ln1512">    /* check whether neighbor's neighbors are tied and untie them */</a>
<a name="ln1513">    if ( at[n1].nRingSystem == at[n2].nRingSystem &amp;&amp;  ib &gt;= num_atoms ) {</a>
<a name="ln1514">        AT_RANK NeighNeighList[MAX_NUM_STEREO_ATOM_NEIGH+1];</a>
<a name="ln1515">        int m, neigh1=-1, neigh2=-1;</a>
<a name="ln1516">        nRank1 = nRank2 = 0;</a>
<a name="ln1517">        /* n1 */</a>
<a name="ln1518">        NeighNeighList[0] = at[n1].valence-1; /* for insertions_sort_NeighListBySymmAndCanonRank() */</a>
<a name="ln1519">        for ( i = 0, m = 1; i &lt; at[n1].valence; i ++ ) {</a>
<a name="ln1520">            int neigh = at[n1].neighbor[i];</a>
<a name="ln1521">            if ( neigh != ia ) {</a>
<a name="ln1522">                NeighNeighList[m ++] = neigh;</a>
<a name="ln1523">            }</a>
<a name="ln1524">        }</a>
<a name="ln1525">        insertions_sort_NeighListBySymmAndCanonRank( NeighNeighList, pRankStack1[0], nCanonRank );</a>
<a name="ln1526">        for ( m = 2; m &lt; at[n1].valence; m ++ ) {</a>
<a name="ln1527">            if ( pRankStack1[0][NeighNeighList[m]] == pRankStack1[0][NeighNeighList[m-1]] ) {</a>
<a name="ln1528">                neigh1 = NeighNeighList[m-1];</a>
<a name="ln1529">                break;</a>
<a name="ln1530">            }</a>
<a name="ln1531">        }</a>
<a name="ln1532">        /* n2 */</a>
<a name="ln1533">        NeighNeighList[0] = at[n2].valence-1; /* for insertions_sort_NeighListBySymmAndCanonRank() */</a>
<a name="ln1534">        for ( i = 0, m = 1; i &lt; at[n2].valence; i ++ ) {</a>
<a name="ln1535">            int neigh = at[n2].neighbor[i];</a>
<a name="ln1536">            if ( neigh != ia ) {</a>
<a name="ln1537">                NeighNeighList[m ++] = neigh;</a>
<a name="ln1538">            }</a>
<a name="ln1539">        }</a>
<a name="ln1540">        insertions_sort_NeighListBySymmAndCanonRank( NeighNeighList, pRankStack2[0], nCanonRank );</a>
<a name="ln1541">        for ( m = 2; m &lt; at[n2].valence; m ++ ) {</a>
<a name="ln1542">            if ( pRankStack2[0][NeighNeighList[m]] == pRankStack2[0][NeighNeighList[m-1]] ) {</a>
<a name="ln1543">#if ( BREAK_ALSO_NEIGH_TIE_ROTATE == 1 )</a>
<a name="ln1544">                neigh2 = NeighNeighList[m];    /* [m] to obtain same axis orientation  around ia&lt;neigh */</a>
<a name="ln1545">#else</a>
<a name="ln1546">                neigh2 = NeighNeighList[m-1];  /* [m-1] to obtain reflection ??? */</a>
<a name="ln1547">#endif</a>
<a name="ln1548">                break;</a>
<a name="ln1549">            }</a>
<a name="ln1550">        }</a>
<a name="ln1551">        if ( neigh1 &gt;= 0 &amp;&amp; neigh2 &gt;= 0 &amp;&amp; pRankStack1[0][neigh1] == pRankStack2[0][neigh2] ) {</a>
<a name="ln1552">            /* neighbors' neighbors are tied */</a>
<a name="ln1553">            nRank1 = pRankStack1[0][neigh1];</a>
<a name="ln1554">            nRank2 = GetMinNewRank(pRankStack1[0], pRankStack1[1], nRank1 );</a>
<a name="ln1555"> </a>
<a name="ln1556">            /*  Break neighbor's neighbor tie */</a>
<a name="ln1557"> </a>
<a name="ln1558">            nNumDiffRanks = nNumDiffRanks1;</a>
<a name="ln1559"> </a>
<a name="ln1560">            pRankStack1[0][neigh1] = nRank2;</a>
<a name="ln1561">            nNumDiffRanks1 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1562">                                         nNumDiffRanks, pRankStack1[0], nTempRank,</a>
<a name="ln1563">                                         pRankStack1[1], lNumIter, 1 );</a>
<a name="ln1564"> </a>
<a name="ln1565">            pRankStack2[0][neigh2] = nRank2;</a>
<a name="ln1566">            nNumDiffRanks2 = DifferentiateRanksBasic( num_at_tg, NeighList,</a>
<a name="ln1567">                                         nNumDiffRanks, pRankStack2[0], nTempRank,</a>
<a name="ln1568">                                         pRankStack2[1], lNumIter, 1 );</a>
<a name="ln1569">        }</a>
<a name="ln1570">    }</a>
<a name="ln1571">#endif</a>
<a name="ln1572"> </a>
<a name="ln1573"> </a>
<a name="ln1574">    /*  for debug only */</a>
<a name="ln1575">    for ( i = 0; i &lt; num_at_tg; i ++ ) {</a>
<a name="ln1576">        if ( pRankStack1[0][(int)pRankStack1[1][i]] != pRankStack2[0][(int)pRankStack2[1][i]] ) {</a>
<a name="ln1577">            return -1;  /*  &lt;BRKPT&gt; */</a>
<a name="ln1578">        }</a>
<a name="ln1579">    }</a>
<a name="ln1580">    /*  Resort lists of  neighbors */</a>
<a name="ln1581">    SortNeighListsBySymmAndCanonRank( num_atoms, nl1,  pRankStack1[0], nCanonRank );</a>
<a name="ln1582">    SortNeighListsBySymmAndCanonRank( num_atoms, nl2,  pRankStack2[0], nCanonRank );</a>
<a name="ln1583"> </a>
<a name="ln1584">    return nNumDiffRanks1+1;</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">/**************************************************************************************/</a>
<a name="ln1588">int CheckNextSymmNeighborsAndBonds( sp_ATOM *at, AT_RANK cur1, AT_RANK cur2, AT_RANK n1, AT_RANK n2,</a>
<a name="ln1589">                                    AT_RANK *nAvoidCheckAtom, AT_RANK *nVisited1, AT_RANK *nVisited2,</a>
<a name="ln1590">                                    AT_RANK *nVisitOrd1, AT_RANK *nVisitOrd2, const AT_RANK *nRank1, const AT_RANK *nRank2 )</a>
<a name="ln1591">{</a>
<a name="ln1592">    AT_RANK s1, s2;</a>
<a name="ln1593">    int     i1, i2, k1, k2;</a>
<a name="ln1594">    if ( nRank1[n1] != nRank2[n2] ) {</a>
<a name="ln1595">        return -1; /*  parallel traversal in stereo removal failed */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1596">    }</a>
<a name="ln1597">    switch ( !nVisited1[n1] + !nVisited2[n2] ) {</a>
<a name="ln1598">    case 0:</a>
<a name="ln1599">        if ( nVisited1[n1] != n2+1 || nVisited2[n2] != n1+1 ) {</a>
<a name="ln1600">            return -1; /*  0; */ /*  possibly error???: we have come to an alreardy traversed pair and */</a>
<a name="ln1601">                       /*  found that the pair previously has not been traversed synchroneously. */</a>
<a name="ln1602">        }              /*  -- Happens in C60. */</a>
<a name="ln1603">        break;</a>
<a name="ln1604">    case 1:</a>
<a name="ln1605">        return -1; /*  0; */ /*  possibly error: one is zero, another is not a zero. Happens in C60 */</a>
<a name="ln1606"> </a>
<a name="ln1607">    /*  case 2: */</a>
<a name="ln1608">        /* both are zero, OK. */</a>
<a name="ln1609">    }</a>
<a name="ln1610">    </a>
<a name="ln1611">    if ( nVisitOrd1[n1] != nVisitOrd2[n2] ) {</a>
<a name="ln1612">        return -1; /*  0; */ /*  different DFS trees */</a>
<a name="ln1613">    }</a>
<a name="ln1614">    /*  at[n1] and at[n2] are next to at[cur1] and at[cur2] respectively */</a>
<a name="ln1615">    /*  Even though the bond might have already been checked, check whether */</a>
<a name="ln1616">    /*  it is a stereo bond/cumulene. If it is, check the bond/cumulene parity. */</a>
<a name="ln1617"> </a>
<a name="ln1618">    /*  Even though the bond or cumulene might have already been checked, check it: this is */</a>
<a name="ln1619">    /*  the only place we can check stereo bonds and cumulenes that are not edges of the DFS tree */</a>
<a name="ln1620">    /*  The code works both for a stereo bond and a stereogenic cumulene. */</a>
<a name="ln1621"> </a>
<a name="ln1622">    for ( i1 = 0, k1 = 0; i1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp;</a>
<a name="ln1623">                          (s1=at[cur1].stereo_bond_neighbor[i1]) &amp;&amp;</a>
<a name="ln1624">                         !(k1=(at[cur1].neighbor[(int)at[cur1].stereo_bond_ord[i1]] == n1)); i1 ++ )</a>
<a name="ln1625">        ;</a>
<a name="ln1626">    for ( i2 = 0, k2 = 0; i2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp;</a>
<a name="ln1627">                          (s2=at[cur2].stereo_bond_neighbor[i2]) &amp;&amp;</a>
<a name="ln1628">                         !(k2=(at[cur2].neighbor[(int)at[cur2].stereo_bond_ord[i2]] == n2)); i2 ++ )</a>
<a name="ln1629">        ;</a>
<a name="ln1630"> </a>
<a name="ln1631">    /* -- this does not work in case of cumulenes --</a>
<a name="ln1632">    for ( i1 = 0, k1 = 0; i1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; (s1=at[cur1].stereo_bond_neighbor[i1]) &amp;&amp; !(k1=(s1-1 == n1)); i1 ++ )</a>
<a name="ln1633">        ;</a>
<a name="ln1634">    for ( i2 = 0, k2 = 0; i2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; (s2=at[cur2].stereo_bond_neighbor[i2]) &amp;&amp; !(k2=(s2-1 == n2)); i2 ++ )</a>
<a name="ln1635">        ;</a>
<a name="ln1636">    */</a>
<a name="ln1637"> </a>
<a name="ln1638">    if ( k1 != k2 ) {    </a>
<a name="ln1639">        return 0; /*  not an error: a stereo bond and not a stereo bond */</a>
<a name="ln1640">    }</a>
<a name="ln1641">    if ( k1 ) {</a>
<a name="ln1642">        /* here k1 == k2 */</a>
<a name="ln1643">        int bCheckBond1, bCheckBond2;</a>
<a name="ln1644">        s1 --;</a>
<a name="ln1645">        s2 --;</a>
<a name="ln1646"> </a>
<a name="ln1647">        bCheckBond1 = (cur1 != nAvoidCheckAtom[0] || s1 != nAvoidCheckAtom[1]) &amp;&amp;</a>
<a name="ln1648">                      (cur1 != nAvoidCheckAtom[1] || s1 != nAvoidCheckAtom[0]);</a>
<a name="ln1649">        bCheckBond2 = (cur2 != nAvoidCheckAtom[0] || s2 != nAvoidCheckAtom[1]) &amp;&amp;</a>
<a name="ln1650">                      (cur2 != nAvoidCheckAtom[1] || s2 != nAvoidCheckAtom[0]);</a>
<a name="ln1651">        </a>
<a name="ln1652">        if ( bCheckBond1 != bCheckBond2 )</a>
<a name="ln1653">            return 0;</a>
<a name="ln1654">        </a>
<a name="ln1655">        if ( !bCheckBond1 &amp;&amp; !bCheckBond2 ) {</a>
<a name="ln1656">            return 1; /*  do not go any further in this direction */</a>
<a name="ln1657">        }</a>
<a name="ln1658"> </a>
<a name="ln1659">        if ( at[cur1].stereo_bond_parity[i1] != at[cur2].stereo_bond_parity[i2] ) {</a>
<a name="ln1660">            /*  different values of  at[].stereo_bond_parity: definitely different bonds */</a>
<a name="ln1661">            /*  known parities */</a>
<a name="ln1662">            if ( PARITY_KNOWN(at[cur1].stereo_bond_parity[i1] ) &amp;&amp;</a>
<a name="ln1663">                 PARITY_KNOWN(at[cur2].stereo_bond_parity[i2] )  ) {</a>
<a name="ln1664">                return 0; /*  different currently known stereo bond parities */</a>
<a name="ln1665">            }</a>
<a name="ln1666">#if ( PROPAGATE_ILL_DEF_STEREO != 1 )</a>
<a name="ln1667">            /*  well defined and to be calculated from the ranks */</a>
<a name="ln1668">            if ( !(PARITY_CALCULATE(at[cur1].stereo_bond_parity[i1]) &amp;&amp; PARITY_WELL_DEF (at[cur2].stereo_bond_parity[i2]) ||</a>
<a name="ln1669">                   PARITY_WELL_DEF (at[cur1].stereo_bond_parity[i1]) &amp;&amp; PARITY_CALCULATE(at[cur2].stereo_bond_parity[i2]) ||</a>
<a name="ln1670">                   PARITY_CALCULATE(at[cur1].stereo_bond_parity[i1]) &amp;&amp; PARITY_CALCULATE(at[cur2].stereo_bond_parity[i2]) ) ) {</a>
<a name="ln1671">                /*  do not reject if: &quot;well defined&quot; and &quot;calculate&quot; or &quot;calculate&quot; and &quot;calculate&quot; */</a>
<a name="ln1672">                return 0; </a>
<a name="ln1673">            }</a>
<a name="ln1674">#endif</a>
<a name="ln1675">        }</a>
<a name="ln1676">   </a>
<a name="ln1677">#if ( PROPAGATE_ILL_DEF_STEREO != 1 )</a>
<a name="ln1678">        if ( (cur1 != cur2 || s1 != s2) &amp;&amp; (cur1 != s2 || cur2 != s1) ) {</a>
<a name="ln1679">            /*  two different stereo bonds */</a>
<a name="ln1680">            if ( PARITY_ILL_DEF( at[cur1].stereo_bond_parity[i1] ) ||</a>
<a name="ln1681">                 PARITY_ILL_DEF( at[cur2].stereo_bond_parity[i2] ) ) {</a>
<a name="ln1682">                return 0;</a>
<a name="ln1683">            }</a>
<a name="ln1684">        }</a>
<a name="ln1685">#endif</a>
<a name="ln1686">    }</a>
<a name="ln1687">    return 1; /*  stereo bonds to n1 and n2 have same known parities or are not stereo bonds */</a>
<a name="ln1688">}</a>
<a name="ln1689">/**************************************************************************************/</a>
<a name="ln1690">int CreateCheckSymmPaths( sp_ATOM *at, AT_RANK prev1, AT_RANK cur1, AT_RANK prev2, AT_RANK cur2,</a>
<a name="ln1691">                         AT_RANK *nAvoidCheckAtom, AT_RANK *nVisited1, AT_RANK *nVisited2,</a>
<a name="ln1692">                         AT_RANK *nVisitOrd1, AT_RANK *nVisitOrd2,</a>
<a name="ln1693">                         NEIGH_LIST *nl1, NEIGH_LIST *nl2, const AT_RANK *nRank1, const AT_RANK *nRank2,</a>
<a name="ln1694">                         AT_RANK *nCanonRank, AT_RANK *nLength, int *bParitiesInverted, int mode  )</a>
<a name="ln1695">{</a>
<a name="ln1696">    int k, k1, k2, ret=0, bParitiesInvertedZero=0, *pbParitiesInverted;</a>
<a name="ln1697">    AT_RANK n1, n2;</a>
<a name="ln1698"> </a>
<a name="ln1699">    nVisited1[cur1] = cur2+1;  /*  symmetrically exchange atom numbers */</a>
<a name="ln1700">    nVisited2[cur2] = cur1+1;</a>
<a name="ln1701"> </a>
<a name="ln1702">    (*nLength) ++;</a>
<a name="ln1703"> </a>
<a name="ln1704">    nVisitOrd1[cur1] = *nLength; /*  save DFS visit order */</a>
<a name="ln1705">    nVisitOrd2[cur2] = *nLength;</a>
<a name="ln1706"> </a>
<a name="ln1707">    /* new version allows all inverted parities */</a>
<a name="ln1708">    if ( PARITY_WELL_DEF(at[cur1].stereo_atom_parity) &amp;&amp;</a>
<a name="ln1709">         PARITY_WELL_DEF(at[cur2].stereo_atom_parity) ) {</a>
<a name="ln1710">        if ( *bParitiesInverted &lt; 0 ) {</a>
<a name="ln1711">            *bParitiesInverted = (at[cur1].stereo_atom_parity + at[cur2].stereo_atom_parity) % 2;</a>
<a name="ln1712">        } else</a>
<a name="ln1713">        if ( *bParitiesInverted != (at[cur1].stereo_atom_parity + at[cur2].stereo_atom_parity) % 2 ) {</a>
<a name="ln1714">            return 0; /*  Different known in advance parities have wrong &quot;inverted&quot; relation */</a>
<a name="ln1715">        }</a>
<a name="ln1716">    } else</a>
<a name="ln1717">    if ( PARITY_KNOWN(at[cur1].stereo_atom_parity) &amp;&amp;</a>
<a name="ln1718">         PARITY_KNOWN(at[cur2].stereo_atom_parity) &amp;&amp;</a>
<a name="ln1719">         at[cur1].stereo_atom_parity != at[cur2].stereo_atom_parity ) {</a>
<a name="ln1720">        return 0;  /*  Different known in advance parities */</a>
<a name="ln1721">    }</a>
<a name="ln1722"> </a>
<a name="ln1723">    if ( cur1 != cur2 &amp;&amp;</a>
<a name="ln1724">         !at[cur1].stereo_bond_neighbor[0] &amp;&amp; !at[cur2].stereo_bond_neighbor[0] &amp;&amp;</a>
<a name="ln1725">         PARITY_KNOWN(at[cur1].parity) != PARITY_KNOWN(at[cur2].parity) ) {</a>
<a name="ln1726">        return 0; /*  one atom is stereogenic, another (presumably equivalent) is not. 9-11-2002 */</a>
<a name="ln1727">    }</a>
<a name="ln1728">#if ( PROPAGATE_ILL_DEF_STEREO != 1 )</a>
<a name="ln1729">    if ( cur1 != cur2 &amp;&amp;</a>
<a name="ln1730">         (PARITY_ILL_DEF(at[cur1].stereo_atom_parity) ||</a>
<a name="ln1731">          PARITY_ILL_DEF(at[cur2].stereo_atom_parity)) </a>
<a name="ln1732">       ) {</a>
<a name="ln1733">        return 0;  /*  Cannot detect whether the paths are same or different */</a>
<a name="ln1734">    }</a>
<a name="ln1735">#endif</a>
<a name="ln1736"> </a>
<a name="ln1737">    if ( at[cur1].valence != at[cur2].valence ) {</a>
<a name="ln1738">        return CT_REMOVE_STEREO_ERR; /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1739">    }</a>
<a name="ln1740">    if ( at[cur1].valence == 1 ) {</a>
<a name="ln1741">        return 1; /*  so far success */</a>
<a name="ln1742">    }</a>
<a name="ln1743">    </a>
<a name="ln1744">    if ( nl1[(int)cur1][0] != nl2[(int)cur2][0] || nl1[(int)cur1][0] != at[cur1].valence ) {</a>
<a name="ln1745">        return CT_REMOVE_STEREO_ERR; /*  error: different valences */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1746">    }</a>
<a name="ln1747"> </a>
<a name="ln1748"> </a>
<a name="ln1749">    for ( k = 1, k1 = 1, k2 = 1; k &lt; at[cur1].valence; k ++, k1 ++, k2 ++ ) {</a>
<a name="ln1750">        if ( (n1 = nl1[(int)cur1][k1]) == prev1 ) {</a>
<a name="ln1751">            n1 = nl1[(int)cur1][++k1]; /*  don't go back */</a>
<a name="ln1752">        }</a>
<a name="ln1753">        if ( (n2 = nl2[(int)cur2][k2]) == prev2 ) {</a>
<a name="ln1754">            n2 = nl2[(int)cur2][++k2]; /*  don't go back */</a>
<a name="ln1755">        }</a>
<a name="ln1756">        </a>
<a name="ln1757">        if ( 0 &gt;= (ret = CheckNextSymmNeighborsAndBonds( at, cur1, cur2, n1, n2, nAvoidCheckAtom,</a>
<a name="ln1758">                                              nVisited1, nVisited2, nVisitOrd1, nVisitOrd2, nRank1, nRank2 ) ) ) {</a>
<a name="ln1759">            return ret; /*  different neighbors or bonds                       */</a>
<a name="ln1760">        }</a>
<a name="ln1761"> </a>
<a name="ln1762">        if ( !nVisited1[n1] ) { /*  recursion */</a>
<a name="ln1763">            /* allow all inverted parities only inside a single ring system containing the starting point */</a>
<a name="ln1764">            pbParitiesInverted = (at[cur1].nRingSystem == at[n1].nRingSystem)? bParitiesInverted:&amp;bParitiesInvertedZero;</a>
<a name="ln1765">            if ( 0 &gt;= (ret = CreateCheckSymmPaths( at, cur1, n1, cur2, n2, nAvoidCheckAtom,</a>
<a name="ln1766">                                         nVisited1, nVisited2, nVisitOrd1, nVisitOrd2,</a>
<a name="ln1767">                                         nl1, nl2, nRank1, nRank2, nCanonRank, nLength, pbParitiesInverted, mode ) ) ) {</a>
<a name="ln1768">                return ret;</a>
<a name="ln1769">            }</a>
<a name="ln1770">        }</a>
<a name="ln1771">    }</a>
<a name="ln1772">    return 1; /*  Success */</a>
<a name="ln1773"> </a>
<a name="ln1774">}</a>
<a name="ln1775">/**************************************************************************************/</a>
<a name="ln1776">/*  Compare parities */</a>
<a name="ln1777">#define MAX_OTHER_NEIGH        2</a>
<a name="ln1778">/*  nNeighMode */</a>
<a name="ln1779">#define NEIGH_MODE_RING        1</a>
<a name="ln1780">#define NEIGH_MODE_CHAIN       2</a>
<a name="ln1781"> </a>
<a name="ln1782">#define CHECKING_STEREOCENTER  1</a>
<a name="ln1783">#define CHECKING_STEREOBOND    2</a>
<a name="ln1784"> </a>
<a name="ln1785">#define COMP_STEREO_SUCCESS    1</a>
<a name="ln1786">#define NOT_WELL_DEF_UNKN      2</a>
<a name="ln1787">#define NOT_WELL_DEF_UNDF      4</a>
<a name="ln1788"> </a>
<a name="ln1789">#define PARITY_IMPOSSIBLE    999</a>
<a name="ln1790">/**************************************************************************************</a>
<a name="ln1791">  Note:    the following C2v/S4 stereo center symmetry recognition</a>
<a name="ln1792">           is not included in the final InChI version released in April 2005</a>
<a name="ln1793">           It is disabled in the mode.h (CHECK_C2v_S4_SYMM = 0)</a>
<a name="ln1794">           As the result, the only central atom in S4 or atoms on C2v axis</a>
<a name="ln1795">           may have pasrity (-) even though these atoms are not stereogenic.</a>
<a name="ln1796"> </a>
<a name="ln1797">  Reason:  Not finished/tested yet</a>
<a name="ln1798"> **************************************************************************************</a>
<a name="ln1799"> </a>
<a name="ln1800">  In case of stereocenter with 2 pairs of constitutionally identical neighbors :</a>
<a name="ln1801">  </a>
<a name="ln1802">  G(n) &gt; H(m) means group G has n elements; group H has m elements and</a>
<a name="ln1803">                                            group H is a subgroup of G</a>
<a name="ln1804"> </a>
<a name="ln1805">  Td(24) &gt; D2d(8&gt; &gt; D2(4)</a>
<a name="ln1806">                  &gt; S4(4)  &gt; C2(2) -- Test for S4</a>
<a name="ln1807">                  &gt; C2v(4) &gt; C2(2) -- Test for C2v</a>
<a name="ln1808">                           &gt; Cs(2)</a>
<a name="ln1809">                  </a>
<a name="ln1810">  Td(24) &gt; C3v(6) &gt; C3(3) -- does not have 2 pairs of constitutionally identical neighbors</a>
<a name="ln1811">                  &gt; Cs(2)</a>
<a name="ln1812"> </a>
<a name="ln1813">  The pair of atoms to check for the existence of a steregenic atom: X, Y</a>
<a name="ln1814"> </a>
<a name="ln1815">       X   Y</a>
<a name="ln1816">        \ /</a>
<a name="ln1817">         C</a>
<a name="ln1818">        / \</a>
<a name="ln1819">       A   B</a>
<a name="ln1820"> </a>
<a name="ln1821">  Conditions to check:</a>
<a name="ln1822"> </a>
<a name="ln1823">  (a) Old #0: Map canonical numbers X1 &lt;--&gt; Y2</a>
<a name="ln1824">      Traverse DFS from X and Y</a>
<a name="ln1825">      If all parities vs. canon. numbers unchanged except that of C</a>
<a name="ln1826">      then C is not stereogenic</a>
<a name="ln1827"> </a>
<a name="ln1828">  (b) C2v  #1: discover ACB symmetry plain Cv</a>
<a name="ln1829">      o Map canonical numbers X1 &lt;--&gt; Y2, Fix(Ai), Fix(Bi)</a>
<a name="ln1830">      o Make sure that after mapping X1 &lt;--&gt; Y2 the atoms Ai and</a>
<a name="ln1831">        Bi still have equal mapping ranks</a>
<a name="ln1832">      Traverse DFS from X and Y</a>
<a name="ln1833">      In this case canonical numbers will be reflected in plane ACB if it exists.</a>
<a name="ln1834">      o Criterion of the presence of the symmetry plain is:</a>
<a name="ln1835">        --&gt; all stereogenic atoms and allenes parities are inverted</a>
<a name="ln1836">  (c) C2v  #2: discover vertical axis C2</a>
<a name="ln1837">      o Map canonical numbers X1 &lt;--&gt; Y2 and A1 &lt;--&gt; B2</a>
<a name="ln1838">      o Make sure that after mapping X1 &lt;--&gt; Y2 the atoms Ai and</a>
<a name="ln1839">        Bi still have equal mapping ranks</a>
<a name="ln1840">      o Traverse DFS from X1 and Y2</a>
<a name="ln1841">        In this case canonical numbers will be rotated by</a>
<a name="ln1842">                     180 degrees around the vertical axis</a>
<a name="ln1843">         (this may be considered as a superposition of two Cv</a>
<a name="ln1844">          reflections in perpendicular vertical planes)</a>
<a name="ln1845">      o Criterion of the presence of the C2 axis is:</a>
<a name="ln1846">        --&gt; all stereogenic atoms and allenes parities are not changed</a>
<a name="ln1847">  (d) S4  #3: discover axis horizontal S4 axis</a>
<a name="ln1848">      o Map canonical numbers X1 &lt;--&gt; Y2, Y1 &lt;--&gt; A2, A1 &lt;--&gt; B2, B1 &lt;--&gt; X2</a>
<a name="ln1849">      o Traverse DFS from X1 and Y2</a>
<a name="ln1850">        In this case the canonical numbers will be rotated by</a>
<a name="ln1851">                     90 degrees and reflected in a horizontal plane.</a>
<a name="ln1852">        3 attempts corrresponding to transpositions 0132, 0213, 0321</a>
<a name="ln1853">                                 are sufficient (XY=01,02,03)</a>
<a name="ln1854">      o Criterion of the presence of the S4 symmetry axis is:</a>
<a name="ln1855">        --&gt; all stereogenic atoms and allenes parities are inverted</a>
<a name="ln1856"> </a>
<a name="ln1857">***************************************************************************************/</a>
<a name="ln1858"> </a>
<a name="ln1859">/**************************************************************************************/</a>
<a name="ln1860">int CalculatedPathsParitiesAreIdentical( sp_ATOM *at, int num_atoms, const AT_RANK *nSymmRank,</a>
<a name="ln1861">                         AT_RANK *nCanonRank, AT_RANK *nAtomNumberCanon,</a>
<a name="ln1862">                         AT_RANK *nAtomNumberCanon1, AT_RANK *nAtomNumberCanon2,</a>
<a name="ln1863">                         AT_RANK *nVisited1, AT_RANK *nVisited2,</a>
<a name="ln1864">                         AT_RANK prev_sb_neigh, AT_RANK cur, AT_RANK next1, AT_RANK next2, int nNeighMode,</a>
<a name="ln1865">                         int bParitiesInverted, int mode, CANON_STAT *pCS,</a>
<a name="ln1866">                         int vABParityUnknown)</a>
<a name="ln1867">{</a>
<a name="ln1868">    int i, i01, i02, i11, i12, i21, i22, k, parity, parity1, parity2, parity12, num_other_neigh;</a>
<a name="ln1869">    int nNumEqStereogenic, nCheckingMode, not_well_def_parities;</a>
<a name="ln1870">    AT_RANK other_neigh[MAX_NUM_STEREO_ATOM_NEIGH], neigh, r1, r2;</a>
<a name="ln1871">    int  nNumComparedCenters = 0, nNumComparedBonds = 0, bCurParityInv1=0 /*, bCurParityInv2=0*/;</a>
<a name="ln1872">    int  bCurRotated=0, nNumDiff=0, nNumInv=0;</a>
<a name="ln1873">    int  s1, s2;</a>
<a name="ln1874"> </a>
<a name="ln1875">    nCheckingMode = ( prev_sb_neigh &lt; num_atoms )? CHECKING_STEREOBOND : CHECKING_STEREOCENTER;</a>
<a name="ln1876">    not_well_def_parities = 0;</a>
<a name="ln1877">    nNumEqStereogenic = 0;</a>
<a name="ln1878"> </a>
<a name="ln1879">    if ( (nNeighMode != NEIGH_MODE_RING &amp;&amp;</a>
<a name="ln1880">         bParitiesInverted != 0) || abs(bParitiesInverted) != 1 ) {</a>
<a name="ln1881">        bParitiesInverted = 0;</a>
<a name="ln1882">    }</a>
<a name="ln1883"> </a>
<a name="ln1884">    if ( bParitiesInverted ) {</a>
<a name="ln1885">        for ( i = 0, i11 = i22 = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1886">            /* count number of atoms that have not been visited */</a>
<a name="ln1887">            i11 += !nVisited1[i];</a>
<a name="ln1888">            i22 += !nVisited2[i];</a>
<a name="ln1889">            nAtomNumberCanon1[i] = MAX_ATOMS+1;  /*  mark unchanged */</a>
<a name="ln1890">            nAtomNumberCanon2[i] = MAX_ATOMS+1;  /*  mark unchanged */</a>
<a name="ln1891">        }</a>
<a name="ln1892">        if ( i11 || i22 ) {</a>
<a name="ln1893">            if ( bParitiesInverted == 1 )</a>
<a name="ln1894">                return 0; /* only a part of the structure has been inverted */</a>
<a name="ln1895">            else</a>
<a name="ln1896">                bParitiesInverted = 0;</a>
<a name="ln1897">        }</a>
<a name="ln1898">    } else {</a>
<a name="ln1899">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1900">            nAtomNumberCanon1[i] = MAX_ATOMS+1;  /*  mark unchanged */</a>
<a name="ln1901">            nAtomNumberCanon2[i] = MAX_ATOMS+1;  /*  mark unchanged */</a>
<a name="ln1902">        }</a>
<a name="ln1903">    }</a>
<a name="ln1904">    if ( (bParitiesInverted  &gt; 0 &amp;&amp; !(mode == MAP_MODE_C2v || mode == MAP_MODE_S4)) ||</a>
<a name="ln1905">         (bParitiesInverted == 0 &amp;&amp; !(mode == MAP_MODE_C2  || mode == MAP_MODE_STD))) {</a>
<a name="ln1906">        return 0;</a>
<a name="ln1907">    }</a>
<a name="ln1908">    /**************************************************************************************</a>
<a name="ln1909">     *    The following discussion assumes that the canonical numbers are</a>
<a name="ln1910">     *    switched for some pairs of constitutionally identical atoms</a>
<a name="ln1911">     *    in such a way that the new numbering is an equivalent to the</a>
<a name="ln1912">     *    nCanonRank[] canonical numbering (the transposition belongs to the</a>
<a name="ln1913">     *    automorphism group of the chemical structure having no stereo).</a>
<a name="ln1914">     *    At this point non-zero elements of nVisited1[] and nVisited2[]</a>
<a name="ln1915">     *    together contain transposition P of the atom numbers.</a>
<a name="ln1916">     *    and P2 respectively of the ordering atom numbers: nVisitedi[k] = Pi(k)+1;</a>
<a name="ln1917">     *    In this implementation:</a>
<a name="ln1918">     *       P1(k)=k for all k</a>
<a name="ln1919">     *       P2(cur)=cur, P2(next1)=next2, P2(next2)=next1 </a>
<a name="ln1920">     *</a>
<a name="ln1921">     *    Below we call one of the numberings &quot;old&quot;, another &quot;new&quot;.</a>
<a name="ln1922">     *</a>
<a name="ln1923">     *    *IF* the old and the new canonical numberings produce same parities for stereogenic</a>
<a name="ln1924">     *    elements for the same canonical number(s)</a>
<a name="ln1925">     *    (that is, old_parity(canon_number) == new_parity(canon_number)</a>
<a name="ln1926">     *    *except* the currently being tested stereocenter at[cur] or stereobond/cumulene</a>
<a name="ln1927">     *    at[cur]=at[prev_sb_neigh], whose parity MUST be inverted</a>
<a name="ln1928">     *</a>
<a name="ln1929">     *    *THEN* the stereocenter or stereobond/cumulene is not stereogenic with one</a>
<a name="ln1930">     *</a>
<a name="ln1931">     *    *EXCEPTION* If the currently tested stereogenic element is constitutionally</a>
<a name="ln1932">     *    equivalent to two or more other stereogenic elements that have been</a>
<a name="ln1933">     *    permuted then the currently tested one is still stereogenic.</a>
<a name="ln1934">     **************************************************************************************/</a>
<a name="ln1935"> </a>
<a name="ln1936">     /*</a>
<a name="ln1937">     * 1. replace the assigned in each of the parallel traversals atom numbers</a>
<a name="ln1938">     *    with the canon. ranks corresponding to the atom numbers in the</a>
<a name="ln1939">     *    currently numbered atoms at[].</a>
<a name="ln1940">     *    One of obtained this way canonical numberings (probably nVisited1[])</a>
<a name="ln1941">     *    is same as the nCanonRank[] because usually nVisited1[i] = i+1 or 0</a>
<a name="ln1942">     */</a>
<a name="ln1943">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1944"> </a>
<a name="ln1945">        if ( nVisited1[i] ) {</a>
<a name="ln1946">            /* canonical number of the atom mapped on atom #i in 'left' path */</a>
<a name="ln1947">            nVisited1[i] = nCanonRank[ (int)nVisited1[i] - 1 ];</a>
<a name="ln1948">            /* reverse: atom # from the mapped canonical rank in 'left' path */</a>
<a name="ln1949">            nAtomNumberCanon1[nVisited1[i] - 1] = i;</a>
<a name="ln1950">        }</a>
<a name="ln1951">        if ( nVisited2[i] ) {</a>
<a name="ln1952">            /* canonical number of the atom mapped on atom #i in 'right' path */</a>
<a name="ln1953">            nVisited2[i] = nCanonRank[ (int)nVisited2[i] - 1 ];</a>
<a name="ln1954">            /* reverse: atom # from the mapped canonical rank in 'right' path */</a>
<a name="ln1955">            nAtomNumberCanon2[nVisited2[i] - 1] = i;</a>
<a name="ln1956">        }</a>
<a name="ln1957">        /* if 'left' and 'right' path do not have atoms in common except the</a>
<a name="ln1958">           starting atom (and in case of stereobond, the end atom) some of</a>
<a name="ln1959">           nVisitedi[i] elements may be zero.</a>
<a name="ln1960">        */</a>
<a name="ln1961">    }</a>
<a name="ln1962">    </a>
<a name="ln1963">    /*</a>
<a name="ln1964">     * if started with a stereobond then check whether its parity has changed.</a>
<a name="ln1965">     * If yes then continue, otherwise parities are different</a>
<a name="ln1966">     *</a>
<a name="ln1967">     * if started with a stereo center then prev_sb_neigh = MAX_ATOMS+1</a>
<a name="ln1968">     *</a>
<a name="ln1969">     * If the transposition of next1 and next2 changes only the parity of the starting stereo atom or stereo bond</a>
<a name="ln1970">     * then the stereo bond or stereo atom is not stereogenic</a>
<a name="ln1971">     *</a>
<a name="ln1972">     * The exception: the stereogenic elememt in question is equivalent</a>
<a name="ln1973">     *    to two or more traversed other stereogenic elememts</a>
<a name="ln1974">     *    (see nNumEqStereogenic below, case similar to trimethylcyclopropane:</a>
<a name="ln1975">     *     3 or more constitutionally equivalent stereogenic elements)</a>
<a name="ln1976">     */</a>
<a name="ln1977">    if ( nCheckingMode == CHECKING_STEREOBOND ) {</a>
<a name="ln1978">        /******************************************************************************</a>
<a name="ln1979">         *</a>
<a name="ln1980">         *  Possibly stereogenic starting bond or cumulene at[cur]-at[prev_sb_neigh]</a>
<a name="ln1981">         *</a>
<a name="ln1982">         *******************************************************************************/</a>
<a name="ln1983">        /*  checking the starting stereo bond */</a>
<a name="ln1984">        if ( nVisited1[prev_sb_neigh] || nVisited2[prev_sb_neigh] ) {</a>
<a name="ln1985">            /*  the bond or cumulene is in the ring and the opposite atom has been visited */</a>
<a name="ln1986">            if ( nVisited1[prev_sb_neigh]  != nVisited2[prev_sb_neigh] ||</a>
<a name="ln1987">                 nCanonRank[prev_sb_neigh] != nVisited2[prev_sb_neigh] ) {</a>
<a name="ln1988">                return 0; /*  error: we came back to the same bond/cumulene and */ /*   &lt;BRKPT&gt; */</a>
<a name="ln1989">                          /*  assigned different canon. ranks to the opposite atom. */</a>
<a name="ln1990">            }</a>
<a name="ln1991">            if ( at[prev_sb_neigh].valence + at[prev_sb_neigh].num_H &gt; 3 )</a>
<a name="ln1992">                return 0; /*  at[prev_sb_neigh] atom can not be adjacent to a stereo bond/cumulene */</a>
<a name="ln1993">                          /*  or does not have 3 attachments (hydrogens are not considered here) */</a>
<a name="ln1994">            for ( i = 0, k = 0; i &lt; MAX_NUM_STEREO_BONDS &amp;&amp;</a>
<a name="ln1995">                                  (neigh=at[prev_sb_neigh].stereo_bond_neighbor[i]) &amp;&amp; !(k=(neigh-1 == cur)); i ++ )</a>
<a name="ln1996">                ;</a>
<a name="ln1997">            if ( !k ) {</a>
<a name="ln1998">                return -1; /*  program error: could not locate stereogenic bond mark on the opposite atom */</a>
<a name="ln1999">            }</a>
<a name="ln2000">            k = (int)at[prev_sb_neigh].stereo_bond_ord[i]; /*  seq. number of the double or cumulene bond on at[prev_sb_neigh] */</a>
<a name="ln2001"> </a>
<a name="ln2002">            for ( i = 0, num_other_neigh = 0; i &lt; at[prev_sb_neigh].valence &amp;&amp; num_other_neigh &lt;= MAX_OTHER_NEIGH; i ++ ) {</a>
<a name="ln2003">                if ( i != k ) { /*  do not include the double or cumulene bond */</a>
<a name="ln2004">                    other_neigh[num_other_neigh ++] = at[prev_sb_neigh].neighbor[i];</a>
<a name="ln2005">                }</a>
<a name="ln2006">            }</a>
<a name="ln2007">            if ( num_other_neigh + at[prev_sb_neigh].num_H &gt; MAX_OTHER_NEIGH ) {</a>
<a name="ln2008">                return CT_STEREOCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2009">            }</a>
<a name="ln2010">            for ( i = 0; i &lt; num_other_neigh; i ++ ) {</a>
<a name="ln2011">                k = (int)other_neigh[i];</a>
<a name="ln2012">                if ( nVisited1[k] &amp;&amp; nVisited1[k] != nCanonRank[k] ) {</a>
<a name="ln2013">                    return 0; /*  parity of the statring stereo bond/cumulene has not changed. */</a>
<a name="ln2014">                }</a>
<a name="ln2015">                if ( nVisited2[k] &amp;&amp; nVisited2[k] != nCanonRank[k] ) {</a>
<a name="ln2016">                    return 0; /*  parity of the statring stereo bond/cumulene has not changed. */</a>
<a name="ln2017">                }</a>
<a name="ln2018">            }</a>
<a name="ln2019">        }</a>
<a name="ln2020">    }</a>
<a name="ln2021">    if ( nCheckingMode == CHECKING_STEREOCENTER ) {</a>
<a name="ln2022">        /**************************************************</a>
<a name="ln2023">         *</a>
<a name="ln2024">         *  Possibly stereogenic starting atom at[cur]</a>
<a name="ln2025">         *</a>
<a name="ln2026">         **************************************************/</a>
<a name="ln2027">        /*  checking the starting stereo center */</a>
<a name="ln2028">        for ( i = 0, num_other_neigh = 0; i &lt; at[cur].valence &amp;&amp; num_other_neigh &lt;= MAX_OTHER_NEIGH; i ++ ) {</a>
<a name="ln2029">            neigh  = at[cur].neighbor[i];</a>
<a name="ln2030">            if ( neigh != next1 &amp;&amp; neigh != next2 ) {</a>
<a name="ln2031">                other_neigh[num_other_neigh ++] = neigh;</a>
<a name="ln2032">            }</a>
<a name="ln2033">        }</a>
<a name="ln2034">        if ( num_other_neigh + at[cur].num_H &gt; MAX_OTHER_NEIGH ) {</a>
<a name="ln2035">            return CT_STEREOCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2036">        }</a>
<a name="ln2037">        /*</a>
<a name="ln2038">        if ( bParitiesInverted &amp;&amp; at[cur].valence == MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln2039">            if ( nVisited1[other_neigh[0]] == nCanonRank[other_neigh[0]] ||</a>
<a name="ln2040">                 nVisited2[other_neigh[0]] == nCanonRank[other_neigh[0]] ||</a>
<a name="ln2041">                 nVisited1[other_neigh[1]] == nCanonRank[other_neigh[1]] ||</a>
<a name="ln2042">                 nVisited2[other_neigh[1]] == nCanonRank[other_neigh[1]] ) {</a>
<a name="ln2043">                bParitiesInverted = 0;</a>
<a name="ln2044">                bCurRotated = 1;</a>
<a name="ln2045">            }</a>
<a name="ln2046">        }</a>
<a name="ln2047">        */</a>
<a name="ln2048">        /* bParitiesInverted = -1 means no predefined stereocenter has been checked */</a>
<a name="ln2049">        if ( bParitiesInverted &amp;&amp; at[cur].valence == MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln2050">            /* special case: 4 canonically eq. neighbors */</a>
<a name="ln2051">            int canon_parity, parity_vis_1, parity_vis_2;</a>
<a name="ln2052">            canon_parity = GetPermutationParity( at+cur, MAX_ATOMS+1, nCanonRank );</a>
<a name="ln2053">            parity_vis_1 = GetPermutationParity( at+cur, MAX_ATOMS+1, nVisited1 );</a>
<a name="ln2054">            parity_vis_2 = GetPermutationParity( at+cur, MAX_ATOMS+1, nVisited2 );</a>
<a name="ln2055">            if ( parity_vis_1 != parity_vis_2 ) {</a>
<a name="ln2056">                return 0;</a>
<a name="ln2057">            }</a>
<a name="ln2058">            if ( bParitiesInverted ==  1 &amp;&amp; parity_vis_1 == canon_parity ) {</a>
<a name="ln2059">                return 0; /* not a typical case of inversion during the mapping of D4h stereocenter */</a>
<a name="ln2060">            } else</a>
<a name="ln2061">            if ( bParitiesInverted == -1 ) {</a>
<a name="ln2062">                if ( parity_vis_1 == canon_parity ) {</a>
<a name="ln2063">                    bParitiesInverted = 0;</a>
<a name="ln2064">                } else {</a>
<a name="ln2065">                    bParitiesInverted = 1;</a>
<a name="ln2066">                }</a>
<a name="ln2067">            }</a>
<a name="ln2068">        }</a>
<a name="ln2069">        /* at this point bParitiesInverted &gt;= 0 */</a>
<a name="ln2070">        if ( !bParitiesInverted &amp;&amp; !bCurRotated ) {</a>
<a name="ln2071">            for ( i = 0; i &lt; num_other_neigh; i ++ ) {</a>
<a name="ln2072">                k = (int)other_neigh[i];</a>
<a name="ln2073">                if ( nVisited1[k] &amp;&amp; nVisited1[k] != nCanonRank[k] ) {</a>
<a name="ln2074">                    return 0; /*  parity of the statring stereo center has not changed. */</a>
<a name="ln2075">                }</a>
<a name="ln2076">                if ( nVisited2[k] &amp;&amp; nVisited2[k] != nCanonRank[k] ) {</a>
<a name="ln2077">                    return 0; /*  parity of the statring stereo center has not changed. */</a>
<a name="ln2078">                }</a>
<a name="ln2079">            }</a>
<a name="ln2080">        }</a>
<a name="ln2081">    }</a>
<a name="ln2082">    </a>
<a name="ln2083">    /*****************************************************</a>
<a name="ln2084">     * Check other (non-starting) stereo centers</a>
<a name="ln2085">     ******************************************************/</a>
<a name="ln2086">    for ( i = 0; i &lt; pCS-&gt;nLenLinearCTStereoCarb; i ++, nNumComparedCenters += (k &gt; 0) ) {</a>
<a name="ln2087">        r1     = pCS-&gt;LinearCTStereoCarb[i].at_num;</a>
<a name="ln2088">        i01    = nAtomNumberCanon[r1-1]; /*  ord. number of the atom that has canon rank r1 */</a>
<a name="ln2089">        </a>
<a name="ln2090">        i11     = nAtomNumberCanon1[r1-1]; /*  = (MAX_ATOMS+1) &gt; num_atoms if the atom has not been traversed */</a>
<a name="ln2091">        i12     = nAtomNumberCanon2[r1-1]; /*  = otherwise &lt; num_atoms */</a>
<a name="ln2092"> </a>
<a name="ln2093">        s1 = (i11 &lt; num_atoms); /*  1 =&gt; the center was traversed on path #1 */</a>
<a name="ln2094">        s2 = (i12 &lt; num_atoms); /*  1 =&gt; the center was traversed on path #2 */</a>
<a name="ln2095"> </a>
<a name="ln2096">        bCurParityInv1 = (bParitiesInverted &amp;&amp;</a>
<a name="ln2097">                          at[cur].nRingSystem == at[i11].nRingSystem &amp;&amp;</a>
<a name="ln2098">                          at[cur].nRingSystem == at[i12].nRingSystem );</a>
<a name="ln2099"> </a>
<a name="ln2100"> </a>
<a name="ln2101">        k  = 0;</a>
<a name="ln2102">        </a>
<a name="ln2103">        /*  check whether the two stereo centers (they can be one and the same atom) have been traversed */</a>
<a name="ln2104">        if ( !s1 &amp;&amp; !s2 ) {</a>
<a name="ln2105">            continue;  /*  Both stereo centers have not been traversed; check the next pair. */</a>
<a name="ln2106">        }</a>
<a name="ln2107"> </a>
<a name="ln2108">        if ( nCheckingMode == CHECKING_STEREOCENTER ) {</a>
<a name="ln2109">            /*  check whether the stereocenters are the starting stereocenter */</a>
<a name="ln2110">            switch( (cur == i11) + (cur == i12) ) {</a>
<a name="ln2111">            case 2:</a>
<a name="ln2112">                continue; /*  do not recheck the starting atom */</a>
<a name="ln2113">            case 1:</a>
<a name="ln2114">                return -1; /*  possibly program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln2115">            /* case 0: */</a>
<a name="ln2116">            /*     break;  */  /*  the stereo centers are not the sarting stereo center */</a>
<a name="ln2117">            }</a>
<a name="ln2118">            if ( cur == i01 ) {</a>
<a name="ln2119">                return -1;  /*  program error: in this case at least one of the i11, i12 must be == cur */ /*   &lt;BRKPT&gt; */</a>
<a name="ln2120">            }</a>
<a name="ln2121">        }</a>
<a name="ln2122">        </a>
<a name="ln2123">        if ( nNeighMode == NEIGH_MODE_RING ) {</a>
<a name="ln2124">            if ( i11 != i12 &amp;&amp; !bCurParityInv1 ) {</a>
<a name="ln2125">                return -1; /*  failed: the two stereo atoms have not been traversed synchronously */</a>
<a name="ln2126">            }</a>
<a name="ln2127">            if ( !at[i11].parity || !at[i12].parity ) {</a>
<a name="ln2128">                return 0; /*  another atom does not have parity (it might have been removed) 9-11-2002 */</a>
<a name="ln2129">            }</a>
<a name="ln2130">        }</a>
<a name="ln2131">        if ( nNeighMode == NEIGH_MODE_CHAIN ) {</a>
<a name="ln2132">            if ( s1+s2 != 1 ) {</a>
<a name="ln2133">                return -1; /*  program error: only one out of s1 and s2 must be 1, another must be 0. */</a>
<a name="ln2134">            }</a>
<a name="ln2135">            if ( (s1 &amp;&amp; !at[i11].parity) || (s2 &amp;&amp; !at[i12].parity) ) {</a>
<a name="ln2136">                return 0; /*  another atom does not have parity (it might have been removed) 9-11-2002 */</a>
<a name="ln2137">            }</a>
<a name="ln2138">        }</a>
<a name="ln2139">        </a>
<a name="ln2140">        parity  = pCS-&gt;LinearCTStereoCarb[i].parity;</a>
<a name="ln2141">        if ( (nNeighMode == NEIGH_MODE_RING  &amp;&amp; (i11 != i01) &amp;&amp; (i12 != i01)) ||</a>
<a name="ln2142">             /*  in NEIGH_MODE_RING case we know that i11 == i12 except bCurParityInv1 == 1 */</a>
<a name="ln2143">             nNeighMode == NEIGH_MODE_CHAIN </a>
<a name="ln2144">             /*  in NEIGH_MODE_CHAIN case here we always have 2 different atoms */</a>
<a name="ln2145">        ) {</a>
<a name="ln2146">            /****************************************************************</a>
<a name="ln2147">             * Case of two transposed atoms or a circular permutation in D4h</a>
<a name="ln2148">             */</a>
<a name="ln2149">            parity1 = s1? GetStereoCenterParity( at, i11, nVisited1 ) : PARITY_IMPOSSIBLE;</a>
<a name="ln2150">            parity2 = s2? GetStereoCenterParity( at, i12, nVisited2 ) : PARITY_IMPOSSIBLE;</a>
<a name="ln2151">            if ( !ATOM_PARITY_KNOWN(parity1) &amp;&amp; !ATOM_PARITY_KNOWN(parity2) ) {</a>
<a name="ln2152">                return -1; /*  should not happen: must have been detected at the time of the traversal */</a>
<a name="ln2153">            }</a>
<a name="ln2154">            if ( s1 &amp;&amp; s2 ) {</a>
<a name="ln2155">                if ( bCurParityInv1 ) {</a>
<a name="ln2156">                    int parity1orig = GetStereoCenterParity( at, i11, nCanonRank ); </a>
<a name="ln2157">                    int parity2orig = GetStereoCenterParity( at, i12, nCanonRank ); </a>
<a name="ln2158">                    if ( i11 == i12 ||</a>
<a name="ln2159">                         ((parity1 == parity1orig || parity2 == parity2orig || parity1 != parity2) &amp;&amp;</a>
<a name="ln2160">                         ATOM_PARITY_WELL_DEF(parity1)) ||</a>
<a name="ln2161">                         (parity1 != parity2 &amp;&amp; (!ATOM_PARITY_WELL_DEF(parity1) ||</a>
<a name="ln2162">                                                !ATOM_PARITY_WELL_DEF(parity2))) )</a>
<a name="ln2163">                        /*return -1; */ /* should be different atoms with inverted parities */</a>
<a name="ln2164">                        nNumDiff ++;</a>
<a name="ln2165">                } else {</a>
<a name="ln2166">                    if ( i11 != i12 || parity1 != parity2 )</a>
<a name="ln2167">                        return -1; /*  program error: must be the same atom */</a>
<a name="ln2168">                }</a>
<a name="ln2169">            }</a>
<a name="ln2170">            parity12 = s1? parity1 : parity2;</a>
<a name="ln2171"> </a>
<a name="ln2172">            if ( ATOM_PARITY_WELL_DEF(parity) &amp;&amp; parity == parity12 ) {</a>
<a name="ln2173">                /*  symmetrical neighbors have well-defined equal parities */</a>
<a name="ln2174">                k ++;</a>
<a name="ln2175">                if ( nCheckingMode == CHECKING_STEREOCENTER &amp;&amp; nNeighMode == NEIGH_MODE_RING ) {</a>
<a name="ln2176">                    /*  all 3: cur, i01, i11 are different atoms (here i11==i12) */</a>
<a name="ln2177">                    /*  here nSymmRank[i01]==nSymmRank[i11] due to the parallel traversal */</a>
<a name="ln2178">                    if ( nSymmRank[cur] == nSymmRank[i01] ) {</a>
<a name="ln2179">                        nNumEqStereogenic ++;  /*  all 3 are equ */</a>
<a name="ln2180">                    }</a>
<a name="ln2181">                }</a>
<a name="ln2182">            } else</a>
<a name="ln2183">            if ( ATOM_PARITY_WELL_DEF(parity) &amp;&amp; ATOM_PARITY_WELL_DEF(parity12) ) {</a>
<a name="ln2184">                /*  apparently different well-defined parities */</a>
<a name="ln2185">                if ( !bCurParityInv1 ) {</a>
<a name="ln2186">                    nNumInv ++;</a>
<a name="ln2187">                    /* return 0; */</a>
<a name="ln2188">                }</a>
<a name="ln2189">            } else {</a>
<a name="ln2190">#if ( PROPAGATE_ILL_DEF_STEREO == 1 )</a>
<a name="ln2191">                /*  at least one parity is ill-defined. Use parity1 and parity2 to temporarily save bitmaps */</a>
<a name="ln2192">                parity1 = (parity  ==vABParityUnknown /*AB_PARITY_UNKN*/)? NOT_WELL_DEF_UNKN :</a>
<a name="ln2193">                          (parity  ==AB_PARITY_UNDF)? NOT_WELL_DEF_UNDF : 0;</a>
<a name="ln2194">                parity2 = (parity12==vABParityUnknown /*AB_PARITY_UNKN*/)? NOT_WELL_DEF_UNKN :</a>
<a name="ln2195">                          (parity12==AB_PARITY_UNDF)? NOT_WELL_DEF_UNDF : 0;</a>
<a name="ln2196">                if ( parity1 | parity2 ) {</a>
<a name="ln2197">                    not_well_def_parities |= ( parity1 | parity2 );</a>
<a name="ln2198">                    k ++;</a>
<a name="ln2199">                } else {</a>
<a name="ln2200">                    return -1;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln2201">                }</a>
<a name="ln2202">#else</a>
<a name="ln2203">                return 0;</a>
<a name="ln2204">#endif</a>
<a name="ln2205">            }</a>
<a name="ln2206">        } else</a>
<a name="ln2207">        if ( i11 == i01 &amp;&amp; i12 == i01 ) {</a>
<a name="ln2208">            /********************************************************************/</a>
<a name="ln2209">            /*  i11 == i12 are same atom as i01, nNeighMode == NEIGH_MODE_RING */</a>
<a name="ln2210">            if ( !s1 || !s2 ) {</a>
<a name="ln2211">                return -1;</a>
<a name="ln2212">            }</a>
<a name="ln2213">            /*  the parity of the new neighbors permutation must be same as the old one */</a>
<a name="ln2214">            /*  this must work for well-defined and ill-defined parities. */</a>
<a name="ln2215">            /*  actual parity (that includes the geometry) is not important here. */</a>
<a name="ln2216">            /*  old permutation */</a>
<a name="ln2217">            parity  = GetPermutationParity( at+i01, MAX_ATOMS+1, nCanonRank );</a>
<a name="ln2218">            /*  new parmutation */</a>
<a name="ln2219">            parity1 = GetPermutationParity( at+i01, MAX_ATOMS+1, nVisited1 );</a>
<a name="ln2220">            parity2 = GetPermutationParity( at+i01, MAX_ATOMS+1, nVisited2 );</a>
<a name="ln2221">            if ( parity != parity1 || parity != parity2 ) {</a>
<a name="ln2222">                return 0;</a>
<a name="ln2223">            }</a>
<a name="ln2224">            k ++;</a>
<a name="ln2225">        } else {</a>
<a name="ln2226">            /* nNeighMode == NEIGH_MODE_RING and only one out of the two (i11 == i01) (i12 == i01) is true */</a>
<a name="ln2227">            return -1; </a>
<a name="ln2228">        }</a>
<a name="ln2229">        /* nNumComparedCenters += (k &gt; 0); */</a>
<a name="ln2230">    }</a>
<a name="ln2231">    if ( bCurRotated || nNumDiff || nNumInv ) {</a>
<a name="ln2232">        return 0;</a>
<a name="ln2233">    }</a>
<a name="ln2234"> </a>
<a name="ln2235">     /* !!!! Add here bParitiesInverted == 1 case !!!! */</a>
<a name="ln2236">    /******************************************************/</a>
<a name="ln2237">    /*  Check other (non-starting) stereo bonds/cumulenes */</a>
<a name="ln2238">    /******************************************************/</a>
<a name="ln2239">    for ( i = 0; i &lt; pCS-&gt;nLenLinearCTStereoDble; i ++, nNumComparedBonds += (k &gt; 0) ) {</a>
<a name="ln2240">        r1     = pCS-&gt;LinearCTStereoDble[i].at_num1;</a>
<a name="ln2241">        r2     = pCS-&gt;LinearCTStereoDble[i].at_num2;</a>
<a name="ln2242">        i01    = nAtomNumberCanon[r1-1];  /*  ord. number of the atom that originally has canon rank r1 */</a>
<a name="ln2243">        i02    = nAtomNumberCanon[r2-1];  /*  ord. number of the atom that originally has canon rank r2 */</a>
<a name="ln2244"> </a>
<a name="ln2245">        i11     = nAtomNumberCanon1[r1-1]; /*  ord. number of the atom that got canon rank r1 during the parallel traversal */</a>
<a name="ln2246">        i12     = nAtomNumberCanon1[r2-1]; /*  ord. number of the atom that got canon rank r2 during the parallel traversal */</a>
<a name="ln2247"> </a>
<a name="ln2248">        i21     = nAtomNumberCanon2[r1-1];</a>
<a name="ln2249">        i22     = nAtomNumberCanon2[r2-1];</a>
<a name="ln2250"> </a>
<a name="ln2251"> </a>
<a name="ln2252">        s1 = (i11 &lt; num_atoms &amp;&amp; i12 &lt; num_atoms);</a>
<a name="ln2253">        s2 = (i21 &lt; num_atoms &amp;&amp; i22 &lt; num_atoms);</a>
<a name="ln2254"> </a>
<a name="ln2255">        k  = 0;</a>
<a name="ln2256"> </a>
<a name="ln2257">        /*  check whether the two stereo bonds/allenes (they can be one and the same) have been traversed */</a>
<a name="ln2258">        if ( !s1 &amp;&amp; !s2 ) {</a>
<a name="ln2259">            continue; /*  Both stereo bonds/cumulenes have not been traversed; check the next pair. */</a>
<a name="ln2260">        }</a>
<a name="ln2261"> </a>
<a name="ln2262">        if ( nCheckingMode == CHECKING_STEREOBOND ) {</a>
<a name="ln2263">            switch ( ((i11 == cur &amp;&amp; i12 == prev_sb_neigh) || (i12 == cur &amp;&amp; i11 == prev_sb_neigh)) +</a>
<a name="ln2264">                     ((i21 == cur &amp;&amp; i22 == prev_sb_neigh) || (i22 == cur &amp;&amp; i21 == prev_sb_neigh)) ) {</a>
<a name="ln2265">            case 2:</a>
<a name="ln2266">                continue; /*  do not recheck the starting bond/cumulene */</a>
<a name="ln2267">            case 1:</a>
<a name="ln2268">                return -1; /*  possibly program error  */ /*   &lt;BRKPT&gt; */</a>
<a name="ln2269">            /* case 0: */</a>
<a name="ln2270">            /*     break; */   /*  the stereo centers are not the sarting stereo center */</a>
<a name="ln2271">            }</a>
<a name="ln2272">            if ( (i01 == cur &amp;&amp; i02 == prev_sb_neigh) || (i02 == cur &amp;&amp; i01 == prev_sb_neigh) ) {</a>
<a name="ln2273">                return -1;  /*  program error: in this case at least one of the i1x, i2x must be == cur */ /*   &lt;BRKPT&gt; */</a>
<a name="ln2274">            }</a>
<a name="ln2275">        }</a>
<a name="ln2276"> </a>
<a name="ln2277">        if ( nNeighMode == NEIGH_MODE_RING ) {</a>
<a name="ln2278">            if ( (i11 != i21 || i12 != i22) &amp;&amp; (i11 != i22 || i12 != i21) ) {</a>
<a name="ln2279">                return -1; /*  failed: the two bonds/cumulenes have not been traversed synchronously */</a>
<a name="ln2280">            }</a>
<a name="ln2281">            if ( 0 &gt; GetStereoNeighborPos( at, i11, i12 ) ) {</a>
<a name="ln2282">                return 0; /*  another bond is not stereo (the stereo might have been removed) 9-11-2002 */</a>
<a name="ln2283">            }</a>
<a name="ln2284"> </a>
<a name="ln2285">        }</a>
<a name="ln2286">        if ( nNeighMode == NEIGH_MODE_CHAIN ) {</a>
<a name="ln2287">            if ( s1+s2 != 1 ) {</a>
<a name="ln2288">                return -1; /*  program error: only one out of s1 and s2 must be 1, another must be 0. */</a>
<a name="ln2289">            }</a>
<a name="ln2290">            if ( (s1 &amp;&amp; 0 &gt; GetStereoNeighborPos( at, i11, i12 )) ||</a>
<a name="ln2291">                 (s2 &amp;&amp; 0 &gt; GetStereoNeighborPos( at, i21, i22 )) ) {</a>
<a name="ln2292">                return 0; /*  another bond is not stereo (the stereo might have been removed) 9-11-2002 */</a>
<a name="ln2293">            }</a>
<a name="ln2294">        }</a>
<a name="ln2295"> </a>
<a name="ln2296">        parity = pCS-&gt;LinearCTStereoDble[i].parity;</a>
<a name="ln2297">        /* bMustBeIdentical  = ATOM_PARITY_ILL_DEF(parity); */</a>
<a name="ln2298">        /* nNumEqStereogenic = 0; */</a>
<a name="ln2299"> </a>
<a name="ln2300">        if ( (nNeighMode == NEIGH_MODE_RING  &amp;&amp; (i11 != i01 || i12 != i02) &amp;&amp; (i11 != i02 || i12 != i01)) ||</a>
<a name="ln2301">             nNeighMode == NEIGH_MODE_CHAIN                    /*  in NEIGH_MODE_CHAIN case here we always have 2 different atoms */</a>
<a name="ln2302">        ) {</a>
<a name="ln2303">            /*******************************************/</a>
<a name="ln2304">            /*  case of two transposed bonds/cumulenes */</a>
<a name="ln2305">            parity1 = s1? GetStereoBondParity( at, i11, i12, nVisited1 ) : PARITY_IMPOSSIBLE;</a>
<a name="ln2306">            parity2 = s2? GetStereoBondParity( at, i21, i22, nVisited2 ) : PARITY_IMPOSSIBLE;</a>
<a name="ln2307">            if ( !ATOM_PARITY_KNOWN(parity1) &amp;&amp; !ATOM_PARITY_KNOWN(parity2) ) {</a>
<a name="ln2308">                return -1; /*  should not happen: must have been detected at the time of traversal */</a>
<a name="ln2309">            }</a>
<a name="ln2310">            if ( s1 &amp;&amp; s2 &amp;&amp; (((i11 != i21 || i12 != i22) &amp;&amp; (i11 != i22 || i12 != i21)) || parity1 != parity2 ) ) {</a>
<a name="ln2311">                return -1; /*  program error: must be the same bond/cumulene */</a>
<a name="ln2312">            }</a>
<a name="ln2313">            parity12 = s1? parity1 : parity2;</a>
<a name="ln2314">            if ( ATOM_PARITY_WELL_DEF(parity) &amp;&amp; parity == parity12 ) {</a>
<a name="ln2315">                /*  symmetrical neighbors have well-defined equal parities */</a>
<a name="ln2316">                k ++;</a>
<a name="ln2317">                if ( nCheckingMode == CHECKING_STEREOBOND &amp;&amp; nNeighMode == NEIGH_MODE_RING ) {</a>
<a name="ln2318">                    /*  all 3 bonds: cur-prev_sb_neigh, i01-i02, i11-i12 are different */</a>
<a name="ln2319">                    /*  (here &lt;i11,i12&gt;==&lt;i21,i22&gt; compared as unordered pairs) */</a>
<a name="ln2320">                    if ( (nSymmRank[cur] == nSymmRank[i01] &amp;&amp; nSymmRank[prev_sb_neigh] == nSymmRank[i02]) ||</a>
<a name="ln2321">                         (nSymmRank[cur] == nSymmRank[i02] &amp;&amp; nSymmRank[prev_sb_neigh] == nSymmRank[i01]) ) {</a>
<a name="ln2322">                        nNumEqStereogenic ++;</a>
<a name="ln2323">                    }</a>
<a name="ln2324">                }</a>
<a name="ln2325">            } else</a>
<a name="ln2326">            if ( ATOM_PARITY_WELL_DEF(parity) &amp;&amp; ATOM_PARITY_WELL_DEF(parity12) ) {</a>
<a name="ln2327">                /*  apparently different well-defined parities */</a>
<a name="ln2328">                return 0;</a>
<a name="ln2329">            } else {</a>
<a name="ln2330">                /*  at least one parity is ill-defined. Use parity1 and parity2 to temporarily save bitmaps */</a>
<a name="ln2331">#if ( PROPAGATE_ILL_DEF_STEREO == 1 )</a>
<a name="ln2332">                parity1 = (parity  ==vABParityUnknown /*AB_PARITY_UNKN*/)? NOT_WELL_DEF_UNKN :</a>
<a name="ln2333">                          (parity  ==AB_PARITY_UNDF)? NOT_WELL_DEF_UNDF : 0;</a>
<a name="ln2334">                parity2 = (parity12==vABParityUnknown /*AB_PARITY_UNKN*/)? NOT_WELL_DEF_UNKN :</a>
<a name="ln2335">                          (parity12==AB_PARITY_UNDF)? NOT_WELL_DEF_UNDF : 0;</a>
<a name="ln2336">                if ( parity1 | parity2 ) {</a>
<a name="ln2337">                    not_well_def_parities |= ( parity1 | parity2 );</a>
<a name="ln2338">                    k ++;</a>
<a name="ln2339">                } else {</a>
<a name="ln2340">                    return -1;  /*  program error */</a>
<a name="ln2341">                }</a>
<a name="ln2342">#else</a>
<a name="ln2343">                return 0;</a>
<a name="ln2344">#endif</a>
<a name="ln2345">            }</a>
<a name="ln2346">        } else {</a>
<a name="ln2347">            /*****************************************************************************************/</a>
<a name="ln2348">            /*  i11-i12 and i21-i22 are same as i01-i02 bond/cumulene, nNeighMode == NEIGH_MODE_RING */</a>
<a name="ln2349">            AT_NUMB n1, n2;</a>
<a name="ln2350">            int       j;</a>
<a name="ln2351">            if ( !s1 || !s2 ) {</a>
<a name="ln2352">                return -1;</a>
<a name="ln2353">            }</a>
<a name="ln2354">            /*  find neighbors along the stereo bond/cumulene */</a>
<a name="ln2355">            for ( j = 0, n1 = MAX_ATOMS+1; j &lt; MAX_NUM_STEREO_BOND_NEIGH &amp;&amp; at[i01].stereo_bond_neighbor[j]; j ++ ) {</a>
<a name="ln2356">                if ( (int)at[i01].stereo_bond_neighbor[j] == i02+1 ) {</a>
<a name="ln2357">                    n1 = at[i01].neighbor[ (int)at[i01].stereo_bond_ord[j] ];</a>
<a name="ln2358">                    break;</a>
<a name="ln2359">                }</a>
<a name="ln2360">            }</a>
<a name="ln2361">            for ( j = 0, n2 = MAX_ATOMS+1; j &lt; MAX_NUM_STEREO_BOND_NEIGH &amp;&amp; at[i02].stereo_bond_neighbor[j]; j ++ ) {</a>
<a name="ln2362">                if ( (int)at[i02].stereo_bond_neighbor[j] == i01+1 ) {</a>
<a name="ln2363">                    n2 = at[i02].neighbor[ (int)at[i02].stereo_bond_ord[j] ];</a>
<a name="ln2364">                    break;</a>
<a name="ln2365">                }</a>
<a name="ln2366">            }</a>
<a name="ln2367">            if ( n1 &gt; MAX_ATOMS || n2 &gt; MAX_ATOMS ) {</a>
<a name="ln2368">                return CT_REMOVE_STEREO_ERR;</a>
<a name="ln2369">            }</a>
<a name="ln2370">            /*  the parity of the new neighbors permutation must be same as the old one */</a>
<a name="ln2371">            /*  this must work for well-defined and ill-defined parities. */</a>
<a name="ln2372">            /*  actual parity (that includes the geometry) is not important here. */</a>
<a name="ln2373">            /*  old permutation */</a>
<a name="ln2374">            parity  = GetPermutationParity( at+i01, n1, nCanonRank) + GetPermutationParity( at+i02, n2, nCanonRank);</a>
<a name="ln2375">            /*  new parmutation */</a>
<a name="ln2376">            parity1 = GetPermutationParity( at+i01, n1, nVisited1 ) + GetPermutationParity( at+i02, n2, nVisited1 );</a>
<a name="ln2377">            parity2 = GetPermutationParity( at+i01, n1, nVisited2 ) + GetPermutationParity( at+i02, n2, nVisited2 );</a>
<a name="ln2378">            if ( parity %2 != parity1 % 2 || parity1 % 2 != parity2 % 2 ) {</a>
<a name="ln2379">                return 0;</a>
<a name="ln2380">            }</a>
<a name="ln2381">            k ++;</a>
<a name="ln2382">        }</a>
<a name="ln2383"> </a>
<a name="ln2384">        /* nNumComparedBonds += ( k &gt; 0 ); */</a>
<a name="ln2385">    }</a>
<a name="ln2386"> </a>
<a name="ln2387">    if ( nNumEqStereogenic &gt; 0 ) {</a>
<a name="ln2388">        /*  case similar to trimethylcyclopropane: 3 constitutionally equivalent stereogenic elements */</a>
<a name="ln2389">        /*  the transposition does not change the parities */</a>
<a name="ln2390">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2391">        pCS-&gt;bExtract |= EXTR_2EQL2CENTER_TO_REMOVE_PARITY;</a>
<a name="ln2392">#endif</a>
<a name="ln2393">        return 0;</a>
<a name="ln2394">    }</a>
<a name="ln2395">/* =========================================================================================</a>
<a name="ln2396">    Note</a>
<a name="ln2397">    ====</a>
<a name="ln2398">    At this point the comparison is complete and no difference sufficient to establish</a>
<a name="ln2399">    absence of stereo parity has been found.</a>
<a name="ln2400">    However, non-zero not_well_def_parities means that an ill-defined parity was</a>
<a name="ln2401">    compared to an ill-defined or well-defined parity. This means that the parity</a>
<a name="ln2402">    of the atom or bond being checked cannot be well-defined anymore.</a>
<a name="ln2403">   ========================================================================================*/</a>
<a name="ln2404"> </a>
<a name="ln2405"> </a>
<a name="ln2406">    not_well_def_parities |= COMP_STEREO_SUCCESS;</a>
<a name="ln2407"> </a>
<a name="ln2408">    return not_well_def_parities;</a>
<a name="ln2409"> </a>
<a name="ln2410">   /*  Add 1 to indicate success. The stereogenic elements might have been */</a>
<a name="ln2411">   /*  removed while checking existence of the previous atom/bond stereo */</a>
<a name="ln2412">   /* return (nNumComparedCenters + nNumComparedBonds + 1);  */</a>
<a name="ln2413">}</a>
<a name="ln2414">/********************************************************************************/</a>
<a name="ln2415">/*  Remove stereo marks from the bonds that are calculated to be non-stereo     */</a>
<a name="ln2416">/*  Such bonds must have 2 constitutionally equivalent attachments              */</a>
<a name="ln2417">/*  (can find two canonical numberings that change only one stereo bond parity) */</a>
<a name="ln2418">int RemoveCalculatedNonStereoBondParities( sp_ATOM *at, int num_atoms, int num_at_tg,</a>
<a name="ln2419">                                          AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln2420">                                          AT_RANK *nCanonRank, const AT_RANK *nSymmRank,</a>
<a name="ln2421">                                          AT_RANK *nAtomNumberCanon, AT_RANK *nAtomNumberCanon1, AT_RANK *nAtomNumberCanon2,</a>
<a name="ln2422">                                          NEIGH_LIST *nl, NEIGH_LIST *nl1, NEIGH_LIST *nl2, </a>
<a name="ln2423">                                          AT_RANK *nVisited1, AT_RANK *nVisited2, </a>
<a name="ln2424">                                          CANON_STAT *pCS,</a>
<a name="ln2425">                                          int vABParityUnknown)</a>
<a name="ln2426">{</a>
<a name="ln2427">    int j, n, m, ret, ret1, ret2, ret_failed=0;</a>
<a name="ln2428">    </a>
<a name="ln2429">    int i1, n1, s2;  /*  n1 must be SIGNED integer */</a>
<a name="ln2430">    AT_RANK nAtomRank1, nAtomRank2, neigh[3], nAvoidCheckAtom[2], opposite_atom, nLength;</a>
<a name="ln2431">    int         nNeighMode = NEIGH_MODE_CHAIN;</a>
<a name="ln2432">    int         nNumEqRingNeigh = 0, bRingNeigh, bSymmNeigh, bParitiesInverted;</a>
<a name="ln2433">    NEIGH_LIST *nl01, *nl02;</a>
<a name="ln2434">    const AT_RANK    *nSymmRank1, *nSymmRank2;</a>
<a name="ln2435"> </a>
<a name="ln2436">    ret = 0;</a>
<a name="ln2437"> </a>
<a name="ln2438">second_pass:</a>
<a name="ln2439"> </a>
<a name="ln2440">    for ( i1 = 0; i1 &lt; num_atoms &amp;&amp; !RETURNED_ERROR(ret_failed); i1 ++ ) {</a>
<a name="ln2441">        if ( at[i1].valence != 3 || !at[i1].stereo_bond_neighbor[0] ) {</a>
<a name="ln2442">            continue;</a>
<a name="ln2443">        }</a>
<a name="ln2444">        for ( n1 = 0; n1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; !RETURNED_ERROR(ret_failed) &amp;&amp; (s2=at[i1].stereo_bond_neighbor[n1]); n1++ ) {</a>
<a name="ln2445">            if ( !PARITY_CALCULATE(at[i1].stereo_bond_parity[n1]) &amp;&amp; PARITY_WELL_DEF(at[i1].stereo_bond_parity[n1]) ) {</a>
<a name="ln2446">                continue;</a>
<a name="ln2447">            }</a>
<a name="ln2448">            opposite_atom = (AT_RANK)(s2-1);</a>
<a name="ln2449">            s2 = at[i1].neighbor[(int)at[i1].stereo_bond_ord[n1]]; /*  different from opposite_atom in case of a cumulene */</a>
<a name="ln2450">            for ( j = 1, n = 0; j &lt;= (int)at[i1].valence; j ++ ) {      </a>
<a name="ln2451">                if ( nl[i1][j] != s2 ) {</a>
<a name="ln2452">                    neigh[n++] = nl[i1][j]; /*  sorting guarantees that canon. rank of neigh[0] is greater or equal */</a>
<a name="ln2453">                }</a>
<a name="ln2454">            }</a>
<a name="ln2455">            if ( n != 2 ) {</a>
<a name="ln2456">                ret = CT_STEREOBOND_ERROR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2457">                goto exit_function;</a>
<a name="ln2458">            }</a>
<a name="ln2459">            if ( nSymmRank[(int)neigh[0]] != nSymmRank[(int)neigh[1]] ) {</a>
<a name="ln2460">                continue; /*  may happen if another half-bond has not a defined parity */</a>
<a name="ln2461">            }</a>
<a name="ln2462"> </a>
<a name="ln2463">            bRingNeigh = (at[(int)neigh[0]].nRingSystem == at[(int)neigh[1]].nRingSystem);</a>
<a name="ln2464">            switch ( nNeighMode ) {</a>
<a name="ln2465">            case NEIGH_MODE_CHAIN:</a>
<a name="ln2466">                if ( bRingNeigh ) {</a>
<a name="ln2467">                    nNumEqRingNeigh ++;</a>
<a name="ln2468">                    continue;</a>
<a name="ln2469">                }</a>
<a name="ln2470">                nl01 = nl;</a>
<a name="ln2471">                nl02 = nl;</a>
<a name="ln2472">                nSymmRank1 = nSymmRank;</a>
<a name="ln2473">                nSymmRank2 = nSymmRank;</a>
<a name="ln2474">                break;</a>
<a name="ln2475"> </a>
<a name="ln2476">            case NEIGH_MODE_RING:</a>
<a name="ln2477">                if ( !bRingNeigh )</a>
<a name="ln2478">                    continue;</a>
<a name="ln2479">                /*  break a tie between the two contitutionally equivalent neighbors, */</a>
<a name="ln2480">                /*  refine the two partitions, sort neighbors lists nl1, nl2 */</a>
<a name="ln2481">                bSymmNeigh = BreakNeighborsTie(  at, num_atoms, num_at_tg, opposite_atom, i1,</a>
<a name="ln2482">                                    neigh, 0, 1, 0,</a>
<a name="ln2483">                                    pRankStack1, pRankStack2, nTempRank, NeighList, nSymmRank, nCanonRank,</a>
<a name="ln2484">                                    nl1, nl2, &amp;pCS-&gt;lNumNeighListIter );</a>
<a name="ln2485">                if ( bSymmNeigh &lt;= 0 ) {</a>
<a name="ln2486">                    if ( ret_failed &gt; bSymmNeigh )</a>
<a name="ln2487">                        ret_failed = bSymmNeigh;</a>
<a name="ln2488">                    continue;</a>
<a name="ln2489">                }</a>
<a name="ln2490">                nl01 = nl1;</a>
<a name="ln2491">                nl02 = nl2;</a>
<a name="ln2492">                nSymmRank1 = pRankStack1[0];</a>
<a name="ln2493">                nSymmRank2 = pRankStack2[0];</a>
<a name="ln2494">                break;</a>
<a name="ln2495">            default:</a>
<a name="ln2496">                return CT_STEREOCOUNT_ERR;  /*  &lt;BRKPT&gt; */</a>
<a name="ln2497">            }</a>
<a name="ln2498"> </a>
<a name="ln2499">            /*  initialize arrays */</a>
<a name="ln2500">            memset( nVisited1, 0, sizeof(nVisited1[0])*num_atoms );</a>
<a name="ln2501">            memset( nVisited2, 0, sizeof(nVisited2[0])*num_atoms );</a>
<a name="ln2502">            memset( nAtomNumberCanon1, 0, sizeof(nAtomNumberCanon1[0])*num_atoms );</a>
<a name="ln2503">            memset( nAtomNumberCanon2, 0, sizeof(nAtomNumberCanon2[0])*num_atoms );</a>
<a name="ln2504">            nLength       = 1;</a>
<a name="ln2505">            nVisited1[i1] = i1+1;   /*  start atoms are the same */</a>
<a name="ln2506">            nVisited2[i1] = i1+1;</a>
<a name="ln2507">            nAtomNumberCanon1[i1] = nLength;</a>
<a name="ln2508">            nAtomNumberCanon2[i1] = nLength;</a>
<a name="ln2509">            nAvoidCheckAtom[0] = i1;</a>
<a name="ln2510">            nAvoidCheckAtom[1] = opposite_atom;</a>
<a name="ln2511">            bParitiesInverted  = (nNeighMode == NEIGH_MODE_RING &amp;&amp;</a>
<a name="ln2512">                                  IS_ALLENE_CHAIN(at[i1].stereo_bond_parity[n1]) &amp;&amp;</a>
<a name="ln2513">                                  PARITY_CALCULATE(at[i1].stereo_bond_parity[n1]) &amp;&amp;</a>
<a name="ln2514">                                  at[i1].nRingSystem == at[opposite_atom].nRingSystem &amp;&amp;</a>
<a name="ln2515">                                  at[opposite_atom].valence==MAX_NUM_STEREO_BONDS)? -1 : 0;</a>
<a name="ln2516">            ret1 = ret2 = 0;</a>
<a name="ln2517">            if ( 0 &lt; (ret1=CreateCheckSymmPaths( at, (AT_RANK)i1, neigh[0], (AT_RANK)i1, neigh[1], nAvoidCheckAtom,</a>
<a name="ln2518">                                       nVisited1, nVisited2, nAtomNumberCanon1, nAtomNumberCanon2,</a>
<a name="ln2519">                                       nl01, nl02, nSymmRank1, nSymmRank2, nCanonRank, &amp;nLength, &amp;bParitiesInverted, 0 ) ) &amp;&amp;</a>
<a name="ln2520">                 0 &lt; (ret2=CalculatedPathsParitiesAreIdentical( at, num_atoms, nSymmRank,</a>
<a name="ln2521">                                       nCanonRank, nAtomNumberCanon, nAtomNumberCanon1, nAtomNumberCanon2,</a>
<a name="ln2522">                                       nVisited1, nVisited2, opposite_atom, (AT_RANK)i1,</a>
<a name="ln2523">                                       neigh[0], neigh[1], nNeighMode, bParitiesInverted, 0, </a>
<a name="ln2524">                                       pCS, vABParityUnknown ) ) ) {</a>
<a name="ln2525">                if ( ret2 &amp; ( NOT_WELL_DEF_UNKN | NOT_WELL_DEF_UNDF ) ) {</a>
<a name="ln2526">                    /*  possibly change the parity to unknown or undefined */</a>
<a name="ln2527">                    int new_parity = (ret2 &amp; NOT_WELL_DEF_UNKN)? vABParityUnknown /*AB_PARITY_UNKN*/: AB_PARITY_UNDF;</a>
<a name="ln2528">                    if ( (PARITY_ILL_DEF(at[i1].stereo_bond_parity[n1]) &amp;&amp; PARITY_VAL(at[i1].stereo_bond_parity[n1]) &gt; new_parity) ||</a>
<a name="ln2529">                         PARITY_CALCULATE(at[i1].stereo_bond_parity[n1]) ) {</a>
<a name="ln2530">                        /*  set new unknown or undefined parity */</a>
<a name="ln2531">                        SetOneStereoBondIllDefParity( at, i1, /* atom number*/ n1 /* stereo bond ord. number*/, new_parity );</a>
<a name="ln2532">                        /*  change in pCS */</a>
<a name="ln2533">                        nAtomRank1 = inchi_max( nCanonRank[i1], nCanonRank[opposite_atom]);</a>
<a name="ln2534">                        nAtomRank2 = inchi_min( nCanonRank[i1], nCanonRank[opposite_atom]);</a>
<a name="ln2535">                        for ( n = 0, m = pCS-&gt;nLenLinearCTStereoDble-1; n &lt;= m; n ++ ) {</a>
<a name="ln2536">                            if ( pCS-&gt;LinearCTStereoDble[n].at_num1 == nAtomRank1 &amp;&amp;</a>
<a name="ln2537">                                 pCS-&gt;LinearCTStereoDble[n].at_num2 == nAtomRank2 ) {</a>
<a name="ln2538">                                pCS-&gt;LinearCTStereoDble[n].parity = new_parity;</a>
<a name="ln2539">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2540">                                pCS-&gt;bExtract |= EXTR_CALC_USED_TO_REMOVE_PARITY;</a>
<a name="ln2541">#endif</a>
<a name="ln2542">                                m = -1;</a>
<a name="ln2543">                                break;</a>
<a name="ln2544">                            }</a>
<a name="ln2545">                        }</a>
<a name="ln2546">                        if ( m &gt;= 0 ) {</a>
<a name="ln2547">                            ret = CT_STEREOCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2548">                            goto exit_function;</a>
<a name="ln2549">                        }</a>
<a name="ln2550">                        ret ++;</a>
<a name="ln2551">                    }</a>
<a name="ln2552">                } else {</a>
<a name="ln2553">                    /*  remove the parity */</a>
<a name="ln2554">                    if ( !RemoveOneStereoBond( at, i1, /* atom number*/ n1 /* stereo bond ord. number*/ ) ) {</a>
<a name="ln2555">                        ret = CT_STEREOBOND_ERROR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2556">                        goto exit_function;</a>
<a name="ln2557">                    }</a>
<a name="ln2558">                    n1 --;  /*  cycle counter may temporarily become negative */</a>
<a name="ln2559">                    /*  Remove from the pCS */</a>
<a name="ln2560">                    nAtomRank1 = inchi_max( nCanonRank[i1], nCanonRank[opposite_atom]);</a>
<a name="ln2561">                    nAtomRank2 = inchi_min( nCanonRank[i1], nCanonRank[opposite_atom]);</a>
<a name="ln2562">                    for ( n = 0, m = pCS-&gt;nLenLinearCTStereoDble-1; n &lt;= m; n ++ ) {</a>
<a name="ln2563">                        if ( pCS-&gt;LinearCTStereoDble[n].at_num1 == nAtomRank1 &amp;&amp;</a>
<a name="ln2564">                             pCS-&gt;LinearCTStereoDble[n].at_num2 == nAtomRank2 ) {</a>
<a name="ln2565">                            if ( n &lt; m ) { /*  remove pCS-&gt;LinearCTStereoDble[n] */</a>
<a name="ln2566">                                memmove( pCS-&gt;LinearCTStereoDble + n,</a>
<a name="ln2567">                                         pCS-&gt;LinearCTStereoDble + n + 1,</a>
<a name="ln2568">                                         (m-n)*sizeof(pCS-&gt;LinearCTStereoDble[0]) );</a>
<a name="ln2569">                            }</a>
<a name="ln2570">                            pCS-&gt;nLenLinearCTStereoDble --;</a>
<a name="ln2571">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2572">                            pCS-&gt;bExtract |= EXTR_CALC_USED_TO_REMOVE_PARITY;</a>
<a name="ln2573">#endif</a>
<a name="ln2574">                            m = -1;</a>
<a name="ln2575">                            break;</a>
<a name="ln2576">                        }</a>
<a name="ln2577">                    }</a>
<a name="ln2578">                    if ( m &gt;= 0 ) {</a>
<a name="ln2579">                        ret = CT_STEREOCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2580">                        goto exit_function;</a>
<a name="ln2581">                    }</a>
<a name="ln2582">                    ret ++;</a>
<a name="ln2583">                }</a>
<a name="ln2584">            } else {</a>
<a name="ln2585">                if ( !ret_failed ) {</a>
<a name="ln2586">                    ret_failed = (ret1&lt;0)? ret1 : (ret2&lt;0)? ret2 : 0;</a>
<a name="ln2587">                }</a>
<a name="ln2588">                if ( !RETURNED_ERROR(ret_failed) ) {</a>
<a name="ln2589">                    if ( RETURNED_ERROR( ret1 ) )</a>
<a name="ln2590">                        ret_failed = ret1;</a>
<a name="ln2591">                    else</a>
<a name="ln2592">                    if ( RETURNED_ERROR( ret2 ) )</a>
<a name="ln2593">                        ret_failed = ret2;</a>
<a name="ln2594">                }</a>
<a name="ln2595">            }</a>
<a name="ln2596">        }</a>
<a name="ln2597">    }</a>
<a name="ln2598">    if ( nNeighMode == NEIGH_MODE_CHAIN &amp;&amp; nNumEqRingNeigh &amp;&amp; !RETURNED_ERROR(ret_failed) ) {</a>
<a name="ln2599">        nNeighMode = NEIGH_MODE_RING;</a>
<a name="ln2600">        goto second_pass;</a>
<a name="ln2601">    }</a>
<a name="ln2602"> </a>
<a name="ln2603">exit_function:</a>
<a name="ln2604"> </a>
<a name="ln2605">    return RETURNED_ERROR(ret_failed)? ret_failed : ret_failed? -(ret_failed+1) : ret;</a>
<a name="ln2606">}</a>
<a name="ln2607">/****************************************************************************/</a>
<a name="ln2608">/*  Remove stereo marks from the atoms that are calculated to be non-stereo */</a>
<a name="ln2609">/*  (can find two numberings that change only one stereo center parity)     */</a>
<a name="ln2610">int RemoveCalculatedNonStereoCenterParities( sp_ATOM *at, int num_atoms, int num_at_tg,</a>
<a name="ln2611">                                          AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln2612">                                          AT_RANK *nCanonRank, const AT_RANK *nSymmRank,</a>
<a name="ln2613">                                          AT_RANK *nAtomNumberCanon, AT_RANK *nAtomNumberCanon1, AT_RANK *nAtomNumberCanon2,</a>
<a name="ln2614">                                          NEIGH_LIST *nl, NEIGH_LIST *nl1, NEIGH_LIST *nl2, </a>
<a name="ln2615">                                          AT_RANK *nVisited1, AT_RANK *nVisited2, </a>
<a name="ln2616">                                          CANON_STAT *pCS,</a>
<a name="ln2617">                                          int vABParityUnknown)</a>
<a name="ln2618">{</a>
<a name="ln2619">    int j, n, m, ret;</a>
<a name="ln2620">    </a>
<a name="ln2621">    int i, k, ret1, ret2, ret_failed=0, mode, max_mode;</a>
<a name="ln2622">    AT_RANK nAtomRank1, neigh[MAX_NUM_STEREO_ATOM_NEIGH], nAvoidCheckAtom[2], nLength;</a>
<a name="ln2623">    int         nNeighMode = NEIGH_MODE_CHAIN;</a>
<a name="ln2624">    int         nNumEqRingNeigh = 0, bRingNeigh, bSymmNeigh, bParitiesInverted;</a>
<a name="ln2625">    NEIGH_LIST *nl01, *nl02;</a>
<a name="ln2626">    const AT_RANK    *nSymmRank1, *nSymmRank2;</a>
<a name="ln2627">    </a>
<a name="ln2628">    ret = 0;</a>
<a name="ln2629"> </a>
<a name="ln2630">second_pass:</a>
<a name="ln2631">    for ( i = 0; i &lt; num_atoms &amp;&amp; !RETURNED_ERROR(ret_failed); i ++ ) {</a>
<a name="ln2632">        if ( !at[i].parity || at[i].stereo_bond_neighbor[0] ) {</a>
<a name="ln2633">            continue;</a>
<a name="ln2634">        }</a>
<a name="ln2635">        if ( at[i].valence &gt; MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln2636">            continue; /*  error: stereo center cannot have more than 4 neighbors */ /*   &lt;BRKPT&gt; */</a>
<a name="ln2637">        }</a>
<a name="ln2638">        /*  at[i1] is a stereo center */</a>
<a name="ln2639">        if ( !PARITY_CALCULATE(at[i].stereo_atom_parity) &amp;&amp; !PARITY_ILL_DEF(at[i].stereo_atom_parity) ) {</a>
<a name="ln2640">            continue;</a>
<a name="ln2641">        }</a>
<a name="ln2642">        /* neighbors sorted according to symm. ranks (primary key) and canon. ranks (secondary key), in descending order */</a>
<a name="ln2643">        /* sorting guarantees that for two constit. equ. neighbors canon. ranks of the first is greater */</a>
<a name="ln2644">        /* !!! previously (but not anymore) the canon. rank of neigh[0] was greater than the others !!! */</a>
<a name="ln2645">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln2646">            neigh[j] = nl[i][j+1]; /*  sorting does NOT guarantee that canon. rank of neigh[0] is greater than others */</a>
<a name="ln2647">        }</a>
<a name="ln2648">        /* </a>
<a name="ln2649">         *  mode = 0 =&gt; Standard approach: switch 2 neighbors</a>
<a name="ln2650">         *         1 =&gt; Check for C2v reflection leading to parity inversion</a>
<a name="ln2651">         *         2 =&gt; Check for C2 rotation preserving parities</a>
<a name="ln2652">         *         3 =&gt; Check for S4 rotation/reflection leading to parity inversion</a>
<a name="ln2653">         */</a>
<a name="ln2654">#if ( CHECK_C2v_S4_SYMM == 1 )</a>
<a name="ln2655">        if ( nNeighMode = NEIGH_MODE_RING &amp;&amp; at[i].valence == 4 &amp;&amp;</a>
<a name="ln2656">             nSymmRank[(int)neigh[0]] == nSymmRank[(int)neigh[1]] &amp;&amp;</a>
<a name="ln2657">             nSymmRank[(int)neigh[2]] == nSymmRank[(int)neigh[3]] &amp;&amp;</a>
<a name="ln2658">             !at[i].bCutVertex </a>
<a name="ln2659">           ) {</a>
<a name="ln2660">            if ( nSymmRank[(int)neigh[1]] == nSymmRank[(int)neigh[2]] ) {</a>
<a name="ln2661">                max_mode = MAP_MODE_S4;</a>
<a name="ln2662">            } else {</a>
<a name="ln2663">                max_mode = inchi_max(MAP_MODE_C2v, MAP_MODE_C2);</a>
<a name="ln2664">            }</a>
<a name="ln2665">        } else {</a>
<a name="ln2666">            max_mode = MAP_MODE_STD;</a>
<a name="ln2667">        }</a>
<a name="ln2668">#else</a>
<a name="ln2669">        max_mode = MAP_MODE_STD;</a>
<a name="ln2670">#endif</a>
<a name="ln2671">        for ( j = 0; j &lt; at[i].valence &amp;&amp; at[i].parity &amp;&amp; !RETURNED_ERROR(ret_failed); j ++ ) {</a>
<a name="ln2672">            for ( k = j+1; k &lt; at[i].valence &amp;&amp; at[i].parity &amp;&amp; !RETURNED_ERROR(ret_failed); k ++ ) {</a>
<a name="ln2673">                for ( mode = 0; mode &lt;= max_mode &amp;&amp; at[i].parity &amp;&amp; !RETURNED_ERROR(ret_failed); mode ++ ) {</a>
<a name="ln2674">                    if ( nSymmRank[(int)neigh[j]] != nSymmRank[(int)neigh[k]] ) {</a>
<a name="ln2675">                        continue; /*  the two neighbors are not constitutionally identical */</a>
<a name="ln2676">                    }</a>
<a name="ln2677">                    bRingNeigh = (at[(int)neigh[j]].nRingSystem == at[(int)neigh[k]].nRingSystem);</a>
<a name="ln2678">                    switch ( nNeighMode ) {</a>
<a name="ln2679">                    case NEIGH_MODE_CHAIN:</a>
<a name="ln2680">                        if ( bRingNeigh ) {</a>
<a name="ln2681">                            nNumEqRingNeigh ++;</a>
<a name="ln2682">                            continue;</a>
<a name="ln2683">                        }</a>
<a name="ln2684">                        nl01 = nl;</a>
<a name="ln2685">                        nl02 = nl;</a>
<a name="ln2686">                        nSymmRank1 = nSymmRank;</a>
<a name="ln2687">                        nSymmRank2 = nSymmRank;</a>
<a name="ln2688">                        break;</a>
<a name="ln2689">                    case NEIGH_MODE_RING:</a>
<a name="ln2690">                        if ( !bRingNeigh )</a>
<a name="ln2691">                            continue;</a>
<a name="ln2692">                        /*  break a tie between the two contitutionally equivalent neighbors, */</a>
<a name="ln2693">                        /*  refine the two partitions, sort neighbors lists nl1, nl2 */</a>
<a name="ln2694">                        bSymmNeigh = BreakNeighborsTie(  at, num_atoms, num_at_tg, MAX_ATOMS+1, i,</a>
<a name="ln2695">                                            neigh, j, k, mode,</a>
<a name="ln2696">                                            pRankStack1, pRankStack2, nTempRank, NeighList, nSymmRank, nCanonRank,</a>
<a name="ln2697">                                            nl1, nl2, &amp;pCS-&gt;lNumNeighListIter );</a>
<a name="ln2698">                        if ( bSymmNeigh &lt;= 0 ) {</a>
<a name="ln2699">                            if ( ret_failed &gt; bSymmNeigh )</a>
<a name="ln2700">                                ret_failed = bSymmNeigh;</a>
<a name="ln2701">                            continue;</a>
<a name="ln2702">                        }</a>
<a name="ln2703">                        nl01 = nl1;</a>
<a name="ln2704">                        nl02 = nl2;</a>
<a name="ln2705">                        nSymmRank1 = pRankStack1[0];</a>
<a name="ln2706">                        nSymmRank2 = pRankStack2[0];</a>
<a name="ln2707">                        break;</a>
<a name="ln2708">                    default:</a>
<a name="ln2709">                        return CT_STEREOCOUNT_ERR;  /*  &lt;BRKPT&gt; */</a>
<a name="ln2710">                    }</a>
<a name="ln2711"> </a>
<a name="ln2712">                    /*  initialize arrays */</a>
<a name="ln2713">                    memset( nVisited1, 0, sizeof(nVisited1[0])*num_atoms );</a>
<a name="ln2714">                    memset( nVisited2, 0, sizeof(nVisited2[0])*num_atoms );</a>
<a name="ln2715">                    memset( nAtomNumberCanon1, 0, sizeof(nAtomNumberCanon1[0])*num_atoms );</a>
<a name="ln2716">                    memset( nAtomNumberCanon2, 0, sizeof(nAtomNumberCanon2[0])*num_atoms );</a>
<a name="ln2717">                    nLength = 1;</a>
<a name="ln2718">                    nVisited1[i] = i+1;   /*  start atom is same */</a>
<a name="ln2719">                    nVisited2[i] = i+1;</a>
<a name="ln2720">                    nAtomNumberCanon1[i] = nLength;</a>
<a name="ln2721">                    nAtomNumberCanon2[i] = nLength;</a>
<a name="ln2722">                    nAvoidCheckAtom[0] = i;</a>
<a name="ln2723">                    nAvoidCheckAtom[1] = MAX_ATOMS+1;</a>
<a name="ln2724">                </a>
<a name="ln2725">                    bParitiesInverted  = (mode==MAP_MODE_C2v || mode==MAP_MODE_S4)? -1 : 0;</a>
<a name="ln2726">                    /*</a>
<a name="ln2727">                    if (nNeighMode==NEIGH_MODE_RING &amp;&amp; at[i].valence==MAX_NUM_STEREO_ATOM_NEIGH) {</a>
<a name="ln2728">                        AT_RANK other_neigh[2];</a>
<a name="ln2729">                        int     n;</a>
<a name="ln2730">                        for ( m = n = 0; m &lt; MAX_NUM_STEREO_ATOM_NEIGH; m ++ ) {</a>
<a name="ln2731">                            if ( at[i].neighbor[m] != neigh[j] &amp;&amp; at[i].neighbor[m] != neigh[k] )</a>
<a name="ln2732">                                other_neigh[n++] = at[i].neighbor[m];</a>
<a name="ln2733">                        }</a>
<a name="ln2734">                        if ( nSymmRank[(int)other_neigh[0]] == nSymmRank[(int)other_neigh[1]] )</a>
<a name="ln2735">                            bParitiesInverted = -1;</a>
<a name="ln2736">                    }</a>
<a name="ln2737">                    */</a>
<a name="ln2738">                    /* allow matching inverted centers only in case all equivalent neighbors in same ring system */</a>
<a name="ln2739"> </a>
<a name="ln2740">                    ret2 = 0; /* initilize. 1/8/2002 */</a>
<a name="ln2741">                </a>
<a name="ln2742">                    if ( 0 &lt; (ret1 = CreateCheckSymmPaths( at, (AT_RANK)i, neigh[j], (AT_RANK)i, neigh[k],</a>
<a name="ln2743">                                               nAvoidCheckAtom,</a>
<a name="ln2744">                                               nVisited1, nVisited2, nAtomNumberCanon1, nAtomNumberCanon2,</a>
<a name="ln2745">                                               nl01, nl02, nSymmRank1, nSymmRank2, nCanonRank, &amp;nLength,</a>
<a name="ln2746">                                               &amp;bParitiesInverted, mode ) ) &amp;&amp;</a>
<a name="ln2747">                         0 &lt; (ret2 = CalculatedPathsParitiesAreIdentical( at, num_atoms, nSymmRank,</a>
<a name="ln2748">                                               nCanonRank, nAtomNumberCanon, nAtomNumberCanon1, nAtomNumberCanon2,</a>
<a name="ln2749">                                               nVisited1, nVisited2, (AT_RANK)MAX_ATOMS, (AT_RANK)i,</a>
<a name="ln2750">                                               neigh[j], neigh[k], nNeighMode, </a>
<a name="ln2751">                                               bParitiesInverted, mode, pCS,</a>
<a name="ln2752">                                               vABParityUnknown) ) ) {</a>
<a name="ln2753">                        if ( ret2 &amp; ( NOT_WELL_DEF_UNKN | NOT_WELL_DEF_UNDF ) ) {</a>
<a name="ln2754">                            /*  possibly change the parity to unknown or undefined */</a>
<a name="ln2755">                            int new_parity = (ret2 &amp; NOT_WELL_DEF_UNKN)? vABParityUnknown /*AB_PARITY_UNKN*/: AB_PARITY_UNDF;</a>
<a name="ln2756">                            if ( (PARITY_ILL_DEF(at[i].stereo_atom_parity) &amp;&amp;</a>
<a name="ln2757">                                 PARITY_VAL(at[i].stereo_atom_parity) &gt; new_parity) ||</a>
<a name="ln2758">                                 PARITY_CALCULATE(at[i].stereo_atom_parity) ) {</a>
<a name="ln2759">                                /*  set new unknown or undefined parity */</a>
<a name="ln2760">                                at[i].stereo_atom_parity = (at[i].stereo_atom_parity ^ PARITY_VAL(at[i].stereo_atom_parity)) | PARITY_VAL(new_parity);</a>
<a name="ln2761">                                at[i].parity = PARITY_VAL(new_parity);</a>
<a name="ln2762">                                /*  Remove from pCS */</a>
<a name="ln2763">                                nAtomRank1 = nCanonRank[i];</a>
<a name="ln2764">                                for ( n = 0, m = pCS-&gt;nLenLinearCTStereoCarb-1; n &lt;= m; n ++ ) {</a>
<a name="ln2765">                                    if ( pCS-&gt;LinearCTStereoCarb[n].at_num == nAtomRank1 ) {</a>
<a name="ln2766">                                        pCS-&gt;LinearCTStereoCarb[n].parity = PARITY_VAL(new_parity);</a>
<a name="ln2767">    #if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2768">                                        pCS-&gt;bExtract |= EXTR_CALC_USED_TO_REMOVE_PARITY;</a>
<a name="ln2769">    #endif</a>
<a name="ln2770">                                        m = -1;</a>
<a name="ln2771">                                        break;</a>
<a name="ln2772">                                    }</a>
<a name="ln2773">                                }</a>
<a name="ln2774">                                if ( m &gt;= 0 ) {</a>
<a name="ln2775">                                    ret = CT_STEREOCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2776">                                    goto exit_function;</a>
<a name="ln2777">                                }</a>
<a name="ln2778">                                ret ++; /*  number of removed or set unknown/undefined parities */</a>
<a name="ln2779">                            }</a>
<a name="ln2780">                        } else {</a>
<a name="ln2781">                            RemoveOneStereoCenter( at, i /* atom number*/ );</a>
<a name="ln2782">                            /*  Remove from pCS */</a>
<a name="ln2783">                            nAtomRank1 = nCanonRank[i];</a>
<a name="ln2784">                            for ( n = 0, m = pCS-&gt;nLenLinearCTStereoCarb-1; n &lt;= m; n ++ ) {</a>
<a name="ln2785">                                if ( pCS-&gt;LinearCTStereoCarb[n].at_num == nAtomRank1 ) {</a>
<a name="ln2786">                                    if ( n &lt; m ) { /*  remove pCS-&gt;LinearCTStereoDble[n] */</a>
<a name="ln2787">                                        memmove( pCS-&gt;LinearCTStereoCarb + n,</a>
<a name="ln2788">                                                 pCS-&gt;LinearCTStereoCarb + n + 1,</a>
<a name="ln2789">                                                 (m-n)*sizeof(pCS-&gt;LinearCTStereoCarb[0]) );</a>
<a name="ln2790">                                    }</a>
<a name="ln2791">                                    pCS-&gt;nLenLinearCTStereoCarb --;</a>
<a name="ln2792">    #if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2793">                                    pCS-&gt;bExtract |= EXTR_CALC_USED_TO_REMOVE_PARITY;</a>
<a name="ln2794">    #endif</a>
<a name="ln2795">                                    m = -1;</a>
<a name="ln2796">                                    break;</a>
<a name="ln2797">                                }</a>
<a name="ln2798">                            }</a>
<a name="ln2799">                            if ( m &gt;= 0 ) {</a>
<a name="ln2800">                                ret = CT_STEREOCOUNT_ERR;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2801">                                goto exit_function;</a>
<a name="ln2802">                            }</a>
<a name="ln2803">                            ret ++;  /*  number of removed or set unknown/undefined parities */</a>
<a name="ln2804">                        }</a>
<a name="ln2805">                    } else {</a>
<a name="ln2806">                        if ( !ret_failed ) {</a>
<a name="ln2807">                            if ( ret1 &lt; 0 ) {</a>
<a name="ln2808">                                ret_failed = ret1;</a>
<a name="ln2809">                            } else</a>
<a name="ln2810">                            if ( ret2 &lt; 0 ) {</a>
<a name="ln2811">                                ret_failed = ret2;</a>
<a name="ln2812">                            }</a>
<a name="ln2813">                        }</a>
<a name="ln2814">                        if ( !RETURNED_ERROR(ret_failed) ) {</a>
<a name="ln2815">                            if ( RETURNED_ERROR( ret1 ) )</a>
<a name="ln2816">                                ret_failed = ret1;</a>
<a name="ln2817">                            else</a>
<a name="ln2818">                            if ( RETURNED_ERROR( ret2 ) )</a>
<a name="ln2819">                                ret_failed = ret2;</a>
<a name="ln2820">                        }</a>
<a name="ln2821">                    }</a>
<a name="ln2822">                }</a>
<a name="ln2823">            }</a>
<a name="ln2824">        }</a>
<a name="ln2825">    }</a>
<a name="ln2826">    if ( nNeighMode == NEIGH_MODE_CHAIN &amp;&amp; nNumEqRingNeigh &amp;&amp; !RETURNED_ERROR(ret_failed) ) {</a>
<a name="ln2827">        nNeighMode = NEIGH_MODE_RING;</a>
<a name="ln2828">        goto second_pass;</a>
<a name="ln2829">    }</a>
<a name="ln2830"> </a>
<a name="ln2831">exit_function:</a>
<a name="ln2832"> </a>
<a name="ln2833">    return RETURNED_ERROR(ret_failed)? ret_failed : ret_failed? -(ret+1) : ret;</a>
<a name="ln2834">}</a>
<a name="ln2835"> </a>
<a name="ln2836">/**************************************************************************************/</a>
<a name="ln2837">int RemoveCalculatedNonStereo( sp_ATOM *at, int num_atoms, int num_at_tg,</a>
<a name="ln2838">                              AT_RANK **pRankStack1, AT_RANK **pRankStack2, AT_RANK *nTempRank, NEIGH_LIST *NeighList,</a>
<a name="ln2839">                              const AT_RANK *nSymmRank, AT_RANK *nCanonRank, </a>
<a name="ln2840">                              AT_RANK *nAtomNumberCanon, CANON_STAT *pCS,</a>
<a name="ln2841">                              int vABParityUnknown)</a>
<a name="ln2842">{</a>
<a name="ln2843">    NEIGH_LIST *nl = NULL, *nl1 = NULL, *nl2 = NULL;</a>
<a name="ln2844">    AT_RANK    *nVisited1 = NULL, *nVisited2 = NULL, *nAtomNumberCanon1 = NULL, *nAtomNumberCanon2 = NULL;</a>
<a name="ln2845">    int        nNumRemoved = 0, nTotRemoved = 0, ret = 0, ret1 = 0, ret2 = 0;</a>
<a name="ln2846">    </a>
<a name="ln2847">    if ( !AllocateForNonStereoRemoval( at, num_atoms, nSymmRank, nCanonRank,</a>
<a name="ln2848">                                       &amp;nAtomNumberCanon1, &amp;nAtomNumberCanon2,</a>
<a name="ln2849">                                       &amp;nl, &amp;nl1, &amp;nl2, &amp;nVisited1, &amp;nVisited2 ) ) {</a>
<a name="ln2850">        return CT_OUT_OF_RAM;  /*   &lt;BRKPT&gt; */</a>
<a name="ln2851">    }</a>
<a name="ln2852">    </a>
<a name="ln2853">    do {</a>
<a name="ln2854">        nNumRemoved = 0;</a>
<a name="ln2855">        /*  bonds */</a>
<a name="ln2856">        ret = RemoveCalculatedNonStereoBondParities( at, num_atoms, num_at_tg,</a>
<a name="ln2857">                                              pRankStack1, pRankStack2, nTempRank, NeighList,</a>
<a name="ln2858">                                              nCanonRank, nSymmRank,</a>
<a name="ln2859">                                              nAtomNumberCanon, nAtomNumberCanon1, nAtomNumberCanon2,</a>
<a name="ln2860">                                              nl, nl1, nl2, nVisited1, nVisited2, pCS,</a>
<a name="ln2861">                                              vABParityUnknown);</a>
<a name="ln2862">        if ( RETURNED_ERROR( ret ) ) {</a>
<a name="ln2863">            goto exit_function;</a>
<a name="ln2864">        }</a>
<a name="ln2865">        if ( ret &lt; 0  ) {</a>
<a name="ln2866">            if ( ret &lt; ret1 ) {  /*   &lt;BRKPT&gt; */</a>
<a name="ln2867">                ret1 = ret;          </a>
<a name="ln2868">            }</a>
<a name="ln2869">            ret = - ( ret + 1 ); /*  number of removed */</a>
<a name="ln2870">        }</a>
<a name="ln2871">        nNumRemoved += ret;</a>
<a name="ln2872"> </a>
<a name="ln2873">        /*  centers */</a>
<a name="ln2874">        ret = RemoveCalculatedNonStereoCenterParities( at, num_atoms, num_at_tg,</a>
<a name="ln2875">                                              pRankStack1, pRankStack2, nTempRank, NeighList,</a>
<a name="ln2876">                                              nCanonRank, nSymmRank,</a>
<a name="ln2877">                                              nAtomNumberCanon, nAtomNumberCanon1, nAtomNumberCanon2,</a>
<a name="ln2878">                                              nl, nl1, nl2, nVisited1, nVisited2, pCS,</a>
<a name="ln2879">                                              vABParityUnknown);</a>
<a name="ln2880">        if ( RETURNED_ERROR( ret ) ) {</a>
<a name="ln2881">            goto exit_function;</a>
<a name="ln2882">        }</a>
<a name="ln2883">        if ( ret &lt; 0  ) {</a>
<a name="ln2884">            if ( ret &lt; ret2 ) {  /*   &lt;BRKPT&gt; */</a>
<a name="ln2885">                ret2 = ret;          </a>
<a name="ln2886">            }</a>
<a name="ln2887">            ret = - ( ret + 1 ); /*  number of removed */</a>
<a name="ln2888">        }</a>
<a name="ln2889">        nNumRemoved += ret;</a>
<a name="ln2890"> </a>
<a name="ln2891">        nTotRemoved += nNumRemoved;</a>
<a name="ln2892"> </a>
<a name="ln2893">    } while ( nNumRemoved );</a>
<a name="ln2894"> </a>
<a name="ln2895">    if ( !RETURNED_ERROR( ret1 ) &amp;&amp; !RETURNED_ERROR( ret2 ) ) {</a>
<a name="ln2896">        ret = inchi_min( ret1, ret2 );</a>
<a name="ln2897">        ret = (ret &gt;= 0)? nTotRemoved : -(1+nTotRemoved);</a>
<a name="ln2898">    }</a>
<a name="ln2899"> </a>
<a name="ln2900">exit_function:</a>
<a name="ln2901">    </a>
<a name="ln2902">    DeAllocateForNonStereoRemoval( &amp;nAtomNumberCanon1, &amp;nAtomNumberCanon2, &amp;nl, &amp;nl1, &amp;nl2, &amp;nVisited1, &amp;nVisited2 );</a>
<a name="ln2903">    </a>
<a name="ln2904">    return ret;</a>
<a name="ln2905">}</a>
<a name="ln2906">#endif /* } REMOVE_CALC_NONSTEREO */</a>

</code></pre>
<div class="balloon" rel="430"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'nNumCurrRanks' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="461"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'nNumCurrRanks' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: iNeigh < 0.</p></div>
<div class="balloon" rel="1005"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'nNeighRankToCanon' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="1348"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'mode == 2' is always true.</p></div>
<div class="balloon" rel="2070"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !bCurRotated.</p></div>
<div class="balloon" rel="2725"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: mode == 1.</p></div>
<div class="balloon" rel="2725"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: mode == 3.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichi_bns.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;ichierr.h&quot;</a>
<a name="ln48">#include &quot;incomdef.h&quot; </a>
<a name="ln49">#include &quot;inpdef.h&quot;</a>
<a name="ln50">#include &quot;extr_ct.h&quot;</a>
<a name="ln51">#include &quot;ichitaut.h&quot;</a>
<a name="ln52">#include &quot;ichinorm.h&quot;</a>
<a name="ln53">#include &quot;util.h&quot;</a>
<a name="ln54">#include &quot;ichicomp.h&quot;</a>
<a name="ln55">#include &quot;ichister.h&quot;</a>
<a name="ln56">#include &quot;ichi_bns.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58"> </a>
<a name="ln59">#define BNS_MARK_ONLY_BLOCKS        1  /* 1 =&gt; find only blocks, do not search for ring systems */</a>
<a name="ln60">#define ALLOW_ONLY_SIMPLE_ALT_PATH  0  /* 0 =&gt; allow alt. path to contain same bond 2 times (in opposite directions) */</a>
<a name="ln61">#define CHECK_TG_ALT_PATH           0  /* 1=&gt; when chacking alt path of a tautomeric atom modify</a>
<a name="ln62">                                              t-group, not the atom */</a>
<a name="ln63">                                       /* 0=&gt; old mode */</a>
<a name="ln64"> </a>
<a name="ln65">#define FIX_CPOINT_BOND_CAP         1  /* 1=&gt; fix bug in case of double bond from neutral cpoint */</a>
<a name="ln66">#define RESET_EDGE_FORBIDDEN_MASK   1  /* 1: previous; 0: do not apply &quot;edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask&quot; */</a>
<a name="ln67">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln68">#define IS_FORBIDDEN(EDGE_FORBIDDEN, PBNS)     (EDGE_FORBIDDEN)</a>
<a name="ln69">#else</a>
<a name="ln70">#define IS_FORBIDDEN(EDGE_FORBIDDEN, PBNS)     (EDGE_FORBIDDEN &amp; PBNS-&gt;edge_forbidden_mask)</a>
<a name="ln71">#endif</a>
<a name="ln72">                                       </a>
<a name="ln73"> </a>
<a name="ln74">typedef enum tagAtTypeTotals </a>
<a name="ln75">{</a>
<a name="ln76">    /* counts do not include:</a>
<a name="ln77">       charged atom adjacent to another charged atom</a>
<a name="ln78">       atom in an unusual valence state or adjacent to an atom in an unusual valence state</a>
<a name="ln79">       radicals different from singlet</a>
<a name="ln80">    */</a>
<a name="ln81">    /*ATTOT_NUM_Plus. */    /* number of positive charges, +1, is (ATTOT_NUM_CHARGES + ATTOT_TOT_CHARGE)/2 */</a>
<a name="ln82">    /*ATTOT_NUM_Minus.*/    /* number of negative charges, -1, is (ATTOT_NUM_CHARGES - ATTOT_TOT_CHARGE)/2 */</a>
<a name="ln83">    ATTOT_NUM_NP_Plus,    /*  0 no H: =N(+)=, #N(+)-, =N(+)&lt;, does not include onium cations &gt;P(+)&lt;, &gt;N(+)&lt; */</a>
<a name="ln84">    ATTOT_NUM_NP_Proton,  /*  1 H(+): -NH3(+), =NH2(+), &gt;NH2(+), =NH(+)-, &gt;NH(+)-, #NH(+), N=N,P */</a>
<a name="ln85">    ATTOT_NUM_NP_H,       /*  2 H:    -NH2, =NH, &gt;NH -NH(-) */</a>
<a name="ln86">    ATTOT_NUM_N_Minus,    /*  3 (-):  -NH(-), &gt;N(-), =N(-) */</a>
<a name="ln87">    ATTOT_NUM_NP,         /*  4 no H: &gt;N- =N-, #N  */</a>
<a name="ln88">    ATTOT_NUM_ON,         /*  5 -N=O: do not allow -N=O =&gt; -NH-OH during H(+) add/removal */</a>
<a name="ln89">    ATTOT_NUM_COH,        /*  6 =C-OH, #C-OH; O=O,S,Se,Te */</a>
<a name="ln90">    ATTOT_NUM_CSH,        /*  7 -C-SH, -C-SeH -C-TeH  */</a>
<a name="ln91">    ATTOT_NUM_ZOH,        /*  8 =Z-OH, #Z-OH; O=O,S,Se,Te; Z may have charge, Z != C */</a>
<a name="ln92">    ATTOT_NUM_OOH,        /*  9  -O-OH, O=O,S,Se,Te */</a>
<a name="ln93">    ATTOT_NUM_ZOOH,       /* 10  O=Z-OH, O=O,S,Se,Te */</a>
<a name="ln94">    ATTOT_NUM_NOH,        /* 11  =N-OH, -N(-)-OH */</a>
<a name="ln95">    ATTOT_NUM_N_OH,       /* 12 &gt;N-OH, -NH-OH, &gt;NH(+)-OH, -N(-)-OH */</a>
<a name="ln96">    ATTOT_NUM_CO,         /* 13 -C=O, =C=O; O=O,S,Se,Te  */</a>
<a name="ln97">    ATTOT_NUM_ZO,         /* 14 -Z=O, =Z=O; O=O,S,Se,Te; Z may have charge  */</a>
<a name="ln98">    ATTOT_NUM_NO,         /* 15 -N=O, =N(+)=O */</a>
<a name="ln99">    ATTOT_NUM_N_O,        /* 16  &gt;N(+)=O, =N(+)=O */</a>
<a name="ln100">    ATTOT_NUM_CO_Minus,   /* 17 =C-O(-), #C-O(-); O=O,S,Se,Te  */</a>
<a name="ln101">    ATTOT_NUM_CS_Minus,   /* 18 -C-S(-); S = S, Se, Te */</a>
<a name="ln102">    ATTOT_NUM_ZO_Minus,   /* 19 =Z-O(-), #Z-O(-); O = O, S, Se, Te */</a>
<a name="ln103">    ATTOT_NUM_OO_Minus,   /* 20 -O-O(-), O=O,S,Se,Te */</a>
<a name="ln104">    ATTOT_NUM_ZOO_Minus,  /* 21 O=Z-O(-), O=O,S,Se,Te */</a>
<a name="ln105">    ATTOT_NUM_NO_Minus,   /* 22 &gt;N-O(-), -NH-O(-) */</a>
<a name="ln106">    ATTOT_NUM_N_O_Minus,  /* 23 -NH-O(-), &gt;N-O(-); O = O, S, Se, Te */</a>
<a name="ln107">    ATTOT_NUM_O_Minus,    /* 24 -Z-O(-); O=O,S,Se,Te */</a>
<a name="ln108">    ATTOT_NUM_OH_Plus,    /* 25 any OH(+) */</a>
<a name="ln109">    ATTOT_NUM_O_Plus,     /* 26 any O(+) without H */</a>
<a name="ln110">    ATTOT_NUM_Proton,     /* 27 proton */</a>
<a name="ln111">    ATTOT_NUM_HalAnion,   /* 28 Halogen anion */</a>
<a name="ln112">    ATTOT_NUM_HalAcid,    /* 29 Halogen acid */</a>
<a name="ln113">    ATTOT_NUM_Errors,     /* 30 for debugging */</a>
<a name="ln114">    ATTOT_TOT_CHARGE,     /* 31 total of positive and negative single charges, +1 and -1 */</a>
<a name="ln115">    ATTOT_NUM_CHARGES,    /* 32 number of positive and negative single charges, +1 and -1 */</a>
<a name="ln116">    ATTOT_ARRAY_LEN       /* 33 array length */</a>
<a name="ln117">} AT_TYPE_TOTALS;</a>
<a name="ln118">    </a>
<a name="ln119">#define ATBIT_NP_Plus    (1 &lt;&lt; ATTOT_NUM_NP_Plus)  </a>
<a name="ln120">#define ATBIT_NP_Proton  (1 &lt;&lt; ATTOT_NUM_NP_Proton)</a>
<a name="ln121">#define ATBIT_NP_H       (1 &lt;&lt; ATTOT_NUM_NP_H)     </a>
<a name="ln122">#define ATBIT_N_Minus    (1 &lt;&lt; ATTOT_NUM_N_Minus)  </a>
<a name="ln123">#define ATBIT_NP         (1 &lt;&lt; ATTOT_NUM_NP)</a>
<a name="ln124">#define ATBIT_ON         (1 &lt;&lt; ATTOT_NUM_ON)</a>
<a name="ln125">#define ATBIT_COH        (1 &lt;&lt; ATTOT_NUM_COH)      </a>
<a name="ln126">#define ATBIT_CSH        (1 &lt;&lt; ATTOT_NUM_CSH)      </a>
<a name="ln127">#define ATBIT_ZOH        (1 &lt;&lt; ATTOT_NUM_ZOH)      </a>
<a name="ln128">#define ATBIT_OOH        (1 &lt;&lt; ATTOT_NUM_OOH)</a>
<a name="ln129">#define ATBIT_ZOOH       (1 &lt;&lt; ATTOT_NUM_ZOOH)</a>
<a name="ln130">#define ATBIT_NOH        (1 &lt;&lt; ATTOT_NUM_NOH)</a>
<a name="ln131">#define ATBIT_N_OH       (1 &lt;&lt; ATTOT_NUM_N_OH)</a>
<a name="ln132">#define ATBIT_CO         (1 &lt;&lt; ATTOT_NUM_CO)       </a>
<a name="ln133">#define ATBIT_ZO         (1 &lt;&lt; ATTOT_NUM_ZO)</a>
<a name="ln134">#define ATBIT_NO         (1 &lt;&lt; ATTOT_NUM_NO)</a>
<a name="ln135">#define ATBIT_N_O        (1 &lt;&lt; ATTOT_NUM_N_O)</a>
<a name="ln136">#define ATBIT_CO_Minus   (1 &lt;&lt; ATTOT_NUM_CO_Minus) </a>
<a name="ln137">#define ATBIT_CS_Minus   (1 &lt;&lt; ATTOT_NUM_CS_Minus) </a>
<a name="ln138">#define ATBIT_ZO_Minus   (1 &lt;&lt; ATTOT_NUM_ZO_Minus)</a>
<a name="ln139">#define ATBIT_OO_Minus   (1 &lt;&lt; ATTOT_NUM_OO_Minus)</a>
<a name="ln140">#define ATBIT_ZOO_Minus  (1 &lt;&lt; ATTOT_NUM_ZOO_Minus)</a>
<a name="ln141">#define ATBIT_NO_Minus   (1 &lt;&lt; ATTOT_NUM_NO_Minus)</a>
<a name="ln142">#define ATBIT_N_O_Minus  (1 &lt;&lt; ATTOT_NUM_N_O_Minus)</a>
<a name="ln143">#define ATBIT_O_Minus    (1 &lt;&lt; ATTOT_NUM_O_Minus)</a>
<a name="ln144">#define ATBIT_OH_Plus    (1 &lt;&lt; ATTOT_NUM_OH_Plus)</a>
<a name="ln145">#define ATBIT_O_Plus     (1 &lt;&lt; ATTOT_NUM_O_Plus) </a>
<a name="ln146">#define ATBIT_Proton     (1 &lt;&lt; ATTOT_NUM_Proton)</a>
<a name="ln147">#define ATBIT_HalAnion   (1 &lt;&lt; ATTOT_NUM_HalAnion) </a>
<a name="ln148">#define ATBIT_HalAcid    (1 &lt;&lt; ATTOT_NUM_HalAcid) </a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">#define ATBIT_Errors     (1 &lt;&lt; ATTOT_NUM_Errors)   </a>
<a name="ln152"> </a>
<a name="ln153">typedef struct tagProtonRemovalMaskAndType </a>
<a name="ln154">{</a>
<a name="ln155">    int typePos;  /* atoms accessible to positive charges */</a>
<a name="ln156">    int maskPos; </a>
<a name="ln157">    int typeNeg; /* atoms accessible to negative charges */</a>
<a name="ln158">    int maskNeg; </a>
<a name="ln159">    int typeH;     /* atoms accessible to hydrogen atoms */</a>
<a name="ln160">    int maskH; </a>
<a name="ln161">} PRMAT;</a>
<a name="ln162"> </a>
<a name="ln163">#define PR_SIMPLE_MSK  (ATBIT_NP_Proton | ATBIT_OH_Plus)</a>
<a name="ln164">#define PR_SIMPLE_TYP  (ATT_ATOM_N | ATT_ATOM_P | ATT_O_PLUS)</a>
<a name="ln165"> </a>
<a name="ln166">#define ATBIT_MSK_NP   (ATBIT_NP_Plus | ATBIT_NP_Proton | ATBIT_NP_H | ATBIT_N_Minus | ATBIT_NP)</a>
<a name="ln167">#define KNOWN_ACIDIC_TYPE   (ATT_ACIDIC_CO | ATT_ACIDIC_S | ATT_OO | ATT_ZOO | ATT_NO)</a>
<a name="ln168">#define ATBIT_MSK_OS   (ATBIT_COH | ATBIT_CSH | ATBIT_ZOH | ATBIT_OOH | ATBIT_ZOOH | ATBIT_NOH | ATBIT_N_OH |\</a>
<a name="ln169">                        ATBIT_CO | ATBIT_ZO  | ATBIT_NO | ATBIT_N_O |\</a>
<a name="ln170">                        ATBIT_CO_Minus | ATBIT_CS_Minus | ATBIT_ZO_Minus | ATBIT_OO_Minus |\</a>
<a name="ln171">                        ATBIT_ZOO_Minus | ATBIT_NO_Minus | ATBIT_N_O_Minus /*| ATBIT_O_Minus*/ )</a>
<a name="ln172">#define ATBIT_MSK_H    (ATBIT_NP_Proton | ATBIT_NP_H | ATBIT_COH | ATBIT_CSH | ATBIT_ZOH | ATBIT_OOH |\</a>
<a name="ln173">                        ATBIT_ZOOH | ATBIT_NOH | ATBIT_N_OH)</a>
<a name="ln174"> </a>
<a name="ln175">#define ATTYP_OS    (ATT_ACIDIC_CO | ATT_ACIDIC_S | ATT_OO | ATT_ZOO | ATT_NO /*| ATT_OTHER_NEG_O*/ | ATT_OTHER_ZO)</a>
<a name="ln176">#define ATTYP_NP    (ATT_ATOM_N | ATT_ATOM_P)</a>
<a name="ln177">#define ATTYP_N     (ATT_ATOM_N)</a>
<a name="ln178">#define ATTYP_P     (ATT_ATOM_P)</a>
<a name="ln179"> </a>
<a name="ln180">/************* simple proton removal from acids **************************/</a>
<a name="ln181">#define AR_ANY_OH       0  /* 1 =&gt; create unknown to be acidic anions */</a>
<a name="ln182">#define AR_SIMPLE_STEPS 3</a>
<a name="ln183">/* acidic groups for proton removal, step 1 */</a>
<a name="ln184">#define AR_SIMPLE_MSK1  (ATBIT_COH | ATBIT_CSH | ATBIT_OOH | ATBIT_ZOOH | ATBIT_NOH | ATBIT_HalAcid)</a>
<a name="ln185">#define AR_SIMPLE_TYP1  (ATT_ACIDIC_CO | ATT_ACIDIC_S | ATT_OO | ATT_ZOO | ATT_NO | ATT_HalAcid)</a>
<a name="ln186">/* acidic groups for proton removal, step 2 */</a>
<a name="ln187">#define AR_SIMPLE_MSK2  (AR_ANY_OH? (ATBIT_N_OH)  :0)</a>
<a name="ln188">#define AR_SIMPLE_TYP2  (AR_ANY_OH? (ATT_N_O)     :0)</a>
<a name="ln189">/* acidic groups for proton removal, step 3 */</a>
<a name="ln190">#define AR_SIMPLE_MSK3  (AR_ANY_OH? (ATBIT_ZOH)   :0)</a>
<a name="ln191">#define AR_SIMPLE_TYP3  (AR_ANY_OH? (ATT_OTHER_ZO):0)</a>
<a name="ln192"> </a>
<a name="ln193">/************* simple proton addition to acids **************************/</a>
<a name="ln194">#define AA_ANY_O_Minus  0  /* 1 =&gt; neutralize unknown to be acidic anions */</a>
<a name="ln195">#define AA_SIMPLE_STEPS 3</a>
<a name="ln196">/* acidic groups for proton addition, step 1 */</a>
<a name="ln197">#define AA_SIMPLE_MSK1  (ATBIT_CO_Minus | ATBIT_CS_Minus | ATBIT_OO_Minus | ATBIT_ZOO_Minus | ATBIT_NO_Minus | ATBIT_O_Minus | ATBIT_HalAnion)</a>
<a name="ln198">#define AA_SIMPLE_TYP1  (ATT_ACIDIC_CO | ATT_ACIDIC_S | ATT_OO | ATT_ZOO | ATT_NO | ATT_OH_MINUS | ATT_HalAnion )</a>
<a name="ln199">/* acidic groups for proton addition, step 2 */</a>
<a name="ln200">#define AA_SIMPLE_MSK2  (AA_ANY_O_Minus? (ATBIT_N_O_Minus)               :0)</a>
<a name="ln201">#define AA_SIMPLE_TYP2  (AA_ANY_O_Minus? (ATT_N_O)                       :0)</a>
<a name="ln202">/* acidic groups for proton addition, step 3 */</a>
<a name="ln203">#define AA_SIMPLE_MSK3  (AA_ANY_O_Minus? (ATBIT_ZO_Minus | ATBIT_O_Minus):0)</a>
<a name="ln204">#define AA_SIMPLE_TYP3  (AA_ANY_O_Minus? (ATT_OTHER_ZO)                  :0)</a>
<a name="ln205"> </a>
<a name="ln206">#if ( FIX_NP_MINUS_BUG == 1 )</a>
<a name="ln207">/* allow to add H(+) to =N(-) which previously was #N */</a>
<a name="ln208">#undef AA_SIMPLE_STEPS</a>
<a name="ln209">#define AA_SIMPLE_STEPS 4</a>
<a name="ln210">#define AA_SIMPLE_MSK4  ATBIT_N_Minus</a>
<a name="ln211">#define AA_SIMPLE_TYP4  ATT_NP_MINUS_V23</a>
<a name="ln212">#endif</a>
<a name="ln213"> </a>
<a name="ln214">/************* hard proton removal from NP **************************/</a>
<a name="ln215">/* (+) charge group for proton removal: mask &amp; type */</a>
<a name="ln216">#define PR_HARD_MSK_POS   ATBIT_MSK_NP</a>
<a name="ln217">#define PR_HARD_TYP_POS   ATTYP_N</a>
<a name="ln218">#define PR_HARD_TYP_POSP  ATTYP_P</a>
<a name="ln219">/* (-) charge group for proton removal */</a>
<a name="ln220">#define PR_HARD_MSK_NEG   (ATBIT_MSK_NP | ATBIT_MSK_OS)</a>
<a name="ln221">#define PR_HARD_TYP_NEG   (ATTYP_N | ATTYP_OS)</a>
<a name="ln222">/* H-group for proton removal */</a>
<a name="ln223">#define PR_HARD_MSK_H     (ATBIT_MSK_NP | ATBIT_MSK_OS)</a>
<a name="ln224">#define PR_HARD_TYP_H     (ATTYP_N | ATTYP_OS)</a>
<a name="ln225"> </a>
<a name="ln226">/************* hard proton removal from acids **************************/</a>
<a name="ln227">/* (+) charge group for proton removal: mask &amp; type */</a>
<a name="ln228">#define AR_HARD_MSK_POS   ATBIT_MSK_NP</a>
<a name="ln229">#define AR_HARD_TYP_POS   ATTYP_N</a>
<a name="ln230">/* (-) charge group for proton removal */</a>
<a name="ln231">#define AR_HARD_MSK_NEG   (ATBIT_MSK_NP | ATBIT_MSK_OS)</a>
<a name="ln232">#define AR_HARD_TYP_NEG   (ATTYP_N | ATTYP_OS)</a>
<a name="ln233">/* H-group acid for proton removal */</a>
<a name="ln234">#define AR_HARD_MSK_HA    (ATBIT_CO | ATBIT_NO )</a>
<a name="ln235">#define AR_HARD_TYP_HA    (ATT_ACIDIC_CO | ATT_NO)</a>
<a name="ln236">/* H-group non-acid for proton removal */</a>
<a name="ln237">#define AR_HARD_MSK_HN    ((ATBIT_MSK_NP | ATBIT_MSK_OS) &amp; ~AR_HARD_MSK_HA)</a>
<a name="ln238">#define AR_HARD_TYP_HN    ((ATTYP_N | ATTYP_OS) /*&amp; ~AR_HARD_TYP_HA*/)</a>
<a name="ln239"> </a>
<a name="ln240">/************* hard proton addition to acids **************************/</a>
<a name="ln241">/* (+) charge group for proton removal: mask &amp; type */</a>
<a name="ln242">#define AA_HARD_MSK_POS   ATBIT_MSK_NP</a>
<a name="ln243">#define AA_HARD_TYP_POS   ATTYP_N</a>
<a name="ln244">/* (-) charge group for negative charge removal */</a>
<a name="ln245">#define AA_HARD_MSK_NEG   ((ATBIT_MSK_NP | ATBIT_MSK_OS) &amp; ~(ATBIT_CO | ATBIT_NO ))</a>
<a name="ln246">#define AA_HARD_TYP_NEG   (ATTYP_N | ATTYP_OS)</a>
<a name="ln247">/* (-) charge group to accept negative charges  */</a>
<a name="ln248">#define AA_HARD_MSK_CO    (ATBIT_CO | ATBIT_NO )</a>
<a name="ln249">#define AA_HARD_TYP_CO    (ATT_ACIDIC_CO | ATT_NO)</a>
<a name="ln250">/* H-group non-acid for proton removal */</a>
<a name="ln251">#define AA_HARD_MSK_H     (ATBIT_MSK_NP | ATBIT_MSK_OS)</a>
<a name="ln252">#define AA_HARD_TYP_H     (ATTYP_N | ATTYP_OS)</a>
<a name="ln253"> </a>
<a name="ln254"> </a>
<a name="ln255">/*****************************************************************************/</a>
<a name="ln256">#define BNS_MAX_NUM_FLOW_CHANGES (1+2*MAX_BOND_EDGE_CAP)</a>
<a name="ln257"> </a>
<a name="ln258">/* -- opiginal Pascal values --</a>
<a name="ln259">#define NO_VERTEX     0</a>
<a name="ln260">#define BLOSSOM_BASE -1</a>
<a name="ln261">#define FIRST_INDX    1</a>
<a name="ln262">*/</a>
<a name="ln263"> </a>
<a name="ln264">#define TREE_NOT_IN_M  0  /* not in T or T' */</a>
<a name="ln265">#define TREE_IN_2      1  /* in T' and not s-reachable */</a>
<a name="ln266">#define TREE_IN_2BLOSS 2  /* in T' and in a blossom, is s-reachable */</a>
<a name="ln267">#define TREE_IN_1      3  /* in T and is s-reachable */</a>
<a name="ln268"> </a>
<a name="ln269">#define TREE_IS_S_REACHABLE(X) (Tree[X] &gt;= TREE_IN_2BLOSS)</a>
<a name="ln270">#define TREE_IS_ON_SCANQ TREE_IS_S_REACHABLE</a>
<a name="ln271">/* #define TREE_IS_ON_SCANQ(X)    (Tree[X] != TREE_NOT_IN_M) */</a>
<a name="ln272">#define TREE_MARK(X, MARK)           do{ if( Tree[X] &lt; MARK ) Tree[X]=MARK; }while(0)</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">/*****************************************************************************</a>
<a name="ln276"> *  store changes done to check whether an alternating path exists</a>
<a name="ln277"> *  (see bSetBnsToCheckAltPath, bRestoreBnsAfterCheckAltPath)</a>
<a name="ln278">******************************************************************************/</a>
<a name="ln279">typedef struct tagAltPathChanges </a>
<a name="ln280">{</a>
<a name="ln281">    /* caps changed in up to 2 vertices */</a>
<a name="ln282">    VertexFlow nOldCapsVert[2][MAXVAL+1];</a>
<a name="ln283">    Vertex     vOldVert[2];</a>
<a name="ln284">    S_CHAR     bSetOldCapsVert[2]; /* number of caps to restore, including st-cap */</a>
<a name="ln285">    /* save ids of the newly created temporary vertices */</a>
<a name="ln286">    Vertex     vNewVertex[2];</a>
<a name="ln287">    S_CHAR     bSetNew[2];         /* indicators whether to remove vertices */</a>
<a name="ln288"> </a>
<a name="ln289">} ALT_PATH_CHANGES;</a>
<a name="ln290"> </a>
<a name="ln291">/*****************************************************************************/</a>
<a name="ln292"> </a>
<a name="ln293">/* Local functions */</a>
<a name="ln294"> </a>
<a name="ln295">int RestoreRadicalsOnly( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at );</a>
<a name="ln296">int bRadChangesAtomType( BN_STRUCT *pBNS, BN_DATA *pBD, Vertex v, Vertex v_1, Vertex v_2 );</a>
<a name="ln297">int BnsAdjustFlowBondsRad( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at, int num_atoms );</a>
<a name="ln298">int SetAtomRadAndChemValFromVertexCapFlow( BN_STRUCT *pBNS, inp_ATOM *atom, int v1 );</a>
<a name="ln299">int bNeedToTestTheFlow( int bond_type, int nTestFlow, int bTestForNonStereoBond );</a>
<a name="ln300">int RestoreEdgeFlow( BNS_EDGE *edge, int delta, int bChangeFlow );</a>
<a name="ln301">int SetAtomBondType( BNS_EDGE *edge, U_CHAR *bond_type12, U_CHAR *bond_type21, int delta, int bChangeFlow );</a>
<a name="ln302">int RestoreBnStructFlow( BN_STRUCT *pBNS, int bChangeFlow );</a>
<a name="ln303">int CompTGroupNumber( const void *tg1, const void *tg2 );</a>
<a name="ln304">int CompCGroupNumber( const void *cg1, const void *cg2 );</a>
<a name="ln305"> </a>
<a name="ln306">/* Rings, Blocks, Non-stereo bonds */</a>
<a name="ln307">int ReInitBnStructForAltBns( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bUnknAltAsNoStereo );</a>
<a name="ln308">int MarkRingSystemsAltBns( BN_STRUCT* pBNS, int bUnknAltAsNoStereo );</a>
<a name="ln309">int MarkNonStereoAltBns( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bUnknAltAsNoStereo );</a>
<a name="ln310"> </a>
<a name="ln311">/* Called from BalancedNetworkSearch */</a>
<a name="ln312">int GetVertexDegree( BN_STRUCT* pBNS, Vertex v );</a>
<a name="ln313">/* Vertex Get2ndNeighbor1( BN_STRUCT* pBNS, Vertex u, EdgeIndex iedge ); not used */</a>
<a name="ln314">Vertex Get2ndEdgeVertex( BN_STRUCT* pBNS, Edge uv );</a>
<a name="ln315">Vertex GetVertexNeighbor( BN_STRUCT* pBNS, Vertex v, int neigh, EdgeIndex *iedge );</a>
<a name="ln316">int GetEdgePointer( BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv, BNS_EDGE **uv, S_CHAR *s_or_t );</a>
<a name="ln317">int AugmentEdge( BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv, int delta, S_CHAR bReverse, int bChangeFlow );</a>
<a name="ln318">int rescap_mark( BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv );</a>
<a name="ln319">int rescap(  BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv );</a>
<a name="ln320">Vertex FindBase( Vertex u, Vertex *BasePtr );</a>
<a name="ln321">int FindPathToVertex_s( Vertex x, Edge *SwitchEdge, Vertex *BasePtr, Vertex *Path, int MaxPathLen );</a>
<a name="ln322">Vertex MakeBlossom( BN_STRUCT* pBNS, Vertex *ScanQ, int *pQSize,</a>
<a name="ln323">                    Vertex *Pu, Vertex *Pv, int max_len_Pu_Pv,</a>
<a name="ln324">                    Edge *SwitchEdge, Vertex *BasePtr,</a>
<a name="ln325">                    Vertex u, Vertex v, EdgeIndex iuv, Vertex b_u, Vertex b_v, S_CHAR *Tree );</a>
<a name="ln326">int PullFlow( BN_STRUCT *pBNS, Edge *SwitchEdge, Vertex x, Vertex y, int delta, S_CHAR bReverse, int bChangeFlow );</a>
<a name="ln327">int FindPathCap( BN_STRUCT* pBNS, Edge *SwitchEdge, Vertex x, Vertex y, int delta );</a>
<a name="ln328"> </a>
<a name="ln329">/*</a>
<a name="ln330">int SetBondType( BNS_EDGE *edge, U_CHAR *bond_type12, U_CHAR *bond_type21, int delta, int bChangeFlow );</a>
<a name="ln331">int SetBondsRestoreBnStructFlow( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bChangeFlow );</a>
<a name="ln332">*/</a>
<a name="ln333">int SetBondsFromBnStructFlow( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bChangeFlow0 );</a>
<a name="ln334">int MarkAtomsAtTautGroups(  BN_STRUCT *pBNS, int num_atoms, BN_AATG *pAATG, int nEnd1, int nEnd2 );</a>
<a name="ln335"> </a>
<a name="ln336">int nMinFlow2Check( BN_STRUCT *pBNS, int iedge );</a>
<a name="ln337">int nMaxFlow2Check( BN_STRUCT *pBNS, int iedge );</a>
<a name="ln338">int nCurFlow2Check( BN_STRUCT *pBNS, int iedge );</a>
<a name="ln339"> </a>
<a name="ln340">/* Bonds testing */</a>
<a name="ln341">/*</a>
<a name="ln342">int bRestoreFlowToCheckOneBond( BN_STRUCT *pBNS, BNS_FLOW_CHANGES *fcd, int nTestFlow, inp_ATOM *at, int num_atoms, int bChangeFlow );</a>
<a name="ln343">*/</a>
<a name="ln344">int bSetFlowToCheckOneBond( BN_STRUCT *pBNS, int iedge, int flow, BNS_FLOW_CHANGES *fcd );</a>
<a name="ln345">int bRestoreFlowAfterCheckOneBond( BN_STRUCT *pBNS, BNS_FLOW_CHANGES *fcd );</a>
<a name="ln346">int bSetBondsAfterCheckOneBond( BN_STRUCT *pBNS, BNS_FLOW_CHANGES *fcd, int nTestFlow, inp_ATOM *at, int num_atoms, int bChangeFlow );</a>
<a name="ln347">int BnsTestAndMarkAltBonds(  BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at, int num_atoms, BNS_FLOW_CHANGES *fcd, int bChangeFlow, int nBondTypeToTest );</a>
<a name="ln348">int bIsAltBond( int bond_type );</a>
<a name="ln349"> </a>
<a name="ln350">/* Fix bonds */</a>
<a name="ln351">int fix_special_bonds( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int edge_forbidden_mask );</a>
<a name="ln352">int TempFix_NH_NH_Bonds( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms );</a>
<a name="ln353">int CorrectFixing_NH_NH_Bonds( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms );</a>
<a name="ln354"> </a>
<a name="ln355">/* Alt path testing */</a>
<a name="ln356">int bSetBnsToCheckAltPath( BN_STRUCT *pBNS, int nVertDoubleBond, int nVertSingleBond, AT_NUMB type,</a>
<a name="ln357">                           int path_type, ALT_PATH_CHANGES *apc, BNS_FLOW_CHANGES *fcd, int *nDots );</a>
<a name="ln358">int bRestoreBnsAfterCheckAltPath( BN_STRUCT *pBNS, ALT_PATH_CHANGES *apc, int bChangeFlow );</a>
<a name="ln359">Vertex GetGroupVertex(BN_STRUCT *pBNS, Vertex v1, AT_NUMB type);</a>
<a name="ln360">BNS_IEDGE GetEdgeToGroupVertex( BN_STRUCT *pBNS, Vertex v1, AT_NUMB type);</a>
<a name="ln361">int bAddNewVertex( BN_STRUCT *pBNS, int nVertDoubleBond, int nCap, int nFlow, int nMaxAdjEdges, int *nDots );</a>
<a name="ln362">int AddNewEdge( BNS_VERTEX *p1, BNS_VERTEX *p2, BN_STRUCT *pBNS, int nEdgeCap, int nEdgeFlow );</a>
<a name="ln363">int bAddStCapToAVertex( BN_STRUCT *pBNS, Vertex v1, Vertex v2, VertexFlow *nOldCapVertSingleBond, int *nDots, int bAdjacentDonors );</a>
<a name="ln364"> </a>
<a name="ln365">static void remove_alt_bond_marks(inp_ATOM *at, int num_atoms);</a>
<a name="ln366">int bIsBnsEndpoint( BN_STRUCT *pBNS, int v );</a>
<a name="ln367"> </a>
<a name="ln368">/* Protons removal, charge neutralization */</a>
<a name="ln369">int is_acidic_CO( inp_ATOM *atom, int at_no );</a>
<a name="ln370">int mark_at_type( inp_ATOM *atom, int num_atoms, int nAtTypeTotals[] );</a>
<a name="ln371">int GetAtomChargeType( inp_ATOM *atom, int at_no, int nAtTypeTotals[], int *pMask, int bSubtract  );</a>
<a name="ln372">int AddChangedAtHChargeBNS( inp_ATOM *at, int num_atoms, int nAtTypeTotals[], S_CHAR *mark );</a>
<a name="ln373">int EliminatePlusMinusChargeAmbiguity( BN_STRUCT *pBNS, int num_atoms );</a>
<a name="ln374">int AddOrRemoveExplOrImplH( int nDelta, inp_ATOM *at, int num_atoms, AT_NUMB at_no, T_GROUP_INFO *t_group_info );</a>
<a name="ln375">int SubtractOrChangeAtHChargeBNS( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms,</a>
<a name="ln376">                                 int nAtTypeTotals[], S_CHAR *mark, T_GROUP_INFO *t_group_info, int bSubtract );</a>
<a name="ln377">int is_Z_atom( U_CHAR el_number );</a>
<a name="ln378">int IsZOX( inp_ATOM *atom, int at_x, int ord );</a>
<a name="ln379">int SimpleRemoveHplusNPO( inp_ATOM *at, int num_atoms, int nAtTypeTotals[], T_GROUP_INFO *t_group_info );</a>
<a name="ln380">int CreateCGroupInBnStruct( inp_ATOM *at, int num_atoms,</a>
<a name="ln381">                            BN_STRUCT *pBNS, int nType, int nMask, int nCharge );</a>
<a name="ln382">int CreateTGroupInBnStruct( inp_ATOM *at, int num_atoms,</a>
<a name="ln383">                            BN_STRUCT *pBNS, int nType, int nMask );</a>
<a name="ln384">int RemoveLastGroupFromBnStruct( inp_ATOM *at, int num_atoms, int tg, BN_STRUCT *pBNS );</a>
<a name="ln385">int SetInitCapFlowToCurrent( BN_STRUCT *pBNS );</a>
<a name="ln386">int SimpleRemoveAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2remove );</a>
<a name="ln387">int SimpleAddAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2add );</a>
<a name="ln388">int HardRemoveAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2remove,</a>
<a name="ln389">                              int *nNumCanceledCharges, BN_STRUCT *pBNS, BN_DATA *pBD );</a>
<a name="ln390">int HardAddAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2add,</a>
<a name="ln391">                              int *nNumCanceledCharges, BN_STRUCT *pBNS, BN_DATA *pBD );</a>
<a name="ln392">int HardRemoveHplusNP( inp_ATOM *at, int num_atoms, int bCancelChargesAlways, int *nNumCanceledCharges,</a>
<a name="ln393">                       BN_AATG *pAATG, BN_STRUCT *pBNS, BN_DATA *pBD  );</a>
<a name="ln394">int RemoveNPProtonsAndAcidCharges( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, BN_STRUCT *pBNS, BN_DATA *pBD );</a>
<a name="ln395">Vertex GetPrevVertex( BN_STRUCT* pBNS, Vertex y, Edge *SwitchEdge, EdgeIndex *iuv );</a>
<a name="ln396">int bIgnoreVertexNonTACN_atom( BN_STRUCT* pBNS, Vertex u, Vertex v );</a>
<a name="ln397">int bIgnoreVertexNonTACN_group( BN_STRUCT* pBNS, Vertex v, Vertex w, Edge *SwitchEdge );</a>
<a name="ln398">int bIsRemovedHfromNHaion( BN_STRUCT* pBNS, Vertex u, Vertex v );</a>
<a name="ln399">int bIsAggressiveDeprotonation( BN_STRUCT* pBNS, Vertex v, Vertex w, Edge *SwitchEdge );</a>
<a name="ln400"> </a>
<a name="ln401">int bIsAtomTypeHard( inp_ATOM *at, int endpoint, int nType, int nMask, int nCharge );</a>
<a name="ln402">int bIsHDonorAccAtomType( inp_ATOM *at, int endpoint, int *cSubType );</a>
<a name="ln403">int bIsNegAtomType( inp_ATOM *at, int i, int *cSubType );</a>
<a name="ln404"> </a>
<a name="ln405">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln406">int RegisterRadEndpoint( BN_STRUCT *pBNS, BN_DATA *pBD, Vertex u);</a>
<a name="ln407">int cmp_rad_endpoints( const void *a1, const void *a2 );</a>
<a name="ln408">int cmp_endpoints_rad( const void *a1, const void *a2 );</a>
<a name="ln409">#endif</a>
<a name="ln410"> </a>
<a name="ln411">int bHasChargedNeighbor( inp_ATOM *at, int iat );</a>
<a name="ln412">/*****************************************************************************/</a>
<a name="ln413">/**** prim(v) is v' *****/</a>
<a name="ln414">#define prim(v) (Vertex)((v)^1)</a>
<a name="ln415"> </a>
<a name="ln416">/*****************************************************************************/</a>
<a name="ln417">#define SwitchEdge_Vert1(u) SwitchEdge[u][0]</a>
<a name="ln418">#define SwitchEdge_Vert2(u) Get2ndEdgeVertex( pBNS, SwitchEdge[u] )</a>
<a name="ln419">#define SwitchEdge_IEdge(u) SwitchEdge[u][1]</a>
<a name="ln420">/*****************************************************************************/</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">/*****************************************************************************/</a>
<a name="ln427">/* Returns value &gt; 0 if a bond has been changed								 */</a>
<a name="ln428">/*****************************************************************************/</a>
<a name="ln429">int RestoreEdgeFlow( BNS_EDGE *edge, int delta, int bChangeFlow )</a>
<a name="ln430">{</a>
<a name="ln431">    /*flow1 = edge-&gt;flow;*/ /* output from BNS */</a>
<a name="ln432">    switch ( bChangeFlow &amp; BNS_EF_CHNG_RSTR ) {</a>
<a name="ln433">    case 0: /* the flow has not been permitted to change inside the BNS */</a>
<a name="ln434">        /* nothing to do */</a>
<a name="ln435">        /*flow1 = edge-&gt;flow;*/    /* output from BNS, the original flow value */</a>
<a name="ln436">        /*flow2 = flow1 + delta;*/ /* the flow would be changed to this value by the BNS if permitted */</a>
<a name="ln437">        break;</a>
<a name="ln438">    case BNS_EF_CHNG_FLOW: /* the flow has been changed by the BNS; update flow0 */</a>
<a name="ln439">        /*flow2 = edge-&gt;flow;*/    /* output from BNS, the changed value */</a>
<a name="ln440">        /*flow1 = flow2 - delta;*/ /* the original flow value before the BNS */</a>
<a name="ln441">        edge-&gt;flow0 = edge-&gt;flow;   /* SAVE NEW EDGE FLOW AS THE INITIAL FLOW FROM CHEM. BONDS */</a>
<a name="ln442">        break;</a>
<a name="ln443">    case BNS_EF_CHNG_RSTR: /* the flow has been changed by the BNS; requested to change it back */</a>
<a name="ln444">        /*flow2 = edge-&gt;flow;*/    /* output from BNS, the changed value */</a>
<a name="ln445">        /*flow1 = flow2 - delta;*/ /* the original flow value before the BNS */</a>
<a name="ln446">        edge-&gt;flow = edge-&gt;flow-delta;    /* CHANGE EDGE FLOW BACK (RESTORE) */</a>
<a name="ln447">        break;</a>
<a name="ln448">    case BNS_EF_RSTR_FLOW: /* the flow has not been permitted to change inside the BNS */</a>
<a name="ln449">        /* nothing to do */</a>
<a name="ln450">        /*flow1 = edge-&gt;flow;*/    /* output from BNS, the original flow value */</a>
<a name="ln451">        /*flow2 = flow1 + delta;*/ /* the flow would be changed to this value by the BNS if permitted */</a>
<a name="ln452">        break;</a>
<a name="ln453">    }</a>
<a name="ln454">    return 0;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">/*****************************************************************************/</a>
<a name="ln460">/* Returns value &gt; 0 if a bond has been changed; do not change flow			 */</a>
<a name="ln461">/*****************************************************************************/</a>
<a name="ln462">int SetAtomBondType( BNS_EDGE *edge, U_CHAR *bond_type12, U_CHAR *bond_type21, int delta, int bChangeFlow )</a>
<a name="ln463">{</a>
<a name="ln464">    int    flow1, flow2, tmp, ret = 0;</a>
<a name="ln465">    int   bond_mark, bond_type, new_bond_type;</a>
<a name="ln466"> </a>
<a name="ln467">    if ( !edge-&gt;pass || !bond_type21 )</a>
<a name="ln468">        return 0;</a>
<a name="ln469"> </a>
<a name="ln470">    switch ( bChangeFlow &amp; BNS_EF_CHNG_RSTR ) {</a>
<a name="ln471">    case 0:                    /* the flow has not been permitted to change inside the BNS: simulated in case of check one bond */</a>
<a name="ln472">    case BNS_EF_RSTR_FLOW:     /* the flow has not been permitted to change inside the BNS: obsolete mode, unexpected bChangeFlow */</a>
<a name="ln473">        flow1 = edge-&gt;flow0;   /* output from BNS, the original (old) flow value */</a>
<a name="ln474">        flow2 = flow1 + delta; /* the flow would be changed to this value by the BNS if permitted */</a>
<a name="ln475">        break;</a>
<a name="ln476">    case BNS_EF_CHNG_FLOW:     /* the flow has been changed by the BNS */</a>
<a name="ln477">    case BNS_EF_CHNG_RSTR:     /* the flow has been changed by the BNS; requested to change it back */</a>
<a name="ln478">        flow2 = edge-&gt;flow;    /* output from BNS, the changed (new) value */</a>
<a name="ln479">        flow1 = edge-&gt;flow0;   /* the original flow (old) value before the BNS */</a>
<a name="ln480">        break;</a>
<a name="ln481">    default:</a>
<a name="ln482">        return 0; /* added 2006-03-21 */</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">    if ( (bChangeFlow &amp; BNS_EF_CHNG_BONDS) &amp;&amp; (bChangeFlow &amp; BNS_EF_ALTR_NS) !=BNS_EF_ALTR_NS ) {</a>
<a name="ln486">        /* set new bond types according to the new flow values */</a>
<a name="ln487">        new_bond_type = flow2+BOND_SINGLE;</a>
<a name="ln488">        if ( *bond_type12 != new_bond_type ) {</a>
<a name="ln489">            *bond_type12 = *bond_type21 = new_bond_type;</a>
<a name="ln490">            ret ++;</a>
<a name="ln491">        }</a>
<a name="ln492">    } else</a>
<a name="ln493">    if ( bChangeFlow &amp; BNS_EF_ALTR_BONDS ) {</a>
<a name="ln494">        if ( flow1 == flow2 ) {</a>
<a name="ln495">            goto exit_function;</a>
<a name="ln496">        }</a>
<a name="ln497">        /* update alternating bond information */</a>
<a name="ln498">        if ( flow1 &gt; flow2 ) {</a>
<a name="ln499">            /* make sure flow2 &gt; flow1 */</a>
<a name="ln500">            tmp   = flow1;</a>
<a name="ln501">            flow1 = flow2;</a>
<a name="ln502">            flow2 = tmp;</a>
<a name="ln503">        }</a>
<a name="ln504">        bond_mark = 0;</a>
<a name="ln505">        switch( bond_type = (*bond_type12 &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln506">        </a>
<a name="ln507">        case BOND_SINGLE:</a>
<a name="ln508">        case BOND_DOUBLE:</a>
<a name="ln509">        case BOND_TRIPLE:</a>
<a name="ln510">            /* assume that the input bond type fits either flow1 or flow2 */</a>
<a name="ln511">            if ( flow1 == 0 &amp;&amp; flow2 == 1 ) {</a>
<a name="ln512">                if ( bChangeFlow &amp; BNS_EF_SET_NOSTEREO ) {</a>
<a name="ln513">                    bond_mark = BOND_MARK_ALT12NS;</a>
<a name="ln514">                    bond_type = BOND_ALT12NS;</a>
<a name="ln515">                } else {</a>
<a name="ln516">                    bond_mark = BOND_MARK_ALT12;</a>
<a name="ln517">                    bond_type = BOND_ALTERN;</a>
<a name="ln518">                }</a>
<a name="ln519">            } else</a>
<a name="ln520">            if ( flow1 == 0 &amp;&amp; flow2 == 2 ) {</a>
<a name="ln521">                bond_mark = BOND_MARK_ALT13;</a>
<a name="ln522">                bond_type = BOND_ALT_13;</a>
<a name="ln523">            } else</a>
<a name="ln524">            if ( flow1 == 1 &amp;&amp; flow2 == 2 ) {</a>
<a name="ln525">                bond_mark = BOND_MARK_ALT23;</a>
<a name="ln526">                bond_type = BOND_ALT_23;</a>
<a name="ln527">            } else {</a>
<a name="ln528">                return BNS_BOND_ERR; /* error */</a>
<a name="ln529">            }</a>
<a name="ln530">            break;</a>
<a name="ln531">        case BOND_TAUTOM:</a>
<a name="ln532">            if ( flow1 == 0 &amp;&amp; flow2 == 1 ) {</a>
<a name="ln533">                bond_mark = BOND_MARK_ALT12NS;</a>
<a name="ln534">            } else {</a>
<a name="ln535">                return BNS_BOND_ERR; /* error */</a>
<a name="ln536">            }</a>
<a name="ln537">            break;</a>
<a name="ln538"> </a>
<a name="ln539">        default:</a>
<a name="ln540">            new_bond_type = bond_type;</a>
<a name="ln541">            bond_mark = (*bond_type12 &amp; BOND_MARK_MASK);</a>
<a name="ln542">            switch( bond_mark ) {</a>
<a name="ln543">            case BOND_MARK_ALT12:</a>
<a name="ln544">                if ( (bChangeFlow &amp; BNS_EF_SET_NOSTEREO) &amp;&amp; flow1 == 0 &amp;&amp; flow2 == 1 ) {</a>
<a name="ln545">                    bond_mark = BOND_MARK_ALT12NS;</a>
<a name="ln546">                    new_bond_type = BOND_ALT12NS;</a>
<a name="ln547">                    break;</a>
<a name="ln548">                }</a>
<a name="ln549">            case BOND_MARK_ALT12NS:</a>
<a name="ln550">                if ( flow1 == 2 || flow2 == 2 ) {</a>
<a name="ln551">                    bond_mark = BOND_MARK_ALT123;</a>
<a name="ln552">                    new_bond_type = BOND_ALT_123;</a>
<a name="ln553">                }</a>
<a name="ln554">                break;</a>
<a name="ln555">            case BOND_MARK_ALT13:</a>
<a name="ln556">                if ( flow1 == 1 || flow2 == 1 ) {</a>
<a name="ln557">                    bond_mark = BOND_MARK_ALT123;</a>
<a name="ln558">                    new_bond_type = BOND_ALT_123;</a>
<a name="ln559">                }</a>
<a name="ln560">                break;</a>
<a name="ln561">            case BOND_MARK_ALT23:</a>
<a name="ln562">                if ( flow1 == 0 || flow2 == 0 ) {</a>
<a name="ln563">                    bond_mark = BOND_MARK_ALT123;</a>
<a name="ln564">                    new_bond_type = BOND_ALT_123;</a>
<a name="ln565">                }</a>
<a name="ln566">                break;</a>
<a name="ln567">            case BOND_MARK_ALT123:</a>
<a name="ln568">                break;</a>
<a name="ln569">            </a>
<a name="ln570">            case 0: /* special case: second alt bond testing */</a>
<a name="ln571">                if ( flow1 == 0 &amp;&amp; flow2 == 1 ) {</a>
<a name="ln572">                    bond_mark = BOND_MARK_ALT12;</a>
<a name="ln573">                } else</a>
<a name="ln574">                if ( flow1 == 0 &amp;&amp; flow2 == 2 ) {</a>
<a name="ln575">                    bond_mark = BOND_MARK_ALT13;</a>
<a name="ln576">                } else</a>
<a name="ln577">                if ( flow1 == 1 &amp;&amp; flow2 == 2 ) {</a>
<a name="ln578">                    bond_mark = BOND_MARK_ALT23;</a>
<a name="ln579">                } else {</a>
<a name="ln580">                    return BNS_BOND_ERR; /* error */</a>
<a name="ln581">                }</a>
<a name="ln582">                break;</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">            default:</a>
<a name="ln586">                return BNS_BOND_ERR; /* error */</a>
<a name="ln587">            }</a>
<a name="ln588">            switch( bond_type ) {</a>
<a name="ln589">            case BOND_TAUTOM:</a>
<a name="ln590">                break;</a>
<a name="ln591">            case BOND_ALTERN:</a>
<a name="ln592">            case BOND_ALT12NS:</a>
<a name="ln593">            case BOND_ALT_123:</a>
<a name="ln594">            case BOND_ALT_13:</a>
<a name="ln595">            case BOND_ALT_23:</a>
<a name="ln596">                bond_type = new_bond_type;</a>
<a name="ln597">                break;</a>
<a name="ln598">            default:</a>
<a name="ln599">                return BNS_BOND_ERR; /* error */</a>
<a name="ln600">            }</a>
<a name="ln601">        }</a>
<a name="ln602">        new_bond_type = bond_type | bond_mark;</a>
<a name="ln603">        if ( new_bond_type != *bond_type12 ) {</a>
<a name="ln604">            *bond_type12 = *bond_type21 = new_bond_type;</a>
<a name="ln605">            ret ++;</a>
<a name="ln606">        }</a>
<a name="ln607">    }</a>
<a name="ln608">exit_function:</a>
<a name="ln609">    return ret;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612"> </a>
<a name="ln613"> </a>
<a name="ln614">/*****************************************************************************/</a>
<a name="ln615">int RunBalancedNetworkSearch( BN_STRUCT *pBNS, BN_DATA *pBD, int bChangeFlow )</a>
<a name="ln616">{</a>
<a name="ln617">    /* Run BNS until no aug pass is found */</a>
<a name="ln618">    int pass, delta=0, nSumDelta;</a>
<a name="ln619">    nSumDelta = 0;</a>
<a name="ln620">    for ( pass = 0; pass &lt; pBNS-&gt;max_altp; pass ++ ) {</a>
<a name="ln621">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln622">        pBNS-&gt;bChangeFlow = 0;</a>
<a name="ln623">        delta=BalancedNetworkSearch ( pBNS, pBD, bChangeFlow );</a>
<a name="ln624">        ReInitBnData( pBD );</a>
<a name="ln625">        if ( 0 &lt; delta ) {</a>
<a name="ln626">            pBNS-&gt;num_altp ++;</a>
<a name="ln627">            nSumDelta += abs( delta );</a>
<a name="ln628">        } else {</a>
<a name="ln629">            break;</a>
<a name="ln630">        }</a>
<a name="ln631">    }</a>
<a name="ln632">    if ( IS_BNS_ERROR(delta) )</a>
<a name="ln633">        return delta;</a>
<a name="ln634">    return nSumDelta; /* number of eliminated pairs of &quot;dots&quot;  */</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">/*****************************************************************************/</a>
<a name="ln640">int SetAtomRadAndChemValFromVertexCapFlow( BN_STRUCT *pBNS, inp_ATOM *atom, int v1 )</a>
<a name="ln641">{</a>
<a name="ln642">    BNS_VERTEX *vert = pBNS-&gt;vert + v1;</a>
<a name="ln643">    inp_ATOM   *at   = atom + v1;</a>
<a name="ln644">    S_CHAR      cValue;</a>
<a name="ln645">    int  nChanges = 0;</a>
<a name="ln646">    /* set only on the 1st pass */</a>
<a name="ln647">    if ( !vert-&gt;st_edge.pass ) {</a>
<a name="ln648">        return 0;</a>
<a name="ln649">    }</a>
<a name="ln650">    /* adjust chem_bonds_valence */</a>
<a name="ln651">    cValue = at-&gt;chem_bonds_valence - at-&gt;valence;</a>
<a name="ln652">    if ( cValue  &gt;= 0 &amp;&amp; cValue != vert-&gt;st_edge.flow ) { </a>
<a name="ln653">        at-&gt;chem_bonds_valence = at-&gt;valence + vert-&gt;st_edge.flow;</a>
<a name="ln654">        nChanges ++;</a>
<a name="ln655">    }</a>
<a name="ln656">    /* adjast radical */</a>
<a name="ln657">    switch ( vert-&gt;st_edge.cap - vert-&gt;st_edge.flow ) {</a>
<a name="ln658">    case 0:</a>
<a name="ln659">        cValue = 0;</a>
<a name="ln660">        break;</a>
<a name="ln661">    case 1:</a>
<a name="ln662">        cValue = RADICAL_DOUBLET;</a>
<a name="ln663">        break;</a>
<a name="ln664">    case 2:</a>
<a name="ln665">        cValue = RADICAL_TRIPLET;</a>
<a name="ln666">        break;</a>
<a name="ln667">    default:</a>
<a name="ln668">        return BNS_BOND_ERR;</a>
<a name="ln669">    }</a>
<a name="ln670">    if ( cValue != at-&gt;radical ) {</a>
<a name="ln671">        at-&gt;radical = cValue;</a>
<a name="ln672">        nChanges ++;</a>
<a name="ln673">    }</a>
<a name="ln674"> </a>
<a name="ln675">    return nChanges;</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">/*****************************************************************************/</a>
<a name="ln681">int AddChangedAtHChargeBNS( inp_ATOM *at, int num_atoms, int nAtTypeTotals[], S_CHAR *mark )</a>
<a name="ln682">{</a>
<a name="ln683">    int i, mask, num;</a>
<a name="ln684">    for ( i = 0, num = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln685">        if ( mark[i] ) {</a>
<a name="ln686">            mark[i] = 0;</a>
<a name="ln687">#if ( FIX_NORM_BUG_ADD_ION_PAIR == 1 )</a>
<a name="ln688">             /* add ignoring adjacent charges */</a>
<a name="ln689">            at[i].at_type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, -2 );</a>
<a name="ln690">#else</a>
<a name="ln691">            at[i].at_type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 );</a>
<a name="ln692">#endif</a>
<a name="ln693">            num ++;</a>
<a name="ln694">        }</a>
<a name="ln695">    }</a>
<a name="ln696">    return num;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699"> </a>
<a name="ln700"> </a>
<a name="ln701">/************************************************************************************/</a>
<a name="ln702">/* Eliminate neutral representation ambiguity: replace (+)--N==(-) with (+)==N--(-) */</a>
<a name="ln703">/* here (+) is positive charge group, (-) is negative charge group, N is N or P     */</a>
<a name="ln704">/* this reduces possibility of ion pair -OH =&gt; -O(+) + H(+) creation instead of     */</a>
<a name="ln705">/* removing H(+) from N or P                                                        */</a>
<a name="ln706">/*																					*/</a>
<a name="ln707">/*==== Call this function after alt path was found and new flows have been set. ====*/</a>
<a name="ln708">/*																					*/</a>
<a name="ln709">/************************************************************************************/</a>
<a name="ln710">int EliminatePlusMinusChargeAmbiguity( BN_STRUCT *pBNS, int num_atoms )</a>
<a name="ln711">{</a>
<a name="ln712">    int       pass, i, v0, v1, v2, ineigh1, /*ineigh0,*/ /*ineigh2,*/ vLast, n, delta, ret, err = 0;</a>
<a name="ln713">    BNS_EDGE *edge;</a>
<a name="ln714">    int       nFound, k;</a>
<a name="ln715">    </a>
<a name="ln716">    for ( pass = pBNS-&gt;num_altp-1, ret = 0; 0 &lt;= pass; pass -- ) {</a>
<a name="ln717">        </a>
<a name="ln718">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln719">        v1 = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln720">        n  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln721">        delta  = ALTP_DELTA(pBNS-&gt;alt_path);</a>
<a name="ln722">        vLast = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln723">        v0 = v2 = NO_VERTEX; /* negative number */</a>
<a name="ln724"> </a>
<a name="ln725">        for ( i = 0; i &lt; n; i ++, delta = -delta, v0 = v1, v1 = v2 /*, ineigh0 = ineigh1*/ ) {</a>
<a name="ln726">            ineigh1 = ALTP_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v1-&gt;v2 neighbor */</a>
<a name="ln727">            /*ineigh2 = ALTP_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);*/  /* v2-&gt;v1 neighbor */</a>
<a name="ln728">            edge = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[ineigh1];</a>
<a name="ln729">            /* follow the BN Structure, not the inp_ATOM, to take care of swithching to</a>
<a name="ln730">               t-groups, c-groups or other fictitious edges/vertices</a>
<a name="ln731">            */</a>
<a name="ln732">            v2 = edge-&gt;neighbor12 ^ v1;</a>
<a name="ln733">            if ( v1 &lt; num_atoms &amp;&amp;</a>
<a name="ln734">                 ( (v0 &gt;= num_atoms &amp;&amp; ( pBNS-&gt;vert[v0].type &amp; BNS_VERT_TYPE_C_GROUP )) ||</a>
<a name="ln735">                   (v2 &gt;= num_atoms &amp;&amp; ( pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_C_GROUP )) ) ) {</a>
<a name="ln736">                int        cgPos, cgNeg;</a>
<a name="ln737">                int        neighPos = -1, neighNeg = -1;</a>
<a name="ln738">                BNS_EDGE *edgePos, *edgeNeg;</a>
<a name="ln739">                nFound = 0;</a>
<a name="ln740">                for ( k = pBNS-&gt;vert[v1].num_adj_edges-1; k &gt;= 0 &amp;&amp; (neighPos &lt; 0 || neighNeg &lt; 0); k -- ) {</a>
<a name="ln741">                    BNS_EDGE   *next_edge = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[k];</a>
<a name="ln742">                    int         v         = next_edge-&gt;neighbor12 ^ v1;</a>
<a name="ln743">                    if ( pBNS-&gt;vert[v].type &amp; BNS_VERT_TYPE_C_GROUP ) {</a>
<a name="ln744">                        if ( pBNS-&gt;vert[v].type &amp; BNS_VERT_TYPE_C_NEGATIVE ) {</a>
<a name="ln745">                            cgNeg    = v;</a>
<a name="ln746">                            neighNeg = k;</a>
<a name="ln747">                            nFound ++;</a>
<a name="ln748">                        } else {</a>
<a name="ln749">                            cgPos    = v;</a>
<a name="ln750">                            neighPos = k;</a>
<a name="ln751">                            nFound ++;</a>
<a name="ln752">                        }</a>
<a name="ln753">                    }</a>
<a name="ln754">                }</a>
<a name="ln755">                if ( 2 == nFound &amp;&amp; neighPos &gt;= 0 &amp;&amp; neighNeg &gt;= 0 ) {</a>
<a name="ln756">                    /* both c-groups have been found */</a>
<a name="ln757">                    edgePos = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[neighPos];</a>
<a name="ln758">                    edgeNeg = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[neighNeg];</a>
<a name="ln759">                    if ( edgePos-&gt;flow &lt; edgeNeg-&gt;flow ) {</a>
<a name="ln760">                        /* ambiguity found; replace (+cg)--N==(-cg) with (+cg)==N--(-cg) */</a>
<a name="ln761">                        int dflow = edgeNeg-&gt;flow - edgePos-&gt;flow;</a>
<a name="ln762">                        </a>
<a name="ln763">                        edgePos-&gt;flow += dflow;</a>
<a name="ln764">                        pBNS-&gt;vert[cgPos].st_edge.cap  += dflow;</a>
<a name="ln765">                        pBNS-&gt;vert[cgPos].st_edge.flow += dflow;</a>
<a name="ln766">                        </a>
<a name="ln767">                        edgeNeg-&gt;flow -= dflow;</a>
<a name="ln768">                        pBNS-&gt;vert[cgNeg].st_edge.cap  -= dflow;</a>
<a name="ln769">                        pBNS-&gt;vert[cgNeg].st_edge.flow -= dflow;</a>
<a name="ln770">                        ret ++;</a>
<a name="ln771">                    }</a>
<a name="ln772">                }</a>
<a name="ln773">            }</a>
<a name="ln774">        }</a>
<a name="ln775">        </a>
<a name="ln776">        if ( v2 != vLast ) {</a>
<a name="ln777">            err = BNS_PROGRAM_ERR;</a>
<a name="ln778">        }</a>
<a name="ln779">    }</a>
<a name="ln780">    return err? err : ret;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784"> </a>
<a name="ln785">/*********************************************************************************/</a>
<a name="ln786">int AddOrRemoveExplOrImplH( int nDelta, inp_ATOM *at, int num_atoms, AT_NUMB at_no, T_GROUP_INFO *t_group_info )</a>
<a name="ln787">{</a>
<a name="ln788">    int i, iso, tot_num_iso_H,</a>
<a name="ln789">        num_H,					/* number of H before the removal, including explicit H  */</a>
<a name="ln790">        nNum2Remove,			/*number of H to remove */</a>
<a name="ln791">        nNumRemovedExplicitH,</a>
<a name="ln792">        nNumExplicit2Implicit;</a>
<a name="ln793">    S_CHAR    num_iso_H[NUM_H_ISOTOPES];</a>
<a name="ln794">    inp_ATOM *at_H;</a>
<a name="ln795"> </a>
<a name="ln796">    if ( !nDelta ) {</a>
<a name="ln797">        return 0;</a>
<a name="ln798">    }</a>
<a name="ln799">    /* add */</a>
<a name="ln800">    if ( nDelta &gt; 0 ) {</a>
<a name="ln801">        at[at_no].num_H += nDelta;</a>
<a name="ln802">        t_group_info-&gt;tni.nNumRemovedProtons --;</a>
<a name="ln803">        return nDelta;</a>
<a name="ln804">    }</a>
<a name="ln805">    /* remove */</a>
<a name="ln806">    nNum2Remove            = -nDelta;</a>
<a name="ln807">    nNumRemovedExplicitH   = t_group_info-&gt;tni.nNumRemovedExplicitH; /* number of explicit H saved separately in</a>
<a name="ln808">                                                                       at[num_atoms+i], i=0..nNumRemovedExplicitH-1 */</a>
<a name="ln809">    tot_num_iso_H          = NUM_ISO_H(at,at_no);</a>
<a name="ln810">    num_H                  = at[at_no].num_H;</a>
<a name="ln811">    /*</a>
<a name="ln812">    tot_num_iso_H          = NUM_ISO_H(at,at_no);</a>
<a name="ln813">    num_H                  = at[at_no].num_H;</a>
<a name="ln814">    nNumAtomExplicitH      = 0;</a>
<a name="ln815">    nNumRemovedExplicitH   = t_group_info-&gt;tni.nNumRemovedExplicitH;</a>
<a name="ln816">    tot_num_explicit_iso_H = 0;</a>
<a name="ln817">    */</a>
<a name="ln818">    at_H                   = at + num_atoms;</a>
<a name="ln819">    memcpy( num_iso_H, at[at_no].num_iso_H, sizeof(num_iso_H)); </a>
<a name="ln820">    /*  Remove all explicit H, otherwise a false stereo can occur.</a>
<a name="ln821">        Example: remove H(+) from the following substructure:</a>
<a name="ln822"> </a>
<a name="ln823">               H                                            H</a>
<a name="ln824">       A      /                                      A     / </a>
<a name="ln825">        &gt;X==N(+)    produces false stereogenic bond:  &gt;X==N </a>
<a name="ln826">       B      \                                      B</a>
<a name="ln827">               H</a>
<a name="ln828">        </a>
<a name="ln829">        To avoid this effect all explicit H atoms must be removed</a>
<a name="ln830">    */</a>
<a name="ln831">    nNumExplicit2Implicit = 0;</a>
<a name="ln832">    for ( i = 0; i &lt; nNumRemovedExplicitH; ) {</a>
<a name="ln833">        if ( at_H[i].neighbor[0] == at_no ) {</a>
<a name="ln834">            int m, k, orig_no = at_H[i].orig_at_number;</a>
<a name="ln835">            nNumRemovedExplicitH --;</a>
<a name="ln836">            nNumExplicit2Implicit ++;</a>
<a name="ln837">            if ( nNumRemovedExplicitH &gt; i ) {</a>
<a name="ln838">                inp_ATOM at_i = at_H[i];</a>
<a name="ln839">                memmove( at_H+i, at_H+i+1, sizeof(at_H[0])*(nNumRemovedExplicitH-i) );</a>
<a name="ln840">                at_H[nNumRemovedExplicitH] = at_i; /* save removed H (for debugging purposes?) */</a>
<a name="ln841">            }</a>
<a name="ln842">            /* adjust 0D parities */</a>
<a name="ln843">            if ( at[at_no].sb_parity[0] ) {</a>
<a name="ln844">                for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[at_no].sb_parity[m]; m ++ ) {</a>
<a name="ln845">                    if ( at[at_no].sn_orig_at_num[m] == orig_no ) {</a>
<a name="ln846">#ifdef _DEBUG</a>
<a name="ln847">                        if ( at[at_no].sn_ord[m] &gt;= 0 ) {</a>
<a name="ln848">                            int stop = 1; /* sb maintenance error */</a>
<a name="ln849">                        }</a>
<a name="ln850">#endif</a>
<a name="ln851">                        if ( at[at_no].valence &gt;= MIN_NUM_STEREO_BOND_NEIGH ) {</a>
<a name="ln852">                            at[at_no].sn_ord[m] = k = (at[at_no].sb_ord[m]==0);</a>
<a name="ln853">                            at[at_no].sn_orig_at_num[m] = at[(int)at[at_no].neighbor[k]].orig_at_number;</a>
<a name="ln854">                            if ( ATOM_PARITY_WELL_DEF( at[at_no].sb_parity[m] ) ) {</a>
<a name="ln855">                                at[at_no].sb_parity[m] = 3 - at[at_no].sb_parity[m];</a>
<a name="ln856">                            }</a>
<a name="ln857">                        } else {</a>
<a name="ln858">                            at[at_no].sn_ord[m] = -99; /* no sb neighbor exists anymore */</a>
<a name="ln859">                            at[at_no].sn_orig_at_num[m] = 0;</a>
<a name="ln860">                            if ( ATOM_PARITY_WELL_DEF( at[at_no].sb_parity[m] ) ) {</a>
<a name="ln861">                                int pnxt_atom, pinxt2cur, pinxt_sb_parity_ord;</a>
<a name="ln862">                                if ( 0 &lt; get_opposite_sb_atom( at, at_no, at[at_no].sb_ord[m],</a>
<a name="ln863">                                                  &amp;pnxt_atom, &amp;pinxt2cur, &amp;pinxt_sb_parity_ord ) ) {</a>
<a name="ln864">                                    at[at_no].sb_parity[m] =</a>
<a name="ln865">                                    at[pnxt_atom].sb_parity[pinxt_sb_parity_ord] = AB_PARITY_UNDF;</a>
<a name="ln866">                                }</a>
<a name="ln867">#ifdef _DEBUG</a>
<a name="ln868">                                else {</a>
<a name="ln869">                                    int stop = 1; /* sb maintenance error */</a>
<a name="ln870">                                }</a>
<a name="ln871">#endif</a>
<a name="ln872">                            }</a>
<a name="ln873">                        }</a>
<a name="ln874">                    }</a>
<a name="ln875">                }</a>
<a name="ln876">            }</a>
<a name="ln877">            /* do not increment i here: we have shifted next at_H[] element</a>
<a name="ln878">               to the ith position and decremented nNumRemovedExplicitH */</a>
<a name="ln879">        } else {</a>
<a name="ln880">            i ++;</a>
<a name="ln881">        }</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">    for ( iso = -1; iso &lt; NUM_H_ISOTOPES &amp;&amp; 0 &lt; nNum2Remove; iso ++ ) {</a>
<a name="ln885">        /* each pass removes up to one H */</a>
<a name="ln886">        if ( iso &lt; 0 ) {</a>
<a name="ln887">            /* try to remove non-isotopic */</a>
<a name="ln888">            while ( tot_num_iso_H &lt; num_H &amp;&amp; 0 &lt; nNum2Remove ) {</a>
<a name="ln889">                /* non-isotopic H exists */</a>
<a name="ln890">                num_H --;</a>
<a name="ln891">                t_group_info-&gt;tni.nNumRemovedProtons ++;</a>
<a name="ln892">                nNum2Remove --;</a>
<a name="ln893">            }</a>
<a name="ln894">        } else {</a>
<a name="ln895">            /* remove isotopic */</a>
<a name="ln896">            while ( num_iso_H[iso] &amp;&amp; num_H &amp;&amp; 0 &lt; nNum2Remove ) {</a>
<a name="ln897">                /* isotopic H exists */</a>
<a name="ln898">                num_H --;</a>
<a name="ln899">                num_iso_H[iso] --;</a>
<a name="ln900">                t_group_info-&gt;tni.nNumRemovedProtonsIsotopic[iso] ++;</a>
<a name="ln901">                t_group_info-&gt;tni.nNumRemovedProtons ++;</a>
<a name="ln902">                nNum2Remove --;</a>
<a name="ln903">            }</a>
<a name="ln904">        }</a>
<a name="ln905">    }</a>
<a name="ln906">#if ( bRELEASE_VERSION != 1 )</a>
<a name="ln907">    if ( nNum2Remove ) {</a>
<a name="ln908">        int stop = 1; /* &lt;BRKPT&gt; Program error */</a>
<a name="ln909">    }</a>
<a name="ln910">#endif</a>
<a name="ln911">    if ( nDelta + nNum2Remove &lt; 0 ) {</a>
<a name="ln912">        at[at_no].num_H = num_H;</a>
<a name="ln913">        memcpy( at[at_no].num_iso_H, num_iso_H, sizeof(at[0].num_iso_H));</a>
<a name="ln914">        t_group_info-&gt;tni.nNumRemovedExplicitH = nNumRemovedExplicitH;</a>
<a name="ln915">    }</a>
<a name="ln916">    return nDelta + nNum2Remove;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920"> </a>
<a name="ln921">/*********************************************************************************/</a>
<a name="ln922">int SubtractOrChangeAtHChargeBNS( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms,</a>
<a name="ln923">                                 int nAtTypeTotals[], S_CHAR *mark, T_GROUP_INFO *t_group_info, int bSubtract )</a>
<a name="ln924">{</a>
<a name="ln925">    int       pass, i, v0, v1, v2, ineigh1, /*ineigh2,*/ vLast, n, delta, ret, err = 0;</a>
<a name="ln926">    BNS_EDGE *edge;</a>
<a name="ln927">    int       nDeltaH, nDeltaCharge;</a>
<a name="ln928">    int       mask, type;</a>
<a name="ln929">    </a>
<a name="ln930">    for ( pass = pBNS-&gt;num_altp-1, ret = 0; 0 &lt;= pass; pass -- ) {</a>
<a name="ln931">        </a>
<a name="ln932">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln933">        v1 = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln934">        n  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln935">        delta  = ALTP_DELTA(pBNS-&gt;alt_path);</a>
<a name="ln936">        vLast = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln937">        v0 = v2 = NO_VERTEX;</a>
<a name="ln938"> </a>
<a name="ln939">        for ( i = 0; i &lt; n; i ++, delta = -delta, v0 = v1, v1 = v2 ) {</a>
<a name="ln940">            ineigh1 = ALTP_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v1-&gt;v2 neighbor */</a>
<a name="ln941">            /*ineigh2 = ALTP_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);*/  /* v2-&gt;v1 neighbor */</a>
<a name="ln942">            edge = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[ineigh1];</a>
<a name="ln943">            /* follow the BN Structure, not the inp_ATOM, to take care of swithching to</a>
<a name="ln944">               t-groups, c-groups or other fictitious edges/vertices</a>
<a name="ln945">            */</a>
<a name="ln946">            v2 = edge-&gt;neighbor12 ^ v1;</a>
<a name="ln947">            if ( v1 &lt; num_atoms &amp;&amp; (v0 &gt;= num_atoms || v2 &gt;= num_atoms) ) {</a>
<a name="ln948">                nDeltaH = nDeltaCharge = 0;</a>
<a name="ln949">                if ( v0 &gt;= num_atoms ) {</a>
<a name="ln950">                    /* delta(v0-v1) = -delta(v1-v2) along the alternating path */</a>
<a name="ln951">                    if ( pBNS-&gt;vert[v0].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln952">                        nDeltaH -= delta;</a>
<a name="ln953">                    } else</a>
<a name="ln954">                    if ( pBNS-&gt;vert[v0].type &amp; BNS_VERT_TYPE_C_GROUP ) {</a>
<a name="ln955">                        nDeltaCharge += delta;</a>
<a name="ln956">                    }</a>
<a name="ln957">                }</a>
<a name="ln958">                if ( v2 &gt;= num_atoms ) {</a>
<a name="ln959">                    if ( pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln960">                        nDeltaH += delta;</a>
<a name="ln961">                    } else</a>
<a name="ln962">                    if ( pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_C_GROUP ) {</a>
<a name="ln963">                        nDeltaCharge -= delta;</a>
<a name="ln964">                    }</a>
<a name="ln965">                }</a>
<a name="ln966">                if ( nDeltaH || nDeltaCharge ) {</a>
<a name="ln967">                    if ( bSubtract ) {</a>
<a name="ln968">                        if ( !mark[v1] ) {</a>
<a name="ln969">                            /* first time the atom has been encountered: subtract */</a>
<a name="ln970">#if ( FIX_NORM_BUG_ADD_ION_PAIR == 1 )</a>
<a name="ln971">                            type   = GetAtomChargeType( at, v1, nAtTypeTotals, &amp;mask, 2 );</a>
<a name="ln972">#else</a>
<a name="ln973">                            type   = GetAtomChargeType( at, v1, nAtTypeTotals, &amp;mask, 1 );</a>
<a name="ln974">#endif</a>
<a name="ln975">                            ret ++; /* number of changed atoms */</a>
<a name="ln976">                            mark[v1] ++;</a>
<a name="ln977">                        }</a>
<a name="ln978">                    } else { /* Change */</a>
<a name="ln979">                        at[v1].charge += nDeltaCharge;</a>
<a name="ln980">                        if ( nDeltaH ) {</a>
<a name="ln981">                            AddOrRemoveExplOrImplH( nDeltaH, at, num_atoms, (AT_NUMB)v1, t_group_info );</a>
<a name="ln982">                        }</a>
<a name="ln983">                        ret ++; /* number of changed atoms */</a>
<a name="ln984">                    }</a>
<a name="ln985">                } </a>
<a name="ln986">            }</a>
<a name="ln987">        }</a>
<a name="ln988">        </a>
<a name="ln989">        if ( v2 != vLast ) {</a>
<a name="ln990">            err = BNS_PROGRAM_ERR;</a>
<a name="ln991">        }</a>
<a name="ln992">    }</a>
<a name="ln993">    return err? err : ret;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997"> </a>
<a name="ln998">/*********************************************************************************/</a>
<a name="ln999">int SetBondsFromBnStructFlow( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bChangeFlow0 )</a>
<a name="ln1000">{</a>
<a name="ln1001">    int       pass, i, v0, v1, v2, ineigh1, ineigh2, vLast, n, delta, ret, ret_val, err = 0;</a>
<a name="ln1002">    BNS_EDGE *edge;</a>
<a name="ln1003">    int       bMovingRad  = 0, bChangeFlowAdd;</a>
<a name="ln1004">    int       bChangeFlow = (bChangeFlow0 &amp; ~BNS_EF_SET_NOSTEREO);</a>
<a name="ln1005">    /*</a>
<a name="ln1006">    bCheckMovingRad = (bChangeFlow &amp; BNS_EF_ALTR_NS) == BNS_EF_ALTR_NS &amp;&amp;</a>
<a name="ln1007">                      pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow;</a>
<a name="ln1008">    */</a>
<a name="ln1009">    for ( pass = pBNS-&gt;num_altp-1, ret = 0; 0 &lt;= pass; pass -- ) {</a>
<a name="ln1010">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln1011">        v1 = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln1012">        n  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln1013">        delta  = ALTP_DELTA(pBNS-&gt;alt_path);</a>
<a name="ln1014">        vLast = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln1015">        if ( (bChangeFlow0 &amp; BNS_EF_SET_NOSTEREO) &amp;&amp;</a>
<a name="ln1016">             (pBNS-&gt;vert[v1].st_edge.cap0 &gt; pBNS-&gt;vert[v1].st_edge.flow0 ||</a>
<a name="ln1017">              pBNS-&gt;vert[vLast].st_edge.cap0 &gt; pBNS-&gt;vert[vLast].st_edge.flow0 ) ) {</a>
<a name="ln1018">            bMovingRad ++;</a>
<a name="ln1019">            bChangeFlowAdd = BNS_EF_SET_NOSTEREO;</a>
<a name="ln1020">            ret |= 2;</a>
<a name="ln1021">        } else {</a>
<a name="ln1022">            bChangeFlowAdd = 0;</a>
<a name="ln1023">        }</a>
<a name="ln1024">        /* start vertex */      </a>
<a name="ln1025">        if ( (bChangeFlow &amp; BNS_EF_CHNG_RSTR) == BNS_EF_CHNG_RSTR) {</a>
<a name="ln1026">            /* restore s-v1 edge flow to the BNS this pass input value */</a>
<a name="ln1027">            ; /*pBNS-&gt;vert[v1].st_edge.flow -= delta;*/</a>
<a name="ln1028">        } else</a>
<a name="ln1029">        if ( (bChangeFlow &amp; BNS_EF_SAVE_ALL) == BNS_EF_SAVE_ALL ) {</a>
<a name="ln1030">            if ( v1 &lt; num_atoms ) {</a>
<a name="ln1031">                /* will produce wrong result if called for v1 next time? */</a>
<a name="ln1032">                ret_val = SetAtomRadAndChemValFromVertexCapFlow( pBNS, at, v1 );</a>
<a name="ln1033">                if ( ret_val &lt; 0 ) {</a>
<a name="ln1034">                    err = BNS_PROGRAM_ERR;</a>
<a name="ln1035">                } else {</a>
<a name="ln1036">                    ret |= (ret_val &gt; 0);</a>
<a name="ln1037">                }</a>
<a name="ln1038">            }</a>
<a name="ln1039">            /*pBNS-&gt;vert[v1].st_edge.flow0 = pBNS-&gt;vert[v1].st_edge.flow;*/</a>
<a name="ln1040">        }</a>
<a name="ln1041">        pBNS-&gt;vert[v1].st_edge.pass = 0;</a>
<a name="ln1042">        </a>
<a name="ln1043">        v0 = v2 = NO_VERTEX;</a>
<a name="ln1044">        for ( i = 0; i &lt; n; i ++, delta = -delta, v0 = v1, v1 = v2 ) {</a>
<a name="ln1045">            ineigh1 = ALTP_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v1-&gt;v2 neighbor */</a>
<a name="ln1046">            ineigh2 = ALTP_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v2-&gt;v1 neighbor */</a>
<a name="ln1047">            edge = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[ineigh1];</a>
<a name="ln1048">            /* follow the BN Structure, not the inp_ATOM, to take care of swithching to</a>
<a name="ln1049">               t-groups, c-groups or other fictitious edges/vertices</a>
<a name="ln1050">            */</a>
<a name="ln1051"> </a>
<a name="ln1052">            v2 = edge-&gt;neighbor12 ^ v1;</a>
<a name="ln1053"> </a>
<a name="ln1054">            /* change at-&gt;chem_bonds_valence 2004-03-08 */</a>
<a name="ln1055">            if ( (bChangeFlow &amp; BNS_EF_CHNG_BONDS) &amp;&amp; v1 &lt; num_atoms ) {</a>
<a name="ln1056">                if ( v0 &gt;= num_atoms &amp;&amp; v2 &lt; num_atoms ) {</a>
<a name="ln1057">                    at[v1].chem_bonds_valence += delta; /* change in v1-v2 bond order */</a>
<a name="ln1058">                } else</a>
<a name="ln1059">                if ( v0 &lt; num_atoms &amp;&amp; v2 &gt;= num_atoms &amp;&amp; v0 != NO_VERTEX ) {</a>
<a name="ln1060">                    at[v1].chem_bonds_valence -= delta; /* change in v0-v1 bond order */</a>
<a name="ln1061">                }</a>
<a name="ln1062">            }</a>
<a name="ln1063">            </a>
<a name="ln1064">            if ( !edge-&gt;pass )</a>
<a name="ln1065">                continue;</a>
<a name="ln1066">    </a>
<a name="ln1067">            if ( v1 &lt; num_atoms &amp;&amp; ineigh1 &lt; at[v1].valence &amp;&amp;</a>
<a name="ln1068">                 v2 &lt; num_atoms &amp;&amp; ineigh2 &lt; at[v2].valence ) {</a>
<a name="ln1069">                if ( (bChangeFlow0 &amp; BNS_EF_ALTR_NS )==BNS_EF_ALTR_NS &amp;&amp;</a>
<a name="ln1070">                     (bChangeFlow0 &amp; BNS_EF_SAVE_ALL)==BNS_EF_SAVE_ALL ) {</a>
<a name="ln1071">                    /* 2004-07-02 special mode: save new ring bonds and mark as non-stereo non-ring bonds */</a>
<a name="ln1072">                    if ( at[v1].nRingSystem != at[v2].nRingSystem ) {</a>
<a name="ln1073">                        /* non-ring bond (bridge) */</a>
<a name="ln1074">                        bChangeFlowAdd = BNS_EF_ALTR_NS;</a>
<a name="ln1075">                    } else {</a>
<a name="ln1076">                        /* ring bond */</a>
<a name="ln1077">                        bChangeFlowAdd = 0;</a>
<a name="ln1078">                    }</a>
<a name="ln1079">                }</a>
<a name="ln1080">                /* change bonds on the first pass only: in this case all flow correspond to the BNS output */</a>
<a name="ln1081">                ret_val = SetAtomBondType( edge, &amp;at[v1].bond_type[ineigh1], &amp;at[v2].bond_type[ineigh2], delta, bChangeFlow | bChangeFlowAdd );</a>
<a name="ln1082">                if ( ret_val &lt; 0 ) {</a>
<a name="ln1083">                    err = BNS_PROGRAM_ERR;</a>
<a name="ln1084">                } else {</a>
<a name="ln1085">                    ret |= (ret_val &gt; 0);</a>
<a name="ln1086">                }</a>
<a name="ln1087">            }</a>
<a name="ln1088">            edge-&gt;pass = 0;</a>
<a name="ln1089">        }</a>
<a name="ln1090">        </a>
<a name="ln1091">        if ( v2 != vLast ) {</a>
<a name="ln1092">            err = BNS_PROGRAM_ERR;</a>
<a name="ln1093">        } else</a>
<a name="ln1094">        if ( (bChangeFlow &amp; BNS_EF_CHNG_RSTR) == BNS_EF_CHNG_RSTR) {</a>
<a name="ln1095">            /* restore v2-t edge flow to the BNS this pass input value */</a>
<a name="ln1096">            /* &quot;+=&quot; instead of &quot;-=&quot; explanation: delta must have same sign as at the last edge */</a>
<a name="ln1097">            ; /*pBNS-&gt;vert[v2].st_edge.flow += delta; */</a>
<a name="ln1098">        } else</a>
<a name="ln1099">        if ( (bChangeFlow &amp; BNS_EF_SAVE_ALL) == BNS_EF_SAVE_ALL ) {</a>
<a name="ln1100">            if ( v2 &lt; num_atoms ) {</a>
<a name="ln1101">                ret_val = SetAtomRadAndChemValFromVertexCapFlow( pBNS, at, v2 );</a>
<a name="ln1102">                if ( ret_val &lt; 0 ) {</a>
<a name="ln1103">                    err = BNS_PROGRAM_ERR;</a>
<a name="ln1104">                } else {</a>
<a name="ln1105">                    ret |= (ret_val &gt; 0);</a>
<a name="ln1106">                }</a>
<a name="ln1107">            }</a>
<a name="ln1108">            /*pBNS-&gt;vert[v2].st_edge.flow0 = pBNS-&gt;vert[v2].st_edge.flow;*/</a>
<a name="ln1109">        }</a>
<a name="ln1110">        pBNS-&gt;vert[v2].st_edge.pass = 0;</a>
<a name="ln1111"> </a>
<a name="ln1112">    }</a>
<a name="ln1113">    return err? err : ret;</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116"> </a>
<a name="ln1117"> </a>
<a name="ln1118">/*********************************************************************************/</a>
<a name="ln1119">int MarkAtomsAtTautGroups(  BN_STRUCT *pBNS, int num_atoms, BN_AATG *pAATG, int nEnd1, int nEnd2 )</a>
<a name="ln1120">{</a>
<a name="ln1121">    int       pass, i, j, v1, v2, ineigh1, ineigh2, vLast, vFirst, n, delta, err = 0;</a>
<a name="ln1122">    BNS_EDGE *edge;</a>
<a name="ln1123">    S_CHAR    cDelta[MAX_ALT_AATG_ARRAY_LEN];</a>
<a name="ln1124">    AT_NUMB   nVertex[MAX_ALT_AATG_ARRAY_LEN];</a>
<a name="ln1125">    int       nLenDelta = 0, last_i, nNumFound;</a>
<a name="ln1126"> </a>
<a name="ln1127">    for ( pass = pBNS-&gt;num_altp-1; 0 &lt;= pass; pass -- ) {</a>
<a name="ln1128">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln1129">        vFirst =</a>
<a name="ln1130">        v1 = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln1131">        n  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln1132">        delta  = ALTP_DELTA(pBNS-&gt;alt_path);</a>
<a name="ln1133">        vLast  = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln1134">        v2     = NO_VERTEX;</a>
<a name="ln1135">        pAATG-&gt;nNumFound = 0; /* initialize */</a>
<a name="ln1136"> </a>
<a name="ln1137">        if ( nEnd1 != vFirst &amp;&amp; nEnd1 != vLast ) {</a>
<a name="ln1138">            nEnd1 = -1; /* really not the end */</a>
<a name="ln1139">        }</a>
<a name="ln1140">        if ( nEnd2 != vFirst &amp;&amp; nEnd2 != vLast ) {</a>
<a name="ln1141">            nEnd2 = -1; /* really not the end */</a>
<a name="ln1142">        }</a>
<a name="ln1143"> </a>
<a name="ln1144">        for ( i = 0; i &lt; n; i ++, delta = -delta, v1 = v2 ) {</a>
<a name="ln1145">            ineigh1 = ALTP_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v1-&gt;v2 neighbor */</a>
<a name="ln1146">            ineigh2 = ALTP_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v2-&gt;v1 neighbor */</a>
<a name="ln1147">            edge = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[ineigh1];</a>
<a name="ln1148">            /* follow the BN Structure, not the inp_ATOM, to take care of swithching to</a>
<a name="ln1149">               t-groups, c-groups or other fictitious edges/vertices</a>
<a name="ln1150">            */</a>
<a name="ln1151">            v2 = edge-&gt;neighbor12 ^ v1;</a>
<a name="ln1152">            /*</a>
<a name="ln1153">            if ( v1 &lt; num_atoms &amp;&amp; v2 &lt; num_atoms ) {</a>
<a name="ln1154">                continue;</a>
<a name="ln1155">            }</a>
<a name="ln1156">            */</a>
<a name="ln1157">            /* BNS increased edge flow by delta */</a>
<a name="ln1158">            if ( v1 &gt;= num_atoms &amp;&amp; </a>
<a name="ln1159">                 ((pBNS-&gt;vert[v1].type &amp; BNS_VERT_TYPE_TGROUP)||(pBNS-&gt;vert[v1].type &amp; BNS_VERT_TYPE_TEMP)) &amp;&amp;</a>
<a name="ln1160">                 0 &lt;= v2 &amp;&amp; v2 &lt;  num_atoms &amp;&amp; (pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_ATOM  ) ) {</a>
<a name="ln1161">                /*</a>
<a name="ln1162">                if ( !(pAATG-&gt;nMarkedAtom[v2] &amp; AATG_MARK_IN_PATH) ) {</a>
<a name="ln1163">                    pAATG-&gt;nMarkedAtom[v2] |= AATG_MARK_IN_PATH;</a>
<a name="ln1164">                    pAATG-&gt;nNumFound ++;</a>
<a name="ln1165">                }</a>
<a name="ln1166">                */</a>
<a name="ln1167">                /* BNS increased bond order in  v1(t-group)-v2(atom) by delta: added delta attachments */</a>
<a name="ln1168">                if ( nLenDelta &lt; MAX_ALT_AATG_ARRAY_LEN ) {</a>
<a name="ln1169">                    cDelta[nLenDelta]  = delta;</a>
<a name="ln1170">                    nVertex[nLenDelta] = v2;</a>
<a name="ln1171">                    nLenDelta ++;</a>
<a name="ln1172">                }</a>
<a name="ln1173">            } else</a>
<a name="ln1174">            if ( v2 &gt;= num_atoms &amp;&amp;</a>
<a name="ln1175">                 ((pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_TGROUP)||(pBNS-&gt;vert[v2].type &amp; BNS_VERT_TYPE_TEMP)) &amp;&amp;</a>
<a name="ln1176">                 0 &lt;= v1 &amp;&amp; v1 &lt;  num_atoms &amp;&amp; (pBNS-&gt;vert[v1].type &amp; BNS_VERT_TYPE_ATOM  ) ) {</a>
<a name="ln1177">                /*</a>
<a name="ln1178">                if ( !(pAATG-&gt;nMarkedAtom[v1] &amp; AATG_MARK_IN_PATH) ) {</a>
<a name="ln1179">                    pAATG-&gt;nMarkedAtom[v1] |= AATG_MARK_IN_PATH;</a>
<a name="ln1180">                    pAATG-&gt;nNumFound ++;</a>
<a name="ln1181">                }</a>
<a name="ln1182">                */</a>
<a name="ln1183">                /* BNS increased bond order in  v1(atom)-v2(t-group) by delta: added delta attachments */</a>
<a name="ln1184">                if ( nLenDelta &lt; MAX_ALT_AATG_ARRAY_LEN ) {</a>
<a name="ln1185">                    cDelta[nLenDelta]  = delta;</a>
<a name="ln1186">                    nVertex[nLenDelta] = v1;</a>
<a name="ln1187">                    nLenDelta ++;</a>
<a name="ln1188">                }</a>
<a name="ln1189">            } else</a>
<a name="ln1190">            /* special case when the testing 'dot' was placed on an atom (should be nEnd1 only) */</a>
<a name="ln1191">            if ( ((0 &lt;= v1) &amp;&amp; (v1 == nEnd1)) || ((v1 == nEnd2) &amp;&amp; (0 &lt;= v2) &amp;&amp; (v2 &lt; num_atoms)) ) {</a>
<a name="ln1192">                if ( nLenDelta &lt; MAX_ALT_AATG_ARRAY_LEN ) {</a>
<a name="ln1193">                    cDelta[nLenDelta]  = -delta;</a>
<a name="ln1194">                    nVertex[nLenDelta] = v1;</a>
<a name="ln1195">                    nLenDelta ++;</a>
<a name="ln1196">                }</a>
<a name="ln1197">            } else</a>
<a name="ln1198">            if ( ((0 &lt;= v2) &amp;&amp; (v2 == nEnd1)) || ((v2 == nEnd2) &amp;&amp; (0 &lt;= v1) &amp;&amp; (v1 &lt; num_atoms)) ) {</a>
<a name="ln1199">                if ( nLenDelta &lt; MAX_ALT_AATG_ARRAY_LEN ) {</a>
<a name="ln1200">                    cDelta[nLenDelta]  = -delta;</a>
<a name="ln1201">                    nVertex[nLenDelta] = v2;</a>
<a name="ln1202">                    nLenDelta ++;</a>
<a name="ln1203">                }</a>
<a name="ln1204">            }</a>
<a name="ln1205">        }</a>
<a name="ln1206">        </a>
<a name="ln1207">        if ( v2 != vLast ) {</a>
<a name="ln1208">            err = BNS_PROGRAM_ERR;</a>
<a name="ln1209">        } else {</a>
<a name="ln1210">            last_i = -1;</a>
<a name="ln1211">            nNumFound = 0;</a>
<a name="ln1212">            /* first run */</a>
<a name="ln1213">            for ( i = 1, j = 0; i &lt; nLenDelta; j = i ++ ) {</a>
<a name="ln1214">                /* ignore sequences (-1,+1) and (+1,-1) in cDelta[] because they  */</a>
<a name="ln1215">                /* describe ordinary aug. paths of moving a single attachment     */</a>
<a name="ln1216">                /* we are looking for aug. paths describing movement of 2 or more */</a>
<a name="ln1217">                if ( ((cDelta[j] &gt; 0) &amp;&amp; (cDelta[i] &gt; 0)) ||</a>
<a name="ln1218">                     ((cDelta[j] &lt; 0) &amp;&amp; (cDelta[i] &lt; 0)) ) {</a>
<a name="ln1219">                    if ( j == last_i ) {</a>
<a name="ln1220">                        /* three attachments moved */</a>
<a name="ln1221">                        return 0;</a>
<a name="ln1222">                    }</a>
<a name="ln1223">                    v1 = nVertex[j];</a>
<a name="ln1224">                    if ( !(pAATG-&gt;nMarkedAtom[v1] &amp; AATG_MARK_IN_PATH) ) {</a>
<a name="ln1225">                        nNumFound ++;</a>
<a name="ln1226">                    }</a>
<a name="ln1227">                    v2 = nVertex[i];</a>
<a name="ln1228">                    if ( !(pAATG-&gt;nMarkedAtom[v2] &amp; AATG_MARK_IN_PATH) ) {</a>
<a name="ln1229">                        nNumFound ++;</a>
<a name="ln1230">                    }</a>
<a name="ln1231">                    last_i = i;</a>
<a name="ln1232">                }</a>
<a name="ln1233">            }</a>
<a name="ln1234">            if ( !nNumFound ) {</a>
<a name="ln1235">                return 0;</a>
<a name="ln1236">            }</a>
<a name="ln1237">            if ( nNumFound &gt; 4 ) {</a>
<a name="ln1238">                return 0;</a>
<a name="ln1239">            }</a>
<a name="ln1240">            if ( nNumFound &lt; 4 ) {</a>
<a name="ln1241">                return 0;</a>
<a name="ln1242">            }</a>
<a name="ln1243">            /* second run */</a>
<a name="ln1244">            for ( i = 1, j = 0; i &lt; nLenDelta; j = i ++ ) {</a>
<a name="ln1245">                /* ignore sequences (-1,+1) and (+1,-1) in cDelta[] because they  */</a>
<a name="ln1246">                /* describe ordinary aug. paths of moving a single attachment     */</a>
<a name="ln1247">                /* we are looking for aug. paths describing movement of 2 or more */</a>
<a name="ln1248">                if ( ((cDelta[j] &gt; 0) &amp;&amp; (cDelta[i] &gt; 0)) ||</a>
<a name="ln1249">                     ((cDelta[j] &lt; 0) &amp;&amp; (cDelta[i] &lt; 0)) ) {</a>
<a name="ln1250">                    v1 = nVertex[i-1];</a>
<a name="ln1251">                    if ( !(pAATG-&gt;nMarkedAtom[v1] &amp; AATG_MARK_IN_PATH) ) {</a>
<a name="ln1252">                        pAATG-&gt;nMarkedAtom[v1] |= AATG_MARK_IN_PATH;</a>
<a name="ln1253">                        pAATG-&gt;nNumFound ++;</a>
<a name="ln1254">                    }</a>
<a name="ln1255">                    v2 = nVertex[i];</a>
<a name="ln1256">                    if ( !(pAATG-&gt;nMarkedAtom[v2] &amp; AATG_MARK_IN_PATH) ) {</a>
<a name="ln1257">                        pAATG-&gt;nMarkedAtom[v2] |= AATG_MARK_IN_PATH;</a>
<a name="ln1258">                        pAATG-&gt;nNumFound ++;</a>
<a name="ln1259">                    }</a>
<a name="ln1260">                }</a>
<a name="ln1261">            }</a>
<a name="ln1262">        }</a>
<a name="ln1263">    }</a>
<a name="ln1264">    return err? err : pAATG-&gt;nNumFound;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267"> </a>
<a name="ln1268"> </a>
<a name="ln1269">/*********************************************************************************/</a>
<a name="ln1270">int RestoreBnStructFlow( BN_STRUCT *pBNS, int bChangeFlow )</a>
<a name="ln1271">{</a>
<a name="ln1272">    int       pass, i, v1, v2, ineigh1, ineigh2, vLast, n, delta, ret, err = 0;</a>
<a name="ln1273">    BNS_EDGE *edge;</a>
<a name="ln1274">    </a>
<a name="ln1275">    for ( pass = pBNS-&gt;num_altp - 1, ret = 0; 0 &lt;= pass; pass -- ) {</a>
<a name="ln1276">        pBNS-&gt;alt_path = pBNS-&gt;altp[pass];</a>
<a name="ln1277">        v1 = ALTP_START_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln1278">        n  = ALTP_PATH_LEN(pBNS-&gt;alt_path);</a>
<a name="ln1279">        delta  = ALTP_DELTA(pBNS-&gt;alt_path);</a>
<a name="ln1280">        vLast  = ALTP_END_ATOM(pBNS-&gt;alt_path);</a>
<a name="ln1281">        v2     = NO_VERTEX;</a>
<a name="ln1282">        /* starting vertex */</a>
<a name="ln1283">        if ( (bChangeFlow &amp; BNS_EF_CHNG_RSTR) == BNS_EF_CHNG_RSTR) {</a>
<a name="ln1284">            pBNS-&gt;vert[v1].st_edge.flow -= delta; /* restore s-v1 edge flow to the BNS input value */</a>
<a name="ln1285">        } else</a>
<a name="ln1286">        if ( (bChangeFlow &amp; BNS_EF_SAVE_ALL) == BNS_EF_SAVE_ALL ) {</a>
<a name="ln1287">            pBNS-&gt;vert[v1].st_edge.flow0 = pBNS-&gt;vert[v1].st_edge.flow;</a>
<a name="ln1288">        }</a>
<a name="ln1289">        /* augmenting path edges */</a>
<a name="ln1290">        for ( i = 0; i &lt; n; i ++, delta = -delta, v1 = v2 ) {</a>
<a name="ln1291">            ineigh1 = ALTP_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v1-&gt;v2 neighbor */</a>
<a name="ln1292">            ineigh2 = ALTP_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path, i);  /* v2-&gt;v1 neighbor */</a>
<a name="ln1293">            edge = pBNS-&gt;edge + pBNS-&gt;vert[v1].iedge[ineigh1];</a>
<a name="ln1294">            v2 = edge-&gt;neighbor12 ^ v1;</a>
<a name="ln1295">            RestoreEdgeFlow( edge, delta, bChangeFlow );</a>
<a name="ln1296">            edge-&gt;pass = 0;</a>
<a name="ln1297">        }</a>
<a name="ln1298">        /* ending vertex */</a>
<a name="ln1299">        if ( v2 != vLast ) {</a>
<a name="ln1300">            err = BNS_PROGRAM_ERR;</a>
<a name="ln1301">        } else</a>
<a name="ln1302">        if ( (bChangeFlow &amp; BNS_EF_CHNG_RSTR) == BNS_EF_CHNG_RSTR) {</a>
<a name="ln1303">            /* restore v2-t edge flow to the original value */</a>
<a name="ln1304">            /* &quot;+=&quot; instead of &quot;-=&quot; explanation: delta must have same sign as at the last edge */</a>
<a name="ln1305">            pBNS-&gt;vert[v2].st_edge.flow += delta; </a>
<a name="ln1306">        } else</a>
<a name="ln1307">        if ( (bChangeFlow &amp; BNS_EF_SAVE_ALL) == BNS_EF_SAVE_ALL ) {</a>
<a name="ln1308">            pBNS-&gt;vert[v2].st_edge.flow0 = pBNS-&gt;vert[v2].st_edge.flow;</a>
<a name="ln1309">        }</a>
<a name="ln1310"> </a>
<a name="ln1311">    }</a>
<a name="ln1312">    return err? err : ret;</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315"> </a>
<a name="ln1316"> </a>
<a name="ln1317">/***************************************************************************************/</a>
<a name="ln1318">int bNeedToTestTheFlow( int bond_type, int nTestFlow, int bTestForNonStereoBond )</a>
<a name="ln1319">{</a>
<a name="ln1320">    int nBondType   = ( BOND_TYPE_MASK &amp; bond_type );</a>
<a name="ln1321">    int nBondAttrib = ( BOND_MARK_MASK &amp; bond_type );</a>
<a name="ln1322"> </a>
<a name="ln1323">    if ( bTestForNonStereoBond ) {</a>
<a name="ln1324">        if ( nBondAttrib || nBondType == BOND_ALTERN || nBondType == BOND_ALT12NS ) {</a>
<a name="ln1325">            switch( nTestFlow ) {</a>
<a name="ln1326">            case 0:  /* single: can be 1 (single)?  */</a>
<a name="ln1327">                if ( nBondAttrib == BOND_MARK_ALT12NS||</a>
<a name="ln1328">                     nBondAttrib == BOND_MARK_ALT123 ||</a>
<a name="ln1329">                     nBondAttrib == BOND_MARK_ALT13  ) {</a>
<a name="ln1330">                    return 0; /* yes, already checked */</a>
<a name="ln1331">                }</a>
<a name="ln1332">                break;</a>
<a name="ln1333">             </a>
<a name="ln1334">            case 1:  /* double: can be 2 (double)? */</a>
<a name="ln1335">                if ( nBondAttrib == BOND_MARK_ALT12NS||</a>
<a name="ln1336">                     nBondAttrib == BOND_MARK_ALT123 ||</a>
<a name="ln1337">                     nBondAttrib == BOND_MARK_ALT23  ) {</a>
<a name="ln1338">                    return 0; /* yes, already checked */</a>
<a name="ln1339">                }</a>
<a name="ln1340">                break;</a>
<a name="ln1341">            case 2:  /* triple: can be 3 (triple)?  */</a>
<a name="ln1342">                if ( nBondAttrib == BOND_MARK_ALT13  ||</a>
<a name="ln1343">                     nBondAttrib == BOND_MARK_ALT123 ||</a>
<a name="ln1344">                     nBondAttrib == BOND_MARK_ALT23  ) {</a>
<a name="ln1345">                    return 0; /* yes, already checked */</a>
<a name="ln1346">                }</a>
<a name="ln1347">                break;</a>
<a name="ln1348">            }</a>
<a name="ln1349">        }</a>
<a name="ln1350">    } else {</a>
<a name="ln1351">        if ( nBondAttrib || nBondType == BOND_ALTERN || nBondType == BOND_ALT12NS ) {</a>
<a name="ln1352">            switch( nTestFlow ) {</a>
<a name="ln1353">            case 0:  /* single: can be 1 (single)?  */</a>
<a name="ln1354">                if ( nBondAttrib == BOND_MARK_ALT12  ||</a>
<a name="ln1355">                     nBondAttrib == BOND_MARK_ALT12NS||</a>
<a name="ln1356">                     nBondAttrib == BOND_MARK_ALT123 ||</a>
<a name="ln1357">                     nBondAttrib == BOND_MARK_ALT13  ) {</a>
<a name="ln1358">                    return 0;</a>
<a name="ln1359">                }</a>
<a name="ln1360">                break;</a>
<a name="ln1361">             </a>
<a name="ln1362">            case 1:  /* double: can be 2 (double)? */</a>
<a name="ln1363">                if ( nBondAttrib == BOND_MARK_ALT12  ||</a>
<a name="ln1364">                     nBondAttrib == BOND_MARK_ALT12NS||</a>
<a name="ln1365">                     nBondAttrib == BOND_MARK_ALT123 ||</a>
<a name="ln1366">                     nBondAttrib == BOND_MARK_ALT23  ) {</a>
<a name="ln1367">                    return 0; /* yes */</a>
<a name="ln1368">                }</a>
<a name="ln1369">                break;</a>
<a name="ln1370">            case 2:  /* triple: can be 3 (triple)?  */</a>
<a name="ln1371">                if ( nBondAttrib == BOND_MARK_ALT13  ||</a>
<a name="ln1372">                     nBondAttrib == BOND_MARK_ALT123 ||</a>
<a name="ln1373">                     nBondAttrib == BOND_MARK_ALT23  ) {</a>
<a name="ln1374">                    return 0;</a>
<a name="ln1375">                }</a>
<a name="ln1376">                break;</a>
<a name="ln1377">            }</a>
<a name="ln1378">        }</a>
<a name="ln1379">    }</a>
<a name="ln1380">    return 1;</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">/***********************************************************************************/</a>
<a name="ln1386">int nBondsValenceInpAt( const inp_ATOM *at, int *nNumAltBonds, int *nNumWrongBonds )</a>
<a name="ln1387">{</a>
<a name="ln1388">    int j, bond_type, nBondsValence = 0, nAltBonds = 0, nNumWrong = 0;</a>
<a name="ln1389">    for ( j = 0; j &lt; at-&gt;valence; j ++ ) {</a>
<a name="ln1390">        bond_type = at-&gt;bond_type[j] &amp; BOND_TYPE_MASK;</a>
<a name="ln1391">        switch( bond_type ) {</a>
<a name="ln1392">            case 0:  /* for structure from InChI reconstruction */</a>
<a name="ln1393">            case BOND_SINGLE:</a>
<a name="ln1394">            case BOND_DOUBLE:</a>
<a name="ln1395">            case BOND_TRIPLE:</a>
<a name="ln1396">                nBondsValence += bond_type;</a>
<a name="ln1397">                break;</a>
<a name="ln1398">            case BOND_ALTERN:</a>
<a name="ln1399">                nAltBonds ++;</a>
<a name="ln1400">                break;</a>
<a name="ln1401">            default:</a>
<a name="ln1402">                nNumWrong ++;</a>
<a name="ln1403">        }</a>
<a name="ln1404">    }</a>
<a name="ln1405">    switch ( nAltBonds ) {</a>
<a name="ln1406">    case 0:</a>
<a name="ln1407">        break;</a>
<a name="ln1408">    case 1:</a>
<a name="ln1409">        nBondsValence += 1; /* 1 or greater than 3 is wrong */</a>
<a name="ln1410">        nNumWrong ++;</a>
<a name="ln1411">        break;</a>
<a name="ln1412">    default:</a>
<a name="ln1413">        nBondsValence += nAltBonds+1;</a>
<a name="ln1414">        break;</a>
<a name="ln1415">    }</a>
<a name="ln1416">    if ( nNumAltBonds ) *nNumAltBonds = nAltBonds;</a>
<a name="ln1417">    if ( nNumWrongBonds ) *nNumWrongBonds = nNumWrong;</a>
<a name="ln1418">    return nBondsValence;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421"> </a>
<a name="ln1422"> </a>
<a name="ln1423">/******************************************************************************/</a>
<a name="ln1424">/* if radical or has aromatic bonds then augment to the lowest &quot;multiplicity&quot; */</a>
<a name="ln1425">/******************************************************************************/</a>
<a name="ln1426">int BnsAdjustFlowBondsRad( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at, int num_atoms )</a>
<a name="ln1427">{</a>
<a name="ln1428">    int  bError=0, nOrigDelta=0, ret, num_removed;</a>
<a name="ln1429"> </a>
<a name="ln1430">#if( CHECK_AROMBOND2ALT == 1 )    </a>
<a name="ln1431">    int *pcValMinusBondsVal = NULL;</a>
<a name="ln1432">    int  i, nValMinusBondsVal, nAltBonds, bIgnore, valen, is_rad, excess;</a>
<a name="ln1433">    </a>
<a name="ln1434">    /* find valence excess (it may only be due to aromatic bonds) */</a>
<a name="ln1435">    for ( i = 0; i &lt; num_atoms; i ++ ) </a>
<a name="ln1436">    {</a>
<a name="ln1437">        valen = nBondsValenceInpAt( at+i, &amp;nAltBonds, &amp;bIgnore );</a>
<a name="ln1438">        nValMinusBondsVal = (int)at[i].chem_bonds_valence - valen;</a>
<a name="ln1439">        bIgnore += (nAltBonds &gt; 3);</a>
<a name="ln1440">        if ( !bIgnore &amp;&amp; nValMinusBondsVal &gt; 0 ) </a>
<a name="ln1441">        {</a>
<a name="ln1442">            if ( !pcValMinusBondsVal &amp;&amp; </a>
<a name="ln1443">                 !(pcValMinusBondsVal = (int *)inchi_calloc(num_atoms, sizeof(pcValMinusBondsVal[0]))))				 </a>
<a name="ln1444">            {</a>
<a name="ln1445">                    bError = BNS_OUT_OF_RAM;</a>
<a name="ln1446">                    goto exit_function;</a>
<a name="ln1447">            }</a>
<a name="ln1448">            /* mark atoms that have extra unsatisfied valence due to aromatic bonds */</a>
<a name="ln1449">            is_rad = (at[i].radical == RADICAL_DOUBLET);</a>
<a name="ln1450">            excess = nValMinusBondsVal+ is_rad;</a>
<a name="ln1451">            pcValMinusBondsVal[i] = excess;</a>
<a name="ln1452">        }</a>
<a name="ln1453">    }</a>
<a name="ln1454">#endif /* CHECK_AROMBOND2ALT */</a>
<a name="ln1455"> </a>
<a name="ln1456">    /* match bonds to valences */</a>
<a name="ln1457">    do </a>
<a name="ln1458">    {</a>
<a name="ln1459">        num_removed = 0;</a>
<a name="ln1460">        ret = RunBalancedNetworkSearch( pBNS, pBD, BNS_EF_CHNG_FLOW );</a>
<a name="ln1461">        if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln1462">        {</a>
<a name="ln1463">            bError = ret;</a>
<a name="ln1464">        } </a>
<a name="ln1465">        else </a>
<a name="ln1466">        {</a>
<a name="ln1467">            nOrigDelta += ret;</a>
<a name="ln1468">            num_removed = pBNS-&gt;num_altp; /* number of augmenting paths */</a>
<a name="ln1469">            if ( ret &gt; 0 ) </a>
<a name="ln1470">            {</a>
<a name="ln1471">                /* save new bonds in at[] and flows in pBNS and at[] */</a>
<a name="ln1472">                ret = SetBondsFromBnStructFlow( pBNS, at, num_atoms, BNS_EF_SAVE_ALL ); /* must include 1: 5=(4|1) */</a>
<a name="ln1473">                if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln1474">                {</a>
<a name="ln1475">                    bError = ret;</a>
<a name="ln1476">                }</a>
<a name="ln1477">                ret = RestoreBnStructFlow( pBNS, BNS_EF_SAVE_ALL ); /* must include 1: 5=(4|1) */</a>
<a name="ln1478">                if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln1479">                {</a>
<a name="ln1480">                    bError = ret;</a>
<a name="ln1481">                }</a>
<a name="ln1482">            }</a>
<a name="ln1483">            ReInitBnStructAltPaths( pBNS );</a>
<a name="ln1484">        }</a>
<a name="ln1485">    } while ( num_removed &amp;&amp; num_removed == pBNS-&gt;max_altp &amp;&amp; !bError );</a>
<a name="ln1486"> </a>
<a name="ln1487">#if( CHECK_AROMBOND2ALT == 1 )    </a>
<a name="ln1488">    /* check whether aromatic bonds have been replaces with alternating bonds */</a>
<a name="ln1489">    if ( !bError &amp;&amp; pcValMinusBondsVal ) </a>
<a name="ln1490">    {</a>
<a name="ln1491">        for ( i = 0; i &lt; num_atoms; i ++ ) </a>
<a name="ln1492">        {</a>
<a name="ln1493">            if ( !pcValMinusBondsVal[i] )</a>
<a name="ln1494">                continue;</a>
<a name="ln1495">            valen = nBondsValenceInpAt( at+i, &amp;nAltBonds, &amp;bIgnore );</a>
<a name="ln1496">            nValMinusBondsVal = (int)at[i].chem_bonds_valence - valen;</a>
<a name="ln1497">            is_rad = (at[i].radical == RADICAL_DOUBLET);</a>
<a name="ln1498">            excess = nValMinusBondsVal + is_rad;</a>
<a name="ln1499">            if ( bIgnore ||</a>
<a name="ln1500">                 ( pcValMinusBondsVal[i] - excess ) != 1 )</a>
<a name="ln1501">            {</a>
<a name="ln1502">                /* radical excess has not been reduced */</a>
<a name="ln1503">                bError = BNS_ALTBOND_ERR;</a>
<a name="ln1504">                break;</a>
<a name="ln1505">            }</a>
<a name="ln1506">        }</a>
<a name="ln1507">    }</a>
<a name="ln1508"> </a>
<a name="ln1509">exit_function:</a>
<a name="ln1510">    if ( pcValMinusBondsVal ) </a>
<a name="ln1511">        inchi_free( pcValMinusBondsVal );</a>
<a name="ln1512">#endif /* CHECK_AROMBOND2ALT */</a>
<a name="ln1513"> </a>
<a name="ln1514">    return bError? bError : nOrigDelta;</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517"> </a>
<a name="ln1518"> </a>
<a name="ln1519">/***************************************************************************************/</a>
<a name="ln1520">int BnsTestAndMarkAltBonds(  BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at, int num_atoms, BNS_FLOW_CHANGES *fcd, int bChangeFlow, int nBondTypeToTest )</a>
<a name="ln1521">{</a>
<a name="ln1522">    int ret, iat, ineigh, neigh;</a>
<a name="ln1523">    int nMinFlow, nMaxFlow, nTestFlow, nCurFlow;</a>
<a name="ln1524">    int iedge, bSuccess, bError, nDots, nChanges, bTestForNonStereoBond;</a>
<a name="ln1525">    /* Normalize bonds and find tautomeric groups */</a>
<a name="ln1526">    bError   = 0;</a>
<a name="ln1527">    nChanges = 0;</a>
<a name="ln1528">    bTestForNonStereoBond = pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow;</a>
<a name="ln1529">    for ( iat = 0; iat &lt; num_atoms &amp;&amp; !bError; iat ++ ) {</a>
<a name="ln1530">        for ( ineigh = 0; ineigh &lt; at[iat].valence &amp;&amp; !bError; ineigh ++ ) {</a>
<a name="ln1531">            neigh = at[iat].neighbor[ineigh];</a>
<a name="ln1532">            if ( neigh &lt; iat )</a>
<a name="ln1533">                continue; /* we have already tested the bond */</a>
<a name="ln1534">            iedge = pBNS-&gt;vert[iat].iedge[ineigh];</a>
<a name="ln1535">            if ( IS_FORBIDDEN(pBNS-&gt;edge[iedge].forbidden, pBNS) )</a>
<a name="ln1536">                continue;</a>
<a name="ln1537">            if ( nBondTypeToTest &amp;&amp; (at[iat].bond_type[ineigh] &amp; BOND_TYPE_MASK) != nBondTypeToTest )</a>
<a name="ln1538">                continue;</a>
<a name="ln1539">            nMinFlow = nMinFlow2Check( pBNS, iedge );</a>
<a name="ln1540">            nMaxFlow = nMaxFlow2Check( pBNS, iedge );</a>
<a name="ln1541">            nCurFlow = nCurFlow2Check( pBNS, iedge );</a>
<a name="ln1542">            if ( nMinFlow == nMaxFlow ) {</a>
<a name="ln1543">                if ( nMaxFlow &amp;&amp; bTestForNonStereoBond ) {</a>
<a name="ln1544">                    nTestFlow = nMaxFlow - (int)(pBNS-&gt;tot_st_cap - pBNS-&gt;tot_st_flow); /* temporary use of nTestFlow */</a>
<a name="ln1545">                    nMinFlow = inchi_max( 0, nTestFlow );</a>
<a name="ln1546">                } else {</a>
<a name="ln1547">                    continue;</a>
<a name="ln1548">                }</a>
<a name="ln1549">            }</a>
<a name="ln1550">            for ( nTestFlow = nMinFlow; nTestFlow &lt;= nMaxFlow &amp;&amp; !bError; nTestFlow ++ ) {</a>
<a name="ln1551">                if ( nTestFlow == nCurFlow )</a>
<a name="ln1552">                    continue;</a>
<a name="ln1553">                if ( !bNeedToTestTheFlow( at[iat].bond_type[ineigh], nTestFlow, bTestForNonStereoBond ) )</a>
<a name="ln1554">                    continue;</a>
<a name="ln1555">                bSuccess = 0;</a>
<a name="ln1556">                nDots = bSetFlowToCheckOneBond( pBNS, iedge, nTestFlow, fcd );</a>
<a name="ln1557">                if ( IS_BNS_ERROR(nDots) ) {</a>
<a name="ln1558">                    if ( nDots == BNS_CANT_SET_BOND ) {</a>
<a name="ln1559">                        ret = bRestoreFlowAfterCheckOneBond( pBNS, fcd );</a>
<a name="ln1560">                        if ( !IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1561">                            continue;</a>
<a name="ln1562">                        }</a>
<a name="ln1563">                    }</a>
<a name="ln1564">                    bError = nDots;</a>
<a name="ln1565">                } else</a>
<a name="ln1566">                if ( nDots &gt; 0 ) {</a>
<a name="ln1567">                    ret = RunBalancedNetworkSearch( pBNS, pBD, bChangeFlow );</a>
<a name="ln1568">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1569">                        bError = ret;</a>
<a name="ln1570">                    } else</a>
<a name="ln1571">                    if ( ret &gt; 0 ) {</a>
<a name="ln1572">                        if ( 2*ret == nDots ) {</a>
<a name="ln1573">                            ret = bSetBondsAfterCheckOneBond( pBNS, fcd, nTestFlow, at, num_atoms, bChangeFlow );</a>
<a name="ln1574">                            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1575">                                bError = ret;</a>
<a name="ln1576">                            } else {</a>
<a name="ln1577">                                nChanges += (ret &amp; 1);</a>
<a name="ln1578">                                ret = SetBondsFromBnStructFlow( pBNS, at, num_atoms, bChangeFlow );</a>
<a name="ln1579">                                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1580">                                    bError = ret;</a>
<a name="ln1581">                                } else</a>
<a name="ln1582">                                if ( ret &gt;= 0 ) {</a>
<a name="ln1583">                                    nChanges += (ret &amp; 1);</a>
<a name="ln1584">                                    bSuccess = 1;</a>
<a name="ln1585">                                } else {</a>
<a name="ln1586">                                    bError = ret;</a>
<a name="ln1587">                                }</a>
<a name="ln1588">                            }</a>
<a name="ln1589">                        }</a>
<a name="ln1590">                        /* typically 2*ret &lt; nDots; 2*ret &gt; nDots should not happen. Check later */</a>
<a name="ln1591">                        ret = RestoreBnStructFlow( pBNS, bChangeFlow &amp; BNS_EF_CHNG_RSTR);</a>
<a name="ln1592">                        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1593">                            bError = ret;</a>
<a name="ln1594">                        }</a>
<a name="ln1595">                    }</a>
<a name="ln1596">                    /* --- reinitialize to repeat the calculations --- */</a>
<a name="ln1597">                    ReInitBnStructAltPaths( pBNS );</a>
<a name="ln1598">                } else</a>
<a name="ln1599">                if ( nDots == 0 ) {</a>
<a name="ln1600">                    ret = bSetBondsAfterCheckOneBond( pBNS, fcd, nTestFlow, at, num_atoms, bChangeFlow );</a>
<a name="ln1601">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1602">                        bError = ret;</a>
<a name="ln1603">                    } else {</a>
<a name="ln1604">                        nChanges += (ret &amp; 1);</a>
<a name="ln1605">                    }</a>
<a name="ln1606">                }</a>
<a name="ln1607">                ret = bRestoreFlowAfterCheckOneBond( pBNS, fcd );</a>
<a name="ln1608">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln1609">                    bError = ret;</a>
<a name="ln1610">                }</a>
<a name="ln1611">            }</a>
<a name="ln1612">        }</a>
<a name="ln1613">    }</a>
<a name="ln1614">    return bError? bError : nChanges;</a>
<a name="ln1615">}</a>
<a name="ln1616"> </a>
<a name="ln1617"> </a>
<a name="ln1618"> </a>
<a name="ln1619">/************************************************************************/</a>
<a name="ln1620">static void remove_alt_bond_marks(inp_ATOM *at, int num_atoms)</a>
<a name="ln1621">{</a>
<a name="ln1622">    int i, j, val;</a>
<a name="ln1623">    for ( i = 0; i &lt; num_atoms; i++ ) {</a>
<a name="ln1624">        for ( val = at[i].valence, j = 0; j &lt; val; j ++ ) {</a>
<a name="ln1625">            at[i].bond_type[j] &amp;= BOND_TYPE_MASK;</a>
<a name="ln1626">        }</a>
<a name="ln1627">    }</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630"> </a>
<a name="ln1631"> </a>
<a name="ln1632">/***************************************************************************************/</a>
<a name="ln1633">int SetForbiddenEdges( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int forbidden_mask )</a>
<a name="ln1634">{</a>
<a name="ln1635">    static U_CHAR el_number_O;</a>
<a name="ln1636">    static U_CHAR el_number_C;</a>
<a name="ln1637">    static U_CHAR el_number_N;</a>
<a name="ln1638"> </a>
<a name="ln1639">    int i, j, neigh, num_found;</a>
<a name="ln1640">    BNS_IEDGE iedge;</a>
<a name="ln1641">    /*S_CHAR    edge_forbidden_mask = BNS_EDGE_FORBIDDEN_MASK;*/</a>
<a name="ln1642">    S_CHAR    edge_forbidden_mask = forbidden_mask;</a>
<a name="ln1643"> </a>
<a name="ln1644">    pBNS-&gt;edge_forbidden_mask |= forbidden_mask;</a>
<a name="ln1645"> </a>
<a name="ln1646">    if ( !el_number_C ) {</a>
<a name="ln1647">        el_number_O = (U_CHAR)get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln1648">        el_number_C = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln1649">        el_number_N = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln1650">    }</a>
<a name="ln1651">    </a>
<a name="ln1652">    num_found = 0;</a>
<a name="ln1653"> </a>
<a name="ln1654">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1655">        /* acetyl */</a>
<a name="ln1656">        if ( at[i].el_number == el_number_C &amp;&amp; 3 == at[i].valence &amp;&amp;</a>
<a name="ln1657">             4 == at[i].chem_bonds_valence ) {</a>
<a name="ln1658">            int num_O = 0;</a>
<a name="ln1659">            int bond_to_O_val = 0;</a>
<a name="ln1660">            int forbidden_bond_pos = -1;</a>
<a name="ln1661">            int forbidden_bond_val = -1;</a>
<a name="ln1662">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1663">                neigh = at[i].neighbor[j];</a>
<a name="ln1664">                if ( at[neigh].el_number == el_number_O &amp;&amp;</a>
<a name="ln1665">                     at[neigh].valence   == 1  ) {</a>
<a name="ln1666">                    num_O ++;</a>
<a name="ln1667">                    bond_to_O_val += (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln1668">                } else {</a>
<a name="ln1669">                    forbidden_bond_pos = j;</a>
<a name="ln1670">                    forbidden_bond_val = (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln1671">                }</a>
<a name="ln1672">            }</a>
<a name="ln1673">            if ( 2 == num_O &amp;&amp; 3 == bond_to_O_val &amp;&amp; 1 == forbidden_bond_val ) {</a>
<a name="ln1674">                iedge = pBNS-&gt;vert[i].iedge[forbidden_bond_pos];</a>
<a name="ln1675">                pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1676">                num_found ++;</a>
<a name="ln1677">            }</a>
<a name="ln1678">        } else</a>
<a name="ln1679">        /* nitro */</a>
<a name="ln1680">        if ( at[i].el_number == el_number_N &amp;&amp; 3 == at[i].valence &amp;&amp;</a>
<a name="ln1681">             (4 == at[i].chem_bonds_valence || 5 == at[i].chem_bonds_valence) ) {</a>
<a name="ln1682">            int num_O = 0;</a>
<a name="ln1683">            int bond_to_O_val = 0;</a>
<a name="ln1684">            int forbidden_bond_pos = -1;</a>
<a name="ln1685">            int forbidden_bond_val = -1;</a>
<a name="ln1686">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1687">                neigh = at[i].neighbor[j];</a>
<a name="ln1688">                if ( at[neigh].el_number == el_number_O &amp;&amp;</a>
<a name="ln1689">                     at[neigh].valence   == 1  ) {</a>
<a name="ln1690">                    num_O ++;</a>
<a name="ln1691">                    bond_to_O_val += (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln1692">                } else {</a>
<a name="ln1693">                    forbidden_bond_pos = j;</a>
<a name="ln1694">                    forbidden_bond_val = (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln1695"> </a>
<a name="ln1696">                }</a>
<a name="ln1697">            }</a>
<a name="ln1698">            if ( 2 == num_O &amp;&amp; (3 == bond_to_O_val || 4 == bond_to_O_val) &amp;&amp; 1 == forbidden_bond_val ) {</a>
<a name="ln1699">                iedge = pBNS-&gt;vert[i].iedge[forbidden_bond_pos];</a>
<a name="ln1700">                pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1701">                num_found ++;</a>
<a name="ln1702">            }</a>
<a name="ln1703">        }</a>
<a name="ln1704">    }</a>
<a name="ln1705">#if ( REMOVE_ION_PAIRS_FIX_BONDS == 1 )</a>
<a name="ln1706">    num_found += fix_special_bonds( pBNS, at, num_atoms, edge_forbidden_mask );</a>
<a name="ln1707">#endif</a>
<a name="ln1708">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln1709">    num_found += TempFix_NH_NH_Bonds( pBNS, at, num_atoms );</a>
<a name="ln1710">#endif</a>
<a name="ln1711">    return num_found;</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714"> </a>
<a name="ln1715"> </a>
<a name="ln1716">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln1717">/************************************************************************/</a>
<a name="ln1718">int TempFix_NH_NH_Bonds( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms )</a>
<a name="ln1719">{</a>
<a name="ln1720">    static U_CHAR el_number_N;</a>
<a name="ln1721">    int i, j, neigh, num_found;</a>
<a name="ln1722">    BNS_IEDGE iedge;</a>
<a name="ln1723">    S_CHAR    edge_forbidden_mask = BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln1724">    if ( !el_number_N ) {</a>
<a name="ln1725">        el_number_N = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln1726">    }</a>
<a name="ln1727">    for ( i = 0, num_found = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1728">        /* -NH-NH- or -NH-NH3 */</a>
<a name="ln1729">        if ( at[i].el_number == el_number_N &amp;&amp; at[i].valence &lt; 3 &amp;&amp; at[i].num_H &amp;&amp;</a>
<a name="ln1730">             3 == at[i].chem_bonds_valence + at[i].num_H   &amp;&amp;</a>
<a name="ln1731">             at[i].chem_bonds_valence == at[i].valence &amp;&amp;</a>
<a name="ln1732">             !at[i].charge &amp;&amp; !at[i].radical ) {</a>
<a name="ln1733">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1734">                neigh = at[i].neighbor[j];</a>
<a name="ln1735">                if ( neigh &lt; i &amp;&amp;</a>
<a name="ln1736">                     at[neigh].el_number == el_number_N &amp;&amp; at[neigh].valence &lt; 3 &amp;&amp; at[neigh].num_H &amp;&amp;</a>
<a name="ln1737">                     3 == at[neigh].chem_bonds_valence + at[neigh].num_H   &amp;&amp;</a>
<a name="ln1738">                     at[neigh].chem_bonds_valence == at[neigh].valence &amp;&amp;</a>
<a name="ln1739">                     !at[neigh].charge &amp;&amp; !at[neigh].radical) {</a>
<a name="ln1740">                    iedge = pBNS-&gt;vert[i].iedge[j];</a>
<a name="ln1741">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1742">                    num_found ++;</a>
<a name="ln1743">                }</a>
<a name="ln1744">            }</a>
<a name="ln1745">        }</a>
<a name="ln1746">    }</a>
<a name="ln1747">    return num_found;</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750"> </a>
<a name="ln1751"> </a>
<a name="ln1752">/************************************************************************/</a>
<a name="ln1753">int CorrectFixing_NH_NH_Bonds( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms )</a>
<a name="ln1754">{</a>
<a name="ln1755">    static U_CHAR el_number_N;</a>
<a name="ln1756">    int i, j, neigh, num_found;</a>
<a name="ln1757">    BNS_IEDGE iedge;</a>
<a name="ln1758">    S_CHAR    edge_forbidden_mask = BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln1759">    if ( !el_number_N ) {</a>
<a name="ln1760">        el_number_N = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln1761">    }</a>
<a name="ln1762">    for ( i = 0, num_found = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln1763">        /* -NH-NH- or -NH-NH3 */</a>
<a name="ln1764">        if ( at[i].el_number == el_number_N &amp;&amp; at[i].valence &lt; 3 ) {</a>
<a name="ln1765">            for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln1766">                neigh = at[i].neighbor[j];</a>
<a name="ln1767">                if ( neigh &lt; i &amp;&amp;</a>
<a name="ln1768">                     at[neigh].el_number == el_number_N &amp;&amp; at[neigh].valence &lt; 3 ) {</a>
<a name="ln1769">                    if ( BOND_TYPE_SINGLE != (at[i].bond_type[j] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln1770">                        iedge = pBNS-&gt;vert[i].iedge[j];</a>
<a name="ln1771">                        if ( pBNS-&gt;edge[iedge].forbidden &amp; edge_forbidden_mask ) {</a>
<a name="ln1772">                            pBNS-&gt;edge[iedge].forbidden &amp;= ~edge_forbidden_mask;</a>
<a name="ln1773">                            num_found ++;</a>
<a name="ln1774">                        }</a>
<a name="ln1775">                    }</a>
<a name="ln1776">                }</a>
<a name="ln1777">            }</a>
<a name="ln1778">        }</a>
<a name="ln1779">    }</a>
<a name="ln1780">    return num_found;</a>
<a name="ln1781">}</a>
<a name="ln1782">#endif</a>
<a name="ln1783"> </a>
<a name="ln1784"> </a>
<a name="ln1785"> </a>
<a name="ln1786"> </a>
<a name="ln1787">/******************************************************/</a>
<a name="ln1788">/* fixes bonds set by remove_ion_pairs() in strutil.c */</a>
<a name="ln1789">/******************************************************/</a>
<a name="ln1790">int fix_special_bonds( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int forbidden_mask )</a>
<a name="ln1791">{   </a>
<a name="ln1792">    int num_changes = 0;</a>
<a name="ln1793"> </a>
<a name="ln1794">    /*                           0 1 2  3  4 5 6  7  8  9                   8  9  */</a>
<a name="ln1795">#if ( FIX_REM_ION_PAIRS_Si_BUG == 1 )</a>
<a name="ln1796">    static const char    el[] = &quot;N;P;As;Sb;O;S;Se;Te;C;Si;&quot;;  /* 8 elements + C, Si */</a>
<a name="ln1797">#else</a>
<a name="ln1798">    static const char    el[] = &quot;N;P;As;Sb;O;S;Se;Te;C;Si&quot;;   /* 8 elements + C, Si */</a>
<a name="ln1799">#endif</a>
<a name="ln1800">    static char    en[12];         /* same number: 8 elements */</a>
<a name="ln1801">    static int     ne=0;           /* will be 8 and 10 */</a>
<a name="ln1802"> </a>
<a name="ln1803">#define ELEM_N_FST  0</a>
<a name="ln1804">#define ELEM_N_LEN  4</a>
<a name="ln1805">#define ELEM_O_FST  4</a>
<a name="ln1806">#define ELEM_O_LEN  4</a>
<a name="ln1807">#define ELEM_S_FST  (ELEM_O_FST+1)</a>
<a name="ln1808">#define ELEM_S_LEN  (ELEM_O_LEN-1)</a>
<a name="ln1809">#define ELEM_C_FST  8</a>
<a name="ln1810">#define ELEM_C_LEN  2</a>
<a name="ln1811"> </a>
<a name="ln1812">#define MAX_NEIGH 6</a>
<a name="ln1813"> </a>
<a name="ln1814">    int i, k, n1, n2, n3, n4, i1, i2, i3, i4, bond_type;</a>
<a name="ln1815">    inp_ATOM *a;</a>
<a name="ln1816">    char elname[ATOM_EL_LEN];</a>
<a name="ln1817">    int j[3], m[3], num_O, k_O, num_N, num_OH, num_OM, num_X, num_other, k_N;</a>
<a name="ln1818"> </a>
<a name="ln1819">    BNS_IEDGE iedge;</a>
<a name="ln1820">    /*S_CHAR    edge_forbidden_mask = BNS_EDGE_FORBIDDEN_MASK;*/</a>
<a name="ln1821">    S_CHAR    edge_forbidden_mask = forbidden_mask;</a>
<a name="ln1822"> </a>
<a name="ln1823">    pBNS-&gt;edge_forbidden_mask |= edge_forbidden_mask;</a>
<a name="ln1824"> </a>
<a name="ln1825">    if ( !ne ) { /* one time initialization */</a>
<a name="ln1826">        const char *b, *e;</a>
<a name="ln1827">        int  len;</a>
<a name="ln1828">        for ( b = el; (e = strchr( b, ';')); b = e+1 ) {</a>
<a name="ln1829">            len = e-b;</a>
<a name="ln1830">            memcpy( elname, b, len );</a>
<a name="ln1831">            elname[len] = '\0';</a>
<a name="ln1832">            en[ne++] = get_periodic_table_number( elname );</a>
<a name="ln1833">        }</a>
<a name="ln1834">        en[ne]   = '\0';</a>
<a name="ln1835">        en[ne+1] = '\0';</a>
<a name="ln1836">    }</a>
<a name="ln1837">    for ( i = 0, a = at; i &lt; num_atoms; i ++, a++ ) {</a>
<a name="ln1838">        if ( !a-&gt;charge &amp;&amp; !a-&gt;radical &amp;&amp; </a>
<a name="ln1839">             2 &lt;= a-&gt;chem_bonds_valence + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln1840">             0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1841">             2 == nNoMetalBondsValence(at, i) + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln1842">             NULL != memchr( en+ELEM_N_FST, at[i].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1843">            /* found N(V), no H */</a>
<a name="ln1844">            if ( 2 == nNoMetalNumBonds(at, i) ) {</a>
<a name="ln1845">                /* #N= */</a>
<a name="ln1846">                /* fix bonds: double and triple: =N# so that bonds cannot be changed by the normalization */</a>
<a name="ln1847">#if ( FIX_N_V_METAL_BONDS_GPF == 1 )</a>
<a name="ln1848">                if ( 0 &gt; (i1 = nNoMetalNeighIndex( at, i )) ||</a>
<a name="ln1849">                     0 &gt; (i2 = nNoMetalOtherNeighIndex( at, i,</a>
<a name="ln1850">                                 n1 = a-&gt;neighbor[i1]/* non-metal neighbor #1 */ ) ) ) {</a>
<a name="ln1851">                    /*num_err ++; */ /* do not count would-be original InChI v.1 buffer overflow GPF */</a>
<a name="ln1852">                    continue; /* v1 bug: 2 bonds to metal yield i1 &lt; 0 and/or i2 &lt; 0 =&gt; bounds violation */</a>
<a name="ln1853">                }</a>
<a name="ln1854">#else</a>
<a name="ln1855">                i1 = nNoMetalNeighIndex( at, i );</a>
<a name="ln1856">                n1 = a-&gt;neighbor[i1]; /* non-metal neighbor #1 */</a>
<a name="ln1857">                i2 = nNoMetalOtherNeighIndex( at, i, n1 );</a>
<a name="ln1858">#endif</a>
<a name="ln1859">                n2 = a-&gt;neighbor[i2]; /* non-metal neighbor #2 */</a>
<a name="ln1860">                /* forbid all edges to non-metals */</a>
<a name="ln1861">                iedge = pBNS-&gt;vert[i].iedge[i1];</a>
<a name="ln1862">                pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask; /* fix bond to neighbor #1 */</a>
<a name="ln1863">                iedge = pBNS-&gt;vert[i].iedge[i2];</a>
<a name="ln1864">                pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask; /* fix bond to neighbor #1 */</a>
<a name="ln1865">                num_changes ++;  /* added 11-15-2005 */</a>
<a name="ln1866">                /*                                                      i n3 */</a>
<a name="ln1867">                /* forbid single bond edge beyond the neighboring =N- as in #N=N- */</a>
<a name="ln1868">                if ( (at[i].bond_type[i1] &amp; BOND_TYPE_MASK) == BOND_TYPE_DOUBLE ) {</a>
<a name="ln1869">                    i3 = i1;</a>
<a name="ln1870">                    n3 = n1;</a>
<a name="ln1871">                } else {</a>
<a name="ln1872">                    i3 = i2;</a>
<a name="ln1873">                    n3 = n2;</a>
<a name="ln1874">                }</a>
<a name="ln1875">                if ( 0 == NUMH(at, n3) &amp;&amp; 2 == nNoMetalNumBonds( at, n3 ) &amp;&amp;</a>
<a name="ln1876">                     3 == nNoMetalBondsValence( at, n3 ) &amp;&amp;</a>
<a name="ln1877">                     NULL != memchr( en+ELEM_N_FST, at[n3].el_number, ELEM_N_LEN) &amp;&amp;</a>
<a name="ln1878">                     0 &lt;= (k = nNoMetalOtherNeighIndex( at, n3, i )) ) {</a>
<a name="ln1879">                    /* found =N- ; forbid the edge*/</a>
<a name="ln1880">                    iedge = pBNS-&gt;vert[n3].iedge[k];</a>
<a name="ln1881">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1882">                    num_changes ++;</a>
<a name="ln1883">                }</a>
<a name="ln1884"> </a>
<a name="ln1885">            } else</a>
<a name="ln1886">            if ( 3 == nNoMetalNumBonds(at, i) &amp;&amp;</a>
<a name="ln1887">                /*         |                      */</a>
<a name="ln1888">                /* found  =N=                     */</a>
<a name="ln1889">                /* locate all non-metal neighbors */</a>
<a name="ln1890">                 0 &lt;= (j[0] = nNoMetalNeighIndex( at, i )) &amp;&amp;</a>
<a name="ln1891">                 0 &lt;= (j[1] = nNoMetalOtherNeighIndex( at, i, m[0] = a-&gt;neighbor[j[0]] )) &amp;&amp;</a>
<a name="ln1892">                 0 &lt;= (j[2] = nNoMetalOtherNeighIndex2( at, i, m[0], m[1] = a-&gt;neighbor[j[1]] )) ) {</a>
<a name="ln1893">                /* count specific neighbors: N(V)=N, N(V)-N N(V)=O, and N(V)-N */</a>
<a name="ln1894">                /* if there is a single neighbor connected by a double bond, namely</a>
<a name="ln1895">                   N(V)=N and/or N(V)=O, then fix the bond(s).</a>
<a name="ln1896">                   If N(V)=O was fixed then do not fix another bond */</a>
<a name="ln1897">                m[2] = a-&gt;neighbor[j[2]];</a>
<a name="ln1898">                num_O = num_N = 0;</a>
<a name="ln1899">                for ( k= 0; k &lt; 3; k ++ ) {</a>
<a name="ln1900">                    n1 = m[k];</a>
<a name="ln1901">                    i1 = j[k];</a>
<a name="ln1902">                    if ( NULL != memchr( en+ELEM_N_FST, at[n1].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1903">                        k_N = k;</a>
<a name="ln1904">                        num_N ++;</a>
<a name="ln1905">                    } else</a>
<a name="ln1906">                    if ( NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln1907">                         1 == nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln1908">                        k_O = k;</a>
<a name="ln1909">                        num_O ++;</a>
<a name="ln1910">                    }</a>
<a name="ln1911">                }</a>
<a name="ln1912">                num_other = 0;</a>
<a name="ln1913">                if ( 1 == num_O &amp;&amp; 0 == at[n1=m[k_O]].charge &amp;&amp; 0 == at[n1].radical &amp;&amp;</a>
<a name="ln1914">                     BOND_TYPE_DOUBLE == (at[i].bond_type[i1=j[k_O]] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln1915">                    /* fix bond to neighbor =O */</a>
<a name="ln1916">                    iedge = pBNS-&gt;vert[i].iedge[i1];</a>
<a name="ln1917">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1918">                    num_changes ++;</a>
<a name="ln1919">                    num_other ++; /* indicator: double to a terminal O has been fixed */</a>
<a name="ln1920">                }</a>
<a name="ln1921">                if ( !num_other &amp;&amp; num_O &lt;= 1 &amp;&amp;</a>
<a name="ln1922">                     1 == num_N &amp;&amp; 0 == at[n1=m[k_N]].charge &amp;&amp; 0 == at[n1].radical &amp;&amp;</a>
<a name="ln1923">                     BOND_TYPE_DOUBLE == (at[i].bond_type[i1=j[k_N]] &amp; BOND_TYPE_MASK ) ) {</a>
<a name="ln1924">                    /* fix bond to neighbor =N */</a>
<a name="ln1925">                    iedge = pBNS-&gt;vert[i].iedge[i1];</a>
<a name="ln1926">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1927">                    num_changes ++;</a>
<a name="ln1928">                }</a>
<a name="ln1929">                         </a>
<a name="ln1930">            } else</a>
<a name="ln1931">            if ( 4 == nNoMetalNumBonds(at, i) ) {</a>
<a name="ln1932">                /*         |                      */</a>
<a name="ln1933">                /* found  -N=N-                   */</a>
<a name="ln1934">                /*         |                      */</a>
<a name="ln1935">                /* locate non-metal neighbor connected by a double bond;</a>
<a name="ln1936">                 * if it is =N- then fix the double bond and the single bond beyond the neighbor</a>
<a name="ln1937">                 */</a>
<a name="ln1938">                num_N = 0;</a>
<a name="ln1939">                num_other = 0;</a>
<a name="ln1940">                for ( i1 = 0; i1 &lt; at[i].valence; i1 ++ ) {</a>
<a name="ln1941">                    if ( BOND_TYPE_DOUBLE == (at[i].bond_type[i1] &amp; BOND_TYPE_MASK) &amp;&amp; </a>
<a name="ln1942">                         !is_el_a_metal(at[n1=(int)at[i].neighbor[i1]].el_number) &amp;&amp;</a>
<a name="ln1943">                         NULL != memchr( en+ELEM_N_FST, at[n1].el_number, ELEM_N_LEN) ) {</a>
<a name="ln1944">                        num_N ++;</a>
<a name="ln1945">                        n2 = n1;</a>
<a name="ln1946">                        i2 = i1;</a>
<a name="ln1947">                    }</a>
<a name="ln1948">                }</a>
<a name="ln1949">                if ( 1 == num_N &amp;&amp; 0 == NUMH(at, n2) &amp;&amp;</a>
<a name="ln1950">                     2 == nNoMetalNumBonds( at, n2 ) &amp;&amp;</a>
<a name="ln1951">                     3 == nNoMetalBondsValence(at, n2) &amp;&amp;</a>
<a name="ln1952">                     0 &lt;= ( i3 = nNoMetalOtherNeighIndex( at, n2, i ) ) &amp;&amp;</a>
<a name="ln1953">                     BOND_TYPE_SINGLE == (at[n2].bond_type[i3] &amp; BOND_TYPE_MASK) ) {</a>
<a name="ln1954">                    /* fix the single bond beyond the N(V) neighbor N(V)=N- */</a>
<a name="ln1955">                    iedge = pBNS-&gt;vert[n2].iedge[i3];</a>
<a name="ln1956">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1957">                    num_changes ++;</a>
<a name="ln1958">                    /* fix the double bond */</a>
<a name="ln1959">                    iedge = pBNS-&gt;vert[i].iedge[i2];</a>
<a name="ln1960">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln1961">                    num_changes ++;</a>
<a name="ln1962">                }</a>
<a name="ln1963">            }</a>
<a name="ln1964">        } else</a>
<a name="ln1965">        if ( !a-&gt;charge &amp;&amp; !a-&gt;radical &amp;&amp; </a>
<a name="ln1966">             2 &lt;= a-&gt;chem_bonds_valence + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln1967">             0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln1968">             2 == nNoMetalBondsValence(at, i) + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln1969">             NULL != memchr( en+ELEM_S_FST, a-&gt;el_number, ELEM_S_LEN) &amp;&amp;</a>
<a name="ln1970">             3 == nNoMetalNumBonds( at, i ) ) {</a>
<a name="ln1971">            /* found S(IV), no H, one double bond, total 3 bonds */</a>
<a name="ln1972">            /*       OH</a>
<a name="ln1973">                    /</a>
<a name="ln1974">              in O=S   (X != O) fix single bond O-X  (type 1)</a>
<a name="ln1975">                    \</a>
<a name="ln1976">                     X</a>
<a name="ln1977">             </a>
<a name="ln1978">                     X</a>
<a name="ln1979">                    /</a>
<a name="ln1980">              in Z=S    (X, Y != OH) fix double bond Z=S (type 2)</a>
<a name="ln1981">                    \</a>
<a name="ln1982">                     Y</a>
<a name="ln1983">            */</a>
<a name="ln1984">            num_N  = 0; /* number of non-metal neighbors connected by a double bond */</a>
<a name="ln1985">            num_OH = 0; /* number of neighbors OH connected by a single bond */</a>
<a name="ln1986">            num_OM = 0; /* number of charged neighbors O connected by a single bond */</a>
<a name="ln1987">            num_O  = 0; /* number of neighbors =O connected by a double bond */</a>
<a name="ln1988">            num_other = 0;</a>
<a name="ln1989">            for ( i1 = 0; i1 &lt; a-&gt;valence; i1 ++ ) {</a>
<a name="ln1990">                n1=(int)a-&gt;neighbor[i1];</a>
<a name="ln1991">                if ( is_el_a_metal(at[n1].el_number) ) {</a>
<a name="ln1992">                    continue;</a>
<a name="ln1993">                }</a>
<a name="ln1994">                bond_type = (a-&gt;bond_type[i1] &amp; BOND_TYPE_MASK);</a>
<a name="ln1995">                if ( BOND_TYPE_DOUBLE == bond_type ) {</a>
<a name="ln1996">                    num_N ++;</a>
<a name="ln1997">                    n2 = n1;</a>
<a name="ln1998">                    i2 = i1;</a>
<a name="ln1999">                    if ( NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) ) {</a>
<a name="ln2000">                        num_O ++;</a>
<a name="ln2001">                    }</a>
<a name="ln2002">                } else</a>
<a name="ln2003">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2004">                     1 == nNoMetalNumBonds( at, n1 ) &amp;&amp;</a>
<a name="ln2005">                     1 == nNoMetalBondsValence(at, n1 ) &amp;&amp;</a>
<a name="ln2006">                     NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) ) {</a>
<a name="ln2007">                    if ( 0 == at[n1].charge ) {</a>
<a name="ln2008">                        num_OH ++;</a>
<a name="ln2009">                        n3 = n1;</a>
<a name="ln2010">                        i3 = i1;</a>
<a name="ln2011">                    } else {</a>
<a name="ln2012">                        num_OM ++;</a>
<a name="ln2013">                    }</a>
<a name="ln2014">                } else {</a>
<a name="ln2015">                    num_other ++;</a>
<a name="ln2016">                    n4 = n1;</a>
<a name="ln2017">                    i4 = i1;</a>
<a name="ln2018">                }</a>
<a name="ln2019">            }</a>
<a name="ln2020">            if ( 1 == num_N &amp;&amp; 1 == num_O &amp;&amp; 1 == num_OH + num_OM ) {</a>
<a name="ln2021">                if ( 1 == num_other ) {</a>
<a name="ln2022">                    /* type 1: fix the single bond S-X */</a>
<a name="ln2023">                    iedge = pBNS-&gt;vert[i].iedge[i4];</a>
<a name="ln2024">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln2025">                    num_changes ++;</a>
<a name="ln2026">                }</a>
<a name="ln2027">            } else</a>
<a name="ln2028">            if ( 1 == num_N &amp;&amp; !num_OH &amp;&amp; !num_OM ) {</a>
<a name="ln2029">                int    bFound = 0; /* flag */</a>
<a name="ln2030">                int    bDoNotFixAnyBond = 0; /* flag */</a>
<a name="ln2031">                /* avoid case N=S-NH or N=S-N(-); N = N, P, As, Sb */</a>
<a name="ln2032">                if ( NULL != memchr( en+ELEM_N_FST, at[n2].el_number, ELEM_N_LEN) ) {</a>
<a name="ln2033">                    U_CHAR el_number = at[n2].el_number;</a>
<a name="ln2034">                    for ( i1 = 0; i1 &lt; a-&gt;valence; i1 ++ ) {</a>
<a name="ln2035">                        n1=(int)a-&gt;neighbor[i1];</a>
<a name="ln2036">                        bond_type = (a-&gt;bond_type[i1] &amp; BOND_TYPE_MASK);</a>
<a name="ln2037">                        if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2038">                             (NUMH(at, n1) || -1 == at[n1].charge) &amp;&amp;</a>
<a name="ln2039">                             el_number == at[n1].el_number ) {</a>
<a name="ln2040">                            i3 = i1;</a>
<a name="ln2041">                            n3 = n1;</a>
<a name="ln2042">                            bFound ++;</a>
<a name="ln2043">                        }</a>
<a name="ln2044">                    }</a>
<a name="ln2045">                }</a>
<a name="ln2046">                /* exception: check if Z==X and they belong to the same ring system */</a>
<a name="ln2047">                for ( i1 = 0; i1 &lt; a-&gt;valence; i1 ++ ) {</a>
<a name="ln2048">                    if ( i1 != i2 ) {</a>
<a name="ln2049">                        n1=(int)a-&gt;neighbor[i1]; </a>
<a name="ln2050">                        if ( at[n2].el_number   == at[n1].el_number &amp;&amp;</a>
<a name="ln2051">                             at[n2].nRingSystem == at[n1].nRingSystem ) {</a>
<a name="ln2052">                            bDoNotFixAnyBond ++;</a>
<a name="ln2053">                        }</a>
<a name="ln2054">                    }</a>
<a name="ln2055">                }</a>
<a name="ln2056"> </a>
<a name="ln2057">                if ( bDoNotFixAnyBond ) {</a>
<a name="ln2058">                    ; /* do nothing */</a>
<a name="ln2059">                } else</a>
<a name="ln2060">                if ( bFound ) {</a>
<a name="ln2061">                    if ( 1 == bFound &amp;&amp; </a>
<a name="ln2062">                         0 &lt;= ( i4 = nNoMetalOtherNeighIndex2( at, i, n2, n3) ) ) {</a>
<a name="ln2063">                        /* fix bond i4 */</a>
<a name="ln2064">                        iedge = pBNS-&gt;vert[i].iedge[i4];</a>
<a name="ln2065">                        pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln2066">                        num_changes ++;</a>
<a name="ln2067">                    }</a>
<a name="ln2068">                } else {</a>
<a name="ln2069">                    /* fix the double bond &gt;S=X */</a>
<a name="ln2070">                    iedge = pBNS-&gt;vert[i].iedge[i2];</a>
<a name="ln2071">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln2072">                    num_changes ++;</a>
<a name="ln2073">                    /* -- test later --</a>
<a name="ln2074">                    if ( 2 == nNoMetalNumBonds( at, n2 ) &amp;&amp;</a>
<a name="ln2075">                         0 &lt;= ( i3 = nNoMetalOtherNeighIndex( at, n2, i ) ) ) {</a>
<a name="ln2076">                        iedge = pBNS-&gt;vert[n2].iedge[i3];</a>
<a name="ln2077">                        pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln2078">                        num_changes ++;</a>
<a name="ln2079">                    }</a>
<a name="ln2080">                    -------------------*/</a>
<a name="ln2081">                }</a>
<a name="ln2082">            }</a>
<a name="ln2083">        } else</a>
<a name="ln2084">        if ( !a-&gt;charge &amp;&amp; !a-&gt;radical &amp;&amp; </a>
<a name="ln2085">             4 &lt;= a-&gt;chem_bonds_valence + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln2086">             0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln2087">             4 == nNoMetalBondsValence(at, i) + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln2088">             NULL != memchr( en+ELEM_S_FST, a-&gt;el_number, ELEM_S_LEN) &amp;&amp;</a>
<a name="ln2089">             4 == nNoMetalNumBonds( at, i ) ) {</a>
<a name="ln2090">            /* found S(VI), no H, two double bonds or one triple bond */</a>
<a name="ln2091">            /*     O </a>
<a name="ln2092">                   || </a>
<a name="ln2093">              in O=S--Y-   (X, Y -- non-terminal) fix single bonds S-X, S-Y  (type 1)</a>
<a name="ln2094">                    \</a>
<a name="ln2095">                     X--</a>
<a name="ln2096">             </a>
<a name="ln2097">                   O  </a>
<a name="ln2098">                   || </a>
<a name="ln2099">              in O=S--O(-)    (X -- non-terminal) fix single bond S-X (type 2)</a>
<a name="ln2100">                    \</a>
<a name="ln2101">                     X--</a>
<a name="ln2102"> </a>
<a name="ln2103">                   O  </a>
<a name="ln2104">                   || </a>
<a name="ln2105">              in O=S--OH     (X -- non-terminal) fix single bond S-X (type 3)</a>
<a name="ln2106">                    \</a>
<a name="ln2107">                     X--</a>
<a name="ln2108"> </a>
<a name="ln2109">            */</a>
<a name="ln2110">            int iN[4];  /* indexes of non-terminal neighbors connected by a single bond */</a>
<a name="ln2111">            num_N  = 0; /* number of non-metal neighbors connected by a double bond */</a>
<a name="ln2112">            num_OH = 0; /* number of neighbors OH connected by a single bond */</a>
<a name="ln2113">            num_OM = 0; /* number of non-terminal neighbors connected by a single bond */</a>
<a name="ln2114">            num_O  = 0; /* number of neighbors =O connected by a double bond */</a>
<a name="ln2115">            num_X  = 0; /* number of terminal atom X != O connected by a single bond */</a>
<a name="ln2116">            num_other = 0;</a>
<a name="ln2117">            for ( i1 = 0; i1 &lt; a-&gt;valence; i1 ++ ) {</a>
<a name="ln2118">                n1=(int)a-&gt;neighbor[i1];</a>
<a name="ln2119">                if ( is_el_a_metal(at[n1].el_number) ) {</a>
<a name="ln2120">                    continue;</a>
<a name="ln2121">                }</a>
<a name="ln2122">                bond_type = (a-&gt;bond_type[i1] &amp; BOND_TYPE_MASK);</a>
<a name="ln2123">                if ( BOND_TYPE_DOUBLE == bond_type ) {</a>
<a name="ln2124">                    num_N ++;</a>
<a name="ln2125">                    if ( (0 == at[n1].charge</a>
<a name="ln2126">#if ( S_VI_O_PLUS_METAL_FIX_BOND == 1 )</a>
<a name="ln2127">                          || ((1 == at[n1].charge) &amp;&amp; (2 == at[n1].valence))</a>
<a name="ln2128">#endif</a>
<a name="ln2129">                         ) &amp;&amp; 0 == at[n1].radical &amp;&amp;</a>
<a name="ln2130">                         0 == num_of_H( at, n1 ) &amp;&amp;</a>
<a name="ln2131">                         NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln2132">                         1 == nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln2133"> </a>
<a name="ln2134">                        num_O ++;</a>
<a name="ln2135">                    }</a>
<a name="ln2136">                } else</a>
<a name="ln2137">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2138">                     1 == nNoMetalNumBonds( at, n1 ) &amp;&amp;</a>
<a name="ln2139">                     NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln2140">                     1 &gt;= num_of_H( at, n1 ) &amp;&amp;</a>
<a name="ln2141">                     1 == (( 0 == at[n1].charge) &amp;&amp; 1==num_of_H( at, n1 ))</a>
<a name="ln2142">                         +((-1 == at[n1].charge) &amp;&amp; 0==num_of_H( at, n1 ))  ) {</a>
<a name="ln2143"> </a>
<a name="ln2144">                    num_OH ++; /* -OH or -O(-) */</a>
<a name="ln2145"> </a>
<a name="ln2146">                } else</a>
<a name="ln2147">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2148">                     1 &lt; nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln2149"> </a>
<a name="ln2150">                    iN[num_OM ++] = i1; /* non-terminal neighbor connected by a single bond */</a>
<a name="ln2151"> </a>
<a name="ln2152">                } else</a>
<a name="ln2153">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2154">                     1 == nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln2155"> </a>
<a name="ln2156">                    num_X ++; /* other terminal neighbor connected by a single bond */</a>
<a name="ln2157"> </a>
<a name="ln2158">                } else {</a>
<a name="ln2159">                    num_other ++;</a>
<a name="ln2160">                }</a>
<a name="ln2161">            }</a>
<a name="ln2162">            if ( num_N == num_O &amp;&amp; 2 == num_O &amp;&amp; 2 == num_OH + num_OM + num_X &amp;&amp; 0 == num_other ) {</a>
<a name="ln2163">                for ( i2 = 0; i2 &lt; num_OM; i2 ++ ) {</a>
<a name="ln2164">                    i1 = iN[i2];</a>
<a name="ln2165">                    /* fix bond i1 */</a>
<a name="ln2166">                    iedge = pBNS-&gt;vert[i].iedge[i1];</a>
<a name="ln2167">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln2168">                    num_changes ++;</a>
<a name="ln2169">                }</a>
<a name="ln2170">            }</a>
<a name="ln2171">        } else</a>
<a name="ln2172">        if ( !a-&gt;charge &amp;&amp; !a-&gt;radical &amp;&amp; </a>
<a name="ln2173">             6 &lt;= a-&gt;chem_bonds_valence + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln2174">             0 == num_of_H( at, i ) &amp;&amp;</a>
<a name="ln2175">             6 == nNoMetalBondsValence(at, i) + NUMH(a,0) - get_el_valence( a-&gt;el_number, 0, 0 ) &amp;&amp;</a>
<a name="ln2176">             NULL != memchr( en+ELEM_S_FST, a-&gt;el_number, ELEM_S_LEN) &amp;&amp;</a>
<a name="ln2177">             5 == nNoMetalNumBonds( at, i ) ) {</a>
<a name="ln2178">            /* found S(VIII), no H, three double bonds or two triple bond */</a>
<a name="ln2179">            /*</a>
<a name="ln2180"> </a>
<a name="ln2181">                   O  </a>
<a name="ln2182">                   || </a>
<a name="ln2183">              in O=S--Y--     (X, Y -- non-terminal) fix single bond S-X, S-Y (type 4)</a>
<a name="ln2184">                  //\</a>
<a name="ln2185">                 O   X--</a>
<a name="ln2186"> </a>
<a name="ln2187">              note: this structure is a mistakenly drawn structure</a>
<a name="ln2188"> </a>
<a name="ln2189">                   O                  O        </a>
<a name="ln2190">                   ||                 ||       </a>
<a name="ln2191">                 O=S--O--Y--  or    O=S--Y--</a>
<a name="ln2192">                    \                  \       </a>
<a name="ln2193">                     X--                O--X--    </a>
<a name="ln2194"> </a>
<a name="ln2195"> </a>
<a name="ln2196">            */</a>
<a name="ln2197">            int iN[5];  /* indexes of non-terminal neighbors connected by a single bond */</a>
<a name="ln2198">            num_N  = 0; /* number of non-metal neighbors connected by a double bond */</a>
<a name="ln2199">            num_OH = 0; /* number of neighbors OH connected by a single bond */</a>
<a name="ln2200">            num_OM = 0; /* number of non-terminal neighbors connected by a single bond */</a>
<a name="ln2201">            num_O  = 0; /* number of neighbors =O connected by a double bond */</a>
<a name="ln2202">            num_X  = 0; /* number of terminal atom X != O connected by a single bond */</a>
<a name="ln2203">            num_other = 0;</a>
<a name="ln2204">            for ( i1 = 0; i1 &lt; a-&gt;valence; i1 ++ ) {</a>
<a name="ln2205">                n1=(int)a-&gt;neighbor[i1];</a>
<a name="ln2206">                if ( is_el_a_metal(at[n1].el_number) ) {</a>
<a name="ln2207">                    continue;</a>
<a name="ln2208">                }</a>
<a name="ln2209">                bond_type = (a-&gt;bond_type[i1] &amp; BOND_TYPE_MASK);</a>
<a name="ln2210">                if ( BOND_TYPE_DOUBLE == bond_type ) {</a>
<a name="ln2211">                    num_N ++;</a>
<a name="ln2212">                    if ( (0 == at[n1].charge</a>
<a name="ln2213">#if ( S_VI_O_PLUS_METAL_FIX_BOND == 1 )</a>
<a name="ln2214">                          || ((1 == at[n1].charge) &amp;&amp; (2 == at[n1].valence))</a>
<a name="ln2215">#endif</a>
<a name="ln2216">                          )                        </a>
<a name="ln2217">                         &amp;&amp; 0 == at[n1].radical &amp;&amp;</a>
<a name="ln2218">                         0 == num_of_H( at, n1 ) &amp;&amp;</a>
<a name="ln2219">                         NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln2220">                         1 == nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln2221"> </a>
<a name="ln2222">                        num_O ++;</a>
<a name="ln2223">                    }</a>
<a name="ln2224">                } else</a>
<a name="ln2225">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2226">                     1 == nNoMetalNumBonds( at, n1 ) &amp;&amp;</a>
<a name="ln2227">                     NULL != memchr( en+ELEM_O_FST, at[n1].el_number, ELEM_O_LEN) &amp;&amp;</a>
<a name="ln2228">                     1 &gt;= num_of_H( at, n1 ) &amp;&amp;</a>
<a name="ln2229">                     1 == (( 0 == at[n1].charge) &amp;&amp; 1==num_of_H( at, n1 ))</a>
<a name="ln2230">                         +((-1 == at[n1].charge) &amp;&amp; 0==num_of_H( at, n1 ))  ) {</a>
<a name="ln2231"> </a>
<a name="ln2232">                    num_OH ++; /* -OH or -O(-) */</a>
<a name="ln2233"> </a>
<a name="ln2234">                } else</a>
<a name="ln2235">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2236">                     1 &lt; nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln2237"> </a>
<a name="ln2238">                    iN[num_OM ++] = i1; /* non-terminal neighbor connected by a single bond */</a>
<a name="ln2239"> </a>
<a name="ln2240">                } else</a>
<a name="ln2241">                if ( BOND_TYPE_SINGLE == bond_type &amp;&amp;</a>
<a name="ln2242">                     1 == nNoMetalNumBonds( at, n1 ) ) {</a>
<a name="ln2243"> </a>
<a name="ln2244">                    num_X ++; /* other terminal neighbor connected by a single bond */</a>
<a name="ln2245"> </a>
<a name="ln2246">                } else {</a>
<a name="ln2247">                    num_other ++;</a>
<a name="ln2248">                }</a>
<a name="ln2249">            }</a>
<a name="ln2250">            if ( num_N == num_O &amp;&amp; 3 == num_O &amp;&amp; 2 == num_OH + num_OM + num_X &amp;&amp; 0 == num_other ) {</a>
<a name="ln2251">                for ( i2 = 0; i2 &lt; num_OM; i2 ++ ) {</a>
<a name="ln2252">                    i1 = iN[i2];</a>
<a name="ln2253">                    /* fix bond i1 */</a>
<a name="ln2254">                    iedge = pBNS-&gt;vert[i].iedge[i1];</a>
<a name="ln2255">                    pBNS-&gt;edge[iedge].forbidden |= edge_forbidden_mask;</a>
<a name="ln2256">                    num_changes ++;</a>
<a name="ln2257">                }</a>
<a name="ln2258">            }</a>
<a name="ln2259">        }</a>
<a name="ln2260">    }</a>
<a name="ln2261">    return num_changes;</a>
<a name="ln2262">}</a>
<a name="ln2263"> </a>
<a name="ln2264"> </a>
<a name="ln2265"> </a>
<a name="ln2266">#define ALL_NONMETAL_Z  0</a>
<a name="ln2267"> </a>
<a name="ln2268"> </a>
<a name="ln2269"> </a>
<a name="ln2270"> </a>
<a name="ln2271">/***************************************************************************************/</a>
<a name="ln2272">int is_Z_atom( U_CHAR el_number )</a>
<a name="ln2273">{</a>
<a name="ln2274">    typedef enum tag_Z_elnumber {</a>
<a name="ln2275">        el_C ,</a>
<a name="ln2276">        el_N ,</a>
<a name="ln2277">        el_P ,</a>
<a name="ln2278">        el_As,</a>
<a name="ln2279">        el_Sb,</a>
<a name="ln2280">        el_S ,</a>
<a name="ln2281">        el_Se,</a>
<a name="ln2282">        el_Te,</a>
<a name="ln2283">        el_Cl,</a>
<a name="ln2284">        el_Br,</a>
<a name="ln2285">        el_I ,</a>
<a name="ln2286">#if ( ALL_NONMETAL_Z == 1 )</a>
<a name="ln2287">        el_B ,</a>
<a name="ln2288">        el_O ,</a>
<a name="ln2289">        el_Si,</a>
<a name="ln2290">        el_Ge,</a>
<a name="ln2291">        el_F ,</a>
<a name="ln2292">        el_At,</a>
<a name="ln2293">#endif</a>
<a name="ln2294">        el_len</a>
<a name="ln2295">    } Z_ELNUMBER;</a>
<a name="ln2296">    static U_CHAR el_numb[el_len];</a>
<a name="ln2297">/*</a>
<a name="ln2298">    return is_el_a_metal( (int)el_number );</a>
<a name="ln2299">*/</a>
<a name="ln2300">    if ( !el_numb[el_C] ) {</a>
<a name="ln2301">        el_numb[el_C ] = (U_CHAR)get_periodic_table_number( &quot;C&quot;  );</a>
<a name="ln2302">        el_numb[el_N ] = (U_CHAR)get_periodic_table_number( &quot;N&quot;  );</a>
<a name="ln2303">        el_numb[el_P ] = (U_CHAR)get_periodic_table_number( &quot;P&quot;  );</a>
<a name="ln2304">        el_numb[el_As] = (U_CHAR)get_periodic_table_number( &quot;As&quot; );</a>
<a name="ln2305">        el_numb[el_Sb] = (U_CHAR)get_periodic_table_number( &quot;Sb&quot; );</a>
<a name="ln2306">        el_numb[el_S ] = (U_CHAR)get_periodic_table_number( &quot;S&quot;  );</a>
<a name="ln2307">        el_numb[el_Se] = (U_CHAR)get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln2308">        el_numb[el_Te] = (U_CHAR)get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln2309">        el_numb[el_Cl] = (U_CHAR)get_periodic_table_number( &quot;Cl&quot; );</a>
<a name="ln2310">        el_numb[el_Br] = (U_CHAR)get_periodic_table_number( &quot;Br&quot; );</a>
<a name="ln2311">        el_numb[el_I ] = (U_CHAR)get_periodic_table_number( &quot;I&quot;  );</a>
<a name="ln2312">#if ( ALL_NONMETAL_Z == 1 )</a>
<a name="ln2313">        el_numb[el_B ] = (U_CHAR)get_periodic_table_number( &quot;B&quot;  );</a>
<a name="ln2314">        el_numb[el_O ] = (U_CHAR)get_periodic_table_number( &quot;O&quot;  );</a>
<a name="ln2315">        el_numb[el_Si] = (U_CHAR)get_periodic_table_number( &quot;Si&quot; );</a>
<a name="ln2316">        el_numb[el_Ge] = (U_CHAR)get_periodic_table_number( &quot;Ge&quot; );</a>
<a name="ln2317">        el_numb[el_F ] = (U_CHAR)get_periodic_table_number( &quot;F&quot;  );</a>
<a name="ln2318">        el_numb[el_At] = (U_CHAR)get_periodic_table_number( &quot;At&quot; );</a>
<a name="ln2319">#endif</a>
<a name="ln2320">    }</a>
<a name="ln2321">    if ( memchr( el_numb, el_number, el_len ) ) {</a>
<a name="ln2322">        return 1;</a>
<a name="ln2323">    } </a>
<a name="ln2324">    return 0;</a>
<a name="ln2325"> </a>
<a name="ln2326">}</a>
<a name="ln2327"> </a>
<a name="ln2328"> </a>
<a name="ln2329"> </a>
<a name="ln2330">/***************************************************************************************/</a>
<a name="ln2331">int IsZOX( inp_ATOM *atom, int at_x, int ord )</a>
<a name="ln2332">{  /* detect O==Z--X, O=O,S,Se,Te */</a>
<a name="ln2333">    static U_CHAR el_number_O  = 0;</a>
<a name="ln2334">    static U_CHAR el_number_S  = 0;</a>
<a name="ln2335">    static U_CHAR el_number_Se = 0;</a>
<a name="ln2336">    static U_CHAR el_number_Te = 0;</a>
<a name="ln2337">    inp_ATOM *at_Z = atom + atom[at_x].neighbor[ord];</a>
<a name="ln2338"> </a>
<a name="ln2339">    int i, neigh, num_O;</a>
<a name="ln2340"> </a>
<a name="ln2341">    if ( !el_number_O ) {</a>
<a name="ln2342">        el_number_O  = (U_CHAR)get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln2343">        el_number_S  = (U_CHAR)get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln2344">        el_number_Se = (U_CHAR)get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln2345">        el_number_Te = (U_CHAR)get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln2346">    }</a>
<a name="ln2347">    for ( i = 0, num_O = 0; i &lt; at_Z-&gt;valence; i ++ ) {</a>
<a name="ln2348">        neigh = at_Z-&gt;neighbor[i];</a>
<a name="ln2349">        if ( neigh == at_x ) {</a>
<a name="ln2350">            continue;</a>
<a name="ln2351">        }</a>
<a name="ln2352">        if ( atom[neigh].valence == 1 &amp;&amp;</a>
<a name="ln2353">             atom[neigh].chem_bonds_valence == 2 &amp;&amp;</a>
<a name="ln2354">             atom[neigh].charge  == 0 &amp;&amp;</a>
<a name="ln2355">             atom[neigh].radical == 0 &amp;&amp;</a>
<a name="ln2356">              (atom[neigh].el_number == el_number_O  ||</a>
<a name="ln2357">               atom[neigh].el_number == el_number_S  ||</a>
<a name="ln2358">               atom[neigh].el_number == el_number_Se ||</a>
<a name="ln2359">               atom[neigh].el_number == el_number_Te ) ) {</a>
<a name="ln2360">            num_O ++;</a>
<a name="ln2361">        }</a>
<a name="ln2362">    }</a>
<a name="ln2363">    return num_O;</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366"> </a>
<a name="ln2367"> </a>
<a name="ln2368">/***************************************************************************************/</a>
<a name="ln2369">int GetAtomChargeType( inp_ATOM *atom, int at_no, int nAtTypeTotals[], int *pMask, int bSubtract  )</a>
<a name="ln2370">{</a>
<a name="ln2371">    static U_CHAR el_number_C  = 0;</a>
<a name="ln2372">    static U_CHAR el_number_O  = 0;</a>
<a name="ln2373">    static U_CHAR el_number_S  = 0;</a>
<a name="ln2374">    static U_CHAR el_number_Se = 0;</a>
<a name="ln2375">    static U_CHAR el_number_Te = 0;</a>
<a name="ln2376">    static U_CHAR el_number_P  = 0;</a>
<a name="ln2377">    static U_CHAR el_number_N  = 0;</a>
<a name="ln2378">    static U_CHAR el_number_H  = 0;</a>
<a name="ln2379"> </a>
<a name="ln2380">    static U_CHAR el_number_F  = 0;</a>
<a name="ln2381">    static U_CHAR el_number_Cl = 0;</a>
<a name="ln2382">    static U_CHAR el_number_Br = 0;</a>
<a name="ln2383">    static U_CHAR el_number_I  = 0;</a>
<a name="ln2384">    </a>
<a name="ln2385">    inp_ATOM *at = atom + at_no;</a>
<a name="ln2386">#if ( FIX_NORM_BUG_ADD_ION_PAIR == 1 )</a>
<a name="ln2387">    int i, neigh, mask, bit, type, num_z, num_m, num_o, delta = bSubtract &gt; 0 ? -1 : 1; /* 0 or -2 =&gt; add, 1 or 2 =&gt; subtract */</a>
<a name="ln2388">    int bNoAdjIon = (bSubtract==0 || bSubtract==1);</a>
<a name="ln2389">#else</a>
<a name="ln2390">    int i, neigh, mask, bit, type, num_z, num_m, num_o, delta = bSubtract? -1 : 1;</a>
<a name="ln2391">#endif</a>
<a name="ln2392">    int bUnsatNHasTerminalO = 0;</a>
<a name="ln2393">    if ( !el_number_C ) {</a>
<a name="ln2394">        el_number_C  = (U_CHAR)get_periodic_table_number( &quot;C&quot; );</a>
<a name="ln2395">        el_number_O  = (U_CHAR)get_periodic_table_number( &quot;O&quot; );</a>
<a name="ln2396">        el_number_S  = (U_CHAR)get_periodic_table_number( &quot;S&quot; );</a>
<a name="ln2397">        el_number_Se = (U_CHAR)get_periodic_table_number( &quot;Se&quot; );</a>
<a name="ln2398">        el_number_Te = (U_CHAR)get_periodic_table_number( &quot;Te&quot; );</a>
<a name="ln2399">        el_number_P  = (U_CHAR)get_periodic_table_number( &quot;P&quot; );</a>
<a name="ln2400">        el_number_N  = (U_CHAR)get_periodic_table_number( &quot;N&quot; );</a>
<a name="ln2401">        el_number_H  = (U_CHAR)get_periodic_table_number( &quot;H&quot; );</a>
<a name="ln2402">        el_number_F  = (U_CHAR)get_periodic_table_number( &quot;F&quot; );</a>
<a name="ln2403">        el_number_Cl = (U_CHAR)get_periodic_table_number( &quot;Cl&quot; );</a>
<a name="ln2404">        el_number_Br = (U_CHAR)get_periodic_table_number( &quot;Br&quot; );</a>
<a name="ln2405">        el_number_I  = (U_CHAR)get_periodic_table_number( &quot;I&quot; );</a>
<a name="ln2406">    }</a>
<a name="ln2407"> </a>
<a name="ln2408">    type = ATT_NONE;</a>
<a name="ln2409">    mask = 0;</a>
<a name="ln2410">    if ( at-&gt;radical &amp;&amp; at-&gt;radical != RADICAL_SINGLET ) {</a>
<a name="ln2411">        goto exit_function;</a>
<a name="ln2412">    }</a>
<a name="ln2413">    if ( is_el_a_metal( at-&gt;el_number ) ) {</a>
<a name="ln2414">        goto exit_function; /* metal */</a>
<a name="ln2415">    }</a>
<a name="ln2416">    if ( at-&gt;charge &lt; -1 || at-&gt;charge &gt; 1 ) {</a>
<a name="ln2417">        goto exit_function;</a>
<a name="ln2418">    }</a>
<a name="ln2419">    if ( !at-&gt;valence &amp;&amp; at-&gt;charge == 1 &amp;&amp; !at-&gt;num_H &amp;&amp; !at-&gt;radical &amp;&amp; at-&gt;el_number == el_number_H ) {</a>
<a name="ln2420">        /* a proton (#1) */</a>
<a name="ln2421">        type = ATT_PROTON;</a>
<a name="ln2422">        mask = ATBIT_Proton;</a>
<a name="ln2423">        goto count_mask_bits;</a>
<a name="ln2424">    }</a>
<a name="ln2425">    if ( !at-&gt;valence &amp;&amp; at-&gt;charge == -1 &amp;&amp; !at-&gt;num_H &amp;&amp; !at-&gt;radical &amp;&amp;</a>
<a name="ln2426">         ( at-&gt;el_number == el_number_F  ||</a>
<a name="ln2427">           at-&gt;el_number == el_number_Cl ||</a>
<a name="ln2428">           at-&gt;el_number == el_number_Br ||</a>
<a name="ln2429">           at-&gt;el_number == el_number_I )</a>
<a name="ln2430">         ) {</a>
<a name="ln2431">        /* a halogen anion (#2) */</a>
<a name="ln2432">        type = ATT_HalAnion;</a>
<a name="ln2433">        mask = ATBIT_HalAnion;</a>
<a name="ln2434">        goto count_mask_bits;</a>
<a name="ln2435">    }</a>
<a name="ln2436">#if ( HAL_ACID_H_XCHG == 1 )</a>
<a name="ln2437">    /* halogen/chalcogen acid */</a>
<a name="ln2438">    if ( (!at-&gt;valence &amp;&amp; at-&gt;charge == 0 &amp;&amp; 1 == at-&gt;num_H &amp;&amp; !at-&gt;radical &amp;&amp;</a>
<a name="ln2439">         ( at-&gt;el_number == el_number_F  ||</a>
<a name="ln2440">           at-&gt;el_number == el_number_Cl ||</a>
<a name="ln2441">           at-&gt;el_number == el_number_Br ||</a>
<a name="ln2442">           at-&gt;el_number == el_number_I )) ||</a>
<a name="ln2443">         (!at-&gt;valence &amp;&amp; at-&gt;charge == 0 &amp;&amp; 2 == at-&gt;num_H &amp;&amp; !at-&gt;radical &amp;&amp;</a>
<a name="ln2444">         ( at-&gt;el_number == el_number_O  ||</a>
<a name="ln2445">           at-&gt;el_number == el_number_S ||</a>
<a name="ln2446">           at-&gt;el_number == el_number_Se ||</a>
<a name="ln2447">           at-&gt;el_number == el_number_Te ))</a>
<a name="ln2448">         ) {</a>
<a name="ln2449">        /* a halogen/chalcogen acid (#3) */</a>
<a name="ln2450">        type = ATT_HalAcid;</a>
<a name="ln2451">        mask = ATBIT_HalAcid;</a>
<a name="ln2452">        goto count_mask_bits;</a>
<a name="ln2453">    }</a>
<a name="ln2454">#endif    </a>
<a name="ln2455">    if ( detect_unusual_el_valence( at-&gt;el_number, at-&gt;charge, at-&gt;radical,</a>
<a name="ln2456">                                        at-&gt;chem_bonds_valence, at-&gt;num_H,</a>
<a name="ln2457">                                        at-&gt;valence ) ) {</a>
<a name="ln2458">        goto exit_function; /* unusual valence state */</a>
<a name="ln2459">    }</a>
<a name="ln2460">    /* check neighbors */</a>
<a name="ln2461">    for ( i = 0, num_z = 0, num_m = 0, num_o = 0; i &lt; at-&gt;valence; i ++ ) {</a>
<a name="ln2462">        neigh = at-&gt;neighbor[i];</a>
<a name="ln2463">#if ( FIX_NORM_BUG_ADD_ION_PAIR == 1 )</a>
<a name="ln2464">        if ( atom[neigh].charge &lt; -1 || atom[neigh].charge &gt; 1 ) {</a>
<a name="ln2465">            goto exit_function; /* neighboring charge */</a>
<a name="ln2466">        }</a>
<a name="ln2467">        if ( atom[neigh].charge &amp;&amp; at-&gt;charge ) {</a>
<a name="ln2468">            if ( bNoAdjIon ) {</a>
<a name="ln2469">                goto exit_function; /* neighboring charge */</a>
<a name="ln2470">            }</a>
<a name="ln2471">            type = ATT_NONE;</a>
<a name="ln2472">            mask = 0;</a>
<a name="ln2473">            goto count_mask_bits;</a>
<a name="ln2474">        }</a>
<a name="ln2475">#else</a>
<a name="ln2476">        if ( atom[neigh].charge &lt; -1 || atom[neigh].charge &gt; 1 || atom[neigh].charge &amp;&amp; at-&gt;charge ) {</a>
<a name="ln2477">            goto exit_function; /* neighboring charge */</a>
<a name="ln2478">        }</a>
<a name="ln2479">#endif</a>
<a name="ln2480">        if ( detect_unusual_el_valence( atom[neigh].el_number, atom[neigh].charge, atom[neigh].radical,</a>
<a name="ln2481">                                            atom[neigh].chem_bonds_valence, atom[neigh].num_H,</a>
<a name="ln2482">                                            atom[neigh].valence ) ) {</a>
<a name="ln2483">            goto exit_function; /* neighbor in unusual valence state */</a>
<a name="ln2484">        }</a>
<a name="ln2485">        if ( is_Z_atom( atom[neigh].el_number ) ) {</a>
<a name="ln2486">            num_z ++;</a>
<a name="ln2487">        }</a>
<a name="ln2488">        if ( is_el_a_metal( atom[neigh].el_number ) ) {</a>
<a name="ln2489">            num_m ++;</a>
<a name="ln2490">        }</a>
<a name="ln2491">        num_o += (atom[neigh].el_number == el_number_O);</a>
<a name="ln2492">        if ( at-&gt;el_number == el_number_N &amp;&amp; at-&gt;valence == 2 &amp;&amp; !at-&gt;charge &amp;&amp;</a>
<a name="ln2493">             /*at-&gt;valence &lt; at-&gt;chem_bonds_valence &amp;&amp;*/</a>
<a name="ln2494">             atom[neigh].valence == 1 &amp;&amp; atom[neigh].chem_bonds_valence == 2 &amp;&amp;</a>
<a name="ln2495">             (atom[neigh].el_number == el_number_O  ||</a>
<a name="ln2496">              atom[neigh].el_number == el_number_S  ||</a>
<a name="ln2497">              atom[neigh].el_number == el_number_Se ||</a>
<a name="ln2498">              atom[neigh].el_number == el_number_Te  )) {</a>
<a name="ln2499">            bUnsatNHasTerminalO ++;</a>
<a name="ln2500">        }</a>
<a name="ln2501">    }</a>
<a name="ln2502">    /* O, S, Se, Te */</a>
<a name="ln2503">    if ( at-&gt;el_number == el_number_O  ||</a>
<a name="ln2504">         at-&gt;el_number == el_number_S  ||</a>
<a name="ln2505">         at-&gt;el_number == el_number_Se ||</a>
<a name="ln2506">         at-&gt;el_number == el_number_Te ) {</a>
<a name="ln2507">        if ( at-&gt;charge == 1 ) {</a>
<a name="ln2508">            if ( at-&gt;num_H ) { /* #4 */</a>
<a name="ln2509">                type  = ATT_O_PLUS;</a>
<a name="ln2510">                mask |= ATBIT_OH_Plus;</a>
<a name="ln2511">            } else { /* #5 */</a>
<a name="ln2512">                type  = ATT_O_PLUS;</a>
<a name="ln2513">                mask |= ATBIT_O_Plus;</a>
<a name="ln2514">            }</a>
<a name="ln2515">        } else</a>
<a name="ln2516">        if ( at-&gt;valence &gt; 1 ) {</a>
<a name="ln2517">            goto exit_function;  /* not a terminal atom #C1 */</a>
<a name="ln2518">        } else</a>
<a name="ln2519">        if ( at-&gt;valence &amp;&amp; !(num_z || num_o) ) {</a>
<a name="ln2520">            if ( num_m == at-&gt;valence ) {</a>
<a name="ln2521">                goto exit_function; /* #C2 */</a>
<a name="ln2522">            }</a>
<a name="ln2523">            goto count_mask_bits;  /* #C3 count charges, no donor or acceptor found */</a>
<a name="ln2524">        } else</a>
<a name="ln2525">        /* here at-&gt;neigh[0] is one of: O, or Z={C, N, P, As, Sb, S, Se, Te, Cl, Br, I} */</a>
<a name="ln2526">        if ( at-&gt;valence ) {</a>
<a name="ln2527">            neigh = at-&gt;neighbor[0]; /* Z or O only */</a>
<a name="ln2528">            if ( !atom[neigh].charge &amp;&amp; atom[neigh].el_number == el_number_C &amp;&amp;</a>
<a name="ln2529">                 atom[neigh].chem_bonds_valence &gt; atom[neigh].valence ) {</a>
<a name="ln2530">                /* =C-OH, #C-OH, =C-O(-), #C-O(-), -C=O, =C=O; O = O, S, Se, Te */</a>
<a name="ln2531">                type = ATT_ACIDIC_CO;</a>
<a name="ln2532">                if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2533">                    mask |= (ATBIT_COH);            /* #6: =C-OH, #C-OH; O=O,S,Se,Te */</a>
<a name="ln2534">                    /*nAtTypeTotals[ATTOT_NUM_COH] ++;*/</a>
<a name="ln2535">                } else</a>
<a name="ln2536">                if ( at-&gt;charge == -1 ) {</a>
<a name="ln2537">                    mask |= (ATBIT_CO_Minus);       /* #7: =C-O(-), #C-O(-); O=O,S,Se,Te */</a>
<a name="ln2538">                    /*nAtTypeTotals[ATTOT_NUM_CO_Minus] ++;*/</a>
<a name="ln2539">                } else</a>
<a name="ln2540">                if ( !at-&gt;num_H &amp;&amp; !at-&gt;charge ) {</a>
<a name="ln2541">                    mask |= (ATBIT_CO);             /* #8 -C=O, =C=O; O=O,S,Se,Te */</a>
<a name="ln2542">                    /*nAtTypeTotals[ATTOT_NUM_CO] ++;*/</a>
<a name="ln2543">                } else {</a>
<a name="ln2544">                    mask |= (ATBIT_Errors);</a>
<a name="ln2545">                    /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2546">                }</a>
<a name="ln2547">            } else</a>
<a name="ln2548">            if ( !atom[neigh].charge &amp;&amp;</a>
<a name="ln2549">                  (atom[neigh].el_number == el_number_O  ||</a>
<a name="ln2550">                   atom[neigh].el_number == el_number_S  ||</a>
<a name="ln2551">                   atom[neigh].el_number == el_number_Se ||</a>
<a name="ln2552">                   atom[neigh].el_number == el_number_Te )  &amp;&amp;</a>
<a name="ln2553">                  atom[neigh].chem_bonds_valence == atom[neigh].valence ) {</a>
<a name="ln2554">                /* -O-OH, -O-O(-); O = O, S, Se, Te */</a>
<a name="ln2555">                type = ATT_OO;</a>
<a name="ln2556">                if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2557">                    mask |= (ATBIT_OOH);            /* #9 -O-OH */</a>
<a name="ln2558">                    /*nAtTypeTotals[ATTOT_NUM_OOH] ++;*/</a>
<a name="ln2559">                } else</a>
<a name="ln2560">                if ( at-&gt;charge == -1 ) {</a>
<a name="ln2561">                    mask |= (ATBIT_OO_Minus);       /* #10 -O-O(-) */</a>
<a name="ln2562">                    /*nAtTypeTotals[ATTOT_NUM_OO_Minus] ++;*/</a>
<a name="ln2563">                } else {</a>
<a name="ln2564">                    mask |= (ATBIT_Errors);</a>
<a name="ln2565">                    /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2566">                }</a>
<a name="ln2567">            } else</a>
<a name="ln2568">            if ( !atom[neigh].charge &amp;&amp;</a>
<a name="ln2569">                 atom[neigh].chem_bonds_valence == atom[neigh].valence &amp;&amp;</a>
<a name="ln2570">                 atom[neigh].el_number == el_number_C &amp;&amp;</a>
<a name="ln2571">                 at-&gt;el_number         != el_number_O ) {</a>
<a name="ln2572">                /* &gt;C-S(-), &gt;C-SH; S = S, Se, Te  */</a>
<a name="ln2573">                type = ATT_ACIDIC_S;</a>
<a name="ln2574">                if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2575">                    mask |= (ATBIT_CSH);            /* #11: &gt;C-SH, &gt;CH-SH, -CH2-SH; S = S, Se, Te */</a>
<a name="ln2576">                    /*nAtTypeTotals[ATTOT_NUM_CSH] ++;*/</a>
<a name="ln2577">                } else</a>
<a name="ln2578">                if ( at-&gt;charge == -1 ) {</a>
<a name="ln2579">                    mask |= (ATBIT_CS_Minus);       /* #12: &gt;C-S(-), &gt;CH-S(-), -CH2-S(-); S = S, Se, Te  */</a>
<a name="ln2580">                    /*nAtTypeTotals[ATTOT_NUM_CS_Minus] ++;*/</a>
<a name="ln2581">                } else {</a>
<a name="ln2582">                    mask |= (ATBIT_Errors);</a>
<a name="ln2583">                    /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2584">                }</a>
<a name="ln2585">            } else</a>
<a name="ln2586">            if ( (atom[neigh].el_number == el_number_N) &amp;&amp;</a>
<a name="ln2587">                 (atom[neigh].valence == 2) &amp;&amp;</a>
<a name="ln2588">                 (!atom[neigh].num_H || ((atom[neigh].num_H == 1) &amp;&amp; (atom[neigh].charge == 1))) ) {</a>
<a name="ln2589">                 /* N or N(-) or NH(+) neighbor */</a>
<a name="ln2590">                type = ATT_NO; /* single bond only */</a>
<a name="ln2591">                if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2592">                    mask |= (ATBIT_NOH);            /* #13: =N-OH, =NH(+)-OH, #N(+)-OH, -N(-)-OH; O = O, S, Se, Te */</a>
<a name="ln2593">                    /*nAtTypeTotals[ATTOT_NUM_NOH] ++;*/</a>
<a name="ln2594">                } else</a>
<a name="ln2595">                if ( at-&gt;charge == -1 ) {</a>
<a name="ln2596">                    mask |= (ATBIT_NO_Minus);       /* #14: =N-O(-); O = O, S, Se, Te */</a>
<a name="ln2597">                    /*nAtTypeTotals[ATTOT_NUM_NO_Minus] ++;*/</a>
<a name="ln2598">                } else</a>
<a name="ln2599">                if ( atom[neigh].charge == 1 || atom[neigh].charge == 0 ) {</a>
<a name="ln2600">                    mask |= (ATBIT_NO);             /* #15: =N(+)=O, -NH(+)=O -N=O */</a>
<a name="ln2601">                    /*nAtTypeTotals[ATTOT_NUM_NO] ++;*/</a>
<a name="ln2602">                } else {</a>
<a name="ln2603">                    mask |= (ATBIT_Errors);</a>
<a name="ln2604">                    /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2605">                }</a>
<a name="ln2606">            } else</a>
<a name="ln2607">            if ( atom[neigh].el_number == el_number_N  ) {</a>
<a name="ln2608">                type = ATT_N_O; /* #16: single bond only */</a>
<a name="ln2609">                if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2610">                    mask |= (ATBIT_N_OH);            /* #16: -NH-OH, &gt;N-OH or &gt;N(+)&lt;OH; O = O, S, Se, Te */</a>
<a name="ln2611">                    /*nAtTypeTotals[ATTOT_NUM_NOH] ++;*/</a>
<a name="ln2612">                } else</a>
<a name="ln2613">                if ( at-&gt;charge == -1 ) {</a>
<a name="ln2614">                    mask |= (ATBIT_N_O_Minus);       /* #17: -NH-O(-), &gt;N-O(-); O = O, S, Se, Te */</a>
<a name="ln2615">                    /*nAtTypeTotals[ATTOT_NUM_NO_Minus] ++;*/</a>
<a name="ln2616">                } else</a>
<a name="ln2617">                if ( atom[neigh].charge == 1 ) {</a>
<a name="ln2618">                    mask |= (ATBIT_N_O);             /* #18:  &gt;N(+)=O */</a>
<a name="ln2619">                    /*nAtTypeTotals[ATTOT_NUM_NO] ++;*/</a>
<a name="ln2620">                } else {</a>
<a name="ln2621">                    mask |= (ATBIT_Errors);</a>
<a name="ln2622">                    /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2623">                }</a>
<a name="ln2624">            } else</a>
<a name="ln2625">            if ( atom[neigh].el_number != el_number_C &amp;&amp; atom[neigh].el_number != el_number_O &amp;&amp;</a>
<a name="ln2626">                 !is_el_a_metal( atom[neigh].el_number ) &amp;&amp;</a>
<a name="ln2627">                 atom[neigh].chem_bonds_valence &gt; atom[neigh].valence ) {</a>
<a name="ln2628">                 /* =Z-OH, #Z-OH, =Z-O(-), #Z-O(-), -Z=O, =Z=O;</a>
<a name="ln2629">                    =Z(+)-OH, #Z(+)-OH, =Z-O(-), #Z-O(-), -Z(+)=O, =Z(+)=O; O = O, S, Se, Te */</a>
<a name="ln2630">                 /* neigh = Z\{N,C} = P, As, Sb, S, Se, Te, Cl, Br, I */</a>
<a name="ln2631">                if ( at-&gt;chem_bonds_valence == 1 &amp;&amp; IsZOX( atom, at_no, 0 ) ) {</a>
<a name="ln2632">                    type = ATT_ZOO;</a>
<a name="ln2633">                    if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2634">                        mask |= (ATBIT_ZOOH);            /* 18: O=Z-OH; O=O,S,Se,Te; Z may have charge */</a>
<a name="ln2635">                        /*nAtTypeTotals[ATTOT_NUM_ZOOH] ++;*/</a>
<a name="ln2636">                    } else</a>
<a name="ln2637">                    if ( at-&gt;charge == -1 ) {</a>
<a name="ln2638">                        mask |= (ATBIT_ZOO_Minus);       /* 19: O=Z-O(-); O = O, S, Se, Te */</a>
<a name="ln2639">                        /*nAtTypeTotals[ATTOT_NUM_ZOO_Minus] ++;*/</a>
<a name="ln2640">                    } else {</a>
<a name="ln2641">                        mask |= (ATBIT_Errors);</a>
<a name="ln2642">                        /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2643">                    }</a>
<a name="ln2644">                } else {</a>
<a name="ln2645">                    type = ATT_OTHER_ZO;</a>
<a name="ln2646">                    if ( at-&gt;num_H == 1 ) {</a>
<a name="ln2647">                        mask |= (ATBIT_ZOH);            /* 20: =Z-OH, #Z-OH; O=O,S,Se,Te; Z may have charge */</a>
<a name="ln2648">                        /*nAtTypeTotals[ATTOT_NUM_ZOH] ++;*/</a>
<a name="ln2649">                    } else</a>
<a name="ln2650">                    if ( at-&gt;charge == -1 ) {</a>
<a name="ln2651">                        mask |= (ATBIT_ZO_Minus);       /* 21: =Z-O(-), #Z-O(-); O = O, S, Se, Te */</a>
<a name="ln2652">                        /*nAtTypeTotals[ATTOT_NUM_ZO_Minus] ++;*/</a>
<a name="ln2653">                    } else</a>
<a name="ln2654">                    if ( at-&gt;num_H == 0 ) {</a>
<a name="ln2655">                        mask |= (ATBIT_ZO);             /* 22: -Z=O, =Z=O; O=O,S,Se,Te; Z may have charge */</a>
<a name="ln2656">                        /*nAtTypeTotals[ATTOT_NUM_ZO] ++;*/</a>
<a name="ln2657">                    } else {</a>
<a name="ln2658">                        mask |= (ATBIT_Errors);</a>
<a name="ln2659">                        /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2660">                    }</a>
<a name="ln2661">                }</a>
<a name="ln2662">            } else</a>
<a name="ln2663">            if ( at-&gt;charge == -1 &amp;&amp; !is_el_a_metal( atom[neigh].el_number ) ) {</a>
<a name="ln2664">                /* &gt;Z-O(-); O=O,S,Se,Te */</a>
<a name="ln2665">                type = ATT_OTHER_NEG_O;</a>
<a name="ln2666">                mask |= (ATBIT_O_Minus);            /* 23: -Z-O(-); O=O,S,Se,Te */</a>
<a name="ln2667">                /*nAtTypeTotals[ATTOT_NUM_ZO_Minus] ++;*/</a>
<a name="ln2668">            }</a>
<a name="ln2669">        } else</a>
<a name="ln2670">        if ( at-&gt;charge == -1 &amp;&amp; at-&gt;num_H == 1 ) {</a>
<a name="ln2671">            type = ATT_OH_MINUS;</a>
<a name="ln2672">            mask |= (ATBIT_O_Minus);            /* 25: HO(-); O=O,S,Se,Te */</a>
<a name="ln2673">        }</a>
<a name="ln2674">    } else</a>
<a name="ln2675">    /* P, N, neutral valence = 3 (not 5) */</a>
<a name="ln2676">    if ( (at-&gt;el_number == el_number_N  ||</a>
<a name="ln2677">          at-&gt;el_number == el_number_P) &amp;&amp;</a>
<a name="ln2678">          0 &lt;= at-&gt;valence &amp;&amp; at-&gt;valence &lt;= 3 &amp;&amp;</a>
<a name="ln2679">          at-&gt;chem_bonds_valence + at-&gt;num_H == 3 + at-&gt;charge ) {</a>
<a name="ln2680">        if ( at-&gt;valence &amp;&amp; !(num_z /*|| num_o == at-&gt;valence*/) ) {</a>
<a name="ln2681">            if ( num_m == at-&gt;valence ) {</a>
<a name="ln2682">                goto exit_function;</a>
<a name="ln2683">            }</a>
<a name="ln2684">            goto count_mask_bits; /* N(III), N(-)(II), N(+)(IV) and same P that have only oxygen neighbors are ignored here */</a>
<a name="ln2685">        }</a>
<a name="ln2686">        type = (at-&gt;el_number == el_number_N)? ATT_ATOM_N : ATT_ATOM_P;</a>
<a name="ln2687">        switch ( at-&gt;charge ) {</a>
<a name="ln2688">        case -1:</a>
<a name="ln2689">            if (at-&gt;el_number == el_number_N) {</a>
<a name="ln2690">                mask |= (ATBIT_N_Minus); /* 26: -NH(-), =N(-), &gt;N(-) */</a>
<a name="ln2691">                </a>
<a name="ln2692">                if ( at-&gt;num_H )</a>
<a name="ln2693">                    mask |= (ATBIT_NP_H); /* 27: -NH(-) */</a>
<a name="ln2694">#if ( FIX_NP_MINUS_BUG == 1 )</a>
<a name="ln2695">                else</a>
<a name="ln2696">                if ( at-&gt;valence == 1 &amp;&amp; at-&gt;chem_bonds_valence &gt;= 2 &amp;&amp; (at-&gt;bond_type[0] &amp; BOND_MARK_ALL) )</a>
<a name="ln2697">                    type |= ATT_NP_MINUS_V23; /* =N(-) created by normalization 2010-03-11 DT */</a>
<a name="ln2698">#endif</a>
<a name="ln2699">                </a>
<a name="ln2700">            }</a>
<a name="ln2701">            /*nAtTypeTotals[ATTOT_NUM_N_Minus] += (at-&gt;el_number == el_number_N);*/</a>
<a name="ln2702">            break;</a>
<a name="ln2703">        case 0:</a>
<a name="ln2704">            if ( at-&gt;num_H ) {</a>
<a name="ln2705">                mask |= (ATBIT_NP_H);          /* 28: -NH2, =NH, &gt;NH */</a>
<a name="ln2706">                /*nAtTypeTotals[ATTOT_NUM_NP_H] ++;*/</a>
<a name="ln2707">            } else {</a>
<a name="ln2708">                if ( bUnsatNHasTerminalO == 1 ) {</a>
<a name="ln2709">                    mask |= (ATBIT_ON);            /* 29: -N=O,-N=OH(+) only, not =N-OH */</a>
<a name="ln2710">                } else {</a>
<a name="ln2711">                    mask |= (ATBIT_NP);            /* 30: -P=O,-P=OH(+), &gt;N- =N- (incl. =N-OH) , #N */</a>
<a name="ln2712">                    /*nAtTypeTotals[ATTOT_NUM_NP] ++;*/</a>
<a name="ln2713">                }</a>
<a name="ln2714">            }</a>
<a name="ln2715">            break; /* ignore neutral N or P */</a>
<a name="ln2716">        case 1:</a>
<a name="ln2717">            if ( at-&gt;num_H ) {</a>
<a name="ln2718">                mask |= (ATBIT_NP_Proton);       /* 31: NH4(+), -NH3(+), =NH2(+), &gt;NH2(+), =NH(+)-, &gt;NH(+)-, #NH(+) */</a>
<a name="ln2719">                /*nAtTypeTotals[ATTOT_NUM_NP_Proton] ++;*/</a>
<a name="ln2720">            } else</a>
<a name="ln2721">            if ( at-&gt;chem_bonds_valence &gt; at-&gt;valence ) {</a>
<a name="ln2722">                mask |= (ATBIT_NP_Plus);         /* =N(+)=, #N(+)-, =N(+)&lt; */</a>
<a name="ln2723">                /*nAtTypeTotals[ATTOT_NUM_NP_Plus] ++;*/</a>
<a name="ln2724">            } else {</a>
<a name="ln2725">                type = 0; /* 32: ignore onium cations &gt;N(+)&lt; */</a>
<a name="ln2726">            }</a>
<a name="ln2727">            break;</a>
<a name="ln2728">        default:</a>
<a name="ln2729">            mask |= (1 &lt;&lt; ATTOT_NUM_Errors);</a>
<a name="ln2730">            /*nAtTypeTotals[ATTOT_NUM_Errors] ++;*/</a>
<a name="ln2731">            break;</a>
<a name="ln2732">        }</a>
<a name="ln2733">    }</a>
<a name="ln2734">count_mask_bits:</a>
<a name="ln2735">    if ( nAtTypeTotals ) {</a>
<a name="ln2736">        if ( mask &amp;&amp; !(mask &amp; (ATBIT_Errors)) ) {</a>
<a name="ln2737">            for ( i = 0, bit = 1; i &lt; ATTOT_ARRAY_LEN; i ++, bit &lt;&lt;= 1 ) {</a>
<a name="ln2738">                if ( bit &amp; mask ) {</a>
<a name="ln2739">                    nAtTypeTotals[i] += delta;</a>
<a name="ln2740">                }</a>
<a name="ln2741">            }</a>
<a name="ln2742">        }</a>
<a name="ln2743">        /* count charges */</a>
<a name="ln2744">        if ( at-&gt;charge ) {</a>
<a name="ln2745">            nAtTypeTotals[ATTOT_TOT_CHARGE]  += delta * at-&gt;charge;</a>
<a name="ln2746">            nAtTypeTotals[ATTOT_NUM_CHARGES] += delta;</a>
<a name="ln2747">        }</a>
<a name="ln2748">    }</a>
<a name="ln2749">    if ( pMask ) {</a>
<a name="ln2750">        *pMask = mask;</a>
<a name="ln2751">    }</a>
<a name="ln2752">exit_function:</a>
<a name="ln2753">    if ( mask &amp; (ATBIT_Errors) ) {</a>
<a name="ln2754">        type = 0;</a>
<a name="ln2755">        if ( nAtTypeTotals ) {</a>
<a name="ln2756">            nAtTypeTotals[ATTOT_NUM_Errors] += 1;</a>
<a name="ln2757">        }</a>
<a name="ln2758">    }</a>
<a name="ln2759">    return type;</a>
<a name="ln2760">}</a>
<a name="ln2761"> </a>
<a name="ln2762"> </a>
<a name="ln2763"> </a>
<a name="ln2764">/***************************************************************************************/</a>
<a name="ln2765">int SimpleRemoveHplusNPO( inp_ATOM *at, int num_atoms, int nAtTypeTotals[], T_GROUP_INFO *t_group_info )</a>
<a name="ln2766">{</a>
<a name="ln2767">    int i, mask, type, num_removed;</a>
<a name="ln2768">    for ( i = 0, num_removed = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln2769">        if ( (PR_SIMPLE_TYP &amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) &amp;&amp;</a>
<a name="ln2770">             (PR_SIMPLE_MSK &amp; mask ) ) {</a>
<a name="ln2771">#if ( bRELEASE_VERSION == 0 )</a>
<a name="ln2772">            if ( at[i].charge != 1 || at[i].num_H == 0 ) {</a>
<a name="ln2773">                return -1;  /* program error */</a>
<a name="ln2774">            }</a>
<a name="ln2775">#endif</a>
<a name="ln2776">            type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln2777">            at[i].charge = 0;</a>
<a name="ln2778">            AddOrRemoveExplOrImplH( -1, at, num_atoms, (AT_NUMB)i, t_group_info );</a>
<a name="ln2779">            /*at[i].num_H --;*/</a>
<a name="ln2780">            num_removed ++;</a>
<a name="ln2781">#if ( FIX_NORM_BUG_ADD_ION_PAIR == 1 )</a>
<a name="ln2782">            type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln2783">#else</a>
<a name="ln2784">            type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* bug: subtract instead of add */</a>
<a name="ln2785">#endif</a>
<a name="ln2786">            /*</a>
<a name="ln2787">            if ( nAtTypeTotals ) {</a>
<a name="ln2788">                nAtTypeTotals[ATTOT_NUM_NP_Proton] --;</a>
<a name="ln2789">                if ( at[i].num_H ) {</a>
<a name="ln2790">                    nAtTypeTotals[ATTOT_NUM_NP_H] ++;</a>
<a name="ln2791">                } else {</a>
<a name="ln2792">                    nAtTypeTotals[ATTOT_NUM_NP] ++;</a>
<a name="ln2793">                }</a>
<a name="ln2794">                nAtTypeTotals[ATTOT_TOT_CHARGE] --;</a>
<a name="ln2795">                nAtTypeTotals[ATTOT_NUM_CHARGES] --;</a>
<a name="ln2796">            }</a>
<a name="ln2797">            */</a>
<a name="ln2798">        }</a>
<a name="ln2799">    }</a>
<a name="ln2800">    return num_removed;</a>
<a name="ln2801">}</a>
<a name="ln2802"> </a>
<a name="ln2803"> </a>
<a name="ln2804"> </a>
<a name="ln2805">/***************************************************************************************/</a>
<a name="ln2806">int bIsAtomTypeHard( inp_ATOM *at, int endpoint, int nType, int nMask, int nCharge )</a>
<a name="ln2807">{</a>
<a name="ln2808">    int        mask;    </a>
<a name="ln2809">    if ( (nType &amp; GetAtomChargeType( at, endpoint, NULL, &amp;mask, 0 )) &amp;&amp; (mask &amp; nMask)</a>
<a name="ln2810">#if ( OPPOSITE_CHARGE_IN_CGROUP == 0 )</a>
<a name="ln2811">         &amp;&amp; ( at[endpoint].charge == nCharge || !at[endpoint].charge )</a>
<a name="ln2812">#endif</a>
<a name="ln2813">    ) {</a>
<a name="ln2814">        return 1;</a>
<a name="ln2815">    }</a>
<a name="ln2816">    return 0;</a>
<a name="ln2817"> </a>
<a name="ln2818">}</a>
<a name="ln2819"> </a>
<a name="ln2820"> </a>
<a name="ln2821"> </a>
<a name="ln2822">/***************************************************************************************/</a>
<a name="ln2823">int bIsHDonorAccAtomType( inp_ATOM *at, int endpoint, int *cSubType )</a>
<a name="ln2824">{</a>
<a name="ln2825">    if ( bIsAtomTypeHard( at, endpoint, PR_HARD_TYP_H, PR_HARD_MSK_H, 0 ) ) {</a>
<a name="ln2826">        /* obtain donor/acceptor info */</a>
<a name="ln2827">        int neutral_valence = at[endpoint].chem_bonds_valence + at[endpoint].num_H - at[endpoint].charge;</a>
<a name="ln2828">        if ( neutral_valence != 2 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln2829">             neutral_valence != 3 /* N, P */          ) {</a>
<a name="ln2830">            return -1; /* wrong endpoint neutral valence */</a>
<a name="ln2831">        } else {</a>
<a name="ln2832">            int edge_flow = at[endpoint].num_H;</a>
<a name="ln2833">            int num_bonds = at[endpoint].valence;</a>
<a name="ln2834">            int edge_cap  = neutral_valence - num_bonds; /* does not allow to reduce -NH3(+) to #N or -OH(+)- to -O- */</a>
<a name="ln2835">            edge_flow = inchi_min( edge_flow, edge_cap);</a>
<a name="ln2836">            /* what this means: */</a>
<a name="ln2837">            if ( edge_cap ) {</a>
<a name="ln2838">                if ( edge_cap &gt; edge_flow )</a>
<a name="ln2839">                    *cSubType |= SALT_ACCEPTOR;</a>
<a name="ln2840">                if ( edge_flow )</a>
<a name="ln2841">                    *cSubType |= SALT_DONOR_H;</a>
<a name="ln2842">                return 4;</a>
<a name="ln2843">            }</a>
<a name="ln2844">        }</a>
<a name="ln2845">    }</a>
<a name="ln2846">    return -1;</a>
<a name="ln2847">}</a>
<a name="ln2848"> </a>
<a name="ln2849"> </a>
<a name="ln2850"> </a>
<a name="ln2851">/***************************************************************************************/</a>
<a name="ln2852">int bIsNegAtomType( inp_ATOM *at, int endpoint, int *cSubType )</a>
<a name="ln2853">{</a>
<a name="ln2854">    int sub_type = 0;</a>
<a name="ln2855">    if ( bIsAtomTypeHard( at, endpoint, PR_HARD_TYP_NEG, PR_HARD_MSK_NEG, -1 ) ) {</a>
<a name="ln2856">        /* obtain donor/acceptor info */</a>
<a name="ln2857">        int neutral_valence = at[endpoint].chem_bonds_valence + at[endpoint].num_H - at[endpoint].charge;</a>
<a name="ln2858">        if ( neutral_valence != 2 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln2859">             neutral_valence != 3 /* N, P */          ) {</a>
<a name="ln2860">            return -1; /* wrong endpoint neutral valence */</a>
<a name="ln2861">        } else {</a>
<a name="ln2862">            int edge_flow = (at[endpoint].charge == -1);</a>
<a name="ln2863">            int num_bonds = at[endpoint].valence;</a>
<a name="ln2864">            int edge_cap  = neutral_valence - num_bonds - at[endpoint].num_H; /* does not allow to reduce -NH3(+) to #N or -OH(+)- to -O- */</a>
<a name="ln2865">            edge_flow = inchi_min( edge_flow, edge_cap);</a>
<a name="ln2866">            /* what this means: */</a>
<a name="ln2867">            if ( edge_cap ) {</a>
<a name="ln2868">                if ( edge_cap &gt; edge_flow )</a>
<a name="ln2869">                    sub_type |= SALT_ACCEPTOR;</a>
<a name="ln2870">                if ( edge_flow ) {</a>
<a name="ln2871">                    sub_type |= SALT_DONOR_Neg;</a>
<a name="ln2872">                }</a>
<a name="ln2873">                if ( sub_type ) {</a>
<a name="ln2874">                    *cSubType |= sub_type;</a>
<a name="ln2875">                    return 4;</a>
<a name="ln2876">                }</a>
<a name="ln2877">            }</a>
<a name="ln2878">        }</a>
<a name="ln2879">    }</a>
<a name="ln2880">    return -1;</a>
<a name="ln2881">}</a>
<a name="ln2882"> </a>
<a name="ln2883"> </a>
<a name="ln2884"> </a>
<a name="ln2885">/*****************************************************************************/</a>
<a name="ln2886">int bIsHardRemHCandidate(  inp_ATOM *at, int i, int *cSubType )</a>
<a name="ln2887">{</a>
<a name="ln2888">    int ret1, ret2, ret;</a>
<a name="ln2889">    int sub_type = 0;</a>
<a name="ln2890">    ret1 = bIsHDonorAccAtomType( at, i, &amp;sub_type );</a>
<a name="ln2891">    ret2 = bIsNegAtomType( at, i, &amp;sub_type );</a>
<a name="ln2892">    ret = inchi_max(ret1, ret2);</a>
<a name="ln2893">    if ( ret &gt; 0 &amp;&amp; sub_type ) {</a>
<a name="ln2894">        *cSubType |= sub_type;</a>
<a name="ln2895">        return ret;</a>
<a name="ln2896">    }</a>
<a name="ln2897">    return -1;</a>
<a name="ln2898">}</a>
<a name="ln2899"> </a>
<a name="ln2900"> </a>
<a name="ln2901"> </a>
<a name="ln2902">/***************************************************************************************/</a>
<a name="ln2903">int CreateCGroupInBnStruct( inp_ATOM *at, int num_atoms,</a>
<a name="ln2904">                            BN_STRUCT *pBNS, int nType, int nMask, int nCharge )</a>
<a name="ln2905">{</a>
<a name="ln2906">    int         k, c_point, cg, centerpoint, fictpoint, type, ret = 0;</a>
<a name="ln2907">    int         num_cg       = 1;</a>
<a name="ln2908">    int         num_edges    = pBNS-&gt;num_edges;</a>
<a name="ln2909">    int         num_vertices = pBNS-&gt;num_vertices; /* new c-group bns-ID */</a>
<a name="ln2910">    BNS_VERTEX *vert_ficpoint, *ver_ficpont_prev;  /* fictitious vertex describing charge c-group */</a>
<a name="ln2911">    BNS_VERTEX *vertex_cpoint;</a>
<a name="ln2912">    BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric c_point */</a>
<a name="ln2913">    int        mask, num_CPoints;</a>
<a name="ln2914"> </a>
<a name="ln2915">    /* Debug: check overflow */</a>
<a name="ln2916">    if ( num_vertices + num_cg &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln2917">        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln2918">    }</a>
<a name="ln2919">    /* count new c-group edges */</a>
<a name="ln2920">    for ( c_point = 0, num_CPoints = 0; c_point &lt; num_atoms; c_point ++ ) {</a>
<a name="ln2921">        if ( (nType &amp; GetAtomChargeType( at, c_point, NULL, &amp;mask, 0 )) &amp;&amp; (mask &amp; nMask)</a>
<a name="ln2922">#if ( OPPOSITE_CHARGE_IN_CGROUP == 0 )</a>
<a name="ln2923">             &amp;&amp; ( at[c_point].charge == nCharge || !at[c_point].charge )</a>
<a name="ln2924">#endif</a>
<a name="ln2925">           ) {</a>
<a name="ln2926">            num_CPoints ++;</a>
<a name="ln2927">        }</a>
<a name="ln2928">    }</a>
<a name="ln2929">    if ( !num_CPoints ) {</a>
<a name="ln2930">        return 0;</a>
<a name="ln2931">    }</a>
<a name="ln2932"> </a>
<a name="ln2933"> </a>
<a name="ln2934"> </a>
<a name="ln2935">    /* clear the new vertex */</a>
<a name="ln2936">    memset( pBNS-&gt;vert+num_vertices, 0, 1*sizeof(pBNS-&gt;vert[0]) );</a>
<a name="ln2937">    /* *old* Make sure the last t-group has the largest t-group ID:</a>
<a name="ln2938">       this is necessary to correctly add new edges and vertices for testing augmenting paths</a>
<a name="ln2939">    */</a>
<a name="ln2940">    /**************************************/</a>
<a name="ln2941">    /* initialize new fictitious vertex   */</a>
<a name="ln2942">    /* representing c-point group         */</a>
<a name="ln2943">    /**************************************/</a>
<a name="ln2944">    ver_ficpont_prev = pBNS-&gt;vert+num_vertices - 1;</a>
<a name="ln2945">    </a>
<a name="ln2946">    for ( cg = 0; cg &lt; num_cg; cg ++, ver_ficpont_prev = vert_ficpoint ) {</a>
<a name="ln2947">        /*</a>
<a name="ln2948">          vert_ficpoint-1 is the last vertex;</a>
<a name="ln2949">          vert_ficpoint   is the being added vertex</a>
<a name="ln2950">          Note: nGroupNumber are not contiguous</a>
<a name="ln2951">        */</a>
<a name="ln2952">        vert_ficpoint                = pBNS-&gt;vert+num_vertices + cg;</a>
<a name="ln2953">        vert_ficpoint-&gt;iedge         = ver_ficpont_prev-&gt;iedge + ver_ficpont_prev-&gt;max_adj_edges;</a>
<a name="ln2954">        vert_ficpoint-&gt;max_adj_edges = num_CPoints+BNS_ADD_EDGES;</a>
<a name="ln2955">        vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln2956">        vert_ficpoint-&gt;st_edge.flow  = vert_ficpoint-&gt;st_edge.flow0  = 0;</a>
<a name="ln2957">        vert_ficpoint-&gt;st_edge.cap   = vert_ficpoint-&gt;st_edge.cap0   = 0;</a>
<a name="ln2958">        vert_ficpoint-&gt;type          = BNS_VERT_TYPE_C_GROUP | ((nCharge&lt;0)?BNS_VERT_TYPE_C_NEGATIVE:0);</a>
<a name="ln2959">    }</a>
<a name="ln2960"> </a>
<a name="ln2961">    /************************************************/</a>
<a name="ln2962">    /* connect c-points to the fictitious vertices  */</a>
<a name="ln2963">    /* representing c-point groups; set caps, flows */</a>
<a name="ln2964">    /************************************************/</a>
<a name="ln2965">    cg = 1;</a>
<a name="ln2966">    for ( c_point = 0; c_point &lt; num_atoms; c_point ++ ) {</a>
<a name="ln2967">        if ( (nType &amp; (type=GetAtomChargeType( at, c_point, NULL, &amp;mask, 0 ))) &amp;&amp; (mask &amp; nMask)</a>
<a name="ln2968">#if ( OPPOSITE_CHARGE_IN_CGROUP == 0 )</a>
<a name="ln2969">             &amp;&amp; ( at[c_point].charge == nCharge || !at[c_point].charge)</a>
<a name="ln2970">#endif</a>
<a name="ln2971">        );</a>
<a name="ln2972">        else</a>
<a name="ln2973">            continue;</a>
<a name="ln2974">        fictpoint = cg + num_vertices - 1; /* c-group vertex index */</a>
<a name="ln2975">        vert_ficpoint = pBNS-&gt;vert + fictpoint; /* c-group vertex */</a>
<a name="ln2976">        vertex_cpoint = pBNS-&gt;vert + c_point;   /* c_point vertex */</a>
<a name="ln2977">        /* Debug: check overflow */</a>
<a name="ln2978">        if ( fictpoint &gt;= pBNS-&gt;max_vertices ||</a>
<a name="ln2979">             num_edges &gt;= pBNS-&gt;max_edges    ||</a>
<a name="ln2980">             vert_ficpoint-&gt;num_adj_edges &gt;= vert_ficpoint-&gt;max_adj_edges ||</a>
<a name="ln2981">             vertex_cpoint-&gt;num_adj_edges &gt;= vertex_cpoint-&gt;max_adj_edges ) {</a>
<a name="ln2982">            ret = BNS_VERT_EDGE_OVFL;</a>
<a name="ln2983">            break;</a>
<a name="ln2984">        }</a>
<a name="ln2985">        vertex_cpoint-&gt;type |= BNS_VERT_TYPE_C_POINT;</a>
<a name="ln2986">        if ( (KNOWN_ACIDIC_TYPE &amp; type) &amp;&amp; nCharge &lt; 0 ) {</a>
<a name="ln2987">            vertex_cpoint-&gt;type |= pBNS-&gt;type_TACN;</a>
<a name="ln2988">        }</a>
<a name="ln2989">#if ( FIX_CPOINT_BOND_CAP != 1 )  /* { */</a>
<a name="ln2990">        /* set capacity = 1 to the edges from the c_point to the centerpoint(s)     */</a>
<a name="ln2991">        /* if their current capacity is zero                                        */</a>
<a name="ln2992">        /* the centerpoint is any adjacent atom that is adjacent to a multiple bond */</a>
<a name="ln2993">        for ( k = 0; k &lt; vertex_cpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln2994">            int iedge = vertex_cpoint-&gt;iedge[k];</a>
<a name="ln2995">            if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln2996">                /* single bond, possibly between c_point and centerpoint */</a>
<a name="ln2997">                centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ c_point);</a>
<a name="ln2998">                if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln2999">                     pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln3000">                    int bond_type = (at[c_point].bond_type[k] &amp; BOND_TYPE_MASK);</a>
<a name="ln3001">                    if ( bond_type == BOND_TAUTOM ||</a>
<a name="ln3002">                         bond_type == BOND_ALTERN ||</a>
<a name="ln3003">                         bond_type == BOND_SINGLE ) {</a>
<a name="ln3004">                        pBNS-&gt;edge[iedge].cap = 1;</a>
<a name="ln3005">                    }</a>
<a name="ln3006">                }</a>
<a name="ln3007">            }</a>
<a name="ln3008">        }</a>
<a name="ln3009">#endif /* } FIX_CPOINT_BOND_CAP */</a>
<a name="ln3010">        /* create a new edge connecting c_point to the new fictitious c-group vertex vert_ficpoint */</a>
<a name="ln3011">        edge = pBNS-&gt;edge + num_edges;</a>
<a name="ln3012">        edge-&gt;cap       = 1;</a>
<a name="ln3013">        edge-&gt;flow      = 0;</a>
<a name="ln3014">        edge-&gt;pass      = 0;</a>
<a name="ln3015">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln3016">        edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask; /* remove previous temporary ban */</a>
<a name="ln3017">#endif</a>
<a name="ln3018">        /* nCharge = +1: mark edge to c-point having no (+)-moveable charge with flow=1 */</a>
<a name="ln3019">        /* nCharge = -1: mark edge to c-point having -1 moveable charge with flow=1 */</a>
<a name="ln3020">        if ( (nCharge==1 &amp;&amp; (at[c_point].charge != 1)) || (nCharge==-1 &amp;&amp; (at[c_point].charge == -1)) )</a>
<a name="ln3021">        /*if ( !CHARGED_CPOINT(at,c_point) )*/</a>
<a name="ln3022">        {</a>
<a name="ln3023">            /* increment new edge flow, update st_edges of the adjacent vertices */</a>
<a name="ln3024">            edge-&gt;flow ++;</a>
<a name="ln3025">            /* increment c-group vertex st-flow &amp; cap */</a>
<a name="ln3026">            vert_ficpoint-&gt;st_edge.flow ++;</a>
<a name="ln3027">            vert_ficpoint-&gt;st_edge.cap ++;</a>
<a name="ln3028">            /* increment c-point vertex st-flow &amp; cap */</a>
<a name="ln3029">            vertex_cpoint-&gt;st_edge.flow ++;</a>
<a name="ln3030">            vertex_cpoint-&gt;st_edge.cap ++;</a>
<a name="ln3031">        }</a>
<a name="ln3032">#if ( FIX_CPOINT_BOND_CAP == 1 ) /* { */</a>
<a name="ln3033">        /* set capacity = 1 to the edges from the c_point to the centerpoint(s)     */</a>
<a name="ln3034">        /* if their current capacity is zero                                        */</a>
<a name="ln3035">        /* the centerpoint is any adjacent atom that is adjacent to a multiple bond */</a>
<a name="ln3036">        for ( k = 0; k &lt; vertex_cpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln3037">            int iedge = vertex_cpoint-&gt;iedge[k];</a>
<a name="ln3038">            VertexFlow  nNewCap = vertex_cpoint-&gt;st_edge.cap;</a>
<a name="ln3039">            centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ c_point);</a>
<a name="ln3040">            if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln3041">                /* single bond, possibly between c_point and centerpoint */</a>
<a name="ln3042">                if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln3043">                     pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln3044">                    nNewCap = inchi_min( pBNS-&gt;vert[centerpoint].st_edge.cap, nNewCap );</a>
<a name="ln3045">                    nNewCap = inchi_min( nNewCap, MAX_BOND_EDGE_CAP );</a>
<a name="ln3046">                    pBNS-&gt;edge[iedge].cap = nNewCap;</a>
<a name="ln3047">                }</a>
<a name="ln3048">            }</a>
<a name="ln3049">#if ( FIX_CPOINT_BOND_CAP2 == 1 ) /* multiple bond */</a>
<a name="ln3050">            else</a>
<a name="ln3051">            if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln3052">                 edge-&gt;flow &amp;&amp; pBNS-&gt;edge[iedge].cap &lt; MAX_BOND_EDGE_CAP ) {</a>
<a name="ln3053">                pBNS-&gt;edge[iedge].cap ++;</a>
<a name="ln3054">            }</a>
<a name="ln3055">#endif</a>
<a name="ln3056">        }</a>
<a name="ln3057">#endif  /* } FIX_CPOINT_BOND_CAP */</a>
<a name="ln3058">        /* connect edge to c_point and fictpoint and increment the counters of neighbors and edges */</a>
<a name="ln3059">        edge-&gt;neighbor1    = c_point; /* the smallest out of v1=endopoint and v2=num_vertices */</a>
<a name="ln3060">        edge-&gt;neighbor12   = c_point ^ fictpoint; /* v1 ^ v2 */</a>
<a name="ln3061">        vertex_cpoint-&gt;iedge[vertex_cpoint-&gt;num_adj_edges] = num_edges;</a>
<a name="ln3062">        vert_ficpoint-&gt;iedge[vert_ficpoint-&gt;num_adj_edges] = num_edges ++;</a>
<a name="ln3063">        edge-&gt;neigh_ord[0] = vertex_cpoint-&gt;num_adj_edges ++;</a>
<a name="ln3064">        edge-&gt;neigh_ord[1] = vert_ficpoint-&gt;num_adj_edges ++;</a>
<a name="ln3065">        edge-&gt;cap0  = edge-&gt;cap;</a>
<a name="ln3066">        edge-&gt;flow0 = edge-&gt;flow;</a>
<a name="ln3067"> </a>
<a name="ln3068">    }</a>
<a name="ln3069">    ret = pBNS-&gt;num_vertices; /* new c-group atom number */</a>
<a name="ln3070">    pBNS-&gt;num_edges     = num_edges;</a>
<a name="ln3071">    pBNS-&gt;num_vertices += num_cg;</a>
<a name="ln3072">    pBNS-&gt;num_c_groups += num_cg;</a>
<a name="ln3073"> </a>
<a name="ln3074">    return ret;</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077">/*********************************************************************************/</a>
<a name="ln3078">int CreateTGroupInBnStruct( inp_ATOM *at, int num_atoms,</a>
<a name="ln3079">                            BN_STRUCT *pBNS, int nType, int nMask )</a>
<a name="ln3080">{</a>
<a name="ln3081">    int ret = 0;</a>
<a name="ln3082">    /* ret = ReInitBnStruct( pBNS ); */</a>
<a name="ln3083">    int         k, endpoint, tg, centerpoint, fictpoint;</a>
<a name="ln3084">    int         num_tg       = 1;</a>
<a name="ln3085">    int         num_edges    = pBNS-&gt;num_edges;</a>
<a name="ln3086">    int         num_vertices = pBNS-&gt;num_vertices;</a>
<a name="ln3087">    BNS_VERTEX *vert_ficpoint, *ver_ficpont_prev;  /* fictitious vertex describing t-group */</a>
<a name="ln3088">    BNS_VERTEX *vert_endpoint;</a>
<a name="ln3089">    BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric endpoint */</a>
<a name="ln3090">     int        mask, num_endpoints, neutral_valence, edge_flow, edge_cap, num_bonds;</a>
<a name="ln3091"> </a>
<a name="ln3092">    /* Debug: check overflow */</a>
<a name="ln3093">    if ( num_vertices + num_tg &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln3094">        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3095">    }</a>
<a name="ln3096">    /* count new t-group edges */</a>
<a name="ln3097">    for ( endpoint = 0, num_endpoints = 0; endpoint &lt; num_atoms; endpoint ++ ) {</a>
<a name="ln3098">        if ( (nType &amp; GetAtomChargeType( at, endpoint, NULL, &amp;mask, 0 )) &amp;&amp; (mask &amp; nMask)</a>
<a name="ln3099">           ) {</a>
<a name="ln3100">            num_endpoints ++;</a>
<a name="ln3101">        }</a>
<a name="ln3102">    }</a>
<a name="ln3103">    if ( !num_endpoints ) {</a>
<a name="ln3104">        return 0;</a>
<a name="ln3105">    }</a>
<a name="ln3106"> </a>
<a name="ln3107"> </a>
<a name="ln3108">    /* since t-group IDs may be not contiguous, clear all vertices that will be added.</a>
<a name="ln3109">       all-zeroes-vertex will be ignored by the BNS</a>
<a name="ln3110">    */</a>
<a name="ln3111">    memset( pBNS-&gt;vert+num_vertices, 0, num_tg*sizeof(pBNS-&gt;vert[0]) );</a>
<a name="ln3112">    /* *old* Make sure the last t-group has the largest t-group ID:</a>
<a name="ln3113">       this is necessary to correctly add new edges and vertices for testing augmenting paths</a>
<a name="ln3114">    */</a>
<a name="ln3115">    /**************************************/</a>
<a name="ln3116">    /* initialize new fictitious vertex   */</a>
<a name="ln3117">    /* representing t-point group         */</a>
<a name="ln3118">    /**************************************/</a>
<a name="ln3119">    ver_ficpont_prev = pBNS-&gt;vert+num_vertices - 1;</a>
<a name="ln3120"> </a>
<a name="ln3121">    for ( tg = 0; tg &lt; num_tg; tg ++, ver_ficpont_prev = vert_ficpoint ) {</a>
<a name="ln3122">        /*</a>
<a name="ln3123">          vert_ficpoint-1 is the last vertex;</a>
<a name="ln3124">          vert_ficpoint   is the vertex that is being added</a>
<a name="ln3125">          Note: nGroupNumber are not contiguous</a>
<a name="ln3126">        */</a>
<a name="ln3127">        vert_ficpoint                = pBNS-&gt;vert+num_vertices + tg;</a>
<a name="ln3128">        vert_ficpoint-&gt;iedge         = ver_ficpont_prev-&gt;iedge + ver_ficpont_prev-&gt;max_adj_edges;</a>
<a name="ln3129">        vert_ficpoint-&gt;max_adj_edges = num_endpoints+BNS_ADD_EDGES+BNS_ADD_SUPER_TGROUP;</a>
<a name="ln3130">        vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln3131">        vert_ficpoint-&gt;st_edge.flow  = vert_ficpoint-&gt;st_edge.flow0  = 0;</a>
<a name="ln3132">        vert_ficpoint-&gt;st_edge.cap   = vert_ficpoint-&gt;st_edge.cap0   = 0;</a>
<a name="ln3133">        vert_ficpoint-&gt;type         |= BNS_VERT_TYPE_TGROUP;</a>
<a name="ln3134">    }</a>
<a name="ln3135">    tg = 1;</a>
<a name="ln3136">    for ( endpoint = 0; endpoint &lt; num_atoms; endpoint ++ ) {</a>
<a name="ln3137">        if ( (nType &amp; GetAtomChargeType( at, endpoint, NULL, &amp;mask, 0 )) &amp;&amp; (mask &amp; nMask));</a>
<a name="ln3138">        else</a>
<a name="ln3139">            continue;</a>
<a name="ln3140">        fictpoint = tg + num_vertices - 1;</a>
<a name="ln3141">        vert_ficpoint = pBNS-&gt;vert + fictpoint;</a>
<a name="ln3142">        vert_endpoint = pBNS-&gt;vert + endpoint;</a>
<a name="ln3143">        /* Debug: check overflow */</a>
<a name="ln3144">        if ( fictpoint &gt;= pBNS-&gt;max_vertices ||</a>
<a name="ln3145">             num_edges &gt;= pBNS-&gt;max_edges    ||</a>
<a name="ln3146">             vert_ficpoint-&gt;num_adj_edges &gt;= vert_ficpoint-&gt;max_adj_edges ||</a>
<a name="ln3147">             vert_endpoint-&gt;num_adj_edges &gt;= vert_endpoint-&gt;max_adj_edges ) {</a>
<a name="ln3148">            ret = BNS_VERT_EDGE_OVFL;</a>
<a name="ln3149">            break;</a>
<a name="ln3150">        }</a>
<a name="ln3151">        /* obtain donor/acceptor info */</a>
<a name="ln3152">        neutral_valence = at[endpoint].chem_bonds_valence + at[endpoint].num_H - at[endpoint].charge;</a>
<a name="ln3153">        if ( neutral_valence != 2 /* O, S, Se, Te */ &amp;&amp;</a>
<a name="ln3154">             neutral_valence != 3 /* N, P */          ) {</a>
<a name="ln3155">            ret = BNS_PROGRAM_ERR; /* wrong endpoint neutral valence */</a>
<a name="ln3156">            break;</a>
<a name="ln3157">        }</a>
<a name="ln3158">        edge_flow = at[endpoint].num_H;</a>
<a name="ln3159">        num_bonds = at[endpoint].valence;</a>
<a name="ln3160">        edge_cap  = neutral_valence - num_bonds; /* does not allow to reduce -NH3(+) to #N or -OH(+)- to -O- */</a>
<a name="ln3161">        if ( 3 == neutral_valence /* N or P */ &amp;&amp; 1 &lt; num_bonds ) {</a>
<a name="ln3162">            edge_cap ++; /* allow -NH2(+)- =&gt; -N=, &gt;NH(+)- =&gt; &gt;N- */</a>
<a name="ln3163">        }</a>
<a name="ln3164">        edge_flow = inchi_min( edge_flow, edge_cap);</a>
<a name="ln3165">        /*</a>
<a name="ln3166">        if ( !nGetEndpointInfo( at, endpoint, &amp;eif ) ) {</a>
<a name="ln3167">            ret = BNS_BOND_ERR;</a>
<a name="ln3168">            break;</a>
<a name="ln3169">        }</a>
<a name="ln3170">        */</a>
<a name="ln3171">        vert_endpoint-&gt;type |= BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln3172">        /* create a new edge connecting endpoint to the new fictitious t-group vertex vert_ficpoint */</a>
<a name="ln3173">        edge = pBNS-&gt;edge + num_edges;</a>
<a name="ln3174">        edge-&gt;cap       = edge_cap;</a>
<a name="ln3175">        edge-&gt;flow      = edge_flow;</a>
<a name="ln3176">        edge-&gt;pass      = 0;</a>
<a name="ln3177">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln3178">        edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln3179">#endif</a>
<a name="ln3180">        /* adjust st_flow and st_cap of the adjacent vertices */</a>
<a name="ln3181">        /* adjust t-group vertex st-flow &amp; cap */</a>
<a name="ln3182">        vert_ficpoint-&gt;st_edge.flow += edge-&gt;flow;</a>
<a name="ln3183">        vert_ficpoint-&gt;st_edge.cap  += edge-&gt;flow;</a>
<a name="ln3184">        /* adjust endpoint vertex st-flow &amp; cap */</a>
<a name="ln3185">        vert_endpoint-&gt;st_edge.flow += edge-&gt;flow;</a>
<a name="ln3186">        vert_endpoint-&gt;st_edge.cap  += edge-&gt;flow;</a>
<a name="ln3187"> </a>
<a name="ln3188">        /* adjust edge cap &amp; flow according to the number of H and number of bonds */</a>
<a name="ln3189">        for ( k = 0; k &lt; vert_endpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln3190">            int iedge = vert_endpoint-&gt;iedge[k];</a>
<a name="ln3191">            VertexFlow  nNewCap = vert_endpoint-&gt;st_edge.cap;</a>
<a name="ln3192">            if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln3193">                /* single bond, possibly between endpoint and centerpoint */</a>
<a name="ln3194">                centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ endpoint);</a>
<a name="ln3195">                if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln3196">                     pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln3197">                    nNewCap = inchi_min( pBNS-&gt;vert[centerpoint].st_edge.cap, nNewCap );</a>
<a name="ln3198">                    nNewCap = inchi_min( nNewCap, MAX_BOND_EDGE_CAP );</a>
<a name="ln3199">                    pBNS-&gt;edge[iedge].cap = nNewCap;</a>
<a name="ln3200">                }</a>
<a name="ln3201">            }</a>
<a name="ln3202">        }</a>
<a name="ln3203"> </a>
<a name="ln3204">        /* connect edge to endpoint and fictpoint and increment the counters of neighbors and edges */</a>
<a name="ln3205">        edge-&gt;neighbor1    = endpoint; /* the smallest out of v1=endopoint and v2=num_vertices */</a>
<a name="ln3206">        edge-&gt;neighbor12   = endpoint ^ fictpoint; /* v1 ^ v2 */</a>
<a name="ln3207">        vert_endpoint-&gt;iedge[vert_endpoint-&gt;num_adj_edges] = num_edges;</a>
<a name="ln3208">        vert_ficpoint-&gt;iedge[vert_ficpoint-&gt;num_adj_edges] = num_edges ++;</a>
<a name="ln3209">        edge-&gt;neigh_ord[0] = vert_endpoint-&gt;num_adj_edges ++;</a>
<a name="ln3210">        edge-&gt;neigh_ord[1] = vert_ficpoint-&gt;num_adj_edges ++;</a>
<a name="ln3211">        edge-&gt;cap0  = edge-&gt;cap;</a>
<a name="ln3212">        edge-&gt;flow0 = edge-&gt;flow;</a>
<a name="ln3213">    }</a>
<a name="ln3214"> </a>
<a name="ln3215">    ret = pBNS-&gt;num_vertices; /* new t-group atom number */</a>
<a name="ln3216">    pBNS-&gt;num_edges     = num_edges;</a>
<a name="ln3217">    pBNS-&gt;num_vertices += num_tg;</a>
<a name="ln3218">    pBNS-&gt;num_t_groups += num_tg;</a>
<a name="ln3219"> </a>
<a name="ln3220">    return ret;</a>
<a name="ln3221">}</a>
<a name="ln3222"> </a>
<a name="ln3223"> </a>
<a name="ln3224"> </a>
<a name="ln3225">/*********************************************************************************/</a>
<a name="ln3226">int RemoveLastGroupFromBnStruct( inp_ATOM *at, int num_atoms, int tg, BN_STRUCT *pBNS )</a>
<a name="ln3227">{</a>
<a name="ln3228">    int ret = 0;</a>
<a name="ln3229">    /* ret = ReInitBnStruct( pBNS ); */</a>
<a name="ln3230">    int         k, endpoint, /*centerpoint, fictpoint,*/ iedge;</a>
<a name="ln3231">    int         num_edges    = pBNS-&gt;num_edges;</a>
<a name="ln3232">    int         num_vertices = pBNS-&gt;num_vertices;</a>
<a name="ln3233">    BNS_VERTEX *vert_ficpoint /*, *ver_ficpont_prev*/;  /* fictitious vertex describing t-group */</a>
<a name="ln3234">    BNS_VERTEX *vert_endpoint;</a>
<a name="ln3235">    BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric endpoint */</a>
<a name="ln3236">    /*int        mask, num_endpoints, neutral_valence, edge_flow, edge_cap, num_bonds;*/</a>
<a name="ln3237">    int        is_t_group = 0, is_c_group = 0;</a>
<a name="ln3238"> </a>
<a name="ln3239">    /* Debug: check overflow */</a>
<a name="ln3240">    if ( pBNS-&gt;num_added_atoms + pBNS-&gt;num_c_groups + pBNS-&gt;num_t_groups + num_atoms &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln3241">        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3242">    }</a>
<a name="ln3243">    if ( tg + 1 != num_vertices ) {</a>
<a name="ln3244">        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3245">    }</a>
<a name="ln3246">    vert_ficpoint = pBNS-&gt;vert + tg;</a>
<a name="ln3247">    if ( vert_ficpoint-&gt;type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln3248">        is_t_group = 1;</a>
<a name="ln3249">    }</a>
<a name="ln3250">    if ( vert_ficpoint-&gt;type &amp; BNS_VERT_TYPE_C_GROUP ) {</a>
<a name="ln3251">        is_c_group = 1;</a>
<a name="ln3252">        if ( vert_ficpoint-&gt;type &amp; BNS_VERT_TYPE_C_NEGATIVE )</a>
<a name="ln3253">            is_c_group = 2;</a>
<a name="ln3254">    }</a>
<a name="ln3255">    for ( k = vert_ficpoint-&gt;num_adj_edges-1; 0 &lt;= k; k -- ) {</a>
<a name="ln3256">        iedge         = vert_ficpoint-&gt;iedge[k];</a>
<a name="ln3257">        if ( iedge + 1 != num_edges ) {</a>
<a name="ln3258">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3259">        }</a>
<a name="ln3260">        edge          = pBNS-&gt;edge + iedge;</a>
<a name="ln3261">        endpoint      = edge-&gt;neighbor12 ^ tg;</a>
<a name="ln3262">        vert_endpoint = pBNS-&gt;vert + endpoint;</a>
<a name="ln3263">        /* adjust st_flow, st_cap */</a>
<a name="ln3264">        vert_endpoint-&gt;st_edge.cap0  =</a>
<a name="ln3265">        vert_endpoint-&gt;st_edge.cap   -= edge-&gt;flow;</a>
<a name="ln3266">        vert_endpoint-&gt;st_edge.flow0 =</a>
<a name="ln3267">        vert_endpoint-&gt;st_edge.flow  -= edge-&gt;flow;</a>
<a name="ln3268">        if ( pBNS-&gt;type_TACN &amp;&amp; (vert_endpoint-&gt;type &amp; pBNS-&gt;type_TACN) == pBNS-&gt;type_TACN ) {</a>
<a name="ln3269">            vert_endpoint-&gt;type ^= pBNS-&gt;type_TACN;</a>
<a name="ln3270">        }</a>
<a name="ln3271">        if ( is_t_group ) {</a>
<a name="ln3272">            vert_endpoint-&gt;type ^= (vert_ficpoint-&gt;type &amp; BNS_VERT_TYPE_ENDPOINT);</a>
<a name="ln3273">        }</a>
<a name="ln3274">        if ( is_c_group ) {</a>
<a name="ln3275">            vert_endpoint-&gt;type ^= (vert_ficpoint-&gt;type &amp; BNS_VERT_TYPE_C_POINT);</a>
<a name="ln3276">        }</a>
<a name="ln3277">        /* remove edge */</a>
<a name="ln3278">        if ( edge-&gt;neigh_ord[0]+1 != vert_endpoint-&gt;num_adj_edges ) {</a>
<a name="ln3279">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln3280">        }</a>
<a name="ln3281">        vert_endpoint-&gt;num_adj_edges --;</a>
<a name="ln3282">        memset( edge, 0, sizeof(*edge) );</a>
<a name="ln3283">        num_edges --;</a>
<a name="ln3284">        if ( 1 == is_t_group &amp;&amp; endpoint &lt; num_atoms ) {</a>
<a name="ln3285">            at-&gt;endpoint = 0;</a>
<a name="ln3286">        }</a>
<a name="ln3287">        if ( 1 == is_c_group &amp;&amp; endpoint &lt; num_atoms ) {</a>
<a name="ln3288">            at-&gt;c_point = 0;</a>
<a name="ln3289">        }</a>
<a name="ln3290">    }</a>
<a name="ln3291">    memset( vert_ficpoint, 0, sizeof(*vert_ficpoint) );</a>
<a name="ln3292">    num_vertices --;</a>
<a name="ln3293"> </a>
<a name="ln3294">    pBNS-&gt;num_edges     = num_edges;</a>
<a name="ln3295">    pBNS-&gt;num_vertices  = num_vertices;</a>
<a name="ln3296">    if ( is_t_group )</a>
<a name="ln3297">        pBNS-&gt;num_t_groups --;</a>
<a name="ln3298">    if ( is_c_group )</a>
<a name="ln3299">        pBNS-&gt;num_c_groups --;</a>
<a name="ln3300"> </a>
<a name="ln3301">    return ret;</a>
<a name="ln3302">}</a>
<a name="ln3303"> </a>
<a name="ln3304"> </a>
<a name="ln3305"> </a>
<a name="ln3306">/******************************************************************************************/</a>
<a name="ln3307">int SetInitCapFlowToCurrent( BN_STRUCT *pBNS )</a>
<a name="ln3308">{</a>
<a name="ln3309">    int       i, j;</a>
<a name="ln3310">    BNS_EDGE *pEdge=NULL;</a>
<a name="ln3311">    for ( i = 0; i &lt; pBNS-&gt;num_vertices; i ++ ) {</a>
<a name="ln3312">        pBNS-&gt;vert[i].st_edge.flow0 = pBNS-&gt;vert[i].st_edge.flow;</a>
<a name="ln3313">        pBNS-&gt;vert[i].st_edge.cap0 = pBNS-&gt;vert[i].st_edge.cap;</a>
<a name="ln3314">        for ( j = 0; j &lt; pBNS-&gt;vert[i].num_adj_edges; j ++ ) {</a>
<a name="ln3315">            pEdge = pBNS-&gt;edge + pBNS-&gt;vert[i].iedge[j];</a>
<a name="ln3316">            pEdge-&gt;cap0  = pEdge-&gt;cap;</a>
<a name="ln3317">            pEdge-&gt;flow0 = pEdge-&gt;flow;</a>
<a name="ln3318">        }</a>
<a name="ln3319">    }</a>
<a name="ln3320">    return 0;</a>
<a name="ln3321">}</a>
<a name="ln3322"> </a>
<a name="ln3323"> </a>
<a name="ln3324"> </a>
<a name="ln3325">/******************************************************************************************/</a>
<a name="ln3326">int ArTypMask[] = { </a>
<a name="ln3327">    AR_SIMPLE_TYP1, AR_SIMPLE_MSK1,</a>
<a name="ln3328">    AR_SIMPLE_TYP2, AR_SIMPLE_MSK2,</a>
<a name="ln3329">    AR_SIMPLE_TYP3, AR_SIMPLE_MSK3,</a>
<a name="ln3330">    0, 0 };</a>
<a name="ln3331"> </a>
<a name="ln3332">    </a>
<a name="ln3333">    </a>
<a name="ln3334">/******************************************************************************************/</a>
<a name="ln3335">int SimpleRemoveAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2remove )</a>
<a name="ln3336">{</a>
<a name="ln3337">    int i, j, max_j=-1, mask, type, num_removed;</a>
<a name="ln3338">    int num[AR_SIMPLE_STEPS+1], num_tot;</a>
<a name="ln3339"> </a>
<a name="ln3340">    for ( j = 0; ArTypMask[2*j]; j ++ ) {</a>
<a name="ln3341">        num[max_j = j] = 0;</a>
<a name="ln3342">    }</a>
<a name="ln3343"> </a>
<a name="ln3344">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3345">        if ( !at[i].charge &amp;&amp; at[i].num_H &amp;&amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3346">            for ( j = 0; j &lt;= max_j; j ++ ) {</a>
<a name="ln3347">                if ( (type &amp; ArTypMask[2*j]) &amp;&amp; (mask &amp;&amp; ArTypMask[2*j+1]) ) {</a>
<a name="ln3348">                    num[j]  ++;</a>
<a name="ln3349">                    break;</a>
<a name="ln3350">                }</a>
<a name="ln3351">            }</a>
<a name="ln3352">        }</a>
<a name="ln3353">    }</a>
<a name="ln3354">    for ( j = 0, num_tot = 0; j &lt;= max_j; j ++ ) {</a>
<a name="ln3355">        if ( (num_tot += num[j]) &gt;= num2remove ) {</a>
<a name="ln3356">            max_j = j;</a>
<a name="ln3357">            break;</a>
<a name="ln3358">        }</a>
<a name="ln3359">    }</a>
<a name="ln3360">    if ( !num_tot ) {</a>
<a name="ln3361">        return 0;</a>
<a name="ln3362">    }</a>
<a name="ln3363">    for ( i = 0, num_removed = 0; i &lt; num_atoms &amp;&amp; num_removed &lt; num2remove; i ++ ) {</a>
<a name="ln3364">        if ( !at[i].charge &amp;&amp; at[i].num_H &amp;&amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3365">            for ( j = 0; j &lt;= max_j; j ++ ) {</a>
<a name="ln3366">                if ( num[j] &amp;&amp; (type &amp; ArTypMask[2*j]) &amp;&amp; (mask &amp;&amp; ArTypMask[2*j+1]) ) {</a>
<a name="ln3367">                    type = GetAtomChargeType( at, i, pAATG-&gt;nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln3368">                    num[j]  --;</a>
<a name="ln3369">                    at[i].charge --;</a>
<a name="ln3370">                    AddOrRemoveExplOrImplH( -1, at, num_atoms, (AT_NUMB)i, pAATG-&gt;t_group_info );</a>
<a name="ln3371">                    /*at[i].num_H  --;*/</a>
<a name="ln3372">                    num_removed ++;</a>
<a name="ln3373">                    type = GetAtomChargeType( at, i, pAATG-&gt;nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln3374">                    break;</a>
<a name="ln3375">                }</a>
<a name="ln3376">            }</a>
<a name="ln3377">        }</a>
<a name="ln3378">    }</a>
<a name="ln3379">    /*</a>
<a name="ln3380">    pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE]  -= num_removed;</a>
<a name="ln3381">    pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] += num_removed;</a>
<a name="ln3382">    */</a>
<a name="ln3383">    return num_removed;</a>
<a name="ln3384">}</a>
<a name="ln3385"> </a>
<a name="ln3386"> </a>
<a name="ln3387"> </a>
<a name="ln3388">/******************************************************************************************/</a>
<a name="ln3389">int bHasAcidicHydrogen( inp_ATOM *at, int i )</a>
<a name="ln3390">{</a>
<a name="ln3391">    int bFound = 0, j, type, mask;</a>
<a name="ln3392">    if ( !at[i].charge &amp;&amp; at[i].num_H &amp;&amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3393">        for ( j = 0; ArTypMask[2*j]; j ++ ) {</a>
<a name="ln3394">            if ( (type &amp; ArTypMask[2*j]) &amp;&amp; (mask &amp; ArTypMask[2*j+1]) ) {</a>
<a name="ln3395">                bFound ++;</a>
<a name="ln3396">                break;</a>
<a name="ln3397">            }</a>
<a name="ln3398">        }</a>
<a name="ln3399">    }</a>
<a name="ln3400">    return bFound;</a>
<a name="ln3401">}</a>
<a name="ln3402"> </a>
<a name="ln3403"> </a>
<a name="ln3404"> </a>
<a name="ln3405">/******************************************************************************************/</a>
<a name="ln3406">int bHasOtherExchangableH ( inp_ATOM *at, int i )</a>
<a name="ln3407">{</a>
<a name="ln3408">    int bFound = 0, type, mask;</a>
<a name="ln3409">    if ( at[i].num_H &amp;&amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3410">            if ( (type &amp; ATT_ATOM_N) &amp;&amp; (mask &amp; ATBIT_NP_H) ) {</a>
<a name="ln3411">                bFound ++;</a>
<a name="ln3412">            }</a>
<a name="ln3413">    }</a>
<a name="ln3414">    return bFound;</a>
<a name="ln3415">}</a>
<a name="ln3416"> </a>
<a name="ln3417"> </a>
<a name="ln3418"> </a>
<a name="ln3419">/******************************************************************************************/</a>
<a name="ln3420">int AaTypMask[] = { </a>
<a name="ln3421">    AA_SIMPLE_TYP1, AA_SIMPLE_MSK1,</a>
<a name="ln3422">#if ( FIX_NP_MINUS_BUG == 1 )</a>
<a name="ln3423">    AA_SIMPLE_TYP4, AA_SIMPLE_MSK4,   /* should not follow 0,0 pair */</a>
<a name="ln3424">#endif</a>
<a name="ln3425">    AA_SIMPLE_TYP2, AA_SIMPLE_MSK2,</a>
<a name="ln3426">    AA_SIMPLE_TYP3, AA_SIMPLE_MSK3,</a>
<a name="ln3427">    0, 0 };</a>
<a name="ln3428"> </a>
<a name="ln3429">    </a>
<a name="ln3430">    </a>
<a name="ln3431">/******************************************************************************************/</a>
<a name="ln3432">int SimpleAddAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2add )</a>
<a name="ln3433">{</a>
<a name="ln3434">    int i, j, max_j=-1, mask, type, num_added;</a>
<a name="ln3435">    int num[AR_SIMPLE_STEPS+1], num_tot;</a>
<a name="ln3436"> </a>
<a name="ln3437">    for ( j = 0; AaTypMask[2*j]; j ++ ) {</a>
<a name="ln3438">        num[max_j = j] = 0;</a>
<a name="ln3439">    }</a>
<a name="ln3440"> </a>
<a name="ln3441">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln3442">        if ( at[i].charge==-1 &amp;&amp;  (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3443">            for ( j = 0; j &lt;= max_j; j ++ ) {</a>
<a name="ln3444">                if ( (type &amp; AaTypMask[2*j]) &amp;&amp; (mask &amp;&amp; AaTypMask[2*j+1]) ) {</a>
<a name="ln3445">                    num[j]  ++;</a>
<a name="ln3446">                    break;</a>
<a name="ln3447">                }</a>
<a name="ln3448">            }</a>
<a name="ln3449">        }</a>
<a name="ln3450">    }</a>
<a name="ln3451">    for ( j = 0, num_tot = 0; j &lt;= max_j; j ++ ) {</a>
<a name="ln3452">        if ( (num_tot += num[j]) &gt;= num2add ) {</a>
<a name="ln3453">            max_j = j;</a>
<a name="ln3454">            break;</a>
<a name="ln3455">        }</a>
<a name="ln3456">    }</a>
<a name="ln3457">    if ( !num_tot ) {</a>
<a name="ln3458">        return 0;</a>
<a name="ln3459">    }</a>
<a name="ln3460">    for ( i = 0, num_added = 0; i &lt; num_atoms &amp;&amp; num_added &lt; num2add; i ++ ) {</a>
<a name="ln3461">        if ( at[i].charge==-1 &amp;&amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3462">            for ( j = 0; j &lt;= max_j; j ++ ) {</a>
<a name="ln3463">                if ( num[j] &amp;&amp; (type &amp; AaTypMask[2*j]) &amp;&amp; (mask &amp;&amp; AaTypMask[2*j+1]) ) {</a>
<a name="ln3464">                    type = GetAtomChargeType( at, i, pAATG-&gt;nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln3465">                    num[j]  --;</a>
<a name="ln3466">                    at[i].charge ++;</a>
<a name="ln3467">                    AddOrRemoveExplOrImplH( 1, at, num_atoms, (AT_NUMB)i, pAATG-&gt;t_group_info );</a>
<a name="ln3468">                    /*at[i].num_H  ++;*/</a>
<a name="ln3469">                    num_added ++;</a>
<a name="ln3470">                    type = GetAtomChargeType( at, i, pAATG-&gt;nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln3471">                    break;</a>
<a name="ln3472">                }</a>
<a name="ln3473">            }</a>
<a name="ln3474">        }</a>
<a name="ln3475">    }</a>
<a name="ln3476">    /*</a>
<a name="ln3477">    pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE]  += num_added;</a>
<a name="ln3478">    pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] -= num_added;</a>
<a name="ln3479">    */</a>
<a name="ln3480">    return num_added;</a>
<a name="ln3481">}</a>
<a name="ln3482"> </a>
<a name="ln3483"> </a>
<a name="ln3484"> </a>
<a name="ln3485">/******************************************************************************************/</a>
<a name="ln3486">int bHasAcidicMinus( inp_ATOM *at, int i )</a>
<a name="ln3487">{</a>
<a name="ln3488">    int bFound = 0, j, type, mask;</a>
<a name="ln3489">    if ( at[i].charge==-1 &amp;&amp;  (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) {</a>
<a name="ln3490">        for ( j = 0; AaTypMask[2*j]; j ++ ) {</a>
<a name="ln3491">            if ( (type &amp; AaTypMask[2*j]) &amp;&amp; (mask &amp; AaTypMask[2*j+1]) ) {</a>
<a name="ln3492">                bFound  ++;</a>
<a name="ln3493">                break;</a>
<a name="ln3494">            }</a>
<a name="ln3495">        }</a>
<a name="ln3496">    }</a>
<a name="ln3497">    return bFound;</a>
<a name="ln3498">}</a>
<a name="ln3499"> </a>
<a name="ln3500"> </a>
<a name="ln3501"> </a>
<a name="ln3502">/******************************************************************************************</a>
<a name="ln3503">Create 2 tautomeric groups: (1) for O on -C=O, (2) for the rest of the atoms.</a>
<a name="ln3504">Pull H from (2) to (1); remove later </a>
<a name="ln3505">*******************************************************************************************/</a>
<a name="ln3506">int HardRemoveAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2remove, int *nNumCanceledCharges, BN_STRUCT *pBNS, BN_DATA *pBD )</a>
<a name="ln3507">{</a>
<a name="ln3508">    int cg_Plus      = 0;</a>
<a name="ln3509">    int cg_Minus     = 0;</a>
<a name="ln3510">    int tg_H_Other   = 0;</a>
<a name="ln3511">    int tg_H_Acid    = 0;</a>
<a name="ln3512"> </a>
<a name="ln3513">    int ret = 0, ret2;</a>
<a name="ln3514">    int nDelta, nNumChanges = 0, nNumMoved2AcidH = 0, nNumNeutralized = 0, nPrevNumCharges;</a>
<a name="ln3515"> </a>
<a name="ln3516">    int nPosCharges, nPosCharges2;</a>
<a name="ln3517">    int nNegCharges, nNegCharges2;</a>
<a name="ln3518">    /*</a>
<a name="ln3519">    int nNumNP_H, nNumNP_H2;</a>
<a name="ln3520">    int nNumOS_H, nNumOS_H2;</a>
<a name="ln3521">    */</a>
<a name="ln3522"> </a>
<a name="ln3523">    nPosCharges =  (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3524">    nNegCharges =  (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3525">    /*</a>
<a name="ln3526">    nNumNP_H    =  pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_H] +</a>
<a name="ln3527">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton];</a>
<a name="ln3528">    nNumOS_H    =  pAATG-&gt;nAtTypeTotals[ATTOT_NUM_COH] +</a>
<a name="ln3529">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CSH] + </a>
<a name="ln3530">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZOH];</a>
<a name="ln3531">    */</a>
<a name="ln3532"> </a>
<a name="ln3533">    /* prevent free exchange H &lt;-&gt; (-) */</a>
<a name="ln3534">    pBNS-&gt;type_CN   = (BNS_VERT_TYPE_C_GROUP | BNS_VERT_TYPE_C_NEGATIVE);</a>
<a name="ln3535">    pBNS-&gt;type_T    = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln3536">    pBNS-&gt;type_TACN = BNS_VERT_TYPE_ACID;</a>
<a name="ln3537">    /* create (+) charge group */</a>
<a name="ln3538">    cg_Plus = CreateCGroupInBnStruct( at, num_atoms, pBNS, AR_HARD_TYP_POS, AR_HARD_MSK_POS, 1 );</a>
<a name="ln3539">    /* create (-) charge group */</a>
<a name="ln3540">    /*</a>
<a name="ln3541">    if ( nAtTypeTotals[ATTOT_NUM_CO_Minus] + </a>
<a name="ln3542">         nAtTypeTotals[ATTOT_NUM_CS_Minus] + </a>
<a name="ln3543">         nAtTypeTotals[ATTOT_NUM_ZO_Minus] + </a>
<a name="ln3544">         nAtTypeTotals[ATTOT_NUM_N_Minus] )</a>
<a name="ln3545">    */</a>
<a name="ln3546">    cg_Minus = CreateCGroupInBnStruct( at, num_atoms, pBNS, AR_HARD_TYP_NEG, AR_HARD_MSK_NEG, -1 );</a>
<a name="ln3547"> </a>
<a name="ln3548">    pBNS-&gt;type_CN   = (BNS_VERT_TYPE_C_GROUP | BNS_VERT_TYPE_C_NEGATIVE);</a>
<a name="ln3549">    pBNS-&gt;type_T    = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln3550">    pBNS-&gt;type_TACN = BNS_VERT_TYPE_ACID;</a>
<a name="ln3551">    </a>
<a name="ln3552">    /* create tautomeric group for non-acidic or negatively charged acidic O  */</a>
<a name="ln3553">    tg_H_Other = CreateTGroupInBnStruct( at, num_atoms, pBNS, AR_HARD_TYP_HN, AR_HARD_MSK_HN );</a>
<a name="ln3554"> </a>
<a name="ln3555">    /* create tautomeric group for possibly acidic O */</a>
<a name="ln3556">    tg_H_Acid = CreateTGroupInBnStruct( at, num_atoms, pBNS, AR_HARD_TYP_HA, AR_HARD_MSK_HA );</a>
<a name="ln3557">    if ( tg_H_Other &gt;= num_atoms &amp;&amp; tg_H_Acid &gt;= num_atoms ) {</a>
<a name="ln3558">        /* find alt path to remove one proton */</a>
<a name="ln3559">        do {</a>
<a name="ln3560">            /* remove a proton */</a>
<a name="ln3561">            nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3562">            ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3563">                            tg_H_Other /*nVertDoubleBond*/, tg_H_Acid /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3564">            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3565">                return ret;</a>
<a name="ln3566">            }</a>
<a name="ln3567">            if ( ret &amp; 1 ) {</a>
<a name="ln3568">                nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3569">                nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3570">                if ( nDelta ) {</a>
<a name="ln3571">                    /* radical pair has disappeared */</a>
<a name="ln3572">                    ; /* goto quick_exit;*/</a>
<a name="ln3573">                }</a>
<a name="ln3574">                nNumMoved2AcidH ++;</a>
<a name="ln3575">                if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + 1 ) {</a>
<a name="ln3576">                    nNumNeutralized += (nPrevNumCharges - (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - 1))/2;</a>
<a name="ln3577">                }</a>
<a name="ln3578">            }</a>
<a name="ln3579"> </a>
<a name="ln3580">        } while ( (ret &amp; 1) &amp;&amp; nNumMoved2AcidH &lt; num2remove );</a>
<a name="ln3581"> </a>
<a name="ln3582">        /* neutralize: remove ion pairs like &gt;N(+)=-O(-) =&gt; &gt;N-=O */</a>
<a name="ln3583">        if ( (nNumMoved2AcidH /*|| bCancelChargesAlways*/) &amp;&amp; cg_Minus &gt;= num_atoms &amp;&amp; cg_Plus &gt;= num_atoms &amp;&amp;</a>
<a name="ln3584">             pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] &gt; abs(pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE]) ) {</a>
<a name="ln3585">            do {</a>
<a name="ln3586">                nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3587">                ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3588">                                cg_Minus /*nVertDoubleBond*/, cg_Plus /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3589">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3590">                    return ret;</a>
<a name="ln3591">                }</a>
<a name="ln3592">                if ( ret &amp; 1 ) {</a>
<a name="ln3593">                    nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3594">                    nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3595">                    if ( nDelta ) {</a>
<a name="ln3596">                        /* radical pair has disappeared */</a>
<a name="ln3597">                        ; /* goto quick_exit;*/</a>
<a name="ln3598">                    }</a>
<a name="ln3599">                    if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] ) {</a>
<a name="ln3600">                        nNumNeutralized += (nPrevNumCharges - pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES])/2;</a>
<a name="ln3601">                    }</a>
<a name="ln3602">                }</a>
<a name="ln3603">            } while ( ret &amp; 1 );</a>
<a name="ln3604">        }</a>
<a name="ln3605">    }</a>
<a name="ln3606"> </a>
<a name="ln3607">    ret = 0;</a>
<a name="ln3608">    if ( tg_H_Acid &gt;= num_atoms ) {</a>
<a name="ln3609">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, tg_H_Acid, pBNS );</a>
<a name="ln3610">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3611">            ret = ret2;</a>
<a name="ln3612">    }</a>
<a name="ln3613">    if ( tg_H_Other &gt;= num_atoms ) {</a>
<a name="ln3614">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, tg_H_Other, pBNS );</a>
<a name="ln3615">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3616">            ret = ret2;</a>
<a name="ln3617">    }</a>
<a name="ln3618">    if ( cg_Minus &gt;= num_atoms ) {</a>
<a name="ln3619">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Minus, pBNS );</a>
<a name="ln3620">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3621">            ret = ret2;</a>
<a name="ln3622">    }</a>
<a name="ln3623">    if ( cg_Plus &gt;= num_atoms ) {</a>
<a name="ln3624">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Plus, pBNS );</a>
<a name="ln3625">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3626">            ret = ret2;</a>
<a name="ln3627">    }</a>
<a name="ln3628">    </a>
<a name="ln3629">    pBNS-&gt;type_CN   = 0;</a>
<a name="ln3630">    pBNS-&gt;type_T    = 0;</a>
<a name="ln3631">    pBNS-&gt;type_TACN = 0;</a>
<a name="ln3632">    </a>
<a name="ln3633">    if ( ret ) {</a>
<a name="ln3634">        return ret;</a>
<a name="ln3635">    }</a>
<a name="ln3636">    if ( pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CO_Minus] + pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZO_Minus] &amp;&amp;</a>
<a name="ln3637">         pAATG-&gt;nAtTypeTotals[ATTOT_NUM_N_Minus] ) {</a>
<a name="ln3638">    }</a>
<a name="ln3639">    </a>
<a name="ln3640">    nPosCharges2 = (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3641">    nNegCharges2 = (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3642">    /*</a>
<a name="ln3643">    nNumNP_H2    = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_H] +</a>
<a name="ln3644">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton];</a>
<a name="ln3645">    nNumOS_H2    = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_COH] +</a>
<a name="ln3646">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CSH] + </a>
<a name="ln3647">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZOH];</a>
<a name="ln3648">    */</a>
<a name="ln3649">    if ( (nPosCharges - nNegCharges) - (nPosCharges2 - nNegCharges2) != 0 ) {</a>
<a name="ln3650">        return BNS_PROGRAM_ERR;</a>
<a name="ln3651">    }</a>
<a name="ln3652"> </a>
<a name="ln3653">    if ( nNumCanceledCharges ) {</a>
<a name="ln3654">#if ( FIX_CANCEL_CHARGE_COUNT_BUG == 1 )</a>
<a name="ln3655">        *nNumCanceledCharges += 2*nNumNeutralized;</a>
<a name="ln3656">#else</a>
<a name="ln3657">        *nNumCanceledCharges = 2*nNumNeutralized;</a>
<a name="ln3658">#endif</a>
<a name="ln3659">    }</a>
<a name="ln3660">    </a>
<a name="ln3661">    return nNumMoved2AcidH;</a>
<a name="ln3662">}</a>
<a name="ln3663"> </a>
<a name="ln3664"> </a>
<a name="ln3665"> </a>
<a name="ln3666">/******************************************************************************************/</a>
<a name="ln3667">int HardAddAcidicProtons( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, int num2add, int *nNumCanceledCharges, BN_STRUCT *pBNS, BN_DATA *pBD )</a>
<a name="ln3668">{</a>
<a name="ln3669">    int cg_Plus        = 0;</a>
<a name="ln3670">    int cg_Minus_CO    = 0;</a>
<a name="ln3671">    int cg_Minus_Other = 0;</a>
<a name="ln3672">    int tg_H           = 0;</a>
<a name="ln3673"> </a>
<a name="ln3674">    int ret = 0, ret2;</a>
<a name="ln3675">    int nDelta, nNumChanges = 0, nNumMoved2AcidMinus = 0, nNumNeutralized = 0, nPrevNumCharges;</a>
<a name="ln3676"> </a>
<a name="ln3677">    int nPosCharges, nPosCharges2;</a>
<a name="ln3678">    int nNegCharges, nNegCharges2;</a>
<a name="ln3679">    /*</a>
<a name="ln3680">    int nNumNP_H, nNumNP_H2;</a>
<a name="ln3681">    int nNumOS_H, nNumOS_H2;</a>
<a name="ln3682">    */</a>
<a name="ln3683">    nPosCharges =  (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3684">    nNegCharges =  (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3685">    /*</a>
<a name="ln3686">    nNumNP_H    =  pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_H] +</a>
<a name="ln3687">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton];</a>
<a name="ln3688">    nNumOS_H    =  pAATG-&gt;nAtTypeTotals[ATTOT_NUM_COH] +</a>
<a name="ln3689">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CSH] + </a>
<a name="ln3690">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZOH];</a>
<a name="ln3691">    */</a>
<a name="ln3692">    /* prevent free exchange H &lt;-&gt; (-) */</a>
<a name="ln3693">    pBNS-&gt;type_CN   = (BNS_VERT_TYPE_C_GROUP | BNS_VERT_TYPE_C_NEGATIVE);</a>
<a name="ln3694">    pBNS-&gt;type_T    = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln3695">    pBNS-&gt;type_TACN = BNS_VERT_TYPE_ACID;</a>
<a name="ln3696">    /* create (+) charge group */</a>
<a name="ln3697">    cg_Plus = CreateCGroupInBnStruct( at, num_atoms, pBNS, AA_HARD_TYP_POS, AA_HARD_MSK_POS, 1 );</a>
<a name="ln3698">    /* create (-) charge group */</a>
<a name="ln3699">    /*</a>
<a name="ln3700">    if ( nAtTypeTotals[ATTOT_NUM_CO_Minus] + </a>
<a name="ln3701">         nAtTypeTotals[ATTOT_NUM_CS_Minus] + </a>
<a name="ln3702">         nAtTypeTotals[ATTOT_NUM_ZO_Minus] + </a>
<a name="ln3703">         nAtTypeTotals[ATTOT_NUM_N_Minus] )</a>
<a name="ln3704">    */</a>
<a name="ln3705">    cg_Minus_CO    = CreateCGroupInBnStruct( at, num_atoms, pBNS, AA_HARD_TYP_CO, AA_HARD_MSK_CO, -1 );</a>
<a name="ln3706"> </a>
<a name="ln3707">    cg_Minus_Other = CreateCGroupInBnStruct( at, num_atoms, pBNS, AA_HARD_TYP_NEG, AA_HARD_MSK_NEG, -1 );</a>
<a name="ln3708"> </a>
<a name="ln3709">    pBNS-&gt;type_CN   = (BNS_VERT_TYPE_C_GROUP | BNS_VERT_TYPE_C_NEGATIVE);</a>
<a name="ln3710">    pBNS-&gt;type_T    = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln3711">    pBNS-&gt;type_TACN = BNS_VERT_TYPE_ACID;</a>
<a name="ln3712">    </a>
<a name="ln3713">    /* create tautomeric group for all H  */</a>
<a name="ln3714">    tg_H = CreateTGroupInBnStruct( at, num_atoms, pBNS, AA_HARD_TYP_H, AA_HARD_MSK_H );</a>
<a name="ln3715"> </a>
<a name="ln3716">    </a>
<a name="ln3717">    if ( cg_Minus_Other &gt;= num_atoms &amp;&amp; cg_Minus_CO &gt;= num_atoms ) {</a>
<a name="ln3718">        /* find alt path to remove one proton */</a>
<a name="ln3719">        do {</a>
<a name="ln3720">            /* add a proton */</a>
<a name="ln3721">            nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3722">            ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3723">                            cg_Minus_Other /*nVertDoubleBond*/, cg_Minus_CO /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3724">            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3725">                return ret;</a>
<a name="ln3726">            }</a>
<a name="ln3727">            if ( ret &amp; 1 ) {</a>
<a name="ln3728">                nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3729">                nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3730">                if ( nDelta ) {</a>
<a name="ln3731">                    /* radical pair has disappeared */</a>
<a name="ln3732">                    ; /* goto quick_exit;*/</a>
<a name="ln3733">                }</a>
<a name="ln3734">                nNumMoved2AcidMinus ++;</a>
<a name="ln3735">                if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + 1 ) {</a>
<a name="ln3736">                    nNumNeutralized += (nPrevNumCharges - (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - 1))/2;</a>
<a name="ln3737">                }</a>
<a name="ln3738">            }</a>
<a name="ln3739"> </a>
<a name="ln3740">        } while ( (ret &amp; 1) &amp;&amp; nNumMoved2AcidMinus &lt; num2add );</a>
<a name="ln3741"> </a>
<a name="ln3742">        /* neutralize: remove ion pairs like &gt;N(+)=-O(-) =&gt; &gt;N-=O */</a>
<a name="ln3743">        if ( (nNumMoved2AcidMinus /*|| bCancelChargesAlways*/) &amp;&amp; cg_Minus_Other &gt;= num_atoms &amp;&amp; cg_Plus &gt;= num_atoms &amp;&amp;</a>
<a name="ln3744">             pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] &gt; abs(pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE]) ) {</a>
<a name="ln3745">            do {</a>
<a name="ln3746">                nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3747">                ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3748">                                cg_Minus_Other /*nVertDoubleBond*/, cg_Plus /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3749">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3750">                    return ret;</a>
<a name="ln3751">                }</a>
<a name="ln3752">                if ( ret &amp; 1 ) {</a>
<a name="ln3753">                    nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3754">                    nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3755">                    if ( nDelta ) {</a>
<a name="ln3756">                        /* radical pair has disappeared */</a>
<a name="ln3757">                        ; /* goto quick_exit;*/</a>
<a name="ln3758">                    }</a>
<a name="ln3759">                    if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] ) {</a>
<a name="ln3760">                        nNumNeutralized += (nPrevNumCharges - pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES])/2;</a>
<a name="ln3761">                    }</a>
<a name="ln3762">                }</a>
<a name="ln3763">            } while ( ret &amp; 1 );</a>
<a name="ln3764">        }</a>
<a name="ln3765">    }</a>
<a name="ln3766"> </a>
<a name="ln3767">    ret = 0;</a>
<a name="ln3768">    if ( tg_H &gt;= num_atoms ) {</a>
<a name="ln3769">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, tg_H, pBNS );</a>
<a name="ln3770">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3771">            ret = ret2;</a>
<a name="ln3772">    }</a>
<a name="ln3773">    if ( cg_Minus_Other &gt;= num_atoms ) {</a>
<a name="ln3774">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Minus_Other, pBNS );</a>
<a name="ln3775">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3776">            ret = ret2;</a>
<a name="ln3777">    }</a>
<a name="ln3778">    if ( cg_Minus_CO &gt;= num_atoms ) {</a>
<a name="ln3779">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Minus_CO, pBNS );</a>
<a name="ln3780">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3781">            ret = ret2;</a>
<a name="ln3782">    }</a>
<a name="ln3783">    if ( cg_Plus &gt;= num_atoms ) {</a>
<a name="ln3784">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Plus, pBNS );</a>
<a name="ln3785">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3786">            ret = ret2;</a>
<a name="ln3787">    }</a>
<a name="ln3788">    </a>
<a name="ln3789">    pBNS-&gt;type_CN   = 0;</a>
<a name="ln3790">    pBNS-&gt;type_T    = 0;</a>
<a name="ln3791">    pBNS-&gt;type_TACN = 0;</a>
<a name="ln3792"> </a>
<a name="ln3793">    if ( ret ) {</a>
<a name="ln3794">        return ret;</a>
<a name="ln3795">    }</a>
<a name="ln3796">    if ( pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CO_Minus] + pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZO_Minus] &amp;&amp;</a>
<a name="ln3797">         pAATG-&gt;nAtTypeTotals[ATTOT_NUM_N_Minus] ) {</a>
<a name="ln3798">    }</a>
<a name="ln3799">    </a>
<a name="ln3800">    nPosCharges2 = (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3801">    nNegCharges2 = (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3802">    /*</a>
<a name="ln3803">    nNumNP_H2    = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_H] +</a>
<a name="ln3804">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton];</a>
<a name="ln3805">    nNumOS_H2    = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_COH] +</a>
<a name="ln3806">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CSH] + </a>
<a name="ln3807">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZOH];</a>
<a name="ln3808">    */</a>
<a name="ln3809">    if ( (nPosCharges - nNegCharges) - (nPosCharges2 - nNegCharges2) != 0 ) {</a>
<a name="ln3810">        return BNS_PROGRAM_ERR;</a>
<a name="ln3811">    }</a>
<a name="ln3812"> </a>
<a name="ln3813">    if ( nNumCanceledCharges ) {</a>
<a name="ln3814">#if ( FIX_CANCEL_CHARGE_COUNT_BUG == 1 )</a>
<a name="ln3815">        *nNumCanceledCharges += 2*nNumNeutralized;</a>
<a name="ln3816">#else</a>
<a name="ln3817">        *nNumCanceledCharges = 2*nNumNeutralized;</a>
<a name="ln3818">#endif</a>
<a name="ln3819">    }</a>
<a name="ln3820">    </a>
<a name="ln3821">    return nNumMoved2AcidMinus;</a>
<a name="ln3822">}</a>
<a name="ln3823"> </a>
<a name="ln3824"> </a>
<a name="ln3825"> </a>
<a name="ln3826">/******************************************************************************************/</a>
<a name="ln3827">/* examples include removal of H from tautomeric O that belongs to the same t-group as N: */</a>
<a name="ln3828">/* &gt;N(+)=-N=-OH =(taut.)=&gt; &gt;N(+)=-NH-=O =(+charge move)=&gt; &gt;N-=NH(+)-=O =&gt; &gt;N-=N-=O + H(+) */</a>
<a name="ln3829">/******************************************************************************************/</a>
<a name="ln3830">int HardRemoveHplusNP( inp_ATOM *at, int num_atoms, int bCancelChargesAlways, int *nNumCanceledCharges,</a>
<a name="ln3831">                       BN_AATG *pAATG, BN_STRUCT *pBNS, BN_DATA *pBD  )</a>
<a name="ln3832">{</a>
<a name="ln3833"> </a>
<a name="ln3834">    int cg_Plus      = 0;</a>
<a name="ln3835">    int cg_Minus     = 0;</a>
<a name="ln3836">    int tg_H         = 0;</a>
<a name="ln3837">#if ( MOVE_PPLUS_TO_REMOVE_PROTONS == 1 )</a>
<a name="ln3838">    int cg_PlusP     = 0;</a>
<a name="ln3839">#endif</a>
<a name="ln3840">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3841">    int nPrevRemovedProtons, nCurrRemovedProtons;</a>
<a name="ln3842">#endif</a>
<a name="ln3843">    int ret = 0, ret2;</a>
<a name="ln3844">    int nDelta, nNumChanges = 0, nNumRemovedProtons = 0, nNumNeutralized = 0, nPrevNumCharges;</a>
<a name="ln3845"> </a>
<a name="ln3846">    int nPosCharges, nPosCharges2;</a>
<a name="ln3847">    int nNegCharges, nNegCharges2;</a>
<a name="ln3848">    /*</a>
<a name="ln3849">    int nNumNP_H, nNumNP_H2;</a>
<a name="ln3850">    int nNumOS_H, nNumOS_H2;</a>
<a name="ln3851">    */</a>
<a name="ln3852"> </a>
<a name="ln3853">    nPosCharges =  (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3854">    nNegCharges =  (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln3855">    /*</a>
<a name="ln3856">    nNumNP_H    =  pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_H] +</a>
<a name="ln3857">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton];</a>
<a name="ln3858">    nNumOS_H    =  pAATG-&gt;nAtTypeTotals[ATTOT_NUM_COH] +</a>
<a name="ln3859">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CSH] + </a>
<a name="ln3860">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZOH];</a>
<a name="ln3861">    */</a>
<a name="ln3862">    /* prevent free exchange H &lt;-&gt; (-) */</a>
<a name="ln3863">    pBNS-&gt;type_CN   = (BNS_VERT_TYPE_C_GROUP | BNS_VERT_TYPE_C_NEGATIVE);</a>
<a name="ln3864">    pBNS-&gt;type_T    = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln3865">    pBNS-&gt;type_TACN = BNS_VERT_TYPE_ACID;</a>
<a name="ln3866">    /* create (+) charge group */</a>
<a name="ln3867">    cg_Plus = CreateCGroupInBnStruct( at, num_atoms, pBNS, PR_HARD_TYP_POS, PR_HARD_MSK_POS, 1 );</a>
<a name="ln3868">    /* create (-) charge group */</a>
<a name="ln3869">    /*</a>
<a name="ln3870">    if ( nAtTypeTotals[ATTOT_NUM_CO_Minus] + </a>
<a name="ln3871">         nAtTypeTotals[ATTOT_NUM_CS_Minus] + </a>
<a name="ln3872">         nAtTypeTotals[ATTOT_NUM_ZO_Minus] + </a>
<a name="ln3873">         nAtTypeTotals[ATTOT_NUM_N_Minus] )</a>
<a name="ln3874">    */</a>
<a name="ln3875">#if ( MOVE_PPLUS_TO_REMOVE_PROTONS == 1 )</a>
<a name="ln3876">    cg_PlusP = CreateCGroupInBnStruct( at, num_atoms, pBNS, PR_HARD_TYP_POSP, PR_HARD_MSK_POS, 1 );</a>
<a name="ln3877">#endif</a>
<a name="ln3878">    cg_Minus = CreateCGroupInBnStruct( at, num_atoms, pBNS, PR_HARD_TYP_NEG, PR_HARD_MSK_NEG, -1 );</a>
<a name="ln3879">    </a>
<a name="ln3880">    /* create single tautomeric group */</a>
<a name="ln3881">    tg_H = CreateTGroupInBnStruct( at, num_atoms, pBNS, PR_HARD_TYP_H, PR_HARD_MSK_H );</a>
<a name="ln3882"> </a>
<a name="ln3883">    if ( tg_H &gt;= num_atoms &amp;&amp; cg_Plus &gt;= num_atoms ) {</a>
<a name="ln3884"> </a>
<a name="ln3885">#if ( FIX_N_MINUS_NORN_BUG == 1 )</a>
<a name="ln3886">        /* neutralize: remove ion pairs like &gt;N(+)=-O(-) =&gt; &gt;N-=O; &gt;N(+)=-NH(-) =&gt; &gt;N-=NH */</a>
<a name="ln3887">        if ( (nNumRemovedProtons || bCancelChargesAlways) &amp;&amp; cg_Minus &gt;= num_atoms &amp;&amp; cg_Plus &gt;= num_atoms &amp;&amp;</a>
<a name="ln3888">             pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] &gt; abs(pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE]) ) {</a>
<a name="ln3889">            do {</a>
<a name="ln3890">                nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3891">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3892">                nPrevRemovedProtons = pAATG-&gt;t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln3893">#endif</a>
<a name="ln3894">                ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3895">                                cg_Minus /*nVertDoubleBond*/, cg_Plus /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3896">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3897">                    return ret;</a>
<a name="ln3898">                }</a>
<a name="ln3899">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3900">                nCurrRemovedProtons = pAATG-&gt;t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln3901">                if ( nCurrRemovedProtons != nPrevRemovedProtons ) {</a>
<a name="ln3902">                    return BNS_RADICAL_ERR;</a>
<a name="ln3903">                }</a>
<a name="ln3904">#endif</a>
<a name="ln3905">                if ( ret &amp; 1 ) {</a>
<a name="ln3906">                    nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3907">                    nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3908">                    if ( nDelta ) {</a>
<a name="ln3909">                        /* radical pair has disappeared */</a>
<a name="ln3910">                        ; /* goto quick_exit;*/</a>
<a name="ln3911">                    }</a>
<a name="ln3912">                    if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] ) {</a>
<a name="ln3913">                        nNumNeutralized += (nPrevNumCharges - pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES])/2;</a>
<a name="ln3914">                    }</a>
<a name="ln3915">                }</a>
<a name="ln3916">            } while ( ret &amp; 1 );</a>
<a name="ln3917">        }</a>
<a name="ln3918">#endif</a>
<a name="ln3919">        /* find alt path to remove one proton */</a>
<a name="ln3920">        do {</a>
<a name="ln3921">            /* remove a proton */</a>
<a name="ln3922">            nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3923">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3924">            nPrevRemovedProtons = pAATG-&gt;t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln3925">#endif</a>
<a name="ln3926">            ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3927">                            tg_H /*nVertDoubleBond*/, cg_Plus /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3928">            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3929">                return ret;</a>
<a name="ln3930">            }</a>
<a name="ln3931">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3932">            nCurrRemovedProtons = pAATG-&gt;t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln3933">            if ( nCurrRemovedProtons != nPrevRemovedProtons + (ret &amp; 1) ) {</a>
<a name="ln3934">                return BNS_RADICAL_ERR;</a>
<a name="ln3935">            }</a>
<a name="ln3936">#endif</a>
<a name="ln3937">            if ( ret &amp; 1 ) {</a>
<a name="ln3938">                nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3939">                nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3940">                if ( nDelta ) {</a>
<a name="ln3941">                    /* radical pair has disappeared */</a>
<a name="ln3942">                    ; /* goto quick_exit;*/</a>
<a name="ln3943">                }</a>
<a name="ln3944">                nNumRemovedProtons ++;</a>
<a name="ln3945">                if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + 1 ) {</a>
<a name="ln3946">                    nNumNeutralized += (nPrevNumCharges - (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - 1))/2;</a>
<a name="ln3947">                }</a>
<a name="ln3948">            }</a>
<a name="ln3949"> </a>
<a name="ln3950">        } while ( ret &amp; 1 );</a>
<a name="ln3951"> </a>
<a name="ln3952">        /* neutralize: remove ion pairs like &gt;N(+)=-O(-) =&gt; &gt;N-=O */</a>
<a name="ln3953">        if ( (nNumRemovedProtons || bCancelChargesAlways) &amp;&amp; cg_Minus &gt;= num_atoms &amp;&amp; cg_Plus &gt;= num_atoms &amp;&amp;</a>
<a name="ln3954">             pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] &gt; abs(pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE]) ) {</a>
<a name="ln3955">            do {</a>
<a name="ln3956">                nPrevNumCharges = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln3957">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3958">                nPrevRemovedProtons = pAATG-&gt;t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln3959">#endif</a>
<a name="ln3960">                ret = bExistsAltPath( pBNS, pBD, pAATG, at, num_atoms,</a>
<a name="ln3961">                                cg_Minus /*nVertDoubleBond*/, cg_Plus /*nVertSingleBond*/, ALT_PATH_MODE_REM_PROTON );</a>
<a name="ln3962">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln3963">                    return ret;</a>
<a name="ln3964">                }</a>
<a name="ln3965">#if ( FIX_REM_PROTON_COUNT_BUG == 1 )</a>
<a name="ln3966">                nCurrRemovedProtons = pAATG-&gt;t_group_info-&gt;tni.nNumRemovedProtons;</a>
<a name="ln3967">                if ( nCurrRemovedProtons != nPrevRemovedProtons ) {</a>
<a name="ln3968">                    return BNS_RADICAL_ERR;</a>
<a name="ln3969">                }</a>
<a name="ln3970">#endif</a>
<a name="ln3971">                if ( ret &amp; 1 ) {</a>
<a name="ln3972">                    nDelta       = (ret &amp; ~3) &gt;&gt; 2;</a>
<a name="ln3973">                    nNumChanges += (0 != (ret &amp; 2));</a>
<a name="ln3974">                    if ( nDelta ) {</a>
<a name="ln3975">                        /* radical pair has disappeared */</a>
<a name="ln3976">                        ; /* goto quick_exit;*/</a>
<a name="ln3977">                    }</a>
<a name="ln3978">                    if ( nPrevNumCharges &gt; pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] ) {</a>
<a name="ln3979">                        nNumNeutralized += (nPrevNumCharges - pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES])/2;</a>
<a name="ln3980">                    }</a>
<a name="ln3981">                }</a>
<a name="ln3982">            } while ( ret &amp; 1 );</a>
<a name="ln3983">        }</a>
<a name="ln3984">    }</a>
<a name="ln3985">    ret = 0;</a>
<a name="ln3986">    if ( tg_H &gt;= num_atoms ) {</a>
<a name="ln3987">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, tg_H, pBNS );</a>
<a name="ln3988">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3989">            ret = ret2;</a>
<a name="ln3990">    }</a>
<a name="ln3991">    if ( cg_Minus &gt;= num_atoms ) {</a>
<a name="ln3992">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Minus, pBNS );</a>
<a name="ln3993">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln3994">            ret = ret2;</a>
<a name="ln3995">    }</a>
<a name="ln3996">#if ( MOVE_PPLUS_TO_REMOVE_PROTONS == 1 )</a>
<a name="ln3997">    if ( cg_PlusP &gt;= num_atoms ) {</a>
<a name="ln3998">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_PlusP, pBNS );</a>
<a name="ln3999">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln4000">            ret = ret2;</a>
<a name="ln4001">    }</a>
<a name="ln4002">#endif</a>
<a name="ln4003">    if ( cg_Plus &gt;= num_atoms ) {</a>
<a name="ln4004">        ret2 = RemoveLastGroupFromBnStruct( at, num_atoms, cg_Plus, pBNS );</a>
<a name="ln4005">        if ( !ret &amp;&amp; ret2 )</a>
<a name="ln4006">            ret = ret2;</a>
<a name="ln4007">    }</a>
<a name="ln4008"> </a>
<a name="ln4009">    pBNS-&gt;type_CN   = 0;</a>
<a name="ln4010">    pBNS-&gt;type_T    = 0;</a>
<a name="ln4011">    pBNS-&gt;type_TACN = 0;</a>
<a name="ln4012">    </a>
<a name="ln4013">    if ( ret ) {</a>
<a name="ln4014">        return ret;</a>
<a name="ln4015">    }</a>
<a name="ln4016">    if ( pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CO_Minus] + pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZO_Minus] &amp;&amp;</a>
<a name="ln4017">         pAATG-&gt;nAtTypeTotals[ATTOT_NUM_N_Minus] ) {</a>
<a name="ln4018">    }</a>
<a name="ln4019">    </a>
<a name="ln4020">    nPosCharges2 = (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] + pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln4021">    nNegCharges2 = (pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CHARGES] - pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE])/2;</a>
<a name="ln4022">    /*</a>
<a name="ln4023">    nNumNP_H2    = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_H] +</a>
<a name="ln4024">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton];</a>
<a name="ln4025">    nNumOS_H2    = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_COH] +</a>
<a name="ln4026">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_CSH] + </a>
<a name="ln4027">                   pAATG-&gt;nAtTypeTotals[ATTOT_NUM_ZOH];</a>
<a name="ln4028">    */</a>
<a name="ln4029">    if ( (nPosCharges - nNegCharges) - (nPosCharges2 - nNegCharges2) != nNumRemovedProtons ) {</a>
<a name="ln4030">        return BNS_PROGRAM_ERR;</a>
<a name="ln4031">    }</a>
<a name="ln4032"> </a>
<a name="ln4033">    if ( nNumCanceledCharges ) {</a>
<a name="ln4034">#if ( FIX_CANCEL_CHARGE_COUNT_BUG == 1 )</a>
<a name="ln4035">        *nNumCanceledCharges += 2*nNumNeutralized;</a>
<a name="ln4036">#else</a>
<a name="ln4037">        *nNumCanceledCharges = 2*nNumNeutralized;</a>
<a name="ln4038">#endif</a>
<a name="ln4039">    }</a>
<a name="ln4040">    </a>
<a name="ln4041">    return nNumRemovedProtons;</a>
<a name="ln4042">}</a>
<a name="ln4043"> </a>
<a name="ln4044"> </a>
<a name="ln4045"> </a>
<a name="ln4046">/***************************************************************************************/</a>
<a name="ln4047">int mark_at_type( inp_ATOM *atom, int num_atoms, int nAtTypeTotals[] )</a>
<a name="ln4048">{</a>
<a name="ln4049">    int i, max_num_ions, mask, type;</a>
<a name="ln4050">    /*int max_protons, max_O_Minus, num_H = 0, num_CO=0;*/</a>
<a name="ln4051">    if ( nAtTypeTotals ) {</a>
<a name="ln4052">        memset( nAtTypeTotals, 0, ATTOT_ARRAY_LEN * sizeof(nAtTypeTotals[0]) );</a>
<a name="ln4053">    }</a>
<a name="ln4054">    for ( i = 0; i &lt; num_atoms; i++ ) {</a>
<a name="ln4055">        type = GetAtomChargeType( atom, i, nAtTypeTotals, &amp;mask, 0 );</a>
<a name="ln4056">        atom[i].at_type = type;</a>
<a name="ln4057">        /*</a>
<a name="ln4058">        num_H  += ((type &amp; PR_HARD_TYP_H)  &amp;&amp; (mask &amp; ATBIT_MSK_H));</a>
<a name="ln4059">        num_CO += ((type &amp; AR_HARD_TYP_HA) &amp;&amp; (mask &amp; AR_HARD_MSK_HA));</a>
<a name="ln4060">        */</a>
<a name="ln4061">    }</a>
<a name="ln4062">    if ( nAtTypeTotals ) {</a>
<a name="ln4063">        /*</a>
<a name="ln4064">        max_protons = nAtTypeTotals[ATTOT_NUM_NP_Proton] + </a>
<a name="ln4065">                      inchi_min(num_H, nAtTypeTotals[ATTOT_NUM_NP_Plus]);</a>
<a name="ln4066">        max_O_Minus = nAtTypeTotals[ATTOT_NUM_CO_Minus] + nAtTypeTotals[ATTOT_NUM_CS_Minus] + </a>
<a name="ln4067">                      nAtTypeTotals[ATTOT_NUM_ZO_Minus] + nAtTypeTotals[ATTOT_NUM_OO_Minus] +</a>
<a name="ln4068">                      nAtTypeTotals[ATTOT_NUM_ZOO_Minus] + nAtTypeTotals[ATTOT_NUM_NO_Minus] +</a>
<a name="ln4069">                      nAtTypeTotals[ATTOT_NUM_O_Minus] +nAtTypeTotals[ATTOT_NUM_N_Minus];</a>
<a name="ln4070">                      ;</a>
<a name="ln4071">        max_num_ions = max_protons + max_O_Minus + nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln4072">        */</a>
<a name="ln4073">        max_num_ions = nAtTypeTotals[ATTOT_NUM_CHARGES];</a>
<a name="ln4074">    } else {</a>
<a name="ln4075">        max_num_ions = 0;</a>
<a name="ln4076">    }</a>
<a name="ln4077">    return max_num_ions;</a>
<a name="ln4078">}</a>
<a name="ln4079"> </a>
<a name="ln4080"> </a>
<a name="ln4081"> </a>
<a name="ln4082">/***************************************************************************************/</a>
<a name="ln4083">int RemoveNPProtonsAndAcidCharges( inp_ATOM *at, int num_atoms, BN_AATG *pAATG, BN_STRUCT *pBNS, BN_DATA *pBD )</a>
<a name="ln4084">{</a>
<a name="ln4085"> </a>
<a name="ln4086">    /* prepare data structure */</a>
<a name="ln4087">    int num;</a>
<a name="ln4088">    int nNumCanceledCharges          = 0;</a>
<a name="ln4089">    int nNumHardRemovedProtons       = 0;</a>
<a name="ln4090">    int nNumHardRemovedAcidicProtons = 0;</a>
<a name="ln4091">    T_GROUP_INFO *t_group_info = pAATG-&gt;t_group_info;</a>
<a name="ln4092">    int ret=0, bError = 0;</a>
<a name="ln4093">    int bAllowHardRemove = (t_group_info-&gt;bTautFlags &amp; TG_FLAG_TEST_TAUT__SALTS) &amp;&amp;</a>
<a name="ln4094">                           (t_group_info-&gt;bTautFlags &amp; TG_FLAG_TEST_TAUT2_SALTS) &amp;&amp;</a>
<a name="ln4095">                           (t_group_info-&gt;bTautFlags &amp; TG_FLAG_MOVE_POS_CHARGES ) &amp;&amp;</a>
<a name="ln4096">                           (t_group_info-&gt;bTautFlags &amp; TG_FLAG_HARD_ADD_REM_PROTONS);</a>
<a name="ln4097">    if ( pAATG-&gt;nMarkedAtom &amp;&amp; num_atoms &lt; pAATG-&gt;nAllocLen ) </a>
<a name="ln4098">    {</a>
<a name="ln4099">        inchi_free( pAATG-&gt;nMarkedAtom );</a>
<a name="ln4100">        qzfree( pAATG-&gt;nEndPoint );</a>
<a name="ln4101">        memset( pAATG, 0, sizeof(*pAATG) );</a>
<a name="ln4102">    }</a>
<a name="ln4103">    if ( !pAATG-&gt;nMarkedAtom &amp;&amp; (pAATG-&gt;nMarkedAtom = (S_CHAR *) inchi_malloc( num_atoms * sizeof(pAATG-&gt;nMarkedAtom[0]))) ) </a>
<a name="ln4104">    {</a>
<a name="ln4105">        pAATG-&gt;nAllocLen = num_atoms;</a>
<a name="ln4106">        pAATG-&gt;nNumFound = 0;</a>
<a name="ln4107">    }</a>
<a name="ln4108"> </a>
<a name="ln4109">    /* o TECHMAN-5.1. Remove protons from charged heteroatoms */</a>
<a name="ln4110"> </a>
<a name="ln4111">    /* (TECHMAN-5.1a) Simple remove of protons from N, P, and O,S,Se,Te */	</a>
<a name="ln4112">    if ( (num = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Proton] + pAATG-&gt;nAtTypeTotals[ATTOT_NUM_OH_Plus]) ) </a>
<a name="ln4113">    {</a>
<a name="ln4114">        ret = SimpleRemoveHplusNPO(at, num_atoms, pAATG-&gt;nAtTypeTotals, t_group_info);</a>
<a name="ln4115">        if ( ret != num ) </a>
<a name="ln4116">        {</a>
<a name="ln4117">            bError = BNS_PROGRAM_ERR;</a>
<a name="ln4118">            goto exit_function;</a>
<a name="ln4119">        }</a>
<a name="ln4120">        /*t_group_info-&gt;nNumRemovedProtons  += ret;*/</a>
<a name="ln4121">        t_group_info-&gt;tni.bNormalizationFlags |= (ret &gt; 0)? FLAG_PROTON_NPO_SIMPLE_REMOVED : 0;</a>
<a name="ln4122">    }</a>
<a name="ln4123"> </a>
<a name="ln4124">    if ( (num = pAATG-&gt;nAtTypeTotals[ATTOT_NUM_NP_Plus]) &amp;&amp; bAllowHardRemove ) </a>
<a name="ln4125">    {</a>
<a name="ln4126">        /* [TECHMAN-5.1b] Hard removing more protons from cationic N; charges may be canceled */</a>
<a name="ln4127">        ret = HardRemoveHplusNP(at, num_atoms, 1, &amp;nNumCanceledCharges, pAATG, pBNS, pBD);</a>
<a name="ln4128">        if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4129">        {</a>
<a name="ln4130">            bError = ret;</a>
<a name="ln4131">            goto exit_function;</a>
<a name="ln4132">        }</a>
<a name="ln4133">        nNumHardRemovedProtons            += ret;</a>
<a name="ln4134">        /*t_group_info-&gt;nNumRemovedProtons  += ret;*/</a>
<a name="ln4135">        t_group_info-&gt;tni.bNormalizationFlags |= (ret &gt; 0)? FLAG_PROTON_NP_HARD_REMOVED : 0;</a>
<a name="ln4136">    }</a>
<a name="ln4137"> </a>
<a name="ln4138"> </a>
<a name="ln4139">    if ( pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE] &gt; 0 ) </a>
<a name="ln4140">    {</a>
<a name="ln4141">        /* o TECHMAN-5.2. Remove protons from neutral heteroatoms */</a>
<a name="ln4142"> </a>
<a name="ln4143">        /* (TECHMAN-5.2a) Simple removal */</a>
<a name="ln4144">        ret = SimpleRemoveAcidicProtons( at, num_atoms, pAATG, pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE] );</a>
<a name="ln4145">        if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4146">        {</a>
<a name="ln4147">            bError = ret;</a>
<a name="ln4148">            goto exit_function;</a>
<a name="ln4149">        }</a>
<a name="ln4150">        /*t_group_info-&gt;nNumRemovedProtons  += ret;*/</a>
<a name="ln4151">        t_group_info-&gt;tni.bNormalizationFlags |= (ret &gt; 0)? FLAG_PROTON_AC_SIMPLE_REMOVED : 0;</a>
<a name="ln4152">        if ( pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE] &gt; 0 &amp;&amp; bAllowHardRemove ) </a>
<a name="ln4153">        {</a>
<a name="ln4154">            /* (TECHMAN-5.2b) Hard removal */</a>
<a name="ln4155">            ret = HardRemoveAcidicProtons( at, num_atoms, pAATG, pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE], &amp;nNumCanceledCharges, pBNS, pBD );</a>
<a name="ln4156">            if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4157">            {</a>
<a name="ln4158">                bError = ret;</a>
<a name="ln4159">                goto exit_function;</a>
<a name="ln4160">            }</a>
<a name="ln4161">            if ( ret &gt; 0 ) </a>
<a name="ln4162">            {</a>
<a name="ln4163">                int ret2 = SimpleRemoveAcidicProtons( at, num_atoms, pAATG, ret );</a>
<a name="ln4164">                if ( ret2 != ret ) </a>
<a name="ln4165">                {</a>
<a name="ln4166">                    bError = BNS_PROGRAM_ERR;</a>
<a name="ln4167">                    goto exit_function;</a>
<a name="ln4168">                }</a>
<a name="ln4169">                /*t_group_info-&gt;nNumRemovedProtons  += ret;*/</a>
<a name="ln4170">                t_group_info-&gt;tni.bNormalizationFlags |= (ret &gt; 0)? FLAG_PROTON_AC_HARD_REMOVED : 0;</a>
<a name="ln4171">                nNumHardRemovedAcidicProtons      += ret;</a>
<a name="ln4172">            }</a>
<a name="ln4173">        }</a>
<a name="ln4174">    } </a>
<a name="ln4175">    else</a>
<a name="ln4176">    if ( pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE] &lt; 0 ) </a>
<a name="ln4177">    {</a>
<a name="ln4178">        ret = SimpleAddAcidicProtons( at, num_atoms, pAATG, -pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE] );</a>
<a name="ln4179">        if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4180">        {</a>
<a name="ln4181">            bError = ret;</a>
<a name="ln4182">            goto exit_function;</a>
<a name="ln4183">        }</a>
<a name="ln4184">        /*t_group_info-&gt;nNumRemovedProtons  -= ret;*/</a>
<a name="ln4185">        /*</a>
<a name="ln4186">           CHECK_TACN == 1 prohibits replacing (-) on N with H unless H can be moved to N</a>
<a name="ln4187">           along an alternating path from another heteroatom (t-group will be detected).</a>
<a name="ln4188">        */</a>
<a name="ln4189">        t_group_info-&gt;tni.bNormalizationFlags |= (ret &gt; 0)? FLAG_PROTON_AC_SIMPLE_ADDED : 0;</a>
<a name="ln4190">        if ( pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE] &lt; 0 &amp;&amp; bAllowHardRemove ) {</a>
<a name="ln4191">            ret = HardAddAcidicProtons( at, num_atoms, pAATG, -pAATG-&gt;nAtTypeTotals[ATTOT_TOT_CHARGE], &amp;nNumCanceledCharges, pBNS, pBD );</a>
<a name="ln4192">            if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4193">            {</a>
<a name="ln4194">                bError = ret;</a>
<a name="ln4195">                goto exit_function;</a>
<a name="ln4196">            }</a>
<a name="ln4197">            if ( ret &gt; 0 ) </a>
<a name="ln4198">            {</a>
<a name="ln4199">                int ret2 = SimpleAddAcidicProtons( at, num_atoms, pAATG, ret );</a>
<a name="ln4200">                if ( ret2 != ret ) </a>
<a name="ln4201">                {</a>
<a name="ln4202">                    bError = BNS_PROGRAM_ERR;</a>
<a name="ln4203">                    goto exit_function;</a>
<a name="ln4204">                }</a>
<a name="ln4205">                /*t_group_info-&gt;nNumRemovedProtons  -= ret;*/</a>
<a name="ln4206">                t_group_info-&gt;tni.bNormalizationFlags |= (ret &gt; 0)? FLAG_PROTON_AC_HARD_ADDED : 0;</a>
<a name="ln4207">                nNumHardRemovedAcidicProtons      -= ret;</a>
<a name="ln4208">            }</a>
<a name="ln4209">        }</a>
<a name="ln4210">    }</a>
<a name="ln4211">    t_group_info-&gt;tni.bNormalizationFlags |= nNumCanceledCharges? FLAG_PROTON_CHARGE_CANCEL : 0;</a>
<a name="ln4212"> </a>
<a name="ln4213">exit_function:</a>
<a name="ln4214">    if ( bError ) </a>
<a name="ln4215">    {</a>
<a name="ln4216">        ret = IS_BNS_ERROR(bError)? bError : BNS_PROGRAM_ERR;</a>
<a name="ln4217">    }</a>
<a name="ln4218">    return ret;</a>
<a name="ln4219">}</a>
<a name="ln4220"> </a>
<a name="ln4221"> </a>
<a name="ln4222"> </a>
<a name="ln4223">/********************************/</a>
<a name="ln4224">/*                              */</a>
<a name="ln4225">/* Main normalization procedure */</a>
<a name="ln4226">/*                              */</a>
<a name="ln4227">/********************************/</a>
<a name="ln4228">int mark_alt_bonds_and_taut_groups ( inp_ATOM *at, inp_ATOM *at_fixed_bonds_out, int num_atoms,</a>
<a name="ln4229">                                     T_GROUP_INFO *t_group_info, INCHI_MODE *inpbTautFlags, INCHI_MODE *inpbTautFlagsDone )</a>
<a name="ln4230"> </a>
<a name="ln4231"> </a>
<a name="ln4232">{</a>
<a name="ln4233">    BN_STRUCT *pBNS = NULL;</a>
<a name="ln4234">    BN_DATA   *pBD  = NULL;</a>
<a name="ln4235">    int bError, nChanges, nTotChanges, taut_found, salt_found, taut_pass, salt_pass, salt_step, ret, ret2, num;</a>
<a name="ln4236">    int  nOrigDelta, num_changed_bonds;</a>
<a name="ln4237">    int max_altp = BN_MAX_ALTP;</a>
<a name="ln4238">    int bChangeFlow = (BNS_EF_CHNG_RSTR | BNS_EF_ALTR_BONDS);</a>
<a name="ln4239">    BNS_FLOW_CHANGES fcd[BNS_MAX_NUM_FLOW_CHANGES+1];</a>
<a name="ln4240">    C_GROUP_INFO CGroupInfo;</a>
<a name="ln4241">    C_GROUP_INFO *c_group_info = &amp;CGroupInfo;</a>
<a name="ln4242">    S_GROUP_INFO SGroupInfo;</a>
<a name="ln4243">    S_GROUP_INFO *s_group_info = &amp;SGroupInfo;</a>
<a name="ln4244">    INCHI_MODE    *pbTautFlags     = t_group_info? &amp;t_group_info-&gt;bTautFlags     : inpbTautFlags;</a>
<a name="ln4245">    INCHI_MODE    *pbTautFlagsDone = t_group_info? &amp;t_group_info-&gt;bTautFlagsDone : inpbTautFlagsDone;</a>
<a name="ln4246"> </a>
<a name="ln4247">    int nAtTypeTotals[ATTOT_ARRAY_LEN];</a>
<a name="ln4248">    int nNumOrigTotAtoms;</a>
<a name="ln4249"> </a>
<a name="ln4250">    BN_AATG  aatg;</a>
<a name="ln4251">    BN_AATG *pAATG = &amp;aatg;</a>
<a name="ln4252"> </a>
<a name="ln4253">#ifdef FIX_AROM_RADICAL		/* Added 2011-05-09 IPl */</a>
<a name="ln4254">    int i, n_arom_radicals=0, *stored_radicals=NULL;</a>
<a name="ln4255">#endif</a>
<a name="ln4256">    </a>
<a name="ln4257">    nChanges = 0;</a>
<a name="ln4258">    bError   = 0;</a>
<a name="ln4259"> </a>
<a name="ln4260">    memset( c_group_info, 0, sizeof(*c_group_info) );</a>
<a name="ln4261">    memset( s_group_info, 0, sizeof(*s_group_info) );</a>
<a name="ln4262">    memset( pAATG,        0, sizeof(*pAATG) );</a>
<a name="ln4263"> </a>
<a name="ln4264"> </a>
<a name="ln4265">#ifdef FIX_AROM_RADICAL		/* Added 2011-05-09 IPl */</a>
<a name="ln4266">    for ( i = 0; i &lt; num_atoms; i ++ ) </a>
<a name="ln4267">    {</a>
<a name="ln4268">        if ( (at[i].radical==RADICAL_DOUBLET) &amp;&amp; (at[i].valence==2) &amp;&amp; </a>
<a name="ln4269">             (at[i].bond_type[0]==BOND_ALTERN) &amp;&amp; (at[i].bond_type[1]==BOND_ALTERN) )</a>
<a name="ln4270">        {</a>
<a name="ln4271">            n_arom_radicals++;</a>
<a name="ln4272">            if ( !stored_radicals )</a>
<a name="ln4273">            {</a>
<a name="ln4274">                stored_radicals = (int *) inchi_calloc(num_atoms, sizeof(int));</a>
<a name="ln4275">									/* 2011-08-05 explicit cast added due to Evan Bolton */</a>
<a name="ln4276">                if ( !stored_radicals )</a>
<a name="ln4277">                {</a>
<a name="ln4278">                    bError = BNS_OUT_OF_RAM;</a>
<a name="ln4279">                    goto exit_function;</a>
<a name="ln4280">                }</a>
<a name="ln4281">                stored_radicals[i] = RADICAL_DOUBLET;</a>
<a name="ln4282">                at[i].radical = 0;</a>
<a name="ln4283">                at[i].num_H++;</a>
<a name="ln4284">            }</a>
<a name="ln4285">        }</a>
<a name="ln4286">    }</a>
<a name="ln4287"> </a>
<a name="ln4288">#endif</a>
<a name="ln4289"> </a>
<a name="ln4290"> </a>
<a name="ln4291">    if ( (*pbTautFlags &amp; TG_FLAG_MOVE_POS_CHARGES) &amp;&amp; num_atoms &gt; 1 ) {</a>
<a name="ln4292">        /* charge groups memory allocation */</a>
<a name="ln4293">        c_group_info-&gt;c_group     = (C_GROUP *)inchi_calloc(num_atoms/2, sizeof(c_group_info-&gt;c_group[0]));</a>
<a name="ln4294">        c_group_info-&gt;c_candidate = (C_CANDIDATE*)inchi_calloc(num_atoms, sizeof(c_group_info-&gt;c_candidate[0]));</a>
<a name="ln4295">        if (c_group_info-&gt;c_group &amp;&amp; c_group_info-&gt;c_candidate) {</a>
<a name="ln4296">            c_group_info-&gt;max_num_c_groups   = num_atoms/2;</a>
<a name="ln4297">            c_group_info-&gt;max_num_candidates = num_atoms;</a>
<a name="ln4298">        } else {</a>
<a name="ln4299">            bError = BNS_OUT_OF_RAM; /* error: out of RAM */</a>
<a name="ln4300">            /*printf(&quot;BNS_OUT_OF_RAM-1: num_at=%d, c_gr=%lx c_can=%lx\n&quot;, num_atoms, c_group_info-&gt;c_group, c_group_info-&gt;c_candidate);*/</a>
<a name="ln4301">            goto exit_function;</a>
<a name="ln4302">        }</a>
<a name="ln4303">    }</a>
<a name="ln4304"> </a>
<a name="ln4305">    if ( *pbTautFlags &amp; TG_FLAG_TEST_TAUT__SALTS ) {</a>
<a name="ln4306">        if ( t_group_info ) {</a>
<a name="ln4307">            /* salt groups memory allocation */</a>
<a name="ln4308">            s_group_info-&gt;s_candidate = (S_CANDIDATE*)inchi_calloc(num_atoms, sizeof(s_group_info-&gt;s_candidate[0]));</a>
<a name="ln4309">            if (s_group_info-&gt;s_candidate) {</a>
<a name="ln4310">                s_group_info-&gt;max_num_candidates = num_atoms;</a>
<a name="ln4311">            } else {</a>
<a name="ln4312">                bError = BNS_OUT_OF_RAM; /* error: out of RAM */</a>
<a name="ln4313">                /*printf(&quot;BNS_OUT_OF_RAM-2\n&quot;);*/</a>
<a name="ln4314">                goto exit_function;</a>
<a name="ln4315">            }</a>
<a name="ln4316">        }</a>
<a name="ln4317">    }</a>
<a name="ln4318">    if ( t_group_info ) {</a>
<a name="ln4319">        if ( t_group_info-&gt;tGroupNumber )</a>
<a name="ln4320">            inchi_free( t_group_info-&gt;tGroupNumber );</a>
<a name="ln4321">        t_group_info-&gt;tGroupNumber = (AT_NUMB *)inchi_calloc( 2*num_atoms+1, sizeof(t_group_info-&gt;tGroupNumber[0]) );</a>
<a name="ln4322">        if ( !t_group_info-&gt;tGroupNumber )  {</a>
<a name="ln4323">            /*printf(&quot;BNS_OUT_OF_RAM-9\n&quot;);*/</a>
<a name="ln4324">            bError = BNS_OUT_OF_RAM; /* error: out of RAM */</a>
<a name="ln4325">            goto exit_function;</a>
<a name="ln4326">        }</a>
<a name="ln4327">        num = t_group_info-&gt;tni.nNumRemovedExplicitH;</a>
<a name="ln4328">        memset ( &amp;t_group_info-&gt;tni, 0, sizeof(t_group_info-&gt;tni) );</a>
<a name="ln4329">        t_group_info-&gt;tni.nNumRemovedExplicitH = num;	</a>
<a name="ln4330">    }    </a>
<a name="ln4331"> </a>
<a name="ln4332"> </a>
<a name="ln4333"> </a>
<a name="ln4334">/*</a>
<a name="ln4335">again:</a>
<a name="ln4336">*/</a>
<a name="ln4337">    /* allocate Balanced Network Data Strucures; replace Alternating bonds with Single */</a>
<a name="ln4338">    if ( (pBNS = AllocateAndInitBnStruct( at, num_atoms, BNS_ADD_ATOMS, BNS_ADD_EDGES, max_altp, &amp;num_changed_bonds )) &amp;&amp;</a>
<a name="ln4339">         (pBD  = AllocateAndInitBnData( pBNS-&gt;max_vertices )) ) </a>
<a name="ln4340">    {</a>
<a name="ln4341"> </a>
<a name="ln4342"> </a>
<a name="ln4343">        pBNS-&gt;pbTautFlags     = pbTautFlags;     /* carry through all functions */</a>
<a name="ln4344">        pBNS-&gt;pbTautFlagsDone = pbTautFlagsDone;  /* carry through all functions */</a>
<a name="ln4345"> </a>
<a name="ln4346">#if ( BNS_PROTECT_FROM_TAUT == 1 )</a>
<a name="ln4347">        /* protect bonds to acetyl and nitro */</a>
<a name="ln4348">        SetForbiddenEdges( pBNS, at, num_atoms, BNS_EDGE_FORBIDDEN_MASK );</a>
<a name="ln4349">#endif</a>
<a name="ln4350"> </a>
<a name="ln4351"> </a>
<a name="ln4352">        /* set bonds in case of input &quot;aromatic&quot; bonds or multiple radicals */</a>
<a name="ln4353"> </a>
<a name="ln4354">#ifdef FIX_AROM_RADICAL		/* Added 2011-05-09 IPl */</a>
<a name="ln4355">        if ( n_arom_radicals )</a>
<a name="ln4356">        {</a>
<a name="ln4357">            ret = BnsAdjustFlowBondsRad( pBNS, pBD, at, num_atoms );</a>
<a name="ln4358">            if ( stored_radicals )</a>
<a name="ln4359">            {</a>
<a name="ln4360">                for ( i = 0; i &lt; num_atoms; i ++ ) </a>
<a name="ln4361">                {</a>
<a name="ln4362">                    if ( stored_radicals[i] )</a>
<a name="ln4363">                    {</a>
<a name="ln4364">                        at[i].radical = stored_radicals[i];</a>
<a name="ln4365">                        at[i].num_H--;</a>
<a name="ln4366">                    }</a>
<a name="ln4367">                }</a>
<a name="ln4368">            }</a>
<a name="ln4369">            if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4370">            {</a>
<a name="ln4371">                bError = ret;</a>
<a name="ln4372">                goto exit_function;</a>
<a name="ln4373">            }</a>
<a name="ln4374">        }</a>
<a name="ln4375">#endif</a>
<a name="ln4376">        ret = BnsAdjustFlowBondsRad( pBNS, pBD, at, num_atoms );</a>
<a name="ln4377"> </a>
<a name="ln4378"> </a>
<a name="ln4379">        /* (here pair(s) of radicals could have disappeared from the atoms) */</a>
<a name="ln4380">        if ( IS_BNS_ERROR( ret ) ) </a>
<a name="ln4381">        {</a>
<a name="ln4382">            bError = ret;</a>
<a name="ln4383">            goto exit_function;</a>
<a name="ln4384">        }</a>
<a name="ln4385">        pBNS-&gt;tot_st_flow += 2*ret;</a>
<a name="ln4386">        </a>
<a name="ln4387">        </a>
<a name="ln4388">        </a>
<a name="ln4389">        /*return 0;*/ /* debug */</a>
<a name="ln4390">        nOrigDelta = ret;</a>
<a name="ln4391">        if ( pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow ) {</a>
<a name="ln4392">            /* has radical */</a>
<a name="ln4393">            bChangeFlow |= BNS_EF_SET_NOSTEREO;</a>
<a name="ln4394">        }</a>
<a name="ln4395">        /******************************************************************** </a>
<a name="ln4396">         *  Remove protons from NH(+), but not PH(+)</a>
<a name="ln4397">         *  Add protons to COO(-) etc.</a>
<a name="ln4398">         *  or remove protons from COOH etc to make the organic part neutral</a>
<a name="ln4399">         *  Note: for now (-) from N(-) can be only canceled or moved to -C=O</a>
<a name="ln4400">         ********************************************************************/</a>
<a name="ln4401">        if ( ( *pbTautFlags &amp; TG_FLAG_VARIABLE_PROTONS ) &amp;&amp; t_group_info &amp;&amp; </a>
<a name="ln4402">             mark_at_type( at, num_atoms, nAtTypeTotals ) &amp;&amp;</a>
<a name="ln4403">             nAtTypeTotals[ATTOT_NUM_CHARGES] ) {</a>
<a name="ln4404">            /*</a>
<a name="ln4405">               the structure is simple to neutralize if it yields exactly </a>
<a name="ln4406">                 num[H(+)]     = num[N,P H(+)]</a>
<a name="ln4407">                 num[N,S,O(-)] = num[=C-O(-)] + num[C-S(-)] + num[N(-)] + num[other O(-), S(-)]</a>
<a name="ln4408"> </a>
<a name="ln4409">                 and n(p) = num[H(+)] - num[N,S,O(-)] (no protons, no negative N,O,S condition)</a>
<a name="ln4410"> </a>
<a name="ln4411">               Additional check is needed if:</a>
<a name="ln4412">                 min{num[N,PH], num[N,P(+), not onium]} &gt; 0 </a>
<a name="ln4413">                     =&gt; possibility to yield more H(+)</a>
<a name="ln4414"> </a>
<a name="ln4415">               min_charge = orig_charge(P,N,O,S) - n(p) - n(OH,SH)</a>
<a name="ln4416">               max_charge = orig_charge(P,N,O,S) - n(p) + n(O,S,N(-)) </a>
<a name="ln4417">            */</a>
<a name="ln4418"> </a>
<a name="ln4419"> </a>
<a name="ln4420">            nNumOrigTotAtoms = t_group_info-&gt;tni.nNumRemovedExplicitH + num_atoms;</a>
<a name="ln4421">            pAATG-&gt;nAtTypeTotals = nAtTypeTotals;</a>
<a name="ln4422">            pAATG-&gt;t_group_info  = t_group_info;</a>
<a name="ln4423">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4424">            pBNS-&gt;edge_forbidden_mask |= BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4425">#endif</a>
<a name="ln4426">            /***********************************************************/</a>
<a name="ln4427">            /*                                                         */</a>
<a name="ln4428">            /*          ( D E ) P R O T O N A T I O N                  */</a>
<a name="ln4429">            /*                                                         */</a>
<a name="ln4430">            /***********************************************************/</a>
<a name="ln4431">            ret = RemoveNPProtonsAndAcidCharges( at, num_atoms, pAATG, pBNS, pBD );</a>
<a name="ln4432">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4433">            pBNS-&gt;edge_forbidden_mask &amp;= ~BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4434">#endif</a>
<a name="ln4435">            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4436">                bError = ret;</a>
<a name="ln4437">                goto exit_function;</a>
<a name="ln4438">            }</a>
<a name="ln4439">            if ( t_group_info-&gt;tni.bNormalizationFlags ) {</a>
<a name="ln4440">                SetInitCapFlowToCurrent( pBNS );</a>
<a name="ln4441">                if ( at_fixed_bonds_out ) {</a>
<a name="ln4442">                    /* copy modified initial tautomeric structure for displaying</a>
<a name="ln4443">                       Warning: implicit H counts in at_fixed_bonds_out include explicit Hs */</a>
<a name="ln4444">                    memcpy( at_fixed_bonds_out, at, nNumOrigTotAtoms*sizeof(at_fixed_bonds_out[0]) );</a>
<a name="ln4445">                    /* -- will be done in FillOutInputInfAtom() --</a>
<a name="ln4446">                    RemoveExcessiveImplicitH( num_atoms, t_group_info-&gt;tni.nNumRemovedExplicitH, at_fixed_bonds_out );</a>
<a name="ln4447">                    */</a>
<a name="ln4448">                }</a>
<a name="ln4449">            }</a>
<a name="ln4450">        }</a>
<a name="ln4451">        /****************** initial bonds normalization ***************/</a>
<a name="ln4452">        if ( *pbTautFlags &amp; TG_FLAG_MOVE_POS_CHARGES ) {</a>
<a name="ln4453">            /******************* find moveable positive charges **********************/</a>
<a name="ln4454">            do {  /* cycling while ret&gt;0 added 2004-06-04 */</a>
<a name="ln4455">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4456">                    pBNS-&gt;edge_forbidden_mask |= BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4457">                    CorrectFixing_NH_NH_Bonds( pBNS, at, num_atoms );</a>
<a name="ln4458">#endif</a>
<a name="ln4459">                    ret = MarkChargeGroups ( at, num_atoms, c_group_info, t_group_info, pBNS, pBD );</a>
<a name="ln4460">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4461">                    pBNS-&gt;edge_forbidden_mask &amp;= ~BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4462">#endif</a>
<a name="ln4463">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4464">                    bError = ret;</a>
<a name="ln4465">                    goto exit_function;</a>
<a name="ln4466">                }</a>
<a name="ln4467">                if ( ret ) {</a>
<a name="ln4468">                    nChanges += ret;</a>
<a name="ln4469">                    ret2 = AddCGroups2BnStruct( pBNS, at, num_atoms, c_group_info );</a>
<a name="ln4470">                    if ( IS_BNS_ERROR( ret2 ) ) {</a>
<a name="ln4471">                        bError = ret2;</a>
<a name="ln4472">                        goto exit_function;</a>
<a name="ln4473">                    }</a>
<a name="ln4474">                    *pbTautFlagsDone |= TG_FLAG_MOVE_POS_CHARGES_DONE;</a>
<a name="ln4475">                }</a>
<a name="ln4476">            } while ( ret &gt; 0 );</a>
<a name="ln4477">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln4478">#else</a>
<a name="ln4479">            /* moveable charges may allow to cancel radicals -- check it */</a>
<a name="ln4480">            if ( pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow ) {</a>
<a name="ln4481">                ret = BnsAdjustFlowBondsRad( pBNS, pBD, at, num_atoms );</a>
<a name="ln4482">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4483">                    bError = ret;</a>
<a name="ln4484">                    goto exit_function;</a>
<a name="ln4485">                }</a>
<a name="ln4486">                if ( ret &gt; 0 ) {</a>
<a name="ln4487">                    /*</a>
<a name="ln4488">                    pBNS-&gt;tot_st_flow += 2*ret;</a>
<a name="ln4489">                    ret = ReInitBnStruct( pBNS, at, num_atoms, 1 );</a>
<a name="ln4490">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4491">                        bError = ret;</a>
<a name="ln4492">                        goto exit_function;</a>
<a name="ln4493">                    }</a>
<a name="ln4494">                    */</a>
<a name="ln4495">                    bError = BNS_RADICAL_ERR;</a>
<a name="ln4496">                    goto exit_function;</a>
<a name="ln4497">                }</a>
<a name="ln4498">            }</a>
<a name="ln4499">#endif</a>
<a name="ln4500">        }</a>
<a name="ln4501">        /************************************************************************/</a>
<a name="ln4502">        /********          test bonds for bond tautomerism         **************/</a>
<a name="ln4503">        /******** replace moveable bonds with &quot;alternating&quot; bonds  **************/</a>
<a name="ln4504">        /************************************************************************/</a>
<a name="ln4505">        ret  = BnsTestAndMarkAltBonds( pBNS, pBD, at, num_atoms, fcd, bChangeFlow, 0 );</a>
<a name="ln4506">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4507">            bError = ret;</a>
<a name="ln4508">            goto exit_function;</a>
<a name="ln4509">        }</a>
<a name="ln4510">        nChanges += ret;</a>
<a name="ln4511">        /*********************** end of initial bonds normalization *************/</a>
<a name="ln4512">        nTotChanges = 0;</a>
<a name="ln4513">        /* check for tautomerism */</a>
<a name="ln4514">        /* find new tautomer groups */</a>
<a name="ln4515">        salt_pass  = 0;</a>
<a name="ln4516">        salt_step  = 0;</a>
<a name="ln4517">        salt_found = 0;</a>
<a name="ln4518"> </a>
<a name="ln4519">        /*************************************************************/</a>
<a name="ln4520">        /*                                                           */</a>
<a name="ln4521">        /*           M A I N   C Y C L E   B E G I N                 */</a>
<a name="ln4522">        /*                                                           */</a>
<a name="ln4523">        /*************************************************************/</a>
<a name="ln4524"> </a>
<a name="ln4525">        do {</a>
<a name="ln4526">            nTotChanges += nChanges;</a>
<a name="ln4527">            nChanges     = 0;</a>
<a name="ln4528">            taut_pass    = 0;</a>
<a name="ln4529"> </a>
<a name="ln4530">            /**************** regular bond/H/(-)/positive charges tautomerism cycle begin **************/</a>
<a name="ln4531">            do {</a>
<a name="ln4532">                taut_pass ++;</a>
<a name="ln4533">                for ( taut_found = 0; 0 &lt; (ret=MarkTautomerGroups( at, num_atoms, t_group_info, c_group_info, pBNS, pBD )); taut_found ++ )</a>
<a name="ln4534">                    ;</a>
<a name="ln4535">                if ( ret &lt; 0 ) {</a>
<a name="ln4536">                    bError = ret;</a>
<a name="ln4537">                }</a>
<a name="ln4538">                if ( taut_found &amp;&amp; !salt_pass ) {</a>
<a name="ln4539">                    *pbTautFlagsDone |= TG_FLAG_TEST_TAUT__ATOMS_DONE;</a>
<a name="ln4540">                }</a>
<a name="ln4541">                if ( taut_found || salt_found ) {</a>
<a name="ln4542">                    /****************** repeat bonds normalization ***************/</a>
<a name="ln4543">                    ret = ReInitBnStructAddGroups( pBNS, at, num_atoms, t_group_info, c_group_info );</a>
<a name="ln4544">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4545">                        bError = ret;</a>
<a name="ln4546">                        goto exit_function;</a>
<a name="ln4547">                    }</a>
<a name="ln4548">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln4549">#else</a>
<a name="ln4550">                    /* discovered moveable charges and H-atoms may allow to cancel radicals */</a>
<a name="ln4551">                    if ( pBNS-&gt;tot_st_cap &gt; pBNS-&gt;tot_st_flow ) {</a>
<a name="ln4552">                        ret = BnsAdjustFlowBondsRad( pBNS, pBD, at, num_atoms );</a>
<a name="ln4553">                        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4554">                            bError = ret;</a>
<a name="ln4555">                            goto exit_function;</a>
<a name="ln4556">                        }</a>
<a name="ln4557">                        if ( ret &gt; 0 ) {</a>
<a name="ln4558">                            /*</a>
<a name="ln4559">                            pBNS-&gt;tot_st_flow += 2*ret;</a>
<a name="ln4560">                            ret = ReInitBnStruct( pBNS, at, num_atoms, 1 );</a>
<a name="ln4561">                            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4562">                                bError = ret;</a>
<a name="ln4563">                                goto exit_function;</a>
<a name="ln4564">                            }</a>
<a name="ln4565">                            */</a>
<a name="ln4566">                            bError = BNS_RADICAL_ERR;</a>
<a name="ln4567">                            goto exit_function;</a>
<a name="ln4568">                        }</a>
<a name="ln4569">                    }</a>
<a name="ln4570">#endif</a>
<a name="ln4571">                    /****************** update bonds normalization ***************/</a>
<a name="ln4572">                    if ( *pbTautFlags &amp; TG_FLAG_MOVE_POS_CHARGES ) {</a>
<a name="ln4573">                        /******************* find moveable charges ***************/</a>
<a name="ln4574">                        do {  /* cycling while ret&gt;0 added 2004-06-04 */</a>
<a name="ln4575">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4576">                            pBNS-&gt;edge_forbidden_mask |= BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4577">                            CorrectFixing_NH_NH_Bonds( pBNS, at, num_atoms );</a>
<a name="ln4578">#endif</a>
<a name="ln4579">                            ret = MarkChargeGroups ( at, num_atoms, c_group_info, t_group_info, pBNS, pBD );</a>
<a name="ln4580">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4581">                            pBNS-&gt;edge_forbidden_mask &amp;= ~BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4582">#endif</a>
<a name="ln4583">                            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4584">                                bError = ret;</a>
<a name="ln4585">                                goto exit_function;</a>
<a name="ln4586">                            }</a>
<a name="ln4587">                            nChanges+= ret;</a>
<a name="ln4588">                            if ( ret &gt; 0 ) {</a>
<a name="ln4589">                                ret2 = ReInitBnStructAddGroups( pBNS, at, num_atoms, t_group_info, c_group_info );</a>
<a name="ln4590">                                if ( IS_BNS_ERROR( ret2 ) ) {</a>
<a name="ln4591">                                    bError = ret2;</a>
<a name="ln4592">                                    goto exit_function;</a>
<a name="ln4593">                                }</a>
<a name="ln4594">                                *pbTautFlagsDone |= TG_FLAG_MOVE_POS_CHARGES_DONE;</a>
<a name="ln4595">                            }</a>
<a name="ln4596">                        } while ( ret &gt; 0 );</a>
<a name="ln4597">                    }</a>
<a name="ln4598"> </a>
<a name="ln4599">                    /************************************************************************/</a>
<a name="ln4600">                    /********             find moveable bonds:                 **************/</a>
<a name="ln4601">                    /********          test bonds for bond tautomerism         **************/</a>
<a name="ln4602">                    /******** replace moveable bonds with &quot;alternating&quot; bonds  **************/</a>
<a name="ln4603">                    /************************************************************************/</a>
<a name="ln4604">                    ret   = BnsTestAndMarkAltBonds( pBNS, pBD, at, num_atoms, fcd, bChangeFlow, 0 );</a>
<a name="ln4605">                    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln4606">                        bError = ret;</a>
<a name="ln4607">                        goto exit_function;</a>
<a name="ln4608">                    }</a>
<a name="ln4609">                    nChanges+= ret;</a>
<a name="ln4610">                    /****************** end of update bonds normalization ***************/</a>
<a name="ln4611">                }</a>
<a name="ln4612">                salt_found = 0;</a>
<a name="ln4613"> </a>
<a name="ln4614">            } while( taut_found &amp;&amp; !bError );</a>
<a name="ln4615">            /**************** regular bond/H/(-)/positive charges tautomerism cycle end **************/</a>
<a name="ln4616">            </a>
<a name="ln4617">            if ( bError ) {</a>
<a name="ln4618">                break;</a>
<a name="ln4619">            }</a>
<a name="ln4620"> </a>
<a name="ln4621">            /******************* 'salt' tautomerism permitted *************************/</a>
<a name="ln4622">            if ( *pbTautFlags &amp; TG_FLAG_TEST_TAUT__SALTS ) {</a>
<a name="ln4623"> </a>
<a name="ln4624">                if ( *pbTautFlags &amp; TG_FLAG_TEST_TAUT2_SALTS ) {</a>
<a name="ln4625">                    /*********** requested one or more &quot;salt&quot; attachement migrartion test ********/</a>
<a name="ln4626">                    if ( !nChanges &amp;&amp; salt_pass &amp;&amp; salt_step ) {</a>
<a name="ln4627">                        break;  /* done */</a>
<a name="ln4628">                    }</a>
<a name="ln4629">                    if ( !salt_step ) { /* salt step 0: process one attachment migrartion */</a>
<a name="ln4630">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4631">                        pBNS-&gt;edge_forbidden_mask |= BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4632">                        CorrectFixing_NH_NH_Bonds( pBNS, at, num_atoms );</a>
<a name="ln4633">#endif</a>
<a name="ln4634">                        salt_found = MarkSaltChargeGroups ( at, num_atoms, s_group_info,</a>
<a name="ln4635">                                                            t_group_info, c_group_info, pBNS, pBD );</a>
<a name="ln4636">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4637">                        pBNS-&gt;edge_forbidden_mask &amp;= ~BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4638">#endif</a>
<a name="ln4639">                        if ( salt_found &lt; 0 ) {</a>
<a name="ln4640">                            bError = salt_found;</a>
<a name="ln4641">                            break;</a>
<a name="ln4642">                        } else</a>
<a name="ln4643">                        if ( salt_found &gt; 0 ) {</a>
<a name="ln4644">                            *pbTautFlagsDone |= TG_FLAG_TEST_TAUT__SALTS_DONE;</a>
<a name="ln4645">                        }</a>
<a name="ln4646">                        salt_step = !salt_found; </a>
<a name="ln4647">                         /* if new 'salt' atoms have been found then repeat regular taut. search</a>
<a name="ln4648">                          *      MarkTautomerGroups() and do not perform salt step 1</a>
<a name="ln4649">                          * if new 'salt' atoms have NOT been found then switch to salt step 1</a>
<a name="ln4650">                          *      and never repeat salt step 0 for the current structure</a>
<a name="ln4651">                          */</a>
<a name="ln4652">                    }</a>
<a name="ln4653">                    if ( salt_step /*||</a>
<a name="ln4654">                         (t_group_info-&gt;tni.bNormalizationFlags &amp; FLAG_NORM_CONSIDER_TAUT)*/ ) { </a>
<a name="ln4655">                        /* salt step 1: process more than one attachment migration */</a>
<a name="ln4656">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4657">                        pBNS-&gt;edge_forbidden_mask |= BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4658">                        CorrectFixing_NH_NH_Bonds( pBNS, at, num_atoms );</a>
<a name="ln4659">#endif</a>
<a name="ln4660">                        salt_found = MarkSaltChargeGroups2 ( at, num_atoms, s_group_info,</a>
<a name="ln4661">                                                            t_group_info, c_group_info, pBNS, pBD );</a>
<a name="ln4662">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4663">                        pBNS-&gt;edge_forbidden_mask &amp;= ~BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4664">#endif</a>
<a name="ln4665">                        if ( salt_found &lt; 0 ) {</a>
<a name="ln4666">                            bError = salt_found;</a>
<a name="ln4667">                            break;</a>
<a name="ln4668">                        } else</a>
<a name="ln4669">                        if ( salt_found == 1 || salt_found == 5 ) {</a>
<a name="ln4670">                            *pbTautFlagsDone |= TG_FLAG_TEST_TAUT2_SALTS_DONE;</a>
<a name="ln4671">                            if ( salt_found == 5 ) {</a>
<a name="ln4672">                                *pbTautFlagsDone |= TG_FLAG_TEST_TAUT3_SALTS_DONE;</a>
<a name="ln4673">                            }</a>
<a name="ln4674">                            /* salt_found == 2 =&gt; only negative charges involved */</a>
<a name="ln4675">                        }</a>
<a name="ln4676">                    }</a>
<a name="ln4677"> </a>
<a name="ln4678">                    salt_pass ++;</a>
<a name="ln4679"> </a>
<a name="ln4680">                } else { /* !( *pbTautFlags &amp; TG_FLAG_TEST_TAUT2_SALTS ) */</a>
<a name="ln4681">                   /*************** requested only one attachement migration test **********/</a>
<a name="ln4682">                    if ( !nChanges &amp;&amp; salt_pass ) { /* one attachment migration */</a>
<a name="ln4683">                        break;</a>
<a name="ln4684">                    }            /* salt step 0: process one attachment migration */</a>
<a name="ln4685">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4686">                        pBNS-&gt;edge_forbidden_mask |= BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4687">                        CorrectFixing_NH_NH_Bonds( pBNS, at, num_atoms );</a>
<a name="ln4688">#endif</a>
<a name="ln4689">                        salt_found = MarkSaltChargeGroups ( at, num_atoms, s_group_info,</a>
<a name="ln4690">                                                            t_group_info, c_group_info, pBNS, pBD );</a>
<a name="ln4691">#if ( RESET_EDGE_FORBIDDEN_MASK == 0 )</a>
<a name="ln4692">                        pBNS-&gt;edge_forbidden_mask &amp;= ~BNS_EDGE_FORBIDDEN_TEMP;</a>
<a name="ln4693">#endif</a>
<a name="ln4694">                    if ( salt_found &lt; 0 ) {</a>
<a name="ln4695">                        bError = salt_found;</a>
<a name="ln4696">                        break;</a>
<a name="ln4697">                    } else</a>
<a name="ln4698">                    if ( salt_found &gt; 0 ) {</a>
<a name="ln4699">                        *pbTautFlagsDone |= TG_FLAG_TEST_TAUT__SALTS_DONE;</a>
<a name="ln4700">                    }</a>
<a name="ln4701">                    salt_pass ++;</a>
<a name="ln4702">                } /* ( *pbTautFlags &amp; TG_FLAG_TEST_TAUT2_SALTS ) */</a>
<a name="ln4703">            } /* ( *pbTautFlags &amp; TG_FLAG_TEST_TAUT__SALTS ) */</a>
<a name="ln4704"> </a>
<a name="ln4705">        } while ( salt_found &amp;&amp; !bError );</a>
<a name="ln4706">        /*************************************************************/</a>
<a name="ln4707">        /*                                                           */</a>
<a name="ln4708">        /*           M A I N   C Y C L E   E N D                     */</a>
<a name="ln4709">        /*                                                           */</a>
<a name="ln4710">        /*************************************************************/</a>
<a name="ln4711"> </a>
<a name="ln4712">        if ( *pbTautFlags &amp; TG_FLAG_MERGE_TAUT_SALTS ) {</a>
<a name="ln4713">            if ( !bError &amp;&amp; s_group_info /*&amp;&amp; s_group_info-&gt;num_candidates &gt; 0*/ ) {</a>
<a name="ln4714">                ret = MergeSaltTautGroups( at, num_atoms, s_group_info,</a>
<a name="ln4715">                                     t_group_info, c_group_info, pBNS );</a>
<a name="ln4716">                if ( ret &lt; 0 ) {</a>
<a name="ln4717">                    bError = ret;</a>
<a name="ln4718">                } else</a>
<a name="ln4719">                if ( ret &gt; 0 ) {</a>
<a name="ln4720">                    *pbTautFlagsDone |= TG_FLAG_MERGE_TAUT_SALTS_DONE;</a>
<a name="ln4721">                }</a>
<a name="ln4722">            }</a>
<a name="ln4723">        }</a>
<a name="ln4724">        if ( !bError &amp;&amp; t_group_info &amp;&amp;</a>
<a name="ln4725">             (t_group_info-&gt;bTautFlags &amp; TG_FLAG_VARIABLE_PROTONS) &amp;&amp;</a>
<a name="ln4726">             (t_group_info-&gt;bTautFlagsDone &amp; (TG_FLAG_FOUND_ISOTOPIC_ATOM_DONE|TG_FLAG_FOUND_ISOTOPIC_H_DONE)) ) {</a>
<a name="ln4727">            ret = MakeIsotopicHGroup( at, num_atoms, s_group_info, t_group_info );</a>
<a name="ln4728">            if ( ret &lt; 0 ) {</a>
<a name="ln4729">                bError = ret;</a>
<a name="ln4730">            }</a>
<a name="ln4731">        }</a>
<a name="ln4732">        /* success */</a>
<a name="ln4733">        remove_alt_bond_marks( at, num_atoms);</a>
<a name="ln4734">        </a>
<a name="ln4735">        /************************************************</a>
<a name="ln4736">         *  Temporarily ignore all non-alternating bonds</a>
<a name="ln4737">         *  and mark non-ring alt bonds non-stereogenic</a>
<a name="ln4738">         ************************************************/</a>
<a name="ln4739"> </a>
<a name="ln4740">        ReInitBnStructForAltBns( pBNS, at, num_atoms, 0 );</a>
<a name="ln4741">        MarkRingSystemsAltBns( pBNS, 0 );</a>
<a name="ln4742">        MarkNonStereoAltBns( pBNS, at, num_atoms, 0 );</a>
<a name="ln4743">#if ( FIX_EITHER_DB_AS_NONSTEREO == 1 )</a>
<a name="ln4744">        /* second time unknown (&quot;Either&quot;) alternating bonds are treated as non-stereogenic */</a>
<a name="ln4745">        /* stereobonds bonds that lost stereo get &quot;Either&quot; stereo_type */</a>
<a name="ln4746">        ReInitBnStructForAltBns( pBNS, at, num_atoms, 1 );</a>
<a name="ln4747">        MarkRingSystemsAltBns( pBNS, 1 );</a>
<a name="ln4748">        MarkNonStereoAltBns( pBNS, at, num_atoms, 1 );</a>
<a name="ln4749">#endif</a>
<a name="ln4750">    } else {</a>
<a name="ln4751">        bError = BNS_OUT_OF_RAM;</a>
<a name="ln4752">        /*printf(&quot;BNS_OUT_OF_RAM-3\n&quot;);*/</a>
<a name="ln4753">    }</a>
<a name="ln4754"> </a>
<a name="ln4755">exit_function:    </a>
<a name="ln4756"> </a>
<a name="ln4757">    pBNS = DeAllocateBnStruct( pBNS );</a>
<a name="ln4758">    pBD  = DeAllocateBnData( pBD );</a>
<a name="ln4759">/*#if ( MOVE_CHARGES == 1 )*/</a>
<a name="ln4760">    if ( c_group_info )  {</a>
<a name="ln4761">        if ( c_group_info-&gt;c_group ) {</a>
<a name="ln4762">            inchi_free( c_group_info-&gt;c_group );</a>
<a name="ln4763">        }</a>
<a name="ln4764">        if ( c_group_info-&gt;c_candidate ) {</a>
<a name="ln4765">            inchi_free( c_group_info-&gt;c_candidate );</a>
<a name="ln4766">        }</a>
<a name="ln4767">    }</a>
<a name="ln4768">/*#endif*/</a>
<a name="ln4769">    if ( s_group_info &amp;&amp; s_group_info-&gt;s_candidate ) {</a>
<a name="ln4770">        inchi_free( s_group_info-&gt;s_candidate );</a>
<a name="ln4771">    }</a>
<a name="ln4772">    if ( pAATG &amp;&amp; pAATG-&gt;nMarkedAtom ) {</a>
<a name="ln4773">        inchi_free( pAATG-&gt;nMarkedAtom );</a>
<a name="ln4774">        qzfree( pAATG-&gt;nEndPoint );</a>
<a name="ln4775">        /*qzfree( pAATG-&gt;nAtTypeTotals );*/ /* nAtTypeTotals is a stack array */</a>
<a name="ln4776">    }</a>
<a name="ln4777">    if ( t_group_info &amp;&amp; t_group_info-&gt;tGroupNumber ) {</a>
<a name="ln4778">        inchi_free( t_group_info-&gt;tGroupNumber );</a>
<a name="ln4779">        t_group_info-&gt;tGroupNumber = NULL;</a>
<a name="ln4780">    }</a>
<a name="ln4781"> </a>
<a name="ln4782">    if ( !bError &amp;&amp; num_atoms == 1 &amp;&amp; at[0].at_type == ATT_PROTON &amp;&amp; t_group_info &amp;&amp; !t_group_info-&gt;tni.nNumRemovedExplicitH ) {</a>
<a name="ln4783">        /* remove single isolated proton */</a>
<a name="ln4784">        t_group_info-&gt;tni.nNumRemovedProtons   = 1;</a>
<a name="ln4785">        t_group_info-&gt;tni.bNormalizationFlags |= FLAG_PROTON_SINGLE_REMOVED;</a>
<a name="ln4786">        if ( at[0].iso_atw_diff ) {</a>
<a name="ln4787">            t_group_info-&gt;tni.nNumRemovedProtonsIsotopic[at[0].iso_atw_diff-1] ++;</a>
<a name="ln4788">        }</a>
<a name="ln4789">        if ( at_fixed_bonds_out ) {</a>
<a name="ln4790">            memcpy( at_fixed_bonds_out, at, num_atoms*sizeof(at_fixed_bonds_out[0]) );</a>
<a name="ln4791">        }</a>
<a name="ln4792">        /*num_atoms --;*/</a>
<a name="ln4793">    }</a>
<a name="ln4794"> </a>
<a name="ln4795"> </a>
<a name="ln4796">    /*</a>
<a name="ln4797">       Additional currently unused info:</a>
<a name="ln4798"> </a>
<a name="ln4799">       nOrigDelta &gt; 0: original structure has been changed</a>
<a name="ln4800">                       due to fiund augmenting path(s)</a>
<a name="ln4801">       nChanges   &gt; 0: either alt. bonds or taut. groups have been found </a>
<a name="ln4802">    */</a>
<a name="ln4803"> </a>
<a name="ln4804">#ifdef FIX_AROM_RADICAL		/* Added 2011-05-09 IPl */</a>
<a name="ln4805">    if ( stored_radicals ) </a>
<a name="ln4806">        inchi_free( stored_radicals );</a>
<a name="ln4807">#endif</a>
<a name="ln4808"> </a>
<a name="ln4809"> </a>
<a name="ln4810">    return bError? bError : num_atoms;  /* ret = 0 =&gt; success, any other =&gt; error */</a>
<a name="ln4811"> </a>
<a name="ln4812">}</a>
<a name="ln4813"> </a>
<a name="ln4814"> </a>
<a name="ln4815"> </a>
<a name="ln4816">/*********************************************************************************/</a>
<a name="ln4817">int nMaxFlow2Check( BN_STRUCT *pBNS, int iedge )</a>
<a name="ln4818">{</a>
<a name="ln4819">    BNS_EDGE *pEdge    = pBNS-&gt;edge + iedge;</a>
<a name="ln4820">    int       nMaxFlow = (pEdge-&gt;cap &amp; EDGE_FLOW_MASK); /* edge cap */</a>
<a name="ln4821"> </a>
<a name="ln4822">    if ( nMaxFlow &gt; MAX_BOND_EDGE_CAP ) {</a>
<a name="ln4823">        nMaxFlow = MAX_BOND_EDGE_CAP;</a>
<a name="ln4824">    }</a>
<a name="ln4825">    return nMaxFlow;</a>
<a name="ln4826">}</a>
<a name="ln4827"> </a>
<a name="ln4828"> </a>
<a name="ln4829"> </a>
<a name="ln4830">/*********************************************************************************/</a>
<a name="ln4831">int nCurFlow2Check( BN_STRUCT *pBNS, int iedge )</a>
<a name="ln4832">{</a>
<a name="ln4833">    BNS_EDGE *pEdge    = pBNS-&gt;edge + iedge;</a>
<a name="ln4834">    int       nCurFlow = (pEdge-&gt;flow &amp; EDGE_FLOW_MASK); /* edge flow */</a>
<a name="ln4835">    return    nCurFlow;</a>
<a name="ln4836">}</a>
<a name="ln4837"> </a>
<a name="ln4838"> </a>
<a name="ln4839"> </a>
<a name="ln4840">/*********************************************************************************/</a>
<a name="ln4841">int nMinFlow2Check( BN_STRUCT *pBNS, int iedge )</a>
<a name="ln4842">{</a>
<a name="ln4843">    BNS_EDGE *pEdge    = pBNS-&gt;edge + iedge;</a>
<a name="ln4844">    Vertex    v1       = pEdge-&gt;neighbor1;</a>
<a name="ln4845">    Vertex    v2       = v1 ^ pEdge-&gt;neighbor12;</a>
<a name="ln4846">    int       f12      = (pEdge-&gt;flow &amp; EDGE_FLOW_MASK);</a>
<a name="ln4847">    int       rescap1, rescap2, rescap12, i, iedge_i;</a>
<a name="ln4848"> </a>
<a name="ln4849">    if ( f12 &gt; 0 ) {</a>
<a name="ln4850">        for ( i = 0, rescap1 = 0; i &lt; pBNS-&gt;vert[v1].num_adj_edges; i ++ ) {</a>
<a name="ln4851">            iedge_i = pBNS-&gt;vert[v1].iedge[i];</a>
<a name="ln4852">            if ( iedge_i == iedge )</a>
<a name="ln4853">                continue;</a>
<a name="ln4854">            rescap1 += (pBNS-&gt;edge[iedge_i].cap &amp; EDGE_FLOW_MASK) - (pBNS-&gt;edge[iedge_i].flow &amp; EDGE_FLOW_MASK);</a>
<a name="ln4855">        }</a>
<a name="ln4856">        for ( i = 0, rescap2 = 0; i &lt; pBNS-&gt;vert[v2].num_adj_edges; i ++ ) {</a>
<a name="ln4857">            iedge_i = pBNS-&gt;vert[v2].iedge[i];</a>
<a name="ln4858">            if ( iedge_i == iedge )</a>
<a name="ln4859">                continue;</a>
<a name="ln4860">            rescap2 += (pBNS-&gt;edge[iedge_i].cap &amp; EDGE_FLOW_MASK) - (pBNS-&gt;edge[iedge_i].flow &amp; EDGE_FLOW_MASK);</a>
<a name="ln4861">        }</a>
<a name="ln4862">        rescap12 = inchi_min( rescap1, rescap2 );</a>
<a name="ln4863">        rescap12 = inchi_min( rescap12, f12 );</a>
<a name="ln4864">        return f12-rescap12;</a>
<a name="ln4865">    }</a>
<a name="ln4866">    return 0;</a>
<a name="ln4867">}</a>
<a name="ln4868"> </a>
<a name="ln4869"> </a>
<a name="ln4870"> </a>
<a name="ln4871">/**********************************************************************************/</a>
<a name="ln4872">int bSetBondsAfterCheckOneBond( BN_STRUCT *pBNS, BNS_FLOW_CHANGES *fcd, int nTestFlow, inp_ATOM *at, int num_atoms, int bChangeFlow0 )</a>
<a name="ln4873">{</a>
<a name="ln4874">    int    ifcd, iedge, new_flow, ret_val, nChanges = 0, bError=0;</a>
<a name="ln4875">    int    bChangeFlow;</a>
<a name="ln4876">    Vertex v1, v2;</a>
<a name="ln4877">    int    ineigh1, ineigh2;</a>
<a name="ln4878">    BNS_EDGE *pEdge;</a>
<a name="ln4879">    </a>
<a name="ln4880">    bChangeFlow0 &amp;= ~BNS_EF_CHNG_RSTR;  /* do not change pEdge flow in SetBondType */</a>
<a name="ln4881">    if ( !bChangeFlow0 )</a>
<a name="ln4882">        return 0;</a>
<a name="ln4883"> </a>
<a name="ln4884">    bChangeFlow = (bChangeFlow0 &amp; ~BNS_EF_SET_NOSTEREO);</a>
<a name="ln4885">    /* find the next to the last changed */</a>
<a name="ln4886">    if ( bChangeFlow0 &amp; BNS_EF_SET_NOSTEREO ) {</a>
<a name="ln4887"> </a>
<a name="ln4888">        for ( ifcd = 0; NO_VERTEX != (iedge = fcd[ifcd].iedge); ifcd ++ ) {</a>
<a name="ln4889">            iedge = fcd[ifcd].iedge;</a>
<a name="ln4890">            pEdge = pBNS-&gt;edge + iedge;</a>
<a name="ln4891">            if ( !pEdge-&gt;pass ) {</a>
<a name="ln4892">                continue;</a>
<a name="ln4893">            }</a>
<a name="ln4894">        </a>
<a name="ln4895">            if ( !ifcd &amp;&amp; nTestFlow&gt;=0 ) {</a>
<a name="ln4896">                new_flow = nTestFlow;</a>
<a name="ln4897">            } else {</a>
<a name="ln4898">                new_flow = (int)pEdge-&gt;flow;</a>
<a name="ln4899">            }</a>
<a name="ln4900"> </a>
<a name="ln4901">            v1 = pEdge-&gt;neighbor1;</a>
<a name="ln4902">            v2 = pEdge-&gt;neighbor12 ^ v1;</a>
<a name="ln4903">            if ( v1 &lt; num_atoms &amp;&amp; v2 &lt; num_atoms &amp;&amp; new_flow != pEdge-&gt;flow0 ) {</a>
<a name="ln4904">                if ( (pBNS-&gt;vert[v1].st_edge.cap0 == pBNS-&gt;vert[v1].st_edge.flow0) !=</a>
<a name="ln4905">                     (pBNS-&gt;vert[v1].st_edge.cap  == pBNS-&gt;vert[v1].st_edge.flow ) ||</a>
<a name="ln4906">                     (pBNS-&gt;vert[v2].st_edge.cap0 == pBNS-&gt;vert[v2].st_edge.flow0) !=</a>
<a name="ln4907">                     (pBNS-&gt;vert[v2].st_edge.cap  == pBNS-&gt;vert[v2].st_edge.flow )) {</a>
<a name="ln4908">                    bChangeFlow |= BNS_EF_SET_NOSTEREO;</a>
<a name="ln4909">                    nChanges    |= BNS_EF_SET_NOSTEREO;</a>
<a name="ln4910">                }</a>
<a name="ln4911">            }</a>
<a name="ln4912">        }</a>
<a name="ln4913"> </a>
<a name="ln4914">    } else {</a>
<a name="ln4915">        for ( ifcd = 0; NO_VERTEX != (iedge = fcd[ifcd].iedge); ifcd ++ )</a>
<a name="ln4916">            ;</a>
<a name="ln4917">    }</a>
<a name="ln4918"> </a>
<a name="ln4919">    /* restore in reversed order to correctly handle vertex changed more than once */</a>
<a name="ln4920">    for ( ifcd -= 1; 0 &lt;= ifcd; ifcd -- ) {</a>
<a name="ln4921"> </a>
<a name="ln4922">        iedge = fcd[ifcd].iedge;</a>
<a name="ln4923">        pEdge = pBNS-&gt;edge + iedge;</a>
<a name="ln4924">        if ( !pEdge-&gt;pass ) {</a>
<a name="ln4925">            continue;</a>
<a name="ln4926">        }</a>
<a name="ln4927">        </a>
<a name="ln4928">        if ( !ifcd &amp;&amp; nTestFlow&gt;=0 ) {</a>
<a name="ln4929">            new_flow = nTestFlow;</a>
<a name="ln4930">        } else {</a>
<a name="ln4931">            new_flow = (int)pEdge-&gt;flow;</a>
<a name="ln4932">        }</a>
<a name="ln4933"> </a>
<a name="ln4934">        v1 = pEdge-&gt;neighbor1;</a>
<a name="ln4935">        v2 = pEdge-&gt;neighbor12 ^ v1;</a>
<a name="ln4936">        if ( v1 &lt; num_atoms &amp;&amp; v2 &lt; num_atoms &amp;&amp; bChangeFlow &amp;&amp; new_flow != pEdge-&gt;flow0 ) {</a>
<a name="ln4937">            ineigh1 = pEdge-&gt;neigh_ord[0];</a>
<a name="ln4938">            ineigh2 = pEdge-&gt;neigh_ord[1];</a>
<a name="ln4939">            ret_val = SetAtomBondType( pEdge, &amp;at[v1].bond_type[ineigh1], &amp;at[v2].bond_type[ineigh2], new_flow-pEdge-&gt;flow0, bChangeFlow );</a>
<a name="ln4940">            if ( !IS_BNS_ERROR( ret_val ) ) {</a>
<a name="ln4941">                nChanges |= (ret_val &gt; 0);</a>
<a name="ln4942">            } else {</a>
<a name="ln4943">                bError = ret_val;</a>
<a name="ln4944">            }</a>
<a name="ln4945">        }</a>
<a name="ln4946">        pEdge-&gt;pass = 0;</a>
<a name="ln4947">    }</a>
<a name="ln4948">    return bError? bError : nChanges;</a>
<a name="ln4949">}</a>
<a name="ln4950"> </a>
<a name="ln4951"> </a>
<a name="ln4952"> </a>
<a name="ln4953">/**********************************************************************************/</a>
<a name="ln4954">int bRestoreFlowAfterCheckOneBond( BN_STRUCT *pBNS, BNS_FLOW_CHANGES *fcd )</a>
<a name="ln4955">{</a>
<a name="ln4956">    int ifcd, iedge;</a>
<a name="ln4957">    Vertex v1, v2;</a>
<a name="ln4958">    BNS_EDGE *pEdge;</a>
<a name="ln4959">    </a>
<a name="ln4960">    /* find the next to the last changed */</a>
<a name="ln4961">    for ( ifcd = 0; NO_VERTEX != (iedge = fcd[ifcd].iedge); ifcd ++ )</a>
<a name="ln4962">        ;</a>
<a name="ln4963"> </a>
<a name="ln4964">    /* restore in reversed order to correctly handle vertex changed more than once */</a>
<a name="ln4965">    for ( ifcd -= 1; 0 &lt;= ifcd; ifcd -- ) {</a>
<a name="ln4966"> </a>
<a name="ln4967">        /* restore edge flow &amp; cap */</a>
<a name="ln4968">        iedge = fcd[ifcd].iedge;</a>
<a name="ln4969">        pEdge = pBNS-&gt;edge + iedge;</a>
<a name="ln4970">        pEdge-&gt;flow = fcd[ifcd].flow;</a>
<a name="ln4971">        pEdge-&gt;cap  = fcd[ifcd].cap;</a>
<a name="ln4972">        pEdge-&gt;pass = 0;</a>
<a name="ln4973"> </a>
<a name="ln4974">        /* restore st-flow, cap */</a>
<a name="ln4975">        if ( NO_VERTEX != (v1 = fcd[ifcd].v1) ) {</a>
<a name="ln4976">            pBNS-&gt;vert[v1].st_edge.flow = fcd[ifcd].flow_st1;</a>
<a name="ln4977">            pBNS-&gt;vert[v1].st_edge.cap  = fcd[ifcd].cap_st1;</a>
<a name="ln4978">            pBNS-&gt;vert[v1].st_edge.pass = 0;</a>
<a name="ln4979">        }</a>
<a name="ln4980">        if ( NO_VERTEX != (v2 = fcd[ifcd].v2) ) {</a>
<a name="ln4981">            pBNS-&gt;vert[v2].st_edge.flow = fcd[ifcd].flow_st2;</a>
<a name="ln4982">            pBNS-&gt;vert[v2].st_edge.cap  = fcd[ifcd].cap_st2;</a>
<a name="ln4983">            pBNS-&gt;vert[v2].st_edge.pass = 0;</a>
<a name="ln4984">        }</a>
<a name="ln4985">    }</a>
<a name="ln4986">    return 0;</a>
<a name="ln4987">}</a>
<a name="ln4988"> </a>
<a name="ln4989"> </a>
<a name="ln4990"> </a>
<a name="ln4991">/**********************************************************************************/</a>
<a name="ln4992">int bSetFlowToCheckOneBond( BN_STRUCT *pBNS, int iedge, int flow, BNS_FLOW_CHANGES *fcd )</a>
<a name="ln4993">{</a>
<a name="ln4994">    BNS_EDGE *pEdge    = pBNS-&gt;edge + iedge;</a>
<a name="ln4995">    int       f12      = (pEdge-&gt;flow &amp; EDGE_FLOW_MASK); /* the original flow */</a>
<a name="ln4996">    int       ifcd     = 0;</a>
<a name="ln4997">    int       nDots    = 0;</a>
<a name="ln4998">    int       i, iedge_i;</a>
<a name="ln4999"> </a>
<a name="ln5000">    fcd[ifcd].iedge    = NO_VERTEX;</a>
<a name="ln5001"> </a>
<a name="ln5002">    if ( f12 &lt; flow ) {</a>
<a name="ln5003">        /* Increase edge flow: Grab flow from the neighbors and delete it: set flow12=cap12 = 0 */</a>
<a name="ln5004">        /************************************************************************************/</a>
<a name="ln5005">        /* For example, simulate a new fixed double bond in place of a single bond and      */</a>
<a name="ln5006">        /* creates ONE or NONE (in case of a radical on adjacent atom) augmenting paths and */</a>
<a name="ln5007">        /* makes it impossible for the BNS to set same flow as it originally was            */</a>
<a name="ln5008">        /************************************************************************************/</a>
<a name="ln5009">        Vertex    v1       = pEdge-&gt;neighbor1;</a>
<a name="ln5010">        Vertex    v2       = v1 ^ pEdge-&gt;neighbor12;</a>
<a name="ln5011">        Vertex    v_i;        /* neighbor of v1 or v2 */</a>
<a name="ln5012">        BNS_EDGE *pEdge_i;</a>
<a name="ln5013">        int       delta1, delta2, f, st_edge_rescap;</a>
<a name="ln5014"> </a>
<a name="ln5015">        if ( (pBNS-&gt;vert[v1].st_edge.cap  &amp; EDGE_FLOW_ST_MASK) &lt; flow ||</a>
<a name="ln5016">             (pBNS-&gt;vert[v2].st_edge.cap  &amp; EDGE_FLOW_ST_MASK) &lt; flow ) {</a>
<a name="ln5017">            return BNS_CANT_SET_BOND;</a>
<a name="ln5018">        }</a>
<a name="ln5019">        if ( (pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK) &lt; f12 ||</a>
<a name="ln5020">             (pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK) &lt; f12 ) {</a>
<a name="ln5021">            return BNS_CAP_FLOW_ERR;</a>
<a name="ln5022">        }</a>
<a name="ln5023"> </a>
<a name="ln5024">        </a>
<a name="ln5025">        fcd[ifcd].iedge    = iedge;</a>
<a name="ln5026">        fcd[ifcd].flow     = pEdge-&gt;flow;</a>
<a name="ln5027">        fcd[ifcd].cap      = pEdge-&gt;cap;</a>
<a name="ln5028">        </a>
<a name="ln5029">        fcd[ifcd].v1       = v1;</a>
<a name="ln5030">        fcd[ifcd].flow_st1 = pBNS-&gt;vert[v1].st_edge.flow;</a>
<a name="ln5031">        fcd[ifcd].cap_st1  = pBNS-&gt;vert[v1].st_edge.cap;</a>
<a name="ln5032">        </a>
<a name="ln5033">        fcd[ifcd].v2       = v2;</a>
<a name="ln5034">        fcd[ifcd].flow_st2 = pBNS-&gt;vert[v2].st_edge.flow;</a>
<a name="ln5035">        fcd[ifcd].cap_st2  = pBNS-&gt;vert[v2].st_edge.cap;</a>
<a name="ln5036"> </a>
<a name="ln5037">        fcd[++ifcd].iedge    = NO_VERTEX; /* mark the end of the fcd[] data */</a>
<a name="ln5038">        pEdge-&gt;pass |= 64;</a>
<a name="ln5039"> </a>
<a name="ln5040">        delta1 = delta2 = flow - f12;</a>
<a name="ln5041"> </a>
<a name="ln5042">        if ( f12 &gt; 0 ) {</a>
<a name="ln5043">            /* remove old edge flow from the flow and cap of the adjacent vertices' st-edges */</a>
<a name="ln5044">            pBNS-&gt;vert[v1].st_edge.cap  = ((pBNS-&gt;vert[v1].st_edge.cap  &amp; EDGE_FLOW_ST_MASK)-f12) | (pBNS-&gt;vert[v1].st_edge.cap  &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5045">            pBNS-&gt;vert[v2].st_edge.cap  = ((pBNS-&gt;vert[v2].st_edge.cap  &amp; EDGE_FLOW_ST_MASK)-f12) | (pBNS-&gt;vert[v2].st_edge.cap  &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5046">            pBNS-&gt;vert[v1].st_edge.flow = ((pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-f12) | (pBNS-&gt;vert[v1].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5047">            pBNS-&gt;vert[v2].st_edge.flow = ((pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-f12) | (pBNS-&gt;vert[v2].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5048">            /* delete current edge flow and capacity */</a>
<a name="ln5049">            pEdge-&gt;flow = (pEdge-&gt;flow &amp; ~EDGE_FLOW_MASK);</a>
<a name="ln5050">        }</a>
<a name="ln5051">        pEdge-&gt;cap  = (pEdge-&gt;cap  &amp; ~EDGE_FLOW_MASK);</a>
<a name="ln5052"> </a>
<a name="ln5053">        /* grab the adjacent vertex1 radical (st_edge_rescap) if it exists */</a>
<a name="ln5054">        st_edge_rescap = (pBNS-&gt;vert[v1].st_edge.cap &amp; EDGE_FLOW_ST_MASK) - (pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK);</a>
<a name="ln5055">        while ( st_edge_rescap &amp;&amp; delta1 ) { </a>
<a name="ln5056">            st_edge_rescap --;  /* grab the radical */</a>
<a name="ln5057">            delta1 --;</a>
<a name="ln5058">            pBNS-&gt;vert[v1].st_edge.cap = ((pBNS-&gt;vert[v1].st_edge.cap &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v1].st_edge.cap &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5059">            nDots --;</a>
<a name="ln5060">        }</a>
<a name="ln5061">        /* grab the adjacent vertex2 radical (st_edge_rescap) if it exists */</a>
<a name="ln5062">        st_edge_rescap = (pBNS-&gt;vert[v2].st_edge.cap &amp; EDGE_FLOW_ST_MASK) - (pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK);</a>
<a name="ln5063">        while ( st_edge_rescap &amp;&amp; delta2 ) {</a>
<a name="ln5064">            st_edge_rescap --;  /* grab the radical */</a>
<a name="ln5065">            delta2 --;</a>
<a name="ln5066">            pBNS-&gt;vert[v2].st_edge.cap = ((pBNS-&gt;vert[v2].st_edge.cap &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v2].st_edge.cap &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5067">            nDots --;</a>
<a name="ln5068">        }</a>
<a name="ln5069">        /* grab flows from v1 neighbors */</a>
<a name="ln5070">        for ( i = 0; delta1 &amp;&amp; i &lt; pBNS-&gt;vert[v1].num_adj_edges; i ++ ) {</a>
<a name="ln5071">            iedge_i = pBNS-&gt;vert[v1].iedge[i];</a>
<a name="ln5072">            if ( iedge_i == iedge )</a>
<a name="ln5073">                continue;</a>
<a name="ln5074">            pEdge_i = pBNS-&gt;edge + iedge_i;</a>
<a name="ln5075">            if ( IS_FORBIDDEN(pEdge_i-&gt;forbidden, pBNS) )</a>
<a name="ln5076">                continue;</a>
<a name="ln5077">            f = (pEdge_i-&gt;flow &amp; EDGE_FLOW_MASK);</a>
<a name="ln5078">            if ( f ) {</a>
<a name="ln5079">                v_i     = pEdge_i-&gt;neighbor12 ^ v1;</a>
<a name="ln5080"> </a>
<a name="ln5081">                fcd[ifcd].iedge    = iedge_i;</a>
<a name="ln5082">                fcd[ifcd].flow     = pEdge_i-&gt;flow;</a>
<a name="ln5083">                fcd[ifcd].cap      = pEdge_i-&gt;cap;</a>
<a name="ln5084">                </a>
<a name="ln5085">                fcd[ifcd].v1       = v_i;</a>
<a name="ln5086">                fcd[ifcd].flow_st1 = pBNS-&gt;vert[v_i].st_edge.flow;</a>
<a name="ln5087">                fcd[ifcd].cap_st1  = pBNS-&gt;vert[v_i].st_edge.cap;</a>
<a name="ln5088">                </a>
<a name="ln5089">                fcd[ifcd].v2       = NO_VERTEX;</a>
<a name="ln5090">                fcd[ifcd].flow_st2 = 0;</a>
<a name="ln5091">                fcd[ifcd].cap_st2  = 0;</a>
<a name="ln5092"> </a>
<a name="ln5093">                fcd[++ifcd].iedge    = NO_VERTEX; /* mark the end of the fcd[] data */</a>
<a name="ln5094">                pEdge_i-&gt;pass |= 64;</a>
<a name="ln5095"> </a>
<a name="ln5096">                while ( f &amp;&amp; delta1 ) {</a>
<a name="ln5097">                    f --;</a>
<a name="ln5098">                    delta1 --;</a>
<a name="ln5099">                    pEdge_i-&gt;flow = ((pEdge_i-&gt;flow &amp; EDGE_FLOW_MASK) - 1) | (pEdge_i-&gt;flow &amp; ~EDGE_FLOW_MASK);</a>
<a name="ln5100">                    pBNS-&gt;vert[v_i].st_edge.flow = ((pBNS-&gt;vert[v_i].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v_i].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5101">                    /* next 2 lines added 01-22-2002 */</a>
<a name="ln5102">                    pBNS-&gt;vert[v1].st_edge.cap  = ((pBNS-&gt;vert[v1].st_edge.cap  &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v1].st_edge.cap  &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5103">                    pBNS-&gt;vert[v1].st_edge.flow = ((pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v1].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5104"> </a>
<a name="ln5105">                    nDots ++;</a>
<a name="ln5106">                }</a>
<a name="ln5107">                    </a>
<a name="ln5108">            }</a>
<a name="ln5109">        }</a>
<a name="ln5110">        /* grab flows from v2 neighbors */</a>
<a name="ln5111">        for ( i = 0; delta2 &amp;&amp; i &lt; pBNS-&gt;vert[v2].num_adj_edges; i ++ ) {</a>
<a name="ln5112">            iedge_i = pBNS-&gt;vert[v2].iedge[i];</a>
<a name="ln5113">            if ( iedge_i == iedge )</a>
<a name="ln5114">                continue;</a>
<a name="ln5115">            pEdge_i = pBNS-&gt;edge + iedge_i;</a>
<a name="ln5116">            if ( IS_FORBIDDEN(pEdge_i-&gt;forbidden, pBNS) )</a>
<a name="ln5117">                continue;</a>
<a name="ln5118">            f = (pEdge_i-&gt;flow &amp; EDGE_FLOW_MASK);</a>
<a name="ln5119">            if ( f ) {</a>
<a name="ln5120">                v_i     = pEdge_i-&gt;neighbor12 ^ v2;</a>
<a name="ln5121"> </a>
<a name="ln5122">                fcd[ifcd].iedge    = iedge_i;</a>
<a name="ln5123">                fcd[ifcd].flow     = pEdge_i-&gt;flow;</a>
<a name="ln5124">                fcd[ifcd].cap      = pEdge_i-&gt;cap;</a>
<a name="ln5125">                </a>
<a name="ln5126">                fcd[ifcd].v1       = v_i;</a>
<a name="ln5127">                fcd[ifcd].flow_st1 = pBNS-&gt;vert[v_i].st_edge.flow;</a>
<a name="ln5128">                fcd[ifcd].cap_st1  = pBNS-&gt;vert[v_i].st_edge.cap;</a>
<a name="ln5129">                </a>
<a name="ln5130">                fcd[ifcd].v2       = NO_VERTEX;</a>
<a name="ln5131">                fcd[ifcd].flow_st2 = 0;</a>
<a name="ln5132">                fcd[ifcd].cap_st2  = 0;</a>
<a name="ln5133"> </a>
<a name="ln5134">                fcd[++ifcd].iedge    = NO_VERTEX; /* mark the end of the fcd[] data */</a>
<a name="ln5135">                pEdge_i-&gt;pass |= 64;</a>
<a name="ln5136"> </a>
<a name="ln5137">                while ( f &amp;&amp; delta2 ) {</a>
<a name="ln5138">                    f --;</a>
<a name="ln5139">                    delta2 --;</a>
<a name="ln5140">                    pEdge_i-&gt;flow = ((pEdge_i-&gt;flow &amp; EDGE_FLOW_MASK) - 1) | (pEdge_i-&gt;flow &amp; ~EDGE_FLOW_MASK);</a>
<a name="ln5141">                    pBNS-&gt;vert[v_i].st_edge.flow = ((pBNS-&gt;vert[v_i].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v_i].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5142">                    /* next 2 lines added 01-22-2002 */</a>
<a name="ln5143">                    pBNS-&gt;vert[v2].st_edge.cap  = ((pBNS-&gt;vert[v2].st_edge.cap  &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v2].st_edge.cap  &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5144">                    pBNS-&gt;vert[v2].st_edge.flow = ((pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-1) | (pBNS-&gt;vert[v2].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5145"> </a>
<a name="ln5146">                    nDots ++;</a>
<a name="ln5147">                }</a>
<a name="ln5148">                    </a>
<a name="ln5149">            }</a>
<a name="ln5150">        }</a>
<a name="ln5151">        if ( delta1 || delta2 ) {</a>
<a name="ln5152">            return BNS_CANT_SET_BOND;</a>
<a name="ln5153">        }</a>
<a name="ln5154">    }</a>
<a name="ln5155"> </a>
<a name="ln5156">    if ( f12 &gt;= flow ) {</a>
<a name="ln5157">        /* Decrease edge flow: Redirect flow to the neighbors and delete it on the edge: set flow12=cap12 = 0 */</a>
<a name="ln5158">        /* f12==flow fixes flow through the edge so that BNS cannot change it */</a>
<a name="ln5159">        /**********************************************************************************************/</a>
<a name="ln5160">        /* For example, simulate a removal of a double bond and create ONE or NONE augmenting path    */</a>
<a name="ln5161">        /* Make it impossible for BNS to set same flow as it originally was                           */</a>
<a name="ln5162">        /**********************************************************************************************/</a>
<a name="ln5163">        Vertex    v1       = pEdge-&gt;neighbor1;</a>
<a name="ln5164">        Vertex    v2       = (v1 ^ pEdge-&gt;neighbor12);</a>
<a name="ln5165">        int       delta;</a>
<a name="ln5166">        /* if NOT (st-cap &gt;= st-flow &gt;= f12 &gt;= flow) then error in the BN structure */</a>
<a name="ln5167">        if ( (pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK) &lt; f12 ||</a>
<a name="ln5168">             (pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK) &lt; f12 ||</a>
<a name="ln5169">             (pBNS-&gt;vert[v1].st_edge.cap  &amp; EDGE_FLOW_ST_MASK) &lt; flow ||</a>
<a name="ln5170">             (pBNS-&gt;vert[v2].st_edge.cap  &amp; EDGE_FLOW_ST_MASK) &lt; flow ) {</a>
<a name="ln5171">            return BNS_CAP_FLOW_ERR;</a>
<a name="ln5172">        }</a>
<a name="ln5173">        fcd[ifcd].iedge    = iedge;</a>
<a name="ln5174">        fcd[ifcd].flow     = pEdge-&gt;flow;</a>
<a name="ln5175">        fcd[ifcd].cap      = pEdge-&gt;cap;</a>
<a name="ln5176">        </a>
<a name="ln5177">        fcd[ifcd].v1       = v1;</a>
<a name="ln5178">        fcd[ifcd].flow_st1 = pBNS-&gt;vert[v1].st_edge.flow;</a>
<a name="ln5179">        fcd[ifcd].cap_st1  = pBNS-&gt;vert[v1].st_edge.cap;</a>
<a name="ln5180">        </a>
<a name="ln5181">        fcd[ifcd].v2       = v2;</a>
<a name="ln5182">        fcd[ifcd].flow_st2 = pBNS-&gt;vert[v2].st_edge.flow;</a>
<a name="ln5183">        fcd[ifcd].cap_st2  = pBNS-&gt;vert[v2].st_edge.cap;</a>
<a name="ln5184"> </a>
<a name="ln5185">        fcd[++ifcd].iedge    = NO_VERTEX; /* mark the end of the fcd[] data */</a>
<a name="ln5186">        pEdge-&gt;pass |= 64;</a>
<a name="ln5187"> </a>
<a name="ln5188">        delta = f12 - flow;</a>
<a name="ln5189">        /* remove current edge flow from st-edges */</a>
<a name="ln5190">        /* -- seem to be a bug --</a>
<a name="ln5191">        pBNS-&gt;vert[v1].st_edge.flow = ((pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-delta) | (pBNS-&gt;vert[v1].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5192">        pBNS-&gt;vert[v2].st_edge.flow = ((pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-delta) | (pBNS-&gt;vert[v2].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5193">        */</a>
<a name="ln5194"> </a>
<a name="ln5195">        /* replacement to the above 2 lines 01-16-2002 */</a>
<a name="ln5196">        /* remove old edge flow from the flow of the adjacent vertices' st-edges */</a>
<a name="ln5197"> </a>
<a name="ln5198">        pBNS-&gt;vert[v1].st_edge.flow = ((pBNS-&gt;vert[v1].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-f12) | (pBNS-&gt;vert[v1].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5199">        pBNS-&gt;vert[v2].st_edge.flow = ((pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK)-f12) | (pBNS-&gt;vert[v2].st_edge.flow &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5200"> </a>
<a name="ln5201">        /* added 01-16-2002: reduce st-cap if new flow &gt; 0  */</a>
<a name="ln5202">        /* remove new edge flow from the cap of the adjacent vertices' st-edges */</a>
<a name="ln5203">        pBNS-&gt;vert[v1].st_edge.cap = ((pBNS-&gt;vert[v1].st_edge.cap &amp; EDGE_FLOW_ST_MASK)-flow) | (pBNS-&gt;vert[v1].st_edge.cap &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5204">        pBNS-&gt;vert[v2].st_edge.cap = ((pBNS-&gt;vert[v2].st_edge.cap &amp; EDGE_FLOW_ST_MASK)-flow) | (pBNS-&gt;vert[v2].st_edge.cap &amp; ~EDGE_FLOW_ST_MASK);</a>
<a name="ln5205">        </a>
<a name="ln5206">        /* delete current edge flow and capacity */</a>
<a name="ln5207">        pEdge-&gt;flow = (pEdge-&gt;flow &amp; ~EDGE_FLOW_MASK);</a>
<a name="ln5208">        pEdge-&gt;cap  = (pEdge-&gt;cap  &amp; ~EDGE_FLOW_MASK);</a>
<a name="ln5209">        nDots = 2*delta;</a>
<a name="ln5210">    }</a>
<a name="ln5211">    return nDots;</a>
<a name="ln5212">}</a>
<a name="ln5213"> </a>
<a name="ln5214"> </a>
<a name="ln5215"> </a>
<a name="ln5216">/**********************************************************************************/</a>
<a name="ln5217">/* Connect new (fictitious, temporary) vertex to to nVertDoubleBond by a new edge */</a>
<a name="ln5218">/* Add radical (set st-cap=1) to the new vertex, set cap=1 to the new edge        */</a>
<a name="ln5219">/* Add radical (set st-cap=1) to nVertSingleBond                                  */</a>
<a name="ln5220">/* Find augmenting path connecting new vertex to nVertSingleBond                  */</a>
<a name="ln5221">/* This corresponds to moving H-atom from nVertSingleBond to nVertDoubleBond      */</a>
<a name="ln5222">/**********************************************************************************/</a>
<a name="ln5223">int bAddNewVertex( BN_STRUCT *pBNS, int nVertDoubleBond, int nCap, int nFlow, int nMaxAdjEdges, int *nDots )</a>
<a name="ln5224">{</a>
<a name="ln5225">    Vertex      vlast    = pBNS-&gt;num_vertices - 1;</a>
<a name="ln5226">    Vertex      vnew     = pBNS-&gt;num_vertices;</a>
<a name="ln5227">    Vertex      v2       = nVertDoubleBond;</a>
<a name="ln5228">    BNS_VERTEX *pVert2   = pBNS-&gt;vert + v2;   /* pointer to an old vertex */</a>
<a name="ln5229">    BNS_VERTEX *pNewVert = pBNS-&gt;vert + vnew; /* pointer to a new vertex */</a>
<a name="ln5230">    </a>
<a name="ln5231">    EdgeIndex   iedge    = pBNS-&gt;num_edges;</a>
<a name="ln5232">    BNS_EDGE   *pEdge    = pBNS-&gt;edge + iedge; /* pointer to a new edge */</a>
<a name="ln5233"> </a>
<a name="ln5234">    if ( iedge &gt;= pBNS-&gt;max_edges || vnew &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln5235">        return BNS_VERT_EDGE_OVFL; /* edges or vertices overflow */</a>
<a name="ln5236">    }</a>
<a name="ln5237">    if ( (pBNS-&gt;vert[vlast].iedge - pBNS-&gt;iedge) + pBNS-&gt;vert[vlast].max_adj_edges + nMaxAdjEdges &gt;= pBNS-&gt;max_iedges ) {</a>
<a name="ln5238">        return BNS_VERT_EDGE_OVFL; /* iedges overflow */</a>
<a name="ln5239">    }</a>
<a name="ln5240">    if ( pVert2-&gt;num_adj_edges &gt;= pVert2-&gt;max_adj_edges || nMaxAdjEdges &lt;= 0 ) {</a>
<a name="ln5241">        return BNS_VERT_EDGE_OVFL; /* neighbors overflow */</a>
<a name="ln5242">    }</a>
<a name="ln5243">    /* fill out the new edge, set its cap and flow, connect */</a>
<a name="ln5244">    /* memset( pEdge, 0, sizeof(*pEdge) ); */</a>
<a name="ln5245">    pEdge-&gt;cap  = pEdge-&gt;cap0  = nCap;</a>
<a name="ln5246">    pEdge-&gt;flow = pEdge-&gt;flow0 = nFlow;</a>
<a name="ln5247">    pEdge-&gt;pass = 0;</a>
<a name="ln5248">    pEdge-&gt;neighbor1  = v2;</a>
<a name="ln5249">    pEdge-&gt;neighbor12 = v2 ^ vnew;</a>
<a name="ln5250">    pEdge-&gt;forbidden  = 0;</a>
<a name="ln5251">    /* fill out the new vertex */</a>
<a name="ln5252">    /* memset( pNewVert, 0, sizeof(*pNewVert) ); */</a>
<a name="ln5253">    pNewVert-&gt;max_adj_edges = nMaxAdjEdges;</a>
<a name="ln5254">    pNewVert-&gt;num_adj_edges = 0;</a>
<a name="ln5255">    pNewVert-&gt;st_edge.cap0  = pNewVert-&gt;st_edge.cap   = nCap;</a>
<a name="ln5256">    pNewVert-&gt;st_edge.flow0 = pNewVert-&gt;st_edge.flow  = nFlow;</a>
<a name="ln5257">    pNewVert-&gt;st_edge.pass  = 0; /* add initialization; added 2006-03-25 */</a>
<a name="ln5258">    pNewVert-&gt;iedge         = pBNS-&gt;vert[vlast].iedge + pBNS-&gt;vert[vlast].max_adj_edges;</a>
<a name="ln5259">    pNewVert-&gt;type          = BNS_VERT_TYPE_TEMP;</a>
<a name="ln5260">    *nDots += nCap - nFlow;</a>
<a name="ln5261"> </a>
<a name="ln5262">    pEdge-&gt;neigh_ord[v2&gt;vnew] = pVert2-&gt;num_adj_edges;</a>
<a name="ln5263">    pEdge-&gt;neigh_ord[v2&lt;vnew] = pNewVert-&gt;num_adj_edges;</a>
<a name="ln5264"> </a>
<a name="ln5265">    /* connect new edge to v2 */</a>
<a name="ln5266">    pVert2-&gt;iedge[pVert2-&gt;num_adj_edges ++] = iedge;</a>
<a name="ln5267">    /* connect new edge to vnew */</a>
<a name="ln5268">    pNewVert-&gt;iedge[pNewVert-&gt;num_adj_edges ++] = iedge;</a>
<a name="ln5269"> </a>
<a name="ln5270">    /* fix v2 flow and cap */</a>
<a name="ln5271">    *nDots -= (int)pVert2-&gt;st_edge.cap - (int)pVert2-&gt;st_edge.flow;</a>
<a name="ln5272">    pVert2-&gt;st_edge.flow += nFlow;</a>
<a name="ln5273">    if ( pVert2-&gt;st_edge.cap &lt; pVert2-&gt;st_edge.flow ) {</a>
<a name="ln5274">        pVert2-&gt;st_edge.cap = pVert2-&gt;st_edge.flow;</a>
<a name="ln5275">    }</a>
<a name="ln5276">    *nDots += (int)pVert2-&gt;st_edge.cap - (int)pVert2-&gt;st_edge.flow;</a>
<a name="ln5277"> </a>
<a name="ln5278">    pBNS-&gt;num_edges ++;</a>
<a name="ln5279">    pBNS-&gt;num_vertices ++;</a>
<a name="ln5280"> </a>
<a name="ln5281">    return vnew;</a>
<a name="ln5282">}</a>
<a name="ln5283"> </a>
<a name="ln5284"> </a>
<a name="ln5285"> </a>
<a name="ln5286">/*****************************************************************************************************/</a>
<a name="ln5287">int AddNewEdge( BNS_VERTEX *p1, BNS_VERTEX *p2, BN_STRUCT *pBNS, int nEdgeCap, int nEdgeFlow )</a>
<a name="ln5288">{</a>
<a name="ln5289">    int ip1 = p1 - pBNS-&gt;vert;</a>
<a name="ln5290">    int ip2 = p2 - pBNS-&gt;vert;</a>
<a name="ln5291">    int ie  = pBNS-&gt;num_edges;</a>
<a name="ln5292">    BNS_EDGE *e = pBNS-&gt;edge + ie;</a>
<a name="ln5293">    /* debug: check bounds */</a>
<a name="ln5294">    if ( ip1 &gt;= pBNS-&gt;max_vertices || ip1 &lt; 0 ||</a>
<a name="ln5295">         ip2 &gt;= pBNS-&gt;max_vertices || ip2 &lt; 0 ||</a>
<a name="ln5296">         ie  &gt;= pBNS-&gt;max_edges    || ie  &lt; 0 ||</a>
<a name="ln5297">         (p1-&gt;iedge - pBNS-&gt;iedge) &lt; 0 ||</a>
<a name="ln5298">         (p1-&gt;iedge - pBNS-&gt;iedge) + p1-&gt;max_adj_edges &gt; pBNS-&gt;max_iedges ||</a>
<a name="ln5299">         (p2-&gt;iedge - pBNS-&gt;iedge) &lt; 0 ||</a>
<a name="ln5300">         (p2-&gt;iedge - pBNS-&gt;iedge) + p2-&gt;max_adj_edges &gt; pBNS-&gt;max_iedges ||</a>
<a name="ln5301">         p1-&gt;num_adj_edges &gt;= p1-&gt;max_adj_edges ||</a>
<a name="ln5302">         p2-&gt;num_adj_edges &gt;= p2-&gt;max_adj_edges  ) {</a>
<a name="ln5303">        return BNS_VERT_EDGE_OVFL;</a>
<a name="ln5304">    }</a>
<a name="ln5305">    /* clear the edge */</a>
<a name="ln5306">    memset( e, 0, sizeof(*e) );</a>
<a name="ln5307">    /* connect */</a>
<a name="ln5308">    e-&gt;neighbor1  = inchi_min( ip1, ip2 );</a>
<a name="ln5309">    e-&gt;neighbor12 = ip1 ^ ip2;</a>
<a name="ln5310">    p1-&gt;iedge[p1-&gt;num_adj_edges] = ie;</a>
<a name="ln5311">    p2-&gt;iedge[p2-&gt;num_adj_edges] = ie;</a>
<a name="ln5312">    e-&gt;neigh_ord[ip1 &gt; ip2] = p1-&gt;num_adj_edges ++;</a>
<a name="ln5313">    e-&gt;neigh_ord[ip1 &lt; ip2] = p2-&gt;num_adj_edges ++;</a>
<a name="ln5314">    e-&gt;cap = e-&gt;cap0 = nEdgeCap;</a>
<a name="ln5315">    e-&gt;flow = e-&gt;flow0 = nEdgeFlow;</a>
<a name="ln5316">    p1-&gt;st_edge.flow += nEdgeFlow;</a>
<a name="ln5317">    p2-&gt;st_edge.flow += nEdgeFlow;</a>
<a name="ln5318">    if ( p1-&gt;st_edge.cap &lt; p1-&gt;st_edge.flow ) {</a>
<a name="ln5319">        p1-&gt;st_edge.cap = p1-&gt;st_edge.flow;</a>
<a name="ln5320">    }</a>
<a name="ln5321">    if ( p2-&gt;st_edge.cap &lt; p2-&gt;st_edge.flow ) {</a>
<a name="ln5322">        p2-&gt;st_edge.cap = p2-&gt;st_edge.flow;</a>
<a name="ln5323">    }</a>
<a name="ln5324">    pBNS-&gt;num_edges ++;</a>
<a name="ln5325">    return ie;</a>
<a name="ln5326">}</a>
<a name="ln5327"> </a>
<a name="ln5328"> </a>
<a name="ln5329"> </a>
<a name="ln5330">/**********************************************************************************/</a>
<a name="ln5331">BNS_IEDGE GetEdgeToGroupVertex( BN_STRUCT *pBNS, Vertex v1, AT_NUMB type)</a>
<a name="ln5332">{</a>
<a name="ln5333">    if ( v1 &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln5334">        Vertex      v2;</a>
<a name="ln5335">        BNS_EDGE   *pEdge1;</a>
<a name="ln5336">        BNS_VERTEX *pVert1 = pBNS-&gt;vert+v1;</a>
<a name="ln5337">        int         i      = pVert1-&gt;num_adj_edges-1;</a>
<a name="ln5338"> </a>
<a name="ln5339">        while( 0 &lt;= i ) {</a>
<a name="ln5340">            pEdge1 = pBNS-&gt;edge + pVert1-&gt;iedge[i];</a>
<a name="ln5341">            v2 = pEdge1-&gt;neighbor12 ^ v1;</a>
<a name="ln5342">            if ( pBNS-&gt;vert[v2].type == type ) {</a>
<a name="ln5343">                return IS_FORBIDDEN(pEdge1-&gt;forbidden, pBNS)? NO_VERTEX : pVert1-&gt;iedge[i];</a>
<a name="ln5344">            }</a>
<a name="ln5345">            i --;</a>
<a name="ln5346">        }</a>
<a name="ln5347">        return NO_VERTEX; /* not found t-group */</a>
<a name="ln5348">    } else</a>
<a name="ln5349">    if ( v1 &lt; pBNS-&gt;num_vertices ) {</a>
<a name="ln5350">        return NO_VERTEX;</a>
<a name="ln5351">    }</a>
<a name="ln5352">    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln5353">}</a>
<a name="ln5354"> </a>
<a name="ln5355"> </a>
<a name="ln5356"> </a>
<a name="ln5357">/**********************************************************************************/</a>
<a name="ln5358">Vertex GetGroupVertex(BN_STRUCT *pBNS, Vertex v1, AT_NUMB type)</a>
<a name="ln5359">{</a>
<a name="ln5360">    if ( v1 &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln5361">        Vertex      v2;</a>
<a name="ln5362">        BNS_EDGE   *pEdge1;</a>
<a name="ln5363">        BNS_VERTEX *pVert1 = pBNS-&gt;vert+v1;</a>
<a name="ln5364">        int         i      = pVert1-&gt;num_adj_edges-1;</a>
<a name="ln5365"> </a>
<a name="ln5366">        AT_NUMB type2;</a>
<a name="ln5367"> </a>
<a name="ln5368">        if ( type == BNS_VERT_TYPE_ENDPOINT )</a>
<a name="ln5369">            type2 = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln5370">        else</a>
<a name="ln5371">        if ( type == BNS_VERT_TYPE_C_POINT )</a>
<a name="ln5372">            type2 = BNS_VERT_TYPE_C_GROUP;</a>
<a name="ln5373">        else</a>
<a name="ln5374">            type2 = 0;</a>
<a name="ln5375"> </a>
<a name="ln5376">        if ( (pVert1-&gt;type &amp; type) == type ) {</a>
<a name="ln5377">            while( 0 &lt;= i ) {</a>
<a name="ln5378">                pEdge1 = pBNS-&gt;edge + pVert1-&gt;iedge[i];</a>
<a name="ln5379">                v2 = pEdge1-&gt;neighbor12 ^ v1;</a>
<a name="ln5380">                if ( pBNS-&gt;vert[v2].type == type2 ) {</a>
<a name="ln5381">                    if ( IS_FORBIDDEN(pEdge1-&gt;forbidden, pBNS) ) {</a>
<a name="ln5382">                        return NO_VERTEX;</a>
<a name="ln5383">                    }</a>
<a name="ln5384">                    return v2;</a>
<a name="ln5385">                }</a>
<a name="ln5386">                i --;</a>
<a name="ln5387">            }</a>
<a name="ln5388">        }</a>
<a name="ln5389">        return BNS_BOND_ERR; /* not found t-group */</a>
<a name="ln5390"> </a>
<a name="ln5391">    } else</a>
<a name="ln5392">    if ( v1 &lt; pBNS-&gt;num_vertices ) {</a>
<a name="ln5393">        return NO_VERTEX;</a>
<a name="ln5394">    }</a>
<a name="ln5395">    return BNS_VERT_EDGE_OVFL;</a>
<a name="ln5396">}</a>
<a name="ln5397"> </a>
<a name="ln5398"> </a>
<a name="ln5399"> </a>
<a name="ln5400">/**********************************************************************************/</a>
<a name="ln5401">int bAddStCapToAVertex( BN_STRUCT *pBNS, Vertex v1, Vertex v2, VertexFlow *nOldCapVertSingleBond, int *nDots, int bAdjacentDonors )</a>
<a name="ln5402">{</a>
<a name="ln5403">        BNS_VERTEX *pVert1   = pBNS-&gt;vert + v1;</a>
<a name="ln5404">        BNS_VERTEX *pVert;</a>
<a name="ln5405">        BNS_EDGE   *pEdge;</a>
<a name="ln5406">        Vertex      v;</a>
<a name="ln5407">        int         i, n;</a>
<a name="ln5408">        VertexFlow  nNewCap;</a>
<a name="ln5409">        /* Change v1: increment its st-cap */</a>
<a name="ln5410">        n = 0;</a>
<a name="ln5411">        nOldCapVertSingleBond[n++] = pVert1-&gt;st_edge.cap;</a>
<a name="ln5412">        /*if ( pVert1-&gt;st_edge.cap == pVert1-&gt;st_edge.flow ) {*/</a>
<a name="ln5413">            pVert1-&gt;st_edge.cap ++;</a>
<a name="ln5414">            *nDots += 1;</a>
<a name="ln5415">        /*}*/</a>
<a name="ln5416">        /* increment caps of adjacent edges if </a>
<a name="ln5417">           (1) the neighbor has st-cap != 0 and </a>
<a name="ln5418">           (2) (edge cap==0) OR (nSumEdgeCap &lt; pVert1-&gt;st_edge.cap &amp;&amp; pVert-&gt;st_edge.flow &gt; pVert1-&gt;st_edge.cap)</a>
<a name="ln5419">        */</a>
<a name="ln5420">        if ( !(pVert1-&gt;type &amp; BNS_VERT_TYPE_ANY_GROUP) ) {</a>
<a name="ln5421">            /*</a>
<a name="ln5422">            AT_NUMB nSumEdgeCap = 0;</a>
<a name="ln5423">            for ( i = 0; i &lt; pVert1-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln5424">                pEdge = pBNS-&gt;edge + pVert1-&gt;iedge[i];</a>
<a name="ln5425">                nSumEdgeCap += pEdge-&gt;cap;</a>
<a name="ln5426">            }</a>
<a name="ln5427">            */</a>
<a name="ln5428">            /* do not increment caps of t-group or c-group edges */</a>
<a name="ln5429">            for ( i = 0; i &lt; pVert1-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln5430">                pEdge = pBNS-&gt;edge + pVert1-&gt;iedge[i];</a>
<a name="ln5431">                nOldCapVertSingleBond[n++] = pEdge-&gt;cap; /* save edge cap */</a>
<a name="ln5432">                v = pEdge-&gt;neighbor12 ^ v1;</a>
<a name="ln5433">                if ( v == v2 &amp;&amp; !bAdjacentDonors ) {</a>
<a name="ln5434">                    continue;</a>
<a name="ln5435">                }</a>
<a name="ln5436">                pVert = pBNS-&gt;vert + v;</a>
<a name="ln5437">                if ( pVert-&gt;type &amp; BNS_VERT_TYPE_ANY_GROUP )</a>
<a name="ln5438">                    continue;</a>
<a name="ln5439">                nNewCap = inchi_min(pVert-&gt;st_edge.cap, pVert1-&gt;st_edge.cap);</a>
<a name="ln5440">                nNewCap = inchi_min(nNewCap, MAX_BOND_EDGE_CAP);</a>
<a name="ln5441">                pEdge-&gt;cap = nNewCap; /* change edge cap */</a>
<a name="ln5442">                /*</a>
<a name="ln5443">                if ( pVert-&gt;st_edge.cap &gt; 0 &amp;&amp; !pEdge-&gt;cap ) {</a>
<a name="ln5444">                    pEdge-&gt;cap ++;</a>
<a name="ln5445">                } else</a>
<a name="ln5446">                if ( pVert-&gt;st_edge.flow &gt; pVert1-&gt;st_edge.cap &amp;&amp;</a>
<a name="ln5447">                     pEdge-&gt;cap &lt; MAX_BOND_EDGE_CAP &amp;&amp;</a>
<a name="ln5448">                     nSumEdgeCap &lt; pVert1-&gt;st_edge.cap ) {</a>
<a name="ln5449">                    pEdge-&gt;cap ++;</a>
<a name="ln5450">                }</a>
<a name="ln5451">                */</a>
<a name="ln5452">            }</a>
<a name="ln5453">        }</a>
<a name="ln5454"> </a>
<a name="ln5455">        return n; /* number of elements in nOldCapVertSingleBond[*] */</a>
<a name="ln5456">}</a>
<a name="ln5457"> </a>
<a name="ln5458"> </a>
<a name="ln5459"> </a>
<a name="ln5460">/**********************************************************************************/</a>
<a name="ln5461"> </a>
<a name="ln5462">#define BNS_CHK_ALTP_NO_ALTPATH  0</a>
<a name="ln5463">#define BNS_CHK_ALTP_SAME_TGROUP 1</a>
<a name="ln5464">#define BNS_CHK_ALTP_SAME_VERTEX 2</a>
<a name="ln5465">#define BNS_CHK_ALTP_SET_SUCCESS 4</a>
<a name="ln5466"> </a>
<a name="ln5467"> </a>
<a name="ln5468"> </a>
<a name="ln5469">/**********************************************************************************/</a>
<a name="ln5470">int bSetBnsToCheckAltPath( BN_STRUCT *pBNS, int nVertDoubleBond, int nVertSingleBond, AT_NUMB type, </a>
<a name="ln5471">                           int path_type, ALT_PATH_CHANGES *apc, BNS_FLOW_CHANGES *fcd, int *nDots )</a>
<a name="ln5472">{</a>
<a name="ln5473">    </a>
<a name="ln5474">    if ( !pBNS-&gt;vert[nVertDoubleBond].st_edge.flow &amp;&amp;</a>
<a name="ln5475">        </a>
<a name="ln5476">         !( path_type == ALT_PATH_MODE_REM2H_CHG ||</a>
<a name="ln5477">            path_type == ALT_PATH_MODE_ADD2H_CHG ||</a>
<a name="ln5478">            path_type == ALT_PATH_MODE_REM2H_TST ||</a>
<a name="ln5479">            path_type == ALT_PATH_MODE_ADD2H_TST )</a>
<a name="ln5480">        ) {</a>
<a name="ln5481">        return BNS_CHK_ALTP_NO_ALTPATH;</a>
<a name="ln5482">    } else {</a>
<a name="ln5483">        </a>
<a name="ln5484">        </a>
<a name="ln5485">        Vertex      vNew;</a>
<a name="ln5486">        Vertex      v1       = nVertSingleBond;</a>
<a name="ln5487">        Vertex      v2       = nVertDoubleBond;</a>
<a name="ln5488"> </a>
<a name="ln5489">        BNS_VERTEX *pVert1   = pBNS-&gt;vert + v1;</a>
<a name="ln5490">        BNS_VERTEX *pVert2   = pBNS-&gt;vert + v2;</a>
<a name="ln5491">        int n, bAdjacentDonors = 0;</a>
<a name="ln5492">        int ifcd = 0;</a>
<a name="ln5493">        </a>
<a name="ln5494">        Vertex     t1=NO_VERTEX;</a>
<a name="ln5495">        Vertex     t2=NO_VERTEX;</a>
<a name="ln5496">        int        iapc;</a>
<a name="ln5497"> </a>
<a name="ln5498">/*#if ( TEST_REMOVE_S_ATOMS == 1 )*/ /* &amp;&amp; ALT_PATH_MODE_4_SALT == path_type */</a>
<a name="ln5499">        if ( ( *pBNS-&gt;pbTautFlags &amp; TG_FLAG_TEST_TAUT2_SALTS ) &amp;&amp;</a>
<a name="ln5500"> </a>
<a name="ln5501">             ALT_PATH_MODE_4_SALT2   == path_type &amp;&amp;</a>
<a name="ln5502">             (BNS_VERT_TYPE_ENDPOINT &amp; type)      ) {</a>
<a name="ln5503"> </a>
<a name="ln5504">/*</a>
<a name="ln5505">---------------------------------------------------------</a>
<a name="ln5506">     \   action |  DB action (v2)   |   SB action (v1)  |</a>
<a name="ln5507">vertex \        | accept H @ vertex | donate H @ vertex |</a>
<a name="ln5508">type     \      | nVertDoubleBond   | nVertSingleBond   |</a>
<a name="ln5509">----------------+-------------------+-------------------+                 </a>
<a name="ln5510">    -ZH (v1)    |  error            |   -ZH(.)          |</a>
<a name="ln5511">(cap&gt;0 on edge  |                   |   increment       |</a>
<a name="ln5512"> except v1-v2)  |                   |   st-cap on Z     |</a>
<a name="ln5513">----------------+-------------------+-------------------+                 </a>
<a name="ln5514">    =Z  (v2)    |  =Z-(.)           |   error           |</a>
<a name="ln5515">  (st-flow&gt;0)   |  add fict vertex  |                   |</a>
<a name="ln5516">                |  with st-cap=1    |                   |</a>
<a name="ln5517">----------------+-------------------+-------------------+                 </a>
<a name="ln5518">  endpoint      |  T(.)             |   T-(.)           |</a>
<a name="ln5519">  of t-group    |  increment        |   add fict vertex |</a>
<a name="ln5520">  represented   |  st-cap on T      |   with st-cap=1   |</a>
<a name="ln5521">  by fictitious |                   |                   |</a>
<a name="ln5522">  vertex T      |                   |                   |</a>
<a name="ln5523">---------------------------------------------------------              </a>
<a name="ln5524">*/</a>
<a name="ln5525"> </a>
<a name="ln5526">            int         bSet_v1;  /* indicator: v1 has been set */</a>
<a name="ln5527">            int         bSet_v2;  /* indicator: v2 has been set */</a>
<a name="ln5528">            int         i;</a>
<a name="ln5529"> </a>
<a name="ln5530">            Vertex      v1t      = NO_VERTEX;</a>
<a name="ln5531">            Vertex      v2t      = NO_VERTEX;</a>
<a name="ln5532">            Vertex      v1Act, v2Act;</a>
<a name="ln5533">            Vertex      v;</a>
<a name="ln5534"> </a>
<a name="ln5535">            memset( apc, 0, sizeof(*apc) );</a>
<a name="ln5536">            fcd[ifcd].iedge = NO_VERTEX;</a>
<a name="ln5537">            *nDots = 0;</a>
<a name="ln5538"> </a>
<a name="ln5539">            if ( v1 == v2 ) {</a>
<a name="ln5540">                return BNS_CHK_ALTP_SAME_VERTEX;</a>
<a name="ln5541">            }</a>
<a name="ln5542"> </a>
<a name="ln5543">            /* check whether v1 has neighbors adjacent to </a>
<a name="ln5544">               multiple bonds</a>
<a name="ln5545">            */</a>
<a name="ln5546">            for ( i = 0, n = 0; i &lt; pVert1-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln5547">                v = (pBNS-&gt;edge + pVert1-&gt;iedge[i])-&gt;neighbor12 ^ v1; /* v is adjacent to v1 */</a>
<a name="ln5548">                if ( v == v2 )</a>
<a name="ln5549">                    continue; /* ignore connection to v2 */</a>
<a name="ln5550">                n += (pBNS-&gt;vert[v].st_edge.cap &gt; 0);</a>
<a name="ln5551">            }</a>
<a name="ln5552">            if ( !n ) {</a>
<a name="ln5553">                return BNS_CHK_ALTP_NO_ALTPATH; /* the vertex cannot have flow */</a>
<a name="ln5554">            }</a>
<a name="ln5555"> </a>
<a name="ln5556">            v1Act = v1;</a>
<a name="ln5557">            v2Act = v2;</a>
<a name="ln5558">        </a>
<a name="ln5559">            /* find t-group that contains v1 */</a>
<a name="ln5560">            if ( (pVert1-&gt;type &amp; type) == type ) {</a>
<a name="ln5561">                v1t = GetGroupVertex(pBNS, v1, type);</a>
<a name="ln5562">                if ( IS_BNS_ERROR( v1t ) ) {</a>
<a name="ln5563">                    return v1t;</a>
<a name="ln5564">                }</a>
<a name="ln5565">                if ( v1t != NO_VERTEX ) {</a>
<a name="ln5566">                    v1Act = v1t;</a>
<a name="ln5567">                }</a>
<a name="ln5568">            }</a>
<a name="ln5569">            /* find t-group that contains v2 */</a>
<a name="ln5570">            if ( (pVert2-&gt;type &amp; type) == type ) {</a>
<a name="ln5571">                v2t = GetGroupVertex(pBNS, v2, type);</a>
<a name="ln5572">                if ( IS_BNS_ERROR( v2t ) ) {</a>
<a name="ln5573">                    return v2t;</a>
<a name="ln5574">                }</a>
<a name="ln5575">                if ( v2t != NO_VERTEX ) {</a>
<a name="ln5576">                    v2Act = v2t;</a>
<a name="ln5577">                }</a>
<a name="ln5578">            }</a>
<a name="ln5579">            if ( v1t != NO_VERTEX &amp;&amp; v1t == v2t ) {</a>
<a name="ln5580">                return BNS_CHK_ALTP_SAME_TGROUP;</a>
<a name="ln5581">            }</a>
<a name="ln5582">        </a>
<a name="ln5583">            bSet_v1 = bSet_v2 = 0;</a>
<a name="ln5584">            /* create new edges adjacent to v1t or v2 */</a>
<a name="ln5585">            iapc = 0;</a>
<a name="ln5586">            if ( v1t != NO_VERTEX ) {</a>
<a name="ln5587">                /* create new edge and vertex, connect to v1t */</a>
<a name="ln5588">                vNew = bAddNewVertex( pBNS, v1t, 1, 0, 1, nDots );</a>
<a name="ln5589">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5590">                    return vNew;</a>
<a name="ln5591">                }</a>
<a name="ln5592">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5593">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5594">                bSet_v1 = 1;</a>
<a name="ln5595">                iapc ++;</a>
<a name="ln5596">            }</a>
<a name="ln5597">            if ( v2t == NO_VERTEX ) {</a>
<a name="ln5598">                /* create new edge and vertex, connect to v2 */</a>
<a name="ln5599">                vNew = bAddNewVertex( pBNS, v2, 1, 0, 1, nDots );</a>
<a name="ln5600">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5601">                    return vNew;</a>
<a name="ln5602">                }</a>
<a name="ln5603">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5604">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5605">                bSet_v2 = 1;</a>
<a name="ln5606">                iapc ++;</a>
<a name="ln5607">            }</a>
<a name="ln5608"> </a>
<a name="ln5609">            /* add st-cap to v1 and/or v2t */</a>
<a name="ln5610">            iapc = 0;</a>
<a name="ln5611">            if ( !bSet_v1 ) {</a>
<a name="ln5612">                /* add st-cap to v1 */</a>
<a name="ln5613">                if ( v1t != NO_VERTEX ) {</a>
<a name="ln5614">                    return BNS_BOND_ERR;</a>
<a name="ln5615">                }</a>
<a name="ln5616">                n = bAddStCapToAVertex( pBNS, v1, v2Act, apc-&gt;nOldCapsVert[iapc], nDots, 0 );</a>
<a name="ln5617">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5618">                apc-&gt;vOldVert[iapc]        = v1;</a>
<a name="ln5619">                iapc ++;</a>
<a name="ln5620">            }</a>
<a name="ln5621">            if ( !bSet_v2 ) {</a>
<a name="ln5622">                /* add st-cap to v2t */</a>
<a name="ln5623">                if ( v2t == NO_VERTEX ) {</a>
<a name="ln5624">                    return BNS_BOND_ERR;</a>
<a name="ln5625">                }</a>
<a name="ln5626">                n = bAddStCapToAVertex( pBNS, v2t, v1Act, apc-&gt;nOldCapsVert[iapc], nDots, 0 );</a>
<a name="ln5627">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5628">                apc-&gt;vOldVert[iapc]        = v2t;</a>
<a name="ln5629">                iapc ++;</a>
<a name="ln5630">            }</a>
<a name="ln5631">            if ( *nDots &lt; 0 || *nDots %2 ) {</a>
<a name="ln5632">                return BNS_SET_ALTP_ERR;</a>
<a name="ln5633">            }</a>
<a name="ln5634">            return BNS_CHK_ALTP_SET_SUCCESS;</a>
<a name="ln5635"> </a>
<a name="ln5636">        }</a>
<a name="ln5637">        /* ( *pBNS-&gt;pbTautFlags &amp; TG_FLAG_TEST_TAUT2_SALTS ) */</a>
<a name="ln5638">/*#endif*/ /*  ( TEST_REMOVE_S_ATOMS == 1 &amp;&amp; ALT_PATH_MODE_4_SALT == path_type ) */</a>
<a name="ln5639">        /*****************************************************************/</a>
<a name="ln5640">        if ( path_type == ALT_PATH_MODE_REM2H_CHG ||</a>
<a name="ln5641">             path_type == ALT_PATH_MODE_ADD2H_CHG ||</a>
<a name="ln5642">             path_type == ALT_PATH_MODE_REM2H_TST ||</a>
<a name="ln5643">             path_type == ALT_PATH_MODE_ADD2H_TST ) { /* added 2004-03-18 */</a>
<a name="ln5644">            </a>
<a name="ln5645">            int bDonors = (path_type == ALT_PATH_MODE_REM2H_CHG) || (path_type == ALT_PATH_MODE_REM2H_TST);</a>
<a name="ln5646"> </a>
<a name="ln5647">            int         bSet_v1;  /* indicator: v1 has been set */</a>
<a name="ln5648">            int         bSet_v2;  /* indicator: v2 has been set */</a>
<a name="ln5649">            int         i, cap = 1;</a>
<a name="ln5650"> </a>
<a name="ln5651">            Vertex      v1t      = NO_VERTEX;</a>
<a name="ln5652">            Vertex      v2t      = NO_VERTEX;</a>
<a name="ln5653">            Vertex      v1Act, v2Act;</a>
<a name="ln5654">            Vertex      v;</a>
<a name="ln5655"> </a>
<a name="ln5656">            memset( apc, 0, sizeof(*apc) );</a>
<a name="ln5657">            fcd[ifcd].iedge = NO_VERTEX;</a>
<a name="ln5658">            *nDots = 0;</a>
<a name="ln5659">            /*</a>
<a name="ln5660">            if ( v1 == v2 ) {</a>
<a name="ln5661">                return BNS_CHK_ALTP_SAME_VERTEX;</a>
<a name="ln5662">            }</a>
<a name="ln5663">            */</a>
<a name="ln5664">            /* check whether v1 and v2 have proper neighbors  */</a>
<a name="ln5665">            for ( i = 0, n = bAdjacentDonors = 0; i &lt; pVert1-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln5666">                v = (pBNS-&gt;edge + pVert1-&gt;iedge[i])-&gt;neighbor12 ^ v1; /* v is adjacent to v1 */</a>
<a name="ln5667">                /* do not ignore connection to v2</a>
<a name="ln5668">                if ( v == v2 )</a>
<a name="ln5669">                    continue;</a>
<a name="ln5670">                */</a>
<a name="ln5671">                n += bDonors ? (pBNS-&gt;vert[v].st_edge.cap &gt; 0) : ((pBNS-&gt;edge + pVert1-&gt;iedge[i])-&gt;flow &gt; 0);</a>
<a name="ln5672">                bAdjacentDonors += bDonors ? (v == v2) &amp;&amp; ((pBNS-&gt;edge + pVert1-&gt;iedge[i])-&gt;flow &lt; MAX_BOND_EDGE_CAP) : 0;</a>
<a name="ln5673">                     /* two donors connected by a single or double bond */ </a>
<a name="ln5674">            }</a>
<a name="ln5675">            if ( !n &amp;&amp; !bAdjacentDonors ) {</a>
<a name="ln5676">                return BNS_CHK_ALTP_NO_ALTPATH; /* the vertex cannot have flow */</a>
<a name="ln5677">            }</a>
<a name="ln5678">            for ( i = 0, n = bAdjacentDonors = 0; i &lt; pVert2-&gt;num_adj_edges; i ++ ) {</a>
<a name="ln5679">                v = (pBNS-&gt;edge + pVert2-&gt;iedge[i])-&gt;neighbor12 ^ v2; /* v is adjacent to v2 */</a>
<a name="ln5680">                /* do not ignore connection to v1</a>
<a name="ln5681">                if ( v == v1 )</a>
<a name="ln5682">                    continue;</a>
<a name="ln5683">                 */</a>
<a name="ln5684">                n += bDonors ? (pBNS-&gt;vert[v].st_edge.cap &gt; 0) : ((pBNS-&gt;edge + pVert2-&gt;iedge[i])-&gt;flow &gt; 0);</a>
<a name="ln5685">                bAdjacentDonors += bDonors ? (v == v1) &amp;&amp; ((pBNS-&gt;edge + pVert2-&gt;iedge[i])-&gt;flow &lt; MAX_BOND_EDGE_CAP ) : 0;</a>
<a name="ln5686">                     /* two donors connected by a single or double bond */</a>
<a name="ln5687">            }</a>
<a name="ln5688">            if ( !n &amp;&amp; !bAdjacentDonors ) {</a>
<a name="ln5689">                return BNS_CHK_ALTP_NO_ALTPATH; /* the vertex cannot have flow */</a>
<a name="ln5690">            }</a>
<a name="ln5691"> </a>
<a name="ln5692">            v1Act = v1;</a>
<a name="ln5693">            v2Act = v2;</a>
<a name="ln5694">        </a>
<a name="ln5695">            /* find t-group that contains v1 */</a>
<a name="ln5696">            if ( (pVert1-&gt;type &amp; type) == type ) {</a>
<a name="ln5697">                v1t = GetGroupVertex(pBNS, v1, type);</a>
<a name="ln5698">                if ( BNS_BOND_ERR == v1t ) {</a>
<a name="ln5699">                    v1t = NO_VERTEX;</a>
<a name="ln5700">                } else</a>
<a name="ln5701">                if ( IS_BNS_ERROR( v1t ) ) {</a>
<a name="ln5702">                    return v1t;</a>
<a name="ln5703">                } else</a>
<a name="ln5704">                if ( v1t != NO_VERTEX ) {</a>
<a name="ln5705">                    v1Act = v1t;</a>
<a name="ln5706">                }</a>
<a name="ln5707">            }</a>
<a name="ln5708">            /* find t-group that contains v2 */</a>
<a name="ln5709">            if ( (pVert2-&gt;type &amp; type) == type ) {</a>
<a name="ln5710">                v2t = GetGroupVertex(pBNS, v2, type);</a>
<a name="ln5711">                if ( BNS_BOND_ERR == v2t ) {</a>
<a name="ln5712">                    v2t = NO_VERTEX;</a>
<a name="ln5713">                } else</a>
<a name="ln5714">                if ( IS_BNS_ERROR( v2t ) ) {</a>
<a name="ln5715">                    return v2t;</a>
<a name="ln5716">                } else</a>
<a name="ln5717">                if ( v2t != NO_VERTEX ) {</a>
<a name="ln5718">                    v2Act = v2t;</a>
<a name="ln5719">                }</a>
<a name="ln5720">            }</a>
<a name="ln5721">            </a>
<a name="ln5722">            if ( v1t != NO_VERTEX &amp;&amp; v1t == v2t ) {</a>
<a name="ln5723">                cap = 2; /* same t-group */</a>
<a name="ln5724">            }</a>
<a name="ln5725">            </a>
<a name="ln5726">            /*  bAddNewVertex: (bDonors != 0) == (vit != NO_VERTEX), i=1,2 */</a>
<a name="ln5727">            bSet_v1 = bSet_v2 = 0;</a>
<a name="ln5728">            /* create new edges adjacent to v1t or v2 */</a>
<a name="ln5729">            iapc = 0;</a>
<a name="ln5730">            if ( (bDonors != 0) == (v1t != NO_VERTEX) ) {</a>
<a name="ln5731">                /* create new edge and vertex, connect to v1Act */</a>
<a name="ln5732">                vNew = bAddNewVertex( pBNS, v1Act, cap, 0, 1, nDots );</a>
<a name="ln5733">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5734">                    return vNew;</a>
<a name="ln5735">                }</a>
<a name="ln5736">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5737">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5738">                bSet_v1 = 1;</a>
<a name="ln5739">                iapc ++;</a>
<a name="ln5740">            }</a>
<a name="ln5741">            if ( (bDonors != 0) == (v2t != NO_VERTEX) &amp;&amp; cap == 1 ) {</a>
<a name="ln5742">                /* create new edge and vertex, connect to v2Act; do not do it if cap==2 */</a>
<a name="ln5743">                vNew = bAddNewVertex( pBNS, v2Act, cap, 0, 1, nDots );</a>
<a name="ln5744">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5745">                    return vNew;</a>
<a name="ln5746">                }</a>
<a name="ln5747">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5748">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5749">                bSet_v2 = 1;</a>
<a name="ln5750">                iapc ++;</a>
<a name="ln5751">            } else</a>
<a name="ln5752">            if ( (bDonors != 0) == (v2t != NO_VERTEX) ) {</a>
<a name="ln5753">                bSet_v2 = 1;</a>
<a name="ln5754">            }</a>
<a name="ln5755"> </a>
<a name="ln5756">            /* add st-cap to v1 and/or v2t */</a>
<a name="ln5757">            iapc = 0;</a>
<a name="ln5758">            /* if cap=2 then just increment st_cap 2 times */</a>
<a name="ln5759">            if ( !bSet_v1 ) {</a>
<a name="ln5760">                /* add st-cap to v1 */</a>
<a name="ln5761">                if ( (bDonors != 0) == (v1t != NO_VERTEX) ) {</a>
<a name="ln5762">                    return BNS_BOND_ERR;</a>
<a name="ln5763">                }</a>
<a name="ln5764">                n = bAddStCapToAVertex( pBNS, v1Act, v2Act, apc-&gt;nOldCapsVert[iapc], nDots, bAdjacentDonors );</a>
<a name="ln5765">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5766">                apc-&gt;vOldVert[iapc]        = v1Act;</a>
<a name="ln5767">                iapc ++;</a>
<a name="ln5768">            }</a>
<a name="ln5769">            if ( !bSet_v2 ) {</a>
<a name="ln5770">                /* add st-cap to v2t */</a>
<a name="ln5771">                if ( (bDonors != 0) == (v2t != NO_VERTEX) ) {</a>
<a name="ln5772">                    return BNS_BOND_ERR;</a>
<a name="ln5773">                }</a>
<a name="ln5774">                n = bAddStCapToAVertex( pBNS, v2Act, v1Act, apc-&gt;nOldCapsVert[iapc], nDots, bAdjacentDonors );</a>
<a name="ln5775">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5776">                apc-&gt;vOldVert[iapc]        = v2Act;</a>
<a name="ln5777">                iapc ++;</a>
<a name="ln5778">            }</a>
<a name="ln5779">            if ( *nDots &lt; 0 || *nDots %2 ) {</a>
<a name="ln5780">                return BNS_SET_ALTP_ERR;</a>
<a name="ln5781">            }</a>
<a name="ln5782">            return BNS_CHK_ALTP_SET_SUCCESS;</a>
<a name="ln5783"> </a>
<a name="ln5784">        }</a>
<a name="ln5785">        /**************************************************************************/</a>
<a name="ln5786">        if ( path_type == ALT_PATH_MODE_REM_PROTON ) { /* added 2004-03-05 */</a>
<a name="ln5787">            if ( v1 &gt;= 0 &amp;&amp; v2 &gt;= 0 &amp;&amp; </a>
<a name="ln5788">                 (pVert1-&gt;type &amp; BNS_VERT_TYPE_ANY_GROUP) &amp;&amp;</a>
<a name="ln5789">                 (pVert2-&gt;type &amp; BNS_VERT_TYPE_ANY_GROUP) ) {</a>
<a name="ln5790">                /* create new edge and vertex, connect to v2 */</a>
<a name="ln5791">                if ( (pBNS-&gt;vert[v1].type &amp; BNS_VERT_TYPE_C_GROUP) &amp;&amp;</a>
<a name="ln5792">                     (pBNS-&gt;vert[v1].st_edge.flow == 2*pBNS-&gt;vert[v1].num_adj_edges ) ) {</a>
<a name="ln5793">                    /* so far in a charge group max edge flow = 1 2004-03-08 */</a>
<a name="ln5794">                    return BNS_CHK_ALTP_NO_ALTPATH;</a>
<a name="ln5795">                }</a>
<a name="ln5796">                memset( apc, 0, sizeof(*apc) );</a>
<a name="ln5797">                fcd[ifcd].iedge = NO_VERTEX;</a>
<a name="ln5798">                *nDots = 0;</a>
<a name="ln5799">                iapc = 0;</a>
<a name="ln5800"> </a>
<a name="ln5801">                vNew = bAddNewVertex( pBNS, v2, 1, 0, 1, nDots );</a>
<a name="ln5802">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5803">                    return vNew;</a>
<a name="ln5804">                }</a>
<a name="ln5805">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5806">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5807">                /*iapc ++;*/</a>
<a name="ln5808">                /* add st-cap (dot) to v1 */</a>
<a name="ln5809">                n = bAddStCapToAVertex( pBNS, v1, v2, apc-&gt;nOldCapsVert[iapc], nDots, 0 );</a>
<a name="ln5810">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5811">                apc-&gt;vOldVert[iapc]        = v1;</a>
<a name="ln5812">                iapc ++;</a>
<a name="ln5813">                return BNS_CHK_ALTP_SET_SUCCESS;</a>
<a name="ln5814">            }</a>
<a name="ln5815">        }</a>
<a name="ln5816"> </a>
<a name="ln5817">#if ( NEUTRALIZE_ENDPOINTS == 1 ) /* { */</a>
<a name="ln5818"> </a>
<a name="ln5819"> </a>
<a name="ln5820">        *nDots = 0;</a>
<a name="ln5821">        memset( apc, 0, sizeof(*apc) );</a>
<a name="ln5822">        fcd[ifcd].iedge = NO_VERTEX;</a>
<a name="ln5823"> </a>
<a name="ln5824">        if ( type &amp; BNS_VERT_TYPE_ENDPOINT ) {</a>
<a name="ln5825">            BNS_IEDGE  iedge;</a>
<a name="ln5826">            AT_NUMB    type2;</a>
<a name="ln5827">            int ret2;</a>
<a name="ln5828">            /* prohibit charge movement */</a>
<a name="ln5829">            type2 =  BNS_VERT_TYPE_C_GROUP;</a>
<a name="ln5830">            iedge = GetEdgeToGroupVertex( pBNS, v1, type2 );</a>
<a name="ln5831">            if (iedge != NO_VERTEX ) {</a>
<a name="ln5832">                /*  set flow=1 on an edge to a c-group vertex to make sure there is no positive charge</a>
<a name="ln5833">                 *  when moving tautomeric H-atoms</a>
<a name="ln5834">                 */</a>
<a name="ln5835">                ret2 = bSetFlowToCheckOneBond( pBNS, iedge, 1, fcd+ifcd );</a>
<a name="ln5836">                if ( IS_BNS_ERROR(ret2) ) {</a>
<a name="ln5837">                    return ret2;</a>
<a name="ln5838">                }</a>
<a name="ln5839">                *nDots += ret2;</a>
<a name="ln5840">                while ( fcd[ifcd].iedge != NO_VERTEX ) {</a>
<a name="ln5841">                    ifcd ++;</a>
<a name="ln5842">                }</a>
<a name="ln5843">            }</a>
<a name="ln5844">            iedge = GetEdgeToGroupVertex( pBNS, v2, type2 );</a>
<a name="ln5845">            if (iedge != NO_VERTEX ) {</a>
<a name="ln5846">                /*  set flow=1 on an edge to a c-group vertex to make sure there is no positive charge</a>
<a name="ln5847">                 *  when moving tautomeric H-atoms</a>
<a name="ln5848">                 */</a>
<a name="ln5849">                ret2 = bSetFlowToCheckOneBond( pBNS, iedge, 1, fcd+ifcd );</a>
<a name="ln5850">                if ( IS_BNS_ERROR(ret2) ) {</a>
<a name="ln5851">                    return ret2;</a>
<a name="ln5852">                }</a>
<a name="ln5853">                *nDots += ret2;</a>
<a name="ln5854">                while ( fcd[ifcd].iedge != NO_VERTEX ) {</a>
<a name="ln5855">                    ifcd ++;</a>
<a name="ln5856">                }</a>
<a name="ln5857">            }</a>
<a name="ln5858">            /* set hydrogen counts */</a>
<a name="ln5859">            type2 = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln5860">            iedge = GetEdgeToGroupVertex( pBNS, v1, type2 );</a>
<a name="ln5861">            if (iedge != NO_VERTEX ) {</a>
<a name="ln5862">                /*  set flow=1 on an edge to a t-group vertex to make sure there is</a>
<a name="ln5863">                 *  a moveable hydrogen atom or (-) on v1 when moving tautomeric H-atoms</a>
<a name="ln5864">                 */</a>
<a name="ln5865">#if ( FIX_H_CHECKING_TAUT == 1 )</a>
<a name="ln5866">                ret2 = bSetFlowToCheckOneBond( pBNS, iedge, 1, fcd+ifcd );</a>
<a name="ln5867">                if ( IS_BNS_ERROR(ret2) ) {</a>
<a name="ln5868">                    return ret2;</a>
<a name="ln5869">                }</a>
<a name="ln5870">                *nDots += ret2;</a>
<a name="ln5871">                while ( fcd[ifcd].iedge != NO_VERTEX ) {</a>
<a name="ln5872">                    ifcd ++;</a>
<a name="ln5873">                }</a>
<a name="ln5874">#else</a>
<a name="ln5875">                t1 = pBNS-&gt;edge[iedge].neighbor12 ^ v1;</a>
<a name="ln5876">#endif</a>
<a name="ln5877">            }</a>
<a name="ln5878">            iedge = GetEdgeToGroupVertex( pBNS, v2, type2 );</a>
<a name="ln5879">            if (iedge != NO_VERTEX ) {</a>
<a name="ln5880">                /*  set flow=0 on an edge to a t-group vertex to make sure there is</a>
<a name="ln5881">                 *  no moveable hydrogen atom or (-) on v2 when moving tautomeric H-atoms</a>
<a name="ln5882">                 */</a>
<a name="ln5883">#if ( FIX_H_CHECKING_TAUT == 1 )</a>
<a name="ln5884">                ret2 = bSetFlowToCheckOneBond( pBNS, iedge, 0, fcd+ifcd );</a>
<a name="ln5885">                if ( IS_BNS_ERROR(ret2) ) {</a>
<a name="ln5886">                    return ret2;</a>
<a name="ln5887">                }</a>
<a name="ln5888">                *nDots += ret2;</a>
<a name="ln5889">                while ( fcd[ifcd].iedge != NO_VERTEX ) {</a>
<a name="ln5890">                    ifcd ++;</a>
<a name="ln5891">                }</a>
<a name="ln5892">#else</a>
<a name="ln5893">                t2 = pBNS-&gt;edge[iedge].neighbor12 ^ v2;</a>
<a name="ln5894">#endif</a>
<a name="ln5895">            }</a>
<a name="ln5896"> </a>
<a name="ln5897">#if ( FIX_H_CHECKING_TAUT == 1 )</a>
<a name="ln5898">#else</a>
<a name="ln5899">            if ( t1 == t2 &amp;&amp; t1 != NO_VERTEX ) {</a>
<a name="ln5900">                return BNS_CHK_ALTP_SAME_TGROUP;</a>
<a name="ln5901">            }</a>
<a name="ln5902">#endif</a>
<a name="ln5903">            iapc = 0;</a>
<a name="ln5904">            /* create new edge and vertex with cap=1 at v2 and/or t1 */</a>
<a name="ln5905">            if ( t1 != NO_VERTEX ) {</a>
<a name="ln5906">                /* create new edge and vertex, connect to t1 */</a>
<a name="ln5907">                vNew = bAddNewVertex( pBNS, t1, 1/*cap*/, 0/*flow*/, 1/*max_adj_edges*/, nDots );</a>
<a name="ln5908">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5909">                    return vNew;</a>
<a name="ln5910">                }</a>
<a name="ln5911">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5912">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5913">                iapc ++;</a>
<a name="ln5914">            }</a>
<a name="ln5915">            if ( t2 == NO_VERTEX ) {</a>
<a name="ln5916">                /* create new edge and vertex, connect to v2 */</a>
<a name="ln5917">                vNew = bAddNewVertex( pBNS, v2, 1/*cap*/, 0/*flow*/, 1/*max_adj_edges*/, nDots );</a>
<a name="ln5918">                if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5919">                    return vNew;</a>
<a name="ln5920">                }</a>
<a name="ln5921">                apc-&gt;vNewVertex[iapc] = vNew;</a>
<a name="ln5922">                apc-&gt;bSetNew[iapc]    = 1;</a>
<a name="ln5923">                iapc ++;</a>
<a name="ln5924">            }</a>
<a name="ln5925"> </a>
<a name="ln5926">            /* add st-cap to v1 and/or v2t */</a>
<a name="ln5927">            iapc = 0;</a>
<a name="ln5928">            if ( t1 == NO_VERTEX ) {</a>
<a name="ln5929">                /* add st-cap to v1 */</a>
<a name="ln5930">                n = bAddStCapToAVertex( pBNS, v1, (Vertex)(t2 == NO_VERTEX? v2:t2), apc-&gt;nOldCapsVert[iapc], nDots, 0 );</a>
<a name="ln5931">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5932">                apc-&gt;vOldVert[iapc]        = v1;</a>
<a name="ln5933">                iapc ++;</a>
<a name="ln5934">            }</a>
<a name="ln5935">            if ( t2 != NO_VERTEX ) {</a>
<a name="ln5936">                /* add st-cap to t2 */</a>
<a name="ln5937">                n = bAddStCapToAVertex( pBNS, t2, (Vertex)(t1 == NO_VERTEX? v1:t1), apc-&gt;nOldCapsVert[iapc], nDots, 0 );</a>
<a name="ln5938">                apc-&gt;bSetOldCapsVert[iapc] = n;</a>
<a name="ln5939">                apc-&gt;vOldVert[iapc]        = t2;</a>
<a name="ln5940">                iapc ++;</a>
<a name="ln5941">            }</a>
<a name="ln5942">        } else {</a>
<a name="ln5943">            /* create new edge and vertex, connect to v2 */</a>
<a name="ln5944">            vNew = bAddNewVertex( pBNS, v2, 1 /* cap*/, 0 /* flow */, 1 /* max_adj_edges */, nDots );</a>
<a name="ln5945">            if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5946">                return vNew;</a>
<a name="ln5947">            }</a>
<a name="ln5948">            apc-&gt;vNewVertex[0] = vNew;</a>
<a name="ln5949">            apc-&gt;bSetNew[0]    = 1;</a>
<a name="ln5950"> </a>
<a name="ln5951">            /* add st-cap to v1 */</a>
<a name="ln5952">            n = bAddStCapToAVertex( pBNS, v1, v2, apc-&gt;nOldCapsVert[0], nDots, 0 );</a>
<a name="ln5953">            apc-&gt;bSetOldCapsVert[0] = n;</a>
<a name="ln5954">            apc-&gt;vOldVert[0]        = v1;</a>
<a name="ln5955">        }</a>
<a name="ln5956">#else  /* } NEUTRALIZE_ENDPOINTS == 0 {*/</a>
<a name="ln5957"> </a>
<a name="ln5958">        *nDots = 0;</a>
<a name="ln5959">        memset( apc, 0, sizeof(*apc) );</a>
<a name="ln5960">        fcd[ifcd].iedge = NO_VERTEX;</a>
<a name="ln5961"> </a>
<a name="ln5962">        /* create new edge and vertex, connect to v2 */</a>
<a name="ln5963">        vNew = bAddNewVertex( pBNS, v2, 1 /* cap*/, 0 /* flow */, 1 /* max_adj_edges */, nDots, 0 );</a>
<a name="ln5964">        if ( IS_BNS_ERROR(vNew) ) {</a>
<a name="ln5965">            return vNew;</a>
<a name="ln5966">        }</a>
<a name="ln5967">        apc-&gt;vNewVertex[0] = vNew;</a>
<a name="ln5968">        apc-&gt;bSetNew[0]    = 1;</a>
<a name="ln5969"> </a>
<a name="ln5970">        /* add st-cap to v1 */</a>
<a name="ln5971">        n = bAddStCapToAVertex( pBNS, v1, v2, apc-&gt;nOldCapsVert[0], nDots );</a>
<a name="ln5972">        apc-&gt;bSetOldCapsVert[0] = n;</a>
<a name="ln5973">        apc-&gt;vOldVert[0]        = v1;</a>
<a name="ln5974">#endif /* } NEUTRALIZE_ENDPOINTS */</a>
<a name="ln5975"> </a>
<a name="ln5976">        if ( *nDots &lt; 0 || *nDots %2 ) {</a>
<a name="ln5977">            return BNS_SET_ALTP_ERR;</a>
<a name="ln5978">        }</a>
<a name="ln5979">        return BNS_CHK_ALTP_SET_SUCCESS;</a>
<a name="ln5980">    }</a>
<a name="ln5981">    /*return BNS_CHK_ALTP_NO_ALTPATH;*/</a>
<a name="ln5982">}</a>
<a name="ln5983"> </a>
<a name="ln5984"> </a>
<a name="ln5985"> </a>
<a name="ln5986">/**********************************************************************************/</a>
<a name="ln5987">int bRestoreBnsAfterCheckAltPath( BN_STRUCT *pBNS, ALT_PATH_CHANGES *apc, int bChangeFlow )</a>
<a name="ln5988">/* int nVertDoubleBond, int nVertSingleBond, int nNewVertex, AT_NUMB *nOldCapVertSingleBond */</a>
<a name="ln5989">{</a>
<a name="ln5990">    BNS_EDGE   *pEdge;</a>
<a name="ln5991">    Vertex      vNew;</a>
<a name="ln5992">    Vertex      vOld;</a>
<a name="ln5993">    BNS_VERTEX *pOldVert;</a>
<a name="ln5994">    BNS_VERTEX *pNewVert;</a>
<a name="ln5995">    int i, j, n, ret;</a>
<a name="ln5996"> </a>
<a name="ln5997">    ret = 0;</a>
<a name="ln5998">    if ( bChangeFlow &amp; BNS_EF_UPD_H_CHARGE ) {</a>
<a name="ln5999">        /* remove new temp. vertices and edges connectong them to the structure */</a>
<a name="ln6000">        for ( i = sizeof(apc-&gt;bSetNew)/sizeof(apc-&gt;bSetNew[0])-1; 0 &lt;= i; i -- ) {</a>
<a name="ln6001">            if ( apc-&gt;bSetNew[i] ) {</a>
<a name="ln6002">                vNew = apc-&gt;vNewVertex[i];</a>
<a name="ln6003">                pNewVert = pBNS-&gt;vert + vNew;</a>
<a name="ln6004">                for ( j = 0; j &lt; pNewVert-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln6005">                    pEdge    = pBNS-&gt;edge+pNewVert-&gt;iedge[j];</a>
<a name="ln6006">                    vOld     = pEdge-&gt;neighbor12 ^ vNew;</a>
<a name="ln6007">                    pOldVert = pBNS-&gt;vert + vOld;</a>
<a name="ln6008">                    pOldVert-&gt;st_edge.flow -= pEdge-&gt;flow;</a>
<a name="ln6009">                    pOldVert-&gt;st_edge.cap  -= pEdge-&gt;flow;</a>
<a name="ln6010">                    /* disconnect new edge from pOldVert */</a>
<a name="ln6011">                    pOldVert-&gt;iedge[--pOldVert-&gt;num_adj_edges] = 0;</a>
<a name="ln6012">                    /* clear the new edge */</a>
<a name="ln6013">                    memset( pEdge, 0, sizeof(*pEdge) );</a>
<a name="ln6014">                    /* and decrement the total number of edges */</a>
<a name="ln6015">                    pBNS-&gt;num_edges --;</a>
<a name="ln6016">                }</a>
<a name="ln6017">                /* clear the new vertex */</a>
<a name="ln6018">                memset( pNewVert, 0, sizeof(BNS_VERTEX) );</a>
<a name="ln6019">                /* and decrement the total number of vertices (new vertice ids are contiguous */</a>
<a name="ln6020">                pBNS-&gt;num_vertices --;</a>
<a name="ln6021">                ret ++;</a>
<a name="ln6022">            }</a>
<a name="ln6023">        }</a>
<a name="ln6024">        /* Restore changed caps of old vertices */</a>
<a name="ln6025">        for ( i = sizeof(apc-&gt;bSetOldCapsVert)/sizeof(apc-&gt;bSetOldCapsVert[0])-1; 0 &lt;= i; i -- ) {</a>
<a name="ln6026">            if ( (n = apc-&gt;bSetOldCapsVert[i]) ) {</a>
<a name="ln6027">                pOldVert   = pBNS-&gt;vert + apc-&gt;vOldVert[i];</a>
<a name="ln6028">                if ( pOldVert-&gt;st_edge.flow &lt;= apc-&gt;nOldCapsVert[i][0] ) { </a>
<a name="ln6029">                    pOldVert-&gt;st_edge.cap = apc-&gt;nOldCapsVert[i][0];</a>
<a name="ln6030">                    n --;</a>
<a name="ln6031">                    ret ++;</a>
<a name="ln6032">                    for ( j = 0; j &lt; n &amp;&amp; j &lt; pOldVert-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln6033">                        pEdge = pBNS-&gt;edge + pOldVert-&gt;iedge[j];</a>
<a name="ln6034">                        pEdge-&gt;cap = apc-&gt;nOldCapsVert[i][j+1];</a>
<a name="ln6035">                    }</a>
<a name="ln6036">                }</a>
<a name="ln6037">            }</a>
<a name="ln6038">        }</a>
<a name="ln6039">     } else {</a>
<a name="ln6040">        /* Restore changed caps of old vertices */</a>
<a name="ln6041">        for ( i = sizeof(apc-&gt;bSetOldCapsVert)/sizeof(apc-&gt;bSetOldCapsVert[0])-1; 0 &lt;= i; i -- ) {</a>
<a name="ln6042">            if ( (n = apc-&gt;bSetOldCapsVert[i]) ) {</a>
<a name="ln6043">                pOldVert   = pBNS-&gt;vert + apc-&gt;vOldVert[i];</a>
<a name="ln6044">                pOldVert-&gt;st_edge.cap = apc-&gt;nOldCapsVert[i][0];</a>
<a name="ln6045">                n --;</a>
<a name="ln6046">                ret ++;</a>
<a name="ln6047">                for ( j = 0; j &lt; n &amp;&amp; j &lt; pOldVert-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln6048">                    pEdge = pBNS-&gt;edge + pOldVert-&gt;iedge[j];</a>
<a name="ln6049">                    pEdge-&gt;cap = apc-&gt;nOldCapsVert[i][j+1];</a>
<a name="ln6050">                }</a>
<a name="ln6051">            }</a>
<a name="ln6052">        }</a>
<a name="ln6053"> </a>
<a name="ln6054">        /* remove new temp. vertices and edges connectong them to the structure */</a>
<a name="ln6055">        for ( i = sizeof(apc-&gt;bSetNew)/sizeof(apc-&gt;bSetNew[0])-1; 0 &lt;= i; i -- ) {</a>
<a name="ln6056">            if ( apc-&gt;bSetNew[i] ) {</a>
<a name="ln6057">                vNew = apc-&gt;vNewVertex[i];</a>
<a name="ln6058">                pNewVert = pBNS-&gt;vert + vNew;</a>
<a name="ln6059">                for ( j = 0; j &lt; pNewVert-&gt;num_adj_edges; j ++ ) {</a>
<a name="ln6060">                    pEdge    = pBNS-&gt;edge+pNewVert-&gt;iedge[j];</a>
<a name="ln6061">                    vOld     = pEdge-&gt;neighbor12 ^ vNew;</a>
<a name="ln6062">                    pOldVert   = pBNS-&gt;vert + vOld;</a>
<a name="ln6063">                    /* disconnect new edge from pOldVert */</a>
<a name="ln6064">                    pOldVert-&gt;iedge[--pOldVert-&gt;num_adj_edges] = 0;</a>
<a name="ln6065">                    /* clear the new edge */</a>
<a name="ln6066">                    memset( pEdge, 0, sizeof(*pEdge) );</a>
<a name="ln6067">                    /* and decrement the total number of edges */</a>
<a name="ln6068">                    pBNS-&gt;num_edges --;</a>
<a name="ln6069">                }</a>
<a name="ln6070">                /* clear the new vertex */</a>
<a name="ln6071">                memset( pNewVert, 0, sizeof(BNS_VERTEX) );</a>
<a name="ln6072">                /* and decrement the total number of vertices (new vertice ids are contiguous */</a>
<a name="ln6073">                pBNS-&gt;num_vertices --;</a>
<a name="ln6074">                ret ++;</a>
<a name="ln6075">            }</a>
<a name="ln6076">        }</a>
<a name="ln6077">    }</a>
<a name="ln6078">    return 0;</a>
<a name="ln6079">}</a>
<a name="ln6080"> </a>
<a name="ln6081"> </a>
<a name="ln6082"> </a>
<a name="ln6083">/**********************************************************************************/</a>
<a name="ln6084">int bExistsAnyAltPath( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at, int num_atoms,</a>
<a name="ln6085">                      int nVert2, int nVert1, int path_type )</a>
<a name="ln6086">{</a>
<a name="ln6087">    int nRet1, nRet2;</a>
<a name="ln6088">    nRet1 = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, nVert2, nVert1, path_type );</a>
<a name="ln6089">    if ( nRet1 &gt; 0 )</a>
<a name="ln6090">        return nRet1;</a>
<a name="ln6091">    nRet2 = bExistsAltPath( pBNS, pBD, NULL, at, num_atoms, nVert1, nVert2, path_type );</a>
<a name="ln6092">    if ( nRet2 &gt; 0 )</a>
<a name="ln6093">        return nRet2;</a>
<a name="ln6094">    if ( IS_BNS_ERROR( nRet1 ) )</a>
<a name="ln6095">        return nRet1;</a>
<a name="ln6096">    if ( IS_BNS_ERROR( nRet2 ) )</a>
<a name="ln6097">        return nRet2;</a>
<a name="ln6098">    return 0;</a>
<a name="ln6099">}</a>
<a name="ln6100"> </a>
<a name="ln6101">#define ALT_PATH_TAUTOM 1</a>
<a name="ln6102">#define ALT_PATH_CHARGE 2</a>
<a name="ln6103">#define ALT_PATH_4_SALT 3</a>
<a name="ln6104"> </a>
<a name="ln6105"> </a>
<a name="ln6106"> </a>
<a name="ln6107">/**********************************************************************************/</a>
<a name="ln6108">int bIsBnsEndpoint( BN_STRUCT *pBNS, int v )</a>
<a name="ln6109">{</a>
<a name="ln6110">    int i, vt;</a>
<a name="ln6111">    BNS_VERTEX    *pVert;  /* vertices */</a>
<a name="ln6112">    BNS_EDGE      *pEdge;  /* edges */</a>
<a name="ln6113"> </a>
<a name="ln6114">    if ( 0 &lt;= v &amp;&amp; v &lt; pBNS-&gt;num_atoms &amp;&amp; (pVert = pBNS-&gt;vert+v) &amp;&amp; (pVert-&gt;type &amp; BNS_VERT_TYPE_ENDPOINT) ) {</a>
<a name="ln6115">        for ( i = pVert-&gt;num_adj_edges - 1; 0 &lt;= i; i -- ) {</a>
<a name="ln6116">            pEdge = pBNS-&gt;edge + pVert-&gt;iedge[i];</a>
<a name="ln6117">            vt = pEdge-&gt;neighbor12 ^ v;</a>
<a name="ln6118">            if ( pBNS-&gt;vert[vt].type &amp; BNS_VERT_TYPE_TGROUP ) {</a>
<a name="ln6119">                return !IS_FORBIDDEN(pEdge-&gt;forbidden, pBNS);</a>
<a name="ln6120">            }</a>
<a name="ln6121">        }</a>
<a name="ln6122">    }</a>
<a name="ln6123">    return 0;</a>
<a name="ln6124">}</a>
<a name="ln6125"> </a>
<a name="ln6126"> </a>
<a name="ln6127"> </a>
<a name="ln6128">/**********************************************************************************/</a>
<a name="ln6129">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln6130">/**********************************************************************************/</a>
<a name="ln6131">int bRadChangesAtomType( BN_STRUCT *pBNS, BN_DATA *pBD, Vertex v, Vertex v_1, Vertex v_2 )</a>
<a name="ln6132">{</a>
<a name="ln6133">    </a>
<a name="ln6134">    EdgeIndex iuv;</a>
<a name="ln6135">    Vertex v_O, v_ChgOrH;</a>
<a name="ln6136">    /* the previous atom along the path: should be a terminal atom */</a>
<a name="ln6137">    if ( v_1 == NO_VERTEX ) {</a>
<a name="ln6138">        v_1 = GetPrevVertex( pBNS, v, pBD-&gt;SwitchEdge, &amp;iuv );</a>
<a name="ln6139">    }</a>
<a name="ln6140">    v_O = v_1 / 2 - 1;</a>
<a name="ln6141">    if ( v_O &lt; 0 || v_O &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln6142">        return 0;</a>
<a name="ln6143">    }</a>
<a name="ln6144">    /* make sure v_O is a terminal atom: its second neighbor is not an atom */</a>
<a name="ln6145">    if ( pBNS-&gt;vert[pBNS-&gt;edge[pBNS-&gt;vert[v_O].iedge[1]].neighbor12 ^ v_O].type &amp; BNS_VERT_TYPE_ATOM ) {</a>
<a name="ln6146">        return 0;</a>
<a name="ln6147">    }</a>
<a name="ln6148">    /* the next to previous vertex vertex along the path: should be a Charge or Taut group vertex */</a>
<a name="ln6149">    if ( v_2 == NO_VERTEX ) {</a>
<a name="ln6150">        v_2 = GetPrevVertex( pBNS, v_1, pBD-&gt;SwitchEdge, &amp;iuv );</a>
<a name="ln6151">    }</a>
<a name="ln6152">    v_ChgOrH = v_2 / 2 - 1;</a>
<a name="ln6153">    if ( v_ChgOrH &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln6154">        return 0;</a>
<a name="ln6155">    }</a>
<a name="ln6156">    /* make sure v_ChgOrH is a charge or taut_group */</a>
<a name="ln6157">    if ( pBNS-&gt;vert[v_ChgOrH].type &amp; (BNS_VERT_TYPE_TGROUP | BNS_VERT_TYPE_C_GROUP) )</a>
<a name="ln6158">        return 1;</a>
<a name="ln6159">    return 0;</a>
<a name="ln6160">}</a>
<a name="ln6161"> </a>
<a name="ln6162"> </a>
<a name="ln6163"> </a>
<a name="ln6164">/**********************************************************************************/</a>
<a name="ln6165">int RegisterRadEndpoint( BN_STRUCT *pBNS, BN_DATA *pBD, Vertex u)</a>
<a name="ln6166">{</a>
<a name="ln6167">    EdgeIndex iuv;</a>
<a name="ln6168">    int       i, num_found;</a>
<a name="ln6169">    Vertex    v, w;</a>
<a name="ln6170">    Vertex    u_last, v2;</a>
<a name="ln6171">    switch( pBD-&gt;bRadSrchMode ) {</a>
<a name="ln6172">    case  RAD_SRCH_NORM:</a>
<a name="ln6173">        /* go backwards along alt path and stop at the 1st found atom (not a fictitious vertex) */</a>
<a name="ln6174">        /* we need only vertices where a radical may be moved, therefore exclude u%2=1 (odd) vertices */</a>
<a name="ln6175">        /* atom number = u/2-1; u = 0 or 1 is 's' or 't' vertices, respectively, they are not atoms  */</a>
<a name="ln6176">        num_found = 0;</a>
<a name="ln6177">        while ( u &gt; Vertex_t &amp;&amp; (u % 2 || u/2 &gt; pBNS-&gt;num_atoms ) ) {</a>
<a name="ln6178">            u = GetPrevVertex( pBNS, u, pBD-&gt;SwitchEdge, &amp;iuv );</a>
<a name="ln6179">        }</a>
<a name="ln6180">        w = u/2 - 1; /* Check whether u is a radical endpoint */</a>
<a name="ln6181">        if ( Vertex_t &lt; u &amp;&amp; w &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln6182">             pBNS-&gt;vert[w].st_edge.cap == (pBNS-&gt;vert[w].st_edge.flow &amp; EDGE_FLOW_ST_MASK) ) {</a>
<a name="ln6183">            /* u is an atom; it is not a radical atom */</a>
<a name="ln6184">            /* now search for the starting radical atom by following the path back from u */</a>
<a name="ln6185">            v = u_last = u;</a>
<a name="ln6186">            while( v &gt; Vertex_t ) {</a>
<a name="ln6187">                u = v;</a>
<a name="ln6188">                v = GetPrevVertex( pBNS, u, pBD-&gt;SwitchEdge, &amp;iuv ); /* Radical endpoint */</a>
<a name="ln6189">            }</a>
<a name="ln6190">            /* check whether u is a radical atom */</a>
<a name="ln6191">            if ( !(u%2) &amp;&amp; Vertex_t &lt; u &amp;&amp;</a>
<a name="ln6192">                 (u = u/2 - 1) &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln6193">                 pBNS-&gt;vert[u].st_edge.cap &gt; (pBNS-&gt;vert[u].st_edge.flow &amp; EDGE_FLOW_ST_MASK) ) {</a>
<a name="ln6194">                /* at pBNS-&gt;vert[u] we have found the radical that originated the path */</a>
<a name="ln6195">                /* pBD-&gt;RadEndpoints[2k] is the radical, pBD-&gt;RadEndpoints[2k+1] is the farthest atom */</a>
<a name="ln6196">                /* to which the radical may be moved (farthest reachable atom) */</a>
<a name="ln6197"> </a>
<a name="ln6198">                /* add *all* atoms that may receive radical from u_rad */</a>
<a name="ln6199">                /* exception: at2 in: ==(+/-/H)---at1==at2(possible rad endpoint) if pBNS-&gt;type_TACN */</a>
<a name="ln6200">                </a>
<a name="ln6201">                for ( v = u_last; v &gt; Vertex_t; v = GetPrevVertex( pBNS, v, pBD-&gt;SwitchEdge, &amp;iuv ) ) {</a>
<a name="ln6202">                    if ( !(v%2) &amp;&amp; (v2 = v/2 - 1) &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln6203">                         pBNS-&gt;vert[v2].st_edge.cap == (pBNS-&gt;vert[v2].st_edge.flow &amp; EDGE_FLOW_ST_MASK) ) {</a>
<a name="ln6204">                        /* check exception */</a>
<a name="ln6205">                        if ( pBNS-&gt;type_TACN &amp;&amp;</a>
<a name="ln6206">                             bRadChangesAtomType( pBNS, pBD, v, NO_VERTEX, NO_VERTEX ) ) {</a>
<a name="ln6207">                            continue;</a>
<a name="ln6208">                        }</a>
<a name="ln6209">                        /* add */</a>
<a name="ln6210">                        for ( i = 0; i &lt; pBD-&gt;nNumRadEndpoints; i += 2 ) {</a>
<a name="ln6211">                            /* check whether this pair, (u,w), has already been saved */</a>
<a name="ln6212">                            if ( u  == pBD-&gt;RadEndpoints[i] &amp;&amp;</a>
<a name="ln6213">                                 v2 == pBD-&gt;RadEndpoints[i+1] ) {</a>
<a name="ln6214">                                break;</a>
<a name="ln6215">                            }</a>
<a name="ln6216">                        }</a>
<a name="ln6217">                        if ( i &gt;= pBD-&gt;nNumRadEndpoints ) {</a>
<a name="ln6218">                            /* add new (u,w) pair */</a>
<a name="ln6219">                            if ( pBD-&gt;nNumRadEndpoints+2 &lt;= pBD-&gt;max_num_vertices  ) {</a>
<a name="ln6220">                                /* add */</a>
<a name="ln6221">                                pBD-&gt;RadEndpoints[pBD-&gt;nNumRadEndpoints ++] = u; /* radical */</a>
<a name="ln6222">                                pBD-&gt;RadEndpoints[pBD-&gt;nNumRadEndpoints ++] = v2; /* endpoint */</a>
<a name="ln6223">                                num_found ++;</a>
<a name="ln6224">                                /*return 1;*/ /* registered */</a>
<a name="ln6225">                            } else {</a>
<a name="ln6226">                                return BNS_VERT_EDGE_OVFL;</a>
<a name="ln6227">                            }</a>
<a name="ln6228">                        }</a>
<a name="ln6229">                    }</a>
<a name="ln6230">                }</a>
<a name="ln6231">                if ( num_found ) {</a>
<a name="ln6232">                    return 1;</a>
<a name="ln6233">                }</a>
<a name="ln6234">            }</a>
<a name="ln6235">        }</a>
<a name="ln6236">        break;</a>
<a name="ln6237"> </a>
<a name="ln6238">    case RAD_SRCH_FROM_FICT:</a>
<a name="ln6239">        /* find nearest atom accessible from a fictitious vertex */</a>
<a name="ln6240">        /* go backwards along alt path and stop at the 1st found atom (not a fictitious vertex) */</a>
<a name="ln6241">        v = u;</a>
<a name="ln6242">        w = NO_VERTEX; /* the nearest atom -- radical-endpoint */</a>
<a name="ln6243">        u = NO_VERTEX; /* fictitious vertex carrying a radical */</a>
<a name="ln6244">        while ( v &gt; Vertex_t ) {</a>
<a name="ln6245">            u = v;</a>
<a name="ln6246">            if ( !(v % 2) &amp;&amp; v/2 &lt;= pBNS-&gt;num_atoms &amp;&amp; </a>
<a name="ln6247">                 pBNS-&gt;vert[v/2-1].st_edge.cap - pBNS-&gt;vert[v/2-1].st_edge.flow &lt; 2 ) {</a>
<a name="ln6248">                w = v; /* vertex w is atom that may be singlet or doublet but not triplet */</a>
<a name="ln6249">            }</a>
<a name="ln6250">            v = GetPrevVertex( pBNS, u, pBD-&gt;SwitchEdge, &amp;iuv );</a>
<a name="ln6251">        }</a>
<a name="ln6252">        v = u/2 - 1; /* vertex u may be the radical from which the path originated; w is the nearest atom */</a>
<a name="ln6253">        if ( w == NO_VERTEX || u == NO_VERTEX || w % 2 || u == w || v &lt; pBNS-&gt;num_atoms ||</a>
<a name="ln6254">             pBNS-&gt;vert[v].st_edge.cap == pBNS-&gt;vert[v].st_edge.flow ||</a>
<a name="ln6255">             (w = w/2 - 1) &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln6256">            break; /* reject */</a>
<a name="ln6257">        }</a>
<a name="ln6258">        u = v;</a>
<a name="ln6259">        /* at pBNS-&gt;vert[u] we have found the radical that originated the path, w is the nearest atom */</a>
<a name="ln6260">        for ( i = 0; i &lt; pBD-&gt;nNumRadEndpoints; i += 2 ) {</a>
<a name="ln6261">            if ( u == pBD-&gt;RadEndpoints[i] &amp;&amp;</a>
<a name="ln6262">                 w == pBD-&gt;RadEndpoints[i+1] ) {</a>
<a name="ln6263">                break; /* this pair has already been stored */</a>
<a name="ln6264">            }</a>
<a name="ln6265">        }</a>
<a name="ln6266">        if ( i &gt;= pBD-&gt;nNumRadEndpoints ) {</a>
<a name="ln6267">            /* a new pair has been found */</a>
<a name="ln6268">            if ( pBD-&gt;nNumRadEndpoints+2 &lt;= pBD-&gt;max_num_vertices  ) {</a>
<a name="ln6269">                /* add */</a>
<a name="ln6270">                pBD-&gt;RadEndpoints[pBD-&gt;nNumRadEndpoints ++] = u; /* radical */</a>
<a name="ln6271">                pBD-&gt;RadEndpoints[pBD-&gt;nNumRadEndpoints ++] = w; /* endpoint */</a>
<a name="ln6272">                return 1; /* registered */</a>
<a name="ln6273">            } else {</a>
<a name="ln6274">                return BNS_VERT_EDGE_OVFL;</a>
<a name="ln6275">            }</a>
<a name="ln6276">        }</a>
<a name="ln6277">        break;</a>
<a name="ln6278">    }</a>
<a name="ln6279"> </a>
<a name="ln6280">    return 0; /* rejected */</a>
<a name="ln6281">}</a>
<a name="ln6282"> </a>
<a name="ln6283"> </a>
<a name="ln6284"> </a>
<a name="ln6285">/**********************************************************************************/</a>
<a name="ln6286">int cmp_rad_endpoints( const void *a1, const void *a2 )</a>
<a name="ln6287">{</a>
<a name="ln6288">    /* Vertex radical_vertex, radical_endpoint */</a>
<a name="ln6289">    const Vertex *p1 = (const Vertex *)a1;</a>
<a name="ln6290">    const Vertex *p2 = (const Vertex *)a2;</a>
<a name="ln6291">    if ( p1[0] &lt; p2[0] )</a>
<a name="ln6292">        return -1;</a>
<a name="ln6293">    if ( p1[0] &gt; p2[0] )</a>
<a name="ln6294">        return 1;</a>
<a name="ln6295">    if ( p1[1] &lt; p2[1] )</a>
<a name="ln6296">        return -1;</a>
<a name="ln6297">    if ( p1[1] &gt; p2[1] )</a>
<a name="ln6298">        return 1;</a>
<a name="ln6299">    return 0;</a>
<a name="ln6300">}</a>
<a name="ln6301"> </a>
<a name="ln6302"> </a>
<a name="ln6303"> </a>
<a name="ln6304">/**********************************************************************************/</a>
<a name="ln6305">int RemoveRadEndpoints( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at )</a>
<a name="ln6306">{</a>
<a name="ln6307">    BNS_EDGE   *e;</a>
<a name="ln6308">    EdgeIndex   ie;</a>
<a name="ln6309">    BNS_VERTEX *p1, *p2;</a>
<a name="ln6310">    Vertex      v1, v2;</a>
<a name="ln6311">    int         i, delta, rad;</a>
<a name="ln6312">    for ( i = pBD-&gt;nNumRadEdges-1; 0 &lt;= i; i -- ) {</a>
<a name="ln6313">        ie = pBD-&gt;RadEdges[i];</a>
<a name="ln6314">        if ( ie &lt; 0 || ie &gt;= pBNS-&gt;num_edges ) {</a>
<a name="ln6315">            goto error_exit;</a>
<a name="ln6316">        }</a>
<a name="ln6317">        e = pBNS-&gt;edge + ie;</a>
<a name="ln6318">        v1 = e-&gt;neighbor1;</a>
<a name="ln6319">        v2 = e-&gt;neighbor12 ^ v1;   /* v2 &gt; v1 &lt;=&gt; v2 was added later */</a>
<a name="ln6320">        if ( ie + 1 != pBNS-&gt;num_edges || </a>
<a name="ln6321">             v1 &lt; 0 || v1 &gt;= pBNS-&gt;num_vertices ||</a>
<a name="ln6322">             v2 &lt; 0 || v2 &gt;= pBNS-&gt;num_vertices ) {</a>
<a name="ln6323">            goto error_exit;</a>
<a name="ln6324">        }</a>
<a name="ln6325">        p1 = pBNS-&gt;vert + v1;</a>
<a name="ln6326">        p2 = pBNS-&gt;vert + v2;</a>
<a name="ln6327"> </a>
<a name="ln6328">        if ( p2-&gt;iedge[p2-&gt;num_adj_edges-1] != ie ||</a>
<a name="ln6329">             p1-&gt;iedge[p1-&gt;num_adj_edges-1] != ie ) {</a>
<a name="ln6330">            goto error_exit;</a>
<a name="ln6331">        }</a>
<a name="ln6332">        p2-&gt;num_adj_edges --;</a>
<a name="ln6333">        p1-&gt;num_adj_edges --;</a>
<a name="ln6334">        p2-&gt;iedge[p2-&gt;num_adj_edges] = 0;</a>
<a name="ln6335">        p1-&gt;iedge[p1-&gt;num_adj_edges] = 0;</a>
<a name="ln6336">        p2-&gt;st_edge.flow -= e-&gt;flow;</a>
<a name="ln6337">        p1-&gt;st_edge.flow -= e-&gt;flow;</a>
<a name="ln6338"> </a>
<a name="ln6339">        if ( !p2-&gt;num_adj_edges &amp;&amp; v2 &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln6340">            if ( v2+1 != pBNS-&gt;num_vertices ) {</a>
<a name="ln6341">                goto error_exit;</a>
<a name="ln6342">            }</a>
<a name="ln6343">            memset( p2, 0, sizeof(*p2) );</a>
<a name="ln6344">            pBNS-&gt;num_vertices --;</a>
<a name="ln6345">        }</a>
<a name="ln6346">        if ( !p1-&gt;num_adj_edges &amp;&amp; v1 &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln6347">            if ( v1+1 != pBNS-&gt;num_vertices ) {</a>
<a name="ln6348">                goto error_exit;</a>
<a name="ln6349">            }</a>
<a name="ln6350">            memset( p1, 0, sizeof(*p1) );</a>
<a name="ln6351">            pBNS-&gt;num_vertices --;</a>
<a name="ln6352">        }</a>
<a name="ln6353">        if ( at &amp;&amp; v1 &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln6354">            delta = p1-&gt;st_edge.cap - p1-&gt;st_edge.flow;</a>
<a name="ln6355">            rad   = at[v1].radical;</a>
<a name="ln6356">            switch( delta ) {</a>
<a name="ln6357">            case 0:</a>
<a name="ln6358">                if ( rad == RADICAL_DOUBLET )</a>
<a name="ln6359">                    rad = 0;</a>
<a name="ln6360">                break;</a>
<a name="ln6361">            case 1:</a>
<a name="ln6362">                if ( rad != RADICAL_DOUBLET )</a>
<a name="ln6363">                    rad = RADICAL_DOUBLET;</a>
<a name="ln6364">            }</a>
<a name="ln6365">            at[v1].radical = rad;</a>
<a name="ln6366">        }</a>
<a name="ln6367">        memset( e, 0, sizeof(*e) );</a>
<a name="ln6368">        pBNS-&gt;num_edges --;</a>
<a name="ln6369">    }</a>
<a name="ln6370">    pBD-&gt;nNumRadEdges = 0;</a>
<a name="ln6371">    pBD-&gt;nNumRadicals = 0;</a>
<a name="ln6372">    pBD-&gt;bRadSrchMode = RAD_SRCH_NORM;</a>
<a name="ln6373">    return 0;</a>
<a name="ln6374">error_exit:</a>
<a name="ln6375">    return BNS_PROGRAM_ERR;</a>
<a name="ln6376">}</a>
<a name="ln6377"> </a>
<a name="ln6378"> </a>
<a name="ln6379"> </a>
<a name="ln6380">/**********************************************************************************/</a>
<a name="ln6381">int RestoreRadicalsOnly( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at )</a>
<a name="ln6382">{</a>
<a name="ln6383">    BNS_EDGE   *e;</a>
<a name="ln6384">    EdgeIndex   ie;</a>
<a name="ln6385">    BNS_VERTEX *p1, *p2;</a>
<a name="ln6386">    Vertex      v1, v2;</a>
<a name="ln6387">    int         i, delta, rad;</a>
<a name="ln6388">    int         p1_num_adj_edges, p2_num_adj_edges;</a>
<a name="ln6389"> </a>
<a name="ln6390">    for ( i = pBD-&gt;nNumRadEdges-1; 0 &lt;= i; i -- ) {</a>
<a name="ln6391">        ie = pBD-&gt;RadEdges[i];</a>
<a name="ln6392">        if ( ie &lt; 0 || ie &gt;= pBNS-&gt;num_edges ) {</a>
<a name="ln6393">            goto error_exit;</a>
<a name="ln6394">        }</a>
<a name="ln6395">        e = pBNS-&gt;edge + ie;</a>
<a name="ln6396">        v1 = e-&gt;neighbor1;         /* atom */</a>
<a name="ln6397">        v2 = e-&gt;neighbor12 ^ v1;   /* v2 &gt; v1 &lt;=&gt; v2 was added later */</a>
<a name="ln6398">        if ( v1 &lt; 0 || v1 &gt;= pBNS-&gt;num_atoms ||</a>
<a name="ln6399">             v2 &lt; pBNS-&gt;num_atoms || v2 &gt;= pBNS-&gt;num_vertices ) {</a>
<a name="ln6400">            goto error_exit;</a>
<a name="ln6401">        }</a>
<a name="ln6402">        p1 = pBNS-&gt;vert + v1;</a>
<a name="ln6403">        p2 = pBNS-&gt;vert + v2;</a>
<a name="ln6404"> </a>
<a name="ln6405">        p1_num_adj_edges = e-&gt;neigh_ord[0];</a>
<a name="ln6406">        p2_num_adj_edges = e-&gt;neigh_ord[1];</a>
<a name="ln6407"> </a>
<a name="ln6408">        if ( p2-&gt;iedge[p2_num_adj_edges] != ie ||</a>
<a name="ln6409">             p1-&gt;iedge[p1_num_adj_edges] != ie ) {</a>
<a name="ln6410">            goto error_exit;</a>
<a name="ln6411">        }</a>
<a name="ln6412"> </a>
<a name="ln6413">        if ( at &amp;&amp; v1 &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln6414">            delta = p1-&gt;st_edge.cap - p1-&gt;st_edge.flow + e-&gt;flow;</a>
<a name="ln6415">            rad   = at[v1].radical;</a>
<a name="ln6416">            switch( delta ) {</a>
<a name="ln6417">            case 0:</a>
<a name="ln6418">                if ( rad == RADICAL_DOUBLET )</a>
<a name="ln6419">                    rad = 0;</a>
<a name="ln6420">                break;</a>
<a name="ln6421">            case 1:</a>
<a name="ln6422">                if ( rad != RADICAL_DOUBLET )</a>
<a name="ln6423">                    rad = RADICAL_DOUBLET;</a>
<a name="ln6424">            }</a>
<a name="ln6425">            at[v1].radical = rad;</a>
<a name="ln6426">        }</a>
<a name="ln6427">    }</a>
<a name="ln6428">    return 0;</a>
<a name="ln6429">error_exit:</a>
<a name="ln6430">    return BNS_PROGRAM_ERR;</a>
<a name="ln6431">}</a>
<a name="ln6432"> </a>
<a name="ln6433"> </a>
<a name="ln6434"> </a>
<a name="ln6435">/**********************************************************************************/</a>
<a name="ln6436">int SetRadEndpoints( BN_STRUCT *pBNS, BN_DATA *pBD, BRS_MODE bRadSrchMode )</a>
<a name="ln6437">{</a>
<a name="ln6438">    int ret, i, j, k, num_new_edges, delta;</a>
<a name="ln6439">    BNS_VERTEX *pRad, *pEndp;</a>
<a name="ln6440">    Vertex     wRad, vRad, vEndp, nNumRadicals;</a>
<a name="ln6441">    int        nDots=0 /* added initialization, 2006-03 */, nNumEdges;</a>
<a name="ln6442">    if ( pBNS-&gt;tot_st_cap &lt;= pBNS-&gt;tot_st_flow ) {</a>
<a name="ln6443">        return 0;</a>
<a name="ln6444">    }</a>
<a name="ln6445">    pBD-&gt;nNumRadEndpoints = 0;</a>
<a name="ln6446">    pBD-&gt;nNumRadEdges     = 0;</a>
<a name="ln6447">    pBD-&gt;bRadSrchMode     = bRadSrchMode;</a>
<a name="ln6448">    pBNS-&gt;alt_path = pBNS-&gt;altp[0];</a>
<a name="ln6449">    pBNS-&gt;bChangeFlow = 0;</a>
<a name="ln6450">    ret = BalancedNetworkSearch( pBNS, pBD, BNS_EF_RAD_SRCH );</a>
<a name="ln6451">    ReInitBnData( pBD );</a>
<a name="ln6452">    ReInitBnStructAltPaths( pBNS );</a>
<a name="ln6453">    if ( !ret &amp;&amp; pBD-&gt;nNumRadEndpoints &gt;= 2 ) {</a>
<a name="ln6454">        /* sort by radical locations */</a>
<a name="ln6455">        qsort( pBD-&gt;RadEndpoints, pBD-&gt;nNumRadEndpoints/2, 2*sizeof(pBD-&gt;RadEndpoints[0]), cmp_rad_endpoints );</a>
<a name="ln6456">        num_new_edges = 0;</a>
<a name="ln6457">        nNumRadicals  = 0;</a>
<a name="ln6458">        /* create new vertices (type=BNS_VERT_TYPE_TEMP) and edges with flow=cap=1 */</a>
<a name="ln6459">        /* connecting the new vertices radical vertices */</a>
<a name="ln6460">        for ( i = 0; i &lt; pBD-&gt;nNumRadEndpoints; i = j ) {</a>
<a name="ln6461">            wRad = pBD-&gt;RadEndpoints[i];</a>
<a name="ln6462">            pRad = pBNS-&gt;vert + wRad;</a>
<a name="ln6463">            delta = pRad-&gt;st_edge.cap - (pRad-&gt;st_edge.flow &amp; EDGE_FLOW_ST_MASK);</a>
<a name="ln6464">            if ( delta &lt;= 0 ) {</a>
<a name="ln6465">                delta = 1;</a>
<a name="ln6466">            }</a>
<a name="ln6467">            nNumEdges = 0;</a>
<a name="ln6468">            for ( j = i; j &lt; pBD-&gt;nNumRadEndpoints &amp;&amp; wRad == pBD-&gt;RadEndpoints[j] ; j += 2 ) {</a>
<a name="ln6469">                nNumEdges ++;</a>
<a name="ln6470">            }</a>
<a name="ln6471">            /* add new aux vertex to the radical atom/vertex */</a>
<a name="ln6472">            vRad = bAddNewVertex( pBNS, wRad, delta, delta, nNumEdges+1, &amp;nDots );</a>
<a name="ln6473">            if ( IS_BNS_ERROR( vRad ) ) {</a>
<a name="ln6474">                ret = vRad;</a>
<a name="ln6475">                goto error_exit;</a>
<a name="ln6476">            }</a>
<a name="ln6477">            pRad     = pBNS-&gt;vert + vRad;</a>
<a name="ln6478">            pBD-&gt;RadEdges[pBD-&gt;nNumRadEdges ++] = pRad-&gt;iedge[pRad-&gt;num_adj_edges-1];</a>
<a name="ln6479">            /* replace references to vertex wRad with vRad */</a>
<a name="ln6480">            for ( k = i, nNumEdges = 0; k &lt; j; k += 2 ) {</a>
<a name="ln6481">                pBD-&gt;RadEndpoints[k] = vRad;</a>
<a name="ln6482">            }</a>
<a name="ln6483">            nNumRadicals ++;</a>
<a name="ln6484">        }</a>
<a name="ln6485">        /* all vRad vertex indices should be in the range vFirstNewVertex...vFirstNewVertex+nNumRadicals-1 */</a>
<a name="ln6486">        /* connect new vertices to the radical endpoints thus replacing radicals with even-length alternating cycles */</a>
<a name="ln6487">        for ( i = 0; i &lt; pBD-&gt;nNumRadEndpoints; i = j ) {</a>
<a name="ln6488">            vRad = pBD-&gt;RadEndpoints[i];</a>
<a name="ln6489">            pRad = pBNS-&gt;vert + vRad;</a>
<a name="ln6490">            for ( j = i; j &lt; pBD-&gt;nNumRadEndpoints &amp;&amp; vRad == pBD-&gt;RadEndpoints[j] ; j += 2 ) {</a>
<a name="ln6491">                /* connect vew vertex pRad to radical endpoints */</a>
<a name="ln6492">                vEndp    = pBD-&gt;RadEndpoints[j+1];</a>
<a name="ln6493">                pEndp    = pBNS-&gt;vert + vEndp;</a>
<a name="ln6494">                ret = AddNewEdge( pRad, pEndp, pBNS, 1, 0 );</a>
<a name="ln6495">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6496">                    goto error_exit;</a>
<a name="ln6497">                }</a>
<a name="ln6498">                pBD-&gt;RadEdges[pBD-&gt;nNumRadEdges ++] = ret;</a>
<a name="ln6499">            }</a>
<a name="ln6500">        }</a>
<a name="ln6501">        pBD-&gt;nNumRadicals = nNumRadicals;</a>
<a name="ln6502">        return nNumRadicals; /* done */</a>
<a name="ln6503">    }</a>
<a name="ln6504">    return 0; /* nothing to do */</a>
<a name="ln6505"> </a>
<a name="ln6506">error_exit:</a>
<a name="ln6507">    RemoveRadEndpoints( pBNS, pBD, NULL );</a>
<a name="ln6508">    return ret;</a>
<a name="ln6509"> </a>
<a name="ln6510">}</a>
<a name="ln6511"> </a>
<a name="ln6512"> </a>
<a name="ln6513"> </a>
<a name="ln6514">/**********************************************************************************/</a>
<a name="ln6515">#define MAX_NUM_RAD  256</a>
<a name="ln6516"> </a>
<a name="ln6517"> </a>
<a name="ln6518"> </a>
<a name="ln6519">/***************************************************************************/</a>
<a name="ln6520">int SetRadEndpoints2( BN_STRUCT *pBNS, BN_DATA *pBD, BRS_MODE bRadSrchMode )</a>
<a name="ln6521">{</a>
<a name="ln6522">    int ret = 0, i, j, k, n, num_new_edges, delta = 1;</a>
<a name="ln6523">    BNS_VERTEX *pRad, *pEndp;</a>
<a name="ln6524">    Vertex     wRad, vRad, vEndp, nNumRadicals;</a>
<a name="ln6525">    Vertex     vRadList[MAX_NUM_RAD], vRadEqul[MAX_NUM_RAD];</a>
<a name="ln6526">    int        nNumRad = 0;</a>
<a name="ln6527">    int        edge_flow;</a>
<a name="ln6528">    int        nDots=0 /* added initialization, 2006-03 */, nNumEdges;</a>
<a name="ln6529">    NodeSet    VertSet;</a>
<a name="ln6530">    if ( pBNS-&gt;tot_st_cap &lt;= pBNS-&gt;tot_st_flow ) {</a>
<a name="ln6531">        return 0;</a>
<a name="ln6532">    }</a>
<a name="ln6533">    /* find all radicals: their vertices have st_cap-st_flow=delta */</a>
<a name="ln6534">    /* save radical atom numbers in vRadList[] and remove radical by making st_cap=st_flow */</a>
<a name="ln6535">    for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln6536">        if ( pBNS-&gt;vert[i].st_edge.cap - delta == (pBNS-&gt;vert[i].st_edge.flow &amp; EDGE_FLOW_ST_MASK) ) {</a>
<a name="ln6537">            if ( nNumRad &lt; MAX_NUM_RAD ) {</a>
<a name="ln6538">                pBNS-&gt;vert[i].st_edge.cap -= delta;</a>
<a name="ln6539">                pBNS-&gt;tot_st_cap          -= delta;</a>
<a name="ln6540">                vRadList[nNumRad] = i;       /* radical position; i &gt; j &lt;=&gt; vRadList[i] &gt; vRadList[j]  */</a>
<a name="ln6541">                vRadEqul[nNumRad] = nNumRad; /* the smallest radical atom that has reachable</a>
<a name="ln6542">                                              * atoms in common with this radical atom</a>
<a name="ln6543">                                              * always keep vRadEqul[nNumRad] &lt;= nNumRad */</a>
<a name="ln6544">                nNumRad ++;</a>
<a name="ln6545">            }</a>
<a name="ln6546">        }</a>
<a name="ln6547">    }</a>
<a name="ln6548">    if ( pBNS-&gt;tot_st_cap - pBNS-&gt;tot_st_flow &gt; nNumRad ) {</a>
<a name="ln6549">        return BNS_CAP_FLOW_ERR; /* extra st_cap on non-atoms or program error */</a>
<a name="ln6550">    }</a>
<a name="ln6551">    memset( &amp;VertSet, 0, sizeof(VertSet) );</a>
<a name="ln6552">    /* find reachable atoms by enabling each radical separately */</a>
<a name="ln6553">    for ( j = 0; j &lt; nNumRad; j ++ ) {</a>
<a name="ln6554">        i  = vRadList[j];</a>
<a name="ln6555">        pBD-&gt;nNumRadEndpoints = 0;</a>
<a name="ln6556">        pBD-&gt;nNumRadEdges     = 0;</a>
<a name="ln6557">        pBD-&gt;bRadSrchMode     = bRadSrchMode;</a>
<a name="ln6558">        pBNS-&gt;alt_path = pBNS-&gt;altp[0];</a>
<a name="ln6559">        pBNS-&gt;bChangeFlow     = 0;</a>
<a name="ln6560">        pBNS-&gt;vert[i].st_edge.cap += delta; /* enable single radical */</a>
<a name="ln6561">        pBNS-&gt;tot_st_cap          += delta;</a>
<a name="ln6562">        ret = BalancedNetworkSearch( pBNS, pBD, BNS_EF_RAD_SRCH ); /* find reachable atoms */</a>
<a name="ln6563">        ReInitBnData( pBD );</a>
<a name="ln6564">        ReInitBnStructAltPaths( pBNS );</a>
<a name="ln6565">        pBD-&gt;bRadSrchMode     = RAD_SRCH_NORM;</a>
<a name="ln6566">        pBNS-&gt;vert[i].st_edge.cap -= delta; /* disable single radical */</a>
<a name="ln6567">        pBNS-&gt;tot_st_cap          -= delta;</a>
<a name="ln6568">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6569">            goto error_exit;</a>
<a name="ln6570">        } else</a>
<a name="ln6571">        if ( ret ) {</a>
<a name="ln6572">            ret = BNS_RADICAL_ERR; /* found augmenting path: should not happen since only one radical was enabled */</a>
<a name="ln6573">            goto error_exit;</a>
<a name="ln6574">        }</a>
<a name="ln6575">        if ( !ret &amp;&amp; pBD-&gt;nNumRadEndpoints &gt;= 2 ) {</a>
<a name="ln6576">            /* sort by: primary_key=radical locations, secondary_key=radical endoint */</a>
<a name="ln6577">            qsort( pBD-&gt;RadEndpoints, pBD-&gt;nNumRadEndpoints/2, 2*sizeof(pBD-&gt;RadEndpoints[0]), cmp_rad_endpoints );</a>
<a name="ln6578">            if ( pBD-&gt;RadEndpoints[0] != i || pBD-&gt;RadEndpoints[pBD-&gt;nNumRadEndpoints-2] != i ) {</a>
<a name="ln6579">                ret = BNS_RADICAL_ERR; /* more than one radical vertex */</a>
<a name="ln6580">                goto error_exit;</a>
<a name="ln6581">            }</a>
<a name="ln6582">            if ( nNumRad &gt; 1 ) {</a>
<a name="ln6583">                /* if more than one radical then save reachable atoms in bitmaps to allow */</a>
<a name="ln6584">                /* faster finding whether same atoms are reachable by two or more radicals */</a>
<a name="ln6585">                /* Later merge such sets */</a>
<a name="ln6586">                if ( NULL == VertSet.bitword ) {</a>
<a name="ln6587">                    SetBitCreate( );</a>
<a name="ln6588">                    if ( !NodeSetCreate( &amp;VertSet, pBNS-&gt;num_atoms, nNumRad ) ) {</a>
<a name="ln6589">                        ret = BNS_OUT_OF_RAM; /* out of RAM */</a>
<a name="ln6590">                        goto error_exit;</a>
<a name="ln6591">                    }</a>
<a name="ln6592">                }</a>
<a name="ln6593">                NodeSetFromRadEndpoints( &amp;VertSet, j, pBD-&gt;RadEndpoints, pBD-&gt;nNumRadEndpoints);</a>
<a name="ln6594">                /* do not allow any radical center be treated as a reachable atom: */</a>
<a name="ln6595">                RemoveFromNodeSet( &amp;VertSet, j, vRadList, nNumRad );</a>
<a name="ln6596">            }</a>
<a name="ln6597">        }</a>
<a name="ln6598">    }</a>
<a name="ln6599">    /* restore radical st_cap so that st_cap-st_flow=delta */</a>
<a name="ln6600">    for ( j = 0; j &lt; nNumRad; j ++ ) {</a>
<a name="ln6601">        i  = vRadList[j];</a>
<a name="ln6602">        pBNS-&gt;vert[i].st_edge.cap += delta;</a>
<a name="ln6603">        pBNS-&gt;tot_st_cap          += delta;</a>
<a name="ln6604">    }</a>
<a name="ln6605">    /* merge lists that have common radical endpoints */</a>
<a name="ln6606">    /* defect: if vertex sets i and j do not intersect they will be compared 2 times */</a>
<a name="ln6607">    /* total up to nNumRad*(nNumRad-1)/2 calls to DoNodeSetsIntersect() */</a>
<a name="ln6608">    if ( nNumRad &gt; 1 ) {</a>
<a name="ln6609">        for ( i = 0; i &lt; nNumRad; i ++ ) {</a>
<a name="ln6610">            if ( vRadEqul[i] != i )</a>
<a name="ln6611">                continue;</a>
<a name="ln6612">            do {</a>
<a name="ln6613">                n = 0;</a>
<a name="ln6614">                for ( j = i+1; j &lt; nNumRad; j ++ ) {</a>
<a name="ln6615">                    if ( vRadEqul[j] != j )</a>
<a name="ln6616">                        continue;</a>
<a name="ln6617">                    if ( DoNodeSetsIntersect( &amp;VertSet, i, j) ) {</a>
<a name="ln6618">                        AddNodeSet2ToNodeSet1( &amp;VertSet, i, j);</a>
<a name="ln6619">                        vRadEqul[j] = i; /* Set j was copied to set i; i &lt; j */</a>
<a name="ln6620">                        n ++;</a>
<a name="ln6621">                    }</a>
<a name="ln6622">                }</a>
<a name="ln6623">            } while( n );</a>
<a name="ln6624">        }</a>
<a name="ln6625">        /* fill out pBD-&gt;RadEndpoints[] */</a>
<a name="ln6626">        for ( i = 0, n = 0; i &lt; nNumRad; i ++ ) {</a>
<a name="ln6627">            if ( i == vRadEqul[i] ) {</a>
<a name="ln6628">                if ( !IsNodeSetEmpty( &amp;VertSet, i) ) {</a>
<a name="ln6629">                    /* store equivalent radicals */</a>
<a name="ln6630">                    for ( j = i+1; j &lt; nNumRad; j ++ ) {</a>
<a name="ln6631">                        if (i == vRadEqul[j] ) {</a>
<a name="ln6632">                            pBD-&gt;RadEndpoints[n++] =  vRadList[i];</a>
<a name="ln6633">                            pBD-&gt;RadEndpoints[n++] = -vRadList[j]-2; /* equivalent radical, alvays not zero */</a>
<a name="ln6634">                        }</a>
<a name="ln6635">                    }</a>
<a name="ln6636">                    /* store endpoints */</a>
<a name="ln6637">                    n = AddNodesToRadEndpoints( &amp;VertSet, i, pBD-&gt;RadEndpoints, vRadList[i], n, pBD-&gt;max_len_Pu_Pv );</a>
<a name="ln6638">                    if ( n &lt; 0 ) {</a>
<a name="ln6639">                        ret = BNS_RADICAL_ERR; /* pBD-&gt;RadEndpoints overflow */</a>
<a name="ln6640">                        goto error_exit;</a>
<a name="ln6641">                    }</a>
<a name="ln6642">                } else {</a>
<a name="ln6643">                    pBD-&gt;RadEndpoints[n++] =  vRadList[i];</a>
<a name="ln6644">                    pBD-&gt;RadEndpoints[n++] =  -1; /* immobile radical, only one edge to add */</a>
<a name="ln6645">                }</a>
<a name="ln6646">            }</a>
<a name="ln6647">        }</a>
<a name="ln6648">        pBD-&gt;nNumRadEndpoints = n;</a>
<a name="ln6649">        NodeSetFree( &amp;VertSet );</a>
<a name="ln6650">    } else</a>
<a name="ln6651">    if ( nNumRad == 1 &amp;&amp; !pBD-&gt;nNumRadEndpoints ) {</a>
<a name="ln6652">        /* 2006-07-30: a single radical; no possible endpoint found */</a>
<a name="ln6653">        for ( i = 0, n = 0; i &lt; nNumRad; i ++ ) {</a>
<a name="ln6654">            pBD-&gt;RadEndpoints[n++] =  vRadList[i];</a>
<a name="ln6655">            pBD-&gt;RadEndpoints[n++] =  -1; /* immobile radical, only one edge to add */</a>
<a name="ln6656">        }</a>
<a name="ln6657">        pBD-&gt;nNumRadEndpoints = n;</a>
<a name="ln6658">    }</a>
<a name="ln6659"> </a>
<a name="ln6660">    if ( !ret &amp;&amp; pBD-&gt;nNumRadEndpoints &gt;= 2 ) {</a>
<a name="ln6661">        /* already sorted by radical locations */</a>
<a name="ln6662">        num_new_edges = 0;</a>
<a name="ln6663">        nNumRadicals  = 0;</a>
<a name="ln6664">        /**************************************************************************</a>
<a name="ln6665">         * create new vertices (type=BNS_VERT_TYPE_TEMP) and edges with flow=cap=1</a>
<a name="ln6666">         * connecting the new vertices radical vertices</a>
<a name="ln6667">         *</a>
<a name="ln6668">         *  </a>
<a name="ln6669">         * Original structure:    atom A is a radical center    A==B--C*--D==E</a>
<a name="ln6670">         *   A*--B==C--D==E       atoms C and E are reachable:  A==B--C===D--E*</a>
<a name="ln6671">         *</a>
<a name="ln6672">         * Resultant temporary structure:</a>
<a name="ln6673">         *   A---B==C--D==E                     </a>
<a name="ln6674">         *  ||     /     /                      </a>
<a name="ln6675">         *  ||    /    /          The additional new vertex (*) and its</a>
<a name="ln6676">         *  ||   /   /            3 edges replace the radical with alternating</a>
<a name="ln6677">         *  ||  /  /              circuits that allow same bond changes</a>
<a name="ln6678">         *  || / /                as moving the radical to atoms C or E.</a>
<a name="ln6679">         *  ||//                  &quot;Double bonds&quot; here have edge cap=1, flow=1</a>
<a name="ln6680">         *  (*)                   &quot;Single bonds&quot; have edge cap=1, flow=0</a>
<a name="ln6681">         *                        </a>
<a name="ln6682">         *   The &quot;equivalent radical centers&quot; (which have at least one reachable atom</a>
<a name="ln6683">         *   in common) are connected to (*) with &quot;double bonds&quot; (edge cap=1, flow=1).</a>
<a name="ln6684">         *   Reachable non-radical atoms are connected by edges with cap=1, flow=0</a>
<a name="ln6685">         *   After running BNS to find alt.path a &quot;double bond&quot; from (*) may move</a>
<a name="ln6686">         *   to another atom thus muving the radical.</a>
<a name="ln6687">         *</a>
<a name="ln6688">         *   Number of additional (*) vertices = number of sets of</a>
<a name="ln6689">         *   &quot;equivalent radical centers&quot;.</a>
<a name="ln6690">         *   Each such a set may include one or more radical centers.</a>
<a name="ln6691">         *</a>
<a name="ln6692">         *   The radicals will be re-created in RemoveRadEndpoints()</a>
<a name="ln6693">         ***************************************************************************/</a>
<a name="ln6694">        for ( i = 0; i &lt; pBD-&gt;nNumRadEndpoints; i = j ) {</a>
<a name="ln6695">            wRad = pBD-&gt;RadEndpoints[i];</a>
<a name="ln6696">            pRad = pBNS-&gt;vert + wRad;</a>
<a name="ln6697">            delta = pRad-&gt;st_edge.cap - (pRad-&gt;st_edge.flow &amp; EDGE_FLOW_ST_MASK);</a>
<a name="ln6698">            if ( delta &lt;= 0 ) {</a>
<a name="ln6699">                delta = 1;</a>
<a name="ln6700">            }</a>
<a name="ln6701">            nNumEdges = 0;</a>
<a name="ln6702">            for ( j = i; j &lt; pBD-&gt;nNumRadEndpoints &amp;&amp; wRad == pBD-&gt;RadEndpoints[j] ; j += 2 ) {</a>
<a name="ln6703">                nNumEdges += (pBD-&gt;RadEndpoints[j+1] != -1); /* immobile radicals have one edge only */</a>
<a name="ln6704">            }</a>
<a name="ln6705">            /* add new aux vertex to the radical atom/vertex making st_cap-st_flow=0 */</a>
<a name="ln6706">            /* in case of immobile radical there will be no additional eddges since nNumEdges=0 */</a>
<a name="ln6707">            vRad = bAddNewVertex( pBNS, wRad, delta, delta, nNumEdges+1, &amp;nDots );</a>
<a name="ln6708">            if ( IS_BNS_ERROR( vRad ) ) {</a>
<a name="ln6709">                ret = vRad;</a>
<a name="ln6710">                goto error_exit;</a>
<a name="ln6711">            }</a>
<a name="ln6712">            pRad     = pBNS-&gt;vert + vRad;</a>
<a name="ln6713">            pBD-&gt;RadEdges[pBD-&gt;nNumRadEdges ++] = pRad-&gt;iedge[pRad-&gt;num_adj_edges-1];</a>
<a name="ln6714">            /* replace references to vertex wRad with vRad */</a>
<a name="ln6715">            for ( k = i, nNumEdges = 0; k &lt; j; k += 2 ) {</a>
<a name="ln6716">                pBD-&gt;RadEndpoints[k] = vRad;</a>
<a name="ln6717">            }</a>
<a name="ln6718">            nNumRadicals ++;</a>
<a name="ln6719">        }</a>
<a name="ln6720">        /* all vRad vertex indices should be in the range vFirstNewVertex...vFirstNewVertex+nNumRadicals-1 */</a>
<a name="ln6721">        /* connect new vertices to the radical endpoints thus replacing radicals with even-length alternating cycles */</a>
<a name="ln6722">        for ( i = 0; i &lt; pBD-&gt;nNumRadEndpoints; i = j ) {</a>
<a name="ln6723">            vRad = pBD-&gt;RadEndpoints[i];</a>
<a name="ln6724">            pRad = pBNS-&gt;vert + vRad;</a>
<a name="ln6725">            for ( j = i; j &lt; pBD-&gt;nNumRadEndpoints &amp;&amp; vRad == pBD-&gt;RadEndpoints[j] ; j += 2 ) {</a>
<a name="ln6726">                /* connect vew vertex pRad to radical endpoints */</a>
<a name="ln6727">                vEndp     = pBD-&gt;RadEndpoints[j+1];</a>
<a name="ln6728">                if ( vEndp == -1 )</a>
<a name="ln6729">                    continue;</a>
<a name="ln6730">                if ( vEndp &lt; 0 ) {</a>
<a name="ln6731">                    edge_flow = 1;</a>
<a name="ln6732">                    vEndp = -vEndp - 2; /* equivalent radical centers */</a>
<a name="ln6733">                } else {</a>
<a name="ln6734">                    edge_flow = 0;</a>
<a name="ln6735">                }</a>
<a name="ln6736">                pEndp    = pBNS-&gt;vert + vEndp;</a>
<a name="ln6737">                ret = AddNewEdge( pRad, pEndp, pBNS, 1, edge_flow );</a>
<a name="ln6738">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6739">                    goto error_exit;</a>
<a name="ln6740">                }</a>
<a name="ln6741">                pBD-&gt;RadEdges[pBD-&gt;nNumRadEdges ++] = ret;</a>
<a name="ln6742">            }</a>
<a name="ln6743">        }</a>
<a name="ln6744">        pBD-&gt;nNumRadicals = nNumRadicals;</a>
<a name="ln6745">        return nNumRadicals; /* done */</a>
<a name="ln6746">    }</a>
<a name="ln6747">    return 0; /* nothing to do */</a>
<a name="ln6748"> </a>
<a name="ln6749">error_exit:</a>
<a name="ln6750">    RemoveRadEndpoints( pBNS, pBD, NULL );</a>
<a name="ln6751">    NodeSetFree( &amp;VertSet );</a>
<a name="ln6752">    return ret;</a>
<a name="ln6753"> </a>
<a name="ln6754">}</a>
<a name="ln6755"> </a>
<a name="ln6756"> </a>
<a name="ln6757">#else</a>
<a name="ln6758"> </a>
<a name="ln6759"> </a>
<a name="ln6760"> </a>
<a name="ln6761">/**********************************************************************************/</a>
<a name="ln6762">int SetRadEndpoints( BN_STRUCT *pBNS, BN_DATA *pBD, BRS_MODE bRadSrchMode )</a>
<a name="ln6763">{</a>
<a name="ln6764">    return 0;</a>
<a name="ln6765">}</a>
<a name="ln6766">int RemoveRadEndpoints( BN_STRUCT *pBNS, BN_DATA *pBD, inp_ATOM *at )</a>
<a name="ln6767">{</a>
<a name="ln6768">    return 0;</a>
<a name="ln6769">}</a>
<a name="ln6770">int SetRadEndpoints2( BN_STRUCT *pBNS, BN_DATA *pBD, BRS_MODE bRadSrchMode )</a>
<a name="ln6771">{</a>
<a name="ln6772">    return 0;</a>
<a name="ln6773">}</a>
<a name="ln6774">#endif</a>
<a name="ln6775"> </a>
<a name="ln6776"> </a>
<a name="ln6777"> </a>
<a name="ln6778">/**********************************************************************************/</a>
<a name="ln6779">/* Return value ret bits if not IS_BNS_ERROR(ret):</a>
<a name="ln6780"> </a>
<a name="ln6781">    ret &amp; 1         =&gt; Success</a>
<a name="ln6782">    ret &amp; 2         =&gt; Bonds changed to Alt</a>
<a name="ln6783">    (ret &amp; ~3) &gt;&gt; 2 =&gt; nDelta: number of removed dots</a>
<a name="ln6784">*/</a>
<a name="ln6785">int bExistsAltPath( BN_STRUCT *pBNS, BN_DATA *pBD, BN_AATG *pAATG, inp_ATOM *at, int num_atoms,</a>
<a name="ln6786">                    int nVertDoubleBond, int nVertSingleBond, int path_type )</a>
<a name="ln6787">{</a>
<a name="ln6788">    ALT_PATH_CHANGES apc;</a>
<a name="ln6789">    int ret, ret_val, bError, bSuccess, bChangeFlow=0, nDots, nDelta, bDoMarkChangedBonds = 1;</a>
<a name="ln6790">    int bAdjustRadicals = 0;</a>
<a name="ln6791">    AT_NUMB          type;</a>
<a name="ln6792">    BNS_FLOW_CHANGES fcd[4*BNS_MAX_NUM_FLOW_CHANGES+1];</a>
<a name="ln6793">    ENDPOINT_INFO    eif;</a>
<a name="ln6794">#if ( KETO_ENOL_TAUT == 1 )</a>
<a name="ln6795">    ENDPOINT_INFO    eif2;</a>
<a name="ln6796">#endif</a>
<a name="ln6797"> </a>
<a name="ln6798">    /* initialize */</a>
<a name="ln6799">    switch( path_type ) {</a>
<a name="ln6800">    case ALT_PATH_MODE_TAUTOM:</a>
<a name="ln6801">        /* Check for alt path allowing to move H and (-). Purpose: confirm possible tautomerism */</a>
<a name="ln6802">        type        = BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln6803">        bChangeFlow = BNS_EF_CHNG_RSTR;</a>
<a name="ln6804">        if ( !at[nVertSingleBond].endpoint &amp;&amp;</a>
<a name="ln6805">             (!nGetEndpointInfo( at, nVertSingleBond, &amp;eif ) || !eif.cDonor ) )</a>
<a name="ln6806">            return 0;</a>
<a name="ln6807">        if ( !at[nVertDoubleBond].endpoint &amp;&amp;</a>
<a name="ln6808">             (!nGetEndpointInfo( at, nVertDoubleBond, &amp;eif ) || !eif.cAcceptor ) )</a>
<a name="ln6809">            return 0;</a>
<a name="ln6810">        break;</a>
<a name="ln6811"> </a>
<a name="ln6812">#if ( KETO_ENOL_TAUT == 1 )</a>
<a name="ln6813">    case ALT_PATH_MODE_TAUTOM_KET:</a>
<a name="ln6814">        /* Check for alt path allowing to move H and (-). Purpose: confirm possible tautomerism */</a>
<a name="ln6815">        type        = BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln6816">        bChangeFlow = BNS_EF_CHNG_RSTR;</a>
<a name="ln6817"> </a>
<a name="ln6818">        if ( !at[nVertSingleBond].endpoint &amp;&amp;</a>
<a name="ln6819">             (!nGetEndpointInfo_KET( at, nVertSingleBond, &amp;eif ) || !eif.cDonor ) )</a>
<a name="ln6820">            return 0;</a>
<a name="ln6821">        if ( !at[nVertDoubleBond].endpoint &amp;&amp;</a>
<a name="ln6822">             (!nGetEndpointInfo_KET( at, nVertDoubleBond, &amp;eif2 ) || !eif2.cAcceptor ) )</a>
<a name="ln6823">            return 0;</a>
<a name="ln6824">        /*</a>
<a name="ln6825">        if ( eif.cKetoEnolCode + eif2.cKetoEnolCode != 3 )</a>
<a name="ln6826">            return 0;</a>
<a name="ln6827">        */</a>
<a name="ln6828">        break;</a>
<a name="ln6829"> </a>
<a name="ln6830">#endif</a>
<a name="ln6831">    case ALT_PATH_MODE_CHARGE:</a>
<a name="ln6832">        /* Find alt path allowing to move (+). Purpose: establish &quot;charge groups&quot;,</a>
<a name="ln6833">           mark alt. bonds due to (+) charge movement */</a>
<a name="ln6834">        type        = BNS_VERT_TYPE_C_POINT;</a>
<a name="ln6835">        bChangeFlow = (BNS_EF_CHNG_RSTR | BNS_EF_ALTR_BONDS);</a>
<a name="ln6836">        break;</a>
<a name="ln6837"> </a>
<a name="ln6838">    case ALT_PATH_MODE_4_SALT:</a>
<a name="ln6839">    case ALT_PATH_MODE_4_SALT2:</a>
<a name="ln6840">        /* Find alt paths allowing to move (-) and H between &quot;acidic oxygen atoms&quot;.</a>
<a name="ln6841">           Purpose: mark alt bonds due to this &quot;long range&quot; tautomerism. */</a>
<a name="ln6842">        type        = BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln6843">        bChangeFlow = (BNS_EF_CHNG_RSTR | BNS_EF_ALTR_BONDS);</a>
<a name="ln6844">        if ( !bIsBnsEndpoint( pBNS, nVertSingleBond ) /* !at[nVertSingleBond].endpoint*/ &amp;&amp;</a>
<a name="ln6845">             (!nGetEndpointInfo( at, nVertSingleBond, &amp;eif ) || !eif.cDonor ) )</a>
<a name="ln6846">            return 0;</a>
<a name="ln6847">        if ( !bIsBnsEndpoint( pBNS, nVertDoubleBond ) /* !at[nVertDoubleBond].endpoint*/ &amp;&amp;</a>
<a name="ln6848">             (!nGetEndpointInfo( at, nVertDoubleBond, &amp;eif ) || !eif.cAcceptor ) )</a>
<a name="ln6849">            return 0;</a>
<a name="ln6850">        memset( &amp;apc, 0, sizeof(apc) );</a>
<a name="ln6851">        break;</a>
<a name="ln6852"> </a>
<a name="ln6853">    case ALT_PATH_MODE_REM2H_CHG:</a>
<a name="ln6854">        bChangeFlow |= BNS_EF_ALTR_BONDS; /* fall through */</a>
<a name="ln6855">    case ALT_PATH_MODE_REM2H_TST:</a>
<a name="ln6856">        bChangeFlow |= BNS_EF_CHNG_RSTR;</a>
<a name="ln6857">        type        = BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln6858">        /* allow non-tautomeric donors or any tautomeric atom */</a>
<a name="ln6859">        if ( !bIsBnsEndpoint( pBNS, nVertSingleBond ) /* not linked to a t-group or the edge forbidden */&amp;&amp;</a>
<a name="ln6860">             (!nGetEndpointInfo( at, nVertSingleBond, &amp;eif ) || !eif.cDonor ) ) /* not a donor */</a>
<a name="ln6861">            return 0;</a>
<a name="ln6862">        if ( !bIsBnsEndpoint( pBNS, nVertDoubleBond ) /* not connected to a t-group */ &amp;&amp;</a>
<a name="ln6863">             (!nGetEndpointInfo( at, nVertDoubleBond, &amp;eif ) || !eif.cDonor ) )</a>
<a name="ln6864">            return 0;</a>
<a name="ln6865">        memset( &amp;apc, 0, sizeof(apc) );</a>
<a name="ln6866">        break;</a>
<a name="ln6867"> </a>
<a name="ln6868">    case ALT_PATH_MODE_ADD2H_CHG:</a>
<a name="ln6869">        bChangeFlow |= BNS_EF_ALTR_BONDS; /* fall through */</a>
<a name="ln6870">    case ALT_PATH_MODE_ADD2H_TST:</a>
<a name="ln6871">        bChangeFlow |= BNS_EF_CHNG_RSTR;</a>
<a name="ln6872">        type        = BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln6873">        /* allow non-tautomeric acceptors or any tautomeric atom */</a>
<a name="ln6874">        if ( !bIsBnsEndpoint( pBNS, nVertSingleBond ) /* !at[nVertSingleBond].endpoint*/ &amp;&amp;</a>
<a name="ln6875">             (!nGetEndpointInfo( at, nVertSingleBond, &amp;eif ) || !eif.cAcceptor ) )</a>
<a name="ln6876">            return 0;</a>
<a name="ln6877">        if ( !bIsBnsEndpoint( pBNS, nVertDoubleBond ) /* !at[nVertSingleBond].endpoint*/ &amp;&amp;</a>
<a name="ln6878">             (!nGetEndpointInfo( at, nVertDoubleBond, &amp;eif ) || !eif.cAcceptor ) )</a>
<a name="ln6879">            return 0;</a>
<a name="ln6880">        break;</a>
<a name="ln6881"> </a>
<a name="ln6882">    case ALT_PATH_MODE_REM_PROTON:</a>
<a name="ln6883">        /* alt path is between the t-group (nVertDoubleBond) and</a>
<a name="ln6884">           the (+)-charge group (nVertSingleBond) */</a>
<a name="ln6885">        type                = 0;</a>
<a name="ln6886">        /*bDoMarkChangedBonds = 0;*/</a>
<a name="ln6887">        bChangeFlow         = (BNS_EF_SAVE_ALL | BNS_EF_UPD_H_CHARGE) | BNS_EF_ALTR_NS; /* added BNS_EF_ALTR_NS: set non-stereo altern non-ring bonds 2004-07-02*/</a>
<a name="ln6888">        break;</a>
<a name="ln6889">    default:</a>
<a name="ln6890">        type = 0;</a>
<a name="ln6891">        bChangeFlow = BNS_EF_CHNG_RSTR;</a>
<a name="ln6892">        break;</a>
<a name="ln6893">    }</a>
<a name="ln6894">    </a>
<a name="ln6895">    bError      = 0;</a>
<a name="ln6896">    bSuccess    = 0;</a>
<a name="ln6897">    nDelta      = 0;</a>
<a name="ln6898"> </a>
<a name="ln6899">    ret = SetRadEndpoints2( pBNS, pBD, RAD_SRCH_NORM );</a>
<a name="ln6900">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6901">        return ret;</a>
<a name="ln6902">    }</a>
<a name="ln6903"> </a>
<a name="ln6904">    /* set BNS to check alt path */</a>
<a name="ln6905">    ret = bSetBnsToCheckAltPath( pBNS, nVertDoubleBond, nVertSingleBond, type, path_type, &amp;apc, fcd, &amp;nDots );</a>
<a name="ln6906">    switch( ret ) {</a>
<a name="ln6907">    case  BNS_CHK_ALTP_NO_ALTPATH:</a>
<a name="ln6908">        ret = RemoveRadEndpoints( pBNS, pBD, NULL );</a>
<a name="ln6909">        return ret;</a>
<a name="ln6910">    case BNS_CHK_ALTP_SAME_TGROUP:</a>
<a name="ln6911">        bSuccess = 1;</a>
<a name="ln6912">        goto reinit_BNS;</a>
<a name="ln6913">    case BNS_CHK_ALTP_SAME_VERTEX:</a>
<a name="ln6914">        ret = RemoveRadEndpoints( pBNS, pBD, NULL );</a>
<a name="ln6915">        return ret? ret : 1; /* very strange ... set a breakpoint here */</a>
<a name="ln6916">    case BNS_CHK_ALTP_SET_SUCCESS:</a>
<a name="ln6917">        break;  /* actually check the existence of the altpath */</a>
<a name="ln6918">    case BNS_CANT_SET_BOND:</a>
<a name="ln6919">        goto reinit_BNS;</a>
<a name="ln6920">    default:</a>
<a name="ln6921">        ret_val = RemoveRadEndpoints( pBNS, pBD, NULL );</a>
<a name="ln6922">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6923">            return ret;</a>
<a name="ln6924">        }</a>
<a name="ln6925">        return BNS_PROGRAM_ERR;</a>
<a name="ln6926">    }</a>
<a name="ln6927"> </a>
<a name="ln6928">    bAdjustRadicals = ( (bChangeFlow &amp; BNS_EF_UPD_RAD_ORI) &amp;&amp; !(bChangeFlow &amp; BNS_EF_RSTR_FLOW) );</a>
<a name="ln6929"> </a>
<a name="ln6930">    /*****************************************************************</a>
<a name="ln6931">     * nDots = 2 for ALT_PATH_CHARGE (checking moveable positive charges)</a>
<a name="ln6932">     * Now nDots for ALT_PATH_TAUTOM or ALT_PATH_4_SALT can be greater</a>
<a name="ln6933">     * because some of the bonds are effectively removed and dots</a>
<a name="ln6934">     * (vertex st-caps) may be added</a>
<a name="ln6935">     * -- to make sure there is no (+) charge on a tautomeric endpoint</a>
<a name="ln6936">     * -- to fix positions of moveable tautomeric attachements</a>
<a name="ln6937">     *    (H and (-)-charges) at the ends of an alt path</a>
<a name="ln6938">     */</a>
<a name="ln6939"> </a>
<a name="ln6940">    /* run BNS */</a>
<a name="ln6941"> </a>
<a name="ln6942">    ret = RunBalancedNetworkSearch( pBNS, pBD, bChangeFlow );</a>
<a name="ln6943">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6944">        bError = ret;</a>
<a name="ln6945">    } else</a>
<a name="ln6946">    if ( ret &gt; 0 ) {</a>
<a name="ln6947">        if ( 2*ret &gt;= nDots ) {</a>
<a name="ln6948">            nDelta = 2*ret - nDots;  /* non-zero means augmentation created another alt. path -- between radicals */</a>
<a name="ln6949">            if ( pAATG &amp;&amp; pAATG-&gt;nMarkedAtom ) {</a>
<a name="ln6950">                if ( pAATG-&gt;nAtTypeTotals &amp;&amp; (bChangeFlow &amp; BNS_EF_UPD_H_CHARGE) ) {</a>
<a name="ln6951">                    memset( pAATG-&gt;nMarkedAtom, 0, num_atoms*sizeof(pAATG-&gt;nMarkedAtom[0]) );</a>
<a name="ln6952">                    /* mark atoms that have charge or H changed, check their input types (that is, before changes),</a>
<a name="ln6953">                       and subtract their input charge/H from nAtTypeTotals */</a>
<a name="ln6954">                    SubtractOrChangeAtHChargeBNS( pBNS, at, num_atoms, pAATG-&gt;nAtTypeTotals, pAATG-&gt;nMarkedAtom, NULL, 1 );</a>
<a name="ln6955">                    /* ZChange charges and/or H, update t_group_info, do not check types or change nAtTypeTotals */</a>
<a name="ln6956">                    /* Atom types will be checked and nAtTypeTotals will be changed in</a>
<a name="ln6957">                       AddChangedAtHChargeBNS() later */</a>
<a name="ln6958">                    SubtractOrChangeAtHChargeBNS( pBNS, at, num_atoms, NULL, NULL, pAATG-&gt;t_group_info, 0 );</a>
<a name="ln6959">                } else</a>
<a name="ln6960">                if ( !pAATG-&gt;nAtTypeTotals ){</a>
<a name="ln6961">                    bDoMarkChangedBonds = MarkAtomsAtTautGroups(  pBNS, num_atoms, pAATG, nVertSingleBond, nVertDoubleBond );</a>
<a name="ln6962">                    if ( bDoMarkChangedBonds &lt; 0 ) {</a>
<a name="ln6963">                        bError = bDoMarkChangedBonds;</a>
<a name="ln6964">                        bDoMarkChangedBonds = 0;</a>
<a name="ln6965">                    }</a>
<a name="ln6966">                }</a>
<a name="ln6967">            }</a>
<a name="ln6968">            if ( bDoMarkChangedBonds ) {</a>
<a name="ln6969">                /* mark bonds that were changed to configure bond testing */</a>
<a name="ln6970">                ret_val = bSetBondsAfterCheckOneBond( pBNS, fcd, -1, at, num_atoms, bChangeFlow );</a>
<a name="ln6971">                if ( IS_BNS_ERROR( ret_val ) ) {</a>
<a name="ln6972">                    bError = ret_val;</a>
<a name="ln6973">                }</a>
<a name="ln6974">                /*ret = SetBondsRestoreBnStructFlow( pBNS, at, num_atoms, bChangeFlow );*/</a>
<a name="ln6975">                /* mark all other changed bonds */</a>
<a name="ln6976">                ret = SetBondsFromBnStructFlow( pBNS, at, num_atoms, bChangeFlow );</a>
<a name="ln6977">                if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln6978">                    bError = ret;</a>
<a name="ln6979">                } else</a>
<a name="ln6980">                if ( !(ret &amp; 1) &amp;&amp; !(ret_val &amp; 1) ) {</a>
<a name="ln6981">                    bSuccess = 1;</a>
<a name="ln6982">                } else</a>
<a name="ln6983">                if ( (((ret &amp; 1) || (ret_val &amp; 1)) &amp;&amp;</a>
<a name="ln6984">                     (bChangeFlow &amp; BNS_EF_ALTR_BONDS)) || (bChangeFlow &amp; BNS_EF_UPD_H_CHARGE) ) {</a>
<a name="ln6985">                    /* some bonds have been changed to alternating */</a>
<a name="ln6986">                    bSuccess = 3;</a>
<a name="ln6987">                } else {</a>
<a name="ln6988">                    bError = BNS_BOND_ERR;</a>
<a name="ln6989">                }</a>
<a name="ln6990">                if ( !bError &amp;&amp; pAATG &amp;&amp; pAATG-&gt;nMarkedAtom &amp;&amp; (bChangeFlow &amp; BNS_EF_UPD_H_CHARGE) ) {</a>
<a name="ln6991">                    /* Update radicals to avoid errors in atom type check in AddChangedAtHChargeBNS() */</a>
<a name="ln6992">                    if ( bAdjustRadicals ) {</a>
<a name="ln6993">                        ret_val = RestoreRadicalsOnly( pBNS, pBD, at );</a>
<a name="ln6994">                        if ( IS_BNS_ERROR( ret_val ) ) {</a>
<a name="ln6995">                            bError = ret_val;</a>
<a name="ln6996">                        }</a>
<a name="ln6997">                    }</a>
<a name="ln6998">                    /* Check atom types of marked atoms and add charge/H changes to nAtTypeTotals */</a>
<a name="ln6999">                    /* Changing atoms were marked in the 1st call to SubtractOrChangeAtHChargeBNS(..., 1) above */</a>
<a name="ln7000">                    AddChangedAtHChargeBNS( at, num_atoms, pAATG-&gt;nAtTypeTotals, pAATG-&gt;nMarkedAtom );</a>
<a name="ln7001">                    if ( bChangeFlow &amp; BNS_EF_CHNG_FLOW ) {</a>
<a name="ln7002">                        /* eliminate ambiguities in already changed flow:</a>
<a name="ln7003">                           replace (+)--N==(-) with (+)==N--(-) (both represent neutral N) */</a>
<a name="ln7004">                        EliminatePlusMinusChargeAmbiguity( pBNS, num_atoms );</a>
<a name="ln7005">                    }</a>
<a name="ln7006">                }</a>
<a name="ln7007">            }</a>
<a name="ln7008">        }</a>
<a name="ln7009">        ret = RestoreBnStructFlow( pBNS, bChangeFlow &amp; BNS_EF_CHNG_RSTR);</a>
<a name="ln7010">        if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln7011">            bError = ret;</a>
<a name="ln7012">        }</a>
<a name="ln7013">    }</a>
<a name="ln7014">reinit_BNS:</a>
<a name="ln7015">    /* --- reinitialize to repeat the calculations --- */</a>
<a name="ln7016">    bRestoreBnsAfterCheckAltPath( pBNS, &amp;apc, bChangeFlow &amp; BNS_EF_UPD_H_CHARGE );</a>
<a name="ln7017">    bRestoreFlowAfterCheckOneBond( pBNS, fcd );</a>
<a name="ln7018">    ret_val = RemoveRadEndpoints( pBNS, pBD, bAdjustRadicals? at : NULL );</a>
<a name="ln7019">    ReInitBnStructAltPaths( pBNS );</a>
<a name="ln7020">    return bError? bError : ret_val? ret_val : (bSuccess + 4*nDelta);</a>
<a name="ln7021">}</a>
<a name="ln7022"> </a>
<a name="ln7023"> </a>
<a name="ln7024"> </a>
<a name="ln7025">/*****************************************************************************/</a>
<a name="ln7026">BN_STRUCT* AllocateAndInitBnStruct( inp_ATOM *at, int num_atoms, int nMaxAddAtoms, int nMaxAddEdges, int max_altp, int *pNum_changed_bonds )</a>
<a name="ln7027">{</a>
<a name="ln7028">    BN_STRUCT   *pBNS         = NULL;</a>
<a name="ln7029">    BNS_VERTEX  *vert;</a>
<a name="ln7030"> </a>
<a name="ln7031">    int    neigh, num_changed_bonds=0;</a>
<a name="ln7032">    U_CHAR bond_type, bond_mark;</a>
<a name="ln7033"> </a>
<a name="ln7034">    int i, j, k, n_edges, num_bonds, num_edges, f1, f2, edge_cap, edge_flow, st_cap, st_flow, flag_alt_bond;</a>
<a name="ln7035">    int tot_st_cap, tot_st_flow;</a>
<a name="ln7036">    int max_tg, max_edges, max_vertices, len_alt_path, max_iedges, num_altp;</a>
<a name="ln7037">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln7038">    int num_rad = 0;</a>
<a name="ln7039"> </a>
<a name="ln7040">    nMaxAddEdges += 1;</a>
<a name="ln7041">#endif</a>
<a name="ln7042">#if ( FIX_NUM_TG == 1 )</a>
<a name="ln7043">    max_tg = inchi_max( num_atoms / 2, 5);</a>
<a name="ln7044">#else</a>
<a name="ln7045">    max_tg = num_atoms;</a>
<a name="ln7046">#endif</a>
<a name="ln7047">    num_changed_bonds = 0;</a>
<a name="ln7048">    </a>
<a name="ln7049">    for ( i = 0, num_bonds = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln7050">        num_bonds += at[i].valence;</a>
<a name="ln7051">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln7052">        num_rad   += (at[i].radical == RADICAL_DOUBLET);</a>
<a name="ln7053">#endif</a>
<a name="ln7054">    }</a>
<a name="ln7055">    /* each atom has enough edges to belong to a tautomeric group + nMaxAddEdges */</a>
<a name="ln7056">    /* number of atoms is large enough to accommodate max. possible number of t-groups + nMaxAddAtoms */</a>
<a name="ln7057">    /* max_altp cannot be larger than BN_MAX_ALTP = 16 */</a>
<a name="ln7058">    num_edges    = (num_bonds /= 2);</a>
<a name="ln7059">    /* +1 for a super-tautomeric group */</a>
<a name="ln7060">    max_vertices = num_atoms + nMaxAddAtoms + max_tg + 1;</a>
<a name="ln7061">    /* +max_tg for edges between t-groups and super-tautomeric group */</a>
<a name="ln7062">    max_edges    = num_edges + (nMaxAddEdges + NUM_KINDS_OF_GROUPS)*max_vertices + max_tg;</a>
<a name="ln7063">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln7064">    if ( num_rad ) {</a>
<a name="ln7065">        max_vertices *= 2;</a>
<a name="ln7066">        max_edges    *= 2;</a>
<a name="ln7067">    }</a>
<a name="ln7068">#endif</a>
<a name="ln7069">    max_iedges   = 2*max_edges;</a>
<a name="ln7070">    len_alt_path = max_vertices+iALTP_HDR_LEN+1; /* may overflow if an edge is traversed in 2 directions */</a>
<a name="ln7071"> </a>
<a name="ln7072">    if ( !( pBNS           = (BN_STRUCT   *)inchi_calloc( 1,           sizeof(BN_STRUCT)) )  ||</a>
<a name="ln7073">         !( pBNS-&gt;edge     = (BNS_EDGE    *)inchi_calloc( max_edges,   sizeof(BNS_EDGE)) )   ||</a>
<a name="ln7074">         !( pBNS-&gt;vert     = (BNS_VERTEX  *)inchi_calloc( max_vertices,sizeof(BNS_VERTEX)) ) ||</a>
<a name="ln7075">         !( pBNS-&gt;iedge    = (BNS_IEDGE   *)inchi_calloc( max_iedges,  sizeof(BNS_IEDGE)) ) ) { </a>
<a name="ln7076">        return DeAllocateBnStruct( pBNS );</a>
<a name="ln7077">    }</a>
<a name="ln7078">    /* alt path init */</a>
<a name="ln7079">    for ( num_altp = 0; num_altp &lt; max_altp &amp;&amp; num_altp &lt; BN_MAX_ALTP; num_altp ++ ) {</a>
<a name="ln7080">        if ( !( pBNS-&gt;altp[num_altp] = (BNS_ALT_PATH*)inchi_calloc( len_alt_path,sizeof(BNS_ALT_PATH))) ) {</a>
<a name="ln7081">            return DeAllocateBnStruct( pBNS );</a>
<a name="ln7082">        }</a>
<a name="ln7083">        ALTP_ALLOCATED_LEN(pBNS-&gt;altp[num_altp]) = len_alt_path;</a>
<a name="ln7084">        pBNS-&gt;len_alt_path                 = len_alt_path;  /* ??? duplication ??? */</a>
<a name="ln7085">        /* re-init */</a>
<a name="ln7086">        ALTP_DELTA(pBNS-&gt;altp[num_altp])         = 0;</a>
<a name="ln7087">        ALTP_START_ATOM(pBNS-&gt;altp[num_altp])    = NO_VERTEX;</a>
<a name="ln7088">        ALTP_END_ATOM(pBNS-&gt;altp[num_altp])      = NO_VERTEX;</a>
<a name="ln7089">        ALTP_PATH_LEN(pBNS-&gt;altp[num_altp])      = 0;</a>
<a name="ln7090">    }</a>
<a name="ln7091">    pBNS-&gt;alt_path = NULL;</a>
<a name="ln7092">    pBNS-&gt;num_altp = 0;</a>
<a name="ln7093">    pBNS-&gt;max_altp = num_altp;</a>
<a name="ln7094"> </a>
<a name="ln7095"> </a>
<a name="ln7096">    /* fill vertices (no connectivity) */</a>
<a name="ln7097">    pBNS-&gt;vert[0].iedge = pBNS-&gt;iedge;</a>
<a name="ln7098">    for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln7099">        k = pBNS-&gt;vert[i].max_adj_edges = at[i].valence + (nMaxAddEdges + NUM_KINDS_OF_GROUPS);</a>
<a name="ln7100">        pBNS-&gt;vert[i+1].iedge = pBNS-&gt;vert[i].iedge + k;</a>
<a name="ln7101">    }</a>
<a name="ln7102">    pBNS-&gt;num_atoms       = num_atoms;      /* number of real atoms */</a>
<a name="ln7103">    pBNS-&gt;num_added_atoms = 0;</a>
<a name="ln7104">    pBNS-&gt;num_t_groups    = 0;              /* number of added t-groups */</a>
<a name="ln7105">    pBNS-&gt;num_c_groups    = 0;</a>
<a name="ln7106">    pBNS-&gt;nMaxAddAtoms    = nMaxAddAtoms;</a>
<a name="ln7107">    pBNS-&gt;nMaxAddEdges    = nMaxAddEdges;</a>
<a name="ln7108"> </a>
<a name="ln7109">    pBNS-&gt;num_vertices    = num_atoms;      /* current number of vertices, a sum of</a>
<a name="ln7110">                                               pBNS-&gt;num_atoms</a>
<a name="ln7111">                                               pBNS-&gt;num_t_groups</a>
<a name="ln7112">                                               pBNS-&gt;num_added_atoms</a>
<a name="ln7113">                                            */</a>
<a name="ln7114">    pBNS-&gt;max_vertices    = max_vertices;</a>
<a name="ln7115">    </a>
<a name="ln7116"> </a>
<a name="ln7117">    pBNS-&gt;num_bonds       = num_bonds;      /* number of real edges (bonds) */</a>
<a name="ln7118">    pBNS-&gt;max_edges       = max_edges;</a>
<a name="ln7119">    pBNS-&gt;max_iedges      = max_iedges;</a>
<a name="ln7120"> </a>
<a name="ln7121">    /* </a>
<a name="ln7122">       To remove t-groups and added atoms:</a>
<a name="ln7123">       In atoms i = 0..pBNS-&gt;num_atoms-1</a>
<a name="ln7124">            pBNS-&gt;vert[i].num_adj_edges = pBNS-&gt;vert[i].max_adj_edges - pBNS-&gt;nMaxAddEdges - NUM_KINDS_OF_GROUPS;</a>
<a name="ln7125">       pBNS-&gt;num_vertices    = pBNS-&gt;num_atoms;</a>
<a name="ln7126">       pBNS-&gt;num_edges       = pBNS-&gt;num_bonds;</a>
<a name="ln7127">       pBNS-&gt;num_added_atoms = 0;</a>
<a name="ln7128">       pBNS-&gt;num_t_groups    = 0;</a>
<a name="ln7129">       pBNS-&gt;num_added_edges = 0;</a>
<a name="ln7130"> </a>
<a name="ln7131">       ALTP_DELTA(pBNS-&gt;alt_path)      = 0;</a>
<a name="ln7132">       ALTP_START_ATOM(pBNS-&gt;alt_path) = NO_VERTEX;</a>
<a name="ln7133">       ALTP_END_ATOM(pBNS-&gt;alt_path)   = NO_VERTEX;</a>
<a name="ln7134">       ALTP_PATH_LEN(pBNS-&gt;alt_path)   = 0;</a>
<a name="ln7135"> </a>
<a name="ln7136">    */</a>
<a name="ln7137"> </a>
<a name="ln7138"> </a>
<a name="ln7139">    /* fill edges and connectivity */</a>
<a name="ln7140">    tot_st_cap = tot_st_flow = 0;</a>
<a name="ln7141">    for ( i = 0, n_edges = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln7142">        vert    = &amp;pBNS-&gt;vert[i];</a>
<a name="ln7143">        st_cap  = 0;</a>
<a name="ln7144">        st_flow = 0;</a>
<a name="ln7145">        flag_alt_bond = 0;</a>
<a name="ln7146">        for ( j = 0; j &lt; at[i].valence; j ++ ) {</a>
<a name="ln7147">            neigh = at[i].neighbor[j];</a>
<a name="ln7148">            /* find this bond at the neighbor */</a>
<a name="ln7149">            for ( k = 0; k &lt; at[neigh].valence; k ++ ) {</a>
<a name="ln7150">                if ( at[neigh].neighbor[k] == i ) {</a>
<a name="ln7151">                    break;</a>
<a name="ln7152">                }</a>
<a name="ln7153">            }</a>
<a name="ln7154">            bond_type = (at[i].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln7155">            bond_mark = (at[i].bond_type[j] &amp; ~BOND_TYPE_MASK);</a>
<a name="ln7156">            if ( bond_type != BOND_SINGLE &amp;&amp; bond_type != BOND_DOUBLE &amp;&amp;</a>
<a name="ln7157">                 bond_type != BOND_TRIPLE /*&amp;&amp; bond_type != BOND_ALTERN*/ ) {</a>
<a name="ln7158">                /* make Unknown or Alternating bonds single */</a>
<a name="ln7159">                bond_type = 1;</a>
<a name="ln7160">                at[i].bond_type[j] = bond_mark | bond_type;</a>
<a name="ln7161">                num_changed_bonds ++;</a>
<a name="ln7162">            }</a>
<a name="ln7163">            if ( neigh &gt; i ) {</a>
<a name="ln7164">                /* this is the first time we encounter this bond */</a>
<a name="ln7165">                f1 = MAX_AT_FLOW(at[i]);</a>
<a name="ln7166">                f2 = MAX_AT_FLOW(at[neigh]);</a>
<a name="ln7167">                edge_flow = bond_type-1;</a>
<a name="ln7168">                if ( edge_flow &gt; MAX_BOND_EDGE_CAP ) {</a>
<a name="ln7169">                    flag_alt_bond ++;</a>
<a name="ln7170">                    edge_flow = 0;  /* BNS will determine flows (that is, bonds) */</a>
<a name="ln7171">                    edge_cap  = AROM_BOND_EDGE_CAP;</a>
<a name="ln7172">                } else {</a>
<a name="ln7173">#if ( 0 &amp;&amp; KETO_ENOL_TAUT == 1 )  /* ????? */</a>
<a name="ln7174">                    edge_cap  = inchi_max(f1, f2);</a>
<a name="ln7175">#else</a>
<a name="ln7176">                    edge_cap  = inchi_min(f1, f2);</a>
<a name="ln7177">#endif</a>
<a name="ln7178">                    edge_cap  = inchi_min(edge_cap, MAX_BOND_EDGE_CAP); /* max capacity = 2 means up to triple bond */</a>
<a name="ln7179">                }</a>
<a name="ln7180">                pBNS-&gt;edge[n_edges].neighbor1    = (AT_NUMB)i;</a>
<a name="ln7181">                pBNS-&gt;edge[n_edges].neighbor12   = (AT_NUMB)(i ^ neigh);</a>
<a name="ln7182">                pBNS-&gt;edge[n_edges].flow =</a>
<a name="ln7183">                pBNS-&gt;edge[n_edges].flow0        = edge_flow;</a>
<a name="ln7184">                pBNS-&gt;edge[n_edges].cap  =</a>
<a name="ln7185">                pBNS-&gt;edge[n_edges].cap0         = edge_cap;</a>
<a name="ln7186">                pBNS-&gt;edge[n_edges].neigh_ord[0] = j;</a>
<a name="ln7187">                pBNS-&gt;edge[n_edges].neigh_ord[1] = k;</a>
<a name="ln7188">                pBNS-&gt;edge[n_edges].pass         = 0;</a>
<a name="ln7189">                pBNS-&gt;edge[n_edges].forbidden    = 0;</a>
<a name="ln7190"> </a>
<a name="ln7191">                vert-&gt;iedge[j] = pBNS-&gt;vert[neigh].iedge[k] = n_edges ++;</a>
<a name="ln7192">            } else {</a>
<a name="ln7193">                /* this is the second time we encounter this bond. It was stored at */</a>
<a name="ln7194">                int  iedge = pBNS-&gt;vert[neigh].iedge[k];</a>
<a name="ln7195">                edge_cap   = pBNS-&gt;edge[iedge].cap;</a>
<a name="ln7196">                edge_flow  = pBNS-&gt;edge[iedge].flow;</a>
<a name="ln7197">            }</a>
<a name="ln7198">            st_flow += edge_flow;</a>
<a name="ln7199">            st_cap  += edge_cap;</a>
<a name="ln7200">        }</a>
<a name="ln7201">        vert-&gt;num_adj_edges = j;</a>
<a name="ln7202">        vert-&gt;st_edge.cap   =</a>
<a name="ln7203">        vert-&gt;st_edge.cap0  = MAX_AT_FLOW(at[i]);</a>
<a name="ln7204">        vert-&gt;st_edge.flow  =</a>
<a name="ln7205">        vert-&gt;st_edge.flow0 = st_flow;</a>
<a name="ln7206">        vert-&gt;type          = BNS_VERT_TYPE_ATOM;</a>
<a name="ln7207">        tot_st_cap  += vert-&gt;st_edge.cap;</a>
<a name="ln7208">        tot_st_flow += vert-&gt;st_edge.flow;</a>
<a name="ln7209">    }</a>
<a name="ln7210">    *pNum_changed_bonds = num_changed_bonds/2;</a>
<a name="ln7211"> </a>
<a name="ln7212">    pBNS-&gt;num_edges       =  n_edges;   /* number of edges */</a>
<a name="ln7213">    pBNS-&gt;num_added_edges = 0;</a>
<a name="ln7214"> </a>
<a name="ln7215">    pBNS-&gt;tot_st_cap  = tot_st_cap;</a>
<a name="ln7216">    pBNS-&gt;tot_st_flow = tot_st_flow;</a>
<a name="ln7217"> </a>
<a name="ln7218">    return pBNS;</a>
<a name="ln7219">}</a>
<a name="ln7220"> </a>
<a name="ln7221"> </a>
<a name="ln7222"> </a>
<a name="ln7223">/*****************************************************************************/</a>
<a name="ln7224">BN_STRUCT* DeAllocateBnStruct( BN_STRUCT *pBNS )</a>
<a name="ln7225">{</a>
<a name="ln7226">    int i;</a>
<a name="ln7227">    if ( pBNS ) {</a>
<a name="ln7228">        if ( pBNS-&gt;edge ) {</a>
<a name="ln7229">            inchi_free( pBNS-&gt;edge );</a>
<a name="ln7230">        }</a>
<a name="ln7231">        for ( i = 0; i &lt; pBNS-&gt;max_altp &amp;&amp; i &lt; BN_MAX_ALTP ; i ++ ) {</a>
<a name="ln7232">            if ( pBNS-&gt;altp[i] ) {</a>
<a name="ln7233">                inchi_free( pBNS-&gt;altp[i] );</a>
<a name="ln7234">            }</a>
<a name="ln7235">        }</a>
<a name="ln7236">        if ( pBNS-&gt;vert ) {</a>
<a name="ln7237">            if ( pBNS-&gt;vert[0].iedge ) {</a>
<a name="ln7238">                inchi_free( pBNS-&gt;vert[0].iedge );</a>
<a name="ln7239">            }</a>
<a name="ln7240">            inchi_free( pBNS-&gt;vert );</a>
<a name="ln7241">        }</a>
<a name="ln7242">        inchi_free( pBNS );</a>
<a name="ln7243">    }</a>
<a name="ln7244">    return NULL;</a>
<a name="ln7245">}</a>
<a name="ln7246"> </a>
<a name="ln7247"> </a>
<a name="ln7248"> </a>
<a name="ln7249">/*****************************************************************************/</a>
<a name="ln7250">int ReInitBnStructAltPaths( BN_STRUCT *pBNS )</a>
<a name="ln7251">{</a>
<a name="ln7252">    int i;</a>
<a name="ln7253">    for ( i = 0; i &lt; pBNS-&gt;max_altp &amp;&amp; i &lt; BN_MAX_ALTP; i ++ ) {</a>
<a name="ln7254">        if ( pBNS-&gt;altp[i] ) {</a>
<a name="ln7255">            ALTP_DELTA(pBNS-&gt;altp[i])      = 0;</a>
<a name="ln7256">            ALTP_PATH_LEN(pBNS-&gt;altp[i])   = 0;</a>
<a name="ln7257">            ALTP_START_ATOM(pBNS-&gt;altp[i]) = NO_VERTEX;</a>
<a name="ln7258">            ALTP_END_ATOM(pBNS-&gt;altp[i])   = NO_VERTEX;</a>
<a name="ln7259">        }</a>
<a name="ln7260">    }</a>
<a name="ln7261">    pBNS-&gt;alt_path = NULL;</a>
<a name="ln7262">    pBNS-&gt;num_altp = 0;</a>
<a name="ln7263">    return i;</a>
<a name="ln7264">}</a>
<a name="ln7265"> </a>
<a name="ln7266"> </a>
<a name="ln7267"> </a>
<a name="ln7268">/*****************************************************************************/</a>
<a name="ln7269">int ReInitBnStructAddGroups( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, T_GROUP_INFO *tgi, C_GROUP_INFO *cgi )</a>
<a name="ln7270">{</a>
<a name="ln7271">    int ret;</a>
<a name="ln7272">    /* strip all t-groups and c-groups */</a>
<a name="ln7273">    ret = ReInitBnStruct( pBNS, at, num_atoms, 0 );</a>
<a name="ln7274">    if ( ret ) {</a>
<a name="ln7275">        ret = BNS_REINIT_ERR;</a>
<a name="ln7276">        goto exit_function;</a>
<a name="ln7277">    }</a>
<a name="ln7278">/*#if ( MOVE_CHARGES == 1 )*/</a>
<a name="ln7279">    if ( *pBNS-&gt;pbTautFlags &amp; TG_FLAG_MOVE_POS_CHARGES ) {</a>
<a name="ln7280">    /* add c-groups */</a>
<a name="ln7281">    ret = AddCGroups2BnStruct( pBNS, at, num_atoms, cgi );</a>
<a name="ln7282">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln7283">        goto exit_function;</a>
<a name="ln7284">    }</a>
<a name="ln7285">    }</a>
<a name="ln7286">/*#endif*/</a>
<a name="ln7287">    /* add t-groups */</a>
<a name="ln7288">    ret = AddTGroups2BnStruct( pBNS, at, num_atoms, tgi );</a>
<a name="ln7289">    if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln7290">        goto exit_function;</a>
<a name="ln7291">    }</a>
<a name="ln7292">exit_function:</a>
<a name="ln7293">    return ret;</a>
<a name="ln7294">}</a>
<a name="ln7295"> </a>
<a name="ln7296"> </a>
<a name="ln7297"> </a>
<a name="ln7298">/*****************************************************************************/</a>
<a name="ln7299">int ReInitBnStruct( BN_STRUCT *pBNS, inp_ATOM *at, int num_at, int bRemoveGroupsFromAtoms )</a>
<a name="ln7300">{</a>
<a name="ln7301">    int i, vfict, kfict, iedgefict, endpoint, centerpoint, iedge, k;</a>
<a name="ln7302">    int ret = 0;</a>
<a name="ln7303">    if ( pBNS ) {</a>
<a name="ln7304">        if ( pBNS-&gt;vert &amp;&amp; pBNS-&gt;edge ) {</a>
<a name="ln7305">            /* debug */</a>
<a name="ln7306">            for ( k = 0, i = 0; k &lt; pBNS-&gt;num_edges; k ++ ) {</a>
<a name="ln7307">                if ( pBNS-&gt;edge[k].pass ) {</a>
<a name="ln7308">                    i ++;</a>
<a name="ln7309">                }</a>
<a name="ln7310">            }</a>
<a name="ln7311">            ret += i * 100;</a>
<a name="ln7312">            /* restore flow and cap on edges to vertices connected to fictitious atoms */</a>
<a name="ln7313">            for ( vfict = pBNS-&gt;num_atoms; vfict &lt; pBNS-&gt;num_vertices; vfict ++ ) {</a>
<a name="ln7314">                for ( kfict = 0; kfict &lt; pBNS-&gt;vert[vfict].num_adj_edges; kfict ++ ) {</a>
<a name="ln7315">                    iedgefict = pBNS-&gt;vert[vfict].iedge[kfict]; /* fictitious edge to the endpoint */</a>
<a name="ln7316">                    endpoint  = pBNS-&gt;edge[iedgefict].neighbor12 ^ vfict;  /* the endpoint */</a>
<a name="ln7317">                    /* to simlify restore cap and flow in ALL edges to the endpoint */</a>
<a name="ln7318">                    if ( bRemoveGroupsFromAtoms &amp;&amp; endpoint &lt; num_at ) {</a>
<a name="ln7319">                        at[endpoint].c_point  = 0;</a>
<a name="ln7320">                        at[endpoint].endpoint = 0;</a>
<a name="ln7321">                    }</a>
<a name="ln7322">                    for ( k = 0; k &lt; pBNS-&gt;vert[endpoint].num_adj_edges; k ++ ) {</a>
<a name="ln7323">                        iedge = pBNS-&gt;vert[endpoint].iedge[k]; /* edge to endpoint */</a>
<a name="ln7324">                        centerpoint = pBNS-&gt;edge[iedge].neighbor12 ^ endpoint;</a>
<a name="ln7325">                        pBNS-&gt;edge[iedge].cap       = pBNS-&gt;edge[iedge].cap0;</a>
<a name="ln7326">                        pBNS-&gt;edge[iedge].flow      = pBNS-&gt;edge[iedge].flow0;</a>
<a name="ln7327">                        pBNS-&gt;edge[iedge].pass      = 0;</a>
<a name="ln7328">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln7329">                        pBNS-&gt;edge[iedge].forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln7330">#endif</a>
<a name="ln7331">                        pBNS-&gt;vert[centerpoint].st_edge.cap  = pBNS-&gt;vert[centerpoint].st_edge.cap0;</a>
<a name="ln7332">                        pBNS-&gt;vert[centerpoint].st_edge.flow = pBNS-&gt;vert[centerpoint].st_edge.flow0;</a>
<a name="ln7333">                    }</a>
<a name="ln7334">                    pBNS-&gt;vert[endpoint].st_edge.cap  = pBNS-&gt;vert[endpoint].st_edge.cap0;</a>
<a name="ln7335">                    pBNS-&gt;vert[endpoint].st_edge.flow = pBNS-&gt;vert[endpoint].st_edge.flow0;</a>
<a name="ln7336">                    pBNS-&gt;vert[endpoint].type &amp;= BNS_VERT_TYPE_ATOM;</a>
<a name="ln7337">                }</a>
<a name="ln7338">            }</a>
<a name="ln7339">            /* reset number of neighbors */</a>
<a name="ln7340">            if ( pBNS-&gt;num_edges &gt; pBNS-&gt;num_bonds ) {</a>
<a name="ln7341">                for ( i = 0; i &lt; pBNS-&gt;num_atoms; i ++ ) {</a>
<a name="ln7342">                    pBNS-&gt;vert[i].num_adj_edges =</a>
<a name="ln7343">                    pBNS-&gt;vert[i].max_adj_edges - pBNS-&gt;nMaxAddEdges - NUM_KINDS_OF_GROUPS;</a>
<a name="ln7344">                }</a>
<a name="ln7345">            }</a>
<a name="ln7346">        } else {</a>
<a name="ln7347">            ret += 2;</a>
<a name="ln7348">        }</a>
<a name="ln7349">        if ( !pBNS-&gt;edge ) {</a>
<a name="ln7350">            ret += 4;</a>
<a name="ln7351">        }</a>
<a name="ln7352">        if ( !pBNS-&gt;iedge ) {</a>
<a name="ln7353">            ret += 8;</a>
<a name="ln7354">        }</a>
<a name="ln7355"> </a>
<a name="ln7356">        ReInitBnStructAltPaths( pBNS );</a>
<a name="ln7357"> </a>
<a name="ln7358">        pBNS-&gt;num_vertices    = pBNS-&gt;num_atoms;</a>
<a name="ln7359">        pBNS-&gt;num_edges       = pBNS-&gt;num_bonds;</a>
<a name="ln7360">        pBNS-&gt;num_added_atoms = 0;</a>
<a name="ln7361">        pBNS-&gt;num_t_groups    = 0;</a>
<a name="ln7362">        pBNS-&gt;num_c_groups    = 0;</a>
<a name="ln7363">        pBNS-&gt;num_added_edges = 0;</a>
<a name="ln7364"> </a>
<a name="ln7365">    } else {</a>
<a name="ln7366">        ret += 1;</a>
<a name="ln7367">    }</a>
<a name="ln7368"> </a>
<a name="ln7369">    return ret;</a>
<a name="ln7370">}</a>
<a name="ln7371"> </a>
<a name="ln7372"> </a>
<a name="ln7373"> </a>
<a name="ln7374">/*****************************************************************************/</a>
<a name="ln7375">int CompTGroupNumber( const void *tg1, const void *tg2 )</a>
<a name="ln7376">{</a>
<a name="ln7377">    return (int)((const T_GROUP *)tg1)-&gt;nGroupNumber - (int)((const T_GROUP *)tg2)-&gt;nGroupNumber;</a>
<a name="ln7378">}</a>
<a name="ln7379"> </a>
<a name="ln7380"> </a>
<a name="ln7381"> </a>
<a name="ln7382">/*****************************************************************************/</a>
<a name="ln7383">int CompCGroupNumber( const void *cg1, const void *cg2 )</a>
<a name="ln7384">{</a>
<a name="ln7385">    return (int)((const C_GROUP *)cg1)-&gt;nGroupNumber - (int)((const C_GROUP *)cg2)-&gt;nGroupNumber;</a>
<a name="ln7386">}</a>
<a name="ln7387"> </a>
<a name="ln7388"> </a>
<a name="ln7389"> </a>
<a name="ln7390">/*****************************************************************************/</a>
<a name="ln7391">int AddTGroups2BnStruct( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, T_GROUP_INFO *tgi  )</a>
<a name="ln7392">{</a>
<a name="ln7393">    int ret = 0;</a>
<a name="ln7394">    /* ret = ReInitBnStruct( pBNS ); */</a>
<a name="ln7395">    if ( tgi &amp;&amp; tgi-&gt;num_t_groups &amp;&amp; tgi-&gt;t_group ) {</a>
<a name="ln7396">        int         i, k, endpoint, centerpoint, fictpoint;</a>
<a name="ln7397">        int         num_tg       = tgi-&gt;num_t_groups;</a>
<a name="ln7398">        int         num_edges    = pBNS-&gt;num_edges;</a>
<a name="ln7399">        int         num_vertices = pBNS-&gt;num_vertices;</a>
<a name="ln7400">        BNS_VERTEX *vert_ficpoint, *ver_ficpont_prev;  /* fictitious vertex describing t-group */</a>
<a name="ln7401">        BNS_VERTEX *vert_endpoint;</a>
<a name="ln7402">        BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric endpoint */</a>
<a name="ln7403">        int        nMaxTGroupNumber = 0;</a>
<a name="ln7404">        ENDPOINT_INFO eif;</a>
<a name="ln7405"> </a>
<a name="ln7406">        /* Debug: check overflow */</a>
<a name="ln7407">        if ( num_vertices + num_tg &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln7408">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln7409">        }</a>
<a name="ln7410">        /* find the largest t-group ID */</a>
<a name="ln7411">        for ( i = 0; i &lt; num_tg; i ++ ) {</a>
<a name="ln7412">            if ( tgi-&gt;t_group[i].nGroupNumber &gt; nMaxTGroupNumber ) {</a>
<a name="ln7413">                nMaxTGroupNumber = tgi-&gt;t_group[i].nGroupNumber;</a>
<a name="ln7414">            }</a>
<a name="ln7415">        }</a>
<a name="ln7416">        /* since t-group IDs may be not contiguous, clear all vertices that will be added.</a>
<a name="ln7417">           all-zeroes-vertex will be ignored by the BNS</a>
<a name="ln7418">        */</a>
<a name="ln7419">        memset( pBNS-&gt;vert+num_vertices, 0, nMaxTGroupNumber*sizeof(pBNS-&gt;vert[0]) );</a>
<a name="ln7420">        /* Make sure the last t-group has the largest t-group ID:</a>
<a name="ln7421">           this is necessary to correctly add new edges and vertices for testing augmenting paths</a>
<a name="ln7422">        */</a>
<a name="ln7423">#if ( bRELEASE_VERSION != 1 )</a>
<a name="ln7424">        insertions_sort( tgi-&gt;t_group, num_tg, sizeof(tgi-&gt;t_group[0]), CompTGroupNumber );</a>
<a name="ln7425">        for ( i = 1; i &lt; num_tg; i ++ ) {</a>
<a name="ln7426">            if ( 1 != tgi-&gt;t_group[i].nGroupNumber - tgi-&gt;t_group[i-1].nGroupNumber ) {</a>
<a name="ln7427">                return BNS_BOND_ERR;</a>
<a name="ln7428">            }</a>
<a name="ln7429">        }</a>
<a name="ln7430">#else</a>
<a name="ln7431">        if ( nMaxTGroupNumber != tgi-&gt;t_group[num_tg-1].nGroupNumber ) {</a>
<a name="ln7432">            insertions_sort( tgi-&gt;t_group, num_tg, sizeof(tgi-&gt;t_group[0]), CompTGroupNumber );</a>
<a name="ln7433">        }</a>
<a name="ln7434">#endif</a>
<a name="ln7435">        /* initialize new fictitious vertices */</a>
<a name="ln7436">        ver_ficpont_prev = pBNS-&gt;vert+num_vertices - 1;</a>
<a name="ln7437"> </a>
<a name="ln7438">        for ( i = 0; i &lt; num_tg; i ++, ver_ficpont_prev = vert_ficpoint ) {</a>
<a name="ln7439">            /*</a>
<a name="ln7440">              vert_ficpoint-1 is the last vertex;</a>
<a name="ln7441">              vert_ficpoint   is the vertex that is being added</a>
<a name="ln7442">              Note: nGroupNumber are not contiguous</a>
<a name="ln7443">            */</a>
<a name="ln7444">            vert_ficpoint                = pBNS-&gt;vert+num_vertices + tgi-&gt;t_group[i].nGroupNumber - 1;</a>
<a name="ln7445">            vert_ficpoint-&gt;iedge         = ver_ficpont_prev-&gt;iedge + ver_ficpont_prev-&gt;max_adj_edges;</a>
<a name="ln7446">            vert_ficpoint-&gt;max_adj_edges = tgi-&gt;t_group[i].nNumEndpoints+BNS_ADD_EDGES+BNS_ADD_SUPER_TGROUP;</a>
<a name="ln7447">            vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln7448">            vert_ficpoint-&gt;st_edge.flow  = vert_ficpoint-&gt;st_edge.flow0  = 0;</a>
<a name="ln7449">            vert_ficpoint-&gt;st_edge.cap   = vert_ficpoint-&gt;st_edge.cap0   = 0;</a>
<a name="ln7450">            vert_ficpoint-&gt;type          = BNS_VERT_TYPE_TGROUP;</a>
<a name="ln7451">        }</a>
<a name="ln7452"> </a>
<a name="ln7453">        for ( endpoint = 0; endpoint &lt; num_atoms; endpoint ++ ) {</a>
<a name="ln7454">            if ( !at[endpoint].endpoint )</a>
<a name="ln7455">                continue;</a>
<a name="ln7456">            fictpoint = at[endpoint].endpoint + num_vertices - 1;</a>
<a name="ln7457">            vert_ficpoint = pBNS-&gt;vert + fictpoint;</a>
<a name="ln7458">            vert_endpoint = pBNS-&gt;vert + endpoint;</a>
<a name="ln7459">            /* Debug: check overflow */</a>
<a name="ln7460">            if ( fictpoint &gt;= pBNS-&gt;max_vertices ||</a>
<a name="ln7461">                 num_edges &gt;= pBNS-&gt;max_edges    ||</a>
<a name="ln7462">                 vert_ficpoint-&gt;num_adj_edges &gt;= vert_ficpoint-&gt;max_adj_edges ||</a>
<a name="ln7463">                 vert_endpoint-&gt;num_adj_edges &gt;= vert_endpoint-&gt;max_adj_edges ) {</a>
<a name="ln7464">                ret = BNS_VERT_EDGE_OVFL;</a>
<a name="ln7465">                break;</a>
<a name="ln7466">            }</a>
<a name="ln7467">            /* obtain donor/acceptor info */</a>
<a name="ln7468">            if ( !nGetEndpointInfo( at, endpoint, &amp;eif ) ) {</a>
<a name="ln7469">#if ( KETO_ENOL_TAUT == 1 )</a>
<a name="ln7470">                if ( !((tgi-&gt;bTautFlags &amp; TG_FLAG_KETO_ENOL_TAUT ) &amp;&amp;</a>
<a name="ln7471">                        nGetEndpointInfo_KET( at, endpoint, &amp;eif )) )</a>
<a name="ln7472">#endif</a>
<a name="ln7473">                {</a>
<a name="ln7474">                    ret = BNS_BOND_ERR;</a>
<a name="ln7475">                    break;</a>
<a name="ln7476">                }</a>
<a name="ln7477">            }</a>
<a name="ln7478"> </a>
<a name="ln7479">            vert_endpoint-&gt;type |= BNS_VERT_TYPE_ENDPOINT;</a>
<a name="ln7480"> </a>
<a name="ln7481">            /* set capacity = 1 to the edges from the endpoint to the centerpoint(s) */</a>
<a name="ln7482">            for ( k = 0; k &lt; vert_endpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln7483">                int iedge = vert_endpoint-&gt;iedge[k];</a>
<a name="ln7484">                if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln7485">                    /* single bond, possibly between endpoint and centerpoint */</a>
<a name="ln7486">                    centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ endpoint);</a>
<a name="ln7487">                    if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln7488">                         pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln7489">                        int bond_type = (at[endpoint].bond_type[k] &amp; BOND_TYPE_MASK);</a>
<a name="ln7490">                        if (bond_type == BOND_TAUTOM  ||</a>
<a name="ln7491">                            bond_type == BOND_ALTERN  ||</a>
<a name="ln7492">                            bond_type == BOND_ALT12NS ||</a>
<a name="ln7493">                            bond_type == BOND_SINGLE ) {</a>
<a name="ln7494">                            pBNS-&gt;edge[iedge].cap = 1;</a>
<a name="ln7495">                        }</a>
<a name="ln7496">                    }</a>
<a name="ln7497">                }</a>
<a name="ln7498">            }</a>
<a name="ln7499">            /* create a new edge connecting endpoint to the new fictitious t-group vertex vert_ficpoint */</a>
<a name="ln7500">            edge = pBNS-&gt;edge + num_edges;</a>
<a name="ln7501">            edge-&gt;cap       = 1;</a>
<a name="ln7502">            edge-&gt;flow      = 0;</a>
<a name="ln7503">            edge-&gt;pass      = 0;</a>
<a name="ln7504">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln7505">            edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln7506">#endif</a>
<a name="ln7507">            /* later include case when the charge change allows the endpoint to become tautomeric */</a>
<a name="ln7508">            /* mark endoint having moveable H atom with flow=1 */</a>
<a name="ln7509"> </a>
<a name="ln7510">            /* -- old &quot;no charges&quot; version -- */</a>
<a name="ln7511">            /* if (at[endpoint].chem_bonds_valence == at[endpoint].valence) */</a>
<a name="ln7512">            /* -- the following line takes charges into account -- */</a>
<a name="ln7513">            if ( eif.cDonor ) /* means the endpoint has an H-atom to donate */</a>
<a name="ln7514">            {</a>
<a name="ln7515">                /* increment edge flow */</a>
<a name="ln7516">                edge-&gt;flow ++;</a>
<a name="ln7517">                /* increment one vertex st-flow &amp; cap */</a>
<a name="ln7518">                vert_ficpoint-&gt;st_edge.flow ++;</a>
<a name="ln7519">                vert_ficpoint-&gt;st_edge.cap ++;</a>
<a name="ln7520">                /* increment another vertex st-flow &amp; cap */</a>
<a name="ln7521">                vert_endpoint-&gt;st_edge.flow ++;</a>
<a name="ln7522">                vert_endpoint-&gt;st_edge.cap ++;</a>
<a name="ln7523">            }</a>
<a name="ln7524">            /* connect edge to endpoint and fictpoint and increment the counters of neighbors and edges */</a>
<a name="ln7525">            edge-&gt;neighbor1    = endpoint; /* the smallest out of v1=endopoint and v2=num_vertices */</a>
<a name="ln7526">            edge-&gt;neighbor12   = endpoint ^ fictpoint; /* v1 ^ v2 */</a>
<a name="ln7527">            vert_endpoint-&gt;iedge[vert_endpoint-&gt;num_adj_edges] = num_edges;</a>
<a name="ln7528">            vert_ficpoint-&gt;iedge[vert_ficpoint-&gt;num_adj_edges] = num_edges ++;</a>
<a name="ln7529">            edge-&gt;neigh_ord[0] = vert_endpoint-&gt;num_adj_edges ++;</a>
<a name="ln7530">            edge-&gt;neigh_ord[1] = vert_ficpoint-&gt;num_adj_edges ++;</a>
<a name="ln7531">            edge-&gt;cap0  = edge-&gt;cap;</a>
<a name="ln7532">            edge-&gt;flow0 = edge-&gt;flow;</a>
<a name="ln7533">        }</a>
<a name="ln7534"> </a>
<a name="ln7535">        pBNS-&gt;num_edges     = num_edges;</a>
<a name="ln7536">        pBNS-&gt;num_vertices += nMaxTGroupNumber;</a>
<a name="ln7537">        pBNS-&gt;num_t_groups  = num_tg;</a>
<a name="ln7538"> </a>
<a name="ln7539">    }</a>
<a name="ln7540">    return ret;</a>
<a name="ln7541">}</a>
<a name="ln7542"> </a>
<a name="ln7543"> </a>
<a name="ln7544"> </a>
<a name="ln7545">/*****************************************************************************/</a>
<a name="ln7546">/*#if ( MOVE_CHARGES == 1 )*/ /* { */</a>
<a name="ln7547"> </a>
<a name="ln7548"> </a>
<a name="ln7549"> </a>
<a name="ln7550">/*****************************************************************************/</a>
<a name="ln7551">int AddCGroups2BnStruct( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, C_GROUP_INFO *cgi  )</a>
<a name="ln7552">{</a>
<a name="ln7553">    int ret = 0;</a>
<a name="ln7554">    /* ret = ReInitBnStruct( pBNS ); */</a>
<a name="ln7555">    if ( cgi &amp;&amp; cgi-&gt;num_c_groups &amp;&amp; cgi-&gt;c_group ) {</a>
<a name="ln7556">        int         i, k, c_point, centerpoint, fictpoint;</a>
<a name="ln7557">        int         num_cg       = cgi-&gt;num_c_groups;</a>
<a name="ln7558">        int         num_edges    = pBNS-&gt;num_edges;</a>
<a name="ln7559">        int         num_vertices = pBNS-&gt;num_vertices;</a>
<a name="ln7560">        BNS_VERTEX *vert_ficpoint, *ver_ficpont_prev;  /* fictitious vertex describing charge c-group */</a>
<a name="ln7561">        BNS_VERTEX *vertex_cpoint;</a>
<a name="ln7562">        BNS_EDGE   *edge;      /* edge between that vertex and the tautomeric c_point */</a>
<a name="ln7563">        int        nMaxCGroupNumber = 0;</a>
<a name="ln7564"> </a>
<a name="ln7565">        /* Debug: check overflow */</a>
<a name="ln7566">        if ( num_vertices + num_cg &gt;= pBNS-&gt;max_vertices ) {</a>
<a name="ln7567">            return BNS_VERT_EDGE_OVFL;</a>
<a name="ln7568">        }</a>
<a name="ln7569">        /* find the largest t-group ID */</a>
<a name="ln7570">        for ( i = 0; i &lt; num_cg; i ++ ) {</a>
<a name="ln7571">            if ( cgi-&gt;c_group[i].nGroupNumber &gt; nMaxCGroupNumber ) {</a>
<a name="ln7572">                nMaxCGroupNumber = cgi-&gt;c_group[i].nGroupNumber;</a>
<a name="ln7573">            }</a>
<a name="ln7574">        }</a>
<a name="ln7575">        /* since t-group IDs may be not contiguous, clear all vertices that will be added.</a>
<a name="ln7576">           all-zeroes-vertex will be ignored by the BNS</a>
<a name="ln7577">        */</a>
<a name="ln7578">        memset( pBNS-&gt;vert+num_vertices, 0, nMaxCGroupNumber*sizeof(pBNS-&gt;vert[0]) );</a>
<a name="ln7579">        /* Make sure the last t-group has the largest t-group ID:</a>
<a name="ln7580">           this is necessary to correctly add new edges and vertices for testing augmenting paths</a>
<a name="ln7581">        */</a>
<a name="ln7582">#if ( bRELEASE_VERSION != 1 )</a>
<a name="ln7583">        insertions_sort( cgi-&gt;c_group, num_cg, sizeof(cgi-&gt;c_group[0]), CompCGroupNumber );</a>
<a name="ln7584">        for ( i = 1; i &lt; num_cg; i ++ ) {</a>
<a name="ln7585">            if ( 1 != cgi-&gt;c_group[i].nGroupNumber - cgi-&gt;c_group[i-1].nGroupNumber ) {</a>
<a name="ln7586">                return BNS_BOND_ERR;</a>
<a name="ln7587">            }</a>
<a name="ln7588">        }</a>
<a name="ln7589">#else</a>
<a name="ln7590">        if ( nMaxCGroupNumber != cgi-&gt;c_group[num_cg-1].nGroupNumber ) {</a>
<a name="ln7591">            insertions_sort( cgi-&gt;c_group, num_cg, sizeof(cgi-&gt;c_group[0]), CompCGroupNumber );</a>
<a name="ln7592">        }</a>
<a name="ln7593">#endif</a>
<a name="ln7594">        /**************************************/</a>
<a name="ln7595">        /* initialize new fictitious vertices */</a>
<a name="ln7596">        /* representing c-point groups        */</a>
<a name="ln7597">        /**************************************/</a>
<a name="ln7598">        ver_ficpont_prev = pBNS-&gt;vert+num_vertices - 1;</a>
<a name="ln7599">        </a>
<a name="ln7600">        for ( i = 0; i &lt; num_cg; i ++, ver_ficpont_prev = vert_ficpoint ) {</a>
<a name="ln7601">            /*</a>
<a name="ln7602">              vert_ficpoint-1 is the last vertex;</a>
<a name="ln7603">              vert_ficpoint   is the being added vertex</a>
<a name="ln7604">              Note: nGroupNumber are not contiguous</a>
<a name="ln7605">            */</a>
<a name="ln7606">            vert_ficpoint                = pBNS-&gt;vert+num_vertices + cgi-&gt;c_group[i].nGroupNumber - 1;</a>
<a name="ln7607">            vert_ficpoint-&gt;iedge         = ver_ficpont_prev-&gt;iedge + ver_ficpont_prev-&gt;max_adj_edges;</a>
<a name="ln7608">            vert_ficpoint-&gt;max_adj_edges = cgi-&gt;c_group[i].num_CPoints+BNS_ADD_EDGES;</a>
<a name="ln7609">            vert_ficpoint-&gt;num_adj_edges = 0;</a>
<a name="ln7610">            vert_ficpoint-&gt;st_edge.flow  = vert_ficpoint-&gt;st_edge.flow0  = 0;</a>
<a name="ln7611">            vert_ficpoint-&gt;st_edge.cap   = vert_ficpoint-&gt;st_edge.cap0   = 0;</a>
<a name="ln7612">            vert_ficpoint-&gt;type          = BNS_VERT_TYPE_C_GROUP;</a>
<a name="ln7613">        }</a>
<a name="ln7614"> </a>
<a name="ln7615">        /************************************************/</a>
<a name="ln7616">        /* connect c-points to the fictitious vertices  */</a>
<a name="ln7617">        /* representing c-point groups; set caps, flows */</a>
<a name="ln7618">        /************************************************/</a>
<a name="ln7619">        for ( c_point = 0; c_point &lt; num_atoms; c_point ++ ) {</a>
<a name="ln7620">            if ( !at[c_point].c_point )</a>
<a name="ln7621">                continue;</a>
<a name="ln7622">            fictpoint = at[c_point].c_point + num_vertices - 1; /* c-group vertex index */</a>
<a name="ln7623">            vert_ficpoint = pBNS-&gt;vert + fictpoint; /* c-group vertex */</a>
<a name="ln7624">            vertex_cpoint = pBNS-&gt;vert + c_point;   /* c_point vertex */</a>
<a name="ln7625">            /* Debug: check overflow */</a>
<a name="ln7626">            if ( fictpoint &gt;= pBNS-&gt;max_vertices ||</a>
<a name="ln7627">                 num_edges &gt;= pBNS-&gt;max_edges    ||</a>
<a name="ln7628">                 vert_ficpoint-&gt;num_adj_edges &gt;= vert_ficpoint-&gt;max_adj_edges ||</a>
<a name="ln7629">                 vertex_cpoint-&gt;num_adj_edges &gt;= vertex_cpoint-&gt;max_adj_edges ) {</a>
<a name="ln7630">                ret = BNS_VERT_EDGE_OVFL;</a>
<a name="ln7631">                break;</a>
<a name="ln7632">            }</a>
<a name="ln7633">            vertex_cpoint-&gt;type |= BNS_VERT_TYPE_C_POINT;</a>
<a name="ln7634">#if ( FIX_CPOINT_BOND_CAP != 1 )  /* { */</a>
<a name="ln7635">            /* set capacity = 1 to the edges from the c_point to the centerpoint(s)     */</a>
<a name="ln7636">            /* if their current capacity is zero                                        */</a>
<a name="ln7637">            /* the centerpoint is any adjacent atom that is adjacent to a multiple bond */</a>
<a name="ln7638">            for ( k = 0; k &lt; vertex_cpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln7639">                int iedge = vertex_cpoint-&gt;iedge[k];</a>
<a name="ln7640">                if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln7641">                    /* single bond, possibly between c_point and centerpoint */</a>
<a name="ln7642">                    centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ c_point);</a>
<a name="ln7643">                    if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln7644">                         pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln7645">                        int bond_type = (at[c_point].bond_type[k] &amp; BOND_TYPE_MASK);</a>
<a name="ln7646">                        if ( bond_type == BOND_TAUTOM ||</a>
<a name="ln7647">                             bond_type == BOND_ALTERN ||</a>
<a name="ln7648">                             bond_type == BOND_SINGLE ) {</a>
<a name="ln7649">                            pBNS-&gt;edge[iedge].cap = 1;</a>
<a name="ln7650">                        }</a>
<a name="ln7651">                    }</a>
<a name="ln7652">                }</a>
<a name="ln7653">            }</a>
<a name="ln7654">#endif /* } FIX_CPOINT_BOND_CAP */</a>
<a name="ln7655">            /* create a new edge connecting c_point to the new fictitious c-group vertex vert_ficpoint */</a>
<a name="ln7656">            edge = pBNS-&gt;edge + num_edges;</a>
<a name="ln7657">            edge-&gt;cap       = 1;</a>
<a name="ln7658">            edge-&gt;flow      = 0;</a>
<a name="ln7659">            edge-&gt;pass      = 0;</a>
<a name="ln7660">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln7661">            edge-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln7662">#endif</a>
<a name="ln7663">            /* mark edge to c-point having NO moveable charge with flow=1 */</a>
<a name="ln7664">            if ( !CHARGED_CPOINT(at,c_point) ) {</a>
<a name="ln7665">                /* increment edge flow */</a>
<a name="ln7666">                edge-&gt;flow ++;</a>
<a name="ln7667">                /* increment c-group vertex st-flow &amp; cap */</a>
<a name="ln7668">                vert_ficpoint-&gt;st_edge.flow ++;</a>
<a name="ln7669">                vert_ficpoint-&gt;st_edge.cap ++;</a>
<a name="ln7670">                /* increment c-point vertex st-flow &amp; cap */</a>
<a name="ln7671">                vertex_cpoint-&gt;st_edge.flow ++;</a>
<a name="ln7672">                vertex_cpoint-&gt;st_edge.cap ++;</a>
<a name="ln7673">            }</a>
<a name="ln7674">#if ( FIX_CPOINT_BOND_CAP == 1 ) /* { */</a>
<a name="ln7675">            /* set capacity = 1 to the edges from the c_point to the centerpoint(s)     */</a>
<a name="ln7676">            /* if their current capacity is zero                                        */</a>
<a name="ln7677">            /* the centerpoint is any adjacent atom that is adjacent to a multiple bond */</a>
<a name="ln7678">            for ( k = 0; k &lt; vertex_cpoint-&gt;num_adj_edges; k ++ ) {</a>
<a name="ln7679">                int iedge = vertex_cpoint-&gt;iedge[k];</a>
<a name="ln7680">                VertexFlow  nNewCap = vertex_cpoint-&gt;st_edge.cap;</a>
<a name="ln7681">                centerpoint = (pBNS-&gt;edge[iedge].neighbor12 ^ c_point);</a>
<a name="ln7682">                if ( !pBNS-&gt;edge[iedge].cap ) {</a>
<a name="ln7683">                    /* single bond, possibly between c_point and centerpoint */</a>
<a name="ln7684">                    if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln7685">                         pBNS-&gt;vert[centerpoint].st_edge.cap &gt;= 1 ) {</a>
<a name="ln7686">                        nNewCap = inchi_min( pBNS-&gt;vert[centerpoint].st_edge.cap, nNewCap );</a>
<a name="ln7687">                        nNewCap = inchi_min( nNewCap, MAX_BOND_EDGE_CAP );</a>
<a name="ln7688">                        pBNS-&gt;edge[iedge].cap = nNewCap;</a>
<a name="ln7689">                    }</a>
<a name="ln7690">#if ( FIX_CPOINT_BOND_CAP2 == 1 ) /* multiple bond */</a>
<a name="ln7691">                    else</a>
<a name="ln7692">                    if ( centerpoint &lt; pBNS-&gt;num_atoms &amp;&amp;</a>
<a name="ln7693">                         edge-&gt;flow &amp;&amp; pBNS-&gt;edge[iedge].cap &lt; MAX_BOND_EDGE_CAP ) {</a>
<a name="ln7694">                        pBNS-&gt;edge[iedge].cap ++;</a>
<a name="ln7695">                    }</a>
<a name="ln7696">#endif</a>
<a name="ln7697">                }</a>
<a name="ln7698">            }</a>
<a name="ln7699">#endif  /* } FIX_CPOINT_BOND_CAP */</a>
<a name="ln7700">            /* connect edge to c_point and fictpoint and increment the counters of neighbors and edges */</a>
<a name="ln7701">            edge-&gt;neighbor1    = c_point; /* the smallest out of v1=endopoint and v2=num_vertices */</a>
<a name="ln7702">            edge-&gt;neighbor12   = c_point ^ fictpoint; /* v1 ^ v2 */</a>
<a name="ln7703">            vertex_cpoint-&gt;iedge[vertex_cpoint-&gt;num_adj_edges] = num_edges;</a>
<a name="ln7704">            vert_ficpoint-&gt;iedge[vert_ficpoint-&gt;num_adj_edges] = num_edges ++;</a>
<a name="ln7705">            edge-&gt;neigh_ord[0] = vertex_cpoint-&gt;num_adj_edges ++;</a>
<a name="ln7706">            edge-&gt;neigh_ord[1] = vert_ficpoint-&gt;num_adj_edges ++;</a>
<a name="ln7707">            edge-&gt;cap0  = edge-&gt;cap;</a>
<a name="ln7708">            edge-&gt;flow0 = edge-&gt;flow;</a>
<a name="ln7709"> </a>
<a name="ln7710">        }</a>
<a name="ln7711"> </a>
<a name="ln7712">        pBNS-&gt;num_edges     = num_edges;</a>
<a name="ln7713">        pBNS-&gt;num_vertices += nMaxCGroupNumber;</a>
<a name="ln7714">        pBNS-&gt;num_c_groups  = num_cg;</a>
<a name="ln7715"> </a>
<a name="ln7716">    }</a>
<a name="ln7717">    return ret;</a>
<a name="ln7718">}</a>
<a name="ln7719">/*#endif*/ /* } MOVE_CHARGES == 1 */</a>
<a name="ln7720"> </a>
<a name="ln7721"> </a>
<a name="ln7722"> </a>
<a name="ln7723"> </a>
<a name="ln7724">/*****************************************************************************/</a>
<a name="ln7725">void ClearAllBnDataVertices( Vertex *v, Vertex value, int size )</a>
<a name="ln7726">{</a>
<a name="ln7727">    int i;</a>
<a name="ln7728">    for ( i = 0; i &lt; size; i ++ ) {</a>
<a name="ln7729">        v[i] = value;</a>
<a name="ln7730">    }</a>
<a name="ln7731">}</a>
<a name="ln7732"> </a>
<a name="ln7733"> </a>
<a name="ln7734"> </a>
<a name="ln7735">/*****************************************************************************/</a>
<a name="ln7736">void ClearAllBnDataEdges( Edge *e, Vertex value, int size )</a>
<a name="ln7737">{</a>
<a name="ln7738">    int i;</a>
<a name="ln7739">    for ( i = 0; i &lt; size; i ++ ) {</a>
<a name="ln7740">        e[i][0] = value;</a>
<a name="ln7741">    }</a>
<a name="ln7742">}</a>
<a name="ln7743"> </a>
<a name="ln7744"> </a>
<a name="ln7745">/*****************************************************************************/</a>
<a name="ln7746">BN_DATA *DeAllocateBnData( BN_DATA *pBD )</a>
<a name="ln7747">{</a>
<a name="ln7748">    if ( pBD ) {</a>
<a name="ln7749">        if ( pBD-&gt;BasePtr )</a>
<a name="ln7750">            inchi_free( pBD-&gt;BasePtr );</a>
<a name="ln7751">        if ( pBD-&gt;SwitchEdge )</a>
<a name="ln7752">            inchi_free( pBD-&gt;SwitchEdge );</a>
<a name="ln7753">        if ( pBD-&gt;Tree )</a>
<a name="ln7754">            inchi_free( pBD-&gt;Tree );</a>
<a name="ln7755">        if ( pBD-&gt;ScanQ )</a>
<a name="ln7756">            inchi_free( pBD-&gt;ScanQ );</a>
<a name="ln7757">        if ( pBD-&gt;Pu )</a>
<a name="ln7758">            inchi_free( pBD-&gt;Pu );</a>
<a name="ln7759">        if ( pBD-&gt;Pv )</a>
<a name="ln7760">            inchi_free( pBD-&gt;Pv );</a>
<a name="ln7761">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln7762">        if ( pBD-&gt;RadEndpoints ) {</a>
<a name="ln7763">            inchi_free( pBD-&gt;RadEndpoints );</a>
<a name="ln7764">        }</a>
<a name="ln7765">        if ( pBD-&gt;RadEdges ) {</a>
<a name="ln7766">            inchi_free( pBD-&gt;RadEdges );</a>
<a name="ln7767">        }</a>
<a name="ln7768">#endif</a>
<a name="ln7769">        inchi_free( pBD );</a>
<a name="ln7770">    }</a>
<a name="ln7771">    return NULL;</a>
<a name="ln7772">}</a>
<a name="ln7773"> </a>
<a name="ln7774"> </a>
<a name="ln7775">/*****************************************************************************/</a>
<a name="ln7776">BN_DATA *AllocateAndInitBnData( int max_num_vertices ) </a>
<a name="ln7777">{</a>
<a name="ln7778">    BN_DATA *pBD = NULL;</a>
<a name="ln7779">    int      max_len_Pu_Pv;</a>
<a name="ln7780">    max_num_vertices = 2*max_num_vertices+2;</a>
<a name="ln7781">    max_len_Pu_Pv    = max_num_vertices/2+1;</a>
<a name="ln7782">    max_len_Pu_Pv   += max_len_Pu_Pv % 2; /* even length */</a>
<a name="ln7783">    if ( !(pBD             = (BN_DATA *) inchi_calloc( 1, sizeof(BN_DATA) ) ) ||</a>
<a name="ln7784">         !(pBD-&gt;BasePtr    = (Vertex *)  inchi_calloc( max_num_vertices, sizeof(Vertex) ) ) ||</a>
<a name="ln7785">         !(pBD-&gt;SwitchEdge = (Edge   *)  inchi_calloc( max_num_vertices, sizeof(Edge  ) ) ) ||</a>
<a name="ln7786">         !(pBD-&gt;Tree       = (S_CHAR *)  inchi_calloc( max_num_vertices, sizeof(S_CHAR) ) ) ||</a>
<a name="ln7787">         !(pBD-&gt;ScanQ      = (Vertex *)  inchi_calloc( max_num_vertices, sizeof(Vertex) ) ) ||</a>
<a name="ln7788">         !(pBD-&gt;Pu         = (Vertex *)  inchi_calloc( max_len_Pu_Pv,    sizeof(Vertex) ) ) ||</a>
<a name="ln7789">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln7790">         !(pBD-&gt;RadEndpoints = (Vertex *)   inchi_calloc( max_len_Pu_Pv, sizeof(Vertex) ) ) ||</a>
<a name="ln7791">         !(pBD-&gt;RadEdges     = (EdgeIndex*) inchi_calloc( max_len_Pu_Pv, sizeof(EdgeIndex) ) ) ||</a>
<a name="ln7792">#endif</a>
<a name="ln7793">         !(pBD-&gt;Pv         = (Vertex *)  inchi_calloc( max_len_Pu_Pv,    sizeof(Vertex) ) ) </a>
<a name="ln7794">       ) {</a>
<a name="ln7795">        pBD = DeAllocateBnData( pBD );</a>
<a name="ln7796">    } else {</a>
<a name="ln7797">        /* Initialize data */</a>
<a name="ln7798">        ClearAllBnDataEdges(pBD-&gt;SwitchEdge, NO_VERTEX, max_num_vertices);</a>
<a name="ln7799">        ClearAllBnDataVertices(pBD-&gt;BasePtr, NO_VERTEX, max_num_vertices);</a>
<a name="ln7800">        memset(pBD-&gt;Tree, TREE_NOT_IN_M, max_num_vertices);</a>
<a name="ln7801">        pBD-&gt;QSize = -1;</a>
<a name="ln7802">        pBD-&gt;max_len_Pu_Pv    = max_len_Pu_Pv;</a>
<a name="ln7803">        pBD-&gt;max_num_vertices = max_num_vertices;</a>
<a name="ln7804">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln7805">        pBD-&gt;nNumRadEndpoints = 0;</a>
<a name="ln7806">#endif</a>
<a name="ln7807">    }</a>
<a name="ln7808">    return pBD;</a>
<a name="ln7809">}</a>
<a name="ln7810"> </a>
<a name="ln7811"> </a>
<a name="ln7812"> </a>
<a name="ln7813">/*****************************************************************************/</a>
<a name="ln7814">int ReInitBnData( BN_DATA *pBD )</a>
<a name="ln7815">{</a>
<a name="ln7816">    int i, ret = 0;</a>
<a name="ln7817">    Vertex u, v;</a>
<a name="ln7818">    if ( pBD ) {</a>
<a name="ln7819">        if ( !pBD-&gt;ScanQ ) {</a>
<a name="ln7820">            ret += 2;</a>
<a name="ln7821">        }</a>
<a name="ln7822">        if ( !pBD-&gt;BasePtr ) {</a>
<a name="ln7823">            ret += 4;</a>
<a name="ln7824">        }</a>
<a name="ln7825">        if ( !pBD-&gt;SwitchEdge ) {</a>
<a name="ln7826">            ret += 8;</a>
<a name="ln7827">        }</a>
<a name="ln7828">        if ( !pBD-&gt;Tree ) {</a>
<a name="ln7829">            ret += 16;</a>
<a name="ln7830">        }</a>
<a name="ln7831">        if ( !ret ) {</a>
<a name="ln7832">            for ( i = 0; i &lt;= pBD-&gt;QSize; i ++ ) {</a>
<a name="ln7833">                u = pBD-&gt;ScanQ[i];</a>
<a name="ln7834">                v = prim(u);</a>
<a name="ln7835">                pBD-&gt;BasePtr[u]     =</a>
<a name="ln7836">                pBD-&gt;BasePtr[v]     =</a>
<a name="ln7837">                pBD-&gt;SwitchEdge_Vert1(u) =</a>
<a name="ln7838">                pBD-&gt;SwitchEdge_Vert1(v) = NO_VERTEX;</a>
<a name="ln7839">                pBD-&gt;Tree[u]        =</a>
<a name="ln7840">                pBD-&gt;Tree[v]        = TREE_NOT_IN_M;</a>
<a name="ln7841">            }</a>
<a name="ln7842">        }</a>
<a name="ln7843">        pBD-&gt;QSize = -1;</a>
<a name="ln7844">        if ( !pBD-&gt;Pu ) {</a>
<a name="ln7845">            ret += 32;</a>
<a name="ln7846">        }</a>
<a name="ln7847">        if ( !pBD-&gt;Pv ) {</a>
<a name="ln7848">            ret += 64;</a>
<a name="ln7849">        }</a>
<a name="ln7850">    } else {</a>
<a name="ln7851">        ret += 1;</a>
<a name="ln7852">    }</a>
<a name="ln7853">    </a>
<a name="ln7854">    return ret;</a>
<a name="ln7855">}</a>
<a name="ln7856"> </a>
<a name="ln7857"> </a>
<a name="ln7858"> </a>
<a name="ln7859">/*****************************************************************************/</a>
<a name="ln7860">int GetVertexDegree( BN_STRUCT* pBNS, Vertex v )</a>
<a name="ln7861">{</a>
<a name="ln7862">    int i = v / 2 - 1;</a>
<a name="ln7863">    if ( i &gt;= 0 ) {</a>
<a name="ln7864">        if ( pBNS-&gt;vert[i].st_edge.cap &gt; 0 ) {</a>
<a name="ln7865">            return pBNS-&gt;vert[i].num_adj_edges+1; /* add 1 neighbor for s or t */</a>
<a name="ln7866">        } else {</a>
<a name="ln7867">            return 0;   /* since the edge s-v has zero capacity, we ignore vertex v */</a>
<a name="ln7868">        }</a>
<a name="ln7869">    } else {</a>
<a name="ln7870">        return pBNS-&gt;num_vertices;</a>
<a name="ln7871">    }</a>
<a name="ln7872">}</a>
<a name="ln7873"> </a>
<a name="ln7874"> </a>
<a name="ln7875"> </a>
<a name="ln7876">/*****************************************************************************/</a>
<a name="ln7877">Vertex Get2ndEdgeVertex( BN_STRUCT* pBNS, Edge uv )</a>
<a name="ln7878">{</a>
<a name="ln7879">    /*</a>
<a name="ln7880">    Vertex ret;</a>
<a name="ln7881">    */</a>
<a name="ln7882">    if ( uv[1] &gt;= 0 ) {</a>
<a name="ln7883">        /* -- debug --</a>
<a name="ln7884">        if ( uv[1] &gt; pBNS-&gt;num_edges || uv[0] &gt; 2*pBNS-&gt;num_vertices+3 ) {</a>
<a name="ln7885">            int stop = 1;</a>
<a name="ln7886">        }</a>
<a name="ln7887">        ret = ((uv[0]-2) ^ (2*pBNS-&gt;edge[uv[1]].neighbor12+1)) + 2;</a>
<a name="ln7888">        if ( ret &gt; 2*pBNS-&gt;num_vertices+3 ) {</a>
<a name="ln7889">            int stop = 1;</a>
<a name="ln7890">        }</a>
<a name="ln7891">        return ret;</a>
<a name="ln7892">          -- end debug -- */</a>
<a name="ln7893">        return ((uv[0]-2) ^ (2*pBNS-&gt;edge[uv[1]].neighbor12+1)) + 2;</a>
<a name="ln7894">        /*short u = uv[0]-FIRST_INDX; */</a>
<a name="ln7895">        /*short t = 2*(((u / 2 - 1) ^ pBNS-&gt;edge[uv[1]].neighbor12) + 1) + ((u+1) &amp; 1) + FIRST_INDX; */</a>
<a name="ln7896">        /*return t; */</a>
<a name="ln7897">    }</a>
<a name="ln7898">    if ( uv[0] &lt;= 1 )</a>
<a name="ln7899">        return -(1 + uv[1]); /* vertex1 is s or t, return x or y */</a>
<a name="ln7900">    else</a>
<a name="ln7901">        return uv[0] % 2; /* vertex1 is x or y, return s or t; never happens? -- NSC 3737, 7634,... */</a>
<a name="ln7902">}    </a>
<a name="ln7903"> </a>
<a name="ln7904"> </a>
<a name="ln7905"> </a>
<a name="ln7906">/*****************************************************************************/</a>
<a name="ln7907">Vertex GetVertexNeighbor( BN_STRUCT* pBNS, Vertex v, int neigh, EdgeIndex *iedge )</a>
<a name="ln7908">{</a>
<a name="ln7909">    /* neigh = 0 =&gt; the neighbor is s or t except case when v is s or t. */</a>
<a name="ln7910">    /* v= FIRST_INDX or FIRST_INDX+1: v is s or t respectively */</a>
<a name="ln7911">    int i, neighbor;</a>
<a name="ln7912">    if ( (i = v - 2) &gt;= 0 ) {</a>
<a name="ln7913">        /* neighbor of x or y */</a>
<a name="ln7914">        if ( neigh ) {</a>
<a name="ln7915">            neigh --;</a>
<a name="ln7916">            /* x or y */</a>
<a name="ln7917">            *iedge = pBNS-&gt;vert[i/2].iedge[neigh];</a>
<a name="ln7918">            if ( !(pBNS-&gt;edge[*iedge].cap &amp; EDGE_FLOW_MASK) || IS_FORBIDDEN(pBNS-&gt;edge[*iedge].forbidden, pBNS) ) {</a>
<a name="ln7919">                return NO_VERTEX;</a>
<a name="ln7920">            }</a>
<a name="ln7921">            neighbor = (i ^ (2 * pBNS-&gt;edge[*iedge].neighbor12 + 1)) + 2; /* parity opposite to v parity */</a>
<a name="ln7922">        } else {</a>
<a name="ln7923">            /* neighbor of x or y is s or t */</a>
<a name="ln7924">            neighbor = (v &amp; 1); /* s or t, same parity as v */</a>
<a name="ln7925">            *iedge   = -( neighbor + 1 );</a>
<a name="ln7926">        }</a>
<a name="ln7927">    } else {</a>
<a name="ln7928">        /* neighbor of s or t: x or y, same parity as v */</a>
<a name="ln7929">        if ( !(pBNS-&gt;vert[neigh].st_edge.cap &amp; EDGE_FLOW_ST_MASK) ) {</a>
<a name="ln7930">            return NO_VERTEX;</a>
<a name="ln7931">        }</a>
<a name="ln7932">        neighbor = 2*neigh + 2 + (v &amp; 1); /* parity same as the parity of v */</a>
<a name="ln7933">        *iedge   = -( neighbor + 1 );</a>
<a name="ln7934">    }</a>
<a name="ln7935">    return neighbor;</a>
<a name="ln7936">}</a>
<a name="ln7937"> </a>
<a name="ln7938"> </a>
<a name="ln7939"> </a>
<a name="ln7940">/*****************************************************************************/</a>
<a name="ln7941">int GetEdgePointer( BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv, BNS_EDGE **uv, S_CHAR *s_or_t )</a>
<a name="ln7942">{</a>
<a name="ln7943">    int i = u / 2 - 1;</a>
<a name="ln7944">    int j = v / 2 - 1;</a>
<a name="ln7945">    int bBackward = BNS_WRONG_PARMS;</a>
<a name="ln7946">    *uv = NULL;</a>
<a name="ln7947">    if ( i &gt;= 0 ) {</a>
<a name="ln7948">        /* u is an atom */</a>
<a name="ln7949">        if ( j &gt;= 0 ) {</a>
<a name="ln7950">            /* v is an atom */</a>
<a name="ln7951">            if ( (u+v)%2 ) {</a>
<a name="ln7952">                *uv = pBNS-&gt;edge+iuv;</a>
<a name="ln7953">                bBackward = ( u &amp; 1 );</a>
<a name="ln7954">                *s_or_t = 0;</a>
<a name="ln7955">            }</a>
<a name="ln7956">        } else</a>
<a name="ln7957">        /* v is s or t */</a>
<a name="ln7958">        if ( v &gt;= 0 &amp;&amp; !((u+v)%2) ) {</a>
<a name="ln7959">            *uv = (BNS_EDGE*)&amp;pBNS-&gt;vert[i].st_edge;</a>
<a name="ln7960">            bBackward = !(v &amp; 1);</a>
<a name="ln7961">            *s_or_t = v+3; /* 3=&gt; v=s, 4=&gt; v=t */</a>
<a name="ln7962">        }</a>
<a name="ln7963">    } else </a>
<a name="ln7964">    if ( j &gt;= 0 ) {</a>
<a name="ln7965">        /* u is s or t */</a>
<a name="ln7966">        if ( u &gt;= 0 &amp;&amp; !((u+v)%2) ) {</a>
<a name="ln7967">            /* v is an atom */</a>
<a name="ln7968">            *uv = (BNS_EDGE*)&amp;pBNS-&gt;vert[j].st_edge;</a>
<a name="ln7969">            bBackward = (u &amp; 1 );</a>
<a name="ln7970">            *s_or_t = u+1; /* 1=&gt; u=s, 2=&gt; u=t */</a>
<a name="ln7971">        }</a>
<a name="ln7972">    }</a>
<a name="ln7973">    return bBackward;</a>
<a name="ln7974">}</a>
<a name="ln7975"> </a>
<a name="ln7976"> </a>
<a name="ln7977"> </a>
<a name="ln7978">/*****************************************************************************/</a>
<a name="ln7979">int AugmentEdge( BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv, int delta, S_CHAR bReverse, int bChangeFlow )</a>
<a name="ln7980">{</a>
<a name="ln7981">    int f, flow, ret=0;</a>
<a name="ln7982"> </a>
<a name="ln7983">    BNS_ST_EDGE    *pst_edge;</a>
<a name="ln7984">    BNS_EDGE       *pedge;</a>
<a name="ln7985">    S_CHAR          s_or_t;</a>
<a name="ln7986">    int bBackward = GetEdgePointer( pBNS, u, v, iuv, &amp;pedge, &amp;s_or_t );</a>
<a name="ln7987">    if ( !IS_BNS_ERROR(bBackward) ) {</a>
<a name="ln7988">        if ( bBackward ) {</a>
<a name="ln7989">            delta = -delta;</a>
<a name="ln7990">        }</a>
<a name="ln7991">        </a>
<a name="ln7992">        if ( s_or_t ) {</a>
<a name="ln7993">            pst_edge = ( BNS_ST_EDGE *) pedge;</a>
<a name="ln7994">            flow = pst_edge-&gt;flow;</a>
<a name="ln7995">            f    =  (flow &amp; EDGE_FLOW_ST_MASK) + delta; /* new flow */</a>
<a name="ln7996">            if ( !delta ) {</a>
<a name="ln7997">                /*((BNS_ST_EDGE *)pedge)-&gt;flow = pst_edge-&gt;flow &amp; ~EDGE_FLOW_ST_PATH;*/</a>
<a name="ln7998">                pst_edge-&gt;flow = pst_edge-&gt;flow &amp; ~EDGE_FLOW_ST_PATH;</a>
<a name="ln7999">            } else {</a>
<a name="ln8000">                int cap = pst_edge-&gt;cap;</a>
<a name="ln8001">                if ( f &lt; 0 || f &gt; cap ) {</a>
<a name="ln8002">                    ret = BNS_WRONG_PARMS;</a>
<a name="ln8003">                } else {</a>
<a name="ln8004">                    if ( !(bChangeFlow &amp; BNS_EF_CHNG_FLOW) ) {</a>
<a name="ln8005">                        f -= delta; /* do not actually change the flow, only find the augmenting path */</a>
<a name="ln8006">                    } else</a>
<a name="ln8007">                    if ( delta ) {</a>
<a name="ln8008">                        /*((BNS_ST_EDGE *)pedge)-&gt;pass ++;*/</a>
<a name="ln8009">                        pst_edge-&gt;pass ++;</a>
<a name="ln8010">                    }</a>
<a name="ln8011">                    flow = (flow &amp; ~(EDGE_FLOW_ST_PATH | EDGE_FLOW_ST_MASK)) + f;</a>
<a name="ln8012">                    /*((BNS_ST_EDGE *)pedge)-&gt;flow = flow;*/</a>
<a name="ln8013">                    pst_edge-&gt;flow = flow;</a>
<a name="ln8014">                    /*((BNS_ST_EDGE *)pedge)-&gt;delta += delta; */</a>
<a name="ln8015">                    if ( bReverse ) {</a>
<a name="ln8016">                        /* u &lt;- v; Note: in case of bReverse s_or_t has actually been determined</a>
<a name="ln8017">                                         for the u' &lt;- v' pair; therefore s and t should be switched</a>
<a name="ln8018">                                         in order to correctly determine the 1st or the last atom</a>
<a name="ln8019">                                         on the augmenting path.</a>
<a name="ln8020">                        */</a>
<a name="ln8021">                        switch( s_or_t ) {</a>
<a name="ln8022">                        case 1: /* u = t: t&lt;-v, v is the last vertex */</a>
<a name="ln8023">                            ALTP_END_ATOM(pBNS-&gt;alt_path) = v / 2 - 1;</a>
<a name="ln8024">                            break;</a>
<a name="ln8025">                        case 2: /* u = s: s&lt;-v, error */</a>
<a name="ln8026">                            ret = BNS_WRONG_PARMS;</a>
<a name="ln8027">                            break;</a>
<a name="ln8028">                        case 3: /* v = t: u&lt;-t, error */</a>
<a name="ln8029">                            ret = BNS_WRONG_PARMS;</a>
<a name="ln8030">                            break;</a>
<a name="ln8031">                        case 4: /* v = s: u&lt;-s, u is the first vertex */</a>
<a name="ln8032">                            ALTP_START_ATOM(pBNS-&gt;alt_path) = u / 2 - 1;</a>
<a name="ln8033">                            ALTP_DELTA(pBNS-&gt;alt_path) = delta;</a>
<a name="ln8034">                            break;</a>
<a name="ln8035">                        default:</a>
<a name="ln8036">                            ret = BNS_WRONG_PARMS;</a>
<a name="ln8037">                            break;</a>
<a name="ln8038">                        }</a>
<a name="ln8039">                    } else {</a>
<a name="ln8040">                        /* u -&gt; v */</a>
<a name="ln8041">                        switch( s_or_t ) {</a>
<a name="ln8042">                        case 1: /* u = s: s-&gt;v, v is the first vertex */</a>
<a name="ln8043">                            ALTP_START_ATOM(pBNS-&gt;alt_path) = v / 2 - 1;</a>
<a name="ln8044">                            ALTP_DELTA(pBNS-&gt;alt_path) = delta;</a>
<a name="ln8045">                            break;</a>
<a name="ln8046">                        case 2: /* u = t: t-&gt;v, error */</a>
<a name="ln8047">                            ret = BNS_WRONG_PARMS;</a>
<a name="ln8048">                            break;</a>
<a name="ln8049">                        case 3: /* v = s: u-&gt;s, error */</a>
<a name="ln8050">                            ret = BNS_WRONG_PARMS;</a>
<a name="ln8051">                            break;</a>
<a name="ln8052">                        case 4: /* v = t: u-&gt;t, u is the last vertex */</a>
<a name="ln8053">                            ALTP_END_ATOM(pBNS-&gt;alt_path) = u / 2 - 1;</a>
<a name="ln8054">                            break;</a>
<a name="ln8055">                        default:</a>
<a name="ln8056">                            ret = BNS_WRONG_PARMS;</a>
<a name="ln8057">                            break;</a>
<a name="ln8058">                        }</a>
<a name="ln8059">                    }</a>
<a name="ln8060">                }</a>
<a name="ln8061">            }</a>
<a name="ln8062">        } else {</a>
<a name="ln8063">            f = (pedge-&gt;flow &amp; EDGE_FLOW_MASK) + delta; </a>
<a name="ln8064">            if ( !delta ) {</a>
<a name="ln8065">                pedge-&gt;flow &amp;= ~EDGE_FLOW_PATH;</a>
<a name="ln8066">            } else {</a>
<a name="ln8067">                if ( f &lt; 0 || f &gt; pedge-&gt;cap ) {</a>
<a name="ln8068">                    ret = BNS_WRONG_PARMS;</a>
<a name="ln8069">                } else {</a>
<a name="ln8070">                    AT_NUMB   iu = u / 2 - 1;</a>
<a name="ln8071">                    AT_NUMB   iv = v / 2 - 1;</a>
<a name="ln8072">                    int       indx;</a>
<a name="ln8073">                    if ( !(bChangeFlow &amp; BNS_EF_CHNG_FLOW) ) {</a>
<a name="ln8074">                        f -= delta; /* do not actually change the flow, only find the augmenting path */</a>
<a name="ln8075">                    } else</a>
<a name="ln8076">                    if ( delta ) {</a>
<a name="ln8077">                        pedge-&gt;pass ++;</a>
<a name="ln8078">                    }</a>
<a name="ln8079">                    pedge-&gt;flow = (pedge-&gt;flow &amp; ~(EDGE_FLOW_PATH | EDGE_FLOW_MASK)) | f;</a>
<a name="ln8080">                    if ( ALTP_MAY_ADD(pBNS-&gt;alt_path) ) {</a>
<a name="ln8081">                        /* bReverse? u &lt;- v : u -&gt; v */</a>
<a name="ln8082">                        indx = bReverse? (pedge-&gt;neighbor1 == iv) : (pedge-&gt;neighbor1 == iu);</a>
<a name="ln8083">                        ALTP_CUR_THIS_ATOM_NEIGHBOR(pBNS-&gt;alt_path) = pedge-&gt;neigh_ord[1-indx];</a>
<a name="ln8084">                        ALTP_CUR_NEXT_ATOM_NEIGHBOR(pBNS-&gt;alt_path) = pedge-&gt;neigh_ord[indx];</a>
<a name="ln8085">                        ALTP_NEXT(pBNS-&gt;alt_path);</a>
<a name="ln8086">                    } else {</a>
<a name="ln8087">                        ALTP_OVERFLOW(pBNS-&gt;alt_path) = 1;</a>
<a name="ln8088">                        ret = BNS_ALTPATH_OVFL;</a>
<a name="ln8089">                    }</a>
<a name="ln8090">                }</a>
<a name="ln8091">            }</a>
<a name="ln8092">        }</a>
<a name="ln8093">        return ret? ret : f;</a>
<a name="ln8094"> </a>
<a name="ln8095">    }</a>
<a name="ln8096">    return bBackward;</a>
<a name="ln8097">}</a>
<a name="ln8098"> </a>
<a name="ln8099"> </a>
<a name="ln8100"> </a>
<a name="ln8101">/*********************************************************************************/</a>
<a name="ln8102">/* find residual capacity and mark the edge as belonging to the augmenting path  */</a>
<a name="ln8103">/*********************************************************************************/</a>
<a name="ln8104">int rescap_mark( BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv )</a>
<a name="ln8105">{</a>
<a name="ln8106">    BNS_ST_EDGE    *pst_edge;</a>
<a name="ln8107">    BNS_EDGE       *pedge;</a>
<a name="ln8108"> </a>
<a name="ln8109">    int    f, flow;</a>
<a name="ln8110">    S_CHAR s_or_t;</a>
<a name="ln8111">    int    bBackward = GetEdgePointer( pBNS, u, v, iuv, &amp;pedge, &amp;s_or_t );</a>
<a name="ln8112">    </a>
<a name="ln8113">    if ( !IS_BNS_ERROR( bBackward ) ) {</a>
<a name="ln8114">        </a>
<a name="ln8115">        if ( s_or_t ) {</a>
<a name="ln8116">            pst_edge = (BNS_ST_EDGE *)pedge;</a>
<a name="ln8117">            flow = pst_edge-&gt;flow;</a>
<a name="ln8118">            f    = (flow &amp; EDGE_FLOW_ST_MASK);</a>
<a name="ln8119">            if ( !bBackward ) {</a>
<a name="ln8120">                f = (int)pst_edge-&gt;cap - f;</a>
<a name="ln8121">            }</a>
<a name="ln8122">            if ( flow &amp; EDGE_FLOW_ST_PATH ) {</a>
<a name="ln8123">                pBNS-&gt;bNotASimplePath ++;</a>
<a name="ln8124">                f /= 2;   /* this is the second time we pass the same edge: reduce flow by a factor of 2 */</a>
<a name="ln8125">            } else {</a>
<a name="ln8126">                pst_edge-&gt;flow |= EDGE_FLOW_ST_PATH; /* mark the edge */</a>
<a name="ln8127">            }</a>
<a name="ln8128">        } else {</a>
<a name="ln8129">            flow = pedge-&gt;flow;</a>
<a name="ln8130">            f    = flow &amp; EDGE_FLOW_MASK;</a>
<a name="ln8131">            if ( !bBackward ) {</a>
<a name="ln8132">                f = (int)pedge-&gt;cap - f;</a>
<a name="ln8133">            }</a>
<a name="ln8134">            if ( flow &amp; EDGE_FLOW_PATH ) {</a>
<a name="ln8135">                f /= 2;    /* this is the second time we pass the same edge: reduce flow by a factor of 2 */</a>
<a name="ln8136">                pBNS-&gt;bNotASimplePath ++;</a>
<a name="ln8137">            } else {</a>
<a name="ln8138">                pedge-&gt;flow |= EDGE_FLOW_PATH;  /* mark the edge */</a>
<a name="ln8139">            }</a>
<a name="ln8140">        }</a>
<a name="ln8141">        return f;</a>
<a name="ln8142"> </a>
<a name="ln8143">    }</a>
<a name="ln8144">    return bBackward;</a>
<a name="ln8145">}</a>
<a name="ln8146"> </a>
<a name="ln8147"> </a>
<a name="ln8148"> </a>
<a name="ln8149">/*****************************************************************************</a>
<a name="ln8150">*	Get previous vertex in the searched path                                 *</a>
<a name="ln8151">*	z is SwitchEdge_Vert2(y) != y. Go backward from z to y                   *</a>
<a name="ln8152">******************************************************************************/</a>
<a name="ln8153">Vertex GetPrevVertex( BN_STRUCT* pBNS, Vertex y, Edge *SwitchEdge, EdgeIndex *iuv )</a>
<a name="ln8154">{</a>
<a name="ln8155">    Vertex w, z, x2, y2, n;</a>
<a name="ln8156">    EdgeIndex iwy;</a>
<a name="ln8157"> </a>
<a name="ln8158">    w   = SwitchEdge_Vert1(y);</a>
<a name="ln8159">    z   = SwitchEdge_Vert2(y);</a>
<a name="ln8160">    iwy = SwitchEdge_IEdge(y);</a>
<a name="ln8161">    if ( z == y ) {</a>
<a name="ln8162">        *iuv = iwy;</a>
<a name="ln8163">        return w;</a>
<a name="ln8164">    }</a>
<a name="ln8165">    x2 = prim(y);</a>
<a name="ln8166">    y2 = prim(z);</a>
<a name="ln8167">    n = 0;</a>
<a name="ln8168">    while ( y2 != NO_VERTEX ) {</a>
<a name="ln8169">        w   = SwitchEdge_Vert1(y2);</a>
<a name="ln8170">        z   = SwitchEdge_Vert2(y2);</a>
<a name="ln8171">        iwy = SwitchEdge_IEdge(y2);</a>
<a name="ln8172">        if ( w == x2 ) {</a>
<a name="ln8173">            *iuv = iwy;</a>
<a name="ln8174">            /*return z; */</a>
<a name="ln8175">            return (y + z)%2? z : prim(z);</a>
<a name="ln8176">        }</a>
<a name="ln8177">        n ++;</a>
<a name="ln8178">#ifdef _DEBUG</a>
<a name="ln8179">        if ( n ) {</a>
<a name="ln8180">            int stop = 1;</a>
<a name="ln8181">        }</a>
<a name="ln8182">#endif</a>
<a name="ln8183">        if ( w == y2 )</a>
<a name="ln8184">            return NO_VERTEX;</a>
<a name="ln8185">        y2 = w;</a>
<a name="ln8186">    }</a>
<a name="ln8187">    return y2;</a>
<a name="ln8188">}</a>
<a name="ln8189"> </a>
<a name="ln8190"> </a>
<a name="ln8191"> </a>
<a name="ln8192">#define CHECK_TACN  1</a>
<a name="ln8193"> </a>
<a name="ln8194"> </a>
<a name="ln8195"> </a>
<a name="ln8196"> </a>
<a name="ln8197">/*****************************************************************************</a>
<a name="ln8198">   The purpose is to avoid paths</a>
<a name="ln8199"> </a>
<a name="ln8200">     (H-group)[u]---atom[v]---((-)-cgroup)[w],  </a>
<a name="ln8201">     </a>
<a name="ln8202">     where atom[v] is not acidic and (-) and H are not interchangeable without</a>
<a name="ln8203">     explicit bond tautomerism.</a>
<a name="ln8204">   </a>
<a name="ln8205">   It is important that acidic atoms are only O,S,Se,Te and should have</a>
<a name="ln8206">   only one chemical bond. Only because of this an early rejection of</a>
<a name="ln8207">   the vertex v (before it gets on SCANQ) is possible.</a>
<a name="ln8208"> </a>
<a name="ln8209">   CHECK_TACN == 1 prohibits replacing (-) on N with H unless H can be moved to N</a>
<a name="ln8210">   along an alternating path from another heteroatom (t-group will be detected).</a>
<a name="ln8211">*****************************************************************************/</a>
<a name="ln8212"> </a>
<a name="ln8213"> </a>
<a name="ln8214"> </a>
<a name="ln8215">#if ( FIX_TACN_POSSIBLE_BUG == 1 ) /* { */</a>
<a name="ln8216"> </a>
<a name="ln8217"> </a>
<a name="ln8218"> </a>
<a name="ln8219">/*****************************************************************************/</a>
<a name="ln8220">int bIgnoreVertexNonTACN_atom( BN_STRUCT* pBNS, Vertex u, Vertex v )</a>
<a name="ln8221">{</a>
<a name="ln8222">#define TYPE_T   1   /* t-group [also called H-group] */</a>
<a name="ln8223">#define TYPE_CN  2   /* (-)c-group */</a>
<a name="ln8224">    int    i, degree, ret, u_is_taut=0, w_is_taut, num_allowed=0, num_found_groups=0;</a>
<a name="ln8225">    Vertex w;</a>
<a name="ln8226">    EdgeIndex ivw;</a>
<a name="ln8227">    if ( !pBNS-&gt;type_TACN || u &lt;= 1 || v &lt;= 1 ||</a>
<a name="ln8228">         (pBNS-&gt;vert[v/2-1].type &amp; pBNS-&gt;type_TACN) ) {</a>
<a name="ln8229">        return 0; /* add/remove H(+) is allowed for acidic atoms */</a>
<a name="ln8230">    }</a>
<a name="ln8231">    if ( !pBNS-&gt;type_T || !pBNS-&gt;type_CN )</a>
<a name="ln8232">        return 0; /* should not happen */</a>
<a name="ln8233">    u_is_taut = ((pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T )? TYPE_T  :</a>
<a name="ln8234">                ((pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)? TYPE_CN : 0;</a>
<a name="ln8235">    if ( u_is_taut ) {</a>
<a name="ln8236">        /* u is either t-group vertex or (-) c-group */</a>
<a name="ln8237">        degree = GetVertexDegree( pBNS, v );</a>
<a name="ln8238">        for ( i = 0; i &lt; degree; i ++ ) {</a>
<a name="ln8239">            /* v = vert[u].neighbor[i]; */</a>
<a name="ln8240">            w = GetVertexNeighbor( pBNS, v, i, &amp;ivw );</a>
<a name="ln8241">            if ( w == NO_VERTEX || w &lt;= 1 ) {</a>
<a name="ln8242">                continue; /* the atom has only single bonds or it is s or t, ignore it */</a>
<a name="ln8243">            }</a>
<a name="ln8244">            if ( w != u &amp;&amp; (ret = rescap(pBNS, v, w, ivw)) &gt; 0 ) {</a>
<a name="ln8245">                num_allowed ++;</a>
<a name="ln8246">                w_is_taut = ((pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)? TYPE_CN :</a>
<a name="ln8247">                            ((pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T )? TYPE_T  : 0;</a>
<a name="ln8248">                if ( (u_is_taut | w_is_taut) == (TYPE_T | TYPE_CN) ) {</a>
<a name="ln8249">                    num_found_groups ++;</a>
<a name="ln8250">                }</a>
<a name="ln8251">            }</a>
<a name="ln8252">        }</a>
<a name="ln8253">        if ( num_found_groups &amp;&amp; num_allowed == 1 ) {</a>
<a name="ln8254">            return 1; /* reject */</a>
<a name="ln8255">        }</a>
<a name="ln8256">    }</a>
<a name="ln8257">    return 0;</a>
<a name="ln8258">#undef TYPE_T</a>
<a name="ln8259">#undef TYPE_CN</a>
<a name="ln8260">}</a>
<a name="ln8261"> </a>
<a name="ln8262"> </a>
<a name="ln8263"> </a>
<a name="ln8264">#else  /* } FIX_TACN_POSSIBLE_BUG { */</a>
<a name="ln8265"> </a>
<a name="ln8266"> </a>
<a name="ln8267"> </a>
<a name="ln8268">/*****************************************************************************/</a>
<a name="ln8269">int bIgnoreVertexNonTACN_atom( BN_STRUCT* pBNS, Vertex u, Vertex v )</a>
<a name="ln8270">{</a>
<a name="ln8271">    int    i, degree, ret, u_is_taut=0, num_allowed=0, num_found_groups=0;</a>
<a name="ln8272">    Vertex w;</a>
<a name="ln8273">    EdgeIndex ivw;</a>
<a name="ln8274">    if ( !pBNS-&gt;type_TACN || u &lt;= 1 || v &lt;= 1 ||</a>
<a name="ln8275">         (pBNS-&gt;vert[v/2-1].type &amp; pBNS-&gt;type_TACN) ) {</a>
<a name="ln8276">        return 0; /* add/remove H(+) is allowed for acidic atoms */</a>
<a name="ln8277">    }</a>
<a name="ln8278">    if ( !pBNS-&gt;type_T || !pBNS-&gt;type_CN )</a>
<a name="ln8279">        return 0; /* should not happen */</a>
<a name="ln8280">    if ( (u_is_taut  = (pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T) ||</a>
<a name="ln8281">         (             (pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)  ) {</a>
<a name="ln8282">        /* u is either t-group vertex or (-) c-group */</a>
<a name="ln8283">        degree = GetVertexDegree( pBNS, v );</a>
<a name="ln8284">        for ( i = 0; i &lt; degree; i ++ ) {</a>
<a name="ln8285">            /* v = vert[u].neighbor[i]; */</a>
<a name="ln8286">            w = GetVertexNeighbor( pBNS, v, i, &amp;ivw );</a>
<a name="ln8287">            if ( w == NO_VERTEX || w &lt;= 1 ) {</a>
<a name="ln8288">                continue; /* the atom has only single bonds or it is s or t, ignore it */</a>
<a name="ln8289">            }</a>
<a name="ln8290">            if ( w != u &amp;&amp; (ret = rescap(pBNS, v, w, ivw)) &gt; 0 ) {</a>
<a name="ln8291">                num_allowed ++;</a>
<a name="ln8292">                if ( (u_is_taut? ((pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN) :</a>
<a name="ln8293">                                 ((pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T ) ) ) {</a>
<a name="ln8294">                    num_found_groups ++;</a>
<a name="ln8295">                }</a>
<a name="ln8296">            }</a>
<a name="ln8297">        }</a>
<a name="ln8298">        if ( num_found_groups &amp;&amp; num_allowed == 1 ) {</a>
<a name="ln8299">            return 1; /* reject */</a>
<a name="ln8300">        }</a>
<a name="ln8301"> </a>
<a name="ln8302">    }</a>
<a name="ln8303">    return 0;</a>
<a name="ln8304">}</a>
<a name="ln8305"> </a>
<a name="ln8306"> </a>
<a name="ln8307"> </a>
<a name="ln8308">#endif /* } FIX_TACN_POSSIBLE_BUG */</a>
<a name="ln8309"> </a>
<a name="ln8310"> </a>
<a name="ln8311"> </a>
<a name="ln8312">/*****************************************************************************</a>
<a name="ln8313">   The purpose is to avoid paths</a>
<a name="ln8314">     (H-group)[u]---atom[v]---((-)-cgroup)[w],  </a>
<a name="ln8315">     </a>
<a name="ln8316">     where atom[v] is not acidic and (-) and H are not interchangeable without</a>
<a name="ln8317">     explicit bond tautomerism.</a>
<a name="ln8318">   </a>
<a name="ln8319">   It is important that acidic atoms are only O,S,Se,Te and should have</a>
<a name="ln8320">   only one chemical bond. Only because of this an early rejection of</a>
<a name="ln8321">   the vertex v (before it gets on SCANQ) is possible.</a>
<a name="ln8322">*****************************************************************************/</a>
<a name="ln8323"> </a>
<a name="ln8324"> </a>
<a name="ln8325"> </a>
<a name="ln8326">#if ( FIX_TACN_POSSIBLE_BUG == 1 ) /* { */</a>
<a name="ln8327"> </a>
<a name="ln8328"> </a>
<a name="ln8329"> </a>
<a name="ln8330">/*****************************************************************************/</a>
<a name="ln8331">int bIgnoreVertexNonTACN_group( BN_STRUCT* pBNS, Vertex v, Vertex w, Edge *SwitchEdge )</a>
<a name="ln8332">{</a>
<a name="ln8333">#define TYPE_T   1   /* t-group [also called H-group] */</a>
<a name="ln8334">#define TYPE_CN  2   /* (-)c-group */</a>
<a name="ln8335">    int    u_is_taut=0, w_is_taut=0;</a>
<a name="ln8336">    Vertex u;</a>
<a name="ln8337">    EdgeIndex iuv;</a>
<a name="ln8338">    if ( v &lt;= 1 || w &lt;= 1 )</a>
<a name="ln8339">        return 0;</a>
<a name="ln8340">#if ( CHECK_TACN == 1 )</a>
<a name="ln8341">    if ( !pBNS-&gt;type_TACN ||</a>
<a name="ln8342">         (pBNS-&gt;vert[v/2-1].type &amp; pBNS-&gt;type_TACN) ) {</a>
<a name="ln8343">        return 0;</a>
<a name="ln8344">    }</a>
<a name="ln8345">    if ( !pBNS-&gt;type_T || !pBNS-&gt;type_CN )</a>
<a name="ln8346">        return 0; /* should not happen */</a>
<a name="ln8347">#endif</a>
<a name="ln8348">    u = GetPrevVertex( pBNS, v, SwitchEdge, &amp;iuv );</a>
<a name="ln8349">    /*</a>
<a name="ln8350">    u   = SwitchEdge_Vert1(v);</a>
<a name="ln8351">    iuv = SwitchEdge_IEdge(v);</a>
<a name="ln8352">    */</a>
<a name="ln8353">    if ( u == NO_VERTEX || iuv &lt; 0 )</a>
<a name="ln8354">        return 0; /* should not happen */</a>
<a name="ln8355">    /* check edge adjacency */</a>
<a name="ln8356">    if ( pBNS-&gt;edge[iuv].neighbor1  != (u/2-1)  &amp;&amp; pBNS-&gt;edge[iuv].neighbor1 != v/2-1 ||</a>
<a name="ln8357">         (pBNS-&gt;edge[iuv].neighbor12 ^ (u/2-1)) != (v/2-1) ) {</a>
<a name="ln8358">        return 0; /* !!! should not happen !!! */</a>
<a name="ln8359">    }</a>
<a name="ln8360">         </a>
<a name="ln8361">#if ( CHECK_TACN == 1 )</a>
<a name="ln8362">    u_is_taut = ((pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T )? TYPE_T :</a>
<a name="ln8363">                ((pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)? TYPE_CN : 0;</a>
<a name="ln8364">    w_is_taut = ((pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T )? TYPE_T :</a>
<a name="ln8365">                ((pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)? TYPE_CN : 0;</a>
<a name="ln8366">    if ( (u_is_taut | w_is_taut) == (TYPE_T | TYPE_CN ) ) {</a>
<a name="ln8367">        /* rescap must have already been checked */</a>
<a name="ln8368">        return 1;</a>
<a name="ln8369">    }</a>
<a name="ln8370">#endif</a>
<a name="ln8371"> </a>
<a name="ln8372">    return 0;</a>
<a name="ln8373">#undef TYPE_T</a>
<a name="ln8374">#undef TYPE_CN</a>
<a name="ln8375">}</a>
<a name="ln8376"> </a>
<a name="ln8377"> </a>
<a name="ln8378"> </a>
<a name="ln8379">#else  /* } FIX_TACN_POSSIBLE_BUG { */</a>
<a name="ln8380"> </a>
<a name="ln8381"> </a>
<a name="ln8382"> </a>
<a name="ln8383">/*****************************************************************************/</a>
<a name="ln8384">int bIgnoreVertexNonTACN_group( BN_STRUCT* pBNS, Vertex v, Vertex w, Edge *SwitchEdge )</a>
<a name="ln8385">{</a>
<a name="ln8386">    int    u_is_taut=0, w_is_taut=0;</a>
<a name="ln8387">    Vertex u;</a>
<a name="ln8388">    EdgeIndex iuv;</a>
<a name="ln8389">    if ( v &lt;= 1 || w &lt;= 1 )</a>
<a name="ln8390">        return 0;</a>
<a name="ln8391">#if ( CHECK_TACN == 1 )</a>
<a name="ln8392">    if ( !pBNS-&gt;type_TACN ||</a>
<a name="ln8393">         (pBNS-&gt;vert[v/2-1].type &amp; pBNS-&gt;type_TACN) ) {</a>
<a name="ln8394">        return 0;</a>
<a name="ln8395">    }</a>
<a name="ln8396">    if ( !pBNS-&gt;type_T || !pBNS-&gt;type_CN )</a>
<a name="ln8397">        return 0; /* should not happen */</a>
<a name="ln8398">#endif</a>
<a name="ln8399">    u = GetPrevVertex( pBNS, v, SwitchEdge, &amp;iuv );</a>
<a name="ln8400">    /*</a>
<a name="ln8401">    u   = SwitchEdge_Vert1(v);</a>
<a name="ln8402">    iuv = SwitchEdge_IEdge(v);</a>
<a name="ln8403">    */</a>
<a name="ln8404">    if ( u == NO_VERTEX || iuv &lt; 0 )</a>
<a name="ln8405">        return 0; /* should not happen */</a>
<a name="ln8406">    /* check edge adjacency */</a>
<a name="ln8407">    if ( (pBNS-&gt;edge[iuv].neighbor1  != (u/2-1)  &amp;&amp; pBNS-&gt;edge[iuv].neighbor1 != v/2-1) ||</a>
<a name="ln8408">         (pBNS-&gt;edge[iuv].neighbor12 ^ (u/2-1)) != (v/2-1) ) {</a>
<a name="ln8409">        return 0; /* !!! should not happen !!! */</a>
<a name="ln8410">    }</a>
<a name="ln8411">         </a>
<a name="ln8412">#if ( CHECK_TACN == 1 )</a>
<a name="ln8413">    if ( ((u_is_taut  = (pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T) ||</a>
<a name="ln8414">          (             (pBNS-&gt;vert[u/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)) &amp;&amp;</a>
<a name="ln8415">         ((w_is_taut  = (pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T) ||</a>
<a name="ln8416">          (             (pBNS-&gt;vert[w/2-1].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)) &amp;&amp;</a>
<a name="ln8417">         u_is_taut + w_is_taut == 1 ) {</a>
<a name="ln8418">        /* rescap must have already been checked */</a>
<a name="ln8419">        return 1;</a>
<a name="ln8420">    }</a>
<a name="ln8421">#endif</a>
<a name="ln8422"> </a>
<a name="ln8423">    return 0;</a>
<a name="ln8424">}</a>
<a name="ln8425">#endif /* } FIX_TACN_POSSIBLE_BUG { */</a>
<a name="ln8426"> </a>
<a name="ln8427"> </a>
<a name="ln8428"> </a>
<a name="ln8429">#if ( FIX_KEEP_H_ON_NH_ANION == 1 )</a>
<a name="ln8430"> </a>
<a name="ln8431"> </a>
<a name="ln8432"> </a>
<a name="ln8433">/*********************************************************************************/</a>
<a name="ln8434">/* Detect an attempt to remove H from -NH(-) to make =N(-);                      */</a>
<a name="ln8435">/* all taut atoma except N are 'acidic'                                          */</a>
<a name="ln8436">/*********************************************************************************/</a>
<a name="ln8437">int bIsRemovedHfromNHaion( BN_STRUCT* pBNS, Vertex u, Vertex v )</a>
<a name="ln8438">{</a>
<a name="ln8439">    int    i, u2, v2, vat2;</a>
<a name="ln8440">    Vertex vtg, vat;</a>
<a name="ln8441">    BNS_VERTEX *pvAT, *pvCN;</a>
<a name="ln8442">    BNS_EDGE   *pEdge;</a>
<a name="ln8443">    if ( !pBNS-&gt;type_TACN || u &lt;= 1 || v &lt;= 1 ||</a>
<a name="ln8444">         u%2 || !(v%2) /* the edge flow may only increase */ ) {</a>
<a name="ln8445">        return 0;</a>
<a name="ln8446">    }</a>
<a name="ln8447">    if ((pBNS-&gt;vert[u2 = u/2-1].type &amp; pBNS-&gt;type_TACN) ||</a>
<a name="ln8448">        (pBNS-&gt;vert[v2 = v/2-1].type &amp; pBNS-&gt;type_TACN) ) {</a>
<a name="ln8449">        return 0; /* add/remove H is allowed for acidic atoms */</a>
<a name="ln8450">    }</a>
<a name="ln8451">    if ( !pBNS-&gt;type_T || !pBNS-&gt;type_CN )</a>
<a name="ln8452">        return 0; /* should not happen */</a>
<a name="ln8453">    /* find which of u, v vertices is N and which is t-group */</a>
<a name="ln8454">    if ( ((pBNS-&gt;vert[u2].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T ) &amp;&amp; v2 &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln8455">        vtg = u;</a>
<a name="ln8456">        vat = v;</a>
<a name="ln8457">    } else</a>
<a name="ln8458">    if ( ((pBNS-&gt;vert[v2].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T ) &amp;&amp; u2 &lt; pBNS-&gt;num_atoms ) {</a>
<a name="ln8459">        vtg = v;</a>
<a name="ln8460">        vat = u;</a>
<a name="ln8461">    } else {</a>
<a name="ln8462">        return 0;</a>
<a name="ln8463">    }</a>
<a name="ln8464">    vat2 = vat/2-1;</a>
<a name="ln8465">    pvAT = pBNS-&gt;vert + vat2;  /* atom */</a>
<a name="ln8466">    for ( i = pvAT-&gt;num_adj_edges-1; 0 &lt;= i; i -- ) {</a>
<a name="ln8467">        pEdge = pBNS-&gt;edge + pvAT-&gt;iedge[i];</a>
<a name="ln8468">        pvCN  = pBNS-&gt;vert + (pEdge-&gt;neighbor12 ^ vat2);</a>
<a name="ln8469">        if ( ((pvCN-&gt;type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN) &amp;&amp;  pEdge-&gt;flow &gt; 0 ) {</a>
<a name="ln8470">            return 1; /* detected */</a>
<a name="ln8471">        }</a>
<a name="ln8472">    }</a>
<a name="ln8473">    return 0;</a>
<a name="ln8474">}</a>
<a name="ln8475">#endif</a>
<a name="ln8476"> </a>
<a name="ln8477"> </a>
<a name="ln8478"> </a>
<a name="ln8479">#if ( FIX_AVOID_ADP == 1 )</a>
<a name="ln8480">/************************************************************************</a>
<a name="ln8481">   Detect  (tg)-N=A-A=A-A=N-(tg)</a>
<a name="ln8482">                        u v  w</a>
<a name="ln8483">     k =    5   4 3 2 1 0 1  2</a>
<a name="ln8484">            ^</a>
<a name="ln8485">          odd number means ADP</a>
<a name="ln8486">*************************************************************************/</a>
<a name="ln8487">int bIsAggressiveDeprotonation( BN_STRUCT* pBNS, Vertex v, Vertex w, Edge *SwitchEdge )</a>
<a name="ln8488">{</a>
<a name="ln8489">#define TYPE_T   1   /* t-group [also called H-group] */</a>
<a name="ln8490">#define TYPE_CN  2   /* (-)c-group */</a>
<a name="ln8491">#define TYPE_AT  4</a>
<a name="ln8492">    int    k, v2, u2, w2, u2_next, type0, type1, type2, type;</a>
<a name="ln8493">    Vertex u, u_next;</a>
<a name="ln8494">    EdgeIndex iuv;</a>
<a name="ln8495">    if ( v &lt;= 1 || w &lt;= 1 )</a>
<a name="ln8496">        return 0;</a>
<a name="ln8497"> </a>
<a name="ln8498">    if ( !pBNS-&gt;type_TACN || !pBNS-&gt;type_T || !pBNS-&gt;type_CN )</a>
<a name="ln8499">        return 0; /* should not happen */</a>
<a name="ln8500">    v2 = v/2 - 1;</a>
<a name="ln8501">    w2 = w/2 - 1;</a>
<a name="ln8502">    if ( v2 &gt;= pBNS-&gt;num_atoms || w2 &lt; pBNS-&gt;num_atoms )</a>
<a name="ln8503">        goto cross_edge;</a>
<a name="ln8504"> </a>
<a name="ln8505">    if ( !((pBNS-&gt;vert[w2].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T ) &amp;&amp;</a>
<a name="ln8506">         !((pBNS-&gt;vert[w2].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN) )</a>
<a name="ln8507">        goto cross_edge;</a>
<a name="ln8508">    /* v ia an atom, w is a t-group, v != w' */</a>
<a name="ln8509">    for ( k = 0, u = v; 1 &lt; (u_next = u, u = GetPrevVertex( pBNS, u, SwitchEdge, &amp;iuv )); k ++ ) {</a>
<a name="ln8510">        u2 = u/2 - 1;</a>
<a name="ln8511">        if ( u2 &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln8512">            /* moving backward along the alt path we have found a vertex</a>
<a name="ln8513">               that is not an atom. Possibly it is a t- or (-)c-group */</a>
<a name="ln8514">            if ( !( k % 2 ) ) {</a>
<a name="ln8515">                return 0; /* even vertex -- always okay */</a>
<a name="ln8516">            }</a>
<a name="ln8517">            if ( !((pBNS-&gt;vert[u2].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T ) &amp;&amp;</a>
<a name="ln8518">                 !((pBNS-&gt;vert[u2].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN) ) {</a>
<a name="ln8519">                /* not a t- or (-)c-group */</a>
<a name="ln8520">                return 0;</a>
<a name="ln8521">            }</a>
<a name="ln8522">            u2_next = u_next/2 - 1;</a>
<a name="ln8523">            if ( !(pBNS-&gt;vert[v2     ].type &amp; pBNS-&gt;type_TACN) &amp;&amp;</a>
<a name="ln8524">                 !(pBNS-&gt;vert[u2_next].type &amp; pBNS-&gt;type_TACN)  ) {</a>
<a name="ln8525">                /* none of the atoms at the ends are N */</a>
<a name="ln8526">                return 0;</a>
<a name="ln8527">            }</a>
<a name="ln8528">            return 1;</a>
<a name="ln8529">        }</a>
<a name="ln8530">    }</a>
<a name="ln8531">    return 0;</a>
<a name="ln8532">cross_edge:</a>
<a name="ln8533">    /*****************************************************************************</a>
<a name="ln8534">     * v and w (v=w') are same vertex reached with opposite &quot;phases&quot;.</a>
<a name="ln8535">     * w cannot be (t) because this would have been detected earlier -- ???</a>
<a name="ln8536">     *   (t)-A=A-A=A-A=A-(t)</a>
<a name="ln8537">     *           v </a>
<a name="ln8538">     *    3  2 1 0 1 2 3  4</a>
<a name="ln8539">     *   kv               kw</a>
<a name="ln8540">     *   (kv + kw)%2 == 1  &lt;==&gt; aggressive deprotonation</a>
<a name="ln8541">     *****************************************************************************/</a>
<a name="ln8542">    if ( v == prim(w) ) {</a>
<a name="ln8543">        type0 = 0;</a>
<a name="ln8544">        if ( v2 &gt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln8545">            type0 = ((pBNS-&gt;vert[v2].type &amp; pBNS-&gt;type_T)  == pBNS-&gt;type_T )? TYPE_T :</a>
<a name="ln8546">                    ((pBNS-&gt;vert[v2].type &amp; pBNS-&gt;type_CN) == pBNS-&gt;type_CN)? TYPE_CN : 0;</a>
<a name="ln8547">        }</a>
<a name="ln8548"> </a>
<a name="ln8549">        </a>
<a name="ln8550"> </a>
<a name="ln8551">    }</a>
<a name="ln8552">          </a>
<a name="ln8553">    </a>
<a name="ln8554">    return 0;</a>
<a name="ln8555">}</a>
<a name="ln8556">#endif</a>
<a name="ln8557"> </a>
<a name="ln8558"> </a>
<a name="ln8559"> </a>
<a name="ln8560">/*****************************************************************************/</a>
<a name="ln8561">int rescap(  BN_STRUCT* pBNS, Vertex u, Vertex v, EdgeIndex iuv )</a>
<a name="ln8562">{</a>
<a name="ln8563">    BNS_ST_EDGE    *pst_edge;</a>
<a name="ln8564">    BNS_EDGE       *pedge;</a>
<a name="ln8565"> </a>
<a name="ln8566">    int f;</a>
<a name="ln8567">    S_CHAR s_or_t;</a>
<a name="ln8568">    int    bBackward = GetEdgePointer( pBNS, u, v, iuv, &amp;pedge, &amp;s_or_t );</a>
<a name="ln8569">    if ( !IS_BNS_ERROR(bBackward) ) {</a>
<a name="ln8570">        </a>
<a name="ln8571">        if ( s_or_t ) {</a>
<a name="ln8572">            pst_edge = (BNS_ST_EDGE *)pedge;</a>
<a name="ln8573">            f    = (pst_edge-&gt;flow &amp; EDGE_FLOW_ST_MASK);</a>
<a name="ln8574">            if ( !bBackward ) {</a>
<a name="ln8575">                f = (int)pst_edge-&gt;cap-f;</a>
<a name="ln8576">            }</a>
<a name="ln8577">        } else {</a>
<a name="ln8578">            f    = (pedge-&gt;flow &amp; EDGE_FLOW_MASK);</a>
<a name="ln8579">            if ( !bBackward ) {</a>
<a name="ln8580">                f = (int)pedge-&gt;cap-f;</a>
<a name="ln8581">            }</a>
<a name="ln8582">        }</a>
<a name="ln8583">        return f;</a>
<a name="ln8584"> </a>
<a name="ln8585">    }</a>
<a name="ln8586">    return bBackward; /* error */</a>
<a name="ln8587">}</a>
<a name="ln8588"> </a>
<a name="ln8589"> </a>
<a name="ln8590"> </a>
<a name="ln8591">/*********************************************************************************</a>
<a name="ln8592">    W.Kocay, D.Stone,</a>
<a name="ln8593">    &quot;An Algorithm for Balanced Flows&quot;,</a>
<a name="ln8594">    The Journal of Combinatorial Mathematics and Combinatorial Computing,</a>
<a name="ln8595">    vol. 19 (1995) pp. 3-31</a>
<a name="ln8596">    </a>
<a name="ln8597">    W.Kocay, D.Stone,</a>
<a name="ln8598">    &quot;Balanced network flows&quot;,</a>
<a name="ln8599">    Bulletin of the Institute of Combinatorics and its Applications,</a>
<a name="ln8600">     vol. 7 (1993), pp. 17--32</a>
<a name="ln8601"> </a>
<a name="ln8602">    N = a balanced network (bipartite directed graph) of:</a>
<a name="ln8603">        n=2*V+2 vertices (incl. s (source) and t (target);</a>
<a name="ln8604">          each other vertex i is included 2 times:</a>
<a name="ln8605">          set X (x[i]) of V vertices (v) and a set Y (y[j]) of</a>
<a name="ln8606">          V complementary vertices (v') so that x[i]' = y[i], x[i]''=x[i], and</a>
<a name="ln8607">        m=2*E+2*V edges (each original undirected edge i-j is represented as</a>
<a name="ln8608">          2 directed edges: x[i]-&gt;y[j] and x[j]-&gt;y[i]; plus</a>
<a name="ln8609">          V edges s-&gt;x[i] and V edges y[j]-&gt;t)</a>
<a name="ln8610">    v'   = a complement vertex to v</a>
<a name="ln8611">    v'u' = (uv)' = a complement edge to uv</a>
<a name="ln8612">    rescap(uv) = cap(uv)-f(uv) if uv is a forward edge</a>
<a name="ln8613">               = f(uv)         if uv is a backward edge</a>
<a name="ln8614">    (i)   0 &lt;= f(uv) &lt;= cap(uv)</a>
<a name="ln8615">    (ii)  f+(u) = f-(u) for all u in X, Y where f+(u) is a total flow out of u,</a>
<a name="ln8616">                  and f-(u) is a total flow into u</a>
<a name="ln8617">    (iii) f(uv) = f((uv)') (balanced flow condition)</a>
<a name="ln8618"> </a>
<a name="ln8619">    S     = a set of all s-searchable vertices</a>
<a name="ln8620">    S-    = all other vertices</a>
<a name="ln8621">    if t in S, then N contains a valid augmenting path P, so that flow can be</a>
<a name="ln8622">            augmented on both P and P'</a>
<a name="ln8623">    if t not in S, then let K=[S,S-], the set of all edges directed from S to S-.</a>
<a name="ln8624">            K is an edge-cut that has a special structure.</a>
<a name="ln8625">    Let</a>
<a name="ln8626">    A  = {x[i], y[i] |x[i] not in S, y[i]     in S}</a>
<a name="ln8627">    B  = {x[i], y[i] |x[i]     in S, y[i] not in S}</a>
<a name="ln8628">    C  = {x[i], y[i] |x[i]     in S, y[i]     in S}</a>
<a name="ln8629">    D  = {x[i], y[i] |x[i] not in S, y[i] not in S}</a>
<a name="ln8630">    N[C]  = subgraph of N induced by C;</a>
<a name="ln8631">            it consists of of a number of connected components C[i]</a>
<a name="ln8632">    K[i]  = those edges of K with one endpoint in C[i].</a>
<a name="ln8633"> </a>
<a name="ln8634">    If t is in S- then</a>
<a name="ln8635"> </a>
<a name="ln8636">    i)   Each C[i] = C[i]'</a>
<a name="ln8637">    ii)  There are no edges between C and D</a>
<a name="ln8638">    iii) Each K[i] has odd capacity, it is called a balanced edge-cut.</a>
<a name="ln8639"> </a>
<a name="ln8640">    balcap(K) = cap(K) - odd(K), where odd(K) is the number of connected components in N[C].</a>
<a name="ln8641">    Name &quot;odd(K)&quot; is because each cap(K[i]) is odd.</a>
<a name="ln8642"> </a>
<a name="ln8643">    Max-Balanced-Flow-Min-Balanced-Cut Theorem:</a>
<a name="ln8644"> </a>
<a name="ln8645">    Let f be a balanced flow in N, and let K be any balanced edge-cut.</a>
<a name="ln8646">    The value of a maximum balanced flow equals the capacity of a minimum</a>
<a name="ln8647">    edge-cut, that is, val(f) = balcap(K) when f is maximum and K is minimum.</a>
<a name="ln8648"> </a>
<a name="ln8649">*********************************************************************************/</a>
<a name="ln8650"> </a>
<a name="ln8651">/*******************************************************/</a>
<a name="ln8652">/*                                                     */</a>
<a name="ln8653">/*        VERTEX NUMBERING                             */</a>
<a name="ln8654">/*                                                     */</a>
<a name="ln8655">/*   Total number of atoms    = n                      */</a>
<a name="ln8656">/*   Total number of vertices = 2*n+2                  */</a>
<a name="ln8657">/*******************************************************/</a>
<a name="ln8658">/*                                                     */</a>
<a name="ln8659">/* atom numbering starts from 0:                       */</a>
<a name="ln8660">/*                                                     */</a>
<a name="ln8661">/* atoms    s t x0 y0 x1 y1 ... xi   yi   ...xn   yn   */</a>
<a name="ln8662">/* vertices 0 1 2  3  4  5  ... 2i-2 2i-1 ...2n-2 2n-1 */</a>
<a name="ln8663">/*                                                     */</a>
<a name="ln8664">/* atom = vertex/2-1; if negative then s or t          */</a>
<a name="ln8665">/*                                                     */</a>
<a name="ln8666">/* vertex = (atom + 1) * 2 + i; i=0 for x, i=1 for y   */</a>
<a name="ln8667">/*                                                     */</a>
<a name="ln8668">/*******************************************************/</a>
<a name="ln8669"> </a>
<a name="ln8670"> </a>
<a name="ln8671"> </a>
<a name="ln8672">/*********************************************************************************/</a>
<a name="ln8673">/* v' variable is called prim(v) for now										 */</a>
<a name="ln8674">/*********************************************************************************/</a>
<a name="ln8675">int BalancedNetworkSearch ( BN_STRUCT* pBNS, BN_DATA *pBD, int bChangeFlow )</a>
<a name="ln8676">{   /* N has source s, target t, the mirror network M is constructed */</a>
<a name="ln8677">    /* the tree T contains a valid sv-path for each v in T. Simultaneously the complementary</a>
<a name="ln8678">       tree T' is built as indicated in comments. The trees T and T' must have no edges or</a>
<a name="ln8679">       vertices in common. Initially T will be built as in breadth-first-search, and T' will</a>
<a name="ln8680">       be the complementary tree, it will contain the complementary valid v't-path.</a>
<a name="ln8681">    */</a>
<a name="ln8682"> </a>
<a name="ln8683">    Vertex          *BasePtr =       pBD-&gt;BasePtr;</a>
<a name="ln8684">    Edge            *SwitchEdge =    pBD-&gt;SwitchEdge;</a>
<a name="ln8685">    S_CHAR          *Tree =          pBD-&gt;Tree;</a>
<a name="ln8686">    Vertex          *ScanQ =         pBD-&gt;ScanQ;     </a>
<a name="ln8687">    int              QSize =         pBD-&gt;QSize;</a>
<a name="ln8688">    Vertex          *Pu =            pBD-&gt;Pu;</a>
<a name="ln8689">    Vertex          *Pv =            pBD-&gt;Pv;</a>
<a name="ln8690">    int              max_len_Pu_Pv=  pBD-&gt;max_len_Pu_Pv;</a>
<a name="ln8691"> </a>
<a name="ln8692">    /* added to translate into C */</a>
<a name="ln8693">    int i, k, degree, delta, ret = 0;</a>
<a name="ln8694">    Vertex u, b_u, v, b_v, w;</a>
<a name="ln8695">    EdgeIndex iuv;</a>
<a name="ln8696">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln8697">    int              n, bRadSearch   = (BNS_EF_RAD_SRCH &amp; bChangeFlow) &amp;&amp; pBD-&gt;RadEndpoints;</a>
<a name="ln8698">    BRS_MODE         bRadSrchMode    = RAD_SRCH_NORM;</a>
<a name="ln8699">    int              bRadSearchPrelim = 0;</a>
<a name="ln8700">    if ( bRadSearch ) {</a>
<a name="ln8701">        pBD-&gt;nNumRadEndpoints = 0;</a>
<a name="ln8702">        bRadSrchMode          = pBD-&gt;bRadSrchMode;</a>
<a name="ln8703">        bRadSearchPrelim      = pBNS-&gt;type_TACN &amp;&amp; bRadSrchMode == RAD_SRCH_NORM;</a>
<a name="ln8704">    }</a>
<a name="ln8705">#endif</a>
<a name="ln8706"> </a>
<a name="ln8707">/*  -- Always --</a>
<a name="ln8708">    Vertex_s = FIRST_INDX;</a>
<a name="ln8709">    Vertex_t = Vertex_s+1;</a>
<a name="ln8710">*/</a>
<a name="ln8711">    QSize = k = 0;     /* put s on ScanQ = set S */</a>
<a name="ln8712">    ScanQ[QSize] = Vertex_s;</a>
<a name="ln8713">    BasePtr[Vertex_t] = Vertex_s;</a>
<a name="ln8714">    BasePtr[Vertex_s] = BLOSSOM_BASE; /* create initial blossom C(Vertex_s) with base s */</a>
<a name="ln8715">    Tree[Vertex_s]    = TREE_IN_1;</a>
<a name="ln8716"> </a>
<a name="ln8717">    do {</a>
<a name="ln8718">        u = ScanQ[k]; /* select u from the head of ScanQ */</a>
<a name="ln8719">        /* since u is on the queue, it has a blossom C(U) with base b_u */</a>
<a name="ln8720">        b_u = FindBase( u, BasePtr );</a>
<a name="ln8721">        degree = GetVertexDegree( pBNS, u );</a>
<a name="ln8722">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln8723">        n = 0;</a>
<a name="ln8724">#endif</a>
<a name="ln8725">        for ( i = 0; i &lt; degree; i ++ ) {</a>
<a name="ln8726">            /* v = vert[u].neighbor[i]; */</a>
<a name="ln8727">            v = GetVertexNeighbor( pBNS, u, i, &amp;iuv );</a>
<a name="ln8728">            if ( v == NO_VERTEX ) {</a>
<a name="ln8729">                continue; /* the atom has only single bonds, ignore it */</a>
<a name="ln8730">            }</a>
<a name="ln8731">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln8732">            if ( !k &amp;&amp; bRadSrchMode == RAD_SRCH_FROM_FICT &amp;&amp; v/2 &lt;= pBNS-&gt;num_atoms ) {</a>
<a name="ln8733">                continue; /* start from fict. vertices only */</a>
<a name="ln8734">            }</a>
<a name="ln8735">            if ( bRadSearchPrelim &amp;&amp; v/2 &gt; pBNS-&gt;num_atoms ) {</a>
<a name="ln8736">                continue; /* during initial add/remove H allow radical movement only through real atoms */</a>
<a name="ln8737">            }</a>
<a name="ln8738">#endif</a>
<a name="ln8739">            if ( /* PrevPt[u] != v ** avoid edges of T */</a>
<a name="ln8740">                 ( SwitchEdge_Vert1(u) != v || SwitchEdge_Vert2(u) != u )  /* avoid edges of T */</a>
<a name="ln8741">                 &amp;&amp; (ret = rescap(pBNS, u, v, iuv)) &gt; 0 ) {</a>
<a name="ln8742">                /* special treatment to prevent H&lt;-&gt;(-) replacement on non-acidic atoms */</a>
<a name="ln8743">                /*----------------------------------------------------------------------*/</a>
<a name="ln8744">                if ( pBNS-&gt;type_TACN ) {</a>
<a name="ln8745">                    if ( bIgnoreVertexNonTACN_atom( pBNS, u, v ) ) {</a>
<a name="ln8746">                        continue;</a>
<a name="ln8747">                    }</a>
<a name="ln8748">                    if ( bIgnoreVertexNonTACN_group( pBNS, u, v, SwitchEdge ) ) {</a>
<a name="ln8749">                        continue;</a>
<a name="ln8750">                    }</a>
<a name="ln8751">#if ( FIX_KEEP_H_ON_NH_ANION == 1 )</a>
<a name="ln8752">                    if ( bIsRemovedHfromNHaion( pBNS, u, v ) ) {</a>
<a name="ln8753">                        continue;</a>
<a name="ln8754">                    }</a>
<a name="ln8755">#endif</a>
<a name="ln8756">#if ( FIX_AVOID_ADP == 1 )</a>
<a name="ln8757">                    if ( bIsAggressiveDeprotonation( pBNS, u, v, SwitchEdge ) ) {</a>
<a name="ln8758">                        continue;</a>
<a name="ln8759">                    }</a>
<a name="ln8760">#endif</a>
<a name="ln8761"> </a>
<a name="ln8762">                }</a>
<a name="ln8763">                /*----------------------------------------------------------------------*/</a>
<a name="ln8764">                b_v = FindBase(v, BasePtr); /* Notation: b_x is a base of x */</a>
<a name="ln8765">                </a>
<a name="ln8766">                if ( b_v == NO_VERTEX ) {  /* originally 0 instead of NO_VERTEX */</a>
<a name="ln8767">                    /* Important note: following &quot;A. Note of Implementing the Algorithm&quot; from the</a>
<a name="ln8768">                       article by Kocay and Stone, all references to PrevPt[a] have been</a>
<a name="ln8769">                       replaced with SwitchEdge[a][0]=SwitchEdge_Vert1(a); to be on a safe side</a>
<a name="ln8770">                       the check whether (SwitchEdge_Vert2(a)==a) has been added.</a>
<a name="ln8771">                    */</a>
<a name="ln8772"> </a>
<a name="ln8773">                    /* v is not yet in T or T' -- add it to T and M */</a>
<a name="ln8774">                    /*PrevPt[v] = u; ** this effectively adds v to T and v' to T' */</a>
<a name="ln8775">                    QSize ++;</a>
<a name="ln8776">                    ScanQ[QSize]  = v;</a>
<a name="ln8777">                    TREE_MARK(v, TREE_IN_1); /* mark v s-reachable (in T) */</a>
<a name="ln8778">                    TREE_MARK(prim(v), TREE_IN_2); /* mark v' in T' */</a>
<a name="ln8779"> </a>
<a name="ln8780">                    /* Switch Edges: If u in T then Pu (a valid su-path) can be constructed</a>
<a name="ln8781">                       by successfully executing u=PrevPt[u] until u=s.</a>
<a name="ln8782">                       For vertices in T' the situation is different.</a>
<a name="ln8783">                       Suppose uv and v'u' are added to a mirror network M creating a blossom:</a>
<a name="ln8784"> </a>
<a name="ln8785">                                    s            T    (Note: in the code v' is prim(v),</a>
<a name="ln8786">                     T             / \                       u' is prim(u), etc.)</a>
<a name="ln8787">                                  /   ...</a>
<a name="ln8788">                                 w=x1</a>
<a name="ln8789">                                / \          u in T,   v in T'</a>
<a name="ln8790">                            u=y2   v'=y3</a>
<a name="ln8791">                                \ /      &lt;--- two added edges uv and (uv)'=v'u'</a>
<a name="ln8792">                     --------    X   ------------intersection of the edges ------------------------</a>
<a name="ln8793">                                / \      &lt;--- (the edges intersection in the picture is shown as X)</a>
<a name="ln8794">                           u'=x2   v=x3      u' it T', v' in T</a>
<a name="ln8795">                                \ /</a>
<a name="ln8796">                    T'           w'=y1</a>
<a name="ln8797">                                  \   ...</a>
<a name="ln8798">                                   \ /</a>
<a name="ln8799">                                    t           T'</a>
<a name="ln8800"> </a>
<a name="ln8801">                       Vertices v and u' now become s-reachable;</a>
<a name="ln8802">                       The valid paths to v and u' must use the edges uv and v'u' respectively.</a>
<a name="ln8803"> </a>
<a name="ln8804">                       For each vertex z in S we define a switch-edge that allows a valid sz-path</a>
<a name="ln8805">                       to be constructed, SwitchEdge[v]=uv and SwitchEdge[u']=v'u'. (We don't</a>
<a name="ln8806">                       know the direction of the edge uv, it may be (u,v) or (v,u). In either case,</a>
<a name="ln8807">                       the complementary edge is indicated by v'u').</a>
<a name="ln8808"> </a>
<a name="ln8809">                       Vertex w' also becomes s-reachable when uv is added to M, and a valid sw'-path</a>
<a name="ln8810">                       must use one of uv and v'u'. Therefore we choose one of them, say uv (see below</a>
<a name="ln8811">                       the rule of choosing the switch-edge), and define SwitchEdge[w'] = uv.</a>
<a name="ln8812"> </a>
<a name="ln8813">                       When the addition of an edge uv to M causes a vertex z to become s-reachable</a>
<a name="ln8814">                       (where z was previously non-reachable), z is placed on the ScanQ, that is, into S.</a>
<a name="ln8815">                       The edge uv is said to be a switch-edge for z.</a>
<a name="ln8816"> </a>
<a name="ln8817">                       Rule: We choose the the order of the vertices uv to be such that the valid sz-path</a>
<a name="ln8818">                       consists of a valid su-path, followed by edge uv, followed by a valid vz-path.</a>
<a name="ln8819"> </a>
<a name="ln8820">                       For vertices z in T we can take SwitchEdge[z]=yz where y=PrevPt[z] since</a>
<a name="ln8821">                       it is the edge yz that allows z to be s-reachable.</a>
<a name="ln8822">                       For vertices z not in S we take SwitchEdge[z]=NONE.</a>
<a name="ln8823"> </a>
<a name="ln8824">                    */</a>
<a name="ln8825"> </a>
<a name="ln8826">                    /* v is not yet in T or T' -- add it to T and M */</a>
<a name="ln8827">                    SwitchEdge_Vert1(v) = u; /* this effectively adds uv and v'u' to M */</a>
<a name="ln8828">                    SwitchEdge_IEdge(v) = iuv;</a>
<a name="ln8829"> </a>
<a name="ln8830">                    BasePtr[prim(v)] = v;</a>
<a name="ln8831">                    BasePtr[v]  = BLOSSOM_BASE; /* create a trivial blossom C(v) with base v */</a>
<a name="ln8832">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln8833">                    n ++;</a>
<a name="ln8834">#endif</a>
<a name="ln8835">                } else</a>
<a name="ln8836">                if ( TREE_IS_S_REACHABLE(prim(v)) /*Is_s_Reachable(prim(v)*/</a>
<a name="ln8837">                     /* if v' is reachable, an st-path is given by P(u)-uv-P'(v') */</a>
<a name="ln8838">                     /*&amp;&amp; PrevPt[prim(u)] != prim(v) ** avoid edges of T' */</a>
<a name="ln8839">                     &amp;&amp; (SwitchEdge_Vert1(prim(u)) != prim(v) || SwitchEdge_Vert2(prim(u)) != prim(u)) /* avoid edges of T' */</a>
<a name="ln8840">                     &amp;&amp; b_u != b_v</a>
<a name="ln8841">                     &amp;&amp; !(pBNS-&gt;type_TACN &amp;&amp; bIgnoreVertexNonTACN_group( pBNS, prim(v), u, SwitchEdge ))</a>
<a name="ln8842">#if ( FIX_KEEP_H_ON_NH_ANION == 1 )</a>
<a name="ln8843">                     &amp;&amp; !(pBNS-&gt;type_TACN &amp;&amp; bIsRemovedHfromNHaion( pBNS, prim(v), u ))</a>
<a name="ln8844">#endif</a>
<a name="ln8845">                     ) {</a>
<a name="ln8846">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln8847">                    n ++;</a>
<a name="ln8848">#endif</a>
<a name="ln8849">                     /* there is now a valid sv-path via u avoiding b_v (unless v==b_v)</a>
<a name="ln8850">                       =&gt; u, v, u', and v' now all become part of the same connected component of M[C] */</a>
<a name="ln8851">                    w = MakeBlossom( pBNS, ScanQ, &amp;QSize, Pu, Pv, max_len_Pu_Pv, SwitchEdge, BasePtr, u, v, iuv, b_u, b_v, Tree );</a>
<a name="ln8852">                    /* this constructed the new blossom and returned its base */</a>
<a name="ln8853">                    if ( IS_BNS_ERROR( w ) ) {</a>
<a name="ln8854">                        pBD-&gt;QSize = QSize;</a>
<a name="ln8855">                        return w; /* error */</a>
<a name="ln8856">                    }</a>
<a name="ln8857">                    b_u = w; /* the new base of C(u) */</a>
<a name="ln8858">                    if ( prim(w) == Vertex_t ) {</a>
<a name="ln8859">                        /* t is now s-reachable, a valid augmenting path P exists in M */</a>
<a name="ln8860">                        delta = FindPathCap( pBNS, SwitchEdge, Vertex_s, Vertex_t, 10000 ); /* compute the residual capacity of P + P' */</a>
<a name="ln8861">                        if ( IS_BNS_ERROR( delta ) ) {</a>
<a name="ln8862">                            pBD-&gt;QSize = QSize;</a>
<a name="ln8863">                            return delta; /* error */</a>
<a name="ln8864">                        }</a>
<a name="ln8865">#if ( ALLOW_ONLY_SIMPLE_ALT_PATH == 1 )</a>
<a name="ln8866">                        if ( pBNS-&gt;bNotASimplePath || abs(delta) &gt; 1 ) {</a>
<a name="ln8867">                            delta = 0;</a>
<a name="ln8868">                        }</a>
<a name="ln8869">#endif</a>
<a name="ln8870">                        if ( delta ) {</a>
<a name="ln8871">                            pBNS-&gt;bChangeFlow |= (bChangeFlow &amp; BNS_EF_CHNG_FLOW);</a>
<a name="ln8872">                        }</a>
<a name="ln8873">                        ret = PullFlow( pBNS, SwitchEdge, Vertex_s, Vertex_t, delta, 0, bChangeFlow ); /* augment on a pair of valid st-paths */</a>
<a name="ln8874">                        pBD-&gt;QSize = QSize;</a>
<a name="ln8875">                        return ( IS_BNS_ERROR(ret)? ret : delta );</a>
<a name="ln8876">                    }</a>
<a name="ln8877">                }</a>
<a name="ln8878">            } else</a>
<a name="ln8879">            if ( IS_BNS_ERROR( ret ) ) {</a>
<a name="ln8880">                pBD-&gt;QSize = QSize;</a>
<a name="ln8881">                return ret; /* error */</a>
<a name="ln8882">            }</a>
<a name="ln8883">        }</a>
<a name="ln8884">#if ( BNS_RAD_SEARCH == 1 )</a>
<a name="ln8885">        if ( bRadSearch &amp;&amp; !n ) {</a>
<a name="ln8886">            /* the BNS stopped at u */</a>
<a name="ln8887">            n = RegisterRadEndpoint( pBNS, pBD, u);</a>
<a name="ln8888">            if ( IS_BNS_ERROR( n ) ) {</a>
<a name="ln8889">                pBD-&gt;QSize = QSize;</a>
<a name="ln8890">                return n;</a>
<a name="ln8891">            }</a>
<a name="ln8892">        }</a>
<a name="ln8893">#endif</a>
<a name="ln8894">        k ++; /* advance ScanQ */</a>
<a name="ln8895">    } while( k &lt;= QSize );</a>
<a name="ln8896">    /* if this point is reached, no valid augmenting path exists, ScanQ contains</a>
<a name="ln8897">       the set S of all s-reachable vertices and K=[S,S-] is a minimum balanced edge-cut */</a>
<a name="ln8898">    /* ClearFlowMarks( vert, num_vert); */</a>
<a name="ln8899">    pBD-&gt;QSize = QSize;</a>
<a name="ln8900">    return 0;</a>
<a name="ln8901">}</a>
<a name="ln8902">/********************************************************************</a>
<a name="ln8903">Blossoms.</a>
<a name="ln8904"> </a>
<a name="ln8905">  The vertices of a mirror network M consist T U T'. Intersection T ^ T' is empty.</a>
<a name="ln8906"> </a>
<a name="ln8907">  The edges of M consist of switch-edges and their complements because edges</a>
<a name="ln8908">  are added in complementary pairs, one of which is always a switch-edge.</a>
<a name="ln8909"> </a>
<a name="ln8910">  The base of every blossom is in T.</a>
<a name="ln8911">  Let C(i) be a blossom with base b_i. Since C(i)=C(i)', C(i) contains vertices of T and T'.</a>
<a name="ln8912">  Since every valid sv-path to v in C(i) contains b_i, b_i is the first s-reachable vertex of C(i).</a>
<a name="ln8913"> </a>
<a name="ln8914">  Suppose the mirror network M contains a valid sz-path P(z) to all vertices z in ScanQ.</a>
<a name="ln8915">  Every vertex of P(z) is s-reachable therefore its vertices are all in blossoms or</a>
<a name="ln8916">  trivial blossoms.</a>
<a name="ln8917"> </a>
<a name="ln8918">  Let z be an s-reachable vertex and P(z) be a valid path in M.</a>
<a name="ln8919">  Then every valid sz-path in M contains exactly the same sequence of blossom bases as P(z).</a>
<a name="ln8920"> </a>
<a name="ln8921">*********************************************************************/</a>
<a name="ln8922"> </a>
<a name="ln8923"> </a>
<a name="ln8924"> </a>
<a name="ln8925">/***********************************************************************</a>
<a name="ln8926">    BasePtr[u] = -2  NO_VERTEX       u is not a blossom</a>
<a name="ln8927">                 -1  BLOSSOM_BASE    u is the base of its blossom</a>
<a name="ln8928">                  v                  a vertex closer to the base</a>
<a name="ln8929">************************************************************************/</a>
<a name="ln8930">Vertex FindBase( Vertex u, Vertex *BasePtr )</a>
<a name="ln8931">{</a>
<a name="ln8932">    if ( BasePtr[u] == NO_VERTEX ) {</a>
<a name="ln8933">        return NO_VERTEX;</a>
<a name="ln8934">    } else</a>
<a name="ln8935">    if ( BasePtr[u] == BLOSSOM_BASE ) {</a>
<a name="ln8936">        return u;</a>
<a name="ln8937">    } else {</a>
<a name="ln8938">        Vertex b;</a>
<a name="ln8939">        b = FindBase(BasePtr[u], BasePtr );</a>
<a name="ln8940">        BasePtr[u] = b; /* path compression */</a>
<a name="ln8941">        return b;</a>
<a name="ln8942">    }</a>
<a name="ln8943">}</a>
<a name="ln8944"> </a>
<a name="ln8945"> </a>
<a name="ln8946"> </a>
<a name="ln8947">/*********************************************************************************/</a>
<a name="ln8948">/* Returns index of the last path element and the path                           */</a>
<a name="ln8949">/*********************************************************************************/</a>
<a name="ln8950">int FindPathToVertex_s( Vertex x, Edge *SwitchEdge, Vertex *BasePtr, Vertex *Path, int MaxPathLen )</a>
<a name="ln8951">{</a>
<a name="ln8952">    /* x is the base of a blossom, construct a valid Path of blossom bases to s */</a>
<a name="ln8953">    int i = 0;</a>
<a name="ln8954">    Path[i] = x;</a>
<a name="ln8955">    while ( x != Vertex_s ) {</a>
<a name="ln8956">        x = FindBase(SwitchEdge_Vert1(x), BasePtr);</a>
<a name="ln8957">        if ( ++i &lt; MaxPathLen ) {</a>
<a name="ln8958">            Path[i] = x;</a>
<a name="ln8959">        } else {</a>
<a name="ln8960">            return BNS_WRONG_PARMS;</a>
<a name="ln8961">        }</a>
<a name="ln8962">    }</a>
<a name="ln8963">    return i;</a>
<a name="ln8964">}</a>
<a name="ln8965"> </a>
<a name="ln8966"> </a>
<a name="ln8967"> </a>
<a name="ln8968">/*********************************************************************************/</a>
<a name="ln8969">/* Make a blossom																 */</a>
<a name="ln8970">/*********************************************************************************/</a>
<a name="ln8971">Vertex MakeBlossom( BN_STRUCT* pBNS, Vertex *ScanQ, int *pQSize,</a>
<a name="ln8972">                    Vertex *Pu, Vertex *Pv, int max_len_Pu_Pv,</a>
<a name="ln8973">                    Edge *SwitchEdge, Vertex *BasePtr,</a>
<a name="ln8974">                    Vertex u, Vertex v, EdgeIndex iuv, Vertex b_u, Vertex b_v, S_CHAR *Tree )</a>
<a name="ln8975">{</a>
<a name="ln8976">    /* In order to find the base of the new blossom, the paths</a>
<a name="ln8977">       P(u) and P(v') are constructed and compared in order to</a>
<a name="ln8978">       find the last blossom base they have in common which</a>
<a name="ln8979">       is reachable on a valid path.</a>
<a name="ln8980"> </a>
<a name="ln8981">       Edge uv connects two blossoms, their bases are b_u and b_v.</a>
<a name="ln8982">    */</a>
<a name="ln8983">    Vertex w, z;</a>
<a name="ln8984">    int len_Pu, len_Pv;</a>
<a name="ln8985">    int i, j;</a>
<a name="ln8986">    EdgeIndex izw;</a>
<a name="ln8987"> </a>
<a name="ln8988">    len_Pu = FindPathToVertex_s( b_u, SwitchEdge, BasePtr, Pu, max_len_Pu_Pv );</a>
<a name="ln8989">    if ( IS_BNS_ERROR( len_Pu ) ) {</a>
<a name="ln8990">        return len_Pu;</a>
<a name="ln8991">    }</a>
<a name="ln8992">    len_Pv = FindPathToVertex_s( b_v, SwitchEdge, BasePtr, Pv, max_len_Pu_Pv );</a>
<a name="ln8993">    if ( IS_BNS_ERROR( len_Pv ) ) {</a>
<a name="ln8994">        return len_Pv;</a>
<a name="ln8995">    }</a>
<a name="ln8996">    i = len_Pu;</a>
<a name="ln8997">    j = len_Pv;</a>
<a name="ln8998">    /* initially Pu[i] and Pv[j] both equal to s, but their first elements are different */</a>
<a name="ln8999">    /* find the last blossom base common to Pu and Pv */</a>
<a name="ln9000">    while ( i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; Pu[i] == Pv[j]  ) {</a>
<a name="ln9001">        /* was (Pu[i]==Pv[j] &amp;&amp; i&gt;=0 &amp;&amp; j&gt;=0) =&gt; tested Pu[-1], Pv[-1] &lt;- pointed by W.Ihlenfeldt 08-26-2004*/</a>
<a name="ln9002">        i --;</a>
<a name="ln9003">        j --;</a>
<a name="ln9004">    }</a>
<a name="ln9005">    i ++;</a>
<a name="ln9006">    w   = Pu[i]; /* w is the last common vertex */</a>
<a name="ln9007">    z   = SwitchEdge_Vert1(w);</a>
<a name="ln9008">    izw = SwitchEdge_IEdge(w);</a>
<a name="ln9009">    /* now extend the blossom if rescap(zw) &gt;= 2 */</a>
<a name="ln9010">    while ( w != Vertex_s &amp;&amp; rescap(pBNS, z, w, izw) &gt;= 2 )</a>
<a name="ln9011">    {</a>
<a name="ln9012">        i++;</a>
<a name="ln9013">        w = Pu[i];</a>
<a name="ln9014">        z = SwitchEdge_Vert1(w);</a>
<a name="ln9015">        izw = SwitchEdge_IEdge(w);</a>
<a name="ln9016">    }</a>
<a name="ln9017">    /* w is the base of the new blossom */</a>
<a name="ln9018">    /* first follow the path Pu from w to b_u */</a>
<a name="ln9019">    for ( i = i-1; i &gt;= 0; i -- ) {</a>
<a name="ln9020">        z = Pu[i];  /* z is the base of the blossom */</a>
<a name="ln9021">        BasePtr[z] = w;</a>
<a name="ln9022">        BasePtr[prim(z)] = w; /* w is the new base of the blossom */</a>
<a name="ln9023">        /* z and z' may already be part of a blossom that is being</a>
<a name="ln9024">           swallowed into a larger blossom.</a>
<a name="ln9025">           We don't want to change the switch edge in that case.</a>
<a name="ln9026">        */</a>
<a name="ln9027">        </a>
<a name="ln9028">        if ( !TREE_IS_ON_SCANQ(prim(z)) /*!IsInScanQ(prim(z)) */) </a>
<a name="ln9029">        {</a>
<a name="ln9030">            SwitchEdge_Vert1(prim(z)) = prim(v);     /* set the switch edge of z' */</a>
<a name="ln9031">            /* SwitchEdge[prim(z)][1] = prim(u);  */</a>
<a name="ln9032">            SwitchEdge_IEdge(prim(z)) = iuv;</a>
<a name="ln9033">            (*pQSize) ++;</a>
<a name="ln9034">            ScanQ[*pQSize] = prim(z);    /* add z' to ScanQ */</a>
<a name="ln9035">            TREE_MARK(prim(z), TREE_IN_2BLOSS); /* mark z' s-reachable */</a>
<a name="ln9036">        }</a>
<a name="ln9037">    }</a>
<a name="ln9038">    /* now follow the path Pv */</a>
<a name="ln9039">    for ( j = j; j &gt;= 0; j -- ) {</a>
<a name="ln9040">        z = Pv[j]; /* z is the base of the blossom */</a>
<a name="ln9041">        BasePtr[z] = w;</a>
<a name="ln9042">        BasePtr[prim(z)] = w; /* w is the new base of the blossom */</a>
<a name="ln9043">        /* z and z' may already be part of a blossom that is being</a>
<a name="ln9044">           swallowed into a larger blossom.</a>
<a name="ln9045">           We don't want to change the switch edge in that case.</a>
<a name="ln9046">        */</a>
<a name="ln9047"> </a>
<a name="ln9048">        if ( !TREE_IS_ON_SCANQ(prim(z)) /*!IsInScanQ(prim(z)) */ )</a>
<a name="ln9049">        {</a>
<a name="ln9050">            SwitchEdge_Vert1(prim(z)) = u;     /* set the switch edge of z' */</a>
<a name="ln9051">            /* SwitchEdge[prim(z)][1] = v;  */</a>
<a name="ln9052">            SwitchEdge_IEdge(prim(z)) = iuv;</a>
<a name="ln9053">            (*pQSize) ++;</a>
<a name="ln9054">            ScanQ[*pQSize] = prim(z);    /* add z' to ScanQ */</a>
<a name="ln9055">            TREE_MARK(prim(z), TREE_IN_2BLOSS); /* mark z' s-reachable */</a>
<a name="ln9056">        }</a>
<a name="ln9057">    }</a>
<a name="ln9058"> </a>
<a name="ln9059">    if ( !TREE_IS_ON_SCANQ(prim(w)) /* !IsInScanQ(prim(w))*/ ) </a>
<a name="ln9060">    {   /* add w' to the blossom */</a>
<a name="ln9061">        SwitchEdge_Vert1(prim(w)) = u;     /* set the switch edge of w' */</a>
<a name="ln9062">        /* SwitchEdge[prim(w)][1] = v;  */</a>
<a name="ln9063">        SwitchEdge_IEdge(prim(w)) = iuv;</a>
<a name="ln9064">        (*pQSize) ++;</a>
<a name="ln9065">        ScanQ[*pQSize] = prim(w); /* add w' to ScanQ */</a>
<a name="ln9066">        TREE_MARK(prim(w), TREE_IN_2BLOSS);  /* mark w' s-reachable */</a>
<a name="ln9067">    }</a>
<a name="ln9068">    return w;</a>
<a name="ln9069">}</a>
<a name="ln9070"> </a>
<a name="ln9071"> </a>
<a name="ln9072"> </a>
<a name="ln9073">/*****************************************************************************</a>
<a name="ln9074">    When t is found to be s-reachable, a valid st-path P is known to exist.</a>
<a name="ln9075">    Its complementary path P' is also valid. Once the residual capacity</a>
<a name="ln9076">    delta(P) is known, the flow is augmented by calling PullFlow(s,t,delta).</a>
<a name="ln9077">    It constructs the path P by using the switch-edges.</a>
<a name="ln9078">    Let uv=SwitchEdge[t].</a>
<a name="ln9079">    Then P is given by a valid su-path, followed by the edge uv, followed by</a>
<a name="ln9080">    a valid vt-path.</a>
<a name="ln9081">    PullFlow is a recursive procedure that constructs the path and its complement.</a>
<a name="ln9082"> </a>
<a name="ln9083">    Let wz=SwitchEdge[y]. PullFlow(x, y, delta) uses the xw- and zy-portions of P</a>
<a name="ln9084">    (see below). Since it must also augment on P' simultaneously, the zy-portion</a>
<a name="ln9085">    is replaced by the y'z'-portion.</a>
<a name="ln9086"> </a>
<a name="ln9087">         x                  y'</a>
<a name="ln9088">         |                  |            P:   x--w--z--y</a>
<a name="ln9089">       P |                  |  P'        P':  y'-z'-w'-x'</a>
<a name="ln9090">         |                  o</a>
<a name="ln9091">         o                   \           </a>
<a name="ln9092">        /   w'          z     \          </a>
<a name="ln9093">       /   o----\   /----o    /</a>
<a name="ln9094">       \  /      \ /      \  /</a>
<a name="ln9095">        \/        X        \/</a>
<a name="ln9096">        /\       / \       /\</a>
<a name="ln9097">       /  \ w   /   \  z' /  \</a>
<a name="ln9098">       \   o----     ----o   /           Using a switch-edge wz and w'z'</a>
<a name="ln9099">        \                   /            to construct P and P'          </a>
<a name="ln9100">         o                 o  </a>
<a name="ln9101">         |                 | </a>
<a name="ln9102">         |                 |</a>
<a name="ln9103">         x'                y</a>
<a name="ln9104"> </a>
<a name="ln9105">**********************************************************************************/</a>
<a name="ln9106"> </a>
<a name="ln9107"> </a>
<a name="ln9108"> </a>
<a name="ln9109"> </a>
<a name="ln9110">/*********************************************************************************/</a>
<a name="ln9111">int PullFlow( BN_STRUCT *pBNS, Edge *SwitchEdge, Vertex x, Vertex y, int delta, S_CHAR bReverse, int bChangeFlow )</a>
<a name="ln9112">{ /* </a>
<a name="ln9113">     Augment the flow by delta on all edges on a path P</a>
<a name="ln9114">     between x and y in the order of the path;</a>
<a name="ln9115">     AugmentEdge( pBNS, w, z, iwz, delta, 0 ) means the path is in w-&gt;z direction</a>
<a name="ln9116">     AugmentEdge( pBNS, w, z, iwz, delta, 1 ) means the path is in w&lt;-z direction</a>
<a name="ln9117"> </a>
<a name="ln9118">     Unlike PullFlow in the paper by Kocay &amp; Stone, here the augmentation</a>
<a name="ln9119">     always starts at &quot;s&quot;, proceeds sequentially through the path end terminates at &quot;t&quot;.</a>
<a name="ln9120">     Since we do not really need the complement path, PullFlow ignores it.</a>
<a name="ln9121"> </a>
<a name="ln9122">  */</a>
<a name="ln9123">  </a>
<a name="ln9124">    Vertex w, z;</a>
<a name="ln9125">    EdgeIndex iwz;</a>
<a name="ln9126">    int ret = 0;</a>
<a name="ln9127"> </a>
<a name="ln9128">    w   = SwitchEdge_Vert1(y);</a>
<a name="ln9129">    z   = SwitchEdge_Vert2(y);</a>
<a name="ln9130">    iwz = SwitchEdge_IEdge(y);</a>
<a name="ln9131">    if ( bReverse ) {</a>
<a name="ln9132">        /* P consists of a path from x to w, then wz, then a path from z to y.  */</a>
<a name="ln9133">        /* z may equal y, in which case z is just PrevPt[y] */</a>
<a name="ln9134">        if ( z != y ) {</a>
<a name="ln9135">            ret = PullFlow( pBNS, SwitchEdge, prim(y), prim(z), delta, (S_CHAR)(1-bReverse), bChangeFlow ); /* augment between z and y */</a>
<a name="ln9136">        }</a>
<a name="ln9137">        if ( !IS_BNS_ERROR(ret) ) {</a>
<a name="ln9138">            ret = AugmentEdge( pBNS, w, z, iwz, delta, bReverse, bChangeFlow);</a>
<a name="ln9139">        }</a>
<a name="ln9140">        /* Do not augment the complementary path: AugmentEdge( prim(z), prim(w), vert, delta); */</a>
<a name="ln9141">        /* w may equal x, in which case there is no need to call PullFlow(x, w) */</a>
<a name="ln9142">        if ( w != x &amp;&amp; !IS_BNS_ERROR(ret) ) {</a>
<a name="ln9143">            ret = PullFlow( pBNS, SwitchEdge, x, w, delta, bReverse, bChangeFlow ); /* augment between x and w */</a>
<a name="ln9144">        }</a>
<a name="ln9145">    } else {</a>
<a name="ln9146">        /* P consists of a path from x to w, then wz, then a path from z to y.  */</a>
<a name="ln9147">        /* w may equal x, in which case there is no need to call PullFlow(x, w) */</a>
<a name="ln9148">        if ( w != x &amp;&amp; !IS_BNS_ERROR(ret) ) {</a>
<a name="ln9149">            ret = PullFlow( pBNS, SwitchEdge, x, w, delta, bReverse, bChangeFlow ); /* augment between x and w */</a>
<a name="ln9150">        }</a>
<a name="ln9151">        if ( !IS_BNS_ERROR(ret) ) {</a>
<a name="ln9152">            ret = AugmentEdge( pBNS, w, z, iwz, delta, bReverse, bChangeFlow);</a>
<a name="ln9153">        }</a>
<a name="ln9154">        /* z may equal y, in which case z is just PrevPt[y] */</a>
<a name="ln9155">        if ( z != y &amp;&amp; !IS_BNS_ERROR(ret) ) {</a>
<a name="ln9156">            ret = PullFlow( pBNS, SwitchEdge, prim(y), prim(z), delta, (S_CHAR)(1-bReverse), bChangeFlow ); /* augment between z and y */</a>
<a name="ln9157">        }</a>
<a name="ln9158">    }</a>
<a name="ln9159">    return ret;</a>
<a name="ln9160">}</a>
<a name="ln9161"> </a>
<a name="ln9162"> </a>
<a name="ln9163"> </a>
<a name="ln9164">/********************************************************************************</a>
<a name="ln9165">Before augmenting on the two paths, it is necessary to find delta(P).</a>
<a name="ln9166">This can be done by following the paths and computing the minimum</a>
<a name="ln9167">residual capacity of all edges on P. An edge on both P and P' counts</a>
<a name="ln9168">for only half of its actual residual capacity, since augmentng on P by</a>
<a name="ln9169">delta will simutaneously reduce its capacity on P' by delta.</a>
<a name="ln9170">The path P can only be followed by using the switch-edges, as in PullFlow(...).</a>
<a name="ln9171">FindPathCap( x, y, delta ) is a recursive procedure that finds the residual</a>
<a name="ln9172">capacity on the portion of P between x and y. delta is the minimum capacity</a>
<a name="ln9173">found so far along the path.</a>
<a name="ln9174">********************************************************************************/</a>
<a name="ln9175">int FindPathCap( BN_STRUCT* pBNS, Edge *SwitchEdge, Vertex x, Vertex y, int delta )</a>
<a name="ln9176">{ /* find the minimum residual capacity of all edges</a>
<a name="ln9177">     between x and y in a valid st-path P.</a>
<a name="ln9178">     delta is the minimum found so far</a>
<a name="ln9179">     the vertices occur in order s,...,x,...,y,...,t along P</a>
<a name="ln9180">     the vertices occur in order s,...,y',...,x',...,t along P'</a>
<a name="ln9181">  */</a>
<a name="ln9182">    Vertex w, z, iwz;</a>
<a name="ln9183">    int    cap, delta2;</a>
<a name="ln9184">    static int level;</a>
<a name="ln9185"> </a>
<a name="ln9186">    if ( level ++ &gt; 50 ) {</a>
<a name="ln9187">#ifdef _DEBUG</a>
<a name="ln9188">        int stop = 1;</a>
<a name="ln9189">#else</a>
<a name="ln9190">    ;</a>
<a name="ln9191">#endif</a>
<a name="ln9192">    }</a>
<a name="ln9193"> </a>
<a name="ln9194"> </a>
<a name="ln9195">    w   = SwitchEdge_Vert1(y);</a>
<a name="ln9196">    z   = SwitchEdge_Vert2(y); /* wz is on the path P */</a>
<a name="ln9197">    iwz = SwitchEdge_IEdge(y); /* edge index */</a>
<a name="ln9198"> </a>
<a name="ln9199">    /* rescap_mark() detects edges passed 2 times and reduces rescap */</a>
<a name="ln9200">    cap = rescap_mark( pBNS, w, z, iwz );</a>
<a name="ln9201"> </a>
<a name="ln9202">    if ( IS_BNS_ERROR( cap ) ) {</a>
<a name="ln9203">        level --;</a>
<a name="ln9204">        return cap;</a>
<a name="ln9205">    }</a>
<a name="ln9206">    if ( cap &lt; delta ) {</a>
<a name="ln9207">        delta = cap;</a>
<a name="ln9208">    }</a>
<a name="ln9209">    /* P consists of a path from x to w, then wz, then a path from z to y */</a>
<a name="ln9210">    if ( w != x ) {</a>
<a name="ln9211">        delta2 = FindPathCap( pBNS, SwitchEdge, x, w, delta );</a>
<a name="ln9212">        delta = inchi_min( delta2, delta );</a>
<a name="ln9213">    }</a>
<a name="ln9214">    if ( z != y ) {</a>
<a name="ln9215">        delta2 = FindPathCap( pBNS, SwitchEdge, prim(y), prim(z), delta );</a>
<a name="ln9216">        delta = inchi_min( delta2, delta );</a>
<a name="ln9217">    }</a>
<a name="ln9218">    level --;</a>
<a name="ln9219">    return delta;</a>
<a name="ln9220">}</a>
<a name="ln9221"> </a>
<a name="ln9222"> </a>
<a name="ln9223"> </a>
<a name="ln9224">/*********************************************************************************/</a>
<a name="ln9225">/* BT = bond types */</a>
<a name="ln9226">#define BT_ALTERN_BOND           1      /* 1-2, possibly stereo */</a>
<a name="ln9227">#define BT_OTHER_ALTERN_BOND     2      /* 1-3, 2-3, 1-2-3 alternating non-stereo non-taut bonds */</a>
<a name="ln9228"> </a>
<a name="ln9229">#define BT_ALTERN_NS_BOND        4</a>
<a name="ln9230"> </a>
<a name="ln9231">#define BT_TAUTOM_BOND           8</a>
<a name="ln9232"> </a>
<a name="ln9233">#define BT_ALTERN_UNKN_BOND     16</a>
<a name="ln9234"> </a>
<a name="ln9235">#define BT_IGNORE_BOND           0</a>
<a name="ln9236"> </a>
<a name="ln9237">#define BT_NONSTEREO_MASK        (BT_TAUTOM_BOND|BT_ALTERN_NS_BOND)</a>
<a name="ln9238"> </a>
<a name="ln9239">#define BT_ALT_BOND_MASK         (BT_ALTERN_BOND|BT_OTHER_ALTERN_BOND)</a>
<a name="ln9240"> </a>
<a name="ln9241">#define BT_NONTAUT_BOND_MASK     (BT_ALTERN_BOND|BT_OTHER_ALTERN_BOND|BT_ALTERN_NS_BOND)</a>
<a name="ln9242"> </a>
<a name="ln9243">/* BNS members redefinitions for finding non-stereo bonds */</a>
<a name="ln9244">/* BNS_EDGE */</a>
<a name="ln9245">#define nBlockNumberAltBns   flow   /* internal variable of the DFS traversal: mark traversed bonds */</a>
<a name="ln9246">#define nNumAtInBlockAltBns  cap</a>
<a name="ln9247">#define nBondTypeInpAltBns   pass    /* 0=&gt;cannot be stereo at all, 1=&gt;alt or taut non-stereo, 2=&gt;can be stereo */</a>
<a name="ln9248">#define nBondNonStereoAltBns cap     /* 1=&gt;found to be non-stereogenic although BondTypeInp=2; 0=&gt;as in BondTypeInp */</a>
<a name="ln9249"> </a>
<a name="ln9250">#if ( BNS_MARK_ONLY_BLOCKS == 1 )   /* { */</a>
<a name="ln9251">/* BNS_VERTEX */</a>
<a name="ln9252">#define bCutVertexAltBns         st_edge.cap0  /* cut-vertex flag */</a>
<a name="ln9253">#define nRingSystemAltBns        st_edge.cap   /* ordering number of a ring system */</a>
<a name="ln9254">#define nNumAtInRingSystemAltBns st_edge.flow0 /* number of vertices in a ring system */</a>
<a name="ln9255">#define nBlockSystemAltBns       st_edge.flow  /* result of the DFS traversal: even cirquit must be within one block */</a>
<a name="ln9256"> </a>
<a name="ln9257">#endif  /* } */</a>
<a name="ln9258"> </a>
<a name="ln9259">#define valenceAltBns            num_adj_edges</a>
<a name="ln9260">/*********************************************************************************/</a>
<a name="ln9261"> </a>
<a name="ln9262"> </a>
<a name="ln9263">/********************************************************************************/</a>
<a name="ln9264">int MarkRingSystemsAltBns( BN_STRUCT* pBNS, int bUnknAltAsNoStereo )</a>
<a name="ln9265">{</a>
<a name="ln9266">    AT_NUMB   *nStackAtom = NULL;</a>
<a name="ln9267">    int        nTopStackAtom;</a>
<a name="ln9268">    AT_NUMB   *nRingStack = NULL;</a>
<a name="ln9269">    int        nTopRingStack; /* was AT_NUMB */</a>
<a name="ln9270">    AT_NUMB   *nBondStack = NULL;</a>
<a name="ln9271">    int        nTopBondStack;</a>
<a name="ln9272">    AT_NUMB   *nDfsNumber = NULL;</a>
<a name="ln9273">    AT_NUMB   *nLowNumber = NULL;</a>
<a name="ln9274">    S_CHAR    *cNeighNumb = NULL;</a>
<a name="ln9275">    AT_NUMB    nDfs;</a>
<a name="ln9276">    AT_NUMB    nNumAtInRingSystem;</a>
<a name="ln9277">    int        i, j, u, w, start, nNumRingSystems, nNumStartChildren;</a>
<a name="ln9278">    BNS_VERTEX *at       = pBNS-&gt;vert;</a>
<a name="ln9279">    BNS_EDGE   *bond     = pBNS-&gt;edge;</a>
<a name="ln9280">    int        num_atoms = pBNS-&gt;num_atoms;</a>
<a name="ln9281">    int        num_edges = pBNS-&gt;num_bonds;</a>
<a name="ln9282"> </a>
<a name="ln9283">    /*  allocate arrays */</a>
<a name="ln9284">    nStackAtom = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nStackAtom[0]));</a>
<a name="ln9285">    nRingStack = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nRingStack[0]));</a>
<a name="ln9286">    nDfsNumber = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nDfsNumber[0]));</a>
<a name="ln9287">    nLowNumber = (AT_NUMB *) inchi_malloc(num_atoms*sizeof(nLowNumber[0]));</a>
<a name="ln9288">    nBondStack = (AT_NUMB *) (num_edges? inchi_malloc(num_edges*sizeof(nBondStack[0])):NULL); /* special case: no bonds 2006-03 */</a>
<a name="ln9289">    cNeighNumb = (S_CHAR  *) inchi_malloc(num_atoms*sizeof(cNeighNumb[0]));</a>
<a name="ln9290">    /*  check allocation */</a>
<a name="ln9291">    if ( !nStackAtom || !nRingStack || !nDfsNumber || !nLowNumber || (!nBondStack &amp;&amp; num_edges) || !cNeighNumb</a>
<a name="ln9292">        ) {</a>
<a name="ln9293">        nNumRingSystems = CT_OUT_OF_RAM;  /*  program error */ /*   &lt;BRKPT&gt; */</a>
<a name="ln9294">        goto exit_function;</a>
<a name="ln9295">    }</a>
<a name="ln9296"> </a>
<a name="ln9297">    /********************************************</a>
<a name="ln9298">     *</a>
<a name="ln9299">     * Find Cut-vertices &amp; Blocks</a>
<a name="ln9300">     *</a>
<a name="ln9301">     *             1\      /5   has 3 blocks (maximal subgraphs that</a>
<a name="ln9302">     *  Example:   | &gt;3--4&lt; |   are nonseparable by deleting a single vertex):</a>
<a name="ln9303">     *             2/      \6   (1,2,3, has 3 bonds), (3,4, has 1 bond), and (4,5,6, has 3 bonds)</a>
<a name="ln9304">     *</a>
<a name="ln9305">     *                          Cut-vertices or articulation points are </a>
<a name="ln9306">     *                          intersections of the blocks: points 3 and 4.</a>
<a name="ln9307">     ********************************************/</a>
<a name="ln9308"> </a>
<a name="ln9309">    /********************************************************</a>
<a name="ln9310"> </a>
<a name="ln9311">       RingSystemAlt are atoms connected by alternating bonds</a>
<a name="ln9312">       (as must be indicated in bIsAltBond()):</a>
<a name="ln9313"> </a>
<a name="ln9314">       BOND_ALTERN</a>
<a name="ln9315">       BOND_ALT_123</a>
<a name="ln9316">       BOND_ALT_13 </a>
<a name="ln9317">       BOND_ALT_23</a>
<a name="ln9318">       </a>
<a name="ln9319">      Since other bonds may be present, we possibly need</a>
<a name="ln9320">      to restart to move to another component </a>
<a name="ln9321">    *********************************************************/</a>
<a name="ln9322"> </a>
<a name="ln9323">    nNumRingSystems = 0;</a>
<a name="ln9324">    memset( nDfsNumber, 0, num_atoms*sizeof(nDfsNumber[0]));</a>
<a name="ln9325"> </a>
<a name="ln9326">    for ( start = 0; start &lt; num_atoms; start ++ ) {</a>
<a name="ln9327">        if ( nDfsNumber[start] )</a>
<a name="ln9328">            continue;</a>
<a name="ln9329">        for ( i = 0; i &lt; at[start].valenceAltBns; i ++ ) {</a>
<a name="ln9330">            if ( bond[at[start].iedge[i]].nBondTypeInpAltBns &amp; BT_ALTERN_BOND )</a>
<a name="ln9331">                goto found_alt;</a>
<a name="ln9332">        }</a>
<a name="ln9333">        continue;</a>
<a name="ln9334"> </a>
<a name="ln9335">found_alt:</a>
<a name="ln9336"> </a>
<a name="ln9337"> </a>
<a name="ln9338">        /*  initiation */</a>
<a name="ln9339">        u               = start; /*  start atom */</a>
<a name="ln9340">        nDfs            = 0;</a>
<a name="ln9341">        nTopStackAtom   =-1;</a>
<a name="ln9342">        nTopRingStack   =-1;</a>
<a name="ln9343">        nTopBondStack   =-1;</a>
<a name="ln9344">        memset( cNeighNumb, 0, num_atoms*sizeof(cNeighNumb[0]));</a>
<a name="ln9345">        /*  push the start atom on the stack */</a>
<a name="ln9346">        nLowNumber[u] = nDfsNumber[u] = ++nDfs;</a>
<a name="ln9347">        nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln9348">        nRingStack[++nTopRingStack] = (AT_NUMB)u;</a>
<a name="ln9349"> </a>
<a name="ln9350">        nNumStartChildren = 0;</a>
<a name="ln9351"> </a>
<a name="ln9352">        do {</a>
<a name="ln9353">            /* advance */</a>
<a name="ln9354">            /*while ( (int)at[i=nStackAtom[nTopStackAtom]].valenceAltBns &gt; (j = (int)cNeighNumb[i]) )*/</a>
<a name="ln9355">            /* replaced due to missing sequence point */</a>
<a name="ln9356">            while ( i=(int)nStackAtom[nTopStackAtom], j = (int)cNeighNumb[i], (int)at[i].valenceAltBns &gt; j )</a>
<a name="ln9357">            {</a>
<a name="ln9358">                cNeighNumb[i] ++;</a>
<a name="ln9359">                if ( !(bond[w=at[i].iedge[j]].nBondTypeInpAltBns &amp; BT_ALT_BOND_MASK) ) {</a>
<a name="ln9360">                    continue;</a>
<a name="ln9361">                }</a>
<a name="ln9362">                u = (int)(bond[at[i].iedge[j]].neighbor12 ^ i);</a>
<a name="ln9363">                if ( !nDfsNumber[u] ) {</a>
<a name="ln9364">                    /* tree edge, 1st visit -- advance */</a>
<a name="ln9365">                    nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln9366">                    nRingStack[++nTopRingStack] = (AT_NUMB)u;</a>
<a name="ln9367">                    nBondStack[++nTopBondStack] = (AT_NUMB)w;</a>
<a name="ln9368">                    nLowNumber[u] = nDfsNumber[u] = ++nDfs;</a>
<a name="ln9369">                    nNumStartChildren += (i == start);</a>
<a name="ln9370">                } else</a>
<a name="ln9371">                if ( !nTopStackAtom || u != (int)nStackAtom[nTopStackAtom-1] ) { /*  may comment out ? */</a>
<a name="ln9372">                    /* back edge: u is not a predecessor of i */</a>
<a name="ln9373">                    if ( nDfsNumber[u] &lt; nDfsNumber[i] ) {</a>
<a name="ln9374">                        /* Back edge, 1st visit: u is ancestor of i. Save and compare */</a>
<a name="ln9375">                        nBondStack[++nTopBondStack] = (AT_NUMB)w;</a>
<a name="ln9376">                        if ( nLowNumber[i] &gt; nDfsNumber[u] ) {</a>
<a name="ln9377">                            nLowNumber[i] = nDfsNumber[u];</a>
<a name="ln9378">                        }</a>
<a name="ln9379">                    }</a>
<a name="ln9380">                }</a>
<a name="ln9381">            }</a>
<a name="ln9382">            cNeighNumb[i] = 0;</a>
<a name="ln9383"> </a>
<a name="ln9384">            /* back up */</a>
<a name="ln9385">            if ( i != start ) {</a>
<a name="ln9386">                u = (int)nStackAtom[nTopStackAtom-1]; /* predecessor of i */</a>
<a name="ln9387">                if ( nLowNumber[i] &gt;= nDfsNumber[u] ) {</a>
<a name="ln9388">                    /* output the block; the block was entered through its first bond u-&gt;i */</a>
<a name="ln9389">                    nNumRingSystems ++;</a>
<a name="ln9390">                    /*at[u].nBlockSystemAltBns = nNumRingSystems;*/ /* mark the atom */</a>
<a name="ln9391">                    nNumAtInRingSystem = 1;</a>
<a name="ln9392">                    /*</a>
<a name="ln9393">                    if ( u != start || nNumStartChildren &gt; 1 ) {</a>
<a name="ln9394">                        at[u].bCutVertexAltBns += 1;  // mark cut-vertex (articulation point)</a>
<a name="ln9395">                    }</a>
<a name="ln9396">                    */</a>
<a name="ln9397">                    while ( nTopRingStack &gt;= 0 ) {</a>
<a name="ln9398">                        j = nRingStack[nTopRingStack--];</a>
<a name="ln9399">                        /*at[j].nBlockSystemAltBns = nNumRingSystems;*/ /*  mark the atom */</a>
<a name="ln9400">                        nNumAtInRingSystem ++;</a>
<a name="ln9401">                        if ( i == j ) {</a>
<a name="ln9402">                            break;</a>
<a name="ln9403">                        }</a>
<a name="ln9404">                    }</a>
<a name="ln9405">                    while ( nTopBondStack &gt;= 0 ) {</a>
<a name="ln9406">                        w = nBondStack[nTopBondStack--];</a>
<a name="ln9407">                        bond[w].nBlockNumberAltBns  = nNumRingSystems; /*  mark the bond */</a>
<a name="ln9408">                        bond[w].nNumAtInBlockAltBns = nNumAtInRingSystem;</a>
<a name="ln9409">                        if ( (i == bond[w].neighbor1 &amp;&amp; u == (i ^ bond[w].neighbor12)) ||</a>
<a name="ln9410">                             (u == bond[w].neighbor1 &amp;&amp; i == (u ^ bond[w].neighbor12))) {</a>
<a name="ln9411">                            break;</a>
<a name="ln9412">                        }</a>
<a name="ln9413">                    }</a>
<a name="ln9414">                } else</a>
<a name="ln9415">                if ( nLowNumber[u] &gt; nLowNumber[i] ) {</a>
<a name="ln9416">                    /* inherit */</a>
<a name="ln9417">                    nLowNumber[u] = nLowNumber[i];</a>
<a name="ln9418">                }</a>
<a name="ln9419">            }</a>
<a name="ln9420">        } while ( --nTopStackAtom &gt;= 0 );</a>
<a name="ln9421">    }</a>
<a name="ln9422"> </a>
<a name="ln9423">#if ( BNS_MARK_ONLY_BLOCKS != 1 )  /* { */</a>
<a name="ln9424"> </a>
<a name="ln9425">    /********************************************</a>
<a name="ln9426">     *</a>
<a name="ln9427">     * Find Ring Systems</a>
<a name="ln9428">     * Including chain atoms X: A-X-B, where the bonds (of any kind) are bridges.</a>
<a name="ln9429">     *</a>
<a name="ln9430">     ********************************************/</a>
<a name="ln9431"> </a>
<a name="ln9432">    /*  initiation */</a>
<a name="ln9433"> </a>
<a name="ln9434">    nNumRingSystems = 0;</a>
<a name="ln9435"> </a>
<a name="ln9436">    for ( start = 0; start &lt; num_atoms; start ++ ) {</a>
<a name="ln9437">        if ( at[start].nRingSystemAltBns )</a>
<a name="ln9438">            continue;</a>
<a name="ln9439">        for ( i = 0; i &lt; at[start].valenceAltBns; i ++ ) {</a>
<a name="ln9440">            if ( bond[at[start].iedge[i]].nBondTypeInpAltBns &amp; BT_ALT_BOND_MASK )</a>
<a name="ln9441">                goto found_alt2;</a>
<a name="ln9442">        }</a>
<a name="ln9443">        continue;</a>
<a name="ln9444"> </a>
<a name="ln9445">found_alt2:</a>
<a name="ln9446"> </a>
<a name="ln9447">        u               = start; /*  start atom */</a>
<a name="ln9448">        nDfs            = 0;</a>
<a name="ln9449">        nTopStackAtom   =-1;</a>
<a name="ln9450">        nTopRingStack   =-1;</a>
<a name="ln9451">        memset( nDfsNumber, 0, num_atoms*sizeof(nDfsNumber[0]));</a>
<a name="ln9452">        memset( cNeighNumb, 0, num_atoms*sizeof(cNeighNumb[0]));</a>
<a name="ln9453">        /*  push the start atom on the stack */</a>
<a name="ln9454">        nLowNumber[u] = nDfsNumber[u] = ++nDfs;</a>
<a name="ln9455">        nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln9456">        nRingStack[++nTopRingStack] = (AT_NUMB)u;</a>
<a name="ln9457"> </a>
<a name="ln9458">        do {</a>
<a name="ln9459">            /* advance */</a>
<a name="ln9460">advance_ring:</a>
<a name="ln9461">            /*if ( (int)at[i=nStackAtom[nTopStackAtom]].valenceAltBns &gt; (j = (int)cNeighNumb[i]) )*/</a>
<a name="ln9462">            /* replaced due to missing sequence point */</a>
<a name="ln9463">            if ( i=(int)nStackAtom[nTopStackAtom], j = (int)cNeighNumb[i], (int)at[i].valenceAltBns &gt; j )</a>
<a name="ln9464">            {</a>
<a name="ln9465">                cNeighNumb[i] ++;</a>
<a name="ln9466">                if ( !(bond[at[i].iedge[j]].nBondTypeInpAltBns &amp; BT_ALTERN_BOND) ) {</a>
<a name="ln9467">                    goto advance_ring;</a>
<a name="ln9468">                }</a>
<a name="ln9469">                u = (int)(bond[at[i].iedge[j]].neighbor12 ^ i);</a>
<a name="ln9470">                if ( !nDfsNumber[u] ) {</a>
<a name="ln9471">                    /* tree edge, 1st visit -- advance */</a>
<a name="ln9472">                    nStackAtom[++nTopStackAtom] = (AT_NUMB)u;</a>
<a name="ln9473">                    nRingStack[++nTopRingStack] = (AT_NUMB)u;</a>
<a name="ln9474">                    nLowNumber[u] = nDfsNumber[u] = ++nDfs;</a>
<a name="ln9475">                } else</a>
<a name="ln9476">                if ( !nTopStackAtom || u != (int)nStackAtom[nTopStackAtom-1] ) {</a>
<a name="ln9477">                    /* back edge: u is not a predecessor of i */</a>
<a name="ln9478">                    if ( nDfsNumber[u] &lt; nDfsNumber[i] ) {</a>
<a name="ln9479">                        /* Back edge, 1st visit: u is ancestor of i. Compare */</a>
<a name="ln9480">                        if ( nLowNumber[i] &gt; nDfsNumber[u] ) {</a>
<a name="ln9481">                            nLowNumber[i] = nDfsNumber[u];</a>
<a name="ln9482">                        }</a>
<a name="ln9483">                    }</a>
<a name="ln9484">                }</a>
<a name="ln9485">                goto advance_ring;</a>
<a name="ln9486">            } else {</a>
<a name="ln9487">                cNeighNumb[i] = 0;</a>
<a name="ln9488">            }</a>
<a name="ln9489"> </a>
<a name="ln9490">            /* back up */</a>
<a name="ln9491">            if ( nDfsNumber[i] == nLowNumber[i] ) {</a>
<a name="ln9492">                /*  found a ring system */</a>
<a name="ln9493">                nNumRingSystems ++;</a>
<a name="ln9494"> </a>
<a name="ln9495">                /*  unwind nRingStack[] down to i */</a>
<a name="ln9496"> </a>
<a name="ln9497">                /*  count atoms in a ring system */</a>
<a name="ln9498">                for ( nNumAtInRingSystem = 0, j =  nTopRingStack; 0 &lt;= j; j -- ) {</a>
<a name="ln9499">                    nNumAtInRingSystem ++;</a>
<a name="ln9500">                    if ( i == (int)nRingStack[j] ) {</a>
<a name="ln9501">                        break;</a>
<a name="ln9502">                    }</a>
<a name="ln9503">                }</a>
<a name="ln9504">                while ( nTopRingStack &gt;= 0 ) {</a>
<a name="ln9505">                    j = (int)nRingStack[nTopRingStack--];</a>
<a name="ln9506">                    at[j].nRingSystemAltBns        = (AT_NUMB)nNumRingSystems; /*  ring system id */</a>
<a name="ln9507">                    at[j].nNumAtInRingSystemAltBns = nNumAtInRingSystem;</a>
<a name="ln9508">                    if ( i == j ) {</a>
<a name="ln9509">                        /*  reached atom on the top of nStackAtom[] stack  */</a>
<a name="ln9510">                        break;</a>
<a name="ln9511">                    }</a>
<a name="ln9512">                }</a>
<a name="ln9513">            } else</a>
<a name="ln9514">            if ( nTopStackAtom &gt; 0 ) {</a>
<a name="ln9515">                j = (int)nStackAtom[nTopStackAtom-1];</a>
<a name="ln9516">                /* inherit nLowNumber */</a>
<a name="ln9517">                if ( nLowNumber[j] &gt; nLowNumber[i] ) {</a>
<a name="ln9518">                    nLowNumber[j] = nLowNumber[i];</a>
<a name="ln9519">                }</a>
<a name="ln9520">            }</a>
<a name="ln9521">        } while ( --nTopStackAtom &gt;= 0 );</a>
<a name="ln9522">    }</a>
<a name="ln9523"> </a>
<a name="ln9524">#endif /* }  BNS_MARK_ONLY_BLOCKS != 1 */</a>
<a name="ln9525"> </a>
<a name="ln9526">exit_function:</a>
<a name="ln9527">    if ( nStackAtom )</a>
<a name="ln9528">        inchi_free( nStackAtom );</a>
<a name="ln9529">    if ( nRingStack )</a>
<a name="ln9530">        inchi_free( nRingStack );</a>
<a name="ln9531">    if ( nDfsNumber )</a>
<a name="ln9532">        inchi_free( nDfsNumber );</a>
<a name="ln9533">    if ( nLowNumber )</a>
<a name="ln9534">        inchi_free( nLowNumber );</a>
<a name="ln9535">    if ( nBondStack )</a>
<a name="ln9536">        inchi_free( nBondStack );</a>
<a name="ln9537">    if ( cNeighNumb )</a>
<a name="ln9538">        inchi_free( cNeighNumb );</a>
<a name="ln9539">    return nNumRingSystems;</a>
<a name="ln9540">}</a>
<a name="ln9541"> </a>
<a name="ln9542"> </a>
<a name="ln9543"> </a>
<a name="ln9544">/*****************************************************************************/</a>
<a name="ln9545">int ReInitBnStructForAltBns( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bUnknAltAsNoStereo )</a>
<a name="ln9546">{</a>
<a name="ln9547">    Vertex v, v2;</a>
<a name="ln9548">    int ret, bond_type, num_to_test, j;</a>
<a name="ln9549">    BNS_EDGE   *pBond;</a>
<a name="ln9550">    BNS_VERTEX *pAtom;</a>
<a name="ln9551">    /* strip all t-groups and c-groups */</a>
<a name="ln9552">    num_to_test = 0;</a>
<a name="ln9553">    if ( bUnknAltAsNoStereo ) {</a>
<a name="ln9554">        for ( j = 0; j &lt; pBNS-&gt;num_edges; j ++ ) {</a>
<a name="ln9555">            pBNS-&gt;edge[j].pass = 0;</a>
<a name="ln9556">        }</a>
<a name="ln9557">    }</a>
<a name="ln9558">    ret = ReInitBnStruct( pBNS, at, num_atoms, 0 );</a>
<a name="ln9559">    if ( ret || pBNS-&gt;num_atoms != num_atoms || pBNS-&gt;num_vertices != num_atoms || pBNS-&gt;num_bonds != pBNS-&gt;num_edges ) {</a>
<a name="ln9560">        ret = BNS_REINIT_ERR;</a>
<a name="ln9561">        goto exit_function;</a>
<a name="ln9562">    }</a>
<a name="ln9563">    /* eliminate bonds and fix st-caps */</a>
<a name="ln9564">    for ( v = 0; v &lt; num_atoms; v ++ ) {</a>
<a name="ln9565">        pAtom = pBNS-&gt;vert + v;</a>
<a name="ln9566">        for ( j = 0; j &lt; pAtom-&gt;valenceAltBns; j ++ ) {</a>
<a name="ln9567">            pBond = pBNS-&gt;edge + pAtom-&gt;iedge[j];</a>
<a name="ln9568">            if ( pBond-&gt;neighbor1 == v ) {</a>
<a name="ln9569">                bond_type = (at[v].bond_type[j] &amp; BOND_TYPE_MASK);</a>
<a name="ln9570">                v2 = pBond-&gt;neighbor12 ^ v;</a>
<a name="ln9571">                if ( at[v].endpoint || at[v2].endpoint ) {</a>
<a name="ln9572">                    bond_type = 0; /* any bond to an endpoint considered non-stereogenic */</a>
<a name="ln9573">                }</a>
<a name="ln9574">#if ( FIX_EITHER_DB_AS_NONSTEREO == 1 )</a>
<a name="ln9575">                if ( bUnknAltAsNoStereo ) {</a>
<a name="ln9576">                    if ( bond_type == BOND_ALTERN &amp;&amp; at[v].bond_stereo[j] == STEREO_DBLE_EITHER ) {</a>
<a name="ln9577">                        bond_type = 0; /* treat unknown (Either) ALT bond as non-stereo */</a>
<a name="ln9578">                    }</a>
<a name="ln9579">                }</a>
<a name="ln9580">#endif</a>
<a name="ln9581">                switch ( bond_type ) {</a>
<a name="ln9582">                </a>
<a name="ln9583">                case BOND_ALTERN :</a>
<a name="ln9584">                    pBond-&gt;nBondTypeInpAltBns = BT_ALTERN_BOND;</a>
<a name="ln9585">                    num_to_test ++;</a>
<a name="ln9586">                    break;</a>
<a name="ln9587">                </a>
<a name="ln9588">                case BOND_ALT_123:</a>
<a name="ln9589">                case BOND_ALT_13 :</a>
<a name="ln9590">                case BOND_ALT_23 :</a>
<a name="ln9591">                    pBond-&gt;nBondTypeInpAltBns = BT_OTHER_ALTERN_BOND;</a>
<a name="ln9592">                    break;</a>
<a name="ln9593"> </a>
<a name="ln9594">                case BOND_TAUTOM :</a>
<a name="ln9595">                    pBond-&gt;nBondTypeInpAltBns = BT_TAUTOM_BOND;</a>
<a name="ln9596">                    break;</a>
<a name="ln9597">                </a>
<a name="ln9598">                case BOND_ALT12NS:</a>
<a name="ln9599">                    pBond-&gt;nBondTypeInpAltBns = BT_ALTERN_NS_BOND;</a>
<a name="ln9600">                    break;</a>
<a name="ln9601"> </a>
<a name="ln9602">                case 0:</a>
<a name="ln9603">                case BOND_SINGLE :</a>
<a name="ln9604">                case BOND_DOUBLE :</a>
<a name="ln9605">                case BOND_TRIPLE :</a>
<a name="ln9606">                    pBond-&gt;nBondTypeInpAltBns = BT_IGNORE_BOND;</a>
<a name="ln9607">                    break;</a>
<a name="ln9608"> </a>
<a name="ln9609">                default:</a>
<a name="ln9610">                    pBond-&gt;nBondTypeInpAltBns = BT_IGNORE_BOND;</a>
<a name="ln9611">                    break;</a>
<a name="ln9612"> </a>
<a name="ln9613">                }</a>
<a name="ln9614">                pBond-&gt;nBondNonStereoAltBns = 0;</a>
<a name="ln9615">                pBond-&gt;nBlockNumberAltBns   = 0;</a>
<a name="ln9616">                pBond-&gt;nNumAtInBlockAltBns  = 0;</a>
<a name="ln9617"> </a>
<a name="ln9618">#if ( RESET_EDGE_FORBIDDEN_MASK == 1 )</a>
<a name="ln9619">                pBond-&gt;forbidden &amp;= pBNS-&gt;edge_forbidden_mask;</a>
<a name="ln9620">#endif</a>
<a name="ln9621">            }</a>
<a name="ln9622">        }</a>
<a name="ln9623">        pAtom-&gt;bCutVertexAltBns         =</a>
<a name="ln9624">        pAtom-&gt;nRingSystemAltBns        =</a>
<a name="ln9625">        pAtom-&gt;nNumAtInRingSystemAltBns =</a>
<a name="ln9626">        pAtom-&gt;nBlockSystemAltBns       = 0;</a>
<a name="ln9627">    }</a>
<a name="ln9628"> </a>
<a name="ln9629">    return num_to_test;</a>
<a name="ln9630">exit_function:</a>
<a name="ln9631">    return ret;</a>
<a name="ln9632">}</a>
<a name="ln9633"> </a>
<a name="ln9634"> </a>
<a name="ln9635"> </a>
<a name="ln9636">/*****************************************************************************/</a>
<a name="ln9637">int MarkNonStereoAltBns( BN_STRUCT *pBNS, inp_ATOM *at, int num_atoms, int bUnknAltAsNoStereo )</a>
<a name="ln9638">{</a>
<a name="ln9639">    int       num_bonds = pBNS-&gt;num_bonds;</a>
<a name="ln9640">    int       ret;</a>
<a name="ln9641">    int       ibond, ib1, ib2;</a>
<a name="ln9642">    BNS_EDGE *pBond;</a>
<a name="ln9643">    Vertex    iat1, iat2;</a>
<a name="ln9644"> </a>
<a name="ln9645">    ret = 0;</a>
<a name="ln9646"> </a>
<a name="ln9647">    if ( pBNS-&gt;num_atoms != num_atoms || pBNS-&gt;num_vertices != num_atoms || pBNS-&gt;num_bonds != pBNS-&gt;num_edges ) {</a>
<a name="ln9648">        ret = BNS_REINIT_ERR;</a>
<a name="ln9649">        goto exit_function;</a>
<a name="ln9650">    }</a>
<a name="ln9651">    if ( bUnknAltAsNoStereo ) {</a>
<a name="ln9652">        for ( ibond=0; ibond &lt; num_bonds; ibond ++ ) {</a>
<a name="ln9653">            pBond = pBNS-&gt;edge + ibond;</a>
<a name="ln9654">            if ( pBond-&gt;nBondTypeInpAltBns != BT_ALTERN_BOND &amp;&amp; pBond-&gt;nBondTypeInpAltBns != BT_IGNORE_BOND ) {</a>
<a name="ln9655">                continue;</a>
<a name="ln9656">            }</a>
<a name="ln9657">            iat1 = pBond-&gt;neighbor1;</a>
<a name="ln9658">            iat2 = pBond-&gt;neighbor12 ^ iat1;</a>
<a name="ln9659">            ib1  = pBond-&gt;neigh_ord[0];</a>
<a name="ln9660">            ib2  = pBond-&gt;neigh_ord[1];</a>
<a name="ln9661">            if ( /* alt bond non-adjacent to a taut. endpoint: */</a>
<a name="ln9662">                  (pBond-&gt;nBondTypeInpAltBns == BT_ALTERN_BOND &amp;&amp;</a>
<a name="ln9663">                  pBond-&gt;nNumAtInBlockAltBns &lt;= 3 )  /* non-ring bond */ ||</a>
<a name="ln9664">                 /* alt bond adjacent to a taut. endpoint: */</a>
<a name="ln9665">                  (pBond-&gt;nBondTypeInpAltBns == BT_IGNORE_BOND &amp;&amp;</a>
<a name="ln9666">                  (at[iat1].bond_type[ib1] &amp; BOND_TYPE_MASK) == BOND_ALTERN )</a>
<a name="ln9667">                ) {</a>
<a name="ln9668">                if ( (at[iat1].bond_type[ib1] &amp; BOND_TYPE_MASK) == BOND_ALTERN ) {</a>
<a name="ln9669">                    /* bond_type = BOND_ALT12NS; */</a>
<a name="ln9670">                    at[iat1].bond_stereo[ib1] =</a>
<a name="ln9671">                    at[iat2].bond_stereo[ib2] =STEREO_DBLE_EITHER;</a>
<a name="ln9672">                    ret ++;</a>
<a name="ln9673">                }</a>
<a name="ln9674">            } </a>
<a name="ln9675">        }</a>
<a name="ln9676">    } else {</a>
<a name="ln9677">        for ( ibond=0; ibond &lt; num_bonds; ibond ++ ) {</a>
<a name="ln9678">            pBond = pBNS-&gt;edge + ibond;</a>
<a name="ln9679">            if ( pBond-&gt;nBondTypeInpAltBns != BT_ALTERN_BOND &amp;&amp; pBond-&gt;nBondTypeInpAltBns != BT_IGNORE_BOND ) {</a>
<a name="ln9680">                continue;</a>
<a name="ln9681">            }</a>
<a name="ln9682">            iat1 = pBond-&gt;neighbor1;</a>
<a name="ln9683">            iat2 = pBond-&gt;neighbor12 ^ iat1;</a>
<a name="ln9684">            ib1  = pBond-&gt;neigh_ord[0];</a>
<a name="ln9685">            ib2  = pBond-&gt;neigh_ord[1];</a>
<a name="ln9686">            if ( /* alt bond non-adjacent to a taut. endpoint: */</a>
<a name="ln9687">                 (pBond-&gt;nBondTypeInpAltBns == BT_ALTERN_BOND &amp;&amp;</a>
<a name="ln9688">                  pBond-&gt;nNumAtInBlockAltBns &lt;= 3 ) /* non-ring bond */ ||</a>
<a name="ln9689">                 /* alt bond adjacent to a taut. endpoint: */</a>
<a name="ln9690">                 (pBond-&gt;nBondTypeInpAltBns == BT_IGNORE_BOND &amp;&amp;</a>
<a name="ln9691">                  (at[iat1].bond_type[ib1] &amp; BOND_TYPE_MASK) == BOND_ALTERN ) </a>
<a name="ln9692">                ) </a>
<a name="ln9693">            {</a>
<a name="ln9694">                at[iat1].bond_type[ib1] =</a>
<a name="ln9695">                at[iat2].bond_type[ib2] =BOND_ALT12NS;</a>
<a name="ln9696">                ret ++;</a>
<a name="ln9697">            } </a>
<a name="ln9698">        }</a>
<a name="ln9699">    }</a>
<a name="ln9700"> </a>
<a name="ln9701">exit_function:</a>
<a name="ln9702"> </a>
<a name="ln9703">    return ret;</a>
<a name="ln9704">}</a>
<a name="ln9705"> </a>
<a name="ln9706">#if ( READ_INCHI_STRING == 1 )</a>
<a name="ln9707">/*****************************************************************************/</a>
<a name="ln9708">#ifndef RI_ERR_ALLOC</a>
<a name="ln9709">/* from ichirvrs.h */</a>
<a name="ln9710">#define RI_ERR_ALLOC   (-1)</a>
<a name="ln9711">#define RI_ERR_SYNTAX  (-2)</a>
<a name="ln9712">#define RI_ERR_PROGR   (-3)</a>
<a name="ln9713">#endif</a>
<a name="ln9714"> </a>
<a name="ln9715"> </a>
<a name="ln9716"> </a>
<a name="ln9717">/*****************************************************************************/</a>
<a name="ln9718">int bHasChargedNeighbor( inp_ATOM *at, int iat )</a>
<a name="ln9719">{</a>
<a name="ln9720">    int i;</a>
<a name="ln9721">    for( i = 0; i &lt; at[iat].valence; i ++ ) {</a>
<a name="ln9722">        if ( at[(int)at[iat].neighbor[i]].charge )</a>
<a name="ln9723">            return 1;</a>
<a name="ln9724">    }</a>
<a name="ln9725">    return 0;</a>
<a name="ln9726">}</a>
<a name="ln9727"> </a>
<a name="ln9728"> </a>
<a name="ln9729"> </a>
<a name="ln9730">/*********************************************************************************</a>
<a name="ln9731">    *num_protons_to_add = nToBeRemovedByNormFromRevrs</a>
<a name="ln9732"> </a>
<a name="ln9733">    nToBeRemovedByNormFromRevrs &gt; 0: less protons should be allowed to be</a>
<a name="ln9734">                                     added by the Normalization of the Reconstructed Structure</a>
<a name="ln9735">    nToBeRemovedByNormFromRevrs &lt; 0: prepare more H(+) to be removed by</a>
<a name="ln9736">                                     the InChI Normalization of the Reconstructed Structure</a>
<a name="ln9737"> </a>
<a name="ln9738">    OrigStruct -&gt; NormOrig + n(orig)*H(+) </a>
<a name="ln9739">    RevrStruct -&gt; NormRevr + n(revr)*H(+) </a>
<a name="ln9740">    nToBeRemovedByNormFromRevrs = n(orig) - n(revr)  [each may be negative]</a>
<a name="ln9741">    </a>
<a name="ln9742">    n(orig) &gt; n(revr) or nToBeRemovedByNormFromRevrs &gt; 0 means:</a>
<a name="ln9743">    -----------------------------------------------------------</a>
<a name="ln9744">    - Too many protons were added by the Normalization to the Reconstructed Structure</a>
<a name="ln9745">      (a) n(revr) &lt; 0 =&gt; protons were added while they should not have been added;</a>
<a name="ln9746">          Solution: &quot;neutralize&quot; (-) charged proton acceptors by moving charges to other atoms</a>
<a name="ln9747">                     on the condition ADP cannot add in another way;</a>
<a name="ln9748">      (b) n(orig) &gt; n(revr) =&gt; 0  =&gt; too few protons were removed</a>
<a name="ln9749">          Solution: (the easiest) attach H(+) to =O or -N&lt; or -N=</a>
<a name="ln9750">          Solution: move (+) from N or OH to an atom adjacent to (-) charge or to</a>
<a name="ln9751">                    an atom that is not N.</a>
<a name="ln9752">    </a>
<a name="ln9753">    n(orig) &lt; n(revr) or nToBeRemovedByNormFromRevrs &lt; 0 means:</a>
<a name="ln9754">    -----------------------------------------------------------</a>
<a name="ln9755">    - Too few protons were added by the Normalization to the Reconstructed Stucture</a>
<a name="ln9756">      (a) n(orig) &lt; 0 =&gt; protons were not added while they should have been added;</a>
<a name="ln9757">          Solution: move (-) to O by replacing =O with -O(-)</a>
<a name="ln9758">      (b) 0 &lt;= n(orig) &lt; n(revr) =&gt; too many protons were removed</a>
<a name="ln9759"> </a>
<a name="ln9760">   Note: it is critically important to takr into account cumbersome Normalization</a>
<a name="ln9761">     Total Charge: if it is &gt;= 0 then no H(+) may be removed from -OH or by ADP</a>
<a name="ln9762">     However, if N(+) is present then ADP will always try to remove a proton</a>
<a name="ln9763">*********************************************************************************/</a>
<a name="ln9764">int AddRemoveProtonsRestr( inp_ATOM *at, int num_atoms, int *num_protons_to_add,</a>
<a name="ln9765">                           int nNumProtAddedByRestr, INCHI_MODE bNormalizationFlags,</a>
<a name="ln9766">                           int num_tg, int nChargeRevrs, int nChargeInChI )</a>
<a name="ln9767">{</a>
<a name="ln9768">    int i, j, ret = 0;</a>
<a name="ln9769">    int nAtTypeTotals[ATTOT_ARRAY_LEN];</a>
<a name="ln9770">    int   num_prot = *num_protons_to_add;</a>
<a name="ln9771">    int   type, mask, bSuccess, nTotCharge, nNumSuccess = 0;</a>
<a name="ln9772">    int max_j_Aa=-1, max_j_Ar=-1;</a>
<a name="ln9773"> </a>
<a name="ln9774">/* for the reference:</a>
<a name="ln9775"> </a>
<a name="ln9776">#define FLAG_NORM_CONSIDER_TAUT      ( FLAG_PROTON_NPO_SIMPLE_REMOVED | \</a>
<a name="ln9777">                                       FLAG_PROTON_NP_HARD_REMOVED    | \</a>
<a name="ln9778">                                       FLAG_PROTON_AC_SIMPLE_ADDED    | \</a>
<a name="ln9779">                                       FLAG_PROTON_AC_SIMPLE_REMOVED  | \</a>
<a name="ln9780">                                       FLAG_PROTON_AC_HARD_REMOVED    | \</a>
<a name="ln9781">                                       FLAG_PROTON_AC_HARD_ADDED      | \</a>
<a name="ln9782">                                       FLAG_PROTON_SINGLE_REMOVED     | \</a>
<a name="ln9783">                                       FLAG_PROTON_CHARGE_CANCEL    )</a>
<a name="ln9784"> </a>
<a name="ln9785">#define FLAG_FORCE_SALT_TAUT         ( FLAG_PROTON_NP_HARD_REMOVED  | \</a>
<a name="ln9786">                                       FLAG_PROTON_AC_HARD_REMOVED  | \</a>
<a name="ln9787">                                       FLAG_PROTON_AC_HARD_ADDED    )</a>
<a name="ln9788"> </a>
<a name="ln9789">*/</a>
<a name="ln9790">    /* if ChargeRevrs &gt; nChargeInChI then we should prevent proton addition or facilitate proton removal</a>
<a name="ln9791">          a typical case is (=) on N or O instead of C(-)</a>
<a name="ln9792"> </a>
<a name="ln9793">       if ChargeRevrs &lt; nChargeInChI then we should prevent proton removal or facilitate proton addition </a>
<a name="ln9794">    */</a>
<a name="ln9795">    </a>
<a name="ln9796">    mark_at_type( at, num_atoms, nAtTypeTotals );</a>
<a name="ln9797">    for ( i = nTotCharge = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln9798">        nTotCharge += at[i].charge;</a>
<a name="ln9799">    }</a>
<a name="ln9800">    /* size for SimpleAddAcidicProtons() */</a>
<a name="ln9801">    for ( max_j_Aa = 0; AaTypMask[2*max_j_Aa]; max_j_Aa ++ )</a>
<a name="ln9802">        ;</a>
<a name="ln9803">    /* size for SimpleRemoveAcidicProtons */</a>
<a name="ln9804">    for ( max_j_Ar = 0; ArTypMask[2*max_j_Ar]; max_j_Ar ++ )</a>
<a name="ln9805">        ;</a>
<a name="ln9806">    if ( num_prot &lt; 0 &amp;&amp; nAtTypeTotals[ATTOT_TOT_CHARGE]-nNumProtAddedByRestr &lt;= 0 ) {</a>
<a name="ln9807">        /* remove proton(s) */</a>
<a name="ln9808">        /* use test from SimpleAddAcidicProtons() to test whether removal of H(+) from =C-OH, etc. is correct */</a>
<a name="ln9809">        for ( i = 0; i &lt; num_atoms &amp;&amp; num_prot; i ++ ) {</a>
<a name="ln9810">            /* choose an atom */</a>
<a name="ln9811">            if ( at[i].sb_parity[0] || at[i].p_parity || at[i].charge ||</a>
<a name="ln9812">                 !at[i].num_H || at[i].radical || bHasChargedNeighbor( at, i ) ) {</a>
<a name="ln9813">                continue;</a>
<a name="ln9814">            }</a>
<a name="ln9815">            /* try to remove a proton and check whether InChI would add it back */</a>
<a name="ln9816">            at[i].charge --;</a>
<a name="ln9817">            at[i].num_H  --;</a>
<a name="ln9818">            type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 );</a>
<a name="ln9819">            at[i].charge ++;</a>
<a name="ln9820">            at[i].num_H  ++;</a>
<a name="ln9821"> </a>
<a name="ln9822">            if ( type ) {</a>
<a name="ln9823">                for ( bSuccess = 0, j = 0; j &lt; max_j_Aa; j ++ ) {</a>
<a name="ln9824">                    if ( (bSuccess = (type &amp; AaTypMask[2*j])) &amp;&amp; (mask &amp;&amp; AaTypMask[2*j+1]) ) {</a>
<a name="ln9825">                        break; /* the proton may be added to this atom */</a>
<a name="ln9826">                    }</a>
<a name="ln9827">                }</a>
<a name="ln9828">                if ( bSuccess ) {</a>
<a name="ln9829">                    type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln9830">                    at[i].charge --;</a>
<a name="ln9831">                    at[i].num_H  --;</a>
<a name="ln9832">                    type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln9833">                    num_prot ++; /* success */</a>
<a name="ln9834">                    nNumSuccess ++;</a>
<a name="ln9835">                }</a>
<a name="ln9836">            }</a>
<a name="ln9837">        }</a>
<a name="ln9838">    }</a>
<a name="ln9839">    if ( num_prot &lt; 0 &amp;&amp; num_tg &amp;&amp; nAtTypeTotals[ATTOT_TOT_CHARGE]-nNumProtAddedByRestr &lt;= 0 ) {</a>
<a name="ln9840">        /* alternative proton removal: O=C-NH =&gt; (-)O-C=N, O and N are taut. endpoints */</a>
<a name="ln9841">        int endp2, centp, k, i0, k0;</a>
<a name="ln9842">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln9843">            /* choose an atom */</a>
<a name="ln9844">            if ( !at[i].endpoint || at[i].sb_parity[0] || at[i].p_parity ||</a>
<a name="ln9845">                 at[i].radical || at[i].charge || bHasChargedNeighbor( at, i ) ) {</a>
<a name="ln9846">                continue;</a>
<a name="ln9847">            }</a>
<a name="ln9848">            /* looking for tautomeric =O */</a>
<a name="ln9849">            if ( 1 != at[i].valence || BOND_TYPE_DOUBLE != at[i].bond_type[0] || at[i].num_H ||</a>
<a name="ln9850">                 2 != get_endpoint_valence( at[i].el_number ) ) {</a>
<a name="ln9851">                continue;</a>
<a name="ln9852">            }</a>
<a name="ln9853">            centp = at[i].neighbor[0];</a>
<a name="ln9854">            if ( at[centp].sb_parity[0] || at[centp].p_parity || !is_centerpoint_elem( at[centp].el_number ) ) {</a>
<a name="ln9855">                continue;</a>
<a name="ln9856">            }</a>
<a name="ln9857">            /* found a possible centerpoint, looking for -NH endpoint */</a>
<a name="ln9858">            for ( k = 0; k &lt; at[centp].valence; k ++ ) {</a>
<a name="ln9859">                if ( at[centp].bond_type[k] != BOND_TYPE_SINGLE ) {</a>
<a name="ln9860">                    continue;</a>
<a name="ln9861">                }</a>
<a name="ln9862">                endp2 = at[centp].neighbor[k];</a>
<a name="ln9863">                if ( at[endp2].endpoint != at[i].endpoint ||</a>
<a name="ln9864">                     !at[endp2].num_H || at[endp2].charge ||</a>
<a name="ln9865">                     at[endp2].sb_parity[0] || at[endp2].p_parity ||</a>
<a name="ln9866">                     at[endp2].valence != at[endp2].chem_bonds_valence ||</a>
<a name="ln9867">                     3 != at[endp2].chem_bonds_valence + at[endp2].num_H ||</a>
<a name="ln9868">                     3 != get_endpoint_valence( at[endp2].el_number ) ) {</a>
<a name="ln9869">                    continue;</a>
<a name="ln9870">                }</a>
<a name="ln9871">                /* find bonds in reciprocal ajacency lists */</a>
<a name="ln9872">                for ( i0 = 0; i0 &lt; at[centp].valence &amp;&amp; i != at[centp].neighbor[i0]; i0 ++ )</a>
<a name="ln9873">                    ;</a>
<a name="ln9874">                for ( k0 = 0; k0 &lt; at[endp2].valence &amp;&amp; centp != at[endp2].neighbor[k0]; k0 ++ )</a>
<a name="ln9875">                    ;</a>
<a name="ln9876">                if ( i0 == at[centp].valence || k0 == at[endp2].valence ) {</a>
<a name="ln9877">                    return RI_ERR_PROGR;</a>
<a name="ln9878">                }</a>
<a name="ln9879">                /* -NH has been found */</a>
<a name="ln9880">                type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln9881">                type = GetAtomChargeType( at, endp2, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[endp2] */</a>
<a name="ln9882">                </a>
<a name="ln9883">                at[i].bond_type[0] --;</a>
<a name="ln9884">                at[centp].bond_type[i0] --;</a>
<a name="ln9885">                at[i].chem_bonds_valence --;</a>
<a name="ln9886">                at[i].charge --;</a>
<a name="ln9887"> </a>
<a name="ln9888">                at[endp2].bond_type[k0] ++;</a>
<a name="ln9889">                at[centp].bond_type[k] ++;</a>
<a name="ln9890">                at[endp2].chem_bonds_valence ++;</a>
<a name="ln9891">                at[endp2].num_H --;</a>
<a name="ln9892"> </a>
<a name="ln9893">                num_prot ++;</a>
<a name="ln9894">                nNumSuccess ++;</a>
<a name="ln9895">                </a>
<a name="ln9896">                type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 ); /* add at[i] */</a>
<a name="ln9897">                type = GetAtomChargeType( at, endp2, nAtTypeTotals, &amp;mask, 0 ); /* add at[endp2] */</a>
<a name="ln9898">            }</a>
<a name="ln9899">        }</a>
<a name="ln9900">    }</a>
<a name="ln9901">    if ( num_prot &gt; 0 ) {</a>
<a name="ln9902">        /* add protons */</a>
<a name="ln9903">        /* 1. Use test from SimpleRemoveAcidicProtons() to test whether addition of H(+) to =C-O(-), etc. is correct */</a>
<a name="ln9904">        for ( i = 0; i &lt; num_atoms &amp;&amp; num_prot &amp;&amp; nAtTypeTotals[ATTOT_TOT_CHARGE]-nNumProtAddedByRestr &gt;= 0; i ++ ) {</a>
<a name="ln9905">            /* choose an atom */</a>
<a name="ln9906">            if ( at[i].sb_parity[0] || at[i].p_parity || at[i].num_H ||</a>
<a name="ln9907">                 at[i].charge != -1 || at[i].radical || bHasChargedNeighbor( at, i ) ) {</a>
<a name="ln9908">                continue;</a>
<a name="ln9909">            }</a>
<a name="ln9910">            /* try to add a proton and check whether InChI would remove it back */</a>
<a name="ln9911">            at[i].charge ++;</a>
<a name="ln9912">            at[i].num_H ++;</a>
<a name="ln9913">            type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 );</a>
<a name="ln9914">            at[i].charge --;</a>
<a name="ln9915">            at[i].num_H --;</a>
<a name="ln9916">            </a>
<a name="ln9917">            if ( type ) {</a>
<a name="ln9918">                for ( bSuccess = 0, j = 0; j &lt; max_j_Ar; j ++ ) {</a>
<a name="ln9919">                    if ( (bSuccess = (type &amp; ArTypMask[2*j])) &amp;&amp; (mask &amp;&amp; ArTypMask[2*j+1]) ) {</a>
<a name="ln9920">                        break;</a>
<a name="ln9921">                    }</a>
<a name="ln9922">                }</a>
<a name="ln9923">                if ( bSuccess ) {</a>
<a name="ln9924">                    type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln9925">                    at[i].charge ++;</a>
<a name="ln9926">                    at[i].num_H  ++;</a>
<a name="ln9927">                    type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln9928">                    num_prot --; /* success */</a>
<a name="ln9929">                    nNumSuccess ++;</a>
<a name="ln9930">                }</a>
<a name="ln9931">            }</a>
<a name="ln9932">        }</a>
<a name="ln9933">        /* 2. Use test from SimpleRemoveHplusNPO() */</a>
<a name="ln9934">        for ( i = 0; i &lt; num_atoms &amp;&amp; num_prot; i ++ ) {</a>
<a name="ln9935">            /* choose an atom */</a>
<a name="ln9936">            if ( at[i].sb_parity[0] || at[i].p_parity ||</a>
<a name="ln9937">                 at[i].charge || at[i].radical || bHasChargedNeighbor( at, i ) ) {</a>
<a name="ln9938">                continue;</a>
<a name="ln9939">            }</a>
<a name="ln9940">            /* try to add a proton and check whether InChI would remove it back */</a>
<a name="ln9941">            at[i].num_H ++;</a>
<a name="ln9942">            at[i].charge ++;</a>
<a name="ln9943">            bSuccess = (PR_SIMPLE_TYP &amp; (type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 )) ) &amp;&amp;</a>
<a name="ln9944">                       (PR_SIMPLE_MSK &amp; mask );</a>
<a name="ln9945">            at[i].num_H --;  /* failed */</a>
<a name="ln9946">            at[i].charge --;</a>
<a name="ln9947">            if ( bSuccess ) {</a>
<a name="ln9948">                type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln9949">                at[i].num_H ++;</a>
<a name="ln9950">                at[i].charge ++;</a>
<a name="ln9951">                type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln9952">                num_prot --;     /* succeeded */</a>
<a name="ln9953">                nNumSuccess ++;</a>
<a name="ln9954">            }</a>
<a name="ln9955">        }</a>
<a name="ln9956">    }</a>
<a name="ln9957"> </a>
<a name="ln9958">    if ( num_prot &lt; 0 &amp;&amp; (bNormalizationFlags &amp; FLAG_PROTON_AC_HARD_ADDED) &amp;&amp; 1 == num_tg &amp;&amp;</a>
<a name="ln9959">         nAtTypeTotals[ATTOT_TOT_CHARGE]-nNumProtAddedByRestr &lt;= 0 ) {</a>
<a name="ln9960">        /* try to remove protons from tautomeric N (specific ADP must be present) */</a>
<a name="ln9961">        int nNumAcceptors_DB_O=0, nNumDonors_SB_NH=0, num_max, num_success;</a>
<a name="ln9962">        for ( i = 0; i &lt; num_atoms; i ++ ) {</a>
<a name="ln9963">            /* choose an atom */</a>
<a name="ln9964">            if ( !at[i].endpoint || at[i].radical ||</a>
<a name="ln9965">                 at[i].sb_parity[0] || at[i].p_parity || bHasChargedNeighbor( at, i ) ) {</a>
<a name="ln9966">                continue;</a>
<a name="ln9967">            }</a>
<a name="ln9968">            type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 );</a>
<a name="ln9969">            if ( (type &amp; AA_HARD_TYP_CO) &amp;&amp; (mask &amp; AA_HARD_MSK_CO) ) {</a>
<a name="ln9970">                nNumAcceptors_DB_O ++;</a>
<a name="ln9971">            } else</a>
<a name="ln9972">            if ( (type == ATT_ATOM_N ) &amp;&amp; (mask == ATBIT_NP_H) &amp;&amp; !at[i].charge &amp;&amp;</a>
<a name="ln9973">                 at[i].valence == at[i].chem_bonds_valence ) {</a>
<a name="ln9974">                nNumDonors_SB_NH ++;</a>
<a name="ln9975">            }</a>
<a name="ln9976">        }</a>
<a name="ln9977">        num_max = inchi_min( nNumAcceptors_DB_O, nNumDonors_SB_NH );</a>
<a name="ln9978">        for ( i = 0, num_success = 0; i &lt; num_atoms &amp;&amp; num_success &lt; num_max &amp;&amp; num_prot &lt; 0; i ++ ) {</a>
<a name="ln9979">            /* choose an atom */</a>
<a name="ln9980">            if ( !at[i].endpoint|| at[i].radical || at[i].sb_parity[0] ||</a>
<a name="ln9981">                 at[i].p_parity || bHasChargedNeighbor( at, i ) ) {</a>
<a name="ln9982">                continue;</a>
<a name="ln9983">            }</a>
<a name="ln9984">            type = GetAtomChargeType( at, i, NULL, &amp;mask, 0 );</a>
<a name="ln9985">            if ( (type == ATT_ATOM_N ) &amp;&amp; (mask == ATBIT_NP_H) &amp;&amp; !at[i].charge &amp;&amp;</a>
<a name="ln9986">                 at[i].valence == at[i].chem_bonds_valence ) {</a>
<a name="ln9987">                type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 1 ); /* subtract at[i] */</a>
<a name="ln9988">                at[i].num_H --;</a>
<a name="ln9989">                at[i].charge --;</a>
<a name="ln9990">                type = GetAtomChargeType( at, i, nAtTypeTotals, &amp;mask, 0 ); /* add changed at[i] */</a>
<a name="ln9991">                num_prot ++;</a>
<a name="ln9992">                num_success ++;</a>
<a name="ln9993">                nNumSuccess ++;</a>
<a name="ln9994">            }</a>
<a name="ln9995">        }</a>
<a name="ln9996">    }</a>
<a name="ln9997">/*exit_function:*/</a>
<a name="ln9998">    *num_protons_to_add = num_prot;</a>
<a name="ln9999">    return ret&lt;0? ret : nNumSuccess;    </a>
<a name="ln10000">}</a>
<a name="ln10001"> </a>
<a name="ln10002"> </a>
<a name="ln10003"> </a>
<a name="ln10004">/*****************************************************************************/</a>
<a name="ln10005">int AddRemoveIsoProtonsRestr( inp_ATOM *at, int num_atoms, NUM_H num_protons_to_add[], int num_tg )</a>
<a name="ln10006">{</a>
<a name="ln10007">    int i, j, k, n, ret = 0;</a>
<a name="ln10008">    int   nNumSuccess = 0, min_at, max_at, num_H, num_iso_H, num_expl_H, num_expl_iso_H;</a>
<a name="ln10009">    int   iCurIso; /* 0=&gt; 1H, 1=&gt; D, 2=&gt; T */</a>
<a name="ln10010">    int   iCurMode, iCurMode1, iCurMode2; /* 0=&gt; Not Endpoints, 1=&gt; Endpoints */</a>
<a name="ln10011">    static U_CHAR el_number_H = 0;</a>
<a name="ln10012"> </a>
<a name="ln10013">    /* distribute isotopes from  heaviest to lightest; pick up atoms in order 1. Not endpoints; 2. Endpoints */</a>
<a name="ln10014">    iCurMode1 = 0;</a>
<a name="ln10015">    iCurMode2 = num_tg ? 1 : 0;</a>
<a name="ln10016">    if ( !el_number_H ) {</a>
<a name="ln10017">        el_number_H = (U_CHAR) get_periodic_table_number( &quot;H&quot; );</a>
<a name="ln10018">    }</a>
<a name="ln10019">    for ( iCurMode = iCurMode1; iCurMode &lt;= iCurMode2; iCurMode ++ ) {</a>
<a name="ln10020">        for ( iCurIso = 2; 0 &lt;= iCurIso; iCurIso -- ) {</a>
<a name="ln10021">            /* check for isotopic H to add */</a>
<a name="ln10022">            if ( !num_protons_to_add[iCurIso] ) {</a>
<a name="ln10023">                continue;</a>
<a name="ln10024">            }</a>
<a name="ln10025">            if ( 0 &gt; num_protons_to_add[iCurIso] ) {</a>
<a name="ln10026">                ret = RI_ERR_PROGR;</a>
<a name="ln10027">                goto exit_function;</a>
<a name="ln10028">            }</a>
<a name="ln10029">            /* limits for atom scanning */</a>
<a name="ln10030">            min_at = 0;</a>
<a name="ln10031">            max_at = num_atoms;</a>
<a name="ln10032">            /* cycle withio the limits */</a>
<a name="ln10033">            for ( i = min_at; i &lt; max_at &amp;&amp; 0 &lt; num_protons_to_add[iCurIso]; i ++ ) {</a>
<a name="ln10034">                /* pick an atom */</a>
<a name="ln10035">                if ( iCurMode ) {</a>
<a name="ln10036">                    if ( at[i].endpoint )</a>
<a name="ln10037">                        j = i;  /* atom number */</a>
<a name="ln10038">                    else</a>
<a name="ln10039">                        continue;</a>
<a name="ln10040">                } else</a>
<a name="ln10041">                if ( !at[i].endpoint &amp;&amp;</a>
<a name="ln10042">                     1 == bHeteroAtomMayHaveXchgIsoH( at, i ) ) { /* atom number */</a>
<a name="ln10043">                    j = i;</a>
<a name="ln10044">                } else</a>
<a name="ln10045">                if ( at[i].el_number == el_number_H &amp;&amp; at[i].charge == 1 &amp;&amp;</a>
<a name="ln10046">                    !at[i].valence &amp;&amp; !at[i].radical &amp;&amp; !at[i].iso_atw_diff ) {</a>
<a name="ln10047">                    /* proton, not isotopic; make it isotopic */</a>
<a name="ln10048">                    at[i].iso_atw_diff = 1 + iCurIso;</a>
<a name="ln10049">                    num_protons_to_add[iCurIso] --;</a>
<a name="ln10050">                    nNumSuccess ++;</a>
<a name="ln10051">                    continue;</a>
<a name="ln10052">                } else {</a>
<a name="ln10053">                    continue;</a>
<a name="ln10054">                }</a>
<a name="ln10055">                /* j is the atom number */</a>
<a name="ln10056">                /* count implicit H */</a>
<a name="ln10057">                num_H      = at[j].num_H;</a>
<a name="ln10058">                num_iso_H  = NUM_ISO_H(at,j);</a>
<a name="ln10059">                while ( num_H &gt; 0 &amp;&amp; num_protons_to_add[iCurIso] &gt; 0  ) {</a>
<a name="ln10060">                    /* substitute one implicit H with an isotopic atom H */</a>
<a name="ln10061">                    at[j].num_iso_H[iCurIso] ++;</a>
<a name="ln10062">                    at[j].num_H --;</a>
<a name="ln10063">                    num_protons_to_add[iCurIso] --;</a>
<a name="ln10064">                    num_H --;</a>
<a name="ln10065">                    num_iso_H ++;</a>
<a name="ln10066">                    nNumSuccess ++;</a>
<a name="ln10067">                }</a>
<a name="ln10068">                /* count explicit H */</a>
<a name="ln10069">                num_expl_H = num_expl_iso_H = 0;</a>
<a name="ln10070">                for ( k = 0; k &lt; at[j].valence &amp;&amp; num_atoms &lt;= (n=at[j].neighbor[k]); k ++ ) {</a>
<a name="ln10071">                    num_expl_H     += (0 == at[n].iso_atw_diff);</a>
<a name="ln10072">                    num_expl_iso_H += (0 != at[n].iso_atw_diff);</a>
<a name="ln10073">                }</a>
<a name="ln10074">                while ( num_expl_H &gt; 0 &amp;&amp; num_protons_to_add[iCurIso] &gt; 0  ) {</a>
<a name="ln10075">                    /* substitute one explicit H with an isotopic atom H */</a>
<a name="ln10076">                    n = at[j].neighbor[num_expl_H];</a>
<a name="ln10077">                    if ( at[n].iso_atw_diff ) {</a>
<a name="ln10078">                        ret = RI_ERR_PROGR;</a>
<a name="ln10079">                        goto exit_function;</a>
<a name="ln10080">                    }</a>
<a name="ln10081">                    at[n].iso_atw_diff = 1 + iCurIso;</a>
<a name="ln10082">                    num_expl_H --;</a>
<a name="ln10083">                    num_expl_iso_H ++;</a>
<a name="ln10084">                    num_protons_to_add[iCurIso] --;</a>
<a name="ln10085">                    nNumSuccess ++;</a>
<a name="ln10086">                }</a>
<a name="ln10087">            }</a>
<a name="ln10088">        }</a>
<a name="ln10089">    }</a>
<a name="ln10090">exit_function:</a>
<a name="ln10091">    return ret&lt;0? ret : nNumSuccess;    </a>
<a name="ln10092">}</a>
<a name="ln10093"> </a>
<a name="ln10094">#endif</a>

</code></pre>
<div class="balloon" rel="1147"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'v1' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 1147, 1176.</p></div>
<div class="balloon" rel="1189"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="1842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1877"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1902"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="1943"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="2032"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memchr' function will lead to underflow of the buffer 'en + 0'.</p></div>
<div class="balloon" rel="2472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'mask' variable was assigned the same value.</p></div>
<div class="balloon" rel="2540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !at->charge.</p></div>
<div class="balloon" rel="2524"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="2674"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v705/" target="_blank">V705</a> It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics.</p></div>
<div class="balloon" rel="3373"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'type' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 3367, 3373.</p></div>
<div class="balloon" rel="3470"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'type' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 3464, 3470.</p></div>
<div class="balloon" rel="3610"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !ret.</p></div>
<div class="balloon" rel="3636"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="3743"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: cg_Minus_Other >= num_atoms.</p></div>
<div class="balloon" rel="3770"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !ret.</p></div>
<div class="balloon" rel="3796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="3953"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: cg_Plus >= num_atoms.</p></div>
<div class="balloon" rel="3988"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !ret.</p></div>
<div class="balloon" rel="4016"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="4170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ret > 0' is always true.</p></div>
<div class="balloon" rel="4206"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ret > 0' is always true.</p></div>
<div class="balloon" rel="4421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'nAtTypeTotals' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="4713"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: s_group_info.</p></div>
<div class="balloon" rel="4760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'c_group_info' is always true.</p></div>
<div class="balloon" rel="4769"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: s_group_info.</p></div>
<div class="balloon" rel="4772"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: pAATG.</p></div>
<div class="balloon" rel="5905"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't1 != - 2' is always false.</p></div>
<div class="balloon" rel="5915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't2 == - 2' is always true.</p></div>
<div class="balloon" rel="5930"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't2 == - 2' is always true.</p></div>
<div class="balloon" rel="5928"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't1 == - 2' is always true.</p></div>
<div class="balloon" rel="5935"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't2 != - 2' is always false.</p></div>
<div class="balloon" rel="6575"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !ret.</p></div>
<div class="balloon" rel="6922"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'ret_val' should be checked here.</p></div>
<div class="balloon" rel="7168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'edge_flow > 2' is always false.</p></div>
<div class="balloon" rel="7959"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the '& pBNS->vert[i].st_edge' buffer is not a multiple of the element size of the type 'BNS_EDGE'.</p></div>
<div class="balloon" rel="7968"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the '& pBNS->vert[j].st_edge' buffer is not a multiple of the element size of the type 'BNS_EDGE'.</p></div>
<div class="balloon" rel="8026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 8026, 8029</p></div>
<div class="balloon" rel="8047"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 8047, 8050</p></div>
<div class="balloon" rel="8280"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B == C' kind. The expression is calculated as following: 'A = (B == C)'.</p></div>
<div class="balloon" rel="8413"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B == C' kind. The expression is calculated as following: 'A = (B == C)'.</p></div>
<div class="balloon" rel="8415"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B == C' kind. The expression is calculated as following: 'A = (B == C)'.</p></div>
<div class="balloon" rel="9039"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'j' variable is assigned to itself.</p></div>
<div class="balloon" rel="9148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: - 9999 <= (ret).</p></div>
<div class="balloon" rel="9148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (ret) <= (- 9999 + 19).</p></div>
<div class="balloon" rel="9148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="9616"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'pBond->cap' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 9614, 9616.</p></div>
<div class="balloon" rel="9832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'type' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 9829, 9832.</p></div>
<div class="balloon" rel="9927"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'type' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 9924, 9927.</p></div>
<div class="balloon" rel="9951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'type' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 9948, 9951.</p></div>
<div class="balloon" rel="9990"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'type' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 9987, 9990.</p></div>
<div class="balloon" rel="9999"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ret < 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>generic.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">generic.h - Handle generic data classes. Custom data for atoms, bonds, etc.</a>
<a name="ln3"> </a>
<a name="ln4">Copyright (C) 1998-2001 by OpenEye Scientific Software, Inc.</a>
<a name="ln5">Some portions Copyright (C) 2001-2010 by Geoffrey R. Hutchison</a>
<a name="ln6"> </a>
<a name="ln7">This file is part of the Open Babel project.</a>
<a name="ln8">For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln9"> </a>
<a name="ln10">This program is free software; you can redistribute it and/or modify</a>
<a name="ln11">it under the terms of the GNU General Public License as published by</a>
<a name="ln12">the Free Software Foundation version 2 of the License.</a>
<a name="ln13"> </a>
<a name="ln14">This program is distributed in the hope that it will be useful,</a>
<a name="ln15">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln17">GNU General Public License for more details.</a>
<a name="ln18">***********************************************************************/</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef OB_GENERIC_H</a>
<a name="ln21">#define OB_GENERIC_H</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;string&gt;</a>
<a name="ln26">#include &lt;vector&gt;</a>
<a name="ln27">#include &lt;map&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;openbabel/math/spacegroup.h&gt;</a>
<a name="ln30">#include &lt;openbabel/obutil.h&gt;</a>
<a name="ln31">#include &lt;openbabel/base.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">namespace OpenBabel</a>
<a name="ln34">{</a>
<a name="ln35"> </a>
<a name="ln36">  // Forward declarations</a>
<a name="ln37">  class OBBase;</a>
<a name="ln38">  class OBAtom;</a>
<a name="ln39">  class OBBond;</a>
<a name="ln40">  class OBMol;</a>
<a name="ln41">  class OBRing;</a>
<a name="ln42"> </a>
<a name="ln43">  //! \class OBCommentData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln44">  //! \brief Used to store a comment string (can be multiple lines long)</a>
<a name="ln45"> class OBAPI OBCommentData : public OBGenericData</a>
<a name="ln46">  {</a>
<a name="ln47">  protected:</a>
<a name="ln48">    std::string _data;</a>
<a name="ln49">  public:</a>
<a name="ln50">    OBCommentData();</a>
<a name="ln51">    OBCommentData(const OBCommentData&amp;);</a>
<a name="ln52">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return new OBCommentData(*this);}</a>
<a name="ln53"> </a>
<a name="ln54">    OBCommentData&amp; operator=(const OBCommentData &amp;src);</a>
<a name="ln55"> </a>
<a name="ln56">    void          SetData(const std::string &amp;data)</a>
<a name="ln57">    { _data = data; Trim(_data); }</a>
<a name="ln58">    void          SetData(const char *d)</a>
<a name="ln59">    {_data = d; Trim(_data);     }</a>
<a name="ln60">    const std::string &amp;GetData()              const</a>
<a name="ln61">    {        return(_data);      }</a>
<a name="ln62">    virtual const std::string &amp;GetValue()              const</a>
<a name="ln63">    {        return(_data);      }</a>
<a name="ln64">  };</a>
<a name="ln65"> </a>
<a name="ln66">  //! \class OBExternalBond generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln67">  //! \brief Used to store information on an external bond</a>
<a name="ln68">  //! (e.g., SMILES fragments)</a>
<a name="ln69">  class OBAPI OBExternalBond</a>
<a name="ln70">  {</a>
<a name="ln71">    int     _idx;</a>
<a name="ln72">    OBAtom *_atom;</a>
<a name="ln73">    OBBond *_bond;</a>
<a name="ln74">  public:</a>
<a name="ln75">  OBExternalBond(): _idx(0), _atom(nullptr), _bond(nullptr) {}</a>
<a name="ln76">    OBExternalBond(OBAtom *,OBBond *,int);</a>
<a name="ln77">    OBExternalBond(const OBExternalBond &amp;);</a>
<a name="ln78">    ~OBExternalBond()   {}</a>
<a name="ln79"> </a>
<a name="ln80">    int     GetIdx()  const    {        return(_idx);    }</a>
<a name="ln81">    OBAtom *GetAtom() const    {        return(_atom);   }</a>
<a name="ln82">    OBBond *GetBond() const    {        return(_bond);   }</a>
<a name="ln83">    void SetIdx(int idx)       {        _idx = idx;      }</a>
<a name="ln84">    void SetAtom(OBAtom *atom) {        _atom = atom;    }</a>
<a name="ln85">    void SetBond(OBBond *bond) {        _bond = bond;    }</a>
<a name="ln86">  };</a>
<a name="ln87"> </a>
<a name="ln88">  //! \class OBExternalBondData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln89">  //! \brief Used to store information on external bonds (e.g., in SMILES fragments)</a>
<a name="ln90"> class OBAPI OBExternalBondData : public OBGenericData</a>
<a name="ln91">  {</a>
<a name="ln92">  protected:</a>
<a name="ln93">    std::vector&lt;OBExternalBond&gt; _vexbnd;</a>
<a name="ln94">  public:</a>
<a name="ln95">    OBExternalBondData();</a>
<a name="ln96"> </a>
<a name="ln97">    //Copying is not used and too much work to set up</a>
<a name="ln98">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return nullptr;}</a>
<a name="ln99"> </a>
<a name="ln100">    void SetData(OBAtom*,OBBond*,int);</a>
<a name="ln101">    std::vector&lt;OBExternalBond&gt; *GetData()</a>
<a name="ln102">      {</a>
<a name="ln103">        return(&amp;_vexbnd);</a>
<a name="ln104">      }</a>
<a name="ln105">  };</a>
<a name="ln106"> </a>
<a name="ln107">  //! \class OBPairData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln108">  //! \brief Used to store arbitrary text attribute/value relationships.</a>
<a name="ln109">  //!</a>
<a name="ln110">  //! Ideal for arbitrary text descriptors for molecules, atoms, bonds, residues,</a>
<a name="ln111">  //!  e.g. in QSAR.</a>
<a name="ln112"> class OBAPI OBPairData : public OBGenericData</a>
<a name="ln113">  {</a>
<a name="ln114">  protected:</a>
<a name="ln115">    std::string _value; //!&lt; The data for this key/value pair</a>
<a name="ln116">  public:</a>
<a name="ln117">    OBPairData();</a>
<a name="ln118">    virtual OBGenericData* Clone(OBBase* /*parent*/) const</a>
<a name="ln119">      {return new OBPairData(*this);}</a>
<a name="ln120">    void    SetValue(const char *v)        {      _value = v;    }</a>
<a name="ln121">    void    SetValue(const std::string &amp;v) {      _value = v;    }</a>
<a name="ln122">    virtual const std::string &amp;GetValue() const</a>
<a name="ln123">    {      return(_value);    }</a>
<a name="ln124">  };</a>
<a name="ln125"> </a>
<a name="ln126">  //! \class OBPairTemplate generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln127">  //! \brief Used to store arbitrary attribute/value relationsips of any type.</a>
<a name="ln128">  // More detailed description in generic.cpp</a>
<a name="ln129">  template &lt;class ValueT&gt;</a>
<a name="ln130">    class OBPairTemplate : public OBGenericData // Note: no OBAPI should be used</a>
<a name="ln131">  {</a>
<a name="ln132">  protected:</a>
<a name="ln133">    ValueT _value; //!&lt; The data for this key/value pair</a>
<a name="ln134">  public:</a>
<a name="ln135">  OBPairTemplate():</a>
<a name="ln136">    OBGenericData(&quot;PairData&quot;, OBGenericDataType::PairData) {};</a>
<a name="ln137">    virtual OBGenericData* Clone(OBBase* /*parent*/) const</a>
<a name="ln138">      {return new OBPairTemplate&lt;ValueT&gt;(*this);}</a>
<a name="ln139">    void SetValue(const ValueT t)             { _value = t;     }</a>
<a name="ln140">    virtual const ValueT &amp;GetGenericValue() const    { return(_value); }</a>
<a name="ln141">  };</a>
<a name="ln142"> </a>
<a name="ln143">  //! Store arbitrary key/value integer data like OBPairData</a>
<a name="ln144">  typedef OBPairTemplate&lt;int&gt;     OBPairInteger;</a>
<a name="ln145">  //! Store arbitrary key/value floating point data like OBPairData</a>
<a name="ln146">  typedef OBPairTemplate&lt;double&gt;  OBPairFloatingPoint;</a>
<a name="ln147">  //! Store arbitrary key/value boolean data like OBPairData</a>
<a name="ln148">  typedef OBPairTemplate&lt;bool&gt;    OBPairBool;</a>
<a name="ln149"> </a>
<a name="ln150">  //! \class OBSetData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln151">  //! \brief Used to store arbitrary attribute/set relationships.</a>
<a name="ln152">  //! Should be used to store a set of OBGenericData based on an attribute.</a>
<a name="ln153"> class OBAPI OBSetData : public OBGenericData</a>
<a name="ln154">  {</a>
<a name="ln155">  protected:</a>
<a name="ln156">    std::vector&lt;OBGenericData *&gt; _vdata;</a>
<a name="ln157">  public:</a>
<a name="ln158">  OBSetData() : OBGenericData(&quot;SetData&quot;, OBGenericDataType::SetData) {}</a>
<a name="ln159">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return new OBSetData(*this);}</a>
<a name="ln160"> </a>
<a name="ln161">    //! Add an OBGenericData element to the set.</a>
<a name="ln162">    void AddData(OBGenericData *d)</a>
<a name="ln163">    {</a>
<a name="ln164">      if(d)</a>
<a name="ln165">        {</a>
<a name="ln166">          _vdata.push_back(d);</a>
<a name="ln167">        }</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    //! Set the array of data to a new vector</a>
<a name="ln171">    void SetData(std::vector&lt;OBGenericData *&gt; &amp;vdata)</a>
<a name="ln172">    {</a>
<a name="ln173">      _vdata = vdata;</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    //! \return the OBGenericData associate with the attribute name parameter.</a>
<a name="ln177">    OBGenericData *GetData(const char *s)</a>
<a name="ln178">    {</a>
<a name="ln179">      std::vector&lt;OBGenericData*&gt;::iterator i;</a>
<a name="ln180"> </a>
<a name="ln181">      for (i = _vdata.begin();i != _vdata.end();++i)</a>
<a name="ln182">        if ((*i)-&gt;GetAttribute() == s)</a>
<a name="ln183">          return(*i);</a>
<a name="ln184"> </a>
<a name="ln185">      return(nullptr);</a>
<a name="ln186">    }</a>
<a name="ln187"> </a>
<a name="ln188">    //! \return the OBGenericData associate with the attribute name parameter.</a>
<a name="ln189">    OBGenericData *GetData(const std::string &amp;s)</a>
<a name="ln190">    {</a>
<a name="ln191">      std::vector&lt;OBGenericData*&gt;::iterator i;</a>
<a name="ln192"> </a>
<a name="ln193">      for (i = _vdata.begin();i != _vdata.end();++i)</a>
<a name="ln194">        if ((*i)-&gt;GetAttribute() == s)</a>
<a name="ln195">          return(*i);</a>
<a name="ln196"> </a>
<a name="ln197">      return(nullptr);</a>
<a name="ln198">    }</a>
<a name="ln199"> </a>
<a name="ln200">    //! Gets the entire set.</a>
<a name="ln201">    virtual const std::vector&lt;OBGenericData *&gt; &amp;GetData() const //now virtual and const</a>
<a name="ln202">    {</a>
<a name="ln203">      return(_vdata);</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    //! Get the begin iterator.</a>
<a name="ln207">    std::vector&lt;OBGenericData*&gt;::iterator GetBegin()</a>
<a name="ln208">      {</a>
<a name="ln209">        return _vdata.begin();</a>
<a name="ln210">      }</a>
<a name="ln211"> </a>
<a name="ln212">    //! Get the end iterator.</a>
<a name="ln213">    std::vector&lt;OBGenericData*&gt;::iterator GetEnd()</a>
<a name="ln214">      {</a>
<a name="ln215">        return _vdata.end();</a>
<a name="ln216">      }</a>
<a name="ln217"> </a>
<a name="ln218">    //! Delete the matching OBGenericData element.</a>
<a name="ln219">    void DeleteData(OBGenericData *gd)</a>
<a name="ln220">    {</a>
<a name="ln221">      std::vector&lt;OBGenericData*&gt;::iterator i;</a>
<a name="ln222">      for (i = _vdata.begin();i != _vdata.end();++i)</a>
<a name="ln223">        if (*i == gd)</a>
<a name="ln224">          {</a>
<a name="ln225">            delete *i;</a>
<a name="ln226">            _vdata.erase(i);</a>
<a name="ln227">            break; // Done, don't do anything more, since iterator is invalid</a>
<a name="ln228">          }</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">  }; // OBSetData</a>
<a name="ln232"> </a>
<a name="ln233">  //! \class OBVirtualBond generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln234">  //! \brief Used to temporarily store bonds that reference</a>
<a name="ln235">  //! an atom that has not yet been added to a molecule</a>
<a name="ln236"> class OBAPI OBVirtualBond : public OBGenericData</a>
<a name="ln237">  {</a>
<a name="ln238">  protected:</a>
<a name="ln239">    unsigned int _bgn;</a>
<a name="ln240">    unsigned int _end;</a>
<a name="ln241">    unsigned int _ord;</a>
<a name="ln242">    int _stereo;</a>
<a name="ln243">  public:</a>
<a name="ln244">    OBVirtualBond();</a>
<a name="ln245">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return new OBVirtualBond(*this);}</a>
<a name="ln246">    OBVirtualBond(unsigned int, unsigned int, unsigned int,int stereo=0);</a>
<a name="ln247">    unsigned int GetBgn()    {      return(_bgn);    }</a>
<a name="ln248">    unsigned int GetEnd()    {      return(_end);    }</a>
<a name="ln249">    unsigned int GetOrder()  {      return(_ord);    }</a>
<a name="ln250">    int GetStereo() {      return(_stereo); }</a>
<a name="ln251">  };</a>
<a name="ln252"> </a>
<a name="ln253">  //! \class OBRingData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln254">  //! \brief Used to store the SSSR set (filled in by OBMol::GetSSSR())</a>
<a name="ln255"> class OBAPI OBRingData : public OBGenericData</a>
<a name="ln256">  {</a>
<a name="ln257">  protected:</a>
<a name="ln258">    std::vector&lt;OBRing*&gt; _vr;</a>
<a name="ln259">  public:</a>
<a name="ln260">    OBRingData();</a>
<a name="ln261">    OBRingData(const OBRingData &amp;);</a>
<a name="ln262">    // When copying a molecule, don't copy the RingData. Why not? Well,</a>
<a name="ln263">    // if you do, you'll end up with two RingDatas because one will already</a>
<a name="ln264">    // exist due to Kekulize() in EndModify() in operator= in OBMol. Having</a>
<a name="ln265">    // more than one RingData causes problems as one of them can become invalid</a>
<a name="ln266">    // and cause segfaults.</a>
<a name="ln267">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return nullptr;}</a>
<a name="ln268">    ~OBRingData();</a>
<a name="ln269"> </a>
<a name="ln270">    OBRingData &amp;operator=(const OBRingData &amp;);</a>
<a name="ln271"> </a>
<a name="ln272">    void SetData(std::vector&lt;OBRing*&gt; &amp;vr)</a>
<a name="ln273">    {</a>
<a name="ln274">      _vr = vr;</a>
<a name="ln275">    }</a>
<a name="ln276">    void PushBack(OBRing *r)</a>
<a name="ln277">    {</a>
<a name="ln278">      _vr.push_back(r);</a>
<a name="ln279">    }</a>
<a name="ln280">    std::vector&lt;OBRing*&gt; &amp;GetData()</a>
<a name="ln281">      {</a>
<a name="ln282">        return(_vr);</a>
<a name="ln283">      }</a>
<a name="ln284"> </a>
<a name="ln285">    std::vector&lt;OBRing*&gt;::iterator BeginRings()</a>
<a name="ln286">      { return(_vr.begin()); }</a>
<a name="ln287">    std::vector&lt;OBRing*&gt;::iterator EndRings()</a>
<a name="ln288">      { return(_vr.end()); }</a>
<a name="ln289">    OBRing *BeginRing(std::vector&lt;OBRing*&gt;::iterator &amp;i);</a>
<a name="ln290">    OBRing *NextRing(std::vector&lt;OBRing*&gt;::iterator &amp;i);</a>
<a name="ln291">  };</a>
<a name="ln292"> </a>
<a name="ln293">  //! \class OBUnitCell generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln294">  //! \brief Used for storing information about periodic boundary conditions</a>
<a name="ln295">  //!   with conversion to/from translation vectors and</a>
<a name="ln296">  //!  (a, b, c, alpha, beta, gamma)</a>
<a name="ln297"> class OBAPI OBUnitCell: public OBGenericData</a>
<a name="ln298">  {</a>
<a name="ln299">  public:</a>
<a name="ln300">    enum LatticeType { Undefined,</a>
<a name="ln301">                       Triclinic,</a>
<a name="ln302">                       Monoclinic,</a>
<a name="ln303">                       Orthorhombic,</a>
<a name="ln304">                       Tetragonal,</a>
<a name="ln305">                       Rhombohedral /**&lt; also called trigonal*/,</a>
<a name="ln306">                       Hexagonal,</a>
<a name="ln307">                       Cubic};</a>
<a name="ln308"> </a>
<a name="ln309"> </a>
<a name="ln310">  protected:</a>
<a name="ln311">    matrix3x3 _mOrtho;// Orthogonal matrix of column vectors</a>
<a name="ln312">    matrix3x3 _mOrient;// Orientation matrix</a>
<a name="ln313">    vector3 _offset;</a>
<a name="ln314">    std::string _spaceGroupName;</a>
<a name="ln315">    const SpaceGroup* _spaceGroup;</a>
<a name="ln316">    LatticeType _lattice;</a>
<a name="ln317">  public:</a>
<a name="ln318">    //! public constructor</a>
<a name="ln319">    OBUnitCell();</a>
<a name="ln320">    OBUnitCell(const OBUnitCell &amp;);</a>
<a name="ln321">    virtual OBGenericData* Clone(OBBase* /*parent*/) const</a>
<a name="ln322">    {return new OBUnitCell(*this);}</a>
<a name="ln323">    ~OBUnitCell()    {}</a>
<a name="ln324"> </a>
<a name="ln325">    OBUnitCell &amp;operator=(const OBUnitCell &amp;);</a>
<a name="ln326"> </a>
<a name="ln327">    /*!</a>
<a name="ln328">    **\brief Constructs the cell matrix in lower triangular form from the values supplied</a>
<a name="ln329">    **\param a The length a</a>
<a name="ln330">    **\param b The length b</a>
<a name="ln331">    **\param c The length c</a>
<a name="ln332">    **\param alpha The angle alpha</a>
<a name="ln333">    **\param beta The angle beta</a>
<a name="ln334">    **\param gamma The angle gamma</a>
<a name="ln335">    */</a>
<a name="ln336">    void SetData(const double a, const double b, const double c,</a>
<a name="ln337">                 const double alpha, const double beta, const double gamma);</a>
<a name="ln338">    /*!</a>
<a name="ln339">    **\brief Constructs the cell matrix using the supplied row vectors</a>
<a name="ln340">    **\param v1 The x-vector</a>
<a name="ln341">    **\param v2 The y-vector</a>
<a name="ln342">    **\param v3 The z-vector</a>
<a name="ln343">    **\see OBUnitCell::GetCellVectors</a>
<a name="ln344">    */</a>
<a name="ln345">    void SetData(const vector3 v1, const vector3 v2, const vector3 v3);</a>
<a name="ln346"> </a>
<a name="ln347">    /*!</a>
<a name="ln348">    **\brief Sets the unit cell matrix</a>
<a name="ln349">    **\param m The unit cell matrix (row vectors)</a>
<a name="ln350">    **\see OBUnitCell::GetCellMatrix</a>
<a name="ln351">    */</a>
<a name="ln352">    void SetData(const matrix3x3 m);</a>
<a name="ln353"> </a>
<a name="ln354">    //! Set the offset to the origin to @p v1</a>
<a name="ln355">    void SetOffset(const vector3 v1);</a>
<a name="ln356"> </a>
<a name="ln357">    //! Set the space group for this unit cell.</a>
<a name="ln358">    //! Does not create an OBSymmetryData entry</a>
<a name="ln359">    void SetSpaceGroup(const SpaceGroup* sg) { _spaceGroup = sg; }</a>
<a name="ln360"> </a>
<a name="ln361">    //! Set the space group symbol for this unit cell.</a>
<a name="ln362">    //! Does not create an OBSymmetryData entry or attempt to convert</a>
<a name="ln363">    //!  between different symbol notations</a>
<a name="ln364">    void SetSpaceGroup(const std::string sg) { _spaceGroup = SpaceGroup::GetSpaceGroup (sg);</a>
<a name="ln365">                                               _spaceGroupName = sg; }</a>
<a name="ln366"> </a>
<a name="ln367">    //! Set the space group for this unit cell. Each spacegroup-symbol</a>
<a name="ln368">    //! has a numeric equivalent which is easier to use to convert between</a>
<a name="ln369">    //! notations.</a>
<a name="ln370">    //! Does not create an OBSymmetryData entry or attempt to convert</a>
<a name="ln371">    //!  between different symbol notations</a>
<a name="ln372">    void SetSpaceGroup(const int sg) { _spaceGroup = SpaceGroup::GetSpaceGroup (sg); }</a>
<a name="ln373"> </a>
<a name="ln374">    //! Set the Bravais lattice type for this unit cell</a>
<a name="ln375">    void SetLatticeType(const LatticeType lt) { _lattice = lt; }</a>
<a name="ln376"> </a>
<a name="ln377">    //! Duplicate symmetry-unique atoms to fill out the unit cell</a>
<a name="ln378">    //! of the molecule, based on the known space group</a>
<a name="ln379">    void FillUnitCell(OBMol *);</a>
<a name="ln380"> </a>
<a name="ln381">    //! @todo Remove nonconst overloads in OBUnitCell on next version bump</a>
<a name="ln382"> </a>
<a name="ln383">    //! \return vector a</a>
<a name="ln384">    double GetA();</a>
<a name="ln385">    double GetA() const;</a>
<a name="ln386">    //! \return vector b</a>
<a name="ln387">    double GetB();</a>
<a name="ln388">    double GetB() const;</a>
<a name="ln389">    //! \return vector c</a>
<a name="ln390">    double GetC();</a>
<a name="ln391">    double GetC() const;</a>
<a name="ln392">    //! \return angle alpha</a>
<a name="ln393">    double GetAlpha();</a>
<a name="ln394">    double GetAlpha() const;</a>
<a name="ln395">    //! \return angle beta</a>
<a name="ln396">    double GetBeta();</a>
<a name="ln397">    double GetBeta() const;</a>
<a name="ln398">    //! \return angle gamma</a>
<a name="ln399">    double GetGamma();</a>
<a name="ln400">    double GetGamma() const;</a>
<a name="ln401">    //! \return any offset in the origin of the periodic boundaries</a>
<a name="ln402">    vector3 GetOffset();</a>
<a name="ln403">    vector3 GetOffset() const;</a>
<a name="ln404"> </a>
<a name="ln405">    //! \return the text representation of the space group for this unit cell</a>
<a name="ln406">    const SpaceGroup* GetSpaceGroup() { return(_spaceGroup); }</a>
<a name="ln407">    const SpaceGroup* GetSpaceGroup() const { return(_spaceGroup); }</a>
<a name="ln408"> </a>
<a name="ln409">    //! \return the text representation of the space group for this unit cell</a>
<a name="ln410">    const std::string GetSpaceGroupName() { return(_spaceGroupName); }</a>
<a name="ln411">    const std::string GetSpaceGroupName() const { return(_spaceGroupName); }</a>
<a name="ln412"> </a>
<a name="ln413">    //! \return lattice type (based on the @p spacegroup)</a>
<a name="ln414">    LatticeType GetLatticeType( int spacegroup );</a>
<a name="ln415">    LatticeType GetLatticeType( int spacegroup ) const;</a>
<a name="ln416"> </a>
<a name="ln417">    //! \return lattice type (based on angles and distances)</a>
<a name="ln418">    LatticeType GetLatticeType();</a>
<a name="ln419">    LatticeType GetLatticeType() const;</a>
<a name="ln420"> </a>
<a name="ln421">    //! \return v1, v2, v3 cell vectors</a>
<a name="ln422">    std::vector&lt;vector3&gt; GetCellVectors();</a>
<a name="ln423">    std::vector&lt;vector3&gt; GetCellVectors() const;</a>
<a name="ln424">    //! Access to the cell matrix as row vectors, useful for writing input files.</a>
<a name="ln425">    //! Equivalent to the transpose of GetOrientationMatrix() * GetOrthoMatrix()</a>
<a name="ln426">    //! \return The cell matrix with row vectors.</a>
<a name="ln427">    //! \see OBUnitCell::GetOrthoMatrix</a>
<a name="ln428">    //! \see OBUnitCell::GetFractionalMatrix</a>
<a name="ln429">    //! \see OBUnitCell::GetOrientationMatrix</a>
<a name="ln430">    //! \see OBUnitCell::FractionalToCartesian</a>
<a name="ln431">    //! \see OBUnitCell::CartesianToFractional</a>
<a name="ln432">    matrix3x3	GetCellMatrix();</a>
<a name="ln433">    matrix3x3	GetCellMatrix() const;</a>
<a name="ln434">    //! \return The orthogonalization matrix, used for converting from fractional to Cartesian coords.</a>
<a name="ln435">    //! \see OBUnitCell::GetCellMatrix</a>
<a name="ln436">    //! \see OBUnitCell::GetFractionalMatrix</a>
<a name="ln437">    //! \see OBUnitCell::GetOrientationMatrix</a>
<a name="ln438">    //! \see OBUnitCell::FractionalToCartesian</a>
<a name="ln439">    //! \see OBUnitCell::CartesianToFractional</a>
<a name="ln440">    matrix3x3 GetOrthoMatrix();</a>
<a name="ln441">    matrix3x3 GetOrthoMatrix() const;</a>
<a name="ln442">    //! Used to convert fractional and cartesian coordinates if the</a>
<a name="ln443">    //! cell is not oriented in standard form (a parallel to x axis,</a>
<a name="ln444">    //! b in xy plane)</a>
<a name="ln445">    //! \return The orientation matrix</a>
<a name="ln446">    //! \see OBUnitCell::GetOrthoMatrix</a>
<a name="ln447">    //! \see OBUnitCell::GetCellMatrix</a>
<a name="ln448">    //! \see OBUnitCell::GetFractionalMatrix</a>
<a name="ln449">    //! \see OBUnitCell::FractionalToCartesian</a>
<a name="ln450">    //! \see OBUnitCell::CartesianToFractional</a>
<a name="ln451">    matrix3x3 GetOrientationMatrix();</a>
<a name="ln452">    matrix3x3 GetOrientationMatrix() const;</a>
<a name="ln453">    //! \return The fractionalization matrix, used for converting from Cartesian to fractional coords.</a>
<a name="ln454">    //! \see OBUnitCell::GetOrthoMatrix</a>
<a name="ln455">    //! \see OBUnitCell::GetCellMatrix</a>
<a name="ln456">    //! \see OBUnitCell::GetOrientationMatrix</a>
<a name="ln457">    //! \see OBUnitCell::FractionalToCartesian</a>
<a name="ln458">    //! \see OBUnitCell::CartesianToFractional</a>
<a name="ln459">    matrix3x3 GetFractionalMatrix();</a>
<a name="ln460">    matrix3x3 GetFractionalMatrix() const;</a>
<a name="ln461"> </a>
<a name="ln462">    //! Convenience function to convert fractional coordinates to</a>
<a name="ln463">    //! cartesian coordinates. Returns</a>
<a name="ln464">    //!</a>
<a name="ln465">    //! GetOrientationMatrix() * GetOrthoMatrix() * frac + GetOffset()</a>
<a name="ln466">    //! \param frac Vector of fractional coordinates</a>
<a name="ln467">    //! \return Cartesian coordinates</a>
<a name="ln468">    vector3 FractionalToCartesian(vector3 frac);</a>
<a name="ln469">    vector3 FractionalToCartesian(vector3 frac) const;</a>
<a name="ln470">    //! Convenience function to convert cartesian coordinates to</a>
<a name="ln471">    //! fractional coordinates. Returns</a>
<a name="ln472">    //!</a>
<a name="ln473">    //! GetFractionalMatrix() * GetOrientationMatrix().inverse() * (cart - GetOffset())</a>
<a name="ln474">    //! \param cart Vector of cartesian coordinates</a>
<a name="ln475">    //! \return Fractional coordinates</a>
<a name="ln476">    vector3 CartesianToFractional(vector3 cart);</a>
<a name="ln477">    vector3 CartesianToFractional(vector3 cart) const;</a>
<a name="ln478"> </a>
<a name="ln479">    //! Wraps cartesian coordinate to fall within the unit cell.</a>
<a name="ln480">    //! \param cart Vector of cartesian coordinates</a>
<a name="ln481">    //! \return Cartesian coordinates within cell boundaries.</a>
<a name="ln482">    vector3 WrapCartesianCoordinate(vector3 cart);</a>
<a name="ln483">    vector3 WrapCartesianCoordinate(vector3 cart) const;</a>
<a name="ln484">    //! Wraps fractional coordinate to fall within the unit cell.</a>
<a name="ln485">    //! \param frac Vector of fractional coordinates</a>
<a name="ln486">    //! \return Fractional coordinates within cell boundaries (between 0 and 1).</a>
<a name="ln487">    //! \todo Make OBUnitCell::WrapFractionalCoordinate static in the next ABI break</a>
<a name="ln488">    vector3 WrapFractionalCoordinate(vector3 frac);</a>
<a name="ln489">    vector3 WrapFractionalCoordinate(vector3 frac) const;</a>
<a name="ln490">    //! Unwraps Cartesian coordinates near a reference location</a>
<a name="ln491">    //! \param new_loc Cartesian coordinates of target</a>
<a name="ln492">    //! \param ref_loc Cartesian coordinates of the reference location</a>
<a name="ln493">    //! \return Unwrapped coordinates of new_loc near ref_loc</a>
<a name="ln494">    vector3 UnwrapCartesianNear(vector3 new_loc, vector3 ref_loc);</a>
<a name="ln495">    vector3 UnwrapCartesianNear(vector3 new_loc, vector3 ref_loc) const;</a>
<a name="ln496">    //! Unwraps fractional coordinates near a reference location.</a>
<a name="ln497">    //! \param new_loc Fractional coordinates of target</a>
<a name="ln498">    //! \param ref_loc Fractional coordinates of the reference location</a>
<a name="ln499">    //! \return Unwrapped coordinates of new_loc near ref_loc</a>
<a name="ln500">    //! \todo Add a simple test case/example, like unwrapNear(&lt;0.9, 0.2, 0.2&gt;, &lt;0.3, 0.9, 0.2&gt;) -&gt; &lt;-0.1, 1.2, 0.2&gt;</a>
<a name="ln501">    vector3 UnwrapFractionalNear(vector3 new_loc, vector3 ref_loc);</a>
<a name="ln502">    vector3 UnwrapFractionalNear(vector3 new_loc, vector3 ref_loc) const;</a>
<a name="ln503">    //! Applies the minimum image convention to a Cartesian displacement vector</a>
<a name="ln504">    //! \param cart Displacement vector between two atoms in Cartesian coordinates</a>
<a name="ln505">    //! \return Cartesian difference, wrapped within half the unit cell</a>
<a name="ln506">    vector3 MinimumImageCartesian(vector3 cart);</a>
<a name="ln507">    vector3 MinimumImageCartesian(vector3 cart) const;</a>
<a name="ln508">    //! Applies the minimum image convention to a fractional displacement vector</a>
<a name="ln509">    //! \param cart Displacement vector between two atoms in fractional coordinates</a>
<a name="ln510">    //! \return Fractional difference, wrapped within half the unit cell (-0.5 to 0.5)</a>
<a name="ln511">    vector3 MinimumImageFractional(vector3 frac);</a>
<a name="ln512">    vector3 MinimumImageFractional(vector3 frac) const;</a>
<a name="ln513"> </a>
<a name="ln514">    //! \return The numeric value of the given spacegroup</a>
<a name="ln515">    int GetSpaceGroupNumber( std::string name = &quot;&quot; );</a>
<a name="ln516">    int GetSpaceGroupNumber( std::string name = &quot;&quot; ) const;</a>
<a name="ln517">    //! \return The cell volume (in Angstroms^3)</a>
<a name="ln518">    double GetCellVolume();</a>
<a name="ln519">    double GetCellVolume() const;</a>
<a name="ln520">  };</a>
<a name="ln521"> </a>
<a name="ln522">  //! \class OBConformerData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln523">  //! \brief Used to hold data on conformers or geometry optimization steps</a>
<a name="ln524">  //!</a>
<a name="ln525">  //! Supplements the support for multiple coordinate sets in OBMol, e.g.,</a>
<a name="ln526">  //! OBMol::GetConformer()</a>
<a name="ln527"> class OBAPI OBConformerData: public OBGenericData</a>
<a name="ln528">  {</a>
<a name="ln529">  protected:</a>
<a name="ln530">    //! Dimensionalities of conformers</a>
<a name="ln531">    std::vector&lt;unsigned short&gt;              _vDimension;</a>
<a name="ln532">    //! Relative energies of conformers (preferably in kJ/mol)</a>
<a name="ln533">    std::vector&lt;double&gt;                      _vEnergies;</a>
<a name="ln534">    //! Atomic forces for each conformer</a>
<a name="ln535">    std::vector&lt; std::vector&lt; vector3 &gt; &gt;    _vForces;</a>
<a name="ln536">    //! Atomic velocities for each conformer (e.g., trajectories)</a>
<a name="ln537">    std::vector&lt; std::vector&lt; vector3 &gt; &gt;    _vVelocity;</a>
<a name="ln538">    //! Atomic displacements for each conformer (e.g., RMS distances)</a>
<a name="ln539">    std::vector&lt; std::vector&lt; vector3 &gt; &gt;    _vDisplace;</a>
<a name="ln540">    //! Additional data (as strings)</a>
<a name="ln541">    std::vector&lt;std::string&gt;                 _vData;</a>
<a name="ln542"> </a>
<a name="ln543">  public:</a>
<a name="ln544">    OBConformerData();</a>
<a name="ln545">    OBConformerData(const OBConformerData &amp;);</a>
<a name="ln546">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return new OBConformerData(*this);}</a>
<a name="ln547">    ~OBConformerData()    {}</a>
<a name="ln548"> </a>
<a name="ln549">    OBConformerData &amp;operator=(const OBConformerData &amp;);</a>
<a name="ln550"> </a>
<a name="ln551">    void SetDimension(std::vector&lt;unsigned short&gt; vd) { _vDimension = vd; }</a>
<a name="ln552">    void SetEnergies(std::vector&lt;double&gt; ve) { _vEnergies = ve; }</a>
<a name="ln553">    void SetForces(std::vector&lt; std::vector&lt; vector3 &gt; &gt; vf) {_vForces = vf;}</a>
<a name="ln554">    void SetVelocities(std::vector&lt; std::vector&lt; vector3 &gt; &gt; vv)</a>
<a name="ln555">    { _vVelocity = vv; }</a>
<a name="ln556">    void SetDisplacements(std::vector&lt; std::vector&lt; vector3 &gt; &gt; vd)</a>
<a name="ln557">    { _vDisplace = vd; }</a>
<a name="ln558">    void SetData(std::vector&lt;std::string&gt; vdat) { _vData = vdat; }</a>
<a name="ln559"> </a>
<a name="ln560">    std::vector&lt;unsigned short&gt; GetDimension() { return _vDimension; }</a>
<a name="ln561">    std::vector&lt;double&gt;         GetEnergies()  { return _vEnergies; }</a>
<a name="ln562">    std::vector&lt; std::vector&lt; vector3 &gt; &gt; GetForces() {return _vForces; }</a>
<a name="ln563">    std::vector&lt; std::vector&lt; vector3 &gt; &gt; GetVelocities()</a>
<a name="ln564">      {return _vVelocity;}</a>
<a name="ln565">    std::vector&lt; std::vector&lt; vector3 &gt; &gt; GetDisplacements()</a>
<a name="ln566">      {return _vDisplace;}</a>
<a name="ln567">    std::vector&lt;std::string&gt;    GetData() { return _vData; }</a>
<a name="ln568"> </a>
<a name="ln569">  };</a>
<a name="ln570"> </a>
<a name="ln571">  //! \class OBSymmetryData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln572">  //! \brief Used to hold the point-group and/or space-group symmetry</a>
<a name="ln573">  //! \todo Add support for translation between symbol notations.</a>
<a name="ln574">  //!        Add symmetry perception routines.</a>
<a name="ln575"> class OBAPI OBSymmetryData: public OBGenericData</a>
<a name="ln576">  {</a>
<a name="ln577">  protected:</a>
<a name="ln578">    std::string _spaceGroup;</a>
<a name="ln579">    std::string _pointGroup;</a>
<a name="ln580">  public:</a>
<a name="ln581">    OBSymmetryData();</a>
<a name="ln582">    OBSymmetryData(const OBSymmetryData &amp;);</a>
<a name="ln583">    virtual OBGenericData* Clone(OBBase* /*parent*/) const{return new OBSymmetryData(*this);}</a>
<a name="ln584">    ~OBSymmetryData()    {}</a>
<a name="ln585"> </a>
<a name="ln586">    OBSymmetryData &amp;operator=(const OBSymmetryData &amp;);</a>
<a name="ln587"> </a>
<a name="ln588">    void SetData(std::string pg, std::string sg = &quot;&quot;)</a>
<a name="ln589">    { _pointGroup = pg; _spaceGroup = sg; }</a>
<a name="ln590">    void SetPointGroup(std::string pg) { _pointGroup = pg; }</a>
<a name="ln591">    void SetSpaceGroup(std::string sg) { _spaceGroup = sg; }</a>
<a name="ln592"> </a>
<a name="ln593">    std::string GetPointGroup() { return _pointGroup; }</a>
<a name="ln594">    std::string GetSpaceGroup() { return _spaceGroup; }</a>
<a name="ln595">  };</a>
<a name="ln596"> </a>
<a name="ln597">  //! \class OBTorsion generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln598">  //! \brief Used to hold the torsion data for a single rotatable bond</a>
<a name="ln599">  //! and all four atoms around it</a>
<a name="ln600">  class OBAPI OBTorsion</a>
<a name="ln601">  {</a>
<a name="ln602">    friend class OBMol;</a>
<a name="ln603">    friend class OBTorsionData;</a>
<a name="ln604"> </a>
<a name="ln605">  protected:</a>
<a name="ln606">    std::pair&lt;OBAtom*,OBAtom*&gt; _bc;</a>
<a name="ln607">    //! double is angle in radians</a>
<a name="ln608">    std::vector&lt;triple&lt;OBAtom*,OBAtom*,double&gt; &gt; _ads;</a>
<a name="ln609"> </a>
<a name="ln610">    OBTorsion(): _bc((OBAtom *)nullptr, (OBAtom *)nullptr)      {      }</a>
<a name="ln611">    //protected for use only by friend classes</a>
<a name="ln612">    OBTorsion(OBAtom *, OBAtom *, OBAtom *, OBAtom *);</a>
<a name="ln613"> </a>
<a name="ln614">    std::vector&lt;quad&lt;OBAtom*,OBAtom*,OBAtom*,OBAtom*&gt; &gt; GetTorsions();</a>
<a name="ln615"> </a>
<a name="ln616">  public:</a>
<a name="ln617">    OBTorsion(const OBTorsion &amp;);</a>
<a name="ln618">    ~OBTorsion()      {}</a>
<a name="ln619"> </a>
<a name="ln620">    OBTorsion&amp; operator=(const OBTorsion &amp;);</a>
<a name="ln621"> </a>
<a name="ln622">    void Clear();</a>
<a name="ln623">    bool Empty()    {      return(_bc.first == 0 &amp;&amp; _bc.second == 0);    }</a>
<a name="ln624"> </a>
<a name="ln625">    bool AddTorsion(OBAtom *a,OBAtom *b, OBAtom *c,OBAtom *d);</a>
<a name="ln626">    bool AddTorsion(quad&lt;OBAtom*,OBAtom*,OBAtom*,OBAtom*&gt; &amp;atoms);</a>
<a name="ln627"> </a>
<a name="ln628">    bool SetAngle(double radians, unsigned int index = 0);</a>
<a name="ln629">    bool SetData(OBBond * /*bond*/) { return false; }</a>
<a name="ln630"> </a>
<a name="ln631">    bool GetAngle(double &amp;radians, unsigned int index =0);</a>
<a name="ln632">    //! Gets the bond index of the central bond</a>
<a name="ln633">    //! \return int bond index</a>
<a name="ln634">    unsigned int GetBondIdx();</a>
<a name="ln635">    size_t GetSize() const    {      return _ads.size();    }</a>
<a name="ln636"> </a>
<a name="ln637">    //! Gets the two central atoms of ABCD torsion</a>
<a name="ln638">    //!   \return pair&lt;OBAtom*,OBAtom*&gt;</a>
<a name="ln639">    std::pair&lt;OBAtom*,OBAtom*&gt;                  GetBC()</a>
<a name="ln640">      {</a>
<a name="ln641">        return(_bc);</a>
<a name="ln642">      }</a>
<a name="ln643">    //! Gets the vector of distal atoms of ABCD torsion</a>
<a name="ln644">    //! \return vector of A,D atom pointers and a double</a>
<a name="ln645">    std::vector&lt;triple&lt;OBAtom*,OBAtom*,double&gt; &gt; GetADs()</a>
<a name="ln646">    {</a>
<a name="ln647">      return(_ads) ;</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">    bool IsProtonRotor();</a>
<a name="ln651">  };</a>
<a name="ln652"> </a>
<a name="ln653">  //! \class OBTorsionData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln654">  //! \brief Used to hold torsions as generic data for OBMol.</a>
<a name="ln655">  //!</a>
<a name="ln656">  //! Filled by OBMol::FindTorsions()</a>
<a name="ln657"> class OBAPI OBTorsionData : public OBGenericData</a>
<a name="ln658">  {</a>
<a name="ln659">    friend class OBMol;</a>
<a name="ln660"> </a>
<a name="ln661">  protected:</a>
<a name="ln662">    std::vector&lt;OBTorsion&gt; _torsions;</a>
<a name="ln663"> </a>
<a name="ln664">    OBTorsionData();</a>
<a name="ln665">    OBTorsionData(const OBTorsionData &amp;);</a>
<a name="ln666"> </a>
<a name="ln667">  public:</a>
<a name="ln668">    OBTorsionData &amp;operator=(const OBTorsionData &amp;);</a>
<a name="ln669"> </a>
<a name="ln670">    //! \todo Needs to be updated to rebase atom pointers (or use indexes)</a>
<a name="ln671">    virtual OBGenericData* Clone(OBBase* /*parent*/) const</a>
<a name="ln672">    {return new OBTorsionData(*this);}</a>
<a name="ln673"> </a>
<a name="ln674">    void Clear();</a>
<a name="ln675"> </a>
<a name="ln676">    //! Gets a vector of the OBTorsion objects</a>
<a name="ln677">    //! \return the vector of torsions</a>
<a name="ln678">    std::vector&lt;OBTorsion&gt; GetData() const</a>
<a name="ln679">      {</a>
<a name="ln680">        return _torsions;</a>
<a name="ln681">      }</a>
<a name="ln682"> </a>
<a name="ln683">    //! Gets the number of torsion structs</a>
<a name="ln684">    //! \return integer count of the number of torsions</a>
<a name="ln685">    size_t      GetSize() const</a>
<a name="ln686">    {</a>
<a name="ln687">      return _torsions.size();</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">    void SetData(OBTorsion &amp;torsion);</a>
<a name="ln691"> </a>
<a name="ln692">    bool FillTorsionArray(std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &amp;torsions);</a>
<a name="ln693">  };</a>
<a name="ln694"> </a>
<a name="ln695">  //! \class OBAngle generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln696">  //! \brief Used to hold the 3 atoms in an angle and the angle itself</a>
<a name="ln697">  class OBAPI OBAngle</a>
<a name="ln698">  {</a>
<a name="ln699">    friend class OBMol;</a>
<a name="ln700">    friend class OBAngleData;</a>
<a name="ln701"> </a>
<a name="ln702">  protected:</a>
<a name="ln703"> </a>
<a name="ln704">    //member data</a>
<a name="ln705"> </a>
<a name="ln706">    OBAtom                *_vertex;</a>
<a name="ln707">    std::pair&lt;OBAtom*,OBAtom*&gt;  _termini;</a>
<a name="ln708">    double                  _radians;</a>
<a name="ln709"> </a>
<a name="ln710">    //protected member functions</a>
<a name="ln711"> </a>
<a name="ln712">    OBAngle();	//protect constructor for use only by friend classes</a>
<a name="ln713">    OBAngle(OBAtom *vertex,OBAtom *a,OBAtom *b);</a>
<a name="ln714"> </a>
<a name="ln715">    triple&lt;OBAtom*,OBAtom*,OBAtom*&gt; GetAtoms();</a>
<a name="ln716">    void SortByIndex();</a>
<a name="ln717"> </a>
<a name="ln718">  public:</a>
<a name="ln719"> </a>
<a name="ln720">    OBAngle(const OBAngle &amp;);</a>
<a name="ln721">    ~OBAngle()</a>
<a name="ln722">      {</a>
<a name="ln723">        _vertex = nullptr;</a>
<a name="ln724">      }</a>
<a name="ln725"> </a>
<a name="ln726">    OBAngle &amp;operator = (const OBAngle &amp;);</a>
<a name="ln727">    bool     operator ==(const OBAngle &amp;);</a>
<a name="ln728"> </a>
<a name="ln729">    void  Clear();</a>
<a name="ln730"> </a>
<a name="ln731">    //! Gets the OBAngle angle value</a>
<a name="ln732">    //! \return angle in radians</a>
<a name="ln733">    double GetAngle() const</a>
<a name="ln734">    {</a>
<a name="ln735">      return(_radians);</a>
<a name="ln736">    }</a>
<a name="ln737">    //! Sets the OBAngle to @p radians</a>
<a name="ln738">    //! \param angle in radians</a>
<a name="ln739">    void  SetAngle(double angle)</a>
<a name="ln740">    {</a>
<a name="ln741">      _radians = angle;</a>
<a name="ln742">    }</a>
<a name="ln743">    void  SetAtoms(OBAtom *vertex,OBAtom *a,OBAtom *b);</a>
<a name="ln744">    void  SetAtoms(triple&lt;OBAtom*,OBAtom*,OBAtom*&gt; &amp;atoms);</a>
<a name="ln745"> </a>
<a name="ln746">  };</a>
<a name="ln747"> </a>
<a name="ln748">  //! \class OBAngleData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln749">  //! \brief Used to hold all angles in a molecule as generic data for OBMol</a>
<a name="ln750"> class OBAPI OBAngleData : public OBGenericData</a>
<a name="ln751">  {</a>
<a name="ln752">    friend class OBMol;</a>
<a name="ln753"> </a>
<a name="ln754">  protected:</a>
<a name="ln755">    std::vector&lt;OBAngle&gt; _angles;</a>
<a name="ln756"> </a>
<a name="ln757">    OBAngleData();</a>
<a name="ln758">    OBAngleData(const OBAngleData &amp;);</a>
<a name="ln759">    //! Gets the angle vector data</a>
<a name="ln760">    /** \return a vector&lt;OBAngle&gt; **/</a>
<a name="ln761">    std::vector&lt;OBAngle&gt; GetData() const</a>
<a name="ln762">      {</a>
<a name="ln763">        return(_angles);</a>
<a name="ln764">      }</a>
<a name="ln765"> </a>
<a name="ln766">  public:</a>
<a name="ln767">    OBAngleData &amp;operator =(const OBAngleData &amp;);</a>
<a name="ln768">    virtual OBGenericData* Clone(OBBase* /*parent*/) const</a>
<a name="ln769">    {return new OBAngleData(*this);}</a>
<a name="ln770"> </a>
<a name="ln771">    void Clear();</a>
<a name="ln772">    unsigned int FillAngleArray(int **angles, unsigned int &amp;size);</a>
<a name="ln773">    bool FillAngleArray(std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &amp;angles);</a>
<a name="ln774"> </a>
<a name="ln775">    void         SetData(OBAngle &amp;);</a>
<a name="ln776">    //! Gets the number of angles stored</a>
<a name="ln777">    //! \return integer count of the number of angles</a>
<a name="ln778">    size_t GetSize() const</a>
<a name="ln779">    {</a>
<a name="ln780">      return _angles.size();</a>
<a name="ln781">    }</a>
<a name="ln782">  };</a>
<a name="ln783"> </a>
<a name="ln784"> </a>
<a name="ln785">  //! \class OBSerialNums generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln786">  //! \brief Defines a map between serial numbers (e.g., in a PDB file) and OBAtom objects inside a molecule</a>
<a name="ln787"> class OBSerialNums : public OBGenericData</a>
<a name="ln788">  {</a>
<a name="ln789">  protected:</a>
<a name="ln790">    std::map&lt;int, OBAtom*&gt; _serialMap; //!&lt; map between serial num</a>
<a name="ln791"> </a>
<a name="ln792">  public:</a>
<a name="ln793"> </a>
<a name="ln794">  OBSerialNums() :</a>
<a name="ln795">    OBGenericData(&quot;obSerialNums&quot;, OBGenericDataType::SerialNums)</a>
<a name="ln796">      {}</a>
<a name="ln797"> </a>
<a name="ln798">  OBSerialNums(const OBSerialNums &amp;cp) : OBGenericData(cp)</a>
<a name="ln799">    {</a>
<a name="ln800">      _serialMap = cp._serialMap;</a>
<a name="ln801">    }</a>
<a name="ln802">    //! Member variables contain OBAtom pointers, so copying only valid within</a>
<a name="ln803">    //! same molecule, unless the code is modified, as in OBRotamerList</a>
<a name="ln804">    virtual OBGenericData* Clone(OBBase* /*parent*/) const</a>
<a name="ln805">    {return new OBSerialNums(*this);}</a>
<a name="ln806"> </a>
<a name="ln807">    std::map&lt;int,OBAtom*&gt; &amp;GetData()    { return _serialMap;    }</a>
<a name="ln808">    void SetData(std::map&lt;int,OBAtom*&gt; &amp;sm) { _serialMap = sm;  }</a>
<a name="ln809"> </a>
<a name="ln810">  };</a>
<a name="ln811"> </a>
<a name="ln812">  //! \class OBVibrationData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln813">  //! \brief Used to hold the normal modes of a molecule, etc.</a>
<a name="ln814"> class OBAPI OBVibrationData: public OBGenericData</a>
<a name="ln815">  {</a>
<a name="ln816">  protected:</a>
<a name="ln817">    //! Normal modes in 1/sqrt(a.u.)</a>
<a name="ln818">    std::vector&lt; std::vector&lt; vector3 &gt; &gt; _vLx;</a>
<a name="ln819"> </a>
<a name="ln820">    //! Harmonic frequencies in inverse centimeters</a>
<a name="ln821">    std::vector&lt;double&gt;  _vFrequencies;</a>
<a name="ln822"> </a>
<a name="ln823">    //! Infrared absorption intensities in KM/Mole</a>
<a name="ln824">    std::vector&lt;double&gt;  _vIntensities;</a>
<a name="ln825"> </a>
<a name="ln826">    //! Raman activities</a>
<a name="ln827">    std::vector&lt;double&gt;  _vRamanActivities;</a>
<a name="ln828"> </a>
<a name="ln829">  public:</a>
<a name="ln830">    OBVibrationData(): OBGenericData(&quot;VibrationData&quot;, OBGenericDataType::VibrationData){};</a>
<a name="ln831">    virtual ~OBVibrationData() {}</a>
<a name="ln832">    virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln833">         {return new OBVibrationData(*this);}</a>
<a name="ln834"> </a>
<a name="ln835">    OBVibrationData &amp; operator=(const OBVibrationData &amp;);</a>
<a name="ln836"> </a>
<a name="ln837">    void SetData(const std::vector&lt; std::vector&lt; vector3 &gt; &gt; &amp; lx,</a>
<a name="ln838">                 const std::vector&lt;double&gt; &amp; frequencies,</a>
<a name="ln839">                 const std::vector&lt;double&gt; &amp; intensities);</a>
<a name="ln840">    void SetData(const std::vector&lt; std::vector&lt; vector3 &gt; &gt; &amp;,</a>
<a name="ln841">                 const std::vector&lt;double&gt; &amp;,</a>
<a name="ln842">                 const std::vector&lt;double&gt; &amp;,</a>
<a name="ln843">                 const std::vector&lt;double&gt; &amp;);</a>
<a name="ln844"> </a>
<a name="ln845">    std::vector&lt; std::vector&lt; vector3 &gt; &gt; GetLx() const</a>
<a name="ln846">      { return this-&gt;_vLx; }</a>
<a name="ln847">    std::vector&lt;double&gt; GetFrequencies() const</a>
<a name="ln848">      { return this-&gt;_vFrequencies; }</a>
<a name="ln849">    std::vector&lt;double&gt; GetIntensities() const</a>
<a name="ln850">      { return this-&gt;_vIntensities; }</a>
<a name="ln851">    std::vector&lt;double&gt; GetRamanActivities() const</a>
<a name="ln852">      { return this-&gt;_vRamanActivities; }</a>
<a name="ln853"> </a>
<a name="ln854">    unsigned int GetNumberOfFrequencies() const;</a>
<a name="ln855">};</a>
<a name="ln856"> </a>
<a name="ln857">  //! \class OBDOSData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln858">  //! \brief Used to hold density of states information</a>
<a name="ln859"> class OBAPI OBDOSData: public OBGenericData</a>
<a name="ln860">  {</a>
<a name="ln861">  protected:</a>
<a name="ln862">    //! Fermi energy (eV) as shown in _vEnergies</a>
<a name="ln863">    double _fermi;</a>
<a name="ln864"> </a>
<a name="ln865">    //! Energy levels (eV)</a>
<a name="ln866">    std::vector&lt;double&gt;  _vEnergies;</a>
<a name="ln867"> </a>
<a name="ln868">    //! Density of corresponding energy level (number of states / unit cell)</a>
<a name="ln869">    std::vector&lt;double&gt;  _vDensities;</a>
<a name="ln870"> </a>
<a name="ln871">    //! Integrated DOS vector</a>
<a name="ln872">    std::vector&lt;double&gt;  _vIntegration;</a>
<a name="ln873"> </a>
<a name="ln874">  public:</a>
<a name="ln875">    OBDOSData(): OBGenericData(&quot;DOSData&quot;, OBGenericDataType::DOSData){};</a>
<a name="ln876">    virtual ~OBDOSData() {}</a>
<a name="ln877">    virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln878">         {return new OBDOSData(*this);}</a>
<a name="ln879"> </a>
<a name="ln880">    OBDOSData &amp; operator=(const OBDOSData &amp;);</a>
<a name="ln881"> </a>
<a name="ln882">    void SetData(double,</a>
<a name="ln883">                 const std::vector&lt;double&gt; &amp;,</a>
<a name="ln884">                 const std::vector&lt;double&gt; &amp;,</a>
<a name="ln885">                 const std::vector&lt;double&gt; &amp;);</a>
<a name="ln886"> </a>
<a name="ln887">    double GetFermiEnergy() const</a>
<a name="ln888">      { return this-&gt;_fermi; }</a>
<a name="ln889">    std::vector&lt;double&gt; GetEnergies() const</a>
<a name="ln890">      { return this-&gt;_vEnergies; }</a>
<a name="ln891">    std::vector&lt;double&gt; GetDensities() const</a>
<a name="ln892">      { return this-&gt;_vDensities; }</a>
<a name="ln893">    std::vector&lt;double&gt; GetIntegration() const</a>
<a name="ln894">      { return this-&gt;_vIntegration; }</a>
<a name="ln895">  };</a>
<a name="ln896"> </a>
<a name="ln897">  //! \class OBOrbital generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln898">  //! \brief Used to store energy, occupation, and orbital symmetry of a particular orbital</a>
<a name="ln899">  //! \sa OBOrbitalData</a>
<a name="ln900">  class OBAPI OBOrbital</a>
<a name="ln901">  {</a>
<a name="ln902">    friend class OBOrbitalData;</a>
<a name="ln903">  protected:</a>
<a name="ln904">    double       _energy;         //!&lt; in electron volts</a>
<a name="ln905">    double       _occupation;     //!&lt; usually 0, 1, or 2, but can be fractional (e.g., solid-state calcs)</a>
<a name="ln906">    std::string  _mullikenSymbol; //!&lt; symmetry designation</a>
<a name="ln907">  public:</a>
<a name="ln908">    void SetData(double energy, double occupation = 2.0, std::string symbol = &quot;A&quot;)</a>
<a name="ln909">    { _energy = energy; _occupation = occupation; _mullikenSymbol = symbol; }</a>
<a name="ln910"> </a>
<a name="ln911">    double GetEnergy() const        { return _energy; }</a>
<a name="ln912">    double GetOccupation() const    { return _occupation; }</a>
<a name="ln913">    std::string GetSymbol() const   { return _mullikenSymbol; }</a>
<a name="ln914">  };</a>
<a name="ln915"> </a>
<a name="ln916">  //! \class OBOrbitalData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln917">  //! \brief Used to hold information about orbital energies</a>
<a name="ln918">  class OBAPI OBOrbitalData: public OBGenericData</a>
<a name="ln919">  {</a>
<a name="ln920">  public:</a>
<a name="ln921">    OBOrbitalData(): OBGenericData(&quot;OrbitalData&quot;, OBGenericDataType::ElectronicData),</a>
<a name="ln922">      _alphaHOMO(0), _betaHOMO(0), _openShell(false) {};</a>
<a name="ln923">    virtual ~OBOrbitalData() {}</a>
<a name="ln924">    virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln925">         {return new OBOrbitalData(*this);}</a>
<a name="ln926"> </a>
<a name="ln927">    OBOrbitalData &amp; operator=(const OBOrbitalData &amp;);</a>
<a name="ln928"> </a>
<a name="ln929">    void SetAlphaOrbitals(std::vector&lt;OBOrbital&gt; orbitalList)</a>
<a name="ln930">    { _alphaOrbitals = orbitalList; }</a>
<a name="ln931">    void SetBetaOrbitals(std::vector&lt;OBOrbital&gt; orbitalList)</a>
<a name="ln932">    { _betaOrbitals = orbitalList; }</a>
<a name="ln933">    void SetHOMO(int alpha, int beta = 0)</a>
<a name="ln934">    { _alphaHOMO = alpha; _betaHOMO = beta; }</a>
<a name="ln935">    void SetOpenShell(bool openShell)</a>
<a name="ln936">    { _openShell = openShell; }</a>
<a name="ln937"> </a>
<a name="ln938">    bool IsOpenShell() { return _openShell; }</a>
<a name="ln939"> </a>
<a name="ln940">    unsigned int GetAlphaHOMO() { return _alphaHOMO; }</a>
<a name="ln941">    unsigned int GetBetaHOMO() { return _betaHOMO; }</a>
<a name="ln942">    std::vector&lt;OBOrbital&gt; GetAlphaOrbitals() { return _alphaOrbitals; }</a>
<a name="ln943">    std::vector&lt;OBOrbital&gt; GetBetaOrbitals() { return _betaOrbitals; }</a>
<a name="ln944"> </a>
<a name="ln945">    //! \brief Convenience function for common cases of closed-shell calculations -- pass the energies and symmetries</a>
<a name="ln946">    //! This method will fill the OBOrbital objects for you</a>
<a name="ln947">    void LoadClosedShellOrbitals(std::vector&lt;double&gt; energies, std::vector&lt;std::string&gt; symmetries, unsigned int alphaHOMO);</a>
<a name="ln948">    //! \brief Convenience function to load alpha orbitals in an open-shell calculation</a>
<a name="ln949">    void LoadAlphaOrbitals(std::vector&lt;double&gt; energies, std::vector&lt;std::string&gt; symmetries, unsigned int alphaHOMO);</a>
<a name="ln950">    //! \brief Convenience function to load beta orbitals in an open-shell calculation</a>
<a name="ln951">    void LoadBetaOrbitals(std::vector&lt;double&gt; energies, std::vector&lt;std::string&gt; symmetries, unsigned int betaHOMO);</a>
<a name="ln952"> </a>
<a name="ln953">  protected:</a>
<a name="ln954">    std::vector&lt;OBOrbital&gt; _alphaOrbitals; //!&lt; List of orbitals. In case of unrestricted calculations, this contains the alpha spin-orbitals</a>
<a name="ln955">    std::vector&lt;OBOrbital&gt; _betaOrbitals;  //!&lt; Only used if needed (e.g., unrestricted calculations)</a>
<a name="ln956">    unsigned int _alphaHOMO;               //!&lt; Highest occupied molecular orbital for _alphaOrbitals</a>
<a name="ln957">    unsigned int _betaHOMO;                //!&lt; Highest occupied for _betaOrbitals (if needed)</a>
<a name="ln958">    bool _openShell;                       //!&lt; Whether we store both alpha and beta spin-orbitals (i.e., a restricted open-shell or unrestricted calc.)</a>
<a name="ln959">  };</a>
<a name="ln960"> </a>
<a name="ln961">  //! \class OBElectronicTransitionData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln962">  //! \brief Used to hold information about electronic transitions</a>
<a name="ln963"> class OBAPI OBElectronicTransitionData: public OBGenericData</a>
<a name="ln964">  {</a>
<a name="ln965">  protected:</a>
<a name="ln966">    //! Wavelengths (nm)</a>
<a name="ln967">    std::vector&lt;double&gt;  _vWavelengths;</a>
<a name="ln968"> </a>
<a name="ln969">    //! Oscillator strengths</a>
<a name="ln970">    std::vector&lt;double&gt;  _vForces;</a>
<a name="ln971"> </a>
<a name="ln972">    //! Electric dipole strengths</a>
<a name="ln973">    std::vector&lt;double&gt;  _vEDipole;</a>
<a name="ln974"> </a>
<a name="ln975">    //! Rotatory strengths (velocity)</a>
<a name="ln976">    std::vector&lt;double&gt;  _vRotatoryStrengthsVelocity;</a>
<a name="ln977"> </a>
<a name="ln978">    //! Rotatory strengths (length)</a>
<a name="ln979">    std::vector&lt;double&gt;  _vRotatoryStrengthsLength;</a>
<a name="ln980"> </a>
<a name="ln981">  public:</a>
<a name="ln982">    OBElectronicTransitionData(): OBGenericData(&quot;ElectronicTransitionData&quot;, OBGenericDataType::ElectronicTransitionData) {}</a>
<a name="ln983">    virtual ~OBElectronicTransitionData() {}</a>
<a name="ln984">    virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln985">         {return new OBElectronicTransitionData(*this);}</a>
<a name="ln986"> </a>
<a name="ln987">    OBElectronicTransitionData &amp; operator=(const OBElectronicTransitionData &amp;);</a>
<a name="ln988"> </a>
<a name="ln989">    void SetData(const std::vector&lt;double&gt; &amp; wavelengths,</a>
<a name="ln990">                 const std::vector&lt;double&gt; &amp; forces);</a>
<a name="ln991"> </a>
<a name="ln992">    void SetEDipole(const std::vector&lt;double&gt; &amp;);</a>
<a name="ln993">    void SetRotatoryStrengthsVelocity(const std::vector&lt;double&gt; &amp;);</a>
<a name="ln994">    void SetRotatoryStrengthsLength(const std::vector&lt;double&gt; &amp;);</a>
<a name="ln995"> </a>
<a name="ln996">    std::vector&lt;double&gt; GetWavelengths() const</a>
<a name="ln997">      { return this-&gt;_vWavelengths; }</a>
<a name="ln998">    std::vector&lt;double&gt; GetForces() const</a>
<a name="ln999">      { return this-&gt;_vForces; }</a>
<a name="ln1000">    std::vector&lt;double&gt; GetEDipole() const</a>
<a name="ln1001">      { return this-&gt;_vEDipole; }</a>
<a name="ln1002">    std::vector&lt;double&gt; GetRotatoryStrengthsVelocity() const</a>
<a name="ln1003">      { return this-&gt;_vRotatoryStrengthsVelocity; }</a>
<a name="ln1004">    std::vector&lt;double&gt; GetRotatoryStrengthsLength() const</a>
<a name="ln1005">      { return this-&gt;_vRotatoryStrengthsLength; }</a>
<a name="ln1006">};</a>
<a name="ln1007"> </a>
<a name="ln1008">  //! \class OBRotationData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln1009">  //! \brief Used to hold the rotational constants and symmetry numbers</a>
<a name="ln1010"> class OBAPI OBRotationData: public OBGenericData</a>
<a name="ln1011"> {</a>
<a name="ln1012"> public:</a>
<a name="ln1013">   enum RType{UNKNOWN, ASYMMETRIC, SYMMETRIC, LINEAR};</a>
<a name="ln1014">   OBRotationData(): OBGenericData(&quot;RotationData&quot;, OBGenericDataType::RotationData){}</a>
<a name="ln1015">   virtual ~OBRotationData(){};</a>
<a name="ln1016">   virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln1017">         {return new OBRotationData(*this);}</a>
<a name="ln1018">   void SetData(RType RotorType, std::vector&lt;double&gt; RotationalConstants, int SymmetryNumber)</a>
<a name="ln1019">   {</a>
<a name="ln1020">     RotConsts = RotationalConstants;</a>
<a name="ln1021">     type = RotorType;</a>
<a name="ln1022">     SymNum = SymmetryNumber;</a>
<a name="ln1023">   }</a>
<a name="ln1024"> </a>
<a name="ln1025">   /// \return Rotational constants in GHz</a>
<a name="ln1026">   std::vector&lt;double&gt; GetRotConsts()const{ return RotConsts; }</a>
<a name="ln1027"> </a>
<a name="ln1028">   int GetSymmetryNumber()const{ return SymNum; }</a>
<a name="ln1029">   RType GetRotorType()const   { return type; }</a>
<a name="ln1030"> </a>
<a name="ln1031"> protected:</a>
<a name="ln1032">   std::vector&lt;double&gt; RotConsts;//!&lt; Rotational constants in GHz</a>
<a name="ln1033">   int                 SymNum;   //!&lt; Rotational Symmetry Number</a>
<a name="ln1034">   RType               type;     //!&lt; linear, symmetric or asymmetric top</a>
<a name="ln1035"> };</a>
<a name="ln1036"> </a>
<a name="ln1037">  //! \class OBVectorData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln1038">  //! \brief Used to hold a 3D vector item (e.g., a dipole moment)</a>
<a name="ln1039">  //! \since version 2.2</a>
<a name="ln1040"> class OBAPI OBVectorData: public OBGenericData</a>
<a name="ln1041"> {</a>
<a name="ln1042"> public:</a>
<a name="ln1043">   OBVectorData(): OBGenericData(&quot;VectorData&quot;, OBGenericDataType::VectorData){}</a>
<a name="ln1044">   virtual ~OBVectorData(){};</a>
<a name="ln1045">   virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln1046">         {return new OBVectorData(*this);}</a>
<a name="ln1047">   void SetData(double x, double y, double z)</a>
<a name="ln1048">     { _vec = vector3(x, y, z); }</a>
<a name="ln1049">   void SetData(vector3 data)</a>
<a name="ln1050">     { _vec = data; }</a>
<a name="ln1051">   vector3 GetData() const</a>
<a name="ln1052">     { return _vec; }</a>
<a name="ln1053"> </a>
<a name="ln1054"> protected:</a>
<a name="ln1055">   vector3            _vec; //!&lt; 3D vector to be stored</a>
<a name="ln1056"> };</a>
<a name="ln1057"> </a>
<a name="ln1058">   //! \class OBMatrixData generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln1059">   //! \brief Used to hold a 3x3 matrix item (e.g., a quadrupole moment)</a>
<a name="ln1060">   //! \since version 2.2</a>
<a name="ln1061">  class OBAPI OBMatrixData: public OBGenericData</a>
<a name="ln1062">  {</a>
<a name="ln1063">  public:</a>
<a name="ln1064">    OBMatrixData(): OBGenericData(&quot;MatrixData&quot;, OBGenericDataType::MatrixData){}</a>
<a name="ln1065">    virtual ~OBMatrixData(){};</a>
<a name="ln1066">    virtual OBGenericData* Clone(OBBase*) const</a>
<a name="ln1067">          {return new OBMatrixData(*this);}</a>
<a name="ln1068">    void SetData(matrix3x3 data)</a>
<a name="ln1069">      { _matrix = data; }</a>
<a name="ln1070">    matrix3x3 GetData() const</a>
<a name="ln1071">      { return _matrix; }</a>
<a name="ln1072"> </a>
<a name="ln1073">  protected:</a>
<a name="ln1074">    matrix3x3            _matrix; //!&lt; 3x3 matrix to be stored</a>
<a name="ln1075">  };</a>
<a name="ln1076"> </a>
<a name="ln1077">  //! \class OBFreeGridPoint generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln1078">  //! \brief Helper class for OBFreeGrid</a>
<a name="ln1079">  //! Can hold a random coordinate and associated value.</a>
<a name="ln1080">  class OBAPI OBFreeGridPoint</a>
<a name="ln1081">  {</a>
<a name="ln1082">  protected:</a>
<a name="ln1083">    double _x,_y,_z,_V;</a>
<a name="ln1084">    </a>
<a name="ln1085">  public:</a>
<a name="ln1086">    OBFreeGridPoint() {};</a>
<a name="ln1087">    OBFreeGridPoint(double x,double y,double z,double V) { _x = x; _y = y; _z = z; _V = V; }</a>
<a name="ln1088">    ~OBFreeGridPoint() {};</a>
<a name="ln1089">    double GetX() { return _x; }</a>
<a name="ln1090">    double GetY() { return _y; }</a>
<a name="ln1091">    double GetZ() { return _z; }</a>
<a name="ln1092">    double GetV() { return _V; }</a>
<a name="ln1093">    void SetX(double x) { _x = x; }</a>
<a name="ln1094">    void SetY(double y) { _y = y; }</a>
<a name="ln1095">    void SetZ(double z) { _z = z; }</a>
<a name="ln1096">    void SetV(double V) { _V = V; }</a>
<a name="ln1097">  };</a>
<a name="ln1098">  </a>
<a name="ln1099">  //! A standard iterator over a vector of FreeGridPoints</a>
<a name="ln1100">  typedef std::vector&lt;OBFreeGridPoint*&gt;::iterator OBFreeGridPointIterator;</a>
<a name="ln1101"> </a>
<a name="ln1102">  //! \class OBFreeGrid generic.h &lt;openbabel/generic.h&gt;</a>
<a name="ln1103">  //! \brief Handle double precision floating point data with coordinates not on a grid</a>
<a name="ln1104">  //! Can hold array of random coordinates and associated values.</a>
<a name="ln1105">  class OBAPI OBFreeGrid: public OBGenericData</a>
<a name="ln1106">  {</a>
<a name="ln1107">  protected:</a>
<a name="ln1108">    std::vector&lt;OBFreeGridPoint*&gt; _points;  //!&lt; coordinates with accompanying float values</a>
<a name="ln1109">  public:</a>
<a name="ln1110"> </a>
<a name="ln1111">    OBFreeGrid() </a>
<a name="ln1112">    {</a>
<a name="ln1113">    }</a>
<a name="ln1114">    </a>
<a name="ln1115">    ~OBFreeGrid() </a>
<a name="ln1116">    {</a>
<a name="ln1117">      //delete _points;</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    int NumPoints() </a>
<a name="ln1121">    { </a>
<a name="ln1122">      return (int)_points.size();</a>
<a name="ln1123">    }</a>
<a name="ln1124">    </a>
<a name="ln1125">    void AddPoint(double x,double y,double z, double V) </a>
<a name="ln1126">    {</a>
<a name="ln1127">      _points.push_back(new OpenBabel::OBFreeGridPoint(x,y,z,V));</a>
<a name="ln1128">    }</a>
<a name="ln1129"> </a>
<a name="ln1130">    OBFreeGridPointIterator BeginPoints() </a>
<a name="ln1131">    { </a>
<a name="ln1132">      return _points.begin(); </a>
<a name="ln1133">    }</a>
<a name="ln1134">    </a>
<a name="ln1135">    OBFreeGridPointIterator EndPoints() </a>
<a name="ln1136">    {</a>
<a name="ln1137">      return _points.begin() + NumPoints(); </a>
<a name="ln1138">    }</a>
<a name="ln1139">    </a>
<a name="ln1140">    OBFreeGridPoint *BeginPoint(OBFreeGridPointIterator &amp;i)</a>
<a name="ln1141">    {</a>
<a name="ln1142">      i = _points.begin();</a>
<a name="ln1143">      return((i == _points.end()) ? (OBFreeGridPoint*)nullptr : (OBFreeGridPoint*)*i);</a>
<a name="ln1144">    }</a>
<a name="ln1145"> </a>
<a name="ln1146">    OBFreeGridPoint *NextPoint(OBFreeGridPointIterator &amp;i)</a>
<a name="ln1147">    {</a>
<a name="ln1148">      ++i;</a>
<a name="ln1149">      return((i == _points.end()) ? (OBFreeGridPoint*)nullptr : (OBFreeGridPoint*)*i);</a>
<a name="ln1150">    }</a>
<a name="ln1151">    </a>
<a name="ln1152">    void Clear();</a>
<a name="ln1153"> </a>
<a name="ln1154">  };</a>
<a name="ln1155">  </a>
<a name="ln1156">  class OBAPI OBPcharge: public OBGenericData</a>
<a name="ln1157">  {</a>
<a name="ln1158">  protected:</a>
<a name="ln1159">    std::vector&lt;double&gt; _PartialCharge;</a>
<a name="ln1160">  public:</a>
<a name="ln1161">    OBPcharge(){};</a>
<a name="ln1162">    ~OBPcharge(){};</a>
<a name="ln1163"> </a>
<a name="ln1164">    int NumPartialCharges() </a>
<a name="ln1165">    { </a>
<a name="ln1166">      return (int)_PartialCharge.size(); </a>
<a name="ln1167">    }</a>
<a name="ln1168">    </a>
<a name="ln1169">    void AddPartialCharge(std::vector&lt;double&gt; q)</a>
<a name="ln1170">    {</a>
<a name="ln1171">      _PartialCharge = q;</a>
<a name="ln1172">    }</a>
<a name="ln1173"> </a>
<a name="ln1174">    std::vector&lt;double&gt; GetPartialCharge()</a>
<a name="ln1175">    {</a>
<a name="ln1176">        return _PartialCharge;</a>
<a name="ln1177">    }</a>
<a name="ln1178">  };</a>
<a name="ln1179"> </a>
<a name="ln1180"> //! A standard iterator over vectors of OBGenericData (e.g., inherited from OBBase)</a>
<a name="ln1181">  typedef std::vector&lt;OBGenericData*&gt;::iterator OBDataIterator;</a>
<a name="ln1182"> </a>
<a name="ln1183">} //end namespace OpenBabel</a>
<a name="ln1184"> </a>
<a name="ln1185">#endif // OB_GENERIC_H</a>
<a name="ln1186"> </a>
<a name="ln1187">//! \file generic.h</a>
<a name="ln1188">//! \brief Handle generic data classes. Custom data for atoms, bonds, etc.</a>

</code></pre>
<div class="balloon" rel="69"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'OBExternalBond' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="875"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _fermi.</p></div>
<div class="balloon" rel="1014"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: SymNum, type.</p></div>
<div class="balloon" rel="1086"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _x, _y, _z, _V.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

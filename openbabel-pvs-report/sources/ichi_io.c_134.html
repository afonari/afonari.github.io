
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichi_io.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;string.h&gt;</a>
<a name="ln42">#include &lt;stdlib.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44">#include &lt;stdarg.h&gt;</a>
<a name="ln45">#include &quot;mode.h&quot;</a>
<a name="ln46">#include &quot;ichi_io.h&quot;</a>
<a name="ln47">#include &quot;ichicomp.h&quot;</a>
<a name="ln48">#include &quot;util.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">#ifndef INCHI_ADD_STR_LEN</a>
<a name="ln51">#define INCHI_ADD_STR_LEN   32768</a>
<a name="ln52">#endif</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln56">extern void (*FWPRINT) (const char * format, va_list argptr );</a>
<a name="ln57">#endif</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60">/*^^^ Internal functions */</a>
<a name="ln61"> </a>
<a name="ln62">int inchi_ios_str_getc( INCHI_IOSTREAM *ios );</a>
<a name="ln63">char *inchi_ios_str_gets( char *szLine, int len, INCHI_IOSTREAM *ios );</a>
<a name="ln64">char *inchi_ios_str_getsTab( char *szLine, int len, INCHI_IOSTREAM *ios );</a>
<a name="ln65">int GetMaxPrintfLength( const char *lpszFormat, va_list argList);</a>
<a name="ln66">char *inchi_fgetsTab( char *szLine, int len, FILE *f ); </a>
<a name="ln67">int inchi_vfprintf( FILE* f, const char* lpszFormat, va_list argList ); </a>
<a name="ln68"> </a>
<a name="ln69">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">                                    INCHI_IOSTREAM OPERATIONS </a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln79">    Init INCHI_IOSTREAM</a>
<a name="ln80">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln81">void inchi_ios_init(INCHI_IOSTREAM* ios, int io_type, FILE *f)</a>
<a name="ln82">{</a>
<a name="ln83">    memset( ios, 0, sizeof(*ios) );</a>
<a name="ln84">    switch (io_type)</a>
<a name="ln85">    {</a>
<a name="ln86">        case INCHI_IOSTREAM_FILE:	ios-&gt;type = INCHI_IOSTREAM_FILE; </a>
<a name="ln87">                                    break;</a>
<a name="ln88">        case INCHI_IOSTREAM_STRING:</a>
<a name="ln89">        default:                    ios-&gt;type = INCHI_IOSTREAM_STRING;</a>
<a name="ln90">                                    break;</a>
<a name="ln91">    }</a>
<a name="ln92">    ios-&gt;f = f; </a>
<a name="ln93">    return;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln99">    If INCHI_IOSTREAM type is INCHI_IOSTREAM_STRING,</a>
<a name="ln100">        flush INCHI_IOSTREAM string buffer to file (if non-NULL); then free buffer.</a>
<a name="ln101">    If INCHI_IOSTREAM type is INCHI_IOSTREAM_FILE, just flush the file.</a>
<a name="ln102">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln103">void inchi_ios_flush(INCHI_IOSTREAM* ios)</a>
<a name="ln104">{</a>
<a name="ln105">    </a>
<a name="ln106">    if (ios-&gt;type == INCHI_IOSTREAM_STRING) </a>
<a name="ln107">    {</a>
<a name="ln108">        if (ios-&gt;s.pStr)</a>
<a name="ln109">        {</a>
<a name="ln110">            if (ios-&gt;s.nUsedLength &gt; 0)</a>
<a name="ln111">            {       </a>
<a name="ln112">                if (ios-&gt;f)</a>
<a name="ln113">                {</a>
<a name="ln114">                    fprintf(ios-&gt;f,&quot;%-s&quot;, ios-&gt;s.pStr); </a>
<a name="ln115">                    fflush(ios-&gt;f);</a>
<a name="ln116">                }</a>
<a name="ln117">                inchi_free(ios-&gt;s.pStr );</a>
<a name="ln118">                ios-&gt;s.pStr = NULL; </a>
<a name="ln119">                ios-&gt;s.nUsedLength = ios-&gt;s.nAllocatedLength = ios-&gt;s.nPtr = 0;</a>
<a name="ln120">            }       </a>
<a name="ln121">        }</a>
<a name="ln122">    }</a>
<a name="ln123">    </a>
<a name="ln124">    else if (ios-&gt;type == INCHI_IOSTREAM_FILE)</a>
<a name="ln125">    {</a>
<a name="ln126">        /* output to plain file: just flush it. */</a>
<a name="ln127">        fflush(ios-&gt;f);</a>
<a name="ln128">    }</a>
<a name="ln129">    </a>
<a name="ln130">    return;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134"> </a>
<a name="ln135">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln136">    If INCHI_IOSTREAM type is INCHI_IOSTREAM_STRING,</a>
<a name="ln137">        flush INCHI_IOSTREAM string buffer to file (if non-NULL) and</a>
<a name="ln138">        another file f2 supplied as parameter (typically, it will be stderr); then free buffer.</a>
<a name="ln139">    If INCHI_IOSTREAM type is INCHI_IOSTREAM_FILE, just flush the both files.</a>
<a name="ln140">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln141">void inchi_ios_flush2(INCHI_IOSTREAM* ios, FILE *f2)</a>
<a name="ln142">{</a>
<a name="ln143"> </a>
<a name="ln144">    if (ios-&gt;type == INCHI_IOSTREAM_STRING) </a>
<a name="ln145">    {</a>
<a name="ln146">        if (ios-&gt;s.pStr)</a>
<a name="ln147">        {</a>
<a name="ln148">            if (ios-&gt;s.nUsedLength &gt; 0)</a>
<a name="ln149">            {       </a>
<a name="ln150">                if (ios-&gt;f)</a>
<a name="ln151">                {</a>
<a name="ln152">                    fprintf(ios-&gt;f,&quot;%-s&quot;, ios-&gt;s.pStr); </a>
<a name="ln153">                    fflush(ios-&gt;f);</a>
<a name="ln154">                }</a>
<a name="ln155">                if (f2!=ios-&gt;f)</a>
<a name="ln156">                    fprintf(f2,&quot;%-s&quot;, ios-&gt;s.pStr); </a>
<a name="ln157">                </a>
<a name="ln158">                inchi_free(ios-&gt;s.pStr );</a>
<a name="ln159">                ios-&gt;s.pStr = NULL; </a>
<a name="ln160">                ios-&gt;s.nUsedLength = ios-&gt;s.nAllocatedLength = ios-&gt;s.nPtr = 0;</a>
<a name="ln161">            }       </a>
<a name="ln162">        }</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">    else if (ios-&gt;type == INCHI_IOSTREAM_FILE)</a>
<a name="ln166">    {</a>
<a name="ln167">        /* output to plain file: just flush it. */</a>
<a name="ln168">        if ( (ios-&gt;f) &amp;&amp; (ios-&gt;f!=stderr) &amp;&amp; (ios-&gt;f!=stdout) )</a>
<a name="ln169">            fflush(ios-&gt;f);</a>
<a name="ln170">        if ( f2 &amp;&amp; f2!=stderr &amp;&amp; f2!=stdout)</a>
<a name="ln171">            fflush(f2);</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    return;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln182">    Close INCHI_IOSTREAM: free string buffer and close the file.</a>
<a name="ln183">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln184">void inchi_ios_close(INCHI_IOSTREAM* ios)</a>
<a name="ln185">{</a>
<a name="ln186">    if (ios-&gt;s.pStr)</a>
<a name="ln187">        inchi_free(ios-&gt;s.pStr);</a>
<a name="ln188">    ios-&gt;s.pStr = NULL; </a>
<a name="ln189">    ios-&gt;s.nUsedLength = ios-&gt;s.nAllocatedLength = ios-&gt;s.nPtr = 0;</a>
<a name="ln190">    if ( (ios-&gt;f) &amp;&amp; (ios-&gt;f!=stderr) &amp;&amp; (ios-&gt;f!=stdout) &amp;&amp; (ios-&gt;f!=stdin))</a>
<a name="ln191">        fclose(ios-&gt;f);</a>
<a name="ln192">    return;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln198">    Reset INCHI_IOSTREAM: set string buffer ptr to NULL (but do _not_ free memory)and close the file.</a>
<a name="ln199">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln200">void inchi_ios_reset(INCHI_IOSTREAM* ios)</a>
<a name="ln201">{</a>
<a name="ln202">    ios-&gt;s.pStr = NULL; </a>
<a name="ln203">    ios-&gt;s.nUsedLength = ios-&gt;s.nAllocatedLength = ios-&gt;s.nPtr = 0;</a>
<a name="ln204">    if ( (ios-&gt;f) &amp;&amp; (ios-&gt;f!=stderr) &amp;&amp; (ios-&gt;f!=stdout) &amp;&amp; (ios-&gt;f!=stdin))</a>
<a name="ln205">        fclose(ios-&gt;f);</a>
<a name="ln206">    return;</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209"> </a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212"> </a>
<a name="ln213">/*******************************************************************/</a>
<a name="ln214">int inchi_ios_str_getc(INCHI_IOSTREAM *ios)</a>
<a name="ln215">{</a>
<a name="ln216"> </a>
<a name="ln217">    if (ios-&gt;type==INCHI_IOSTREAM_STRING)</a>
<a name="ln218">    {</a>
<a name="ln219">        if ( ios-&gt;s.nPtr &lt; ios-&gt;s.nUsedLength ) </a>
<a name="ln220">        {</a>
<a name="ln221">            return (int)ios-&gt;s.pStr[ios-&gt;s.nPtr++];</a>
<a name="ln222">        }</a>
<a name="ln223">        return EOF;</a>
<a name="ln224">    }</a>
<a name="ln225">    </a>
<a name="ln226">    else if (ios-&gt;type==INCHI_IOSTREAM_FILE)</a>
<a name="ln227">    {</a>
<a name="ln228">        return fgetc( ios-&gt;f );</a>
<a name="ln229">    }</a>
<a name="ln230">    </a>
<a name="ln231">    /* error */</a>
<a name="ln232">    return EOF;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236"> </a>
<a name="ln237">/*******************************************************************/</a>
<a name="ln238">char *inchi_ios_str_gets(char *szLine, int len, INCHI_IOSTREAM *f)</a>
<a name="ln239">{</a>
<a name="ln240">int  length=0, c=0;</a>
<a name="ln241">    if ( -- len &lt; 0 ) </a>
<a name="ln242">    {</a>
<a name="ln243">        return NULL;</a>
<a name="ln244">    }</a>
<a name="ln245">    while ( length &lt; len &amp;&amp; EOF != (c = inchi_ios_str_getc( f )) ) </a>
<a name="ln246">    {</a>
<a name="ln247">        szLine[length++] = (char)c;</a>
<a name="ln248">        if ( c == '\n' )</a>
<a name="ln249">            break;</a>
<a name="ln250">    }</a>
<a name="ln251">    if ( !length &amp;&amp; EOF == c ) </a>
<a name="ln252">    {</a>
<a name="ln253">        return NULL;</a>
<a name="ln254">    }</a>
<a name="ln255">    szLine[length] = '\0';</a>
<a name="ln256">    return szLine;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">/********************************************************************************/</a>
<a name="ln262">/* read up to len or tab or LF; if empty read next until finds non-empty line   */</a>
<a name="ln263">/* remove leading and trailing white spaces; keep zero termination              */</a>
<a name="ln264">/********************************************************************************/</a>
<a name="ln265">char *inchi_ios_str_getsTab( char *szLine, int len, INCHI_IOSTREAM *f )</a>
<a name="ln266">{</a>
<a name="ln267">int  length=0, c=0;</a>
<a name="ln268">    if ( --len &lt; 0 ) </a>
<a name="ln269">    {</a>
<a name="ln270">        return NULL;</a>
<a name="ln271">    }</a>
<a name="ln272">    while ( length &lt; len &amp;&amp; EOF != (c = inchi_ios_str_getc(f)) ) </a>
<a name="ln273">    {</a>
<a name="ln274">        if ( c == '\t' )</a>
<a name="ln275">            c = '\n';</a>
<a name="ln276">        szLine[length++] = (char)c;</a>
<a name="ln277">        if ( c == '\n' )</a>
<a name="ln278">            break;</a>
<a name="ln279">    }</a>
<a name="ln280">    if ( !length &amp;&amp; EOF == c ) </a>
<a name="ln281">    {</a>
<a name="ln282">        return NULL;</a>
<a name="ln283">    }</a>
<a name="ln284">    szLine[length] = '\0';</a>
<a name="ln285">    return szLine;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">/*******************************************************************/</a>
<a name="ln290">int inchi_ios_gets( char *szLine, int len, INCHI_IOSTREAM *f, int *bTooLongLine )</a>
<a name="ln291">{</a>
<a name="ln292">int  length;</a>
<a name="ln293">char *p;</a>
<a name="ln294">    do </a>
<a name="ln295">    {</a>
<a name="ln296">        p = inchi_ios_str_gets( szLine, len-1, f );</a>
<a name="ln297">        if ( !p ) </a>
<a name="ln298">        {</a>
<a name="ln299">            *bTooLongLine = 0;</a>
<a name="ln300">            return -1; /* end of file or cannot read */</a>
<a name="ln301">        }</a>
<a name="ln302">        szLine[len-1] = '\0';</a>
<a name="ln303">        /*</a>
<a name="ln304">        *bTooLongLine = !strchr( szLine, '\n' );</a>
<a name="ln305">        */</a>
<a name="ln306">        p = strchr( szLine, '\n' );</a>
<a name="ln307">        *bTooLongLine = ( !p &amp;&amp; ((int)strlen(szLine)) == len-2 );</a>
<a name="ln308">        LtrimRtrim( szLine, &amp;length );</a>
<a name="ln309">    } while ( !length );</a>
<a name="ln310"> </a>
<a name="ln311">    return length;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315">/*******************************************************************/</a>
<a name="ln316">/* read up to len or tab or LF; if empty read next until finds non-empty line   */</a>
<a name="ln317">/* remove leading and trailing white spaces; keep zero termination */</a>
<a name="ln318">/*******************************************************************/</a>
<a name="ln319">int inchi_ios_getsTab( char *szLine, int len, INCHI_IOSTREAM *f, int *bTooLongLine )</a>
<a name="ln320">{</a>
<a name="ln321">int  length;</a>
<a name="ln322">char *p;</a>
<a name="ln323">    do </a>
<a name="ln324">    {</a>
<a name="ln325">        p = inchi_ios_str_getsTab( szLine, len-1, f );</a>
<a name="ln326">        if ( !p ) </a>
<a name="ln327">        {</a>
<a name="ln328">            *bTooLongLine = 0;</a>
<a name="ln329">            return -1; /* end of file or cannot read */</a>
<a name="ln330">        }</a>
<a name="ln331">        szLine[len-1] = '\0';</a>
<a name="ln332">        /*</a>
<a name="ln333">        *bTooLongLine = !strchr( szLine, '\n' );</a>
<a name="ln334">        */</a>
<a name="ln335">        p = strchr( szLine, '\n' );</a>
<a name="ln336">        *bTooLongLine = ( !p &amp;&amp; ((int)strlen(szLine)) == len-2 );</a>
<a name="ln337">        LtrimRtrim( szLine, &amp;length );</a>
<a name="ln338">    } while ( !length );</a>
<a name="ln339">    return length;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">/*******************************************************************/</a>
<a name="ln343">int inchi_ios_getsTab1( char *szLine, int len, INCHI_IOSTREAM *f, int *bTooLongLine )</a>
<a name="ln344">{</a>
<a name="ln345">int  length;</a>
<a name="ln346">char *p;</a>
<a name="ln347">    /*do {*/</a>
<a name="ln348">        p = inchi_ios_str_getsTab( szLine, len-1, f );</a>
<a name="ln349">        if ( !p ) </a>
<a name="ln350">        {</a>
<a name="ln351">            *bTooLongLine = 0;</a>
<a name="ln352">            return -1; /* end of file or cannot read */</a>
<a name="ln353">        }</a>
<a name="ln354">        szLine[len-1] = '\0';</a>
<a name="ln355">        /*</a>
<a name="ln356">        *bTooLongLine = !strchr( szLine, '\n' );</a>
<a name="ln357">        */</a>
<a name="ln358">        p = strchr( szLine, '\n' );</a>
<a name="ln359">        *bTooLongLine = ( !p &amp;&amp; ((int)strlen(szLine)) == len-2 );</a>
<a name="ln360">        LtrimRtrim( szLine, &amp;length );</a>
<a name="ln361">    /*} while ( !length );*/</a>
<a name="ln362">    return length;</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">/*****************************************************************/</a>
<a name="ln371">int inchi_ios_print( INCHI_IOSTREAM * ios, const char* lpszFormat, ... )</a>
<a name="ln372">{</a>
<a name="ln373">int ret=0, ret2=0;</a>
<a name="ln374">va_list argList;</a>
<a name="ln375"> </a>
<a name="ln376">    if (!ios) </a>
<a name="ln377">        return -1;</a>
<a name="ln378">    </a>
<a name="ln379">    if (ios-&gt;type == INCHI_IOSTREAM_STRING) </a>
<a name="ln380">    {    </a>
<a name="ln381">        /* output to string buffer */        </a>
<a name="ln382">        int max_len;</a>
<a name="ln383">        my_va_start( argList, lpszFormat );</a>
<a name="ln384">        max_len = GetMaxPrintfLength( lpszFormat, argList);</a>
<a name="ln385">        va_end( argList );</a>
<a name="ln386">        if ( max_len &gt;= 0 ) </a>
<a name="ln387">        {</a>
<a name="ln388">            if ( ios-&gt;s.nAllocatedLength - ios-&gt;s.nUsedLength &lt;= max_len ) </a>
<a name="ln389">            {</a>
<a name="ln390">                /* enlarge output string */</a>
<a name="ln391">                int  nAddLength = inchi_max( INCHI_ADD_STR_LEN, max_len );</a>
<a name="ln392">                char *new_str = </a>
<a name="ln393">                    (char *)inchi_calloc( ios-&gt;s.nAllocatedLength + nAddLength, sizeof(new_str[0]) );</a>
<a name="ln394">                if ( new_str ) </a>
<a name="ln395">                {</a>
<a name="ln396">                    if ( ios-&gt;s.pStr ) </a>
<a name="ln397">                    {</a>
<a name="ln398">                        if ( ios-&gt;s.nUsedLength &gt; 0 ) </a>
<a name="ln399">                            memcpy( new_str, ios-&gt;s.pStr, sizeof(new_str[0])* ios-&gt;s.nUsedLength );</a>
<a name="ln400">                        inchi_free( ios-&gt;s.pStr );</a>
<a name="ln401">                    }</a>
<a name="ln402">                    ios-&gt;s.pStr              = new_str;</a>
<a name="ln403">                    ios-&gt;s.nAllocatedLength += nAddLength;</a>
<a name="ln404">                } </a>
<a name="ln405">                else return -1; /* failed */</a>
<a name="ln406">            }</a>
<a name="ln407">            /* output */</a>
<a name="ln408">            my_va_start( argList, lpszFormat );</a>
<a name="ln409">            ret = vsprintf( ios-&gt;s.pStr + ios-&gt;s.nUsedLength, lpszFormat, argList );</a>
<a name="ln410">            va_end(argList);</a>
<a name="ln411">            if ( ret &gt;= 0 ) </a>
<a name="ln412">                ios-&gt;s.nUsedLength += ret;</a>
<a name="ln413">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln414">            if( FWPRINT )</a>
<a name="ln415">            {</a>
<a name="ln416">                my_va_start( argList, lpszFormat );</a>
<a name="ln417">                FWPRINT( lpszFormat, argList );</a>
<a name="ln418">                va_end( argList );</a>
<a name="ln419">            }</a>
<a name="ln420">#endif</a>
<a name="ln421">            return ret;</a>
<a name="ln422">        }</a>
<a name="ln423">        return -1;</a>
<a name="ln424">    }</a>
<a name="ln425">    </a>
<a name="ln426">    else if (ios-&gt;type == INCHI_IOSTREAM_FILE)</a>
<a name="ln427">    {</a>
<a name="ln428">        /* output to file */</a>
<a name="ln429">        if (ios-&gt;f) </a>
<a name="ln430">        {</a>
<a name="ln431">            my_va_start( argList, lpszFormat );</a>
<a name="ln432">            ret = vfprintf( ios-&gt;f, lpszFormat, argList );</a>
<a name="ln433">            va_end( argList );</a>
<a name="ln434">        } </a>
<a name="ln435">        else </a>
<a name="ln436">        {</a>
<a name="ln437">            my_va_start( argList, lpszFormat );</a>
<a name="ln438">            ret2 = vfprintf( stdout, lpszFormat, argList );</a>
<a name="ln439">            va_end( argList );</a>
<a name="ln440">        }</a>
<a name="ln441">#ifdef TARGET_LIB_FOR_WINCHI</a>
<a name="ln442">        if( FWPRINT )</a>
<a name="ln443">        {</a>
<a name="ln444">            my_va_start( argList, lpszFormat );</a>
<a name="ln445">            FWPRINT( lpszFormat, argList );</a>
<a name="ln446">            va_end( argList );</a>
<a name="ln447">        }</a>
<a name="ln448">#endif</a>
<a name="ln449">        return ret? ret : ret2;</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">    /* no output */</a>
<a name="ln454">    return 0;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">/**********************************************************************/</a>
<a name="ln461">/* This function's output should not be displayed in the output pane  */</a>
<a name="ln462">/**********************************************************************/</a>
<a name="ln463">int inchi_ios_print_nodisplay( INCHI_IOSTREAM * ios, const char* lpszFormat, ... )</a>
<a name="ln464">{</a>
<a name="ln465">va_list argList;</a>
<a name="ln466"> </a>
<a name="ln467">    if (!ios) </a>
<a name="ln468">        return -1;</a>
<a name="ln469">    </a>
<a name="ln470">    if (ios-&gt;type == INCHI_IOSTREAM_STRING) </a>
<a name="ln471">    {</a>
<a name="ln472">        /* output to string buffer */</a>
<a name="ln473">        int ret=0, max_len;</a>
<a name="ln474">        my_va_start( argList, lpszFormat );</a>
<a name="ln475">        max_len = GetMaxPrintfLength( lpszFormat, argList);</a>
<a name="ln476">        va_end( argList );</a>
<a name="ln477">        if ( max_len &gt;= 0 ) </a>
<a name="ln478">        {</a>
<a name="ln479">            if ( ios-&gt;s.nAllocatedLength - ios-&gt;s.nUsedLength &lt;= max_len ) </a>
<a name="ln480">            {</a>
<a name="ln481">                /* enlarge output string */</a>
<a name="ln482">                int  nAddLength = inchi_max( INCHI_ADD_STR_LEN, max_len );</a>
<a name="ln483">                char *new_str = (char *)inchi_calloc( ios-&gt;s.nAllocatedLength + nAddLength, sizeof(new_str[0]) );</a>
<a name="ln484">                if ( new_str ) </a>
<a name="ln485">                {</a>
<a name="ln486">                    if ( ios-&gt;s.pStr ) </a>
<a name="ln487">                    {</a>
<a name="ln488">                        if ( ios-&gt;s.nUsedLength &gt; 0 ) </a>
<a name="ln489">                        {</a>
<a name="ln490">                            memcpy( new_str, ios-&gt;s.pStr, sizeof(new_str[0])*ios-&gt;s.nUsedLength );</a>
<a name="ln491">                        }</a>
<a name="ln492">                        inchi_free( ios-&gt;s.pStr );</a>
<a name="ln493">                    }</a>
<a name="ln494">                    ios-&gt;s.pStr              = new_str;</a>
<a name="ln495">                    ios-&gt;s.nAllocatedLength += nAddLength;</a>
<a name="ln496">                } else </a>
<a name="ln497">                {</a>
<a name="ln498">                    return -1; /* failed */</a>
<a name="ln499">                }</a>
<a name="ln500">            }</a>
<a name="ln501">            /* output */</a>
<a name="ln502">            my_va_start( argList, lpszFormat );</a>
<a name="ln503">            ret = vsprintf( ios-&gt;s.pStr + ios-&gt;s.nUsedLength, lpszFormat, argList );</a>
<a name="ln504">            va_end(argList);</a>
<a name="ln505">            if ( ret &gt;= 0 ) </a>
<a name="ln506">            {</a>
<a name="ln507">                ios-&gt;s.nUsedLength += ret;</a>
<a name="ln508">            }</a>
<a name="ln509">            return ret;</a>
<a name="ln510">        }</a>
<a name="ln511">        return -1;</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    else if (ios-&gt;type == INCHI_IOSTREAM_FILE)</a>
<a name="ln515">    {</a>
<a name="ln516">        my_va_start( argList, lpszFormat );</a>
<a name="ln517">        inchi_print_nodisplay( ios-&gt;f, lpszFormat, argList);</a>
<a name="ln518">        va_end(argList);        </a>
<a name="ln519">    }</a>
<a name="ln520"> </a>
<a name="ln521">    /* no output */</a>
<a name="ln522">    return 0;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526"> </a>
<a name="ln527"> </a>
<a name="ln528">/*****************************************************************/</a>
<a name="ln529">/* Print to string buffer or to file+stderr */</a>
<a name="ln530">int inchi_ios_eprint( INCHI_IOSTREAM * ios, const char* lpszFormat, ... )</a>
<a name="ln531">{</a>
<a name="ln532">int ret=0, ret2=0;</a>
<a name="ln533">va_list argList;</a>
<a name="ln534"> </a>
<a name="ln535">    if (!ios) </a>
<a name="ln536">        return -1;</a>
<a name="ln537"> </a>
<a name="ln538">    if (ios-&gt;type == INCHI_IOSTREAM_STRING) /* was #if ( defined(TARGET_API_LIB) || defined(INCHI_STANDALONE_EXE) ) */</a>
<a name="ln539">    {</a>
<a name="ln540">        /* output to string buffer */</a>
<a name="ln541">        int max_len, nAddLength = 0;</a>
<a name="ln542">        char *new_str = NULL;</a>
<a name="ln543"> </a>
<a name="ln544">        my_va_start( argList, lpszFormat );</a>
<a name="ln545">        max_len = GetMaxPrintfLength( lpszFormat, argList);</a>
<a name="ln546">        va_end( argList );</a>
<a name="ln547"> </a>
<a name="ln548">        if ( max_len &gt;= 0 ) </a>
<a name="ln549">        {</a>
<a name="ln550">            if ( ios-&gt;s.nAllocatedLength - ios-&gt;s.nUsedLength &lt;= max_len ) </a>
<a name="ln551">            {</a>
<a name="ln552">                /* enlarge output string */</a>
<a name="ln553">                nAddLength = inchi_max( INCHI_ADD_STR_LEN, max_len );</a>
<a name="ln554">                new_str = (char *)inchi_calloc( ios-&gt;s.nAllocatedLength + nAddLength, sizeof(new_str[0]) );</a>
<a name="ln555">                if ( new_str ) </a>
<a name="ln556">                {</a>
<a name="ln557">                    if ( ios-&gt;s.pStr ) </a>
<a name="ln558">                    {</a>
<a name="ln559">                        if ( ios-&gt;s.nUsedLength &gt; 0 ) </a>
<a name="ln560">                        {</a>
<a name="ln561">                            memcpy( new_str, ios-&gt;s.pStr, sizeof(new_str[0])* ios-&gt;s.nUsedLength );</a>
<a name="ln562">                        }</a>
<a name="ln563">                        inchi_free( ios-&gt;s.pStr );</a>
<a name="ln564">                    }</a>
<a name="ln565">                    ios-&gt;s.pStr              = new_str;</a>
<a name="ln566">                    ios-&gt;s.nAllocatedLength += nAddLength;</a>
<a name="ln567">                } </a>
<a name="ln568">                else </a>
<a name="ln569">                {</a>
<a name="ln570">                    return -1; /* failed */</a>
<a name="ln571">                }</a>
<a name="ln572">            }</a>
<a name="ln573">         </a>
<a name="ln574">            /* output */</a>
<a name="ln575">            my_va_start( argList, lpszFormat );</a>
<a name="ln576">            ret = vsprintf( ios-&gt;s.pStr + ios-&gt;s.nUsedLength, lpszFormat, argList );</a>
<a name="ln577">            va_end(argList);</a>
<a name="ln578">            if ( ret &gt;= 0 ) </a>
<a name="ln579">            {</a>
<a name="ln580">                ios-&gt;s.nUsedLength += ret;</a>
<a name="ln581">            }</a>
<a name="ln582">            return ret;</a>
<a name="ln583">        }</a>
<a name="ln584">        return -1;</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    else if (ios-&gt;type == INCHI_IOSTREAM_FILE)</a>
<a name="ln588">    {</a>
<a name="ln589">        if ( ios-&gt;f) </a>
<a name="ln590">        {</a>
<a name="ln591">            /* output to plain file */</a>
<a name="ln592">            my_va_start( argList, lpszFormat );</a>
<a name="ln593">            ret = inchi_vfprintf( ios-&gt;f, lpszFormat, argList ); </a>
<a name="ln594">            va_end( argList );</a>
<a name="ln595">/*^^^  No output to stderr from within dll or GUI program */</a>
<a name="ln596">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_LIB_FOR_WINCHI) )</a>
<a name="ln597">            if ( ios-&gt;f != stderr ) </a>
<a name="ln598">            { </a>
<a name="ln599">                my_va_start( argList, lpszFormat );</a>
<a name="ln600">                ret2 = vfprintf( stderr, lpszFormat, argList );</a>
<a name="ln601">                va_end( argList );</a>
<a name="ln602">            }</a>
<a name="ln603">#endif</a>
<a name="ln604">            return ret? ret : ret2;</a>
<a name="ln605">        }</a>
<a name="ln606">    } </a>
<a name="ln607"> </a>
<a name="ln608">    /* no output */</a>
<a name="ln609">    return 0;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612"> </a>
<a name="ln613"> </a>
<a name="ln614"> </a>
<a name="ln615">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln616"> </a>
<a name="ln617"> </a>
<a name="ln618">                                    PLAIN FILE OPERATIONS </a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624"> </a>
<a name="ln625">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln626"> </a>
<a name="ln627">/* Print to file, echoing to stderr */</a>
<a name="ln628">int inchi_fprintf( FILE* f, const char* lpszFormat, ... )</a>
<a name="ln629">{</a>
<a name="ln630">int ret=0, ret2=0;</a>
<a name="ln631">va_list argList;</a>
<a name="ln632">    if (f) </a>
<a name="ln633">    {</a>
<a name="ln634">        my_va_start( argList, lpszFormat );</a>
<a name="ln635">        ret = inchi_vfprintf( f, lpszFormat, argList ); </a>
<a name="ln636">        va_end( argList );</a>
<a name="ln637">/*^^^  No output to stderr from within dll or GUI program */</a>
<a name="ln638">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_LIB_FOR_WINCHI) )</a>
<a name="ln639">        if ( f != stderr ) </a>
<a name="ln640">        { </a>
<a name="ln641">            my_va_start( argList, lpszFormat );</a>
<a name="ln642">            ret2 = vfprintf( stderr, lpszFormat, argList );</a>
<a name="ln643">            va_end( argList );</a>
<a name="ln644">        }</a>
<a name="ln645">#endif</a>
<a name="ln646">        return ret? ret : ret2;</a>
<a name="ln647">    }</a>
<a name="ln648">    return 0;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651"> </a>
<a name="ln652"> </a>
<a name="ln653">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln654"> </a>
<a name="ln655">/* Print to file */</a>
<a name="ln656">int inchi_vfprintf( FILE* f, const char* lpszFormat, va_list argList )</a>
<a name="ln657">{</a>
<a name="ln658">int ret=0;</a>
<a name="ln659">    if ( f == stderr &amp;&amp; lpszFormat &amp;&amp; lpszFormat[0] &amp;&amp; '\r' == lpszFormat[strlen(lpszFormat)-1] ) </a>
<a name="ln660">    {</a>
<a name="ln661">#define CONSOLE_LINE_LEN 80</a>
<a name="ln662">#ifndef COMPILE_ANSI_ONLY</a>
<a name="ln663">        char szLine[CONSOLE_LINE_LEN];</a>
<a name="ln664">        ret = _vsnprintf( szLine, CONSOLE_LINE_LEN-1, lpszFormat, argList );</a>
<a name="ln665">        if ( ret &lt; 0 ) </a>
<a name="ln666">        {</a>
<a name="ln667">            /*  output is longer than the console line */</a>
<a name="ln668">            /*^^^ Fixed bug: (CONSOLE_LINE_LEN-4) --&gt; (CONSOLE_LINE_LEN-4-1) 11-22-08 IPl */</a>
<a name="ln669">            strcpy(szLine+CONSOLE_LINE_LEN-5, &quot;...\r&quot;);</a>
<a name="ln670">        }</a>
<a name="ln671">        fputs( szLine, f );</a>
<a name="ln672">#else</a>
<a name="ln673">        ret = vfprintf( f, lpszFormat, argList );</a>
<a name="ln674">#endif</a>
<a name="ln675">#undef CONSOLE_LINE_LEN</a>
<a name="ln676">    } </a>
<a name="ln677">    else </a>
<a name="ln678">    {</a>
<a name="ln679">        ret = vfprintf( f, lpszFormat, argList );</a>
<a name="ln680">    }</a>
<a name="ln681">    return ret;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">/**********************************************************************/</a>
<a name="ln687">/* This function's output should not be displayed in the output pane  */</a>
<a name="ln688">/**********************************************************************/</a>
<a name="ln689">int inchi_print_nodisplay( FILE* f, const char* lpszFormat, ... )</a>
<a name="ln690">{</a>
<a name="ln691">int ret=0;</a>
<a name="ln692">va_list argList;</a>
<a name="ln693">FILE* fi;</a>
<a name="ln694">    if (f)	</a>
<a name="ln695">        fi = f;</a>
<a name="ln696">    else	</a>
<a name="ln697">        fi = stdout;</a>
<a name="ln698">    my_va_start( argList, lpszFormat );</a>
<a name="ln699">    ret = vfprintf( fi, lpszFormat, argList );</a>
<a name="ln700">    return ret;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">#if ( FIX_READ_LONG_LINE_BUG == 1 )</a>
<a name="ln706">/********************************************************************/</a>
<a name="ln707">int inchi_fgetsLfTab( char *szLine, int len, FILE *f )</a>
<a name="ln708">{</a>
<a name="ln709">    int  length;</a>
<a name="ln710">    char *p;</a>
<a name="ln711">    char szSkip[256];</a>
<a name="ln712">    int  bTooLongLine = 0;</a>
<a name="ln713">    do {</a>
<a name="ln714">        p = inchi_fgetsTab( szLine, len, f );</a>
<a name="ln715">        if ( !p ) {</a>
<a name="ln716">            return -1; /* end of file or cannot read */</a>
<a name="ln717">        }</a>
<a name="ln718">        bTooLongLine = ( (int)strlen(szLine) == len-1 &amp;&amp; szLine[len-2] != '\n' );</a>
<a name="ln719">        LtrimRtrim( szLine, &amp;length );</a>
<a name="ln720">    } while ( !length );</a>
<a name="ln721">    if ( bTooLongLine ) {</a>
<a name="ln722">        while ( (p = inchi_fgetsTab( szSkip, sizeof(szSkip)-1, f )) ) {</a>
<a name="ln723">            if ( strchr( szSkip, '\n' ) )</a>
<a name="ln724">                break;</a>
<a name="ln725">        }</a>
<a name="ln726">    }</a>
<a name="ln727">    return length;</a>
<a name="ln728">}</a>
<a name="ln729">#else</a>
<a name="ln730">/********************************************************************/</a>
<a name="ln731">int inchi_fgetsLfTab( char *szLine, int len, FILE *f )</a>
<a name="ln732">{</a>
<a name="ln733">    int  length;</a>
<a name="ln734">    char *p;</a>
<a name="ln735">    char szSkip[256];</a>
<a name="ln736">    int  bTooLongLine = 0;</a>
<a name="ln737">    do {</a>
<a name="ln738">        p = inchi_fgetsTab( szLine, len-1, f );</a>
<a name="ln739">        if ( !p ) {</a>
<a name="ln740">            return -1; /* end of file or cannot read */</a>
<a name="ln741">        }</a>
<a name="ln742">        szLine[len-1] = '\0';</a>
<a name="ln743">        /*</a>
<a name="ln744">        bTooLongLine = !strchr( szLine, '\n' );</a>
<a name="ln745">        */</a>
<a name="ln746">        bTooLongLine = ( !p &amp;&amp; ((int)strlen(szLine)) == len-2 );</a>
<a name="ln747">        LtrimRtrim( szLine, &amp;length );</a>
<a name="ln748">    } while ( !length );</a>
<a name="ln749">    if ( bTooLongLine ) {</a>
<a name="ln750">        while ( p = inchi_fgetsTab( szSkip, sizeof(szSkip)-1, f ) ) {</a>
<a name="ln751">            szSkip[sizeof(szSkip)-1] = '\0';</a>
<a name="ln752">            if ( strchr( szSkip, '\n' ) )</a>
<a name="ln753">                break;</a>
<a name="ln754">        }</a>
<a name="ln755">    }</a>
<a name="ln756">    return length;</a>
<a name="ln757">}</a>
<a name="ln758">#endif</a>
<a name="ln759"> </a>
<a name="ln760"> </a>
<a name="ln761">/*******************************************************************/</a>
<a name="ln762">/* read up to len or tab or LF; if empty read next until finds non-empty line   */</a>
<a name="ln763">/* remove leading and trailing white spaces; keep zero termination */</a>
<a name="ln764">/*******************************************************************/</a>
<a name="ln765">char *inchi_fgetsTab( char *szLine, int len, FILE *f )</a>
<a name="ln766">{</a>
<a name="ln767">    int  length=0, c=0;</a>
<a name="ln768">    len --;</a>
<a name="ln769">    while ( length &lt; len &amp;&amp; EOF != (c = fgetc( f )) ) {</a>
<a name="ln770">        if ( c == '\t' )</a>
<a name="ln771">            c = '\n';</a>
<a name="ln772">        szLine[length++] = (char)c;</a>
<a name="ln773">        if ( c == '\n' )</a>
<a name="ln774">            break;</a>
<a name="ln775">    }</a>
<a name="ln776">    if ( !length &amp;&amp; EOF == c ) {</a>
<a name="ln777">        return NULL;</a>
<a name="ln778">    }</a>
<a name="ln779">    szLine[length] = '\0';</a>
<a name="ln780">    return szLine;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784"> </a>
<a name="ln785">/******************************************************************/</a>
<a name="ln786">/* read not more than line_len bytes from an lf-terminated line   */</a>
<a name="ln787">/* if input line is too long quietly ignore the rest of the line  */</a>
<a name="ln788">char* inchi_fgetsLf( char* line, int line_len, FILE* inp )</a>
<a name="ln789">{</a>
<a name="ln790">    char *p, *q;</a>
<a name="ln791">    memset( line, 0, line_len );</a>
<a name="ln792">    if ( NULL != (p = fgets( line, line_len, inp ) ) &amp;&amp; NULL == strchr(p, '\n' ) ){</a>
<a name="ln793">        char temp[64]; /* bypass up to '\n' or up to end of file whichever comes first*/</a>
<a name="ln794">        while ( NULL != fgets( temp, sizeof(temp), inp ) &amp;&amp; NULL == strchr(temp,'\n') )</a>
<a name="ln795">            ;</a>
<a name="ln796">    }</a>
<a name="ln797">    if ( p &amp;&amp; (q = strchr(line, '\r')) ) { /*  fix CR CR LF line terminator. */</a>
<a name="ln798">        q[0] = '\n';</a>
<a name="ln799">        q[1] = '\0';</a>
<a name="ln800">    }    </a>
<a name="ln801">    return p;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806"> </a>
<a name="ln807"> </a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810"> </a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">/*****************************************************************</a>
<a name="ln814"> *</a>
<a name="ln815"> *  Estimate printf string length</a>
<a name="ln816"> *  </a>
<a name="ln817"> *  The code is based on Microsoft Knowledge Base article Q127038:</a>
<a name="ln818"> *  &quot;FIX: CString::Format Gives Assertion Failed, Access Violation&quot;</a>
<a name="ln819"> *  (Related to Microsoft Visual C++, 32-bit Editions, versions 2.0, 2.1)</a>
<a name="ln820"> *</a>
<a name="ln821"> *****************************************************************/</a>
<a name="ln822"> </a>
<a name="ln823">#define FORCE_ANSI      0x10000</a>
<a name="ln824">#define FORCE_UNICODE   0x20000</a>
<a name="ln825"> </a>
<a name="ln826">/* formatting (using wsprintf style formatting)*/</a>
<a name="ln827">int GetMaxPrintfLength( const char *lpszFormat, va_list argList)</a>
<a name="ln828">{</a>
<a name="ln829">     /*ASSERT(AfxIsValidString(lpszFormat, FALSE));*/</a>
<a name="ln830">     const char * lpsz;</a>
<a name="ln831">     int nMaxLen, nWidth, nPrecision, nModifier, nItemLen;</a>
<a name="ln832"> </a>
<a name="ln833">     nMaxLen = 0;</a>
<a name="ln834">     /* make a guess at the maximum length of the resulting string */</a>
<a name="ln835">     for ( lpsz = lpszFormat; *lpsz; lpsz ++ )</a>
<a name="ln836">     {</a>
<a name="ln837">          /* handle '%' character, but watch out for '%%' */</a>
<a name="ln838">          if (*lpsz != '%' || *( ++ lpsz ) == '%')</a>
<a name="ln839">          {</a>
<a name="ln840">               nMaxLen += 1;</a>
<a name="ln841">               continue;</a>
<a name="ln842">          }</a>
<a name="ln843"> </a>
<a name="ln844">          nItemLen = 0;</a>
<a name="ln845"> </a>
<a name="ln846">          /*  handle '%' character with format */</a>
<a name="ln847">          nWidth = 0;</a>
<a name="ln848">          for (; *lpsz; lpsz ++ )</a>
<a name="ln849">          {</a>
<a name="ln850">               /* check for valid flags */</a>
<a name="ln851">               if (*lpsz == '#')</a>
<a name="ln852">                    nMaxLen += 2;   /* for '0x' */</a>
<a name="ln853">               else if (*lpsz == '*')</a>
<a name="ln854">                    nWidth = va_arg(argList, int);</a>
<a name="ln855">               else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0'</a>
<a name="ln856">                        || *lpsz == ' ')</a>
<a name="ln857">                           ;</a>
<a name="ln858">               else /* hit non-flag character */</a>
<a name="ln859">                          break;</a>
<a name="ln860">          }</a>
<a name="ln861">          /* get width and skip it */</a>
<a name="ln862">          if (nWidth == 0)</a>
<a name="ln863">          {</a>
<a name="ln864">               /* width indicated by */</a>
<a name="ln865">               nWidth = atoi(lpsz);</a>
<a name="ln866">               for (; *lpsz &amp;&amp; isdigit(*lpsz); lpsz ++ )</a>
<a name="ln867">                     ;</a>
<a name="ln868">          }</a>
<a name="ln869">          /*ASSERT(nWidth &gt;= 0);*/</a>
<a name="ln870">          if ( nWidth &lt; 0 )</a>
<a name="ln871">              goto exit_error; /* instead of exception */</a>
<a name="ln872"> </a>
<a name="ln873">          nPrecision = 0;</a>
<a name="ln874">          if (*lpsz == '.')</a>
<a name="ln875">          {</a>
<a name="ln876">               /* skip past '.' separator (width.precision)*/</a>
<a name="ln877">               lpsz ++;</a>
<a name="ln878"> </a>
<a name="ln879">               /* get precision and skip it*/</a>
<a name="ln880">               if (*lpsz == '*')</a>
<a name="ln881">               {</a>
<a name="ln882">                    nPrecision = va_arg(argList, int);</a>
<a name="ln883">                    lpsz ++;</a>
<a name="ln884">               }</a>
<a name="ln885">               else</a>
<a name="ln886">               {</a>
<a name="ln887">                    nPrecision = atoi(lpsz);</a>
<a name="ln888">                    for (; *lpsz &amp;&amp; isdigit(*lpsz); lpsz ++)</a>
<a name="ln889">                            ;</a>
<a name="ln890">               }</a>
<a name="ln891">              if ( nPrecision &lt; 0 )</a>
<a name="ln892">                  goto exit_error; /* instead of exception */</a>
<a name="ln893">          }</a>
<a name="ln894"> </a>
<a name="ln895">          /* should be on type modifier or specifier */</a>
<a name="ln896">          nModifier = 0;</a>
<a name="ln897">          switch (*lpsz)</a>
<a name="ln898">          {</a>
<a name="ln899">          /* modifiers that affect size */</a>
<a name="ln900">          case 'h':</a>
<a name="ln901">               switch ( lpsz[1] ) {</a>
<a name="ln902">               case 'd':</a>
<a name="ln903">               case 'i':</a>
<a name="ln904">               case 'o':</a>
<a name="ln905">               case 'x':</a>
<a name="ln906">               case 'X':</a>
<a name="ln907">               case 'u':</a>
<a name="ln908">                   /* short unsigned, short double, etc. -- added to the original MS example */</a>
<a name="ln909">                   /* ignore the fact that these modifiers do affect size */</a>
<a name="ln910">                   lpsz ++;</a>
<a name="ln911">                   break;</a>
<a name="ln912">               default:</a>
<a name="ln913">                   nModifier = FORCE_ANSI;</a>
<a name="ln914">                   lpsz ++;</a>
<a name="ln915">                   break;</a>
<a name="ln916">               }</a>
<a name="ln917">               break;</a>
<a name="ln918">          case 'l':</a>
<a name="ln919">               switch ( lpsz[1] ) {</a>
<a name="ln920">               case 'd':</a>
<a name="ln921">               case 'i':</a>
<a name="ln922">               case 'o':</a>
<a name="ln923">               case 'x':</a>
<a name="ln924">               case 'X':</a>
<a name="ln925">               case 'u':</a>
<a name="ln926">               case 'f': /* long float -- post ANSI C */</a>
<a name="ln927">                   /* long unsigned, long double, etc. -- added to the original MS example */</a>
<a name="ln928">                   /* ignore the fact that these modifiers do affect size */</a>
<a name="ln929">                   lpsz ++;</a>
<a name="ln930">                   break;</a>
<a name="ln931">               default:</a>
<a name="ln932">                   /*</a>
<a name="ln933">                   nModifier = FORCE_UNICODE;</a>
<a name="ln934">                   lpsz ++;</a>
<a name="ln935">                   break;</a>
<a name="ln936">                   */</a>
<a name="ln937">                   goto exit_error;  /* no UNICODE, please */</a>
<a name="ln938">               }</a>
<a name="ln939">               break;</a>
<a name="ln940">          /* modifiers that do not affect size */</a>
<a name="ln941">          case 'F':</a>
<a name="ln942">          case 'N':</a>
<a name="ln943">          case 'L':</a>
<a name="ln944">               lpsz ++;</a>
<a name="ln945">               break;</a>
<a name="ln946">          }</a>
<a name="ln947"> </a>
<a name="ln948">          /* now should be on specifier */</a>
<a name="ln949">          switch (*lpsz | nModifier)</a>
<a name="ln950">          {</a>
<a name="ln951">          /* single characters*/</a>
<a name="ln952">          case 'c':</a>
<a name="ln953">          case 'C':</a>
<a name="ln954">               nItemLen = 2;</a>
<a name="ln955">               va_arg(argList, int);</a>
<a name="ln956">               break;</a>
<a name="ln957">          case 'c'|FORCE_ANSI:</a>
<a name="ln958">          case 'C'|FORCE_ANSI:</a>
<a name="ln959">               nItemLen = 2;</a>
<a name="ln960">               va_arg(argList, int);</a>
<a name="ln961">               break;</a>
<a name="ln962">          case 'c'|FORCE_UNICODE:</a>
<a name="ln963">          case 'C'|FORCE_UNICODE:</a>
<a name="ln964">               goto exit_error;  /* no UNICODE, please */</a>
<a name="ln965">               /*</a>
<a name="ln966">               nItemLen = 2;</a>
<a name="ln967">               va_arg(argList, wchar_t);</a>
<a name="ln968">               break;</a>
<a name="ln969">               */</a>
<a name="ln970"> </a>
<a name="ln971">          /* strings*/</a>
<a name="ln972">          case 's':</a>
<a name="ln973">          case 'S':</a>
<a name="ln974">               nItemLen = strlen(va_arg(argList, char*));</a>
<a name="ln975">               nItemLen = inchi_max(1, nItemLen);</a>
<a name="ln976">               break;</a>
<a name="ln977">          case 's'|FORCE_ANSI:</a>
<a name="ln978">          case 'S'|FORCE_ANSI:</a>
<a name="ln979">               nItemLen = strlen(va_arg(argList, char*));</a>
<a name="ln980">               nItemLen = inchi_max(1, nItemLen);</a>
<a name="ln981">               break;</a>
<a name="ln982"> </a>
<a name="ln983">          case 's'|FORCE_UNICODE:</a>
<a name="ln984">          case 'S'|FORCE_UNICODE:</a>
<a name="ln985">               goto exit_error;  /* no UNICODE, please */</a>
<a name="ln986">               /*</a>
<a name="ln987">               nItemLen = wcslen(va_arg(argList, wchar_t*));</a>
<a name="ln988">               nItemLen = inchi_max(1, nItemLen);</a>
<a name="ln989">               break;</a>
<a name="ln990">               */</a>
<a name="ln991"> </a>
<a name="ln992">          }</a>
<a name="ln993"> </a>
<a name="ln994">          /* adjust nItemLen for strings */</a>
<a name="ln995">          if (nItemLen != 0)</a>
<a name="ln996">          {</a>
<a name="ln997">               nItemLen = inchi_max(nItemLen, nWidth);</a>
<a name="ln998">               if (nPrecision != 0)</a>
<a name="ln999">                    nItemLen = inchi_min(nItemLen, nPrecision);</a>
<a name="ln1000">          }</a>
<a name="ln1001">          else</a>
<a name="ln1002">          {</a>
<a name="ln1003">               switch (*lpsz)</a>
<a name="ln1004">               {</a>
<a name="ln1005">               /* integers */</a>
<a name="ln1006">               case 'd':</a>
<a name="ln1007">               case 'i':</a>
<a name="ln1008">               case 'u':</a>
<a name="ln1009">               case 'x':</a>
<a name="ln1010">               case 'X':</a>
<a name="ln1011">               case 'o':</a>
<a name="ln1012">                    va_arg(argList, int);</a>
<a name="ln1013">                    nItemLen = 32;</a>
<a name="ln1014">                    nItemLen = inchi_max(nItemLen, nWidth+nPrecision);</a>
<a name="ln1015">                    break;</a>
<a name="ln1016"> </a>
<a name="ln1017">               case 'e':</a>
<a name="ln1018">               case 'f':</a>
<a name="ln1019">               case 'g':</a>
<a name="ln1020">               case 'G':</a>
<a name="ln1021">                    va_arg(argList, double);</a>
<a name="ln1022">                    nItemLen = 32;</a>
<a name="ln1023">                    nItemLen = inchi_max(nItemLen, nWidth+nPrecision);</a>
<a name="ln1024">                    break;</a>
<a name="ln1025"> </a>
<a name="ln1026">               case 'p':</a>
<a name="ln1027">                    va_arg(argList, void*);</a>
<a name="ln1028">                    nItemLen = 32;</a>
<a name="ln1029">                    nItemLen = inchi_max(nItemLen, nWidth+nPrecision);</a>
<a name="ln1030">                    break;</a>
<a name="ln1031"> </a>
<a name="ln1032">               /* no output */</a>
<a name="ln1033">               case 'n':</a>
<a name="ln1034">                    va_arg(argList, int*);</a>
<a name="ln1035">                    break;</a>
<a name="ln1036"> </a>
<a name="ln1037">               default:</a>
<a name="ln1038">                   /*ASSERT(FALSE);*/  /* unknown formatting option*/</a>
<a name="ln1039">                   goto exit_error; /* instead of exception */</a>
<a name="ln1040">               }</a>
<a name="ln1041">          }</a>
<a name="ln1042"> </a>
<a name="ln1043">          /* adjust nMaxLen for output nItemLen */</a>
<a name="ln1044">          nMaxLen += nItemLen;</a>
<a name="ln1045">     }</a>
<a name="ln1046">     return nMaxLen;</a>
<a name="ln1047"> </a>
<a name="ln1048">exit_error:</a>
<a name="ln1049">     return -1; /* wrong format */</a>
<a name="ln1050">} </a>
<a name="ln1051"> </a>

</code></pre>
<div class="balloon" rel="974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 974, 979</p></div>
<div class="balloon" rel="954"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 954, 959</p></div>
<div class="balloon" rel="1012"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1012, 1021, 1027</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

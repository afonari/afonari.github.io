
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ichiqueu.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC </a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> * </a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the </a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier </a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or </a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> * </a>
<a name="ln21"> * This library is distributed in the hope that it will be useful, </a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of </a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  </a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI) </a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> * </a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the </a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with </a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> * </a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> * </a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;string.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">/*^^^ */</a>
<a name="ln44">#include &quot;mode.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;inpdef.h&quot;</a>
<a name="ln47">#include &quot;extr_ct.h&quot;</a>
<a name="ln48">#include &quot;ichitaut.h&quot;</a>
<a name="ln49">#include &quot;ichi_bns.h&quot;</a>
<a name="ln50">/*^^^ */</a>
<a name="ln51"> </a>
<a name="ln52">/*******************************************************************/</a>
<a name="ln53"> </a>
<a name="ln54">#if ( FIND_RING_SYSTEMS == 1 ) /* { */</a>
<a name="ln55"> </a>
<a name="ln56">/* local prototypes */</a>
<a name="ln57">int are_alt_bonds( U_CHAR *bonds, int len );</a>
<a name="ln58">int AddBondsPos( inp_ATOM *atom, T_BONDPOS *BondPosTmp, int nNumBondPosTmp, T_BONDPOS *BondPos, int nMaxNumBondPos, int nNumBondPos );</a>
<a name="ln59">int AddEndPoints( T_ENDPOINT *EndPointTmp, int nNumNewEndPoint, T_ENDPOINT *EndPoint, int nMaxNumEndPoint, int nNumEndPoint);</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">/******************************************</a>
<a name="ln66"> *</a>
<a name="ln67"> *  Tautomerism in 5- and 6-member rings</a>
<a name="ln68"> *</a>
<a name="ln69"> ******************************************/</a>
<a name="ln70"> </a>
<a name="ln71">const int NONE = (AT_RANK)~0;</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">/* </a>
<a name="ln75">  1,5 Tautomerism in 6-member alt ring:</a>
<a name="ln76"> </a>
<a name="ln77">   /=\          /==\</a>
<a name="ln78"> HN   C=O  &lt;-&gt; N    C-OH</a>
<a name="ln79">   \=/          \\-//</a>
<a name="ln80">    </a>
<a name="ln81"> </a>
<a name="ln82">   1,2 Tautomerism in 5-member ring:</a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">  HN--X           N==X  </a>
<a name="ln86">   |   \\         |   \</a>
<a name="ln87">   |    Z  &lt;-&gt;    |    Z</a>
<a name="ln88">   |   /          |   //</a>
<a name="ln89">   N==Y          HN--Y</a>
<a name="ln90">   </a>
<a name="ln91"> </a>
<a name="ln92">  1,4 tautomerism in 7-member ring</a>
<a name="ln93"> </a>
<a name="ln94">      /C==D             //C-D  </a>
<a name="ln95">   O=B     \        HO-B     \\</a>
<a name="ln96">     |      E  &lt;-&gt;     |      E</a>
<a name="ln97">  HO-A     //        O=A     / </a>
<a name="ln98">      \\G-F             \\G-F  </a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">  1,4 tautomerism in 5-member ring</a>
<a name="ln102"> </a>
<a name="ln103">             </a>
<a name="ln104">   O=B--C            O-B==C   </a>
<a name="ln105">     |   \\            |   \  </a>
<a name="ln106">     |     D  &lt;-&gt;      |     D</a>
<a name="ln107">     |   /             |   // </a>
<a name="ln108">  HO-A==E           HO=A--E   </a>
<a name="ln109"> </a>
<a name="ln110">*/</a>
<a name="ln111">typedef int CHECK_DFS_RING( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int nStartAtomNeighbor,</a>
<a name="ln112">                        int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln113">                        T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln114">                        T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln115">                        int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln116">                        struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD, int num_atoms );</a>
<a name="ln117"> </a>
<a name="ln118">typedef int CHECK_CENTERPOINT ( inp_ATOM *atom, int iat );</a>
<a name="ln119"> </a>
<a name="ln120">CHECK_DFS_RING Check7MembTautRing;</a>
<a name="ln121">CHECK_DFS_RING Check6MembTautRing;</a>
<a name="ln122">CHECK_DFS_RING Check5MembTautRing;</a>
<a name="ln123"> </a>
<a name="ln124">#if ( TAUT_15_NON_RING == 1 )  /* post v.1 feature */</a>
<a name="ln125">/* DFS simple alt path for 1,5 tautomerism, post v.1 feature */</a>
<a name="ln126">typedef int CHECK_DFS_PATH( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int jNxtNeigh, int nStartAtomNeighbor,</a>
<a name="ln127">                        int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln128">                        T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln129">                        T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln130">                        int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln131">                        struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD, int num_atoms );</a>
<a name="ln132"> </a>
<a name="ln133">typedef int CHECK_DFS_CENTERPOINT( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int jNxtNeigh,</a>
<a name="ln134">                        struct BalancedNetworkStructure *pBNS,</a>
<a name="ln135">                        struct BalancedNetworkData *pBD, int num_atoms );</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138">CHECK_DFS_PATH        Check15TautPath;</a>
<a name="ln139">CHECK_DFS_CENTERPOINT Check15TautPathCenterpoint;</a>
<a name="ln140"> </a>
<a name="ln141">int DFS_FindTautAltPath( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln142">                      int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln143">                      int nCycleLen,</a>
<a name="ln144">                      AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath,</a>
<a name="ln145">                      CHECK_DFS_PATH *CheckDfsPath, CHECK_DFS_CENTERPOINT *CheckCenterPoint,</a>
<a name="ln146">                      T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln147">                      T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln148">                      int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln149">                      struct BalancedNetworkStructure *pBNS,</a>
<a name="ln150">                      struct BalancedNetworkData *pBD, int num_atoms );</a>
<a name="ln151"> </a>
<a name="ln152">#define BOND_WRONG 64</a>
<a name="ln153">#define IS_ALT_OR_DBLBOND(X) (((X) == BOND_SINGLE || (X) == BOND_DOUBLE)? (X) : \</a>
<a name="ln154">                              ((X) == BOND_ALTERN || (X) == BOND_TAUTOM || (X) == BOND_ALT12NS)? BOND_ALTERN : \</a>
<a name="ln155">                              BOND_WRONG);</a>
<a name="ln156"> </a>
<a name="ln157">#endif /* TAUT_15_NON_RING */</a>
<a name="ln158"> </a>
<a name="ln159">int DFS_FindTautInARing( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln160">                      int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln161">                      int nCycleLen,</a>
<a name="ln162">                      AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath,</a>
<a name="ln163">                      CHECK_DFS_RING *CheckDfsRing, CHECK_CENTERPOINT *CheckCenterPoint,</a>
<a name="ln164">                      T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln165">                      T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln166">                      int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln167">                      struct BalancedNetworkStructure *pBNS, struct BalancedNetworkData *pBD, int num_atoms );</a>
<a name="ln168"> </a>
<a name="ln169">#if ( REPLACE_ALT_WITH_TAUT == 1 )</a>
<a name="ln170">#define REPLACE_THE_BOND(X) ( (X) == BOND_SINGLE || (X) == BOND_DOUBLE || (X) == BOND_ALTERN || (X) == BOND_ALT12NS )</a>
<a name="ln171">#else</a>
<a name="ln172">#define REPLACE_THE_BOND(X) ( (X) == BOND_SINGLE || (X) == BOND_DOUBLE )</a>
<a name="ln173">#endif</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">int bIsCenterPointStrict( inp_ATOM *atom, int iat )</a>
<a name="ln177">{</a>
<a name="ln178">    if ( atom[iat].valence == atom[iat].chem_bonds_valence ) {</a>
<a name="ln179">        int endpoint_valence = get_endpoint_valence(atom[iat].el_number);</a>
<a name="ln180">        if ( endpoint_valence &amp;&amp; ((endpoint_valence &gt; atom[iat].valence &amp;&amp; /* added a check for negative charge or H 3-31-03 */</a>
<a name="ln181">                                   (atom[iat].num_H || atom[iat].charge == -1)) ||</a>
<a name="ln182">                                 (!atom[iat].charge &amp;&amp; atom[iat].c_point)) ) {</a>
<a name="ln183">            return 1; /*  may appear to be tautomeric or chargable</a>
<a name="ln184">                          (this increases chem_bonds_valence), should be explored */</a>
<a name="ln185">        }</a>
<a name="ln186">        return 0;</a>
<a name="ln187">    }</a>
<a name="ln188">    if (atom[iat].valence+1 == atom[iat].chem_bonds_valence &amp;&amp;</a>
<a name="ln189">        is_centerpoint_elem_strict( atom[iat].el_number ) ) {</a>
<a name="ln190">                return 1;</a>
<a name="ln191">    }</a>
<a name="ln192">    return 0;</a>
<a name="ln193">}</a>
<a name="ln194">/********************************************************************************/</a>
<a name="ln195">int nGet14TautIn7MembAltRing( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln196">                              int nStartAtomNeighborEndpoint, int nStartAtomNeighborNeighborEndpoint,</a>
<a name="ln197">                              AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath, int nMaxLenDfsPath,</a>
<a name="ln198">                              T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln199">                              T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln200">                              int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln201">                              struct BalancedNetworkStructure *pBNS,</a>
<a name="ln202">                              struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln203">{   </a>
<a name="ln204">    int nRet;</a>
<a name="ln205"> </a>
<a name="ln206">    *pnNumEndPoint = 0;</a>
<a name="ln207">    *pnNumBondPos  = 0;</a>
<a name="ln208"> </a>
<a name="ln209">    if ( nMaxLenDfsPath &lt;= 7 ) {</a>
<a name="ln210">        return -1; /*  path is too short */</a>
<a name="ln211">    }</a>
<a name="ln212"> </a>
<a name="ln213">    nRet = DFS_FindTautInARing( atom, nStartAtom, nStartAtomNeighbor,</a>
<a name="ln214">                                 nStartAtomNeighborEndpoint, nStartAtomNeighborNeighborEndpoint, 7,</a>
<a name="ln215">                                 nDfsPathPos, DfsPath,</a>
<a name="ln216">                                 Check7MembTautRing, bIsCenterPointStrict,</a>
<a name="ln217">                                 EndPoint, nMaxNumEndPoint,</a>
<a name="ln218">                                 BondPos, nMaxNumBondPos,</a>
<a name="ln219">                                 pnNumEndPoint, pnNumBondPos, </a>
<a name="ln220">                                 pBNS, pBD, num_atoms</a>
<a name="ln221">                      );</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">    return nRet;</a>
<a name="ln225">}</a>
<a name="ln226">/********************************************************************************/</a>
<a name="ln227">int nGet14TautIn5MembAltRing( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln228">                              int nStartAtomNeighborEndpoint, int nStartAtomNeighborNeighborEndpoint,</a>
<a name="ln229">                              AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath, int nMaxLenDfsPath,</a>
<a name="ln230">                              T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln231">                              T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln232">                              int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln233">                              struct BalancedNetworkStructure *pBNS,</a>
<a name="ln234">                              struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln235">{   </a>
<a name="ln236">    int nRet;</a>
<a name="ln237"> </a>
<a name="ln238">    *pnNumEndPoint = 0;</a>
<a name="ln239">    *pnNumBondPos  = 0;</a>
<a name="ln240"> </a>
<a name="ln241">    if ( nMaxLenDfsPath &lt;= 5 ) {</a>
<a name="ln242">        return -1; /*  path is too short */</a>
<a name="ln243">    }</a>
<a name="ln244"> </a>
<a name="ln245">    nRet = DFS_FindTautInARing( atom, nStartAtom, nStartAtomNeighbor,</a>
<a name="ln246">                                 nStartAtomNeighborEndpoint, nStartAtomNeighborNeighborEndpoint, 5,</a>
<a name="ln247">                                 nDfsPathPos, DfsPath,</a>
<a name="ln248">                                 Check7MembTautRing, bIsCenterPointStrict,</a>
<a name="ln249">                                 EndPoint, nMaxNumEndPoint,</a>
<a name="ln250">                                 BondPos, nMaxNumBondPos,</a>
<a name="ln251">                                 pnNumEndPoint, pnNumBondPos, </a>
<a name="ln252">                                 pBNS, pBD, num_atoms</a>
<a name="ln253">                      );</a>
<a name="ln254"> </a>
<a name="ln255"> </a>
<a name="ln256">    return nRet;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/********************************************************************************/</a>
<a name="ln260">int nGet12TautIn5MembAltRing( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln261">                              AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath, int nMaxLenDfsPath,</a>
<a name="ln262">                              T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln263">                              T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln264">                              int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln265">                              struct BalancedNetworkStructure *pBNS,</a>
<a name="ln266">                              struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln267">{</a>
<a name="ln268">    int nRet;</a>
<a name="ln269"> </a>
<a name="ln270">    *pnNumEndPoint = 0;</a>
<a name="ln271">    *pnNumBondPos  = 0;</a>
<a name="ln272"> </a>
<a name="ln273">    if ( nMaxLenDfsPath &lt;= 5 ) {</a>
<a name="ln274">        return -1; /*  path is too short */</a>
<a name="ln275">    }</a>
<a name="ln276"> </a>
<a name="ln277">    nRet = DFS_FindTautInARing( atom, nStartAtom, nStartAtomNeighbor, -1, -1, 5,</a>
<a name="ln278">                                 nDfsPathPos, DfsPath,</a>
<a name="ln279">                                 Check5MembTautRing, bIsCenterPointStrict,</a>
<a name="ln280">                                 EndPoint, nMaxNumEndPoint,</a>
<a name="ln281">                                 BondPos, nMaxNumBondPos,</a>
<a name="ln282">                                 pnNumEndPoint, pnNumBondPos, </a>
<a name="ln283">                                 pBNS, pBD, num_atoms</a>
<a name="ln284">                      );</a>
<a name="ln285">    return nRet;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/********************************************************************************/</a>
<a name="ln289">int nGet15TautIn6MembAltRing( inp_ATOM *atom, int nStartAtom, AT_RANK  *nDfsPathPos,</a>
<a name="ln290">                              DFS_PATH *DfsPath, int nMaxLenDfsPath,</a>
<a name="ln291">                              T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln292">                              T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln293">                              int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln294">                              struct BalancedNetworkStructure *pBNS,</a>
<a name="ln295">                              struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln296">{</a>
<a name="ln297">    int nRet;</a>
<a name="ln298"> </a>
<a name="ln299">    *pnNumEndPoint = 0;</a>
<a name="ln300">    *pnNumBondPos  = 0;</a>
<a name="ln301"> </a>
<a name="ln302">    if ( nMaxLenDfsPath &lt;= 7 ) {</a>
<a name="ln303">        return -1; /*  path is too short */</a>
<a name="ln304">    }</a>
<a name="ln305"> </a>
<a name="ln306">    nRet = DFS_FindTautInARing( atom, nStartAtom, -1/*nStartAtomNeighbor*/, -1/*nStartAtomNeighbor2*/,</a>
<a name="ln307">                                 -1/*nStartAtomNeighborNeighbor*/, 6 /* nCycleLen*/,</a>
<a name="ln308">                                 nDfsPathPos, DfsPath,</a>
<a name="ln309">                                 Check6MembTautRing, bIsCenterPointStrict,</a>
<a name="ln310">                                 EndPoint, nMaxNumEndPoint,</a>
<a name="ln311">                                 BondPos, nMaxNumBondPos,</a>
<a name="ln312">                                 pnNumEndPoint, pnNumBondPos,</a>
<a name="ln313">                                 pBNS, pBD, num_atoms</a>
<a name="ln314">                      );</a>
<a name="ln315">    return nRet;</a>
<a name="ln316">}</a>
<a name="ln317">#if ( TAUT_15_NON_RING      == 1 ) /***** post v.1 feature *****/</a>
<a name="ln318">/********************************************************************************/</a>
<a name="ln319">int nGet15TautInAltPath( inp_ATOM *atom, int nStartAtom, AT_RANK  *nDfsPathPos,</a>
<a name="ln320">                              DFS_PATH *DfsPath, int nMaxLenDfsPath,</a>
<a name="ln321">                              T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln322">                              T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln323">                              int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln324">                              struct BalancedNetworkStructure *pBNS,</a>
<a name="ln325">                              struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln326">{</a>
<a name="ln327">    int nRet;</a>
<a name="ln328"> </a>
<a name="ln329">    *pnNumEndPoint = 0;</a>
<a name="ln330">    *pnNumBondPos  = 0;</a>
<a name="ln331"> </a>
<a name="ln332">    if ( nMaxLenDfsPath &lt;= 7 ) {</a>
<a name="ln333">        return -1; /*  path is too short */</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">    nRet = DFS_FindTautAltPath( atom, nStartAtom, -1/*nStartAtomNeighbor*/, -1/*nStartAtomNeighbor2*/,</a>
<a name="ln337">                                 -1/*nStartAtomNeighborNeighbor*/, 4 /* nCycleLen*/,</a>
<a name="ln338">                                 nDfsPathPos, DfsPath,</a>
<a name="ln339">                                 Check15TautPath, Check15TautPathCenterpoint,</a>
<a name="ln340">                                 EndPoint, nMaxNumEndPoint,</a>
<a name="ln341">                                 BondPos, nMaxNumBondPos,</a>
<a name="ln342">                                 pnNumEndPoint, pnNumBondPos,</a>
<a name="ln343">                                 pBNS, pBD, num_atoms</a>
<a name="ln344">                      );</a>
<a name="ln345">    return nRet;</a>
<a name="ln346">}</a>
<a name="ln347">#endif</a>
<a name="ln348">/********************************************************************************/</a>
<a name="ln349">/*  DFS version */</a>
<a name="ln350">#define MAX_DFS_DEPTH 16</a>
<a name="ln351"> </a>
<a name="ln352">/********************************************************************************/</a>
<a name="ln353">int DFS_FindTautInARing( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln354">                      int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln355">                      int nCycleLen,</a>
<a name="ln356">                      AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath,</a>
<a name="ln357">                      CHECK_DFS_RING *CheckDfsRing, CHECK_CENTERPOINT *CheckCenterPoint,</a>
<a name="ln358">                      T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln359">                      T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln360">                      int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln361">                      struct BalancedNetworkStructure *pBNS,</a>
<a name="ln362">                      struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln363">{</a>
<a name="ln364">    /*  Depth First Search */</a>
<a name="ln365">    /*  Ignore all atoms not belonging to the current ring system (=biconnected component) */</a>
<a name="ln366">    AT_RANK      nMinLenDfsPath;</a>
<a name="ln367">    int          j, cur_at, nxt_at, prv_at;</a>
<a name="ln368">    int          nLenDfsPath, nNumFound, ret;</a>
<a name="ln369">    AT_RANK      nRingSystem;</a>
<a name="ln370">    int          nDoNotTouchAtom1 = -1, nDoNotTouchAtom2 = -1;</a>
<a name="ln371"> </a>
<a name="ln372">    nLenDfsPath=0;</a>
<a name="ln373">    nNumFound=0;</a>
<a name="ln374"> </a>
<a name="ln375">    nCycleLen --;</a>
<a name="ln376">    </a>
<a name="ln377">    DfsPath[nLenDfsPath].at_no         = cur_at = nStartAtom;</a>
<a name="ln378">    DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln379">    DfsPath[nLenDfsPath].bond_pos      = -1;</a>
<a name="ln380">    nDfsPathPos[cur_at]            = nLenDfsPath+1;  /*  mark */</a>
<a name="ln381">    nRingSystem                    = atom[nStartAtom].nRingSystem;</a>
<a name="ln382">    nMinLenDfsPath                 = 0;</a>
<a name="ln383">    if ( nStartAtomNeighbor2 &gt;= 0 ) {</a>
<a name="ln384">        nDoNotTouchAtom1 = (int)atom[cur_at].neighbor[nStartAtomNeighbor2];</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    </a>
<a name="ln388">    /*  add the first neighbor to the 2nd tree position if required */</a>
<a name="ln389">    if ( nStartAtomNeighbor &gt;= 0 ) {</a>
<a name="ln390">        j = nStartAtomNeighbor;</a>
<a name="ln391">        prv_at = cur_at;</a>
<a name="ln392">        cur_at = atom[prv_at].neighbor[j];</a>
<a name="ln393">        DfsPath[nLenDfsPath].bond_type     = (atom[prv_at].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln394">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln395">        DfsPath[nLenDfsPath].bond_type = ACTUAL_ORDER(pBNS,prv_at,j,DfsPath[nLenDfsPath].bond_type);</a>
<a name="ln396">#endif</a>
<a name="ln397">        DfsPath[nLenDfsPath].bond_pos      = j;</a>
<a name="ln398"> </a>
<a name="ln399">        nLenDfsPath ++;</a>
<a name="ln400"> </a>
<a name="ln401">        DfsPath[nLenDfsPath].at_no         = cur_at;</a>
<a name="ln402">        DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln403">        DfsPath[nLenDfsPath].bond_pos      = -1;</a>
<a name="ln404">        nDfsPathPos[cur_at]                = nLenDfsPath+1;</a>
<a name="ln405">        nMinLenDfsPath ++;</a>
<a name="ln406">        if ( nStartAtomNeighborNeighbor &gt;= 0 ) {</a>
<a name="ln407">            nDoNotTouchAtom2 = (int)atom[cur_at].neighbor[nStartAtomNeighborNeighbor];</a>
<a name="ln408">        }</a>
<a name="ln409">    }</a>
<a name="ln410"> </a>
<a name="ln411">    /*  MAIN DFS CYCLE: may find one and the same t-group 2 times; saves only one instance */</a>
<a name="ln412">    /*  traverse *all* paths starting at atom[nStartAtom]; max. path length = (nCycleLen+1)  */</a>
<a name="ln413">    while ( nLenDfsPath &gt;= nMinLenDfsPath ) {</a>
<a name="ln414">        j = ++DfsPath[nLenDfsPath].bond_pos;</a>
<a name="ln415">        if ( j &lt; atom[cur_at=(int)DfsPath[nLenDfsPath].at_no].valence ) {</a>
<a name="ln416">            DfsPath[nLenDfsPath].bond_type = (atom[cur_at].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln417">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln418">            DfsPath[nLenDfsPath].bond_type = ACTUAL_ORDER(pBNS,cur_at,j,DfsPath[nLenDfsPath].bond_type);</a>
<a name="ln419">#endif</a>
<a name="ln420">            nxt_at = (int)atom[cur_at].neighbor[j];</a>
<a name="ln421">            if ( nxt_at == nDoNotTouchAtom1 ||</a>
<a name="ln422">                 nxt_at == nDoNotTouchAtom2  ) {</a>
<a name="ln423">                ; /*  ignore */</a>
<a name="ln424">            } else</a>
<a name="ln425">            if ( nDfsPathPos[nxt_at] ) {</a>
<a name="ln426">                /*  found a ring closure or a step backwards */</a>
<a name="ln427">                if ( 1 == nDfsPathPos[nxt_at] &amp;&amp; nLenDfsPath == nCycleLen ) {</a>
<a name="ln428">                    /*  we have found the cycle; check it */</a>
<a name="ln429">                    ret = (*CheckDfsRing)( atom, DfsPath, nLenDfsPath, nStartAtomNeighbor,</a>
<a name="ln430">                                           nStartAtomNeighbor2, nStartAtomNeighborNeighbor,</a>
<a name="ln431">                                           EndPoint, nMaxNumEndPoint, BondPos, nMaxNumBondPos,</a>
<a name="ln432">                                           pnNumEndPoint, pnNumBondPos, </a>
<a name="ln433">                                           pBNS, pBD, num_atoms</a>
<a name="ln434">                      );</a>
<a name="ln435">                    if ( ret &lt; 0 ) {</a>
<a name="ln436">                        nNumFound = ret;</a>
<a name="ln437">                        goto clear_path;</a>
<a name="ln438">                    }</a>
<a name="ln439">                    nNumFound += ret;</a>
<a name="ln440"> </a>
<a name="ln441">                }</a>
<a name="ln442">            } else</a>
<a name="ln443">            if ( !(*CheckCenterPoint)( atom, nxt_at ) ) {</a>
<a name="ln444">                ; /*  cannot advance to a non-centerpoint; ignore */</a>
<a name="ln445">            } else</a>
<a name="ln446">            if ( nLenDfsPath &lt; nCycleLen ) {</a>
<a name="ln447">                /*  advance */</a>
<a name="ln448">                nLenDfsPath ++;</a>
<a name="ln449">                cur_at = nxt_at;</a>
<a name="ln450">                DfsPath[nLenDfsPath].at_no         = cur_at;</a>
<a name="ln451">                DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln452">                DfsPath[nLenDfsPath].bond_pos      = -1;</a>
<a name="ln453">                nDfsPathPos[cur_at]                = nLenDfsPath+1;  /*  mark */</a>
<a name="ln454">            }</a>
<a name="ln455">        } else {</a>
<a name="ln456">            /*  retract */</a>
<a name="ln457">            nDfsPathPos[(int)DfsPath[nLenDfsPath].at_no] = 0;</a>
<a name="ln458">            nLenDfsPath --;</a>
<a name="ln459">        }</a>
<a name="ln460">    }</a>
<a name="ln461">clear_path:</a>
<a name="ln462">    while ( 0 &lt;= nLenDfsPath ) {</a>
<a name="ln463">        nDfsPathPos[(int)DfsPath[nLenDfsPath].at_no] = 0;</a>
<a name="ln464">        nLenDfsPath --;</a>
<a name="ln465">    }</a>
<a name="ln466">    return nNumFound;</a>
<a name="ln467">}</a>
<a name="ln468">#if ( TAUT_15_NON_RING      == 1 ) /***** post v.1 feature *****/</a>
<a name="ln469">/********************************************************************************/</a>
<a name="ln470">int DFS_FindTautAltPath( inp_ATOM *atom, int nStartAtom, int nStartAtomNeighbor,</a>
<a name="ln471">                      int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln472">                      int nCycleLen,</a>
<a name="ln473">                      AT_RANK  *nDfsPathPos, DFS_PATH *DfsPath,</a>
<a name="ln474">                      CHECK_DFS_PATH *CheckDfsPath, CHECK_DFS_CENTERPOINT *CheckCenterPointPath,</a>
<a name="ln475">                      T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln476">                      T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln477">                      int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln478">                      struct BalancedNetworkStructure *pBNS,</a>
<a name="ln479">                      struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln480">{</a>
<a name="ln481">    /*  Naive Depth First Search: same atom may be approached along different alt paths */</a>
<a name="ln482">    /*  Ignore all atoms not belonging to the current ring system (=biconnected component) */</a>
<a name="ln483">    AT_RANK      nMinLenDfsPath;</a>
<a name="ln484">    int          j, cur_at, nxt_at, prv_at;</a>
<a name="ln485">    int          nLenDfsPath, nNumFound, ret;</a>
<a name="ln486">    AT_RANK      nRingSystem;</a>
<a name="ln487">    int          nDoNotTouchAtom1 = -1, nDoNotTouchAtom2 = -1;</a>
<a name="ln488"> </a>
<a name="ln489">    nLenDfsPath=0;</a>
<a name="ln490">    nNumFound=0;</a>
<a name="ln491"> </a>
<a name="ln492">    nCycleLen --; /* indef of the last atom in the alt path, statring from 0 */</a>
<a name="ln493">    </a>
<a name="ln494">    DfsPath[nLenDfsPath].at_no         = cur_at = nStartAtom;</a>
<a name="ln495">    DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln496">    DfsPath[nLenDfsPath].bond_pos      = -1;  /* initialize index of the bond to the next atom */</a>
<a name="ln497">    nDfsPathPos[cur_at]            = nLenDfsPath+1;  /*  mark with distance + 1 */</a>
<a name="ln498">    nRingSystem                    = atom[nStartAtom].nRingSystem;</a>
<a name="ln499">    nMinLenDfsPath                 = 0;  /* allow to restart from nStartAtom */</a>
<a name="ln500">    if ( nStartAtomNeighbor2 &gt;= 0 ) {</a>
<a name="ln501">        nDoNotTouchAtom1 = (int)atom[cur_at].neighbor[nStartAtomNeighbor2];</a>
<a name="ln502">    }</a>
<a name="ln503"> </a>
<a name="ln504">    </a>
<a name="ln505">    /*  add the first neighbor to the 2nd tree position if required */</a>
<a name="ln506">    if ( nStartAtomNeighbor &gt;= 0 ) {</a>
<a name="ln507">        j = nStartAtomNeighbor;</a>
<a name="ln508">        prv_at = cur_at;</a>
<a name="ln509">        cur_at = atom[prv_at].neighbor[j];</a>
<a name="ln510">        DfsPath[nLenDfsPath].bond_type     = (atom[prv_at].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln511">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln512">        DfsPath[nLenDfsPath].bond_type = ACTUAL_ORDER(pBNS,prv_at,j,DfsPath[nLenDfsPath].bond_type);</a>
<a name="ln513">#endif</a>
<a name="ln514">        DfsPath[nLenDfsPath].bond_pos      = j; /* fix index of the bond to the next atom */</a>
<a name="ln515"> </a>
<a name="ln516">        nLenDfsPath ++;</a>
<a name="ln517"> </a>
<a name="ln518">        DfsPath[nLenDfsPath].at_no         = cur_at;</a>
<a name="ln519">        DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln520">        DfsPath[nLenDfsPath].bond_pos      = -1;</a>
<a name="ln521">        nDfsPathPos[cur_at]                = nLenDfsPath+1; /* mark with distance + 1 */</a>
<a name="ln522">        nMinLenDfsPath ++;                 /* allow to restart from nStartAtom's neighbor */</a>
<a name="ln523">        if ( nStartAtomNeighborNeighbor &gt;= 0 ) {</a>
<a name="ln524">            nDoNotTouchAtom2 = (int)atom[cur_at].neighbor[nStartAtomNeighborNeighbor];</a>
<a name="ln525">        }</a>
<a name="ln526">    }</a>
<a name="ln527"> </a>
<a name="ln528">    /*  MAIN DFS CYCLE: may find one and the same t-group 2 times; saves only one instance */</a>
<a name="ln529">    /*  traverse *all* paths starting at atom[nStartAtom]; max. path length = (nCycleLen+1)  */</a>
<a name="ln530">    while ( nLenDfsPath &gt;= nMinLenDfsPath ) {</a>
<a name="ln531">        j = ++DfsPath[nLenDfsPath].bond_pos;</a>
<a name="ln532">        if ( j &lt; atom[cur_at=(int)DfsPath[nLenDfsPath].at_no].valence ) {</a>
<a name="ln533">            DfsPath[nLenDfsPath].bond_type = (atom[cur_at].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln534">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln535">            DfsPath[nLenDfsPath].bond_type = ACTUAL_ORDER(pBNS,cur_at,j,DfsPath[nLenDfsPath].bond_type);</a>
<a name="ln536">#endif</a>
<a name="ln537">            nxt_at = (int)atom[cur_at].neighbor[j];</a>
<a name="ln538">            if ( nxt_at == nDoNotTouchAtom1 || /* forbidden */</a>
<a name="ln539">                 nxt_at == nDoNotTouchAtom2 || /* forbidden */</a>
<a name="ln540">                 nDfsPathPos[nxt_at]        || /* ring closure */</a>
<a name="ln541">                 (nLenDfsPath &amp;&amp; nxt_at == (int)DfsPath[nLenDfsPath-1].at_no) /* step backwards */</a>
<a name="ln542">                 ) {</a>
<a name="ln543">                ; /* ignore nxt_at */</a>
<a name="ln544">            } else</a>
<a name="ln545">            if ( nLenDfsPath == nCycleLen &amp;&amp;</a>
<a name="ln546">                 /* 1,5 and at least one of the endpoints is not in a ring */</a>
<a name="ln547">                 (atom[nxt_at].nNumAtInRingSystem == 1 || atom[nStartAtom].nNumAtInRingSystem == 1)  &amp;&amp;</a>
<a name="ln548">                /*  we have found the alt path of the requested length; check it */</a>
<a name="ln549">                /* calling Check15TautPath() */</a>
<a name="ln550">                (ret = (*CheckDfsPath)( atom, DfsPath, nLenDfsPath, j, nStartAtomNeighbor,</a>
<a name="ln551">                                       nStartAtomNeighbor2, nStartAtomNeighborNeighbor,</a>
<a name="ln552">                                       EndPoint, nMaxNumEndPoint, BondPos, nMaxNumBondPos,</a>
<a name="ln553">                                       pnNumEndPoint, pnNumBondPos, </a>
<a name="ln554">                                       pBNS, pBD, num_atoms ) ) ) {</a>
<a name="ln555">                if ( ret &lt; 0 ) {</a>
<a name="ln556">                    nNumFound = ret;</a>
<a name="ln557">                    goto clear_path; /* program error */</a>
<a name="ln558">                }</a>
<a name="ln559">                nNumFound += ret; /* success */</a>
<a name="ln560">            } else /* calling Check15TautPathCenterpoint() */</a>
<a name="ln561">            if ( !(*CheckCenterPointPath)( atom, DfsPath, nLenDfsPath, j,</a>
<a name="ln562">                                       pBNS, pBD, num_atoms  ) ) {</a>
<a name="ln563">                ; /*  cannot advance to a non-centerpoint; ignore */</a>
<a name="ln564">            } else</a>
<a name="ln565">            if ( nLenDfsPath &lt; nCycleLen ) {</a>
<a name="ln566">                /*  advance */</a>
<a name="ln567">                nLenDfsPath ++;</a>
<a name="ln568">                cur_at = nxt_at;</a>
<a name="ln569">                DfsPath[nLenDfsPath].at_no         = cur_at;</a>
<a name="ln570">                DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln571">                DfsPath[nLenDfsPath].bond_pos      = -1;</a>
<a name="ln572">                nDfsPathPos[cur_at]                = nLenDfsPath+1;  /*  mark */</a>
<a name="ln573">            }</a>
<a name="ln574">        } else {</a>
<a name="ln575">            /*  retract */</a>
<a name="ln576">            nDfsPathPos[(int)DfsPath[nLenDfsPath].at_no] = 0;</a>
<a name="ln577">            nLenDfsPath --;</a>
<a name="ln578">        }</a>
<a name="ln579">    }</a>
<a name="ln580">clear_path:</a>
<a name="ln581">    while ( 0 &lt;= nLenDfsPath ) {</a>
<a name="ln582">        nDfsPathPos[(int)DfsPath[nLenDfsPath].at_no] = 0;</a>
<a name="ln583">        nLenDfsPath --;</a>
<a name="ln584">    }</a>
<a name="ln585">    return nNumFound;</a>
<a name="ln586">}</a>
<a name="ln587">#endif /* TAUT_15_NON_RING */     </a>
<a name="ln588">/*******************************************</a>
<a name="ln589"> *      check if bonds are alternating     */</a>
<a name="ln590">int are_alt_bonds( U_CHAR *bonds, int len )</a>
<a name="ln591">{</a>
<a name="ln592">    U_CHAR next_bond;</a>
<a name="ln593">    int           i, bAnyBond, bTautBondPresent=BOND_ALTERN;</a>
<a name="ln594">    if ( len &lt; 2 || bonds[0] == BOND_TRIPLE || bonds[0] == BOND_ALT_13 ) {</a>
<a name="ln595">        return 0;</a>
<a name="ln596">    }</a>
<a name="ln597">    next_bond = bonds[0]==BOND_SINGLE? BOND_DOUBLE : bonds[0]==BOND_DOUBLE? BOND_SINGLE : 0;</a>
<a name="ln598">    if ( bonds[0] == BOND_TAUTOM ) {</a>
<a name="ln599">        bTautBondPresent= BOND_TAUTOM;</a>
<a name="ln600">        next_bond = 0;</a>
<a name="ln601">    } else {</a>
<a name="ln602">        next_bond = bonds[0]==BOND_SINGLE? BOND_DOUBLE : bonds[0]==BOND_DOUBLE? BOND_SINGLE : 0;</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    for ( i = 1; i &lt; len; i ++ ) {</a>
<a name="ln606">        if ( bonds[i] == BOND_TAUTOM ) {</a>
<a name="ln607">            bTautBondPresent = BOND_TAUTOM;</a>
<a name="ln608">            bAnyBond         = 1;</a>
<a name="ln609">        } else {</a>
<a name="ln610">            bAnyBond = (bonds[i] == BOND_ALTERN || bonds[i] == BOND_ALT12NS);</a>
<a name="ln611">        }</a>
<a name="ln612">        if ( next_bond ) {</a>
<a name="ln613">            if ( bonds[i] == next_bond || bAnyBond ) {</a>
<a name="ln614">                next_bond = (next_bond == BOND_SINGLE)? BOND_DOUBLE : BOND_SINGLE;</a>
<a name="ln615">                continue;</a>
<a name="ln616">            }</a>
<a name="ln617">            return 0;</a>
<a name="ln618">        } else</a>
<a name="ln619">        if ( bonds[i] == BOND_SINGLE ) {</a>
<a name="ln620">            next_bond = BOND_DOUBLE;</a>
<a name="ln621">            continue;</a>
<a name="ln622">        } else</a>
<a name="ln623">        if ( bonds[i] == BOND_DOUBLE ) {</a>
<a name="ln624">            next_bond = BOND_SINGLE;</a>
<a name="ln625">            continue;</a>
<a name="ln626">        } else</a>
<a name="ln627">        if ( !bAnyBond ) {</a>
<a name="ln628">            return 0;</a>
<a name="ln629">        }</a>
<a name="ln630">    }</a>
<a name="ln631">    return !next_bond? bTautBondPresent :</a>
<a name="ln632">           (next_bond == BOND_SINGLE)? BOND_DOUBLE : BOND_SINGLE; /* bond to the end atom */</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">/********************************************************************************/</a>
<a name="ln636">int AddBondsPos( inp_ATOM *atom, T_BONDPOS *BondPosTmp, int nNumBondPosTmp, T_BONDPOS *BondPos,</a>
<a name="ln637">                 int nMaxNumBondPos, int nNumBondPos )</a>
<a name="ln638">{</a>
<a name="ln639">    int i, j, k, cur_at, nxt_at;</a>
<a name="ln640">    /*  add opposite direction bonds to BondPosTmp */</a>
<a name="ln641">    for ( j = 0; j &lt; nNumBondPosTmp; j += 2 ) {</a>
<a name="ln642">        cur_at = BondPosTmp[j].nAtomNumber;</a>
<a name="ln643">        nxt_at = atom[cur_at].neighbor[(int)BondPosTmp[j].neighbor_index];</a>
<a name="ln644">        for ( k = 0; k &lt; atom[nxt_at].valence; k ++ ) {</a>
<a name="ln645">            if ( cur_at == atom[nxt_at].neighbor[k] ) {</a>
<a name="ln646">                BondPosTmp[j+1].nAtomNumber = nxt_at;</a>
<a name="ln647">                BondPosTmp[j+1].neighbor_index = k;</a>
<a name="ln648">                break;</a>
<a name="ln649">            }</a>
<a name="ln650">        }</a>
<a name="ln651">    }</a>
<a name="ln652">    /*  add new tautomeric bonds */</a>
<a name="ln653">    for ( j = 0; j &lt; nNumBondPosTmp; j += 2 ) {</a>
<a name="ln654">        for ( i = 0; i &lt; nNumBondPos; i ++ ) {</a>
<a name="ln655">            if ( (BondPos[i].nAtomNumber    == BondPosTmp[j].nAtomNumber &amp;&amp;</a>
<a name="ln656">                 BondPos[i].neighbor_index == BondPosTmp[j].neighbor_index) ||</a>
<a name="ln657">                 (BondPos[i].nAtomNumber    == BondPosTmp[j+1].nAtomNumber &amp;&amp;</a>
<a name="ln658">                 BondPos[i].neighbor_index == BondPosTmp[j+1].neighbor_index) ) {</a>
<a name="ln659">                break; /*  bond has already been added */</a>
<a name="ln660">            }</a>
<a name="ln661">        }</a>
<a name="ln662">        if ( i == nNumBondPos ) {</a>
<a name="ln663">            if ( i &gt; nMaxNumBondPos ) {</a>
<a name="ln664">                return -1; /*  overflow */</a>
<a name="ln665">            }</a>
<a name="ln666">            BondPos[nNumBondPos ++]    = BondPosTmp[j];</a>
<a name="ln667">        }</a>
<a name="ln668">    }</a>
<a name="ln669">    return nNumBondPos;</a>
<a name="ln670">}</a>
<a name="ln671">/********************************************************************************/</a>
<a name="ln672">int AddEndPoints( T_ENDPOINT *EndPointTmp, int nNumNewEndPoint, T_ENDPOINT *EndPoint,</a>
<a name="ln673">                  int nMaxNumEndPoint, int nNumEndPoint)</a>
<a name="ln674">{</a>
<a name="ln675">    int i, j;</a>
<a name="ln676">    /*  add new endpoints */</a>
<a name="ln677">    for ( j = 0; j &lt; nNumNewEndPoint; j ++ ) {</a>
<a name="ln678">        for ( i = 0; i &lt; nNumEndPoint; i ++ ) {</a>
<a name="ln679">            if ( EndPoint[i].nAtomNumber == EndPointTmp[j].nAtomNumber ) {</a>
<a name="ln680">                break;</a>
<a name="ln681">            }</a>
<a name="ln682">        }</a>
<a name="ln683">        if ( i == nNumEndPoint ) {</a>
<a name="ln684">            if ( i &gt; nMaxNumEndPoint ) {</a>
<a name="ln685">                return -1; /*  overflow */</a>
<a name="ln686">            }</a>
<a name="ln687">            EndPoint[nNumEndPoint ++] = EndPointTmp[j];</a>
<a name="ln688">        }</a>
<a name="ln689">    }</a>
<a name="ln690">    return nNumEndPoint;</a>
<a name="ln691">}</a>
<a name="ln692">/********************************************************************************/</a>
<a name="ln693">/* </a>
<a name="ln694"> </a>
<a name="ln695">  1,4 tautomerism in 7-member ring</a>
<a name="ln696"> </a>
<a name="ln697">      /C==D             //C-D          A=DfsPath[0].at_no</a>
<a name="ln698">   O=B     \        HO-B     \\        B=DfsPath[1].at_no</a>
<a name="ln699">     |      E  &lt;-&gt;     |      E        nStartAtomNeighbor2:        from A to HO</a>
<a name="ln700">  HO-A     //        O=A     /         nStartAtomNeighborNeighbor: from B to O</a>
<a name="ln701">      \\G-F             \\G-F  </a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">  1,4 tautomerism in 5-member ring</a>
<a name="ln705"> </a>
<a name="ln706">             </a>
<a name="ln707">   O=B--C            O-B==C   </a>
<a name="ln708">     |   \\            |   \  </a>
<a name="ln709">     |     D  &lt;-&gt;      |     D</a>
<a name="ln710">     |   /             |   // </a>
<a name="ln711">  HO-A==E           HO=A--E   </a>
<a name="ln712"> </a>
<a name="ln713">*/</a>
<a name="ln714">/********************************************************************************/</a>
<a name="ln715">int Check7MembTautRing( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int nStartAtomNeighbor,</a>
<a name="ln716">                        int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln717">                        T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln718">                        T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln719">                        int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln720">                        struct BalancedNetworkStructure *pBNS,</a>
<a name="ln721">                        struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln722">{</a>
<a name="ln723">#define PATH_LEN 8</a>
<a name="ln724"> </a>
<a name="ln725">    int i, j, k, /*m,*/ nNumEndPoint, nNumEndPointTmp, nNumBondPos, nNumBondPosTmp;</a>
<a name="ln726">    int endpoint, /*nMobile, nMobile1, nMobile2,*/ o1_at, o2_at;</a>
<a name="ln727">    int ret;</a>
<a name="ln728">    U_CHAR path_bonds[PATH_LEN+1], bond_type;</a>
<a name="ln729">    T_ENDPOINT EndPointTmp[2];</a>
<a name="ln730">    T_BONDPOS  BondPosTmp[2*PATH_LEN];</a>
<a name="ln731">    ENDPOINT_INFO eif1, eif2;</a>
<a name="ln732">    int nErr=0;</a>
<a name="ln733"> </a>
<a name="ln734"> </a>
<a name="ln735">    if ( nLenDfsPath + 2 &gt; PATH_LEN ) {</a>
<a name="ln736">        return -1; /*  too long path */</a>
<a name="ln737">    }</a>
<a name="ln738">    if ( nLenDfsPath != 6 &amp;&amp; nLenDfsPath != 4 ) {</a>
<a name="ln739">        return -1; /*  wrong call */</a>
<a name="ln740">    }</a>
<a name="ln741"> </a>
<a name="ln742"> </a>
<a name="ln743">    nNumBondPos  = *pnNumBondPos;</a>
<a name="ln744">    nNumEndPoint = *pnNumEndPoint;</a>
<a name="ln745">    nNumBondPosTmp  = 0;</a>
<a name="ln746">    nNumEndPointTmp = 0;</a>
<a name="ln747">    ret             = 0;</a>
<a name="ln748"> </a>
<a name="ln749">    o1_at = atom[(int)DfsPath[1].at_no].neighbor[nStartAtomNeighborNeighbor];</a>
<a name="ln750">    o2_at = atom[(int)DfsPath[0].at_no].neighbor[nStartAtomNeighbor2];</a>
<a name="ln751">    /*</a>
<a name="ln752">    nMobile1 = (atom[o1_at].charge == -1) + atom[o1_at].num_H;</a>
<a name="ln753">    nMobile2 = (atom[o2_at].charge == -1) + atom[o2_at].num_H;</a>
<a name="ln754">    */</a>
<a name="ln755">    if ( !nGetEndpointInfo( atom, o1_at, &amp;eif1 ) ||</a>
<a name="ln756">         !nGetEndpointInfo( atom, o2_at, &amp;eif2 ) ) {</a>
<a name="ln757">        return 0;</a>
<a name="ln758">    }</a>
<a name="ln759"> </a>
<a name="ln760">    /*  save endpoints */</a>
<a name="ln761">    for ( j = 0; j &lt; 2; j ++ ) {</a>
<a name="ln762">        endpoint = j? o2_at : o1_at;</a>
<a name="ln763">        if ( !atom[endpoint].endpoint ) {</a>
<a name="ln764">            AddAtom2num( EndPointTmp[nNumEndPointTmp].num, atom, endpoint, 2 ); /* fill out */</a>
<a name="ln765">            AddAtom2DA( EndPointTmp[nNumEndPointTmp].num_DA, atom, endpoint, 2 );</a>
<a name="ln766">     /*</a>
<a name="ln767">            nMobile  = j? nMobile2 : nMobile1;</a>
<a name="ln768">        } else {</a>
<a name="ln769">            nMobile  = 0;</a>
<a name="ln770">        }</a>
<a name="ln771">        if ( nMobile ) {</a>
<a name="ln772">            EndPointTmp[nNumEndPointTmp].num[1] = (atom[endpoint].charge == -1);</a>
<a name="ln773">            EndPointTmp[nNumEndPointTmp].num[0] = nMobile;</a>
<a name="ln774">            for ( m = 0; m &lt; T_NUM_ISOTOPIC; m ++ ) {</a>
<a name="ln775">                EndPointTmp[nNumEndPointTmp].num[T_NUM_NO_ISOTOPIC+m] = atom[endpoint].num_iso_H[NUM_H_ISOTOPES-m-1];</a>
<a name="ln776">            }</a>
<a name="ln777">     */</a>
<a name="ln778">        } else {</a>
<a name="ln779">            memset( EndPointTmp + nNumEndPointTmp, 0, sizeof(EndPointTmp[0]) );</a>
<a name="ln780">        }</a>
<a name="ln781">        EndPointTmp[nNumEndPointTmp].nAtomNumber  = endpoint;</a>
<a name="ln782">        EndPointTmp[nNumEndPointTmp].nGroupNumber = atom[endpoint].endpoint;</a>
<a name="ln783">        EndPointTmp[nNumEndPointTmp].nEquNumber   = 0;</a>
<a name="ln784">        nNumEndPointTmp ++;</a>
<a name="ln785">    }</a>
<a name="ln786">    </a>
<a name="ln787"> </a>
<a name="ln788">    /*  extract bonds */</a>
<a name="ln789">    k = (int)DfsPath[1].at_no;</a>
<a name="ln790">    bond_type = (atom[k].bond_type[nStartAtomNeighborNeighbor] &amp; ~BOND_MARK_ALL);</a>
<a name="ln791">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln792">    bond_type = ACTUAL_ORDER(pBNS,k,nStartAtomNeighborNeighbor,bond_type);</a>
<a name="ln793">#endif</a>
<a name="ln794">    path_bonds[0] = bond_type;</a>
<a name="ln795">    if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln796">        BondPosTmp[nNumBondPosTmp].nAtomNumber = k;</a>
<a name="ln797">        BondPosTmp[nNumBondPosTmp].neighbor_index = nStartAtomNeighborNeighbor;</a>
<a name="ln798">        nNumBondPosTmp += 2;</a>
<a name="ln799">    }</a>
<a name="ln800">    for ( i = 1; i &lt;= nLenDfsPath; i ++ ) {</a>
<a name="ln801">        bond_type = DfsPath[i].bond_type;</a>
<a name="ln802">        path_bonds[i] = bond_type;</a>
<a name="ln803">        if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln804">            BondPosTmp[nNumBondPosTmp].nAtomNumber = DfsPath[i].at_no;</a>
<a name="ln805">            BondPosTmp[nNumBondPosTmp].neighbor_index = DfsPath[i].bond_pos;</a>
<a name="ln806">            nNumBondPosTmp += 2;</a>
<a name="ln807">        }</a>
<a name="ln808">    }</a>
<a name="ln809">    bond_type = (atom[(int)DfsPath[0].at_no].bond_type[nStartAtomNeighbor2] &amp; ~BOND_MARK_ALL);</a>
<a name="ln810">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln811">    bond_type = ACTUAL_ORDER(pBNS,(int)DfsPath[0].at_no,nStartAtomNeighbor2,bond_type);</a>
<a name="ln812">#endif</a>
<a name="ln813">    path_bonds[i++] = bond_type;</a>
<a name="ln814">    if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln815">        BondPosTmp[nNumBondPosTmp].nAtomNumber = DfsPath[0].at_no;</a>
<a name="ln816">        BondPosTmp[nNumBondPosTmp].neighbor_index = nStartAtomNeighbor2;</a>
<a name="ln817">        nNumBondPosTmp += 2;</a>
<a name="ln818">    }</a>
<a name="ln819"> </a>
<a name="ln820">    if ( !are_alt_bonds( path_bonds, i ) ) {</a>
<a name="ln821">        return 0;</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    /* path_bonds is from at_n1 to at_n2 */</a>
<a name="ln825">    if ( !(j=are_alt_bonds( path_bonds, i )) ) {</a>
<a name="ln826">        return 0;</a>
<a name="ln827">    }</a>
<a name="ln828">    /* j is a bond type of the last bond to o2_at, the first bond from o1_at is 2-j if j=1 or 2 */</a>
<a name="ln829"> </a>
<a name="ln830">              /* single bond at o2_at: it should have a mobile atom, o1_at should not */</a>
<a name="ln831">    if ( (j == BOND_SINGLE &amp;&amp; ((!atom[o2_at].endpoint &amp;&amp; !eif2.cDonor) || (!atom[o1_at].endpoint &amp;&amp; !eif1.cAcceptor))) ||</a>
<a name="ln832">              /* double bond at o2_at: it should not have a mobile atom, o1_at should */</a>
<a name="ln833">         (j == BOND_DOUBLE &amp;&amp; ((!atom[o2_at].endpoint &amp;&amp; !eif2.cAcceptor) || (!atom[o1_at].endpoint &amp;&amp; !eif1.cDonor))) ) {</a>
<a name="ln834">         return 0; /* bond pattern does not fit */</a>
<a name="ln835">    }</a>
<a name="ln836"> </a>
<a name="ln837"> </a>
<a name="ln838">    nNumBondPos = AddBondsPos( atom, BondPosTmp, nNumBondPosTmp, BondPos, nMaxNumBondPos, nNumBondPos );</a>
<a name="ln839">    nNumEndPoint = AddEndPoints( EndPointTmp, nNumEndPointTmp, EndPoint, nMaxNumEndPoint, nNumEndPoint);</a>
<a name="ln840"> </a>
<a name="ln841">    if ( nNumBondPos &gt;= 0 &amp;&amp; nNumEndPoint &gt;= 0 ) {</a>
<a name="ln842">        if ( (ret = (nNumBondPos &gt; *pnNumBondPos) || (nNumEndPoint &gt; *pnNumEndPoint)) ) {</a>
<a name="ln843">            *pnNumBondPos  = nNumBondPos  ;</a>
<a name="ln844">            *pnNumEndPoint = nNumEndPoint ;</a>
<a name="ln845">        }</a>
<a name="ln846">    }</a>
<a name="ln847"> </a>
<a name="ln848">    if ( ret ) {</a>
<a name="ln849">        /* finally check whether the bonds allow moving the hydrogens */</a>
<a name="ln850">        if ( (atom[o1_at].endpoint != atom[o2_at].endpoint || !atom[o1_at].endpoint) ) {</a>
<a name="ln851">            nErr = bExistsAnyAltPath( pBNS, pBD, atom, num_atoms, o1_at, o2_at, ALT_PATH_MODE_TAUTOM );</a>
<a name="ln852">            if ( nErr &lt;= 0 )</a>
<a name="ln853">                return nErr;</a>
<a name="ln854">        }</a>
<a name="ln855">    }</a>
<a name="ln856"> </a>
<a name="ln857">    return ret;</a>
<a name="ln858"> </a>
<a name="ln859">    </a>
<a name="ln860">#undef PATH_LEN</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">/********************************************************************************/</a>
<a name="ln864">/* </a>
<a name="ln865">  1,5 Tautomerism in 6-member alt ring:</a>
<a name="ln866"> </a>
<a name="ln867">   /=\          /==\          N = DfsPath[0].at_no</a>
<a name="ln868"> HN   C=O  &lt;-&gt; N    C-OH      C = DfsPath[3].at_no</a>
<a name="ln869">   \=/          \\-//</a>
<a name="ln870">    </a>
<a name="ln871">*/</a>
<a name="ln872">/********************************************************************************/</a>
<a name="ln873">/*  check if a tautomeric 6-member ring has been found */</a>
<a name="ln874">int Check6MembTautRing( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int nStartAtomNeighbor,</a>
<a name="ln875">                        int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln876">                        T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln877">                        T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln878">                        int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln879">                        struct BalancedNetworkStructure *pBNS,</a>
<a name="ln880">                        struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln881">{</a>
<a name="ln882">#define PATH_LEN 4</a>
<a name="ln883">    int i, j, k, /*m,*/ nNumBondPos, nNumEndPoint;</a>
<a name="ln884">    int nNumEndPointTmp, nNumBondPosTmp, o_at, ret;</a>
<a name="ln885">    /* int num_taut_endpoints, num_H; */</a>
<a name="ln886">    int middle_pos;</a>
<a name="ln887">    int nMobile, endpoint, endpoint_valence, chem_bonds_valence;</a>
<a name="ln888">    int nMobile1, endpoint_valence1;  /*  o_at */</a>
<a name="ln889">    int nMobile2, endpoint_valence2;  /*  n_at */</a>
<a name="ln890">    int nxt_at;</a>
<a name="ln891">    int n_at;</a>
<a name="ln892">    U_CHAR path_bonds[2][PATH_LEN+1], bond_type;</a>
<a name="ln893">    T_ENDPOINT EndPointTmp[2];</a>
<a name="ln894">    T_BONDPOS  BondPosTmp[4*PATH_LEN];</a>
<a name="ln895">    ENDPOINT_INFO eif1, eif2;</a>
<a name="ln896"> </a>
<a name="ln897">    if ( nStartAtomNeighbor &gt;= 0 || nStartAtomNeighbor2 &gt;= 0 || nStartAtomNeighborNeighbor &gt;= 0 )</a>
<a name="ln898">        return -1; /*  wrong call */</a>
<a name="ln899"> </a>
<a name="ln900">    if ( nLenDfsPath != 5 )</a>
<a name="ln901">        return -1; /*  wrong call */</a>
<a name="ln902"> </a>
<a name="ln903">    nNumBondPos  = *pnNumBondPos;</a>
<a name="ln904">    nNumEndPoint = *pnNumEndPoint;</a>
<a name="ln905">    nNumBondPosTmp  = 0;</a>
<a name="ln906">    nNumEndPointTmp = 0;</a>
<a name="ln907">    ret             = 0;</a>
<a name="ln908">    </a>
<a name="ln909">    n_at   = (int)DfsPath[0].at_no;   /*  -N= or -NH- atom */</a>
<a name="ln910">    nxt_at = DfsPath[middle_pos = (nLenDfsPath+1)/2].at_no;  /*  must have tautomeric neighbor -OH or =O or -NH2 or =NH */</a>
<a name="ln911"> </a>
<a name="ln912">    if ( atom[nxt_at].valence != 3 </a>
<a name="ln913">#if ( TAUT_RINGS_ATTACH_CHAIN == 1 )        </a>
<a name="ln914">         || !atom[nxt_at].bCutVertex</a>
<a name="ln915">#endif        </a>
<a name="ln916">       ) {</a>
<a name="ln917">        return 0;</a>
<a name="ln918">    }</a>
<a name="ln919"> </a>
<a name="ln920">    for ( i = 0; i &lt; atom[nxt_at].valence; i ++ ) {</a>
<a name="ln921">        o_at = atom[nxt_at].neighbor[i];</a>
<a name="ln922">        if ( o_at != DfsPath[middle_pos-1].at_no &amp;&amp; o_at != DfsPath[middle_pos+1].at_no ) {</a>
<a name="ln923">            break; /*  &gt;=O or /&gt;-OH has been found */</a>
<a name="ln924">        }</a>
<a name="ln925">    }</a>
<a name="ln926">    if ( i == atom[nxt_at].valence ) {</a>
<a name="ln927">        return 0; /*  no neighboring atom &gt;=O or /&gt;-OH */</a>
<a name="ln928">    }</a>
<a name="ln929">    bond_type = (atom[nxt_at].bond_type[i] &amp; ~BOND_MARK_ALL);</a>
<a name="ln930">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln931">    bond_type = ACTUAL_ORDER(pBNS,nxt_at,i,bond_type);</a>
<a name="ln932">#endif</a>
<a name="ln933">    if ( bond_type != BOND_SINGLE &amp;&amp;</a>
<a name="ln934">         bond_type != BOND_DOUBLE &amp;&amp;</a>
<a name="ln935">         bond_type != BOND_TAUTOM &amp;&amp;</a>
<a name="ln936">         bond_type != BOND_ALT12NS &amp;&amp;</a>
<a name="ln937">         bond_type != BOND_ALTERN ) {</a>
<a name="ln938">        return 0;</a>
<a name="ln939">    }</a>
<a name="ln940"> </a>
<a name="ln941">    /*  check whether the two atoms already belong to one tautomeric group */</a>
<a name="ln942">#if ( TAUT_IGNORE_EQL_ENDPOINTS == 1 )</a>
<a name="ln943">    if ( atom[n_at].endpoint &amp;&amp; atom[n_at].endpoint == atom[o_at].endpoint ) {</a>
<a name="ln944">        return 0;</a>
<a name="ln945">    }</a>
<a name="ln946">#endif</a>
<a name="ln947">    /*  check =O valence; must be 2 for O, S, Se or 3 for N */</a>
<a name="ln948">    if ( !(endpoint_valence1=nGetEndpointInfo( atom, o_at, &amp;eif1 )) )</a>
<a name="ln949">    {</a>
<a name="ln950">        return 0; /*  n_at has been checked in MarkTautomerGroups(...) */</a>
<a name="ln951">    }</a>
<a name="ln952">/*</a>
<a name="ln953">    if ( 2 != endpoint_valence1 )</a>
<a name="ln954">        return 0; // accept only O, S, Se</a>
<a name="ln955">*/</a>
<a name="ln956">    /*  check hydrogens/endpoints */</a>
<a name="ln957">    nMobile1 = atom[o_at].num_H + (atom[o_at].charge==-1);</a>
<a name="ln958">    if ( bond_type == BOND_SINGLE &amp;&amp; !eif1.cDonor &amp;&amp; !atom[o_at].endpoint )</a>
<a name="ln959">        return 0;</a>
<a name="ln960">    /* not needed since nGetEndpointInfo returned non-zero </a>
<a name="ln961">    if ( nMobile1 + atom[o_at].chem_bonds_valence != endpoint_valence1 )</a>
<a name="ln962">        return 0;</a>
<a name="ln963">    */</a>
<a name="ln964">    </a>
<a name="ln965">    if ( !(endpoint_valence2=nGetEndpointInfo( atom, n_at, &amp;eif2 ) ) ) {</a>
<a name="ln966">        return 0; /* should not happen here */</a>
<a name="ln967">    }</a>
<a name="ln968">    nMobile2 = atom[n_at].num_H + (atom[n_at].charge==-1);</a>
<a name="ln969"> </a>
<a name="ln970">    nMobile = 0;</a>
<a name="ln971"> </a>
<a name="ln972">    /*  can mobile group move from o_at to n_at? */</a>
<a name="ln973">    nMobile += (atom[o_at].endpoint || eif1.cDonor) &amp;&amp;  /*  from o_at */</a>
<a name="ln974">                bond_type != BOND_DOUBLE   &amp;&amp;</a>
<a name="ln975">               ( atom[n_at].endpoint ||                   /*  to n_at */</a>
<a name="ln976">                 eif2.cNeutralBondsValence &gt; atom[n_at].valence );</a>
<a name="ln977">    /*  can mobile group move from n_at to o_at? */</a>
<a name="ln978">    nMobile += (atom[n_at].endpoint || eif2.cDonor)  &amp;&amp; /*  from n_at */</a>
<a name="ln979">               (atom[o_at].endpoint ||          /*  to o_at */</a>
<a name="ln980">                eif1.cNeutralBondsValence &gt; atom[o_at].valence ) &amp;&amp;</a>
<a name="ln981">                bond_type != BOND_SINGLE; </a>
<a name="ln982"> </a>
<a name="ln983"> </a>
<a name="ln984">    if ( !nMobile )</a>
<a name="ln985">        return 0;</a>
<a name="ln986">    /*</a>
<a name="ln987">    num_H = atom[n_at].num_H + atom[o_at].num_H;</a>
<a name="ln988">    num_taut_endpoints = (0!=atom[n_at].endpoint) + (0!=atom[o_at].endpoint); // if O, N already are endpoints</a>
<a name="ln989">    if ( num_H != 1 &amp;&amp; num_taut_endpoints != 2 &amp;&amp; !(num_H==2 &amp;&amp; num_taut_endpoints &gt;= 1) ) {</a>
<a name="ln990">        return 0;</a>
<a name="ln991">    }</a>
<a name="ln992">    */</a>
<a name="ln993">    /*  extract -OH bond */</a>
<a name="ln994">    nNumBondPosTmp = 0;</a>
<a name="ln995"> </a>
<a name="ln996">    path_bonds[0][0] = path_bonds[1][0] = bond_type;</a>
<a name="ln997">    if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln998">        BondPosTmp[nNumBondPosTmp].nAtomNumber = nxt_at; /*  accumulate bonds to be */</a>
<a name="ln999">        BondPosTmp[nNumBondPosTmp].neighbor_index = i;   /*  marked as tautomeric */</a>
<a name="ln1000">        nNumBondPosTmp += 2; /*  leave room for the same bond in the opposite direction */</a>
<a name="ln1001">    }</a>
<a name="ln1002"> </a>
<a name="ln1003">    /*  extract other bonds */</a>
<a name="ln1004">    /* path_bonds[] contents:</a>
<a name="ln1005">    </a>
<a name="ln1006">                                                         </a>
<a name="ln1007">                    O              OH            OH   </a>
<a name="ln1008">                    ||             |             |    </a>
<a name="ln1009">                   /  \          //  \          /  \\ </a>
<a name="ln1010">                  ||   ||  &lt;--&gt;  |   ||  &lt;--&gt;  ||   | </a>
<a name="ln1011">                   \  /          \\  /          \  // </a>
<a name="ln1012">                    NH             N             N    </a>
<a name="ln1013">         </a>
<a name="ln1014">        path[0]:  O=NH-=-      OH-N...         OH.N...</a>
<a name="ln1015">        path[1]   O=NH-=-      OH-N...         OH.N...</a>
<a name="ln1016">                 bonds are    all bonds       all bonds  </a>
<a name="ln1017">                 single and   are either      are either </a>
<a name="ln1018">                 double       alt or taut     alt or taut</a>
<a name="ln1019">    */</a>
<a name="ln1020">    for ( j = 0; j &lt; middle_pos; j ++ ) {</a>
<a name="ln1021">        for ( i = 0; i &lt; 2; i ++ ) {</a>
<a name="ln1022">            /* k = i? j : middle_pos-1-j; */</a>
<a name="ln1023">            k = i? middle_pos+j : middle_pos-1-j;</a>
<a name="ln1024">            /*  i=0: from O neighbor i=0: down to N, i=1: up to N */</a>
<a name="ln1025">            bond_type = DfsPath[k].bond_type;</a>
<a name="ln1026"> </a>
<a name="ln1027">            path_bonds[i][j+1] = bond_type;</a>
<a name="ln1028">            if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln1029">                BondPosTmp[nNumBondPosTmp].nAtomNumber = DfsPath[k].at_no;       /*  accumulate bonds to be */</a>
<a name="ln1030">                BondPosTmp[nNumBondPosTmp].neighbor_index = DfsPath[k].bond_pos; /*  marked as tautomeric */</a>
<a name="ln1031">                nNumBondPosTmp += 2;   /*  leave room for the same bond in the opposite direction */</a>
<a name="ln1032">            }</a>
<a name="ln1033">        }</a>
<a name="ln1034">    }</a>
<a name="ln1035">    if ( !are_alt_bonds( path_bonds[0], middle_pos+1 ) || !are_alt_bonds( path_bonds[1], middle_pos+1 ) ) {</a>
<a name="ln1036">        return 0;</a>
<a name="ln1037">    }</a>
<a name="ln1038"> </a>
<a name="ln1039">    /* finally check whether the bonds allow moving the hydrogens */</a>
<a name="ln1040">    if ( (atom[o_at].endpoint != atom[n_at].endpoint || !atom[o_at].endpoint) ) {</a>
<a name="ln1041">        int nErr;</a>
<a name="ln1042">        nErr = bExistsAnyAltPath( pBNS, pBD, atom, num_atoms, n_at, o_at, ALT_PATH_MODE_TAUTOM );</a>
<a name="ln1043">        if ( nErr &lt;= 0 )</a>
<a name="ln1044">            return nErr;</a>
<a name="ln1045">    }</a>
<a name="ln1046">    /*  save endpoints */</a>
<a name="ln1047">    for ( j = 0; j &lt; 2; j ++ ) {</a>
<a name="ln1048">        endpoint = j? n_at :      /*  =N-  2 */</a>
<a name="ln1049">                      o_at;       /*  -OH  1 */</a>
<a name="ln1050">        if ( !atom[endpoint].endpoint ) { /* not a known endpoint */</a>
<a name="ln1051">            endpoint_valence   = j? endpoint_valence2 : endpoint_valence1;</a>
<a name="ln1052">            chem_bonds_valence = j? eif2.cNeutralBondsValence : eif1.cNeutralBondsValence;</a>
<a name="ln1053">            /* endpoint_valence = get_endpoint_valence( atom[endpoint].el_number ); */</a>
<a name="ln1054">            nMobile  = j? nMobile2 : nMobile1;</a>
<a name="ln1055">            /* nMobile  = (atom[endpoint].charge == -1) + atom[endpoint].num_H; */</a>
<a name="ln1056">            /* if ( nMobile + atom[endpoint].chem_bonds_valence != endpoint_valence ) -- fixed 02-06-2003*/</a>
<a name="ln1057">            if ( nMobile + chem_bonds_valence != endpoint_valence )</a>
<a name="ln1058">                return 0; /*  abnormal endpoint valence; ignore. */</a>
<a name="ln1059">            AddAtom2num( EndPointTmp[nNumEndPointTmp].num, atom, endpoint, 2 ); /* fill out */</a>
<a name="ln1060">            AddAtom2DA( EndPointTmp[nNumEndPointTmp].num_DA, atom, endpoint, 2 );</a>
<a name="ln1061">/*</a>
<a name="ln1062">            EndPointTmp[nNumEndPointTmp].num[1] = (atom[endpoint].charge == -1);</a>
<a name="ln1063">            EndPointTmp[nNumEndPointTmp].num[0] = nMobile;</a>
<a name="ln1064">            for ( m = 0; m &lt; T_NUM_ISOTOPIC; m ++ ) {</a>
<a name="ln1065">                EndPointTmp[nNumEndPointTmp].num[T_NUM_NO_ISOTOPIC+m] = atom[endpoint].num_iso_H[NUM_H_ISOTOPES-m-1];</a>
<a name="ln1066">            }</a>
<a name="ln1067">*/</a>
<a name="ln1068">        } else { /* already an endpoint */ /* **now it is wrong:** no mobile atom/charge at this endpoint */</a>
<a name="ln1069">            memset( EndPointTmp + nNumEndPointTmp, 0, sizeof(EndPointTmp[0]) );</a>
<a name="ln1070">        }</a>
<a name="ln1071">        EndPointTmp[nNumEndPointTmp].nAtomNumber  = endpoint;</a>
<a name="ln1072">        EndPointTmp[nNumEndPointTmp].nGroupNumber = atom[endpoint].endpoint;</a>
<a name="ln1073">        EndPointTmp[nNumEndPointTmp].nEquNumber   = 0;</a>
<a name="ln1074"> </a>
<a name="ln1075">        nNumEndPointTmp ++;</a>
<a name="ln1076">    }</a>
<a name="ln1077">    /*  add collected tautomeric bonds and endpoints to the input/output data */</a>
<a name="ln1078">    nNumBondPos  = AddBondsPos( atom, BondPosTmp, nNumBondPosTmp, BondPos, nMaxNumBondPos, nNumBondPos );</a>
<a name="ln1079">    nNumEndPoint = AddEndPoints( EndPointTmp, nNumEndPointTmp, EndPoint, nMaxNumEndPoint, nNumEndPoint);</a>
<a name="ln1080"> </a>
<a name="ln1081">    if ( nNumBondPos &gt;= 0 &amp;&amp; nNumEndPoint &gt;= 0 ) {</a>
<a name="ln1082">        if ( (ret = (nNumBondPos &gt; *pnNumBondPos) || (nNumEndPoint &gt; *pnNumEndPoint)) ) {</a>
<a name="ln1083">            *pnNumBondPos  = nNumBondPos  ;</a>
<a name="ln1084">            *pnNumEndPoint = nNumEndPoint ;</a>
<a name="ln1085">        }</a>
<a name="ln1086">    }</a>
<a name="ln1087">    return ret;</a>
<a name="ln1088">    </a>
<a name="ln1089">#undef PATH_LEN</a>
<a name="ln1090">}</a>
<a name="ln1091">#if ( TAUT_15_NON_RING == 1 )  /* post v.1 feature */</a>
<a name="ln1092">/********************************************************************************</a>
<a name="ln1093">Check (1,5) taut alt path centerpoint (unfinished) [add path checking]</a>
<a name="ln1094">*********************************************************************************/</a>
<a name="ln1095">int Check15TautPathCenterpoint( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int jNxtNeigh,</a>
<a name="ln1096">                        struct BalancedNetworkStructure *pBNS,</a>
<a name="ln1097">                        struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln1098">{</a>
<a name="ln1099">    int nxt_at = atom[DfsPath[nLenDfsPath].at_no].neighbor[jNxtNeigh];</a>
<a name="ln1100">    /* atom[nxt_at].endpoint below allows for keto-enol -CH&lt; or -CH2- endpoints  */</a>
<a name="ln1101">    return atom[nxt_at].endpoint || bIsCenterPointStrict( atom, nxt_at );</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">/********************************************************************************/</a>
<a name="ln1105">/* </a>
<a name="ln1106">  1,5 Tautomerism in general (unfinished) [just a copy from 6-memb case]</a>
<a name="ln1107"> </a>
<a name="ln1108">  AH--B==C--D==E             C may be carbon exhibiting keto-enol tautomerism</a>
<a name="ln1109">  0   1  2  3  4             as well as A or E may be previously detected such a carbon</a>
<a name="ln1110">            ^   nxt_at</a>
<a name="ln1111">            |</a>
<a name="ln1112">            +-- = nLenDfsPath</a>
<a name="ln1113"> </a>
<a name="ln1114">*/</a>
<a name="ln1115">/********************************************************************************/</a>
<a name="ln1116">/*  check if 1,5 tautomeric path has been found */</a>
<a name="ln1117">int Check15TautPath( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int jNxtNeigh, int nStartAtomNeighbor,</a>
<a name="ln1118">                        int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln1119">                        T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln1120">                        T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln1121">                        int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln1122">                        struct BalancedNetworkStructure *pBNS,</a>
<a name="ln1123">                        struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln1124">{</a>
<a name="ln1125">#define PATH_LEN 4</a>
<a name="ln1126">    int i, j, k, /*m,*/ nNumBondPos, nNumEndPoint, cur_at, prv_at, at1, at2 /*, at3, step_at*/;</a>
<a name="ln1127">    int nNumEndPointTmp, nNumBondPosTmp, ret;</a>
<a name="ln1128">    /* int num_taut_endpoints, num_H; */</a>
<a name="ln1129">    int nMobile, endpoint, endpoint_valence, chem_bonds_valence;</a>
<a name="ln1130">    int nMobile1, endpoint_valence1;  /* start atom, at1 */</a>
<a name="ln1131">    int nMobile2, endpoint_valence2;  /* end atom,   at2 */</a>
<a name="ln1132">    /*int nMobile3, endpoint_valence3=-1;*/  /* middle atom, at3 */</a>
<a name="ln1133">    /*int nxt_at;*/</a>
<a name="ln1134">    int alt_bonds[2];</a>
<a name="ln1135">    U_CHAR /*path_bonds[2][PATH_LEN+1],*/ bond_type;</a>
<a name="ln1136">    T_ENDPOINT EndPointTmp[2];</a>
<a name="ln1137">    T_BONDPOS  BondPosTmp[4*PATH_LEN];</a>
<a name="ln1138">    ENDPOINT_INFO eif1, eif2/*, eif3*/;</a>
<a name="ln1139"> </a>
<a name="ln1140">    if ( nStartAtomNeighbor &gt;= 0 || nStartAtomNeighbor2 &gt;= 0 || nStartAtomNeighborNeighbor &gt;= 0 )</a>
<a name="ln1141">        return -1; /*  wrong call */</a>
<a name="ln1142"> </a>
<a name="ln1143">    if ( nLenDfsPath != 3 )</a>
<a name="ln1144">        return -1; /*  wrong call */</a>
<a name="ln1145"> </a>
<a name="ln1146">    nNumBondPos  = *pnNumBondPos;</a>
<a name="ln1147">    nNumEndPoint = *pnNumEndPoint;</a>
<a name="ln1148">    nNumBondPosTmp  = 0;</a>
<a name="ln1149">    nNumEndPointTmp = 0;</a>
<a name="ln1150">    ret             = 0;</a>
<a name="ln1151"> </a>
<a name="ln1152">/*-------add the last atom, nLenDfsPath=4 --*/</a>
<a name="ln1153">    j = jNxtNeigh;</a>
<a name="ln1154">    prv_at = DfsPath[nLenDfsPath].at_no;</a>
<a name="ln1155">    cur_at = atom[prv_at].neighbor[j];</a>
<a name="ln1156">    DfsPath[nLenDfsPath].bond_type     = (atom[prv_at].bond_type[j] &amp; ~BOND_MARK_ALL);</a>
<a name="ln1157">#if ( FIX_BOND23_IN_TAUT == 1 )</a>
<a name="ln1158">    DfsPath[nLenDfsPath].bond_type = ACTUAL_ORDER(pBNS,prv_at,j,DfsPath[nLenDfsPath].bond_type);</a>
<a name="ln1159">#endif</a>
<a name="ln1160">    DfsPath[nLenDfsPath].bond_pos      = j; /* fix index of the bond to the next atom */</a>
<a name="ln1161"> </a>
<a name="ln1162">    nLenDfsPath ++;</a>
<a name="ln1163"> </a>
<a name="ln1164">    DfsPath[nLenDfsPath].at_no         = cur_at;</a>
<a name="ln1165">    DfsPath[nLenDfsPath].bond_type     = 0;</a>
<a name="ln1166">    DfsPath[nLenDfsPath].bond_pos      = -1;</a>
<a name="ln1167">    /*nDfsPathPos[cur_at]                = nLenDfsPath+1;*/ /* mark with distance + 1 */</a>
<a name="ln1168">/*------------------------------------------*/</a>
<a name="ln1169">    at1 = (int)DfsPath[0].at_no;</a>
<a name="ln1170">    at2 = (int)DfsPath[nLenDfsPath].at_no;</a>
<a name="ln1171">    /*at3 = (int)DfsPath[2].at_no;*/</a>
<a name="ln1172">    if ( atom[at1].endpoint &amp;&amp; atom[at1].endpoint == atom[at2].endpoint ) {</a>
<a name="ln1173">        /* start &amp; end already belong to the same taut group */</a>
<a name="ln1174">        goto exit_function;  /* nothing to do */</a>
<a name="ln1175">    }</a>
<a name="ln1176"> </a>
<a name="ln1177">    /* check bond types along alt path */</a>
<a name="ln1178">    alt_bonds[0] =  alt_bonds[1] = 0;</a>
<a name="ln1179">    for( i = 0; i &lt; nLenDfsPath; i ++ ) {</a>
<a name="ln1180">        alt_bonds[i%2] |= IS_ALT_OR_DBLBOND(DfsPath[i].bond_type);</a>
<a name="ln1181">    }</a>
<a name="ln1182">    if ( (alt_bonds[0] &amp; alt_bonds[1] &amp; (BOND_SINGLE | BOND_DOUBLE)) ||</a>
<a name="ln1183">         (alt_bonds[0] &amp; BOND_WRONG) || (alt_bonds[1] &amp; BOND_WRONG ) ) {</a>
<a name="ln1184">        goto exit_function; /* incompatible with alt path or wrong bonds */\</a>
<a name="ln1185">    }</a>
<a name="ln1186">    /* check possibly tautomeric endpoints at the ends */</a>
<a name="ln1187">    endpoint_valence1 = nGetEndpointInfo( atom, at1, &amp;eif1 );</a>
<a name="ln1188">    endpoint_valence2 = nGetEndpointInfo( atom, at2, &amp;eif2 );</a>
<a name="ln1189">#ifdef NEVER   /* do not use C-endpoint of keto-enol tautomer to find 1,5 the taut path */</a>
<a name="ln1190">    if ( !endpoint_valence1 &amp;&amp; !atom[at1].endpoint ||</a>
<a name="ln1191">         !endpoint_valence2 &amp;&amp; !atom[at2].endpoint )</a>
<a name="ln1192">        goto exit_function; /* at least one of the end atoms cannot be an endpoint */</a>
<a name="ln1193">#endif</a>
<a name="ln1194">    if ( !endpoint_valence1 || !endpoint_valence2 )</a>
<a name="ln1195">        goto exit_function;  /* require both endpoints be heteroatoms */</a>
<a name="ln1196">    /*  check hydrogens/endpoints */</a>
<a name="ln1197">    nMobile1 = atom[at1].num_H + (atom[at1].charge==-1);</a>
<a name="ln1198">    if ( !atom[at1].endpoint ) {</a>
<a name="ln1199">        if ( (alt_bonds[0] &amp; BOND_SINGLE) &amp;&amp; !eif1.cDonor )</a>
<a name="ln1200">            goto exit_function;</a>
<a name="ln1201">        if ( (alt_bonds[0] &amp; BOND_DOUBLE) &amp;&amp; !eif1.cAcceptor )</a>
<a name="ln1202">            goto exit_function;</a>
<a name="ln1203">    }</a>
<a name="ln1204">    nMobile2 = atom[at2].num_H + (atom[at2].charge==-1);</a>
<a name="ln1205">    if ( !atom[at2].endpoint ) {</a>
<a name="ln1206">        if ( (alt_bonds[1] &amp; BOND_SINGLE) &amp;&amp; !eif2.cDonor )</a>
<a name="ln1207">            goto exit_function;</a>
<a name="ln1208">        if ( (alt_bonds[1] &amp; BOND_DOUBLE) &amp;&amp; !eif2.cAcceptor )</a>
<a name="ln1209">            goto exit_function;</a>
<a name="ln1210">    }</a>
<a name="ln1211"> </a>
<a name="ln1212">    nMobile = 0;</a>
<a name="ln1213"> </a>
<a name="ln1214">    /*  can mobile group move from at1=o_at to at2=n_at? */</a>
<a name="ln1215">    nMobile += (atom[at1].endpoint || eif1.cDonor) &amp;&amp;  /*  from o_at */</a>
<a name="ln1216">               !(alt_bonds[0] &amp; BOND_DOUBLE)   &amp;&amp;</a>
<a name="ln1217">               ( atom[at2].endpoint ||                   /*  to n_at */</a>
<a name="ln1218">                 eif2.cNeutralBondsValence &gt; atom[at2].valence );</a>
<a name="ln1219">    /*  can mobile group move from at2=n_at to at1=o_at? */</a>
<a name="ln1220">    nMobile += (atom[at2].endpoint || eif2.cDonor)  &amp;&amp; /*  from n_at */</a>
<a name="ln1221">               !(alt_bonds[1] &amp; BOND_DOUBLE)   &amp;&amp;</a>
<a name="ln1222">               ( atom[at1].endpoint ||          /*  to o_at */</a>
<a name="ln1223">                 eif1.cNeutralBondsValence &gt; atom[at1].valence ); </a>
<a name="ln1224"> </a>
<a name="ln1225"> </a>
<a name="ln1226">    if ( !nMobile )</a>
<a name="ln1227">        goto exit_function;</a>
<a name="ln1228"> </a>
<a name="ln1229">    /* check whether the bonds allow moving the hydrogens between at1 and at2 */</a>
<a name="ln1230">    if ( (atom[at1].endpoint != atom[at2].endpoint || !atom[at1].endpoint) ) {</a>
<a name="ln1231">        int nErr;</a>
<a name="ln1232">        nErr = bExistsAnyAltPath( pBNS, pBD, atom, num_atoms, at1, at2, ALT_PATH_MODE_TAUTOM );</a>
<a name="ln1233">        if ( nErr &lt;= 0 ) {</a>
<a name="ln1234">            ret = nErr;</a>
<a name="ln1235">            goto exit_function;</a>
<a name="ln1236">        }</a>
<a name="ln1237">    }</a>
<a name="ln1238"> </a>
<a name="ln1239">    /* save tautomeric bonds */</a>
<a name="ln1240">    nNumBondPosTmp = 0;</a>
<a name="ln1241">    for ( k = 0; k &lt; nLenDfsPath; k ++ ) {</a>
<a name="ln1242">        bond_type = DfsPath[k].bond_type;</a>
<a name="ln1243">        if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln1244">            BondPosTmp[nNumBondPosTmp].nAtomNumber = DfsPath[k].at_no;     /*  accumulate bonds to be */</a>
<a name="ln1245">            BondPosTmp[nNumBondPosTmp].neighbor_index = DfsPath[k].bond_pos;  /*  marked as tautomeric */</a>
<a name="ln1246">            nNumBondPosTmp += 2; /*  leave room for the same bond in opposite direction */</a>
<a name="ln1247">        }</a>
<a name="ln1248">    }</a>
<a name="ln1249">    /*  save endpoints */</a>
<a name="ln1250">    for ( j = 0; j &lt; 2; j ++ ) {</a>
<a name="ln1251">        endpoint = j? at2 : at1;</a>
<a name="ln1252">        if ( !atom[endpoint].endpoint ) { /* not a known endpoint */</a>
<a name="ln1253">            endpoint_valence   = j? endpoint_valence2 : endpoint_valence1;</a>
<a name="ln1254">            chem_bonds_valence = j? eif2.cNeutralBondsValence : eif1.cNeutralBondsValence;</a>
<a name="ln1255">            /* endpoint_valence = get_endpoint_valence( atom[endpoint].el_number ); */</a>
<a name="ln1256">            nMobile  = j? nMobile2 : nMobile1;</a>
<a name="ln1257">            /* nMobile  = (atom[endpoint].charge == -1) + atom[endpoint].num_H; */</a>
<a name="ln1258">            /* if ( nMobile + atom[endpoint].chem_bonds_valence != endpoint_valence ) -- fixed 02-06-2003*/</a>
<a name="ln1259">            if ( nMobile + chem_bonds_valence != endpoint_valence )</a>
<a name="ln1260">                goto exit_function; /*  abnormal endpoint valence; ignore. */</a>
<a name="ln1261">            AddAtom2num( EndPointTmp[nNumEndPointTmp].num, atom, endpoint, 2 ); /* fill out */</a>
<a name="ln1262">            AddAtom2DA( EndPointTmp[nNumEndPointTmp].num_DA, atom, endpoint, 2 );</a>
<a name="ln1263">        } else { /* already an endpoint */ /* **now it is wrong:** no mobile atom/charge at this endpoint */</a>
<a name="ln1264">            memset( EndPointTmp + nNumEndPointTmp, 0, sizeof(EndPointTmp[0]) );</a>
<a name="ln1265">        }</a>
<a name="ln1266">        EndPointTmp[nNumEndPointTmp].nAtomNumber  = endpoint;</a>
<a name="ln1267">        EndPointTmp[nNumEndPointTmp].nGroupNumber = atom[endpoint].endpoint;</a>
<a name="ln1268">        EndPointTmp[nNumEndPointTmp].nEquNumber   = 0;</a>
<a name="ln1269"> </a>
<a name="ln1270">        nNumEndPointTmp ++;</a>
<a name="ln1271">    }</a>
<a name="ln1272">    /*  add collected tautomeric bonds and endpoints to the input/output data */</a>
<a name="ln1273">    nNumBondPos  = AddBondsPos( atom, BondPosTmp, nNumBondPosTmp, BondPos, nMaxNumBondPos, nNumBondPos );</a>
<a name="ln1274">    nNumEndPoint = AddEndPoints( EndPointTmp, nNumEndPointTmp, EndPoint, nMaxNumEndPoint, nNumEndPoint);</a>
<a name="ln1275"> </a>
<a name="ln1276">    if ( nNumBondPos &gt;= 0 &amp;&amp; nNumEndPoint &gt;= 0 ) {</a>
<a name="ln1277">        if ( (ret = (nNumBondPos &gt; *pnNumBondPos) || (nNumEndPoint &gt; *pnNumEndPoint)) ) {</a>
<a name="ln1278">            *pnNumBondPos  = nNumBondPos  ;</a>
<a name="ln1279">            *pnNumEndPoint = nNumEndPoint ;</a>
<a name="ln1280">        }</a>
<a name="ln1281">    }</a>
<a name="ln1282"> </a>
<a name="ln1283">exit_function:</a>
<a name="ln1284">    /*nDfsPathPos[DfsPath[nLenDfsPath].at_no] = 0;*/</a>
<a name="ln1285"> </a>
<a name="ln1286">    return ret;</a>
<a name="ln1287">    </a>
<a name="ln1288">#undef PATH_LEN</a>
<a name="ln1289">}</a>
<a name="ln1290">#endif  /* TAUT_15_NON_RING */</a>
<a name="ln1291"> </a>
<a name="ln1292">/********************************************************************************/</a>
<a name="ln1293">/* </a>
<a name="ln1294"> </a>
<a name="ln1295">  1,4 tautomerism in 5-member ring</a>
<a name="ln1296"> </a>
<a name="ln1297">             </a>
<a name="ln1298">   O=N2-C            O-N2=C          N1 = DfsPath[0].at_no</a>
<a name="ln1299">     |   \\            |   \         N2 = DfsPath[1].at_no</a>
<a name="ln1300">     |     D  &lt;-&gt;      |     D</a>
<a name="ln1301">     |   /             |   // </a>
<a name="ln1302">  HO-N1=E           HO=N1-E   </a>
<a name="ln1303"> </a>
<a name="ln1304">*/</a>
<a name="ln1305">/********************************************************************************/</a>
<a name="ln1306">/*  check if a tautomeric 5-member ring (pyrazole derivatives) has been found */</a>
<a name="ln1307">int Check5MembTautRing( inp_ATOM *atom, DFS_PATH *DfsPath, int nLenDfsPath, int nStartAtomNeighbor,</a>
<a name="ln1308">                        int nStartAtomNeighbor2, int nStartAtomNeighborNeighbor,</a>
<a name="ln1309">                        T_ENDPOINT *EndPoint, int nMaxNumEndPoint,</a>
<a name="ln1310">                        T_BONDPOS  *BondPos, int nMaxNumBondPos,</a>
<a name="ln1311">                        int *pnNumEndPoint, int *pnNumBondPos,</a>
<a name="ln1312">                        struct BalancedNetworkStructure *pBNS,</a>
<a name="ln1313">                        struct BalancedNetworkData *pBD, int num_atoms )</a>
<a name="ln1314">{</a>
<a name="ln1315">#define PATH_LEN 4</a>
<a name="ln1316">    int i, j, /*m,*/ nMobile, nMobile1, nMobile2;</a>
<a name="ln1317">    int num_taut_endpoints, nNumBondPos, nNumBondPosTmp, nNumEndPoint, nNumEndPointTmp, ret;</a>
<a name="ln1318">    int endpoint;</a>
<a name="ln1319">    int n1_at   = (int)DfsPath[0].at_no;</a>
<a name="ln1320">    int n2_at   = (int)DfsPath[1].at_no;</a>
<a name="ln1321">    U_CHAR path_bonds[PATH_LEN+1], bond_type;</a>
<a name="ln1322">    T_ENDPOINT EndPointTmp[2];</a>
<a name="ln1323">    T_BONDPOS  BondPosTmp[2*PATH_LEN];</a>
<a name="ln1324">    ENDPOINT_INFO eif1, eif2;</a>
<a name="ln1325"> </a>
<a name="ln1326">    /*  the two root atoms (atom[n1_at] and atom[n2_at]) cannot belong */</a>
<a name="ln1327">    /*  to one and the same tautomeric group: it has been verified in MarkTautomerGroups() */</a>
<a name="ln1328"> </a>
<a name="ln1329">    /*  check hydrogens/endpoints */</a>
<a name="ln1330">    if ( nLenDfsPath != 4 ) {</a>
<a name="ln1331">        return 0; /*  program error */</a>
<a name="ln1332">    }</a>
<a name="ln1333">    if ( nStartAtomNeighbor2 &gt;= 0 || nStartAtomNeighborNeighbor &gt;= 0 )</a>
<a name="ln1334">        return 0; /*  program error: wrong call */</a>
<a name="ln1335"> </a>
<a name="ln1336">    nNumBondPos  = *pnNumBondPos;</a>
<a name="ln1337">    nNumEndPoint = *pnNumEndPoint;</a>
<a name="ln1338">    nNumEndPointTmp = 0;</a>
<a name="ln1339">    nNumBondPosTmp  = 0;</a>
<a name="ln1340">    ret             = 0;</a>
<a name="ln1341"> </a>
<a name="ln1342">    if ( !nGetEndpointInfo( atom, n1_at, &amp;eif1 ) ||</a>
<a name="ln1343">         !nGetEndpointInfo( atom, n2_at, &amp;eif2 ) ) {</a>
<a name="ln1344">        return 0;</a>
<a name="ln1345">    }</a>
<a name="ln1346"> </a>
<a name="ln1347">    nMobile1 = atom[n1_at].num_H + (atom[n1_at].charge==-1);</a>
<a name="ln1348">    nMobile2 = atom[n2_at].num_H + (atom[n2_at].charge==-1);</a>
<a name="ln1349">    nMobile = nMobile1 + nMobile2;</a>
<a name="ln1350">    num_taut_endpoints = (0!=atom[n1_at].endpoint) + (0!=atom[n2_at].endpoint); /*  if both N atoms already are endpoints */</a>
<a name="ln1351">    /*</a>
<a name="ln1352">    if ( !(nMobile == 1 || num_taut_endpoints == 2) &amp;&amp; !(nMobile&gt;1 &amp;&amp; num_taut_endpoints &gt;= 1) ) {</a>
<a name="ln1353">        return 0;</a>
<a name="ln1354">    }</a>
<a name="ln1355">    */</a>
<a name="ln1356">    if ( num_taut_endpoints == 0 &amp;&amp; nMobile != 1 ) {</a>
<a name="ln1357">        return 0;</a>
<a name="ln1358">    }        </a>
<a name="ln1359"> </a>
<a name="ln1360">    /* finally check whether the bonds allow moving the hydrogens */</a>
<a name="ln1361">    if ( (atom[n1_at].endpoint != atom[n2_at].endpoint || !atom[n1_at].endpoint) ) {</a>
<a name="ln1362">        int nErr;</a>
<a name="ln1363">        nErr = bExistsAnyAltPath( pBNS, pBD, atom, num_atoms, n1_at, n2_at, ALT_PATH_MODE_TAUTOM );</a>
<a name="ln1364">        if ( nErr &lt;= 0 )</a>
<a name="ln1365">            return nErr;</a>
<a name="ln1366">    }</a>
<a name="ln1367"> </a>
<a name="ln1368">    /*  save endpoints */</a>
<a name="ln1369">    for ( j = 0; j &lt; 2; j ++ ) {</a>
<a name="ln1370">        endpoint = j? n1_at : n2_at;</a>
<a name="ln1371">        if ( !atom[endpoint].endpoint ) { /* not a known endpoint */</a>
<a name="ln1372">/*</a>
<a name="ln1373">            nMobile  = (atom[endpoint].charge == -1) + atom[endpoint].num_H;</a>
<a name="ln1374">        } else {</a>
<a name="ln1375">            nMobile  = 0;</a>
<a name="ln1376">        }</a>
<a name="ln1377">        if ( nMobile ) {</a>
<a name="ln1378">*/</a>
<a name="ln1379">            AddAtom2num( EndPointTmp[nNumEndPointTmp].num, atom, endpoint, 2 ); /* fill out */</a>
<a name="ln1380">            AddAtom2DA( EndPointTmp[nNumEndPointTmp].num_DA, atom, endpoint, 2 );</a>
<a name="ln1381">            /*</a>
<a name="ln1382">            EndPointTmp[nNumEndPointTmp].num[1] = (atom[endpoint].charge == -1);</a>
<a name="ln1383">            EndPointTmp[nNumEndPointTmp].num[0] = nMobile;</a>
<a name="ln1384">            for ( m = 0; m &lt; T_NUM_ISOTOPIC; m ++ ) {</a>
<a name="ln1385">                EndPointTmp[nNumEndPointTmp].num[T_NUM_NO_ISOTOPIC+m] = atom[endpoint].num_iso_H[NUM_H_ISOTOPES-m-1];</a>
<a name="ln1386">            }</a>
<a name="ln1387">            */</a>
<a name="ln1388">        } else {</a>
<a name="ln1389">            memset( EndPointTmp + nNumEndPointTmp, 0, sizeof(EndPointTmp[0]) );</a>
<a name="ln1390">        }</a>
<a name="ln1391">        EndPointTmp[nNumEndPointTmp].nAtomNumber  = endpoint;</a>
<a name="ln1392">        EndPointTmp[nNumEndPointTmp].nGroupNumber = atom[endpoint].endpoint;</a>
<a name="ln1393">        EndPointTmp[nNumEndPointTmp].nEquNumber   = 0;</a>
<a name="ln1394"> </a>
<a name="ln1395">        nNumEndPointTmp ++;</a>
<a name="ln1396">    }</a>
<a name="ln1397"> </a>
<a name="ln1398">    /*  extract bonds */</a>
<a name="ln1399">    nNumBondPosTmp = 0;</a>
<a name="ln1400">    for ( i = 1; i &lt;= nLenDfsPath; i ++ ) {</a>
<a name="ln1401">        bond_type = DfsPath[i].bond_type;</a>
<a name="ln1402">        path_bonds[i-1] = bond_type;</a>
<a name="ln1403">        if ( REPLACE_THE_BOND( bond_type ) ) {</a>
<a name="ln1404">            BondPosTmp[nNumBondPosTmp].nAtomNumber = DfsPath[i].at_no;</a>
<a name="ln1405">            BondPosTmp[nNumBondPosTmp].neighbor_index = DfsPath[i].bond_pos;</a>
<a name="ln1406">            nNumBondPosTmp += 2;</a>
<a name="ln1407">        }</a>
<a name="ln1408">    }</a>
<a name="ln1409">    /* path_bonds is from at_n2 to at_n1 */</a>
<a name="ln1410">    if ( !(i=are_alt_bonds( path_bonds, nLenDfsPath )) ) {</a>
<a name="ln1411">        return 0;</a>
<a name="ln1412">    }</a>
<a name="ln1413">    /* i is a bond type of the last bond to at_n1, the first bond from at_n2 is 2-i if i=1 or 2 */</a>
<a name="ln1414"> </a>
<a name="ln1415">              /* single bond at n1_at: it should have a mobile atom, n2_at should not */</a>
<a name="ln1416">    if ( (i == BOND_SINGLE &amp;&amp; ((!atom[n1_at].endpoint &amp;&amp; !eif1.cDonor)    || (!atom[n2_at].endpoint &amp;&amp; !eif2.cAcceptor) )) ||</a>
<a name="ln1417">              /* double bond at n1_at: it should not have a mobile atom, n2_at should */</a>
<a name="ln1418">         (i == BOND_DOUBLE &amp;&amp; ((!atom[n1_at].endpoint &amp;&amp; !eif1.cAcceptor) || (!atom[n2_at].endpoint &amp;&amp; !eif2.cDonor))) ) {</a>
<a name="ln1419">         return 0; /* bond pattern does not fit */</a>
<a name="ln1420">    }</a>
<a name="ln1421">                     </a>
<a name="ln1422">    nNumBondPos = AddBondsPos( atom, BondPosTmp, nNumBondPosTmp, BondPos, nMaxNumBondPos, nNumBondPos );</a>
<a name="ln1423">    nNumEndPoint = AddEndPoints( EndPointTmp, nNumEndPointTmp, EndPoint, nMaxNumEndPoint, nNumEndPoint);</a>
<a name="ln1424"> </a>
<a name="ln1425">    if ( nNumBondPos &gt;= 0 &amp;&amp; nNumEndPoint &gt;= 0 ) {</a>
<a name="ln1426">        if ( (ret = (nNumBondPos &gt; *pnNumBondPos) || (nNumEndPoint &gt; *pnNumEndPoint)) ) {</a>
<a name="ln1427">            *pnNumBondPos  = nNumBondPos  ;</a>
<a name="ln1428">            *pnNumEndPoint = nNumEndPoint ;</a>
<a name="ln1429">        }</a>
<a name="ln1430">    }</a>
<a name="ln1431">    return ret;</a>
<a name="ln1432">    </a>
<a name="ln1433">#undef PATH_LEN</a>
<a name="ln1434">}</a>
<a name="ln1435">#endif /* } */</a>

</code></pre>
<div class="balloon" rel="763"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'endpoint' should be checked here.</p></div>
<div class="balloon" rel="994"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'nNumBondPosTmp' variable was assigned the same value.</p></div>
<div class="balloon" rel="1050"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'endpoint' should be checked here.</p></div>
<div class="balloon" rel="1240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'nNumBondPosTmp' variable was assigned the same value.</p></div>
<div class="balloon" rel="1252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'endpoint' should be checked here.</p></div>
<div class="balloon" rel="1371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'endpoint' should be checked here.</p></div>
<div class="balloon" rel="1399"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'nNumBondPosTmp' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

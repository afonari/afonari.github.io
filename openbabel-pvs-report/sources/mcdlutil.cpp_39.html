
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mcdlutil.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* -*-C++-*-</a>
<a name="ln2"> </a>
<a name="ln3">**********************************************************************</a>
<a name="ln4"> </a>
<a name="ln5">Copyright (C) 2007,2008 by Sergei V. Trepalin sergey_trepalin@chemical-block.com</a>
<a name="ln6">Copyright (C) 2007,2008 by Andrei Gakh andrei.gakh@nnsa.doe.gov</a>
<a name="ln7"> </a>
<a name="ln8">This file is part of the Open Babel project.</a>
<a name="ln9">For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln10"> </a>
<a name="ln11">This program is free software; you can redistribute it and/or modify</a>
<a name="ln12">it under the terms of the GNU General Public License as published by</a>
<a name="ln13">the Free Software Foundation version 2 of the License.</a>
<a name="ln14"> </a>
<a name="ln15">This program is distributed in the hope that it will be useful,</a>
<a name="ln16">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln17">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18">GNU General Public License for more details.</a>
<a name="ln19">***********************************************************************</a>
<a name="ln20">*/</a>
<a name="ln21">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln22">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln23">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln24">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln25">#include &lt;openbabel/mcdlutil.h&gt;</a>
<a name="ln26">#include &lt;openbabel/data.h&gt;</a>
<a name="ln27">#include &lt;openbabel/obconversion.h&gt;</a>
<a name="ln28">#include &lt;openbabel/stereo/stereo.h&gt;</a>
<a name="ln29">#include &lt;openbabel/stereo/cistrans.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#ifndef WIN32</a>
<a name="ln32">#include &lt;cmath&gt;</a>
<a name="ln33">#endif</a>
<a name="ln34">#ifdef __MINGW32__</a>
<a name="ln35">#include &lt;cmath&gt;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">using namespace std;</a>
<a name="ln39"> </a>
<a name="ln40">namespace OpenBabel {</a>
<a name="ln41"> </a>
<a name="ln42">#define CONNMAX 15</a>
<a name="ln43"> </a>
<a name="ln44">  // Forward declarations</a>
<a name="ln45">  class TEditedMolecule;</a>
<a name="ln46"> </a>
<a name="ln47">  typedef struct adjustedlist{</a>
<a name="ln48">    int nb;</a>
<a name="ln49">    int adjusted[CONNMAX];</a>
<a name="ln50">  } adjustedlist;</a>
<a name="ln51"> </a>
<a name="ln52">  typedef adjustedlist neighbourlist;</a>
<a name="ln53"> </a>
<a name="ln54">#define PI 3.141592653589793238462</a>
<a name="ln55">#define blDenominator 4.0   //Controls bond legth in bondEnlarge</a>
<a name="ln56">#define nRotBondsMax 10     //Determines no. rotating bonds that are systematically searched in correctOverlapped</a>
<a name="ln57"> </a>
<a name="ln58">  //Hydrogen valencies. Zero dummy element is the first</a>
<a name="ln59">	const int hVal[NELEMMCDL] = {</a>
<a name="ln60">    0,1,0,0,0,3,4,3,2,1,</a>
<a name="ln61">    0,0,0,3,4,3,2,1,0,0,</a>
<a name="ln62">    0,0,0,0,0,0,0,0,0,0,</a>
<a name="ln63">    0,0,4,3,2,1,0,0,0,0,</a>
<a name="ln64">    0,0,0,0,0,0,0,0,0,0,</a>
<a name="ln65">    2,3,2,1,0,0,0,0,0,0,</a>
<a name="ln66">    0,0,0,0,0,0,0,0,0,0,</a>
<a name="ln67">    0,0,0,0,0,0,0,0,0,0,</a>
<a name="ln68">    0,0,2,0,2,1,0,1,2,0,</a>
<a name="ln69">    0,0,0,0,0,0,0,0,0,0,</a>
<a name="ln70">    0,0,0,0,1,0,0,0,0,0,</a>
<a name="ln71">    0,0,0,0,0,0,0,0,0,0,0};</a>
<a name="ln72"> </a>
<a name="ln73">	const int maxVal[NELEMMCDL] = {</a>
<a name="ln74">    0,1,0,1,2,4,4,5,3,1,</a>
<a name="ln75">    0,1,2,4,4,6,6,7,0,1,</a>
<a name="ln76">    2,3,4,5,6,7,6,4,4,2,</a>
<a name="ln77">    2,3,4,5,6,7,8,1,2,3,</a>
<a name="ln78">    4,5,6,7,8,6,6,2,2,3,</a>
<a name="ln79">    4,5,6,7,8,1,2,3,4,4,</a>
<a name="ln80">    3,3,3,3,3,4,3,3,3,3,</a>
<a name="ln81">    3,3,4,5,6,7,8,6,6,3,</a>
<a name="ln82">    2,3,4,5,6,7,8,1,2,3,</a>
<a name="ln83">    4,5,6,6,6,6,3,4,3,3,</a>
<a name="ln84">    3,3,1,1,1,0,0,0,0,0,</a>
<a name="ln85">    0,8,1,8,5,0,0,0,0,0,0};</a>
<a name="ln86"> </a>
<a name="ln87">  const int chargeVal[NELEMMCDL] = {  //0 - dummy</a>
<a name="ln88">    0,-1,-1,-1,-1,-1,-1, 1, 1, 1,-1, //Ne</a>
<a name="ln89">    -1,-1,-1,-1, 1, 1, 1,-1,-1,-1, //Ca</a>
<a name="ln90">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, //Zn</a>
<a name="ln91">    -1,-1, 1, 1, 1,-1,-1,-1,-1,-1, //Zr</a>
<a name="ln92">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, //Sn</a>
<a name="ln93">    1, 1, 1,-1,-1,-1,-1,-1,-1,-1, //Nd</a>
<a name="ln94">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, //Yb</a>
<a name="ln95">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, //Hg</a>
<a name="ln96">    -1,-1, 1, 1, 1,-1,-1,-1,-1,-1, //Th</a>
<a name="ln97">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, //Fm</a>
<a name="ln98">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,</a>
<a name="ln99">    -1,-1,-1,-1,-1,-1,-1,-1,-1};</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">  const string aSymb[NELEMMCDL] = {&quot;0&quot;,</a>
<a name="ln103">                                   &quot;H&quot; ,&quot;He&quot;,&quot;Li&quot;,&quot;Be&quot;,&quot;B&quot; ,&quot;C&quot; ,&quot;N&quot; ,&quot;O&quot; ,&quot;F&quot; ,&quot;Ne&quot;,</a>
<a name="ln104">                                   &quot;Na&quot;,&quot;Mg&quot;,&quot;Al&quot;,&quot;Si&quot;,&quot;P&quot; ,&quot;S&quot; ,&quot;Cl&quot;,&quot;Ar&quot;,&quot;K&quot; ,&quot;Ca&quot;,</a>
<a name="ln105">                                   &quot;Sc&quot;,&quot;Ti&quot;,&quot;V&quot; ,&quot;Cr&quot;,&quot;Mn&quot;,&quot;Fe&quot;,&quot;Co&quot;,&quot;Ni&quot;,&quot;Cu&quot;,&quot;Zn&quot;,</a>
<a name="ln106">                                   &quot;Ga&quot;,&quot;Ge&quot;,&quot;As&quot;,&quot;Se&quot;,&quot;Br&quot;,&quot;Kr&quot;,&quot;Rb&quot;,&quot;Sr&quot;,&quot;Y&quot; ,&quot;Zr&quot;,</a>
<a name="ln107">                                   &quot;Nb&quot;,&quot;Mo&quot;,&quot;Tc&quot;,&quot;Ru&quot;,&quot;Rh&quot;,&quot;Pd&quot;,&quot;Ag&quot;,&quot;Cd&quot;,&quot;In&quot;,&quot;Sn&quot;,</a>
<a name="ln108">                                   &quot;Sb&quot;,&quot;Te&quot;,&quot;I&quot; ,&quot;Xe&quot;,&quot;Cs&quot;,&quot;Ba&quot;,&quot;La&quot;,&quot;Ce&quot;,&quot;Pr&quot;,&quot;Nd&quot;,</a>
<a name="ln109">                                   &quot;Pm&quot;,&quot;Sm&quot;,&quot;Eu&quot;,&quot;Gd&quot;,&quot;Tb&quot;,&quot;Dy&quot;,&quot;Ho&quot;,&quot;Er&quot;,&quot;Tm&quot;,&quot;Yb&quot;,</a>
<a name="ln110">                                   &quot;Lu&quot;,&quot;Hf&quot;,&quot;Ta&quot;,&quot;W&quot; ,&quot;Re&quot;,&quot;Os&quot;,&quot;Ir&quot;,&quot;Pt&quot;,&quot;Au&quot;,&quot;Hg&quot;,</a>
<a name="ln111">                                   &quot;Tl&quot;,&quot;Pb&quot;,&quot;Bi&quot;,&quot;Po&quot;,&quot;At&quot;,&quot;Rn&quot;,&quot;Fr&quot;,&quot;Ra&quot;,&quot;Ac&quot;,&quot;Th&quot;,</a>
<a name="ln112">                                   &quot;Pa&quot;,&quot;U&quot; ,&quot;Np&quot;,&quot;Pu&quot;,&quot;Am&quot;,&quot;Cm&quot;,&quot;Bk&quot;,&quot;Cf&quot;,&quot;Es&quot;,&quot;Fm&quot;,</a>
<a name="ln113">                                   &quot;Md&quot;,&quot;No&quot;,&quot;Lr&quot;,&quot;D&quot; ,&quot;&quot;  ,&quot;G&quot; ,&quot;0&quot; ,&quot;Xx&quot;,&quot;&quot;  ,&quot;&quot;  ,</a>
<a name="ln114">                                   &quot;M&quot; ,&quot;X&quot; ,&quot;A&quot; ,&quot;Q&quot; ,&quot;&quot;  ,&quot;&quot;  ,&quot;&quot;  ,&quot;&quot;  ,&quot;&quot;  ,&quot;&quot;};</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">#define NEXACTATOMS 21</a>
<a name="ln118">  const int exactAtom[NEXACTATOMS]={6,14,5,50,82,8,16,34,52,7,15,33,51,9,17,35,53,32,13,26,80};</a>
<a name="ln119">#define NALKALYATOMS 5</a>
<a name="ln120">  const int alkaly[NALKALYATOMS] ={3,11,19,37,55};</a>
<a name="ln121">#define NALKALYEARTHATOMS 5</a>
<a name="ln122">  const int alkalyEarth[NALKALYEARTHATOMS] ={4,12,20,38,56};</a>
<a name="ln123">#define NTRIVALENTATOMS 31</a>
<a name="ln124">  const int trivalent[NTRIVALENTATOMS] ={21,31,39,49,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,81,89,90,91,92,93,94,95,96,97,98,99};</a>
<a name="ln125">#define NTITANATOMS 3</a>
<a name="ln126">  const int titan[NTITANATOMS] ={22,40,72};</a>
<a name="ln127">#define NVANADIUMATOMS 3</a>
<a name="ln128">  const int vanadium[NVANADIUMATOMS] ={23,41,73};</a>
<a name="ln129">#define NCHROMIUMATOMS 3</a>
<a name="ln130">  const int cromium[NCHROMIUMATOMS] ={24,42,74};</a>
<a name="ln131">#define NMANGANESEATOMS 3</a>
<a name="ln132">  const int manganeze[NMANGANESEATOMS] ={25,43,75};</a>
<a name="ln133">#define NLIKEFEATOMS 2</a>
<a name="ln134">  const int likeFe[NLIKEFEATOMS] ={27,28};</a>
<a name="ln135">#define NPLATINUMATOMS 6</a>
<a name="ln136">  const int platinum[NPLATINUMATOMS] ={44,45,46,76,77,78};</a>
<a name="ln137">#define NCOPPERATOMS 3</a>
<a name="ln138">  const int copper[NCOPPERATOMS] ={29,47,79};</a>
<a name="ln139">#define NZINKATOMS 2</a>
<a name="ln140">  const int zink[NZINKATOMS] ={30,48};</a>
<a name="ln141"> </a>
<a name="ln142">#define NMETALS 78</a>
<a name="ln143">#define NHALOGENS 5</a>
<a name="ln144">#define NHETERO 10</a>
<a name="ln145">#define NAROMMAX 9</a>
<a name="ln146">#define NLIGHT_METALS 20</a>
<a name="ln147">#define NHEAVY_METALS 58</a>
<a name="ln148"> </a>
<a name="ln149">#define DEUTERIUM_ATOM 104</a>
<a name="ln150">#define METALL_ATOM 111</a>
<a name="ln151">#define HALOGEN_ATOM 112</a>
<a name="ln152">#define ANY_ATOM 113</a>
<a name="ln153">#define HETERO_ATOM 114</a>
<a name="ln154">#define ANY_BOND 8</a>
<a name="ln155"> </a>
<a name="ln156">  const int possibleAromatic [NAROMMAX] = {7,8,15,16,33,34,51,52,HETERO_ATOM};</a>
<a name="ln157">  const int metals[NMETALS] = {</a>
<a name="ln158">    3,4,11,12,13,19,20,21,22,23,24,25,26,27,28,29,</a>
<a name="ln159">    30,31,37,38,39,40,41,42,43,44,45,46,47,48,49,50,55,56,57,58,59,60,61,62,63,</a>
<a name="ln160">    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,87,88,89,90,91,</a>
<a name="ln161">    92,93,94,95,96,97,98,99,100,101,102,103};</a>
<a name="ln162"> </a>
<a name="ln163">  //#define A B   ??? -</a>
<a name="ln164">  const int lightMetals[NLIGHT_METALS] = {</a>
<a name="ln165">    3,4,11,12,13,19,20,21,22,23,24,25,26,27,28,29,30,31,37,38};</a>
<a name="ln166">  const int heavyMetals[NHEAVY_METALS] = {</a>
<a name="ln167">    39,40,41,42,43,44,45,46,47,48,49,50,55,56,57,58,59,60,61,62,63,</a>
<a name="ln168">    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,87,88,89,90,91,</a>
<a name="ln169">    92,93,94,95,96,97,98,99,100,101,102,103};</a>
<a name="ln170">  const int halogens[NHALOGENS] = {9,17,35,53,85};</a>
<a name="ln171">  const int hetero[NHETERO] = {7,8,14,15,16,33,34,51,52,84};</a>
<a name="ln172"> </a>
<a name="ln173">#define RUNDEF -1.2345678E9</a>
<a name="ln174">#define DEFAULTBONDLENGTH 1.44</a>
<a name="ln175">#define NDATABASE_MOLECULES 148</a>
<a name="ln176"> </a>
<a name="ln177">  const string strData[NDATABASE_MOLECULES]= {</a>
<a name="ln178">    &quot;05A53816506A53810000A00008692A99998857A6567442806020101030401050203050504&quot;,</a>
<a name="ln179">    &quot;06A25008659A74998659A99994330A74990000A25000000A00004330100203030405060106060406020305010305020104&quot;,</a>
<a name="ln180">    &quot;06A48805837A48800000A00007834A90467987A59523994A999962970802010103040106040502060503050302&quot;,</a>
<a name="ln181">    &quot;06A33680000A00003697A90943697A90949999A00009999E3368717109020101030203010602050304050606040405&quot;,</a>
<a name="ln182">    &quot;06A00002886A49980000A99992886A71137887A28867887E49985773070102020303060601010503040405&quot;,</a>
<a name="ln183">    &quot;07A00002500A00007499A86397499A86392500A43200000A69404999A4235999909070203070304050402030102050606070105&quot;,</a>
<a name="ln184">    &quot;07A18315489A81685489A18311830A81681830A49990000A00008658A9999865809050403050204010301060602020707010607&quot;,</a>
<a name="ln185">    &quot;07A51830000A99995257A61733821A00008921A86408921A16055257E45686533100604030601070704050702050301020304050602&quot;,</a>
<a name="ln186">    &quot;07A43300000A86602500A00002500A86607499A00007499A43309999A213550000801020301050606040402050301070607&quot;,</a>
<a name="ln187">    &quot;07A69274000A69270000A00000000A00004000A69277999A34649999E3464599909010203040407010707060605050104060203&quot;,</a>
<a name="ln188">    &quot;07A43309999A00007499A86607499A00002499A86602499A43300000E433049990806050406020101030305020406070702&quot;,</a>
<a name="ln189">    &quot;08A99994342A99991475A50354342A74810040A50351475A00004363A24800000A00001455100405050301020402030107080806070506030704&quot;,</a>
<a name="ln190">    &quot;08A14437499A43307499A57735000A43302500A14432500A00005000A57730000A57739999100102020303040405050601060407020808060607&quot;,</a>
<a name="ln191">    &quot;08A55684926A59770000A13416715A91136862A00003196A24094926A99995337E654534311106030806020101030401070408020708060503050207&quot;,</a>
<a name="ln192">    &quot;08A00003799A00009999A21890000A83936200A83930000A61999999E21896200E6199379912070206040206010203010805010806080703030507040405&quot;,</a>
<a name="ln193">    &quot;08A36607320A78867320A99993660A78860000A36600000A15473660A00002113A0000520709010202030304040505060106050701080807&quot;,</a>
<a name="ln194">    &quot;08A00005000A00008332A57705000A28419999A57708332A57701667A29290000A0000166709010202040405050301030306060707080801&quot;,</a>
<a name="ln195">    &quot;08A48819390A53570000A00007833A90467986A59523994A11895837A99996297E48815837100603050602080803040807040502070503010401&quot;,</a>
<a name="ln196">    &quot;08A19105257A80890000A99992628A19100000A00002628A80895257E50001004E500042531101080807070404050105060303020806070204020601&quot;,</a>
<a name="ln197">    &quot;08A50000000A50006666A00002886A16670000A83320000A99992886E66662886E33332886100108080303040401010707060605050106020302&quot;,</a>
<a name="ln198">    &quot;08A25008659A74998659A99994330A74990000A25000000A00004330E30622562E6937256209010202030304040505060106060703080708&quot;,</a>
<a name="ln199">    &quot;09A24994330A74994330A24991444A74991444A49990000A99995773A00005773A85558273A144382731105040305020401030602010607010207090708060908&quot;,</a>
<a name="ln200">    &quot;09A55375090A55370002A12826830A91696964A64713483A18610000A99995492A00003324E2320509012090305090201010304010704050207050908080308060602&quot;,</a>
<a name="ln201">    &quot;09A18510000A00003211A90859999A70960000A00008451A52418451A70965241E52413211E18515241130905050602050102080402080608090101040907070403070603&quot;,</a>
<a name="ln202">    &quot;09A19105257A49994253A49991004A19100000A00002628A80895257A99992628A80890000E386426281101020203030404050105060707080206030805090907&quot;,</a>
<a name="ln203">    &quot;09A49994252A80895257A49991004A80890000A19090000A00002628A19095257A99992628E218626281101020208080404030103030505060607070103090109&quot;,</a>
<a name="ln204">    &quot;09A00003622A10641208A32581208A49670000A32583622A99993247A81610000A68065661E593523311101020203030404050501030909070706060808050407&quot;,</a>
<a name="ln205">    &quot;09A31703170A50000000A00004999A36604999A68293170A63394999A99994999A81698169A18308169100102010303090904040502050106070507080806&quot;,</a>
<a name="ln206">    &quot;09A82718548A41359999A91956942A00008341A44961502A55014870A11246476A55010000E449664761107040607090401090301030609050608050804020102&quot;,</a>
<a name="ln207">    &quot;09A70330000A29660000A00002881A00007010A29669891A70339891A99997010A99992881E63994946100102020303040405050606070708010802090509&quot;,</a>
<a name="ln208">    &quot;09A80419999A43868037A89488452A00009735A15210000A53806452A11118037A53801698E43863169100704060702040102030103060209060805090805&quot;,</a>
<a name="ln209">    &quot;09A10176779A34868279A63437716A99994155A63430500A34860000A10171406A00004155E26634155100102020303090905050606070708010803040504&quot;,</a>
<a name="ln210">    &quot;09A16675773A50005773A83325773A50000000A16670000A00002886A83320000A99992886E66662886100102020909040405050601060407070808030302&quot;,</a>
<a name="ln211">    &quot;09A70296185A40884515A09414515A42940000A00006071A88530000A99994478E46463112E779448571103050803040202050102080409080604070109070706&quot;,</a>
<a name="ln212">    &quot;09A19319009A62699999A97487225A97482775A62690000A19310991A00005000A45715000A23465000100102020303040405050606070107080508020809&quot;,</a>
<a name="ln213">    &quot;10A43309999A86597499A72165000A43305000A28867499A86592500A43300000A28862500A00002500A0000749912020303040405010507080306040810050809091001020607&quot;,</a>
<a name="ln214">    &quot;10A46515888A50291200A06397575A81687425A55524463A17730000A16865888A88076225A00002513A9999993812070305070201010304010502080509070602090610080410&quot;,</a>
<a name="ln215">    &quot;10A48804396A48801478A00006392A90466546A59522553A11914396A99994857A59520000A69959494A2962949412060305060201010304010704070505080208040903101009&quot;,</a>
<a name="ln216">    &quot;10A25474570A16166133A62753127A54374570A54370000A94454931A86996254A38217369A00008932A1791999912010203010504040207040607030506030408020909100810&quot;,</a>
<a name="ln217">    &quot;10A00006995A25904430A25900855A66250000A99991632A46986995A63859327A85547850A85544430E46981632130201030204030410010607060807090802090509040510060510&quot;,</a>
<a name="ln218">    &quot;10A53026409A85668294A00008578A65814346A12696409A99996433A51190000A12692065A65810691E53022065130503040510010103040604091008080508070709091001020206&quot;,</a>
<a name="ln219">    &quot;10A99994745A58033967A85242714A58030000A24865324A65322714A00002818A82426113A18370000E32963967131005061004020205030106040306020808010409090707051007&quot;,</a>
<a name="ln220">    &quot;10A38760000A23092718A00008169A83160000A23097153A99998464A83164436A67457153E67452718E387644361405080205090402090809100101041007070406070806020103100503&quot;,</a>
<a name="ln221">    &quot;10A36631099A20423911A00000000A82571099A20428500A99999856A82575689A66328500E66323911E366356891410050508020509040209080910010104100707040607080603020103&quot;,</a>
<a name="ln222">    &quot;10A73929797A99996506A32668429A26361664A99991664A00009797A63030000A26366506E32663734E68198060130806100802010103030610020804030902050407050709050709&quot;,</a>
<a name="ln223">    &quot;10A00007120A10935313A99996759A14849577A54623723A48450000A82347300A63309577A89634915E4845531312020105020610100107100506090504010708040803070903&quot;,</a>
<a name="ln224">    &quot;10A18301830A50000000A81691830A99995000A00005000A18308169A50009999A81698169E50006340E5000366112010202030310100101050506060909080807070608040403&quot;,</a>
<a name="ln225">    &quot;10A62500000A25002165A76109666A99992165A25006783A40838511A99996491A00009666E74798226E4083374912020110010401070406100502080506080905070903060703&quot;,</a>
<a name="ln226">    &quot;10A73929796A99996506A32668429A26361663A99991663A00009796A63030000A26366506E32663734E6819805912080610080201010303061002080403090205040705070905&quot;,</a>
<a name="ln227">    &quot;11A11600000A46320000A57051522A28912486A00761522A28147513A00008476A10849999A45569999A56288476A284451212002010302070608070910100609080405050104030511041101110211110311060811071111091110&quot;,</a>
<a name="ln228">    &quot;12A86832482A65403688A00002482A21983688A43972482A43970000A21986311A00007446A43977446A65406311A43979999A8683744630030808111112120101060306060504020209090407050510100701021012091107080403010501101202120911101107080908040307030506020604&quot;,</a>
<a name="ln229">    &quot;11A55476610A55471550A30757567A91868524A65015060A24036610A99997020A32150000A24039664A00004877A00001550130506020101030401070405020705080210061110081109060309&quot;,</a>
<a name="ln230">    &quot;11A99994719A35190000A50464719A64810000A90277646A00004838A09727765A41667765A60187646A74542927A25462927131003041002111103040206071106030808070905030910010105&quot;,</a>
<a name="ln231">    &quot;11A54717869A10769779A91039894A00005034A21977869A99998274A65021620A65026365A05821505A19730000E547130661405020805010203010603060801110807110709111007100910040504&quot;,</a>
<a name="ln232">    &quot;11A63167961A37420000A00005471A63165546A43862037A09653395A68423395A00008150A18139999A47959999E342139991406030506021111030411070405020705030808090910100106070401&quot;,</a>
<a name="ln233">    &quot;11A50227868A00000000A06467868A63146852A06463611A63142407A88964074A18652407A30859999E18656852E5022361115011111050503060808100410010411060310090309010607070408020205&quot;,</a>
<a name="ln234">    &quot;11A33586997A99992256A00007945A62567945A51370000A20545575A82195337A20541779A61486761A86960000E33583081130805110501110608030601030906070904010704070205101002&quot;,</a>
<a name="ln235">    &quot;11A46588688A46585901A23299999A23294644A00008688A00005901A85963661A85960000A23290000E41501367E597136611405060406020401020305030107080207040904101011071108110908&quot;,</a>
<a name="ln236">    &quot;11A74236368A00008420A80755210A12646263A46091158A53023684A20804895A53020000A61998579A22849999E46094895130704060711040111030103061105060805080901100902100402&quot;,</a>
<a name="ln237">    &quot;11A31388599A13560000A00009949A58129999A37597499A07368599A63938949A45724300A05043100A17822600E31384849130603050611010103040107040511070510020810110909020508&quot;,</a>
<a name="ln238">    &quot;11A00004220A00001358A24810000A50001358A74818488A24815626A24818488A74815626A99994220A99991358E50004220130201030204031104061101060706081109081009041005080705&quot;,</a>
<a name="ln239">    &quot;11A85916567A35746567A99992562A23462655A00009594A49450000A23469594A12637033A79770000E48375123E758051231402040102031111101004030111010406090609030810070205080705&quot;,</a>
<a name="ln240">    &quot;11A09557693A34559510A65449510A90447693A99994755A90441816A65440000A34550000A09551816A00004755E3675475512010202030304040505060607070808090910011007110311&quot;,</a>
<a name="ln241">    &quot;11A00009999A42230000A00006825A78729999A52073492A10255079A87345449A87348517E10258517E78726930E422350791406030506021111031011071005020705090608090708041001040301&quot;,</a>
<a name="ln242">    &quot;11A13393318A13746318A70459999A49670000A86644773A44732909A00005045A90889045A21849999E78206545E49674999130601110210110506110406040702010708100508090210030903&quot;,</a>
<a name="ln243">    &quot;11A99995000A81698169A81691829A00005000A50009998A50000000A18301829A18308169E50006338E31703169E6830316912070408041004050802050102030106030706110109111009&quot;,</a>
<a name="ln244">    &quot;11A49991430A25005766A99991430A49997229A00001430A25000000A74990000A74995766E74992892E49994337E2500289212050606010701030904080201110510091110100803070402&quot;,</a>
<a name="ln245">    &quot;12A49997216A25008659A49994330A00007216A25002886A00004330A74992886A99994330A74998659A99997216A25000000A749900001405030605040202010103040609011009080707030810051107121211&quot;,</a>
<a name="ln246">    &quot;12A74852867A74850000A44730000A95313961A80111961A56432867A99993093A21052452A00004640A53805093A24853885E5058388515061205060201011204010704050207050809120801101011110903080203&quot;,</a>
<a name="ln247">    &quot;12A00003057A47044586A99994586A47041529A99991529A73520000A47047643A73529172A99997643A17970584A17975530E735261151406050406021203120305020402070708080909030211100101110410&quot;,</a>
<a name="ln248">    &quot;12A40419999A55880712A00007357A17531277A55884325A17535184A90205891A90209166A34830000E81107504E41302134E41306289160603050611121203101207100708030108010507050211040406040909020211&quot;,</a>
<a name="ln249">    &quot;12A83909999A37070000A00005869A00008652A44813000A08764391A75144695A68408652A75147390E08767390E68405999E37074391160603050602121203111207110502070510060910070908110408030401080901&quot;,</a>
<a name="ln250">    &quot;12A67547130A27484678A78944678A27481245A78941245A31286036A53210000A99995885A00006262A08487356E31282716E570157721412021203020406110305040711070507090210061009080301080601&quot;,</a>
<a name="ln251">    &quot;13A00008749A21667501A21669999A46659999A68308749A46657501A21662499A46652499A68301250A46650000A21660000A00001250A3501512124010201030304040505060602021313070708080909101011111212071311131013081309131213011303130413061305&quot;,</a>
<a name="ln252">    &quot;12A98975714A74231429A49490000A24741429A98978571A00005714A00008571A24749999A74239999E49498571E24744285E7423428512120202030304041111060607070808101009090505010112&quot;,</a>
<a name="ln253">    &quot;13A28577422A57147422A71424948A57142474A28572474A14284948A99994948A71420000A99990000A71429897A99999897A00002474A00007422160102020303040405050601060307040808090907021010111107051201131312&quot;,</a>
<a name="ln254">    &quot;13A99994826A91595517A83512806A74203552A54942806A94380000A44703607A85380666A16353603A25602863A13885888A00001596A08320912160507030504070204010201030408030608060907111010051310121309111209&quot;,</a>
<a name="ln255">    &quot;13A39485622A00003358A32469999A69013962A30124453A23988376A61112528A85093962A92982528A68711132A68710000A92980000E84791132160603050602010103040107040502070510130710040808090913101111120912&quot;,</a>
<a name="ln256">    &quot;13A60776420A66072578A90957683A28148103A52614999A83206052A20806788A00005578A07342947A07340000A20809999A52610000E40781315160506020101030401020507050807090813090213091012100512071104110603&quot;,</a>
<a name="ln257">    &quot;13A63116880A88436880A88432580A99994701A50224701A63110000A37776880A12442580A12446880A00004701A37770000A37772580A6311258015030413030501010202040513091007090512120808100507111206131106&quot;,</a>
<a name="ln258">    &quot;13A66660962A66662887A83333849A99992887A99990962A83330000A50000000A33330962A33332887A16660000A00000962A00002887A1666384915010202030304040505060106070808090107101111121213081009130209&quot;,</a>
<a name="ln259">    &quot;13A22073757A07045817A48844666A00000000A07048909A68573757A25832121A52145817A29129999A52148909A22071212E48847575E25834909160806130802010103030613020810031202051009120905091101071304110704&quot;,</a>
<a name="ln260">    &quot;13A18232941A00005293A47863921A77493823A00008725A71412941A22020980A51665293A25839999A51668725A18230000E47867254E22024215161308020101030306130208100312020510091209050911010713110704080604&quot;,</a>
<a name="ln261">    &quot;13A85754958A99992462A99997437A00004924A14072462A85750000A85759898A42717437A42712462A14077437A57289898A57280000E5728495815020103011301060207030813091311081209040510080509120610040711&quot;,</a>
<a name="ln262">    &quot;13A00008994A36698934A00006804A18349999A55028934A36693254A54560000A18345739A73371064A73373195A36691064E55024260E36696804160103080313080213040106110402091007090612121011071205020513100806&quot;,</a>
<a name="ln263">    &quot;13A60780000A67532108A39210000A32242108A10892108A89102108A00003963A99993963A39215201A60785201A79516296A20486296E501033451404031304020101031302050406020705080609101110120907120811&quot;,</a>
<a name="ln264">    &quot;13A60520000A10660521A39180000A20476299A10822113A89172113A00003961A99993961A79526299E60525168E39185168E32162113E675421131412031301010305120613070508061110091004110704080905021302&quot;,</a>
<a name="ln265">    &quot;14A22012921A22010284A00003814A43083895A26732069A05352921A44973124A67292962A64462313A99992313A84583976A71380000A92750000E74831014190603050602010103040107040502070514120814110909120709081113121413101113100408&quot;,</a>
<a name="ln266">    &quot;14A18759999A29620000A01974012A48374140A33072038A08392993A53803184A09386433A20735732A53808661A48875732A00008025E40976433E271529932006030506021414030414070405020705080306091304071108130911120809121011131001121001&quot;,</a>
<a name="ln267">    &quot;14A37508659A62498659A74996495A62494330A37504330A25006495A74992165A62490000A37500000A25002165A00002165A00006495A99996495A999921651701020203030404050506010607080809091004070510120610110313071411121314&quot;,</a>
<a name="ln268">    &quot;14A52504032A47494920A31242823A25623791A06253791A31240000A00004839A25620887A68756129A74375161A93755161A68758952A99994113A743780641705070305040702040102010304080306080611130911101301100209101409121412&quot;,</a>
<a name="ln269">    &quot;14A49995955A36928217A99993692A49992263A00008217A86945955A13032263A00004524A63070000A99990000E86942263E63073692E36924524E130359552314050201050208050708130408130213140707041401010411100904100903100603120103120912110606011104&quot;,</a>
<a name="ln270">    &quot;14A14989134A00007637A67720000A47251181A79534409A99995591A79536772A67722362A55916772A55914409A11815591A35457953A35453228A35455591161314121411141014091405100605070609070810041303040803021101120201&quot;,</a>
<a name="ln271">    &quot;14A00002151A10824678A74260000A21050075A57591849A38601849A29535658A38604678A57594678A64325658A85664678A99992037E29532829E6432282918130414130305050606040314071308060905101411091011121103120208070201020401&quot;,</a>
<a name="ln272">    &quot;14A57093413A57090749A79674204A79030000A00002206A99991915A39023454A39020749A16774204A17100083E30962955E30961415E65801415E658027892002040102031414131304030108100708091111121210090708021312060403060510090511071401&quot;,</a>
<a name="ln273">    &quot;14A00001443A00004330A25005728A60475728A50001443A25000000A75000000A99991443A99994330A85566830E25002887E75005773E60472887E5000433018010202030314140505060106050707080809071301111113141212090910100404030413&quot;,</a>
<a name="ln274">    &quot;14A14499999A00347478A43809999A58294608A58297478A00344608A00002521A58292521A43800000A14490000A28641391E43804999E14494999E286432171713020201050312051213030107130812090810071110091106020405041406141114&quot;,</a>
<a name="ln275">    &quot;14A19889999A45149217A66708216A88286043A70752304A13482174A00004521A12467216A70750000A44130000E29313695E56946043E40096303E4009313018131403130403050414050614070608071308071110110910050912110412021201020801&quot;,</a>
<a name="ln276">    &quot;14A60520641A99990000A38890641A00880000A10822716A88592716A00004565A99114565A20476866A78946866E60525772E38895772E32162716E6695271615130314010103051306140705080612111011091207090810050406020204&quot;,</a>
<a name="ln277">    &quot;15A15004047A35682933A10222610A35680000A59083989A28862199A54313197A00003461A72723050A67272258A90903461A99991848A75220440A93850440E795414082006070402020501020604030603080108050907101109131012111413141207051509151410111315&quot;,</a>
<a name="ln278">    &quot;14A99993463A89991732A89995196A60000000A39990000A60006927A10001732A00003463A10005196A39996927E29995196E29991732E70005196E700017321401020214140404050512120707080809091111101006061313030301&quot;,</a>
<a name="ln279">    &quot;15A14543959A34772874A10002551A34770000A57953929A28402111A53183108A00003402A71132991A65682229A93173842A92260411A99991877A73630411E84542874190607040202050102060403060308010805090710110915101315141014091311121412130705&quot;,</a>
<a name="ln280">    &quot;15A46187999A69287999A80825999A69284000A46184000A34645999A34642000A11552000A00004000A11555999A80822000A69280000A46180000A00007999A3464999918010202030304040505060106070808090910050706101112121313070411150110141415&quot;,</a>
<a name="ln281">    &quot;15A33335773A50006735A33333849A66665773A50002886A66663849A16662886A00003849A16666735A00005773A50000962A66660000A83330962A83334811A9999192418050603050102020404060103091001090307070808100511111212130613061413151514&quot;,</a>
<a name="ln282">    &quot;14A24498659A00004286A50331429A26170000A75508572A99994286A74490000A50337230E75505715E24495715E74492814E26172814E42283637E6140510915081414131303110703070906110608050905030412041202100210010801&quot;,</a>
<a name="ln283">    &quot;16A73181418A16684435A37326615A33468273A10227107A00004783A68276769A83024030A99994030A95756586A76088273A63930000A33840000A24491418A50242305A5024478330030208070908101111070910040305060602040513121413150101121415141613161516121601161608160916101607161116040316160506161602&quot;,</a>
<a name="ln284">    &quot;15A25446903A08194678A53505998A29245772A08191396A75436903A00005998A99992565A32750226A57301396A85660000A75431207A99995508E57304678E53502829191406041401030306040214100315020510091509050907010207130608131208151211081011&quot;,</a>
<a name="ln285">    &quot;16A70462641A70460264A90353433A51463508A66071886A88590264A49702829A29532716A32162075A00002075A13743584A26020000A99991773A06730000E22810906E853726412316030516020101030401070405020705151208151109091207090811131603131412151410111410040806130206&quot;,</a>
<a name="ln286">    &quot;16A38483333A57733333A67351666A57730000A38480000A28861666A28865000A38486666A57736666A28868333A38489999A57739999A67358333A09625000A00006666A09628333190102020303040405050601060708080901071011111212130810091307141415151616100209&quot;,</a>
<a name="ln287">    &quot;16A59953466A69901721A69905199A40043466A99993466A09841721A89921721A89925199A59950000A59956920A29865199A29861721A09845199A40046920A40040000A00003442190201030104010508070208030902100311041204141115121606131106120705150913161014&quot;,</a>
<a name="ln288">    &quot;15A71629322A12851233A50830000A00003000A71620675A50839999A95106091A00006997A95103906A12858764E76162814E34588536E76167185E08895000E3458146215150202040414110505030315130707090911120606010113140808101012&quot;,</a>
<a name="ln289">    &quot;16A40003464A59993464A69991732A59990000A40000000A30001732A30005196A40006928A59996928A69995196A89995196A99993464A89991732A10001732A00003464A1000519618020303040405050601060708080909100107021010111112121303131415151616070614&quot;,</a>
<a name="ln290">    &quot;16A61204512A61201863A99992864A46586454A38260538A15304689A25005747A15301863A99990000A00006454A71320000A89854620E71322864E89851869E25002832E457855732308051505020501020715060810060710160601160407010413011203011211021409021412141311110913030309&quot;,</a>
<a name="ln291">    &quot;16A21912563A23970000A00003476A39953505A26941767A05712563A44522740A81270648A55482740A99992091A63922003A61874654A99993329E89262740E66443329E5091350521060305060201010304010704050207050416070915110911161215120914151313141310141011081008&quot;,</a>
<a name="ln292">    &quot;16A34524404A83733226A38885581A99991895A22621178A42462150A14683840A83734659A68645581A63880000A83730000A00001843A06740461E67061178E38883226E63882407190605140602161615150502140315080209080309101611100402041113051213071201071501&quot;,</a>
<a name="ln293">    &quot;16A21141056A39430000A60560000A78861056A78864045A60565101A00001056A99991056A99994045A00004045A21144045A39435101E39432113E60562113E39432988E6056298818010202030304041414131301010704080809071010111112120606051115151616050509&quot;,</a>
<a name="ln294">    &quot;16A89991732A99993464A69991732A59990000A40000000A30001732A10001732A00003464A10005196A89995196A40006928A59996928E69995196E30005196E59993464E400034641716151503030404050506160606070708080909141411111212131310100202010103&quot;,</a>
<a name="ln295">    &quot;17A57140000A42850825A71430825A42852474A71432474A85720000A28563299A57143299A99992474A99990825A28564949A14282474A57144949A42855774A14285774A00003299A000049492009100503030606100805040202010103070411071308141304081114121616170712151117150509&quot;,</a>
<a name="ln296">    &quot;16A49994173A99990759A00001897A87120000A44480000A15444316A14701043A99993083A84913984A00003510E30513367E69853225E69110901E29411897E72051897E485210911705141305041515161614130407140204070310061003080908020611091211010112&quot;,</a>
<a name="ln297">    &quot;16A00003849A16670962A33330000A16676735A66660000A83320962A33337697A99993849A66667697A83326735E83324810E49996735E83322887E49990962E16674810E16672887161602020303141405050606131308081111101009091212070704041515010116&quot;,</a>
<a name="ln298">    &quot;17A06651153A56331153A00007272A15759999A00009090A56332970A15754545A06652970A47249999A62989090A62987272A47244545A31490000E31493636E47246363E31499090E1575636318041605040317030507171407121512141115100909161011070812060602080113011302&quot;,</a>
<a name="ln299">    &quot;18A69995196A89995196A99993464A89991732A69991732A59993464A59996927A69998659A89998659A99996927A40003464A30005196A40006927A59990000A40000000A30001732A10001732A00003464220102020303040405050601060708080909100107021006111112121307130514141515161116171816171812&quot;,</a>
<a name="ln300">    &quot;18A40005196A59995196A69993464A59991732A40001732A30003464A69996928A89996928A99995196A89993464A10003464A00005196A10006928A30006928A49993464A69990000A49990000A49998609220102020303040405050601060708080909100207031011121213131406110114021504161617171514180718&quot;,</a>
<a name="ln301">    &quot;17A99992891A49990000A99990952A00000952A83330000A16660000A83335782A00002891A66668673A33338673A16665782E33336733E16663843E66666733E66660952E33330952E833338431716021502051506160717140709141012121111131308080404060305010317011009&quot;,</a>
<a name="ln302">    &quot;18A50003750A50001587A99990000A38055337A31250504A12503896A20424760A12501587A87493750A00005337A79570577A61940000A68744833A87491441E62590719E20422378E79572959E374046172308051605020501020716060810060710180601180407010409131713011311171409031411031514021512110212&quot;,</a>
<a name="ln303">    &quot;18A26160872A41280000A58720000A73830872A91270872A99992383A08720872A00002383A08723893A26163893A91273893A41284765A73833893A58724765E58723021E41283021E41281744E587217442001020203030404181817170101070708080909101016161515131314141212101311110606050504&quot;,</a>
<a name="ln304">    &quot;19A57143298A71432474A57144949A42852474A57141649A71430824A99992474A42855773A42850824A28563298A42854124A85720000A57140000A99990824A28564949A14282474A14285773A00003298A00004949220714020606121214010204090913130610041510030108030401150816181819101617151917110405010207&quot;,</a>
<a name="ln305">    &quot;19A29138599A32545200A00009919A53629999A72535319A07138599A60138879A75947359A50524360A46493040A52393200A47120000A33172040A64782279A35650680A61060920E39992279E59512080E3595759924060319060201010304010704190207191009181016141411110918161013111716121315171512150708020909050508&quot;,</a>
<a name="ln306">    &quot;18A83338796A16660979A00003911A33330000A00005865A99995865A66669775A66660000A16668796A83330979A33339775A99993911E50008796E83332932E16666842E50000979E16662932E8333684218081610081410121406121806041602041702031705031505091511091311071301071801&quot;,</a>
<a name="ln307">    &quot;20A93358165A33223593A66773593A33221633A16774532A66771633A83544532A16770694A50000694A00003593A50004532A99993593A00001633A99991633A75940000A90500000A75947145A66775470A93356205E8322069424101305100204040809040609030611020813070312141420200602051103120715061614151618031907171801191701&quot;,</a>
<a name="ln308">    &quot;21A51751924A51750189A66372528A37722565A48541396A62861924A36552075A21641999A23691509A95021396A09942641A19000000A04970000A00001509A70751509A74262150A88882603A84492037A99992037A84493924E169606792906030506020101030401070405020705211208211109091207090811131221131411131404081506161516031910171920181810151817201617&quot;,</a>
<a name="ln309">    &quot;20A83200000A66400000A99990000A33985090A66795090A83205090A17585090A99993327A99991714A50000000A33200000A16400000A00001714A00003427A00005090A00000000A99995090A50005090E50001714E5000332721010302011002051806051706081709080309191011101211161213161415071504071804201813141920&quot;,</a>
<a name="ln310">    &quot;21A99995173A38633013A26931504A22882200A92786421A22880000A04432955A60151579A55582231A55580149A76552418A72793029A00001158A09390000A80304259A84673649A80305700A99993649E94724259E08932200E4223237430200703200604040702042102030621030821100909021209111208101108201313071314140612151116151717161519161818191705050101191801&quot;,</a>
<a name="ln311">    &quot;21A93358655A33224083A66774083A33222123A16785022A66772123A83545022A16781184A49050000A00004083A50005022A99994083A00002123A99992123A75940490A90500490A75947635A66775961A93356696E83221184E500011842610130510020404082104062103061102081307031214142020060205110312071506161415161803190717180119170102092009&quot;,</a>
<a name="ln312">    &quot;22A33333849A33335773A50006735A66665773A66663849A50002886A83336735A99995773A99993849A83332886A16672886A00003849A00005773A16676735A16678659A33339622A50008659A83338659A83330962A66660000A50000962A16670962280102020303040405050601060708080909100407051011121213131401110214151616171703141507181920202121061019112221221718&quot;,</a>
<a name="ln313">    &quot;22A30772664A46152664A53841332A46150000A30770000A23081332A53843997A69223997A76912664A69221332A76915329A92305329A99993997A92302664A46155329A53846661A69226661A23083997A30775329A07691332A00002664A0769399727010202030304040505060106070808090910020703101112121313140811091407151516161711170118181915190620202121221822&quot;,</a>
<a name="ln314">    &quot;22A30008660A10008660A00006928A10005196A00003464A10001732A69998660A89998660A99996928A89995196A99993464A89991732A69991732A60000000A40000000A30001732E40006928E30005196E40003464E60003464E69995196E6000692827222121202019191818172217070808090910220721101011111212132013141515161619131406050504041816060302020101170403&quot;,</a>
<a name="ln315">    &quot;24A16673849A16675773A33336735A50005773A50003849A33332886A66666735A83325773A83323849A66662886A66660962A50000000A33330962A33338659A50009621A66668659A99998659A99996735A00006735A00008659A00000962A00002886A99992886A99990962310102020303040405050601060708080909100407051011121213130610110314141515160716171818080219192021220122232409232113112417161420&quot;,</a>
<a name="ln316">    &quot;24A31693170A31691056A49990000A68301056A68303170A89433170A99995000A89436830A68306830A68308943A49999999A31698943A31696830A10566830A00005000A10563170A86600000A99991340A99998660A86609999A13399999A00008660A00001340A13390000280102020303040405050606070708080909101011111212131314141515161601041706181817081910202019122114222221162302242423&quot;,</a>
<a name="ln317">    &quot;25A68361042A10676736A10673126A32261042A89323158A68368895A31618895A89326811A14140000A99751377A86340000A00001302A50240000A00004938A99754987A49499999A86349925A13409925A00008548A99758598A68366811A32263126A31616736A68363158A494949873224252325222521250124022322030422052406210723082109041005110112031304140315081606170618071902200820171505071601130214120918191110&quot;,</a>
<a name="ln318">    &quot;24A76718683A87797576A96755665A96754023A89382063A77440869A58510000A41080000A59929999A38329999A20659069A06467650A00005731A00003835A08841987A21650706E82286173E63078094E35928094E16716173E16713458E35921537E63071537E8228345824100909181019121111191220141313201421161515211622070808220723050606230524030404240317010202170118&quot;,</a>
<a name="ln319">    &quot;26A99991663A82650000A66210000A99990000A33330000A16890000A99993039A00001605A00003268A00006537A00008200A16899804A33339804A99996422A49770000A66669804A83099804A99998142A99999804A49779804A99994759A00009804A00004931A00000000E49776651E4977321127040102040302150326150515060524060824090823091023111022111222131220132520162017161917181914182114072101072526&quot;,</a>
<a name="ln320">    &quot;28A49997302A49992697A73025000A26975000A20233831A38327976A61687976A31576808A79763831A79766167A68086841A38322023A61682023A68423191A31573191A06743831A00005000A06746167A38320674A49990000A61680674A93253831A99995000A93256167A61689324A49999998A38329324A202361673204050106010706080309031010111107021202131314140912151505051616171718121919202021211309222223232424100725252626272706042828182808&quot;,</a>
<a name="ln321">    &quot;28A26160872A41280000A58720000A73830872A91270872A99995871A08720872A08722616A99994127A91272616A08727383A00005871A00004127A08729127A26169127A91277383A91279127A73839127A58729999A41289999E58728255E41288255E82555871E82554127E17445871E17444127E41281744E587217443201020203030404282827270101070708082626252511111212131308111414151522222121181819192020151817171616232324241010090906061610050504&quot;,</a>
<a name="ln322">    &quot;30A44366431A33185790A22067722A55474499A55475790A44363849A44367722A33184499A22142574A78864569A33331924A67136525A88962558A44440000A33330649A66663849A22143849A78635797A55630649A99991924A00006423A11115774A11114499A88800015A99990649A66660000A77770649A00087746A89043888A2214647033020103070405050130020604070108020917291010181109120513291415151116041723181219142013280321282221232224252520262727240806300316102619&quot;,</a>
<a name="ln323">    &quot;36A42856185A57146185A64284948A57143711A42853711A35714948A64282474A57141237A42851237A35712474A78564948A85713711A78562474A64287422A78567422A85716185A35717422A42858659A57148659A21434948A14296185A21437422A21432474A14293711A35710000A14291237A00003711A00006185A14298659A35719896A64289896A85718659A99996185A99993711A85711237A6428000048010202030304040505060106070808090910040705100311111212130713021414151516111601171718181914190620202121221722102323242024262309252821242730182229321519313412163336081335262536353433323130292827&quot;,</a>
<a name="ln324">    &quot;42A17323500A17326499A08665999A17327499A17322500A08664000A08665000A08662000A00002500A00003500A00006499A00007499A08667999A43302000A34641500A51961500A25982000A43307999A34648499A51968499A25987999A69286499A77935999A69287499A69283500A77934000A69282500A60622000A77935000A60627999A51960500A43300000A34640500A86593500A86592500A77932000A77937999A86597499A86596499A34649499A43309999A5196949948020302040105010603070706050808090910061011121213130403111415141615171705181918201921210422232224252625272728281626292923243030203132323333151631343535363627263424373738383923391940404141422042&quot;,</a>
<a name="ln325">    &quot;60A21159049A17778821A32689182A51019771A54399999A39459638A05577213A35427935A65078888A71849343A47678759A11047581A85878461A82498233A95786811A90306443A08305967A55447753A98515564A63245965A23246328A67698577A37587292A06883953A19256703A01416446A47485643A17834689A00004435A80685310A77586929A31054538A35284033A08213556A02733187A12641538A20943069A51044356A60942706A16031765A33451110A47510228A43082245A91646046A50851240A67475461A75283670A30831422A79273295A87472418A26680656A44130000A63102064A65830816A59060361A90224032A97103553A77360950A92952786A8075117890010201060112020302070304030804050409050605100611071707260818082109140918101310221122112312251226131413151416151915441619163017211724182019572030203821322231232523272435243725282629273327462833283429342935304931443146323732383343344035363640365137483839394539494041414241434252425443534456454845554647475347564851495050575058515252555354546055585659575958605960&quot;,</a>
<a name="ln326">  };</a>
<a name="ln327"> </a>
<a name="ln328">#define NBONDTYPES 11</a>
<a name="ln329"> </a>
<a name="ln330">  const int bondValence[NBONDTYPES] = {1,2,3,1,1,0,0,0,1,1,1};</a>
<a name="ln331"> </a>
<a name="ln332">  const string fsastart=&quot;{SA:&quot;;</a>
<a name="ln333">  const string fsbstart=&quot;{SB:&quot;;</a>
<a name="ln334"> </a>
<a name="ln335"> </a>
<a name="ln336">  string intToStr(int k) {</a>
<a name="ln337">    char temp[16];</a>
<a name="ln338">    sprintf(temp,&quot;%d&quot;,k);</a>
<a name="ln339">    string line=temp;</a>
<a name="ln340">    return line;</a>
<a name="ln341">  };</a>
<a name="ln342"> </a>
<a name="ln343"> </a>
<a name="ln344">  //-------------------------------------------------------------------</a>
<a name="ln345">  class Rect {</a>
<a name="ln346">  public:</a>
<a name="ln347">    double left,top,right,bottom;</a>
<a name="ln348">  };</a>
<a name="ln349"> </a>
<a name="ln350">  class Point {</a>
<a name="ln351">  public:</a>
<a name="ln352">    double x,y;</a>
<a name="ln353">  };</a>
<a name="ln354"> </a>
<a name="ln355">  //-------------------------------------------------------------------</a>
<a name="ln356">  class  TSingleAtom  {</a>
<a name="ln357">  public:</a>
<a name="ln358">    short int na;   /*Atom position in the Periodic Table (nucley charge)*/</a>
<a name="ln359">    short int nv;   /*Current atom's valence*/</a>
<a name="ln360">    short int nc;   /*-9..+9 atom's charge*/</a>
<a name="ln361">    short int iz;   /*Isotope difference between round(AtomMass)*/</a>
<a name="ln362">    double    rx;   /*Internal X-coordinate representation*/</a>
<a name="ln363">    double    ry;   /*Internal Y-coordinate representation*/</a>
<a name="ln364">    short int rl;   /*radical label*/</a>
<a name="ln365">    short int nb;   /*Number of neightboring atoms*/</a>
<a name="ln366">    int gtd;        /*Depth of atom in molecule according to GTD*/</a>
<a name="ln367">    short int currvalence;</a>
<a name="ln368">    /*Valence, excluding non-defined hydrogen</a>
<a name="ln369">      atoms. Equal sum of valences for each  bond type.*/</a>
<a name="ln370">    short int special;</a>
<a name="ln371">    /*Special=0 - no special definition</a>
<a name="ln372">      =1 - no other atoms, except explicitly defined, can</a>
<a name="ln373">      be connected with the atom (query structure)*/</a>
<a name="ln374">    short int ac[CONNMAX];</a>
<a name="ln375">    /*atom's numbers in array ATOM, which are</a>
<a name="ln376">      connected with the atom selected*/</a>
<a name="ln377">    short int astereo;   /*=0 - no stereo, =1 - R, = 2 -S,  = 3 - unknown*/</a>
<a name="ln378"> </a>
<a name="ln379">    string anum;</a>
<a name="ln380">    int enumerator;</a>
<a name="ln381">    int fragIndex;</a>
<a name="ln382"> </a>
<a name="ln383">    TSingleAtom() {</a>
<a name="ln384">      na=6; nv=hVal[na]; gtd=0;</a>
<a name="ln385">      nc=0; iz=0; nb=0; rl=0; currvalence=0; special=0; astereo=0; enumerator=0; fragIndex=0;</a>
<a name="ln386">    };</a>
<a name="ln387">    TSingleAtom * clone();</a>
<a name="ln388">    int encoder();</a>
<a name="ln389">    int chargeConversion();</a>
<a name="ln390">    int valencyConversion();</a>
<a name="ln391">    int allAtAtom();</a>
<a name="ln392">    void atomCopy(TSingleAtom * source);</a>
<a name="ln393">    static bool atomEquivalent(TSingleAtom * structure, TSingleAtom * query,</a>
<a name="ln394">                               int nHStr, int nHQuery, bool chargeSensitivity, bool isotopeSensitivity);</a>
<a name="ln395">    static int chargeDeltaValency(int atomNo);</a>
<a name="ln396">  };</a>
<a name="ln397"> </a>
<a name="ln398">  class  TSingleBond  {</a>
<a name="ln399">  public:</a>
<a name="ln400">    short int tb;</a>
<a name="ln401">    /*Bond type:</a>
<a name="ln402">      1 - single</a>
<a name="ln403">      2 - double</a>
<a name="ln404">      3 - triple</a>
<a name="ln405">      4 - aromathic (query)</a>
<a name="ln406">      5 - single/double (query)</a>
<a name="ln407">      6 - coordinational</a>
<a name="ln408">      7 - not used</a>
<a name="ln409">      8 - any (query)</a>
<a name="ln410">      9 - up</a>
<a name="ln411">      10 - down</a>
<a name="ln412">      11 - either*/</a>
<a name="ln413">    short int at[2];     /*Bond definition-atoms number in array ATOM*/</a>
<a name="ln414">    short int db;        /*Ring/Chain conditions*/</a>
<a name="ln415"> </a>
<a name="ln416">    // The original MCDL code used bstereo to store the bond stereo</a>
<a name="ln417">    short int bstereo;   /* =0 - no, =1 - E , = 2 - Z, =3 E/Z*/</a>
<a name="ln418">    // The new code uses bstereo_refs, the refs from the OBCisTransStereo object arranged in a U</a>
<a name="ln419">    //</a>
<a name="ln420">    //                            1       4</a>
<a name="ln421">    //                             \     /</a>
<a name="ln422">    //                              X = Y</a>
<a name="ln423">    //                             /     \</a>
<a name="ln424">    //                            2       3</a>
<a name="ln425">    vector&lt;unsigned long&gt; bstereo_refs;</a>
<a name="ln426"> </a>
<a name="ln427">    short int special;</a>
<a name="ln428">    int enumerator;</a>
<a name="ln429">    /*=1 - Chain (query)</a>
<a name="ln430">      =2 - Ring  (query)</a>
<a name="ln431">      =3 - CIS/TRANS</a>
<a name="ln432">      =4 - CIS/TRANS+Chain;</a>
<a name="ln433">      =5 - CIS/TRANS+Ring;*/</a>
<a name="ln434">    TSingleBond * clone();</a>
<a name="ln435">    int bondConversion();</a>
<a name="ln436">    void bondCopy(TSingleBond * source);</a>
<a name="ln437">    static bool bondEquivalent(TSingleBond * sBond, TSingleBond * qBond);</a>
<a name="ln438">    int getValence();</a>
<a name="ln439">  };</a>
<a name="ln440">  //-------------------------------------------------------------------</a>
<a name="ln441">  TSingleAtom * TSingleAtom::clone() {</a>
<a name="ln442">    TSingleAtom * result;</a>
<a name="ln443">    result=new TSingleAtom();</a>
<a name="ln444"> </a>
<a name="ln445">    result-&gt;astereo=this-&gt;astereo;</a>
<a name="ln446">    for (int i=0; i&lt;CONNMAX; i++) result-&gt;ac[i]=this-&gt;ac[i];</a>
<a name="ln447">    result-&gt;currvalence=this-&gt;currvalence;</a>
<a name="ln448">    result-&gt;iz=this-&gt;iz;</a>
<a name="ln449">    result-&gt;na=this-&gt;na;</a>
<a name="ln450">    result-&gt;nb=this-&gt;nb;</a>
<a name="ln451">    result-&gt;nc=this-&gt;nc;</a>
<a name="ln452">    result-&gt;nv=this-&gt;nv;</a>
<a name="ln453">    result-&gt;rl=this-&gt;rl;</a>
<a name="ln454">    result-&gt;rx=this-&gt;rx;</a>
<a name="ln455">    result-&gt;ry=this-&gt;ry;</a>
<a name="ln456">    result-&gt;gtd=this-&gt;gtd;</a>
<a name="ln457">    result-&gt;special=this-&gt;special;</a>
<a name="ln458">    result-&gt;enumerator=this-&gt;enumerator;</a>
<a name="ln459">    result-&gt;fragIndex=this-&gt;fragIndex;</a>
<a name="ln460">    result-&gt;anum=this-&gt;anum;</a>
<a name="ln461">    return result;</a>
<a name="ln462">  };</a>
<a name="ln463"> </a>
<a name="ln464"> </a>
<a name="ln465">  int TSingleAtom::chargeDeltaValency(int atomNo) {</a>
<a name="ln466">    int result=-1;</a>
<a name="ln467">    if (atomNo &lt; NELEMMCDL) result=chargeVal[atomNo];</a>
<a name="ln468">    return result;</a>
<a name="ln469">  };</a>
<a name="ln470"> </a>
<a name="ln471">  int TSingleAtom::encoder() {</a>
<a name="ln472">    // For given atom's number ATN in array ATOM returns a number from 1 to 32.</a>
<a name="ln473">    //  Atoms with related properties have the same number. It is required to reduce</a>
<a name="ln474">    //  the possible number of fragments in structure}</a>
<a name="ln475">    int i;</a>
<a name="ln476"> </a>
<a name="ln477">    for (i=0; i&lt;NEXACTATOMS; i++) if (exactAtom[i] == na) return i;</a>
<a name="ln478">    for (i=0; i&lt;NALKALYATOMS; i++) if (na == alkaly[i]) return 21;</a>
<a name="ln479">    for (i=0; i&lt;NALKALYEARTHATOMS; i++) if (na == alkalyEarth[i]) return 22;</a>
<a name="ln480">    for (i=0; i&lt;NTRIVALENTATOMS; i++) if (na == trivalent[i]) return 23;</a>
<a name="ln481">    for (i=0; i&lt;NTITANATOMS; i++) if (na == titan[i]) return 24;</a>
<a name="ln482">    for (i=0; i&lt;NVANADIUMATOMS; i++) if (na == vanadium[i]) return 25;</a>
<a name="ln483">    for (i=0; i&lt;NCHROMIUMATOMS; i++) if (na == cromium[i]) return 26;</a>
<a name="ln484">    for (i=0; i&lt;NMANGANESEATOMS; i++) if (na == manganeze[i]) return 27;</a>
<a name="ln485">    for (i=0; i&lt;NCOPPERATOMS; i++) if (na == copper[i]) return 28;</a>
<a name="ln486">    for (i=0; i&lt;NLIKEFEATOMS; i++) if (na == likeFe[i]) return 29;</a>
<a name="ln487">    for (i=0; i&lt;NZINKATOMS; i++) if (na == zink[i]) return 30;</a>
<a name="ln488">    for (i=0; i&lt;NPLATINUMATOMS; i++) if (na == platinum[i]) return 31;</a>
<a name="ln489">    return 32;</a>
<a name="ln490">  };</a>
<a name="ln491"> </a>
<a name="ln492">  int TSingleAtom::chargeConversion() {</a>
<a name="ln493"> </a>
<a name="ln494">    //  3 - if radical label present.</a>
<a name="ln495">    //  2 - if charge &lt;0</a>
<a name="ln496">    //  1 - if charge &gt;0</a>
<a name="ln497">    //  0 - charge=0</a>
<a name="ln498"> </a>
<a name="ln499">    if (nc &lt; 0) return 2;</a>
<a name="ln500">    if (nc &gt; 0) return 1;</a>
<a name="ln501">    return 0;</a>
<a name="ln502">  };</a>
<a name="ln503"> </a>
<a name="ln504">  int TSingleAtom::valencyConversion() {</a>
<a name="ln505"> </a>
<a name="ln506">    //for atom's number ATN in array ATOM returns some connected with valency value:</a>
<a name="ln507">    // =2-Valence of ATN is less, then usual</a>
<a name="ln508">    // =1-Valence of ATN is more, then usual</a>
<a name="ln509">    // =0-usual valency</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">    int k1,k2;</a>
<a name="ln513">    int result=0;</a>
<a name="ln514"> </a>
<a name="ln515">    //Default hydrogen</a>
<a name="ln516">    k1=nv;</a>
<a name="ln517">    k1=k1-currvalence-abs(nc)-rl;</a>
<a name="ln518">    if (k1&lt;0) k1=0;</a>
<a name="ln519">    k2=hVal[na];</a>
<a name="ln520">    k2=k2-currvalence-abs(nc)-rl;</a>
<a name="ln521">    if (k2&lt;0) k2=0;</a>
<a name="ln522">    if (k1 == k2) result=0; else if (k1 &lt; k2) result=1; else result=2;</a>
<a name="ln523">    return result;</a>
<a name="ln524">  };</a>
<a name="ln525"> </a>
<a name="ln526">  int TSingleAtom::allAtAtom() {</a>
<a name="ln527">    //Define a digital representation of atom, they include:</a>
<a name="ln528">    //  a) Position of atom in the Periodic System</a>
<a name="ln529">    //  b) Its charge</a>
<a name="ln530">    //  c) Its valency}</a>
<a name="ln531"> </a>
<a name="ln532">    int b1,b2,b3,w;</a>
<a name="ln533"> </a>
<a name="ln534">    b1=encoder();</a>
<a name="ln535">    b2=chargeConversion();</a>
<a name="ln536">    b3=valencyConversion();</a>
<a name="ln537">    w=b3;</a>
<a name="ln538">    w=w &lt;&lt; 2;</a>
<a name="ln539">    w=w+b2;</a>
<a name="ln540">    w=w &lt;&lt; 5;</a>
<a name="ln541">    w=w+b1;</a>
<a name="ln542">    if (rl != 0) w= ~w;</a>
<a name="ln543">    return w;</a>
<a name="ln544">  };</a>
<a name="ln545"> </a>
<a name="ln546">  void TSingleAtom::atomCopy(TSingleAtom * source) {</a>
<a name="ln547"> </a>
<a name="ln548">    this-&gt;astereo=source-&gt;astereo;</a>
<a name="ln549">    for (int i=0; i&lt;CONNMAX; i++) this-&gt;ac[i]=source-&gt;ac[i];</a>
<a name="ln550">    this-&gt;currvalence=source-&gt;currvalence;</a>
<a name="ln551">    this-&gt;iz=source-&gt;iz;</a>
<a name="ln552">    this-&gt;na=source-&gt;na;</a>
<a name="ln553">    this-&gt;nb=source-&gt;nb;</a>
<a name="ln554">    this-&gt;nc=source-&gt;nc;</a>
<a name="ln555">    this-&gt;nv=source-&gt;nv;</a>
<a name="ln556">    this-&gt;rl=source-&gt;rl;</a>
<a name="ln557">    this-&gt;rx=source-&gt;rx;</a>
<a name="ln558">    this-&gt;ry=source-&gt;ry;</a>
<a name="ln559">    this-&gt;special=source-&gt;special;</a>
<a name="ln560">  };</a>
<a name="ln561"> </a>
<a name="ln562">  bool TSingleAtom::atomEquivalent(TSingleAtom * structure, TSingleAtom * query,</a>
<a name="ln563">                                   int nHStr, int nHQuery, bool chargeSensitivity, bool isotopeSensitivity) {</a>
<a name="ln564">    bool result=false;</a>
<a name="ln565">    int i,j,k;</a>
<a name="ln566"> </a>
<a name="ln567">    if (structure == nullptr || query == nullptr) return result;</a>
<a name="ln568">    i=nHQuery;</a>
<a name="ln569">    if (i&gt;0) {   //if explicitly defined H is accociated with query atom</a>
<a name="ln570">      j=structure-&gt;nv;</a>
<a name="ln571">      k=abs(structure-&gt;nc);</a>
<a name="ln572">      if (k&gt;9) k=k-9;</a>
<a name="ln573">      j=j-structure-&gt;currvalence-k;</a>
<a name="ln574">      if (j&lt;0) j=0;</a>
<a name="ln575">      j=j+nHStr;</a>
<a name="ln576">      if (i&gt;j) return result;</a>
<a name="ln577">      //on corresponding structure atom must be at least the same number of H}</a>
<a name="ln578">    }</a>
<a name="ln579">    if (((structure-&gt;nc != query-&gt;nc) &amp;&amp; chargeSensitivity)</a>
<a name="ln580">        || ((structure-&gt;rl != query-&gt;rl) &amp;&amp; chargeSensitivity)</a>
<a name="ln581">        || ((structure-&gt;iz != query-&gt;iz) &amp;&amp; isotopeSensitivity)) return result;</a>
<a name="ln582">    //non-equivalency of Charge and Isotop is case of exact matching of these attributes</a>
<a name="ln583">    i=query-&gt;special; //'NO OTHER' attribute on query</a>
<a name="ln584">    if (i == 1)  if ((structure-&gt;nb-nHStr) != query-&gt;nb) return result;</a>
<a name="ln585">    //'NO OTHER' means, that number of neighbour in query must be the same as in structure</a>
<a name="ln586">    //Checking for equivalent position in the Periodic Table</a>
<a name="ln587">    if (structure-&gt;na == query-&gt;na) result=true; else {</a>
<a name="ln588">      if (query-&gt;na == METALL_ATOM) { //Metall checking</a>
<a name="ln589">        for (i=0; i&lt;NMETALS; i++) if (structure-&gt;na == metals[i]) {</a>
<a name="ln590">            result=true;</a>
<a name="ln591">            break;</a>
<a name="ln592">          }</a>
<a name="ln593">      }</a>
<a name="ln594">      if (query-&gt;na == HALOGEN_ATOM) { //Halogen checking</a>
<a name="ln595">        for (i=0; i&lt;NHALOGENS; i++) if (structure-&gt;na == halogens[i]) {</a>
<a name="ln596">            result=true;</a>
<a name="ln597">            break;</a>
<a name="ln598">          }</a>
<a name="ln599">      }</a>
<a name="ln600">      if (query-&gt;na == HETERO_ATOM) { //Hetero checking</a>
<a name="ln601">        for (i=0; i&lt;NHETERO; i++) if (structure-&gt;na == hetero[i]) {</a>
<a name="ln602">            result=true;</a>
<a name="ln603">            break;</a>
<a name="ln604">          }</a>
<a name="ln605">      }</a>
<a name="ln606">      if (query-&gt;na == ANY_ATOM) result=true; //Any atom</a>
<a name="ln607">    }</a>
<a name="ln608">    return result;</a>
<a name="ln609">  };</a>
<a name="ln610"> </a>
<a name="ln611">  //----------------  TSingleBond methods ----------------------</a>
<a name="ln612">  TSingleBond * TSingleBond::clone() {</a>
<a name="ln613">    TSingleBond * result;</a>
<a name="ln614">    result=new TSingleBond();</a>
<a name="ln615"> </a>
<a name="ln616">    result-&gt;at[0]=this-&gt;at[0];</a>
<a name="ln617">    result-&gt;at[1]=this-&gt;at[1];</a>
<a name="ln618">    result-&gt;bstereo=this-&gt;bstereo;</a>
<a name="ln619">    result-&gt;bstereo_refs=this-&gt;bstereo_refs;</a>
<a name="ln620">    result-&gt;db=this-&gt;db;</a>
<a name="ln621">    result-&gt;special=this-&gt;special;</a>
<a name="ln622">    result-&gt;tb=this-&gt;tb;</a>
<a name="ln623">    result-&gt;enumerator=this-&gt;enumerator;</a>
<a name="ln624">    return result;</a>
<a name="ln625">  };</a>
<a name="ln626"> </a>
<a name="ln627">  int TSingleBond::getValence() {</a>
<a name="ln628">    int result=0;</a>
<a name="ln629">    if (this-&gt;tb &lt;=NBONDTYPES) result=bondValence[this-&gt;tb-1];</a>
<a name="ln630">    return result;</a>
<a name="ln631">  };</a>
<a name="ln632"> </a>
<a name="ln633">  bool TSingleBond::bondEquivalent(TSingleBond * sBond, TSingleBond * qBond){</a>
<a name="ln634">    //for bond's number BONDNUMBER in structure (BOND) and for query bond's number</a>
<a name="ln635">    //QBONDNUMBER (QBOND) determines, if they may be accociated one with other.</a>
<a name="ln636">    //QBC-array, for each query bond contains explicitly defined cyclic conditions:</a>
<a name="ln637">    // 0-no cyclic condition is implemented</a>
<a name="ln638">    // 1-query bond and corresponding structure bond must be a Chain</a>
<a name="ln639">    // 2-query bond and corresponding structure bond must be a Ring</a>
<a name="ln640">    //Function has 'TRUE' value if bonds can be matched, FALSE otherwise</a>
<a name="ln641"> </a>
<a name="ln642">    bool test1;</a>
<a name="ln643">    int bT,qBT,bD,qBD;</a>
<a name="ln644">    bool result=false;</a>
<a name="ln645"> </a>
<a name="ln646">    bT=sBond-&gt;tb; qBT=qBond-&gt;tb;</a>
<a name="ln647">    bD=sBond-&gt;db; qBD=qBond-&gt;db;</a>
<a name="ln648">    if (sBond-&gt;special&gt;=3) sBond-&gt;special=sBond-&gt;special-3;</a>
<a name="ln649">    if (qBond-&gt;special&gt;=3) qBond-&gt;special=qBond-&gt;special-3;</a>
<a name="ln650">    if (((qBond-&gt;special==1) &amp;&amp; (bD&gt;1)) || ((qBond-&gt;special==2) &amp;&amp; (bD&lt;2))) return result;</a>
<a name="ln651">    //Explicitly defined cyclic conditions are violated</a>
<a name="ln652">    if ((qBD&gt;1) &amp;&amp; (bD&lt;2)) return result;</a>
<a name="ln653">    //Implicitly defined cyclic conditions are violated}</a>
<a name="ln654">    if (qBT==ANY_BOND) {  //Any bond in query</a>
<a name="ln655">      result=true;</a>
<a name="ln656">      return result;</a>
<a name="ln657">    };</a>
<a name="ln658">    if ((qBT==4) || (qBD==2) || (qBD==3)) { //Aromatic bond</a>
<a name="ln659">      result=(bD==2) || (bD==3) || (bT==4);</a>
<a name="ln660">      return result;</a>
<a name="ln661">    };</a>
<a name="ln662">    if ((bD==2) || (bD==3)) {</a>
<a name="ln663">      //non-Aromatic in query, but Aromatic in structure</a>
<a name="ln664">      result=false;</a>
<a name="ln665">      return result;</a>
<a name="ln666">    };</a>
<a name="ln667">    test1=false;</a>
<a name="ln668">    if ((qBT==5) &amp;&amp; ((bT==1) || (bT==2) || (bT==5))) test1=true;</a>
<a name="ln669">    //SINGLE/DOUBLE query bond</a>
<a name="ln670">    if (bT==qBT) test1=true;</a>
<a name="ln671">    //Type of bonds in structure and in query are equivalent}</a>
<a name="ln672">    result=test1;</a>
<a name="ln673">    return result;</a>
<a name="ln674">  };</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">  int TSingleBond::bondConversion() {</a>
<a name="ln678">    //generate a code for bond's nuber BNB in array BOND. It is took into consi-</a>
<a name="ln679">    //deration bond type and cycle size</a>
<a name="ln680">    int b1,b2;</a>
<a name="ln681"> </a>
<a name="ln682">    if (tb &gt; 4) b1=0; else b1=tb;</a>
<a name="ln683">    b2=7; //for other Switch value</a>
<a name="ln684">    switch (db) {</a>
<a name="ln685">    case 0 :</a>
<a name="ln686">      b2=5;</a>
<a name="ln687">      break;</a>
<a name="ln688">    case 1 :</a>
<a name="ln689">      b2=0;</a>
<a name="ln690">      break;</a>
<a name="ln691">    case 2 :</a>
<a name="ln692">      b1=4;</a>
<a name="ln693">      b2=1;</a>
<a name="ln694">      break;</a>
<a name="ln695">    case 3 :</a>
<a name="ln696">      b1=4;</a>
<a name="ln697">      b2=2;</a>
<a name="ln698">      break;</a>
<a name="ln699">    case 4 :</a>
<a name="ln700">      b2=3;</a>
<a name="ln701">      break;</a>
<a name="ln702">    case 5 :</a>
<a name="ln703">      b2=4;</a>
<a name="ln704">      break;</a>
<a name="ln705">    case 6 :</a>
<a name="ln706">      b2=6;</a>
<a name="ln707">      break;</a>
<a name="ln708">    };</a>
<a name="ln709">    b2=b2 &lt;&lt; 2;</a>
<a name="ln710">    b2=b2+b1;</a>
<a name="ln711">    return b2;</a>
<a name="ln712">  };</a>
<a name="ln713"> </a>
<a name="ln714">  void TSingleBond::bondCopy(TSingleBond * source) {</a>
<a name="ln715">    this-&gt;at[0]=source-&gt;at[0];</a>
<a name="ln716">    this-&gt;at[1]=source-&gt;at[1];</a>
<a name="ln717">    this-&gt;bstereo=source-&gt;bstereo;</a>
<a name="ln718">    this-&gt;db=source-&gt;db;</a>
<a name="ln719">    this-&gt;special=source-&gt;special;</a>
<a name="ln720">    this-&gt;tb=source-&gt;tb;</a>
<a name="ln721">  };</a>
<a name="ln722"> </a>
<a name="ln723">  //******************************************************************</a>
<a name="ln724">  //                      TSimpleMolecule</a>
<a name="ln725">  //------------------------------------------------------------------</a>
<a name="ln726">  class TSimpleMolecule {</a>
<a name="ln727">  protected:</a>
<a name="ln728">    std::vector&lt;TSingleAtom*&gt; fAtom;</a>
<a name="ln729">    std::vector&lt;TSingleBond*&gt; fBond;</a>
<a name="ln730">  public:</a>
<a name="ln731">    std::ostream * refofs;</a>
<a name="ln732">    virtual ~TSimpleMolecule() {</a>
<a name="ln733">      clear();</a>
<a name="ln734">    };</a>
<a name="ln735">    TSimpleMolecule() {</a>
<a name="ln736">      refofs = nullptr;</a>
<a name="ln737">    };</a>
<a name="ln738"> </a>
<a name="ln739">    int nAtoms();</a>
<a name="ln740">    int nBonds();</a>
<a name="ln741">    TSingleAtom * getAtom(int index);</a>
<a name="ln742">    TSingleBond * getBond(int index);</a>
<a name="ln743">    void defineAtomConn();</a>
<a name="ln744">    void defineBondConn(neighbourlist *bondConnection);</a>
<a name="ln745">    void newB(neighbourlist * bk, int bnum, int anum, int &amp; total, int * e, int * e1);</a>
<a name="ln746">    void singleVawe(neighbourlist * bk, std::vector&lt;int&gt; &amp; alreadyDefined,</a>
<a name="ln747">                    std::vector&lt;int&gt; &amp; prevBond, std::vector&lt;int&gt; &amp; prevAtom,</a>
<a name="ln748">                    int &amp; nPrev, std::vector&lt;int&gt; &amp; curBond, std::vector&lt;int&gt; &amp; curAtom);</a>
<a name="ln749">    void vaweBond(int bondN, neighbourlist * bk, int &amp; ringSize, std::vector&lt;int&gt; &amp; bondList);</a>
<a name="ln750">    void allAboutCycles();</a>
<a name="ln751">    void redraw(const std::vector&lt;int&gt;listAtomClean, const std::vector&lt;int&gt;listBondClean,</a>
<a name="ln752">                int atomClean, int &amp; bondClean, int spn, int sCHA1, int sCHB1, bool iOPT7);</a>
<a name="ln753">    void clear();</a>
<a name="ln754">    void readOBMol(OBMol * pmol);</a>
<a name="ln755">    void readConnectionMatrix(const std::vector&lt;int&gt;iA1, const std::vector&lt;int&gt;iA2, int nAtoms, int nBonds);</a>
<a name="ln756">    void readConnectionMatrix(const std::vector&lt;int&gt;iA1, const std::vector&lt;int&gt;iA2, const std::vector&lt;double&gt;rx, const std::vector&lt;double&gt;ry, int nAtoms, int nBonds);</a>
<a name="ln757">    void redrawMolecule();</a>
<a name="ln758">    void getMolfile(std::ostream &amp; data);</a>
<a name="ln759">    bool checkOverlapped();</a>
<a name="ln760">    double averageBondLength();</a>
<a name="ln761">    void flipSmall(int cHB);</a>
<a name="ln762">    int listarSize();</a>
<a name="ln763">    bool makeFragment(std::vector&lt;int&gt;&amp; list, int aT, int aTEx);</a>
<a name="ln764">    void moleculeCopy(TSimpleMolecule &amp; source);</a>
<a name="ln765">    int correctOverlapped();</a>
<a name="ln766">    void normalizeCoordinates(double aveBL);</a>
<a name="ln767">    void makeEquivalentList(std::vector&lt;int&gt;&amp; equivalenceList, bool isTopologyOnly);</a>
<a name="ln768">    void bondEnlarge(int bN);</a>
<a name="ln769">    void deleteAtom(int index);</a>
<a name="ln770">    void deleteBond(int index);</a>
<a name="ln771">    void addAtom(TSingleAtom * sa);</a>
<a name="ln772">    void addAtom(int na, int charge, double rx, double ry);</a>
<a name="ln773">    void addBond(TSingleBond * sb);</a>
<a name="ln774">    void addBond(int tb, int at1, int at2);</a>
<a name="ln775">    void setCoordinatesString(string value);</a>
<a name="ln776">    void unitVector(int aN, double&amp; xV, double&amp; yV);</a>
<a name="ln777">    void bondUnitVector(int bn, double&amp; xv, double&amp; yv);</a>
<a name="ln778">    double bondLength(int index);</a>
<a name="ln779">    int singleAtomicDescriptor(int aNumber,int bNumber, bool useEnumerator);</a>
<a name="ln780">    int hasOverlapped(double delta, bool findFirst);</a>
<a name="ln781">    int getNH(int atomNo);</a>
<a name="ln782">    bool correctDblBondStereo();</a>
<a name="ln783">  private:</a>
<a name="ln784">    bool aromatic(int cycleSize, const std::vector&lt;int&gt; bondList, std::vector&lt;int&gt;&amp; arom);</a>
<a name="ln785">    void twoAtomUnitVector(int na1, int na2, double &amp; xv, double &amp; yv, const std::vector&lt;int&gt;atomDefine);</a>
<a name="ln786">    void defC(int&amp; currNumDef, int baseCycle, int atomClean, std::vector&lt;int&gt;&amp; cycleDefine,</a>
<a name="ln787">                 std::vector&lt;int&gt;&amp; atomDefine, std::vector&lt;std::vector&lt;int&gt; &gt;&amp; atomCycle, std::vector&lt;int&gt;&amp; dsATN,</a>
<a name="ln788">                 std::vector&lt;int&gt;&amp; dsTP,</a>
<a name="ln789">                 std::vector&lt;int&gt;&amp; dsSC, std::vector&lt;int&gt;&amp; dsNA1, std::vector&lt;int&gt;&amp; dsNA2);</a>
<a name="ln790">    void defA(int&amp; currNumDef, int atomClean, int sPN, int baseCycle, std::vector&lt;int&gt;&amp; atomDefine, const std::vector&lt;int&gt; listAtomClean,</a>
<a name="ln791">              std::vector&lt;int&gt;&amp; cycleDefine, std::vector&lt;std::vector&lt;int&gt; &gt;&amp; atomCycle,</a>
<a name="ln792">              std::vector&lt;int&gt;&amp; dsATN, std::vector&lt;int&gt;&amp; dsTP, std::vector&lt;int&gt;&amp; dsNA1, std::vector&lt;int&gt;&amp; dsNA2);</a>
<a name="ln793">    void canonizeCycle(int ringSize, std::vector&lt;int&gt; &amp; bondList);</a>
<a name="ln794">    //Chain rotate members</a>
<a name="ln795">    double atomDistanceMetric(int an);</a>
<a name="ln796">    bool bondsOverlapped(int bN1, int bN2, double delta);</a>
<a name="ln797">    int fragmentSecond(int sphere, int att, int secAt, const std::vector&lt;int&gt; a,</a>
<a name="ln798">                       const std::vector&lt;int&gt; b, const neighbourlist *bk, std::vector&lt;int&gt;&amp; wSphere);</a>
<a name="ln799">    bool threeBondResolve(int an, int bondExcluded, double&amp; xv, double&amp; yv, neighbourlist* bkExt);</a>
<a name="ln800">    bool unitVectorCoincident(int aN, double xV, double yV);</a>
<a name="ln801">    int setupRotorSearch(const vector&lt;int&gt; &amp;rotBondList, vector&lt;int&gt;&amp; inner_bonds, vector&lt;int&gt;&amp; remainder);</a>
<a name="ln802">  };</a>
<a name="ln803"> </a>
<a name="ln804">  int TSimpleMolecule::getNH(int atomNo) {</a>
<a name="ln805">    int result=0;</a>
<a name="ln806">    TSingleAtom * atom;</a>
<a name="ln807">    int i,n;</a>
<a name="ln808"> </a>
<a name="ln809">    if (atomNo &gt;= nAtoms()) return result;</a>
<a name="ln810">    atom=getAtom(atomNo);</a>
<a name="ln811">    result=atom-&gt;nv;</a>
<a name="ln812">    result=result-(atom-&gt;currvalence)+(atom-&gt;nc*TSingleAtom::chargeDeltaValency(atom-&gt;na))-(atom-&gt;rl);</a>
<a name="ln813">    if (result &lt; 0) result=0;</a>
<a name="ln814">    if (atom-&gt;nb &gt; 0) for (i=0; i&lt;atom-&gt;nb; i++) {</a>
<a name="ln815">        n=atom-&gt;ac[i];</a>
<a name="ln816">        if (getAtom(n)-&gt;na == 1) result=result+1;</a>
<a name="ln817">      };</a>
<a name="ln818">    return result;</a>
<a name="ln819">  };</a>
<a name="ln820"> </a>
<a name="ln821">  int TSimpleMolecule::singleAtomicDescriptor(int aNumber,int bNumber, bool useEnumerator) {</a>
<a name="ln822">    //Bond BNumber has to have type=9 or 10</a>
<a name="ln823">    int result=0;</a>
<a name="ln824">    int an [4] = {0};</a>
<a name="ln825">    int j,m,k;</a>
<a name="ln826">    double x[3];</a>
<a name="ln827">    double y[3];</a>
<a name="ln828">    double r,r1,r2;</a>
<a name="ln829">    bool testBad;</a>
<a name="ln830">    double tn [2];</a>
<a name="ln831">    bool rsn;</a>
<a name="ln832">    bool isInvert;</a>
<a name="ln833"> </a>
<a name="ln834">    if ((getAtom(aNumber)-&gt;nb &lt; 3) || (getAtom(aNumber)-&gt;nb &gt; 4)) return result;</a>
<a name="ln835">    for (j=0; j&lt;getAtom(aNumber)-&gt;nb; j++) an[j]=getAtom(aNumber)-&gt;ac[j];</a>
<a name="ln836">    if (useEnumerator) {</a>
<a name="ln837">      //fragIndex as main base</a>
<a name="ln838">      for (j=0; j&lt;(getAtom(aNumber)-&gt;nb-1); j++) for (m=j+1; m&lt;getAtom(aNumber)-&gt;nb; m++)</a>
<a name="ln839">                                                   if (getAtom(an[j])-&gt;fragIndex &gt; getAtom(an[m])-&gt;fragIndex) {</a>
<a name="ln840">                                                     k=an[j];</a>
<a name="ln841">                                                     an[j]=an[m];</a>
<a name="ln842">                                                     an[m]=k;</a>
<a name="ln843">                                                   };</a>
<a name="ln844">    } else {</a>
<a name="ln845">      for (j=0; j&lt;(getAtom(aNumber)-&gt;nb-1); j++) for (m=j+1; m&lt;getAtom(aNumber)-&gt;nb; m++)</a>
<a name="ln846">                                                   if (an[j] &gt; an[m]) {</a>
<a name="ln847">                                                     k=an[j];</a>
<a name="ln848">                                                     an[j]=an[m];</a>
<a name="ln849">                                                     an[m]=k;</a>
<a name="ln850">                                                   };</a>
<a name="ln851">    };</a>
<a name="ln852"> </a>
<a name="ln853">    //  return 1;</a>
<a name="ln854"> </a>
<a name="ln855">    for (j=0; j&lt;3; j++) {</a>
<a name="ln856">      k=an[j];</a>
<a name="ln857">      x[j]=getAtom(k)-&gt;rx-getAtom(aNumber)-&gt;rx;</a>
<a name="ln858">      y[j]=getAtom(k)-&gt;ry-getAtom(aNumber)-&gt;ry;</a>
<a name="ln859">    };</a>
<a name="ln860"> </a>
<a name="ln861">    isInvert=true;</a>
<a name="ln862">    if (getAtom(aNumber)-&gt;nb == 4) if (getBond(bNumber)-&gt;at[1] != an[3]) {</a>
<a name="ln863">        isInvert=false;</a>
<a name="ln864">        for (j=0; j&lt;3; j++) if (an[j] == getBond(bNumber)-&gt;at[1]) {</a>
<a name="ln865">            k=an[3];</a>
<a name="ln866">            x[j]=getAtom(k)-&gt;rx-getAtom(aNumber)-&gt;rx;</a>
<a name="ln867">            y[j]=getAtom(k)-&gt;ry-getAtom(aNumber)-&gt;ry;</a>
<a name="ln868">          };</a>
<a name="ln869">      };</a>
<a name="ln870">    testBad=false;</a>
<a name="ln871">    for (j=0; j&lt;3; j++) {</a>
<a name="ln872">      r=sqrt(x[j]*x[j]+y[j]*y[j]);</a>
<a name="ln873">      if (r == 0) testBad=true; else {</a>
<a name="ln874">        x[j]=x[j]/r;</a>
<a name="ln875">        y[j]=y[j]/r;</a>
<a name="ln876">      };</a>
<a name="ln877">    };</a>
<a name="ln878"> </a>
<a name="ln879">    //  return 1;</a>
<a name="ln880"> </a>
<a name="ln881">    if (! testBad) {</a>
<a name="ln882">      for (j=0; j&lt;2; j++) { //determination of the sign of rotation</a>
<a name="ln883">        r1=x[0]*y[j+1]-y[0]*x[j+1];     //Sin</a>
<a name="ln884">        r2=x[0]*x[j+1]+y[0]*y[j+1];     //Cos</a>
<a name="ln885">        if (r1 &lt; 0) r2=-2-r2;           // 0 degress = +1; Pi/2 degrees = 0; Pi degrees = -1; 3*Pi/2 degrees = -2; 2*Pi degrees = -3</a>
<a name="ln886">        tn[j]=r2;</a>
<a name="ln887">      };</a>
<a name="ln888">      rsn=( tn[0] &gt; tn[1]);</a>
<a name="ln889">      //return 1;</a>
<a name="ln890"> </a>
<a name="ln891">      //Analizing cases....</a>
<a name="ln892">      if (getBond(bNumber)-&gt;tb == 10) rsn=! rsn;</a>
<a name="ln893">      if (getAtom(aNumber)-&gt;nb == 4) if (isInvert) rsn=! rsn;</a>
<a name="ln894">      if (tn[0] != tn[1]) {</a>
<a name="ln895">        if (rsn) result=1; else result=2;</a>
<a name="ln896">      };</a>
<a name="ln897">    };</a>
<a name="ln898">    return result;</a>
<a name="ln899">  };</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">  void TSimpleMolecule::bondUnitVector(int bn, double&amp; xv, double&amp; yv) {</a>
<a name="ln903">    //for bon's number BN in the structure, described by ATOM, BOND, CONN calculates</a>
<a name="ln904">    //the unit vector (Xv,Yv on output). The vector is best direction to add new fra-</a>
<a name="ln905">    //gment to current structure. The procedure is used by TEMPLATE and MAKEPOLI}</a>
<a name="ln906"> </a>
<a name="ln907">    double si,r1,r2,r3,s1,s2,s3,s4,x1,y1,y2;</a>
<a name="ln908">    int na1,na2,i;</a>
<a name="ln909"> </a>
<a name="ln910">    na1=getBond(bn)-&gt;at[0];</a>
<a name="ln911">    na2=getBond(bn)-&gt;at[1];</a>
<a name="ln912">    s1=getAtom(na1)-&gt;rx;</a>
<a name="ln913">    s2=getAtom(na1)-&gt;ry;</a>
<a name="ln914">    s3=getAtom(na2)-&gt;rx;</a>
<a name="ln915">    s4=getAtom(na2)-&gt;ry;</a>
<a name="ln916">    r1=s1-s3;</a>
<a name="ln917">    r2=s2-s4;</a>
<a name="ln918">    r3=sqrt(r1*r1+r2*r2);</a>
<a name="ln919">    r1=r1/r3; //COS</a>
<a name="ln920">    r2=r2/r3; //SIN</a>
<a name="ln921">    si=0;</a>
<a name="ln922">    for (i=0; i&lt;getAtom(na1)-&gt;nb; i++) if (getAtom(na1)-&gt;ac[i] != na2) {</a>
<a name="ln923">        x1=getAtom(getAtom(na1)-&gt;ac[i])-&gt;rx-s1;</a>
<a name="ln924">        y1=getAtom(getAtom(na1)-&gt;ac[i])-&gt;ry-s2;</a>
<a name="ln925">        y2=x1*r2-y1*r1;</a>
<a name="ln926">        if (y2 != 0) si=si+y2/abs(y2);</a>
<a name="ln927">      }</a>
<a name="ln928">    for (i=0; i&lt;getAtom(na2)-&gt;nb; i++) if (getAtom(na2)-&gt;ac[i] != na1) {</a>
<a name="ln929">        x1=getAtom(getAtom(na2)-&gt;ac[i])-&gt;rx-s3;</a>
<a name="ln930">        y1=getAtom(getAtom(na2)-&gt;ac[i])-&gt;ry-s4;</a>
<a name="ln931">        y2=x1*r2-y1*r1;</a>
<a name="ln932">        if (y2 != 0) si=si+y2/abs(y2);</a>
<a name="ln933">      }</a>
<a name="ln934">    if (si != 0) si=si/abs(si); else si=1;</a>
<a name="ln935">    xv=-r2*si; yv=r1*si;</a>
<a name="ln936">  }</a>
<a name="ln937"> </a>
<a name="ln938"> </a>
<a name="ln939">  bool TSimpleMolecule::threeBondResolve(int an, int bondExcluded, double&amp; xv, double&amp; yv, neighbourlist* bkExt) {</a>
<a name="ln940">    //Addition from 16 April 2006</a>
<a name="ln941">    int bondNoList [3];</a>
<a name="ln942">    bool result=false;</a>
<a name="ln943">    double centerX[3];</a>
<a name="ln944">    double centerY[3];</a>
<a name="ln945">    unsigned int nBondNo;</a>
<a name="ln946">    neighbourlist* bk;</a>
<a name="ln947">    std::vector&lt;int&gt;bondList;</a>
<a name="ln948">    std::vector&lt;int&gt;* blStore = nullptr;</a>
<a name="ln949">    bool testBad,testOK;</a>
<a name="ln950">    unsigned int m, j, n1, n2, n, k;</a>
<a name="ln951">    int rs;</a>
<a name="ln952">    double dist,x,y,minDist;</a>
<a name="ln953">    unsigned int i;</a>
<a name="ln954">    bool test;</a>
<a name="ln955">    int at;</a>
<a name="ln956">    double r1,r2,s1,s3;</a>
<a name="ln957"> </a>
<a name="ln958">    if (bkExt != nullptr) {</a>
<a name="ln959">      bk=bkExt;</a>
<a name="ln960">    } else {</a>
<a name="ln961">      bk=(neighbourlist *)malloc(nAtoms() * sizeof(adjustedlist));</a>
<a name="ln962">      defineBondConn(bk);</a>
<a name="ln963">    }</a>
<a name="ln964">    nBondNo=0;</a>
<a name="ln965">    testBad=false;</a>
<a name="ln966">    testOK=true;</a>
<a name="ln967"> </a>
<a name="ln968">    for (i=0; i&lt;bk[an].nb; i++) {</a>
<a name="ln969">      n=bk[an].adjusted[i];</a>
<a name="ln970">      if (n != bondExcluded) {</a>
<a name="ln971">        vaweBond(n,bk,rs,bondList);</a>
<a name="ln972">        if (rs &gt; 0) {</a>
<a name="ln973">          //I have to analize bondList to determine second cycle to exclude adamanthane</a>
<a name="ln974">          if (blStore == nullptr) {</a>
<a name="ln975">            //Save</a>
<a name="ln976">            blStore= new std::vector&lt;int&gt;(rs);</a>
<a name="ln977">            for (j=0; j&lt;blStore-&gt;size(); j++) (*blStore)[j]=bondList[j];</a>
<a name="ln978">          } else {</a>
<a name="ln979">            m=0;</a>
<a name="ln980">            for (j=0; j&lt;blStore-&gt;size(); j++) {</a>
<a name="ln981">              test=false;</a>
<a name="ln982">              for (k=0; k&lt;rs; k++) if (bondList[k] == (*blStore)[j]) {</a>
<a name="ln983">                  test=true;</a>
<a name="ln984">                  break;</a>
<a name="ln985">                };</a>
<a name="ln986">              if (test) m++;</a>
<a name="ln987">            };</a>
<a name="ln988">            if ((m &gt; 1) &amp;&amp; (m &lt; blStore-&gt;size())) {</a>
<a name="ln989">              testOK=false;</a>
<a name="ln990">            };</a>
<a name="ln991">          };</a>
<a name="ln992">          //center determination</a>
<a name="ln993">          centerX[nBondNo]=0;</a>
<a name="ln994">          centerY[nBondNo]=0;</a>
<a name="ln995">          for (j=0; j&lt;rs; j++) {</a>
<a name="ln996">            m=bondList[j];</a>
<a name="ln997">            n1=getBond(m)-&gt;at[0];</a>
<a name="ln998">            n2=getBond(m)-&gt;at[1];</a>
<a name="ln999">            centerX[nBondNo]=centerX[nBondNo]+getAtom(n1)-&gt;rx+getAtom(n2)-&gt;rx;</a>
<a name="ln1000">            centerY[nBondNo]=centerY[nBondNo]+getAtom(n1)-&gt;ry+getAtom(n2)-&gt;ry;</a>
<a name="ln1001">          };</a>
<a name="ln1002">          centerX[nBondNo]=centerX[nBondNo]/(2*rs);</a>
<a name="ln1003">          centerY[nBondNo]=centerY[nBondNo]/(2*rs);</a>
<a name="ln1004">          bondNoList[nBondNo]=n;</a>
<a name="ln1005">          nBondNo++;</a>
<a name="ln1006">        };</a>
<a name="ln1007">      };// else testBad:=true;</a>
<a name="ln1008">      if ((nBondNo == 3) || (testBad)) break;</a>
<a name="ln1009">    };</a>
<a name="ln1010">    if (nBondNo &lt; 2) testBad=true;</a>
<a name="ln1011"> </a>
<a name="ln1012">    if ((! testBad) &amp;&amp; testOK) {</a>
<a name="ln1013">      dist=0;</a>
<a name="ln1014">      if (nBondNo == 2) {</a>
<a name="ln1015">        //single bond, attached to ring. Re-definition center....</a>
<a name="ln1016">        x=0; y=0;</a>
<a name="ln1017">        for (i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln1018">          x=x+getAtom(i)-&gt;rx;</a>
<a name="ln1019">          y=y+getAtom(i)-&gt;ry;</a>
<a name="ln1020">        };</a>
<a name="ln1021">        x=x/nAtoms();</a>
<a name="ln1022">        y=y/nAtoms();</a>
<a name="ln1023">        for (i=0; i&lt;nBondNo; i++) {</a>
<a name="ln1024">          centerX[i]=x;</a>
<a name="ln1025">          centerY[i]=y;</a>
<a name="ln1026">        };</a>
<a name="ln1027">      };</a>
<a name="ln1028">      for (i=0; i&lt;nBondNo; i++) {</a>
<a name="ln1029">        at=getBond(bondNoList[i])-&gt;at[0];</a>
<a name="ln1030">        if (at == an) at=getBond(bondNoList[i])-&gt;at[1];</a>
<a name="ln1031">        r1=getAtom(at)-&gt;rx-getAtom(an)-&gt;rx;</a>
<a name="ln1032">        r2=getAtom(at)-&gt;ry-getAtom(an)-&gt;ry;</a>
<a name="ln1033">        s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1034">        if (s1 == 0) testBad=true; else {</a>
<a name="ln1035">          r1=r1/s1; r2=r2/s1;</a>
<a name="ln1036">          x=-r1;</a>
<a name="ln1037">          y=-r2;</a>
<a name="ln1038">          minDist=1000000000;</a>
<a name="ln1039">          for (j=0; j&lt;nBondNo; j++) {</a>
<a name="ln1040">            r1=(x*s1+getAtom(an)-&gt;rx-centerX[j]);</a>
<a name="ln1041">            r2=(y*s1+getAtom(an)-&gt;ry-centerY[j]);</a>
<a name="ln1042">            s3=sqrt(r1*r1+r2*r2);</a>
<a name="ln1043">            if (s3 &lt; minDist) minDist=s3;</a>
<a name="ln1044">          };</a>
<a name="ln1045">          if (minDist &gt; dist) {</a>
<a name="ln1046">            dist=minDist;</a>
<a name="ln1047">            xv=x;</a>
<a name="ln1048">            yv=y;</a>
<a name="ln1049">          };</a>
<a name="ln1050">        };</a>
<a name="ln1051">      };</a>
<a name="ln1052">      if (! testBad) result=true;</a>
<a name="ln1053">    };</a>
<a name="ln1054">    //end addition from 16 April 2006</a>
<a name="ln1055">    if (bkExt == nullptr) free(bk);</a>
<a name="ln1056">    if (blStore != nullptr) delete(blStore);</a>
<a name="ln1057">    return result;</a>
<a name="ln1058">  };</a>
<a name="ln1059"> </a>
<a name="ln1060">  bool TSimpleMolecule::unitVectorCoincident(int aN, double xV, double yV) {</a>
<a name="ln1061">    bool result=false;</a>
<a name="ln1062">    int i, aT;</a>
<a name="ln1063">    double r1,r2,s1;</a>
<a name="ln1064"> </a>
<a name="ln1065">    for (i=0; i&lt;getAtom(aN)-&gt;nb; i++) {</a>
<a name="ln1066">      aT=getAtom(aN)-&gt;ac[i];</a>
<a name="ln1067">      r1=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1068">      r2=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1069">      s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1070">      if (s1 &gt; 0.00001) {</a>
<a name="ln1071">        r1=r1/s1;</a>
<a name="ln1072">        r2=r2/s1;</a>
<a name="ln1073">        if ((abs(r1-xV) &lt; 0.1) &amp;&amp; (abs(r2-yV) &lt; 0.1)) result=true;</a>
<a name="ln1074">      };</a>
<a name="ln1075">      if (result) break;</a>
<a name="ln1076">    };</a>
<a name="ln1077">    return result;</a>
<a name="ln1078">  };</a>
<a name="ln1079"> </a>
<a name="ln1080">  void TSimpleMolecule::unitVector(int aN, double&amp; xV, double&amp; yV) {</a>
<a name="ln1081">    //For atom's number AN in the array ATOM (the same structure is described with</a>
<a name="ln1082">    //bond's array BOND and bond-connection matrix invariants CONN) unit vector</a>
<a name="ln1083">    //is calculated (XV, YV) on output. Unit vector shows the best direction to</a>
<a name="ln1084">    //make new bond}</a>
<a name="ln1085">    double sc[4] = {0,1/2,1.7320508/2,1};</a>
<a name="ln1086">    double cc[4] = {1,1.7320508/2,1/2,0};</a>
<a name="ln1087">    double sQ3=sqrt(3.0)/2.0;</a>
<a name="ln1088">    double si,r1,r2,r3,r4,s1,s2,s3,s4,fi;</a>
<a name="ln1089">    double xm[3];  //Initial dimensions 1..3</a>
<a name="ln1090">    double ym[3];  //Initial dimensions 1..3</a>
<a name="ln1091">    int i,i1,i2;</a>
<a name="ln1092">    int nB1,aT,aT1;</a>
<a name="ln1093">    bool mK[CONNMAX] = {false};</a>
<a name="ln1094">    bool test;</a>
<a name="ln1095"> </a>
<a name="ln1096">    nB1=1;</a>
<a name="ln1097">    if (getAtom(aN)-&gt;nb == 0) {</a>
<a name="ln1098">      xV=1;</a>
<a name="ln1099">      yV=0;               //if no atoms connected-horizontal unit vector</a>
<a name="ln1100">      return;</a>
<a name="ln1101">    } else if (getAtom(aN)-&gt;nb == 1) {  //single atom connected-start calculations}</a>
<a name="ln1102">      aT=getAtom(aN)-&gt;ac[0];</a>
<a name="ln1103">      r1=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1104">      r2=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1105">      s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1106">      if (s1 == 0) {</a>
<a name="ln1107">        xV=0.3826834;</a>
<a name="ln1108">        yV=-0.9238795;</a>
<a name="ln1109">        return;</a>
<a name="ln1110">      }</a>
<a name="ln1111">      r1=r1/s1; r2=r2/s1;</a>
<a name="ln1112">      nB1=getAtom(aT)-&gt;nb;</a>
<a name="ln1113">      si=1;</a>
<a name="ln1114">      if (nB1 &gt; 1) {</a>
<a name="ln1115">        aT1=getAtom(aT)-&gt;ac[0];</a>
<a name="ln1116">        if (aT1 == aN) aT1=getAtom(aT)-&gt;ac[1];</a>
<a name="ln1117">        r3=getAtom(aT1)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1118">        r4=getAtom(aT1)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1119">        s2=sqrt(r3*r3+r4*r4);</a>
<a name="ln1120">        if (s2 == 0) s2=1;</a>
<a name="ln1121">        r3=r3/s2; r4=r4/s2;</a>
<a name="ln1122">        si=r2*r3-r4*r1;</a>
<a name="ln1123">        if (si != 0) si=si/abs(si); else si=1;</a>
<a name="ln1124">      }</a>
<a name="ln1125">      s3=sqrt(3.0)/2.0;</a>
<a name="ln1126">      s4=-0.5;</a>
<a name="ln1127">      xV=r1*s4-r2*si*s3;  //single atom connected-unit vector at 2Pi/3 angle</a>
<a name="ln1128">      yV=r2*s4+r1*si*s3;</a>
<a name="ln1129">    } else {            //multiply connection case</a>
<a name="ln1130">      xV=0;</a>
<a name="ln1131">      yV=0;</a>
<a name="ln1132">      for (i=0; i&lt;getAtom(aN)-&gt;nb; i++) mK[i]=true;</a>
<a name="ln1133">      if (getAtom(aN)-&gt;nb == 3) {</a>
<a name="ln1134">        //three-bond connection-search for projec. of tetrahedron</a>
<a name="ln1135"> </a>
<a name="ln1136">        if (threeBondResolve(aN,-1,xV,yV,nullptr)) {</a>
<a name="ln1137">          return;</a>
<a name="ln1138">        };</a>
<a name="ln1139"> </a>
<a name="ln1140">        for (i=0; i&lt;3; i++) {</a>
<a name="ln1141">          aT=getAtom(aN)-&gt;ac[i];</a>
<a name="ln1142">          xm[i]=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1143">          ym[i]=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1144">          r1=sqrt(xm[i]*xm[i]+ym[i]*ym[i]);</a>
<a name="ln1145">          xm[i]=xm[i]/r1; ym[i]=ym[i]/r1;</a>
<a name="ln1146">        }</a>
<a name="ln1147">        i=0;</a>
<a name="ln1148">        do {      //Search for bond, which make 30 degree angle with another</a>
<a name="ln1149">          i1=1; i2=2;</a>
<a name="ln1150">          switch (i) {</a>
<a name="ln1151">          case 0: {</a>
<a name="ln1152">            i1=1; i2=2; break;</a>
<a name="ln1153">          }</a>
<a name="ln1154">          case 1: {</a>
<a name="ln1155">            i1=0; i2=2; break;</a>
<a name="ln1156">          }</a>
<a name="ln1157">          case 2: {  //Else value - only three</a>
<a name="ln1158">            i1=0; i2=1; break;</a>
<a name="ln1159">          }</a>
<a name="ln1160">          }</a>
<a name="ln1161">          s1=xm[i1]*xm[i2]+ym[i1]*ym[i2];</a>
<a name="ln1162">          s2=xm[i]*xm[i1]+ym[i]*ym[i1];</a>
<a name="ln1163">          s3=xm[i]*xm[i2]+ym[i]*ym[i2];</a>
<a name="ln1164">          test=false;</a>
<a name="ln1165">          if (abs(s1+0.5) &lt; 0.05) {  //two bonds form 120 degrees angle</a>
<a name="ln1166">            test=(abs(s2-sQ3)&lt;0.05) || (abs(s3-sQ3)&lt;0.05);</a>
<a name="ln1167">            if (! test) test=((abs(s2) &lt; 0.05) &amp;&amp; (abs(s3+sQ3)&lt;0.05))</a>
<a name="ln1168">                          || ((abs(s3)&lt;0.05) &amp;&amp; (abs(s2+sQ3)&lt;0.05));</a>
<a name="ln1169">          }</a>
<a name="ln1170">          i++;</a>
<a name="ln1171">        } while (! (test || (i == 3)));</a>
<a name="ln1172">        if (test) mK[i-1]=false;  //In the original Java code without -1</a>
<a name="ln1173">      }</a>
<a name="ln1174">      for (i=0; i&lt;getAtom(aN)-&gt;nb; i++) if (mK[i]) {</a>
<a name="ln1175">          aT=getAtom(aN)-&gt;ac[i];</a>
<a name="ln1176">          r1=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1177">          r2=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1178">          s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1179">          if (s1 &lt; 0.05) s1=1;</a>
<a name="ln1180">          r1=r1/s1; r2=r2/s1;</a>
<a name="ln1181">          xV=xV-r1;</a>
<a name="ln1182">          yV=yV-r2;</a>
<a name="ln1183">        }</a>
<a name="ln1184">      r1=sqrt(xV*xV+yV*yV);</a>
<a name="ln1185">      if (r1 &gt; 0.05) {</a>
<a name="ln1186">        //unit vector may be calculated from current connection</a>
<a name="ln1187">        xV=xV/r1;</a>
<a name="ln1188">        yV=yV/r1;</a>
<a name="ln1189">      } else {</a>
<a name="ln1190">        //impossible to calculate unit vector-more definitions</a>
<a name="ln1191">        if (getAtom(aN)-&gt;nb == 2) {    //linear existing connection-Pi/2 angle</a>
<a name="ln1192">          aT=getAtom(aN)-&gt;ac[0];</a>
<a name="ln1193">          r1=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1194">          r2=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1195">          s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1196">          if (s1 &lt; 0.05) {</a>
<a name="ln1197">            xV=0.3826834;</a>
<a name="ln1198">            yV=-0.9238795;</a>
<a name="ln1199">            return;</a>
<a name="ln1200">          }</a>
<a name="ln1201">          r1=r1/s1; r2=r2/s1;</a>
<a name="ln1202">          xV=-r2; yV=-r1;</a>
<a name="ln1203">        } else if (getAtom(aN)-&gt;nb == 3) { //3-bonds connection - projection of tetrahedrone is calculated</a>
<a name="ln1204">          //Which of bonds has the horizontal direction</a>
<a name="ln1205">          r3=100000;</a>
<a name="ln1206">          for (i=0; i&lt;3; i++) {</a>
<a name="ln1207">            aT=getAtom(aN)-&gt;ac[i];</a>
<a name="ln1208">            r1=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1209">            r2=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1210">            s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1211">            if (s1 &lt; 0.05) {</a>
<a name="ln1212">              xV=0.3826834;</a>
<a name="ln1213">              yV=-0.9238795;</a>
<a name="ln1214">              return;</a>
<a name="ln1215">            }</a>
<a name="ln1216">            r1=abs(r1/s1); r2=abs(r2/s1);</a>
<a name="ln1217">            if (r1 &lt; r3) {r3=r1; nB1=i;}</a>
<a name="ln1218">            if (r2 &lt; r3) {r3=r2; nB1=i;}</a>
<a name="ln1219">          }</a>
<a name="ln1220">          aT=getAtom(aN)-&gt;ac[nB1];       //Horizontal or vertical bond found}</a>
<a name="ln1221">          r1=getAtom(aT)-&gt;rx-getAtom(aN)-&gt;rx;</a>
<a name="ln1222">          r2=getAtom(aT)-&gt;ry-getAtom(aN)-&gt;ry;</a>
<a name="ln1223">          s1=sqrt(r1*r1+r2*r2);</a>
<a name="ln1224">          r1=r1/s1; r2=r2/s1;</a>
<a name="ln1225">          xV= r1*cos(150*PI/180)+r2*sin(150*PI/180);</a>
<a name="ln1226">          yV=-r1*sin(150*PI/180)+r2*cos(150*PI/180);</a>
<a name="ln1227">        } else {</a>
<a name="ln1228">          xV=sqrt(2.0)/2.0; //other case - Pi/4 to horizont angle</a>
<a name="ln1229">          yV=-xV;</a>
<a name="ln1230">        }</a>
<a name="ln1231">      }</a>
<a name="ln1232"> </a>
<a name="ln1233">      //checking if coincided xV and uV with existing bonds</a>
<a name="ln1234">      if (unitVectorCoincident(aN,xV,yV)) {</a>
<a name="ln1235">        fi=15*PI/180.0;</a>
<a name="ln1236">        r3=cos(fi);</a>
<a name="ln1237">        r4=sin(fi);</a>
<a name="ln1238">        r1= xV*r3+yV*r4;</a>
<a name="ln1239">        r2=-xV*r4+yV*r3;</a>
<a name="ln1240">        if (unitVectorCoincident(aN,r1,r2)) {</a>
<a name="ln1241">          r1=xV*r3-yV*r4;</a>
<a name="ln1242">          r2=xV*r4+yV*r3;</a>
<a name="ln1243">        };</a>
<a name="ln1244">        if (unitVectorCoincident(aN,r1,r2)) {</a>
<a name="ln1245">          fi=7.5*PI/180.0;</a>
<a name="ln1246">          r3=cos(fi);</a>
<a name="ln1247">          r4=sin(fi);</a>
<a name="ln1248">          r1= xV*r3+yV*r4;</a>
<a name="ln1249">          r2=-xV*r4+yV*r3;</a>
<a name="ln1250">          if (unitVectorCoincident(aN,r1,r2)) {</a>
<a name="ln1251">            r1=xV*r3-yV*r4;</a>
<a name="ln1252">            r2=xV*r4+yV*r3;</a>
<a name="ln1253">          };</a>
<a name="ln1254">        };</a>
<a name="ln1255">        xV=r1;</a>
<a name="ln1256">        yV=r2;</a>
<a name="ln1257">      };</a>
<a name="ln1258">    };</a>
<a name="ln1259">    //Correction of angles, closed to 0, 30, 60, 90 degrees to exact values</a>
<a name="ln1260">    if (getAtom(aN)-&gt;nb &lt; 6) for (i=0; i&lt;4; i++) if ((abs(abs(xV)-sc[i])&lt;0.04)</a>
<a name="ln1261">                                                     &amp;&amp; (abs(abs(yV)-cc[i]) &lt; 0.04)) {</a>
<a name="ln1262">          if (xV &lt; 0) xV=-sc[i]; else xV=sc[i];</a>
<a name="ln1263">          if (yV &lt; 0) yV=-cc[i]; else yV=cc[i];</a>
<a name="ln1264">        }</a>
<a name="ln1265">  }</a>
<a name="ln1266"> </a>
<a name="ln1267">  void TSimpleMolecule::clear() {</a>
<a name="ln1268">    for (unsigned int i=0; i&lt;fAtom.size(); i++) delete(fAtom.at(i));</a>
<a name="ln1269">    fAtom.clear();</a>
<a name="ln1270">    for (unsigned int i=0; i&lt;fBond.size(); i++) delete(fBond.at(i));</a>
<a name="ln1271">    fBond.clear();</a>
<a name="ln1272">  };</a>
<a name="ln1273"> </a>
<a name="ln1274">  void TSimpleMolecule::setCoordinatesString(string value){</a>
<a name="ln1275">    //set back above prcedure</a>
<a name="ln1276">    TSingleAtom * sa;</a>
<a name="ln1277">    TSingleBond * sb;</a>
<a name="ln1278">    int i,n,k,kk;</a>
<a name="ln1279">    string s;</a>
<a name="ln1280"> </a>
<a name="ln1281">    clear();</a>
<a name="ln1282">    n=0;</a>
<a name="ln1283">    s=value.substr(n,2); //2 symbols - number of atoms</a>
<a name="ln1284">    n=n+2;</a>
<a name="ln1285">    kk=strtol(s.c_str(),nullptr,10);</a>
<a name="ln1286">    for (i=0; i&lt;kk; i++) {</a>
<a name="ln1287">      sa=new TSingleAtom();</a>
<a name="ln1288">      s=value.substr(n,1);</a>
<a name="ln1289">      if (s == &quot;1&quot;) sa-&gt;na=101; else</a>
<a name="ln1290">        if (s == &quot;2&quot;) sa-&gt;na=102; else</a>
<a name="ln1291">          if (s == &quot;3&quot;) sa-&gt;na=103; else</a>
<a name="ln1292">            if (s == &quot;A&quot;) sa-&gt;na=ANY_ATOM; else</a>
<a name="ln1293">              if (s == &quot;E&quot;) {</a>
<a name="ln1294">                sa-&gt;na=ANY_ATOM;</a>
<a name="ln1295">                sa-&gt;special=1;</a>
<a name="ln1296">              } else sa-&gt;na=6;//Atom.positionofAtom(s);</a>
<a name="ln1297">      n=n+1;</a>
<a name="ln1298">      s=value.substr(n,4);</a>
<a name="ln1299">      n=n+4;</a>
<a name="ln1300">      k=strtol(s.c_str(),nullptr,10);</a>
<a name="ln1301">      sa-&gt;rx=(double)k/10000.0;</a>
<a name="ln1302">      s=value.substr(n,4);</a>
<a name="ln1303">      n=n+4;</a>
<a name="ln1304">      k=strtol(s.c_str(),nullptr,10);</a>
<a name="ln1305">      sa-&gt;ry=(double)k/10000.0;</a>
<a name="ln1306">      addAtom(sa);</a>
<a name="ln1307">    };</a>
<a name="ln1308">    s=value.substr(n,2);  //2 symbols - number of bonds</a>
<a name="ln1309">    n=n+2;</a>
<a name="ln1310">    kk=strtol(s.c_str(),nullptr,10);</a>
<a name="ln1311">    for (i=0; i&lt;kk; i++) {</a>
<a name="ln1312">      sb=new TSingleBond();</a>
<a name="ln1313">      sb-&gt;tb=ANY_BOND;  //any bond</a>
<a name="ln1314">      s=value.substr(n,2);</a>
<a name="ln1315">      n=n+2;</a>
<a name="ln1316">      k=strtol(s.c_str(),nullptr,10);</a>
<a name="ln1317">      sb-&gt;at[0]=k-1;</a>
<a name="ln1318">      s=value.substr(n,2);</a>
<a name="ln1319">      n=n+2;</a>
<a name="ln1320">      k=strtol(s.c_str(),nullptr,10);</a>
<a name="ln1321">      sb-&gt;at[1]=k-1;</a>
<a name="ln1322">      addBond(sb);</a>
<a name="ln1323">    };</a>
<a name="ln1324">  };</a>
<a name="ln1325"> </a>
<a name="ln1326"> </a>
<a name="ln1327">  void TSimpleMolecule::addAtom(TSingleAtom * sa){</a>
<a name="ln1328">    fAtom.push_back(sa);</a>
<a name="ln1329">  };</a>
<a name="ln1330"> </a>
<a name="ln1331">  void TSimpleMolecule::addAtom(int na, int charge, double rx, double ry) {</a>
<a name="ln1332">    TSingleAtom * sa;</a>
<a name="ln1333">    sa=new TSingleAtom();</a>
<a name="ln1334">    sa-&gt;na=na;</a>
<a name="ln1335">    sa-&gt;nc=charge;</a>
<a name="ln1336">    sa-&gt;rx=rx;</a>
<a name="ln1337">    sa-&gt;ry=ry;</a>
<a name="ln1338">    fAtom.push_back(sa);</a>
<a name="ln1339">  };</a>
<a name="ln1340"> </a>
<a name="ln1341">  void TSimpleMolecule::addBond(TSingleBond * sb){</a>
<a name="ln1342">    fBond.push_back(sb);</a>
<a name="ln1343">  };</a>
<a name="ln1344"> </a>
<a name="ln1345">  void TSimpleMolecule::addBond(int tb, int at1, int at2){</a>
<a name="ln1346">    TSingleBond * sb;</a>
<a name="ln1347">    sb=new TSingleBond();</a>
<a name="ln1348">    sb-&gt;tb=tb;</a>
<a name="ln1349">    sb-&gt;at[0]=at1;</a>
<a name="ln1350">    sb-&gt;at[1]=at2;</a>
<a name="ln1351">    fBond.push_back(sb);</a>
<a name="ln1352">  };</a>
<a name="ln1353"> </a>
<a name="ln1354">  void TSimpleMolecule::moleculeCopy(TSimpleMolecule &amp; source) {</a>
<a name="ln1355">    TSingleAtom * sa;</a>
<a name="ln1356">    TSingleBond * sb;</a>
<a name="ln1357"> </a>
<a name="ln1358">    clear();</a>
<a name="ln1359">    for (int i=0; i&lt;source.nAtoms(); i++) {</a>
<a name="ln1360">      sa=source.getAtom(i);</a>
<a name="ln1361">      fAtom.push_back(sa-&gt;clone());</a>
<a name="ln1362">    };</a>
<a name="ln1363">    for (int i=0; i&lt;source.nBonds(); i++) {</a>
<a name="ln1364">      sb=source.getBond(i);</a>
<a name="ln1365">      fBond.push_back(sb-&gt;clone());</a>
<a name="ln1366">    };</a>
<a name="ln1367">    if (refofs == nullptr) refofs=source.refofs;</a>
<a name="ln1368">  };</a>
<a name="ln1369"> </a>
<a name="ln1370">  void TSimpleMolecule::deleteBond(int index) {</a>
<a name="ln1371">    std::vector&lt;TSingleBond*&gt; tempBond(nBonds());</a>
<a name="ln1372">    int i,n;</a>
<a name="ln1373"> </a>
<a name="ln1374">    n=0;</a>
<a name="ln1375">    //bond deletion</a>
<a name="ln1376">    for (i=0; i&lt;nBonds(); i++) if (i != index) {</a>
<a name="ln1377">        tempBond[n]=getBond(i);</a>
<a name="ln1378">        n++;</a>
<a name="ln1379">      } else {</a>
<a name="ln1380">        delete(getBond(i));</a>
<a name="ln1381">        fBond[i]=nullptr;</a>
<a name="ln1382">      };</a>
<a name="ln1383">    fBond.resize(n);</a>
<a name="ln1384">    for (i=0; i&lt;n; i++) fBond[i]=tempBond[i];</a>
<a name="ln1385">    tempBond.clear();</a>
<a name="ln1386">  };</a>
<a name="ln1387"> </a>
<a name="ln1388"> </a>
<a name="ln1389">  void TSimpleMolecule::deleteAtom(int index) {</a>
<a name="ln1390">    std::vector&lt;TSingleAtom*&gt; tempAtom(nAtoms()-1);</a>
<a name="ln1391">    std::vector&lt;TSingleBond*&gt; tempBond(nBonds());</a>
<a name="ln1392">    unsigned int i, n;</a>
<a name="ln1393"> </a>
<a name="ln1394">    n=0;</a>
<a name="ln1395">    //atom deletion</a>
<a name="ln1396">    for (i=0; i&lt;nAtoms(); i++) if (i != index) {</a>
<a name="ln1397">        tempAtom[n]=getAtom(i);</a>
<a name="ln1398">        n++;</a>
<a name="ln1399">      } else {</a>
<a name="ln1400">        delete(getAtom(i));</a>
<a name="ln1401">        fAtom[i]=nullptr;</a>
<a name="ln1402">      };</a>
<a name="ln1403">    fAtom.resize(n);</a>
<a name="ln1404">    for (i=0; i&lt;n; i++) fAtom[i]=tempAtom[i];</a>
<a name="ln1405">    tempAtom.clear();</a>
<a name="ln1406">    //connected bonds deletion</a>
<a name="ln1407">    n=0;</a>
<a name="ln1408">    for (i=0; i&lt;tempBond.size(); i++) {</a>
<a name="ln1409">      if ((getBond(i)-&gt;at[0] == index) || (getBond(i)-&gt;at[1] == index)) {</a>
<a name="ln1410">        delete(getBond(i));</a>
<a name="ln1411">        fBond[i]=nullptr;</a>
<a name="ln1412">      } else {</a>
<a name="ln1413">        if (getBond(i)-&gt;at[0] &gt; index) getBond(i)-&gt;at[0]=getBond(i)-&gt;at[0]-1;</a>
<a name="ln1414">        if (getBond(i)-&gt;at[1] &gt; index) getBond(i)-&gt;at[1]=getBond(i)-&gt;at[1]-1;</a>
<a name="ln1415">        tempBond[n]=getBond(i);</a>
<a name="ln1416">        n++;</a>
<a name="ln1417">      };</a>
<a name="ln1418">    };</a>
<a name="ln1419">    fBond.resize(n);</a>
<a name="ln1420">    for (i=0; i&lt;n; i++) fBond[i]=tempBond[i];</a>
<a name="ln1421">    tempBond.clear();</a>
<a name="ln1422">  };</a>
<a name="ln1423"> </a>
<a name="ln1424"> </a>
<a name="ln1425">  double TSimpleMolecule::bondLength(int index) {</a>
<a name="ln1426">    double result=1;</a>
<a name="ln1427">    double x,y;</a>
<a name="ln1428">    int k1,k2;</a>
<a name="ln1429">    k1=getBond(index)-&gt;at[0];</a>
<a name="ln1430">    k2=getBond(index)-&gt;at[1];</a>
<a name="ln1431">    x=getAtom(k1)-&gt;rx-getAtom(k2)-&gt;rx;</a>
<a name="ln1432">    y=getAtom(k1)-&gt;ry-getAtom(k2)-&gt;ry;</a>
<a name="ln1433">    result=sqrt(x*x+y*y);</a>
<a name="ln1434">    return result;</a>
<a name="ln1435">  };</a>
<a name="ln1436"> </a>
<a name="ln1437">  int TSimpleMolecule::listarSize() { // Probably should be removed and replaced with either nAtoms() or nBonds() as appropriate</a>
<a name="ln1438">    int result=10;  //Minimal vector size 10</a>
<a name="ln1439">    if (nAtoms() &gt; result) result=nAtoms();</a>
<a name="ln1440">    if (nBonds() &gt; result) result=nBonds();</a>
<a name="ln1441">    return result;</a>
<a name="ln1442">  };</a>
<a name="ln1443"> </a>
<a name="ln1444">  bool TSimpleMolecule::makeFragment(std::vector&lt;int&gt;&amp; list, int aT, int aTEx) {</a>
<a name="ln1445">    //Starting from atom's number AT in bond-connection matrix invariants array CONN</a>
<a name="ln1446">    //the all connected atom's (through one or more bonds) numbers are inserted into</a>
<a name="ln1447">    //the LIST vector. If ATEX non-equal</a>
<a name="ln1448">    //zero, than atom with this number and all other, which is connected through</a>
<a name="ln1449">    //atom ATEX, don't include in LIST array. Boolean variable TEST has TRUE value</a>
<a name="ln1450">    //on output if between AT and ATEX exist cyclic bond, false otherwise}</a>
<a name="ln1451">    int i,j,k,l;</a>
<a name="ln1452">    bool test, test1;</a>
<a name="ln1453">    list.resize(0);</a>
<a name="ln1454"> </a>
<a name="ln1455">    test=false;</a>
<a name="ln1456">    if ((nAtoms() ==0 ) || (aT &lt; 0) || (aT &gt;= nAtoms())) {</a>
<a name="ln1457">      return test;</a>
<a name="ln1458">    }</a>
<a name="ln1459"> </a>
<a name="ln1460">    list.push_back(aT);</a>
<a name="ln1461">    for (i=0; i&lt;getAtom(aT)-&gt;nb; i++) if (getAtom(aT)-&gt;ac[i] != aTEx) {</a>
<a name="ln1462">        list.push_back(getAtom(aT)-&gt;ac[i]);</a>
<a name="ln1463">      }</a>
<a name="ln1464">    if (list.size() == 1) return test;                      //exit in AT non-connected atom</a>
<a name="ln1465">    k=0;</a>
<a name="ln1466">    do {                                 //iterational algorithm to define all}</a>
<a name="ln1467">      for (i=0; i&lt;getAtom(list[k])-&gt;nb; i++) {</a>
<a name="ln1468">        test1=false;</a>
<a name="ln1469">        l=getAtom(list[k])-&gt;ac[i];</a>
<a name="ln1470">        if (l != aTEx) {</a>
<a name="ln1471">          for (j=0; j&lt;list.size(); j++) if (list[j] == l) test1=true;</a>
<a name="ln1472">        } else test=true;</a>
<a name="ln1473">        if ((! test1) &amp;&amp; (l != aTEx) &amp;&amp; (l &gt;= 0) &amp;&amp; (l &lt; nAtoms())) {</a>
<a name="ln1474">          list.push_back(l);</a>
<a name="ln1475">        }</a>
<a name="ln1476">      }</a>
<a name="ln1477">      k=k+1;                             //atoms which are connected with AT}</a>
<a name="ln1478">    } while (k&lt;list.size());</a>
<a name="ln1479">    return test;</a>
<a name="ln1480">  }</a>
<a name="ln1481"> </a>
<a name="ln1482">  void TSimpleMolecule::readConnectionMatrix(const std::vector&lt;int&gt;iA1, const std::vector&lt;int&gt;iA2, int nAtoms, int nBonds) {</a>
<a name="ln1483">    TSingleAtom * sa;</a>
<a name="ln1484">    TSingleBond * sb;</a>
<a name="ln1485">    int i;</a>
<a name="ln1486"> </a>
<a name="ln1487">    clear();</a>
<a name="ln1488">    srand(30000);</a>
<a name="ln1489">    for (i=1; i&lt;=nAtoms; i++) {</a>
<a name="ln1490">      sa=new TSingleAtom();</a>
<a name="ln1491">      sa-&gt;na=6;</a>
<a name="ln1492">      sa-&gt;nv=hVal[sa-&gt;na];</a>
<a name="ln1493">      sa-&gt;rx=(double)rand()/1000.0;</a>
<a name="ln1494">      sa-&gt;ry=(double)rand()/1000.0;</a>
<a name="ln1495">      fAtom.push_back(sa);</a>
<a name="ln1496">    };</a>
<a name="ln1497"> </a>
<a name="ln1498">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln1499">      sb=new TSingleBond();</a>
<a name="ln1500">      sb-&gt;at[0]=iA1[i];</a>
<a name="ln1501">      sb-&gt;at[1]=iA2[i];</a>
<a name="ln1502">      sb-&gt;tb=1;</a>
<a name="ln1503">      fBond.push_back(sb);</a>
<a name="ln1504">    };</a>
<a name="ln1505">    defineAtomConn();</a>
<a name="ln1506">    allAboutCycles();</a>
<a name="ln1507">  };</a>
<a name="ln1508"> </a>
<a name="ln1509">  void TSimpleMolecule::readConnectionMatrix(const std::vector&lt;int&gt;iA1, const std::vector&lt;int&gt;iA2, const std::vector&lt;double&gt;rx, const std::vector&lt;double&gt;ry, int nAtoms, int nBonds) {</a>
<a name="ln1510">    readConnectionMatrix(iA1,iA2,nAtoms,nBonds);</a>
<a name="ln1511">    for (int i=0; i&lt;nAtoms; i++) {</a>
<a name="ln1512">      getAtom(i)-&gt;rx=rx[i];</a>
<a name="ln1513">      getAtom(i)-&gt;ry=ry[i];</a>
<a name="ln1514">    };</a>
<a name="ln1515">  };</a>
<a name="ln1516"> </a>
<a name="ln1517"> </a>
<a name="ln1518">  void TSimpleMolecule::normalizeCoordinates(double aveBL) {</a>
<a name="ln1519">    int i;</a>
<a name="ln1520">    double d,xMin,yMin;</a>
<a name="ln1521"> </a>
<a name="ln1522">    if (nAtoms() == 0) return;</a>
<a name="ln1523"> </a>
<a name="ln1524">    d=averageBondLength();</a>
<a name="ln1525">    if ((d &gt; 0) &amp;&amp; (aveBL&gt;0)) for (i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln1526">        getAtom(i)-&gt;rx=getAtom(i)-&gt;rx*aveBL/d;</a>
<a name="ln1527">        getAtom(i)-&gt;ry=getAtom(i)-&gt;ry*aveBL/d;</a>
<a name="ln1528">      };</a>
<a name="ln1529">    //Normalizing X and Y coordinates</a>
<a name="ln1530">    xMin=getAtom(0)-&gt;rx;</a>
<a name="ln1531">    yMin=getAtom(0)-&gt;ry;</a>
<a name="ln1532">    for (i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln1533">      if (getAtom(i)-&gt;rx &lt; xMin) xMin=getAtom(i)-&gt;rx;</a>
<a name="ln1534">      if (getAtom(i)-&gt;ry &lt; yMin) yMin=getAtom(i)-&gt;ry;</a>
<a name="ln1535">    };</a>
<a name="ln1536">    for (i=0; i&lt; nAtoms(); i++) {</a>
<a name="ln1537">      getAtom(i)-&gt;rx=getAtom(i)-&gt;rx-xMin+aveBL;</a>
<a name="ln1538">      getAtom(i)-&gt;ry=getAtom(i)-&gt;ry-yMin+aveBL;</a>
<a name="ln1539">    };</a>
<a name="ln1540">  };</a>
<a name="ln1541"> </a>
<a name="ln1542">  void TSimpleMolecule::readOBMol(OBMol * pmol) {</a>
<a name="ln1543">    TSingleAtom * sa;</a>
<a name="ln1544">    TSingleBond * sb;</a>
<a name="ln1545">    OBAtom * atom;</a>
<a name="ln1546">    OBBond * bond;</a>
<a name="ln1547">    int na,nb,i;</a>
<a name="ln1548"> </a>
<a name="ln1549">    // Stereo perception should not be triggered if this function is called</a>
<a name="ln1550">    // from MDLFormat::ReadMolecule-&gt;Alias::Expand-&gt;Alias::FromNameLookup-&gt;(MCDL)groupRedraw</a>
<a name="ln1551">    // as this triggers a failure in the test suite for InChI conversion</a>
<a name="ln1552">    // (specifically the ferrocene).</a>
<a name="ln1553">    bool perceive_stereo = true;</a>
<a name="ln1554">    if (pmol-&gt;GetMod() == 1)</a>
<a name="ln1555">      perceive_stereo = false;</a>
<a name="ln1556">    OBStereoFacade facade(pmol);</a>
<a name="ln1557"> </a>
<a name="ln1558">    // When laying out, we may need to iterate over the most central bonds</a>
<a name="ln1559">    // first - that's why we remember the GTD: the GTD is the distance from</a>
<a name="ln1560">    // atom i to every other atom j. Atoms on the &quot;inside&quot; of the molecule</a>
<a name="ln1561">    // will have a lower GTD value than atoms on the &quot;outside&quot;.</a>
<a name="ln1562">    vector&lt;int&gt; vGTD;</a>
<a name="ln1563">    pmol-&gt;GetGTDVector(vGTD);</a>
<a name="ln1564"> </a>
<a name="ln1565">    clear();</a>
<a name="ln1566"> </a>
<a name="ln1567">    na=pmol-&gt;NumAtoms();</a>
<a name="ln1568">    nb=pmol-&gt;NumBonds();</a>
<a name="ln1569"> </a>
<a name="ln1570">    for (i=1; i&lt;=na; i++) {</a>
<a name="ln1571">      atom=pmol-&gt;GetAtom(i);</a>
<a name="ln1572">      sa=new TSingleAtom();</a>
<a name="ln1573">      sa-&gt;na=atom-&gt;GetAtomicNum();</a>
<a name="ln1574">      sa-&gt;nc=atom-&gt;GetFormalCharge();</a>
<a name="ln1575">      sa-&gt;rl=atom-&gt;GetSpinMultiplicity();</a>
<a name="ln1576">      sa-&gt;rx=atom-&gt;GetX();</a>
<a name="ln1577">      sa-&gt;ry=atom-&gt;GetY();</a>
<a name="ln1578">      sa-&gt;gtd = vGTD.at(i-1);</a>
<a name="ln1579">      fAtom.push_back(sa);</a>
<a name="ln1580">    };</a>
<a name="ln1581">    for (i=0; i&lt;nb; i++) {</a>
<a name="ln1582">      bond=pmol-&gt;GetBond(i);</a>
<a name="ln1583">      sb=new TSingleBond();</a>
<a name="ln1584">      sb-&gt;at[0]=bond-&gt;GetBeginAtomIdx()-1;</a>
<a name="ln1585">      sb-&gt;at[1]=bond-&gt;GetEndAtomIdx()-1;</a>
<a name="ln1586">      sb-&gt;tb=bond-&gt;GetBondOrder();</a>
<a name="ln1587">      //	if (bond-&gt;IsUp()) sb-&gt;tb=9;</a>
<a name="ln1588">      //	if (bond-&gt;IsDown()) sb-&gt;tb=10;</a>
<a name="ln1589">      if (bond-&gt;IsWedge()) sb-&gt;tb=9;</a>
<a name="ln1590">      if (bond-&gt;IsHash()) sb-&gt;tb=10;</a>
<a name="ln1591">      if (perceive_stereo &amp;&amp; facade.HasCisTransStereo(bond-&gt;GetId())) {</a>
<a name="ln1592">        OBCisTransStereo::Config config = facade.GetCisTransStereo(bond-&gt;GetId())-&gt;GetConfig(OBStereo::ShapeU);</a>
<a name="ln1593">        if (config.specified)</a>
<a name="ln1594">          sb-&gt;bstereo_refs = config.refs;</a>
<a name="ln1595">      }</a>
<a name="ln1596">      fBond.push_back(sb);</a>
<a name="ln1597">    };</a>
<a name="ln1598"> </a>
<a name="ln1599"> </a>
<a name="ln1600">    defineAtomConn();</a>
<a name="ln1601">    allAboutCycles();</a>
<a name="ln1602">  };</a>
<a name="ln1603"> </a>
<a name="ln1604"> </a>
<a name="ln1605">  int TSimpleMolecule::nAtoms() {</a>
<a name="ln1606">    return fAtom.size();</a>
<a name="ln1607">  };</a>
<a name="ln1608"> </a>
<a name="ln1609">  int TSimpleMolecule::nBonds() {</a>
<a name="ln1610">    return fBond.size();</a>
<a name="ln1611">  };</a>
<a name="ln1612"> </a>
<a name="ln1613"> </a>
<a name="ln1614">  TSingleAtom * TSimpleMolecule::getAtom(int index) {</a>
<a name="ln1615">    return (TSingleAtom *)fAtom.at(index);</a>
<a name="ln1616">  };</a>
<a name="ln1617"> </a>
<a name="ln1618">  TSingleBond * TSimpleMolecule::getBond(int index) {</a>
<a name="ln1619">    return (TSingleBond *)fBond.at(index);</a>
<a name="ln1620">  };</a>
<a name="ln1621"> </a>
<a name="ln1622">  void TSimpleMolecule::defineAtomConn() {</a>
<a name="ln1623">    //for each atom returns list of adjusted atoms in atomConnection</a>
<a name="ln1624">    int i,n1, n2;</a>
<a name="ln1625">    TSingleAtom * sa;</a>
<a name="ln1626"> </a>
<a name="ln1627">    for (i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln1628">      getAtom(i)-&gt;nb=0;</a>
<a name="ln1629">      getAtom(i)-&gt;currvalence=0;</a>
<a name="ln1630">    };</a>
<a name="ln1631">    for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln1632">      n1=getBond(i)-&gt;at[0]; n2=getBond(i)-&gt;at[1];</a>
<a name="ln1633">      sa=getAtom(n1);</a>
<a name="ln1634">      sa-&gt;ac[sa-&gt;nb]=n2;</a>
<a name="ln1635">      sa-&gt;nb++;</a>
<a name="ln1636">      sa-&gt;currvalence=sa-&gt;currvalence+getBond(i)-&gt;getValence();</a>
<a name="ln1637">      sa=getAtom(n2);</a>
<a name="ln1638">      sa-&gt;ac[sa-&gt;nb]=n1;</a>
<a name="ln1639">      sa-&gt;nb++;</a>
<a name="ln1640">      sa-&gt;currvalence=sa-&gt;currvalence+getBond(i)-&gt;getValence();</a>
<a name="ln1641">    };</a>
<a name="ln1642">  };</a>
<a name="ln1643"> </a>
<a name="ln1644">  void TSimpleMolecule::defineBondConn(neighbourlist *bondConnection) {</a>
<a name="ln1645">    //for each atom returns list of adjusted bonds in bondConnection</a>
<a name="ln1646">    int i,n1, n2;</a>
<a name="ln1647"> </a>
<a name="ln1648">    for (i=0; i&lt;nAtoms(); i++) bondConnection[i].nb=0;</a>
<a name="ln1649">    for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln1650">      n1=getBond(i)-&gt;at[0]; n2=getBond(i)-&gt;at[1];</a>
<a name="ln1651">      bondConnection[n1].adjusted[bondConnection[n1].nb]=i;</a>
<a name="ln1652">      bondConnection[n1].nb++;</a>
<a name="ln1653">      bondConnection[n2].adjusted[bondConnection[n2].nb]=i;</a>
<a name="ln1654">      bondConnection[n2].nb++;</a>
<a name="ln1655">    };</a>
<a name="ln1656">  };</a>
<a name="ln1657"> </a>
<a name="ln1658">  void TSimpleMolecule::newB(neighbourlist * bk, int bnum, int anum, int &amp; total, int * e, int * e1) {</a>
<a name="ln1659">    /*for atom's number ANUM calculates the bond's list, which are connected</a>
<a name="ln1660">      with the ANUM, excluding bond BNUM. The bond's list is inserted into array</a>
<a name="ln1661">      L, TOTAL-number of components in the array. Array L1 contains atom's number</a>
<a name="ln1662">      which is connected with atom ANUM through corresponding bond in the array L.*/</a>
<a name="ln1663">    int n,i;</a>
<a name="ln1664"> </a>
<a name="ln1665">    total=0;</a>
<a name="ln1666">    for (i=0; i&lt;bk[anum].nb; i++) if (bk[anum].adjusted[i] != bnum) {</a>
<a name="ln1667">        n=bk[anum].adjusted[i];  //bond number zero-based</a>
<a name="ln1668">        e[total]=n;</a>
<a name="ln1669">        if (getBond(n)-&gt;at[0] == anum) e1[total]=getBond(n)-&gt;at[1]; else e1[total]=getBond(n)-&gt;at[0];</a>
<a name="ln1670">        total++;</a>
<a name="ln1671">      };</a>
<a name="ln1672">  };</a>
<a name="ln1673"> </a>
<a name="ln1674">  void TSimpleMolecule::singleVawe(neighbourlist * bk, std::vector&lt;int&gt; &amp; alreadyDefined,</a>
<a name="ln1675">                                   std::vector&lt;int&gt; &amp; prevBond, std::vector&lt;int&gt; &amp; prevAtom,</a>
<a name="ln1676">                                   int &amp; nPrev, std::vector&lt;int&gt; &amp; curBond, std::vector&lt;int&gt; &amp; curAtom) {</a>
<a name="ln1677">    /*</a>
<a name="ln1678">      a vawe algorithm is used to calculate the neighbour sphere. PREVBOND and</a>
<a name="ln1679">      PREVATOM contain on input the bond's and atom's list correspondingly, the</a>
<a name="ln1680">      atom has been took into consideration at previous step. NPREV-number of</a>
<a name="ln1681">      components in PREVBOND and PREVATOM on input.  ALREADYDEFINED is the global</a>
<a name="ln1682">      array for procedure, which calls the SINGLEVAWE. It contains for each bond's</a>
<a name="ln1683">      number either zero, if the bond has not been took into consideration yet or</a>
<a name="ln1684">      bond's number from previous neighbour sphere. The subroutine makes next:</a>
<a name="ln1685">      1) calculates the new neighbour sphere for each bond from PREVBOND.</a>
<a name="ln1686">      2) if some bonds were not defined, they are labelled in ALREADYDEFINED,</a>
<a name="ln1687">      they numbers being stored into PREVBOND and PREVATOM. So, on output</a>
<a name="ln1688">      the arrays contain information for new neighbour sphere.</a>
<a name="ln1689">      3) On output NPrev is changed so new number of component in PREVBOND</a>
<a name="ln1690">      is lighted}</a>
<a name="ln1691">    */</a>
<a name="ln1692">    int e[CONNMAX];</a>
<a name="ln1693">    int e1[CONNMAX];</a>
<a name="ln1694">    int i,j,ncur;</a>
<a name="ln1695">    int n;</a>
<a name="ln1696"> </a>
<a name="ln1697">    ncur=0;</a>
<a name="ln1698">    n=0;</a>
<a name="ln1699">    for (i=0; i&lt;nPrev; i++) {</a>
<a name="ln1700">      newB(bk,prevBond[i],prevAtom[i],n,e,e1);</a>
<a name="ln1701">      if (n != 0) for (j=0; j&lt;n; j++) if (alreadyDefined[e[j]]&lt;0) {</a>
<a name="ln1702">            curBond[ncur]=e[j];</a>
<a name="ln1703">            curAtom[ncur]=e1[j];</a>
<a name="ln1704">            ncur++;</a>
<a name="ln1705">            alreadyDefined[e[j]]=prevBond[i];</a>
<a name="ln1706">          };</a>
<a name="ln1707">    };</a>
<a name="ln1708">    nPrev=ncur;</a>
<a name="ln1709">    for (i=0; i&lt;ncur; i++) prevBond[i]=curBond[i];</a>
<a name="ln1710">    for (i=0; i&lt;ncur; i++) prevAtom[i]=curAtom[i];</a>
<a name="ln1711">  };</a>
<a name="ln1712"> </a>
<a name="ln1713">  void TSimpleMolecule::vaweBond(int bondN, neighbourlist *bk,</a>
<a name="ln1714">                                 int &amp; ringSize, std::vector&lt;int&gt; &amp; bondList) {</a>
<a name="ln1715">    /*The procedure for bond's number BONDN determines, whether or not the bond</a>
<a name="ln1716">      belongs to ring (RINGSIZE=0 if not ring bond and RINGSIZE=number of atoms</a>
<a name="ln1717">      in the smallest ring, to which the bond is assigned). If the bond belongs</a>
<a name="ln1718">      to ring, array BONDLIST contains on output the bond's numbers, which are</a>
<a name="ln1719">      also assigned to the same ring */</a>
<a name="ln1720"> </a>
<a name="ln1721">    int i,j,k,aA,i1,i2;</a>
<a name="ln1722">    std::vector&lt;int&gt;pA(nBonds());</a>
<a name="ln1723">    std::vector&lt;int&gt;pB(nBonds());</a>
<a name="ln1724">    std::vector&lt;int&gt;oD(nBonds());</a>
<a name="ln1725">    std::vector&lt;int&gt;curBond(nBonds());</a>
<a name="ln1726">    std::vector&lt;int&gt;curAtom(nBonds());</a>
<a name="ln1727">    bool test;</a>
<a name="ln1728">    int nP;</a>
<a name="ln1729"> </a>
<a name="ln1730"> </a>
<a name="ln1731">    for (j=0; j&lt;nBonds(); j++) oD[j]=-1;</a>
<a name="ln1732">    oD[bondN]=65500;</a>
<a name="ln1733">    ringSize=1;</a>
<a name="ln1734">    nP=1;  //OK for zer-based in C</a>
<a name="ln1735">    pB[0]=bondN; //pB.setValue(1,bondN);</a>
<a name="ln1736">    pA[0]=getBond(bondN)-&gt;at[0];//pA.setValue(1,fBond.getAT(bondN,1));</a>
<a name="ln1737">    aA=getBond(bondN)-&gt;at[1];//fBond.getAT(bondN,2);</a>
<a name="ln1738"> </a>
<a name="ln1739">    k=0;</a>
<a name="ln1740">    test=false;</a>
<a name="ln1741">    while (! ((nP==0) || test)) {                        //recursion</a>
<a name="ln1742">      ringSize++;</a>
<a name="ln1743">      singleVawe(bk,oD,pB,pA,nP,curBond,curAtom);      //new neighbour sphere generation}</a>
<a name="ln1744">      test=false;</a>
<a name="ln1745">      if (nP&gt;0) for (j=0; j&lt;nP; j++) if (pA[j] == aA) {</a>
<a name="ln1746">            test=true;</a>
<a name="ln1747">            k=pB[j];</a>
<a name="ln1748">          };</a>
<a name="ln1749">    }; //recursion finishing</a>
<a name="ln1750">    if (test) {                    //bond belongs to ring</a>
<a name="ln1751">      bondList.resize(ringSize);</a>
<a name="ln1752">      bondList[ringSize-1]=bondN;         //bond BONDN must be last in the list</a>
<a name="ln1753">      for (j=1; j&lt;ringSize; j++) {        //BONDLIST formation</a>
<a name="ln1754">        bondList[j-1]=k;</a>
<a name="ln1755">        k=oD[k];</a>
<a name="ln1756">      };</a>
<a name="ln1757">      //Sorting remaining bonds in ascending order - need for cycle comparison</a>
<a name="ln1758">      k=2;                   //all bonds are sorted</a>
<a name="ln1759">      //remains last bond in cycle description=bondN (input parameter)</a>
<a name="ln1760">      for (i=0; i&lt;(ringSize-k); i++) for (j=i+1; j&lt;=(ringSize-k); j++) {</a>
<a name="ln1761">          i1=bondList[i];</a>
<a name="ln1762">          i2=bondList[j];</a>
<a name="ln1763">          if (i1 &gt; i2) {</a>
<a name="ln1764">            bondList[i]=i2;</a>
<a name="ln1765">            bondList[j]=i1;</a>
<a name="ln1766">          };</a>
<a name="ln1767">        };</a>
<a name="ln1768">    } else ringSize=0;</a>
<a name="ln1769">  };</a>
<a name="ln1770"> </a>
<a name="ln1771"> </a>
<a name="ln1772">  //This method must be called ONLY from AllAboutCycles</a>
<a name="ln1773">  bool TSimpleMolecule::aromatic(int cycleSize, const std::vector&lt;int&gt; bondList,</a>
<a name="ln1774">                                 std::vector&lt;int&gt;&amp; arom) {</a>
<a name="ln1775"> </a>
<a name="ln1776">    /*for a cycle with the dimension of CYCLESIZE determines, whether or not the</a>
<a name="ln1777">      cycle is aromatic. BONDLIST contains the bond's numbers, which are belongs</a>
<a name="ln1778">      to the cycle. AROM-global array for the structure under study, for each bond</a>
<a name="ln1779">      in the structure contains label, whether the bond is aromatic or not. On out-</a>
<a name="ln1780">      put function AROMATIC contains TRUE if the ring is aromatic, FALSE otherwise</a>
<a name="ln1781">    */</a>
<a name="ln1782">    bool test;</a>
<a name="ln1783">    int i,j,k,n,n1,m;</a>
<a name="ln1784">    int doubleDetected[11];</a>
<a name="ln1785">    int atomDetected[11];</a>
<a name="ln1786">    bool result=false;</a>
<a name="ln1787"> </a>
<a name="ln1788">    if ((cycleSize&lt;5) || (cycleSize&gt;6)) return result;</a>
<a name="ln1789">    //procedure define aromatic only for 5 or 6 membered cycles}</a>
<a name="ln1790">    //Simple Test}</a>
<a name="ln1791">    n=0;</a>
<a name="ln1792">    for (i=0; i&lt;cycleSize; i++) {</a>
<a name="ln1793">      k=bondList[i];</a>
<a name="ln1794"> </a>
<a name="ln1795">      if ((getBond(k)-&gt;tb == 1) &amp;&amp; (arom[k]==0)) doubleDetected[i]=0; else</a>
<a name="ln1796">        if ((getBond(k)-&gt;tb == 2) || (getBond(k)-&gt;tb == 4) || (arom[k]&gt;0)) {</a>
<a name="ln1797">          n=n+1;                 //number of double or aromatic bonds calculation}</a>
<a name="ln1798">          doubleDetected[i]=1;</a>
<a name="ln1799">        } else return result;</a>
<a name="ln1800">    };</a>
<a name="ln1801">    if (cycleSize==6) {     //6-membered ring}</a>
<a name="ln1802">      if (n&gt;=3) {</a>
<a name="ln1803">        result=true;</a>
<a name="ln1804">        if (n&lt;=4) for (i=0; i&lt;cycleSize; i++) if (doubleDetected[i]==0) {</a>
<a name="ln1805">              //Checking if not connected</a>
<a name="ln1806">              for (j=0; j&lt;cycleSize; j++) if ((j != i) &amp;&amp; (doubleDetected[j]==0)) {</a>
<a name="ln1807">                  test=(getBond(bondList[i])-&gt;at[0] == getBond(bondList[j])-&gt;at[0]) || (getBond(bondList[i])-&gt;at[0] == getBond(bondList[j])-&gt;at[1])</a>
<a name="ln1808">                    || (getBond(bondList[i])-&gt;at[1] == getBond(bondList[j])-&gt;at[0]) || (getBond(bondList[i])-&gt;at[1] == getBond(bondList[j])-&gt;at[1]);</a>
<a name="ln1809">                  if (test) result=false;</a>
<a name="ln1810">                  if (! result) break;</a>
<a name="ln1811">                };</a>
<a name="ln1812">              if (! result) break;</a>
<a name="ln1813">            };</a>
<a name="ln1814">      };</a>
<a name="ln1815">      return result;</a>
<a name="ln1816">    };</a>
<a name="ln1817"> </a>
<a name="ln1818">    if (n&lt;2) return result;        //5-membered ring</a>
<a name="ln1819">    m=0;</a>
<a name="ln1820">    for (i=0; i&lt;cycleSize; i++) if (doubleDetected[i]==0) {</a>
<a name="ln1821">        atomDetected[m]=getBond(bondList[i])-&gt;at[0];</a>
<a name="ln1822">        m++;</a>
<a name="ln1823">        atomDetected[m]=getBond(bondList[i])-&gt;at[1];</a>
<a name="ln1824">        m++;</a>
<a name="ln1825">      };</a>
<a name="ln1826">    n=-1;</a>
<a name="ln1827">    if (m&gt;0) for (i=0; i&lt;(m-1); i++) for (j=i+1; j&lt;m; j++) if (atomDetected[i]==atomDetected[j]) n=i;</a>
<a name="ln1828">    //Addition from January 2001</a>
<a name="ln1829">    if (n&gt;=0) {</a>
<a name="ln1830">      n1=-1;</a>
<a name="ln1831">      for (i=0; i&lt;(m-1); i++) if (i != n) for (j=i+1; j&lt;m; j++) if (atomDetected[i]==atomDetected[j]) n1=i;</a>
<a name="ln1832">      if (n1&gt;=0) return result;</a>
<a name="ln1833">    };</a>
<a name="ln1834">    if (n &lt; 0) {   //No common atoms...</a>
<a name="ln1835">      result=m==4;</a>
<a name="ln1836">      return result;</a>
<a name="ln1837">    };</a>
<a name="ln1838">    test=false;</a>
<a name="ln1839">    i=0;</a>
<a name="ln1840">    j=getAtom(atomDetected[n])-&gt;na;</a>
<a name="ln1841">    for (i=0; i&lt;NAROMMAX; i++) if (j == possibleAromatic[i]) {</a>
<a name="ln1842">        test=true;</a>
<a name="ln1843">        break;</a>
<a name="ln1844">      };</a>
<a name="ln1845">    if (! test) test=(j==6) &amp;&amp; (getAtom(atomDetected[n])-&gt;nc &lt; 0);</a>
<a name="ln1846">    //cyclopentadienyl checking}</a>
<a name="ln1847">    result=test;</a>
<a name="ln1848">    return result;</a>
<a name="ln1849">  };</a>
<a name="ln1850"> </a>
<a name="ln1851">  void TSimpleMolecule::allAboutCycles() {</a>
<a name="ln1852">    /*</a>
<a name="ln1853">      for each bond in the structure cyclic conditions are calculated and stored</a>
<a name="ln1854">      into the BOND[I].DB variables. Possible values:</a>
<a name="ln1855">      0 - chain;</a>
<a name="ln1856">      1 - chain, appended to cycle;</a>
<a name="ln1857">      2 - aromatic, 5-membered ring;</a>
<a name="ln1858">      3 - aromatic, 6-membered ring;</a>
<a name="ln1859">      4...more = non-aromatic ring size+1}</a>
<a name="ln1860">    */</a>
<a name="ln1861">    std::vector&lt;int&gt;bondTested(nBonds(), 0);</a>
<a name="ln1862">    std::vector&lt;int&gt;bondList;</a>
<a name="ln1863">    std::vector&lt;int&gt;ar(nBonds(), 0);</a>
<a name="ln1864">    std::vector&lt;int&gt;ar1(nBonds());</a>
<a name="ln1865">    std::vector&lt;std::vector&lt;int&gt; &gt; cycleDescription;</a>
<a name="ln1866"> </a>
<a name="ln1867">    int i,n,j,k;</a>
<a name="ln1868">    int cycleSize;</a>
<a name="ln1869">    neighbourlist *bk;</a>
<a name="ln1870"> </a>
<a name="ln1871">    if (nBonds() == 0) return;</a>
<a name="ln1872">    bk=(neighbourlist *)malloc(nAtoms() * sizeof(adjustedlist));</a>
<a name="ln1873">    defineBondConn(bk);</a>
<a name="ln1874">    //initial values for MainList-number of bonds, connected to each atom and their numbers in array BOND</a>
<a name="ln1875">    for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln1876">      getBond(i)-&gt;db=0;</a>
<a name="ln1877">    }</a>
<a name="ln1878">    n=0;</a>
<a name="ln1879">    for (i=0; i&lt;nBonds(); i++) if (bondTested[i] == 0) {</a>
<a name="ln1880">        vaweBond(i,bk,cycleSize,bondList); //Is I-th bond cyclic?</a>
<a name="ln1881">        if (cycleSize&gt;0) {       //Yes, cyclic</a>
<a name="ln1882">          canonizeCycle(cycleSize,bondList);</a>
<a name="ln1883">          cycleDescription.push_back(bondList);</a>
<a name="ln1884">          n++;</a>
<a name="ln1885">          ar1[n-1]=0;</a>
<a name="ln1886">          if (aromatic(cycleSize,bondList,ar)) {       //store, if aromatic cycle}</a>
<a name="ln1887">            ar1[n-1]=1;</a>
<a name="ln1888">            for (j=0; j&lt;cycleSize; j++) ar[bondList[j]]=1;</a>
<a name="ln1889">          };</a>
<a name="ln1890">          for (j=0; j&lt;cycleSize; j++) bondTested[bondList[j]]=1;</a>
<a name="ln1891">          //marking all bonds in the cycle}</a>
<a name="ln1892">        };</a>
<a name="ln1893">        bondTested[i]=1;                                //marking I-th bond</a>
<a name="ln1894">      };</a>
<a name="ln1895">    if (n&gt;0) {</a>
<a name="ln1896">      j=1;</a>
<a name="ln1897">      while (j != 0) {</a>
<a name="ln1898">        j=0;</a>
<a name="ln1899">        for (i=0; i&lt;n; i++) if (ar1[i]==0) {   //search for condenced aromatics</a>
<a name="ln1900">            bondList=cycleDescription[i];</a>
<a name="ln1901">            cycleSize=bondList.size();</a>
<a name="ln1902">            if (aromatic(cycleSize,bondList,ar)) {</a>
<a name="ln1903">              j++;</a>
<a name="ln1904">              ar1[i]=1;</a>
<a name="ln1905">              for (k=0; k&lt;cycleSize; k++) ar[bondList[k]]=1;</a>
<a name="ln1906">            };</a>
<a name="ln1907">          };</a>
<a name="ln1908">      }; //until J=0;          {until new aromatics are not detected under iteration}</a>
<a name="ln1909">      for (i=0; i&lt;n; i++) if (ar1[i]==0) {       //Label of non-aromatic cycles in BOND</a>
<a name="ln1910">          bondList=cycleDescription[i];</a>
<a name="ln1911">          cycleSize=bondList.size();</a>
<a name="ln1912">          for (j=0; j&lt;cycleSize; j++) {</a>
<a name="ln1913">            k=cycleSize+1;</a>
<a name="ln1914">            if ((getBond(bondList[j])-&gt;db==0) || (k&lt;getBond(bondList[j])-&gt;db)) getBond(bondList[j])-&gt;db=k;</a>
<a name="ln1915">          };</a>
<a name="ln1916">        };</a>
<a name="ln1917">      for (i=0; i&lt;n; i++) if (ar1[i]==1)  {     //Label of aromatic cycle in BOND</a>
<a name="ln1918">          bondList=cycleDescription[i];</a>
<a name="ln1919">          cycleSize=bondList.size();</a>
<a name="ln1920">          for (j=0; j&lt;cycleSize; j++) {</a>
<a name="ln1921">            if (cycleSize==5) getBond(bondList[j])-&gt;db=2;</a>
<a name="ln1922">            if ((cycleSize==6) &amp;&amp; (getBond(bondList[j])-&gt;db != 2)) getBond(bondList[j])-&gt;db=3;</a>
<a name="ln1923">          };</a>
<a name="ln1924">        };</a>
<a name="ln1925">    };</a>
<a name="ln1926">    free(bk);</a>
<a name="ln1927">  };</a>
<a name="ln1928"> </a>
<a name="ln1929"> </a>
<a name="ln1930">  void TSimpleMolecule::redrawMolecule() {</a>
<a name="ln1931">    int i;</a>
<a name="ln1932">    int atomClean;</a>
<a name="ln1933">    int bondClean;</a>
<a name="ln1934">    std::vector&lt;int&gt;listAtomClean(nAtoms());</a>
<a name="ln1935">    std::vector&lt;int&gt;listBondClean(nBonds());</a>
<a name="ln1936"> </a>
<a name="ln1937">    if (nAtoms()==0) return;</a>
<a name="ln1938">    for (i=0; i&lt;nAtoms(); i++) listAtomClean[i]=i;</a>
<a name="ln1939">    for (i=0; i&lt;nBonds(); i++) listBondClean[i]=i;</a>
<a name="ln1940">    atomClean=nAtoms();</a>
<a name="ln1941">    bondClean=nBonds();</a>
<a name="ln1942">    redraw(listAtomClean,listBondClean,atomClean,bondClean,1,1,0,false);</a>
<a name="ln1943">  };</a>
<a name="ln1944"> </a>
<a name="ln1945"> </a>
<a name="ln1946">  void TSimpleMolecule::twoAtomUnitVector(int na1, int na2, double &amp; xv, double &amp; yv, const std::vector&lt;int&gt;atomDefine) {</a>
<a name="ln1947">    /*Using atom's numbers NA1 and NA2 in the array ATOMS calculates the direction</a>
<a name="ln1948">      for bond between NA1 and NA2 (XV,YV on output). At this direction new</a>
<a name="ln1949">      substitutor may be added with optimal place.*/</a>
<a name="ln1950">    double si,r1,r2,r3,s1,s2,s3,s4,x1,y1,y2;</a>
<a name="ln1951">    int i,k;</a>
<a name="ln1952"> </a>
<a name="ln1953">    if ((getAtom(na1)-&gt;rx==getAtom(na2)-&gt;rx) &amp;&amp; (getAtom(na1)-&gt;ry==getAtom(na2)-&gt;ry)) {</a>
<a name="ln1954">      xv=1;</a>
<a name="ln1955">      yv=1;</a>
<a name="ln1956">      return;</a>
<a name="ln1957">    };</a>
<a name="ln1958">    s1=getAtom(na1)-&gt;rx;</a>
<a name="ln1959">    s2=getAtom(na1)-&gt;ry;</a>
<a name="ln1960">    s3=getAtom(na2)-&gt;rx;</a>
<a name="ln1961">    s4=getAtom(na2)-&gt;ry;</a>
<a name="ln1962">    r1=s1-s3;</a>
<a name="ln1963">    r2=s2-s4;</a>
<a name="ln1964">    r3=sqrt(r1*r1+r2*r2);</a>
<a name="ln1965">    r1=r1/r3;  r2=r2/r3;</a>
<a name="ln1966">    si=0;</a>
<a name="ln1967">    for (i=0; i&lt;getAtom(na1)-&gt;nb; i++) {</a>
<a name="ln1968">      k=getAtom(na1)-&gt;ac[i];</a>
<a name="ln1969">      if (k != na2) if (atomDefine[k] &gt; 0) {</a>
<a name="ln1970">          x1=getAtom(k)-&gt;rx-s1;</a>
<a name="ln1971">          y1=getAtom(k)-&gt;ry-s2;</a>
<a name="ln1972">          y2=x1*r2-y1*r1;</a>
<a name="ln1973">          if (y2 != 0) si=si+y2/abs(y2);</a>
<a name="ln1974">        };</a>
<a name="ln1975">    };</a>
<a name="ln1976">    for (i=0; i&lt;getAtom(na2)-&gt;nb; i++) {</a>
<a name="ln1977">      k=getAtom(na2)-&gt;ac[i];</a>
<a name="ln1978">      if (k != na1) if (atomDefine[k] &gt; 0) {</a>
<a name="ln1979">          x1=getAtom(k)-&gt;rx-s3;</a>
<a name="ln1980">          y1=getAtom(k)-&gt;ry-s4;</a>
<a name="ln1981">          y2=x1*r2-y1*r1;</a>
<a name="ln1982">          if (y2 != 0) si=si+y2/abs(y2);</a>
<a name="ln1983">        };</a>
<a name="ln1984">    };</a>
<a name="ln1985">    if (si != 0) si=si/abs(si); else si=1;</a>
<a name="ln1986">    xv=-r2*si; yv=r1*si;</a>
<a name="ln1987">  };</a>
<a name="ln1988"> </a>
<a name="ln1989">  void TSimpleMolecule::defC(int&amp; currNumDef, int baseCycle, int atomClean, std::vector&lt;int&gt;&amp; cycleDefine,</a>
<a name="ln1990">    std::vector&lt;int&gt;&amp; atomDefine, std::vector&lt;std::vector&lt;int&gt; &gt;&amp; atomCycle, std::vector&lt;int&gt;&amp; dsATN,</a>
<a name="ln1991">                             std::vector&lt;int&gt;&amp; dsTP,</a>
<a name="ln1992">                             std::vector&lt;int&gt;&amp; dsSC, std::vector&lt;int&gt;&amp; dsNA1, std::vector&lt;int&gt;&amp; dsNA2) {</a>
<a name="ln1993">    //The procedure create priority list formation for cleaning of molecule. Recur-</a>
<a name="ln1994">    // sive calls to the procedure are required together with DefA. After recursion</a>
<a name="ln1995">    // have been finished, the DEFINESEQUENCE array will be created. The procedure</a>
<a name="ln1996">    // analyze cyclic fragments</a>
<a name="ln1997">    int aA,cN,maxAtDef,i,j,atDef;</a>
<a name="ln1998">    bool test;</a>
<a name="ln1999"> </a>
<a name="ln2000">    test=true;</a>
<a name="ln2001">    while (test) {</a>
<a name="ln2002">      cN=-1;</a>
<a name="ln2003">      if ((baseCycle==0) || (currNumDef==atomClean)) return;</a>
<a name="ln2004">      maxAtDef=0;</a>
<a name="ln2005">      for (i=0; i&lt;baseCycle; i++) if (cycleDefine[i]==0) {</a>
<a name="ln2006">          //        {for all cycles, which were not included into priority list}</a>
<a name="ln2007">          atDef=0;</a>
<a name="ln2008">          //        {search for maximal priority level}</a>
<a name="ln2009">          for (j=0; j&lt;atomCycle[i].size(); j++) if (atomDefine[atomCycle[i][j]]&gt;0) atDef=atDef+1;</a>
<a name="ln2010">          if (atDef &gt; maxAtDef) {</a>
<a name="ln2011">            //          {  search for cycles, for which maximal number of atoms were inserted in the priority list}</a>
<a name="ln2012">            maxAtDef=atDef;</a>
<a name="ln2013">            cN=i;</a>
<a name="ln2014">          } else if ((maxAtDef &gt; 0) &amp;&amp; (atDef==maxAtDef)) {</a>
<a name="ln2015">            //         {search for minimal cycle size}</a>
<a name="ln2016">            if (atomCycle[i].size()&lt;atomCycle[cN].size()) cN=i;</a>
<a name="ln2017">          };</a>
<a name="ln2018">        };</a>
<a name="ln2019">      if (cN&gt;=0) if (maxAtDef==atomCycle[cN].size()) {</a>
<a name="ln2020">          cycleDefine[cN]=1;</a>
<a name="ln2021">          cN=-1;</a>
<a name="ln2022">        };</a>
<a name="ln2023"> </a>
<a name="ln2024">      //          {CN-number of selected cycle with max.number of atoms, already defined, or with minimal size}</a>
<a name="ln2025">      if (cN&gt;=0) {</a>
<a name="ln2026">        cycleDefine[cN]=1;  //{Label, that CN-th cycle is inserted into priority list}</a>
<a name="ln2027"> </a>
<a name="ln2028">        test=(atomDefine[atomCycle[cN][0]]&gt;0) &amp;&amp;</a>
<a name="ln2029">          (atomDefine[atomCycle[cN][atomCycle[cN].size() - 1]]==0);</a>
<a name="ln2030">        //        {if first atom from cyclic fragment was inserted into list previously and last-no}</a>
<a name="ln2031">        while (! test) {</a>
<a name="ln2032">          //          {enumeration of atom's sequence in cyclic fragment}</a>
<a name="ln2033">          aA=atomCycle[cN][0];</a>
<a name="ln2034">          for (j=1; j&lt;atomCycle[cN].size(); j++) atomCycle[cN][j-1]=atomCycle[cN][j];</a>
<a name="ln2035">          atomCycle[cN][atomCycle[cN].size() - 1]=aA;</a>
<a name="ln2036">          test=(atomDefine[atomCycle[cN][0]]&gt;0) &amp;&amp;</a>
<a name="ln2037">            (atomDefine[atomCycle[cN][atomCycle[cN].size() - 1]]==0);</a>
<a name="ln2038">        };</a>
<a name="ln2039">        //        {now first atom in the cycle definition list must be inserted into the priority list early, and the last atom-no}</a>
<a name="ln2040">        for (j=0;currNumDef &lt; atomClean &amp;&amp; j&lt;atomCycle[cN].size()-maxAtDef; j++) {</a>
<a name="ln2041">          //          for each undefined atom from selected cycle}</a>
<a name="ln2042">          //atom is added to priority list}</a>
<a name="ln2043">          dsATN[currNumDef]=atomCycle[cN][maxAtDef+j];</a>
<a name="ln2044"> </a>
<a name="ln2045">          atomDefine[dsATN[currNumDef]]=1;</a>
<a name="ln2046">          if (maxAtDef&lt;3) dsTP[currNumDef]=maxAtDef+1; else dsTP[currNumDef]=4;</a>
<a name="ln2047">          //type of clean procedure definition}</a>
<a name="ln2048">          dsNA1[currNumDef]=atomCycle[cN][maxAtDef-1];</a>
<a name="ln2049">          dsNA2[currNumDef]=atomCycle[cN][0];</a>
<a name="ln2050">          dsSC[currNumDef]=atomCycle[cN].size()-maxAtDef;</a>
<a name="ln2051">          currNumDef++;</a>
<a name="ln2052"> </a>
<a name="ln2053">          /*       Initial Java codes</a>
<a name="ln2054">          //atom is added to priority list}</a>
<a name="ln2055">          dsATN.setValue(currNumDef.value,atomCycle.getValue(cycleAddress.getValue(cN)+maxAtDef+j));</a>
<a name="ln2056">          atomDefine.setValue(dsATN.getValue(currNumDef.value),1);</a>
<a name="ln2057">          if (maxAtDef&lt;3) dsTP.setValue(currNumDef.value,maxAtDef+1); else dsTP.setValue(currNumDef.value,4);</a>
<a name="ln2058">          //type of clean procedure definition}</a>
<a name="ln2059">          dsNA1.setValue(currNumDef.value,atomCycle.getValue(cycleAddress.getValue(cN)+maxAtDef));</a>
<a name="ln2060">          dsNA2.setValue(currNumDef.value,atomCycle.getValue(cycleAddress.getValue(cN)+1));</a>
<a name="ln2061">          dsSC.setValue(currNumDef.value,cycleSize.getValue(cN)-maxAtDef);</a>
<a name="ln2062">          currNumDef.value=currNumDef.value+1;</a>
<a name="ln2063">          */</a>
<a name="ln2064">        };</a>
<a name="ln2065">      };</a>
<a name="ln2066">      test=(cN&lt;0) || (currNumDef==atomClean);</a>
<a name="ln2067">      test=! test;</a>
<a name="ln2068">    };</a>
<a name="ln2069">  };</a>
<a name="ln2070"> </a>
<a name="ln2071">  void TSimpleMolecule::defA(int&amp; currNumDef, int atomClean, int sPN, int baseCycle, std::vector&lt;int&gt;&amp; atomDefine, const std::vector&lt;int&gt; listAtomClean,</a>
<a name="ln2072">                             std::vector&lt;int&gt;&amp; cycleDefine, std::vector&lt;std::vector&lt;int&gt; &gt;&amp; atomCycle,</a>
<a name="ln2073">                             std::vector&lt;int&gt;&amp; dsATN, std::vector&lt;int&gt;&amp; dsTP, std::vector&lt;int&gt;&amp; dsNA1, std::vector&lt;int&gt;&amp; dsNA2) {</a>
<a name="ln2074"> </a>
<a name="ln2075">    //The procedure create priority list formation for cleaning of molecule. Recur-</a>
<a name="ln2076">    // sive calls to the procedure are required together with DefC. After recursion</a>
<a name="ln2077">    //have been finished, the DEFINESEQUENCE array will be created. The procedure</a>
<a name="ln2078">    //analyze chain fragments</a>
<a name="ln2079">    int i,j,k,rC;</a>
<a name="ln2080"> </a>
<a name="ln2081"> </a>
<a name="ln2082"> </a>
<a name="ln2083">    if (currNumDef==atomClean) return;</a>
<a name="ln2084"> </a>
<a name="ln2085">    for (i=0; i&lt;atomClean; i++) if (atomDefine[listAtomClean[i]]==0)</a>
<a name="ln2086">                                  if (getAtom(listAtomClean[i])-&gt;nb &gt; 0) for (j=0; j&lt;getAtom(listAtomClean[i])-&gt;nb; j++) {</a>
<a name="ln2087">                                      k=getAtom(listAtomClean[i])-&gt;ac[j];</a>
<a name="ln2088">                                      if (atomDefine[k]&gt;0) {</a>
<a name="ln2089">                                        //if atom has a neighbour, which has already been inserted into priority</a>
<a name="ln2090">                                        // list, then it is inserted into the priority list}</a>
<a name="ln2091">                                        dsATN[currNumDef]=listAtomClean[i];</a>
<a name="ln2092">                                        atomDefine[dsATN[currNumDef]]=1;</a>
<a name="ln2093">                                        dsTP[currNumDef]=1;                  //type of clean}</a>
<a name="ln2094">                                        dsNA1[currNumDef]=k;</a>
<a name="ln2095">                                        dsNA2[currNumDef]=-1;</a>
<a name="ln2096">                                        currNumDef++;</a>
<a name="ln2097">                                        //only one atom is added into priority list, then it is necessary to</a>
<a name="ln2098">                                        // analyze cycles by DEFC procedure!}</a>
<a name="ln2099">                                        return;</a>
<a name="ln2100">                                      };</a>
<a name="ln2101">                                    };</a>
<a name="ln2102">    if ((sPN&lt;3) || (sPN==4)) {   //{next may not be implemented to CleanGroup command}</a>
<a name="ln2103">      //{initializing priority list for clean of a new fragment}</a>
<a name="ln2104">      rC=0;</a>
<a name="ln2105">      j=100000;</a>
<a name="ln2106">      //minimal cycle size searching}</a>
<a name="ln2107">      if (baseCycle&gt;0) for (i=0; i&lt;baseCycle; i++) if (cycleDefine[i]==0) if (atomCycle[i].size()&lt;j) {</a>
<a name="ln2108">              rC=i;</a>
<a name="ln2109">              j=atomCycle[i].size();</a>
<a name="ln2110">            };</a>
<a name="ln2111">      if (rC&gt;0) i=atomCycle[rC][0]; else {</a>
<a name="ln2112">        //        {not found-first undefined atom is selected}</a>
<a name="ln2113">        i=0;</a>
<a name="ln2114">        while (atomDefine[listAtomClean[i]] != 0) i++;</a>
<a name="ln2115">        i=listAtomClean[i];</a>
<a name="ln2116">      };</a>
<a name="ln2117">    } else i=listAtomClean[atomClean-1];</a>
<a name="ln2118">    //for group-first atom, from which group started, is selected}</a>
<a name="ln2119">    dsATN[currNumDef]=i;</a>
<a name="ln2120">    atomDefine[dsATN[currNumDef]]=1;</a>
<a name="ln2121">    dsTP[currNumDef]=0;                  //type of clean}</a>
<a name="ln2122">    dsNA1[currNumDef]=-1;</a>
<a name="ln2123">    dsNA2[currNumDef]=-1;</a>
<a name="ln2124">    currNumDef++; //Addition the atom selected to the list}</a>
<a name="ln2125">  };</a>
<a name="ln2126"> </a>
<a name="ln2127">  void TSimpleMolecule::canonizeCycle(int ringSize, std::vector&lt;int&gt; &amp; bondList) {</a>
<a name="ln2128">    //Order of nonds in cycle description in so way, that bond with minimal number</a>
<a name="ln2129">    //is the first in this description. Then is coming bond, which is appended to</a>
<a name="ln2130">    //atom with maximal number, then next and so on</a>
<a name="ln2131">    std::vector&lt;int&gt; bondUsed(ringSize);</a>
<a name="ln2132">    std::vector&lt;int&gt; newBondList(ringSize);</a>
<a name="ln2133">    int i,j,n,m,currentAtom;</a>
<a name="ln2134"> </a>
<a name="ln2135">    n=bondList[0];</a>
<a name="ln2136">    m=0;</a>
<a name="ln2137">    for (i=0; i&lt;ringSize; i++) {</a>
<a name="ln2138">      bondUsed[i]=0;</a>
<a name="ln2139">      if (bondList[i]&lt;n) {  //minimal bond number</a>
<a name="ln2140">        n=bondList[i];</a>
<a name="ln2141">        m=i;</a>
<a name="ln2142">      };</a>
<a name="ln2143">    };</a>
<a name="ln2144">    currentAtom=getBond(n)-&gt;at[0];</a>
<a name="ln2145">    if (getBond(n)-&gt;at[1] &gt; currentAtom) currentAtom=getBond(n)-&gt;at[1];</a>
<a name="ln2146">    newBondList[0]=n;</a>
<a name="ln2147">    bondUsed[m]=1;</a>
<a name="ln2148">    n=1;</a>
<a name="ln2149">    for (i=1; i&lt;ringSize; i++) {  //cycle size-1 because of 1-st bond already selected</a>
<a name="ln2150">      for (j=0; j&lt;ringSize; j++) if (bondUsed[j] == 0) {</a>
<a name="ln2151">          m=bondList[j];</a>
<a name="ln2152">          if ((getBond(m)-&gt;at[0] == currentAtom) || (getBond(m)-&gt;at[1] == currentAtom)) {</a>
<a name="ln2153">            bondUsed[j]=1;</a>
<a name="ln2154">            newBondList[n]=m;</a>
<a name="ln2155">            n++;</a>
<a name="ln2156">            if (getBond(m)-&gt;at[0] == currentAtom) currentAtom=getBond(m)-&gt;at[1]; else currentAtom=getBond(m)-&gt;at[0];</a>
<a name="ln2157">            break;</a>
<a name="ln2158">          };</a>
<a name="ln2159">        };</a>
<a name="ln2160">    };</a>
<a name="ln2161">    //copy new set</a>
<a name="ln2162">    for (i=0; i&lt;ringSize; i++)bondList[i]=newBondList[i];</a>
<a name="ln2163">  };</a>
<a name="ln2164"> </a>
<a name="ln2165">  void TSimpleMolecule::redraw(const std::vector&lt;int&gt;listAtomClean, const std::vector&lt;int&gt;listBondClean,</a>
<a name="ln2166">                               int atomClean, int &amp; bondClean, int spn, int sCHA1, int sCHB1, bool iOPT7) {</a>
<a name="ln2167">    /*</a>
<a name="ln2168">      the arrays are the priority list for clean. Minimal element of record has</a>
<a name="ln2169">      the maximal priority. Each element of record contains:</a>
<a name="ln2170">      ATN-atom's number in the ATOM array, coordinate of which must be calculated</a>
<a name="ln2171">      at current step.</a>
<a name="ln2172">      TP -type of calculation of coordinates for the atom ATN:</a>
<a name="ln2173">      =0 - simple put at any position</a>
<a name="ln2174">      =1 - calculation from coordinates of previously defined atom NA1. NA2</a>
<a name="ln2175">      value hasn't effect in the case.</a>
<a name="ln2176">      =2 - for cyclic fragment, coordinates of all cyclic atoms must be cal-</a>
<a name="ln2177">      culated from the ones for atom NA1-base atom in cycle. This type</a>
<a name="ln2178">      means fragment: chain bond, attached to the cycle. NA2 value hasn't</a>
<a name="ln2179">      effect in the case.</a>
<a name="ln2180">      =3 - for cyclic fragment, coordinates of all cyclic atoms must be cal-</a>
<a name="ln2181">      culated from the ones for pair of atoms NA1 and NA2. The pair is</a>
<a name="ln2182">      connected with bond. This type means fragment in condenced-cyclic</a>
<a name="ln2183">      systems.</a>
<a name="ln2184">      =4 - for cyclic fragment, coordinates of all cyclic atoms must be cal-</a>
<a name="ln2185">      culated from the ones for pair of atoms NA1 and NA2. The pair is</a>
<a name="ln2186">      connected through more, then one bond. This type means fragment</a>
<a name="ln2187">      in polycyclic systems.</a>
<a name="ln2188">      AN1,AN2-auxiliary atom's numbers (see TP description).</a>
<a name="ln2189">      SC-cycle size minus number of already defined atoms. The variable is taken</a>
<a name="ln2190">      into consideration for TP=2-4.</a>
<a name="ln2191">    */</a>
<a name="ln2192">    bool test;</a>
<a name="ln2193">    int cs;</a>
<a name="ln2194">    int add,nb,k,k1,k2,l,i,j,baseCycle,lx,ly;</a>
<a name="ln2195">    int currNumDef;</a>
<a name="ln2196">    int atomSecond;</a>
<a name="ln2197"> </a>
<a name="ln2198">    double r,cf,fi,ux,uy,ux1,uy1,ux2,uy2,uvX,uvY,c,s;</a>
<a name="ln2199">    double xCenterOld,yCenterOld,xCenterNew,yCenterNew,bondLengthOld,bondLengthNew;</a>
<a name="ln2200">    neighbourlist *bk;</a>
<a name="ln2201">    int n,n1,n2;</a>
<a name="ln2202">    double r1;</a>
<a name="ln2203">    bool isCycle,isChainFour;</a>
<a name="ln2204">    int mm1,mm2,mAny,bnEx;</a>
<a name="ln2205"> </a>
<a name="ln2206">    //Lx,Ly,Button:integer;</a>
<a name="ln2207"> </a>
<a name="ln2208">    if ((atomClean&lt;1) || (bondClean==0)) return;</a>
<a name="ln2209"> </a>
<a name="ln2210">    std::vector&lt;int&gt; dsATN(atomClean);</a>
<a name="ln2211">    std::vector&lt;int&gt; dsTP(atomClean);</a>
<a name="ln2212">    std::vector&lt;int&gt; dsSC(atomClean);</a>
<a name="ln2213">    std::vector&lt;int&gt; dsNA1(atomClean);</a>
<a name="ln2214">    std::vector&lt;int&gt; dsNA2(atomClean);</a>
<a name="ln2215"> </a>
<a name="ln2216">    defineAtomConn();</a>
<a name="ln2217">    allAboutCycles();</a>
<a name="ln2218"> </a>
<a name="ln2219">    test=true;</a>
<a name="ln2220">    bk = (neighbourlist *)malloc(nAtoms() * sizeof(adjustedlist));</a>
<a name="ln2221">    defineBondConn(bk);</a>
<a name="ln2222">    //{Start clean for LISTATOMCLEAN and LISTBONDCLEAN atoms and bonds}</a>
<a name="ln2223">    baseCycle=0;</a>
<a name="ln2224">    cs=0;</a>
<a name="ln2225">    ux=0;</a>
<a name="ln2226">    uy=0;</a>
<a name="ln2227">    uvX=0;</a>
<a name="ln2228">    uvY=0;</a>
<a name="ln2229">    atomSecond=0;</a>
<a name="ln2230"> </a>
<a name="ln2231">    std::vector&lt;int&gt;bondList;</a>
<a name="ln2232">    std::vector&lt;vector&lt;int&gt; &gt; cycleDescription;</a>
<a name="ln2233">    for (i=0; i&lt;bondClean; i++) {</a>
<a name="ln2234">      vaweBond(listBondClean[i],bk,cs,bondList); //If I-th bond belongs to cycle}</a>
<a name="ln2235">      if (cs&gt;0) {</a>
<a name="ln2236">        canonizeCycle(cs,bondList);</a>
<a name="ln2237">        test=false;</a>
<a name="ln2238">        for (j=0; j&lt;baseCycle; j++) if(cycleDescription[j].size() == cs) {</a>
<a name="ln2239">            test=true;</a>
<a name="ln2240">            for (k=0; k&lt;cycleDescription[j].size(); k++) if (bondList[k] != cycleDescription[j][k]) {</a>
<a name="ln2241">                test=false;</a>
<a name="ln2242">                break;</a>
<a name="ln2243">              };</a>
<a name="ln2244">            if (test) break;</a>
<a name="ln2245">          };</a>
<a name="ln2246">        if (! test) {     //{not found-the cycle is added to cycle's list}</a>
<a name="ln2247">          baseCycle++;</a>
<a name="ln2248">          cycleDescription.push_back(bondList);</a>
<a name="ln2249">        };</a>
<a name="ln2250">      };</a>
<a name="ln2251">    };</a>
<a name="ln2252"> </a>
<a name="ln2253">    std::vector&lt;std::vector&lt;int&gt; &gt; atomCycle(cycleDescription.size());</a>
<a name="ln2254">    std::vector&lt;int&gt; cycleDefine(cycleDescription.size());</a>
<a name="ln2255"> </a>
<a name="ln2256">    for (i=0; i&lt;baseCycle; i++) { //making atom list in those order, as they will be defined at cycles}</a>
<a name="ln2257">      cycleDefine[i]=0;</a>
<a name="ln2258">      k=cycleDescription[i][0];</a>
<a name="ln2259">      j=cycleDescription[i][1];</a>
<a name="ln2260"> </a>
<a name="ln2261">      if ((getBond(k)-&gt;at[0]==getBond(j)-&gt;at[0]) || (getBond(k)-&gt;at[0]==getBond(j)-&gt;at[1])) atomCycle[i].push_back(getBond(k)-&gt;at[0]);</a>
<a name="ln2262">      else atomCycle[i].push_back(getBond(k)-&gt;at[1]);</a>
<a name="ln2263">      n=atomCycle[i][0]; //previoulsly putted atom</a>
<a name="ln2264">      for (j=1; j&lt;cycleDescription[i].size(); j++) {</a>
<a name="ln2265">        k=cycleDescription[i][j];</a>
<a name="ln2266">        if (getBond(k)-&gt;at[0]==n) atomCycle[i].push_back(getBond(k)-&gt;at[1]); else atomCycle[i].push_back(getBond(k)-&gt;at[0]);</a>
<a name="ln2267">        n=atomCycle[i][j];</a>
<a name="ln2268">      };</a>
<a name="ln2269">    };</a>
<a name="ln2270"> </a>
<a name="ln2271">    //calculation of the coordinates of fragment's center and scaling factor}</a>
<a name="ln2272"> </a>
<a name="ln2273">    if ((spn&lt;3) || (spn==4)) {</a>
<a name="ln2274">      xCenterOld=0;</a>
<a name="ln2275">      yCenterOld=0;</a>
<a name="ln2276">      bondLengthOld=0;</a>
<a name="ln2277">      if (spn == 4) {</a>
<a name="ln2278">        vector&lt;int&gt; tempAtomArray(nAtoms(), 0);</a>
<a name="ln2279">        for (i=0; i&lt;atomClean; i++) {</a>
<a name="ln2280">          k=listAtomClean[i];</a>
<a name="ln2281">          tempAtomArray[k]=1;</a>
<a name="ln2282">        };</a>
<a name="ln2283">        n=0;</a>
<a name="ln2284">        for (i=0; i&lt;nAtoms(); i++) if (tempAtomArray[i]==0) {</a>
<a name="ln2285">            xCenterOld=xCenterOld+getAtom(i)-&gt;rx;</a>
<a name="ln2286">            yCenterOld=yCenterOld+getAtom(i)-&gt;ry;</a>
<a name="ln2287">            n++;</a>
<a name="ln2288">          };</a>
<a name="ln2289">        xCenterOld=xCenterOld/(double)n; yCenterOld=yCenterOld/(double)n;</a>
<a name="ln2290">        vector&lt;int&gt; tempBondArray(nBonds(), 0);</a>
<a name="ln2291">        for (i=0; i&lt;bondClean; i++) {</a>
<a name="ln2292">          k=listBondClean[i];</a>
<a name="ln2293">          tempBondArray[k]=1;</a>
<a name="ln2294">        };</a>
<a name="ln2295">        n=0;</a>
<a name="ln2296">        bondLengthOld=1E10;</a>
<a name="ln2297">        r1=0;</a>
<a name="ln2298">        for (i=0; i&lt;nBonds(); i++) if (tempBondArray[i] == 0) {</a>
<a name="ln2299">            r=this-&gt;bondLength(i);</a>
<a name="ln2300">            if (r &lt; bondLengthOld) bondLengthOld=n;</a>
<a name="ln2301">            r1=r1+r;</a>
<a name="ln2302">            n++;</a>
<a name="ln2303">          };</a>
<a name="ln2304">        r1=r1/n;</a>
<a name="ln2305">        if (5*bondLengthOld &lt; r1) bondLengthOld=r1;</a>
<a name="ln2306">      } else {</a>
<a name="ln2307">        for (i=0; i&lt;atomClean; i++) {</a>
<a name="ln2308">          k=listAtomClean[i];</a>
<a name="ln2309">          xCenterOld=xCenterOld+getAtom(k)-&gt;rx;</a>
<a name="ln2310">          yCenterOld=yCenterOld+getAtom(k)-&gt;ry;</a>
<a name="ln2311">        };</a>
<a name="ln2312">        xCenterOld=xCenterOld/(double)atomClean; yCenterOld=yCenterOld/(double)atomClean;</a>
<a name="ln2313">        for (i=0; i&lt;bondClean; i++) {</a>
<a name="ln2314">          k=listBondClean[i];</a>
<a name="ln2315">          bondLengthOld=bondLengthOld+this-&gt;bondLength(k);</a>
<a name="ln2316">        };</a>
<a name="ln2317">        bondLengthOld=bondLengthOld/(double)bondClean;</a>
<a name="ln2318">      };</a>
<a name="ln2319">      if (bondLengthOld&lt;0.01) bondLengthOld=1;</a>
<a name="ln2320">    } else {</a>
<a name="ln2321"> </a>
<a name="ln2322">      xCenterOld=getAtom(sCHA1)-&gt;rx; //{CHA1 - To atom connected, CHB1-splitting bond}</a>
<a name="ln2323">      yCenterOld=getAtom(sCHA1)-&gt;ry;</a>
<a name="ln2324">      lx=getBond(sCHB1)-&gt;at[0];</a>
<a name="ln2325">      ly=getBond(sCHB1)-&gt;at[1];</a>
<a name="ln2326">      if (ly == sCHA1) {</a>
<a name="ln2327">        lx=getBond(sCHB1)-&gt;at[1];</a>
<a name="ln2328">        ly=getBond(sCHB1)-&gt;at[0];</a>
<a name="ln2329">      };</a>
<a name="ln2330">      atomSecond=ly;</a>
<a name="ln2331">      //for group it is necessary to calculate unit vector direction</a>
<a name="ln2332">      uvX=getAtom(ly)-&gt;rx-getAtom(lx)-&gt;rx;</a>
<a name="ln2333">      uvY=getAtom(ly)-&gt;ry-getAtom(lx)-&gt;ry;</a>
<a name="ln2334">      bondLengthOld=sqrt(uvX*uvX+uvY*uvY);</a>
<a name="ln2335">      if (bondLengthOld&lt;0.01) bondLengthOld=1;</a>
<a name="ln2336">      uvX=uvX/bondLengthOld;</a>
<a name="ln2337">      uvY=uvY/bondLengthOld;</a>
<a name="ln2338"> </a>
<a name="ln2339">    };</a>
<a name="ln2340"> </a>
<a name="ln2341">    std::vector&lt;int&gt; atomDefine(nAtoms(), 0); //flags-zero value OK</a>
<a name="ln2342">    if ((spn&lt;3) || (spn==4)) {     //checking already cleaned atoms...</a>
<a name="ln2343">      for (i=0; i&lt;nAtoms(); i++) atomDefine[i]=1;</a>
<a name="ln2344">      for (i=0; i&lt;atomClean; i++) {</a>
<a name="ln2345">        k=listAtomClean[i];</a>
<a name="ln2346">        atomDefine[k]=0;</a>
<a name="ln2347">      };</a>
<a name="ln2348">    };</a>
<a name="ln2349">    currNumDef=0;</a>
<a name="ln2350">    while (currNumDef&lt;atomClean) {</a>
<a name="ln2351">      //start recursion-priority list formation}</a>
<a name="ln2352">      defC(currNumDef,baseCycle,atomClean,cycleDefine,atomDefine,atomCycle,dsATN,dsTP,dsSC,dsNA1,dsNA2);</a>
<a name="ln2353">      defA(currNumDef,atomClean,spn,baseCycle,atomDefine,listAtomClean,cycleDefine,atomCycle,dsATN,dsTP,dsNA1,dsNA2);</a>
<a name="ln2354">    }; //end recursion}</a>
<a name="ln2355"> </a>
<a name="ln2356">    for (i=0; i&lt;nAtoms(); i++) atomDefine[i]=0;</a>
<a name="ln2357"> </a>
<a name="ln2358">    if ((spn&lt;3) || (spn==4)) {     //checking already cleaned atoms...</a>
<a name="ln2359">      for (i=0; i&lt;nAtoms(); i++) atomDefine[i]=1;</a>
<a name="ln2360">      for (i=0; i&lt;atomClean; i++) {</a>
<a name="ln2361">        k=listAtomClean[i];</a>
<a name="ln2362">        atomDefine[k]=0;</a>
<a name="ln2363">      };</a>
<a name="ln2364">      for (i=0; i&lt;nAtoms(); i++) if (atomDefine[i]==1) {</a>
<a name="ln2365">          getAtom(i)-&gt;rx=(xCenterOld+(getAtom(i)-&gt;rx-xCenterOld)/bondLengthOld);</a>
<a name="ln2366">          getAtom(i)-&gt;ry=(yCenterOld+(getAtom(i)-&gt;ry-yCenterOld)/bondLengthOld);</a>
<a name="ln2367">        };</a>
<a name="ln2368">    };</a>
<a name="ln2369"> </a>
<a name="ln2370">    i=0;</a>
<a name="ln2371"> </a>
<a name="ln2372">    if (atomClean&gt;=1) while (i&lt;atomClean) {</a>
<a name="ln2373"> </a>
<a name="ln2374">        switch (dsTP[i]) {</a>
<a name="ln2375">        case 0:{</a>
<a name="ln2376">          atomDefine[dsATN[i]]=1; //old coordinates of the atom are used}</a>
<a name="ln2377">          getAtom(dsATN[i])-&gt;rx=xCenterOld+(getAtom(dsATN[i])-&gt;rx-xCenterOld)/bondLengthOld;</a>
<a name="ln2378">          getAtom(dsATN[i])-&gt;ry=yCenterOld+(getAtom(dsATN[i])-&gt;ry-yCenterOld)/bondLengthOld;</a>
<a name="ln2379">          break;</a>
<a name="ln2380">        }</a>
<a name="ln2381">        case 1:</a>
<a name="ln2382">        case 2: if (atomDefine[dsATN[i]] == 0) {</a>
<a name="ln2383">            k1=dsNA1[i];</a>
<a name="ln2384">            k=getAtom(k1)-&gt;nb;</a>
<a name="ln2385">            nb=0;</a>
<a name="ln2386">            ux=0;</a>
<a name="ln2387">            uy=0;</a>
<a name="ln2388">            ux1=0;</a>
<a name="ln2389">            uy1=0;</a>
<a name="ln2390">            //bond direction calculation}</a>
<a name="ln2391">            for (j=0; j&lt;k; j++) if (atomDefine[getAtom(k1)-&gt;ac[j]]&gt;0) {</a>
<a name="ln2392">                k2=getAtom(k1)-&gt;ac[j];</a>
<a name="ln2393">                nb=nb+1;           //number of already cleaned atoms}</a>
<a name="ln2394">                ux=ux+(getAtom(k1)-&gt;rx-getAtom(k2)-&gt;rx);</a>
<a name="ln2395">                uy=uy+(getAtom(k1)-&gt;ry-getAtom(k2)-&gt;ry);</a>
<a name="ln2396">                if (dsTP[i]==1) for (l=0; l&lt;getAtom(k2)-&gt;nb; l++) if (atomDefine[getAtom(k2)-&gt;ac[l]]&gt;0) {</a>
<a name="ln2397">                      ux1=ux1+(getAtom(k2)-&gt;rx-getAtom(getAtom(k2)-&gt;ac[l])-&gt;rx);</a>
<a name="ln2398">                      uy1=uy1+(getAtom(k2)-&gt;ry-getAtom(getAtom(k2)-&gt;ac[l])-&gt;rx);</a>
<a name="ln2399">                    };</a>
<a name="ln2400">              };</a>
<a name="ln2401">            if (dsTP[i]==1) {     //chain fragment</a>
<a name="ln2402">              if ((abs(ux) &lt;= 0.00001) &amp;&amp; (abs(uy) &lt;= 0.00001)) {</a>
<a name="ln2403">                bnEx=-1;</a>
<a name="ln2404">                for (j=0; j&lt;bk[k1].nb; j++) {</a>
<a name="ln2405">                  n=bk[k1].adjusted[j];</a>
<a name="ln2406">                  n1=getBond(n)-&gt;at[0];</a>
<a name="ln2407">                  if (n1 == k1) n1=getBond(n)-&gt;at[1];</a>
<a name="ln2408">                  if (n1 == dsATN[i]) bnEx=n;</a>
<a name="ln2409">                  if (bnEx &gt;= 0) break;</a>
<a name="ln2410">                };</a>
<a name="ln2411">                test= (bnEx &gt;= 0);</a>
<a name="ln2412">                if (test) test=threeBondResolve(k1,bnEx,ux,uy,bk);</a>
<a name="ln2413">                if (! test) {</a>
<a name="ln2414">                  ux=ux1; uy=uy1;</a>
<a name="ln2415">                };</a>
<a name="ln2416">              };</a>
<a name="ln2417"> </a>
<a name="ln2418">              if ((ux==0) &amp;&amp; (uy==0)) ux=1;</a>
<a name="ln2419">              fi=(k-nb-1)*PI/(double)k;</a>
<a name="ln2420">              //Addition for fluorine chain fragments...</a>
<a name="ln2421">              isChainFour=false;</a>
<a name="ln2422">              n=0; mm1=-1; mm2=-1; mAny=-1;</a>
<a name="ln2423">              if ((k == 4) &amp;&amp; (getAtom(k1)-&gt;na == 6))  for (j=0; j&lt;getAtom(k1)-&gt;nb; j++) {</a>
<a name="ln2424">                  n1=getAtom(k1)-&gt;ac[j];</a>
<a name="ln2425">                  if (atomDefine[n1] == 0) {</a>
<a name="ln2426">                    mAny=n1;</a>
<a name="ln2427">                    if (getAtom(n1)-&gt;nb == 1) n++; else {</a>
<a name="ln2428">                      if (mm1 == -1) mm1=n1; else mm2=n1;</a>
<a name="ln2429">                    };</a>
<a name="ln2430">                  };</a>
<a name="ln2431">                };</a>
<a name="ln2432">              if ((mm1 == -1) &amp;&amp; (n == 3)) {</a>
<a name="ln2433">                mm1=mAny;</a>
<a name="ln2434">                n--;</a>
<a name="ln2435">              };</a>
<a name="ln2436">              isChainFour=(n == 2) &amp;&amp; (mm1 &gt;= 0);</a>
<a name="ln2437">              //End addition</a>
<a name="ln2438">              isCycle=false;</a>
<a name="ln2439">              if ((nb == 2) &amp;&amp; ((k == 4) || (k == 5))) {</a>
<a name="ln2440">                n=0;</a>
<a name="ln2441">                for (j=0; j&lt;bk[dsNA1[i]].nb; j++) {</a>
<a name="ln2442">                  k2=bk[dsNA1[i]].adjusted[j];</a>
<a name="ln2443">                  if (getBond(k2)-&gt;db &gt; 1) {</a>
<a name="ln2444">                    n1=getBond(k2)-&gt;at[0];</a>
<a name="ln2445">                    if (n1 == k1) n1=getBond(k2)-&gt;at[1];</a>
<a name="ln2446">                    if (atomDefine[n1] != 0) n++;</a>
<a name="ln2447">                  };</a>
<a name="ln2448">                };</a>
<a name="ln2449">                isCycle=(n == 2);</a>
<a name="ln2450">              };</a>
<a name="ln2451">              if (isChainFour) {</a>
<a name="ln2452">                n=0;</a>
<a name="ln2453">                fi=PI/3;</a>
<a name="ln2454">                ux1= ux*cos(fi)+uy*sin(fi);</a>
<a name="ln2455">                uy1=-ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2456">                cf=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2457">                if (cf != 0) {</a>
<a name="ln2458">                  ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2459">                };</a>
<a name="ln2460">                getAtom(mm1)-&gt;rx=getAtom(k1)-&gt;rx+ux1; //coordinates</a>
<a name="ln2461">                getAtom(mm1)-&gt;ry=getAtom(k1)-&gt;ry+uy1;</a>
<a name="ln2462">                atomDefine[mm1]=1;</a>
<a name="ln2463">                if (mm2 &gt;= 0) {</a>
<a name="ln2464">                  fi=-PI/3;</a>
<a name="ln2465">                  ux1= ux*cos(fi)+uy*sin(fi);</a>
<a name="ln2466">                  uy1=-ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2467">                  cf=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2468">                  if (cf != 0) {</a>
<a name="ln2469">                    ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2470">                  };</a>
<a name="ln2471">                  getAtom(mm2)-&gt;rx=getAtom(k1)-&gt;rx+ux1; //coordinates</a>
<a name="ln2472">                  getAtom(mm2)-&gt;ry=getAtom(k1)-&gt;ry+uy1; //coordinates</a>
<a name="ln2473">                  atomDefine[mm2]=1;</a>
<a name="ln2474">                };</a>
<a name="ln2475">                ux=0; uy=0;  //New cosines....</a>
<a name="ln2476">                for (j=0; j&lt;getAtom(k1)-&gt;nb; j++) if (atomDefine[getAtom(k1)-&gt;ac[j]] &gt; 0) {</a>
<a name="ln2477">                    k2=getAtom(k1)-&gt;ac[j];</a>
<a name="ln2478">                    ux=ux+(getAtom(k1)-&gt;rx-getAtom(k2)-&gt;rx);</a>
<a name="ln2479">                    uy=uy+(getAtom(k1)-&gt;ry-getAtom(k2)-&gt;ry);</a>
<a name="ln2480">                  };</a>
<a name="ln2481">                fi=PI/6;</a>
<a name="ln2482">                for (j=0; j&lt;getAtom(k1)-&gt;nb; j++) {</a>
<a name="ln2483">                  n1=getAtom(k1)-&gt;ac[j];</a>
<a name="ln2484">                  if (atomDefine[n1] == 0) {</a>
<a name="ln2485">                    ux1= ux*cos(fi)+uy*sin(fi);</a>
<a name="ln2486">                    uy1=-ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2487">                    cf=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2488">                    if (cf != 0) {</a>
<a name="ln2489">                      ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2490">                    };</a>
<a name="ln2491">                    getAtom(n1)-&gt;rx=getAtom(k1)-&gt;rx+ux1; //coordinates}</a>
<a name="ln2492">                    getAtom(n1)-&gt;ry=getAtom(k1)-&gt;ry+uy1; //coordinates}</a>
<a name="ln2493">                    fi=-fi;</a>
<a name="ln2494">                    atomDefine[n1]=1;</a>
<a name="ln2495">                  };</a>
<a name="ln2496">                };</a>
<a name="ln2497">              } else if (isCycle) {</a>
<a name="ln2498">                if (k == 4) fi=PI/6; else fi=PI/3;</a>
<a name="ln2499">                ux1= ux*cos(fi)+uy*sin(fi);</a>
<a name="ln2500">                uy1=-ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2501">                cf=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2502">                if (cf != 0) {</a>
<a name="ln2503">                  ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2504">                };</a>
<a name="ln2505">                getAtom(dsATN[i])-&gt;rx=getAtom(k1)-&gt;rx+ux1; //coordinates</a>
<a name="ln2506">                getAtom(dsATN[i])-&gt;ry=getAtom(k1)-&gt;ry+uy1; //coordinates</a>
<a name="ln2507">                atomDefine[dsATN[i]]=1;</a>
<a name="ln2508">                for (j=0; j&lt;getAtom(dsNA1[i])-&gt;nb; j++) {</a>
<a name="ln2509">                  k2=getAtom(dsNA1[i])-&gt;ac[j];</a>
<a name="ln2510">                  if (atomDefine[k2] == 0) {</a>
<a name="ln2511">                    ux1=ux*cos(fi)-uy*sin(fi);</a>
<a name="ln2512">                    uy1=ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2513">                    if (cf != 0) {</a>
<a name="ln2514">                      ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2515">                    };</a>
<a name="ln2516">                    getAtom(k2)-&gt;rx=getAtom(k1)-&gt;rx+ux1;</a>
<a name="ln2517">                    getAtom(k2)-&gt;ry=getAtom(k1)-&gt;ry+uy1;</a>
<a name="ln2518">                    fi=0;</a>
<a name="ln2519">                    atomDefine[k2]=1;</a>
<a name="ln2520">                  };</a>
<a name="ln2521">                };</a>
<a name="ln2522">              } else {</a>
<a name="ln2523"> </a>
<a name="ln2524">                if (bk[dsNA1[i]].nb == 2) {  //two-connected fragment</a>
<a name="ln2525">                  //Search for triple bond or for two double-bonds</a>
<a name="ln2526">                  n1=bk[dsNA1[i]].adjusted[0];</a>
<a name="ln2527">                  n2=bk[dsNA1[i]].adjusted[1];</a>
<a name="ln2528">                  if ((getBond(n1)-&gt;tb == 3) || (getBond(n2)-&gt;tb == 3)) k=3; else</a>
<a name="ln2529">                    if ((getBond(n1)-&gt;tb == 2) &amp;&amp; (getBond(n2)-&gt;tb == 2)) {</a>
<a name="ln2530">                      if (getAtom(dsNA1[i])-&gt;na == 6) k=3;</a>
<a name="ln2531">                    };</a>
<a name="ln2532">                };</a>
<a name="ln2533">                //Two-conncted fragment like pyrophosphate</a>
<a name="ln2534">                if ((k== 2) &amp;&amp; (getAtom(dsNA1[i])-&gt;na != 6)) {</a>
<a name="ln2535">                  n1=getAtom(dsNA1[i])-&gt;ac[0];</a>
<a name="ln2536">                  n2=getAtom(dsNA1[i])-&gt;ac[1];</a>
<a name="ln2537">                  if ((getAtom(n1)-&gt;nb &gt;= 4) &amp;&amp; (getAtom(n2)-&gt;nb &gt;= 4) &amp;&amp; (getAtom(n1)-&gt;na != 6) &amp;&amp; (getAtom(n2)-&gt;na != 6)) k=3;</a>
<a name="ln2538">                };</a>
<a name="ln2539">                //End pyrophosphate</a>
<a name="ln2540">                if (k==2) { //120 degrees fragment}</a>
<a name="ln2541">                  if ((ux1==0) &amp;&amp; (uy1==0)) ux1=1;</a>
<a name="ln2542">                  fi=PI/3;</a>
<a name="ln2543">                  cf=uy*ux1-ux*uy1;</a>
<a name="ln2544">                  if (cf != 0) fi=fi*cf/abs(cf);</a>
<a name="ln2545">                };</a>
<a name="ln2546">                ux1=ux*cos(fi)+uy*sin(fi);</a>
<a name="ln2547">                uy1=-ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2548">                cf=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2549">                if (cf != 0) {</a>
<a name="ln2550">                  ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2551">                };</a>
<a name="ln2552">                getAtom(dsATN[i])-&gt;rx=getAtom(k1)-&gt;rx+ux1; //coordinates</a>
<a name="ln2553">                getAtom(dsATN[i])-&gt;ry=getAtom(k1)-&gt;ry+uy1; //coordinates</a>
<a name="ln2554">                atomDefine[dsATN[i]]=1;</a>
<a name="ln2555">              };</a>
<a name="ln2556">            } else {                   //cyclic fragment}</a>
<a name="ln2557"> </a>
<a name="ln2558">              if ((ux==0) &amp;&amp; (uy==0)) ux=1;</a>
<a name="ln2559">              fi=(k-nb-2)*PI/(double)k;</a>
<a name="ln2560">              ux1=ux*cos(fi)+uy*sin(fi);</a>
<a name="ln2561">              uy1=-ux*sin(fi)+uy*cos(fi);</a>
<a name="ln2562">              cf=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2563">              if (cf != 0) {</a>
<a name="ln2564">                ux1=ux1/cf; uy1=uy1/cf;</a>
<a name="ln2565">              };</a>
<a name="ln2566">              nb=dsSC[i];</a>
<a name="ln2567">              cs=nb+1;</a>
<a name="ln2568">              cf=1/(2*sin(PI/(double)cs));</a>
<a name="ln2569">              ux=getAtom(dsNA1[i])-&gt;rx+cf*ux1;</a>
<a name="ln2570">              uy=getAtom(dsNA1[i])-&gt;ry+cf*uy1;</a>
<a name="ln2571">              fi=2*PI/(double)cs;</a>
<a name="ln2572">              ux1=getAtom(dsNA1[i])-&gt;rx-ux;</a>
<a name="ln2573">              uy1=getAtom(dsNA1[i])-&gt;ry-uy;</a>
<a name="ln2574">              //coordinates of all atoms for the cycle under study are calculated}</a>
<a name="ln2575">              if ((nb + i) &gt; dsATN.size()) nb=dsATN.size()-i; // Check added to avoid segfault below, see issue #1851</a>
<a name="ln2576">              for (j=0; j&lt;nb; j++) {</a>
<a name="ln2577">                getAtom(dsATN[i+j-0])-&gt;rx=ux+ux1*cos((j+1)*fi)+uy1*sin((j+1)*fi);</a>
<a name="ln2578">                getAtom(dsATN[i+j-0])-&gt;ry=uy-ux1*sin((j+1)*fi)+uy1*cos((j+1)*fi);</a>
<a name="ln2579">                atomDefine[dsATN[i+j-0]]=1;</a>
<a name="ln2580">              };</a>
<a name="ln2581"> </a>
<a name="ln2582">              i=i+nb-1;</a>
<a name="ln2583">            };</a>
<a name="ln2584">            break;</a>
<a name="ln2585">          } else break;</a>
<a name="ln2586">        case 3:</a>
<a name="ln2587">        case 4: {</a>
<a name="ln2588"> </a>
<a name="ln2589">          twoAtomUnitVector(dsNA1[i],dsNA2[i],ux,uy,atomDefine);</a>
<a name="ln2590">          //calculation of an optimal side to add new fragment</a>
<a name="ln2591">          ux1=getAtom(dsNA1[i])-&gt;rx-getAtom(dsNA2[i])-&gt;rx;</a>
<a name="ln2592">          uy1=getAtom(dsNA1[i])-&gt;ry-getAtom(dsNA2[i])-&gt;ry;</a>
<a name="ln2593">          if (dsTP[i]==3)   {  //angle calc. for condenced cycle}</a>
<a name="ln2594">            nb=dsSC[i];</a>
<a name="ln2595">            cs=nb+2;</a>
<a name="ln2596">            fi=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2597">            cf=fi/(2*sin(PI/(double)cs)/cos(PI/(double)cs));</a>
<a name="ln2598">            add=0;</a>
<a name="ln2599">          } else {     //angle calc. for polycycle</a>
<a name="ln2600">            r=sqrt(ux1*ux1+uy1*uy1);</a>
<a name="ln2601">            add=(int)ceil(r);</a>
<a name="ln2602">            nb=dsSC[i];</a>
<a name="ln2603">            cs=nb+2+add;</a>
<a name="ln2604">            cf=r/(2*sin(PI*(nb+1)/(double)cs));</a>
<a name="ln2605">            r=r/2.0;</a>
<a name="ln2606">            cf=sqrt(cf*cf-r*r);</a>
<a name="ln2607">          };</a>
<a name="ln2608">          ux=(getAtom(dsNA1[i])-&gt;rx+getAtom(dsNA2[i])-&gt;rx)/2.0+ux*cf;</a>
<a name="ln2609">          uy=(getAtom(dsNA1[i])-&gt;ry+getAtom(dsNA2[i])-&gt;ry)/2.0+uy*cf;</a>
<a name="ln2610">          ux1=getAtom(dsNA1[i])-&gt;rx-ux;</a>
<a name="ln2611">          uy1=getAtom(dsNA1[i])-&gt;ry-uy;</a>
<a name="ln2612">          fi=2*PI/(double)cs;</a>
<a name="ln2613">          ux2=ux+ux1*cos((1.0+add)*fi)+uy1*sin((1.0+add)*fi);</a>
<a name="ln2614">          uy2=uy-ux1*sin((1.0+add)*fi)+uy1*cos((1.0+add)*fi);</a>
<a name="ln2615">          if ((abs(getAtom(dsNA2[i])-&gt;rx-ux2)&lt;0.01) &amp;&amp; (abs(getAtom(dsNA2[i])-&gt;ry-uy2)&lt;0.01)) fi=-fi;</a>
<a name="ln2616">          //FAtom's coordinates calculation</a>
<a name="ln2617">          for (j=0; j&lt;nb; j++) {</a>
<a name="ln2618">            getAtom(dsATN[i+j-0])-&gt;rx=ux+ux1*cos((j+1)*fi)+uy1*sin((j+1)*fi);</a>
<a name="ln2619">            getAtom(dsATN[i+j-0])-&gt;ry=uy-ux1*sin((j+1)*fi)+uy1*cos((j+1)*fi);</a>
<a name="ln2620">            atomDefine[dsATN[i+j-0]]=1;</a>
<a name="ln2621">          }</a>
<a name="ln2622">          i=i+nb-1;</a>
<a name="ln2623">          break;</a>
<a name="ln2624">        }</a>
<a name="ln2625">        }</a>
<a name="ln2626">        i++;</a>
<a name="ln2627">      }</a>
<a name="ln2628">    bondLengthNew=0;</a>
<a name="ln2629"> </a>
<a name="ln2630">    //Rescaling and shift of structure</a>
<a name="ln2631">    for (i=0; i&lt;bondClean; i++)  bondLengthNew=bondLengthNew+bondLength(listBondClean[i]);</a>
<a name="ln2632">    bondLengthNew=bondLengthNew/(double)bondClean;</a>
<a name="ln2633">    xCenterNew=0; yCenterNew=0;</a>
<a name="ln2634">    for (i=0; i&lt;atomClean; i++) {</a>
<a name="ln2635">      xCenterNew=xCenterNew+getAtom(listAtomClean[i])-&gt;rx;</a>
<a name="ln2636">      yCenterNew=yCenterNew+getAtom(listAtomClean[i])-&gt;ry;</a>
<a name="ln2637">    };</a>
<a name="ln2638">    xCenterNew=xCenterNew/(double)atomClean; yCenterNew=yCenterNew/(double)atomClean;</a>
<a name="ln2639">    bondLengthNew=0.15*bondLengthOld;</a>
<a name="ln2640">    //IOPT[7]-controlles, whether or not the atom's shifts should be created, if coordinates of pair of atoms are identical</a>
<a name="ln2641">    if (spn==3) {                     //Rescaling and shift coordinates for group (CODE=3)</a>
<a name="ln2642">      xCenterNew=getAtom(sCHA1)-&gt;rx;</a>
<a name="ln2643">      yCenterNew=getAtom(sCHA1)-&gt;ry;</a>
<a name="ln2644">      ux=getAtom(atomSecond)-&gt;rx-getAtom(sCHA1)-&gt;rx;</a>
<a name="ln2645">      uy=getAtom(atomSecond)-&gt;ry-getAtom(sCHA1)-&gt;ry;</a>
<a name="ln2646">      r=sqrt(ux*ux+uy*uy);</a>
<a name="ln2647">      ux=ux/r; uy=uy/r;</a>
<a name="ln2648">      c=ux*uvX+uy*uvY;</a>
<a name="ln2649">      s=ux*uvY-uy*uvX;</a>
<a name="ln2650">      for (i=0; i&lt;atomClean; i++) {</a>
<a name="ln2651">        ux1=getAtom(listAtomClean[i])-&gt;rx-xCenterNew;</a>
<a name="ln2652">        uy1=getAtom(listAtomClean[i])-&gt;ry-yCenterNew;</a>
<a name="ln2653">        getAtom(listAtomClean[i])-&gt;rx=c*ux1-s*uy1;</a>
<a name="ln2654">        getAtom(listAtomClean[i])-&gt;ry=s*ux1+c*uy1;</a>
<a name="ln2655">      };</a>
<a name="ln2656">      xCenterNew=0;</a>
<a name="ln2657">      yCenterNew=0;</a>
<a name="ln2658"> </a>
<a name="ln2659">    };</a>
<a name="ln2660">    if (spn != 4) for (i=0; i&lt;atomClean; i++) {   //New screen coordinates</a>
<a name="ln2661">        getAtom(listAtomClean[i])-&gt;rx=getAtom(listAtomClean[i])-&gt;rx-xCenterNew+xCenterOld;</a>
<a name="ln2662">        getAtom(listAtomClean[i])-&gt;ry=getAtom(listAtomClean[i])-&gt;ry-yCenterNew+yCenterOld;</a>
<a name="ln2663">      };</a>
<a name="ln2664">    // Tidy up</a>
<a name="ln2665">    free(bk);</a>
<a name="ln2666">  };</a>
<a name="ln2667"> </a>
<a name="ln2668"> </a>
<a name="ln2669">  void TSimpleMolecule::getMolfile(std::ostream &amp; data) {</a>
<a name="ln2670">    char buff[BUFF_SIZE];</a>
<a name="ln2671">    TSingleAtom * sa;</a>
<a name="ln2672">    TSingleBond * sb;</a>
<a name="ln2673">    int charge,bondType,stereoType;</a>
<a name="ln2674"> </a>
<a name="ln2675">    data&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;  //three empty lines</a>
<a name="ln2676">    snprintf(buff,BUFF_SIZE,&quot;%3d%3d%3d%3d%3d%3d%3d%3d%3d%3d%3d V2000&quot;,nAtoms(),nBonds(),0,0,0,0,0,0,0,0,999);</a>
<a name="ln2677">    data &lt;&lt; buff &lt;&lt; endl;</a>
<a name="ln2678">    for (int i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln2679">      sa=getAtom(i);</a>
<a name="ln2680">      switch (sa-&gt;nc) {</a>
<a name="ln2681">      case 1: charge = 3; break;</a>
<a name="ln2682">      case 2: charge = 2; break;</a>
<a name="ln2683">      case 3: charge = 1; break;</a>
<a name="ln2684">      case -1: charge = 5; break;</a>
<a name="ln2685">      case -2: charge = 6; break;</a>
<a name="ln2686">      case -3: charge = 7; break;</a>
<a name="ln2687">      default: charge=0; break;</a>
<a name="ln2688">      }</a>
<a name="ln2689">      snprintf(buff, BUFF_SIZE, &quot;%10.4f%10.4f%10.4f %-3s%2d%3d%3d%3d%3d&quot;,</a>
<a name="ln2690">               sa-&gt;rx, sa-&gt;ry, 0.0, (aSymb[sa-&gt;na]).c_str(), 0,charge,0,0,0);</a>
<a name="ln2691">      data &lt;&lt; buff &lt;&lt; endl;</a>
<a name="ln2692">    };</a>
<a name="ln2693">    for (int i=0; i&lt;nBonds(); i++) {</a>
<a name="ln2694">      sb=getBond(i);</a>
<a name="ln2695">      bondType=sb-&gt;tb;</a>
<a name="ln2696">      stereoType=0;</a>
<a name="ln2697">      if (bondType == 9) {</a>
<a name="ln2698">        bondType=1;</a>
<a name="ln2699">        stereoType=1;</a>
<a name="ln2700">      } else if (bondType == 10) {</a>
<a name="ln2701">        bondType=1;</a>
<a name="ln2702">        stereoType=6;</a>
<a name="ln2703">      } else if (bondType == 11) {</a>
<a name="ln2704">        bondType=1;</a>
<a name="ln2705">        stereoType=4;</a>
<a name="ln2706">      };</a>
<a name="ln2707">      snprintf(buff, BUFF_SIZE, &quot;%3d%3d%3d%3d%3d%3d&quot;,(sb-&gt;at[0]+1), (sb-&gt;at[1]+1), bondType, stereoType, 0, 0);</a>
<a name="ln2708">      data &lt;&lt; buff &lt;&lt; endl;</a>
<a name="ln2709">    };</a>
<a name="ln2710">  };</a>
<a name="ln2711"> </a>
<a name="ln2712">  //*******************************************************************************</a>
<a name="ln2713">  //Below routines from ChainRotate-flipping acyclic bonds and enlarging bonds to get fine picture</a>
<a name="ln2714">  //*******************************************************************************</a>
<a name="ln2715"> </a>
<a name="ln2716">  double TSimpleMolecule::atomDistanceMetric(int an) {</a>
<a name="ln2717">    int i, n;</a>
<a name="ln2718">    double r, rr;</a>
<a name="ln2719">    double x1, y1, x2, y2, d, result;</a>
<a name="ln2720"> </a>
<a name="ln2721">    if (getAtom(an)-&gt;nb == 0) return 0;</a>
<a name="ln2722">    result=0.01;</a>
<a name="ln2723">    n=getAtom(an)-&gt;ac[0];</a>
<a name="ln2724">    x1=getAtom(an)-&gt;rx-getAtom(n)-&gt;rx;</a>
<a name="ln2725">    y1=getAtom(an)-&gt;ry-getAtom(n)-&gt;ry;</a>
<a name="ln2726">    rr=sqrt(x1*x1+y1*y1);</a>
<a name="ln2727">    for (i=0; i&lt;nAtoms(); i++) if ((i != an) &amp;&amp; (i != n)) {</a>
<a name="ln2728">        x2=getAtom(i)-&gt;rx-getAtom(n)-&gt;rx;</a>
<a name="ln2729">        y2=getAtom(i)-&gt;ry-getAtom(n)-&gt;ry;</a>
<a name="ln2730">        d=rr*sqrt(x2*x2+y2*y2);</a>
<a name="ln2731">        if (d == 0) r=0; else r=(x1*x2+y1*y2)/d;</a>
<a name="ln2732">        if (r &gt; 0) result=result+r;</a>
<a name="ln2733">      };</a>
<a name="ln2734">    return result;</a>
<a name="ln2735">  };</a>
<a name="ln2736"> </a>
<a name="ln2737"> </a>
<a name="ln2738">  double xDistPoint(double x1, double y1, double x2, double y2, double x0, double y0) {</a>
<a name="ln2739">    //The function finds distance between FAtom AN and bond BN (including sign).</a>
<a name="ln2740">    // The bond is treated as segment, not as straight line!}</a>
<a name="ln2741">    double d, r, r1, yMin, yMax, xMin, xMax, xx, yy, result;</a>
<a name="ln2742"> </a>
<a name="ln2743">    if (y1 &lt; y2) {</a>
<a name="ln2744">      yMin=y1;</a>
<a name="ln2745">      yMax=y2;</a>
<a name="ln2746">    } else {</a>
<a name="ln2747">      yMin=y2;</a>
<a name="ln2748">      yMax=y1;</a>
<a name="ln2749">    };</a>
<a name="ln2750">    xx=x1-x2;</a>
<a name="ln2751">    yy=y1-y2;</a>
<a name="ln2752">    r1=sqrt(xx*xx+yy*yy);</a>
<a name="ln2753">    yMin=yMin-0.1*r1; yMax=yMax+0.1*r1;</a>
<a name="ln2754">    d=y2-y1;</a>
<a name="ln2755">    if (abs(d) &lt; 1E-8) {</a>
<a name="ln2756">      result=1E9;</a>
<a name="ln2757">      return result;</a>
<a name="ln2758">    };</a>
<a name="ln2759">    if ((y0 &gt; yMin) &amp;&amp; (y0 &lt; yMax)) {</a>
<a name="ln2760">      r=x1+(y0-y1)*(x2-x1)/d;</a>
<a name="ln2761">      if (x1 &gt; x2) {</a>
<a name="ln2762">        xMin=x2;</a>
<a name="ln2763">        xMax=x1;</a>
<a name="ln2764">      } else {</a>
<a name="ln2765">        xMin=x1;</a>
<a name="ln2766">        xMax=x2;</a>
<a name="ln2767">      };</a>
<a name="ln2768">      xMin=xMin-0.1*r1;</a>
<a name="ln2769">      xMax=xMax+0.1*r1;</a>
<a name="ln2770">      if (r &lt; xMin) r=xMin;</a>
<a name="ln2771">      if (r &gt; xMax) r=xMax;</a>
<a name="ln2772">      result=r-x0;</a>
<a name="ln2773">    } else result=1E9;</a>
<a name="ln2774">    return result;</a>
<a name="ln2775">  };</a>
<a name="ln2776"> </a>
<a name="ln2777">  bool overlapped(double x1A, double y1A, double x2A, double y2A,</a>
<a name="ln2778">                  double x1B, double y1B, double x2B, double y2B, double delta) {</a>
<a name="ln2779"> </a>
<a name="ln2780">    double a1, b1, c1, a2, b2, c2, r, cX, cY, x, y, r1, r2;</a>
<a name="ln2781">    double xMin, xMax, yMin, yMax;</a>
<a name="ln2782">    bool result=false;</a>
<a name="ln2783"> </a>
<a name="ln2784">    r=y2A-y1A;</a>
<a name="ln2785">    if (abs(r) &gt; 1E-9) {</a>
<a name="ln2786">      a1=1/r;</a>
<a name="ln2787">      cY=-y1A/r;</a>
<a name="ln2788">    } else {</a>
<a name="ln2789">      a1=1E9;</a>
<a name="ln2790">      cY=-y1A*1E9;</a>
<a name="ln2791">      if (r &lt; 0) {</a>
<a name="ln2792">        a1=-a1;</a>
<a name="ln2793">        cY=-cY;</a>
<a name="ln2794">      };</a>
<a name="ln2795">    };</a>
<a name="ln2796">    r=x2A-x1A;</a>
<a name="ln2797">    if (abs(r) &gt; 1E-9) {</a>
<a name="ln2798">      b1=1/r;</a>
<a name="ln2799">      cX=x1A/r;</a>
<a name="ln2800">    } else {</a>
<a name="ln2801">      b1=1E9;</a>
<a name="ln2802">      cX=x1A*1E9;</a>
<a name="ln2803">      if (r &lt; 0) {</a>
<a name="ln2804">        b1=-b1;</a>
<a name="ln2805">        cX=-cX;</a>
<a name="ln2806">      };</a>
<a name="ln2807">    };</a>
<a name="ln2808">    b1=-b1;</a>
<a name="ln2809">    c1=cX+cY;</a>
<a name="ln2810">    r=y2B-y1B;</a>
<a name="ln2811">    if (abs(r) &gt; 1E-9) {</a>
<a name="ln2812">      a2=1/r;</a>
<a name="ln2813">      cY=-y1B/r;</a>
<a name="ln2814">    } else {</a>
<a name="ln2815">      a2=1E9;</a>
<a name="ln2816">      cY=-y1B*1E9;</a>
<a name="ln2817">      if (r &lt; 0) {</a>
<a name="ln2818">        a2=-a2;</a>
<a name="ln2819">        cY=-cY;</a>
<a name="ln2820">      };</a>
<a name="ln2821">    };</a>
<a name="ln2822">    r=x2B-x1B;</a>
<a name="ln2823">    if (abs(r) &gt; 1E-9) {</a>
<a name="ln2824">      b2=1/r;</a>
<a name="ln2825">      cX=x1B/r;</a>
<a name="ln2826">    } else {</a>
<a name="ln2827">      b2=1E9;</a>
<a name="ln2828">      cX=x1B*1E9;</a>
<a name="ln2829">      if (r &lt; 0) {</a>
<a name="ln2830">        b2=-b2;</a>
<a name="ln2831">        cX=-cX;</a>
<a name="ln2832">      };</a>
<a name="ln2833">    };</a>
<a name="ln2834">    b2=-b2;</a>
<a name="ln2835">    c2=cX+cY;</a>
<a name="ln2836">    r1=b1*c2-b2*c1;</a>
<a name="ln2837">    r2=a1*b2-a2*b1;</a>
<a name="ln2838">    if (abs(r2) &gt; 1E-9) y=r1/r2; else {</a>
<a name="ln2839">      y=1E9;</a>
<a name="ln2840">      if (r1 &lt; 0) y=-y;</a>
<a name="ln2841">    };</a>
<a name="ln2842">    r1=c1*a2-c2*a1;</a>
<a name="ln2843">    r2=a1*b2-a2*b1;</a>
<a name="ln2844">    if (abs(r2) &gt; 1E-9) x=r1/r2; else {</a>
<a name="ln2845">      x=1E9;</a>
<a name="ln2846">      if (r1 &lt; 0) x=-x;</a>
<a name="ln2847">    };</a>
<a name="ln2848">    if (x1A &lt; x2A) {</a>
<a name="ln2849">      xMin=x1A;</a>
<a name="ln2850">      xMax=x2A;</a>
<a name="ln2851">    } else {</a>
<a name="ln2852">      xMin=x2A;</a>
<a name="ln2853">      xMax=x1A;</a>
<a name="ln2854">    };</a>
<a name="ln2855">    if (y1A &lt; y2A) {</a>
<a name="ln2856">      yMin=y1A;</a>
<a name="ln2857">      yMax=y2A;</a>
<a name="ln2858">    } else {</a>
<a name="ln2859">      yMin=y2A;</a>
<a name="ln2860">      yMax=y1A;</a>
<a name="ln2861">    };</a>
<a name="ln2862">    xMin=xMin-delta;</a>
<a name="ln2863">    xMax=xMax+delta;</a>
<a name="ln2864">    yMin=yMin-delta;</a>
<a name="ln2865">    yMax=yMax+delta;</a>
<a name="ln2866">    result=((x &gt;= xMin) &amp;&amp; (x &lt;= xMax) &amp;&amp; (y &gt;= yMin) &amp;&amp; (y &lt;= yMax));</a>
<a name="ln2867">    if (result) {</a>
<a name="ln2868">      if (x1B &lt; x2B) {</a>
<a name="ln2869">        xMin=x1B;</a>
<a name="ln2870">        xMax=x2B;</a>
<a name="ln2871">      } else {</a>
<a name="ln2872">        xMin=x2B;</a>
<a name="ln2873">        xMax=x1B;</a>
<a name="ln2874">      };</a>
<a name="ln2875">      if (y1B &lt; y2B) {</a>
<a name="ln2876">        yMin=y1B;</a>
<a name="ln2877">        yMax=y2B;</a>
<a name="ln2878">      } else {</a>
<a name="ln2879">        yMin=y2B;</a>
<a name="ln2880">        yMax=y1B;</a>
<a name="ln2881">      };</a>
<a name="ln2882">      xMin=xMin-delta;</a>
<a name="ln2883">      xMax=xMax+delta;</a>
<a name="ln2884">      yMin=yMin-delta;</a>
<a name="ln2885">      yMax=yMax+delta;</a>
<a name="ln2886">      result=((x &gt;= xMin) &amp;&amp; (x &lt;= xMax) &amp;&amp; (y &gt;= yMin) &amp;&amp; (y &lt;= yMax));</a>
<a name="ln2887">    };</a>
<a name="ln2888">    if (! result) result=(abs(xDistPoint(x1A,y1A,x2A,y2A,x1B,y1B)) &lt; delta);</a>
<a name="ln2889">    if (! result) result=(abs(xDistPoint(x1A,y1A,x2A,y2A,x2B,y2B)) &lt; delta);</a>
<a name="ln2890">    if (! result) result=(abs(xDistPoint(x1B,y1B,x2B,y2B,x1A,y1A)) &lt; delta);</a>
<a name="ln2891">    if (! result) result=(abs(xDistPoint(x1B,y1B,x2B,y2B,x2A,y2A)) &lt; delta);</a>
<a name="ln2892">    return result;</a>
<a name="ln2893">  };</a>
<a name="ln2894"> </a>
<a name="ln2895"> </a>
<a name="ln2896">  bool TSimpleMolecule::bondsOverlapped(int bN1, int bN2, double delta) {</a>
<a name="ln2897">    double x1A,y1A,x2A,y2A,x1B,y1B,x2B,y2B;</a>
<a name="ln2898">    bool result;</a>
<a name="ln2899"> </a>
<a name="ln2900">    x1A=getAtom(getBond(bN1)-&gt;at[0])-&gt;rx;</a>
<a name="ln2901">    y1A=getAtom(getBond(bN1)-&gt;at[0])-&gt;ry;</a>
<a name="ln2902">    x2A=getAtom(getBond(bN1)-&gt;at[1])-&gt;rx;</a>
<a name="ln2903">    y2A=getAtom(getBond(bN1)-&gt;at[1])-&gt;ry;</a>
<a name="ln2904"> </a>
<a name="ln2905">    x1B=getAtom(getBond(bN2)-&gt;at[0])-&gt;rx;</a>
<a name="ln2906">    y1B=getAtom(getBond(bN2)-&gt;at[0])-&gt;ry;</a>
<a name="ln2907">    x2B=getAtom(getBond(bN2)-&gt;at[1])-&gt;rx;</a>
<a name="ln2908">    y2B=getAtom(getBond(bN2)-&gt;at[1])-&gt;ry;</a>
<a name="ln2909"> </a>
<a name="ln2910">    result=false;</a>
<a name="ln2911">    if (((x1A&gt;(x1B+delta)) &amp;&amp; (x2A&gt;(x1B+delta)) &amp;&amp; (x1A&gt;(x2B+delta)) &amp;&amp; (x2A&gt;(x2B+delta))) ||</a>
<a name="ln2912">        ((x1A&lt;(x1B-delta)) &amp;&amp; (x2A&lt;(x1B-delta)) &amp;&amp; (x1A&lt;(x2B-delta)) &amp;&amp; (x2A&lt;(x2B-delta))) ||</a>
<a name="ln2913">        ((y1A&gt;(y1B+delta)) &amp;&amp; (y2A&gt;(y1B+delta)) &amp;&amp; (y1A&gt;(y2B+delta)) &amp;&amp; (y2A&gt;(y2B+delta))) ||</a>
<a name="ln2914">        ((y1A&lt;(y1B-delta)) &amp;&amp; (y2A&lt;(y1B-delta)) &amp;&amp; (y1A&lt;(y2B-delta)) &amp;&amp; (y2A&lt;(y2B-delta)))) return result;</a>
<a name="ln2915">    result=overlapped(x1A,y1A,x2A,y2A,x1B,y1B,x2B,y2B,delta);</a>
<a name="ln2916">    return result;</a>
<a name="ln2917">  };</a>
<a name="ln2918"> </a>
<a name="ln2919"> </a>
<a name="ln2920">  int TSimpleMolecule::hasOverlapped(double delta, bool findFirst) {</a>
<a name="ln2921">    int i, j;</a>
<a name="ln2922">    bool test;</a>
<a name="ln2923">    double r,xx,yy;</a>
<a name="ln2924">    int result=0;</a>
<a name="ln2925"> </a>
<a name="ln2926">    for (i=1; i&lt;(nBonds()-1); i++) for (j=i+1; j&lt;nBonds(); j++) {</a>
<a name="ln2927">        test=(getBond(i)-&gt;at[0] == getBond(j)-&gt;at[0]) || (getBond(i)-&gt;at[0] == getBond(j)-&gt;at[1]) ||</a>
<a name="ln2928">          (getBond(i)-&gt;at[1] == getBond(j)-&gt;at[0]) || (getBond(i)-&gt;at[1] == getBond(j)-&gt;at[1]);</a>
<a name="ln2929">        if (! test) if (bondsOverlapped(i,j,delta)) {</a>
<a name="ln2930">            result++;</a>
<a name="ln2931">            if (findFirst) return result;</a>
<a name="ln2932">          };</a>
<a name="ln2933">      };</a>
<a name="ln2934">    for (i=0; i&lt;(nAtoms()-1); i++) for (j=i+1; j&lt;nAtoms(); j++) {</a>
<a name="ln2935">        xx=getAtom(i)-&gt;rx-getAtom(j)-&gt;rx;</a>
<a name="ln2936">        yy=getAtom(i)-&gt;ry-getAtom(j)-&gt;ry;</a>
<a name="ln2937">        r=sqrt(xx*xx+yy*yy);</a>
<a name="ln2938">        if (r &lt; (2*delta)) {</a>
<a name="ln2939">          result++;</a>
<a name="ln2940">          if (findFirst) return result;</a>
<a name="ln2941">        };</a>
<a name="ln2942">      };</a>
<a name="ln2943">    return result;</a>
<a name="ln2944">  };</a>
<a name="ln2945"> </a>
<a name="ln2946">  bool TSimpleMolecule::checkOverlapped() {</a>
<a name="ln2947">    bool result;</a>
<a name="ln2948">    result=hasOverlapped(averageBondLength()/32,true)&gt;0;</a>
<a name="ln2949">    return result;</a>
<a name="ln2950">  };</a>
<a name="ln2951"> </a>
<a name="ln2952">  double TSimpleMolecule::averageBondLength() {</a>
<a name="ln2953">    double result=0;</a>
<a name="ln2954">    if (nBonds() == 0) return result;</a>
<a name="ln2955">    for (int i=0; i&lt;nBonds(); i++) result=result+bondLength(i);</a>
<a name="ln2956">    result=result/(double)nBonds();</a>
<a name="ln2957">    return result;</a>
<a name="ln2958">  };</a>
<a name="ln2959"> </a>
<a name="ln2960">  void TSimpleMolecule::flipSmall(int cHB) {</a>
<a name="ln2961">    //the bond number CHB is used to divide the fragment into two parts. For lower</a>
<a name="ln2962">    //part flip is executed. Case CHB-ring bond-no effects}</a>
<a name="ln2963"> </a>
<a name="ln2964">    int cHA1, cHA2, n;</a>
<a name="ln2965">    bool test;</a>
<a name="ln2966">    std::vector&lt;int&gt;list1(listarSize());</a>
<a name="ln2967">    double r, xc, yc, xo, yo, xn, yn;</a>
<a name="ln2968">    int i;</a>
<a name="ln2969"> </a>
<a name="ln2970">    if (cHB &lt; 0) return;</a>
<a name="ln2971"> </a>
<a name="ln2972">    test=makeFragment(list1,getBond(cHB)-&gt;at[1],getBond(cHB)-&gt;at[0]);</a>
<a name="ln2973">    if (list1.size() &gt; 1) {</a>
<a name="ln2974">      //One of the atoms haven't neighbours-flip unavalable</a>
<a name="ln2975">      cHA1=getBond(cHB)-&gt;at[0];</a>
<a name="ln2976">      cHA2=getBond(cHB)-&gt;at[1];</a>
<a name="ln2977">      xc=getAtom(cHA2)-&gt;rx-getAtom(cHA1)-&gt;rx; //Axes direction calculation</a>
<a name="ln2978">      yc=getAtom(cHA2)-&gt;ry-getAtom(cHA1)-&gt;ry;</a>
<a name="ln2979">      r=sqrt(xc*xc+yc*yc);</a>
<a name="ln2980">      xc=xc/r;</a>
<a name="ln2981">      yc=yc/r;</a>
<a name="ln2982">      xo=xc*xc-yc*yc;</a>
<a name="ln2983">      yo=2*xc*yc;</a>
<a name="ln2984"> </a>
<a name="ln2985">      for (i=0; i&lt;list1.size(); i++) {</a>
<a name="ln2986">        //rotation at angle Pi around axes for all atoms in the LIST fragment</a>
<a name="ln2987">        n=list1[i];</a>
<a name="ln2988">        xc=getAtom(n)-&gt;rx-getAtom(cHA1)-&gt;rx;</a>
<a name="ln2989">        yc=getAtom(n)-&gt;ry-getAtom(cHA1)-&gt;ry;</a>
<a name="ln2990">        xn=xc*xo+yc*yo;</a>
<a name="ln2991">        yn=xc*yo-yc*xo;</a>
<a name="ln2992">        getAtom(n)-&gt;rx=getAtom(cHA1)-&gt;rx+xn;</a>
<a name="ln2993">        getAtom(n)-&gt;ry=getAtom(cHA1)-&gt;ry+yn;</a>
<a name="ln2994">      };</a>
<a name="ln2995">    };</a>
<a name="ln2996">  };</a>
<a name="ln2997"> </a>
<a name="ln2998">  void TSimpleMolecule::bondEnlarge(int bN) {</a>
<a name="ln2999">    double r;</a>
<a name="ln3000">    std::vector&lt;int&gt; list(listarSize());</a>
<a name="ln3001">    int cHA1, cH1, cH2, n;</a>
<a name="ln3002">    bool test;</a>
<a name="ln3003">    double xc, yc, xc1, yc1;</a>
<a name="ln3004">    int i;</a>
<a name="ln3005"> </a>
<a name="ln3006">    for (i=0; i&lt;nAtoms(); i++) list[i]=i;</a>
<a name="ln3007">    cHA1=getBond(bN)-&gt;at[0];</a>
<a name="ln3008">    test=makeFragment(list,cHA1,getBond(bN)-&gt;at[1]);</a>
<a name="ln3009">    if (list[0] == getBond(bN)-&gt;at[0]) { //center definition</a>
<a name="ln3010">      cH1=getBond(bN)-&gt;at[0];</a>
<a name="ln3011">      cH2=getBond(bN)-&gt;at[1];</a>
<a name="ln3012">    } else {</a>
<a name="ln3013">      cH1=getBond(bN)-&gt;at[1];</a>
<a name="ln3014">      cH2=getBond(bN)-&gt;at[0];</a>
<a name="ln3015">    };</a>
<a name="ln3016">    xc=getAtom(cH1)-&gt;rx-getAtom(cH2)-&gt;rx;</a>
<a name="ln3017">    yc=getAtom(cH1)-&gt;ry-getAtom(cH2)-&gt;ry;</a>
<a name="ln3018">    r=sqrt(xc*xc+yc*yc);</a>
<a name="ln3019">    xc=xc/r;</a>
<a name="ln3020">    yc=yc/r;</a>
<a name="ln3021">    xc1=getAtom(cH2)-&gt;rx-getAtom(cH1)-&gt;rx;</a>
<a name="ln3022">    yc1=getAtom(cH2)-&gt;ry-getAtom(cH1)-&gt;ry;</a>
<a name="ln3023">    r=r*2;</a>
<a name="ln3024">    for (i=0; i&lt;list.size(); i++) { //coordinates change</a>
<a name="ln3025">      n=list[i];</a>
<a name="ln3026">      getAtom(n)-&gt;rx=getAtom(n)-&gt;rx+xc1+r*xc;</a>
<a name="ln3027">      getAtom(n)-&gt;ry=getAtom(n)-&gt;ry+yc1+r*yc;</a>
<a name="ln3028">    };</a>
<a name="ln3029">  };</a>
<a name="ln3030"> </a>
<a name="ln3031">  int sproduct(TSimpleMolecule &amp; sm, int br, int i1, int i2) {</a>
<a name="ln3032">    /*</a>
<a name="ln3033">      BR-central bond's number in array BOND, I1, I2-bond's numbers, which are</a>
<a name="ln3034">      connected to different atoms of BR. The BR bond is treated by the subroutine</a>
<a name="ln3035">      as a strait line. On return SPRODUCT has value 1 if both I1 and I2 lies at</a>
<a name="ln3036">      one side of strait line (Z), 2-if at different side (E) and 0 if I1 or I2</a>
<a name="ln3037">      is collinear with BR */</a>
<a name="ln3038"> </a>
<a name="ln3039">    int crAN[4];  //0-th element will not be used-translation from Delphi</a>
<a name="ln3040">    double crRx[4];</a>
<a name="ln3041">    double crRy[4];</a>
<a name="ln3042">    int i;</a>
<a name="ln3043">    double l1,l2;</a>
<a name="ln3044">    int result=0;</a>
<a name="ln3045"> </a>
<a name="ln3046">    crAN[0]=sm.getBond(br)-&gt;at[0];</a>
<a name="ln3047">    crAN[1]=sm.getBond(br)-&gt;at[1];</a>
<a name="ln3048">    if ((sm.getBond(i1)-&gt;at[0] != crAN[0]) &amp;&amp; (sm.getBond(i1)-&gt;at[0] != crAN[1])) {</a>
<a name="ln3049">      crAN[2]=sm.getBond(i1)-&gt;at[0];</a>
<a name="ln3050">    } else {</a>
<a name="ln3051">      crAN[2]=sm.getBond(i1)-&gt;at[1];</a>
<a name="ln3052">    };</a>
<a name="ln3053">    if ((sm.getBond(i2)-&gt;at[0] != crAN[0]) &amp;&amp; (sm.getBond(i2)-&gt;at[0] != crAN[1])) {</a>
<a name="ln3054">      crAN[3]=sm.getBond(i2)-&gt;at[0];</a>
<a name="ln3055">    } else {</a>
<a name="ln3056">      crAN[3]=sm.getBond(i2)-&gt;at[1];</a>
<a name="ln3057">    };</a>
<a name="ln3058">    for (i=0; i&lt;4; i++) {</a>
<a name="ln3059">      crRx[i]=sm.getAtom(crAN[i])-&gt;rx;</a>
<a name="ln3060">      crRy[i]=sm.getAtom(crAN[i])-&gt;ry;</a>
<a name="ln3061">    };</a>
<a name="ln3062">    for (i=1; i&lt;4; i++) {</a>
<a name="ln3063">      crRx[i]=crRx[i]-crRx[0];</a>
<a name="ln3064">      crRy[i]=crRy[i]-crRy[0];</a>
<a name="ln3065">    };</a>
<a name="ln3066">    l1=crRx[1]*crRy[2]-crRy[1]*crRx[2];</a>
<a name="ln3067">    l2=crRx[1]*crRy[3]-crRy[1]*crRx[3];</a>
<a name="ln3068">    if ((l1 == 0) || (l2 == 0)) return result;</a>
<a name="ln3069">    if (((l1 &gt; 0) &amp;&amp; (l2 &gt; 0)) || ((l1 &lt; 0) &amp;&amp; (l2 &lt; 0))) result=1; else result=2;</a>
<a name="ln3070">    return result;</a>
<a name="ln3071">  };</a>
<a name="ln3072"> </a>
<a name="ln3073">  bool TSimpleMolecule::correctDblBondStereo() {</a>
<a name="ln3074">    TSimpleMolecule &amp;sm = *this;</a>
<a name="ln3075">    int i,j,an1,an2,bn1,bn2,n;</a>
<a name="ln3076">    bool result = false;</a>
<a name="ln3077"> </a>
<a name="ln3078">    //Flip bonds to show Z/E orientation</a>
<a name="ln3079">    for (i=0; i&lt;sm.nBonds(); i++) {</a>
<a name="ln3080">      TSingleBond* dblbond = sm.getBond(i);</a>
<a name="ln3081">      if (dblbond-&gt;bstereo_refs.empty())</a>
<a name="ln3082">        continue;</a>
<a name="ln3083"> </a>
<a name="ln3084">      an1 = dblbond-&gt;at[0];</a>
<a name="ln3085">      an2 = dblbond-&gt;at[1];</a>
<a name="ln3086"> </a>
<a name="ln3087">      int ref_atom1 = 0;</a>
<a name="ln3088">      if (dblbond-&gt;bstereo_refs[ref_atom1]==OBStereo::ImplicitRef)</a>
<a name="ln3089">        ref_atom1 = 1;</a>
<a name="ln3090">      int ref_atom2 = 2;</a>
<a name="ln3091">      if (dblbond-&gt;bstereo_refs[ref_atom2]==OBStereo::ImplicitRef)</a>
<a name="ln3092">        ref_atom2 = 3;</a>
<a name="ln3093">      short int cistrans=1; // cistrans of 1 =&gt; cis, 2 =&gt; trans</a>
<a name="ln3094">      if ((ref_atom2 - ref_atom1) == 2)</a>
<a name="ln3095">        cistrans=2;</a>
<a name="ln3096"> </a>
<a name="ln3097">      bn1=-1; bn2=-1;</a>
<a name="ln3098">      for (j=0; j&lt;sm.nBonds(); ++j) {</a>
<a name="ln3099">        TSingleBond* bond = sm.getBond(j);</a>
<a name="ln3100">        if ((bond-&gt;at[0]==an1 &amp;&amp; bond-&gt;at[1]!=an2) || (bond-&gt;at[0]==an2 &amp;&amp; bond-&gt;at[1]!=an1) ||</a>
<a name="ln3101">            (bond-&gt;at[1]==an1 &amp;&amp; bond-&gt;at[0]!=an2) || (bond-&gt;at[1]==an2 &amp;&amp; bond-&gt;at[0]!=an1)) {</a>
<a name="ln3102">          // This is one of the single bonds around the dbl bond</a>
<a name="ln3103">          if (bond-&gt;at[0]==dblbond-&gt;bstereo_refs[ref_atom1] || bond-&gt;at[1]==dblbond-&gt;bstereo_refs[ref_atom1])</a>
<a name="ln3104">            bn1=j;</a>
<a name="ln3105">          if (bond-&gt;at[0]==dblbond-&gt;bstereo_refs[ref_atom2] || bond-&gt;at[1]==dblbond-&gt;bstereo_refs[ref_atom2])</a>
<a name="ln3106">            bn2=j;</a>
<a name="ln3107">        }</a>
<a name="ln3108">      }</a>
<a name="ln3109"> </a>
<a name="ln3110">      if ((bn1 &gt;= 0) &amp;&amp; (bn2 &gt;= 0)) {</a>
<a name="ln3111">        n = sproduct(sm,i,bn1,bn2); // 1 for cis, 2 for trans</a>
<a name="ln3112">        if (n != cistrans) {</a>
<a name="ln3113">          sm.flipSmall(i);</a>
<a name="ln3114">          result = true;</a>
<a name="ln3115">        }</a>
<a name="ln3116">      }</a>
<a name="ln3117">    }</a>
<a name="ln3118">    return result;</a>
<a name="ln3119">  }</a>
<a name="ln3120"> </a>
<a name="ln3121">  bool compareAtoms(int a1, int a2, const std::vector&lt;std::vector&lt;int&gt; *&gt; aeqList) {</a>
<a name="ln3122">    std::vector&lt;int&gt; * l1;</a>
<a name="ln3123">    std::vector&lt;int&gt; * l2;</a>
<a name="ln3124">    unsigned int i;</a>
<a name="ln3125">    bool result=false;</a>
<a name="ln3126"> </a>
<a name="ln3127">    if ((a1 &lt; 0) || (a2 &lt; 0) || (a1 &gt;= aeqList.size()) || (a2 &gt;= aeqList.size())) return result;</a>
<a name="ln3128">    l1 = (std::vector&lt;int&gt; *)(aeqList.at(a1));</a>
<a name="ln3129">    l2 = (std::vector&lt;int&gt; *)(aeqList.at(a2));</a>
<a name="ln3130">    if (l1 == nullptr || l2 == nullptr) return result;</a>
<a name="ln3131">    if (l1-&gt;size() != l2-&gt;size()) return result;</a>
<a name="ln3132">    result=true;</a>
<a name="ln3133">    for (i=0; i&lt;l1-&gt;size(); i++) if ((*l1)[i] != (*l2)[i]) {</a>
<a name="ln3134">        result=false;</a>
<a name="ln3135">        break;</a>
<a name="ln3136">      };</a>
<a name="ln3137">    return result;</a>
<a name="ln3138">  };</a>
<a name="ln3139"> </a>
<a name="ln3140">  int TSimpleMolecule::fragmentSecond(int sphere, int att, int secAt, const std::vector&lt;int&gt; a,</a>
<a name="ln3141">                                      const std::vector&lt;int&gt; b, const neighbourlist *bk, std::vector&lt;int&gt;&amp; wSphere) {</a>
<a name="ln3142"> </a>
<a name="ln3143">    /*Generate a longinteger number, which is characterize fragment with atom</a>
<a name="ln3144">      CHA in center. Up to second neigbour's sphere are took into account. Array</a>
<a name="ln3145">      A contains the atom's codes, generated by ALLATATOM, array B-bond's codes,</a>
<a name="ln3146">      generated by BONDCONVERSION*/</a>
<a name="ln3147"> </a>
<a name="ln3148">    int i,j,k,n,i1,i2,i3,jj;</a>
<a name="ln3149">    std::vector&lt;int&gt; aDist(listarSize());</a>
<a name="ln3150">    std::vector&lt;int&gt; aList(listarSize());</a>
<a name="ln3151">    std::vector&lt;int&gt; atomoBond(listarSize());</a>
<a name="ln3152">    std::vector&lt;int&gt; * aPrev [3];</a>
<a name="ln3153">    bool test,testOK;</a>
<a name="ln3154">    int w2;</a>
<a name="ln3155">    int l2,l3,tl1,tl2;</a>
<a name="ln3156">    std::vector&lt;int&gt; ab(listarSize());</a>
<a name="ln3157">    int result=0;</a>
<a name="ln3158">    //    String s;</a>
<a name="ln3159"> </a>
<a name="ln3160">    if (nAtoms()==0) return result;</a>
<a name="ln3161"> </a>
<a name="ln3162"> </a>
<a name="ln3163">    for (j=0; j&lt;3; j++) aPrev[j]=new std::vector&lt;int&gt;(listarSize());</a>
<a name="ln3164">    for (i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln3165">      aDist[i]=65700;</a>
<a name="ln3166">      atomoBond[i]=0;</a>
<a name="ln3167">      for (j=0; j&lt;3; j++) (*aPrev[j])[i]=-1;</a>
<a name="ln3168">    };</a>
<a name="ln3169">    for (i=0; i&lt;sphere; i++) wSphere[i]=0;</a>
<a name="ln3170">    aDist[att]=0;</a>
<a name="ln3171">    k=0;</a>
<a name="ln3172">    atomoBond[att]=a[att];</a>
<a name="ln3173">    testOK=false;</a>
<a name="ln3174">    test=true;</a>
<a name="ln3175"> </a>
<a name="ln3176">    while (test) {</a>
<a name="ln3177">      test=false;</a>
<a name="ln3178">      k++;</a>
<a name="ln3179">      for (i1=0; i1&lt;nAtoms(); i1++) if (aDist[i1]==(k-1)) { //K-sphere number, K-1-previous sphere</a>
<a name="ln3180">          if (bk[i1].nb &gt; 0) for (j=0; j&lt;bk[i1].nb; j++) {</a>
<a name="ln3181">              //for each neighbour</a>
<a name="ln3182">              i3=bk[i1].adjusted[j];//[I1].BN[J];</a>
<a name="ln3183">              i2=getBond(i3)-&gt;at[0];</a>
<a name="ln3184">              if (i2 == i1) i2=getBond(i3)-&gt;at[1];</a>
<a name="ln3185"> </a>
<a name="ln3186">              if ((aDist[i2] &gt;= k) &amp;&amp; (aDist[i2] &lt;= 65700)) {</a>
<a name="ln3187">                //if the neighbour has not been added yet to list}</a>
<a name="ln3188">                aDist[i2]=k;          //Mark neighbour's sphere number</a>
<a name="ln3189">                jj=0;</a>
<a name="ln3190">                test=true;</a>
<a name="ln3191">                for (jj=1; jj&lt;=3; jj++) {</a>
<a name="ln3192">                  if (((*aPrev[jj-1])[i2] == -1) || (jj == 3)) {</a>
<a name="ln3193">                    (*aPrev[jj-1])[i2]=i1;</a>
<a name="ln3194">                    break;</a>
<a name="ln3195">                  };</a>
<a name="ln3196">                };</a>
<a name="ln3197">                w2=a[i2];</a>
<a name="ln3198">                w2=w2 &lt;&lt; 6;</a>
<a name="ln3199">                w2=w2+b[i3];</a>
<a name="ln3200">                w2=w2 ^ atomoBond[i2];  //atomoBond[I2]:=AtomoBond[I2] xor W2; !!!!!!!</a>
<a name="ln3201">                atomoBond[i2]=w2;</a>
<a name="ln3202">              };</a>
<a name="ln3203">            };</a>
<a name="ln3204">        };</a>
<a name="ln3205">      if (secAt &lt; 0) testOK=(k==sphere); else testOK=((k&gt;=sphere) &amp;&amp; (aDist[secAt] &lt; 65700));</a>
<a name="ln3206">      if (testOK) test=false;</a>
<a name="ln3207">    }; //end WHILE</a>
<a name="ln3208">    // At this point I have sphere numbers in Adist, corresponding AtomoBond word, number of atom(s), from</a>
<a name="ln3209">    //which the desirable atom were generated</a>
<a name="ln3210"> </a>
<a name="ln3211">    for (i=0; i&lt;nAtoms(); i++) ab[i]=atomoBond[i];</a>
<a name="ln3212">    for (i1=k; i1&gt;=1; i1--) {</a>
<a name="ln3213">      n=0;</a>
<a name="ln3214">      for (i=0; i&lt;nAtoms(); i++) if (aDist[i] == i1) {</a>
<a name="ln3215">          aList[n]=i;</a>
<a name="ln3216">          n++;</a>
<a name="ln3217">        };</a>
<a name="ln3218">      if (n &gt; 0) {</a>
<a name="ln3219">        i2=0;</a>
<a name="ln3220">        for (i=0; i&lt;n; i++) {</a>
<a name="ln3221">          for (j=1; j&lt;=3; j++) if ((*aPrev[j-1])[aList[i]] &gt;= 0) {</a>
<a name="ln3222">              tl1=ab[aList[i]];</a>
<a name="ln3223">              tl2=atomoBond[(*aPrev[j-1])[aList[i]]]; // [Aprev[J][AList[I]]];</a>
<a name="ln3224">              tl2=tl2 &lt;&lt; 9;</a>
<a name="ln3225">              tl1=tl1 ^ tl2;</a>
<a name="ln3226">              ab[aList[i]]=tl1;</a>
<a name="ln3227">            };</a>
<a name="ln3228">        };</a>
<a name="ln3229">        //Sorting</a>
<a name="ln3230">        if (n &gt; 1) for (i=0; i&lt;(n-1); i++) for (j=i+1; j&lt;n; j++) if (ab[aList[i]] &lt; ab[aList[j]]) {</a>
<a name="ln3231">                i2=aList[i]; aList[i]=aList[j]; aList[j]=i2;</a>
<a name="ln3232">              };</a>
<a name="ln3233">        if (n &gt; 1) i2=15/(n-1);</a>
<a name="ln3234">        l2=ab[aList[0]];</a>
<a name="ln3235">        if (n &gt; 1) for (i=1; i&lt;n; i++) {</a>
<a name="ln3236">            l3=ab[aList[i]];</a>
<a name="ln3237">            l3=l3 &lt;&lt; (i*i2);</a>
<a name="ln3238">            l2=l2 ^ l3;</a>
<a name="ln3239">          };</a>
<a name="ln3240">        l3=0;</a>
<a name="ln3241">        for (i=0; i&lt;n; i++) l3=l3+getAtom(aList[i])-&gt;nc;</a>
<a name="ln3242">        if (l3 != 0) l2=-l2;</a>
<a name="ln3243">        for (i=0; i&lt;n; i++) l2=l2 + a[aList[i]];  //Addition from 04.04.94}</a>
<a name="ln3244">        wSphere[i1-1]=l2;</a>
<a name="ln3245">      } else wSphere[i1-1]=0;</a>
<a name="ln3246">    };</a>
<a name="ln3247">    if ((secAt == -1) || (secAt == 65700)) result=0; else result=a[secAt];</a>
<a name="ln3248">    //freeing resources</a>
<a name="ln3249">    for (j=0; j&lt;3; j++) delete(aPrev[j]);</a>
<a name="ln3250"> </a>
<a name="ln3251"> </a>
<a name="ln3252">    return result;</a>
<a name="ln3253">  };</a>
<a name="ln3254"> </a>
<a name="ln3255"> </a>
<a name="ln3256">  void TSimpleMolecule::makeEquivalentList(std::vector&lt;int&gt;&amp; equivalenceList, bool isTopologyOnly) {</a>
<a name="ln3257">    //AllAboutCycles must be called early</a>
<a name="ln3258"> </a>
<a name="ln3259">    std::vector&lt;int&gt; a(listarSize());</a>
<a name="ln3260">    std::vector&lt;int&gt; b(listarSize());</a>
<a name="ln3261">    TSimpleMolecule * em;</a>
<a name="ln3262">    int i,j,n;</a>
<a name="ln3263">    neighbourlist *bk;</a>
<a name="ln3264">    std::vector&lt;std::vector&lt;int&gt; *&gt; aeqList(0);</a>
<a name="ln3265">    std::vector&lt;int&gt; * lL;</a>
<a name="ln3266"> </a>
<a name="ln3267"> </a>
<a name="ln3268">    em= new TSimpleMolecule();</a>
<a name="ln3269">    em-&gt;moleculeCopy(*this);</a>
<a name="ln3270"> </a>
<a name="ln3271">    //Only topology-nothing more!!!!</a>
<a name="ln3272">    if (isTopologyOnly) {</a>
<a name="ln3273">      for (i=0; i&lt;em-&gt;nAtoms(); i++) {</a>
<a name="ln3274">        em-&gt;getAtom(i)-&gt;na=6;</a>
<a name="ln3275">        em-&gt;getAtom(i)-&gt;nv=4;</a>
<a name="ln3276">        em-&gt;getAtom(i)-&gt;rl=6;</a>
<a name="ln3277">        em-&gt;getAtom(i)-&gt;nc=0;</a>
<a name="ln3278">      };</a>
<a name="ln3279">      for (i=0; i&lt;em-&gt;nBonds(); i++) em-&gt;getBond(i)-&gt;tb=1;</a>
<a name="ln3280">      em-&gt;defineAtomConn();</a>
<a name="ln3281">    } else {</a>
<a name="ln3282">      for (i=0; i&lt;em-&gt;nBonds(); i++) if ((em-&gt;getBond(i)-&gt;tb &gt;= 9) &amp;&amp; (em-&gt;getBond(i)-&gt;tb &lt;= 11)) em-&gt;getBond(i)-&gt;tb=1;</a>
<a name="ln3283">    };</a>
<a name="ln3284">    bk=(neighbourlist *)malloc(nAtoms() * sizeof(adjustedlist));</a>
<a name="ln3285">    em-&gt;defineBondConn(bk);</a>
<a name="ln3286">    //</a>
<a name="ln3287">    for (i=0; i&lt;em-&gt;nAtoms(); i++) a[i]=em-&gt;getAtom(i)-&gt;allAtAtom();</a>
<a name="ln3288">    for (i=0; i&lt;em-&gt;nBonds(); i++) b[i]=em-&gt;getBond(i)-&gt;bondConversion();</a>
<a name="ln3289">    for (i=0; i&lt;em-&gt;nAtoms(); i++) {</a>
<a name="ln3290">      lL=new vector&lt;int&gt;(em-&gt;listarSize());</a>
<a name="ln3291">      for (j=0; j&lt;lL-&gt;size(); j++) (*lL)[i]=0;</a>
<a name="ln3292">      em-&gt;fragmentSecond(em-&gt;nAtoms(),i,-1,a,b,bk,*lL);</a>
<a name="ln3293">      aeqList.push_back(lL);</a>
<a name="ln3294">    };</a>
<a name="ln3295">    equivalenceList.resize(em-&gt;nAtoms());</a>
<a name="ln3296"> </a>
<a name="ln3297"> </a>
<a name="ln3298">    n=0;</a>
<a name="ln3299">    for (i=0; i&lt;equivalenceList.size(); i++) equivalenceList[i]=0;</a>
<a name="ln3300">    for (i=0; i&lt;em-&gt;nAtoms(); i++) if (equivalenceList[i] == 0) {</a>
<a name="ln3301">        n++;</a>
<a name="ln3302">        equivalenceList[i]=n;</a>
<a name="ln3303">        if (i &lt; (em-&gt;nAtoms()-1)) for (j=i+1; j&lt;em-&gt;nAtoms(); j++) if (equivalenceList[j] == 0) {</a>
<a name="ln3304">              if (compareAtoms(j,i,aeqList)) equivalenceList[j]=n;</a>
<a name="ln3305">            }</a>
<a name="ln3306">      };</a>
<a name="ln3307"> </a>
<a name="ln3308">    //freeing resorces</a>
<a name="ln3309">    for (int i=0; i&lt;aeqList.size(); i++) delete(aeqList.at(i));</a>
<a name="ln3310">    aeqList.clear();</a>
<a name="ln3311">    free(bk);</a>
<a name="ln3312">    delete(em);</a>
<a name="ln3313">  };</a>
<a name="ln3314"> </a>
<a name="ln3315">  // Iterates through all of the possibilities 1000..., 0100..., 1100..., 0010...</a>
<a name="ln3316">  // (in the case where maxValues is [1111...]). Returns false when all possibilities</a>
<a name="ln3317">  // have been generated (true otherwise).</a>
<a name="ln3318">  bool incrementValues(std::vector&lt;int&gt;&amp; currentValues, const std::vector&lt;int&gt; maxValues) {</a>
<a name="ln3319">    unsigned int i, l;</a>
<a name="ln3320">    bool result=false;</a>
<a name="ln3321"> </a>
<a name="ln3322">    for (i=0; i&lt;currentValues.size(); i++) {</a>
<a name="ln3323">      l=currentValues[i];</a>
<a name="ln3324">      l++;</a>
<a name="ln3325">      if (l &lt;= maxValues[i]) {</a>
<a name="ln3326">        currentValues[i]=l;</a>
<a name="ln3327">        result=true;</a>
<a name="ln3328">        break;</a>
<a name="ln3329">      }</a>
<a name="ln3330">      else</a>
<a name="ln3331">        currentValues[i]=0;</a>
<a name="ln3332">    }</a>
<a name="ln3333">    return result;</a>
<a name="ln3334">  }</a>
<a name="ln3335"> </a>
<a name="ln3336"> </a>
<a name="ln3337"> </a>
<a name="ln3338">  int TSimpleMolecule::correctOverlapped() {</a>
<a name="ln3339">    double r;</a>
<a name="ln3340">    TSimpleMolecule * smCopy=new TSimpleMolecule();</a>
<a name="ln3341">    TSimpleMolecule * bestStore=nullptr;</a>
<a name="ln3342">    TSimpleMolecule * tmpStore = new TSimpleMolecule();</a>
<a name="ln3343">    int i, j, n, k, kk;</a>
<a name="ln3344">    bool test;</a>
<a name="ln3345">    int result;</a>
<a name="ln3346">    std::vector&lt;int&gt; currentValues(nBonds());</a>
<a name="ln3347">    std::vector&lt;int&gt; maxValues(nBonds());</a>
<a name="ln3348">    std::vector&lt;int&gt; rotBondList(nBonds());</a>
<a name="ln3349">    int at1,at2;</a>
<a name="ln3350"> </a>
<a name="ln3351"> </a>
<a name="ln3352">    r=averageBondLength()/blDenominator;</a>
<a name="ln3353">    k=hasOverlapped(r,false);</a>
<a name="ln3354">    result=k;</a>
<a name="ln3355">    smCopy-&gt;moleculeCopy(*this);</a>
<a name="ln3356">    test=true;</a>
<a name="ln3357">    while (test) {</a>
<a name="ln3358">      test=false;</a>
<a name="ln3359">      for (i=0; i&lt;nBonds(); i++) if (getBond(i)-&gt;db == 0) {</a>
<a name="ln3360">          flipSmall(i);</a>
<a name="ln3361">          kk=hasOverlapped(r,false);</a>
<a name="ln3362">          if (kk&lt;k) {</a>
<a name="ln3363">            test=true;</a>
<a name="ln3364">            k=kk;</a>
<a name="ln3365">            smCopy-&gt;moleculeCopy(*this);</a>
<a name="ln3366">          } else moleculeCopy(*smCopy);</a>
<a name="ln3367">        }</a>
<a name="ln3368">      if (k == 0) test=false;</a>
<a name="ln3369">    }</a>
<a name="ln3370">    result=k;</a>
<a name="ln3371">    if (result &gt; 0)  {  //multiple bonds rotation...</a>
<a name="ln3372">      smCopy-&gt;moleculeCopy(*this);</a>
<a name="ln3373"> </a>
<a name="ln3374">      for (i=0; i&lt;rotBondList.size(); i++)</a>
<a name="ln3375">        rotBondList[i]=0;</a>
<a name="ln3376">      for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln3377">        TSingleBond* bond = getBond(i);</a>
<a name="ln3378">        if (bond-&gt;db != 0)</a>
<a name="ln3379">          continue;</a>
<a name="ln3380">        // Skip if it's a dbl bond with defined CT stereo as this will already have been set</a>
<a name="ln3381">        if (bond-&gt;tb == 2 &amp;&amp; !bond-&gt;bstereo_refs.empty())</a>
<a name="ln3382">          continue;</a>
<a name="ln3383"> </a>
<a name="ln3384">        at1 = bond-&gt;at[0];</a>
<a name="ln3385">        at2 = bond-&gt;at[1];</a>
<a name="ln3386">        if ((getAtom(at1)-&gt;nb &gt;= 2) &amp;&amp; (getAtom(at2)-&gt;nb &gt;=2)) {</a>
<a name="ln3387">          //checking if greter 1</a>
<a name="ln3388">          test=false;</a>
<a name="ln3389">          if (getAtom(at1)-&gt;nb == 3) {</a>
<a name="ln3390">            test=true;</a>
<a name="ln3391">            for (j=0; j&lt;getAtom(at1)-&gt;nb; j++) {</a>
<a name="ln3392">              k=getAtom(at1)-&gt;ac[j];</a>
<a name="ln3393">              if ((k != at2) &amp;&amp; (getAtom(k)-&gt;nb &gt; 1)) test=false;</a>
<a name="ln3394">            }</a>
<a name="ln3395">          }</a>
<a name="ln3396">          if ((! test) &amp;&amp; (getAtom(at2)-&gt;nb == 3)) {</a>
<a name="ln3397">            test=true;</a>
<a name="ln3398">            for (j=0; j&lt;getAtom(at2)-&gt;nb; j++) {</a>
<a name="ln3399">              k=getAtom(at2)-&gt;ac[j];</a>
<a name="ln3400">              if ((k != at1) &amp;&amp; (getAtom(k)-&gt;nb &gt; 1)) test=false;</a>
<a name="ln3401">            }</a>
<a name="ln3402">          }</a>
<a name="ln3403">          if (! test) rotBondList[i]=1;</a>
<a name="ln3404">        }</a>
<a name="ln3405">      }</a>
<a name="ln3406"> </a>
<a name="ln3407">      vector&lt;int&gt; inner_bonds;</a>
<a name="ln3408">      vector&lt;int&gt; remainder;</a>
<a name="ln3409">      int n_rotors = setupRotorSearch(rotBondList, inner_bonds, remainder);</a>
<a name="ln3410">      int kk_flip;</a>
<a name="ln3411"> </a>
<a name="ln3412">      if (n_rotors &gt; 0) {  // All possible combinations of rotations for the inner_bonds...</a>
<a name="ln3413">        int m_rotors = n_rotors &lt;= nRotBondsMax ? n_rotors : nRotBondsMax;</a>
<a name="ln3414">        currentValues.resize(m_rotors);</a>
<a name="ln3415">        maxValues.resize(m_rotors);</a>
<a name="ln3416">        for (i=0; i&lt;m_rotors; i++) {</a>
<a name="ln3417">          currentValues[i]=0;</a>
<a name="ln3418">          maxValues[i]=1;</a>
<a name="ln3419">        }</a>
<a name="ln3420">        bestStore= new TSimpleMolecule();</a>
<a name="ln3421">        bestStore-&gt;moleculeCopy(*smCopy);</a>
<a name="ln3422">        test=true;</a>
<a name="ln3423">        k = result;</a>
<a name="ln3424">        while (test &amp;&amp; (k&gt;0)) {</a>
<a name="ln3425">          moleculeCopy(*smCopy);</a>
<a name="ln3426">          n=0;</a>
<a name="ln3427">          for (i=0; i&lt;inner_bonds.size(); i++) if (inner_bonds[i] != 0) {</a>
<a name="ln3428">              n++;</a>
<a name="ln3429">              if (currentValues[n-1] == 1) flipSmall(i);</a>
<a name="ln3430">            }</a>
<a name="ln3431">          kk = hasOverlapped(r, false);</a>
<a name="ln3432">          if (kk &lt; k) {</a>
<a name="ln3433">            k = kk;</a>
<a name="ln3434">            bestStore-&gt;moleculeCopy(*this);</a>
<a name="ln3435">          }</a>
<a name="ln3436">          // Now greedily try the remainder of the bonds</a>
<a name="ln3437">          for (i=0; i&lt;remainder.size(); i++) {</a>
<a name="ln3438">            tmpStore-&gt;moleculeCopy(*this);</a>
<a name="ln3439">            flipSmall(remainder[i]);</a>
<a name="ln3440">            kk_flip = hasOverlapped(r, false);</a>
<a name="ln3441">            if (kk &lt; kk_flip) // Revert to unflipped</a>
<a name="ln3442">              moleculeCopy(*tmpStore);</a>
<a name="ln3443">            else</a>
<a name="ln3444">              kk = kk_flip;</a>
<a name="ln3445">            if (kk &lt; k) {</a>
<a name="ln3446">              k = kk;</a>
<a name="ln3447">              bestStore-&gt;moleculeCopy(*this);</a>
<a name="ln3448">            }</a>
<a name="ln3449">          }</a>
<a name="ln3450">          test=incrementValues(currentValues,maxValues);</a>
<a name="ln3451">        };// (k=0) or (not test);</a>
<a name="ln3452">        moleculeCopy(*bestStore);</a>
<a name="ln3453">        result=k;</a>
<a name="ln3454">      };</a>
<a name="ln3455">    };</a>
<a name="ln3456">    if (result&gt;0) { //Bond enlarge....]</a>
<a name="ln3457">      k=hasOverlapped(r,false);</a>
<a name="ln3458">      n=1;</a>
<a name="ln3459">      while (n != 0) {</a>
<a name="ln3460">        n=0;</a>
<a name="ln3461">        for (i=0; i&lt;nBonds(); i++) if (getBond(i)-&gt;db == 0) {</a>
<a name="ln3462">            smCopy-&gt;moleculeCopy(*this);</a>
<a name="ln3463">            smCopy-&gt;bondEnlarge(i);</a>
<a name="ln3464">            kk=smCopy-&gt;hasOverlapped(r,false);</a>
<a name="ln3465">            if (kk &lt; k) {</a>
<a name="ln3466">              k=kk;</a>
<a name="ln3467">              n=i;</a>
<a name="ln3468">            };</a>
<a name="ln3469">            smCopy-&gt;flipSmall(i);</a>
<a name="ln3470">            kk=smCopy-&gt;hasOverlapped(r,false);</a>
<a name="ln3471">            if (kk &lt; k) {</a>
<a name="ln3472">              k=kk;</a>
<a name="ln3473">              n=-i;</a>
<a name="ln3474">            };</a>
<a name="ln3475">          };</a>
<a name="ln3476">        if (abs(n) != 0) {</a>
<a name="ln3477">          bondEnlarge(abs(n));</a>
<a name="ln3478">          if (n &lt; 0) flipSmall(abs(n));</a>
<a name="ln3479">        };</a>
<a name="ln3480">      };</a>
<a name="ln3481">      result=k;</a>
<a name="ln3482">    };</a>
<a name="ln3483">    //freeing resources</a>
<a name="ln3484">    if (smCopy != nullptr) delete(smCopy);</a>
<a name="ln3485">    if (bestStore != nullptr) delete(bestStore);</a>
<a name="ln3486">    if (tmpStore != nullptr) delete(tmpStore);</a>
<a name="ln3487"> </a>
<a name="ln3488">    return result;</a>
<a name="ln3489">  };</a>
<a name="ln3490"> </a>
<a name="ln3491">  // Comparison function for sort in setupRotorSearch</a>
<a name="ln3492">  bool CompareRotor(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)</a>
<a name="ln3493">  {</a>
<a name="ln3494">    return(a.second &lt; b.second);   //inside-&gt;out</a>
<a name="ln3495">  }</a>
<a name="ln3496"> </a>
<a name="ln3497">  int TSimpleMolecule::setupRotorSearch(const vector&lt;int&gt; &amp;rotBondList, vector&lt;int&gt;&amp; inner_bonds, vector&lt;int&gt;&amp; remainder)</a>
<a name="ln3498">  {</a>
<a name="ln3499">    vector&lt;pair&lt;int,int&gt; &gt; vtmp; // pair of (bond_id, gtd_score)</a>
<a name="ln3500">    int at1, at2;</a>
<a name="ln3501">    int n_rotors = 0;</a>
<a name="ln3502"> </a>
<a name="ln3503">    for (unsigned int i=0; i&lt;rotBondList.size(); i++)</a>
<a name="ln3504">      if (rotBondList[i] != 0) {</a>
<a name="ln3505">        n_rotors++;</a>
<a name="ln3506">        at1 = getBond(i)-&gt;at[0];</a>
<a name="ln3507">        at2 = getBond(i)-&gt;at[1];</a>
<a name="ln3508">        int score = getAtom(at1)-&gt;gtd + getAtom(at2)-&gt;gtd;</a>
<a name="ln3509">        vtmp.push_back(pair&lt;int,int&gt; (i, score));</a>
<a name="ln3510">      }</a>
<a name="ln3511">    // sort the rotatable bonds by GTD score</a>
<a name="ln3512">    sort(vtmp.begin(), vtmp.end(), CompareRotor);</a>
<a name="ln3513"> </a>
<a name="ln3514">    // inner_bonds will be identical to rotBondList except that</a>
<a name="ln3515">    // only the inner ten rotatable bonds will have values of 1</a>
<a name="ln3516">    inner_bonds.resize(rotBondList.size(), 0);</a>
<a name="ln3517">    for (unsigned int j=0; j&lt;nRotBondsMax &amp;&amp; j&lt;vtmp.size(); ++j) {</a>
<a name="ln3518">      inner_bonds[vtmp[j].first] = 1;</a>
<a name="ln3519">    }</a>
<a name="ln3520"> </a>
<a name="ln3521">    // remainder will store all of the other rotatable bonds</a>
<a name="ln3522">    if (vtmp.size() &gt; nRotBondsMax) {</a>
<a name="ln3523">      for (unsigned int j=nRotBondsMax; j&lt;vtmp.size(); ++j) {</a>
<a name="ln3524">        remainder.push_back(vtmp[j].first);</a>
<a name="ln3525">      }</a>
<a name="ln3526">    }</a>
<a name="ln3527"> </a>
<a name="ln3528">    return n_rotors;</a>
<a name="ln3529">  }</a>
<a name="ln3530"> </a>
<a name="ln3531">  //********************************************************************************</a>
<a name="ln3532">  //                 Determine Bond orders from attached hydrogens</a>
<a name="ln3533">  //*******************************************************************************</a>
<a name="ln3534"> </a>
<a name="ln3535">  void deleteIntElement(std::vector&lt;int&gt; * source, int index) {</a>
<a name="ln3536">    unsigned int i, n;</a>
<a name="ln3537">    std::vector&lt;int&gt; temp(source-&gt;size()-1);</a>
<a name="ln3538"> </a>
<a name="ln3539">    n=0;</a>
<a name="ln3540">    for (i=0; i&lt;source-&gt;size(); i++) if (i != index) {</a>
<a name="ln3541">        temp[n]=(*source)[i];</a>
<a name="ln3542">        n++;</a>
<a name="ln3543">      };</a>
<a name="ln3544">    source-&gt;resize(source-&gt;size()-1);</a>
<a name="ln3545">    for (i=0; i&lt;source-&gt;size(); i++) (*source)[i]=temp[i];</a>
<a name="ln3546">  };</a>
<a name="ln3547"> </a>
<a name="ln3548">  int hydrogenValency(int na) {   //Hydrogen valency</a>
<a name="ln3549">    int result=0;</a>
<a name="ln3550">    if (na &lt; NELEMMCDL) result=hVal[na];</a>
<a name="ln3551">    return result;</a>
<a name="ln3552">  };</a>
<a name="ln3553"> </a>
<a name="ln3554">  int maxValency(int na) {        //Maximal valency of a specified element</a>
<a name="ln3555">    int result=8;</a>
<a name="ln3556">    if (na &lt; NELEMMCDL) result=maxVal[na];</a>
<a name="ln3557">    return result;</a>
<a name="ln3558">  };</a>
<a name="ln3559"> </a>
<a name="ln3560">  static int findAlternateSinglets(const std::vector&lt;int&gt;iA1, const std::vector&lt;int&gt;iA2, const std::vector&lt;int&gt; nH,</a>
<a name="ln3561">                                   const std::vector&lt;int&gt; hydrogenValency, std::vector&lt;int&gt;&amp; bondOrder, int nAtoms, int nBonds) {</a>
<a name="ln3562">    //return values: 0 - no singlet found, 1 - found and assigned singlet, 2 - assigned singlet only with special</a>
<a name="ln3563"> </a>
<a name="ln3564">    std::vector&lt;int&gt;nUnassigned(nAtoms);</a>
<a name="ln3565">    std::vector&lt;int&gt;nAssigned(nAtoms);</a>
<a name="ln3566">    std::vector&lt;int&gt;bNumber(nAtoms);</a>
<a name="ln3567"> </a>
<a name="ln3568"> </a>
<a name="ln3569">    int i,n,k;</a>
<a name="ln3570">    int result;</a>
<a name="ln3571"> </a>
<a name="ln3572">    result=0;</a>
<a name="ln3573">    for (i=0; i&lt;nAtoms; i++) {</a>
<a name="ln3574">      nUnassigned[i]=0;</a>
<a name="ln3575">      nAssigned[i]=0;</a>
<a name="ln3576">    };</a>
<a name="ln3577">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3578">      n=bondOrder[i];</a>
<a name="ln3579">      if (n == 0) {</a>
<a name="ln3580">        nUnassigned[iA1[i]]=nUnassigned[iA1[i]]+1;</a>
<a name="ln3581">        nUnassigned[iA2[i]]=nUnassigned[iA2[i]]+1;</a>
<a name="ln3582">        bNumber[iA1[i]]=i;</a>
<a name="ln3583">        bNumber[iA2[i]]=i;</a>
<a name="ln3584">      } else {</a>
<a name="ln3585">        nAssigned[iA1[i]]=nAssigned[iA1[i]]+n;</a>
<a name="ln3586">        nAssigned[iA2[i]]=nAssigned[iA2[i]]+n;</a>
<a name="ln3587">      };</a>
<a name="ln3588">    };</a>
<a name="ln3589"> </a>
<a name="ln3590">    for (i=0; i&lt;nAtoms; i++) if ((hydrogenValency[i] &gt; 0) &amp;&amp; (nUnassigned[i] == 1)) {</a>
<a name="ln3591">        n=bNumber[i];</a>
<a name="ln3592">        k=hydrogenValency[i]-(nH[i]+nAssigned[i]);</a>
<a name="ln3593">        if (k &lt; 1) {</a>
<a name="ln3594">          if (k == 0) {  //increment H valence by 2</a>
<a name="ln3595">            k=2;</a>
<a name="ln3596">          } else {</a>
<a name="ln3597">            k=1;</a>
<a name="ln3598">          };</a>
<a name="ln3599">          result=2;</a>
<a name="ln3600">        };</a>
<a name="ln3601">        if (k &gt; 3) {</a>
<a name="ln3602">          k=3;</a>
<a name="ln3603">          result=3;</a>
<a name="ln3604">        };</a>
<a name="ln3605">        bondOrder[n]=k;</a>
<a name="ln3606">        if (result == 0) {</a>
<a name="ln3607">          result=1;</a>
<a name="ln3608">        };</a>
<a name="ln3609">      };</a>
<a name="ln3610">    return result;</a>
<a name="ln3611">  };</a>
<a name="ln3612"> </a>
<a name="ln3613">  static void makeAssignment(const std::vector&lt;int&gt; iA1, const std::vector&lt;int&gt; iA2, const std::vector&lt;int&gt; nH,</a>
<a name="ln3614">                             const std::vector&lt;int&gt; hydrogenValency,	const std::vector&lt;int&gt; bondAssignment, const std::vector&lt;int&gt; specialFlag,</a>
<a name="ln3615">                             std::vector&lt;int&gt;&amp; bondOrder, int nAtoms, int nBonds, int &amp; nAss) {</a>
<a name="ln3616"> </a>
<a name="ln3617">    int i,k;</a>
<a name="ln3618"> </a>
<a name="ln3619">    nAss=0;</a>
<a name="ln3620">    for (i=0; i&lt;nBonds; i++) if (bondOrder[i] == 0) {</a>
<a name="ln3621">        bondOrder[i]=bondAssignment[nAss]+specialFlag[i];</a>
<a name="ln3622">        nAss++;</a>
<a name="ln3623">        k=1;</a>
<a name="ln3624">        while (k != 0) {</a>
<a name="ln3625">          k=findAlternateSinglets(iA1,iA2,nH,hydrogenValency,bondOrder,nAtoms,nBonds);</a>
<a name="ln3626">        };</a>
<a name="ln3627">      };</a>
<a name="ln3628">  };</a>
<a name="ln3629"> </a>
<a name="ln3630">  static bool analyzeOK(const std::vector&lt;int&gt; iA1,const std::vector&lt;int&gt; iA2, const std::vector&lt;int&gt; nH,</a>
<a name="ln3631">                        const std::vector&lt;int&gt; hydrogenValency,	const std::vector&lt;int&gt; maxValency, const std::vector&lt;int&gt; bondOrder,</a>
<a name="ln3632">                        const std::vector&lt;int&gt; atomCheckFlag, int nAtoms, int nBonds, int &amp; nGtMax, int &amp; nNEH, int &amp; nOddEven,</a>
<a name="ln3633">                        bool testExceedHydrogen, bool oddEvenCheck) {</a>
<a name="ln3634"> </a>
<a name="ln3635">    std::vector&lt;int&gt;nBondsValency(nAtoms);  //dynamically allocation</a>
<a name="ln3636">    int i,k;</a>
<a name="ln3637">    bool result;</a>
<a name="ln3638"> </a>
<a name="ln3639">    nGtMax=0;</a>
<a name="ln3640">    nNEH=0;</a>
<a name="ln3641">    nOddEven=0;</a>
<a name="ln3642">    for (i=0; i&lt;nAtoms; i++) nBondsValency[i]=0;</a>
<a name="ln3643">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3644">      nBondsValency[iA1[i]]=nBondsValency[iA1[i]]+bondOrder[i];</a>
<a name="ln3645">      nBondsValency[iA2[i]]=nBondsValency[iA2[i]]+bondOrder[i];</a>
<a name="ln3646">    };</a>
<a name="ln3647">    for (i=0; i&lt;nAtoms; i++) if (atomCheckFlag[i] == 1) {</a>
<a name="ln3648">        if (nBondsValency[i] &gt; maxValency[i]) nGtMax++;</a>
<a name="ln3649">        if (testExceedHydrogen) {</a>
<a name="ln3650">          if ((nH[i]+nBondsValency[i]) != hydrogenValency[i]) nNEH++;</a>
<a name="ln3651">        } else {</a>
<a name="ln3652">          if ((hydrogenValency[i] &gt; 0) &amp;&amp; (nH[i] &gt; 0)) if ((nH[i]+nBondsValency[i]) != hydrogenValency[i]) nNEH++;</a>
<a name="ln3653">          if ((hydrogenValency[i] &gt; 0) &amp;&amp; (nH[i] ==0)) if (nBondsValency[i] &lt; hydrogenValency[i]) nNEH++;</a>
<a name="ln3654">          if (oddEvenCheck) {</a>
<a name="ln3655">            k=nH[i]+nBondsValency[i];</a>
<a name="ln3656">            if ((k % 2) != (maxValency[i] % 2)) nOddEven++;</a>
<a name="ln3657">          };</a>
<a name="ln3658">        };</a>
<a name="ln3659">      };</a>
<a name="ln3660">    result=((nGtMax == 0) &amp;&amp; (nNEH == 0) &amp;&amp; (nOddEven == 0));</a>
<a name="ln3661">    return result;</a>
<a name="ln3662">  };</a>
<a name="ln3663"> </a>
<a name="ln3664">  static bool incrementAssignment(std::vector&lt;int&gt;&amp; bondAssignment, int nAss) {</a>
<a name="ln3665">    int i,j;</a>
<a name="ln3666">    bool result;</a>
<a name="ln3667"> </a>
<a name="ln3668">    result=false;</a>
<a name="ln3669">    for (i=nAss-1; i&gt;=0; i--) if (bondAssignment[i] == 1) {</a>
<a name="ln3670">        bondAssignment[i]++;</a>
<a name="ln3671">        if (i &lt; (nAss-1)) for (j=i+1; j&lt;nAss; j++) bondAssignment[j]=1;</a>
<a name="ln3672">        result=true;</a>
<a name="ln3673">        return result;</a>
<a name="ln3674">      };</a>
<a name="ln3675">    return result;</a>
<a name="ln3676">  };</a>
<a name="ln3677"> </a>
<a name="ln3678">  static int determineBondsOrder(const std::vector&lt;int&gt; iA1, const std::vector&lt;int&gt; iA2,</a>
<a name="ln3679">                                 const std::vector&lt;int&gt; nH, const std::vector&lt;int&gt; maxValency,std::vector&lt;int&gt;&amp; bondOrder,</a>
<a name="ln3680">                                 std::vector&lt;int&gt;&amp; hydrogenValency, int nAtoms, int nBonds, bool oddEvenViolate) {</a>
<a name="ln3681">    //On input BortOrder has to be initialized. Real bond orders have to be putted. 0 means this order should be determined</a>
<a name="ln3682">    //MaxValency and HydrogenValency and NH are required only for those atoms, which are included in BondOrder=0</a>
<a name="ln3683"> </a>
<a name="ln3684">    std::vector&lt;int&gt;nNeighbour(nAtoms);</a>
<a name="ln3685">    std::vector&lt;int&gt;bondAssignment(nBonds);  //Should be Max(Atoms, Bonds);</a>
<a name="ln3686">    std::vector&lt;int&gt;bondOrderStore(nBonds);</a>
<a name="ln3687">    std::vector&lt;int&gt;specialFlag(nBonds);</a>
<a name="ln3688"> </a>
<a name="ln3689">    int i,j,k,n,nAss;</a>
<a name="ln3690">    bool  test;</a>
<a name="ln3691">    int nGtMax;  //number of atoms, for which maximal valency is exausted</a>
<a name="ln3692">    int nNEH;    //bumber of atoms, for which number of calc and desirable hydrogens are disagree</a>
<a name="ln3693">    int nOddEven;//Parity violation - atom with odd maximal valency has even valency and back</a>
<a name="ln3694">    int result;</a>
<a name="ln3695"> </a>
<a name="ln3696">    k=nAtoms;</a>
<a name="ln3697">    if (nBonds &gt; k) k=nBonds;</a>
<a name="ln3698">    k++;</a>
<a name="ln3699"> </a>
<a name="ln3700">    result=0;</a>
<a name="ln3701">    for (i=0; i&lt;nAtoms; i++) nNeighbour[i]=0;</a>
<a name="ln3702">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3703">      nNeighbour[iA1[i]]=nNeighbour[iA1[i]]+1;</a>
<a name="ln3704">      nNeighbour[iA2[i]]=nNeighbour[iA2[i]]+1;</a>
<a name="ln3705">      specialFlag[i]=0;</a>
<a name="ln3706">    };</a>
<a name="ln3707">    //Special flag-find allene and cumulene</a>
<a name="ln3708">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3709">      if ((nNeighbour[iA1[i]] == 2) &amp;&amp; (nNeighbour[iA2[i]] == 2) &amp;&amp; (hydrogenValency[iA1[i]] == 4)</a>
<a name="ln3710">          &amp;&amp; (hydrogenValency[iA2[i]] == 4) &amp;&amp; (nH[iA1[i]] == 0) &amp;&amp; (nH[iA2[i]] == 0)) specialFlag[i]=1;</a>
<a name="ln3711">    };</a>
<a name="ln3712"> </a>
<a name="ln3713">    //correct hydrogen valency by 2 if required....</a>
<a name="ln3714">    for (i=0; i&lt;nAtoms; i++) if (hydrogenValency[i] &gt; 0) {</a>
<a name="ln3715">        n=nH[i]+nNeighbour[i];</a>
<a name="ln3716">        if (n &gt; hydrogenValency[i]) hydrogenValency[i]=hydrogenValency[i]+2;</a>
<a name="ln3717">        if (n &gt; hydrogenValency[i]) hydrogenValency[i]=hydrogenValency[i]+2;</a>
<a name="ln3718">      };</a>
<a name="ln3719">    //Label all bonds which have order 1 exactly</a>
<a name="ln3720">    for (i=0; i&lt;nAtoms; i++) if ((hydrogenValency[i] &gt; 0) &amp;&amp; (nH[i] &gt; 0)) {</a>
<a name="ln3721">        n=nH[i]+nNeighbour[i];</a>
<a name="ln3722">        if (n == hydrogenValency[i]) for (j=0; j&lt;nBonds; j++) if (((iA1[j] == i) || (iA2[j] == i)) &amp;&amp; (bondOrder[j] == 0)) {</a>
<a name="ln3723">              bondOrder[j]=1;</a>
<a name="ln3724">            };</a>
<a name="ln3725">      };</a>
<a name="ln3726"> </a>
<a name="ln3727">    k=1;</a>
<a name="ln3728">    while (k != 0) {</a>
<a name="ln3729">      k=findAlternateSinglets(iA1,iA2,nH,hydrogenValency,bondOrder,nAtoms,nBonds);</a>
<a name="ln3730">    };</a>
<a name="ln3731">    //repeat default no. hydrogens correction</a>
<a name="ln3732">    for (i=0; i&lt;nAtoms; i++) nNeighbour[i]=0;</a>
<a name="ln3733">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3734">      k=bondOrder[i];</a>
<a name="ln3735">      if (k == 0) k=1;</a>
<a name="ln3736">      nNeighbour[iA1[i]]=nNeighbour[iA1[i]]+k;</a>
<a name="ln3737">      nNeighbour[iA2[i]]=nNeighbour[iA2[i]]+k;</a>
<a name="ln3738">    };</a>
<a name="ln3739">    //correct hydrogen valency by 2 if required....</a>
<a name="ln3740"> </a>
<a name="ln3741"> </a>
<a name="ln3742">    for (i=0; i&lt;nAtoms; i++) if (hydrogenValency[i] &gt; 0) {</a>
<a name="ln3743">        n=nH[i]+nNeighbour[i];</a>
<a name="ln3744">        if (n &gt; hydrogenValency[i]) hydrogenValency[i]=hydrogenValency[i]+2;</a>
<a name="ln3745">        if (n &gt; hydrogenValency[i]) hydrogenValency[i]=hydrogenValency[i]+2;</a>
<a name="ln3746">      };</a>
<a name="ln3747"> </a>
<a name="ln3748">    //below array NNeighbour is used for picking atoms, for which valency have to be checked..</a>
<a name="ln3749">    for (i=0; i&lt;nAtoms; i++) nNeighbour[i]=0;</a>
<a name="ln3750">    for (i=0; i&lt;nBonds; i++) if (bondOrder[i] == 0) {</a>
<a name="ln3751">        nNeighbour[iA1[i]]=1;</a>
<a name="ln3752">        nNeighbour[iA2[i]]=1;</a>
<a name="ln3753">      };</a>
<a name="ln3754">    test=false;</a>
<a name="ln3755">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3756">      bondAssignment[i]=1;</a>
<a name="ln3757">      bondOrderStore[i]=bondOrder[i];</a>
<a name="ln3758">      if (bondOrder[i] == 0) test=true;   //bad bonds exists-must to assign...</a>
<a name="ln3759">    };</a>
<a name="ln3760">    if (! test) return result;    //All fine-not necessary especially alternate</a>
<a name="ln3761">    test=false;</a>
<a name="ln3762">    while (! test) {              //Try to assign with fina valencies</a>
<a name="ln3763">      for (i=0; i&lt;nBonds; i++) bondOrder[i]=bondOrderStore[i];</a>
<a name="ln3764">      makeAssignment(iA1,iA2,nH,hydrogenValency,bondAssignment,specialFlag,bondOrder,nAtoms,nBonds,nAss);</a>
<a name="ln3765">      test=analyzeOK(iA1,iA2,nH,hydrogenValency,maxValency,bondOrder,nNeighbour,nAtoms,nBonds,nGtMax,nNEH,nOddEven,true,true);</a>
<a name="ln3766">      if (! test) {</a>
<a name="ln3767">        test=! incrementAssignment(bondAssignment,nAss);</a>
<a name="ln3768">        if (test) result=1;</a>
<a name="ln3769">      };</a>
<a name="ln3770">    };</a>
<a name="ln3771">    if (result == 1) {        //try to assign with hydrogen valency exceeded</a>
<a name="ln3772">      result=0;</a>
<a name="ln3773">      for (i=0; i&lt;nBonds; i++) bondAssignment[i]=1;</a>
<a name="ln3774">      test=false;</a>
<a name="ln3775">      while (! test) {</a>
<a name="ln3776">        for (i=0; i&lt;nBonds; i++) bondOrder[i]=bondOrderStore[i];</a>
<a name="ln3777">        makeAssignment(iA1,iA2,nH,hydrogenValency,bondAssignment,specialFlag,bondOrder,nAtoms,nBonds,nAss);</a>
<a name="ln3778">        test=analyzeOK(iA1,iA2,nH,hydrogenValency,maxValency,bondOrder,nNeighbour,nAtoms,nBonds,nGtMax,nNEH,nOddEven,false,true);</a>
<a name="ln3779">        if (! test) {</a>
<a name="ln3780">          test=! incrementAssignment(bondAssignment,nAss);</a>
<a name="ln3781">          if (test) result=1;</a>
<a name="ln3782">        };</a>
<a name="ln3783">      };</a>
<a name="ln3784">    };</a>
<a name="ln3785">    if (result == 1) {        //hydrogen valency is still bad. Try to analyze withoud Odd/Even checking (metals, etc).</a>
<a name="ln3786">      result=0;</a>
<a name="ln3787">      for (i=0; i&lt;nBonds; i++) bondAssignment[i]=1;</a>
<a name="ln3788">      test=false;</a>
<a name="ln3789">      while (! test) {</a>
<a name="ln3790">        for (i=0; i&lt;nBonds; i++) bondOrder[i]=bondOrderStore[i];</a>
<a name="ln3791">        makeAssignment(iA1,iA2,nH,hydrogenValency,bondAssignment,specialFlag,bondOrder,nAtoms,nBonds,nAss);</a>
<a name="ln3792">        test=analyzeOK(iA1,iA2,nH,hydrogenValency,maxValency,bondOrder,nNeighbour,nAtoms,nBonds,nGtMax,nNEH,nOddEven,false,false);</a>
<a name="ln3793">        if (! test) {</a>
<a name="ln3794">          test=! incrementAssignment(bondAssignment,nAss);</a>
<a name="ln3795">          if (test) result=1;</a>
<a name="ln3796">        };</a>
<a name="ln3797">      };</a>
<a name="ln3798">    };</a>
<a name="ln3799">    return result;</a>
<a name="ln3800">  };</a>
<a name="ln3801"> </a>
<a name="ln3802">  int alternate(const std::vector&lt;int&gt; aPosition,const std::vector&lt;int&gt; aCharge,</a>
<a name="ln3803">                const std::vector&lt;int&gt; aRad,const std::vector&lt;int&gt; nHydr, const std::vector&lt;int&gt; iA1,</a>
<a name="ln3804">                const std::vector&lt;int&gt; iA2, std::vector&lt;int&gt; &amp; bondOrders, int nAtoms, int nBonds) {</a>
<a name="ln3805"> </a>
<a name="ln3806">    std::vector&lt;int&gt; hVal(nAtoms);</a>
<a name="ln3807">    std::vector&lt;int&gt; maxVal(nAtoms);</a>
<a name="ln3808">    int i,result;</a>
<a name="ln3809"> </a>
<a name="ln3810">    for (i=0; i&lt;nAtoms; i++) {</a>
<a name="ln3811">      hVal[i]=hydrogenValency(aPosition[i]);</a>
<a name="ln3812">      if (hVal[i] &gt; 0) {</a>
<a name="ln3813">        if (aRad[i] != 0) hVal[i]=hVal[i]-1;  //returns 0 for non-radical and 2 for radical</a>
<a name="ln3814">        if (aPosition[i] == 5) hVal[i]=hVal[i]-aCharge[i];           //B</a>
<a name="ln3815">        else if (aPosition[i] == 6) hVal[i]=hVal[i]-abs(aCharge[i]); //C</a>
<a name="ln3816">        else hVal[i]=hVal[i]+aCharge[i];  //Heteroatoms</a>
<a name="ln3817">        if (hVal[i] &lt; 0) hVal[i]=0;</a>
<a name="ln3818">      };</a>
<a name="ln3819">      maxVal[i]=maxValency(aPosition[i]);</a>
<a name="ln3820">      if (aCharge[i] != 0) maxVal[i]=maxVal[i]+1;</a>
<a name="ln3821">    };</a>
<a name="ln3822">    result=determineBondsOrder(iA1,iA2,nHydr,maxVal,bondOrders,hVal,nAtoms,nBonds,true);</a>
<a name="ln3823">    return result;</a>
<a name="ln3824">  };</a>
<a name="ln3825"> </a>
<a name="ln3826">  int alternate(OBMol * pmol, const std::vector&lt;int&gt; nH, std::vector&lt;int&gt;&amp; bondOrders) {</a>
<a name="ln3827">    //This overloaded method does not work. By unknown reason I cannot extract</a>
<a name="ln3828">    //connection matrix from pmol</a>
<a name="ln3829"> </a>
<a name="ln3830">    //number of hydogens must be filled on input.</a>
<a name="ln3831">    std::vector&lt;int&gt; hVal(pmol-&gt;NumAtoms());</a>
<a name="ln3832">    std::vector&lt;int&gt; maxVal(pmol-&gt;NumAtoms());</a>
<a name="ln3833">    std::vector&lt;int&gt;iA1(pmol-&gt;NumBonds());</a>
<a name="ln3834">    std::vector&lt;int&gt;iA2(pmol-&gt;NumBonds());</a>
<a name="ln3835">    int nAtoms,nBonds;</a>
<a name="ln3836">    int i,k,na;</a>
<a name="ln3837">    OBAtom * sa;</a>
<a name="ln3838">    OBBond * sb;</a>
<a name="ln3839">    int result=0;</a>
<a name="ln3840"> </a>
<a name="ln3841">    pmol-&gt;AssignSpinMultiplicity();</a>
<a name="ln3842"> </a>
<a name="ln3843">    nAtoms=pmol-&gt;NumAtoms();</a>
<a name="ln3844">    nBonds=pmol-&gt;NumBonds();</a>
<a name="ln3845"> </a>
<a name="ln3846">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3847">      sb=pmol-&gt;GetBond(i);</a>
<a name="ln3848">      iA1[i]=sb-&gt;GetBeginAtomIdx()-1;</a>
<a name="ln3849">      iA2[i]=sb-&gt;GetEndAtomIdx()-1;</a>
<a name="ln3850">    };</a>
<a name="ln3851"> </a>
<a name="ln3852"> </a>
<a name="ln3853">    for (i=1; i&lt;=nAtoms; i++) {</a>
<a name="ln3854">      sa=pmol-&gt;GetAtom(i);</a>
<a name="ln3855">      na=sa-&gt;GetAtomicNum();</a>
<a name="ln3856">      hVal[i-1]=hydrogenValency(na);</a>
<a name="ln3857">      if (hVal[i-1] &gt; 0) {</a>
<a name="ln3858">        if (sa-&gt;GetSpinMultiplicity() != 0) hVal[i-1]=hVal[i-1]-1;  //returns 0 for non-radical and 2 for radical</a>
<a name="ln3859">        k=sa-&gt;GetFormalCharge();</a>
<a name="ln3860">        if (sa-&gt;IsHeteroatom()) hVal[i-1]=hVal[i-1]+k;</a>
<a name="ln3861">        else if (na == 6) hVal[i-1]=hVal[i-1]-abs(k);</a>
<a name="ln3862">        else hVal[i-1]=hVal[i-1]-k;</a>
<a name="ln3863">        if (hVal[i-1] &lt; 0) hVal[i-1]=0;</a>
<a name="ln3864">      };</a>
<a name="ln3865">      maxVal[i-1]=maxValency(na);</a>
<a name="ln3866">      if (sa-&gt;GetFormalCharge() != 0) maxVal[i-1]=maxVal[i-1]+1;</a>
<a name="ln3867">    };</a>
<a name="ln3868"> </a>
<a name="ln3869">    result=determineBondsOrder(iA1,iA2,nH,maxVal,bondOrders,hVal,nAtoms,nBonds,true);</a>
<a name="ln3870">    for (i=0; i&lt;nBonds; i++) {</a>
<a name="ln3871">      sb=pmol-&gt;GetBond(i);</a>
<a name="ln3872">      sb-&gt;SetBondOrder(bondOrders[i]);</a>
<a name="ln3873">    };</a>
<a name="ln3874">    return result;</a>
<a name="ln3875">  };</a>
<a name="ln3876">  //*****************************************************************************</a>
<a name="ln3877">  //*******************  EditedMolecule class ***********************************</a>
<a name="ln3878">  //*****************************************************************************</a>
<a name="ln3879"> </a>
<a name="ln3880"> </a>
<a name="ln3881">  class TEditedMolecule: public TSimpleMolecule {</a>
<a name="ln3882">  protected:</a>
<a name="ln3883">    std::vector&lt;int&gt; queryQHydr;</a>
<a name="ln3884">    std::vector&lt;int&gt; queryAGer;</a>
<a name="ln3885">    std::vector&lt;int&gt; queryBQCounter;</a>
<a name="ln3886">    std::vector&lt;int&gt; queryCurrentAssignment;</a>
<a name="ln3887">    std::vector&lt;int&gt; queryEnum;</a>
<a name="ln3888">    std::vector&lt;int&gt; queryInverse;</a>
<a name="ln3889"> </a>
<a name="ln3890">    bool queryStereoQ,fIsQueryPrepare;</a>
<a name="ln3891"> </a>
<a name="ln3892">    std::vector&lt;int&gt; aSTested;</a>
<a name="ln3893">    std::vector&lt;int&gt; bSTested;</a>
<a name="ln3894">    std::vector&lt;int&gt; bSTestedStore;</a>
<a name="ln3895"> </a>
<a name="ln3896">    void removeHydrogen(std::vector&lt;int&gt; * qHydr, std::vector&lt;int&gt; * qEnumerator);</a>
<a name="ln3897">    void atomBondChange();</a>
<a name="ln3898">    bool stereoBondChange();</a>
<a name="ln3899">    void directBondAss(int&amp; bnq, bool&amp; test, bool&amp; test1, bool const* const* beq,</a>
<a name="ln3900">                       bool const* const* aeq, std::vector&lt;int&gt;&amp; bqcounter, std::vector&lt;int&gt;&amp; aqtested,</a>
<a name="ln3901">                       std::vector&lt;int&gt;&amp; bstested, std::vector&lt;int&gt;&amp; bqtested, std::vector&lt;int&gt;&amp; astested,</a>
<a name="ln3902">                       const std::vector&lt;int&gt; ager, const neighbourlist *bsconn, TSimpleMolecule * smol);</a>
<a name="ln3903">    bool allQueryPresent(const std::vector&lt;int&gt; qA, const std::vector&lt;int&gt; qB,</a>
<a name="ln3904">                         int nA, int nB);</a>
<a name="ln3905">  public:</a>
<a name="ln3906">    static int const NOOTHER_MASK=1;</a>
<a name="ln3907">    static int const AROMATIC_MASK=NOOTHER_MASK &lt;&lt; 1;</a>
<a name="ln3908">    static int const EXACTNUMBER_MASK=AROMATIC_MASK &lt;&lt; 1;</a>
<a name="ln3909">    bool fIOPT10;   //charge sensitivite</a>
<a name="ln3910">    bool fIOPT11;   //isotopes difference</a>
<a name="ln3911">    int  fIOPT12;   //stereo bond change</a>
<a name="ln3912">    bool fIOPT13;   //semipolar bond as double</a>
<a name="ln3913">    std::vector&lt;int&gt; queryAQTested;</a>
<a name="ln3914">    std::vector&lt;int&gt; queryBQTested;</a>
<a name="ln3915">    std::vector&lt;int&gt;* fIncludedList;</a>
<a name="ln3916">    TEditedMolecule() : TSimpleMolecule() {</a>
<a name="ln3917">      fIncludedList=nullptr;</a>
<a name="ln3918">	  fIOPT10=false;</a>
<a name="ln3919">	  fIOPT11=false;</a>
<a name="ln3920">	  fIOPT13=true;</a>
<a name="ln3921">	  fIOPT12=1;</a>
<a name="ln3922">    };</a>
<a name="ln3923"> </a>
<a name="ln3924">    int prepareQuery(TSimpleMolecule &amp; sMol);</a>
<a name="ln3925">    bool fragmentSearch(TEditedMolecule * molecule1, std::vector&lt;int&gt;* bondLabel);</a>
<a name="ln3926">    TEditedMolecule * extractFragment(int atomN, std::vector&lt;int&gt; * enumerator);</a>
<a name="ln3927">    void addAsTemplate(TEditedMolecule&amp; fragmentMol, int thisAN, int smAN, int thisBN, int smBN, bool isAddition);</a>
<a name="ln3928">    int addFragment(TEditedMolecule &amp; eMolecule, int naDEF, int cha, int chb,</a>
<a name="ln3929">                    int chb1, std::vector&lt;int&gt;&amp; list, double xOldCenter, double yOldCenter, double xNewCenter,</a>
<a name="ln3930">                    double yNewCenter, double scale, double cFi, double sFi, int buttonStatus, bool clearEnumerator);</a>
<a name="ln3931">  };</a>
<a name="ln3932"> </a>
<a name="ln3933">  int TEditedMolecule::addFragment(TEditedMolecule &amp; eMolecule, int naDEF, int cha, int chb,</a>
<a name="ln3934">                                   int chb1, std::vector&lt;int&gt;&amp; list, double xOldCenter, double yOldCenter, double xNewCenter,</a>
<a name="ln3935">                                   double yNewCenter, double scale, double cFi, double sFi, int buttonStatus, bool clearEnumerator) {</a>
<a name="ln3936"> </a>
<a name="ln3937">    //    The procedure is used by TEMPLATE and MAKEPOLI procedure to add large frag-</a>
<a name="ln3938">    //     ments to structure. The connection between structure and fragment may be</a>
<a name="ln3939">    //     achived both through atoms (CHA&gt;0) and through bonds (CHB&gt;0).</a>
<a name="ln3940">    //                              Variables description:</a>
<a name="ln3941">    //     NAtoms-number of atoms in structure</a>
<a name="ln3942">    //     NBonds-number of bonds in structure</a>
<a name="ln3943">    //     ATOM-atom's attributes in structure</a>
<a name="ln3944">    //     BOND-bond's attributes in structure</a>
<a name="ln3945">    //     CONN-some invariants of bond-connection matrix</a>
<a name="ln3946">    //     NAtoms1, NBonds1, ATOM1, BOND1, CONN1-the same for fragments (these varia-</a>
<a name="ln3947">    //       bles can contain data for more, than one fragments)</a>
<a name="ln3948">    //     LIST-atom's number in arrays ATOM1,CONN1, which should be added to structure</a>
<a name="ln3949">    //     NaDef-number of principal components in LIST array</a>
<a name="ln3950">    //     CHA-atom's number in array ATOM (structure), which was selected for addition</a>
<a name="ln3951">    //     CHB-bond's number in array BOND (structure), which was selected for addition</a>
<a name="ln3952">    //     CHB1-bond's number in array BOND1 (fragment), which was selected for addition</a>
<a name="ln3953">    //     XOldCenter,YOldCenter-old coordinates of the fragment on screen (center rotation)</a>
<a name="ln3954">    //     XNewCenter,YNewCenter-new coordinates of the fragment on screen</a>
<a name="ln3955">    //     Scale-scale variables to resize fragment</a>
<a name="ln3956">    //     CFi,SFi-cosine and sine of the angle of rotation of the fragment relative</a>
<a name="ln3957">    //      old coordinate of ths type of a fragment addition (active only for addition</a>
<a name="ln3958">    //       through atoms). If e fragment on screen</a>
<a name="ln3959">    //     ButtonStatus-regulateButtonStatus=1 then fragment will be added to structure</a>
<a name="ln3960">    //       (new bond arise). If ButtonStatus=2 then fragment will be freezed in</a>
<a name="ln3961">    //       structure (selected new atom for structure will be deleted, no new bond</a>
<a name="ln3962">    //       will be arised)}</a>
<a name="ln3963"> </a>
<a name="ln3964">    //    Returns 0 if addition is OK,  otherwise:</a>
<a name="ln3965">    //    =1 - Maxima number of atoms is reached</a>
<a name="ln3966">    //    =2 - Maximal number of bonds is reached</a>
<a name="ln3967"> </a>
<a name="ln3968">    int i,j1,j2,na,k1,k2,j,nb,n1,n2;</a>
<a name="ln3969">    int l1=0;</a>
<a name="ln3970">    int l2=0;</a>
<a name="ln3971">    bool test;</a>
<a name="ln3972">    double r1,r2,r3,r4,emBLength;</a>
<a name="ln3973">    TSingleAtom * sa=nullptr;</a>
<a name="ln3974">    TSingleBond * sb=nullptr;</a>
<a name="ln3975">    int result=0;</a>
<a name="ln3976"> </a>
<a name="ln3977"> </a>
<a name="ln3978"> </a>
<a name="ln3979">    //return result;</a>
<a name="ln3980">    //Analizing on boundaries}</a>
<a name="ln3981">    k2=1; k1=1;</a>
<a name="ln3982"> </a>
<a name="ln3983">    //Analizing of bond's</a>
<a name="ln3984">    nb=0;</a>
<a name="ln3985">    emBLength=0;</a>
<a name="ln3986">    std::vector&lt;int&gt; bList(eMolecule.nAtoms(), 0);</a>
<a name="ln3987">    for (i=0; i&lt;naDEF; i++) bList[list[i]]=1;</a>
<a name="ln3988">    for (i=0; i&lt;eMolecule.nBonds(); i++) {</a>
<a name="ln3989">      n1=eMolecule.getBond(i)-&gt;at[0];</a>
<a name="ln3990">      n2=eMolecule.getBond(i)-&gt;at[1];</a>
<a name="ln3991">      if ((bList[n1] != 0) || (bList[n2] != 0)) {</a>
<a name="ln3992">        nb++;</a>
<a name="ln3993">        emBLength=emBLength+eMolecule.bondLength(i);</a>
<a name="ln3994">      }</a>
<a name="ln3995">    }</a>
<a name="ln3996">    if (nb &gt; 0) emBLength=emBLength/nb;</a>
<a name="ln3997"> </a>
<a name="ln3998">    na=nAtoms();</a>
<a name="ln3999">    nb=nBonds();</a>
<a name="ln4000"> </a>
<a name="ln4001"> </a>
<a name="ln4002">    if (chb &gt;= 0) {   //Bond was selected for addition</a>
<a name="ln4003"> </a>
<a name="ln4004">      l1=getBond(chb)-&gt;at[0];     //L1,L2,K1,K2-atoms numbers for corresponding bonds</a>
<a name="ln4005">      l2=getBond(chb)-&gt;at[1];     //in structure and in fragment</a>
<a name="ln4006">      k1=eMolecule.getBond(chb1)-&gt;at[0];</a>
<a name="ln4007">      k2=eMolecule.getBond(chb1)-&gt;at[1];</a>
<a name="ln4008">      j=0;</a>
<a name="ln4009">      for (i=0; i&lt;naDEF; i++) {</a>
<a name="ln4010">        test=(list[i] == k1) || (list[i] == k2);</a>
<a name="ln4011">        if (! test) {</a>
<a name="ln4012">          list[j]=list[i];</a>
<a name="ln4013">          j++;</a>
<a name="ln4014">        };</a>
<a name="ln4015">      };</a>
<a name="ln4016">      list[naDEF-2]=k1;</a>
<a name="ln4017">      list[naDEF-1]=k2;</a>
<a name="ln4018">      //It is necessary to make the pair of atoms last in array so they may be</a>
<a name="ln4019">      // deleted easy from final structure</a>
<a name="ln4020">    }</a>
<a name="ln4021">    //Addition from 13 May 2000</a>
<a name="ln4022">    if (((cha &lt; 0) || (nBonds() == 0)) &amp;&amp; (emBLength &gt; 0)) {</a>
<a name="ln4023">      if (nBonds() == 0) r1=DEFAULTBONDLENGTH; else r1=averageBondLength();</a>
<a name="ln4024">      scale=r1/emBLength;</a>
<a name="ln4025">    }</a>
<a name="ln4026">    //End addition</a>
<a name="ln4027"> </a>
<a name="ln4028">    for (i=0; i&lt;naDEF; i++) {</a>
<a name="ln4029">      //recalculation of atom's coordinates in fragment to new ones, compartible</a>
<a name="ln4030">      //with the structure coordinates. Some rescaling and rotation take place</a>
<a name="ln4031">      r1=eMolecule.getAtom(list[i])-&gt;rx-xOldCenter;</a>
<a name="ln4032">      r2=eMolecule.getAtom(list[i])-&gt;ry-yOldCenter;</a>
<a name="ln4033">      r3=scale*(r1*cFi-r2*sFi);</a>
<a name="ln4034">      r4=scale*(r1*sFi+r2*cFi);</a>
<a name="ln4035">      sa=eMolecule.getAtom(list[i])-&gt;clone();</a>
<a name="ln4036">      sa-&gt;rx=xNewCenter+r3;</a>
<a name="ln4037">      sa-&gt;ry=yNewCenter+r4;</a>
<a name="ln4038">      if (clearEnumerator) sa-&gt;enumerator=0;</a>
<a name="ln4039">      sa-&gt;fragIndex=0;</a>
<a name="ln4040">      addAtom(sa);</a>
<a name="ln4041">    }</a>
<a name="ln4042">    if (chb &gt;= 0) {</a>
<a name="ln4043">      //specific for bond-to-bond addition block-determination of correspondence</a>
<a name="ln4044">      //of pair of atoms, which make bond, in fragment to the same pair of atoms in</a>
<a name="ln4045">      //structure. Determination is perfomed through internuclear distances}</a>
<a name="ln4046">      r1=getAtom(l2)-&gt;rx-getAtom(nAtoms()-1)-&gt;rx;</a>
<a name="ln4047">      r2=getAtom(l2)-&gt;ry-getAtom(nAtoms()-1)-&gt;ry;</a>
<a name="ln4048">      r3=r1*r1+r2*r2;</a>
<a name="ln4049">      r1=getAtom(l1)-&gt;rx-getAtom(nAtoms()-1)-&gt;rx;</a>
<a name="ln4050">      r2=getAtom(l1)-&gt;ry-getAtom(nAtoms()-1)-&gt;ry;</a>
<a name="ln4051">      r4=r1*r1+r2*r2;</a>
<a name="ln4052">      if (r3 &lt; r4) {k2=nAtoms()-1; k1=nAtoms()-2;</a>
<a name="ln4053">      } else {k2=nAtoms()-2; k1=nAtoms()-1;}</a>
<a name="ln4054">    }</a>
<a name="ln4055"> </a>
<a name="ln4056">    for (i=0; i&lt;eMolecule.nBonds(); i++) if ((chb &lt; 0) || ((chb1 &gt;= 0) &amp;&amp; (i != chb1))) {</a>
<a name="ln4057">        //addition of bonds from fragment to structure</a>
<a name="ln4058">        test=false;</a>
<a name="ln4059">        j1=-1;</a>
<a name="ln4060">        do { //Search, if bond I from BOND1 is presented in the fragment</a>
<a name="ln4061">          j1++;</a>
<a name="ln4062">          if (eMolecule.getBond(i)-&gt;at[0] == list[j1]) test=true;</a>
<a name="ln4063">        }  while (! (test || (j1 == (naDEF-1))));</a>
<a name="ln4064">        if (test) {  //Bond is presented-addition</a>
<a name="ln4065">          j2=-1;</a>
<a name="ln4066">          do     //Search for second atom, which makes I-th bond in fragment</a>
<a name="ln4067">            j2++;</a>
<a name="ln4068">          while (eMolecule.getBond(i)-&gt;at[1] != list[j2]);</a>
<a name="ln4069">          sb=new TSingleBond();</a>
<a name="ln4070">          j1=na+j1;            //atoms, which make the bond, renumeration</a>
<a name="ln4071">          j2=na+j2;</a>
<a name="ln4072">          sb-&gt;tb=eMolecule.getBond(i)-&gt;tb;  //attributes copy</a>
<a name="ln4073">          sb-&gt;at[0]=j1;</a>
<a name="ln4074">          sb-&gt;at[1]=j2;</a>
<a name="ln4075">          if (clearEnumerator) sb-&gt;enumerator=0;</a>
<a name="ln4076">          addBond(sb);</a>
<a name="ln4077">        }</a>
<a name="ln4078">      }</a>
<a name="ln4079"> </a>
<a name="ln4080"> </a>
<a name="ln4081">    if (chb &gt;= 0) { //bond-to-bond addition</a>
<a name="ln4082">      for (i=0; i&lt;nBonds(); i++) { //atom renumeration</a>
<a name="ln4083">        if (getBond(i)-&gt;at[0] == k1) getBond(i)-&gt;at[0]=l1;</a>
<a name="ln4084">        if (getBond(i)-&gt;at[0] == k2) getBond(i)-&gt;at[0]=l2;</a>
<a name="ln4085">        if (getBond(i)-&gt;at[1] == k1) getBond(i)-&gt;at[1]=l1;</a>
<a name="ln4086">        if (getBond(i)-&gt;at[1] == k2) getBond(i)-&gt;at[1]=l2;</a>
<a name="ln4087">      }</a>
<a name="ln4088">      //Two atoms deleted...</a>
<a name="ln4089">      delete(fAtom[nAtoms()-1]);</a>
<a name="ln4090">      delete(fAtom[nAtoms()-2]);</a>
<a name="ln4091">      fAtom.resize(nAtoms()-2);</a>
<a name="ln4092"> </a>
<a name="ln4093"> </a>
<a name="ln4094">      //two atoms, which make the bond to be added in fragment,</a>
<a name="ln4095">      //are deleted. They occupy last positions in arrays ATOM and CONN due to</a>
<a name="ln4096">      //initial sorting</a>
<a name="ln4097">      /* Contains mistake-commented to the better time</a>
<a name="ln4098">         i=0;</a>
<a name="ln4099">         do {                 //Two or three bond connection is calculated</a>
<a name="ln4100">         j=na;</a>
<a name="ln4101">         if (j &lt; nAtoms()) do {               //Search for concided atoms</a>
<a name="ln4102">         rr1=getAtom(i)-&gt;rx-getAtom(j)-&gt;rx;</a>
<a name="ln4103">         rr2=getAtom(i)-&gt;ry-getAtom(j)-&gt;ry;</a>
<a name="ln4104">         lR=sqrt(rr1*rr1+rr2*rr2);</a>
<a name="ln4105">         test=((i != j) &amp; ((lR) &lt;= 3));</a>
<a name="ln4106">         if (test) { //Concided pair of atoms found</a>
<a name="ln4107">         for (k=0; k&lt;nBonds(); k++) {</a>
<a name="ln4108">         //Re-assignment of bonds</a>
<a name="ln4109">         if (getBond(k)-&gt;at[0] == j) getBond(k)-&gt;at[0]=i;</a>
<a name="ln4110">         if (getBond(k)-&gt;at[1] == j) getBond(k)-&gt;at[1]=i;</a>
<a name="ln4111">         }</a>
<a name="ln4112">         deleteAtom(j);                          //Deletion of atom</a>
<a name="ln4113">         k=0;</a>
<a name="ln4114">         do {      //Search for bonds, which have identical pair of atom or which</a>
<a name="ln4115">         l=k;</a>
<a name="ln4116">         do {</a>
<a name="ln4117">         test=(getBond(k)-&gt;at[0] == getBond(l)-&gt;at[0])</a>
<a name="ln4118">         &amp;&amp; (getBond(k)-&gt;at[1] == getBond(l)-&gt;at[1]);</a>
<a name="ln4119">         test=test || (getBond(k)-&gt;at[0] == getBond(l)-&gt;at[1])</a>
<a name="ln4120">         &amp;&amp; (getBond(k)-&gt;at[1] == getBond(l)-&gt;at[0]);</a>
<a name="ln4121">         test=test || (getBond(l)-&gt;at[0] == getBond(l)-&gt;at[1]);</a>
<a name="ln4122">         if (test) {         //Bad bonds was found-deletion</a>
<a name="ln4123">         deleteBond(l);</a>
<a name="ln4124">         l--;</a>
<a name="ln4125">         }</a>
<a name="ln4126">         l++;</a>
<a name="ln4127">         } while (l &lt; nBonds());</a>
<a name="ln4128">         k++;</a>
<a name="ln4129">         } while (k &lt; (nBonds()-1));</a>
<a name="ln4130">         j--;</a>
<a name="ln4131">         }</a>
<a name="ln4132">         j++;</a>
<a name="ln4133">         } while (j &lt; nAtoms());</a>
<a name="ln4134">         i++;</a>
<a name="ln4135">         } while (i &lt; na);</a>
<a name="ln4136">      */</a>
<a name="ln4137">    }</a>
<a name="ln4138"> </a>
<a name="ln4139"> </a>
<a name="ln4140">    if ((buttonStatus&gt;1) &amp;&amp; (chb &lt; 0)) {</a>
<a name="ln4141">      //if fragment 'is freezed' through atom, the atom needs to be deleted</a>
<a name="ln4142">      for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln4143">        if (getBond(i)-&gt;at[0] == cha) getBond(i)-&gt;at[0]=na;</a>
<a name="ln4144">        if (getBond(i)-&gt;at[1] == cha) getBond(i)-&gt;at[1]=na;</a>
<a name="ln4145">      }</a>
<a name="ln4146">      defineAtomConn();</a>
<a name="ln4147">      deleteAtom(cha);                      //atom deleting</a>
<a name="ln4148">    }; //new values for attribute array</a>
<a name="ln4149"> </a>
<a name="ln4150">    defineAtomConn();</a>
<a name="ln4151">    //Search for badly-connected aromatic bonds</a>
<a name="ln4152">    /* commented to better time. Use alternation bond instead</a>
<a name="ln4153">       if (chb&gt;=0) {</a>
<a name="ln4154">       for (i=0; i&lt;nBonds(); i++) bTested[i]=0;</a>
<a name="ln4155">       do {</a>
<a name="ln4156">       i=0;</a>
<a name="ln4157">       do {                               //Search for badly connected atom</a>
<a name="ln4158">       test=(getAtom(i)-&gt;currvalence &gt; maxVal[getAtom(i)-&gt;na]);</a>
<a name="ln4159">       i++;</a>
<a name="ln4160">       } while (! (test || (i == nAtoms())));</a>
<a name="ln4161">       if (test) {                   //Creation aromtic bond list</a>
<a name="ln4162">       n=0;</a>
<a name="ln4163">       aList[0]=i-1;</a>
<a name="ln4164">       doubleSearch=true;</a>
<a name="ln4165">       do {</a>
<a name="ln4166">       j=nb;</a>
<a name="ln4167">       test=false;</a>
<a name="ln4168">       if (j &lt; nBonds()) do {</a>
<a name="ln4169">       test=((getBond(j)-&gt;at[0] == aList[n]) || (getBond(j)-&gt;at[1] == aList[n]));</a>
<a name="ln4170">       if (doubleSearch) test=(test &amp;&amp; (getBond(j)-&gt;tb == 2)); else test=(test &amp;&amp; (getBond(j)-&gt;tb == 1));</a>
<a name="ln4171">       test=(test &amp;&amp; (bTested[j] == 0));</a>
<a name="ln4172">       j++;</a>
<a name="ln4173">       } while (! (test || (j == nBonds())));</a>
<a name="ln4174">       if (test) {              //Addition to the aromatic list</a>
<a name="ln4175">       bList[n]=j-1;</a>
<a name="ln4176">       bTested[j]=1;</a>
<a name="ln4177">       l=getBond(j-1)-&gt;at[0];</a>
<a name="ln4178">       if (l == aList[n]) l=getBond(j-1)-&gt;at[1];</a>
<a name="ln4179">       n++;</a>
<a name="ln4180">       aList[n]=l;</a>
<a name="ln4181">       doubleSearch= ! doubleSearch;</a>
<a name="ln4182">       }</a>
<a name="ln4183">       } while (test);</a>
<a name="ln4184">       if (n &gt; 1) {                 //Alternation of aromatic chain</a>
<a name="ln4185">       for (j=1; j&lt;n; j++) {</a>
<a name="ln4186">       if ((int)Math.IEEEremainder(J,2) == 1) fBond.setTB(BList.getValue(J),(byte)1); else fBond.setTB(BList.getValue(J),(byte)2);</a>
<a name="ln4187">       }</a>
<a name="ln4188">       fAtom.setCurrValence(AList.getValue(1),(byte)(fAtom.getCurrValence(AList.getValue(1))-1));</a>
<a name="ln4189">       fAtom.setCurrValence(AList.getValue(N),(byte)(fAtom.getCurrValence(AList.getValue(N))+1));</a>
<a name="ln4190">       Test=true;</a>
<a name="ln4191">       } else {                     //Unable to alternate</a>
<a name="ln4192">       J=Nb;</a>
<a name="ln4193">       Test=false;</a>
<a name="ln4194">       if (J &lt; fBond.maxIndex()) do {                          //Search for double bond</a>
<a name="ln4195">       J=J+1;</a>
<a name="ln4196">       Test=((fBond.getAT(J,1) == AList.getValue(N)) || (fBond.getAT(J,2) == AList.getValue(N)));</a>
<a name="ln4197">       Test=(Test &amp; (fBond.getTB(J) == 2));</a>
<a name="ln4198">       } while (! (Test || (J == fBond.maxIndex())));</a>
<a name="ln4199">       if (Test) {        //Conversion of found double to single bond</a>
<a name="ln4200">       fBond.setTB(J,(byte)1);</a>
<a name="ln4201">       fAtom.setCurrValence(fBond.getAT(J,1),(byte)(fAtom.getCurrValence(fBond.getAT(J,1))-1));</a>
<a name="ln4202">       fAtom.setCurrValence(fBond.getAT(J,2),(byte)(fAtom.getCurrValence(fBond.getAT(J,2))-1));</a>
<a name="ln4203">       Test=true;</a>
<a name="ln4204">       }</a>
<a name="ln4205">       }</a>
<a name="ln4206">       }</a>
<a name="ln4207">       } while (test);</a>
<a name="ln4208">       }</a>
<a name="ln4209">    */</a>
<a name="ln4210">    return result;</a>
<a name="ln4211">  }</a>
<a name="ln4212"> </a>
<a name="ln4213"> </a>
<a name="ln4214"> </a>
<a name="ln4215">  void TEditedMolecule::addAsTemplate(TEditedMolecule&amp; fragmentMol, int thisAN, int smAN, int thisBN, int smBN, bool isAddition) {</a>
<a name="ln4216">    int nAtomsOld,nBondsOld,naDef1,naDef,i;</a>
<a name="ln4217">    bool test,test1,test2;</a>
<a name="ln4218">    std::vector&lt;int&gt; list;</a>
<a name="ln4219">    double r,scale,xOld,yOld,xNew,yNew,xCenter,yCenter;</a>
<a name="ln4220">    double r1;</a>
<a name="ln4221">    double r2;</a>
<a name="ln4222">    double xu1;</a>
<a name="ln4223">    double yu1;</a>
<a name="ln4224">    double xu2;</a>
<a name="ln4225">    double yu2;</a>
<a name="ln4226">    double cAngle;</a>
<a name="ln4227">    double rxTemp1,ryTemp1;</a>
<a name="ln4228">    int mouseButton=0;</a>
<a name="ln4229">    int n;</a>
<a name="ln4230">    double amin;</a>
<a name="ln4231"> </a>
<a name="ln4232"> </a>
<a name="ln4233"> </a>
<a name="ln4234">    if (fragmentMol.nAtoms() == 0) return;</a>
<a name="ln4235">    if ((thisAN&lt;0) &amp;&amp; (thisBN&lt;0)) {</a>
<a name="ln4236">      this-&gt;moleculeCopy(fragmentMol);</a>
<a name="ln4237">      return;</a>
<a name="ln4238">    }</a>
<a name="ln4239"> </a>
<a name="ln4240">    naDef1=smAN;</a>
<a name="ln4241">    test1=true;</a>
<a name="ln4242">    test2=false;</a>
<a name="ln4243">    xCenter=0;</a>
<a name="ln4244">    yCenter=0;</a>
<a name="ln4245">    if (thisBN &gt;= 0) {</a>
<a name="ln4246">      naDef1=fragmentMol.getBond(smBN)-&gt;at[0];</a>
<a name="ln4247">      test1=false; test2=true;</a>
<a name="ln4248">    }</a>
<a name="ln4249"> </a>
<a name="ln4250">    scale=1;</a>
<a name="ln4251">    xOld=0;</a>
<a name="ln4252">    yOld=0;</a>
<a name="ln4253">    test=fragmentMol.makeFragment(list,naDef1,-1); //creation of template's fragment</a>
<a name="ln4254">    //Scale definitions</a>
<a name="ln4255"> </a>
<a name="ln4256">    if (thisAN &gt;= 0) { //connection through atoms</a>
<a name="ln4257">      xCenter=this-&gt;getAtom(thisAN)-&gt;rx;</a>
<a name="ln4258">      yCenter=this-&gt;getAtom(thisAN)-&gt;ry;</a>
<a name="ln4259">      naDef=thisAN;</a>
<a name="ln4260">      scale=1;</a>
<a name="ln4261">      r1=0;</a>
<a name="ln4262">      r2=0;</a>
<a name="ln4263">      if (fragmentMol.getAtom(naDef1)-&gt;nb &gt; 0) {</a>
<a name="ln4264">        amin=100000000; n=1;</a>
<a name="ln4265">        for (i=0; i&lt;fragmentMol.getAtom(naDef1)-&gt;nb; i++) {</a>
<a name="ln4266">          rxTemp1=fragmentMol.getAtom(naDef1)-&gt;rx-fragmentMol.getAtom(fragmentMol.getAtom(naDef1)-&gt;ac[i])-&gt;rx;</a>
<a name="ln4267">          ryTemp1=fragmentMol.getAtom(naDef1)-&gt;ry-fragmentMol.getAtom(fragmentMol.getAtom(naDef1)-&gt;ac[i])-&gt;ry;</a>
<a name="ln4268">          r1=sqrt(rxTemp1*rxTemp1+ryTemp1*ryTemp1);</a>
<a name="ln4269">          if(r1 &lt; amin) {</a>
<a name="ln4270">            amin=r1;</a>
<a name="ln4271">            n=i;</a>
<a name="ln4272">          };</a>
<a name="ln4273">        };</a>
<a name="ln4274">        rxTemp1=fragmentMol.getAtom(naDef1)-&gt;rx-fragmentMol.getAtom(fragmentMol.getAtom(naDef1)-&gt;ac[n])-&gt;rx;</a>
<a name="ln4275">        ryTemp1=fragmentMol.getAtom(naDef1)-&gt;ry-fragmentMol.getAtom(fragmentMol.getAtom(naDef1)-&gt;ac[n])-&gt;ry;</a>
<a name="ln4276">        r1=sqrt(rxTemp1*rxTemp1+ryTemp1*ryTemp1);</a>
<a name="ln4277">      } else r1=DEFAULTBONDLENGTH;</a>
<a name="ln4278"> </a>
<a name="ln4279">      if (this-&gt;getAtom(naDef)-&gt;nb &gt; 0) {</a>
<a name="ln4280">        amin=100000000; n=1;</a>
<a name="ln4281">        for (i=0; i&lt;this-&gt;getAtom(naDef)-&gt;nb; i++) {</a>
<a name="ln4282">          rxTemp1=this-&gt;getAtom(naDef)-&gt;rx-this-&gt;getAtom(this-&gt;getAtom(naDef)-&gt;ac[i])-&gt;rx;</a>
<a name="ln4283">          ryTemp1=this-&gt;getAtom(naDef)-&gt;ry-this-&gt;getAtom(this-&gt;getAtom(naDef)-&gt;ac[i])-&gt;ry;</a>
<a name="ln4284">          r2=sqrt(rxTemp1*rxTemp1+ryTemp1*ryTemp1);</a>
<a name="ln4285">          if(r2 &lt; amin) {</a>
<a name="ln4286">            amin=r2;</a>
<a name="ln4287">            n=i;</a>
<a name="ln4288">          };</a>
<a name="ln4289">        };</a>
<a name="ln4290">        rxTemp1=this-&gt;getAtom(naDef)-&gt;rx-this-&gt;getAtom(this-&gt;getAtom(naDef)-&gt;ac[n])-&gt;rx;</a>
<a name="ln4291">        ryTemp1=this-&gt;getAtom(naDef)-&gt;ry-this-&gt;getAtom(this-&gt;getAtom(naDef)-&gt;ac[n])-&gt;ry;</a>
<a name="ln4292">        r2=sqrt(rxTemp1*rxTemp1+ryTemp1*ryTemp1);</a>
<a name="ln4293">      } else {</a>
<a name="ln4294">        if (this-&gt;nBonds() &gt; 0) r2=this-&gt;averageBondLength(); else r2=DEFAULTBONDLENGTH;</a>
<a name="ln4295">      }</a>
<a name="ln4296">      if (r1 &gt; 0) scale=r2/r1; else scale=1;</a>
<a name="ln4297">    } else if (thisBN &gt;= 0) {      //connection through bonds</a>
<a name="ln4298">      rxTemp1=fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[0])-&gt;rx-fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[1])-&gt;rx;</a>
<a name="ln4299">      ryTemp1=fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[0])-&gt;ry-fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[1])-&gt;ry;</a>
<a name="ln4300">      r1=sqrt(rxTemp1*rxTemp1+ryTemp1*ryTemp1);</a>
<a name="ln4301">      rxTemp1=this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[0])-&gt;rx-this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[1])-&gt;rx;</a>
<a name="ln4302">      ryTemp1=this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[0])-&gt;ry-this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[1])-&gt;ry;</a>
<a name="ln4303">      r2=sqrt(rxTemp1*rxTemp1+ryTemp1*ryTemp1);</a>
<a name="ln4304">      if (r1 &gt; 0) scale=r2/r1; else scale=1;</a>
<a name="ln4305">    }</a>
<a name="ln4306">    //Old coordinates definition</a>
<a name="ln4307">    if (smAN &gt;= 0) {</a>
<a name="ln4308">      xOld=fragmentMol.getAtom(smAN)-&gt;rx;</a>
<a name="ln4309">      yOld=fragmentMol.getAtom(smAN)-&gt;ry;</a>
<a name="ln4310">    }</a>
<a name="ln4311">    if (thisBN &gt;= 0) {</a>
<a name="ln4312">      xOld=(fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[0])-&gt;rx+fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[1])-&gt;rx)/2;</a>
<a name="ln4313">      yOld=(fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[0])-&gt;ry+fragmentMol.getAtom(fragmentMol.getBond(smBN)-&gt;at[1])-&gt;ry)/2;</a>
<a name="ln4314">    }</a>
<a name="ln4315"> </a>
<a name="ln4316"> </a>
<a name="ln4317">    //New coordinate definition</a>
<a name="ln4318">    if (thisBN &gt;= 0) {  //connection through bonds</a>
<a name="ln4319">      xNew=(this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[0])-&gt;rx+this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[1])-&gt;rx)/2;</a>
<a name="ln4320">      yNew=(this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[0])-&gt;ry+this-&gt;getAtom(this-&gt;getBond(thisBN)-&gt;at[1])-&gt;ry)/2;</a>
<a name="ln4321">    } else {        //connection through atoms}</a>
<a name="ln4322">      if (isAddition) { //addition of fragment</a>
<a name="ln4323">        this-&gt;unitVector(thisAN,xu1,yu1);</a>
<a name="ln4324">        if (xu1 &gt; -0.999) r=yu1/(1+xu1); else if (yu1 &gt; 0) r=1E9; else r=-1E9;</a>
<a name="ln4325">        cAngle=2*180*atan(r)/PI;</a>
<a name="ln4326">        if (true) {</a>
<a name="ln4327">          cAngle=(int)(cAngle/30);</a>
<a name="ln4328">          cAngle=30*cAngle;</a>
<a name="ln4329">          r=cAngle*PI/180;</a>
<a name="ln4330">          xu1=cos(r);</a>
<a name="ln4331">          yu1=sin(r);</a>
<a name="ln4332">        }</a>
<a name="ln4333">        xNew=r1*scale*xu1+this-&gt;getAtom(thisAN)-&gt;rx;</a>
<a name="ln4334">        yNew=r1*scale*yu1+this-&gt;getAtom(thisAN)-&gt;ry;</a>
<a name="ln4335">      } else {                     //freezing of fragment</a>
<a name="ln4336">        if (this-&gt;getAtom(thisAN)-&gt;nb == 0) {</a>
<a name="ln4337">          xu1=1; yu1=0;</a>
<a name="ln4338">        } else if (this-&gt;getAtom(thisAN)-&gt;nb == 1) {</a>
<a name="ln4339">          xu1=this-&gt;getAtom(thisAN)-&gt;rx-this-&gt;getAtom(this-&gt;getAtom(thisAN)-&gt;ac[0])-&gt;rx;</a>
<a name="ln4340">          yu1=this-&gt;getAtom(thisAN)-&gt;ry-this-&gt;getAtom(this-&gt;getAtom(thisAN)-&gt;ac[0])-&gt;ry;</a>
<a name="ln4341">          //yu1=this.fAtom.getRY(thisAN)-this.fAtom.getRY(this.fAtom.getAC(thisAN,1));</a>
<a name="ln4342">          r2=sqrt(xu1*xu1+yu1*yu1);</a>
<a name="ln4343">          if (r2 &gt; 1.0E-4) {</a>
<a name="ln4344">            xu1=xu1/r2;</a>
<a name="ln4345">            yu1=yu1/r2;</a>
<a name="ln4346">          } else {xu1=1; yu1=0;}</a>
<a name="ln4347">        } else this-&gt;unitVector(thisAN,xu1,yu1);</a>
<a name="ln4348">        if (xu1 &gt; -0.999) r=yu1/(1+xu1); else if (yu1 &gt; 0) r=1E9; else r=-1E9;</a>
<a name="ln4349">        cAngle=2*180*atan(r)/PI;</a>
<a name="ln4350">        if (true) {</a>
<a name="ln4351">          cAngle=(int)(cAngle/30);</a>
<a name="ln4352">          cAngle=30*cAngle;</a>
<a name="ln4353">          r=cAngle*PI/180;</a>
<a name="ln4354">          xu1=cos(r);</a>
<a name="ln4355">          yu1=sin(r);</a>
<a name="ln4356">        }</a>
<a name="ln4357">        xNew=this-&gt;getAtom(thisAN)-&gt;rx;</a>
<a name="ln4358">        yNew=this-&gt;getAtom(thisAN)-&gt;ry;</a>
<a name="ln4359">      }</a>
<a name="ln4360">    }</a>
<a name="ln4361"> </a>
<a name="ln4362"> </a>
<a name="ln4363">    //Angle definition</a>
<a name="ln4364">    if (thisAN &gt;= 0) {                             //connection through atoms</a>
<a name="ln4365">      fragmentMol.unitVector(smAN,xu2,yu2);</a>
<a name="ln4366">      xu2=-xu2; yu2=-yu2;</a>
<a name="ln4367">      r1=xu1*xu2+yu1*yu2;</a>
<a name="ln4368">      r2=yu1*xu2-xu1*yu2;</a>
<a name="ln4369">      nBondsOld=this-&gt;nBonds();</a>
<a name="ln4370">      nAtomsOld=this-&gt;nAtoms();</a>
<a name="ln4371">      if (isAddition) mouseButton=1; else mouseButton=2;</a>
<a name="ln4372"> </a>
<a name="ln4373">      this-&gt;addFragment(fragmentMol,list.size(),thisAN,thisBN,smBN,list,</a>
<a name="ln4374">                        xOld,yOld,xNew,yNew,scale,r1,r2,mouseButton,false);</a>
<a name="ln4375"> </a>
<a name="ln4376"> </a>
<a name="ln4377">      if (isAddition) {</a>
<a name="ln4378">        this-&gt;addBond(1,nAtomsOld,thisAN);</a>
<a name="ln4379">      } else nAtomsOld=nAtomsOld-1;</a>
<a name="ln4380">    } else if ((smBN &gt;= 0) &amp;&amp; (thisBN &gt;= 0)) {       //connection through bonds</a>
<a name="ln4381">      this-&gt;bondUnitVector(thisBN,xu1,yu1);</a>
<a name="ln4382">      fragmentMol.bondUnitVector(smBN,xu2,yu2);</a>
<a name="ln4383">      xu2=-xu2; yu2=-yu2;</a>
<a name="ln4384">      r1=xu1*xu2+yu1*yu2;</a>
<a name="ln4385">      r2=yu1*xu2-xu1*yu2;</a>
<a name="ln4386">      nBondsOld=this-&gt;nBonds();</a>
<a name="ln4387">      nAtomsOld=this-&gt;nAtoms();</a>
<a name="ln4388">      addFragment(fragmentMol,list.size(),thisAN,thisBN,smBN,list,</a>
<a name="ln4389">                  xOld,yOld,xNew,yNew,scale,r1,r2,1,false);</a>
<a name="ln4390">    }</a>
<a name="ln4391">  }</a>
<a name="ln4392"> </a>
<a name="ln4393"> </a>
<a name="ln4394">  TEditedMolecule * TEditedMolecule::extractFragment(int atomN, std::vector&lt;int&gt; * enumerator) {</a>
<a name="ln4395"> </a>
<a name="ln4396">    std::vector&lt;int&gt; list(listarSize());</a>
<a name="ln4397">    std::vector&lt;int&gt;  inverseList(listarSize());</a>
<a name="ln4398">    int i,j,k;</a>
<a name="ln4399">    bool test;</a>
<a name="ln4400">    TSingleAtom * sa;</a>
<a name="ln4401">    TSingleBond * sb;</a>
<a name="ln4402">    TEditedMolecule * result=nullptr;</a>
<a name="ln4403"> </a>
<a name="ln4404">    if ((atomN &lt; 0) || (atomN &gt;= nAtoms())) return result;</a>
<a name="ln4405">    if (enumerator != nullptr) for (i=0; i&lt;nAtoms(); i++) (*enumerator)[i]=-1;</a>
<a name="ln4406">    for (i=0; i&lt;nAtoms(); i++) inverseList[i]=-1;</a>
<a name="ln4407">    test=makeFragment(list,atomN,-1);</a>
<a name="ln4408"> </a>
<a name="ln4409"> </a>
<a name="ln4410">    if (list.size()&gt;1) for (i=0; i&lt;(list.size()-1); i++) for (j=i+1; j&lt;list.size(); j++) if (list[i]&gt;list[j]) {</a>
<a name="ln4411">            k=list[i];</a>
<a name="ln4412">            list[i]=list[j];</a>
<a name="ln4413">            list[j]=k;</a>
<a name="ln4414">          };</a>
<a name="ln4415">    for (i=0; i&lt;list.size(); i++) inverseList[list[i]]=i;</a>
<a name="ln4416"> </a>
<a name="ln4417">    result= new TEditedMolecule();</a>
<a name="ln4418">    for (i=0; i&lt;list.size(); i++) {</a>
<a name="ln4419">        sa=this-&gt;getAtom(list[i])-&gt;clone();</a>
<a name="ln4420">        result-&gt;addAtom(sa);</a>
<a name="ln4421">        if (enumerator != nullptr) (*enumerator)[list[i]]=i;</a>
<a name="ln4422">      }</a>
<a name="ln4423">    if (nBonds() &gt; 0) for (i=0; i&lt;nBonds(); i++)</a>
<a name="ln4424">                        if (inverseList[getBond(i)-&gt;at[0]] &gt;= 0) {</a>
<a name="ln4425">                          sb=getBond(i)-&gt;clone();</a>
<a name="ln4426">                          sb-&gt;at[0]=inverseList[getBond(i)-&gt;at[0]];</a>
<a name="ln4427">                          sb-&gt;at[1]=inverseList[getBond(i)-&gt;at[1]];</a>
<a name="ln4428">                          result-&gt;addBond(sb);</a>
<a name="ln4429">                        }</a>
<a name="ln4430">    return result;</a>
<a name="ln4431">  }</a>
<a name="ln4432"> </a>
<a name="ln4433"> </a>
<a name="ln4434"> </a>
<a name="ln4435">  int TEditedMolecule::prepareQuery(TSimpleMolecule &amp; sMol) {</a>
<a name="ln4436">    /*Returns error code:</a>
<a name="ln4437">      0  - no error</a>
<a name="ln4438">      -1 - input molecule is not assigned or number of atoms equal zero</a>
<a name="ln4439">      -2 - unconnected fragments were detected</a>
<a name="ln4440">      -3 - an exception take place*/</a>
<a name="ln4441"> </a>
<a name="ln4442">    TEditedMolecule * molecule1;</a>
<a name="ln4443">    int i,j,k,l;</a>
<a name="ln4444">    bool test,test1,test2,test3;</a>
<a name="ln4445">    int aQ1,aQ2,bNQ;</a>
<a name="ln4446">    int result;</a>
<a name="ln4447">    bool whileCondition,whileCondition1;</a>
<a name="ln4448"> </a>
<a name="ln4449">    result=-1;</a>
<a name="ln4450">    if (sMol.nAtoms()==0) return result;</a>
<a name="ln4451">    sMol.defineAtomConn();</a>
<a name="ln4452">    sMol.allAboutCycles();</a>
<a name="ln4453">    //Three above line instead of this line: CalculateAllIndeces(SMOl);</a>
<a name="ln4454">    moleculeCopy(sMol);</a>
<a name="ln4455"> </a>
<a name="ln4456">    result=0;</a>
<a name="ln4457"> </a>
<a name="ln4458"> </a>
<a name="ln4459">    fIsQueryPrepare=true;</a>
<a name="ln4460">    for (i=0; i&lt;nAtoms(); i++) { //isotops change</a>
<a name="ln4461">      if ((getAtom(i)-&gt;na==104) &amp;&amp; (! fIOPT11)) getAtom(i)-&gt;na=1;</a>
<a name="ln4462">      if (! fIOPT11) getAtom(i)-&gt;iz=0;</a>
<a name="ln4463">    };</a>
<a name="ln4464"> </a>
<a name="ln4465">    //Initializinf arrays</a>
<a name="ln4466">    neighbourlist *queryBK=(neighbourlist *)malloc(listarSize()*sizeof(adjustedlist));</a>
<a name="ln4467">    queryQHydr.resize(listarSize());</a>
<a name="ln4468">    queryAGer.resize(listarSize());</a>
<a name="ln4469">    queryAQTested.resize(listarSize());</a>
<a name="ln4470">    queryBQTested.resize(listarSize());</a>
<a name="ln4471">    queryBQCounter.resize(listarSize());</a>
<a name="ln4472">    queryCurrentAssignment.resize(listarSize());</a>
<a name="ln4473">    aSTested.resize(listarSize());</a>
<a name="ln4474">    bSTested.resize(listarSize());</a>
<a name="ln4475">    bSTestedStore.resize(listarSize());</a>
<a name="ln4476">    //initializing</a>
<a name="ln4477">    for (i=0; i&lt;listarSize(); i++) {</a>
<a name="ln4478">      queryBK[i].nb=0;</a>
<a name="ln4479">      queryQHydr[i]=0;</a>
<a name="ln4480">      queryAGer[i]=-1;</a>
<a name="ln4481">      queryAQTested[i]=-1;</a>
<a name="ln4482">      queryBQTested[i]=-1;</a>
<a name="ln4483">      queryBQCounter[i]=-1;</a>
<a name="ln4484">      queryCurrentAssignment[i]=-1;</a>
<a name="ln4485">      aSTested[i]=-1;</a>
<a name="ln4486">      bSTested[i]=-1;</a>
<a name="ln4487">      bSTestedStore[i]=-1;</a>
<a name="ln4488">    };</a>
<a name="ln4489">    queryEnum.resize(sMol.nAtoms());</a>
<a name="ln4490">    queryInverse.resize(sMol.nAtoms());</a>
<a name="ln4491">    for (i=0; i&lt;sMol.nAtoms(); i++) {</a>
<a name="ln4492">      queryEnum[i]=-1;</a>
<a name="ln4493">      queryInverse[i]=-1;</a>
<a name="ln4494">    };</a>
<a name="ln4495">    molecule1=new TEditedMolecule();</a>
<a name="ln4496"> </a>
<a name="ln4497">    //At this step memory was not allocated to: BK1,BEQ,AEQ. Realloction will be</a>
<a name="ln4498">    //required for three above temporary allocated arrays}</a>
<a name="ln4499">    removeHydrogen(&amp;queryQHydr,nullptr);  //Connection is calculated inside RemoveHydr}</a>
<a name="ln4500">    if (fIOPT13) atomBondChange();  //semipolar bond conversion</a>
<a name="ln4501">    defineBondConn(queryBK);</a>
<a name="ln4502">    //initial values</a>
<a name="ln4503">    for (i=0; i&lt;nAtoms(); i++) aSTested[i]=getAtom(i)-&gt;special;</a>
<a name="ln4504">    l=1;</a>
<a name="ln4505">    if (nAtoms()&gt;2) {</a>
<a name="ln4506">      j=queryBK[0].nb;</a>
<a name="ln4507">      for (i=1; i&lt;nAtoms(); i++) {</a>
<a name="ln4508">        //search for maximally coordinated non-carbon</a>
<a name="ln4509">        k=queryBK[i].nb;</a>
<a name="ln4510">        test1=k&gt;j;</a>
<a name="ln4511">        test2=(getAtom(l)-&gt;na&lt;104) &amp;&amp; (getAtom(l)-&gt;na!=6);</a>
<a name="ln4512">        test3=(getAtom(i)-&gt;na&lt;104) &amp;&amp; (getAtom(i)-&gt;na!=6);</a>
<a name="ln4513">        if ((test1 &amp;&amp; (! test2)) || (test3 &amp;&amp; (! test2))</a>
<a name="ln4514">            || (test1 &amp;&amp; test2 &amp;&amp; test3)) {</a>
<a name="ln4515">          j=k; l=i;</a>
<a name="ln4516">        };</a>
<a name="ln4517">      };</a>
<a name="ln4518">    };</a>
<a name="ln4519"> </a>
<a name="ln4520">    queryAQTested[0]=0; //Sequence for query assignment begin from the atom</a>
<a name="ln4521">    aQ1=0; bNQ=-1; test=true;</a>
<a name="ln4522">    if (nBonds()&gt;0) while (test) {  //Define sequence to match query and structure</a>
<a name="ln4523">        i=0;</a>
<a name="ln4524">        whileCondition=true;</a>
<a name="ln4525">        while (whileCondition) {</a>
<a name="ln4526">          test=(queryAQTested[i] != -1);</a>
<a name="ln4527">          if (test) {</a>
<a name="ln4528">            j=0;</a>
<a name="ln4529">            whileCondition1=true;</a>
<a name="ln4530">            if (queryBK[i].nb&gt;0) while (whileCondition1) {</a>
<a name="ln4531">                k=queryBK[i].adjusted[j];</a>
<a name="ln4532">                j++;</a>
<a name="ln4533">                test=(bSTested[k]==-1);</a>
<a name="ln4534">                whileCondition1=test || (j&gt;=queryBK[i].nb);</a>
<a name="ln4535">                whileCondition1=! whileCondition1;</a>
<a name="ln4536">              };</a>
<a name="ln4537">            if (queryBK[i].nb==0) test=false;</a>
<a name="ln4538">          };</a>
<a name="ln4539">          i++;</a>
<a name="ln4540">          whileCondition=test || (i==nAtoms());</a>
<a name="ln4541">          whileCondition=! whileCondition;</a>
<a name="ln4542">        };</a>
<a name="ln4543">        if (test) { //connected atom found</a>
<a name="ln4544">          i--;  //zero-index</a>
<a name="ln4545">          aQ2=i;</a>
<a name="ln4546">          whileCondition=true;</a>
<a name="ln4547">          while (whileCondition) {</a>
<a name="ln4548">            j=0;</a>
<a name="ln4549">            //search for query bond appended to AQ2, which has not been assigned yet</a>
<a name="ln4550">            whileCondition1=true;</a>
<a name="ln4551">            k=0;</a>
<a name="ln4552">            test1=true;</a>
<a name="ln4553">            if (queryBK[aQ2].nb&gt;0) while (whileCondition1) {</a>
<a name="ln4554">                k=queryBK[aQ2].adjusted[j];</a>
<a name="ln4555">                test1=(bSTested[k]==-1);</a>
<a name="ln4556">                j++;</a>
<a name="ln4557">                whileCondition1=test1 || (j&gt;=queryBK[aQ2].nb);</a>
<a name="ln4558">                whileCondition1=! whileCondition1;</a>
<a name="ln4559">              } else {</a>
<a name="ln4560">              k=0;</a>
<a name="ln4561">              test1=false;</a>
<a name="ln4562">            };</a>
<a name="ln4563">            if (test1)  {  //found</a>
<a name="ln4564">              bNQ++; bSTested[k]=bNQ; //store, that BNQ has been assigned</a>
<a name="ln4565">              l=getBond(k)-&gt;at[1];</a>
<a name="ln4566">              //atoms enumeration</a>
<a name="ln4567">              if (l==aQ2) {</a>
<a name="ln4568">                l=getBond(k)-&gt;at[0];</a>
<a name="ln4569">                getBond(k)-&gt;at[1]=l;</a>
<a name="ln4570">                getBond(k)-&gt;at[0]=aQ2;</a>
<a name="ln4571">              };</a>
<a name="ln4572">              test1=(queryAQTested[l]==-1);</a>
<a name="ln4573">              //Make AGER array for end-of cycle BNQ bond}</a>
<a name="ln4574">              if (test1) {</a>
<a name="ln4575">                queryAGer[bNQ]=l;</a>
<a name="ln4576">                aQ1=aQ1+1;</a>
<a name="ln4577">                queryAQTested[l]=aQ1;</a>
<a name="ln4578">                aQ2=l;</a>
<a name="ln4579">              } else aQ2=-1;</a>
<a name="ln4580">            };</a>
<a name="ln4581">            whileCondition=(! test1) || (aQ2==-1);</a>
<a name="ln4582">            whileCondition=! whileCondition;</a>
<a name="ln4583">          };</a>
<a name="ln4584">        };</a>
<a name="ln4585">      };</a>
<a name="ln4586">    //Detection of unconnected fragment}</a>
<a name="ln4587">    for (i=0; i&lt;nAtoms(); i++) if (queryAQTested[i]==-1) result=-2;</a>
<a name="ln4588">    if (result&gt;=0) {</a>
<a name="ln4589">      //Creation of inverse enumeration</a>
<a name="ln4590">      queryInverse.resize(queryAQTested.size());</a>
<a name="ln4591">      for (j=0; j&lt;queryInverse.size(); j++) queryInverse[j]=queryAQTested[j];</a>
<a name="ln4592">      //Enumeration of atoms and bonds in query in order of assignment}</a>
<a name="ln4593">      molecule1-&gt;moleculeCopy(*this);</a>
<a name="ln4594">      for (i=0; i&lt;nAtoms(); i++) molecule1-&gt;getAtom(queryAQTested[i])-&gt;atomCopy(this-&gt;getAtom(i));</a>
<a name="ln4595">      for (i=0; i&lt;nAtoms(); i++) queryBQTested[queryAQTested[i]]=queryQHydr[i];</a>
<a name="ln4596">      for (i=0; i&lt;queryQHydr.size(); i++) queryQHydr[i]=queryBQTested[i];</a>
<a name="ln4597">      //Do NOT enumeate QueryEnum - it will be done later throgh QueryInverse!!!}</a>
<a name="ln4598">      if (nBonds()&gt;0) for (i=0; i&lt;nBonds(); i++) if (queryAGer[i] != -1) queryAGer[i]=queryAQTested[queryAGer[i]];</a>
<a name="ln4599">      if (nBonds()&gt;0) for (i=0; i&lt;nBonds(); i++) molecule1-&gt;getBond(bSTested[i])-&gt;bondCopy(this-&gt;getBond(i));</a>
<a name="ln4600">      bSTestedStore.resize(bSTested.size());</a>
<a name="ln4601">      for (i=0; i&lt;bSTestedStore.size(); i++) bSTestedStore[i]=bSTested[i];</a>
<a name="ln4602">      if (nBonds()&gt;0) for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln4603">          molecule1-&gt;getBond(i)-&gt;at[0]=queryAQTested[molecule1-&gt;getBond(i)-&gt;at[0]];</a>
<a name="ln4604">          molecule1-&gt;getBond(i)-&gt;at[1]=queryAQTested[molecule1-&gt;getBond(i)-&gt;at[1]];</a>
<a name="ln4605">        };</a>
<a name="ln4606">      //Enumeration of</a>
<a name="ln4607">      this-&gt;moleculeCopy(*molecule1);</a>
<a name="ln4608">      defineAtomConn();</a>
<a name="ln4609">      //Store NO OTHER atom attribute</a>
<a name="ln4610">      for (i=0; i&lt;nAtoms(); i++) getAtom(queryAQTested[i])-&gt;special=aSTested[i];</a>
<a name="ln4611">      defineBondConn(queryBK);</a>
<a name="ln4612">      j=0;</a>
<a name="ln4613">      //Search for last non-special atom in query}</a>
<a name="ln4614">      queryStereoQ=stereoBondChange(); //Stereo bond conversion</a>
<a name="ln4615">    };</a>
<a name="ln4616">    delete(molecule1);</a>
<a name="ln4617">    free(queryBK);</a>
<a name="ln4618">    return result;</a>
<a name="ln4619">  };</a>
<a name="ln4620"> </a>
<a name="ln4621"> </a>
<a name="ln4622">  void TEditedMolecule::removeHydrogen(std::vector&lt;int&gt; * qHydr, std::vector&lt;int&gt; * qEnumerator) {</a>
<a name="ln4623"> </a>
<a name="ln4624">    //Explicitly-defined hydrogens are removed from the structure, which is characte-</a>
<a name="ln4625">    //rized of total number of atoms NA, total number of bonds NB, atom's attribute</a>
<a name="ln4626">    //array ATOM, bond's attribute array BOND, bond-connection matrix invariants</a>
<a name="ln4627">    //ONN. Number of explicitly-defined hydrogens for each atom are stored in</a>
<a name="ln4628">    //QHYDR. If QUERYLABEL points on some atom, the value is recalculated so that</a>
<a name="ln4629">    //the same atom is pointed after hydrogens have been removed from the structure</a>
<a name="ln4630"> </a>
<a name="ln4631">    //NB! QueryLabel should be array!}</a>
<a name="ln4632">    int i,j,i1;</a>
<a name="ln4633">    bool test,test1,test2;</a>
<a name="ln4634"> </a>
<a name="ln4635">    if (qEnumerator != nullptr) {</a>
<a name="ln4636">      if (qEnumerator-&gt;size() != nAtoms()) qEnumerator-&gt;resize(nAtoms());</a>
<a name="ln4637">      for (i=0; i&lt;qEnumerator-&gt;size(); i++) (*qEnumerator)[i]=i;</a>
<a name="ln4638">    };</a>
<a name="ln4639">    for (i=0; i&lt;nAtoms(); i++) {</a>
<a name="ln4640">      if (qHydr != nullptr) (*qHydr)[i]=0;</a>
<a name="ln4641">      if ((! fIOPT11) &amp;&amp; (getAtom(i)-&gt;na==104)) getAtom(i)-&gt;na=1;</a>
<a name="ln4642">      //D-&gt;H if no isotop sensitivity}</a>
<a name="ln4643">    };</a>
<a name="ln4644">    i=0;</a>
<a name="ln4645">    test1=false;</a>
<a name="ln4646">    if (nAtoms()&gt;0) while (i&lt;nAtoms()) {</a>
<a name="ln4647">        if (getAtom(i)-&gt;na==1) { //hydrogen found</a>
<a name="ln4648">          test1=true; j=0; i1=0; test2=true;</a>
<a name="ln4649">          if (nBonds()&gt;0) while (test2) { //search for corresponding bond and hydrogen's neighbour detection</a>
<a name="ln4650">              test=(getBond(j)-&gt;at[0]==i) || (getBond(j)-&gt;at[1]==i);</a>
<a name="ln4651">              if (test) {</a>
<a name="ln4652">                i1=getBond(j)-&gt;at[0];</a>
<a name="ln4653">                if (i1==i) i1=getBond(j)-&gt;at[1];</a>
<a name="ln4654">              };</a>
<a name="ln4655">              test2=test || (j==nBonds());</a>
<a name="ln4656">              test2=! test1;</a>
<a name="ln4657">              j++;</a>
<a name="ln4658">            };</a>
<a name="ln4659"> </a>
<a name="ln4660">          deleteAtom(i);</a>
<a name="ln4661">          if (qHydr != nullptr &amp;&amp; i &lt; nAtoms() - 1) deleteIntElement(qHydr,i);</a>
<a name="ln4662"> </a>
<a name="ln4663">          if (i1&gt;i)  i1=i1-1;</a>
<a name="ln4664">          //shift of attribute's arrays</a>
<a name="ln4665">          if (qEnumerator != nullptr) {</a>
<a name="ln4666">            for (j=0; j&lt;qEnumerator-&gt;size(); j++) {</a>
<a name="ln4667">              if ((*qEnumerator)[j] == i) (*qEnumerator)[j]=-i1; else</a>
<a name="ln4668">                if ((*qEnumerator)[j] &gt; i)  (*qEnumerator)[j]=(*qEnumerator)[j]-1; else</a>
<a name="ln4669">                  if (((*qEnumerator)[j] &lt; 0) &amp;&amp; (abs((*qEnumerator)[j]) &gt; i)) (*qEnumerator)[j]=(*qEnumerator)[j]+1;</a>
<a name="ln4670">            };</a>
<a name="ln4671">          };</a>
<a name="ln4672">          if (i1 &gt; 0 &amp;&amp; qHydr != nullptr) (*qHydr)[i1]=(*qHydr)[i1]+1;</a>
<a name="ln4673">          //counter of explicitly defined hydrogens</a>
<a name="ln4674">          i--;</a>
<a name="ln4675">        };</a>
<a name="ln4676">        i++;</a>
<a name="ln4677">      };</a>
<a name="ln4678">    if (test1) {</a>
<a name="ln4679">      defineAtomConn();</a>
<a name="ln4680">      //Inverse enumerator creation... New QA-&gt;OldQA array}</a>
<a name="ln4681">      if (qEnumerator != nullptr) {</a>
<a name="ln4682">        //??? Is it required ?}</a>
<a name="ln4683">      };</a>
<a name="ln4684">    };</a>
<a name="ln4685">  };</a>
<a name="ln4686"> </a>
<a name="ln4687">  void TEditedMolecule::atomBondChange() {</a>
<a name="ln4688">    //substitutes the semipolar bond with double. NBONDS-total number of bonds,</a>
<a name="ln4689">    //BOND-bond's attributes, ATOM-atom's attributes}</a>
<a name="ln4690">    int i;</a>
<a name="ln4691">    int ca,cb;</a>
<a name="ln4692"> </a>
<a name="ln4693">    if (nBonds()==0) return;</a>
<a name="ln4694">    for (i=0; i&lt;nBonds(); i++) {</a>
<a name="ln4695">      ca=getAtom(getBond(i)-&gt;at[0])-&gt;nc;</a>
<a name="ln4696">      cb=getAtom(getBond(i)-&gt;at[1])-&gt;nc;</a>
<a name="ln4697">      if ((((ca&lt;0) &amp;&amp; (cb&gt;0)) || ((ca&gt;0) &amp;&amp; (cb&lt;0))) &amp;&amp; ((getBond(i)-&gt;tb&lt;3) || (getBond(i)-&gt;tb&gt;8))) {</a>
<a name="ln4698">        if (ca&lt;0) {</a>
<a name="ln4699">          getAtom(getBond(i)-&gt;at[0])-&gt;nc=ca+1;</a>
<a name="ln4700">          getAtom(getBond(i)-&gt;at[1])-&gt;nc=cb-1;</a>
<a name="ln4701">        };</a>
<a name="ln4702">        if (ca&gt;0) {</a>
<a name="ln4703">          getAtom(getBond(i)-&gt;at[0])-&gt;nc=ca-1;</a>
<a name="ln4704">          getAtom(getBond(i)-&gt;at[1])-&gt;nc=cb+1;</a>
<a name="ln4705">        };</a>
<a name="ln4706">        if (getBond(i)-&gt;tb&lt;3) getBond(i)-&gt;tb=getBond(i)-&gt;tb+1; else getBond(i)-&gt;tb=2;</a>
<a name="ln4707">      };</a>
<a name="ln4708">    };</a>
<a name="ln4709">  };</a>
<a name="ln4710"> </a>
<a name="ln4711">  bool TEditedMolecule::stereoBondChange() {</a>
<a name="ln4712">    //Subtitute stereo bonds with single. On output TEST has TRUE value, if at</a>
<a name="ln4713">    //least one stereo bond was detected in structure with bond attributes BOND</a>
<a name="ln4714">    //nd total number of bonds NBONDS</a>
<a name="ln4715">    int i;</a>
<a name="ln4716">    bool result;</a>
<a name="ln4717"> </a>
<a name="ln4718">    result=false;</a>
<a name="ln4719">    if ((nBonds()==0) || (fIOPT12==2)) return result;</a>
<a name="ln4720">    //If Exact Stereo Search-no substitution</a>
<a name="ln4721">    for (i=0; i&lt;nBonds(); i++)  {</a>
<a name="ln4722">      if (fIOPT12==3) {</a>
<a name="ln4723">        //If Replace Stereo Search-only EITHER bond substitution}</a>
<a name="ln4724">        if (getBond(i)-&gt;tb==11) getBond(i)-&gt;tb=1;</a>
<a name="ln4725">        if (getBond(i)-&gt;tb&gt;=9) result=true;</a>
<a name="ln4726">      };</a>
<a name="ln4727">      if (fIOPT12==1) if (getBond(i)-&gt;tb&gt;=9) getBond(i)-&gt;tb=1;</a>
<a name="ln4728">      //If No Stereo search-all bonds substitution</a>
<a name="ln4729">    };</a>
<a name="ln4730">    return result;</a>
<a name="ln4731">  };</a>
<a name="ln4732"> </a>
<a name="ln4733">  void TEditedMolecule::directBondAss(int&amp; bnq, bool&amp; test, bool&amp; test1, bool const* const* beq,</a>
<a name="ln4734">                                      bool const* const* aeq, std::vector&lt;int&gt;&amp; bqcounter, std::vector&lt;int&gt;&amp; aqtested,</a>
<a name="ln4735">                                      std::vector&lt;int&gt;&amp; bstested, std::vector&lt;int&gt;&amp; bqtested, std::vector&lt;int&gt;&amp; astested,</a>
<a name="ln4736">                                      const std::vector&lt;int&gt; ager, const neighbourlist *bsconn, TSimpleMolecule * smol) {</a>
<a name="ln4737">    //Assign a structure atom to query atom. Variables:</a>
<a name="ln4738">    //BNQ-query bond's number, which needs to be assigned</a>
<a name="ln4739">    //BEQ,AEQ-boolean matrix, contains list of equivalent bonds</a>
<a name="ln4740">    //BSCONN-for each atom containes list of connected bonds in structure</a>
<a name="ln4741">    //QBOND,SBOND-bond's attributes for query and structure respectively</a>
<a name="ln4742">    //ASTESTED- I-th element of the array contains the query atom's number, which</a>
<a name="ln4743">    //          has been assigned to I-th atom of structure (=0-no assignment)</a>
<a name="ln4744">    //AQTESTED- I-th element of the array contains the structure atom's number,</a>
<a name="ln4745">    //          which has been assigned to I-th atom of query (=0-no assignment)</a>
<a name="ln4746">    //BSTESTED- I-th element of the array contains the query bond's number, which</a>
<a name="ln4747">    //          has been assigned to I-th bond of structure (=0-no assignment)</a>
<a name="ln4748">    //BQTESTED- I-th element of the array contains the structure bond's number,</a>
<a name="ln4749">    //          which has been assigned to I-th bond of query (=0-no assignment)</a>
<a name="ln4750">    //BQCOUNTER-for each query bond contains bond's number in array BSCONN(!)-con-</a>
<a name="ln4751">    //          nected to corresponding structure atom bonds. The structure bonds</a>
<a name="ln4752">    //          in array BSCONN with less than or equal number have been tested on</a>
<a name="ln4753">    //          assignment, with above number-no.</a>
<a name="ln4754">    //AGER-for each query bond contains query atom's number, which must be generated</a>
<a name="ln4755">    //     at assignment of this bond to structure or zero, if no atom may be gene-</a>
<a name="ln4756">    //     rated. This array is used for cyclic conditions definition (last bond in</a>
<a name="ln4757">    //     the cycle must be created between already-defined query atoms-no genera-</a>
<a name="ln4758">    //     tion).</a>
<a name="ln4759">    //TEST-on output contains TRUE, if assignment was successful, FALSE otherwise</a>
<a name="ln4760">    //TEST1-on output contains TRUE if all bonds, connected to last assigned atom</a>
<a name="ln4761">    //      in structure will be tested, FALSE otherwise. If TEST1=TRUE and TEST=</a>
<a name="ln4762">    //      FALSE it means, that last atom in structure had been unproperly assigned</a>
<a name="ln4763">    //      -backstep is required to reassign the atom.*/</a>
<a name="ln4764">    int bns,bs,as1,as2,aq2,aq1;</a>
<a name="ln4765">    bool whiletest;</a>
<a name="ln4766"> </a>
<a name="ln4767">    test=false;</a>
<a name="ln4768">    aq1=getBond(bnq)-&gt;at[0];      //first query atom, already assigned</a>
<a name="ln4769">    as1=aqtested[aq1];  //corresponding first structure atom</a>
<a name="ln4770">    if (as1&lt;0) return;</a>
<a name="ln4771">    aq2=getBond(bnq)-&gt;at[1];      //second query atom}</a>
<a name="ln4772">    bs=bqcounter[bnq];</a>
<a name="ln4773">    bns=0; as2=0;</a>
<a name="ln4774">    whiletest=true;</a>
<a name="ln4775">    if (bs&lt;bsconn[as1].nb) while (whiletest) {</a>
<a name="ln4776">        bns=bsconn[as1].adjusted[bs];  //structure bond, assigned to query BNQ}</a>
<a name="ln4777">        //if structure bond hasn't already been assigned, and query and structure</a>
<a name="ln4778">        //bonds are equivalent, then...</a>
<a name="ln4779">        if (bstested[bns]&lt;0) if (beq[bns][bnq]) {</a>
<a name="ln4780">            as2=smol-&gt;getBond(bns)-&gt;at[0];                  //second structure atom}</a>
<a name="ln4781">            if (as2==as1) as2=smol-&gt;getBond(bns)-&gt;at[1];</a>
<a name="ln4782">            test=false;</a>
<a name="ln4783">            //if no new structure atom assignment must be generated-checking, if AS2</a>
<a name="ln4784">            // equal already defined atom for query atom AQ2}</a>
<a name="ln4785">            if ((ager[bnq]&lt;0) &amp;&amp; (astested[as2]&gt;=0)) test=(aqtested[aq2]==as2);</a>
<a name="ln4786">            //if new atom in structure must be assigned-testing equivalence with</a>
<a name="ln4787">            //corresponding query</a>
<a name="ln4788">            if ((ager[bnq]&gt;=0) &amp;&amp; (astested[as2]&lt;0)) test=aeq[as2][aq2];</a>
<a name="ln4789">          };</a>
<a name="ln4790">        bs=bs+1;</a>
<a name="ln4791">        whiletest=(bs==bsconn[as1].nb) || test;</a>
<a name="ln4792">        whiletest=! whiletest;</a>
<a name="ln4793">      }; //until(BS=BSCONN[AS1].NB) or TEST;</a>
<a name="ln4794">    //until all list of structure bonds will be exausted or success in assignment</a>
<a name="ln4795">    if (test) { //Success</a>
<a name="ln4796">      if (ager[bnq]&gt;=0) {    //if new atom has been assigned-store assignment}</a>
<a name="ln4797">        aqtested[aq2]=as2; astested[as2]=aq2;</a>
<a name="ln4798">      };</a>
<a name="ln4799">      bstested[bns]=bnq; //store assignment of bonds}</a>
<a name="ln4800">      bqtested[bnq]=bns;</a>
<a name="ln4801">    };</a>
<a name="ln4802">    bqcounter[bnq]=bs;    //last used structure bond's number in SCONN array}</a>
<a name="ln4803">    test1=(bs==bsconn[as1].nb); //test, if SCONN for atom given is exausted}</a>
<a name="ln4804">  };</a>
<a name="ln4805"> </a>
<a name="ln4806">  bool TEditedMolecule::allQueryPresent(const std::vector&lt;int&gt; qA, const std::vector&lt;int&gt; qB,</a>
<a name="ln4807">                                        int nA, int nB) {</a>
<a name="ln4808">    //the function returns TRUE if for all query atoms and bonds the equivalent</a>
<a name="ln4809">    //structure atom (bond) can be found, FALSE otherwise. QA-for each query atom</a>
<a name="ln4810">    //contains '1' if a structure atom may be associated with the query, '0' other-</a>
<a name="ln4811">    //wise. The same is true for bond's list QB. NA-total number of query atoms,</a>
<a name="ln4812">    //NB-total number of query bonds</a>
<a name="ln4813">    int i;</a>
<a name="ln4814">    bool test,whiletest;</a>
<a name="ln4815"> </a>
<a name="ln4816">    i=0;</a>
<a name="ln4817">    if (nA&lt;0) return false;</a>
<a name="ln4818">    whiletest=true;</a>
<a name="ln4819">    test=false;</a>
<a name="ln4820">    while (whiletest) {</a>
<a name="ln4821">      test=qA[i]==1;</a>
<a name="ln4822">      i++;</a>
<a name="ln4823">      whiletest=(! test) || (i==nA);</a>
<a name="ln4824">      whiletest=! whiletest;</a>
<a name="ln4825">    };</a>
<a name="ln4826">    if (test &amp;&amp; (nB&gt;=0)) {</a>
<a name="ln4827">      i=0;</a>
<a name="ln4828">      whiletest=false;</a>
<a name="ln4829">      while (whiletest) {</a>
<a name="ln4830">        test=qB[i]==1;</a>
<a name="ln4831">        i++;</a>
<a name="ln4832">        whiletest=(! test) || (i==nB);</a>
<a name="ln4833">        whiletest=! whiletest;</a>
<a name="ln4834">      };</a>
<a name="ln4835">    };</a>
<a name="ln4836">    return test;</a>
<a name="ln4837">  };</a>
<a name="ln4838"> </a>
<a name="ln4839">  bool TEditedMolecule::fragmentSearch(TEditedMolecule * molecule1, std::vector&lt;int&gt;* bondLabel) {</a>
<a name="ln4840">    int cycleNumber;</a>
<a name="ln4841">    int j,k,l,m,mm;</a>
<a name="ln4842">    bool test;</a>
<a name="ln4843">    bool test1;</a>
<a name="ln4844">    bool test2,test3;</a>
<a name="ln4845">    int aq1,aq2,as1,as2,j1,i1;</a>
<a name="ln4846">    int ii;</a>
<a name="ln4847">    bool result=false;</a>
<a name="ln4848">    bool whiletest1,whiletest2;</a>
<a name="ln4849"> </a>
<a name="ln4850">    if (molecule1 == nullptr || !fIsQueryPrepare) return result;</a>
<a name="ln4851">    if (molecule1-&gt;nAtoms()==0) return result;</a>
<a name="ln4852"> </a>
<a name="ln4853">    if (molecule1-&gt;listarSize()&gt;aSTested.size()) aSTested.resize(molecule1-&gt;listarSize());</a>
<a name="ln4854">    if (molecule1-&gt;listarSize()&gt;bSTested.size()) bSTested.resize(molecule1-&gt;listarSize());</a>
<a name="ln4855">    if (molecule1-&gt;listarSize()&gt;queryQHydr.size()) queryQHydr.resize(molecule1-&gt;listarSize());</a>
<a name="ln4856">    if (molecule1-&gt;listarSize()&gt;queryAQTested.size()) queryAQTested.resize(molecule1-&gt;listarSize());</a>
<a name="ln4857">    if (molecule1-&gt;listarSize()&gt;queryBQTested.size()) queryBQTested.resize(molecule1-&gt;listarSize());</a>
<a name="ln4858">    if (molecule1-&gt;listarSize()&gt;queryCurrentAssignment.size()) queryCurrentAssignment.resize(molecule1-&gt;listarSize());</a>
<a name="ln4859">    if (this-&gt;listarSize()&gt;queryAQTested.size()) queryAQTested.resize(this-&gt;listarSize());</a>
<a name="ln4860"> </a>
<a name="ln4861">    // Initialise aEQ, a 2D bool matrix of size [molecule1-&gt;nAtoms()][nAtoms()] and set all to false</a>
<a name="ln4862">    bool **aEQ = (bool **)malloc(molecule1-&gt;nAtoms()*sizeof(bool *));</a>
<a name="ln4863">    for (int i=0; i&lt;molecule1-&gt;nAtoms(); ++i) {</a>
<a name="ln4864">      aEQ[i] = (bool *)malloc(nAtoms()*sizeof(bool ));</a>
<a name="ln4865">      for (int j=0; j&lt;nAtoms(); ++j)</a>
<a name="ln4866">        aEQ[i][j] = false;</a>
<a name="ln4867">    }</a>
<a name="ln4868">    // Initialise bEQ, a 2D bool matrix of size [molecule1-&gt;nBonds()][nBonds()] and set all to false</a>
<a name="ln4869">    bool **bEQ = (bool **)malloc(molecule1-&gt;nBonds()*sizeof(bool *));</a>
<a name="ln4870">    for (int i=0; i&lt;molecule1-&gt;nBonds(); ++i) {</a>
<a name="ln4871">      bEQ[i] = (bool *)malloc(nBonds()*sizeof(bool ));</a>
<a name="ln4872">      for (int j=0; j&lt;nBonds(); ++j)</a>
<a name="ln4873">        bEQ[i][j] = false;</a>
<a name="ln4874">    }</a>
<a name="ln4875"> </a>
<a name="ln4876">    cycleNumber=0;</a>
<a name="ln4877"> </a>
<a name="ln4878">    molecule1-&gt;fIOPT11=fIOPT11;</a>
<a name="ln4879">    molecule1-&gt;fIOPT12=fIOPT13;</a>
<a name="ln4880">    molecule1-&gt;fIOPT13=fIOPT13;</a>
<a name="ln4881">    test2 = true;</a>
<a name="ln4882"> </a>
<a name="ln4883">    //{R/S/Z/E description are removed: they are not used in substructure search}</a>
<a name="ln4884">    if (fIOPT13) molecule1-&gt;atomBondChange(); //Semipolar bond conversion</a>
<a name="ln4885">    molecule1-&gt;defineAtomConn();</a>
<a name="ln4886">    neighbourlist *structureBK = (neighbourlist *)malloc(molecule1-&gt;nAtoms() * sizeof(adjustedlist));</a>
<a name="ln4887">    molecule1-&gt;defineBondConn(structureBK);</a>
<a name="ln4888">    // GRH: 2011-10-15 unused via clang static analyzer</a>
<a name="ln4889">    // stereoS=molecule1-&gt;stereoBondChange(); //Stereo bond conversion}</a>
<a name="ln4890">    for (j=0; j&lt;molecule1-&gt;nAtoms(); j++) {</a>
<a name="ln4891">      //Isotops conversion}</a>
<a name="ln4892">      if ((molecule1-&gt;getAtom(j)-&gt;na==104) &amp;&amp; (! fIOPT11)) molecule1-&gt;getAtom(j)-&gt;na=1;</a>
<a name="ln4893">      if (! fIOPT11) molecule1-&gt;getAtom(j)-&gt;iz=0;</a>
<a name="ln4894">      bSTested[j]=0;  //bsTested contains nu. explicit hydrogens - so 0 is fine!</a>
<a name="ln4895">    };</a>
<a name="ln4896">    for (j=0; j&lt;molecule1-&gt;nAtoms(); j++) if (molecule1-&gt;getAtom(j)-&gt;na==1)</a>
<a name="ln4897">                                            if (molecule1-&gt;getAtom(j)-&gt;nb&gt;0) for (k=0; k&lt;molecule1-&gt;getAtom(j)-&gt;nb; k++) {</a>
<a name="ln4898">                                                //Formation of list explicitly-defined hydrogens}</a>
<a name="ln4899">                                                l=molecule1-&gt;getAtom(j)-&gt;ac[k];</a>
<a name="ln4900">                                                bSTested[l]=bSTested[l]+1;</a>
<a name="ln4901">                                              };</a>
<a name="ln4902">    for (k=0; k&lt;nAtoms(); k++) aSTested[k]=-1;</a>
<a name="ln4903">    if (nAtoms()==1) {</a>
<a name="ln4904">      //Partial case - if single atom was defined}</a>
<a name="ln4905">      test2=false;</a>
<a name="ln4906">      j=0;</a>
<a name="ln4907">      whiletest1=true;</a>
<a name="ln4908">      if (molecule1-&gt;nAtoms()&gt;0) while (whiletest1) {</a>
<a name="ln4909">          test2=TSingleAtom::atomEquivalent(molecule1-&gt;getAtom(j),getAtom(0),bSTested[j],queryQHydr[0],fIOPT10,fIOPT11);</a>
<a name="ln4910">          //Addition for aromatic search}</a>
<a name="ln4911">          if (test2 &amp;&amp; ((getAtom(0)-&gt;special &amp; AROMATIC_MASK)!=0) ){</a>
<a name="ln4912">            test2=false;</a>
<a name="ln4913">            for (m=0; m&lt;=structureBK[j].nb; m++) {</a>
<a name="ln4914">              mm=structureBK[j].adjusted[m];</a>
<a name="ln4915">              if ((molecule1-&gt;getBond(mm)-&gt;db==2) || (molecule1-&gt;getBond(mm)-&gt;db==3)) {</a>
<a name="ln4916">                test2=true;</a>
<a name="ln4917">                break;</a>
<a name="ln4918">              };</a>
<a name="ln4919">            };</a>
<a name="ln4920">          };</a>
<a name="ln4921">          //End addition}</a>
<a name="ln4922">          if (test2) {</a>
<a name="ln4923">            if (queryEnum.size()&lt;1) queryEnum.resize(1);</a>
<a name="ln4924">            queryEnum[0]=0;</a>
<a name="ln4925">            if (queryAQTested.size()&lt;1) queryAQTested.resize(1);</a>
<a name="ln4926">            queryAQTested[0]=j;</a>
<a name="ln4927">          };</a>
<a name="ln4928">          j++;</a>
<a name="ln4929">          whiletest1=test2 || (j==molecule1-&gt;nAtoms());</a>
<a name="ln4930">          whiletest1=! whiletest1;</a>
<a name="ln4931">        };</a>
<a name="ln4932">    } else if (nBonds()==0) test2=false; else {</a>
<a name="ln4933">      //General case - substructure search</a>
<a name="ln4934">      if (fIncludedList != nullptr) {</a>
<a name="ln4935">        for (j=0; j&lt;molecule1-&gt;nAtoms(); j++) for (k=0; k&lt;nAtoms(); k++) aEQ[j][k]=false;</a>
<a name="ln4936">        for (k=0; k&lt;nAtoms(); k++) {</a>
<a name="ln4937">          j=(*fIncludedList)[k];</a>
<a name="ln4938">          aEQ[j][k]=true;</a>
<a name="ln4939">          aSTested[k]=1;</a>
<a name="ln4940">        };</a>
<a name="ln4941">      } else {</a>
<a name="ln4942">        for (j=0; j&lt;molecule1-&gt;nAtoms(); j++) for (k=0; k&lt;nAtoms(); k++) {</a>
<a name="ln4943">            //Creation of atom-equivalent matrix}</a>
<a name="ln4944"> </a>
<a name="ln4945">            test3=(TSingleAtom::atomEquivalent(molecule1-&gt;getAtom(j),getAtom(k),bSTested[j],</a>
<a name="ln4946">                                               queryQHydr[k],fIOPT10,fIOPT11) &amp;&amp; (getAtom(k)-&gt;nb&lt;=molecule1-&gt;getAtom(j)-&gt;nb));</a>
<a name="ln4947"> </a>
<a name="ln4948">            //Addition for aromatic search</a>
<a name="ln4949">            if (test3 &amp;&amp; ((getAtom(k)-&gt;special &amp; AROMATIC_MASK) !=0)) {</a>
<a name="ln4950">              test3=false;</a>
<a name="ln4951">              for (m=0; m&lt;structureBK[j].nb; m++) {</a>
<a name="ln4952">                mm=structureBK[j].adjusted[m];</a>
<a name="ln4953">                if ((molecule1-&gt;getBond(mm)-&gt;db==2) || (molecule1-&gt;getBond(mm)-&gt;db==3)) {</a>
<a name="ln4954">                  test3=true;</a>
<a name="ln4955">                  break;</a>
<a name="ln4956">                };</a>
<a name="ln4957">              };</a>
<a name="ln4958">            };</a>
<a name="ln4959">            aEQ[j][k]=test3;</a>
<a name="ln4960">            if (test3) aSTested[k]=1;</a>
<a name="ln4961">          };</a>
<a name="ln4962">      };</a>
<a name="ln4963"> </a>
<a name="ln4964">      for (j=0; j&lt;nBonds(); j++) queryAQTested[j]=0;</a>
<a name="ln4965">      for (j=0; j&lt;molecule1-&gt;nBonds(); j++) for (k=0; k&lt;nBonds(); k++) {</a>
<a name="ln4966">          //Creation of bond-equivalent matrix</a>
<a name="ln4967">          aq1=getBond(k)-&gt;at[0];   aq2=getBond(k)-&gt;at[1];</a>
<a name="ln4968">          as1=molecule1-&gt;getBond(j)-&gt;at[0]; as2=molecule1-&gt;getBond(j)-&gt;at[1];</a>
<a name="ln4969">          test2=(aEQ[as1][aq1] &amp;&amp; aEQ[as2][aq2]) || (aEQ[as1][aq2] &amp;&amp; aEQ[as2][aq1]);</a>
<a name="ln4970">          if (test2) {</a>
<a name="ln4971">            test3=TSingleBond::bondEquivalent(molecule1-&gt;getBond(j),getBond(k));</a>
<a name="ln4972">            bEQ[j][k]=test3;</a>
<a name="ln4973">            if (test3) queryAQTested[k]=1;</a>
<a name="ln4974">          } else bEQ[j][k]=false;</a>
<a name="ln4975">        };</a>
<a name="ln4976">      //Check, if all query atoms has a partner in structure</a>
<a name="ln4977">      test2=allQueryPresent(aSTested,queryAQTested,nAtoms(),nBonds());</a>
<a name="ln4978">      if (test2) {</a>
<a name="ln4979">        j1=0;</a>
<a name="ln4980">        for (k=1; k&lt;molecule1-&gt;nAtoms(); k++) if (aEQ[k][0]) {</a>
<a name="ln4981">            //Collection of structure atoms, which may be associated with first query atom</a>
<a name="ln4982">            j=0;</a>
<a name="ln4983">            whiletest1=true;</a>
<a name="ln4984">            while (whiletest1) {</a>
<a name="ln4985">              test=bEQ[structureBK[k].adjusted[j]][0];</a>
<a name="ln4986">              if (test) {</a>
<a name="ln4987">                queryCurrentAssignment[j1]=k;</a>
<a name="ln4988">                j1++;</a>
<a name="ln4989">              };</a>
<a name="ln4990">              j++;</a>
<a name="ln4991">              whiletest1=test || (j==structureBK[k].nb);</a>
<a name="ln4992">              whiletest1=! whiletest1;</a>
<a name="ln4993">            };</a>
<a name="ln4994">          };</a>
<a name="ln4995">        i1=0;</a>
<a name="ln4996">        whiletest1=true;</a>
<a name="ln4997">        if (j1&gt;0) while (whiletest1) { //for each structure, which may be assigned to 1-st query</a>
<a name="ln4998">            for (j=0; j&lt;nAtoms(); j++) queryAQTested[j]=-1; //array initializing</a>
<a name="ln4999">            for (j=0; j&lt;nBonds(); j++) queryBQCounter[j]=0;</a>
<a name="ln5000">            for (j=0; j&lt;nBonds(); j++) queryBQTested[j]=-1;</a>
<a name="ln5001">            for (j=0; j&lt;molecule1-&gt;nBonds(); j++) bSTested[j]=-1;</a>
<a name="ln5002">            for (j=0; j&lt;molecule1-&gt;nAtoms(); j++) aSTested[j]=-1;</a>
<a name="ln5003">            queryAQTested[0]=queryCurrentAssignment[i1];</a>
<a name="ln5004">            aSTested[queryCurrentAssignment[i1]]=0;</a>
<a name="ln5005">            ii=0;</a>
<a name="ln5006">            whiletest2=true;</a>
<a name="ln5007">            while (whiletest2) { //start recursion</a>
<a name="ln5008">              directBondAss(ii,test,test1,bEQ,aEQ,queryBQCounter,queryAQTested,bSTested,</a>
<a name="ln5009">                            queryBQTested,aSTested,queryAGer,structureBK,molecule1);</a>
<a name="ln5010">              if ((! test) &amp;&amp; (ii&gt;=1)) {</a>
<a name="ln5011">                //previous atom were badly assigned-backstep</a>
<a name="ln5012">                queryBQCounter[ii]=0;</a>
<a name="ln5013">                k=queryAGer[ii-1];</a>
<a name="ln5014">                if (k&gt;=0) {</a>
<a name="ln5015">                  l=queryAQTested[k]; queryAQTested[k]=-1; aSTested[l]=-1;</a>
<a name="ln5016">                };</a>
<a name="ln5017">                bSTested[queryBQTested[ii-1]]=-1;</a>
<a name="ln5018">                queryBQTested[ii-1]=-1;</a>
<a name="ln5019">                ii=ii-2;</a>
<a name="ln5020">                test=true;</a>
<a name="ln5021">              };</a>
<a name="ln5022">              ii=ii+1; //query bond counter</a>
<a name="ln5023">              whiletest2=(ii==nBonds()) || ((! test) &amp;&amp; (ii==1));</a>
<a name="ln5024">              whiletest2=! whiletest2;</a>
<a name="ln5025">            };</a>
<a name="ln5026">            i1++;</a>
<a name="ln5027">            test2=(ii==nBonds()); //Checking, if success has been reached</a>
<a name="ln5028">            whiletest1=((j1==i1) || test2);</a>
<a name="ln5029">            whiletest1=! whiletest1;</a>
<a name="ln5030">          } else test2=false;</a>
<a name="ln5031">      };</a>
<a name="ln5032">    };</a>
<a name="ln5033"> </a>
<a name="ln5034">    if (bondLabel != nullptr &amp;&amp; nBonds() &gt; 0) {</a>
<a name="ln5035">      bondLabel-&gt;resize(molecule1-&gt;nBonds());</a>
<a name="ln5036">      if (test2) for (j=0; j&lt;molecule1-&gt;nBonds(); j++) if (bSTested[j]&gt;=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0;</a>
<a name="ln5037">    };</a>
<a name="ln5038">    result=test2;</a>
<a name="ln5039"> </a>
<a name="ln5040">    // Tidy up</a>
<a name="ln5041">    free(structureBK);</a>
<a name="ln5042">    for (int i=0; i&lt;molecule1-&gt;nAtoms(); ++i)</a>
<a name="ln5043">      free(aEQ[i]);</a>
<a name="ln5044">    free(aEQ);</a>
<a name="ln5045">    for (int i=0; i&lt;molecule1-&gt;nBonds(); ++i)</a>
<a name="ln5046">      free(bEQ[i]);</a>
<a name="ln5047">    free(bEQ);</a>
<a name="ln5048"> </a>
<a name="ln5049"> </a>
<a name="ln5050">    return result;</a>
<a name="ln5051">  };</a>
<a name="ln5052">  //***************************************************************************</a>
<a name="ln5053">  //                   Diagram generation routines</a>
<a name="ln5054">  //***************************************************************************</a>
<a name="ln5055">  class PartFragmentDefinition {</a>
<a name="ln5056">  public:</a>
<a name="ln5057">    int fragID1,fragID2,fragID3,fragFirstAtomNo;</a>
<a name="ln5058">    int fragmentCount;</a>
<a name="ln5059">    double fragWidth,fragHeight,fragTop,fragLeft;</a>
<a name="ln5060"> </a>
<a name="ln5061">    PartFragmentDefinition(){</a>
<a name="ln5062">    };</a>
<a name="ln5063">    void assign(const PartFragmentDefinition source) {</a>
<a name="ln5064">      fragID1=source.fragID1;</a>
<a name="ln5065">      fragID2=source.fragID2;</a>
<a name="ln5066">      fragID3=source.fragID3;</a>
<a name="ln5067">      fragFirstAtomNo=source.fragFirstAtomNo;</a>
<a name="ln5068">      fragmentCount=source.fragmentCount;</a>
<a name="ln5069">      fragWidth=source.fragWidth;</a>
<a name="ln5070">      fragHeight=source.fragHeight;</a>
<a name="ln5071">      fragTop=source.fragTop;</a>
<a name="ln5072">      fragLeft=source.fragLeft;</a>
<a name="ln5073">    };</a>
<a name="ln5074">  };</a>
<a name="ln5075"> </a>
<a name="ln5076"> </a>
<a name="ln5077"> </a>
<a name="ln5078">  class  TemplateRedraw  {</a>
<a name="ln5079">  public:</a>
<a name="ln5080">    TemplateRedraw();</a>
<a name="ln5081">    //  virtual ~TemplateRedraw() {</a>
<a name="ln5082">    //    clear();</a>
<a name="ln5083">    //  };</a>
<a name="ln5084">    bool isOverlapped(const std::vector&lt;PartFragmentDefinition *&gt; list, int fragNo, double xSuggested, double ySuggested);</a>
<a name="ln5085">    void arrangeFragments(std::vector&lt;PartFragmentDefinition *&gt;&amp; list, int fragNo, double aspOptimal);</a>
<a name="ln5086">    void redrawFine(TSimpleMolecule&amp; smIn);</a>
<a name="ln5087">    int  coordinatesPrepare(TEditedMolecule&amp; sm, int kk, int anTemplateNo);</a>
<a name="ln5088">  private:</a>
<a name="ln5089">    static std::vector&lt;TEditedMolecule *&gt; queryData;</a>
<a name="ln5090">    void clear();</a>
<a name="ln5091">    bool internalBondsPresent(TEditedMolecule * mQuery, TSimpleMolecule * mStructure);</a>
<a name="ln5092">    void rotateBondVertically(TSimpleMolecule * sm, const std::vector&lt;int&gt;bondList, int bondNo,</a>
<a name="ln5093">                              double xuValue, double yuValue, double&amp; c1, double&amp; s1, double&amp; xSize, double&amp; ySize,</a>
<a name="ln5094">                              double&amp; xCenter, double&amp; yCenter, int&amp; nVert);</a>
<a name="ln5095">    void selectFragmentConfiguration(TSimpleMolecule * sm, std::vector&lt;int&gt;* atomList);</a>
<a name="ln5096">    void rescaleSingleFragment(TSimpleMolecule * sm, std::vector&lt;int&gt;* atomList, PartFragmentDefinition&amp; pf, double offset);</a>
<a name="ln5097">    void arrangeMolecules(std::vector&lt;PartFragmentDefinition *&gt;&amp; extendedList, double aspOptimal);</a>
<a name="ln5098">    bool loadTemplates();</a>
<a name="ln5099">  };</a>
<a name="ln5100"> </a>
<a name="ln5101">  //Initialization of static member variable</a>
<a name="ln5102">  std::vector&lt;TEditedMolecule *&gt; TemplateRedraw::queryData;</a>
<a name="ln5103"> </a>
<a name="ln5104">  bool TemplateRedraw::loadTemplates() {</a>
<a name="ln5105">    std::ifstream ifs;</a>
<a name="ln5106">    string filename(&quot;templates.sdf&quot;);//(&quot;e:\\templates.sdf&quot;);</a>
<a name="ln5107">    TEditedMolecule sm;</a>
<a name="ln5108">    TEditedMolecule * em;</a>
<a name="ln5109">    int i,na1,na2;</a>
<a name="ln5110">    bool test;</a>
<a name="ln5111">    bool result=false;</a>
<a name="ln5112"> </a>
<a name="ln5113">    try {</a>
<a name="ln5114">      OpenDatafile(ifs, filename);</a>
<a name="ln5115">    } catch (exception ex) {</a>
<a name="ln5116">      return result;</a>
<a name="ln5117">    };</a>
<a name="ln5118"> </a>
<a name="ln5119">    //Read into a vector of OBMol</a>
<a name="ln5120">    if (ifs) {</a>
<a name="ln5121">      OBConversion conv(&amp;ifs);</a>
<a name="ln5122">      conv.SetInFormat(&quot;sdf&quot;);</a>
<a name="ln5123"> </a>
<a name="ln5124">      OBMol mol;</a>
<a name="ln5125">      mol.SetIsPatternStructure();</a>
<a name="ln5126">      while (conv.Read(&amp;mol)) {</a>
<a name="ln5127">        sm.readOBMol(&amp;mol);</a>
<a name="ln5128">        mol.Clear();</a>
<a name="ln5129">        for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln5130">          if (sm.getAtom(i)-&gt;na != 1) sm.getAtom(i)-&gt;na=ANY_ATOM;</a>
<a name="ln5131">          sm.getAtom(i)-&gt;nc=0;</a>
<a name="ln5132">        }</a>
<a name="ln5133">        for (i=0; i&lt;sm.nBonds(); i++) {</a>
<a name="ln5134">          na1=sm.getBond(i)-&gt;at[0];</a>
<a name="ln5135">          na2=sm.getBond(i)-&gt;at[1];</a>
<a name="ln5136">          test=((sm.getAtom(na1)-&gt;na != 1) &amp;&amp; (sm.getAtom(na2)-&gt;na != 1));</a>
<a name="ln5137">          if (test) sm.getBond(i)-&gt;tb=ANY_BOND;  //ANY bons</a>
<a name="ln5138">        }</a>
<a name="ln5139">        sm.defineAtomConn();</a>
<a name="ln5140">        sm.allAboutCycles();</a>
<a name="ln5141">        em=new TEditedMolecule();</a>
<a name="ln5142">        em-&gt;prepareQuery(sm);</a>
<a name="ln5143">        queryData.push_back(em);</a>
<a name="ln5144">      }</a>
<a name="ln5145">      result=true;</a>
<a name="ln5146">      obErrorLog.ThrowError(__FUNCTION__, &quot;Read OK &quot; + filename, obInfo);</a>
<a name="ln5147">    }</a>
<a name="ln5148">    // else {obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot find &quot; + filename, obWarning);}</a>
<a name="ln5149">    return result;</a>
<a name="ln5150">  };</a>
<a name="ln5151"> </a>
<a name="ln5152"> </a>
<a name="ln5153">  TemplateRedraw::TemplateRedraw(){</a>
<a name="ln5154">    if(queryData.empty()) //Load internal and external templates only once</a>
<a name="ln5155">      {</a>
<a name="ln5156">        unsigned int i, j;</a>
<a name="ln5157">        TEditedMolecule * em;</a>
<a name="ln5158">        TEditedMolecule * em1;</a>
<a name="ln5159">        TEditedMolecule * em2;</a>
<a name="ln5160">        TEditedMolecule sm;</a>
<a name="ln5161">        bool test;</a>
<a name="ln5162"> </a>
<a name="ln5163">        //Load external..</a>
<a name="ln5164">        loadTemplates();</a>
<a name="ln5165">        //...and internal templates</a>
<a name="ln5166">        for (i=0; i&lt;NDATABASE_MOLECULES; i++) {</a>
<a name="ln5167">          sm.setCoordinatesString(strData[i]);</a>
<a name="ln5168">          sm.defineAtomConn();</a>
<a name="ln5169">          sm.allAboutCycles();</a>
<a name="ln5170">          em=new TEditedMolecule();</a>
<a name="ln5171">          em-&gt;prepareQuery(sm);</a>
<a name="ln5172">          queryData.push_back(em);</a>
<a name="ln5173">        }</a>
<a name="ln5174">        if (queryData.size()&gt;1) for (i=0; i&lt;(queryData.size()-1); i++) for (j=i+1; j&lt;queryData.size(); j++) {</a>
<a name="ln5175">              test=false;</a>
<a name="ln5176">              em1=(TEditedMolecule *)queryData[i];</a>
<a name="ln5177">              em2=(TEditedMolecule *)queryData[j];</a>
<a name="ln5178">              if (em1-&gt;nAtoms() &lt; em2-&gt;nAtoms()) test=true; else</a>
<a name="ln5179">                if (em1-&gt;nAtoms() &gt; em2-&gt;nAtoms()) test=false; else</a>
<a name="ln5180">                  if (em1-&gt;nBonds() &lt; em2-&gt;nBonds()) test=true;</a>
<a name="ln5181"> </a>
<a name="ln5182">              if (test) {</a>
<a name="ln5183">                queryData[i]=em2;</a>
<a name="ln5184">                queryData[j]=em1;</a>
<a name="ln5185">              }</a>
<a name="ln5186">            }</a>
<a name="ln5187">      }</a>
<a name="ln5188">  }</a>
<a name="ln5189"> </a>
<a name="ln5190">  void TemplateRedraw::clear() {</a>
<a name="ln5191">    for (unsigned int i=0; i&lt;queryData.size(); i++) {</a>
<a name="ln5192">      delete(queryData[i]);</a>
<a name="ln5193">    };</a>
<a name="ln5194">  };</a>
<a name="ln5195"> </a>
<a name="ln5196"> </a>
<a name="ln5197">  bool TemplateRedraw::internalBondsPresent(TEditedMolecule * mQuery, TSimpleMolecule * mStructure) {</a>
<a name="ln5198">    std::vector&lt;int&gt; aList(mStructure-&gt;nAtoms());</a>
<a name="ln5199">    std::vector&lt;int&gt; bList(mStructure-&gt;nBonds());</a>
<a name="ln5200">    unsigned int i, n1, n2;</a>
<a name="ln5201">    bool result=false;</a>
<a name="ln5202"> </a>
<a name="ln5203">    for (i=0; i&lt;aList.size(); i++) aList[i]=0;</a>
<a name="ln5204">    for (i=0; i&lt;bList.size(); i++) bList[i]=0;</a>
<a name="ln5205">    for (i=0; i&lt;mQuery-&gt;nAtoms(); i++) aList[mQuery-&gt;queryAQTested[i]]=1;</a>
<a name="ln5206">    for (i=0; i&lt;mQuery-&gt;nBonds(); i++) bList[mQuery-&gt;queryBQTested[i]]=1;</a>
<a name="ln5207">    for (i=0; i&lt;bList.size(); i++) if (bList[i] == 0) {</a>
<a name="ln5208">        n1=mStructure-&gt;getBond(i)-&gt;at[0];</a>
<a name="ln5209">        n2=mStructure-&gt;getBond(i)-&gt;at[1];</a>
<a name="ln5210">        if ((aList[n1] == 1) &amp;&amp; (aList[n2] == 1)) result=true;</a>
<a name="ln5211">        if (result) break;</a>
<a name="ln5212">      };</a>
<a name="ln5213">    //seek for 3-attached atom</a>
<a name="ln5214">    return result;</a>
<a name="ln5215">  };</a>
<a name="ln5216"> </a>
<a name="ln5217">  void TemplateRedraw::rotateBondVertically(TSimpleMolecule * sm, const std::vector&lt;int&gt;bondList, int bondNo, double xuValue, double yuValue, double&amp; c1, double&amp; s1, double&amp; xSize, double&amp; ySize, double&amp; xCenter, double&amp; yCenter, int&amp; nVert) {</a>
<a name="ln5218">    //Dummy rotation of molecule</a>
<a name="ln5219">    //Two solution - when c2,s2 are used - are determined for cases of rotaition when Up and Down are counterchnged. Single solution would be enough</a>
<a name="ln5220">    std::vector&lt;bool&gt; atomList(sm-&gt;nAtoms(), false);</a>
<a name="ln5221">    int i,n,n1,n2;</a>
<a name="ln5222">    bool test;</a>
<a name="ln5223">    double rX,rY,r;</a>
<a name="ln5224">    std::vector&lt;double&gt; coorX(sm-&gt;nAtoms());</a>
<a name="ln5225">    std::vector&lt;double&gt; coorY(sm-&gt;nAtoms());</a>
<a name="ln5226">    double xMin,xMax,yMin,yMax;</a>
<a name="ln5227"> </a>
<a name="ln5228"> </a>
<a name="ln5229"> </a>
<a name="ln5230">    xSize=0;</a>
<a name="ln5231">    ySize=0;</a>
<a name="ln5232">    c1=1; s1=0;</a>
<a name="ln5233">    xCenter=0; yCenter=0;</a>
<a name="ln5234">    nVert=0;</a>
<a name="ln5235">    test=false;</a>
<a name="ln5236">    for (i=0; i&lt;bondList.size(); i++) {</a>
<a name="ln5237">      n=bondList[i];</a>
<a name="ln5238">      if (n==bondNo) test=true;</a>
<a name="ln5239">      n1=sm-&gt;getBond(n)-&gt;at[0];</a>
<a name="ln5240">      n2=sm-&gt;getBond(n)-&gt;at[1];</a>
<a name="ln5241">      atomList[n1]=true;</a>
<a name="ln5242">      atomList[n2]=true;</a>
<a name="ln5243">    };</a>
<a name="ln5244">    if (! test) return;  //bond is absent in the list....</a>
<a name="ln5245">    n1=sm-&gt;getBond(bondNo)-&gt;at[0];</a>
<a name="ln5246">    n2=sm-&gt;getBond(bondNo)-&gt;at[1];</a>
<a name="ln5247">    xCenter=sm-&gt;getAtom(n2)-&gt;rx;</a>
<a name="ln5248">    yCenter=sm-&gt;getAtom(n2)-&gt;ry;</a>
<a name="ln5249">    rX=sm-&gt;getAtom(n1)-&gt;rx-xCenter;</a>
<a name="ln5250">    rY=sm-&gt;getAtom(n1)-&gt;ry-yCenter;</a>
<a name="ln5251">    r=sqrt(rX*rX+rY*rY);</a>
<a name="ln5252">    if (r != 0) {</a>
<a name="ln5253">      rX=rX/r; rY=rY/r;</a>
<a name="ln5254">      if (abs(rX) &lt; 0.00001) {</a>
<a name="ln5255">        s1=xuValue/rY;</a>
<a name="ln5256">        c1=-yuValue/rY;</a>
<a name="ln5257">      } else if (abs(rY) &lt; 0.00001) {</a>
<a name="ln5258">        s1=yuValue/rX;</a>
<a name="ln5259">        c1=xuValue/rX;</a>
<a name="ln5260">      } else {</a>
<a name="ln5261">        s1=(xuValue/rX+yuValue/rY)/(rY/rX+rX/rY);</a>
<a name="ln5262">        c1=(xuValue/rY-yuValue/rX)/(rY/rX+rX/rY);</a>
<a name="ln5263">      };</a>
<a name="ln5264">    };</a>
<a name="ln5265">    //c1, s1 analizing</a>
<a name="ln5266">    for (i=0; i&lt;sm-&gt;nAtoms(); i++) {</a>
<a name="ln5267">      coorX[i]=c1*(sm-&gt;getAtom(i)-&gt;rx-xCenter)+s1*(sm-&gt;getAtom(i)-&gt;ry-yCenter);</a>
<a name="ln5268">      coorY[i]=s1*(sm-&gt;getAtom(i)-&gt;rx-xCenter)-c1*(sm-&gt;getAtom(i)-&gt;ry-yCenter);</a>
<a name="ln5269">    };</a>
<a name="ln5270">    xMin=RUNDEF; xMax=RUNDEF;</a>
<a name="ln5271">    yMin=RUNDEF; yMax=RUNDEF;</a>
<a name="ln5272">    for (i=0; i&lt;sm-&gt;nAtoms(); i++) if (atomList[i]) {</a>
<a name="ln5273">        if ((coorX[i] &lt; xMin) || (xMin == RUNDEF)) xMin=coorX[i];</a>
<a name="ln5274">        if ((coorX[i] &gt; xMax) || (xMax == RUNDEF)) xMax=coorX[i];</a>
<a name="ln5275">        if ((coorY[i] &lt; yMin) || (yMin == RUNDEF)) yMin=coorY[i];</a>
<a name="ln5276">        if ((coorY[i] &gt; yMax) || (yMax == RUNDEF)) yMax=coorY[i];</a>
<a name="ln5277">      };</a>
<a name="ln5278">    xSize=xMax-xMin;</a>
<a name="ln5279">    ySize=yMax-yMin;</a>
<a name="ln5280">    //calculation no. vertical bonds...</a>
<a name="ln5281">    for (i=0; i&lt;bondList.size(); i++) {</a>
<a name="ln5282">      n=bondList[i];</a>
<a name="ln5283">      n1=sm-&gt;getBond(n)-&gt;at[0];</a>
<a name="ln5284">      n2=sm-&gt;getBond(n)-&gt;at[1];</a>
<a name="ln5285">      //no. vert. bonds</a>
<a name="ln5286">      r=coorY[n1]-coorY[n2];</a>
<a name="ln5287">      if (abs(r) &gt; 0) {</a>
<a name="ln5288">        r=abs((coorX[n1]-coorX[n2])/r);</a>
<a name="ln5289">        if (r &lt; 0.02) nVert++;</a>
<a name="ln5290">      };</a>
<a name="ln5291">    };</a>
<a name="ln5292">  };</a>
<a name="ln5293"> </a>
<a name="ln5294">  void TemplateRedraw::selectFragmentConfiguration(TSimpleMolecule * sm, std::vector&lt;int&gt;* atomList) {</a>
<a name="ln5295">    //for each fragment in AtomList select optimal angle of rotation</a>
<a name="ln5296">    double xMax;</a>
<a name="ln5297">    double xSize;</a>
<a name="ln5298">    double ySize;</a>
<a name="ln5299">    double xCenter;</a>
<a name="ln5300">    double yCenter;</a>
<a name="ln5301">    double c;</a>
<a name="ln5302">    double s;</a>
<a name="ln5303">    int nVert;</a>
<a name="ln5304">    double cMax,sMax,x,y;</a>
<a name="ln5305">    std::vector&lt;int&gt; bondList(0);</a>
<a name="ln5306">    std::vector&lt;int&gt; bondListAll(0);</a>
<a name="ln5307">    std::vector&lt;bool&gt; atomCleaned(sm-&gt;nAtoms());</a>
<a name="ln5308">    int i,j,n,n1,n2,w;</a>
<a name="ln5309">    bool test;</a>
<a name="ln5310"> </a>
<a name="ln5311">    if (atomList == nullptr) {</a>
<a name="ln5312">      for (i=0; i&lt;sm-&gt;nAtoms(); i++) atomCleaned[i]=true;</a>
<a name="ln5313">    } else {</a>
<a name="ln5314">      for (i=0; i&lt;sm-&gt;nAtoms(); i++) atomCleaned[i]=false;</a>
<a name="ln5315">      for (i=0; i&lt;atomList-&gt;size(); i++) {</a>
<a name="ln5316">        n=(*atomList)[i];</a>
<a name="ln5317">        atomCleaned[n]=true;</a>
<a name="ln5318">      };</a>
<a name="ln5319">    };</a>
<a name="ln5320">    //bondList generation...</a>
<a name="ln5321">    for (i=0; i&lt;sm-&gt;nBonds(); i++) {</a>
<a name="ln5322">      n1=sm-&gt;getBond(i)-&gt;at[0];</a>
<a name="ln5323">      n2=sm-&gt;getBond(i)-&gt;at[1];</a>
<a name="ln5324">      if (atomCleaned[n1] &amp;&amp; atomCleaned[n2]) {</a>
<a name="ln5325">        w=i;</a>
<a name="ln5326">        bondListAll.push_back(w);</a>
<a name="ln5327">        if (sm-&gt;getBond(i)-&gt;db &gt; 1) bondList.push_back(w); //only ring bonds...</a>
<a name="ln5328">      };</a>
<a name="ln5329">    };</a>
<a name="ln5330">    if (bondList.size() == 0) {</a>
<a name="ln5331">      bondList.resize(bondListAll.size());</a>
<a name="ln5332">      for (i=0; i&lt;bondListAll.size(); i++) bondList[i]=bondListAll[i];</a>
<a name="ln5333">    };</a>
<a name="ln5334">    if (bondList.size() &gt; 0) {</a>
<a name="ln5335">      //search for 4-coordinater non-carbon</a>
<a name="ln5336">      test=false;</a>
<a name="ln5337">      n=-1;</a>
<a name="ln5338">      for (i=0; i&lt;sm-&gt;nAtoms(); i++) if (atomCleaned[i] &amp;&amp; (sm-&gt;getAtom(i)-&gt;na != 6) &amp;&amp; (sm-&gt;getAtom(i)-&gt;nb == 4)) {</a>
<a name="ln5339">          test=true;</a>
<a name="ln5340">          for (j=0; j&lt;sm-&gt;nBonds(); j++) if ((sm-&gt;getBond(j)-&gt;at[0] == i) || (sm-&gt;getBond(j)-&gt;at[1] == i)) {</a>
<a name="ln5341">              n=j;</a>
<a name="ln5342">              if (sm-&gt;getBond(j)-&gt;db &gt; 1) {</a>
<a name="ln5343">                n=-1;</a>
<a name="ln5344">                test=false;</a>
<a name="ln5345">                break;</a>
<a name="ln5346">              };</a>
<a name="ln5347">            };</a>
<a name="ln5348">          if (test) break;</a>
<a name="ln5349">        };</a>
<a name="ln5350">      if (! test) for (i=0; i&lt;sm-&gt;nBonds(); i++) if (atomCleaned[sm-&gt;getBond(i)-&gt;at[0]] &amp;&amp; (sm-&gt;getBond(i)-&gt;db == 5)) {</a>
<a name="ln5351">            n=i;</a>
<a name="ln5352">            test=true;</a>
<a name="ln5353">            break;</a>
<a name="ln5354">          };</a>
<a name="ln5355">      if (test) {</a>
<a name="ln5356">        rotateBondVertically(sm,bondListAll,n,1.0,0.0,c,s,xSize,ySize,xCenter,yCenter,nVert);</a>
<a name="ln5357">        if (ySize &gt; xSize) rotateBondVertically(sm,bondListAll,n,0.0,1.0,c,s,xSize,ySize,xCenter,yCenter,nVert);</a>
<a name="ln5358">        cMax=c;</a>
<a name="ln5359">        sMax=s;</a>
<a name="ln5360">      } else {</a>
<a name="ln5361">        xMax=0; cMax=1; sMax=0;</a>
<a name="ln5362">        for (i=0; i&lt;bondList.size(); i++) {</a>
<a name="ln5363">          n=bondList[i];</a>
<a name="ln5364">          rotateBondVertically(sm,bondList,n,sqrt(3.0)/2.0,0.5,c,s,xSize,ySize,xCenter,yCenter,nVert);</a>
<a name="ln5365">          xSize=xSize+nVert*xSize/10.0;  //5 vertical bonds=1 xSize</a>
<a name="ln5366">          if (xSize &gt; xMax) {</a>
<a name="ln5367">            xMax=xSize;</a>
<a name="ln5368">            cMax=c;</a>
<a name="ln5369">            sMax=s;</a>
<a name="ln5370">          };</a>
<a name="ln5371">        };</a>
<a name="ln5372">        for (i=0; i&lt;bondList.size(); i++) {</a>
<a name="ln5373">          n=bondList[i];</a>
<a name="ln5374">          rotateBondVertically(sm,bondList,n,1.0,0.0,c,s,xSize,ySize,xCenter,yCenter,nVert);</a>
<a name="ln5375">          xSize=xSize+nVert*xSize/10.0;  //5 vertical bonds=1 xSize</a>
<a name="ln5376">          if (xSize &gt; xMax) {</a>
<a name="ln5377">            xMax=xSize;</a>
<a name="ln5378">            cMax=c;</a>
<a name="ln5379">            sMax=s;</a>
<a name="ln5380">          };</a>
<a name="ln5381">        };</a>
<a name="ln5382">      };</a>
<a name="ln5383">      //Rotation</a>
<a name="ln5384">      for (i=0; i&lt;sm-&gt;nAtoms(); i++) if (atomCleaned[i]) {</a>
<a name="ln5385">          x=cMax*(sm-&gt;getAtom(i)-&gt;rx-xCenter)+sMax*(sm-&gt;getAtom(i)-&gt;ry-yCenter);</a>
<a name="ln5386">          y=sMax*(sm-&gt;getAtom(i)-&gt;rx-xCenter)-cMax*(sm-&gt;getAtom(i)-&gt;ry-yCenter);</a>
<a name="ln5387">          sm-&gt;getAtom(i)-&gt;rx=x;</a>
<a name="ln5388">          sm-&gt;getAtom(i)-&gt;ry=y;</a>
<a name="ln5389">        };</a>
<a name="ln5390">    };</a>
<a name="ln5391">  };</a>
<a name="ln5392"> </a>
<a name="ln5393">  void TemplateRedraw::rescaleSingleFragment(TSimpleMolecule * sm, std::vector&lt;int&gt;* atomList, PartFragmentDefinition&amp; pf, double offset) {</a>
<a name="ln5394">    int i,n;</a>
<a name="ln5395">    double xMin,xMax,yMin,yMax;</a>
<a name="ln5396">    double scale,r1,r2;</a>
<a name="ln5397">    double x,y;</a>
<a name="ln5398"> </a>
<a name="ln5399">    xMin=RUNDEF;</a>
<a name="ln5400">    xMax=RUNDEF;</a>
<a name="ln5401">    yMin=RUNDEF;</a>
<a name="ln5402">    yMax=RUNDEF;</a>
<a name="ln5403">    for (i=0; i&lt;atomList-&gt;size(); i++) {</a>
<a name="ln5404">      n=(*atomList)[i];</a>
<a name="ln5405">      if ((sm-&gt;getAtom(n)-&gt;rx &lt; xMin) || (xMin == RUNDEF)) xMin=sm-&gt;getAtom(n)-&gt;rx;</a>
<a name="ln5406">      if ((sm-&gt;getAtom(n)-&gt;rx &gt; xMax) || (xMax == RUNDEF)) xMax=sm-&gt;getAtom(n)-&gt;rx;</a>
<a name="ln5407">      if ((sm-&gt;getAtom(n)-&gt;ry &lt; yMin) || (yMin == RUNDEF)) yMin=sm-&gt;getAtom(n)-&gt;ry;</a>
<a name="ln5408">      if ((sm-&gt;getAtom(n)-&gt;ry &gt; yMax) || (yMax == RUNDEF)) yMax=sm-&gt;getAtom(n)-&gt;ry;</a>
<a name="ln5409">    };</a>
<a name="ln5410">    // LPW: Nearly horizontal molecules were being scaled which resulted in</a>
<a name="ln5411">    // some nonsensical structures.  This code ensures that coordinates with</a>
<a name="ln5412">    // &quot;almost&quot; horizontal or vertical geometries don't get scaled.</a>
<a name="ln5413">    bool Xeq = (fabs(xMax - xMin) &lt; 0.01);</a>
<a name="ln5414">    bool Yeq = (fabs(yMax - yMin) &lt; 0.01);</a>
<a name="ln5415">    if ((Xeq) &amp;&amp; (Yeq)) {</a>
<a name="ln5416">      for (i=0; i&lt;atomList-&gt;size(); i++) {</a>
<a name="ln5417">        n=(*atomList)[i];</a>
<a name="ln5418">        sm-&gt;getAtom(n)-&gt;rx=(pf.fragLeft+pf.fragWidth/2);</a>
<a name="ln5419">        sm-&gt;getAtom(n)-&gt;ry=(pf.fragTop+pf.fragHeight/2);</a>
<a name="ln5420">      };</a>
<a name="ln5421">      return;</a>
<a name="ln5422">    };</a>
<a name="ln5423">    if (Xeq) {         //y should be scaled</a>
<a name="ln5424">      scale=(pf.fragHeight-2*offset)/(yMax-yMin);</a>
<a name="ln5425">    } else if (Yeq) { //x should be scaled</a>
<a name="ln5426">      scale=(pf.fragWidth-2*offset)/(xMax-xMin);</a>
<a name="ln5427">    } else {</a>
<a name="ln5428">      r1=(pf.fragHeight-2*offset)/(yMax-yMin);</a>
<a name="ln5429">      r2=(pf.fragWidth-2*offset)/(xMax-xMin);</a>
<a name="ln5430">      if (r1 &gt; r2) scale=r2; else scale=r1;</a>
<a name="ln5431">    };</a>
<a name="ln5432">    for (i=0; i&lt;atomList-&gt;size(); i++) {</a>
<a name="ln5433">      n=(*atomList)[i];</a>
<a name="ln5434">      x=pf.fragLeft+offset+(sm-&gt;getAtom(n)-&gt;rx-xMin)*scale;</a>
<a name="ln5435">      y=pf.fragTop+offset+(sm-&gt;getAtom(n)-&gt;ry-yMin)*scale;</a>
<a name="ln5436">      sm-&gt;getAtom(n)-&gt;rx=x;</a>
<a name="ln5437">      sm-&gt;getAtom(n)-&gt;ry=y;</a>
<a name="ln5438">    };</a>
<a name="ln5439">  };</a>
<a name="ln5440"> </a>
<a name="ln5441"> </a>
<a name="ln5442">  bool ptInRect(const Rect r, const Point p) {</a>
<a name="ln5443">    bool result=((p.x &gt;= r.left) &amp; (p.x &lt;= r.right) &amp; (p.y &gt;= r.top) &amp; (p.y &lt;= r.bottom));</a>
<a name="ln5444">    return result;</a>
<a name="ln5445">  }</a>
<a name="ln5446"> </a>
<a name="ln5447"> </a>
<a name="ln5448">  bool TemplateRedraw::isOverlapped(const std::vector&lt;PartFragmentDefinition *&gt; list, int fragNo, double xSuggested, double ySuggested) {</a>
<a name="ln5449">    //  !!! Zero-based fragno !!!</a>
<a name="ln5450">    //checking if recteangles are overlapped from different fagments.</a>
<a name="ln5451">    Rect rect;</a>
<a name="ln5452">    Point p;</a>
<a name="ln5453">    int i,j,n1,n2;</a>
<a name="ln5454">    PartFragmentDefinition * ef;</a>
<a name="ln5455">    PartFragmentDefinition * efTemp;</a>
<a name="ln5456">    bool test, result;</a>
<a name="ln5457"> </a>
<a name="ln5458">    result=false;</a>
<a name="ln5459">    ef=(PartFragmentDefinition *)list[fragNo];</a>
<a name="ln5460">    rect.left=xSuggested;</a>
<a name="ln5461">    rect.top=ySuggested;</a>
<a name="ln5462">    rect.right=rect.left+ef-&gt;fragWidth;</a>
<a name="ln5463">    rect.bottom=rect.top+ef-&gt;fragHeight;</a>
<a name="ln5464">    for (i=0; i&lt;fragNo; i++) {</a>
<a name="ln5465">      efTemp=(PartFragmentDefinition *)list[i];</a>
<a name="ln5466">      test=((efTemp-&gt;fragLeft+efTemp-&gt;fragWidth) &lt; rect.left);</a>
<a name="ln5467">      if (! test) test=((efTemp-&gt;fragTop+efTemp-&gt;fragHeight) &lt; rect.top);</a>
<a name="ln5468">      if (! test) test=(efTemp-&gt;fragLeft &gt; rect.right);</a>
<a name="ln5469">      if (! test) test=(efTemp-&gt;fragTop &gt; rect.bottom);</a>
<a name="ln5470">      if (! test) {</a>
<a name="ln5471">        n1=(int)(efTemp-&gt;fragLeft);</a>
<a name="ln5472">        n2=(int)(efTemp-&gt;fragLeft+efTemp-&gt;fragWidth);</a>
<a name="ln5473">        for (j=n1; j&lt;=n2; j++) {</a>
<a name="ln5474">          p.x=j;</a>
<a name="ln5475">          p.y=efTemp-&gt;fragTop;</a>
<a name="ln5476">          if (ptInRect(rect,p)) {</a>
<a name="ln5477">            result=true;</a>
<a name="ln5478">            return result;</a>
<a name="ln5479">          };</a>
<a name="ln5480">          p.x=j;</a>
<a name="ln5481">          p.y=efTemp-&gt;fragTop+efTemp-&gt;fragHeight;</a>
<a name="ln5482">          if (ptInRect(rect,p)) {</a>
<a name="ln5483">            result=true;</a>
<a name="ln5484">            return result;</a>
<a name="ln5485">          };</a>
<a name="ln5486">        };</a>
<a name="ln5487">        n1=(int)(efTemp-&gt;fragTop);</a>
<a name="ln5488">        n2=(int)(efTemp-&gt;fragTop+efTemp-&gt;fragHeight);</a>
<a name="ln5489">        for (j=n1; j&lt;=n2; j++) {</a>
<a name="ln5490">          p.y=j;</a>
<a name="ln5491">          p.x=efTemp-&gt;fragLeft;</a>
<a name="ln5492">          if (ptInRect(rect,p)) {</a>
<a name="ln5493">            result=true;</a>
<a name="ln5494">            return result;</a>
<a name="ln5495">          };</a>
<a name="ln5496">          p.y=j;</a>
<a name="ln5497">          p.x=efTemp-&gt;fragLeft+efTemp-&gt;fragWidth;</a>
<a name="ln5498">          if (ptInRect(rect,p)) {</a>
<a name="ln5499">            result=true;</a>
<a name="ln5500">            return result;</a>
<a name="ln5501">          };</a>
<a name="ln5502">        };</a>
<a name="ln5503">      };</a>
<a name="ln5504">    };</a>
<a name="ln5505">    return result;</a>
<a name="ln5506">  };</a>
<a name="ln5507"> </a>
<a name="ln5508">  void TemplateRedraw::arrangeFragments(std::vector&lt;PartFragmentDefinition *&gt;&amp; list, int fragNo, double aspOptimal) {</a>
<a name="ln5509">    //!! Frag no zero-based!</a>
<a name="ln5510">    double aspDelta,xNice,yNice,xMax,yMax,xMin,yMin,r,x,y,xNew,yNew;</a>
<a name="ln5511">    PartFragmentDefinition * ef;</a>
<a name="ln5512">    PartFragmentDefinition * efInterest;</a>
<a name="ln5513">    int i;</a>
<a name="ln5514"> </a>
<a name="ln5515">    ef=(PartFragmentDefinition *)list[0];</a>
<a name="ln5516">    xMax=ef-&gt;fragLeft+ef-&gt;fragWidth; yMax=ef-&gt;fragTop+ef-&gt;fragHeight;</a>
<a name="ln5517">    xMin=ef-&gt;fragLeft; yMin=ef-&gt;fragTop;</a>
<a name="ln5518">    //Calculate sizes....</a>
<a name="ln5519">    for (i=1; i&lt;fragNo; i++) {</a>
<a name="ln5520">      ef=(PartFragmentDefinition*)list[i];</a>
<a name="ln5521">      r=ef-&gt;fragLeft+ef-&gt;fragWidth;</a>
<a name="ln5522">      if (r &gt; xMax) xMax=r;</a>
<a name="ln5523">      r=ef-&gt;fragTop+ef-&gt;fragHeight;</a>
<a name="ln5524">      if (r &gt; yMax) yMax=r;</a>
<a name="ln5525">      if (ef-&gt;fragTop &lt; yMin) yMin=ef-&gt;fragTop;</a>
<a name="ln5526">      if (ef-&gt;fragLeft &lt; xMin) xMin=ef-&gt;fragLeft;</a>
<a name="ln5527">    };</a>
<a name="ln5528">    aspDelta=1000000; xNice=0; yNice=0;</a>
<a name="ln5529">    efInterest=(PartFragmentDefinition *)list[fragNo];</a>
<a name="ln5530">    for (i=0; i&lt;fragNo; i++) {</a>
<a name="ln5531">      ef=(PartFragmentDefinition *)list[i];</a>
<a name="ln5532">      //Insert right</a>
<a name="ln5533">      x=ef-&gt;fragLeft+ef-&gt;fragWidth+1;</a>
<a name="ln5534">      y=ef-&gt;fragTop;</a>
<a name="ln5535">      if (! isOverlapped(list,fragNo,x,y)) {</a>
<a name="ln5536">        if (((x+efInterest-&gt;fragWidth) &lt;= xMax) &amp;&amp; ((y+efInterest-&gt;fragHeight) &lt;= yMax)) {</a>
<a name="ln5537">          efInterest-&gt;fragLeft=x; efInterest-&gt;fragTop=y;</a>
<a name="ln5538">          list[fragNo]=efInterest;</a>
<a name="ln5539">          return;</a>
<a name="ln5540">        };</a>
<a name="ln5541">        xNew=x+efInterest-&gt;fragWidth; if (xMax &gt; xNew) xNew=xMax;</a>
<a name="ln5542">        yNew=y+efInterest-&gt;fragHeight; if (yMax &gt; yNew) yNew=yMax;</a>
<a name="ln5543">        r=(yNew-yMin)/(xNew-xMin);</a>
<a name="ln5544">        if (abs(r-aspOptimal) &lt; aspDelta) {</a>
<a name="ln5545">          xNice=x; yNice=y;</a>
<a name="ln5546">          aspDelta=abs(r-aspOptimal);</a>
<a name="ln5547">        };</a>
<a name="ln5548">      };</a>
<a name="ln5549">      x=ef-&gt;fragLeft;</a>
<a name="ln5550">      y=ef-&gt;fragTop+ef-&gt;fragHeight+1;</a>
<a name="ln5551">      if (! isOverlapped(list,fragNo,x,y)) {</a>
<a name="ln5552">        if (((x+efInterest-&gt;fragWidth) &lt;= xMax) &amp;&amp; ((y+efInterest-&gt;fragHeight) &lt;= yMax)) {</a>
<a name="ln5553">          efInterest-&gt;fragLeft=x; efInterest-&gt;fragTop=y;</a>
<a name="ln5554">          list[fragNo]=efInterest;</a>
<a name="ln5555">          return;</a>
<a name="ln5556">        };</a>
<a name="ln5557">        xNew=x+efInterest-&gt;fragWidth; if (xMax &gt; xNew) xNew=xMax;</a>
<a name="ln5558">        yNew=y+efInterest-&gt;fragHeight; if (yMax &gt; yNew) yNew=yMax;</a>
<a name="ln5559">        r=(yNew-yMin)/(xNew-xMin);</a>
<a name="ln5560">        if (abs(r-aspOptimal) &lt; aspDelta) {</a>
<a name="ln5561">          xNice=x; yNice=y;</a>
<a name="ln5562">          aspDelta=abs(r-aspOptimal);</a>
<a name="ln5563">        };</a>
<a name="ln5564">      };</a>
<a name="ln5565">    };</a>
<a name="ln5566">    //if here - maxX,0 and 0,MaxY have to be tested...</a>
<a name="ln5567">    x=xMax; y=0;</a>
<a name="ln5568">    xNew=x+efInterest-&gt;fragWidth; if (xMax &gt; xNew) xNew=xMax;</a>
<a name="ln5569">    yNew=y+efInterest-&gt;fragHeight; if (yMax &gt; yNew) yNew=yMax;</a>
<a name="ln5570">    r=(yNew-yMin)/(xNew-xMin);</a>
<a name="ln5571">    if (abs(r-aspOptimal) &lt; aspDelta) {</a>
<a name="ln5572">      xNice=x; yNice=y;</a>
<a name="ln5573">      aspDelta=abs(r-aspOptimal);</a>
<a name="ln5574">    };</a>
<a name="ln5575">    x=0; y=yMax;</a>
<a name="ln5576">    xNew=x+efInterest-&gt;fragWidth; if (xMax &gt; xNew) xNew=xMax;</a>
<a name="ln5577">    yNew=y+efInterest-&gt;fragHeight; if (yMax &gt; yNew) yNew=yMax;</a>
<a name="ln5578">    r=(yNew-yMin)/(xNew-xMin);</a>
<a name="ln5579">    if (abs(r-aspOptimal) &lt; aspDelta) {</a>
<a name="ln5580">      xNice=x; yNice=y;</a>
<a name="ln5581">      aspDelta=abs(r-aspOptimal);</a>
<a name="ln5582">    };</a>
<a name="ln5583">    efInterest-&gt;fragLeft=xNice; efInterest-&gt;fragTop=yNice;</a>
<a name="ln5584">    list[fragNo]=efInterest;</a>
<a name="ln5585">  };</a>
<a name="ln5586"> </a>
<a name="ln5587">  void TemplateRedraw::arrangeMolecules(std::vector&lt;PartFragmentDefinition *&gt;&amp; extendedList, double aspOptimal) {</a>
<a name="ln5588"> </a>
<a name="ln5589">    unsigned int i, j;</a>
<a name="ln5590">    PartFragmentDefinition * ef;</a>
<a name="ln5591">    PartFragmentDefinition * efTemp;</a>
<a name="ln5592">    double maxX,minY,minX,maxY,r,r1;</a>
<a name="ln5593"> </a>
<a name="ln5594">    if (extendedList.size() &gt; 1) {</a>
<a name="ln5595">      //Search for Max Width and MaxHeight fragments</a>
<a name="ln5596">      for (i=0; i&lt;(extendedList.size()-1); i++) for (j=i+1; j&lt;extendedList.size(); j++) {</a>
<a name="ln5597">          ef=(PartFragmentDefinition *)extendedList[i];</a>
<a name="ln5598">          efTemp=(PartFragmentDefinition *)extendedList[j];</a>
<a name="ln5599">          if (efTemp-&gt;fragWidth &gt; ef-&gt;fragWidth) {</a>
<a name="ln5600">            extendedList[j]=ef;</a>
<a name="ln5601">            extendedList[i]=efTemp;</a>
<a name="ln5602">          };</a>
<a name="ln5603">        };</a>
<a name="ln5604">      if (extendedList.size() &gt; 2) {</a>
<a name="ln5605">        ef=(PartFragmentDefinition *)extendedList[1];</a>
<a name="ln5606">        for (i=2; i&lt;extendedList.size(); i++) {</a>
<a name="ln5607">          efTemp=(PartFragmentDefinition *)extendedList[i];</a>
<a name="ln5608">          if (efTemp-&gt;fragHeight &gt; ef-&gt;fragHeight) {</a>
<a name="ln5609">            extendedList[i]=ef;</a>
<a name="ln5610">            extendedList[1]=efTemp;</a>
<a name="ln5611">            ef=efTemp;</a>
<a name="ln5612">          };</a>
<a name="ln5613">        };</a>
<a name="ln5614">      };</a>
<a name="ln5615">      //Try to arrange 1-st and 2-nd fragments....</a>
<a name="ln5616">      ef=(PartFragmentDefinition *)extendedList[0];</a>
<a name="ln5617">      efTemp=(PartFragmentDefinition *)extendedList[1];</a>
<a name="ln5618">      maxX=ef-&gt;fragWidth+efTemp-&gt;fragWidth;</a>
<a name="ln5619">      minY=efTemp-&gt;fragHeight;</a>
<a name="ln5620">      if (ef-&gt;fragHeight &gt; minY) minY=ef-&gt;fragHeight;</a>
<a name="ln5621">      r=minY/maxX;</a>
<a name="ln5622">      minX=ef-&gt;fragWidth;</a>
<a name="ln5623">      maxY=ef-&gt;fragHeight+efTemp-&gt;fragHeight;</a>
<a name="ln5624">      r1=maxY/minX;</a>
<a name="ln5625">      if (abs(r-aspOptimal) &lt; abs(r1-aspOptimal)) {</a>
<a name="ln5626">        if (ef-&gt;fragHeight &gt; efTemp-&gt;fragHeight) {</a>
<a name="ln5627">          efTemp-&gt;fragLeft=ef-&gt;fragWidth;</a>
<a name="ln5628">          extendedList[1]=efTemp;</a>
<a name="ln5629">        } else {</a>
<a name="ln5630">          ef-&gt;fragLeft=efTemp-&gt;fragWidth;</a>
<a name="ln5631">          extendedList[0]=ef;</a>
<a name="ln5632">        };</a>
<a name="ln5633">      } else {</a>
<a name="ln5634">        efTemp-&gt;fragTop=ef-&gt;fragHeight;</a>
<a name="ln5635">        extendedList[1]=efTemp;</a>
<a name="ln5636">      };</a>
<a name="ln5637">      //Arranging of 3-rd and more frgments...</a>
<a name="ln5638">      if (extendedList.size()&gt;2) for (i=2; i&lt;extendedList.size(); i++) arrangeFragments(extendedList,i,aspOptimal);</a>
<a name="ln5639">    };</a>
<a name="ln5640">  };</a>
<a name="ln5641"> </a>
<a name="ln5642"> </a>
<a name="ln5643">  int TemplateRedraw::coordinatesPrepare(TEditedMolecule&amp; sm, int kk, int anTemplateNo) {</a>
<a name="ln5644"> </a>
<a name="ln5645">    TEditedMolecule * em=nullptr;</a>
<a name="ln5646">    int i, j, k, fragmentAN, templateAN;</a>
<a name="ln5647">    int atomClean;</a>
<a name="ln5648">    int bondClean;</a>
<a name="ln5649">    std::vector&lt;int&gt; templateAtomNumber(0);</a>
<a name="ln5650">    std::vector&lt;int&gt; fragmentAtomNumber(0);</a>
<a name="ln5651">    bool test,test1;</a>
<a name="ln5652">    std::vector&lt;TEditedMolecule *&gt; groupsFind(0);</a>
<a name="ln5653">    TEditedMolecule tm;</a>
<a name="ln5654">    TEditedMolecule * emTemplate;</a>
<a name="ln5655">    std::vector&lt;int&gt; enumerator(0);</a>
<a name="ln5656">    TSingleBond * sb;</a>
<a name="ln5657">    int nFound;</a>
<a name="ln5658">    TEditedMolecule * smFragment;</a>
<a name="ln5659">    TEditedMolecule * smRest;</a>
<a name="ln5660">    int naStore;</a>
<a name="ln5661">    int result;</a>
<a name="ln5662"> </a>
<a name="ln5663"> </a>
<a name="ln5664">    sm.defineAtomConn();</a>
<a name="ln5665">    sm.allAboutCycles();</a>
<a name="ln5666"> </a>
<a name="ln5667"> </a>
<a name="ln5668">    result=-1;</a>
<a name="ln5669"> </a>
<a name="ln5670"> </a>
<a name="ln5671">    for (i=kk; i&lt;queryData.size(); i++) if ((TEditedMolecule *)queryData[i]-&gt;fragmentSearch(&amp;sm,nullptr)) {</a>
<a name="ln5672">        em=(TEditedMolecule *)queryData[i];</a>
<a name="ln5673">        if (! internalBondsPresent(em,&amp;sm)) {</a>
<a name="ln5674">          result=i+1;</a>
<a name="ln5675">          break;</a>
<a name="ln5676">        };</a>
<a name="ln5677">        em=nullptr;</a>
<a name="ln5678">      };</a>
<a name="ln5679"> </a>
<a name="ln5680"> </a>
<a name="ln5681">    if (em == nullptr) {</a>
<a name="ln5682">      if (anTemplateNo &gt;= 0) {</a>
<a name="ln5683">        sm.addAtom(6,0,0.0,0.0);</a>
<a name="ln5684">        sm.addBond(1,anTemplateNo,sm.nAtoms()-1);</a>
<a name="ln5685">        sm.defineAtomConn();</a>
<a name="ln5686">      };</a>
<a name="ln5687">      sm.redrawMolecule();</a>
<a name="ln5688">      if (anTemplateNo &gt;= 0) {</a>
<a name="ln5689">        sm.deleteBond(sm.nBonds());</a>
<a name="ln5690">        sm.deleteAtom(sm.nAtoms()-1);</a>
<a name="ln5691">        sm.defineAtomConn();</a>
<a name="ln5692">      };</a>
<a name="ln5693">    } else {</a>
<a name="ln5694">      //Hurrah! Found! Redraw from template</a>
<a name="ln5695">      templateAtomNumber.resize(0);</a>
<a name="ln5696">      fragmentAtomNumber.resize(0);</a>
<a name="ln5697">      //Atom list formation</a>
<a name="ln5698">      atomClean=0;</a>
<a name="ln5699">      vector&lt;int&gt; listAtomClean;</a>
<a name="ln5700">      for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln5701">        test=false;</a>
<a name="ln5702">        for (j=0; j&lt;em-&gt;nAtoms(); j++) {</a>
<a name="ln5703">          k=em-&gt;queryAQTested[j];</a>
<a name="ln5704">          if (i==k) {</a>
<a name="ln5705">            //Coordinates assigning</a>
<a name="ln5706">            sm.getAtom(i)-&gt;rx=em-&gt;getAtom(j)-&gt;rx;</a>
<a name="ln5707">            sm.getAtom(i)-&gt;ry=em-&gt;getAtom(j)-&gt;ry;</a>
<a name="ln5708">            test=true;</a>
<a name="ln5709">            break;</a>
<a name="ln5710">          };</a>
<a name="ln5711">        };</a>
<a name="ln5712">        if (test) {   //Only those atoms, defined at template, are cleaned.....</a>
<a name="ln5713">          listAtomClean.push_back(i);</a>
<a name="ln5714">          atomClean++;</a>
<a name="ln5715">        };</a>
<a name="ln5716">      };</a>
<a name="ln5717"> </a>
<a name="ln5718">      enumerator.resize(sm.nAtoms());  //index-old number value-new number</a>
<a name="ln5719">      for (i=0; i&lt;enumerator.size(); i++) enumerator[i]=-1;</a>
<a name="ln5720">      for (i=0; i&lt;atomClean; i++) enumerator[listAtomClean[i]]=i;</a>
<a name="ln5721">      k=atomClean;</a>
<a name="ln5722">      for (i=0; i&lt;enumerator.size(); i++) if (enumerator[i]==-1) {</a>
<a name="ln5723">          enumerator[i]=k;</a>
<a name="ln5724">          k++;</a>
<a name="ln5725">        };</a>
<a name="ln5726">      //Atom and bond enumeration...</a>
<a name="ln5727"> </a>
<a name="ln5728">      for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln5729">        k=0;</a>
<a name="ln5730">        for (j=0; j&lt;enumerator.size(); j++)  if (enumerator[j]==i) {</a>
<a name="ln5731">            k=j;</a>
<a name="ln5732">            break;</a>
<a name="ln5733">          };</a>
<a name="ln5734">        tm.addAtom(sm.getAtom(k)-&gt;clone());</a>
<a name="ln5735">      };</a>
<a name="ln5736">      //Bond enumeration</a>
<a name="ln5737">      for (i=0; i&lt;sm.nBonds(); i++) {</a>
<a name="ln5738">        sb=sm.getBond(i)-&gt;clone();</a>
<a name="ln5739">        sb-&gt;at[0]=enumerator[sb-&gt;at[0]];</a>
<a name="ln5740">        sb-&gt;at[1]=enumerator[sb-&gt;at[1]];</a>
<a name="ln5741">        tm.addBond(sb);</a>
<a name="ln5742">      };</a>
<a name="ln5743"> </a>
<a name="ln5744">      nFound=atomClean;</a>
<a name="ln5745">      //now tm is the same as sm (simplemolecule) on input, but coordinates will be taken from template for first nFound atoms</a>
<a name="ln5746">      tm.defineAtomConn();</a>
<a name="ln5747">      tm.allAboutCycles();</a>
<a name="ln5748">      //search for connected bonds</a>
<a name="ln5749">      test=true;</a>
<a name="ln5750">      while (test) {</a>
<a name="ln5751">        test=false;</a>
<a name="ln5752">        for (i=tm.nBonds()-1; i&gt;=0; i--) {</a>
<a name="ln5753">          test1=((tm.getBond(i)-&gt;at[0]&lt;nFound) &amp;&amp; (tm.getBond(i)-&gt;at[1]&gt;=nFound)) || ((tm.getBond(i)-&gt;at[1]&lt;nFound) &amp;&amp; (tm.getBond(i)-&gt;at[0]&gt;=nFound));</a>
<a name="ln5754">          if (test1) if (tm.getBond(i)-&gt;db&lt;=1) { //acyclic bond</a>
<a name="ln5755">              test=true;</a>
<a name="ln5756">              emTemplate=new TEditedMolecule();</a>
<a name="ln5757">			  if (tm.getBond(i)-&gt;at[1] &lt; nFound) {</a>
<a name="ln5758">				templateAN=tm.getBond(i)-&gt;at[0];</a>
<a name="ln5759">				fragmentAN=tm.getBond(i)-&gt;at[1];</a>
<a name="ln5760">			  } else {</a>
<a name="ln5761">			    templateAN=tm.getBond(i)-&gt;at[1];</a>
<a name="ln5762">				fragmentAN=tm.getBond(i)-&gt;at[0];</a>
<a name="ln5763">			  }</a>
<a name="ln5764">              templateAtomNumber.push_back(tm.getAtom(templateAN)-&gt;enumerator);  //in template....</a>
<a name="ln5765">              fragmentAtomNumber.push_back(tm.getAtom(fragmentAN)-&gt;enumerator);</a>
<a name="ln5766">              tm.deleteBond(i);  //must be called prior extract fragment</a>
<a name="ln5767">              tm.defineAtomConn();</a>
<a name="ln5768">              smFragment=tm.extractFragment(fragmentAN,nullptr);</a>
<a name="ln5769">              smRest=tm.extractFragment(templateAN,nullptr);</a>
<a name="ln5770">              tm.moleculeCopy(*smRest);</a>
<a name="ln5771">              //I have to delete unnecessary atoms and bond here...</a>
<a name="ln5772">              emTemplate-&gt;moleculeCopy(*smFragment);</a>
<a name="ln5773">              groupsFind.push_back(emTemplate);</a>
<a name="ln5774">              delete(smFragment);</a>
<a name="ln5775">              delete(smRest);</a>
<a name="ln5776">            };</a>
<a name="ln5777">          if (test) break;</a>
<a name="ln5778">        };</a>
<a name="ln5779">      };</a>
<a name="ln5780">      //Atom clean list formation</a>
<a name="ln5781">      atomClean=tm.nAtoms()-nFound;</a>
<a name="ln5782">      listAtomClean.resize(0);</a>
<a name="ln5783">      for (i=0; i&lt;atomClean; i++) listAtomClean.push_back(nFound+i);</a>
<a name="ln5784"> </a>
<a name="ln5785">      vector&lt;int&gt; listBondClean;</a>
<a name="ln5786">      bondClean=0;</a>
<a name="ln5787">      for (i=0; i&lt;tm.nBonds(); i++) {</a>
<a name="ln5788">        test=false;</a>
<a name="ln5789">        for (j=0; j&lt;atomClean; j++) {</a>
<a name="ln5790">          if (listAtomClean[j]==tm.getBond(i)-&gt;at[0]) test=true;</a>
<a name="ln5791">          if (listAtomClean[j]==tm.getBond(i)-&gt;at[1]) test=true;</a>
<a name="ln5792">          if (test) break;</a>
<a name="ln5793">        };</a>
<a name="ln5794">        if (test) {</a>
<a name="ln5795">          listBondClean.push_back(i);</a>
<a name="ln5796">          bondClean++;</a>
<a name="ln5797">        };</a>
<a name="ln5798">      };</a>
<a name="ln5799">      //and cleaning....</a>
<a name="ln5800">      tm.defineAtomConn();</a>
<a name="ln5801">      tm.redraw(listAtomClean,listBondClean,atomClean,bondClean,4,0,0,false);</a>
<a name="ln5802">      for (i=0; i&lt;groupsFind.size(); i++) {</a>
<a name="ln5803">        emTemplate=(TEditedMolecule *)groupsFind[i];</a>
<a name="ln5804">        fragmentAN=-1;</a>
<a name="ln5805">        for (j=0; j&lt;emTemplate-&gt;nAtoms(); j++) if (emTemplate-&gt;getAtom(j)-&gt;enumerator==fragmentAtomNumber[i]) {</a>
<a name="ln5806">            fragmentAN=j;</a>
<a name="ln5807">            break;</a>
<a name="ln5808">          };</a>
<a name="ln5809"> </a>
<a name="ln5810">        emTemplate-&gt;refofs=sm.refofs;</a>
<a name="ln5811"> </a>
<a name="ln5812">        coordinatesPrepare(*emTemplate,0,fragmentAN);  //recursive call</a>
<a name="ln5813">        templateAN=-1; fragmentAN=-1;</a>
<a name="ln5814">        for (j=0; j&lt;tm.nAtoms(); j++) if (tm.getAtom(j)-&gt;enumerator==templateAtomNumber[i]) {</a>
<a name="ln5815">            templateAN=j;</a>
<a name="ln5816">            break;</a>
<a name="ln5817">          };</a>
<a name="ln5818">        for (j=0; j&lt;emTemplate-&gt;nAtoms(); j++) if (emTemplate-&gt;getAtom(j)-&gt;enumerator==fragmentAtomNumber[i]) {</a>
<a name="ln5819">            fragmentAN=j;</a>
<a name="ln5820">            break;</a>
<a name="ln5821">          };</a>
<a name="ln5822">		if ((templateAN&gt;=0) &amp;&amp; (fragmentAN&gt;=0)) {</a>
<a name="ln5823">          naStore=tm.nAtoms();</a>
<a name="ln5824">          tm.refofs=sm.refofs;</a>
<a name="ln5825">          tm.addAsTemplate(*emTemplate,templateAN,fragmentAN,-1,-1,true);</a>
<a name="ln5826">		};</a>
<a name="ln5827">      };</a>
<a name="ln5828">      sm.moleculeCopy(tm);</a>
<a name="ln5829">      sm.defineAtomConn();</a>
<a name="ln5830">      sm.allAboutCycles();</a>
<a name="ln5831">    };</a>
<a name="ln5832">    for (i=0; i&lt;groupsFind.size(); i++) delete(groupsFind[i]);</a>
<a name="ln5833">    return result;</a>
<a name="ln5834">  };</a>
<a name="ln5835"> </a>
<a name="ln5836"> </a>
<a name="ln5837">  class StereoBondStore {</a>
<a name="ln5838">  public:</a>
<a name="ln5839">    int bn,w;</a>
<a name="ln5840">  };</a>
<a name="ln5841"> </a>
<a name="ln5842">  void TemplateRedraw::redrawFine(TSimpleMolecule&amp; smIn) {</a>
<a name="ln5843"> </a>
<a name="ln5844">    int i,j,n;</a>
<a name="ln5845">    std::vector&lt;int&gt; atomTested(smIn.nAtoms());</a>
<a name="ln5846">    std::vector&lt;int&gt; atomList;</a>
<a name="ln5847">    std::vector&lt;StereoBondStore *&gt; stereoBondList(0);</a>
<a name="ln5848">    int w;</a>
<a name="ln5849">    PartFragmentDefinition * pf;</a>
<a name="ln5850">    std::vector&lt;PartFragmentDefinition *&gt; frList(0);</a>
<a name="ln5851">    double xMin,xMax,yMin,yMax;</a>
<a name="ln5852">    double oldBondLength,newBondLength;</a>
<a name="ln5853">    std::vector&lt;TEditedMolecule *&gt; molList(0); //contains list of molecules...</a>
<a name="ln5854">    TEditedMolecule * sm;</a>
<a name="ln5855">    TEditedMolecule smCopy;</a>
<a name="ln5856">    TEditedMolecule smCopy2;</a>
<a name="ln5857">    int frCount,nA;</a>
<a name="ln5858">    TSingleAtom * sA;</a>
<a name="ln5859">    TSingleBond * sB;</a>
<a name="ln5860">    StereoBondStore * sbs;</a>
<a name="ln5861">    int nOverlapped, nOverlappedMin;</a>
<a name="ln5862"> </a>
<a name="ln5863">    //smIn will be clear-nothing</a>
<a name="ln5864"> </a>
<a name="ln5865">	for (int i=0; i&lt;smIn.nAtoms(); i++) {</a>
<a name="ln5866">	  smIn.getAtom(i)-&gt;rx=cos(2*PI*i/smIn.nAtoms());</a>
<a name="ln5867">	  smIn.getAtom(i)-&gt;ry=-sin(2*PI*i/smIn.nAtoms());</a>
<a name="ln5868">	};</a>
<a name="ln5869">	smIn.defineAtomConn();</a>
<a name="ln5870">	smIn.allAboutCycles();</a>
<a name="ln5871">	smIn.redrawMolecule();</a>
<a name="ln5872"> </a>
<a name="ln5873"> </a>
<a name="ln5874"> </a>
<a name="ln5875">    oldBondLength=smIn.averageBondLength();</a>
<a name="ln5876">    if (oldBondLength &lt; 0.1) oldBondLength=1.0;</a>
<a name="ln5877"> </a>
<a name="ln5878">    smCopy.moleculeCopy(smIn);</a>
<a name="ln5879"> </a>
<a name="ln5880">    for (i=0; i&lt;smIn.nBonds(); i++) if ((smIn.getBond(i)-&gt;tb == 9)  || (smIn.getBond(i)-&gt;tb == 10)) {</a>
<a name="ln5881">        w=0;  //!!!! add for STEREO later !!!! w.value=ProcessStereo.analizeRS(smIn,smIn.fBond.getAT(i,1));</a>
<a name="ln5882"> </a>
<a name="ln5883">        if (w&gt;0) {</a>
<a name="ln5884">          sbs=new StereoBondStore();</a>
<a name="ln5885">          sbs-&gt;bn=i;</a>
<a name="ln5886">          sbs-&gt;w=w;</a>
<a name="ln5887">          stereoBondList.push_back(sbs);</a>
<a name="ln5888">        };</a>
<a name="ln5889">      };</a>
<a name="ln5890"> </a>
<a name="ln5891">    for (i=0; i&lt;smCopy.nAtoms(); i++) smCopy.getAtom(i)-&gt;anum=intToStr(i);</a>
<a name="ln5892"> </a>
<a name="ln5893">    for (i=0; i&lt;smCopy.nAtoms(); i++) atomTested[i]=0;</a>
<a name="ln5894"> </a>
<a name="ln5895">    bool testSingleAtom=false;</a>
<a name="ln5896">    for (i=0; i&lt;smCopy.nAtoms(); i++) if (atomTested[i] == 0) {</a>
<a name="ln5897">        smCopy.makeFragment(atomList,i,-1);</a>
<a name="ln5898">        for (j=0; j&lt;atomList.size(); j++) {</a>
<a name="ln5899">          n=atomList[j];</a>
<a name="ln5900">          atomTested[n]=1;</a>
<a name="ln5901">        };</a>
<a name="ln5902">        sm=smCopy.extractFragment(i,nullptr);</a>
<a name="ln5903">        sm-&gt;defineAtomConn();</a>
<a name="ln5904">        if ((i == 0) &amp;&amp; (sm-&gt;nAtoms() == 1)) testSingleAtom=true;</a>
<a name="ln5905">        molList.push_back(sm);</a>
<a name="ln5906">      };</a>
<a name="ln5907">    //Bug conversion reported by Chris 08.08.2010-Illegal Atomic Coordinates. Reason-zero bond length for single atom</a>
<a name="ln5908">    if (testSingleAtom  &amp;&amp; (molList.size() &gt; 1)) {</a>
<a name="ln5909">      n=-1;</a>
<a name="ln5910">      for (frCount=0; frCount&lt;molList.size(); frCount++) {</a>
<a name="ln5911">        sm=(TEditedMolecule *)molList[frCount];</a>
<a name="ln5912">        if (sm-&gt;nAtoms() &gt; 1) {</a>
<a name="ln5913">          n=frCount;</a>
<a name="ln5914">          break;</a>
<a name="ln5915">        };</a>
<a name="ln5916">      };</a>
<a name="ln5917">      if (n &gt; 0) {</a>
<a name="ln5918">        sm=(TEditedMolecule *)molList[n];</a>
<a name="ln5919">        molList[n]=molList[0];</a>
<a name="ln5920">        molList[0]=sm;</a>
<a name="ln5921">      };</a>
<a name="ln5922">    };</a>
<a name="ln5923"> </a>
<a name="ln5924">    int qq=0;</a>
<a name="ln5925"> </a>
<a name="ln5926">    for (frCount=0; frCount&lt;molList.size(); frCount++) {</a>
<a name="ln5927">      sm=(TEditedMolecule *)molList[frCount];</a>
<a name="ln5928">      for (i=0; i&lt;sm-&gt;nAtoms(); i++) sm-&gt;getAtom(i)-&gt;enumerator=i;</a>
<a name="ln5929">      n=0;</a>
<a name="ln5930">      nOverlappedMin=10000000;</a>
<a name="ln5931">      smCopy2.moleculeCopy(*sm);</a>
<a name="ln5932">      while (n &gt;=0) {</a>
<a name="ln5933">        qq++;</a>
<a name="ln5934">        sm-&gt;refofs=smIn.refofs;</a>
<a name="ln5935">        n=coordinatesPrepare(*sm,n,-1);</a>
<a name="ln5936"> </a>
<a name="ln5937">        sm-&gt;correctDblBondStereo();</a>
<a name="ln5938">        nOverlapped=sm-&gt;correctOverlapped();</a>
<a name="ln5939">        if (nOverlapped &lt; nOverlappedMin) {</a>
<a name="ln5940">          smCopy2.moleculeCopy(*sm);</a>
<a name="ln5941">          nOverlappedMin=nOverlapped;</a>
<a name="ln5942">        } else sm-&gt;moleculeCopy(smCopy2);</a>
<a name="ln5943"> </a>
<a name="ln5944">        if (nOverlappedMin == 0) n=-1;</a>
<a name="ln5945">      };</a>
<a name="ln5946"> </a>
<a name="ln5947">      sm-&gt;defineAtomConn();</a>
<a name="ln5948">      atomList.resize(sm-&gt;nAtoms());</a>
<a name="ln5949">      for (i=0; i&lt;atomList.size(); i++) atomList[i]=i;</a>
<a name="ln5950">      selectFragmentConfiguration(sm,&amp;atomList);</a>
<a name="ln5951">      newBondLength=sm-&gt;averageBondLength();</a>
<a name="ln5952">      if (newBondLength &gt; 0)  for (i=0; i&lt;sm-&gt;nAtoms(); i++) {</a>
<a name="ln5953">          sm-&gt;getAtom(i)-&gt;rx=sm-&gt;getAtom(i)-&gt;rx*oldBondLength/newBondLength;</a>
<a name="ln5954">          sm-&gt;getAtom(i)-&gt;ry=sm-&gt;getAtom(i)-&gt;ry*oldBondLength/newBondLength;</a>
<a name="ln5955">        };</a>
<a name="ln5956">      //stereo input try</a>
<a name="ln5957">    };</a>
<a name="ln5958"> </a>
<a name="ln5959">    frList.resize(0);</a>
<a name="ln5960"> </a>
<a name="ln5961"> </a>
<a name="ln5962">    smCopy.clear();</a>
<a name="ln5963">    nA=0;</a>
<a name="ln5964">    for (frCount=0; frCount&lt;molList.size(); frCount++) {</a>
<a name="ln5965">      sm=(TEditedMolecule *)molList[frCount];</a>
<a name="ln5966">      for (i=0; i&lt;sm-&gt;nAtoms(); i++) {</a>
<a name="ln5967">        sA=sm-&gt;getAtom(i)-&gt;clone();</a>
<a name="ln5968">        smCopy.addAtom(sA);</a>
<a name="ln5969">      };</a>
<a name="ln5970">      for (i=0; i&lt;sm-&gt;nBonds(); i++) {</a>
<a name="ln5971">        sB=sm-&gt;getBond(i)-&gt;clone();</a>
<a name="ln5972">        sB-&gt;at[0]=sm-&gt;getBond(i)-&gt;at[0]+nA;</a>
<a name="ln5973">        sB-&gt;at[1]=sm-&gt;getBond(i)-&gt;at[1]+nA;</a>
<a name="ln5974">        smCopy.addBond(sB);</a>
<a name="ln5975">      };</a>
<a name="ln5976">      //dimensions store....</a>
<a name="ln5977"> </a>
<a name="ln5978"> </a>
<a name="ln5979">      xMin=RUNDEF; xMax=RUNDEF; yMin=RUNDEF; yMax=RUNDEF;</a>
<a name="ln5980">      for (j=0; j&lt;sm-&gt;nAtoms(); j++) {</a>
<a name="ln5981">        if ((sm-&gt;getAtom(j)-&gt;rx &lt; xMin) || (xMin == RUNDEF)) xMin=sm-&gt;getAtom(j)-&gt;rx;</a>
<a name="ln5982">        if ((sm-&gt;getAtom(j)-&gt;rx &gt; xMax) || (xMax == RUNDEF)) xMax=sm-&gt;getAtom(j)-&gt;rx;</a>
<a name="ln5983">        if ((sm-&gt;getAtom(j)-&gt;ry &lt; yMin) || (yMin == RUNDEF)) yMin=sm-&gt;getAtom(j)-&gt;ry;</a>
<a name="ln5984">        if ((sm-&gt;getAtom(j)-&gt;ry &gt; yMax) || (yMax == RUNDEF)) yMax=sm-&gt;getAtom(j)-&gt;ry;</a>
<a name="ln5985">      };</a>
<a name="ln5986">      pf=new PartFragmentDefinition();</a>
<a name="ln5987">      pf-&gt;fragID1=0;</a>
<a name="ln5988">      pf-&gt;fragID2=0;</a>
<a name="ln5989">      pf-&gt;fragID3=0;</a>
<a name="ln5990">      pf-&gt;fragFirstAtomNo=nA; // Was nA+1, lead to off-by-one problems with fragments</a>
<a name="ln5991">      pf-&gt;fragmentCount=1;</a>
<a name="ln5992">      pf-&gt;fragWidth=xMax-xMin;</a>
<a name="ln5993">      pf-&gt;fragHeight=yMax-yMin;</a>
<a name="ln5994">      pf-&gt;fragTop=0;</a>
<a name="ln5995">      pf-&gt;fragLeft=0;</a>
<a name="ln5996">      frList.push_back(pf);</a>
<a name="ln5997">      //Prepare for new get</a>
<a name="ln5998">      nA=nA+sm-&gt;nAtoms();</a>
<a name="ln5999">    };</a>
<a name="ln6000">    smCopy.defineAtomConn();</a>
<a name="ln6001">    //arrange fragments</a>
<a name="ln6002">    if (frList.size()&gt;1) {</a>
<a name="ln6003">      newBondLength=smCopy.averageBondLength();</a>
<a name="ln6004">      for (i=0;i&lt;frList.size(); i++) {</a>
<a name="ln6005">        pf=(PartFragmentDefinition *)frList[i];</a>
<a name="ln6006">        pf-&gt;fragWidth=pf-&gt;fragWidth+newBondLength;</a>
<a name="ln6007">        pf-&gt;fragHeight=pf-&gt;fragHeight+newBondLength;</a>
<a name="ln6008">      };</a>
<a name="ln6009">      arrangeMolecules(frList,1/1.5);</a>
<a name="ln6010">      //rescaling in fragments....</a>
<a name="ln6011">      for (i=0; i&lt;frList.size(); i++) {</a>
<a name="ln6012">        pf=(PartFragmentDefinition *)frList[i];</a>
<a name="ln6013">        smCopy.makeFragment(atomList,pf-&gt;fragFirstAtomNo,-1);</a>
<a name="ln6014">        rescaleSingleFragment(&amp;smCopy,&amp;atomList,*pf,newBondLength/2);</a>
<a name="ln6015">      };</a>
<a name="ln6016">    };</a>
<a name="ln6017">    //rescaling to satisfy bond length</a>
<a name="ln6018">    newBondLength=smCopy.averageBondLength();</a>
<a name="ln6019">    if (newBondLength&gt;0) for (i=0; i&lt;smCopy.nAtoms(); i++) {</a>
<a name="ln6020">        smCopy.getAtom(i)-&gt;rx=smCopy.getAtom(i)-&gt;rx*oldBondLength/newBondLength;</a>
<a name="ln6021">        smCopy.getAtom(i)-&gt;ry=smCopy.getAtom(i)-&gt;ry*oldBondLength/newBondLength;</a>
<a name="ln6022">      };</a>
<a name="ln6023">    for (i=0; i&lt;smCopy.nAtoms(); i++) {</a>
<a name="ln6024">      n=atoi(smCopy.getAtom(i)-&gt;anum.c_str());</a>
<a name="ln6025">      if (n &gt;= 0) {</a>
<a name="ln6026">        smIn.getAtom(n)-&gt;rx=smCopy.getAtom(i)-&gt;rx;</a>
<a name="ln6027">        smIn.getAtom(n)-&gt;ry=smCopy.getAtom(i)-&gt;ry;</a>
<a name="ln6028">      };</a>
<a name="ln6029">    };</a>
<a name="ln6030">    for (i=0; i&lt;stereoBondList.size(); i++) {</a>
<a name="ln6031">      sbs=(StereoBondStore *)stereoBondList[i];</a>
<a name="ln6032">      //w=ProcessStereo.analizeRS(smIn,smIn.fBond.getAT(sbs-&gt;bn,1)); !!!! add for STEREO later !!!!</a>
<a name="ln6033">      w = 0; // Added by Noel as the previous line assigning w has been commented out</a>
<a name="ln6034">      if ((w &gt; 0) &amp;&amp; (w != sbs-&gt;w)) {</a>
<a name="ln6035">        if (smIn.getBond(sbs-&gt;bn)-&gt;tb == 9) smIn.getBond(sbs-&gt;bn)-&gt;tb=10; else smIn.getBond(sbs-&gt;bn)-&gt;tb=9;</a>
<a name="ln6036">      };</a>
<a name="ln6037">    };</a>
<a name="ln6038">    for (i=0; i&lt;stereoBondList.size(); i++) delete(stereoBondList[i]);</a>
<a name="ln6039">    for (i=0; i&lt;frList.size(); i++) delete(frList[i]);</a>
<a name="ln6040">    for (i=0; i&lt;molList.size(); i++) delete(molList[i]);</a>
<a name="ln6041">  };</a>
<a name="ln6042"> </a>
<a name="ln6043"> </a>
<a name="ln6044">  //-----------------------------------------------------------------------</a>
<a name="ln6045">  //***********************************************************************</a>
<a name="ln6046">  /*</a>
<a name="ln6047">    Diagram is generated using templates, which are stored in SD file templates.sdf</a>
<a name="ln6048">    The SD file is usual SD file, which contain chemical structures and might contain data.</a>
<a name="ln6049">    Only chemical structures are used. Subgraph isomorphisme search is executed and coordinates</a>
<a name="ln6050">    of atoms are determined from templates. See Molecules, 11, 129-141 (2006) for algorithm decription.</a>
<a name="ln6051">    Structures in SD file are converted in next manner:</a>
<a name="ln6052">    1. All atoms, except explicit hydrogens, are replaced with generic ANY_ATOM (matched with any atom in subgraph isomorphisme search)</a>
<a name="ln6053">    2. All bonds are replaces with generic ANY_BOND, which can be matched with any bond in molecule</a>
<a name="ln6054">    3. All hydrogen are removed, but they are used for search-query and structure atom matching is believed fo be</a>
<a name="ln6055">    successful if chemical structure contains more or equal number of hydrogens, than query. Using explicitly-defined hydrogens</a>
<a name="ln6056">    on query enables ones to remove substitutors attachment for atom, which are sterically hidden on templates</a>
<a name="ln6057">    if the file will not be found, predefined templates will be used</a>
<a name="ln6058">  */</a>
<a name="ln6059">  void generateDiagram(OBMol * pmol, std::ostream &amp; ofs) {</a>
<a name="ln6060">    TEditedMolecule sm;</a>
<a name="ln6061">    OBAtom * atom;</a>
<a name="ln6062"> </a>
<a name="ln6063">    sm.readOBMol(pmol);</a>
<a name="ln6064">    sm.refofs=&amp;ofs;</a>
<a name="ln6065"> </a>
<a name="ln6066">    TemplateRedraw tr;</a>
<a name="ln6067">    tr.redrawFine(sm);</a>
<a name="ln6068">    for (unsigned int i=1; i&lt;=pmol-&gt;NumAtoms(); i++) {</a>
<a name="ln6069">      atom=pmol-&gt;GetAtom(i);</a>
<a name="ln6070">      atom-&gt;SetVector(sm.getAtom(i-1)-&gt;rx,-sm.getAtom(i-1)-&gt;ry,0.0);</a>
<a name="ln6071">    };</a>
<a name="ln6072">    sm.getMolfile(ofs);</a>
<a name="ln6073">  };</a>
<a name="ln6074"> </a>
<a name="ln6075">  void generateDiagram(OBMol * pmol) {</a>
<a name="ln6076">    TEditedMolecule sm;</a>
<a name="ln6077">    OBAtom * atom;</a>
<a name="ln6078"> </a>
<a name="ln6079">    sm.readOBMol(pmol);</a>
<a name="ln6080"> </a>
<a name="ln6081">    TemplateRedraw tr;</a>
<a name="ln6082">    tr.redrawFine(sm);</a>
<a name="ln6083">    for (unsigned int i=1; i&lt;=pmol-&gt;NumAtoms(); i++) {</a>
<a name="ln6084">      atom=pmol-&gt;GetAtom(i);</a>
<a name="ln6085">      atom-&gt;SetVector(sm.getAtom(i-1)-&gt;rx,-sm.getAtom(i-1)-&gt;ry,0.0);</a>
<a name="ln6086">    };</a>
<a name="ln6087">  };</a>
<a name="ln6088"> </a>
<a name="ln6089">  void generateDiagram(const std::vector&lt;int&gt; iA1, const std::vector&lt;int&gt; iA2,</a>
<a name="ln6090">                       std::vector&lt;double&gt;&amp; rx, std::vector&lt;double&gt;&amp; ry, int nAtoms, int nBonds) {</a>
<a name="ln6091"> </a>
<a name="ln6092">    TEditedMolecule sm;</a>
<a name="ln6093"> </a>
<a name="ln6094">    sm.readConnectionMatrix(iA1,iA2,nAtoms,nBonds);</a>
<a name="ln6095">    TemplateRedraw tr;</a>
<a name="ln6096">    tr.redrawFine(sm);</a>
<a name="ln6097"> </a>
<a name="ln6098">    sm.normalizeCoordinates(1.0);</a>
<a name="ln6099">    rx.resize(nAtoms);</a>
<a name="ln6100">    ry.resize(nAtoms);</a>
<a name="ln6101">    for (int i=0; i&lt;nAtoms; i++) {</a>
<a name="ln6102">      rx[i]=sm.getAtom(i)-&gt;rx;</a>
<a name="ln6103">      ry[i]=-sm.getAtom(i)-&gt;ry;</a>
<a name="ln6104">    };</a>
<a name="ln6105">  };</a>
<a name="ln6106"> </a>
<a name="ln6107">  bool fragmentSearch(OBMol * query, OBMol * structure) {</a>
<a name="ln6108"> </a>
<a name="ln6109">    TEditedMolecule sm;</a>
<a name="ln6110">    TEditedMolecule em;</a>
<a name="ln6111">    bool result=false;</a>
<a name="ln6112"> </a>
<a name="ln6113">    sm.readOBMol(query);</a>
<a name="ln6114">    sm.defineAtomConn();</a>
<a name="ln6115">    sm.allAboutCycles();</a>
<a name="ln6116">    em.prepareQuery(sm);</a>
<a name="ln6117">    sm.clear();</a>
<a name="ln6118">    sm.readOBMol(structure);</a>
<a name="ln6119">    sm.defineAtomConn();</a>
<a name="ln6120">    sm.allAboutCycles();</a>
<a name="ln6121"> </a>
<a name="ln6122">    result=em.fragmentSearch(&amp;sm,nullptr);</a>
<a name="ln6123">    return result;</a>
<a name="ln6124">  };</a>
<a name="ln6125"> </a>
<a name="ln6126">  bool fragmentSearch(const std::vector&lt;int&gt; aPositionQuery, const std::vector&lt;int&gt; iA1Query,</a>
<a name="ln6127">                      const std::vector&lt;int&gt; iA2Query,  const std::vector&lt;int&gt; bondTypesQuery, const std::vector&lt;int&gt; aPositionStructure, const std::vector&lt;int&gt; iA1Structure,</a>
<a name="ln6128">                      const std::vector&lt;int&gt; iA2Structure,  const std::vector&lt;int&gt; bondTypesStructure, int nAtomsQuery, int nBondsQuery, int nAtomsStructure, int nBondsStructure) {</a>
<a name="ln6129"> </a>
<a name="ln6130">    TEditedMolecule sm;</a>
<a name="ln6131">    TEditedMolecule em;</a>
<a name="ln6132">    bool result=false;</a>
<a name="ln6133">    TSingleAtom * sa;</a>
<a name="ln6134">    TSingleBond * sb;</a>
<a name="ln6135">    int i;</a>
<a name="ln6136"> </a>
<a name="ln6137">    sm.readConnectionMatrix(iA1Query,iA2Query,nAtomsQuery,nBondsQuery);</a>
<a name="ln6138">    for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln6139">      sa=sm.getAtom(i);</a>
<a name="ln6140">      sa-&gt;na=aPositionQuery[i];</a>
<a name="ln6141">    };</a>
<a name="ln6142">    for (i=0; i&lt;sm.nBonds(); i++) {</a>
<a name="ln6143">      sb=sm.getBond(i);</a>
<a name="ln6144">      sb-&gt;tb=bondTypesQuery[i];</a>
<a name="ln6145">    };</a>
<a name="ln6146">    sm.defineAtomConn();</a>
<a name="ln6147">    sm.allAboutCycles();</a>
<a name="ln6148">    em.prepareQuery(sm);</a>
<a name="ln6149">    sm.clear();</a>
<a name="ln6150">    sm.readConnectionMatrix(iA1Structure,iA2Structure,nAtomsStructure,nBondsStructure);</a>
<a name="ln6151">    for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln6152">      sa=sm.getAtom(i);</a>
<a name="ln6153">      sa-&gt;na=aPositionStructure[i];</a>
<a name="ln6154">    };</a>
<a name="ln6155">    for (i=0; i&lt;sm.nBonds(); i++) {</a>
<a name="ln6156">      sb=sm.getBond(i);</a>
<a name="ln6157">      sb-&gt;tb=bondTypesStructure[i];</a>
<a name="ln6158">    };</a>
<a name="ln6159">    sm.defineAtomConn();</a>
<a name="ln6160">    sm.allAboutCycles();</a>
<a name="ln6161"> </a>
<a name="ln6162">    result=em.fragmentSearch(&amp;sm,nullptr);</a>
<a name="ln6163">    return result;</a>
<a name="ln6164">  };</a>
<a name="ln6165"> </a>
<a name="ln6166"> </a>
<a name="ln6167">  void equivalenceList(const std::vector&lt;int&gt; aPosition,const std::vector&lt;int&gt; aCharge,</a>
<a name="ln6168">                       const std::vector&lt;int&gt; aRad, const std::vector&lt;int&gt; iA1, const std::vector&lt;int&gt; iA2,</a>
<a name="ln6169">                       const std::vector&lt;int&gt; bondTypes,  std::vector&lt;int&gt;&amp; eqList, int nAtoms, int nBonds) {</a>
<a name="ln6170"> </a>
<a name="ln6171">    TEditedMolecule sm;</a>
<a name="ln6172">    TSingleAtom * sa;</a>
<a name="ln6173">    TSingleBond * sb;</a>
<a name="ln6174">    int i;</a>
<a name="ln6175"> </a>
<a name="ln6176">    sm.readConnectionMatrix(iA1,iA2,nAtoms,nBonds);</a>
<a name="ln6177">    for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln6178">      sa=sm.getAtom(i);</a>
<a name="ln6179">      sa-&gt;na=aPosition[i];</a>
<a name="ln6180">      sa-&gt;nc=aCharge[i];</a>
<a name="ln6181">      sa-&gt;rl=aRad[i];</a>
<a name="ln6182">    };</a>
<a name="ln6183">    for (i=0; i&lt;sm.nBonds(); i++) {</a>
<a name="ln6184">      sb=sm.getBond(i);</a>
<a name="ln6185">      sb-&gt;tb=bondTypes[i];</a>
<a name="ln6186">    };</a>
<a name="ln6187">    sm.defineAtomConn();</a>
<a name="ln6188">    sm.allAboutCycles();</a>
<a name="ln6189">    sm.makeEquivalentList(eqList,false);</a>
<a name="ln6190">  };</a>
<a name="ln6191"> </a>
<a name="ln6192"> </a>
<a name="ln6193">  void equivalenceList(OBMol * pmol,  std::vector&lt;int&gt;&amp; eqList) {</a>
<a name="ln6194">    TEditedMolecule sm;</a>
<a name="ln6195"> </a>
<a name="ln6196">    sm.readOBMol(pmol);</a>
<a name="ln6197">    sm.defineAtomConn();</a>
<a name="ln6198">    sm.allAboutCycles();</a>
<a name="ln6199">    sm.makeEquivalentList(eqList,false);</a>
<a name="ln6200">  };</a>
<a name="ln6201"> </a>
<a name="ln6202">  void addFragment(OBMol * molecule, OBMol * fragment, int molAN, int fragAN, int molBN, int fragBN, bool isAddition) {</a>
<a name="ln6203">    TEditedMolecule eMol;</a>
<a name="ln6204">    TEditedMolecule eFrag;</a>
<a name="ln6205">    OBAtom sa;</a>
<a name="ln6206">    int i;</a>
<a name="ln6207"> </a>
<a name="ln6208">    if (molecule == fragment) return;</a>
<a name="ln6209">    eMol.readOBMol(molecule);</a>
<a name="ln6210">    eFrag.readOBMol(fragment);</a>
<a name="ln6211">    eMol.addAsTemplate(eFrag,molAN,fragAN,molBN,fragBN,isAddition);</a>
<a name="ln6212">    molecule-&gt;Clear();</a>
<a name="ln6213">    for (i=0; i&lt;eMol.nAtoms(); i++) {</a>
<a name="ln6214">      sa.Clear();</a>
<a name="ln6215">      sa.SetAtomicNum(eMol.getAtom(i)-&gt;na);</a>
<a name="ln6216">      sa.SetFormalCharge(eMol.getAtom(i)-&gt;na);</a>
<a name="ln6217">      if (eMol.getAtom(i)-&gt;rl != 0) sa.SetSpinMultiplicity(1);</a>
<a name="ln6218">      sa.SetVector(eMol.getAtom(i)-&gt;rx,eMol.getAtom(i)-&gt;ry,0.0);</a>
<a name="ln6219">      molecule-&gt;AddAtom(sa);</a>
<a name="ln6220">    };</a>
<a name="ln6221">    for (i=0; i&lt;eMol.nBonds(); i++) molecule-&gt;AddBond(eMol.getBond(i)-&gt;at[0]+1,eMol.getBond(i)-&gt;at[1]+1,eMol.getBond(i)-&gt;tb);</a>
<a name="ln6222">    molecule-&gt;EndModify();</a>
<a name="ln6223">  };</a>
<a name="ln6224"> </a>
<a name="ln6225"> </a>
<a name="ln6226">  void createStereoLists(OBMol * pmol, std::vector&lt;int&gt;&amp; bondStereoList, std::vector&lt;int&gt;&amp; atomStereoList, std::vector&lt;int&gt;&amp; eqList) {</a>
<a name="ln6227">    TEditedMolecule sm;</a>
<a name="ln6228">    int n,m,i,j,n1,n2;</a>
<a name="ln6229">    bool test;</a>
<a name="ln6230"> </a>
<a name="ln6231">    //checking if multiply stereocenters or acyclic double=bonds are present</a>
<a name="ln6232">    sm.readOBMol(pmol);</a>
<a name="ln6233">    sm.defineAtomConn();</a>
<a name="ln6234">    sm.allAboutCycles();</a>
<a name="ln6235">    n=0;</a>
<a name="ln6236">    m=0;</a>
<a name="ln6237">    for (i=0; i&lt;sm.nBonds();  i++) {</a>
<a name="ln6238">      if ((sm.getBond(i)-&gt;tb == 9) || (sm.getBond(i)-&gt;tb == 10)) n++;</a>
<a name="ln6239">      if ((sm.getBond(i)-&gt;tb == 2) &amp;&amp; (sm.getBond(i)-&gt;db &lt; 2)) m++;</a>
<a name="ln6240">      if ((m &gt; 0) || (n &gt; 1)) break;</a>
<a name="ln6241">    };</a>
<a name="ln6242">    sm.makeEquivalentList(eqList,false);</a>
<a name="ln6243">    bondStereoList.resize(sm.nBonds());</a>
<a name="ln6244">    for (i=0; i&lt;sm.nBonds(); i++) bondStereoList[i]=0;</a>
<a name="ln6245">    for (i=0; i&lt;sm.nBonds(); i++) if ((sm.getBond(i)-&gt;tb == 2) &amp;&amp; (sm.getBond(i)-&gt;db &lt; 2)) {</a>
<a name="ln6246">        //possible YES!</a>
<a name="ln6247">        n=sm.getBond(i)-&gt;at[0];</a>
<a name="ln6248">        test=(sm.getAtom(n)-&gt;nb &gt; 1) &amp;&amp; (sm.getAtom(n)-&gt;nb &lt;= 3);</a>
<a name="ln6249">        if (test) {</a>
<a name="ln6250">          n=sm.getBond(i)-&gt;at[1];</a>
<a name="ln6251">          test=(sm.getAtom(n)-&gt;nb &gt; 1) &amp;&amp; (sm.getAtom(n)-&gt;nb &lt;= 3);</a>
<a name="ln6252">        };</a>
<a name="ln6253">        n=sm.getBond(i)-&gt;at[0];</a>
<a name="ln6254">        m=sm.getBond(i)-&gt;at[1];</a>
<a name="ln6255">        if (test &amp;&amp; (sm.getAtom(n)-&gt;nb == 3)) {  //checking if equivalent substitutors are present....</a>
<a name="ln6256">          n1=-1;</a>
<a name="ln6257">          n2=-1;</a>
<a name="ln6258">          for (j=0; j&lt;sm.getAtom(n)-&gt;nb; j++) if (sm.getAtom(n)-&gt;ac[j] != m) {</a>
<a name="ln6259">              if (n1 == -1) n1=sm.getAtom(n)-&gt;ac[j]; else n2=sm.getAtom(n)-&gt;ac[j];</a>
<a name="ln6260">            };</a>
<a name="ln6261">          if ((n1 &gt;= 0) &amp;&amp; (n2 &gt;= 0)) {</a>
<a name="ln6262">            if (eqList[n1] == eqList[n2]) test=false;</a>
<a name="ln6263">          };</a>
<a name="ln6264">        };</a>
<a name="ln6265">        n=sm.getBond(i)-&gt;at[1];</a>
<a name="ln6266">        m=sm.getBond(i)-&gt;at[0];</a>
<a name="ln6267">        if (test &amp;&amp; (sm.getAtom(n)-&gt;nb == 3)) {  //checking if equivalent substitutors are present....</a>
<a name="ln6268">          n1=-1;</a>
<a name="ln6269">          n2=-1;</a>
<a name="ln6270">          for (j=0; j&lt;sm.getAtom(n)-&gt;nb; j++) if (sm.getAtom(n)-&gt;ac[j] != m) {</a>
<a name="ln6271">              if (n1 == -1) n1=sm.getAtom(n)-&gt;ac[j]; else n2=sm.getAtom(n)-&gt;ac[j];</a>
<a name="ln6272">            };</a>
<a name="ln6273">          if ((n1 &gt;= 0) &amp;&amp; (n2 &gt;= 0)) {</a>
<a name="ln6274">            if (eqList[n1] == eqList[n2]) test=false;</a>
<a name="ln6275">          };</a>
<a name="ln6276">        };</a>
<a name="ln6277">        if (test) bondStereoList[i]=1;</a>
<a name="ln6278">      };  //end of double bond stereo list formation</a>
<a name="ln6279"> </a>
<a name="ln6280">    //Formation of atoms, which have stereo notation....</a>
<a name="ln6281">    atomStereoList.resize(sm.nAtoms());</a>
<a name="ln6282">    for (i=0; i&lt;sm.nAtoms(); i++) atomStereoList[i]=0;</a>
<a name="ln6283">    for (i=0; i&lt;sm.nBonds(); i++) if ((sm.getBond(i)-&gt;tb == 9) || (sm.getBond(i)-&gt;tb == 10)) {</a>
<a name="ln6284">        n=sm.getBond(i)-&gt;at[0];</a>
<a name="ln6285">        atomStereoList[n]=1;</a>
<a name="ln6286">      };</a>
<a name="ln6287">  };</a>
<a name="ln6288"> </a>
<a name="ln6289">  int compareStringsNumbers(string s1, string s2) {</a>
<a name="ln6290"> </a>
<a name="ln6291">    int result;</a>
<a name="ln6292">    unsigned int n, i;</a>
<a name="ln6293"> </a>
<a name="ln6294">    n=s1.length();</a>
<a name="ln6295">    if (s2.length()&gt;n) n=s2.length();</a>
<a name="ln6296">    if (s1.length()&lt;n) for (i=s1.length(); i&lt;n; i++) {</a>
<a name="ln6297">        if ((s1.at(0) &gt;= '0') &amp;&amp; (s1.at(0) &lt;= '9')) s1=&quot;0&quot;+s1; else s1=s1+&quot;0&quot;;</a>
<a name="ln6298">      };</a>
<a name="ln6299">    if (s2.length()&lt;n) for (i=s2.length(); i&lt;n; i++) {</a>
<a name="ln6300">        if ((s2.at(0) &gt;= '0') &amp;&amp; (s2.at(0) &lt;= '9')) s2=&quot;0&quot;+s2; else s2=s2+&quot;0&quot;;</a>
<a name="ln6301">      };</a>
<a name="ln6302">    //lowest priority -zz</a>
<a name="ln6303"> </a>
<a name="ln6304">    result=s1.compare(s2);</a>
<a name="ln6305">    return result;</a>
<a name="ln6306">  }</a>
<a name="ln6307"> </a>
<a name="ln6308"> </a>
<a name="ln6309">  std::string getAtomSymbol(TSimpleMolecule &amp; sm, int atAtom, int atEx, int priority, string ndData) {</a>
<a name="ln6310">    //!  nepravil'no</a>
<a name="ln6311">    //For given atom AtAtom returns atom symbol with given prioritate. AtEx-do not take part into calculations</a>
<a name="ln6312">    string result=&quot;&quot;;</a>
<a name="ln6313">    std::vector&lt;string&gt; collectedSymbols(15);</a>
<a name="ln6314">    //string collectedSymbols [] = new string [15];</a>
<a name="ln6315">    int nPrior=0;</a>
<a name="ln6316">    int i,j,n;</a>
<a name="ln6317">    bool test;</a>
<a name="ln6318"> </a>
<a name="ln6319">    //result=aSymb[sm.getAtom(atAtom)-&gt;na];</a>
<a name="ln6320">    //result=&quot;at=&quot;+intToStr(atAtom)+&quot; nt=&quot;+intToStr(sm.nAtoms())+&quot; na=&quot;+intToStr(sm.getAtom(atAtom)-&gt;na);</a>
<a name="ln6321"> </a>
<a name="ln6322">    for (i=0; i&lt;sm.getAtom(atAtom)-&gt;nb; i++) {</a>
<a name="ln6323">      n=sm.getAtom(atAtom)-&gt;ac[i];</a>
<a name="ln6324">      if (n != atEx) {</a>
<a name="ln6325">        nPrior++;</a>
<a name="ln6326">        test=false;</a>
<a name="ln6327">        if (sm.getAtom(n)-&gt;anum.length() &gt; 0) test=true;</a>
<a name="ln6328">        if (test) collectedSymbols[nPrior-1]=sm.getAtom(n)-&gt;anum; else collectedSymbols[nPrior-1]=aSymb[sm.getAtom(n)-&gt;na];</a>
<a name="ln6329">      };</a>
<a name="ln6330">    };</a>
<a name="ln6331">    n=sm.getNH(atAtom);</a>
<a name="ln6332">    for (i=0; i&lt;n; i++) {</a>
<a name="ln6333">      nPrior++;</a>
<a name="ln6334">      collectedSymbols[nPrior-1]=&quot;H&quot;;</a>
<a name="ln6335">    };</a>
<a name="ln6336">    if (nPrior &lt; 4) for (i=0; i&lt;4; i++) {</a>
<a name="ln6337">        nPrior++;</a>
<a name="ln6338">        collectedSymbols[nPrior-1]=ndData;//&quot;zz&quot;;  //instead of 0 - less prioritate....</a>
<a name="ln6339">        if (nPrior == 4) break;</a>
<a name="ln6340">      };</a>
<a name="ln6341">    for (i=0; i&lt;(nPrior-1); i++) for (j=i+1; j&lt;nPrior; j++) if (compareStringsNumbers(collectedSymbols[i],collectedSymbols[j])&gt;0) {</a>
<a name="ln6342">          result=collectedSymbols[i];</a>
<a name="ln6343">          collectedSymbols[i]=collectedSymbols[j];</a>
<a name="ln6344">          collectedSymbols[j]=result;</a>
<a name="ln6345">        };</a>
<a name="ln6346">    if ((priority &gt; 0) &amp;&amp; (priority &lt;= nPrior)) result=collectedSymbols[priority-1];</a>
<a name="ln6347">    return result;</a>
<a name="ln6348">  };</a>
<a name="ln6349"> </a>
<a name="ln6350"> </a>
<a name="ln6351">  std::string getAtomSymbol(TSimpleMolecule &amp; sm, int atAtom) {</a>
<a name="ln6352">    bool test=false;</a>
<a name="ln6353">    string result=&quot;&quot;;</a>
<a name="ln6354"> </a>
<a name="ln6355">    if (sm.getAtom(atAtom)-&gt;anum.length() &gt; 0) test=true;</a>
<a name="ln6356">    if (test) result=sm.getAtom(atAtom)-&gt;anum; else result=aSymb[sm.getAtom(atAtom)-&gt;na];</a>
<a name="ln6357">    return result;</a>
<a name="ln6358">  };</a>
<a name="ln6359"> </a>
<a name="ln6360">  int indexOf(const string instring, const string substring, int fromPos=0) {</a>
<a name="ln6361">    int result=instring.find(substring,fromPos);</a>
<a name="ln6362">    if (result == string::npos) result=-1;</a>
<a name="ln6363">    if (result &gt;= instring.length()) result=-1;</a>
<a name="ln6364">    return result;</a>
<a name="ln6365">  };</a>
<a name="ln6366"> </a>
<a name="ln6367">  std::string removeZeroeth(std::string instring) {</a>
<a name="ln6368">    string result=instring;</a>
<a name="ln6369">    int n;</a>
<a name="ln6370"> </a>
<a name="ln6371">    n=indexOf(result,&quot;,0&quot;);</a>
<a name="ln6372">    while (n&gt;=0) {</a>
<a name="ln6373">      result=result.substr(0,n+1)+result.substr(n+2);</a>
<a name="ln6374">      n=indexOf(result,&quot;,0&quot;);</a>
<a name="ln6375">    };</a>
<a name="ln6376">    return result;</a>
<a name="ln6377">  };</a>
<a name="ln6378"> </a>
<a name="ln6379">  int analizeParity(string data) {</a>
<a name="ln6380">    int result=0;  //Unknown parity</a>
<a name="ln6381">    int n,m,n1;</a>
<a name="ln6382">    string s1=&quot;&quot;;</a>
<a name="ln6383">    string s2=&quot;&quot;;</a>
<a name="ln6384">    bool test=true;</a>
<a name="ln6385"> </a>
<a name="ln6386">    n1=0;</a>
<a name="ln6387">    n=data.length();</a>
<a name="ln6388">    m=0;</a>
<a name="ln6389">    while (test) {</a>
<a name="ln6390">      n--;</a>
<a name="ln6391">      if (data.at(n) == ',') {</a>
<a name="ln6392">        n1++;</a>
<a name="ln6393">        if (s2.length() == 0) {</a>
<a name="ln6394">          s2=data.substr(n+1);</a>
<a name="ln6395">          m=n;</a>
<a name="ln6396">        };</a>
<a name="ln6397">      };</a>
<a name="ln6398">      test=(n1 &lt; 2) &amp;&amp; (n &gt; 1);</a>
<a name="ln6399">    };</a>
<a name="ln6400">    if ((n1 == 2) &amp;&amp; (n &gt; 0) &amp;&amp; (m &gt; 0)) s1=data.substr(n+1,m);</a>
<a name="ln6401">    if ((s1.length() &gt;0 ) &amp;&amp; (s2.length() &gt; 0)) {</a>
<a name="ln6402">      n=compareStringsNumbers(s1,s2);</a>
<a name="ln6403">      if (n &gt; 0) result=1; else if (n &lt; 0) result=-1;</a>
<a name="ln6404">    };</a>
<a name="ln6405">    return result;</a>
<a name="ln6406">  };</a>
<a name="ln6407"> </a>
<a name="ln6408">  int analizeParityBond(string data) {</a>
<a name="ln6409">    int result=0;  //Unknown parity</a>
<a name="ln6410">    int n,m;</a>
<a name="ln6411">    string s1=&quot;&quot;;</a>
<a name="ln6412">    string s2=&quot;&quot;;</a>
<a name="ln6413">    string s3=&quot;&quot;;</a>
<a name="ln6414">    bool test;</a>
<a name="ln6415"> </a>
<a name="ln6416">    n=data.length();</a>
<a name="ln6417">    m=0;</a>
<a name="ln6418">    test=true;</a>
<a name="ln6419">    while (test) {</a>
<a name="ln6420">      n--;</a>
<a name="ln6421">      if (data.at(n) == ',') {</a>
<a name="ln6422">        test=false;</a>
<a name="ln6423">        s3=data.substr(n+1);</a>
<a name="ln6424">        m=n;</a>
<a name="ln6425">      };</a>
<a name="ln6426">    };</a>
<a name="ln6427">    test=n&gt;1;</a>
<a name="ln6428">    while (test) {</a>
<a name="ln6429">      n--;</a>
<a name="ln6430">      if (data.at(n) == ',') {</a>
<a name="ln6431">        test=false;</a>
<a name="ln6432">        s2=data.substr(n+1,m);</a>
<a name="ln6433">        m=n;</a>
<a name="ln6434">      };</a>
<a name="ln6435">    };</a>
<a name="ln6436">    test=n&gt;1;</a>
<a name="ln6437">    while (test) {</a>
<a name="ln6438">      n--;</a>
<a name="ln6439">      if (data.at(n) == ',') {</a>
<a name="ln6440">        test=false;</a>
<a name="ln6441">        s1=data.substr(n+1,m);</a>
<a name="ln6442">        m=n;</a>
<a name="ln6443">      };</a>
<a name="ln6444">    };</a>
<a name="ln6445">    if ((s1.length() &gt; 0) &amp;&amp; (s2.length() &gt; 0)) {</a>
<a name="ln6446">      n=compareStringsNumbers(s1,s2);</a>
<a name="ln6447">      if (n &gt; 0) result=1; else if (n &lt; 0) result=-1;</a>
<a name="ln6448">    };</a>
<a name="ln6449">    return result;</a>
<a name="ln6450">  };</a>
<a name="ln6451"> </a>
<a name="ln6452"> </a>
<a name="ln6453">  std::string changeParity(std::string data) {</a>
<a name="ln6454">    string result=&quot;&quot;;</a>
<a name="ln6455">    int n,m,n1;</a>
<a name="ln6456">    string s1=&quot;&quot;;</a>
<a name="ln6457">    string s2=&quot;&quot;;</a>
<a name="ln6458">    bool test=true;</a>
<a name="ln6459"> </a>
<a name="ln6460">    n1=0;</a>
<a name="ln6461">    n=data.length();</a>
<a name="ln6462">    m=0;</a>
<a name="ln6463">    while (test) {</a>
<a name="ln6464">      n--;</a>
<a name="ln6465">      if (data.at(n) == ',') {</a>
<a name="ln6466">        n1++;</a>
<a name="ln6467">        if (s2.length() == 0) {</a>
<a name="ln6468">          s2=data.substr(n+1);</a>
<a name="ln6469">          m=n;</a>
<a name="ln6470">        };</a>
<a name="ln6471">      };</a>
<a name="ln6472">      test=(n1 &lt; 2) &amp;&amp; (n &gt; 1);</a>
<a name="ln6473">    };</a>
<a name="ln6474">    if ((n1 == 2) &amp;&amp; (n &gt; 0) &amp;&amp; (m &gt; 0)) {</a>
<a name="ln6475">      s1=data.substr(n+1,m);</a>
<a name="ln6476">      result=data.substr(0,n)+&quot;,&quot;+s2+&quot;,&quot;+s1;</a>
<a name="ln6477">    };</a>
<a name="ln6478">    return result;</a>
<a name="ln6479">  };</a>
<a name="ln6480"> </a>
<a name="ln6481">  std::string changeParityBond(std::string data) {</a>
<a name="ln6482">    string result=&quot;&quot;;</a>
<a name="ln6483">    int n,m;</a>
<a name="ln6484">    string s1=&quot;&quot;;</a>
<a name="ln6485">    string s2=&quot;&quot;;</a>
<a name="ln6486">    string s3=&quot;&quot;;</a>
<a name="ln6487">    bool test;</a>
<a name="ln6488"> </a>
<a name="ln6489">    n=data.length();</a>
<a name="ln6490">    m=0;</a>
<a name="ln6491">    test=true;</a>
<a name="ln6492">    while (test) {</a>
<a name="ln6493">      n--;</a>
<a name="ln6494">      if (data.at(n) == ',') {</a>
<a name="ln6495">        test=false;</a>
<a name="ln6496">        s3=data.substr(n+1);</a>
<a name="ln6497">        m=n;</a>
<a name="ln6498">      };</a>
<a name="ln6499">    };</a>
<a name="ln6500">    test=n&gt;1;</a>
<a name="ln6501">    while (test) {</a>
<a name="ln6502">      n--;</a>
<a name="ln6503">      if (data.at(n) == ',') {</a>
<a name="ln6504">        test=false;</a>
<a name="ln6505">        s2=data.substr(n+1,m);</a>
<a name="ln6506">        m=n;</a>
<a name="ln6507">      };</a>
<a name="ln6508">    };</a>
<a name="ln6509">    test=n&gt;1;</a>
<a name="ln6510">    while (test) {</a>
<a name="ln6511">      n--;</a>
<a name="ln6512">      if (data.at(n) == ',') {</a>
<a name="ln6513">        test=false;</a>
<a name="ln6514">        s1=data.substr(n+1,m);</a>
<a name="ln6515">        m=n;</a>
<a name="ln6516">      };</a>
<a name="ln6517">    };</a>
<a name="ln6518">    if ((s1.length() &gt; 0) &amp;&amp; (s2.length() &gt; 0) &amp;&amp; (s3.length() &gt; 0)) {</a>
<a name="ln6519">      result=data.substr(0,n)+&quot;,&quot;+s2+&quot;,&quot;+s1+&quot;,&quot;+s3;</a>
<a name="ln6520">    };</a>
<a name="ln6521">    return result;</a>
<a name="ln6522">  };</a>
<a name="ln6523"> </a>
<a name="ln6524">  std::string getAtomMCDL(OBMol * pmol, int ntatoms, const std::vector&lt;int&gt; ix, const std::vector&lt;int&gt; aNumber, const std::vector&lt;int&gt; atomStereoList, const std::vector&lt;int&gt; eqList) {</a>
<a name="ln6525"> </a>
<a name="ln6526">    TEditedMolecule sm;</a>
<a name="ln6527">    int i,j,k,n,atn,n1,m;</a>
<a name="ln6528">    string result=&quot;&quot;;</a>
<a name="ln6529">    string data=&quot;&quot;;</a>
<a name="ln6530">    string as1,as2,s,s1,s2;</a>
<a name="ln6531">    std::vector&lt;int&gt; priority(4);</a>
<a name="ln6532">    std::vector&lt;string&gt; v(0);</a>
<a name="ln6533">    std::vector&lt;int&gt; anumStereo(0);</a>
<a name="ln6534">    bool testParity;</a>
<a name="ln6535"> </a>
<a name="ln6536">    sm.readOBMol(pmol);</a>
<a name="ln6537"> </a>
<a name="ln6538">    for (i=0; i&lt;sm.nAtoms(); i++) sm.getAtom(i)-&gt;anum=&quot;&quot;;</a>
<a name="ln6539">    for (i=0; i&lt;ntatoms; i++) {</a>
<a name="ln6540">      n=ix[i];        //new numeration</a>
<a name="ln6541">      atn=aNumber[i]; //numeration in sm</a>
<a name="ln6542">      sm.getAtom(atn)-&gt;anum=intToStr(n);</a>
<a name="ln6543">    };</a>
<a name="ln6544"> </a>
<a name="ln6545">    for (i=0; i&lt;ntatoms; i++) {</a>
<a name="ln6546">      atn=aNumber[i]; //atom number in sm (initial molecule)</a>
<a name="ln6547">      if (atomStereoList[atn] != 0) {  //Contains stereo information</a>
<a name="ln6548">        n=ix[i];        //central atom, new numeration</a>
<a name="ln6549">        data=&quot;&quot;+intToStr(n);</a>
<a name="ln6550">        for (j=0; j&lt;priority.size(); j++) priority[j]=0;</a>
<a name="ln6551">        as1=&quot;&quot;; as2=&quot;&quot;;</a>
<a name="ln6552">        //cleaning fragIndex - addition from June 2008</a>
<a name="ln6553">        for (j=0; j&lt;sm.getAtom(atn)-&gt;nb; j++) {</a>
<a name="ln6554">          k=sm.getAtom(atn)-&gt;ac[j];</a>
<a name="ln6555">          sm.getAtom(k)-&gt;fragIndex=0;</a>
<a name="ln6556">        }</a>
<a name="ln6557">        //end addition</a>
<a name="ln6558"> </a>
<a name="ln6559"> </a>
<a name="ln6560">        for (j=1; j&lt;=4; j++) {</a>
<a name="ln6561">          s=getAtomSymbol(sm,atn,-1,j,&quot;00&quot;);</a>
<a name="ln6562">          //Search through bonds...</a>
<a name="ln6563">          n1=-1;</a>
<a name="ln6564">          s1=&quot;&quot;;</a>
<a name="ln6565">          for (k=0; k&lt;sm.nBonds(); k++) if ((sm.getBond(k)-&gt;at[0] == atn) || (sm.getBond(k)-&gt;at[1] == atn)) {</a>
<a name="ln6566">              if (sm.getBond(k)-&gt;at[0] == atn) m=sm.getBond(k)-&gt;at[1]; else m=sm.getBond(k)-&gt;at[0];</a>
<a name="ln6567">              s1=getAtomSymbol(sm,m);</a>
<a name="ln6568">              if (s.compare(s1) == 0) {</a>
<a name="ln6569">                sm.getAtom(m)-&gt;fragIndex=5-j;</a>
<a name="ln6570">                n1=k;</a>
<a name="ln6571">                break;</a>
<a name="ln6572">              };</a>
<a name="ln6573">            };</a>
<a name="ln6574">          if (n1 &gt; 0) priority[j-1]=n1; else if (j&lt;4) priority[j-1]=-1;</a>
<a name="ln6575">          if (j &lt;= 2) data=data+&quot;,&quot;+s;  else if (j == 3) as1=s; else as2=s;</a>
<a name="ln6576">        };</a>
<a name="ln6577"> </a>
<a name="ln6578">        int bn=-1;</a>
<a name="ln6579">        for (j=0; j&lt;sm.nBonds(); j++) if ((sm.getBond(j)-&gt;tb == 9) || (sm.getBond(j)-&gt;tb == 10)) {</a>
<a name="ln6580">            if (sm.getBond(j)-&gt;at[0] == atn) {</a>
<a name="ln6581">              bn=j;</a>
<a name="ln6582">              break;</a>
<a name="ln6583">            };</a>
<a name="ln6584">          };</a>
<a name="ln6585">        m=sm.singleAtomicDescriptor(atn,bn,true);</a>
<a name="ln6586">        if (m == 1) data=data+&quot;,&quot;+as2+&quot;,&quot;+as1; else data=data+&quot;,&quot;+as1+&quot;,&quot;+as2;</a>
<a name="ln6587">        v.push_back(data);</a>
<a name="ln6588">        anumStereo.push_back(atn);  //accumulation of atomic numbers in sm to check meso-forms...</a>
<a name="ln6589">      };</a>
<a name="ln6590">    };</a>
<a name="ln6591"> </a>
<a name="ln6592">    //meso-isomer handling</a>
<a name="ln6593">    string ss=&quot;&quot;;</a>
<a name="ln6594">    bool presentOtherStereo=false;</a>
<a name="ln6595">    if (anumStereo.size() &gt; 1) for (i=0; i&lt;(anumStereo.size()-1); i++) if (anumStereo[i] &gt;= 0) {</a>
<a name="ln6596">          n=0;</a>
<a name="ln6597">          for (j=i+1; j&lt;anumStereo.size(); j++) if ((anumStereo[i] &gt;= 0) &amp;&amp; (anumStereo[j] &gt;= 0)) if (eqList[anumStereo[i]] == eqList[anumStereo[j]]) n++;</a>
<a name="ln6598">          if ((n % 2) != 1) presentOtherStereo=true;</a>
<a name="ln6599">          if (n&gt;=1) {  //meso-forms search...</a>
<a name="ln6600">            s=v[i];</a>
<a name="ln6601">            k=analizeParity(s);</a>
<a name="ln6602">            testParity=false;</a>
<a name="ln6603">            for (j=i+1; j&lt;anumStereo.size(); j++) if ((anumStereo[i] &gt;= 0) &amp;&amp; (anumStereo[j] &gt;= 0)) if (eqList[anumStereo[i]] == eqList[anumStereo[j]]) {</a>
<a name="ln6604">                  s1=v[j];</a>
<a name="ln6605">                  if (! testParity) {</a>
<a name="ln6606">                    m=analizeParity(s1);</a>
<a name="ln6607">                    if (k*m == -1) testParity=true;</a>
<a name="ln6608">                  };</a>
<a name="ln6609">                  if (s.compare(s1) &gt; 0) s=s1;</a>
<a name="ln6610">                };</a>
<a name="ln6611">            if (testParity) {</a>
<a name="ln6612">              if ((ss.length() == 0) || (ss.compare(s) &gt; 0)) ss=s;</a>
<a name="ln6613">              for (j=i+1; j&lt;anumStereo.size(); j++) if ((anumStereo[i] &gt;= 0) &amp;&amp; (anumStereo[j] &gt;= 0)) if (eqList[anumStereo[i]] == eqList[anumStereo[j]]) anumStereo[j]=-1;</a>
<a name="ln6614">              anumStereo[i]=-1;</a>
<a name="ln6615">            } else {</a>
<a name="ln6616">              for (j=i+1; j&lt;anumStereo.size(); j++) if ((anumStereo[i] &gt;= 0) &amp;&amp; (anumStereo[j] &gt;= 0)) if (eqList[anumStereo[i]] == eqList[anumStereo[j]]) anumStereo[j]=-2;</a>
<a name="ln6617">              anumStereo[i]=-2;</a>
<a name="ln6618">              presentOtherStereo=true;</a>
<a name="ln6619">            };</a>
<a name="ln6620">          } else anumStereo[i]=-2;</a>
<a name="ln6621">        };</a>
<a name="ln6622">    //Do not analyze meso-forms for complex molecules....</a>
<a name="ln6623">    if (presentOtherStereo) ss=&quot;&quot;;</a>
<a name="ln6624"> </a>
<a name="ln6625">    if (ss.length() &gt; 0) {  //some meso-isomers were found-analyze their parity and change if necessary</a>
<a name="ln6626">      k=analizeParity(ss);</a>
<a name="ln6627">      if (k == 1) for (i=0; i&lt;anumStereo.size(); i++) if (anumStereo[i] == -1) {  //all parities should be changed to satisfy..</a>
<a name="ln6628">            s=v[i];</a>
<a name="ln6629">            s1=changeParity(s);</a>
<a name="ln6630">            v[i]=s1;</a>
<a name="ln6631">          };</a>
<a name="ln6632">    };</a>
<a name="ln6633"> </a>
<a name="ln6634">    //end meso-isomers handling</a>
<a name="ln6635">    //sorting vectors...</a>
<a name="ln6636">    if (v.size() &gt; 1) for (i=0; i&lt;(v.size() - 1); i++) for (j=i+1; j&lt;v.size(); j++) {</a>
<a name="ln6637">          s1=v[i];</a>
<a name="ln6638">          s2=v[j];</a>
<a name="ln6639">          if (compareStringsNumbers(s1,s2) &gt; 0) {</a>
<a name="ln6640">            v[j]=s1;</a>
<a name="ln6641">            v[i]=s2;</a>
<a name="ln6642">          };</a>
<a name="ln6643">        };</a>
<a name="ln6644">    if (v.size() &gt; 0) {</a>
<a name="ln6645">      result=fsastart;</a>
<a name="ln6646">      for (i=0; i &lt; v.size(); i++) {</a>
<a name="ln6647">        s1=v[i];</a>
<a name="ln6648">        while (indexOf(s1,&quot;zz&quot;) &gt; 0) {  //Substitite temporary lowest-priority 00 to zero</a>
<a name="ln6649">          n=indexOf(s1,&quot;zz&quot;);</a>
<a name="ln6650">          s1=s1.substr(0,n)+&quot;0&quot;+s1.substr(n+2);</a>
<a name="ln6651">        };</a>
<a name="ln6652">        while (indexOf(s1,&quot;00&quot;) &gt; 0) {  //Substitite temporary lowest-priority 00 to zero</a>
<a name="ln6653">          n=indexOf(s1,&quot;00&quot;);</a>
<a name="ln6654">          s1=s1.substr(0,n)+&quot;0&quot;+s1.substr(n+2);</a>
<a name="ln6655">        };</a>
<a name="ln6656">        if (i &gt; 0) result=result+&quot;;&quot;;</a>
<a name="ln6657">        s1=removeZeroeth(s1);</a>
<a name="ln6658">        result=result+s1;</a>
<a name="ln6659">      };</a>
<a name="ln6660">      result=result+&quot;}&quot;;</a>
<a name="ln6661">    };</a>
<a name="ln6662">    return result;</a>
<a name="ln6663">  };</a>
<a name="ln6664"> </a>
<a name="ln6665">  bool bondEquivalent(int bn1, int bn2, const std::vector&lt;int&gt; eqList, TSimpleMolecule &amp; sm) {</a>
<a name="ln6666">    bool result=false;</a>
<a name="ln6667">    int n1,n2,n3,n4;</a>
<a name="ln6668"> </a>
<a name="ln6669">    if ((bn1 &gt;= sm.nBonds()) || (bn2 &gt; sm.nBonds())) return result;</a>
<a name="ln6670">    n1=sm.getBond(bn1)-&gt;at[0];</a>
<a name="ln6671">    n2=sm.getBond(bn1)-&gt;at[1];</a>
<a name="ln6672">    n3=sm.getBond(bn2)-&gt;at[0];</a>
<a name="ln6673">    n4=sm.getBond(bn2)-&gt;at[1];</a>
<a name="ln6674">    result=(((eqList[n1] == eqList[n3]) &amp;&amp; (eqList[n2] == eqList[n4])) ||</a>
<a name="ln6675">            ((eqList[n1] == eqList[n4]) &amp;&amp; (eqList[n2] == eqList[n3])));</a>
<a name="ln6676">    return result;</a>
<a name="ln6677">  };</a>
<a name="ln6678"> </a>
<a name="ln6679"> </a>
<a name="ln6680">  std::string getBondMCDL(OBMol * pmol, int nbStore, int ntatoms, const std::vector&lt;int&gt; ix, const std::vector&lt;int&gt; aNumber, int bonds[MAXBONDS][4], const std::vector&lt;int&gt; bondStereoList, const std::vector&lt;int&gt; eqList) {</a>
<a name="ln6681">    TSimpleMolecule sm;</a>
<a name="ln6682">    std::vector&lt;int&gt; anumStereo(0);</a>
<a name="ln6683">    std::vector&lt;string&gt; v(0);</a>
<a name="ln6684">    int i,j,n,m,n1,n2,n3,n4,an1,an2,an3,an4,k;</a>
<a name="ln6685">    string s,s1,s2,as1,as2,as3,as4;</a>
<a name="ln6686">    bool testDouble,testParity;</a>
<a name="ln6687">    string data=&quot;&quot;;</a>
<a name="ln6688">    string result=&quot;&quot;;</a>
<a name="ln6689"> </a>
<a name="ln6690">    sm.readOBMol(pmol);</a>
<a name="ln6691"> </a>
<a name="ln6692">    for (i=0; i&lt;sm.nAtoms(); i++) sm.getAtom(i)-&gt;anum=&quot;&quot;;</a>
<a name="ln6693">    for (i=0; i&lt;ntatoms; i++) {</a>
<a name="ln6694">      n=ix[i];        //new numeration</a>
<a name="ln6695">      k=aNumber[i];   //numeration in sm</a>
<a name="ln6696">      sm.getAtom(k)-&gt;anum=intToStr(n);</a>
<a name="ln6697">    };</a>
<a name="ln6698"> </a>
<a name="ln6699"> </a>
<a name="ln6700"> </a>
<a name="ln6701">    for (i=0; i&lt;nbStore; i++) if (bonds[i][2] == 2) {</a>
<a name="ln6702">        n=bonds[i][3]-1; //Old bond number</a>
<a name="ln6703">        testDouble=bondStereoList[n] == 1;  //bondStereoList is filled on input-stereonotation can be used for acyclic double-bond with non-equivalent substitutors....</a>
<a name="ln6704">        if (testDouble) {</a>
<a name="ln6705">          n1=ix[bonds[i][0]-1];</a>
<a name="ln6706">          n2=ix[bonds[i][1]-1];</a>
<a name="ln6707">          if (n1&gt;n2) {</a>
<a name="ln6708">            k=bonds[i][0];</a>
<a name="ln6709">            bonds[i][0]=bonds[i][1];</a>
<a name="ln6710">            bonds[i][1]=k;</a>
<a name="ln6711">          };</a>
<a name="ln6712">          //1-st atom has minimal number now. Search for minimal number, attached to first</a>
<a name="ln6713">          n1=ix[bonds[i][0]-1];</a>
<a name="ln6714">          n2=ix[bonds[i][1]-1];</a>
<a name="ln6715"> </a>
<a name="ln6716">          data=&quot;&quot;+intToStr(n1)+&quot;d&quot;+intToStr(n2);</a>
<a name="ln6717">          n1=-1;  //to 1-st atom</a>
<a name="ln6718">          n2=-1;</a>
<a name="ln6719">          n3=-1;  //to 2-nd atom</a>
<a name="ln6720">          n4=-1;</a>
<a name="ln6721">          an1=-1; an2=-1; an3=-1; an4=-1;</a>
<a name="ln6722">          // search for the attached atoms...</a>
<a name="ln6723">          for (j=0; j&lt;nbStore; j++) if (i != j) {</a>
<a name="ln6724">              if ((bonds[j][0] == bonds[i][0]) || (bonds[j][1] == bonds[i][0])) {</a>
<a name="ln6725">                if (n1 == -1) n1=j; else n2=j;</a>
<a name="ln6726">                if (bonds[j][0] == bonds[i][0]) {</a>
<a name="ln6727">                  if (an1 == -1) an1=ix[bonds[j][1]-1]; else an2=ix[bonds[j][1]-1];</a>
<a name="ln6728">                } else {</a>
<a name="ln6729">                  if (an1 == -1) an1=ix[bonds[j][0]-1]; else an2=ix[bonds[j][0]-1];</a>
<a name="ln6730">                };</a>
<a name="ln6731">              };</a>
<a name="ln6732">              if ((bonds[j][0] == bonds[i][1]) || (bonds[j][1] == bonds[i][1])) {</a>
<a name="ln6733">                if (n3 == -1) n3=j; else n4=j;</a>
<a name="ln6734">                if (bonds[j][0] == bonds[i][1]) {</a>
<a name="ln6735">                  if (an3 == -1) an3=ix[bonds[j][1]-1]; else an4=ix[bonds[j][1]-1];</a>
<a name="ln6736">                } else {</a>
<a name="ln6737">                  if (an3 == -1) an3=ix[bonds[j][0]-1]; else an4=ix[bonds[j][0]-1];</a>
<a name="ln6738">                };</a>
<a name="ln6739">              };</a>
<a name="ln6740">            };</a>
<a name="ln6741">          if ((an1 &gt;= 0) &amp;&amp; (an2 &gt;= 0)) if (an1 &gt; an2) {</a>
<a name="ln6742">              k=n1; n1=n2; n2=k;</a>
<a name="ln6743">              k=an1; an1=an2; an2=k;</a>
<a name="ln6744">            };</a>
<a name="ln6745">          //Now n1,n2 contains bond numbers in bonds array, connected to bonds[i][0] atom. n3,n4-bond numbers, connected to bonds[i][1] atom.</a>
<a name="ln6746">          //I have to use corresponding elements bonds[n1][3] to determine bond numbers in initial molecule sm.</a>
<a name="ln6747">          if (an1 &gt;= 0) as1=&quot;&quot;+intToStr(an1); else {</a>
<a name="ln6748">            //Hydrogens MUST not be...</a>
<a name="ln6749">            as1=getAtomSymbol(sm,aNumber[bonds[i][0]-1],aNumber[bonds[i][1]-1],1,&quot;zz&quot;);</a>
<a name="ln6750">          };</a>
<a name="ln6751">          if (an2 &gt;= 0) as2=&quot;&quot;+intToStr(an2); else {</a>
<a name="ln6752">            as2=getAtomSymbol(sm,aNumber[bonds[i][0]-1],aNumber[bonds[i][1]-1],2,&quot;zz&quot;);</a>
<a name="ln6753">            if (as2.compare(&quot;zz&quot;) == 0) {</a>
<a name="ln6754">              as2=&quot;00&quot;;</a>
<a name="ln6755">            };</a>
<a name="ln6756">          };</a>
<a name="ln6757">          if (an3 &gt;= 0) as3=&quot;&quot;+intToStr(an3); else {</a>
<a name="ln6758">            //Hydrogens MUST not be...</a>
<a name="ln6759">            as3=getAtomSymbol(sm,aNumber[bonds[i][1]-1],aNumber[bonds[i][0]-1],1,&quot;zz&quot;);</a>
<a name="ln6760">          };</a>
<a name="ln6761">          if (an4 &gt;= 0) as4=&quot;&quot;+intToStr(an4); else {</a>
<a name="ln6762">            as4=getAtomSymbol(sm,aNumber[bonds[i][1]-1],aNumber[bonds[i][0]-1],2,&quot;zz&quot;);</a>
<a name="ln6763">            if (as4.compare(&quot;zz&quot;) == 0) {</a>
<a name="ln6764">              as4=&quot;00&quot;;</a>
<a name="ln6765">            };</a>
<a name="ln6766">          };</a>
<a name="ln6767"> </a>
<a name="ln6768">          if (n1 &lt; 0) {  //bond is connected with undefined atom - search for it....</a>
<a name="ln6769">            an1=aNumber[bonds[i][0]-1];</a>
<a name="ln6770">            an2=aNumber[bonds[i][1]-1]; //excluded atom...</a>
<a name="ln6771">            for (j=0; j&lt;sm.nBonds(); j++) {</a>
<a name="ln6772">              an3=sm.getBond(j)-&gt;at[0];</a>
<a name="ln6773">              an4=sm.getBond(j)-&gt;at[1];</a>
<a name="ln6774">              if ((an3 == an1) || (an4 == an1)) {</a>
<a name="ln6775">                if (an3 == an1) k=an4; else k=an3;</a>
<a name="ln6776">                if (k != an2) {</a>
<a name="ln6777">                  s=getAtomSymbol(sm,k);</a>
<a name="ln6778">                  if (s.compare(as1) == 0) n1=j;</a>
<a name="ln6779">                };</a>
<a name="ln6780">              };</a>
<a name="ln6781">              if (n1 &gt;= 0) break;</a>
<a name="ln6782">            };</a>
<a name="ln6783">            //Searching for anum!</a>
<a name="ln6784">          } else n1=bonds[n1][3]-1;</a>
<a name="ln6785">          if (n3 &lt; 0) {  //bond is connected with undefined atom - search for it....</a>
<a name="ln6786">            an1=aNumber[bonds[i][1]-1];</a>
<a name="ln6787">            an2=aNumber[bonds[i][0]-1]; //excluded atom...</a>
<a name="ln6788">            for (j=0; j&lt;sm.nBonds(); j++) {</a>
<a name="ln6789">              an3=sm.getBond(j)-&gt;at[0];</a>
<a name="ln6790">              an4=sm.getBond(j)-&gt;at[1];</a>
<a name="ln6791">              if ((an3 == an1) || (an4 == an1)) {</a>
<a name="ln6792">                if (an3 == an1) k=an4; else k=an3;</a>
<a name="ln6793">                if (k != an2) {</a>
<a name="ln6794">                  s=getAtomSymbol(sm,k);</a>
<a name="ln6795">                  if (s.compare(as3) == 0) n3=j;</a>
<a name="ln6796">                };</a>
<a name="ln6797">              };</a>
<a name="ln6798">              if (n3 &gt;= 0) break;</a>
<a name="ln6799">            };</a>
<a name="ln6800">            //Searching for anum!</a>
<a name="ln6801">          } else n3=bonds[n3][3]-1;</a>
<a name="ln6802"> </a>
<a name="ln6803">          //above OK</a>
<a name="ln6804"> </a>
<a name="ln6805">          if ((n1 &lt; 0) || (n3 &lt; 0)) {</a>
<a name="ln6806">            //my error in logic. raise an exception</a>
<a name="ln6807">            //or do nothing...</a>
<a name="ln6808">            data=&quot;&quot;;</a>
<a name="ln6809">          } else {</a>
<a name="ln6810">            //sign determine...</a>
<a name="ln6811">            //Then I can to determine scalar product</a>
<a name="ln6812">            //and angle between bonds n1 and n3</a>
<a name="ln6813">            k=sproduct(sm,bonds[i][3]-1,n1,n3);</a>
<a name="ln6814">            if (as2.compare(&quot;00&quot;) == 0) {</a>
<a name="ln6815">              data=data+&quot;,&quot;+as2;</a>
<a name="ln6816">              if (k == 1) {  //cis</a>
<a name="ln6817">                data=data+&quot;,&quot;+as4;</a>
<a name="ln6818">                data=data+&quot;,&quot;+as3;//an3;</a>
<a name="ln6819">                data=data+&quot;,&quot;+as1;</a>
<a name="ln6820">              } else if (k == 2) {  //trans</a>
<a name="ln6821">                data=data+&quot;,&quot;+as3;</a>
<a name="ln6822">                data=data+&quot;,&quot;+as4;</a>
<a name="ln6823">                data=data+&quot;,&quot;+as1;</a>
<a name="ln6824">              } else data=&quot;&quot;;  //collinear</a>
<a name="ln6825">            } else {</a>
<a name="ln6826">              data=data+&quot;,&quot;+as1;//an1;</a>
<a name="ln6827">              if (k == 1) {  //cis</a>
<a name="ln6828">                data=data+&quot;,&quot;+as3;//an3;</a>
<a name="ln6829">                data=data+&quot;,&quot;+as4;</a>
<a name="ln6830">                data=data+&quot;,&quot;+as2;</a>
<a name="ln6831">              } else if (k == 2) {  //trans</a>
<a name="ln6832">                data=data+&quot;,&quot;+as4;</a>
<a name="ln6833">                data=data+&quot;,&quot;+as3;</a>
<a name="ln6834">                data=data+&quot;,&quot;+as2;</a>
<a name="ln6835">              } else data=&quot;&quot;;  //collinear</a>
<a name="ln6836">            };</a>
<a name="ln6837">          };</a>
<a name="ln6838">          if (data.length() &gt; 0) {</a>
<a name="ln6839">            v.push_back(data);</a>
<a name="ln6840">            anumStereo.push_back(n);</a>
<a name="ln6841">          };</a>
<a name="ln6842">        }</a>
<a name="ln6843">      };</a>
<a name="ln6844"> </a>
<a name="ln6845"> </a>
<a name="ln6846">    //Identical double-bonds search, like cis,trans-hexa-2,4-diene</a>
<a name="ln6847">    if (anumStereo.size() &gt; 1) for (i=0; i&lt;(anumStereo.size()-1); i++) if (anumStereo[i] &gt;= 0) {</a>
<a name="ln6848">          n=0;</a>
<a name="ln6849">          for (j=i+1; j&lt;anumStereo.size(); j++) if (bondEquivalent(anumStereo[i],anumStereo[j],eqList,sm)) n++;</a>
<a name="ln6850">          if (n&gt;=1) {  //bond searching...</a>
<a name="ln6851">            s=v[i];</a>
<a name="ln6852">            k=analizeParityBond(s);</a>
<a name="ln6853">            testParity=false;</a>
<a name="ln6854">            for (j=i+1; j&lt;anumStereo.size(); j++) if (bondEquivalent(anumStereo[i],anumStereo[j],eqList,sm)) {</a>
<a name="ln6855">                s1=v[j];</a>
<a name="ln6856">                if (! testParity) {</a>
<a name="ln6857">                  m=analizeParityBond(s1);</a>
<a name="ln6858">                  if (k*m == -1) testParity=true;</a>
<a name="ln6859">                };</a>
<a name="ln6860">                if (compareStringsNumbers(s,s1)&gt;0) s=s1;</a>
<a name="ln6861">              };</a>
<a name="ln6862">            if (testParity) {</a>
<a name="ln6863">              k=analizeParityBond(s);</a>
<a name="ln6864">              if (k == 1) {  //all parities should be changed to satisfy..</a>
<a name="ln6865">                s=v[i];</a>
<a name="ln6866">                s1=changeParityBond(s);</a>
<a name="ln6867">                v[i]=s1;</a>
<a name="ln6868">                for (j=i+1; j&lt;anumStereo.size(); j++) if (bondEquivalent(anumStereo[i],anumStereo[j],eqList,sm)) {</a>
<a name="ln6869">                    s=v[j];</a>
<a name="ln6870">                    s1=changeParityBond(s);</a>
<a name="ln6871">                    v[j]=s1;</a>
<a name="ln6872">                  };</a>
<a name="ln6873">              };</a>
<a name="ln6874">            };</a>
<a name="ln6875">            // set all anumStereo processed to 0 to indicate, that no processing is required</a>
<a name="ln6876">            for (j=i+1; j&lt;anumStereo.size(); j++) if (bondEquivalent(anumStereo[i],anumStereo[j],eqList,sm)) anumStereo[j]=-1;</a>
<a name="ln6877">          };</a>
<a name="ln6878">          anumStereo[i]=-1;</a>
<a name="ln6879">        }; //end symmetrical bonds</a>
<a name="ln6880"> </a>
<a name="ln6881">    if (v.size() &gt; 1) for (i=0; i&lt;(v.size() - 1); i++) for (j=i+1; j&lt;v.size(); j++) {</a>
<a name="ln6882">          s1=v[i];</a>
<a name="ln6883">          s2=v[j];</a>
<a name="ln6884">          if (compareStringsNumbers(s1,s2) &gt; 0) {</a>
<a name="ln6885">            v[j]=s1;</a>
<a name="ln6886">            v[i]=s2;</a>
<a name="ln6887">          };</a>
<a name="ln6888">        };</a>
<a name="ln6889">    if (v.size() &gt; 0) {   //stereobonds present</a>
<a name="ln6890">      result=fsbstart;</a>
<a name="ln6891">      for (i=0; i &lt; v.size(); i++) {</a>
<a name="ln6892">        s1=v[i];</a>
<a name="ln6893">        while (indexOf(s1,&quot;zz&quot;) &gt; 0) {  //Substitite temporary lowest-priority 00 to zero</a>
<a name="ln6894">          n=indexOf(s1,&quot;zz&quot;);</a>
<a name="ln6895">          s1=s1.substr(0,n)+&quot;0&quot;+s1.substr(n+2);</a>
<a name="ln6896">        };</a>
<a name="ln6897">        while (indexOf(s1,&quot;00&quot;) &gt; 0) {  //Substitite temporary lowest-priority 00 to zero</a>
<a name="ln6898">          n=indexOf(s1,&quot;00&quot;);</a>
<a name="ln6899">          s1=s1.substr(0,n)+&quot;0&quot;+s1.substr(n+2);</a>
<a name="ln6900">        };</a>
<a name="ln6901">        if (i &gt; 0) result=result+&quot;;&quot;;</a>
<a name="ln6902">        s1=removeZeroeth(s1);</a>
<a name="ln6903">        result=result+s1;</a>
<a name="ln6904">      };</a>
<a name="ln6905">      result=result+&quot;}&quot;;</a>
<a name="ln6906">    } else result=&quot;&quot;;</a>
<a name="ln6907">    return result;</a>
<a name="ln6908">  };</a>
<a name="ln6909"> </a>
<a name="ln6910">  std::string addZeroeth(std::string instring, std::string stringAdd) {</a>
<a name="ln6911">    string result=instring;</a>
<a name="ln6912">    int n;</a>
<a name="ln6913"> </a>
<a name="ln6914">    n=indexOf(result,&quot;,,&quot;);</a>
<a name="ln6915">    while (n&gt;=0) {</a>
<a name="ln6916">      result=result.substr(0,n+1)+stringAdd+result.substr(n+1);</a>
<a name="ln6917">      n=indexOf(result,&quot;,,&quot;);</a>
<a name="ln6918">    };</a>
<a name="ln6919">    return result;</a>
<a name="ln6920">  };</a>
<a name="ln6921"> </a>
<a name="ln6922"> </a>
<a name="ln6923">  void setUpDownBonds(int atomNo, int parity, TSimpleMolecule &amp; sm, std::vector&lt;int&gt;&amp; iA1, std::vector&lt;int&gt;&amp; iA2, std::vector&lt;int&gt;&amp; stereoBonds) {</a>
<a name="ln6924">    int i,k;</a>
<a name="ln6925"> </a>
<a name="ln6926">    for (i=0; i&lt;sm.nBonds(); i++) if (stereoBonds[i] == -1) {</a>
<a name="ln6927">        if ((sm.getBond(i)-&gt;at[0] == atomNo) || (sm.getBond(i)-&gt;at[1] == atomNo)) {</a>
<a name="ln6928">          if (sm.getBond(i)-&gt;at[1] == atomNo) {  //change atomic order...</a>
<a name="ln6929">            k=sm.getBond(i)-&gt;at[0];</a>
<a name="ln6930">            sm.getBond(i)-&gt;at[0]=sm.getBond(i)-&gt;at[1];</a>
<a name="ln6931">            sm.getBond(i)-&gt;at[1]=k;</a>
<a name="ln6932">            k=iA1[i];</a>
<a name="ln6933">            iA1[i]=iA2[i];</a>
<a name="ln6934">            iA2[i]=k;</a>
<a name="ln6935">          };</a>
<a name="ln6936">          sm.getBond(i)-&gt;tb=9;  //up</a>
<a name="ln6937">          k=sm.singleAtomicDescriptor(atomNo,i,false);</a>
<a name="ln6938">          //!!! By unknown reason inversion of configuration took place.</a>
<a name="ln6939">          if (k == parity) stereoBonds[i]=2; else stereoBonds[i]=1;</a>
<a name="ln6940">          break;</a>
<a name="ln6941">        };</a>
<a name="ln6942">      };</a>
<a name="ln6943">  };</a>
<a name="ln6944"> </a>
<a name="ln6945"> </a>
<a name="ln6946">  void implementAtomStereo(std::vector&lt;int&gt;&amp; iA1, std::vector&lt;int&gt;&amp; iA2, std::vector&lt;int&gt;&amp; stereoBonds, const std::vector&lt;double&gt;rx, const std::vector&lt;double&gt; ry, int acount, int bcount, std::string astereo) {</a>
<a name="ln6947">    //onInput stereoBonds contains only those bonds, which might be stereo</a>
<a name="ln6948">    TSimpleMolecule sm;</a>
<a name="ln6949"> </a>
<a name="ln6950">    string ss,s,temp;</a>
<a name="ln6951">    int n1,atn;</a>
<a name="ln6952">    bool threeCoor;</a>
<a name="ln6953"> </a>
<a name="ln6954">    if (astereo.length() == 0) return;</a>
<a name="ln6955">    sm.readConnectionMatrix(iA1,iA2,rx,ry,acount,bcount);</a>
<a name="ln6956"> </a>
<a name="ln6957">    ss=astereo;</a>
<a name="ln6958">    astereo=addZeroeth(astereo,&quot;-1&quot;);</a>
<a name="ln6959">    while (astereo.length() &gt;0 ) {</a>
<a name="ln6960">      s=&quot;&quot;;</a>
<a name="ln6961">      n1=indexOf(astereo,&quot;;&quot;);</a>
<a name="ln6962">      if (n1 &gt; 0) {</a>
<a name="ln6963">        s=astereo.substr(0,n1);</a>
<a name="ln6964">        if (n1 &lt; (astereo.length()-1)) astereo=astereo.substr(n1+1); else astereo=&quot;&quot;;</a>
<a name="ln6965">      } else {</a>
<a name="ln6966">        s=astereo;</a>
<a name="ln6967">        astereo=&quot;&quot;;</a>
<a name="ln6968">      };</a>
<a name="ln6969">      //analize s</a>
<a name="ln6970">      if (s.length() &gt; 0) {</a>
<a name="ln6971">        //save data in Astereo... Bond reconfiguring is possible only after re-drawing and chain rotations</a>
<a name="ln6972">        //      s=removeSpaces(s);</a>
<a name="ln6973">        n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln6974">        if (n1 &gt; 0) {</a>
<a name="ln6975">          threeCoor=(indexOf(s,&quot;-1&quot;) &gt; 0);</a>
<a name="ln6976">          temp=s.substr(0,n1);</a>
<a name="ln6977">          s=s.substr(n1+1);</a>
<a name="ln6978">          atn=atoi(temp.c_str())-1;  //one-based-has to be corrected to zero-based</a>
<a name="ln6979">          n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln6980">          if (n1 &gt; 0) s=s.substr(n1+1);</a>
<a name="ln6981">          n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln6982">          if (n1 &gt; 0) s=s.substr(n1+1);</a>
<a name="ln6983">          n1=indexOf(s,&quot;H&quot;);</a>
<a name="ln6984">          if (n1&lt;0) {</a>
<a name="ln6985">            n1=indexOf(s,&quot;0&quot;);</a>
<a name="ln6986">            if (n1 &gt; 0) n1=indexOf(s,&quot;,0&quot;); //occupy last position</a>
<a name="ln6987">          };</a>
<a name="ln6988">          if (n1 == 0) {</a>
<a name="ln6989">            setUpDownBonds(atn,1,sm,iA1,iA2,stereoBonds);</a>
<a name="ln6990">          } else if (n1 &gt; 0) {</a>
<a name="ln6991">            setUpDownBonds(atn,2,sm,iA1,iA2,stereoBonds);</a>
<a name="ln6992">          } else {</a>
<a name="ln6993">            //Priority analizing</a>
<a name="ln6994">            n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln6995">            if (n1 &gt; 0) {</a>
<a name="ln6996">              temp=s.substr(0,n1);</a>
<a name="ln6997">              s=s.substr(n1+1);</a>
<a name="ln6998">              if (temp.compare(&quot;0&quot;) == 0) temp=&quot;zz&quot;;</a>
<a name="ln6999">              if (s.compare(&quot;0&quot;) == 0) s=&quot;zz&quot;;</a>
<a name="ln7000">              if (threeCoor) {</a>
<a name="ln7001">                if (compareStringsNumbers(temp,s) &lt; 0) /*result.fAtom.setAStereo(atn,(byte)1)*/setUpDownBonds(atn,1,sm,iA1,iA2,stereoBonds); else setUpDownBonds(atn,2,sm,iA1,iA2,stereoBonds)/*result.fAtom.setAStereo(atn,(byte)2)*/;</a>
<a name="ln7002">              } else {</a>
<a name="ln7003">                if (compareStringsNumbers(temp,s) &gt; 0) /*result.fAtom.setAStereo(atn,(byte)1)*/setUpDownBonds(atn,1,sm,iA1,iA2,stereoBonds); else setUpDownBonds(atn,2,sm,iA1,iA2,stereoBonds)/*result.fAtom.setAStereo(atn,(byte)2)*/;</a>
<a name="ln7004">              };</a>
<a name="ln7005">            };</a>
<a name="ln7006">          };</a>
<a name="ln7007">        };</a>
<a name="ln7008">      };</a>
<a name="ln7009">    };</a>
<a name="ln7010">  };</a>
<a name="ln7011"> </a>
<a name="ln7012">  // The following function is used by MCDLformat.cpp</a>
<a name="ln7013">  void implementBondStereo(const std::vector&lt;int&gt; iA1, const std::vector&lt;int&gt; iA2, std::vector&lt;double&gt;&amp; rx, std::vector&lt;double&gt;&amp; ry, int acount, int bcount, std::string bstereo) {</a>
<a name="ln7014">    TEditedMolecule sm;</a>
<a name="ln7015">    string ss,s,sF,sa1,sa2,temp;</a>
<a name="ln7016">    int i,n1,n2,k,bn;</a>
<a name="ln7017">    bool hasStereo=false;</a>
<a name="ln7018">    bool coorChanged=false;</a>
<a name="ln7019">    if (bstereo.length() == 0) return;</a>
<a name="ln7020">    sm.readConnectionMatrix(iA1,iA2,rx,ry,acount,bcount);</a>
<a name="ln7021">    ss=bstereo;</a>
<a name="ln7022">    bstereo=addZeroeth(bstereo,&quot;0&quot;);</a>
<a name="ln7023">    while (bstereo.length() &gt;0 ) {</a>
<a name="ln7024">      s=&quot;&quot;;</a>
<a name="ln7025">      n1=indexOf(bstereo,&quot;;&quot;);</a>
<a name="ln7026">      if (n1 &gt; 0) {</a>
<a name="ln7027">        s=bstereo.substr(0,n1);</a>
<a name="ln7028">        if (n1 &lt; (bstereo.length()-1)) bstereo=bstereo.substr(n1+1); else bstereo=&quot;&quot;;</a>
<a name="ln7029">      } else {</a>
<a name="ln7030">        s=bstereo;</a>
<a name="ln7031">        bstereo=&quot;&quot;;</a>
<a name="ln7032">      };</a>
<a name="ln7033">      //analize s</a>
<a name="ln7034">      if (s.length() &gt; 0) {</a>
<a name="ln7035">        //save data in Bstereo... Bond reconfiguring is possible only after re-drawing</a>
<a name="ln7036">        //      CommonRout.RemoveSpaces(s);</a>
<a name="ln7037">        n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln7038">        if (n1 &gt; 0) {</a>
<a name="ln7039">          temp=s.substr(0,n1);</a>
<a name="ln7040">          s=s.substr(n1+1);</a>
<a name="ln7041">          n1=indexOf(temp,&quot;d&quot;);</a>
<a name="ln7042">          if (n1 &lt; 0) n1=indexOf(temp,&quot;D&quot;);</a>
<a name="ln7043">          if (n1 &gt; 0) {</a>
<a name="ln7044">            n2=atoi(temp.substr(0,n1).c_str());</a>
<a name="ln7045">            n1=atoi(temp.substr(n1+1).c_str());</a>
<a name="ln7046">            //search for bond...</a>
<a name="ln7047">            bn=-1;</a>
<a name="ln7048">            for (i=0; i&lt;sm.nBonds(); i++) if (((sm.getBond(i)-&gt;at[0] == (n1-1)) &amp;&amp; (sm.getBond(i)-&gt;at[1] == (n2-1))) || ((sm.getBond(i)-&gt;at[0] == (n2-1)) &amp;&amp; (sm.getBond(i)-&gt;at[1] == (n1-1)))) {</a>
<a name="ln7049">                bn=i;</a>
<a name="ln7050">                break;</a>
<a name="ln7051">              };</a>
<a name="ln7052">            n1=-1;</a>
<a name="ln7053">            n2=-1;</a>
<a name="ln7054">            k=indexOf(s,&quot;,&quot;);</a>
<a name="ln7055">            sF=&quot;&quot;;</a>
<a name="ln7056">            if (k &gt; 0)  {</a>
<a name="ln7057">              sF=s.substr(0,k);</a>
<a name="ln7058">              s=s.substr(k+1);  //removing 1-st fragment, added to an1</a>
<a name="ln7059">            };</a>
<a name="ln7060">            k=indexOf(s,&quot;,&quot;);</a>
<a name="ln7061">            sa1=&quot;&quot;; sa2=&quot;&quot;;</a>
<a name="ln7062">            if (k &gt; 0) {                    //and analizing of order of two remaining fragments, connected to an2</a>
<a name="ln7063">              sa1=s.substr(0,k);</a>
<a name="ln7064">              s=s.substr(k+1);</a>
<a name="ln7065">              try {</a>
<a name="ln7066">                n1=atoi(sa1.c_str());</a>
<a name="ln7067">                if (n1 == 0) {</a>
<a name="ln7068">                  n1=-1;</a>
<a name="ln7069">                  sa1=&quot;00&quot;;//&quot;zz&quot;;</a>
<a name="ln7070">                };</a>
<a name="ln7071">              } catch (exception ex) {</a>
<a name="ln7072">                n1=-1;</a>
<a name="ln7073">              };</a>
<a name="ln7074">            };</a>
<a name="ln7075">            k=indexOf(s,&quot;,&quot;);</a>
<a name="ln7076">            if (k &gt; 0) {</a>
<a name="ln7077">              sa2=s.substr(0,k);</a>
<a name="ln7078">              s=s.substr(k+1);</a>
<a name="ln7079">              try {</a>
<a name="ln7080">                n2=atoi(sa2.c_str());</a>
<a name="ln7081">                if (n2 == 0) {</a>
<a name="ln7082">                  n2=-1;</a>
<a name="ln7083">                  sa2=&quot;00&quot;;//&quot;zz&quot;;</a>
<a name="ln7084">                };</a>
<a name="ln7085">              } catch (exception ex) {</a>
<a name="ln7086">                n2=-1;</a>
<a name="ln7087">              };</a>
<a name="ln7088">            };</a>
<a name="ln7089">            if (bn &gt;= 0) {</a>
<a name="ln7090">              if ((n1 &lt; 0) &amp;&amp; (n2 &lt; 0)) {</a>
<a name="ln7091">                if (compareStringsNumbers(sa1,sa2) &gt; 0) k=1; else k=2;</a>
<a name="ln7092">              } else {</a>
<a name="ln7093">                if (n1 &lt; 0) k=1; else //E</a>
<a name="ln7094">                  if (n2 &lt; 0) k=2; else { //Z</a>
<a name="ln7095">                    if (n1 &lt; n2) k=2; else k=1;</a>
<a name="ln7096">                  };</a>
<a name="ln7097">              };</a>
<a name="ln7098">              if (sF.compare(&quot;0&quot;) == 0) k=3-k;</a>
<a name="ln7099">              sm.getBond(bn)-&gt;bstereo=k;</a>
<a name="ln7100">              hasStereo=true;</a>
<a name="ln7101">            };</a>
<a name="ln7102">          };</a>
<a name="ln7103">        };</a>
<a name="ln7104">      };</a>
<a name="ln7105">    };</a>
<a name="ln7106">    if (hasStereo) {</a>
<a name="ln7107">      coorChanged = sm.correctDblBondStereo();</a>
<a name="ln7108">      if (coorChanged) for (i=0; i&lt;sm.nAtoms(); i++) {</a>
<a name="ln7109">          rx[i]=sm.getAtom(i)-&gt;rx;</a>
<a name="ln7110">          ry[i]=sm.getAtom(i)-&gt;ry;</a>
<a name="ln7111">        };</a>
<a name="ln7112">    };</a>
<a name="ln7113">  };</a>
<a name="ln7114"> </a>
<a name="ln7115">  //****************************************************************************</a>
<a name="ln7116">  //Group redraw - generate 2D coordinates  for chemical group</a>
<a name="ln7117">  //****************************************************************************</a>
<a name="ln7118">  int OBMCDL groupRedraw(OBMol * pmol, int bondN, int atomN, bool atomNInGroup) {</a>
<a name="ln7119">    /*</a>
<a name="ln7120">      bondN - index of acyclic bond in pmol (zero-based).</a>
<a name="ln7121">      atomN - index of atom attached to bond bondN to start redraw from it (1-based)</a>
<a name="ln7122">      atomNInGroup - if true it is assumed, that atom atomN, attached to bond bondN</a>
<a name="ln7123">      is inside group to be redrawn, false otherwise</a>
<a name="ln7124">      Atoms at both ends of the bond should have coordinates before calling this function.</a>
<a name="ln7125">      returns 0 - all OK, =1 - number of atoms or bond are outside defined, = 2-cyclic bond</a>
<a name="ln7126">    */</a>
<a name="ln7127">    TSimpleMolecule sm;</a>
<a name="ln7128">    int result=0;</a>
<a name="ln7129"> </a>
<a name="ln7130">    std::vector&lt;int&gt; bondList;</a>
<a name="ln7131">    OBAtom * atom;</a>
<a name="ln7132">    int i,n,at,atEx,nb;</a>
<a name="ln7133"> </a>
<a name="ln7134">    sm.readOBMol(pmol);</a>
<a name="ln7135">    atomN--; //TSimpleMolecule: numeration of atoms is started from 0, while for OBMOl from 1;</a>
<a name="ln7136">    if ((bondN &gt;= sm.nBonds())  || (bondN &lt; 0) || (atomN &gt;= sm.nAtoms()) || (atomN &lt; 0)) {</a>
<a name="ln7137">      result=1;</a>
<a name="ln7138">      return result;</a>
<a name="ln7139">    };</a>
<a name="ln7140"> </a>
<a name="ln7141">    if (sm.getBond(bondN)-&gt;db &gt; 0) {</a>
<a name="ln7142">      result=2;</a>
<a name="ln7143">      return result;</a>
<a name="ln7144">    };</a>
<a name="ln7145">    if (! atomNInGroup) {</a>
<a name="ln7146">      n=sm.getBond(bondN)-&gt;at[0];</a>
<a name="ln7147">      if (n == atomN) n=sm.getBond(bondN)-&gt;at[1];</a>
<a name="ln7148">      atomN=n;</a>
<a name="ln7149">    };</a>
<a name="ln7150">    std::vector&lt;int&gt; allAtomList(sm.nAtoms(), 0);</a>
<a name="ln7151">    std::vector&lt;int&gt;    atomList(sm.nAtoms(), 0);</a>
<a name="ln7152">    n=0;</a>
<a name="ln7153">    if (sm.getBond(bondN)-&gt;at[0] == atomN) {</a>
<a name="ln7154">      at=sm.getBond(bondN)-&gt;at[0];</a>
<a name="ln7155">      atEx=sm.getBond(bondN)-&gt;at[1];</a>
<a name="ln7156">    } else {</a>
<a name="ln7157">      at=sm.getBond(bondN)-&gt;at[1];</a>
<a name="ln7158">      atEx=sm.getBond(bondN)-&gt;at[0];</a>
<a name="ln7159">    };</a>
<a name="ln7160">    if (sm.makeFragment(atomList,at,atEx)) {</a>
<a name="ln7161">      //addition of atom in non-cleaned fragment at last position</a>
<a name="ln7162">      atomList.push_back(atEx);</a>
<a name="ln7163">      for (i=0; i&lt;atomList.size(); i++) allAtomList[atomList[i]]=1;</a>
<a name="ln7164">      nb=0;</a>
<a name="ln7165">      for (i=0; i&lt;sm.nBonds(); i++) if ((allAtomList[sm.getBond(i)-&gt;at[0]] == 1) &amp;&amp; (allAtomList[sm.getBond(i)-&gt;at[1]] == 1)) {</a>
<a name="ln7166">          bondList.push_back(i);</a>
<a name="ln7167">          nb++;</a>
<a name="ln7168">        };</a>
<a name="ln7169">      sm.redraw(atomList,bondList,atomList.size(),nb,3,atEx,bondN,false);</a>
<a name="ln7170">      //Setting OBMOL coordinates</a>
<a name="ln7171">      for (int i=0; i&lt;atomList.size(); i++) {</a>
<a name="ln7172">        n=atomList[i];</a>
<a name="ln7173">        atom=pmol-&gt;GetAtom(n+1);  //1-based</a>
<a name="ln7174">        atom-&gt;SetVector(sm.getAtom(n)-&gt;rx,sm.getAtom(n)-&gt;ry,0.0);</a>
<a name="ln7175">      };</a>
<a name="ln7176">    } else result=3;  //unknown error</a>
<a name="ln7177">    return result;</a>
<a name="ln7178">  };</a>
<a name="ln7179">  /*</a>
<a name="ln7180">    int groupRedrawFrameAtom(OBMol * pmol, int bondN, int atomInFrame) {</a>
<a name="ln7181">    int atomN;</a>
<a name="ln7182">    atomN=pmol-&gt;GetBond(bondN)-&gt;GetBeginAtomIdx();</a>
<a name="ln7183">    if (atomN == atomInFrame) atomN=pmol-&gt;GetBond(bondN)-&gt;GetEndAtomIdx();</a>
<a name="ln7184">    int result=groupRedraw(pmol,bondN,atomN);</a>
<a name="ln7185">    return result;</a>
<a name="ln7186">    };</a>
<a name="ln7187">  */</a>
<a name="ln7188">  //****************************************************************************</a>
<a name="ln7189">  //assept a lot of structures on input and remove duplicates and non-connected</a>
<a name="ln7190">  //****************************************************************************</a>
<a name="ln7191">  bool parseFormula(const std::string formulaString, std::vector &lt;int&gt;&amp; enumber, int &amp; valency) {</a>
<a name="ln7192">    //vector&lt;string&gt; items;</a>
<a name="ln7193">    int i,n,k,n1,n2;//,j,nStart;</a>
<a name="ln7194">    string s;</a>
<a name="ln7195">    bool test;</a>
<a name="ln7196">    string asym;</a>
<a name="ln7197">    string value=formulaString;</a>
<a name="ln7198"> </a>
<a name="ln7199">    valency=-1;</a>
<a name="ln7200"> </a>
<a name="ln7201">    for (i=0; i&lt;NELEMMCDL; i++) enumber[i]=0;</a>
<a name="ln7202"> </a>
<a name="ln7203">    for (i=1; i&lt;NELEMMCDL; i++) if (aSymb[i].length()==2) {</a>
<a name="ln7204">        test=true;</a>
<a name="ln7205">        asym=aSymb[i];</a>
<a name="ln7206">        while (test) {</a>
<a name="ln7207">          test=false;</a>
<a name="ln7208">          n=indexOf(value,asym);</a>
<a name="ln7209">          if (n&gt;=0) {</a>
<a name="ln7210">            test=true;</a>
<a name="ln7211">            value=value.substr(0,n)+value.substr(n+asym.length(),value.length());</a>
<a name="ln7212">            k=1;</a>
<a name="ln7213">            if (n&lt;value.length()) if ((value.at(n)&gt;='0') &amp;&amp; (value.at(n)&lt;='9')) {</a>
<a name="ln7214">                n1=n;</a>
<a name="ln7215">                n2=n;</a>
<a name="ln7216">                while ((n2&lt;(value.length()-1)) &amp;&amp; (value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9')) n2++;</a>
<a name="ln7217">                if (! ((value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9'))) n2--;</a>
<a name="ln7218">                s=value.substr(n1,n2+1);</a>
<a name="ln7219">                k=atoi(s.c_str());</a>
<a name="ln7220">                value=value.substr(0,n1)+value.substr(n2+1,value.length());</a>
<a name="ln7221">              };</a>
<a name="ln7222">            enumber[i]=enumber[i]+k;</a>
<a name="ln7223">            if ((n == 0) &amp;&amp; (valency == -1)) valency=i;</a>
<a name="ln7224">          };</a>
<a name="ln7225">        };</a>
<a name="ln7226">      };</a>
<a name="ln7227">    for (i=1; i&lt;NELEMMCDL; i++) if (aSymb[i].length() == 1) {</a>
<a name="ln7228">        test=true;</a>
<a name="ln7229">        asym=aSymb[i];</a>
<a name="ln7230">        while (test) {</a>
<a name="ln7231">          test=false;</a>
<a name="ln7232">          n=indexOf(value,asym);</a>
<a name="ln7233">          if (n&gt;=0) {</a>
<a name="ln7234">            test=true;</a>
<a name="ln7235">            value=value.substr(0,n)+value.substr(n+asym.length(),value.length());</a>
<a name="ln7236">            k=1;</a>
<a name="ln7237">            if (n&lt;value.length()) if ((value.at(n)&gt;='0') &amp;&amp; (value.at(n)&lt;='9')) {</a>
<a name="ln7238">                n1=n;</a>
<a name="ln7239">                n2=n;</a>
<a name="ln7240">                while ((n2&lt;(value.length()-1)) &amp;&amp; (value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9')) n2++;</a>
<a name="ln7241">                if (! ((value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9'))) n2--;</a>
<a name="ln7242">                s=value.substr(n1,n2+1);</a>
<a name="ln7243">                k=atoi(s.c_str());</a>
<a name="ln7244">                value=value.substr(0,n1)+value.substr(n2+1,value.length());</a>
<a name="ln7245">              };</a>
<a name="ln7246">            enumber[i]=enumber[i]+k;</a>
<a name="ln7247">            if ((n == 0) &amp;&amp; (valency == -1)) valency=i;</a>
<a name="ln7248">          };</a>
<a name="ln7249">        };</a>
<a name="ln7250">      };</a>
<a name="ln7251">    if (valency &gt; 0) {</a>
<a name="ln7252">      n=valency;</a>
<a name="ln7253">      valency=hVal[n];</a>
<a name="ln7254">      if (valency == 0) valency=1;</a>
<a name="ln7255">      for (i=1; i&lt;NELEMMCDL; i++) if ((i != n) &amp;&amp; (enumber[i] &gt; 0)) {</a>
<a name="ln7256">          k=hVal[i];</a>
<a name="ln7257">          if (k == 0) k=1;</a>
<a name="ln7258">          k=k*enumber[i];</a>
<a name="ln7259">          valency=valency-k;</a>
<a name="ln7260">        };</a>
<a name="ln7261">      if (valency &lt;= 0) valency=1;</a>
<a name="ln7262">    };</a>
<a name="ln7263">    return (value.length() == 0);</a>
<a name="ln7264">  };</a>
<a name="ln7265"> </a>
<a name="ln7266"> </a>
<a name="ln7267">  int canonizeMCDL(const std::string atomBlock, std::vector&lt;std::string&gt; &amp; structureList) {</a>
<a name="ln7268">    return 0;</a>
<a name="ln7269">  };</a>
<a name="ln7270"> </a>
<a name="ln7271"> </a>
<a name="ln7272">  //****************************************************************************</a>
<a name="ln7273">  //*******************Tested routines, wiil be deleted*************************</a>
<a name="ln7274">  //****************************************************************************</a>
<a name="ln7275"> </a>
<a name="ln7276">  void prepareTest(OBMol * pmol, std::ostream &amp; ofs) {</a>
<a name="ln7277">    TEditedMolecule * sm;</a>
<a name="ln7278"> </a>
<a name="ln7279">    sm=new TEditedMolecule();</a>
<a name="ln7280">    sm-&gt;refofs=&amp;ofs;</a>
<a name="ln7281"> </a>
<a name="ln7282">    sm-&gt;readOBMol(pmol);</a>
<a name="ln7283"> </a>
<a name="ln7284">    TemplateRedraw tr;</a>
<a name="ln7285">    tr.redrawFine(*sm);</a>
<a name="ln7286"> </a>
<a name="ln7287">    sm-&gt;getMolfile(ofs);</a>
<a name="ln7288"> </a>
<a name="ln7289">    delete(sm);</a>
<a name="ln7290">  };</a>
<a name="ln7291"> </a>
<a name="ln7292"> </a>
<a name="ln7293">} // namespace OpenBabel</a>
<a name="ln7294"> </a>
<a name="ln7295">//! \file mcdlutil.cpp</a>
<a name="ln7296">//! utilities for mcdl format, might be useful for another</a>
<a name="ln7297"> </a>
<a name="ln7298">/// @file mcdlutil.cpp</a>
<a name="ln7299">/// @brief 2D molecule coordinate generation.</a>

</code></pre>
<div class="balloon" rel="1152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'i1' variable was assigned the same value.</p></div>
<div class="balloon" rel="1152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'i2' variable was assigned the same value.</p></div>
<div class="balloon" rel="1155"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'i2' variable was assigned the same value.</p></div>
<div class="balloon" rel="1744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'test' variable was assigned the same value.</p></div>
<div class="balloon" rel="2404"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bk'. Check lines: 2404, 2220.</p></div>
<div class="balloon" rel="2372"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'atomClean >= 1' is always true.</p></div>
<div class="balloon" rel="3484"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v668/" target="_blank">V668</a> There is no sense in testing the 'smCopy' pointer against null, as the memory was allocated using the 'new' operator. The exception will be generated in the case of memory allocation error.</p></div>
<div class="balloon" rel="3486"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v668/" target="_blank">V668</a> There is no sense in testing the 'tmpStore' pointer against null, as the memory was allocated using the 'new' operator. The exception will be generated in the case of memory allocation error.</p></div>
<div class="balloon" rel="4367"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'xu1' used.</p></div>
<div class="balloon" rel="4367"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'yu1' used.</p></div>
<div class="balloon" rel="4478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'queryBK'. Check lines: 4478, 4466.</p></div>
<div class="balloon" rel="4560"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'k' variable was assigned the same value.</p></div>
<div class="balloon" rel="4599"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 4598, 4599.</p></div>
<div class="balloon" rel="4656"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'test2' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 4655, 4656.</p></div>
<div class="balloon" rel="4636"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'nAtoms()' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 4636, 4646.</p></div>
<div class="balloon" rel="4828"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'whiletest' variable was assigned the same value.</p></div>
<div class="balloon" rel="4864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'aEQ'. Check lines: 4864, 4862.</p></div>
<div class="balloon" rel="4866"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'aEQ[i]'. Check lines: 4866, 4864.</p></div>
<div class="balloon" rel="4871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bEQ'. Check lines: 4871, 4869.</p></div>
<div class="balloon" rel="4873"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bEQ[i]'. Check lines: 4873, 4871.</p></div>
<div class="balloon" rel="4913"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'structureBK'. Check lines: 4913, 4886.</p></div>
<div class="balloon" rel="5179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'test' variable was assigned the same value.</p></div>
<div class="balloon" rel="5883"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'w > 0' is always false.</p></div>
<div class="balloon" rel="6034"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (w > 0).</p></div>
<div class="balloon" rel="6597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (anumStereo[i] >= 0).</p></div>
<div class="balloon" rel="6603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (anumStereo[i] >= 0).</p></div>
<div class="balloon" rel="383"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: rx, ry, ac.</p></div>
<div class="balloon" rel="3916"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: queryStereoQ, fIsQueryPrepare.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

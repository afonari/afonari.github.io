
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>MCDLformat.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">Copyright (C) 2007 by Mike N. Burnett, burnettmn@ornl.gov</a>
<a name="ln3">Copyright (C) 2007 by Sergei V. Trepalin sergey_trepalin@chemical-block.com</a>
<a name="ln4">Copyright (C) 2007 by Andrei Gakh andrei.gakh@nnsa.doe.gov</a>
<a name="ln5"> </a>
<a name="ln6">Code translation from Java</a>
<a name="ln7"> </a>
<a name="ln8">This file is part of the Open Babel project.</a>
<a name="ln9">For more information, see &lt;http://openbabel.org/&gt;</a>
<a name="ln10"> </a>
<a name="ln11">This program is free software; you can redistribute it and/or modify</a>
<a name="ln12">it under the terms of the GNU General Public License as published by</a>
<a name="ln13">the Free Software Foundation version 2 of the License.</a>
<a name="ln14"> </a>
<a name="ln15">This program is distributed in the hope that it will be useful,</a>
<a name="ln16">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln17">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18">GNU General Public License for more details.</a>
<a name="ln19">***********************************************************************/</a>
<a name="ln20">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln21">#include &lt;openbabel/obmolecformat.h&gt;</a>
<a name="ln22">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln23">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln24">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln25">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;openbabel/mcdlutil.h&gt;</a>
<a name="ln28">#include &lt;cstdlib&gt;</a>
<a name="ln29"> </a>
<a name="ln30">using namespace std;</a>
<a name="ln31">namespace OpenBabel</a>
<a name="ln32">{</a>
<a name="ln33"> </a>
<a name="ln34">class MCDLFormat : public OBMoleculeFormat</a>
<a name="ln35">{</a>
<a name="ln36">public:</a>
<a name="ln37">  MCDLFormat()</a>
<a name="ln38">  {</a>
<a name="ln39">    OBConversion::RegisterFormat(&quot;mcdl&quot;,this);</a>
<a name="ln40">    init();</a>
<a name="ln41">  }</a>
<a name="ln42"> </a>
<a name="ln43">  virtual const char* Description() //required</a>
<a name="ln44">  {</a>
<a name="ln45">    return</a>
<a name="ln46">    &quot;MCDL format\n&quot;</a>
<a name="ln47">    &quot;Modular Chemical Descriptor Language\n\n&quot;</a>
<a name="ln48">    &quot;As described in [gb2001]_.\n\n&quot;</a>
<a name="ln49"> </a>
<a name="ln50">&quot;.. [gb2001] A.A. Gakh and M.N. Burnett. **Modular Chemical Descriptor\n&quot;</a>
<a name="ln51">&quot;            Language (MCDL): Composition, Connectivity and\n&quot;</a>
<a name="ln52">&quot;            Supplementary Modules.**\n&quot;</a>
<a name="ln53">&quot;            *J. Chem. Inf. Comput. Sci.*, **2004**, *41*, 1491-1499.\n&quot;</a>
<a name="ln54">&quot;            [`Link &lt;https://doi.org/10.1021/ci000108y&gt;`_]\n\n&quot;</a>
<a name="ln55"> </a>
<a name="ln56">&quot;Here's an example conversion from SMILES to MCDL::\n\n&quot;</a>
<a name="ln57">&quot;  obabel -:\&quot;CC(=O)Cl\&quot; -omcdl\n&quot;</a>
<a name="ln58">&quot;  CHHH;COCl[2]\n&quot;;</a>
<a name="ln59">  }</a>
<a name="ln60"> </a>
<a name="ln61">  virtual const char* SpecificationURL(){return</a>
<a name="ln62">     &quot;http://pubs.acs.org/cgi-bin/abstract.cgi/jcisd8/2001/41/i06/abs/ci000108y.html&quot;;}</a>
<a name="ln63"> </a>
<a name="ln64">  virtual const char* GetMIMEType()</a>
<a name="ln65">  { return &quot;chemical/x-MCDL&quot;; }</a>
<a name="ln66"> </a>
<a name="ln67">  /* Flags() can return be any of the following combined by |</a>
<a name="ln68">     or be omitted if none apply</a>
<a name="ln69">     NOTREADABLE  READONEONLY  NOTWRITABLE  WRITEONEONLY  DEFAULTFORMAT</a>
<a name="ln70">     READBINARY  WRITEBINARY  READXML  ZEROATOMSOK*/</a>
<a name="ln71">  virtual unsigned int Flags()</a>
<a name="ln72">  {</a>
<a name="ln73">      return 0;</a>
<a name="ln74">  }</a>
<a name="ln75"> </a>
<a name="ln76">  virtual int SkipObjects(int n, OBConversion* pConv)</a>
<a name="ln77">  {</a>
<a name="ln78">      if(n==0) n++;</a>
<a name="ln79">      string temp;</a>
<a name="ln80">      istream&amp; ifs = *pConv-&gt;GetInStream();</a>
<a name="ln81">      do {</a>
<a name="ln82">          if(ifs.good())</a>
<a name="ln83">            getline(ifs, temp);</a>
<a name="ln84">        }while(ifs.good() &amp;&amp; --n);</a>
<a name="ln85">      return ifs.good() ? 1 : -1;</a>
<a name="ln86">  }</a>
<a name="ln87"> </a>
<a name="ln88">  ////////////////////////////////////////////////////</a>
<a name="ln89">  /// Declarations for the &quot;API&quot; interface functions. Definitions are below</a>
<a name="ln90">  virtual bool ReadMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln91">  virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln92"> </a>
<a name="ln93">private:</a>
<a name="ln94"> </a>
<a name="ln95">  string fsastart;</a>
<a name="ln96">  string fsbstart;</a>
<a name="ln97">  string fchstart;</a>
<a name="ln98">  string fradstart;</a>
<a name="ln99">    //coordinates string</a>
<a name="ln100">  string fnastart;</a>
<a name="ln101">  string fnbstart;</a>
<a name="ln102">  string fzcoorstart;</a>
<a name="ln103">  string fablockstart;</a>
<a name="ln104">  string fbblockstart;</a>
<a name="ln105">  string fchargeblockstart;</a>
<a name="ln106">  string fstereobondstart;</a>
<a name="ln107">  string ftitlestart;</a>
<a name="ln108"> </a>
<a name="ln109">//  int fragNo;</a>
<a name="ln110">  int maxdepth;</a>
<a name="ln111">  int kflag;</a>
<a name="ln112"> </a>
<a name="ln113">  int ntatoms;</a>
<a name="ln114">  int nbonds;</a>
<a name="ln115">  string  finalstr;</a>
<a name="ln116"> </a>
<a name="ln117">  int qx [MAXFRAGS];</a>
<a name="ln118">  int qa [MAXBONDS][4];</a>
<a name="ln119">//  int HVal[NELEMMAX];</a>
<a name="ln120"> </a>
<a name="ln121">private:</a>
<a name="ln122">  void init();</a>
<a name="ln123">  void initGlobals();</a>
<a name="ln124">  void solve(int ntypes, int z[MAXBONDS][4], int depth);</a>
<a name="ln125">  string constring(int conntab [MAXBONDS][4], char * tstr);</a>
<a name="ln126">  string intToStr(int k);</a>
<a name="ln127">  string getMCDL(OBMol* pmol, bool includeCoordinates);</a>
<a name="ln128">  void restoreFullMCDL(string value, OBMol* pmol);</a>
<a name="ln129">  void setMCDL(const string lineToParse, OBMol* pmol, string &amp; sout);</a>
<a name="ln130">  void assignCharges(const std::vector &lt;int&gt; aPosition, const std::vector &lt;int&gt; iA1,</a>
<a name="ln131">    const std::vector &lt;int&gt; iA2, std::vector &lt;int&gt;&amp; aCharges, std::vector &lt;int&gt;&amp; charges,</a>
<a name="ln132">    std::vector &lt;int&gt;&amp; bondOrder, int aPos, int nPrev, int nt, int acount, int bcount);</a>
<a name="ln133">  int indexOf(const string instring, const string substring, int fromPos=0);</a>
<a name="ln134">  int lastIndexOf(const string instring, const string substring);</a>
<a name="ln135">  bool parseFormula(const string formulaString, std::vector &lt;int&gt;&amp; enumber);</a>
<a name="ln136">  string getMolTitle(string &amp; line);</a>
<a name="ln137"> </a>
<a name="ln138">};</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">  void MCDLFormat::init(){</a>
<a name="ln143">    fsastart=&quot;{SA:&quot;;</a>
<a name="ln144">    fsbstart=&quot;{SB:&quot;;</a>
<a name="ln145">    fchstart=&quot;{CZ:&quot;;</a>
<a name="ln146">    fradstart=&quot;{RA:&quot;;</a>
<a name="ln147">    //coordinates string</a>
<a name="ln148">    fnastart=&quot;{NA:&quot;;</a>
<a name="ln149">    fnbstart=&quot;{NB:&quot;;</a>
<a name="ln150">    fzcoorstart=&quot;{ZV:&quot;;</a>
<a name="ln151">    fablockstart=&quot;{CC:&quot;;</a>
<a name="ln152">    fbblockstart=&quot;{BB:&quot;;</a>
<a name="ln153">    fchargeblockstart=&quot;{MM:CHG,&quot;;</a>
<a name="ln154">    fstereobondstart=&quot;{BS:&quot;;</a>
<a name="ln155">    ftitlestart=&quot;{CN:}&quot;;</a>
<a name="ln156"> </a>
<a name="ln157">   };</a>
<a name="ln158"> </a>
<a name="ln159">  void MCDLFormat::initGlobals(){</a>
<a name="ln160">    int i,j;</a>
<a name="ln161"> </a>
<a name="ln162">    maxdepth=0;</a>
<a name="ln163">    kflag=0;</a>
<a name="ln164"> </a>
<a name="ln165">    ntatoms=0;</a>
<a name="ln166">    nbonds=0;</a>
<a name="ln167">    finalstr=&quot;&quot;;</a>
<a name="ln168"> </a>
<a name="ln169">  for (i=0; i&lt;MAXFRAGS; i++) {</a>
<a name="ln170">    qx[i]=0;</a>
<a name="ln171">    for (j=0; j&lt;4; j++) qa[i][j]=0;</a>
<a name="ln172">  };</a>
<a name="ln173"> </a>
<a name="ln174">  };</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">/* Create descriptor connectivity string from connectivity table of fragments */</a>
<a name="ln179">  string MCDLFormat::constring(int conntab [MAXBONDS][4], char * tstr)</a>
<a name="ln180">{</a>
<a name="ln181">    int  i,j,k,n,nn,icons[6],comma;</a>
<a name="ln182">    char line[82],semis[100];</a>
<a name="ln183">    string result=&quot;&quot;;</a>
<a name="ln184"> </a>
<a name="ln185">    result=&quot;[&quot;;</a>
<a name="ln186">    semis[0] = '\0';</a>
<a name="ln187"> </a>
<a name="ln188">    for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln189">    {</a>
<a name="ln190">        if (i &gt; 0)</a>
<a name="ln191">            strcat(semis,&quot;;&quot;);</a>
<a name="ln192"> </a>
<a name="ln193">        n = 0;</a>
<a name="ln194">        for (j=0; j&lt;nbonds; j++)</a>
<a name="ln195">            if (conntab[j][2] == (i+1))</a>
<a name="ln196">                icons[n++] = conntab[j][3];</a>
<a name="ln197">        if (n &gt; 1)</a>
<a name="ln198">        {</a>
<a name="ln199">            for (j=0; j&lt;n-1; j++)</a>
<a name="ln200">                for (k=j+1; k&lt;n; k++)</a>
<a name="ln201">                    if (icons[k] &lt; icons[j])</a>
<a name="ln202">                    {</a>
<a name="ln203">                        nn = icons[j];</a>
<a name="ln204">                        icons[j] = icons[k];</a>
<a name="ln205">                        icons[k] = nn;</a>
<a name="ln206">                    }</a>
<a name="ln207"> </a>
<a name="ln208">        }</a>
<a name="ln209">        comma = 0;</a>
<a name="ln210">        for (j=0; j&lt;n; j++)</a>
<a name="ln211">        {</a>
<a name="ln212">            if (icons[j] &gt; (i+1) &amp;&amp; comma == 0)</a>
<a name="ln213">            {</a>
<a name="ln214">                sprintf(line,&quot;%s%d&quot;,semis,icons[j]);</a>
<a name="ln215">                result=result+line;//strcat(sp,line);</a>
<a name="ln216">                comma = 1;</a>
<a name="ln217">                semis[0] = '\0';</a>
<a name="ln218">            }</a>
<a name="ln219">            else if (icons[j] &gt; (i+1) &amp;&amp; comma == 1)</a>
<a name="ln220">            {</a>
<a name="ln221">                sprintf(line,&quot;,%d&quot;,icons[j]);</a>
<a name="ln222">                result=result+line;//strcat(sp,line);</a>
<a name="ln223">            }</a>
<a name="ln224"> </a>
<a name="ln225">        }</a>
<a name="ln226">    }</a>
<a name="ln227"> </a>
<a name="ln228">    result=result+&quot;]&quot;;</a>
<a name="ln229">    return result;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">  void MCDLFormat::solve(int ntypes, int z[MAXBONDS][4], int depth)</a>
<a name="ln234">{</a>
<a name="ln235">    int  i,dupnum,j,k,ktype,nn,nt;</a>
<a name="ln236">    bool iflag,newone;</a>
<a name="ln237">    int *  nsum[MAXBONDS];</a>
<a name="ln238">    bool lflag[MAXFRAGS];</a>
<a name="ln239">    char strg[MAXFRAGS+1];</a>
<a name="ln240">	char * strngs[MAXFRAGS+1];</a>
<a name="ln241">    char tstr[MAXFRAGS+1];</a>
<a name="ln242">    int  numdups, dupfrag, jump;</a>
<a name="ln243">    bool jflag;</a>
<a name="ln244">    int  ix[MAXFRAGS],conntab[MAXBONDS][4],cx[MAXFRAGS];</a>
<a name="ln245">    int  mx[MAXFRAGS];</a>
<a name="ln246"> </a>
<a name="ln247">	//stack overflow message-move data from stack to heap</a>
<a name="ln248">	for (i=0; i&lt;=MAXFRAGS; i++) strngs[i]=(char *)malloc(MAXFRAGS);</a>
<a name="ln249">    for (i=0; i&lt;MAXBONDS; i++)  nsum[i]=(int *) malloc(MAXFRAGS);</a>
<a name="ln250"> </a>
<a name="ln251">    // depth = recursion level</a>
<a name="ln252">    if (depth &gt; 10)</a>
<a name="ln253">    {</a>
<a name="ln254">        printf(&quot;Ten recursion levels exceeded.\n&quot;);</a>
<a name="ln255">        return;</a>
<a name="ln256">        //exitprog(freeflag);</a>
<a name="ln257">    }</a>
<a name="ln258">    if (depth &gt; maxdepth)</a>
<a name="ln259">        maxdepth = depth;</a>
<a name="ln260"> </a>
<a name="ln261">    for (i=0; i&lt;nbonds; i++)</a>
<a name="ln262">    {</a>
<a name="ln263">        for (j=0; j&lt;4; j++)</a>
<a name="ln264">            conntab[i][j] = z[i][j];</a>
<a name="ln265">        mx[conntab[i][0]-1] = conntab[i][2];</a>
<a name="ln266">    }</a>
<a name="ln267"> </a>
<a name="ln268">    jflag = true;</a>
<a name="ln269">    if (depth == 1)</a>
<a name="ln270">    {</a>
<a name="ln271">        jflag = false;</a>
<a name="ln272">        for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln273">        {</a>
<a name="ln274">            ix[i] = mx[i];</a>
<a name="ln275">            if (ix[i] != mx[0])</a>
<a name="ln276">                jflag = true;</a>
<a name="ln277">        }</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">    iflag = true;</a>
<a name="ln281">    while (iflag)</a>
<a name="ln282">    {</a>
<a name="ln283">        if (jflag)</a>
<a name="ln284">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln285">                ix[i] = 0;</a>
<a name="ln286"> </a>
<a name="ln287">            nt = 1;</a>
<a name="ln288">            ktype = 1;</a>
<a name="ln289">            iflag = false;</a>
<a name="ln290"> </a>
<a name="ln291">           while (nt &lt;= ntypes &amp;&amp; jflag)</a>
<a name="ln292">           {</a>
<a name="ln293">            for (j=0; j&lt;ntatoms; j++)</a>
<a name="ln294">            {</a>
<a name="ln295">                   lflag[j] = false;</a>
<a name="ln296">                for (i=0; i&lt;nbonds; i++)</a>
<a name="ln297">                       nsum[i][j] = 0;</a>
<a name="ln298">            }</a>
<a name="ln299"> </a>
<a name="ln300">            for (i=0; i&lt;nbonds; i++)</a>
<a name="ln301">            if (conntab[i][2] == nt)</a>
<a name="ln302">            {</a>
<a name="ln303">                j = conntab[i][0]-1;</a>
<a name="ln304">                k = conntab[i][3]-1;</a>
<a name="ln305">                nsum[j][k]++;</a>
<a name="ln306">                lflag[j] = true;</a>
<a name="ln307">            }</a>
<a name="ln308"> </a>
<a name="ln309">                nn = 0;</a>
<a name="ln310"> </a>
<a name="ln311">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln312">            if (lflag[i])</a>
<a name="ln313">            {</a>
<a name="ln314">                for (j=0; j&lt;ntypes; j++)</a>
<a name="ln315">                    strg[j] = nsum[i][j]+48;</a>
<a name="ln316">                strg[ntypes] = '\0';</a>
<a name="ln317">                newone = true;</a>
<a name="ln318">                for (j=0; j&lt;nn; j++)</a>
<a name="ln319">                    if (strcmp(strngs[j],strg) == 0)</a>
<a name="ln320">                    {    newone = false;</a>
<a name="ln321">                        break;</a>
<a name="ln322">                    }</a>
<a name="ln323">                if (newone)</a>
<a name="ln324">                    strcpy(strngs[nn++],strg);</a>
<a name="ln325">            }</a>
<a name="ln326"> </a>
<a name="ln327">            if (nn &gt; 1)</a>
<a name="ln328">            {</a>
<a name="ln329">            iflag = true;</a>
<a name="ln330"> </a>
<a name="ln331">            // sort strings</a>
<a name="ln332">            for (i=0; i&lt;nn-1; i++)</a>
<a name="ln333">                for (j=i+1; j&lt;nn; j++)</a>
<a name="ln334">                    if (strcmp(strngs[j],strngs[i]) &gt; 0)</a>
<a name="ln335">                    {</a>
<a name="ln336">                    strcpy(tstr,strngs[i]);</a>
<a name="ln337">                    strcpy(strngs[i],strngs[j]);</a>
<a name="ln338">                    strcpy(strngs[j],tstr);</a>
<a name="ln339">                    }</a>
<a name="ln340">                }</a>
<a name="ln341"> </a>
<a name="ln342">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln343">            if (lflag[i])</a>
<a name="ln344">            {</a>
<a name="ln345">                for (j=0; j&lt;ntypes; j++)</a>
<a name="ln346">                    strg[j] = nsum[i][j]+48;</a>
<a name="ln347">                strg[ntypes] = '\0';</a>
<a name="ln348">                for (j=0; j&lt;nn; j++)</a>
<a name="ln349">                    if (strcmp(strg,strngs[j]) == 0)</a>
<a name="ln350">                        ix[i] = ktype+j;</a>
<a name="ln351">            }</a>
<a name="ln352"> </a>
<a name="ln353">                nt++;</a>
<a name="ln354">                ktype += nn;</a>
<a name="ln355">           }</a>
<a name="ln356"> </a>
<a name="ln357">        ntypes = 0;</a>
<a name="ln358">        for (i=0; i&lt;nbonds; i++)</a>
<a name="ln359">        {</a>
<a name="ln360">            conntab[i][2] = ix[conntab[i][0]-1];</a>
<a name="ln361">            conntab[i][3] = ix[conntab[i][1]-1];</a>
<a name="ln362">            if (conntab[i][2] &gt; ntypes)</a>
<a name="ln363">                ntypes = conntab[i][2];</a>
<a name="ln364">        }</a>
<a name="ln365"> </a>
<a name="ln366">            if (iflag)</a>
<a name="ln367">            continue;</a>
<a name="ln368"> </a>
<a name="ln369">        if (ntypes &lt; ntatoms)</a>
<a name="ln370">        {</a>
<a name="ln371">            for (j=0; j&lt;ntypes; j++)</a>
<a name="ln372">            {</a>
<a name="ln373">            numdups = 0;</a>
<a name="ln374">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln375">                if (ix[i] == j+1)</a>
<a name="ln376">                {</a>
<a name="ln377">                    numdups++;</a>
<a name="ln378">                    jump = ix[i] - mx[i];</a>
<a name="ln379">                }</a>
<a name="ln380">            if (numdups &gt; 1)</a>
<a name="ln381">            {</a>
<a name="ln382">                dupfrag = j+1;</a>
<a name="ln383">                break;</a>
<a name="ln384">            }</a>
<a name="ln385">            }</a>
<a name="ln386"> </a>
<a name="ln387">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln388">                cx[i] = ix[i];</a>
<a name="ln389"> </a>
<a name="ln390">            for (j=0; j&lt;numdups; j++)</a>
<a name="ln391">            {</a>
<a name="ln392">                for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln393">                    ix[i] = cx[i];</a>
<a name="ln394"> </a>
<a name="ln395">            dupnum = 0;</a>
<a name="ln396">                for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln397">            {</a>
<a name="ln398">                if (ix[i] &gt; dupfrag)</a>
<a name="ln399">                    ix[i] = mx[i] + jump + 1;</a>
<a name="ln400">                else if (ix[i] == dupfrag &amp;&amp; j != dupnum)</a>
<a name="ln401">                {</a>
<a name="ln402">                    dupnum++;</a>
<a name="ln403">                    ix[i] = mx[i] + jump + 1;</a>
<a name="ln404">                }</a>
<a name="ln405">                else if (ix[i] == dupfrag &amp;&amp; j == dupnum)</a>
<a name="ln406">                    dupnum++;</a>
<a name="ln407">            }</a>
<a name="ln408"> </a>
<a name="ln409">            ntypes = 0;</a>
<a name="ln410">                for (i=0; i&lt;nbonds; i++)</a>
<a name="ln411">                {</a>
<a name="ln412">                conntab[i][2] = ix[conntab[i][0]-1];</a>
<a name="ln413">                conntab[i][3] = ix[conntab[i][1]-1];</a>
<a name="ln414">                if (conntab[i][2] &gt; ntypes)</a>
<a name="ln415">                    ntypes = conntab[i][2];</a>
<a name="ln416">                }</a>
<a name="ln417">                solve(ntypes,conntab,depth+1);</a>
<a name="ln418">            }</a>
<a name="ln419">        }</a>
<a name="ln420">    }</a>
<a name="ln421"> </a>
<a name="ln422">    if (ntypes == ntatoms)</a>
<a name="ln423">    {</a>
<a name="ln424">            //if (true) fprintf(o_verbose,&quot;%s\n&quot;,constring(conntab,tstr));</a>
<a name="ln425"> </a>
<a name="ln426">        if (!kflag)</a>
<a name="ln427">        {</a>
<a name="ln428">            kflag++;</a>
<a name="ln429">      finalstr=constring(conntab,tstr);</a>
<a name="ln430">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln431">                qx[i] = ix[i];</a>
<a name="ln432">            for (i=0; i&lt;nbonds; i++)</a>
<a name="ln433">                for (j=0; j&lt;4; j++)</a>
<a name="ln434">                    qa[i][j] = conntab[i][j];</a>
<a name="ln435">        }</a>
<a name="ln436">        else if (finalstr != constring(conntab,tstr))</a>
<a name="ln437">        {</a>
<a name="ln438">            for (i=0; i&lt;ntatoms; i++)</a>
<a name="ln439">            {</a>
<a name="ln440">                tstr[0] = '\0';</a>
<a name="ln441">                strg[0] = '\0';</a>
<a name="ln442">                for (j=0; j&lt;ntatoms; j++)</a>
<a name="ln443">                {</a>
<a name="ln444">                    strcat(tstr,&quot;0&quot;);</a>
<a name="ln445">                    strcat(strg,&quot;0&quot;);</a>
<a name="ln446">                }</a>
<a name="ln447">                for (j=0; j&lt;nbonds; j++)</a>
<a name="ln448">                {</a>
<a name="ln449">                    if (conntab[j][2] == (i+1))</a>
<a name="ln450">                           tstr[conntab[j][3]-1] = '1';</a>
<a name="ln451">                    if (qa[j][2] == (i+1))</a>
<a name="ln452">                           strg[qa[j][3]-1] = '1';</a>
<a name="ln453">                }</a>
<a name="ln454">                if (strcmp(tstr,strg) &lt; 0)</a>
<a name="ln455">                       break;</a>
<a name="ln456">                if (strcmp(tstr,strg) &gt; 0)</a>
<a name="ln457">                {</a>
<a name="ln458">                    finalstr=constring(conntab,tstr);</a>
<a name="ln459">                    for (j=0; j&lt;ntatoms; j++)</a>
<a name="ln460">                        qx[j] = ix[j];</a>
<a name="ln461">                    for (j=0; j&lt;nbonds; j++)</a>
<a name="ln462">                        for (k=0; k&lt;4; k++)</a>
<a name="ln463">                            qa[j][k] = conntab[j][k];</a>
<a name="ln464">                    break;</a>
<a name="ln465">                }</a>
<a name="ln466">            }</a>
<a name="ln467">        }</a>
<a name="ln468">    }</a>
<a name="ln469">	//freeing resources</a>
<a name="ln470">	for (i=0; i&lt;=MAXFRAGS; i++) free(strngs[i]);</a>
<a name="ln471">	for (i=0; i&lt; MAXBONDS; i++) free(nsum[i]);</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474"> </a>
<a name="ln475">  string MCDLFormat::intToStr(int k) {</a>
<a name="ln476">    char temp[16];</a>
<a name="ln477">    sprintf(temp,&quot;%d&quot;,k);</a>
<a name="ln478">  string line=temp;</a>
<a name="ln479">  return line;</a>
<a name="ln480">  };</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">  string MCDLFormat::getMCDL(OBMol* pmol, bool includeCoordinates) {</a>
<a name="ln485">    int  i=0;</a>
<a name="ln486">    int  j=0;</a>
<a name="ln487">    int  k=0;</a>
<a name="ln488">    int  n=0;</a>
<a name="ln489">    int  nt=0;</a>
<a name="ln490">    int  nn=0;</a>
<a name="ln491">    int  ntypes=0;</a>
<a name="ln492">    int  charge=0;</a>
<a name="ln493">    int  netcharge=0;</a>
<a name="ln494">    int  netradical=0;</a>
<a name="ln495">    int  chgarray[60][2];</a>
<a name="ln496">    std::vector&lt;int&gt; ifragnum(MAXFRAGS);</a>
<a name="ln497">    int  ltypes=0;</a>
<a name="ln498">    int  ia0=0;</a>
<a name="ln499">    int  ia1=0;</a>
<a name="ln500">    int  chgflag=0;</a>
<a name="ln501">    int  radicalflag=0;</a>
<a name="ln502">    int  icons[96];</a>
<a name="ln503">    int  newone=0;</a>
<a name="ln504">    std::vector&lt;int&gt; nchg(MAXFRAGS);</a>
<a name="ln505">    std::vector&lt;int&gt; nrad(MAXFRAGS);</a>
<a name="ln506">    int naStore,nbStore;</a>
<a name="ln507">    string constr=&quot;&quot;;</a>
<a name="ln508">    string frag=&quot;&quot;;</a>
<a name="ln509">    string fragment [MAXFRAGS];</a>
<a name="ln510">    string line=&quot;&quot;;</a>
<a name="ln511">    string semis=&quot;&quot;;</a>
<a name="ln512">    int  comma;</a>
<a name="ln513">    std::vector&lt;int&gt; ix(MAXFRAGS);</a>
<a name="ln514">    int ia[MAXBONDS][4];</a>
<a name="ln515">    string data=&quot;&quot;;</a>
<a name="ln516">    int z[MAXBONDS][4];</a>
<a name="ln517">    //FRAGCON</a>
<a name="ln518">    int nHydr[MAXFRAGS];</a>
<a name="ln519">    string aSymb [MAXFRAGS];</a>
<a name="ln520">    int aCharge[MAXFRAGS];</a>
<a name="ln521">    int aRadical[MAXFRAGS];</a>
<a name="ln522">    std::vector&lt;int&gt; aNumber(MAXFRAGS);</a>
<a name="ln523">    int bonds[MAXBONDS][4];</a>
<a name="ln524">    int nConn[MAXFRAGS];</a>
<a name="ln525">    //string s;</a>
<a name="ln526">    int l;//,m;</a>
<a name="ln527">    string astereo=&quot;&quot;;</a>
<a name="ln528">    string bstereo=&quot;&quot;;</a>
<a name="ln529">    string s1,s2;</a>
<a name="ln530">    std::vector &lt;int&gt; eqList;</a>
<a name="ln531">    std::vector &lt;int&gt;  bondStereoList;</a>
<a name="ln532">    std::vector &lt;int&gt;  atomStereoList;</a>
<a name="ln533">    std::vector &lt;int&gt;  anumStereo;</a>
<a name="ln534">    string as1,as2,as3,as4;</a>
<a name="ln535">    string linestereo;</a>
<a name="ln536">    OBAtom *atom;</a>
<a name="ln537">    OBBond *bond;</a>
<a name="ln538"> </a>
<a name="ln539">/* read in fragments and find different types */</a>
<a name="ln540">/* ntypes: number of fragment types */</a>
<a name="ln541">/* ntatoms: total number of fragments */</a>
<a name="ln542">/* fragment[i]: atomic symbol string of fragment type i */</a>
<a name="ln543">/* ifragnum[i]: number of fragments of type i */</a>
<a name="ln544"> </a>
<a name="ln545">  initGlobals();</a>
<a name="ln546">    ntypes = 0;</a>
<a name="ln547">    ntatoms = 0;</a>
<a name="ln548">    for (i=0; i&lt;MAXFRAGS; i++)</a>
<a name="ln549">        ifragnum[i] = 0;</a>
<a name="ln550"> </a>
<a name="ln551">    chgflag = 0;</a>
<a name="ln552">    netcharge = 0;</a>
<a name="ln553">    radicalflag=0;</a>
<a name="ln554">    netradical=0;</a>
<a name="ln555"> </a>
<a name="ln556">  netcharge=pmol-&gt;GetTotalCharge();</a>
<a name="ln557">  netradical=pmol-&gt;GetTotalSpinMultiplicity()-1;</a>
<a name="ln558"> </a>
<a name="ln559">//Here FRAGCON conversion...</a>
<a name="ln560">  pmol-&gt;DeleteHydrogens();</a>
<a name="ln561">  createStereoLists(pmol,bondStereoList,atomStereoList,eqList);</a>
<a name="ln562">//    return &quot;started&quot;; //passed</a>
<a name="ln563">  naStore=pmol-&gt;NumAtoms();</a>
<a name="ln564">  nbStore=pmol-&gt;NumBonds();</a>
<a name="ln565">  for (i=1; i&lt;=naStore; i++) {</a>
<a name="ln566">    atom=pmol-&gt;GetAtom(i);</a>
<a name="ln567">    nHydr[i-1]=atom-&gt;GetImplicitHCount()+atom-&gt;ExplicitHydrogenCount();</a>
<a name="ln568">    aCharge[i-1]=atom-&gt;GetFormalCharge();</a>
<a name="ln569">    aRadical[i-1]=atom-&gt;GetSpinMultiplicity();</a>
<a name="ln570">    aSymb[i-1]=OBElements::GetSymbol(atom-&gt;GetAtomicNum());</a>
<a name="ln571">    nConn[i-1]=atom-&gt;GetHvyDegree();</a>
<a name="ln572">    aNumber[i-1]=i-1;</a>
<a name="ln573">  };</a>
<a name="ln574">  for (i=1; i&lt;=nbStore; i++) {</a>
<a name="ln575">    bond=pmol-&gt;GetBond(i-1);</a>
<a name="ln576">    bonds[i-1][0]=bond-&gt;GetBeginAtomIdx();</a>
<a name="ln577">    bonds[i-1][1]=bond-&gt;GetEndAtomIdx();</a>
<a name="ln578">      bonds[i-1][2]=bond-&gt;GetBondOrder();  //type of bond store</a>
<a name="ln579">      bonds[i-1][3]=i;                     //bond number in sm store</a>
<a name="ln580">    };</a>
<a name="ln581">    //FRAGCON</a>
<a name="ln582">    i=0;</a>
<a name="ln583">    while (i &lt; naStore) {</a>
<a name="ln584">      if ((nConn[i] == 1) &amp;&amp; (nHydr[i] == 0)) {</a>
<a name="ln585">        k=-1;</a>
<a name="ln586">        for (j=0; j&lt;nbStore; j++) if ((bonds[j][0] == (i+1)) || (bonds[j][1] == (i+1))) {</a>
<a name="ln587">          k=j;</a>
<a name="ln588">          break;</a>
<a name="ln589">        }</a>
<a name="ln590">        if (k&gt;=0) {</a>
<a name="ln591">          if (bonds[k][0] == (i+1)) nn=bonds[k][1]-1; else nn=bonds[k][0]-1;</a>
<a name="ln592">          aCharge[nn]=aCharge[nn]+aCharge[i];</a>
<a name="ln593">          aRadical[nn]=aRadical[nn]+aRadical[i];</a>
<a name="ln594">          aSymb[nn]=aSymb[nn]+aSymb[i];</a>
<a name="ln595">          for (j=i; j&lt;(naStore-1); j++) {</a>
<a name="ln596">            nHydr[j]=nHydr[j+1];</a>
<a name="ln597">            aCharge[j]=aCharge[j+1];</a>
<a name="ln598">            aRadical[j]=aRadical[j+1];</a>
<a name="ln599">            aSymb[j]=aSymb[j+1];</a>
<a name="ln600">            nConn[j]=nConn[j+1];</a>
<a name="ln601">            aNumber[j]=aNumber[j+1];</a>
<a name="ln602">          };</a>
<a name="ln603">          for (j=0; j&lt;nbStore; j++) {</a>
<a name="ln604">            if (bonds[j][0] &gt; (i+1)) bonds[j][0]--;</a>
<a name="ln605">            if (bonds[j][1] &gt; (i+1)) bonds[j][1]--;</a>
<a name="ln606">          };</a>
<a name="ln607">          for (j=k; j&lt;(nbStore-1); j++) {</a>
<a name="ln608">            bonds[j][0]=bonds[j+1][0];</a>
<a name="ln609">            bonds[j][1]=bonds[j+1][1];</a>
<a name="ln610">            bonds[j][2]=bonds[j+1][2];</a>
<a name="ln611">            bonds[j][3]=bonds[j+1][3];</a>
<a name="ln612">          };</a>
<a name="ln613">          i--;</a>
<a name="ln614">          naStore--;</a>
<a name="ln615">          nbStore--;</a>
<a name="ln616">        };</a>
<a name="ln617">      };</a>
<a name="ln618">      i++;</a>
<a name="ln619">    }</a>
<a name="ln620">//Ald without fragcon</a>
<a name="ln621">  for (i=1; i&lt;=naStore; i++) {</a>
<a name="ln622">      charge=aCharge[i-1];</a>
<a name="ln623">      if (charge != 0) chgflag = 1;</a>
<a name="ln624">      if (aRadical[i-1] != 0) radicalflag=1;</a>
<a name="ln625">      ntatoms++;</a>
<a name="ln626">      newone = 1;</a>
<a name="ln627">      frag=aSymb[i-1];</a>
<a name="ln628">      j=nHydr[i-1];</a>
<a name="ln629">      if (j&gt;0) for (l=0; l&lt;j; l++) {</a>
<a name="ln630">        frag=frag+&quot;H&quot;;</a>
<a name="ln631">      };</a>
<a name="ln632">      for (j=0; j&lt;ntypes; j++) if (fragment[j] == frag) {</a>
<a name="ln633">        ifragnum[j]++;</a>
<a name="ln634">        newone = 0;</a>
<a name="ln635">        break;</a>
<a name="ln636">      }</a>
<a name="ln637">      if (newone != 0) {</a>
<a name="ln638">        fragment[ntypes]=frag;</a>
<a name="ln639">        ifragnum[ntypes]++;</a>
<a name="ln640">        ntypes++;</a>
<a name="ln641">      }</a>
<a name="ln642">    }</a>
<a name="ln643"> </a>
<a name="ln644">    ltypes=ntypes;</a>
<a name="ln645">// order fragment types in ASCII order</a>
<a name="ln646">    for (i=0; i&lt;ntypes-1; i++) for (j=i+1; j&lt;ntypes; j++) if (fragment[j] &lt; fragment[i]) {</a>
<a name="ln647">      frag=fragment[i];</a>
<a name="ln648">      fragment[i]=fragment[j];</a>
<a name="ln649">      fragment[j]=frag;</a>
<a name="ln650">      k = ifragnum[i];</a>
<a name="ln651">      ifragnum[i] = ifragnum[j];</a>
<a name="ln652">      ifragnum[j] = k;</a>
<a name="ln653">    }</a>
<a name="ln654">// reread the fragments</a>
<a name="ln655">// ix[i]: fragment type of fragment i</a>
<a name="ln656">    for (i=1; i&lt;=ntatoms; i++) {</a>
<a name="ln657">      frag=aSymb[i-1];</a>
<a name="ln658">      j=nHydr[i-1];</a>
<a name="ln659">      if (j&gt;0) for (l=0; l&lt;j; l++) {</a>
<a name="ln660">        frag=frag+&quot;H&quot;;</a>
<a name="ln661">      };</a>
<a name="ln662">      for (j=0; j&lt;ntypes; j++) if (frag == fragment[j]) ix[i-1] = j+1;</a>
<a name="ln663">    }</a>
<a name="ln664"> </a>
<a name="ln665">//FRAGCON format atoms conversion</a>
<a name="ln666">// read in the connections</a>
<a name="ln667">// ia[i][0]: from fragment; ia[i][1]: to fragment of connection i</a>
<a name="ln668">    nbonds = 0;</a>
<a name="ln669">    for (i=1; i&lt;=nbStore; i++) {</a>
<a name="ln670">      // Possible, DRAGON format can contains multiply bonds between 2 atoms. Bond order?</a>
<a name="ln671">      ia0=bonds[i-1][0];</a>
<a name="ln672">      ia1=bonds[i-1][1];</a>
<a name="ln673"> </a>
<a name="ln674">      newone = 1;</a>
<a name="ln675">      for (j=0; j&lt;nbonds; j++)</a>
<a name="ln676">          if ((ia[j][0] == ia0 &amp;&amp; ia[j][1] == ia1) ||</a>
<a name="ln677">              (ia[j][0] == ia1 &amp;&amp; ia[j][1] == ia0))</a>
<a name="ln678">          {</a>
<a name="ln679">              newone = 0;</a>
<a name="ln680">              break;</a>
<a name="ln681">          }</a>
<a name="ln682">      if (newone == 1) {</a>
<a name="ln683">        ia[nbonds][0] = ia0;</a>
<a name="ln684">        ia[nbonds][1] = ia1;</a>
<a name="ln685">        nbonds=nbonds+1;</a>
<a name="ln686">        ia[nbonds][0] = ia1;</a>
<a name="ln687">        ia[nbonds][1] = ia0;</a>
<a name="ln688">        nbonds=nbonds+1;</a>
<a name="ln689">      }</a>
<a name="ln690">    };</a>
<a name="ln691">    for (i=0; i&lt;nbonds; i++) {</a>
<a name="ln692">        ia[i][2] = ix[ia[i][0]-1];</a>
<a name="ln693">        ia[i][3] = ix[ia[i][1]-1];</a>
<a name="ln694">    };</a>
<a name="ln695">    for (i=0; i&lt;nbonds; i++) for (j=0; j&lt;4; j++) {</a>
<a name="ln696">      z[i][j] = ia[i][j];</a>
<a name="ln697">    };</a>
<a name="ln698">    maxdepth = 1;</a>
<a name="ln699"> </a>
<a name="ln700">        // data ready for solution</a>
<a name="ln701">    solve(ntypes,z,1);</a>
<a name="ln702"> </a>
<a name="ln703">    for (i=0; i&lt;ntatoms; i++) ix[i] = qx[i];</a>
<a name="ln704">    for (i=0; i&lt;nbonds; i++) for (j=0; j&lt;4; j++) ia[i][j] = qa[i][j];</a>
<a name="ln705"> </a>
<a name="ln706">//atoms stereo getting</a>
<a name="ln707">    astereo=getAtomMCDL(pmol,ntatoms,ix,aNumber,atomStereoList,eqList);</a>
<a name="ln708">//bond stereo getting</a>
<a name="ln709">    bstereo=getBondMCDL(pmol,nbStore,ntatoms,ix,aNumber,bonds,bondStereoList,eqList);</a>
<a name="ln710"> </a>
<a name="ln711">    // original and final fragment numbers</a>
<a name="ln712">    if (chgflag != 0) for (i=0; i&lt;ntatoms; i++) nchg[ix[i]] = aCharge[i];</a>
<a name="ln713">    if (radicalflag != 0) for (i=0; i&lt;ntatoms; i++) nrad[ix[i]] = aRadical[i];</a>
<a name="ln714"> </a>
<a name="ln715">    // net charge</a>
<a name="ln716">    data=&quot;&quot;;</a>
<a name="ln717">    if (netcharge != 0)</a>
<a name="ln718">    {</a>
<a name="ln719">        if (netcharge &gt; 0)</a>
<a name="ln720">            data=data+intToStr(netcharge)+&quot;+;&quot;;</a>
<a name="ln721">        else data=data+intToStr(abs(netcharge))+&quot;-;&quot;;</a>
<a name="ln722">    }</a>
<a name="ln723">    if (netradical != 0) data=data+intToStr(netradical)+&quot;*;&quot;;</a>
<a name="ln724">    // fragment portion of linear descriptor</a>
<a name="ln725">    for (i=0; i&lt;ltypes; i++) {</a>
<a name="ln726">      if (i &gt; 0) {</a>
<a name="ln727">        data=data+';';</a>
<a name="ln728">      }</a>
<a name="ln729">      if (ifragnum[i] &gt; 1) {</a>
<a name="ln730">        data=data+intToStr(ifragnum[i]);</a>
<a name="ln731">      }</a>
<a name="ln732">      data=data+fragment[i];</a>
<a name="ln733">    }</a>
<a name="ln734">    constr=&quot;[&quot;;</a>
<a name="ln735">    // connectivity portion of linear descriptor</a>
<a name="ln736">    semis=&quot;&quot;;</a>
<a name="ln737">    nt = 1;</a>
<a name="ln738">    for (i=0; i&lt;ntatoms; i++) {</a>
<a name="ln739">      if (i &gt; 0) {</a>
<a name="ln740">        semis=semis+&quot;;&quot;;</a>
<a name="ln741">      }</a>
<a name="ln742">      n = 0;</a>
<a name="ln743">      for (j=0; j&lt;nbonds; j++) if (ia[j][2] == (i+1)) icons[n++] = ia[j][3];</a>
<a name="ln744">      if (n &gt; 1) {</a>
<a name="ln745">        for (j=0; j&lt;n-1; j++) for (k=j+1; k&lt;n; k++) if (icons[k] &lt; icons[j]) {</a>
<a name="ln746">          nn = icons[j];</a>
<a name="ln747">          icons[j] = icons[k];</a>
<a name="ln748">          icons[k] = nn;</a>
<a name="ln749">        }</a>
<a name="ln750">      }</a>
<a name="ln751">      comma = 0;</a>
<a name="ln752">      for (j=0; j&lt;n; j++) {</a>
<a name="ln753">        if ((icons[j] &gt; (i+1)) &amp;&amp; (comma == 0)) {</a>
<a name="ln754">          constr=constr+semis;</a>
<a name="ln755">          constr=constr+intToStr(icons[j]);</a>
<a name="ln756">          comma = 1;</a>
<a name="ln757">          semis=&quot;&quot;;</a>
<a name="ln758">        }  else if ((icons[j] &gt; (i+1)) &amp;&amp; (comma == 1)) {</a>
<a name="ln759">          constr=constr+&quot;,&quot;+intToStr(icons[j]);</a>
<a name="ln760">        }</a>
<a name="ln761">      }</a>
<a name="ln762">      nt++;</a>
<a name="ln763">    };</a>
<a name="ln764">    line=line+&quot;]&quot;;</a>
<a name="ln765"> </a>
<a name="ln766">    constr=constr+line;</a>
<a name="ln767">    data=data+constr;</a>
<a name="ln768">    // fragment charges</a>
<a name="ln769">    if (chgflag != 0) {</a>
<a name="ln770">      nt = 0;</a>
<a name="ln771">      for (n=-3; n&lt;4; n++) for (i=0; i&lt;ntatoms; i++) if ((nchg[ix[i]] == n) &amp;&amp; (n != 0)) {</a>
<a name="ln772">        chgarray[nt][0] = n;</a>
<a name="ln773">        chgarray[nt++][1] = ix[i];</a>
<a name="ln774">      }</a>
<a name="ln775">      for (i=0; i&lt;nt-1; i++) for (j=i; j&lt;nt; j++) if (chgarray[i][0] &gt; chgarray[j][0]) {</a>
<a name="ln776">        k = chgarray[i][0];</a>
<a name="ln777">        n = chgarray[i][1];</a>
<a name="ln778">        chgarray[i][0] = chgarray[j][0];</a>
<a name="ln779">        chgarray[i][1] = chgarray[j][1];</a>
<a name="ln780">        chgarray[j][0] = k;</a>
<a name="ln781">        chgarray[j][1] = n;</a>
<a name="ln782">      }</a>
<a name="ln783">      for (i=0; i&lt;nt-1; i++) for (j=i; j&lt;nt; j++) if ((chgarray[i][0] == chgarray[j][0]) &amp;&amp; (chgarray[i][1] &gt; chgarray[j][1])) {</a>
<a name="ln784">        n = chgarray[i][1];</a>
<a name="ln785">        chgarray[i][1] = chgarray[j][1];</a>
<a name="ln786">        chgarray[j][1] = n;</a>
<a name="ln787">      }</a>
<a name="ln788">      line=&quot;&quot;;</a>
<a name="ln789">      for (i=-1; i&gt;-4; i--) {</a>
<a name="ln790">        n = 0;</a>
<a name="ln791">        for (j=0; j&lt;nt; j++) if (chgarray[j][0] == i) n++;</a>
<a name="ln792">        if (n &gt; 0) {</a>
<a name="ln793">          for (j=0; j&lt;nt; j++) if (chgarray[j][0] == i) {</a>
<a name="ln794">            if (chgarray[j][1] == 0)</a>
<a name="ln795">              frag=&quot;&quot;+intToStr(chgarray[j][1])+&quot;,&quot;+intToStr(abs(i))+&quot;-&quot;;//Math.abs(i)+&quot;-1&quot;;</a>
<a name="ln796">            else</a>
<a name="ln797">              frag=&quot;&quot;+intToStr(chgarray[j][1])+&quot;,&quot;+intToStr(abs(i))+&quot;-&quot;;//Math.abs(i)+&quot;-&quot;+chgarray[j][1];</a>
<a name="ln798">            if (line.length() &gt; 0) line=line+&quot;;&quot;;</a>
<a name="ln799">            line=line+frag;</a>
<a name="ln800">          }</a>
<a name="ln801">        }</a>
<a name="ln802">      }</a>
<a name="ln803">      for (i=1; i&lt;4; i++){</a>
<a name="ln804">        n = 0;</a>
<a name="ln805">        for (j=0; j&lt;nt; j++) if (chgarray[j][0] == i) n++;</a>
<a name="ln806">        if (n &gt; 0) {</a>
<a name="ln807">          for (j=0; j&lt;nt; j++) if (chgarray[j][0] == i) {</a>
<a name="ln808">            if (chgarray[j][1] == 0)</a>
<a name="ln809">              frag=&quot;&quot;+intToStr(chgarray[j][1])+&quot;,&quot;+intToStr(i)+&quot;+&quot;;//i+&quot;+1&quot;;</a>
<a name="ln810">            else</a>
<a name="ln811">              frag=&quot;&quot;+intToStr(chgarray[j][1])+&quot;,&quot;+intToStr(i)+&quot;+&quot;;</a>
<a name="ln812">            if (line.length() &gt; 0) line=line+&quot;;&quot;;</a>
<a name="ln813">            line=line+frag;</a>
<a name="ln814">          }</a>
<a name="ln815">        }</a>
<a name="ln816">      }</a>
<a name="ln817">      if (ntypes&gt;1) {</a>
<a name="ln818">        constr=fchstart;//&quot;{CZ:&quot;;</a>
<a name="ln819">        constr=constr+line;</a>
<a name="ln820">        constr=constr+&quot;}&quot;;</a>
<a name="ln821">        data=data+constr;</a>
<a name="ln822">      };</a>
<a name="ln823"> </a>
<a name="ln824">    };</a>
<a name="ln825">    //radical processing</a>
<a name="ln826">    if (radicalflag != 0) {</a>
<a name="ln827">      for (i=0; i&lt;ntatoms; i++) {</a>
<a name="ln828">        chgarray[i][0]=0;</a>
<a name="ln829">        chgarray[i][1]=0;</a>
<a name="ln830">      };</a>
<a name="ln831">      nt = 0;</a>
<a name="ln832">      for (n=1; n&lt;3; n++) for (i=0; i&lt;ntatoms; i++) if (nrad[ix[i]] == n) {</a>
<a name="ln833">        chgarray[nt][0] = n;</a>
<a name="ln834">        chgarray[nt++][1] = ix[i];</a>
<a name="ln835">      }</a>
<a name="ln836">      for (i=0; i&lt;nt-1; i++) for (j=i; j&lt;nt; j++) if (chgarray[i][0] &gt; chgarray[j][0]) {</a>
<a name="ln837">        k = chgarray[i][0];</a>
<a name="ln838">        n = chgarray[i][1];</a>
<a name="ln839">        chgarray[i][0] = chgarray[j][0];</a>
<a name="ln840">        chgarray[i][1] = chgarray[j][1];</a>
<a name="ln841">        chgarray[j][0] = k;</a>
<a name="ln842">        chgarray[j][1] = n;</a>
<a name="ln843">      }</a>
<a name="ln844">      for (i=0; i&lt;nt-1; i++) for (j=i; j&lt;nt; j++) if ((chgarray[i][0] == chgarray[j][0]) &amp;&amp; (chgarray[i][1] &gt; chgarray[j][1])) {</a>
<a name="ln845">        n = chgarray[i][1];</a>
<a name="ln846">        chgarray[i][1] = chgarray[j][1];</a>
<a name="ln847">        chgarray[j][1] = n;</a>
<a name="ln848">      }</a>
<a name="ln849">      line=&quot;&quot;;</a>
<a name="ln850">      for (i=1; i&lt;3; i++){</a>
<a name="ln851">        n = 0;</a>
<a name="ln852">        for (j=0; j&lt;nt; j++) if (chgarray[j][0] == i) n++;</a>
<a name="ln853">        if (n &gt; 0) {</a>
<a name="ln854">          for (j=0; j&lt;nt; j++) if (chgarray[j][0] == i) {</a>
<a name="ln855">            if (chgarray[j][1] == 0)</a>
<a name="ln856">              frag=&quot;&quot;+intToStr(chgarray[j][1])+&quot;,&quot;+intToStr(i)+&quot;*&quot;;</a>
<a name="ln857">            else</a>
<a name="ln858">              frag=&quot;&quot;+intToStr(chgarray[j][1])+&quot;,&quot;+intToStr(i)+&quot;*&quot;;</a>
<a name="ln859">            if (line.length() &gt; 0) line=line+&quot;;&quot;;</a>
<a name="ln860">            line=line+frag;</a>
<a name="ln861">          }</a>
<a name="ln862">        }</a>
<a name="ln863">      }</a>
<a name="ln864">      if (ntypes&gt;1) {</a>
<a name="ln865">        constr=fradstart;//&quot;{CZ:&quot;;</a>
<a name="ln866">        constr=constr+line;</a>
<a name="ln867">        constr=constr+&quot;}&quot;;</a>
<a name="ln868">        data=data+constr;</a>
<a name="ln869">      };</a>
<a name="ln870"> </a>
<a name="ln871">    };</a>
<a name="ln872"> </a>
<a name="ln873">//*****************************************************************************</a>
<a name="ln874">    data=data+astereo;</a>
<a name="ln875">    data=data+bstereo;</a>
<a name="ln876">//*****************************************************************************</a>
<a name="ln877">  /*   Block should be saved for future using</a>
<a name="ln878"> </a>
<a name="ln879">    if (includeCoordinates &amp;&amp; (sm.fAtom.maxIndex() &gt; 0))  {</a>
<a name="ln880">      //Atom and bond blocks include</a>
<a name="ln881">      data=data+fnastart+sm.fAtom.maxIndex()+&quot;}&quot;;//};</a>
<a name="ln882">      data=data+fnbstart+sm.fBond.maxIndex()+&quot;}&quot;;//};</a>
<a name="ln883">      data=data+fzcoorstart+&quot;N}&quot;;</a>
<a name="ln884">      //analizing minimal and maximal values of atomic coordinates</a>
<a name="ln885">      xMin=sm.fAtom.getRX(1); xMax=sm.fAtom.getRX(1); yMin=sm.fAtom.getRY(1); yMax=sm.fAtom.getRY(1);</a>
<a name="ln886">      for (i=1; i&lt;=sm.fAtom.maxIndex(); i++) {</a>
<a name="ln887">        if (sm.fAtom.getRX(i) &lt; xMin) xMin=sm.fAtom.getRX(i);</a>
<a name="ln888">        if (sm.fAtom.getRX(i) &gt; xMax) xMax=sm.fAtom.getRX(i);</a>
<a name="ln889">        if (sm.fAtom.getRY(i) &lt; yMin) yMin=sm.fAtom.getRY(i);</a>
<a name="ln890">        if (sm.fAtom.getRY(i) &gt; yMax) yMax=sm.fAtom.getRY(i);</a>
<a name="ln891">      };</a>
<a name="ln892">      scale=0;</a>
<a name="ln893">      if (xMax != xMin) scale=1/(xMax-xMin);</a>
<a name="ln894">      if (yMax != yMin) if ((1/(yMax-yMin)) &lt; scale) scale=1/(yMax-yMin);</a>
<a name="ln895">      if (scale == 0) scale=1;</a>
<a name="ln896">      line=fablockstart;</a>
<a name="ln897">      nCharge=0;</a>
<a name="ln898">      for (i=1; i&lt;=sm.fAtom.maxIndex(); i++) {</a>
<a name="ln899">        r=sm.fAtom.getRX(i);</a>
<a name="ln900">        r=9.99*(r-xMin)*scale;</a>
<a name="ln901">        s=CommonRout.str(r,0,2);</a>
<a name="ln902">        line=line+s+&quot;,&quot;;</a>
<a name="ln903">        r=sm.fAtom.getRY(i);</a>
<a name="ln904">        r=9.99*(r-yMin)*scale;</a>
<a name="ln905">        s=CommonRout.str(r,0,2);</a>
<a name="ln906">        line=line+s+Atom.symbolofAtom(sm.fAtom.getNA(i));</a>
<a name="ln907">        if (i &lt; sm.fAtom.maxIndex()) line=line+&quot;;&quot;; else line=line+&quot;}&quot;;//};</a>
<a name="ln908">        if (sm.fAtom.getNC(i) != 0) nCharge++;</a>
<a name="ln909">      };</a>
<a name="ln910">      data=data+line;</a>
<a name="ln911">      line=fbblockstart;</a>
<a name="ln912">      //two lines - adition for stereo handling</a>
<a name="ln913">      test=false;</a>
<a name="ln914">      linestereo=fstereobondstart;</a>
<a name="ln915">      for (i=1; i&lt;=sm.fBond.maxIndex(); i++) {</a>
<a name="ln916">        n=sm.fBond.getTB(i);</a>
<a name="ln917">        s=&quot;s&quot;;</a>
<a name="ln918">        if (n &gt; 3) n=1;</a>
<a name="ln919">        if (n == 2) s=&quot;d&quot;; else if (n == 3) s=&quot;t&quot;;</a>
<a name="ln920">        s=&quot;&quot;+sm.fBond.getAT(i,1)+s+sm.fBond.getAT(i,2);</a>
<a name="ln921">        line=line+s;</a>
<a name="ln922">        if (i &lt; sm.fBond.maxIndex()) line=line+&quot;;&quot;; else line=line+&quot;}&quot;; //};</a>
<a name="ln923">        //stereoanalizing</a>
<a name="ln924">        n=sm.fBond.getTB(i);</a>
<a name="ln925">        if ((n &gt;= 9) &amp;&amp; (n &lt;= 11)) {</a>
<a name="ln926">          if (test) linestereo=linestereo+&quot;;&quot;;</a>
<a name="ln927">          test=true;</a>
<a name="ln928">          s=&quot;p&quot;;</a>
<a name="ln929">          if (n == 10) s=&quot;o&quot;; else if (n == 11) s=&quot;e&quot;;</a>
<a name="ln930">          s=&quot;&quot;+sm.fBond.getAT(i,1)+s+sm.fBond.getAT(i,2);</a>
<a name="ln931">          linestereo=linestereo+s;</a>
<a name="ln932">        };</a>
<a name="ln933">      };</a>
<a name="ln934">      data=data+line;</a>
<a name="ln935">      if (test) {</a>
<a name="ln936">        linestereo=linestereo+&quot;}&quot;; //};</a>
<a name="ln937">        data=data+linestereo;</a>
<a name="ln938">      };</a>
<a name="ln939">      if (nCharge != 0) {</a>
<a name="ln940">        line=fchargeblockstart+nCharge;</a>
<a name="ln941">        for (i=1; i&lt;= sm.fAtom.maxIndex(); i++) if (sm.fAtom.getNC(i) != 0) line=line+&quot;,&quot;+i+&quot;,&quot;+sm.fAtom.getNC(i);</a>
<a name="ln942">        line=line+&quot;}&quot;;</a>
<a name="ln943">        data=data+line;</a>
<a name="ln944">      };</a>
<a name="ln945">    };</a>
<a name="ln946">  */</a>
<a name="ln947">    return data;</a>
<a name="ln948">  };</a>
<a name="ln949"> </a>
<a name="ln950">  void MCDLFormat::restoreFullMCDL(string value, OBMol* pmol) {</a>
<a name="ln951"> </a>
<a name="ln952">  };</a>
<a name="ln953"> </a>
<a name="ln954">  void MCDLFormat::setMCDL(const string lineToParse, OBMol* pmol, string &amp; sout) {</a>
<a name="ln955"> </a>
<a name="ln956">  std::vector &lt;int&gt; nH(MAXFRAGS);</a>
<a name="ln957">  std::vector &lt;int&gt; nF(MAXFRAGS);</a>
<a name="ln958">//  int nb;//,na;</a>
<a name="ln959">  unsigned int i, j, nt, n1, n2;//,n3, nfrag;</a>
<a name="ln960">  bool test;</a>
<a name="ln961">  OBAtom sa;</a>
<a name="ln962">  string mf=&quot;&quot;;</a>
<a name="ln963">  string s=&quot;&quot;;</a>
<a name="ln964">  string temp=&quot;&quot;;</a>
<a name="ln965">  string ss=&quot;&quot;;</a>
<a name="ln966">  string sstore=&quot;&quot;;</a>
<a name="ln967">  int m,n,k;</a>
<a name="ln968">  std::vector &lt;int&gt; nHydr(MAXFRAGS);</a>
<a name="ln969">  string astereo=&quot;&quot;;</a>
<a name="ln970">  string bstereo=&quot;&quot;;</a>
<a name="ln971">  string chargestring=&quot;&quot;;</a>
<a name="ln972">  string radicalstring=&quot;&quot;;</a>
<a name="ln973">  int nPrev;</a>
<a name="ln974">  string sa1=&quot;&quot;;</a>
<a name="ln975">  string sa2=&quot;&quot;;</a>
<a name="ln976">  string sF=&quot;&quot;;</a>
<a name="ln977">  std::vector &lt;int&gt; charges(MAXFRAGS);</a>
<a name="ln978">  std::vector &lt;int&gt; radicals(MAXFRAGS);</a>
<a name="ln979">  std::vector &lt;int&gt; fragIndex(MAXFRAGS);</a>
<a name="ln980">  std::vector &lt;int&gt; sbSpecial(MAXBONDS);</a>
<a name="ln981">  std::vector &lt;int&gt; enumber(NELEMMAX);  //number of elements...</a>
<a name="ln982">  std::vector &lt;int&gt; bondOrders(MAXBONDS);</a>
<a name="ln983">  std::vector &lt;double&gt; rx(MAXFRAGS);</a>
<a name="ln984">  std::vector &lt;double&gt; ry(MAXFRAGS);</a>
<a name="ln985">  std::vector &lt;string&gt; names(MAXFRAGS);</a>
<a name="ln986">  int netcharge=0;</a>
<a name="ln987">  int netradical=0;</a>
<a name="ln988">  unsigned int nelements=0;</a>
<a name="ln989">  int kk;</a>
<a name="ln990">  string value=&quot;&quot;;</a>
<a name="ln991">  unsigned int acount, bcount, flags;</a>
<a name="ln992"> </a>
<a name="ln993">  std::vector &lt;int&gt; iA1(MAXBONDS);</a>
<a name="ln994">  std::vector &lt;int&gt; iA2(MAXBONDS);</a>
<a name="ln995">  std::vector &lt;int&gt; aPosition(MAXFRAGS);</a>
<a name="ln996">  std::vector &lt;int&gt; aCharge(MAXFRAGS);</a>
<a name="ln997">  std::vector &lt;int&gt; aRad(MAXFRAGS);</a>
<a name="ln998">  std::vector &lt;int&gt; stereoBonds(MAXBONDS);</a>
<a name="ln999"> </a>
<a name="ln1000">  value=lineToParse;</a>
<a name="ln1001">  sout=&quot;&quot;;</a>
<a name="ln1002"> </a>
<a name="ln1003">  if ((indexOf(value,fablockstart) &gt;= 0) &amp;&amp; (indexOf(value,fbblockstart) &gt; 0)) {</a>
<a name="ln1004">    restoreFullMCDL(value,pmol);</a>
<a name="ln1005">    return;</a>
<a name="ln1006">  };</a>
<a name="ln1007">  for (i=0; i&lt;MAXBONDS; i++) {</a>
<a name="ln1008">    stereoBonds[i]=0;</a>
<a name="ln1009">    sbSpecial[i]=0;</a>
<a name="ln1010">    iA1[i]=0;</a>
<a name="ln1011">    iA2[i]=0;</a>
<a name="ln1012">  };</a>
<a name="ln1013"> </a>
<a name="ln1014">  for (i=0; i&lt;MAXFRAGS; i++) {</a>
<a name="ln1015">    charges[i]=0;</a>
<a name="ln1016">    radicals[i]=0;</a>
<a name="ln1017">    fragIndex[i]=0;</a>
<a name="ln1018">    //special[i]=0;</a>
<a name="ln1019">    nHydr[i]=0;</a>
<a name="ln1020">    names[i]=&quot;&quot;;</a>
<a name="ln1021">    aPosition[i]=6;</a>
<a name="ln1022">    aCharge[i]=0;</a>
<a name="ln1023">    aRad[i]=0;</a>
<a name="ln1024">  };</a>
<a name="ln1025">  //removing net charges and radiacal</a>
<a name="ln1026">  test=false;</a>
<a name="ln1027">  n=1;</a>
<a name="ln1028">  while ((value.length() &gt; 0) &amp;&amp; (value.at(0) &gt;= '0') &amp;&amp; (value.at(0) &lt;= '9') &amp;&amp; (! test) &amp;&amp; (n&gt;0)) {</a>
<a name="ln1029">    n=indexOf(value,&quot;;&quot;);</a>
<a name="ln1030">    if (n&gt;0) {</a>
<a name="ln1031">      s=value.substr(0,n);</a>
<a name="ln1032">      n1=indexOf(s,&quot;+&quot;);</a>
<a name="ln1033">      if (n1 &lt; 0) n1=indexOf(s,&quot;-&quot;);</a>
<a name="ln1034">      if (n1 &lt; 0) n1=indexOf(s,&quot;*&quot;);</a>
<a name="ln1035">      if (n1 &lt; 0) {</a>
<a name="ln1036">        n=0;</a>
<a name="ln1037">        test=true;</a>
<a name="ln1038">      };</a>
<a name="ln1039">    };</a>
<a name="ln1040">    if (n &gt; 0) {</a>
<a name="ln1041">      s=value.substr(0,n);</a>
<a name="ln1042">      if ((s.at(s.length()-1) == '+') || (s.at(s.length()-1) == '-')) {</a>
<a name="ln1043">        //total charge processing</a>
<a name="ln1044">        if (s.at(s.length()-1) == '+') netcharge=1; else netcharge=-1;</a>
<a name="ln1045">        s=s.substr(0,s.length()-1);</a>
<a name="ln1046">        n1=atoi(s.c_str());</a>
<a name="ln1047">        netcharge=netcharge*n1;</a>
<a name="ln1048">      } else if (s.at(s.length()-1) == '*') {</a>
<a name="ln1049">        //radical processing</a>
<a name="ln1050">        s=s.substr(0,s.length()-1);</a>
<a name="ln1051">        n1=atoi(s.c_str());</a>
<a name="ln1052">        netradical=n1;</a>
<a name="ln1053">      };</a>
<a name="ln1054">      value=value.substr(n+1,value.length());</a>
<a name="ln1055">      if (value.length() &gt; 0) if (value.at(0) == ';'){</a>
<a name="ln1056">        value=value.substr(1);</a>
<a name="ln1057">      };</a>
<a name="ln1058">    };</a>
<a name="ln1059">  };</a>
<a name="ln1060"> </a>
<a name="ln1061">  //stereo string extraction</a>
<a name="ln1062"> </a>
<a name="ln1063">  n1=indexOf(value,fsastart);</a>
<a name="ln1064">  if (n1&gt;=0) {</a>
<a name="ln1065">    n2=indexOf(value,&quot;}&quot;,n1);</a>
<a name="ln1066">    if (n2&gt;0) {</a>
<a name="ln1067">      astereo=&quot;&quot;+value.substr(n1+fsastart.length(),n2);</a>
<a name="ln1068">      value=value.substr(0,n1)+value.substr(n2+1);</a>
<a name="ln1069">    }</a>
<a name="ln1070">  };</a>
<a name="ln1071">  n1=indexOf(value,fsbstart);</a>
<a name="ln1072">  if (n1&gt;=0) {</a>
<a name="ln1073">    n2=indexOf(value,&quot;}&quot;,n1);</a>
<a name="ln1074">    if (n2&gt;0) {</a>
<a name="ln1075">      bstereo=&quot;&quot;+value.substr(n1+fsbstart.length(),n2);</a>
<a name="ln1076">      value=value.substr(0,n1)+value.substr(n2+1);</a>
<a name="ln1077">    }</a>
<a name="ln1078">  };</a>
<a name="ln1079">  //charges processing</a>
<a name="ln1080">  n1=indexOf(value,fchstart);</a>
<a name="ln1081">  if (n1&gt;=0) {</a>
<a name="ln1082">    n2=indexOf(value,&quot;}&quot;,n1);</a>
<a name="ln1083">    if (n2&gt;0) {</a>
<a name="ln1084">      chargestring=&quot;&quot;+value.substr(n1+fchstart.length(),n2);</a>
<a name="ln1085">      value=value.substr(0,n1)+value.substr(n2+1);</a>
<a name="ln1086">    };</a>
<a name="ln1087">  };</a>
<a name="ln1088">  if ((netcharge != 0) &amp;&amp; (chargestring == &quot;&quot;)) {</a>
<a name="ln1089">    chargestring = &quot;1,&quot; +intToStr(abs(netcharge));</a>
<a name="ln1090">    if (netcharge &lt; 0) chargestring=chargestring+&quot;-&quot;; else chargestring=chargestring+&quot;+&quot;;</a>
<a name="ln1091">  };</a>
<a name="ln1092">  //radical processing</a>
<a name="ln1093">  n1=indexOf(value,fradstart);</a>
<a name="ln1094">  if (n1&gt;=0) {</a>
<a name="ln1095">    n2=indexOf(value,&quot;}&quot;,n1);</a>
<a name="ln1096">    if (n2&gt;0) {</a>
<a name="ln1097">      radicalstring=&quot;&quot;+value.substr(n1+fradstart.length(),n2);</a>
<a name="ln1098">      value=value.substr(0,n1)+value.substr(n2+1);</a>
<a name="ln1099">    };</a>
<a name="ln1100">  };</a>
<a name="ln1101">  if ((netradical != 0) &amp;&amp; (radicalstring == &quot;&quot;)) {</a>
<a name="ln1102">    radicalstring= &quot;1,&quot; + intToStr(abs(netcharge)) + &quot;*&quot;;</a>
<a name="ln1103">  };</a>
<a name="ln1104"> </a>
<a name="ln1105">  n1=indexOf(value,&quot;]&quot;);</a>
<a name="ln1106">  if (n1 &gt; 0) {</a>
<a name="ln1107">    value=value.substr(0,n1);  //by unknown reason it was n1-1</a>
<a name="ln1108">  };</a>
<a name="ln1109"> </a>
<a name="ln1110">  //Atom array analizing</a>
<a name="ln1111">  test=true;</a>
<a name="ln1112">  nt=0;</a>
<a name="ln1113">  nelements=0;</a>
<a name="ln1114"> </a>
<a name="ln1115"> </a>
<a name="ln1116">  while (test) {</a>
<a name="ln1117">    n1=indexOf(value,&quot;;&quot;);</a>
<a name="ln1118">    n2=indexOf(value,&quot;[&quot;);</a>
<a name="ln1119"> </a>
<a name="ln1120">    if (n1&lt;0) {</a>
<a name="ln1121">      n1=n2;</a>
<a name="ln1122">    } else {</a>
<a name="ln1123">      if ((n2&lt;n1) &amp;&amp; (n2&gt;=0)) n1=n2;</a>
<a name="ln1124">    };</a>
<a name="ln1125">    mf=value.substr(0,n1);</a>
<a name="ln1126">    value=value.substr(n1,value.length());</a>
<a name="ln1127">    if (value.at(0)==';') value=value.substr(1,value.length());</a>
<a name="ln1128">    n1=1;</a>
<a name="ln1129">    if ((mf.at(0)&gt;='0') &amp;&amp; (mf.at(0)&lt;='9')) {</a>
<a name="ln1130">      test=true;</a>
<a name="ln1131">      temp=&quot;&quot;;</a>
<a name="ln1132">      while (test) {</a>
<a name="ln1133">        temp=temp+mf.at(0);</a>
<a name="ln1134">        mf=mf.substr(1,mf.length());</a>
<a name="ln1135">        test=(mf.at(0)&gt;='0') &amp;&amp; (mf.at(0)&lt;='9');</a>
<a name="ln1136">      };</a>
<a name="ln1137">      n1=atoi(temp.c_str());</a>
<a name="ln1138">    };</a>
<a name="ln1139">    //do not change n1==nFrag!!!</a>
<a name="ln1140">    nt=nt+n1;</a>
<a name="ln1141">  //Conversion of XxHHHH to XxHn</a>
<a name="ln1142">    n2=lastIndexOf(mf,&quot;HH&quot;);</a>
<a name="ln1143">    while (n2&gt;0) {</a>
<a name="ln1144">      if (n2&lt;(mf.length()-2)) {</a>
<a name="ln1145">        ss=mf.substr(mf.length()-1,mf.length());</a>
<a name="ln1146">        k=atoi(ss.c_str())+1;//Integer.parseInt(ss)+1;</a>
<a name="ln1147">      } else k=2;</a>
<a name="ln1148">      mf=mf.substr(0,n2+1)+intToStr(k);</a>
<a name="ln1149">      n2=lastIndexOf(mf,&quot;HH&quot;);</a>
<a name="ln1150">    };</a>
<a name="ln1151">    //passed to this point...</a>
<a name="ln1152">    //End convsrsion</a>
<a name="ln1153">    n2=indexOf(mf,&quot;H&quot;);</a>
<a name="ln1154">    temp=&quot;0&quot;;</a>
<a name="ln1155">    if (n2&gt;0)  {</a>
<a name="ln1156">      if (n2&lt;(mf.length()-1)) {</a>
<a name="ln1157">        temp=mf.substr(n2+1,mf.length());</a>
<a name="ln1158">      } else temp=&quot;1&quot;;</a>
<a name="ln1159">      mf=mf.substr(0,n2);</a>
<a name="ln1160">    };</a>
<a name="ln1161">    n2=atoi(temp.c_str());//Integer.parseInt(temp);</a>
<a name="ln1162">    //do not change n2 - number of hydrogens...</a>
<a name="ln1163"> </a>
<a name="ln1164">    nH[nelements]=n2;</a>
<a name="ln1165">    nF[nelements]=n1;</a>
<a name="ln1166">    names[nelements]=mf;</a>
<a name="ln1167">    nelements++;</a>
<a name="ln1168"> </a>
<a name="ln1169">    test=value.at(0) != '[';</a>
<a name="ln1170">  };</a>
<a name="ln1171"> </a>
<a name="ln1172">  sa.Clear();</a>
<a name="ln1173"> </a>
<a name="ln1174">  acount=nt;</a>
<a name="ln1175"> </a>
<a name="ln1176">  //parsing and analizing...</a>
<a name="ln1177">  for (i=0; i&lt;MAXFRAGS; i++) charges[i]=0;</a>
<a name="ln1178">  if (chargestring != &quot;&quot;) while (chargestring.length() &gt; 0) {</a>
<a name="ln1179">    n1=indexOf(chargestring,&quot;;&quot;);</a>
<a name="ln1180">    if (n1&gt;0) {</a>
<a name="ln1181">      s=chargestring.substr(0,n1);</a>
<a name="ln1182">      chargestring=chargestring.substr(n1+1);</a>
<a name="ln1183">    } else {</a>
<a name="ln1184">      s=chargestring;</a>
<a name="ln1185">      chargestring=&quot;&quot;;</a>
<a name="ln1186">    };</a>
<a name="ln1187">    n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln1188">    if (n1 &gt; 0) {</a>
<a name="ln1189">      sa1=s.substr(0,n1);</a>
<a name="ln1190">      s=s.substr(n1+1);</a>
<a name="ln1191">      n2=1;</a>
<a name="ln1192">      if (indexOf(s,&quot;-&quot;) &gt; 0) n2=-1;</a>
<a name="ln1193">      s=s.substr(0,s.length()-1);</a>
<a name="ln1194">      n1=atoi(s.c_str());</a>
<a name="ln1195">      n1=n1*n2;</a>
<a name="ln1196">      n2=atoi(sa1.c_str());</a>
<a name="ln1197">      charges[n2-1]=n1;</a>
<a name="ln1198">    };</a>
<a name="ln1199">  };</a>
<a name="ln1200">  for (i=0; i&lt;MAXFRAGS; i++) radicals[i]=0;</a>
<a name="ln1201">  if (radicalstring != &quot;&quot;) while (radicalstring.length() &gt; 0) {</a>
<a name="ln1202">    n1=indexOf(radicalstring,&quot;;&quot;);</a>
<a name="ln1203">    if (n1&gt;0) {</a>
<a name="ln1204">      s=radicalstring.substr(0,n1);</a>
<a name="ln1205">      radicalstring=radicalstring.substr(n1+1);</a>
<a name="ln1206">    } else {</a>
<a name="ln1207">      s=radicalstring;</a>
<a name="ln1208">      radicalstring=&quot;&quot;;</a>
<a name="ln1209">    };</a>
<a name="ln1210">    n1=indexOf(s,&quot;,&quot;);</a>
<a name="ln1211">    if (n1 &gt; 0) {</a>
<a name="ln1212">      sa1=s.substr(0,n1);</a>
<a name="ln1213">      s=s.substr(n1+1);</a>
<a name="ln1214">      n2=1;</a>
<a name="ln1215">      if (indexOf(s,&quot;-&quot;) &gt; 0) n2=-1;</a>
<a name="ln1216">      s=s.substr(0,s.length()-1);</a>
<a name="ln1217">      n2=atoi(sa1.c_str());</a>
<a name="ln1218">      radicals[n2-1]=1;</a>
<a name="ln1219">    };</a>
<a name="ln1220">  };</a>
<a name="ln1221">//passed</a>
<a name="ln1222"> </a>
<a name="ln1223"> </a>
<a name="ln1224"> </a>
<a name="ln1225">  nt=0;</a>
<a name="ln1226">  ss=&quot;&quot;;</a>
<a name="ln1227">  bcount=0;</a>
<a name="ln1228"> </a>
<a name="ln1229">  for (i=0; i&lt;nelements; i++) {</a>
<a name="ln1230">    s=names[i];</a>
<a name="ln1231">    n1=1;</a>
<a name="ln1232">    if (s.length()&gt;1) if ((s.at(1)&gt;='a') &amp;&amp; (s.at(1)&lt;='z')) n1=2;</a>
<a name="ln1233">    temp=s.substr(0,n1);</a>
<a name="ln1234">    if (n1&lt;s.length()) sstore=s.substr(n1,s.length()); else sstore=&quot;&quot;;</a>
<a name="ln1235">    n1=nF[i];</a>
<a name="ln1236">    n2=OBElements::GetAtomicNum(temp.c_str());//Atom.positionofAtom(temp);</a>
<a name="ln1237">    nPrev=acount;</a>
<a name="ln1238"> </a>
<a name="ln1239">    for (j=1; j&lt;=n1; j++) {</a>
<a name="ln1240">      fragIndex[nt]=nt+1;//sa.fragIndex=fragNo;</a>
<a name="ln1241">      nHydr[nt]=nH[i];      //sa.special=(byte)nH.getValue(i+1);</a>
<a name="ln1242">      nt++;</a>
<a name="ln1243"> </a>
<a name="ln1244">      aPosition[nt-1]=n2;</a>
<a name="ln1245"> </a>
<a name="ln1246">      if (sstore.length()&gt;0) if (parseFormula(sstore,enumber)) { //bf=Formula.parseString(sstore);</a>
<a name="ln1247">        for (k=1; k&lt;NELEMMAX; k++) if (enumber[k] &gt; 0) for (m=1; m&lt;=enumber[k]; m++) {</a>
<a name="ln1248">          fragIndex[acount]=nt+1;//sa.fragIndex=fragNo;  //Do not increment!</a>
<a name="ln1249">          nHydr[acount]=0;//special[acount]=0;</a>
<a name="ln1250">          aPosition[acount]=k;</a>
<a name="ln1251">          acount++;</a>
<a name="ln1252"> </a>
<a name="ln1253">          kk=hydrogenValency(k);//HVal[k];</a>
<a name="ln1254">          if (kk == 0) kk=1;</a>
<a name="ln1255">          bcount++;</a>
<a name="ln1256">          sbSpecial[bcount-1]=1;</a>
<a name="ln1257">          bondOrders[bcount-1]=kk;</a>
<a name="ln1258">          iA1[bcount-1]=nt-1;</a>
<a name="ln1259">          iA2[bcount-1]=acount-1;</a>
<a name="ln1260">        };</a>
<a name="ln1261">        //checking for nitrogen...</a>
<a name="ln1262">        //length analizing-extracting and addition of other atoms...</a>
<a name="ln1263">      };</a>
<a name="ln1264">      //charges analizing and restore</a>
<a name="ln1265"> </a>
<a name="ln1266">    if (charges[nt-1] != 0) {      //search for appropriate atom to put charge..</a>
<a name="ln1267">    if (nPrev == acount) {</a>
<a name="ln1268">      aCharge[nt-1]=charges[nt-1];</a>
<a name="ln1269">    } else  {</a>
<a name="ln1270">      if (charges[nt-1] &lt; 0) {</a>
<a name="ln1271">        assignCharges(aPosition,iA1,iA2,aCharge,charges,bondOrders,8,nPrev,nt,acount,bcount);</a>
<a name="ln1272">        assignCharges(aPosition,iA1,iA2,aCharge,charges,bondOrders,7,nPrev,nt,acount,bcount);</a>
<a name="ln1273">        assignCharges(aPosition,iA1,iA2,aCharge,charges,bondOrders,16,nPrev,nt,acount,bcount);</a>
<a name="ln1274">        if (charges[nt-1] != 0) {</a>
<a name="ln1275">          aCharge[nt-1]=charges[nt-1];</a>
<a name="ln1276">        };</a>
<a name="ln1277">      } else {  //positive charge-at central atom</a>
<a name="ln1278">        aCharge[nt-1]=charges[nt-1];</a>
<a name="ln1279">      };</a>
<a name="ln1280">    };</a>
<a name="ln1281">  };</a>
<a name="ln1282">  if (radicals[nt-1] != 0) {      //search for appropriate atom to put charge..</a>
<a name="ln1283">    aRad[nt-1]=radicals[nt-1];</a>
<a name="ln1284">  };</a>
<a name="ln1285">  nPrev=acount;</a>
<a name="ln1286">};</a>
<a name="ln1287"> </a>
<a name="ln1288">  };</a>
<a name="ln1289"> </a>
<a name="ln1290">  //Bond analizing....</a>
<a name="ln1291">  value=value.substr(1,value.length());</a>
<a name="ln1292"> </a>
<a name="ln1293">  nt=0;</a>
<a name="ln1294">  ss=&quot;&quot;;</a>
<a name="ln1295">  test=true;</a>
<a name="ln1296">  while ((value.length()&gt;0) &amp;&amp; test) {</a>
<a name="ln1297">    n1=indexOf(value,&quot;;&quot;);</a>
<a name="ln1298">    n2=indexOf(value,&quot;]&quot;);</a>
<a name="ln1299">    if (n1&lt;0) n1=n2; else if ((n2&lt;n1) &amp;&amp; (n2&gt;=0)) n1=n2;</a>
<a name="ln1300">    mf=&quot;&quot;;</a>
<a name="ln1301">    if ((n1&gt;=0) &amp;&amp; (value.length() &gt; n1)) {</a>
<a name="ln1302">      mf=value.substr(0,n1);</a>
<a name="ln1303">      value=value.substr(n1+1,value.length());</a>
<a name="ln1304">    } else {</a>
<a name="ln1305">      test=false;</a>
<a name="ln1306">      mf=value;</a>
<a name="ln1307">      value=&quot;&quot;;</a>
<a name="ln1308">    };</a>
<a name="ln1309">    nt++;</a>
<a name="ln1310">    //parsing each fragment</a>
<a name="ln1311">    while (mf.length()&gt;0) {</a>
<a name="ln1312">      n1=indexOf(mf,&quot;,&quot;);</a>
<a name="ln1313">      if (n1&gt;=0) {</a>
<a name="ln1314">        s=mf.substr(0,n1);</a>
<a name="ln1315">        mf=mf.substr(n1+1,mf.length());</a>
<a name="ln1316">      } else {</a>
<a name="ln1317">        s=mf;</a>
<a name="ln1318">        mf=&quot;&quot;;</a>
<a name="ln1319">      };</a>
<a name="ln1320">      n1=atoi(s.c_str());</a>
<a name="ln1321">      bcount++;</a>
<a name="ln1322">      bondOrders[bcount-1]=0;</a>
<a name="ln1323">      iA1[bcount-1]=nt-1;</a>
<a name="ln1324">      iA2[bcount-1]=n1-1;</a>
<a name="ln1325">    };</a>
<a name="ln1326"> </a>
<a name="ln1327">    if (value.length()&gt;0) if (value.at(0)==']') value=&quot;&quot;; //end parsing</a>
<a name="ln1328">  };</a>
<a name="ln1329"> </a>
<a name="ln1330">  //Alternation</a>
<a name="ln1331">  alternate(aPosition,aCharge,aRad,nHydr,iA1,iA2,bondOrders,acount,bcount);</a>
<a name="ln1332">  generateDiagram(iA1,iA2,rx,ry,acount,bcount);</a>
<a name="ln1333">  for (i=0; i&lt;bcount; i++) if (bondOrders[i] == 1) stereoBonds[i]=-1; //flags for bonds, which might be stereo</a>
<a name="ln1334">  implementAtomStereo(iA1,iA2,stereoBonds,rx,ry,acount,bcount,astereo);</a>
<a name="ln1335">  implementBondStereo(iA1,iA2,rx,ry,acount,bcount,bstereo);</a>
<a name="ln1336"> </a>
<a name="ln1337"> </a>
<a name="ln1338">  if (pmol != nullptr) {</a>
<a name="ln1339">    for (i=0; i&lt;acount; i++) {</a>
<a name="ln1340">      sa.Clear();</a>
<a name="ln1341">      sa.SetAtomicNum(aPosition[i]);</a>
<a name="ln1342">      if (aCharge[i] != 0) sa.SetFormalCharge(aCharge[i]);</a>
<a name="ln1343">      if (aRad[i] != 0) sa.SetSpinMultiplicity(1);</a>
<a name="ln1344">      sa.SetVector(rx[i],ry[i],0.0);</a>
<a name="ln1345">      pmol-&gt;AddAtom(sa);</a>
<a name="ln1346">    };</a>
<a name="ln1347">    for (i=0; i&lt;bcount; i++) {</a>
<a name="ln1348">      flags=0;</a>
<a name="ln1349">      if (stereoBonds[i] == 1) flags=OB_WEDGE_BOND; else</a>
<a name="ln1350">      if (stereoBonds[i] == 2) flags=OB_HASH_BOND;</a>
<a name="ln1351">      pmol-&gt;AddBond(iA1[i]+1,iA2[i]+1,bondOrders[i],flags);</a>
<a name="ln1352">    };</a>
<a name="ln1353">  };</a>
<a name="ln1354">};</a>
<a name="ln1355"> </a>
<a name="ln1356">  void MCDLFormat::assignCharges(const std::vector &lt;int&gt; aPosition, const std::vector &lt;int&gt; iA1,</a>
<a name="ln1357">  const std::vector &lt;int&gt; iA2, std::vector &lt;int&gt;&amp; aCharges, std::vector &lt;int&gt;&amp; charges,</a>
<a name="ln1358">  std::vector &lt;int&gt;&amp; bondOrder, int aPos, int nPrev, int nt, int acount, int bcount){</a>
<a name="ln1359">  //set negative charges</a>
<a name="ln1360">    int k,j,n;</a>
<a name="ln1361"> </a>
<a name="ln1362">  //return;</a>
<a name="ln1363"> </a>
<a name="ln1364">  for (k=nPrev; k&lt;acount; k++) {</a>
<a name="ln1365">    if (aPosition[k] == aPos) {</a>
<a name="ln1366">        aCharges[k]=-1;</a>
<a name="ln1367">        charges[nt-1]=charges[nt-1]+1;</a>
<a name="ln1368">    for (j=0; j&lt;bcount; j++) {</a>
<a name="ln1369">      if ((((iA1[j]+1) == nt) &amp;&amp; (iA2[j] == k)) || ((iA1[j] == k) &amp;&amp; ((iA2[j]+1) == nt))) {</a>
<a name="ln1370">      n=bondOrder[j];</a>
<a name="ln1371">            if (n &gt; 1) {</a>
<a name="ln1372">              n=n-1;</a>
<a name="ln1373">        bondOrder[j]=n;</a>
<a name="ln1374">          };</a>
<a name="ln1375">          };</a>
<a name="ln1376">        };</a>
<a name="ln1377">    };</a>
<a name="ln1378">      if (charges[nt-1] == 0) break;</a>
<a name="ln1379">    };</a>
<a name="ln1380">  };</a>
<a name="ln1381"> </a>
<a name="ln1382"> </a>
<a name="ln1383">  int MCDLFormat::indexOf(const string instring, const string substring, int fromPos) {</a>
<a name="ln1384">    int result=instring.find(substring,fromPos);</a>
<a name="ln1385">    if (result == string::npos) result=-1;</a>
<a name="ln1386">    if (result &gt;= instring.length()) result=-1;</a>
<a name="ln1387">      return result;</a>
<a name="ln1388">  };</a>
<a name="ln1389"> </a>
<a name="ln1390">  int MCDLFormat::lastIndexOf(const string instring, const string substring) {</a>
<a name="ln1391">    int result,n;</a>
<a name="ln1392">  bool test;</a>
<a name="ln1393"> </a>
<a name="ln1394">  result=-1;</a>
<a name="ln1395">  test=true;</a>
<a name="ln1396">  n=-1;</a>
<a name="ln1397">  while (test) {</a>
<a name="ln1398">    n=instring.find(substring,n+1);</a>
<a name="ln1399">    if (n == string::npos)</a>
<a name="ln1400">      test=false;</a>
<a name="ln1401">    else {</a>
<a name="ln1402">        result=n;</a>
<a name="ln1403">    };</a>
<a name="ln1404">  };</a>
<a name="ln1405">    //int result=instring.find_last_of(substring);</a>
<a name="ln1406">    //if  (result == string::npos) result=-1;</a>
<a name="ln1407">    //if  (result &gt; (instring.length()-substring.length())) result=-1;</a>
<a name="ln1408">    return result;</a>
<a name="ln1409">  };</a>
<a name="ln1410"> </a>
<a name="ln1411">bool MCDLFormat::parseFormula(const string formulaString, std::vector &lt;int&gt;&amp; enumber) {</a>
<a name="ln1412">  //vector&lt;string&gt; items;</a>
<a name="ln1413">  unsigned int i, n, k, n1, n2;//,j,nStart;</a>
<a name="ln1414">  string s;</a>
<a name="ln1415">  bool test;</a>
<a name="ln1416">  string asym;</a>
<a name="ln1417">  string value=formulaString;</a>
<a name="ln1418"> </a>
<a name="ln1419">  for (i = 0; i&lt;NELEMMCDL; i++) enumber[i] = 0;</a>
<a name="ln1420"> </a>
<a name="ln1421">  for (i = 1; i&lt;NELEMMCDL; i++) if (strlen(OBElements::GetSymbol(i)) == 2) {</a>
<a name="ln1422">      test=true;</a>
<a name="ln1423">    asym=OBElements::GetSymbol(i);</a>
<a name="ln1424">      while (test) {</a>
<a name="ln1425">        test=false;</a>
<a name="ln1426">        n=indexOf(value,asym);</a>
<a name="ln1427">        if (n&gt;=0) {</a>
<a name="ln1428">          test=true;</a>
<a name="ln1429">          value=value.substr(0,n)+value.substr(n+asym.length(),value.length());</a>
<a name="ln1430">          k=1;</a>
<a name="ln1431">          if (n&lt;value.length()) if ((value.at(n)&gt;='0') &amp;&amp; (value.at(n)&lt;='9')) {</a>
<a name="ln1432">            n1=n;</a>
<a name="ln1433">            n2=n;</a>
<a name="ln1434">            while ((n2&lt;(value.length()-1)) &amp;&amp; (value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9')) n2++;</a>
<a name="ln1435">            if (! ((value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9'))) n2--;</a>
<a name="ln1436">            s=value.substr(n1,n2+1);</a>
<a name="ln1437">            k=atoi(s.c_str());</a>
<a name="ln1438">            value=value.substr(0,n1)+value.substr(n2+1,value.length());</a>
<a name="ln1439">          };</a>
<a name="ln1440">          enumber[i]=enumber[i]+k;</a>
<a name="ln1441">        };</a>
<a name="ln1442">      };</a>
<a name="ln1443">    };</a>
<a name="ln1444">  for (i = 1; i&lt;NELEMMCDL; i++) if (strlen(OBElements::GetSymbol(i)) == 1) {</a>
<a name="ln1445">      test=true;</a>
<a name="ln1446">    asym=OBElements::GetSymbol(i);</a>
<a name="ln1447">      while (test) {</a>
<a name="ln1448">        test=false;</a>
<a name="ln1449">        n=indexOf(value,asym);</a>
<a name="ln1450">        if (n&gt;=0) {</a>
<a name="ln1451">          test=true;</a>
<a name="ln1452">          value=value.substr(0,n)+value.substr(n+asym.length(),value.length());</a>
<a name="ln1453">          k=1;</a>
<a name="ln1454">          if (n&lt;value.length()) if ((value.at(n)&gt;='0') &amp;&amp; (value.at(n)&lt;='9')) {</a>
<a name="ln1455">            n1=n;</a>
<a name="ln1456">            n2=n;</a>
<a name="ln1457">            while ((n2&lt;(value.length()-1)) &amp;&amp; (value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9')) n2++;</a>
<a name="ln1458">            if (! ((value.at(n2)&gt;='0') &amp;&amp; (value.at(n2)&lt;='9'))) n2--;</a>
<a name="ln1459">            s=value.substr(n1,n2+1);</a>
<a name="ln1460">      k=atoi(s.c_str());</a>
<a name="ln1461">            value=value.substr(0,n1)+value.substr(n2+1,value.length());</a>
<a name="ln1462">          };</a>
<a name="ln1463">          enumber[i]=enumber[i]+k;</a>
<a name="ln1464">        };</a>
<a name="ln1465">      };</a>
<a name="ln1466">    };</a>
<a name="ln1467">  return (value.length() == 0);</a>
<a name="ln1468">};</a>
<a name="ln1469"> </a>
<a name="ln1470">  string MCDLFormat::getMolTitle(string &amp; line) {</a>
<a name="ln1471">    string::size_type n,k;</a>
<a name="ln1472">  string result;</a>
<a name="ln1473">  n=line.find(ftitlestart);</a>
<a name="ln1474">  if (n != string::npos) {</a>
<a name="ln1475">    k=line.find(&quot;}&quot;,n+ftitlestart.size());</a>
<a name="ln1476">    if (k != string::npos) {</a>
<a name="ln1477">    result=line.substr(n+ftitlestart.length(),k-n-ftitlestart.length());</a>
<a name="ln1478">    line=line.substr(0,n+1)+line.substr(k+1);</a>
<a name="ln1479">    }</a>
<a name="ln1480">  }</a>
<a name="ln1481">  return result;</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484"> </a>
<a name="ln1485">  ////////////////////////////////////////////////////</a>
<a name="ln1486"> </a>
<a name="ln1487">//Make an instance of the format class</a>
<a name="ln1488">MCDLFormat theMCDLFormat;</a>
<a name="ln1489"> </a>
<a name="ln1490">/////////////////////////////////////////////////////////////////</a>
<a name="ln1491"> </a>
<a name="ln1492">bool MCDLFormat::ReadMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln1493">{</a>
<a name="ln1494">  OBMol* pmol = pOb-&gt;CastAndClear&lt;OBMol&gt;();</a>
<a name="ln1495">  if (pmol == nullptr)</a>
<a name="ln1496">      return false;</a>
<a name="ln1497"> </a>
<a name="ln1498">  istream&amp; ifs = *pConv-&gt;GetInStream();</a>
<a name="ln1499"> </a>
<a name="ln1500">  pmol-&gt;BeginModify();</a>
<a name="ln1501"> </a>
<a name="ln1502">  int dim=0;</a>
<a name="ln1503">  pmol-&gt;SetDimension(dim);</a>
<a name="ln1504"> </a>
<a name="ln1505">  string line=&quot;&quot;;</a>
<a name="ln1506">    if(ifs.good()) getline(ifs, line);</a>
<a name="ln1507"> </a>
<a name="ln1508">  string molTitle=getMolTitle(line);</a>
<a name="ln1509"> </a>
<a name="ln1510">  if (molTitle.length() &gt; 0) pmol-&gt;SetTitle(molTitle.c_str());</a>
<a name="ln1511">  if (line.length() &gt; 0) setMCDL(line,pmol,molTitle);</a>
<a name="ln1512"> </a>
<a name="ln1513">  pmol-&gt;EndModify();</a>
<a name="ln1514"> </a>
<a name="ln1515">  return true;</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">////////////////////////////////////////////////////////////////</a>
<a name="ln1519"> </a>
<a name="ln1520">bool MCDLFormat::WriteMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln1521">{</a>
<a name="ln1522">  OBMol* pmol = dynamic_cast&lt;OBMol*&gt;(pOb);</a>
<a name="ln1523">  if (pmol == nullptr) return false;</a>
<a name="ln1524"> </a>
<a name="ln1525">  std::ostream &amp; ofs = *pConv-&gt;GetOutStream();</a>
<a name="ln1526"> </a>
<a name="ln1527">  //To use an output option</a>
<a name="ln1528">  string title=pmol-&gt;GetTitle();</a>
<a name="ln1529">  if (title.length() &gt; 0) title=ftitlestart+title+&quot;}&quot;;</a>
<a name="ln1530">  ofs &lt;&lt; getMCDL(pmol,false) &lt;&lt; title &lt;&lt; endl;</a>
<a name="ln1531">  // prepareTest(pmol,ofs);</a>
<a name="ln1532">  //generateDiagram(pmol,ofs);</a>
<a name="ln1533"> </a>
<a name="ln1534">  return true; //or false to stop converting</a>
<a name="ln1535">}</a>
<a name="ln1536"> </a>
<a name="ln1537">} //namespace OpenBabel</a>
<a name="ln1538"> </a>

</code></pre>
<div class="balloon" rel="398"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'dupfrag' used.</p></div>
<div class="balloon" rel="797"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="811"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="858"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="556"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'netcharge' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 552, 556.</p></div>
<div class="balloon" rel="1033"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 < 0' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="1034"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 < 0' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="1035"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 < 0' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="1064"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="1072"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="1081"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="1094"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="1120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 < 0' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="1130"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'test' variable was assigned the same value.</p></div>
<div class="balloon" rel="1299"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 < 0' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="1313"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n1 >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="1427"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="1450"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'n >= 0' is always true. Unsigned type value is always >= 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

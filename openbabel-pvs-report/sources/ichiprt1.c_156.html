
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ichiprt1.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * International Chemical Identifier (InChI)</a>
<a name="ln3"> * Version 1</a>
<a name="ln4"> * Software version 1.04</a>
<a name="ln5"> * September 9, 2011</a>
<a name="ln6"> *</a>
<a name="ln7"> * The InChI library and programs are free software developed under the</a>
<a name="ln8"> * auspices of the International Union of Pure and Applied Chemistry (IUPAC).</a>
<a name="ln9"> * Originally developed at NIST. Modifications and additions by IUPAC</a>
<a name="ln10"> * and the InChI Trust.</a>
<a name="ln11"> *</a>
<a name="ln12"> * IUPAC/InChI-Trust Licence for the International Chemical Identifier (InChI)</a>
<a name="ln13"> * Software version 1.0.</a>
<a name="ln14"> * Copyright (C) IUPAC and InChI Trust Limited</a>
<a name="ln15"> *</a>
<a name="ln16"> * This library is free software; you can redistribute it and/or modify it under the</a>
<a name="ln17"> * terms of the IUPAC/InChI Trust Licence for the International Chemical Identifier</a>
<a name="ln18"> * (InChI) Software version 1.0; either version 1.0 of the License, or</a>
<a name="ln19"> * (at your option) any later version.</a>
<a name="ln20"> *</a>
<a name="ln21"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln22"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln23"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</a>
<a name="ln24"> * See the IUPAC/InChI Trust Licence for the International Chemical Identifier (InChI)</a>
<a name="ln25"> * Software version 1.0 for more details.</a>
<a name="ln26"> *</a>
<a name="ln27"> * You should have received a copy of the IUPAC/InChI Trust Licence for the</a>
<a name="ln28"> * International Chemical Identifier (InChI) Software version 1.0 along with</a>
<a name="ln29"> * this library; if not, write to:</a>
<a name="ln30"> *</a>
<a name="ln31"> * The InChI Trust</a>
<a name="ln32"> * c/o FIZ CHEMIE Berlin</a>
<a name="ln33"> * Franklinstrasse 11</a>
<a name="ln34"> * 10587 Berlin</a>
<a name="ln35"> * GERMANY</a>
<a name="ln36"> *</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44">#include &lt;math.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;mode.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#include &quot;inpdef.h&quot;</a>
<a name="ln49">#include &quot;ichi.h&quot;</a>
<a name="ln50">#include &quot;strutil.h&quot;</a>
<a name="ln51">#include &quot;util.h&quot;</a>
<a name="ln52">#include &quot;extr_ct.h&quot;</a>
<a name="ln53">#include &quot;ichitaut.h&quot;</a>
<a name="ln54">#include &quot;ichinorm.h&quot;</a>
<a name="ln55">#include &quot;ichicant.h&quot;</a>
<a name="ln56">#include &quot;ichicano.h&quot;</a>
<a name="ln57">#include &quot;ichicomn.h&quot;</a>
<a name="ln58">#include &quot;ichister.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;ichicomp.h&quot;</a>
<a name="ln61">#include &quot;ichimain.h&quot;</a>
<a name="ln62">#include &quot;ichimake.h&quot;</a>
<a name="ln63"> </a>
<a name="ln64">#include &quot;ichi_io.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">int PrintXmlStartTag(char *pStr,</a>
<a name="ln67">                     int indent, int bEnd, const char *tag,</a>
<a name="ln68">                     const char *l1, int v1, const char *l2, int v2,</a>
<a name="ln69">                     const char *l3, int v3, const char *l4, int v4,</a>
<a name="ln70">                     const char *l5, int v5, const char *l6, int v6);</a>
<a name="ln71">int Needs2addXmlEntityRefs(const char *s );</a>
<a name="ln72">int AddXmlEntityRefs(const char *p, char *d );</a>
<a name="ln73">#if ( TEST_RENUMB_ATOMS == 1 ) /*  { */</a>
<a name="ln74">int CompareStereoINChI( INChI_Stereo *s1, INChI_Stereo *s2 );</a>
<a name="ln75">#endif</a>
<a name="ln76"> </a>
<a name="ln77">int str_LineStart(const char *tag, char *tag2, int val2, char *pStr, int ind );</a>
<a name="ln78">int str_LineEnd(const char *tag, int tot_len, int nStrLen,</a>
<a name="ln79">                int *bOverflow, char *pStr, int ind, int bPlainTextTags );</a>
<a name="ln80">int CleanOrigCoord(MOL_COORD szCoord, int delim );</a>
<a name="ln81">int WriteOrigCoord(int num_inp_atoms, MOL_COORD *szMolCoord, int *i,</a>
<a name="ln82">                   char *szBuf, int buf_len);</a>
<a name="ln83">int WriteOrigAtoms(int num_inp_atoms, inp_ATOM *at, int *i,</a>
<a name="ln84">                   char *szBuf, int buf_len,</a>
<a name="ln85">                   STRUCT_DATA *sd);</a>
<a name="ln86">int WriteOrigBonds(int num_inp_atoms, inp_ATOM *at, int *i,</a>
<a name="ln87">                   char *szBuf, int buf_len,</a>
<a name="ln88">                   STRUCT_DATA *sd);</a>
<a name="ln89"> </a>
<a name="ln90">void GetSaveOptLetters(unsigned char save_opt_bits, char* let1, char* let2);</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">char VER_STRING[64];</a>
<a name="ln94"> </a>
<a name="ln95">const char sCompDelim[]       = &quot;;&quot;; /* component delimiter */</a>
<a name="ln96">const char sIdenticalValues[] = &quot;*&quot;; /* identical component */</a>
<a name="ln97">const char x_space[]          = &quot;                  &quot;;</a>
<a name="ln98"> </a>
<a name="ln99">/* xml output: words &amp; additional tags */</a>
<a name="ln100">const char x_inchi[]          = INCHI_NAME;</a>
<a name="ln101">const char x_inchi_ver[]      = &quot;version&quot;; /* &quot;InChI.version&quot;; */</a>
<a name="ln102">const char x_curr_ver[]       = INCHI_VERSION;</a>
<a name="ln103"> </a>
<a name="ln104">const char x_structure[]      = &quot;structure&quot;;</a>
<a name="ln105">const char x_number[]         = &quot;number&quot;;</a>
<a name="ln106">const char x_header[]         = &quot;id.name&quot;;</a>
<a name="ln107">const char x_value[]          = &quot;id.value&quot;;</a>
<a name="ln108"> </a>
<a name="ln109">const char x_empty[]          = &quot;&quot;;</a>
<a name="ln110"> </a>
<a name="ln111">const char x_type[]           = &quot;type&quot;;</a>
<a name="ln112"> </a>
<a name="ln113">const char x_message[]        = &quot;message&quot;;</a>
<a name="ln114">const char x_text[]           = &quot;value&quot;;</a>
<a name="ln115"> </a>
<a name="ln116">const char x_ferr[]           = &quot;fatal (aborted)&quot;;</a>
<a name="ln117">const char x_err[]            = &quot;error (no InChI)&quot;;</a>
<a name="ln118">const char x_warn[]           = &quot;warning&quot;;</a>
<a name="ln119"> </a>
<a name="ln120">const char x_basic[]          = &quot;identifier&quot;;</a>
<a name="ln121">const char x_tautomeric[]     = &quot;mobile-H&quot;;</a>
<a name="ln122">const char x_reconnected[]    = &quot;reconnected&quot;;</a>
<a name="ln123"> </a>
<a name="ln124">const char x_ver[]            = &quot;version&quot;;</a>
<a name="ln125"> </a>
<a name="ln126">const char x_type_alpha[]     = &quot;alpha&quot;;</a>
<a name="ln127">const char x_type_numer[]     = &quot;numeric&quot;;</a>
<a name="ln128">const char x_type_predec[]    = &quot;sct&quot;;</a>
<a name="ln129">const char x_type_normal[]    = &quot;normal&quot;;</a>
<a name="ln130">const char x_type_short[]     = &quot;compressed&quot;;</a>
<a name="ln131">const char x_basic_layer[]    = &quot;basic&quot;;</a>
<a name="ln132"> </a>
<a name="ln133">const char x_aux_basic[]      = &quot;identifier.auxiliary-info&quot;;</a>
<a name="ln134">const char x_aux_comm[]       = &quot;!-- This section is NOT a part of the identifier, it is not unique --&quot;;</a>
<a name="ln135"> </a>
<a name="ln136">const char x_ign_uu_sp2[]     = &quot;omit_undef_dbond&quot;;</a>
<a name="ln137">const char x_ign_uu_sp3[]     = &quot;omit_undef_sp3&quot;;</a>
<a name="ln138"> </a>
<a name="ln139">const char x_line_opening[]   = &quot;&lt;&quot;;</a>
<a name="ln140">const char x_line_closing[]   = &quot;&lt;/&quot;;</a>
<a name="ln141">const char x_close_line[]     = &quot;&gt;&quot;;</a>
<a name="ln142"> </a>
<a name="ln143">const char x_abs[]            = &quot;1&quot;;</a>
<a name="ln144">const char x_rel[]            = &quot;2&quot;;</a>
<a name="ln145">const char x_rac[]            = &quot;3&quot;;</a>
<a name="ln146"> </a>
<a name="ln147">#define MAX_TAG_LEN 64</a>
<a name="ln148"> </a>
<a name="ln149">typedef struct tagInchiTag</a>
<a name="ln150">{</a>
<a name="ln151">    const char *szPlainLabel;</a>
<a name="ln152">    const char *szPlainComment;</a>
<a name="ln153">    const char *szXmlLabel;</a>
<a name="ln154">    int  bAlwaysOutput;</a>
<a name="ln155">} INCHI_TAG;</a>
<a name="ln156"> </a>
<a name="ln157">/* identifier */</a>
<a name="ln158">const INCHI_TAG IdentLbl[] =</a>
<a name="ln159">{</a>
<a name="ln160">                                                                  /* prefixes: may be combined in this order */</a>
<a name="ln161">/* IL_FIXH_ORD, */    { &quot;/&quot;,   &quot;fixed_H&quot;,        &quot;fixed-H&quot;,        0 }, /* fixed H */</a>
<a name="ln162">/* IL_ISOT_ORD, */    { &quot;/&quot;,   &quot;isotopic&quot;,       &quot;isotopic&quot;,       0 }, /* isotopic */</a>
<a name="ln163">/* IL_STER_ORD, */    { &quot;/&quot;,   &quot;stereo&quot;,         &quot;stereo&quot;,         0 }, /* stereo */</a>
<a name="ln164">                                                                   /* items */</a>
<a name="ln165">/* IL_VERS_ORD, */    { &quot;&quot; ,   &quot;version&quot;,        &quot;version&quot;,        1 },</a>
<a name="ln166">/* IL_FML__ORD, */    { &quot;/&quot;,   &quot;formula&quot;,        &quot;formula&quot;,        1 }, /* basic part formula */</a>
<a name="ln167">/* IL_CONN_ORD, */    { &quot;/c&quot;,  &quot;connections&quot;,    &quot;connections&quot;,    1 },</a>
<a name="ln168">/* IL_ALLH_ORD, */    { &quot;/h&quot;,  &quot;H_atoms&quot;,        &quot;H&quot;,              1 },</a>
<a name="ln169">/* IL_CHRG_ORD, */    { &quot;/q&quot;,  &quot;charge&quot;,         &quot;charge&quot;,         1 },</a>
<a name="ln170">/* IL_PROT_ORD, */    { &quot;/p&quot;,  &quot;protons&quot;,        &quot;protons&quot;,        0 },</a>
<a name="ln171">                                                                    /* stereo */</a>
<a name="ln172">/* IL_DBND_ORD, */    { &quot;/b&quot;,  &quot;dbond&quot;,          &quot;dbond&quot;,          0 },</a>
<a name="ln173">/* IL_SP3S_ORD, */    { &quot;/t&quot;,  &quot;sp3&quot;,            &quot;sp3&quot;,            0 },</a>
<a name="ln174">/* IL_INVS_ORD, */    { &quot;/m&quot;,  &quot;sp3:inverted&quot;,   &quot;abs.inverted&quot;,   0 }, /* mirrored */</a>
<a name="ln175">/* IL_TYPS_ORD, */    { &quot;/s&quot;,  &quot;type (1=abs, 2=rel, 3=rac)&quot;, &quot;type&quot;,           0 }, /* stereo type */</a>
<a name="ln176">                                                                    /* isotopic */</a>
<a name="ln177">/* IL_ATMS_ORD, */    { &quot;/i&quot;,  &quot;atoms&quot;,          &quot;atoms&quot;,          1 },</a>
<a name="ln178">                                                                    /* isotopic mobile H only */</a>
<a name="ln179">/* IL_XCGA_ORD, */    { &quot;/h&quot;,  &quot;exchangeable_H&quot;, &quot;H-isotopic&quot;,     1 },</a>
<a name="ln180">                                                                    /* fixed H only */</a>
<a name="ln181">/* IL_FMLF_ORD, */    { &quot;/f&quot;,  &quot;formula&quot;,        &quot;formula&quot;,        1 }, /* fixed H formula */</a>
<a name="ln182">/* IL_HFIX_ORD, */    { &quot;/h&quot;,  &quot;H_fixed&quot; ,       &quot;H-fixed&quot; ,       1 }, /* fixed-H */</a>
<a name="ln183">/* IL_TRNS_ORD, */    { &quot;/o&quot;,  &quot;transposition&quot;,  &quot;transposition&quot;,  0 }, /* order */</a>
<a name="ln184">/* IL_REC__ORD, */    { &quot;/r&quot;,  &quot;reconnected bond(s) to metal(s) formula&quot;,  &quot;formula&quot;,  0 }</a>
<a name="ln185">};</a>
<a name="ln186"> </a>
<a name="ln187">/*</a>
<a name="ln188"> </a>
<a name="ln189">  Parsing plain text InChI (FML is a chemical formula)</a>
<a name="ln190">  ========================</a>
<a name="ln191"> </a>
<a name="ln192">  1.12Beta/FML       /i      /f[FML]  /i   [/o] /rFML      /i      /f[FML]  /i   [/o] end</a>
<a name="ln193">          |          |       |        |         |          |       |        |         |</a>
<a name="ln194">Labels    | chqpbtms | hbtms | hqbtms | btms    | chqpbtms | hbtms | hqbtms | btms    |</a>
<a name="ln195">inside:   |          |       |        |         |          |       |        |         |</a>
<a name="ln196">          | non-iso- | iso-  | fix-   | iso-    | non-iso- | iso-  | fix-   | iso-    |</a>
<a name="ln197">meaning:  | topic    | topic | ed H   | topic   | topic    | topic | ed H   | topic   |</a>
<a name="ln198">          |----------+-------+--------+---------|----------+-------+--------+---------|</a>
<a name="ln199">          |        mobile-H  |   fixed-H        |        mobile-H  |   fixed-H        |</a>
<a name="ln200">          |----------+-------+--------+---------|----------+-------+--------+---------|</a>
<a name="ln201">          |                                     |                                     |</a>
<a name="ln202">          |     normal  or disconected metal    |      reconnected bonds to metal     |</a>
<a name="ln203">          |_____________________________________|_____________________________________|</a>
<a name="ln204"> </a>
<a name="ln205">  meanings of h:</a>
<a name="ln206"> </a>
<a name="ln207">       /h   -  immobile H &amp; mobile H group(s)</a>
<a name="ln208">     /i/h   -  exchangeable isotopic H (common)</a>
<a name="ln209">     /f/h   -  fixed-H</a>
<a name="ln210">     /f/i/h -  never happens</a>
<a name="ln211"> </a>
<a name="ln212">*/</a>
<a name="ln213"> </a>
<a name="ln214">typedef enum tagIdentLblOrd</a>
<a name="ln215">{</a>
<a name="ln216">    IL_FIXH_ORD,</a>
<a name="ln217">    IL_ISOT_ORD,</a>
<a name="ln218">    IL_STER_ORD,</a>
<a name="ln219"> </a>
<a name="ln220">    IL_VERS_ORD,</a>
<a name="ln221">    IL_FML__ORD,</a>
<a name="ln222">    IL_CONN_ORD,</a>
<a name="ln223">    IL_ALLH_ORD,</a>
<a name="ln224">    IL_CHRG_ORD,</a>
<a name="ln225">    IL_PROT_ORD,</a>
<a name="ln226"> </a>
<a name="ln227">    IL_DBND_ORD,</a>
<a name="ln228">    IL_SP3S_ORD,</a>
<a name="ln229">    IL_INVS_ORD,</a>
<a name="ln230">    IL_TYPS_ORD,</a>
<a name="ln231"> </a>
<a name="ln232">    IL_ATMS_ORD,</a>
<a name="ln233"> </a>
<a name="ln234">    IL_XCGA_ORD,</a>
<a name="ln235"> </a>
<a name="ln236">    IL_FMLF_ORD,</a>
<a name="ln237">    IL_HFIX_ORD,</a>
<a name="ln238">    IL_TRNS_ORD,</a>
<a name="ln239">    IL_REC__ORD,</a>
<a name="ln240"> </a>
<a name="ln241">    IL_MAX_ORD /* max number of tags */</a>
<a name="ln242">} IDENT_LBL_ORD;</a>
<a name="ln243"> </a>
<a name="ln244">typedef enum tagIdentLblBit</a>
<a name="ln245">{</a>
<a name="ln246">    IL_FIXH = 1 &lt;&lt; IL_FIXH_ORD,</a>
<a name="ln247">    IL_ISOT = 1 &lt;&lt; IL_ISOT_ORD,</a>
<a name="ln248">    IL_STER = 1 &lt;&lt; IL_STER_ORD,</a>
<a name="ln249"> </a>
<a name="ln250">    IL_VERS = 1 &lt;&lt; IL_VERS_ORD,</a>
<a name="ln251">    IL_FML_ = 1 &lt;&lt; IL_FML__ORD,</a>
<a name="ln252">    IL_CONN = 1 &lt;&lt; IL_CONN_ORD,</a>
<a name="ln253">    IL_ALLH = 1 &lt;&lt; IL_ALLH_ORD,</a>
<a name="ln254">    IL_CHRG = 1 &lt;&lt; IL_CHRG_ORD,</a>
<a name="ln255">    IL_PROT = 1 &lt;&lt; IL_PROT_ORD,</a>
<a name="ln256"> </a>
<a name="ln257">    IL_DBND = 1 &lt;&lt; IL_DBND_ORD,</a>
<a name="ln258">    IL_SP3S = 1 &lt;&lt; IL_SP3S_ORD,</a>
<a name="ln259">    IL_INVS = 1 &lt;&lt; IL_INVS_ORD,</a>
<a name="ln260">    IL_TYPS = 1 &lt;&lt; IL_TYPS_ORD,</a>
<a name="ln261"> </a>
<a name="ln262">    IL_ATMS = 1 &lt;&lt; IL_ATMS_ORD,</a>
<a name="ln263"> </a>
<a name="ln264">    IL_XCGA = 1 &lt;&lt; IL_XCGA_ORD,</a>
<a name="ln265"> </a>
<a name="ln266">    IL_FMLF = 1 &lt;&lt; IL_FMLF_ORD,</a>
<a name="ln267">    IL_HFIX = 1 &lt;&lt; IL_HFIX_ORD,</a>
<a name="ln268">    IL_TRNS = 1 &lt;&lt; IL_TRNS_ORD,</a>
<a name="ln269">    IL_REC_ = 1 &lt;&lt; IL_REC__ORD</a>
<a name="ln270"> </a>
<a name="ln271">} IDENT_LBL_BIT;</a>
<a name="ln272"> </a>
<a name="ln273">/* aux info */</a>
<a name="ln274">const INCHI_TAG AuxLbl[] =</a>
<a name="ln275">{</a>
<a name="ln276">                                                                    /* prefixes may be combined in this order */</a>
<a name="ln277">/* AL_FIXH_ORD, */    { &quot;/&quot;,     &quot;fixed_H&quot;,                &quot;fixed-H&quot;,             0 }, /* fixed-H */</a>
<a name="ln278">/* AL_ISOT_ORD, */    { &quot;/&quot;,     &quot;isotopic&quot;,               &quot;isotopic&quot;,            0 }, /* isotopic */</a>
<a name="ln279">/* AL_STER_ORD, */    { &quot;/&quot;,     &quot;abs_stereo_inverted&quot;,    &quot;stereo.abs.inverted&quot;, 0 }, /* inv abs sp3 stereo */</a>
<a name="ln280">/* AL_REVR_ORD, */    { &quot;/&quot;,     &quot;reversibility&quot;,          &quot;reversibility&quot;,       0 }, /* reversibility */</a>
<a name="ln281">                                                                       /* items */</a>
<a name="ln282">/* AL_VERS_ORD, */    { &quot;&quot;,      &quot;version&quot;,                &quot;version&quot;,             1 },</a>
<a name="ln283">/* AL_NORM_ORD, */    { &quot;/&quot;,     &quot;normalization_type&quot;,     &quot;norm-type&quot;,           1 },</a>
<a name="ln284">/* AL_ANBR_ORD, */    { &quot;/N:&quot;,   &quot;original_atom_numbers&quot;,  &quot;atom.orig-nbr&quot;,       1 },</a>
<a name="ln285">/* AL_AEQU_ORD, */    { &quot;/E:&quot;,   &quot;atom_equivalence&quot;,       &quot;atom.equivalence&quot;,    0 },</a>
<a name="ln286">/* AL_GEQU_ORD, */    { &quot;/gE:&quot;,  &quot;group_equivalence&quot;,      &quot;group.equivalence&quot;,   0 },</a>
<a name="ln287">                                                                       /* inv abs sp3 stereo */</a>
<a name="ln288">/* AL_SP3I_ORD, */    { &quot;/it:&quot;,  &quot;sp3&quot;,                    &quot;sp3&quot;,                 0 },</a>
<a name="ln289">/* AL_SP3N_ORD, */    { &quot;/iN:&quot;,  &quot;original_atom_numbers&quot;,  &quot;atom.orig-nbr&quot;,       0 },</a>
<a name="ln290"> </a>
<a name="ln291">/* AL_CRV__ORD, */    { &quot;/CRV:&quot;, &quot;charge_radical_valence&quot;, &quot;charges-rad-val&quot;,     0 },</a>
<a name="ln292">                                                                       /* reversibility */</a>
<a name="ln293">/* AL_ATMR_ORD, */    { &quot;/rA:&quot;,  &quot;atoms&quot;,                  &quot;atoms&quot;,               0 },</a>
<a name="ln294">/* AL_BNDR_ORD, */    { &quot;/rB:&quot;,  &quot;bonds&quot;,                  &quot;bonds&quot;,               0 },</a>
<a name="ln295">/* AL_XYZR_ORD, */    { &quot;/rC:&quot;,  &quot;xyz&quot;,                    &quot;xyz&quot;,                 0 },</a>
<a name="ln296">                                                                       /* fixed-H only */</a>
<a name="ln297">/* AL_FIXN_ORD, */    { &quot;/F:&quot;,   &quot;original_atom_numbers&quot;,  &quot;atom.orig-nbr&quot;,       1 },</a>
<a name="ln298">                                                                       /* isotopic only */</a>
<a name="ln299">/* AL_ISON_ORD, */    { &quot;/I:&quot;,   &quot;original_atom_numbers&quot;,  &quot;atom.orig-nbr&quot;,       1 },</a>
<a name="ln300"> </a>
<a name="ln301">/* AL_REC__ORD, */    { &quot;/R:&quot;,  &quot;reconnected bond(s) to metal(s) part&quot;,  &quot;&quot;,      1 }</a>
<a name="ln302"> </a>
<a name="ln303">};</a>
<a name="ln304"> </a>
<a name="ln305">typedef enum tagAuxLblOrd</a>
<a name="ln306">{</a>
<a name="ln307">    AL_FIXH_ORD,</a>
<a name="ln308">    AL_ISOT_ORD,</a>
<a name="ln309">    AL_STER_ORD,</a>
<a name="ln310">    AL_REVR_ORD,</a>
<a name="ln311"> </a>
<a name="ln312">    AL_VERS_ORD,</a>
<a name="ln313">    AL_NORM_ORD,</a>
<a name="ln314">    AL_ANBR_ORD,</a>
<a name="ln315">    AL_AEQU_ORD,</a>
<a name="ln316">    AL_GEQU_ORD,</a>
<a name="ln317"> </a>
<a name="ln318">    AL_SP3I_ORD,</a>
<a name="ln319">    AL_SP3N_ORD,</a>
<a name="ln320"> </a>
<a name="ln321">    AL_CRV__ORD,</a>
<a name="ln322"> </a>
<a name="ln323">    AL_ATMR_ORD,</a>
<a name="ln324">    AL_BNDR_ORD,</a>
<a name="ln325">    AL_XYZR_ORD,</a>
<a name="ln326"> </a>
<a name="ln327">    AL_FIXN_ORD,</a>
<a name="ln328"> </a>
<a name="ln329">    AL_ISON_ORD,</a>
<a name="ln330"> </a>
<a name="ln331">    AL_REC__ORD,</a>
<a name="ln332"> </a>
<a name="ln333">    AL_MAX_ORD   /* max number of tags */</a>
<a name="ln334"> </a>
<a name="ln335">} AUX_LBL_ORD;</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">typedef enum tagAuxLblBit</a>
<a name="ln339">{</a>
<a name="ln340">    AL_FIXH = 1 &lt;&lt; AL_FIXH_ORD,</a>
<a name="ln341">    AL_ISOT = 1 &lt;&lt; AL_ISOT_ORD,</a>
<a name="ln342">    AL_STER = 1 &lt;&lt; AL_STER_ORD,</a>
<a name="ln343">    AL_REVR = 1 &lt;&lt; AL_REVR_ORD,</a>
<a name="ln344"> </a>
<a name="ln345">    AL_VERS = 1 &lt;&lt; AL_VERS_ORD,</a>
<a name="ln346">    AL_NORM = 1 &lt;&lt; AL_NORM_ORD,</a>
<a name="ln347">    AL_ANBR = 1 &lt;&lt; AL_ANBR_ORD,</a>
<a name="ln348">    AL_AEQU = 1 &lt;&lt; AL_AEQU_ORD,</a>
<a name="ln349">    AL_GEQU = 1 &lt;&lt; AL_GEQU_ORD,</a>
<a name="ln350"> </a>
<a name="ln351">    AL_SP3I = 1 &lt;&lt; AL_SP3I_ORD,</a>
<a name="ln352">    AL_SP3N = 1 &lt;&lt; AL_SP3N_ORD,</a>
<a name="ln353"> </a>
<a name="ln354">    AL_CRV_ = 1 &lt;&lt; AL_CRV__ORD,</a>
<a name="ln355"> </a>
<a name="ln356">    AL_ATMR = 1 &lt;&lt; AL_ATMR_ORD,</a>
<a name="ln357">    AL_BNDR = 1 &lt;&lt; AL_BNDR_ORD,</a>
<a name="ln358">    AL_XYZR = 1 &lt;&lt; AL_XYZR_ORD,</a>
<a name="ln359"> </a>
<a name="ln360">    AL_FIXN = 1 &lt;&lt; AL_FIXN_ORD,</a>
<a name="ln361"> </a>
<a name="ln362">    AL_ISON = 1 &lt;&lt; AL_ISON_ORD,</a>
<a name="ln363"> </a>
<a name="ln364">    AL_REC_ = 1 &lt;&lt; AL_REC__ORD</a>
<a name="ln365"> </a>
<a name="ln366">} AUX_LBL_BIT;</a>
<a name="ln367"> </a>
<a name="ln368">const int MAX_TAG_NUM = inchi_max((int)IL_MAX_ORD, (int)AL_MAX_ORD);</a>
<a name="ln369"> </a>
<a name="ln370">char *szGetTag(const INCHI_TAG *Tag, int nTag, int bTag, char *szTag, int *bAlways);</a>
<a name="ln371"> </a>
<a name="ln372">#define SP(N)        (x_space+sizeof(x_space)-1-(N))</a>
<a name="ln373">/**********************************************************************************************/</a>
<a name="ln374">typedef struct tagXmlEntityRef</a>
<a name="ln375">{</a>
<a name="ln376">    char nChar;</a>
<a name="ln377">    const char *pRef;</a>
<a name="ln378">} X_REF;</a>
<a name="ln379">const X_REF xmlRef[] = { {'&lt;', &quot;&amp;lt;&quot;}, {'&amp;', &quot;&amp;amp;&quot;}, {'&gt;', &quot;&amp;gt;&quot;}, {'&quot;', &quot;&amp;quot;&quot;}, {'\'', &quot;&amp;apos;&quot;}, {0, NULL}, };</a>
<a name="ln380">const char szRefChars[sizeof(xmlRef)/sizeof(xmlRef[0])] = {'&lt;', '&amp;', '&gt;', '&quot;', '\'', '\0' };</a>
<a name="ln381">/**********************************************************************************************/</a>
<a name="ln382">int PrintXmlStartTag(char *pStr, int indent, int bEnd, const char *tag,</a>
<a name="ln383">                     const char *l1, int v1, const char *l2, int v2,</a>
<a name="ln384">                     const char *l3, int v3, const char *l4, int v4,</a>
<a name="ln385">                     const char *l5, int v5, const char *l6, int v6)</a>
<a name="ln386">{</a>
<a name="ln387">    int len=0;</a>
<a name="ln388">    if ( tag ) {</a>
<a name="ln389">        len += sprintf( pStr+len, &quot;%s&lt;%s&quot;, SP(indent), tag);</a>
<a name="ln390">    }</a>
<a name="ln391">    if ( l1 ) {</a>
<a name="ln392">        len += sprintf( pStr+len, &quot; %s=\&quot;%d\&quot;&quot;, l1, v1);</a>
<a name="ln393">    }</a>
<a name="ln394">    if ( l2 ) {</a>
<a name="ln395">        len += sprintf( pStr+len, &quot; %s=\&quot;%d\&quot;&quot;, l2, v2);</a>
<a name="ln396">    }</a>
<a name="ln397">    if ( l3 ) {</a>
<a name="ln398">        len += sprintf( pStr+len, &quot; %s=\&quot;%d\&quot;&quot;, l3, v3);</a>
<a name="ln399">    }</a>
<a name="ln400">    if ( l4 ) {</a>
<a name="ln401">        len += sprintf( pStr+len, &quot; %s=\&quot;%d\&quot;&quot;, l4, v4);</a>
<a name="ln402">    }</a>
<a name="ln403">    if ( l5 ) {</a>
<a name="ln404">        len += sprintf( pStr+len, &quot; %s=\&quot;%d\&quot;&quot;, l5, v5);</a>
<a name="ln405">    }</a>
<a name="ln406">    if ( l6 ) {</a>
<a name="ln407">        len += sprintf( pStr+len, &quot; %s=\&quot;%d\&quot;&quot;, l6, v6);</a>
<a name="ln408">    }</a>
<a name="ln409">    if ( (bEnd &amp; 3) ) {</a>
<a name="ln410">        len += sprintf( pStr+len, &quot;%s%s&quot;, (bEnd &amp; 1)?&quot;/&quot;:&quot;&quot;, (bEnd &amp; 2)?&quot;&gt;&quot;:&quot;&quot;);</a>
<a name="ln411">    }</a>
<a name="ln412">    return len;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/**********************************************************************************************/</a>
<a name="ln416">int Needs2addXmlEntityRefs( const char *s )</a>
<a name="ln417">{</a>
<a name="ln418">    int len = 0;</a>
<a name="ln419">    const X_REF *q = xmlRef, *r;</a>
<a name="ln420">    const char  *p;</a>
<a name="ln421">    if ( s &amp;&amp; *s ) {</a>
<a name="ln422">        for ( q = xmlRef, len = 0; q-&gt;nChar; q ++ ) {</a>
<a name="ln423">            for ( p = s; (p = strchr( p, q-&gt;nChar )); p ++ ) {</a>
<a name="ln424">                if ( q-&gt;nChar == '&amp;' ) {</a>
<a name="ln425">                    for ( r = xmlRef; r-&gt;nChar; r ++ ) {</a>
<a name="ln426">                        if ( !memcmp( p, r-&gt;pRef, strlen(r-&gt;pRef) ) )</a>
<a name="ln427">                            goto DoNotSubstitute;</a>
<a name="ln428">                    }</a>
<a name="ln429">                }</a>
<a name="ln430">                len += strlen(q-&gt;pRef)-1;</a>
<a name="ln431">DoNotSubstitute:;</a>
<a name="ln432">            }</a>
<a name="ln433">        }</a>
<a name="ln434">        if ( len ) {</a>
<a name="ln435">            len += strlen( s );</a>
<a name="ln436">        }</a>
<a name="ln437">    }</a>
<a name="ln438">    return len;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/**********************************************************************************************/</a>
<a name="ln442">int AddXmlEntityRefs( const char *p, char *d )</a>
<a name="ln443">{</a>
<a name="ln444">    int len_d, n;</a>
<a name="ln445">    const X_REF *q = xmlRef, *r;</a>
<a name="ln446"> </a>
<a name="ln447">    len_d = 0;</a>
<a name="ln448">    while ( *p ) {</a>
<a name="ln449">        n = strcspn( p, szRefChars );</a>
<a name="ln450">        if ( n &gt; 0 ) {</a>
<a name="ln451">            /*  first n characters of p do not contain referenced chars; copy them */</a>
<a name="ln452">            strncpy( d+len_d, p, n ); /*  does not have zero termination */</a>
<a name="ln453">            len_d += n;  /*  new destination length */</a>
<a name="ln454">            p += n;      /*  position of the referenced char in the source */</a>
<a name="ln455">        }</a>
<a name="ln456">        if ( *p ) {</a>
<a name="ln457">            if ( *p == '&amp;' ) {</a>
<a name="ln458">                for ( r = xmlRef; r-&gt;nChar; r ++ ) {</a>
<a name="ln459">                    if ( !memcmp( p, r-&gt;pRef, strlen(r-&gt;pRef) ) ) {</a>
<a name="ln460">                        d[len_d++] = *p;</a>
<a name="ln461">                        goto DoNotSubstitute;</a>
<a name="ln462">                    }</a>
<a name="ln463">                }</a>
<a name="ln464">            }</a>
<a name="ln465">            q = xmlRef + (strchr( szRefChars,  UCINT *p) - szRefChars);</a>
<a name="ln466">            strcpy( d+len_d, q-&gt;pRef );   /*  add entity reference and zero termination */</a>
<a name="ln467">            len_d += strlen( d + len_d ); /*  new destination length */</a>
<a name="ln468">DoNotSubstitute:</a>
<a name="ln469">            p ++;</a>
<a name="ln470">        } else {</a>
<a name="ln471">            d[len_d] = '\0'; /*  add zero termination */</a>
<a name="ln472">        }</a>
<a name="ln473"> </a>
<a name="ln474">    }</a>
<a name="ln475">    return len_d;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">/**********************************************************************************************/</a>
<a name="ln479">int OutputINChIXmlRootStartTag( INCHI_IOSTREAM *output_file )</a>
<a name="ln480">{</a>
<a name="ln481">    char pStr[128];</a>
<a name="ln482">    sprintf( pStr, &quot;&lt;%s %s=\&quot;%s\&quot;&gt;&quot;, x_inchi, x_inchi_ver, x_curr_ver );</a>
<a name="ln483">    inchi_ios_print_nodisplay( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln484">    return 0;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/**********************************************************************************************/</a>
<a name="ln488">int OutputINChIXmlRootEndTag( INCHI_IOSTREAM *output_file )</a>
<a name="ln489">{</a>
<a name="ln490">    char pStr[128];</a>
<a name="ln491">    sprintf( pStr, &quot;&lt;/%s&gt;&quot;, x_inchi );</a>
<a name="ln492">    inchi_ios_print_nodisplay( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln493">    return 0;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">/**********************************************************************************************/</a>
<a name="ln497">int OutputINChIXmlStructStartTag( INCHI_IOSTREAM *output_file, char *pStr, int ind /* indent*/,</a>
<a name="ln498">                                 int nStrLen, int bNoStructLabels,</a>
<a name="ln499">                                 int num_input_struct, const char *szSdfLabel, const char *szSdfValue )</a>
<a name="ln500">{</a>
<a name="ln501">    char szBuf[64];</a>
<a name="ln502">    int nEstLen1;</a>
<a name="ln503">    int nEstLen2;</a>
<a name="ln504">    int ret = 0;</a>
<a name="ln505">    int tot_len;</a>
<a name="ln506">    char *pSdfLabel = NULL, *pSdfValue = NULL, *p;</a>
<a name="ln507">    /*  substitute special characters (see szRefChars[]) with xml Entity References */</a>
<a name="ln508">    int   len;</a>
<a name="ln509">    if ( bNoStructLabels ) {</a>
<a name="ln510">        /* no labela at all */</a>
<a name="ln511">        inchi_ios_print( output_file, &quot;%s\n&quot;, &quot;&quot; );   /*  empty line */</a>
<a name="ln512">        tot_len = 0;</a>
<a name="ln513">        tot_len += sprintf(pStr+tot_len, &quot;%s&lt;%s&quot;, SP(ind), x_structure);</a>
<a name="ln514">        tot_len += sprintf(pStr+tot_len, &quot;&gt;&quot; );</a>
<a name="ln515">        inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln516">        ret = 1; /*  success */</a>
<a name="ln517">    } else</a>
<a name="ln518">    if ( !(szSdfLabel &amp;&amp; szSdfLabel[0]) &amp;&amp; !(szSdfValue &amp;&amp; szSdfValue[0]) ) {</a>
<a name="ln519">        /* only structure number if present */</a>
<a name="ln520">        inchi_ios_print( output_file, &quot;%s\n&quot;, &quot;&quot; );   /*  empty line */</a>
<a name="ln521">        tot_len = 0;</a>
<a name="ln522">        tot_len += sprintf(pStr+tot_len, &quot;%s&lt;%s&quot;, SP(ind), x_structure);</a>
<a name="ln523">        if ( num_input_struct &gt; 0 ) {</a>
<a name="ln524">            tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%d\&quot;&quot;, x_number, num_input_struct);</a>
<a name="ln525">        }</a>
<a name="ln526">        tot_len += sprintf(pStr+tot_len, &quot;&gt;&quot; );</a>
<a name="ln527">        inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln528">        ret = 1; /*  success */</a>
<a name="ln529">    } else {</a>
<a name="ln530">        if ( (len = Needs2addXmlEntityRefs( szSdfLabel )) ) {</a>
<a name="ln531">            if ( (p = (char*) inchi_malloc( len+1 )) ) {</a>
<a name="ln532">                AddXmlEntityRefs( szSdfLabel, p );</a>
<a name="ln533">                szSdfLabel = pSdfLabel = p;</a>
<a name="ln534">            }</a>
<a name="ln535">        }</a>
<a name="ln536">        if ( (len = Needs2addXmlEntityRefs( szSdfValue )) ) {</a>
<a name="ln537">            if ( (p = (char*) inchi_malloc( len+1 )) ) {</a>
<a name="ln538">                AddXmlEntityRefs( szSdfValue, p );</a>
<a name="ln539">                szSdfValue = pSdfValue = p;</a>
<a name="ln540">            }</a>
<a name="ln541">        }</a>
<a name="ln542">        nEstLen1 = ind + 1 + sizeof(x_structure)-1</a>
<a name="ln543">                       + 1 + sizeof(x_number)-1 + 1 + sprintf(szBuf,&quot;\&quot;%d\&quot;&quot;, num_input_struct)  + 2;</a>
<a name="ln544">        nEstLen2 = 1 + sizeof(x_header)-1 + 1 + 2 + (szSdfLabel? strlen(szSdfLabel):0)</a>
<a name="ln545">                 + 1 + sizeof(x_value) -1 + 1 + 2 + (szSdfValue? strlen(szSdfValue):0) + 2;</a>
<a name="ln546">        if ( nEstLen1 &lt;= nStrLen ) {</a>
<a name="ln547">            inchi_ios_print( output_file, &quot;%s\n&quot;, &quot;&quot; );   /*  empty line */</a>
<a name="ln548">            tot_len = 0;</a>
<a name="ln549">            tot_len += sprintf(pStr+tot_len, &quot;%s&lt;%s&quot;, SP(ind), x_structure);</a>
<a name="ln550">            tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%d\&quot;&quot;, x_number, num_input_struct);</a>
<a name="ln551">            if ( nEstLen1 + nEstLen2 &lt;= nStrLen ) {</a>
<a name="ln552">                tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%s\&quot;&quot;, x_header, szSdfLabel? szSdfLabel:x_empty);</a>
<a name="ln553">                tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%s\&quot;&quot;, x_value, szSdfValue? szSdfValue:x_empty);</a>
<a name="ln554">            }</a>
<a name="ln555">            tot_len += sprintf(pStr+tot_len, &quot;&gt;&quot; );</a>
<a name="ln556">            inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln557">            ret = 1; /*  success */</a>
<a name="ln558">        }</a>
<a name="ln559">        if ( pSdfValue ) {</a>
<a name="ln560">            inchi_free ( pSdfValue );</a>
<a name="ln561">        }</a>
<a name="ln562">        if ( pSdfLabel ) {</a>
<a name="ln563">            inchi_free( pSdfLabel );</a>
<a name="ln564">        }</a>
<a name="ln565">    }</a>
<a name="ln566">    return ret;  /*  0 =&gt; Buffer overflow */</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">/**********************************************************************************************/</a>
<a name="ln570">int OutputINChIXmlStructEndTag( INCHI_IOSTREAM *output_file, char *pStr, int nStrLen, int ind )</a>
<a name="ln571">{</a>
<a name="ln572">    if ( output_file &amp;&amp; pStr )</a>
<a name="ln573">    {</a>
<a name="ln574">        int nEstLen1 = ind + 1 + 1 + sizeof(x_structure)-1 + 2;</a>
<a name="ln575">        if ( nEstLen1 &lt;= nStrLen )</a>
<a name="ln576">        {</a>
<a name="ln577">            sprintf(pStr, &quot;%s&lt;/%s&gt;&quot;, SP(ind), x_structure);</a>
<a name="ln578">            inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln579">            return 1;</a>
<a name="ln580">        }</a>
<a name="ln581">    }</a>
<a name="ln582">    return 0;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">/**********************************************************************************************/</a>
<a name="ln586">int OutputINChIXmlError( INCHI_IOSTREAM *output_file, char *pStr, int nStrLen, int ind,</a>
<a name="ln587">                        /*int nErrorNumber,*/ char *pErrorText, int bError )</a>
<a name="ln588">{</a>
<a name="ln589">    /* char szBuf[64]; */</a>
<a name="ln590">    const char *pErr;</a>
<a name="ln591">    char *pNewErrorText=NULL, *szErrorText = pErrorText;</a>
<a name="ln592">    int nEstLen, len=0, ret = 0;</a>
<a name="ln593"> </a>
<a name="ln594">    switch( bError ) {</a>
<a name="ln595">    case _IS_WARNING:</a>
<a name="ln596">        pErr = x_warn;</a>
<a name="ln597">        break;</a>
<a name="ln598">    case _IS_ERROR:</a>
<a name="ln599">        pErr = x_err;</a>
<a name="ln600">        break;</a>
<a name="ln601">    default: /*  _IS_FATAL */</a>
<a name="ln602">        pErr = x_ferr;</a>
<a name="ln603">        break;</a>
<a name="ln604">    }</a>
<a name="ln605"> </a>
<a name="ln606">#if ( ENTITY_REFS_IN_XML_MESSAGES == 1 )</a>
<a name="ln607">    /*  insert xml entity references if necessary */</a>
<a name="ln608">    if ( (len = Needs2addXmlEntityRefs( szErrorText )) ) {</a>
<a name="ln609">        if ( (pNewErrorText = (char*) inchi_malloc( len+1 )) ) {</a>
<a name="ln610">            AddXmlEntityRefs( szErrorText, pNewErrorText );</a>
<a name="ln611">            szErrorText = pNewErrorText;</a>
<a name="ln612">        }</a>
<a name="ln613">    }</a>
<a name="ln614">#else</a>
<a name="ln615">    szErrorText = pErrorText;</a>
<a name="ln616">#endif</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">    nEstLen = ind + 1 + sizeof(x_message)-1</a>
<a name="ln620">                  + 1 + sizeof(x_type)-1 + 1 + 1 + strlen(pErr)-1</a>
<a name="ln621">                  /* + 1 + sizeof(x_code)-1 + 1 +     sprintf(szBuf, &quot;%d&quot;, nErrorNumber) */</a>
<a name="ln622">                  + 1 + sizeof(x_text)-1 + 1 + 1 + strlen(szErrorText) + 2;</a>
<a name="ln623">    if ( nEstLen &lt;= nStrLen ) {</a>
<a name="ln624">        /*</a>
<a name="ln625">        sprintf( pStr, &quot;%s&lt;%s %s=\&quot;%s\&quot; %s=\&quot;%d\&quot; %s=\&quot;%s\&quot;/&gt;&quot;,</a>
<a name="ln626">                 SP(ind), x_message, x_type, pErr, x_code, nErrorNumber, x_text, szErrorText );</a>
<a name="ln627">        */</a>
<a name="ln628">        sprintf( pStr, &quot;%s&lt;%s %s=\&quot;%s\&quot; %s=\&quot;%s\&quot;/&gt;&quot;,</a>
<a name="ln629">                 SP(ind), x_message, x_type, pErr, x_text, szErrorText );</a>
<a name="ln630">        inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln631">        /*</a>
<a name="ln632">        pErrorText[0] = '\0'; // do not repeat same output</a>
<a name="ln633">        */</a>
<a name="ln634">        ret = 1;</a>
<a name="ln635">    }</a>
<a name="ln636">    if ( pNewErrorText )</a>
<a name="ln637">        inchi_free( pNewErrorText );</a>
<a name="ln638">    return ret;</a>
<a name="ln639"> </a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">/**********************************************************************************************/</a>
<a name="ln643">int OutputINChIPlainError( INCHI_IOSTREAM *output_file, char *pStr, int nStrLen,</a>
<a name="ln644">                           char *pErrorText, int bError )</a>
<a name="ln645">{</a>
<a name="ln646">    /* char szBuf[64]; */</a>
<a name="ln647">    const char *pErr;</a>
<a name="ln648">    char *pNewErrorText=NULL, *szErrorText = pErrorText;</a>
<a name="ln649">    int nEstLen, ret = 0;</a>
<a name="ln650"> </a>
<a name="ln651">    switch( bError ) {</a>
<a name="ln652">    case _IS_WARNING:</a>
<a name="ln653">        pErr = x_warn;</a>
<a name="ln654">        break;</a>
<a name="ln655">    case _IS_ERROR:</a>
<a name="ln656">        pErr = x_err;</a>
<a name="ln657">        break;</a>
<a name="ln658">    default: /*  _IS_FATAL */</a>
<a name="ln659">        pErr = x_ferr;</a>
<a name="ln660">        break;</a>
<a name="ln661">    }</a>
<a name="ln662">                  /* &lt;%s: &gt;, x_message */</a>
<a name="ln663">    nEstLen =     sizeof(x_message)-1 + 1 + 1</a>
<a name="ln664">                  /* &lt;%s=\&quot;%s\&quot;&gt;, x_type, pErr */</a>
<a name="ln665">                  + sizeof(x_type)-1 + 1 + 1 + strlen(pErr) + 1</a>
<a name="ln666">                  /* &lt; %s=\&quot;%s\&quot;\n&gt;, x_text, szErrorText */</a>
<a name="ln667">                  + 1 + sizeof(x_text)-1 + 1 + 1 + strlen(szErrorText) + 1 + 1;</a>
<a name="ln668">    if ( nEstLen &lt; nStrLen ) {</a>
<a name="ln669">        sprintf( pStr, &quot;%s: %s=\&quot;%s\&quot; %s=\&quot;%s\&quot;&quot;,</a>
<a name="ln670">                 x_message, x_type, pErr, x_text, szErrorText );</a>
<a name="ln671">        inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln672">        ret = 1;</a>
<a name="ln673">    }</a>
<a name="ln674">    if ( pNewErrorText )</a>
<a name="ln675">        inchi_free( pNewErrorText );</a>
<a name="ln676">    return ret;</a>
<a name="ln677"> </a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">/**************************************************************************/</a>
<a name="ln681"> </a>
<a name="ln682">#ifndef OUT_TN    /* defined in mode.h; quoted here for reference purposes only */</a>
<a name="ln683"> </a>
<a name="ln684">#define OUT_N1              0    /* non-tautomeric only */</a>
<a name="ln685">#define OUT_T1              1    /* tautomeric if present otherwise non-tautomeric */</a>
<a name="ln686">#define OUT_NT              2    /* only non-taut representations of tautomeric */</a>
<a name="ln687">#define OUT_TN              3    /* tautomeric if present otherwise non-tautomeric;</a>
<a name="ln688">                                    sepatately output non-taut representations of tautomeric if present */</a>
<a name="ln689">/* OUT_TN = OUT_T1 + OUT_NT */</a>
<a name="ln690">#endif</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">/******************************************************************/</a>
<a name="ln694">const char *EquString( int EquVal )</a>
<a name="ln695">{</a>
<a name="ln696">    int bFrom = EquVal &amp; (iiSTEREO | iiSTEREO_INV | iiNUMB | iiEQU );</a>
<a name="ln697">    int bType = EquVal &amp; (iitISO   | iitNONTAUT );</a>
<a name="ln698">    int bEq2  = EquVal &amp; (iiEq2NONTAUT | iiEq2ISO | iiEq2INV );</a>
<a name="ln699">    const char *r = &quot;&quot;;</a>
<a name="ln700"> </a>
<a name="ln701">#if ( FIX_EMPTY_LAYER_BUG == 1 )</a>
<a name="ln702">    int bEmpty= EquVal &amp; iiEmpty;</a>
<a name="ln703">    if ( bEmpty ) {</a>
<a name="ln704">        r = &quot;e&quot;;</a>
<a name="ln705">        return r;</a>
<a name="ln706">    }</a>
<a name="ln707">#endif</a>
<a name="ln708"> </a>
<a name="ln709">    switch ( bFrom ) {</a>
<a name="ln710"> </a>
<a name="ln711">    case iiSTEREO:  /* ------------ Stereo --------------------*/</a>
<a name="ln712">        switch ( bType ) {</a>
<a name="ln713">        case iitISO:  /* iso main stereo =... */</a>
<a name="ln714">            switch( bEq2 ) {</a>
<a name="ln715">            case 0:</a>
<a name="ln716">                r = &quot;m&quot;;            /* iso main stereo = main stereo */</a>
<a name="ln717">                break;</a>
<a name="ln718">            default:</a>
<a name="ln719">                r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln720">                break;</a>
<a name="ln721">            }</a>
<a name="ln722">            break;</a>
<a name="ln723">        case iitNONTAUT: /* non-taut stereo =... */</a>
<a name="ln724">            switch( bEq2 ) {</a>
<a name="ln725">            case 0:</a>
<a name="ln726">                r = &quot;m&quot;;            /* non-taut stereo = main stereo */</a>
<a name="ln727">                break;</a>
<a name="ln728">            default:</a>
<a name="ln729">                r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln730">                break;</a>
<a name="ln731">            }</a>
<a name="ln732">            break;</a>
<a name="ln733">        case (iitNONTAUT | iitISO): /* iso non-taut stereo = ... */</a>
<a name="ln734">            switch( bEq2 ) {</a>
<a name="ln735">            case 0:</a>
<a name="ln736">                r = &quot;m&quot;;            /* iso non-taut stereo = main stereo */</a>
<a name="ln737">                break;</a>
<a name="ln738">            case iiEq2ISO:</a>
<a name="ln739">                r = &quot;M&quot;;            /* iso non-taut stereo = main iso stereo */</a>
<a name="ln740">                break;</a>
<a name="ln741">            case iiEq2NONTAUT:</a>
<a name="ln742">                r = &quot;n&quot;;            /* iso non-taut stereo = non-taut stereo */</a>
<a name="ln743">                break;</a>
<a name="ln744">            default:</a>
<a name="ln745">                r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln746">                break;</a>
<a name="ln747">            }</a>
<a name="ln748">            break;</a>
<a name="ln749">        default:</a>
<a name="ln750">            r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln751">            break;</a>
<a name="ln752">        }</a>
<a name="ln753">        break;</a>
<a name="ln754"> </a>
<a name="ln755">    case iiSTEREO_INV: /*---------- Inverted Aux Stereo ------*/</a>
<a name="ln756">        if ( bEq2 &amp; iiEq2INV ) { /* stereo = Inverted(another stereo) */</a>
<a name="ln757">            bEq2 &amp;= ~iiEq2INV;</a>
<a name="ln758">            switch( bType ) {</a>
<a name="ln759">            case 0: /* main = ...*/</a>
<a name="ln760">                switch( bEq2 ) {</a>
<a name="ln761">                case 0:</a>
<a name="ln762">                    r = &quot;im&quot;;       /* main         = Inv(main) */</a>
<a name="ln763">                    break;</a>
<a name="ln764">                case iiEq2ISO:</a>
<a name="ln765">                    r = &quot;iM&quot;;       /* main         = Inv(main iso) */</a>
<a name="ln766">                    break;</a>
<a name="ln767">                case iiEq2NONTAUT:</a>
<a name="ln768">                    r = &quot;in&quot;;       /* maim         = Inv(non-taut) */</a>
<a name="ln769">                    break;</a>
<a name="ln770">                case (iiEq2NONTAUT | iiEq2ISO):</a>
<a name="ln771">                    r = &quot;iN&quot;;       /* maim         = Inv(non-taut iso ) */</a>
<a name="ln772">                    break;</a>
<a name="ln773">                default:</a>
<a name="ln774">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln775">                    break;</a>
<a name="ln776">                }</a>
<a name="ln777">                break;</a>
<a name="ln778">            case iitISO: /* main iso = ...*/</a>
<a name="ln779">                switch( bEq2 ) {</a>
<a name="ln780">                case 0:</a>
<a name="ln781">                    r = &quot;im&quot;;       /* main iso     = Inv(main) */</a>
<a name="ln782">                    break;</a>
<a name="ln783">                case iiEq2ISO:</a>
<a name="ln784">                    r = &quot;iM&quot;;       /* main iso     = Inv(main iso) */</a>
<a name="ln785">                    break;</a>
<a name="ln786">                case iiEq2NONTAUT:</a>
<a name="ln787">                    r = &quot;in&quot;;       /* maim iso     = Inv(non-taut) */</a>
<a name="ln788">                    break;</a>
<a name="ln789">                case (iiEq2NONTAUT | iiEq2ISO):</a>
<a name="ln790">                    r = &quot;iN&quot;;       /* maim         = Inv(non-taut iso ) */</a>
<a name="ln791">                    break;</a>
<a name="ln792">                default:</a>
<a name="ln793">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln794">                    break;</a>
<a name="ln795">                }</a>
<a name="ln796">                break;</a>
<a name="ln797">            case iitNONTAUT: /* non-taut = ... */</a>
<a name="ln798">                switch( bEq2 ) {</a>
<a name="ln799">                case 0:</a>
<a name="ln800">                    r = &quot;im&quot;;       /* non-taut     = Inv(main) */</a>
<a name="ln801">                    break;</a>
<a name="ln802">                case iiEq2ISO:</a>
<a name="ln803">                    r = &quot;iM&quot;;       /* non-taut     = Inv(main iso) */</a>
<a name="ln804">                    break;</a>
<a name="ln805">                case iiEq2NONTAUT:</a>
<a name="ln806">                    r = &quot;in&quot;;       /* non-taut     = Inv(non-taut) */</a>
<a name="ln807">                    break;</a>
<a name="ln808">                case (iiEq2NONTAUT | iiEq2ISO):</a>
<a name="ln809">                    r = &quot;iN&quot;;       /* non-taut     = Inv(non-taut iso ) */</a>
<a name="ln810">                    break;</a>
<a name="ln811">                default:</a>
<a name="ln812">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln813">                    break;</a>
<a name="ln814">                }</a>
<a name="ln815">                break;</a>
<a name="ln816">            case (iitNONTAUT | iitISO):</a>
<a name="ln817">                switch( bEq2 ) {</a>
<a name="ln818">                case 0:</a>
<a name="ln819">                    r = &quot;im&quot;;       /* non-taut iso = Inv(main) */</a>
<a name="ln820">                    break;</a>
<a name="ln821">                case iiEq2ISO:</a>
<a name="ln822">                    r = &quot;iM&quot;;       /* non-taut iso = Inv(main iso) */</a>
<a name="ln823">                    break;</a>
<a name="ln824">                case iiEq2NONTAUT:</a>
<a name="ln825">                    r = &quot;in&quot;;       /* non-taut iso = Inv(non-taut) */</a>
<a name="ln826">                    break;</a>
<a name="ln827">                case (iiEq2NONTAUT | iiEq2ISO):</a>
<a name="ln828">                    r = &quot;iN&quot;;       /* non-taut iso = Inv(non-taut iso ) */</a>
<a name="ln829">                    break;</a>
<a name="ln830">                default:</a>
<a name="ln831">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln832">                }</a>
<a name="ln833">                break;</a>
<a name="ln834">            default:</a>
<a name="ln835">                r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln836">                break;</a>
<a name="ln837">            }</a>
<a name="ln838"> </a>
<a name="ln839">        } else {  /* Inv stereo = another (non-inverted) stereo */</a>
<a name="ln840"> </a>
<a name="ln841">            switch( bType ) {</a>
<a name="ln842">            case iitISO: /* main iso = ...*/</a>
<a name="ln843">                switch( bEq2 ) {</a>
<a name="ln844">                case 0:</a>
<a name="ln845">                    r = &quot;m&quot;;       /* main         = (inverted aux) main */</a>
<a name="ln846">                    break;</a>
<a name="ln847">                default:</a>
<a name="ln848">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln849">                    break;</a>
<a name="ln850">                }</a>
<a name="ln851">                break;</a>
<a name="ln852">            case iitNONTAUT: /* non-taut = ... */</a>
<a name="ln853">                switch( bEq2 ) {</a>
<a name="ln854">                case 0:</a>
<a name="ln855">                    r = &quot;m&quot;;       /* non-taut     = (inverted aux) main */</a>
<a name="ln856">                    break;</a>
<a name="ln857">                default:</a>
<a name="ln858">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln859">                    break;</a>
<a name="ln860">                }</a>
<a name="ln861">                break;</a>
<a name="ln862">            case (iitNONTAUT | iitISO): /* non-taut iso = ...*/</a>
<a name="ln863">                switch( bEq2 ) {</a>
<a name="ln864">                case 0:</a>
<a name="ln865">                    r = &quot;m&quot;;        /* non-taut iso  = (inverted aux) main */</a>
<a name="ln866">                    break;</a>
<a name="ln867">                case iiEq2ISO:</a>
<a name="ln868">                    r = &quot;M&quot;;       /* non-taut iso  = (inverted aux) main iso */</a>
<a name="ln869">                    break;</a>
<a name="ln870">                case iiEq2NONTAUT:</a>
<a name="ln871">                    r = &quot;n&quot;;       /* non-taut iso  = (inverted aux) non-taut */</a>
<a name="ln872">                    break;</a>
<a name="ln873">                default:</a>
<a name="ln874">                    r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln875">                    break;</a>
<a name="ln876">                }</a>
<a name="ln877">                break;</a>
<a name="ln878">            default:</a>
<a name="ln879">                r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln880">                break;</a>
<a name="ln881">            }</a>
<a name="ln882">        }</a>
<a name="ln883">        break;</a>
<a name="ln884"> </a>
<a name="ln885">    case ( iiNUMB | iiSTEREO_INV): /*------------- Inv Stereo Numbering ------------*/</a>
<a name="ln886">        switch( bType ) {</a>
<a name="ln887">        case 0: /* inv stereo numb main = ...*/</a>
<a name="ln888">            switch( bEq2 ) {</a>
<a name="ln889">            case 0:</a>
<a name="ln890">                r = &quot;m&quot;;       /* inv stereo numb main     = main numb */</a>
<a name="ln891">                break;</a>
<a name="ln892">            default:</a>
<a name="ln893">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln894">                break;</a>
<a name="ln895">            }</a>
<a name="ln896">            break;</a>
<a name="ln897">        case iitISO: /* inv stereo iso numb main = ...*/</a>
<a name="ln898">            switch( bEq2 ) {</a>
<a name="ln899">            case 0:</a>
<a name="ln900">                r = &quot;m&quot;;       /* inv stereo iso numb main = main numb  */</a>
<a name="ln901">                break;</a>
<a name="ln902">            case iiEq2INV:</a>
<a name="ln903">                r = &quot;im&quot;;      /* inv stereo iso numb main = InvStereo(main) numb */</a>
<a name="ln904">                break;</a>
<a name="ln905">            case iiEq2ISO:</a>
<a name="ln906">                r = &quot;M&quot;;      /* inv stereo iso numb main = isotopic main numb */</a>
<a name="ln907">                break;</a>
<a name="ln908">            default:</a>
<a name="ln909">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln910">                break;</a>
<a name="ln911">            }</a>
<a name="ln912">            break;</a>
<a name="ln913">        case iitNONTAUT: /* inv stereo numb non-taut = ... */</a>
<a name="ln914">            switch( bEq2 ) {</a>
<a name="ln915">            case 0:</a>
<a name="ln916">                r = &quot;m&quot;;       /* inv stereo numb non-taut = main numb */</a>
<a name="ln917">                break;</a>
<a name="ln918">            case iiEq2NONTAUT:</a>
<a name="ln919">                r = &quot;n&quot;;       /* inv stereo numb non-taut = non-taut numb */</a>
<a name="ln920">                break;</a>
<a name="ln921">            case iiEq2INV:</a>
<a name="ln922">                r = &quot;im&quot;;      /* inv stereo numb non-taut =  InvStereo(main) numb  */</a>
<a name="ln923">                break;</a>
<a name="ln924">            default:</a>
<a name="ln925">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln926">                break;</a>
<a name="ln927">            }</a>
<a name="ln928">            break;</a>
<a name="ln929">        case (iitNONTAUT | iitISO): /* inv stereo numb non-taut iso = ... */</a>
<a name="ln930">            switch( bEq2 ) {</a>
<a name="ln931">            case 0:</a>
<a name="ln932">                r = &quot;m&quot;;       /* inv stereo numb non-taut iso = main numb */</a>
<a name="ln933">                break;</a>
<a name="ln934">            case iiEq2ISO:</a>
<a name="ln935">                r = &quot;M&quot;;       /* inv stereo numb non-taut iso = main numb iso */</a>
<a name="ln936">                break;</a>
<a name="ln937">            case (iiEq2ISO | iiEq2INV):</a>
<a name="ln938">                r = &quot;iM&quot;;       /* inv stereo numb non-taut iso = InvStereo(main iso) numb */</a>
<a name="ln939">                break;</a>
<a name="ln940">            case iiEq2NONTAUT:</a>
<a name="ln941">                r = &quot;n&quot;;       /* inv stereo numb non-taut iso = non-taut numb */</a>
<a name="ln942">                break;</a>
<a name="ln943">            case (iiEq2NONTAUT | iiEq2ISO):</a>
<a name="ln944">                r = &quot;N&quot;;       /* inv stereo numb non-taut iso = non-taut iso numb */</a>
<a name="ln945">                break;</a>
<a name="ln946">            case iiEq2INV:</a>
<a name="ln947">                r = &quot;im&quot;;      /* inv stereo numb non-taut iso = InvStereo(main) numb */</a>
<a name="ln948">                break;</a>
<a name="ln949">            case (iiEq2NONTAUT | iiEq2INV):</a>
<a name="ln950">                r = &quot;in&quot;;      /* inv stereo numb non-taut iso = InvStereo(non-taut) numb ) */</a>
<a name="ln951">                break;</a>
<a name="ln952">            default:</a>
<a name="ln953">                r = &quot;??&quot;;           /* should not happen  */</a>
<a name="ln954">                break;</a>
<a name="ln955">            }</a>
<a name="ln956">            break;</a>
<a name="ln957">        default:</a>
<a name="ln958">            r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln959">            break;</a>
<a name="ln960">        }</a>
<a name="ln961">        break;</a>
<a name="ln962"> </a>
<a name="ln963">    case iiNUMB:           /*------------- Canonical Numbering ------------*/</a>
<a name="ln964">        switch( bType ) {</a>
<a name="ln965">        case 0:         /* numb main = ...*/</a>
<a name="ln966">            r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln967">            break;</a>
<a name="ln968">        case iitISO:     /* iso numb main = ...*/</a>
<a name="ln969">            switch( bEq2 ) {</a>
<a name="ln970">            case 0:</a>
<a name="ln971">                r = &quot;m&quot;;       /* iso numb main = main numb  */</a>
<a name="ln972">                break;</a>
<a name="ln973">            default:</a>
<a name="ln974">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln975">            }</a>
<a name="ln976">            break;</a>
<a name="ln977">        case iitNONTAUT: /* numb non-taut = ... */</a>
<a name="ln978">            switch( bEq2 ) {</a>
<a name="ln979">            case 0:</a>
<a name="ln980">                r = &quot;m&quot;;       /* numb non-taut = main numb */</a>
<a name="ln981">                break;</a>
<a name="ln982">            default:</a>
<a name="ln983">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln984">            }</a>
<a name="ln985">            break;</a>
<a name="ln986">        case (iitNONTAUT | iitISO): /* numb non-taut iso = ... */</a>
<a name="ln987">            switch( bEq2 ) {</a>
<a name="ln988">            case 0:</a>
<a name="ln989">                r = &quot;m&quot;;       /* numb non-taut iso = main numb */</a>
<a name="ln990">                break;</a>
<a name="ln991">            case iiEq2ISO:</a>
<a name="ln992">                r = &quot;M&quot;;       /* numb non-taut iso = main numb iso */</a>
<a name="ln993">                break;</a>
<a name="ln994">            case iiEq2NONTAUT:</a>
<a name="ln995">                r = &quot;n&quot;;       /* numb non-taut iso = non-taut numb */</a>
<a name="ln996">                break;</a>
<a name="ln997">            default:</a>
<a name="ln998">                r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln999">                break;</a>
<a name="ln1000">            }</a>
<a name="ln1001">            break;</a>
<a name="ln1002">        default:</a>
<a name="ln1003">            r = &quot;??&quot;;           /* should not happen */</a>
<a name="ln1004">            break;</a>
<a name="ln1005">        }</a>
<a name="ln1006">        break;</a>
<a name="ln1007"> </a>
<a name="ln1008">    case iiEQU:         /*------------- Atom Equivalence ------------*/</a>
<a name="ln1009">        switch( bType ) {</a>
<a name="ln1010">        case 0:         /* equivalence main = ...*/</a>
<a name="ln1011">            r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln1012">            break;</a>
<a name="ln1013">        case iitISO:     /* equivalence main iso = ...*/</a>
<a name="ln1014">            switch( bEq2 ) {</a>
<a name="ln1015">            case 0:</a>
<a name="ln1016">                r = &quot;m&quot;;       /* equivalence main = main equ  */</a>
<a name="ln1017">                break;</a>
<a name="ln1018">            default:</a>
<a name="ln1019">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln1020">                break;</a>
<a name="ln1021">            }</a>
<a name="ln1022">            break;</a>
<a name="ln1023">        case iitNONTAUT: /* equivalence non-taut = ... */</a>
<a name="ln1024">            switch( bEq2 ) {</a>
<a name="ln1025">            case 0:</a>
<a name="ln1026">                r = &quot;m&quot;;       /* equivalence non-taut = main equ */</a>
<a name="ln1027">                break;</a>
<a name="ln1028">            default:</a>
<a name="ln1029">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln1030">                break;</a>
<a name="ln1031">            }</a>
<a name="ln1032">            break;</a>
<a name="ln1033">        case (iitNONTAUT | iitISO): /*  equivalence non-taut iso = ... */</a>
<a name="ln1034">            switch( bEq2 ) {</a>
<a name="ln1035">            case 0:</a>
<a name="ln1036">                r = &quot;m&quot;;       /* equivalence non-taut iso = main equ */</a>
<a name="ln1037">                break;</a>
<a name="ln1038">            case iiEq2ISO:</a>
<a name="ln1039">                r = &quot;M&quot;;       /* equivalence non-taut iso = main iso equ */</a>
<a name="ln1040">                break;</a>
<a name="ln1041">            case iiEq2NONTAUT:</a>
<a name="ln1042">                r = &quot;n&quot;;       /* equivalence non-taut iso = non-taut equ */</a>
<a name="ln1043">                break;</a>
<a name="ln1044">            default:</a>
<a name="ln1045">                r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln1046">                break;</a>
<a name="ln1047">            }</a>
<a name="ln1048">            break;</a>
<a name="ln1049">        default:</a>
<a name="ln1050">            r = &quot;??&quot;;          /* should not happen */</a>
<a name="ln1051">            break;</a>
<a name="ln1052">        }</a>
<a name="ln1053">        break;</a>
<a name="ln1054">    default:</a>
<a name="ln1055">        r = &quot;??&quot;;      /* should not happen */</a>
<a name="ln1056">        break;</a>
<a name="ln1057">    }</a>
<a name="ln1058">    return r;</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">/**********************************************************************************************/</a>
<a name="ln1062"> </a>
<a name="ln1063">#define OUT_NONTAUT  OUT_NN  /* was OUT_NT until 2004-04-07 */</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">/**********************************************************************************************/</a>
<a name="ln1067">int OutputINChI2(char *pStr, int nStrLen,</a>
<a name="ln1068">                 INCHI_SORT *pINChISortTautAndNonTaut2[][TAUT_NUM],</a>
<a name="ln1069">                 int iINChI,</a>
<a name="ln1070">                 ORIG_STRUCT *pOrigStruct,</a>
<a name="ln1071">                 int bDisconnectedCoord, int bOutputType, int bINChIOutputOptions,</a>
<a name="ln1072">                 int bXml, int bAbcNumbers,int bCtPredecessors, int bNoStructLabels,</a>
<a name="ln1073">                 int num_components2[],</a>
<a name="ln1074">                 int num_non_taut2[], int num_taut2[],</a>
<a name="ln1075">                 INCHI_IOSTREAM *output_file, INCHI_IOSTREAM *log_file,</a>
<a name="ln1076">                 int num_input_struct,</a>
<a name="ln1077">                 const char *szSdfLabel, const char *szSdfValue, long lSdfId,</a>
<a name="ln1078">                 int *pSortPrintINChIFlags,</a>
<a name="ln1079">                 unsigned char save_opt_bits)</a>
<a name="ln1080">{</a>
<a name="ln1081">    int bINChIOutputOptions0 = bINChIOutputOptions &amp; ~(INCHI_OUT_XML | INCHI_OUT_PLAIN_TEXT | INCHI_OUT_PLAIN_TEXT_COMMENTS);</a>
<a name="ln1082">    int bINChIOutputOptionsCur;</a>
<a name="ln1083">    int bCurOption, ret, i;</a>
<a name="ln1084"> </a>
<a name="ln1085">    ret = 0;</a>
<a name="ln1086"> </a>
<a name="ln1087">    for ( i = 0; i &lt; 3; i ++ )</a>
<a name="ln1088">    {</a>
<a name="ln1089">        switch( i )</a>
<a name="ln1090">        {</a>
<a name="ln1091">        case 0:</a>
<a name="ln1092">            bCurOption = INCHI_OUT_XML;</a>
<a name="ln1093">            break;</a>
<a name="ln1094">        case 1:</a>
<a name="ln1095">            bCurOption = INCHI_OUT_PLAIN_TEXT;</a>
<a name="ln1096">            break;</a>
<a name="ln1097">        case 2:</a>
<a name="ln1098">            bCurOption = INCHI_OUT_PLAIN_TEXT_COMMENTS;</a>
<a name="ln1099">            break;</a>
<a name="ln1100">        default:</a>
<a name="ln1101">            continue;</a>
<a name="ln1102">        }</a>
<a name="ln1103">        if ( bINChIOutputOptions &amp; bCurOption )</a>
<a name="ln1104">        {</a>
<a name="ln1105">            bINChIOutputOptionsCur = bINChIOutputOptions0 | bCurOption;</a>
<a name="ln1106">            if ( i != 1 )</a>
<a name="ln1107">            {</a>
<a name="ln1108">                bINChIOutputOptionsCur  &amp;= ~INCHI_OUT_TABBED_OUTPUT;</a>
<a name="ln1109">            }</a>
<a name="ln1110">            ret |= OutputINChI1( pStr, nStrLen,</a>
<a name="ln1111">                                 pINChISortTautAndNonTaut2,</a>
<a name="ln1112">                                 iINChI,</a>
<a name="ln1113">                                 pOrigStruct,</a>
<a name="ln1114">                                 bDisconnectedCoord, bOutputType, bINChIOutputOptionsCur,</a>
<a name="ln1115">                                 bXml, bAbcNumbers,bCtPredecessors, bNoStructLabels,</a>
<a name="ln1116">                                 num_components2,</a>
<a name="ln1117">                                 num_non_taut2, num_taut2,</a>
<a name="ln1118">                                 output_file, log_file,</a>
<a name="ln1119">                                 num_input_struct,</a>
<a name="ln1120">                                 szSdfLabel, szSdfValue, lSdfId,</a>
<a name="ln1121">                                 pSortPrintINChIFlags,</a>
<a name="ln1122">                                 save_opt_bits);</a>
<a name="ln1123">        }</a>
<a name="ln1124">    }</a>
<a name="ln1125"> </a>
<a name="ln1126">    return ret;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">/**********************************************************************************/</a>
<a name="ln1130">char *szGetTag( const INCHI_TAG *Tag, int nTag, int bTag, char *szTag, int *bAlways )</a>
<a name="ln1131">{</a>
<a name="ln1132">    int i, j, bit, num, len;</a>
<a name="ln1133">    if ( 0 &lt; nTag &amp;&amp; nTag &lt; 3 ) {</a>
<a name="ln1134">        /* no plain text comments: pick up the last tag */</a>
<a name="ln1135">        for ( i = 0, j = -1, bit = 1; i &lt; MAX_TAG_NUM; i ++, bit &lt;&lt;= 1 ) {</a>
<a name="ln1136">            if ( bTag &amp; bit ) {</a>
<a name="ln1137">                j = i;</a>
<a name="ln1138">            }</a>
<a name="ln1139">        }</a>
<a name="ln1140">        if ( j &gt;= 0 ) {</a>
<a name="ln1141">            strcpy( szTag, nTag == 1? Tag[j].szXmlLabel : nTag == 2? Tag[j].szPlainLabel : &quot;???&quot; );</a>
<a name="ln1142">            if ( nTag != 2 ) {</a>
<a name="ln1143">                *bAlways = Tag[j].bAlwaysOutput;</a>
<a name="ln1144">            }</a>
<a name="ln1145">            return szTag;</a>
<a name="ln1146">        }</a>
<a name="ln1147">    } else</a>
<a name="ln1148">    if ( nTag == 3 ) {</a>
<a name="ln1149">        /* plain text with comments */</a>
<a name="ln1150">        szTag[0] = '{';</a>
<a name="ln1151">        szTag[1] = '\0';</a>
<a name="ln1152">        for ( i = 0, j = -1, bit = 1, num=0; i &lt; MAX_TAG_NUM; i ++, bit &lt;&lt;= 1 ) {</a>
<a name="ln1153">            if ( bTag &amp; bit ) {</a>
<a name="ln1154">                j = i;</a>
<a name="ln1155">                if ( num ++ ) {</a>
<a name="ln1156">                    strcat( szTag, &quot;:&quot; );</a>
<a name="ln1157">                }</a>
<a name="ln1158">                strcat( szTag, Tag[i].szPlainComment );</a>
<a name="ln1159">            }</a>
<a name="ln1160">        }</a>
<a name="ln1161">        if ( num ) {</a>
<a name="ln1162">            strcat( szTag, &quot;}&quot; );</a>
<a name="ln1163">            num = strlen( Tag[j].szPlainLabel );</a>
<a name="ln1164">            len = strlen( szTag );</a>
<a name="ln1165">            if ( len ) {</a>
<a name="ln1166">                memmove( szTag + num, szTag, len+1 );</a>
<a name="ln1167">                memcpy( szTag, Tag[j].szPlainLabel, num );</a>
<a name="ln1168">            } else {</a>
<a name="ln1169">                strcpy ( szTag, Tag[j].szPlainLabel );</a>
<a name="ln1170">            }</a>
<a name="ln1171">            *bAlways = Tag[j].bAlwaysOutput;</a>
<a name="ln1172">        } else {</a>
<a name="ln1173">            strcpy( szTag, &quot;???&quot; );</a>
<a name="ln1174">        }</a>
<a name="ln1175">        return szTag;</a>
<a name="ln1176">    }</a>
<a name="ln1177">    strcpy( szTag, &quot;???&quot; );</a>
<a name="ln1178">    return szTag;</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">/***************************************************************************************/</a>
<a name="ln1183">/*  sorting in descending order: return -1 if *p1 &gt; *p2, return +1 if *p1 &lt; *p2               */</a>
<a name="ln1184">/***************************************************************************************/</a>
<a name="ln1185">int OutputINChI1(char *pStr, int nStrLen,</a>
<a name="ln1186">                 INCHI_SORT *pINChISortTautAndNonTaut2[][TAUT_NUM],</a>
<a name="ln1187">                 int iINChI,</a>
<a name="ln1188">                 ORIG_STRUCT *pOrigStruct,</a>
<a name="ln1189">                 int bDisconnectedCoord, int bOutputType, int bINChIOutputOptions,</a>
<a name="ln1190">                 int bXml, int bAbcNumbers,int bCtPredecessors, int bNoStructLabels,</a>
<a name="ln1191">                 int num_components2[], int num_non_taut2[], int num_taut2[],</a>
<a name="ln1192">                 INCHI_IOSTREAM *output_file, INCHI_IOSTREAM *log_file,</a>
<a name="ln1193">                 int num_input_struct,</a>
<a name="ln1194">                 const char *szSdfLabel, const char *szSdfValue, long lSdfId,</a>
<a name="ln1195">                 int *pSortPrintINChIFlags,</a>
<a name="ln1196">                 unsigned char save_opt_bits)</a>
<a name="ln1197">{</a>
<a name="ln1198">/*</a>
<a name="ln1199">  bINChIOutputOptions bits:</a>
<a name="ln1200"> </a>
<a name="ln1201">    INCHI_OUT_NO_AUX_INFO           0x0001    do not output Aux Info</a>
<a name="ln1202">    INCHI_OUT_SHORT_AUX_INFO        0x0002    output short version of Aux Info</a>
<a name="ln1203">    INCHI_OUT_ONLY_AUX_INFO         0x0004    output only Aux Info</a>
<a name="ln1204">    INCHI_OUT_EMBED_REC             0x0008    embed reconnected INChI into disconnected INChI</a>
<a name="ln1205"> </a>
<a name="ln1206">*/</a>
<a name="ln1207"> </a>
<a name="ln1208">    /*int ATOM_MODE = ((bAbcNumbers?2:0)|5|(bCtPredecessors?8:0));*/</a>
<a name="ln1209">    int ATOM_MODE = ((bAbcNumbers?CT_MODE_ABC_NUMBERS:0)</a>
<a name="ln1210">                    | CT_MODE_ATOM_COUNTS</a>
<a name="ln1211">                    | CT_MODE_NO_ORPHANS</a>
<a name="ln1212">#if ( EQL_H_NUM_TOGETHER == 1 )</a>
<a name="ln1213">                    | CT_MODE_EQL_H_TOGETHER</a>
<a name="ln1214">#endif</a>
<a name="ln1215">#if ( ABC_CT_NUM_CLOSURES == 1 )</a>
<a name="ln1216">                    | (bAbcNumbers &amp;&amp; bCtPredecessors? CT_MODE_ABC_NUM_CLOSURES:0)</a>
<a name="ln1217">#endif</a>
<a name="ln1218">                    | (bCtPredecessors?CT_MODE_PREDECESSORS:0));</a>
<a name="ln1219"> </a>
<a name="ln1220">    int TAUT_MODE = (bAbcNumbers?CT_MODE_ABC_NUMBERS:0);</a>
<a name="ln1221">    char sDifSegs[DIFL_LENGTH][DIFS_LENGTH];</a>
<a name="ln1222">    /* bOutputType =</a>
<a name="ln1223">         TAUT_YES  =&gt; tautomeric only (if no tautomeric components then no output;</a>
<a name="ln1224">         TAUT_NON  =&gt; only non-tautomeric output (if no non-taut present then no output;</a>
<a name="ln1225">         TAUT_BOTH =&gt; tautomeric and non-tautomeric */</a>
<a name="ln1226"> </a>
<a name="ln1227">    int  i, j, ii, jj, /*ii2, jj2,*/ tot_len, tot_len2, bOverflow, bEmbeddedOutputCalled=0;</a>
<a name="ln1228">    int  bIsotopic, bTautIsoHNum, bTautIsoAt, bHasIsotopicAtoms[TAUT_NUM];</a>
<a name="ln1229">    int  bStereoSp2[TAUT_NUM], bStereoSp3[TAUT_NUM];</a>
<a name="ln1230">    int  bIsotopicStereoSp2[TAUT_NUM], bIsotopicStereoSp3[TAUT_NUM];</a>
<a name="ln1231">    int  bStereoAbsInverted[TAUT_NUM], bIsotopicStereoAbsInverted[TAUT_NUM];</a>
<a name="ln1232">    int  bStereoAbs[TAUT_NUM], bIsotopicStereoAbs[TAUT_NUM];</a>
<a name="ln1233">    int  bAtomEqu[TAUT_NUM], bTautEqu[TAUT_NUM], bIsotopicAtomEqu[TAUT_NUM], bIsotopicTautEqu[TAUT_NUM];</a>
<a name="ln1234">    int  bInvStereo[TAUT_NUM], bInvIsotopicStereo[TAUT_NUM];</a>
<a name="ln1235">    int  bInvStereoOrigNumb[TAUT_NUM], bInvIsotopicStereoOrigNumb[TAUT_NUM], bIsotopicOrigNumb[TAUT_NUM];</a>
<a name="ln1236">    int  bTautomeric, bNonTautomeric, bTautomericAcid, bHardAddRemProton, iCurTautMode;</a>
<a name="ln1237">    int  bRequestedRacemicStereo=0, bRequestedRelativeStereo = 0, bRelRac;</a>
<a name="ln1238">    int  bRacemicStereo[TAUT_NUM], bRelativeStereo[TAUT_NUM];</a>
<a name="ln1239">    int  bIsotopicRacemicStereo[TAUT_NUM], bIsotopicRelativeStereo[TAUT_NUM];</a>
<a name="ln1240">    int  bChargesRadVal[TAUT_NUM], bOrigCoord[TAUT_NUM];</a>
<a name="ln1241">    int  bIgn_UU_Sp3[TAUT_NUM], bIgn_UU_Sp2[TAUT_NUM];</a>
<a name="ln1242">    int  bIgn_UU_Sp3_Iso[TAUT_NUM], bIgn_UU_Sp2_Iso[TAUT_NUM];</a>
<a name="ln1243">    int  ind, inc, bNonTautIsIdenticalToTaut = 1;</a>
<a name="ln1244">    int  bNonTautNonIsoIdentifierNotEmpty = 0, bNonTautIsoIdentifierNotEmpty = 0;</a>
<a name="ln1245">    INCHI_SORT   **pINChISortTautAndNonTaut = pINChISortTautAndNonTaut2[iINChI];</a>
<a name="ln1246">    INCHI_SORT   *pINChISort =pINChISortTautAndNonTaut[TAUT_YES];</a>
<a name="ln1247">    INCHI_SORT   *pINChISort2=pINChISortTautAndNonTaut[TAUT_YES];</a>
<a name="ln1248">    INCHI_SORT   *is, *is2;</a>
<a name="ln1249">    INChI        *pINChI /*, *pINChI2*/;</a>
<a name="ln1250">    INChI_Aux    *pINChI_Aux = NULL;</a>
<a name="ln1251"> </a>
<a name="ln1252"> </a>
<a name="ln1253">    int  ret = 0; /*  0=&gt;failed, 1=&gt;success */</a>
<a name="ln1254">    int  bOutType = bOutputType; /* ??? */</a>
<a name="ln1255">    int  nTag;</a>
<a name="ln1256">    int  bTautomericOutputAllowed, bSecondNonTautPass;</a>
<a name="ln1257">    int  num_components = num_components2[iINChI];</a>
<a name="ln1258">    int  num_comp[TAUT_NUM], max_num_comp;</a>
<a name="ln1259">    int  num_iso_H[NUM_H_ISOTOPES], bHasIsoH;</a>
<a name="ln1260">    int  nNumRemovedProtons, nNumMovedProtons;</a>
<a name="ln1261">    int  bTautAndNonTaut, bTautIsNonTaut;</a>
<a name="ln1262"> </a>
<a name="ln1263">    int  bAlways           = 0;</a>
<a name="ln1264">    int  bUseMulipliers    = 1;</a>
<a name="ln1265">    int  bOmitRepetitions  = 1;</a>
<a name="ln1266">    int  bPlainTextTags    = 2;  /* 0 =&gt; no plain tags, 1=&gt; plain text tags, 2=&gt;plaintext tags without consecutive // */</a>
<a name="ln1267">    int  bPlainText        = 0 != (bINChIOutputOptions &amp; (INCHI_OUT_PLAIN_TEXT | INCHI_OUT_PLAIN_TEXT_COMMENTS));</a>
<a name="ln1268">    int  bPlainTextCommnts = 0 != (bINChIOutputOptions &amp; INCHI_OUT_PLAIN_TEXT_COMMENTS);</a>
<a name="ln1269">    int  bPlainTabbedOutput;</a>
<a name="ln1270">    int  bTag1, bTag2, bTag3, bFhTag; /* tag bits */</a>
<a name="ln1271">    int  nCurINChISegment, nSegmAction;</a>
<a name="ln1272">    char szTag1[MAX_TAG_LEN], szTag2[MAX_TAG_LEN], szTag3[MAX_TAG_LEN];</a>
<a name="ln1273">    const char *pLF, *pTAB;</a>
<a name="ln1274"> </a>
<a name="ln1275">    /*^^^ 15 April, 2008 */</a>
<a name="ln1276">    int bFixTranspChargeBug = 0;</a>
<a name="ln1277">#if ( FIX_TRANSPOSITION_CHARGE_BUG == 1 ) /* 2008-01-02 */</a>
<a name="ln1278">    if ( INCHI_OUT_FIX_TRANSPOSITION_CHARGE_BUG &amp; bINChIOutputOptions )</a>
<a name="ln1279">        bFixTranspChargeBug = 1;</a>
<a name="ln1280">#endif</a>
<a name="ln1281">    /*^^^ 15 April, 2008 */</a>
<a name="ln1282"> </a>
<a name="ln1283">    bXml                   = 0 != (bINChIOutputOptions &amp; INCHI_OUT_XML);</a>
<a name="ln1284">    nTag  = bPlainTextCommnts? 3 : bPlainText? 2 : bXml? 1 : 0; /* tag type */</a>
<a name="ln1285">    ind                    = bXml? 1 : -1;</a>
<a name="ln1286">    inc                    = bXml? 1 : -1;</a>
<a name="ln1287">    pLF                    = bPlainTextCommnts? &quot;\n&quot; : &quot;\0&quot;;</a>
<a name="ln1288">    bFhTag                 = 0;</a>
<a name="ln1289">    bPlainTabbedOutput     = 0 != (bINChIOutputOptions &amp; INCHI_OUT_TABBED_OUTPUT) &amp;&amp;</a>
<a name="ln1290">                             bPlainText &amp;&amp; !bXml &amp;&amp; !bPlainTextCommnts;</a>
<a name="ln1291">#if ( !defined(TARGET_API_LIB) &amp;&amp; !defined(TARGET_LIB_FOR_WINCHI) )</a>
<a name="ln1292">    pTAB                   = bPlainTabbedOutput? &quot;\t&quot; : &quot;\n&quot;;</a>
<a name="ln1293">#else</a>
<a name="ln1294">    pTAB                   = &quot;\n&quot;;</a>
<a name="ln1295">#endif</a>
<a name="ln1296"> </a>
<a name="ln1297"> </a>
<a name="ln1298">    memset( sDifSegs, DIFV_BOTH_EMPTY, sizeof(sDifSegs) );</a>
<a name="ln1299"> </a>
<a name="ln1300">    if ( !pStr ) {</a>
<a name="ln1301">        inchi_ios_eprint(log_file,</a>
<a name="ln1302">            &quot;Cannot allocate output buffer. No output for structure #%d.%s%s%s%s\n&quot;,</a>
<a name="ln1303">            num_input_struct, SDF_LBL_VAL(szSdfLabel, szSdfValue));</a>
<a name="ln1304">        return ret;</a>
<a name="ln1305">    }</a>
<a name="ln1306"> </a>
<a name="ln1307">    bSecondNonTautPass = 0;</a>
<a name="ln1308">/* -- commented out to allow empty InChI --</a>
<a name="ln1309">    if (!num_components )</a>
<a name="ln1310">    {</a>
<a name="ln1311">        return 0;</a>
<a name="ln1312">    }</a>
<a name="ln1313">*/</a>
<a name="ln1314"> </a>
<a name="ln1315">    /* init version string */</a>
<a name="ln1316">    if ( !VER_STRING[0] )</a>
<a name="ln1317">    {</a>
<a name="ln1318">        strcpy(VER_STRING,  &quot;(V&quot;);</a>
<a name="ln1319">        strcat(VER_STRING,  INCHI_VERSION);</a>
<a name="ln1320">        strcat(VER_STRING,  &quot;)&quot;);</a>
<a name="ln1321">    }</a>
<a name="ln1322">    for ( i = 0; i &lt; TAUT_NUM; i ++ )</a>
<a name="ln1323">    {</a>
<a name="ln1324">        bHasIsotopicAtoms[i]      = num_comp[i]                  =</a>
<a name="ln1325">        bStereoSp2[i]             = bStereoSp3[i]                =</a>
<a name="ln1326">        bIsotopicStereoSp2[i]     = bIsotopicStereoSp3[i]        =</a>
<a name="ln1327">        bIsotopicOrigNumb[i]      =</a>
<a name="ln1328">        bStereoAbs[i]             = bIsotopicStereoAbs[i]         =</a>
<a name="ln1329">        bStereoAbsInverted[i]     = bIsotopicStereoAbsInverted[i] =</a>
<a name="ln1330">        bRacemicStereo[i]         = bRelativeStereo[i]            =</a>
<a name="ln1331">        bIsotopicRacemicStereo[i] = bIsotopicRelativeStereo[i]    =</a>
<a name="ln1332">        bAtomEqu[i]               = bTautEqu[i]                   =</a>
<a name="ln1333">        bIsotopicAtomEqu[i]       = bIsotopicTautEqu[i]           =</a>
<a name="ln1334">        bInvStereo[i]             = bInvIsotopicStereo[i]         =</a>
<a name="ln1335">        bInvStereoOrigNumb[i]     = bInvIsotopicStereoOrigNumb[i] =</a>
<a name="ln1336">        bIgn_UU_Sp3[i]            = bIgn_UU_Sp2[i]                =</a>
<a name="ln1337">        bIgn_UU_Sp3_Iso[i]        = bIgn_UU_Sp2_Iso[i]            =</a>
<a name="ln1338">        bChargesRadVal[i]         = bOrigCoord[i]                 = 0;</a>
<a name="ln1339">    }</a>
<a name="ln1340"> </a>
<a name="ln1341">    /*  find if it is isotopic */</a>
<a name="ln1342">    bIsotopic       = bTautomeric = bNonTautomeric = bTautomericAcid =</a>
<a name="ln1343">                      bHardAddRemProton = bTautIsoHNum = bTautIsoAt = 0;</a>
<a name="ln1344">    bTautAndNonTaut = bTautIsNonTaut = 0;</a>
<a name="ln1345">    /*</a>
<a name="ln1346">         x = bStereo, bStereoSp2, bStereoSp3, bStereoAbsInverted,</a>
<a name="ln1347">             bIsotopicStereo, bIsotopicStereoSp2, bIsotopicStereoSp3, bIsotopicStereoAbsInverted</a>
<a name="ln1348"> </a>
<a name="ln1349">         OUT_N1: x[TAUT_NON] refers to non-tautomeric only</a>
<a name="ln1350">         OUT_T1: x[TAUT_YES] refers to tautomeric if exists otherwise non-tautomeric</a>
<a name="ln1351">         OUT_NT: x[TAUT_NON] refers to non-taut representations of tautomeric</a>
<a name="ln1352">         OUT_TN: x[TAUT_YES] refers to tautomeric if exists otherwise non-tautomeric</a>
<a name="ln1353">                 x[TAUT_NON] refers to non-taut representations of tautomeric</a>
<a name="ln1354">     */</a>
<a name="ln1355"> </a>
<a name="ln1356">    memset( num_iso_H, 0, sizeof(num_iso_H) );</a>
<a name="ln1357">    nNumRemovedProtons = 0;</a>
<a name="ln1358">    nNumMovedProtons   = 0;</a>
<a name="ln1359">    bHasIsoH           = 0;</a>
<a name="ln1360">    bTautomericOutputAllowed = (bOutType==OUT_T1 || bOutType== OUT_TN);</a>
<a name="ln1361">    pINChISort=pINChISortTautAndNonTaut[bTautomericOutputAllowed? TAUT_YES : TAUT_NON];</a>
<a name="ln1362">    is  = pINChISort;</a>
<a name="ln1363">    is2 = (bOutType== OUT_TN)? pINChISortTautAndNonTaut[TAUT_NON] : NULL;</a>
<a name="ln1364"> </a>
<a name="ln1365">    for ( i = 0, is2 = pINChISortTautAndNonTaut[TAUT_NON]; i &lt; num_components; i ++, is ++, is2? is2++:NULL )</a>
<a name="ln1366">    {</a>
<a name="ln1367">        CompINChILayers( is, is2, sDifSegs, bFixTranspChargeBug );</a>
<a name="ln1368">        bNonTautIsIdenticalToTaut = bNonTautIsIdenticalToTaut &amp;&amp; !CompINChITautVsNonTaut(is, is2, 1);</a>
<a name="ln1369">        if ( is &amp;&amp; (pINChI_Aux = is-&gt;pINChI_Aux[TAUT_YES]) )</a>
<a name="ln1370">        {</a>
<a name="ln1371">            for ( j = 0; j &lt; NUM_H_ISOTOPES; j ++ )</a>
<a name="ln1372">            {</a>
<a name="ln1373">                bHasIsoH     += abs(pINChI_Aux-&gt;nNumRemovedIsotopicH[j]);</a>
<a name="ln1374">                num_iso_H[j] += pINChI_Aux-&gt;nNumRemovedIsotopicH[j];</a>
<a name="ln1375">            }</a>
<a name="ln1376">            nNumRemovedProtons += pINChI_Aux-&gt;nNumRemovedProtons;</a>
<a name="ln1377">            nNumMovedProtons   += abs(pINChI_Aux-&gt;nNumRemovedProtons);</a>
<a name="ln1378">        }</a>
<a name="ln1379">        if ( bTautomericOutputAllowed )</a>
<a name="ln1380">        {</a>
<a name="ln1381">            /* check for removed isotopic H */</a>
<a name="ln1382">            for ( j = TAUT_YES; j &lt; TAUT_NUM; j ++ )</a>
<a name="ln1383">            {</a>
<a name="ln1384">                switch ( bOutType ) {</a>
<a name="ln1385">                case OUT_N1: /* x[TAUT_NON]: non-tautomeric only -- never happens */</a>
<a name="ln1386">                    jj = GET_II(bOutType,is);</a>
<a name="ln1387">                    if ( jj != j )</a>
<a name="ln1388">                        continue;</a>
<a name="ln1389">                    ii = TAUT_NON;</a>
<a name="ln1390">                    break;</a>
<a name="ln1391">                case OUT_T1: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric */</a>
<a name="ln1392">                    jj = GET_II(bOutType,is);</a>
<a name="ln1393">                    if ( jj != j )</a>
<a name="ln1394">                        continue;</a>
<a name="ln1395">                    ii = TAUT_YES;</a>
<a name="ln1396">                    break;</a>
<a name="ln1397">                case OUT_NT: /* x[TAUT_NON]: only non-taut representations of tautomeric -- never happens */</a>
<a name="ln1398">                    jj = GET_II(bOutType,is);</a>
<a name="ln1399">                    if ( jj != j )</a>
<a name="ln1400">                        continue;</a>
<a name="ln1401">                    ii = TAUT_NON;</a>
<a name="ln1402">                    break;</a>
<a name="ln1403">                /* main path of control flow */</a>
<a name="ln1404">                case OUT_TN: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric;</a>
<a name="ln1405">                              * x[TAUT_NON]: non-taut only if tautomeric is present */</a>
<a name="ln1406">                    jj = ( j == TAUT_YES )? GET_II(OUT_T1,is) : ( j == TAUT_NON )? GET_II(OUT_NT,is) : -1;</a>
<a name="ln1407">                    if ( jj == TAUT_YES )</a>
<a name="ln1408">                    {</a>
<a name="ln1409">                        /* Fix12 */</a>
<a name="ln1410">                        if ( is-&gt;pINChI[jj]-&gt;lenTautomer &gt; 0 )</a>
<a name="ln1411">                        {</a>
<a name="ln1412">                            bTautAndNonTaut += (!is-&gt;pINChI[jj]-&gt;bDeleted &amp;&amp; HAS_N(is));</a>
<a name="ln1413">                        } else</a>
<a name="ln1414">                        {</a>
<a name="ln1415">                            bTautIsNonTaut ++;</a>
<a name="ln1416">                        }</a>
<a name="ln1417">                    }</a>
<a name="ln1418">                    if ( jj &lt; 0 )</a>
<a name="ln1419">                        continue;</a>
<a name="ln1420">                    ii = j;</a>
<a name="ln1421">                    break;</a>
<a name="ln1422">                default:</a>
<a name="ln1423">                    continue;</a>
<a name="ln1424">                }</a>
<a name="ln1425">                if ( jj != j )</a>
<a name="ln1426">                    continue;</a>
<a name="ln1427">                if ( (pINChI = is-&gt;pINChI[jj]) &amp;&amp; pINChI-&gt;nNumberOfAtoms &gt; 0 &amp;&amp; (pINChI_Aux = is-&gt;pINChI_Aux[jj]) )</a>
<a name="ln1428">                {</a>
<a name="ln1429">                    bTautIsoHNum += (pINChI_Aux-&gt;nNumRemovedIsotopicH[0] +</a>
<a name="ln1430">                                     pINChI_Aux-&gt;nNumRemovedIsotopicH[1] +</a>
<a name="ln1431">                                     pINChI_Aux-&gt;nNumRemovedIsotopicH[2]);</a>
<a name="ln1432">                    bTautIsoAt   += (pINChI-&gt;nNumberOfIsotopicAtoms&gt;0 || pINChI-&gt;nNumberOfIsotopicTGroups &gt; 0 );</a>
<a name="ln1433">                }</a>
<a name="ln1434">            }</a>
<a name="ln1435">        }</a>
<a name="ln1436">    }</a>
<a name="ln1437">    sDifSegs[DIFL_M ][DIFS_p_PROTONS] = nNumRemovedProtons? DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln1438">    sDifSegs[DIFL_MI][DIFS_h_H_ATOMS] = bHasIsoH?           DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;</a>
<a name="ln1439"> </a>
<a name="ln1440">    MarkUnusedAndEmptyLayers( sDifSegs );</a>
<a name="ln1441"> </a>
<a name="ln1442"> </a>
<a name="ln1443"> </a>
<a name="ln1444">    bNonTautIsIdenticalToTaut = bNonTautIsIdenticalToTaut &amp;&amp; !bTautIsoHNum;</a>
<a name="ln1445">    /*********************************************************************************************/</a>
<a name="ln1446">    for ( i = 0, is = pINChISort; i &lt; num_components; i ++, is ++ )</a>
<a name="ln1447">    {</a>
<a name="ln1448">        int bCurIso, bCurStereo, bCurIsoStereo, bCurHasIsoStereo /* Fix14 */, bCurTaut /*, bCurTaut2*/;</a>
<a name="ln1449">        int bCompExists, bCurIsoHPos, bCurIsoHStereo;</a>
<a name="ln1450">        int bCurStereoSp2, bCurIsoStereoSp2, bCurStereoSp3, bCurIsoStereoSp3, bCurIsoStereoSp3Inv;</a>
<a name="ln1451">        int bCurRacemic, bCurRelative, bCurIsoRacemic, bCurIsoRelative;</a>
<a name="ln1452">        bCompExists = 0;</a>
<a name="ln1453">        for ( j = TAUT_NON; j &lt; TAUT_NUM; j ++ )</a>
<a name="ln1454">        {</a>
<a name="ln1455">            switch ( bOutType ) {</a>
<a name="ln1456">            case OUT_N1: /* x[TAUT_NON]: non-tautomeric only */</a>
<a name="ln1457">                jj = GET_II(bOutType,is);</a>
<a name="ln1458">                if ( jj != j )</a>
<a name="ln1459">                    continue;</a>
<a name="ln1460">                ii = TAUT_NON;</a>
<a name="ln1461">                break;</a>
<a name="ln1462">            case OUT_T1: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric */</a>
<a name="ln1463">                jj = GET_II(bOutType,is);</a>
<a name="ln1464">                if ( jj != j )</a>
<a name="ln1465">                    continue;</a>
<a name="ln1466">                ii = TAUT_YES;</a>
<a name="ln1467">                break;</a>
<a name="ln1468">            case OUT_NT: /* x[TAUT_NON]: only non-taut representations of tautomeric */</a>
<a name="ln1469">                jj = GET_II(bOutType,is);</a>
<a name="ln1470">                if ( jj != j )</a>
<a name="ln1471">                    continue;</a>
<a name="ln1472">                ii = TAUT_NON;</a>
<a name="ln1473">                break;</a>
<a name="ln1474">            /* main control flow comes here: requested both mobile and fixed H results */</a>
<a name="ln1475">            case OUT_TN: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric;</a>
<a name="ln1476">                          * x[TAUT_NON]: non-taut only if tautomeric is present */</a>
<a name="ln1477">                jj = ( j == TAUT_YES )? GET_II(OUT_T1,is) : ( j == TAUT_NON )? GET_II(OUT_NT,is) : -1;</a>
<a name="ln1478">                if ( jj &lt; 0 )</a>
<a name="ln1479">                {</a>
<a name="ln1480">                    /* Fix12 */</a>
<a name="ln1481">                    if ( bTautAndNonTaut &amp;&amp; bTautIsNonTaut &amp;&amp;</a>
<a name="ln1482">                         j == TAUT_NON &amp;&amp; 0 &lt;= (jj = GET_II(OUT_T1,is)) &amp;&amp;</a>
<a name="ln1483">                         !is-&gt;pINChI[jj]-&gt;bDeleted &amp;&amp; !is-&gt;pINChI[jj]-&gt;lenTautomer )</a>
<a name="ln1484">                    {</a>
<a name="ln1485">                        ; /* the requested non-tautomeric component is in tautomeric position</a>
<a name="ln1486">                             (is-&gt;pINChI[TAUT_YES]);</a>
<a name="ln1487">                             process it also as non-tautomeric if Fixed-H layer was requested */</a>
<a name="ln1488">                    }</a>
<a name="ln1489">                    else</a>
<a name="ln1490">                    {</a>
<a name="ln1491">                        continue;</a>
<a name="ln1492">                    }</a>
<a name="ln1493">                }</a>
<a name="ln1494">                ii = j; /* ii is what we wanted; jj is what we found (0 = TAUT_NON: fixed_H, 1 = TAUT_YES: mobile_H) */</a>
<a name="ln1495">                /* -- not used 2004-09-16 ---</a>
<a name="ln1496">                if ( is2 ) {</a>
<a name="ln1497">                    jj2 = ( j == TAUT_YES )? GET_II(OUT_T1,is2) : ( j == TAUT_NON )? GET_II(OUT_NT,is2) : -1;</a>
<a name="ln1498">                    if ( jj2 &gt;= 0 ) {</a>
<a name="ln1499">                        ii2 = j;</a>
<a name="ln1500">                    } else {</a>
<a name="ln1501">                        ii2 = -1;</a>
<a name="ln1502">                    }</a>
<a name="ln1503">                } else {</a>
<a name="ln1504">                    jj2 = ii2 = -1;</a>
<a name="ln1505">                }</a>
<a name="ln1506">                -----------------------------*/</a>
<a name="ln1507">                break;</a>
<a name="ln1508">            default:</a>
<a name="ln1509">                continue;</a>
<a name="ln1510">            }</a>
<a name="ln1511">            if ( (pINChI = is-&gt;pINChI[jj]) &amp;&amp; pINChI-&gt;nNumberOfAtoms &gt; 0 )</a>
<a name="ln1512">            {</a>
<a name="ln1513">                /*pINChI_Aux = is-&gt;pINChI_Aux[jj];*/</a>
<a name="ln1514">                bCompExists ++;</a>
<a name="ln1515">                bCurTaut            = (pINChI-&gt;lenTautomer &gt; 0);</a>
<a name="ln1516">                bCurIso             = (pINChI-&gt;nNumberOfIsotopicAtoms&gt;0 || pINChI-&gt;nNumberOfIsotopicTGroups &gt; 0 );</a>
<a name="ln1517">                bCurIsoHPos         = ((pINChI-&gt;nPossibleLocationsOfIsotopicH &amp;&amp; pINChI-&gt;nPossibleLocationsOfIsotopicH[0] &gt; 1) || pINChI-&gt;lenTautomer &gt; 1);</a>
<a name="ln1518">                /* present isotopic H + their possible positions AND/OR isotopic atoms */</a>
<a name="ln1519">                bCurIsoHStereo      = (bCurIsoHPos &amp;&amp; (bTautIsoHNum || bTautIsoAt)) || bCurIso;</a>
<a name="ln1520">                if ( jj == j &amp;&amp; pINChI-&gt;bDeleted )</a>
<a name="ln1521">                {</a>
<a name="ln1522">                    num_comp[j] --;</a>
<a name="ln1523">                    if ( bCurTaut )</a>
<a name="ln1524">                    {</a>
<a name="ln1525">                        bTautomeric        |= 1; /* tautomeric representation is present */</a>
<a name="ln1526">                        bNonTautomeric     |= HAS_N(is);</a>
<a name="ln1527">                    }</a>
<a name="ln1528">                    bIsotopic              |= bCurIso;</a>
<a name="ln1529">                    continue; /* deleted H(+) in tautomeric representation */</a>
<a name="ln1530">                }</a>
<a name="ln1531">                bCurStereoSp2       = pINChI-&gt;Stereo &amp;&amp; (pINChI-&gt;Stereo-&gt;nNumberOfStereoBonds &gt; 0);</a>
<a name="ln1532">                bCurHasIsoStereo    =</a>
<a name="ln1533">                bCurStereoSp3       = pINChI-&gt;Stereo &amp;&amp; (pINChI-&gt;Stereo-&gt;nNumberOfStereoCenters &gt; 0 );</a>
<a name="ln1534">                bCurIsoStereoSp2    = bCurIsoHStereo &amp;&amp; pINChI-&gt;StereoIsotopic &amp;&amp; (pINChI-&gt;StereoIsotopic-&gt;nNumberOfStereoBonds &gt; 0);</a>
<a name="ln1535">                bCurIsoStereoSp3    = bCurIsoHStereo &amp;&amp; pINChI-&gt;StereoIsotopic &amp;&amp; (pINChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters &gt; 0);</a>
<a name="ln1536">                bCurIsoStereoSp3Inv = bCurIsoStereoSp3 &amp;&amp; pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs; /* inversion changes sp3 stereo */</a>
<a name="ln1537">                bRequestedRacemicStereo         |= (0!=(pINChI-&gt;nFlags &amp; INCHI_FLAG_RAC_STEREO));</a>
<a name="ln1538"> </a>
<a name="ln1539">                bRequestedRelativeStereo        |= (0!=(pINChI-&gt;nFlags &amp; INCHI_FLAG_REL_STEREO));</a>
<a name="ln1540">                /* check whether isotopic stereo is same as non-isotopic; if same than do not output isotopic stereo */</a>
<a name="ln1541">                if ( bCurStereoSp2 &amp;&amp; bCurIsoStereoSp2 )</a>
<a name="ln1542">                {</a>
<a name="ln1543">                    bCurIsoStereoSp2 = !Eql_INChI_Stereo( pINChI-&gt;Stereo, EQL_SP2, pINChI-&gt;StereoIsotopic, EQL_SP2, 0 );</a>
<a name="ln1544">                }</a>
<a name="ln1545">                if ( bCurStereoSp3 &amp;&amp; bCurIsoStereoSp3 )</a>
<a name="ln1546">                {</a>
<a name="ln1547">                    /* bCurIsoStereoSp3=0 means (iso stereo sp3) = (non-iso stereo sp3) or (iso stereo sp3) = Inv(non-iso stereo sp3) */</a>
<a name="ln1548">                    bCurIsoStereoSp3 = !Eql_INChI_Stereo( pINChI-&gt;Stereo, EQL_SP3, pINChI-&gt;StereoIsotopic, EQL_SP3,</a>
<a name="ln1549">                              (pINChI-&gt;nFlags &amp; INCHI_FLAG_RAC_STEREO) || (pINChI-&gt;nFlags &amp; INCHI_FLAG_REL_STEREO) );</a>
<a name="ln1550">                    if ( !bCurIsoStereoSp3 ) {</a>
<a name="ln1551">                        /* inversion changes iso sp3 differently from non-iso sp3 Fix11 */</a>
<a name="ln1552">                        bCurIsoStereoSp3Inv &amp;= (pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs != pINChI-&gt;Stereo-&gt;nCompInv2Abs);</a>
<a name="ln1553">                    }</a>
<a name="ln1554">                }</a>
<a name="ln1555"> </a>
<a name="ln1556">                bCurRelative        =  bRequestedRelativeStereo &amp;&amp; bCurStereoSp3;</a>
<a name="ln1557">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1558">                bCurRelative        =  bCurRelative &amp;&amp;</a>
<a name="ln1559">                                      (pINChI-&gt;Stereo-&gt;nNumberOfStereoCenters &gt; 1 ) &amp;&amp;</a>
<a name="ln1560">                                      (pINChI-&gt;Stereo-&gt;nCompInv2Abs != 0) &amp;&amp;</a>
<a name="ln1561">#endif</a>
<a name="ln1562"> </a>
<a name="ln1563"> </a>
<a name="ln1564"> </a>
<a name="ln1565">                bCurIsoRelative     = bRequestedRelativeStereo &amp;&amp; (bCurIsoStereoSp3 || bCurIsoStereoSp3Inv);</a>
<a name="ln1566">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1567">                bCurIsoRelative     = bCurIsoRelative &amp;&amp;</a>
<a name="ln1568">                                      (pINChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters &gt; 1 ) &amp;&amp;</a>
<a name="ln1569">                                      (pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs != 0) &amp;&amp;</a>
<a name="ln1570">#endif</a>
<a name="ln1571"> </a>
<a name="ln1572"> </a>
<a name="ln1573">                bCurRacemic         = bRequestedRacemicStereo &amp;&amp; bCurStereoSp3;</a>
<a name="ln1574">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1575">                bCurRacemic         = bCurRacemic &amp;&amp;</a>
<a name="ln1576">                                      (pINChI-&gt;Stereo-&gt;nCompInv2Abs != 0) &amp;&amp;</a>
<a name="ln1577">                                      (pINChI-&gt;Stereo-&gt;nNumberOfStereoCenters &gt; 0 ) ?</a>
<a name="ln1578">                                      pINChI-&gt;Stereo-&gt;nNumberOfStereoCenters : 0;</a>
<a name="ln1579">#endif</a>
<a name="ln1580"> </a>
<a name="ln1581">                bCurIsoRacemic      = bRequestedRacemicStereo &amp;&amp; (bCurIsoStereoSp3 || bCurIsoStereoSp3Inv);</a>
<a name="ln1582">#if ( REL_RAC_STEREO_IGN_1_SC == 1 )</a>
<a name="ln1583">                bCurIsoRacemic      = bCurIsoRacemic &amp;</a>
<a name="ln1584">                                      (pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs != 0) &amp;&amp;</a>
<a name="ln1585">                                      (pINChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters &gt; 0 ) ?</a>
<a name="ln1586">                                       pINChI-&gt;StereoIsotopic-&gt;nNumberOfStereoCenters : 0;</a>
<a name="ln1587">#endif</a>
<a name="ln1588">                if ( bRequestedRelativeStereo )</a>
<a name="ln1589">                {</a>
<a name="ln1590">                    bCurStereoSp3     = bCurRelative || (bCurStereoSp3 &amp;&amp; (pINChI-&gt;Stereo-&gt;nNumberOfStereoCenters &gt; 1 )); /* Fix11 */</a>
<a name="ln1591">                    bCurIsoStereoSp3  = bCurIsoRelative   ? bCurIsoStereoSp3 : 0;</a>
<a name="ln1592">                }</a>
<a name="ln1593">                else</a>
<a name="ln1594">                {</a>
<a name="ln1595">                    if ( bRequestedRacemicStereo )</a>
<a name="ln1596">                    {</a>
<a name="ln1597">                        bCurStereoSp3     = bCurRacemic    &gt; 1 || (bCurStereoSp3 &amp;&amp; (pINChI-&gt;Stereo-&gt;nNumberOfStereoCenters &gt; 1 )); /* Fix11 */</a>
<a name="ln1598">                        bCurIsoStereoSp3  = bCurIsoRacemic &gt; 1? bCurIsoStereoSp3 : 0;</a>
<a name="ln1599">                    }</a>
<a name="ln1600">                }</a>
<a name="ln1601">                bCurStereo          = bCurStereoSp2    || bCurStereoSp3;</a>
<a name="ln1602">                bCurIsoStereo       = bCurIsoStereoSp2 || bCurIsoStereoSp3;</a>
<a name="ln1603"> </a>
<a name="ln1604">                bIsotopic              |= bCurIso;</a>
<a name="ln1605">                bHasIsotopicAtoms[ii]  |= bCurIso;</a>
<a name="ln1606">                bStereoSp2[ii]         |= bCurStereoSp2;</a>
<a name="ln1607">                bStereoSp3[ii]         |= bCurStereoSp3;</a>
<a name="ln1608">                bIgn_UU_Sp3[ii]        |= !bCurStereoSp3 &amp;&amp; (pINChI-&gt;nFlags &amp; INCHI_FLAG_SC_IGN_ALL_UU);</a>
<a name="ln1609">                bIgn_UU_Sp2[ii]        |= !bCurStereoSp2 &amp;&amp; (pINChI-&gt;nFlags &amp; INCHI_FLAG_SB_IGN_ALL_UU);</a>
<a name="ln1610">                bIsotopicStereoSp2[ii] |= bCurIsoStereoSp2;</a>
<a name="ln1611">                bIsotopicStereoSp3[ii] |= bCurIsoStereoSp3;</a>
<a name="ln1612">                bIgn_UU_Sp3_Iso[ii]    |= !bCurIsoStereoSp3 &amp;&amp; (pINChI-&gt;nFlags &amp; INCHI_FLAG_SC_IGN_ALL_ISO_UU);</a>
<a name="ln1613">                bIgn_UU_Sp2_Iso[ii]    |= !bCurIsoStereoSp2 &amp;&amp; (pINChI-&gt;nFlags &amp; INCHI_FLAG_SB_IGN_ALL_ISO_UU);</a>
<a name="ln1614">                bStereoAbs[ii]                  |= bCurStereoSp3 &amp;&amp; (pINChI-&gt;Stereo-&gt;nCompInv2Abs != 0);</a>
<a name="ln1615">                bStereoAbsInverted[ii]          |= bCurStereoSp3 &amp;&amp; (pINChI-&gt;Stereo-&gt;nCompInv2Abs &lt; 0);</a>
<a name="ln1616">                /* Fix08: missing isotopic inverted flag if isotopic = inverted non-isotopic */</a>
<a name="ln1617">                bIsotopicStereoAbsInverted[ii]  |= (bCurIsoStereoSp3 &amp;&amp; (pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &lt; 0)) ||</a>
<a name="ln1618">                                                   (!bCurIsoStereoSp3  &amp;&amp; pINChI-&gt;StereoIsotopic  &amp;&amp; pINChI-&gt;Stereo &amp;&amp;</a>
<a name="ln1619">                                                   pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln1620">                                                   pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs != pINChI-&gt;Stereo-&gt;nCompInv2Abs);</a>
<a name="ln1621">                /* Fix 11: missing /s1 if only isotopic stereo is inverted */</a>
<a name="ln1622">                bIsotopicStereoAbs[ii]          |= (bCurIsoStereoSp3 &amp;&amp; (pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs != 0)) ||</a>
<a name="ln1623">                                                   (!bCurIsoStereoSp3  &amp;&amp; pINChI-&gt;StereoIsotopic  &amp;&amp; pINChI-&gt;Stereo &amp;&amp;</a>
<a name="ln1624">                                                   pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs &amp;&amp;</a>
<a name="ln1625">                                                   pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs != pINChI-&gt;Stereo-&gt;nCompInv2Abs);</a>
<a name="ln1626"> </a>
<a name="ln1627">                bRelativeStereo[ii]             |= bCurRelative;</a>
<a name="ln1628">                bIsotopicRelativeStereo[ii]     |= bCurIsoRelative;</a>
<a name="ln1629">                bRacemicStereo[ii]              |= bCurRacemic;</a>
<a name="ln1630">                bIsotopicRacemicStereo[ii]      |= bCurIsoRacemic;</a>
<a name="ln1631"> </a>
<a name="ln1632">                bTautomericAcid                 |= (0!=(pINChI-&gt;nFlags &amp; INCHI_FLAG_ACID_TAUT));</a>
<a name="ln1633">                bHardAddRemProton               |= (0!=(pINChI-&gt;nFlags &amp; INCHI_FLAG_HARD_ADD_REM_PROTON));</a>
<a name="ln1634">                if ( bCurTaut )</a>
<a name="ln1635">                {</a>
<a name="ln1636">                    bTautomeric        |= 1; /* tautomeric representation is present */</a>
<a name="ln1637">                    /* does tautomeric structure have also a non-tautomeric repesentation? */</a>
<a name="ln1638">                    bNonTautomeric     |= HAS_N(is);</a>
<a name="ln1639">                }</a>
<a name="ln1640"> </a>
<a name="ln1641">                /* auxiliary info */</a>
<a name="ln1642">                if ( !(bINChIOutputOptions &amp; INCHI_OUT_NO_AUX_INFO) &amp;&amp; (pINChI_Aux = is-&gt;pINChI_Aux[jj]) )</a>
<a name="ln1643">                {</a>
<a name="ln1644">                    /* detect presence of constitutional equivalence onfo */</a>
<a name="ln1645">                    int bCurEqu, bCurTautEqu=0, bCurIsoEqu=0, bCurIsoTautEqu=0; /* Fix15-disabled */</a>
<a name="ln1646">                    bAtomEqu[ii] |= (bCurEqu = bHasEquString( pINChI_Aux-&gt;nConstitEquNumbers,</a>
<a name="ln1647">                                                   pINChI_Aux-&gt;nNumberOfAtoms));</a>
<a name="ln1648">                    if ( bCurTaut )</a>
<a name="ln1649">                    {</a>
<a name="ln1650">                        bTautEqu[ii] |= (bCurTautEqu = bHasEquString( pINChI_Aux-&gt;nConstitEquTGroupNumbers,</a>
<a name="ln1651">                                                       pINChI_Aux-&gt;nNumberOfTGroups));</a>
<a name="ln1652">                    }</a>
<a name="ln1653">                    if ( bCurIso )</a>
<a name="ln1654">                    {</a>
<a name="ln1655">                        bIsotopicAtomEqu[ii] |= (bCurIsoEqu = bHasEquString( pINChI_Aux-&gt;nConstitEquIsotopicNumbers,</a>
<a name="ln1656">                                                               pINChI_Aux-&gt;nNumberOfAtoms)) /*|| bCurEqu*/;</a>
<a name="ln1657">                        if ( bCurTaut )</a>
<a name="ln1658">                        {</a>
<a name="ln1659">                            bIsotopicTautEqu[ii] |= (bCurIsoTautEqu = bHasEquString( pINChI_Aux-&gt;nConstitEquIsotopicTGroupNumbers,</a>
<a name="ln1660">                                                                   pINChI_Aux-&gt;nNumberOfTGroups)) /*|| bCurTautEqu*/;</a>
<a name="ln1661">                        }</a>
<a name="ln1662">                        /* non-zero if isotopic numbering for inverted isotopic stereo is different */</a>
<a name="ln1663">                        bIsotopicOrigNumb[ii] |= bCurHasIsoStereo &amp;&amp; /* Fix14 */</a>
<a name="ln1664">                                                 pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv &amp;&amp;</a>
<a name="ln1665">                                                 pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd &amp;&amp;</a>
<a name="ln1666">                            (0 != memcmp( pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv,</a>
<a name="ln1667">                                          pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd,</a>
<a name="ln1668">                                          sizeof(pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv[0])</a>
<a name="ln1669">                                          * pINChI_Aux-&gt;nNumberOfAtoms));</a>
<a name="ln1670"> </a>
<a name="ln1671">                    }</a>
<a name="ln1672">                    /* inverted stereo */</a>
<a name="ln1673">                    if ( bCurStereoSp3 &amp;&amp; pINChI-&gt;Stereo-&gt;nCompInv2Abs )</a>
<a name="ln1674">                    {</a>
<a name="ln1675">                        bInvStereo[ii]         |= 1;</a>
<a name="ln1676">                        bInvStereoOrigNumb[ii] |= pINChI_Aux-&gt;nOrigAtNosInCanonOrd &amp;&amp;</a>
<a name="ln1677">                                                  pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv &amp;&amp;</a>
<a name="ln1678">                            (0 != memcmp( pINChI_Aux-&gt;nOrigAtNosInCanonOrd,</a>
<a name="ln1679">                                          pINChI_Aux-&gt;nOrigAtNosInCanonOrdInv,</a>
<a name="ln1680">                                          sizeof(pINChI_Aux-&gt;nOrigAtNosInCanonOrd[0])</a>
<a name="ln1681">                                          * pINChI_Aux-&gt;nNumberOfAtoms));</a>
<a name="ln1682">                    }</a>
<a name="ln1683">                    /* inverted isotopic stereo */</a>
<a name="ln1684">                    if ( bCurIsoStereoSp3 &amp;&amp; pINChI-&gt;StereoIsotopic-&gt;nCompInv2Abs )</a>
<a name="ln1685">                    {</a>
<a name="ln1686">                        bInvIsotopicStereo[ii]         |= 1;</a>
<a name="ln1687">                        bInvIsotopicStereoOrigNumb[ii] |= pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd &amp;&amp;</a>
<a name="ln1688">                                                          pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv &amp;&amp;</a>
<a name="ln1689">                            (0 != memcmp( pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd,</a>
<a name="ln1690">                                          pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrdInv,</a>
<a name="ln1691">                                          sizeof(pINChI_Aux-&gt;nIsotopicOrigAtNosInCanonOrd[0])</a>
<a name="ln1692">                                          * pINChI_Aux-&gt;nNumberOfAtoms));</a>
<a name="ln1693">                    }</a>
<a name="ln1694">                    if ( pINChI_Aux-&gt;OrigInfo &amp;&amp; bHasOrigInfo(pINChI_Aux-&gt;OrigInfo, pINChI_Aux-&gt;nNumberOfAtoms) )</a>
<a name="ln1695">                    {</a>
<a name="ln1696">                        bChargesRadVal[ii] |= 1;</a>
<a name="ln1697">                    }</a>
<a name="ln1698">                }</a>
<a name="ln1699">            }</a>
<a name="ln1700">        }</a>
<a name="ln1701">        if ( bCompExists )</a>
<a name="ln1702">        {</a>
<a name="ln1703">            for ( j = TAUT_NON; j &lt; TAUT_NUM; j ++ )</a>
<a name="ln1704">            {</a>
<a name="ln1705">                num_comp[j] ++;</a>
<a name="ln1706">            }</a>
<a name="ln1707">        }</a>
<a name="ln1708">    }</a>
<a name="ln1709">    if ( bTautomeric /*&amp;&amp; bTautomericAcid*/ ) /* &quot;&amp;&amp; bTautomericAcid&quot; commented out 2004-06-02 */</a>
<a name="ln1710">    {</a>
<a name="ln1711">        bTautomeric += bTautomericAcid; /* long-range tautomerism */</a>
<a name="ln1712">        bTautomeric += (bHardAddRemProton? 4 : 0);</a>
<a name="ln1713">    }</a>
<a name="ln1714">    if ( bRequestedRacemicStereo || bRequestedRelativeStereo )</a>
<a name="ln1715">    {</a>
<a name="ln1716">        /* do not output inverted stereo info */</a>
<a name="ln1717">        for ( i = 0; i &lt; TAUT_NUM; i ++ )</a>
<a name="ln1718">        {</a>
<a name="ln1719">            /* Fix11 */</a>
<a name="ln1720">            bStereoAbsInverted[i] =</a>
<a name="ln1721">            bStereoAbs[i]         =</a>
<a name="ln1722">            bInvStereo[i]         =</a>
<a name="ln1723">            bInvStereoOrigNumb[i] =  0;</a>
<a name="ln1724">            /* bIsotopicRelativeStereo[i]=0 may happen because iso stereo is same or inverted non-iso stereo */</a>
<a name="ln1725">            bIsotopicStereoAbsInverted[i] =</a>
<a name="ln1726">            bIsotopicStereoAbs[i]         =</a>
<a name="ln1727">            bInvIsotopicStereo[i]         =</a>
<a name="ln1728">            bInvIsotopicStereoOrigNumb[i] = 0;</a>
<a name="ln1729">            /* -- commented out: Fix11--</a>
<a name="ln1730">            if ( bRacemicStereo[i] || bRelativeStereo[i] )</a>
<a name="ln1731">            {</a>
<a name="ln1732">                bStereoAbsInverted[i] =</a>
<a name="ln1733">                bStereoAbs[i]         =</a>
<a name="ln1734">                bInvStereo[i]         =</a>
<a name="ln1735">                bInvStereoOrigNumb[i] =  0;</a>
<a name="ln1736">            }</a>
<a name="ln1737">            if ( bIsotopicRacemicStereo[i] || bIsotopicRelativeStereo[i] )</a>
<a name="ln1738">            {</a>
<a name="ln1739">                bIsotopicStereoAbsInverted[i] =</a>
<a name="ln1740">                bIsotopicStereoAbs[i]         =</a>
<a name="ln1741">                bInvIsotopicStereo[i]         =</a>
<a name="ln1742">                bInvIsotopicStereoOrigNumb[i] = 0;</a>
<a name="ln1743">            }</a>
<a name="ln1744">            */</a>
<a name="ln1745">        }</a>
<a name="ln1746">    }</a>
<a name="ln1747"> </a>
<a name="ln1748"> </a>
<a name="ln1749">    iCurTautMode = bOutType == OUT_N1? TAUT_NON:  /* only non-taut */</a>
<a name="ln1750">                   bOutType == OUT_T1? TAUT_YES:  /* tautomeric if present, otherwise non-tautomeric */</a>
<a name="ln1751">                   bOutType == OUT_NT? TAUT_NON:  /* only non-taut representations of tautomeric */</a>
<a name="ln1752">                   bOutType == OUT_TN? TAUT_YES:  /* tautomeric if present otherwise non-tautomeric; */</a>
<a name="ln1753">                                             -1;   /* separately output non-taut representations of tautomeric if present */</a>
<a name="ln1754"> </a>
<a name="ln1755">    if ( iCurTautMode &lt; 0 )</a>
<a name="ln1756">    {</a>
<a name="ln1757">        return 0;  /* error */</a>
<a name="ln1758">    }</a>
<a name="ln1759"> </a>
<a name="ln1760">    if ( bXml )</a>
<a name="ln1761">    {</a>
<a name="ln1762">        ind += inc* (1+iINChI);</a>
<a name="ln1763">    }</a>
<a name="ln1764"> </a>
<a name="ln1765">    bOverflow = 0;</a>
<a name="ln1766"> </a>
<a name="ln1767">    num_components = num_comp[iCurTautMode];</a>
<a name="ln1768"> </a>
<a name="ln1769">    max_num_comp   = inchi_max(num_comp[TAUT_NON], num_comp[TAUT_YES]);</a>
<a name="ln1770"> </a>
<a name="ln1771">    if ( bINChIOutputOptions &amp; INCHI_OUT_ONLY_AUX_INFO )</a>
<a name="ln1772">    {</a>
<a name="ln1773">        goto output_aux_info;</a>
<a name="ln1774">    }</a>
<a name="ln1775"> </a>
<a name="ln1776">    nCurINChISegment = DIFL_M;</a>
<a name="ln1777"> </a>
<a name="ln1778">    /******************************************</a>
<a name="ln1779">     *</a>
<a name="ln1780">     *  Structure (Compound) Header</a>
<a name="ln1781">     *</a>
<a name="ln1782">     ******************************************/</a>
<a name="ln1783">    if ( bXml )</a>
<a name="ln1784">    {</a>
<a name="ln1785">        /* -- moved to the line above goto output_aux_info;</a>
<a name="ln1786">        ind += inc* (1+iINChI);</a>
<a name="ln1787">        */</a>
<a name="ln1788">        /*  basic title, version */</a>
<a name="ln1789">        if ( INCHI_BAS == iINChI )</a>
<a name="ln1790">        {</a>
<a name="ln1791">            inchi_ios_print( output_file, &quot;\n&quot; );   /*  empty line */</a>
<a name="ln1792">        }</a>
<a name="ln1793">        tot_len = sprintf(pStr, &quot;%s&lt;%s %s=\&quot;%s\&quot;&quot;,</a>
<a name="ln1794">            SP(ind), x_basic, x_ver, x_curr_ver);</a>
<a name="ln1795">        if ( INCHI_REC == iINChI || (INCHI_BAS == iINChI &amp;&amp; bDisconnectedCoord) )</a>
<a name="ln1796">        {</a>
<a name="ln1797">            tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%d\&quot;&quot;, x_reconnected, iINChI );</a>
<a name="ln1798">        }</a>
<a name="ln1799">        if ( bAbcNumbers || bCtPredecessors )</a>
<a name="ln1800">        {</a>
<a name="ln1801">            const char *pNumber = &quot;&quot;;</a>
<a name="ln1802">            const char *pDelim  = &quot;&quot;;</a>
<a name="ln1803">            const char *pCtType = &quot;&quot;;</a>
<a name="ln1804">            if ( bAbcNumbers &amp;&amp; bCtPredecessors )</a>
<a name="ln1805">            {</a>
<a name="ln1806">                pNumber = x_type_short;</a>
<a name="ln1807">            }</a>
<a name="ln1808">            else</a>
<a name="ln1809">            {</a>
<a name="ln1810">                pNumber = bAbcNumbers? x_type_alpha : x_type_numer;</a>
<a name="ln1811">                pDelim  = (bAbcNumbers &amp;&amp; bCtPredecessors)? &quot;-&quot;:&quot;&quot;;</a>
<a name="ln1812">                pCtType = bCtPredecessors? x_type_predec:&quot;&quot;;</a>
<a name="ln1813">            }</a>
<a name="ln1814">            /*  type */</a>
<a name="ln1815">            tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%s%s%s\&quot;&quot;, x_type, pNumber, pDelim, pCtType);</a>
<a name="ln1816">        }</a>
<a name="ln1817">        sprintf(pStr+tot_len,&quot;&gt;&quot;);</a>
<a name="ln1818">        inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln1819">        ind += inc;</a>
<a name="ln1820">    }</a>
<a name="ln1821">    else</a>
<a name="ln1822">    if ( INCHI_BAS == iINChI )</a>
<a name="ln1823">    {</a>
<a name="ln1824">        /* eliminate empty line in plain text output */</a>
<a name="ln1825">        if ( bNoStructLabels )</a>
<a name="ln1826">        {</a>
<a name="ln1827">            ;</a>
<a name="ln1828">/* -- removed empty line before InChI ---</a>
<a name="ln1829">#ifndef TARGET_API_LIB</a>
<a name="ln1830">            inchi_ios_print( output_file, &quot;\n&quot; );</a>
<a name="ln1831">#else</a>
<a name="ln1832">            ;</a>
<a name="ln1833">#endif</a>
<a name="ln1834">*/</a>
<a name="ln1835">        }</a>
<a name="ln1836">        else</a>
<a name="ln1837">        {</a>
<a name="ln1838">            if ( !(szSdfLabel &amp;&amp; szSdfLabel[0]) &amp;&amp; !(szSdfValue &amp;&amp; szSdfValue[0]) )</a>
<a name="ln1839">            {</a>
<a name="ln1840">                tot_len = sprintf( pStr, &quot;%sStructure: %d&quot;, pLF, num_input_struct );</a>
<a name="ln1841">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pTAB );</a>
<a name="ln1842">            }</a>
<a name="ln1843">            else</a>
<a name="ln1844">            {</a>
<a name="ln1845">                tot_len = sprintf( pStr, &quot;%sStructure: %d.%s%s%s%s&quot;,</a>
<a name="ln1846">                                         pLF,</a>
<a name="ln1847">                                        num_input_struct,</a>
<a name="ln1848">                                        SDF_LBL_VAL(szSdfLabel, szSdfValue) );</a>
<a name="ln1849">                if ( lSdfId )</a>
<a name="ln1850">                {</a>
<a name="ln1851">                    tot_len --;</a>
<a name="ln1852">                    tot_len += sprintf( pStr + tot_len, &quot;:%ld&quot;, lSdfId );</a>
<a name="ln1853">                }</a>
<a name="ln1854">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pTAB );</a>
<a name="ln1855">            }</a>
<a name="ln1856">        }</a>
<a name="ln1857">        /* inchi_ios_print( output_file, &quot;%s%s=%s&quot;, pLF, (FLAG_SORT_PRINT_ReChI_PREFIX &amp; *pSortPrintINChIFlags)? INCHI_REC_NAME : INCHI_NAME, pLF ); */</a>
<a name="ln1858">        inchi_ios_print( output_file, &quot;%s%s=%s&quot;, pLF, INCHI_NAME, pLF );</a>
<a name="ln1859">    }</a>
<a name="ln1860"> </a>
<a name="ln1861"> </a>
<a name="ln1862">    /*****************************************************</a>
<a name="ln1863">     *</a>
<a name="ln1864">     * version  (10-29-2003)</a>
<a name="ln1865">     *</a>
<a name="ln1866">     ****************************************************/</a>
<a name="ln1867">    if ( INCHI_BAS == iINChI || !(bINChIOutputOptions &amp; INCHI_OUT_EMBED_REC) /* || !bXml */)</a>
<a name="ln1868">    {</a>
<a name="ln1869">        /* xml: only if the first or not embedded; plain: always */</a>
<a name="ln1870">        szGetTag( IdentLbl, nTag,  bTag1 = IL_VERS, szTag1, &amp;bAlways );</a>
<a name="ln1871">        tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln1872">        tot_len += sprintf(pStr + tot_len, &quot;%s&quot;, x_curr_ver);</a>
<a name="ln1873"> </a>
<a name="ln1874">        /* 10-17-2008 Add 'standard' flag if necessary */</a>
<a name="ln1875">        if ( bINChIOutputOptions &amp; INCHI_OUT_STDINCHI )</a>
<a name="ln1876">            tot_len += sprintf(pStr + tot_len, &quot;S&quot;);</a>
<a name="ln1877"> </a>
<a name="ln1878">        /*if ( bXml ) {*/  /* avoid leading slash in plain output */</a>
<a name="ln1879">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln1880">                goto exit_function;</a>
<a name="ln1881">        /*}*/</a>
<a name="ln1882">        inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln1883">    }</a>
<a name="ln1884"> </a>
<a name="ln1885"> </a>
<a name="ln1886">    /*****************************************************</a>
<a name="ln1887">     *</a>
<a name="ln1888">     * atoms, connection tables and tautomeric info</a>
<a name="ln1889">     *</a>
<a name="ln1890">     ****************************************************/</a>
<a name="ln1891">    /******************* constitution: dot-disconnected Hill formulas: &lt;formula&gt; */</a>
<a name="ln1892">    if ( num_components2[0] || num_components2[1] )</a>
<a name="ln1893">    {</a>
<a name="ln1894">        szGetTag( IdentLbl, nTag,  bTag1 = INCHI_REC == iINChI? IL_REC_ : IL_FML_, szTag1, &amp;bAlways );</a>
<a name="ln1895">        tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln1896">        tot_len = str_HillFormula(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln1897">                                  &amp;bOverflow, bOutType, num_components, bUseMulipliers);</a>
<a name="ln1898"> </a>
<a name="ln1899">        if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, 1 ) )</a>
<a name="ln1900">            goto exit_function;</a>
<a name="ln1901">        inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln1902">    }</a>
<a name="ln1903">    /****************  semicolon/dot-disconnected connection tables */</a>
<a name="ln1904">    szGetTag( IdentLbl, nTag,  bTag1 = IL_CONN, szTag1, &amp;bAlways );</a>
<a name="ln1905">    tot_len  = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln1906">    tot_len2 = str_Connections(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln1907">                              &amp;bOverflow, bOutType, ATOM_MODE, num_components, bUseMulipliers);</a>
<a name="ln1908">    /* current version does not output empty (&quot;;;;;&quot;) connectivity */</a>
<a name="ln1909">    if ( tot_len != tot_len2 /*|| !bXml*/ ) { /* 2004-06-30: never output empty connection table */</a>
<a name="ln1910">        tot_len = tot_len2;</a>
<a name="ln1911">        if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -2, bPlainTextTags ) )</a>
<a name="ln1912">            goto exit_function; /* pStr overfow */</a>
<a name="ln1913">        inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln1914">    }</a>
<a name="ln1915">    /************** hydrogen atoms; do not output empty */</a>
<a name="ln1916">    if ( INCHI_SEGM_FILL == INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_h_H_ATOMS] ) )</a>
<a name="ln1917">    {</a>
<a name="ln1918">        szGetTag( IdentLbl, nTag,  bTag1 = IL_ALLH, szTag1, &amp;bAlways );</a>
<a name="ln1919">        tot_len  = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln1920">        tot_len2 = str_H_atoms(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln1921">                              &amp;bOverflow, bOutType, ATOM_MODE, TAUT_MODE,</a>
<a name="ln1922">                              num_components, bUseMulipliers);</a>
<a name="ln1923">        if ( tot_len != tot_len2 /*|| !bXml*/ ) { /* 2004-06-21: never output empty */</a>
<a name="ln1924">            tot_len = tot_len2;</a>
<a name="ln1925">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -2, 1 ) )</a>
<a name="ln1926">                goto exit_function;</a>
<a name="ln1927">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln1928">        }</a>
<a name="ln1929">    }</a>
<a name="ln1930"> </a>
<a name="ln1931"> </a>
<a name="ln1932">    bFhTag = 0;</a>
<a name="ln1933"> </a>
<a name="ln1934"> </a>
<a name="ln1935">repeat_INChI_output:</a>
<a name="ln1936"> </a>
<a name="ln1937">    /*****************************************************</a>
<a name="ln1938">     * charge</a>
<a name="ln1939">     */</a>
<a name="ln1940"> </a>
<a name="ln1941">    nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_q_CHARGE] );</a>
<a name="ln1942">    if ( nSegmAction )</a>
<a name="ln1943">    {</a>
<a name="ln1944">        szGetTag( IdentLbl, nTag,  bTag1 = IL_CHRG | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln1945">        tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln1946">        if ( INCHI_SEGM_FILL == nSegmAction )</a>
<a name="ln1947">        {</a>
<a name="ln1948">            tot_len = str_Charge2(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln1949">                                  &amp;bOverflow, bOutType, num_components,</a>
<a name="ln1950">                                  bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln1951">            bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln1952">        }</a>
<a name="ln1953">        if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln1954">            goto exit_function;</a>
<a name="ln1955">        inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln1956">    }</a>
<a name="ln1957">    else</a>
<a name="ln1958">    {</a>
<a name="ln1959">        if ( !bXml )</a>
<a name="ln1960">        {</a>
<a name="ln1961">            if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln1962">        }</a>
<a name="ln1963">    }</a>
<a name="ln1964"> </a>
<a name="ln1965">    /*****************************************************</a>
<a name="ln1966">     * removed protons</a>
<a name="ln1967">     */</a>
<a name="ln1968">    if ( iCurTautMode == TAUT_YES &amp;&amp; !bSecondNonTautPass )</a>
<a name="ln1969">    {</a>
<a name="ln1970"> </a>
<a name="ln1971">        nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_p_PROTONS] );</a>
<a name="ln1972">        if ( nSegmAction )</a>
<a name="ln1973">        {</a>
<a name="ln1974">            szGetTag( IdentLbl, nTag,  bTag1 = IL_PROT | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln1975">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln1976">            tot_len += sprintf( pStr + tot_len, &quot;%+d&quot;, nNumRemovedProtons );</a>
<a name="ln1977">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln1978">                goto exit_function;</a>
<a name="ln1979">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln1980">        }</a>
<a name="ln1981">        else</a>
<a name="ln1982">        {</a>
<a name="ln1983">            if ( !bXml )</a>
<a name="ln1984">            {</a>
<a name="ln1985">                if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln1986">            }</a>
<a name="ln1987">        }</a>
<a name="ln1988"> </a>
<a name="ln1989">    }</a>
<a name="ln1990"> </a>
<a name="ln1991"> </a>
<a name="ln1992">    /**************************************************</a>
<a name="ln1993">     *</a>
<a name="ln1994">     *    non-isotopic stereo</a>
<a name="ln1995">     */</a>
<a name="ln1996"> </a>
<a name="ln1997">    {</a>
<a name="ln1998">        int i;</a>
<a name="ln1999">        i = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_t_SATOMS] );</a>
<a name="ln2000">        i = i;</a>
<a name="ln2001">    }</a>
<a name="ln2002"> </a>
<a name="ln2003">    if ( INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_b_SBONDS] ) ||</a>
<a name="ln2004">         INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_t_SATOMS] ) ||</a>
<a name="ln2005">         INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_m_SP3INV] ) ||</a>
<a name="ln2006">         INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_s_STYPE] ) )</a>
<a name="ln2007">    {</a>
<a name="ln2008">        /*  stereo */</a>
<a name="ln2009">        szGetTag( IdentLbl, nTag,  bTag1 = IL_STER | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2010">        if ( bXml )</a>
<a name="ln2011">        {</a>
<a name="ln2012">            str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2013">            inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2014">            ind += inc;</a>
<a name="ln2015">        }</a>
<a name="ln2016"> </a>
<a name="ln2017">        /*  sp2 */</a>
<a name="ln2018">        /*if ( bStereoSp2[iCurTautMode]  )*/</a>
<a name="ln2019">        if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_b_SBONDS] )) )</a>
<a name="ln2020">        {</a>
<a name="ln2021">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_DBND, szTag2, &amp;bAlways );</a>
<a name="ln2022">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2023">            if ( INCHI_SEGM_FILL == nSegmAction )</a>
<a name="ln2024">            {</a>
<a name="ln2025">                tot_len = str_Sp2(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2026">                                   &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2027">                                   bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2028">                bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2029">            }</a>
<a name="ln2030">            if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2031">                goto exit_function;</a>
<a name="ln2032">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2033">        }</a>
<a name="ln2034">        else</a>
<a name="ln2035">        {</a>
<a name="ln2036">            if ( !bXml )</a>
<a name="ln2037">            {</a>
<a name="ln2038">                if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; ); /* sp2 */</a>
<a name="ln2039">            }</a>
<a name="ln2040">        }</a>
<a name="ln2041"> </a>
<a name="ln2042">        /*  sp3 */</a>
<a name="ln2043">        /*if ( bStereoSp3[iCurTautMode]  )*/</a>
<a name="ln2044">        if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_t_SATOMS] )) )</a>
<a name="ln2045">        {</a>
<a name="ln2046">            bRelRac     = bRelativeStereo[iCurTautMode] || bRacemicStereo[iCurTautMode];</a>
<a name="ln2047">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_SP3S, szTag2, &amp;bAlways );</a>
<a name="ln2048">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2049">            if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2050">                tot_len = str_Sp3(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2051">                                  &amp;bOverflow, bOutType, TAUT_MODE, num_components, bRelRac,</a>
<a name="ln2052">                                  bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2053">                bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2054">            }</a>
<a name="ln2055"> </a>
<a name="ln2056">            if (str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ))</a>
<a name="ln2057">                goto exit_function;</a>
<a name="ln2058">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2059">        }</a>
<a name="ln2060">        else</a>
<a name="ln2061">        {</a>
<a name="ln2062">            if ( !bXml )</a>
<a name="ln2063">            {</a>
<a name="ln2064">                if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; ); /* sp3 */</a>
<a name="ln2065">            }</a>
<a name="ln2066">        }</a>
<a name="ln2067"> </a>
<a name="ln2068">        /* bStereoAbsInverted[iCurTautMode]  */</a>
<a name="ln2069"> </a>
<a name="ln2070">        /* if ( bStereoAbs[iCurTautMode]  ) */</a>
<a name="ln2071">        if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_m_SP3INV] )) )</a>
<a name="ln2072">        {</a>
<a name="ln2073">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_INVS, szTag2, &amp;bAlways );</a>
<a name="ln2074">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2075">            if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2076">                tot_len = str_StereoAbsInv(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln2077">                                           &amp;bOverflow, bOutType, num_components);</a>
<a name="ln2078">                bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2079">            }</a>
<a name="ln2080"> </a>
<a name="ln2081">            if (str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ))</a>
<a name="ln2082">                goto exit_function;</a>
<a name="ln2083">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2084">        }</a>
<a name="ln2085">        else</a>
<a name="ln2086">        {</a>
<a name="ln2087">            if ( !bXml )</a>
<a name="ln2088">            {</a>
<a name="ln2089">                if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; ); /* stereo-abs-inv */</a>
<a name="ln2090">            }</a>
<a name="ln2091">        }</a>
<a name="ln2092"> </a>
<a name="ln2093">        /* stereo type */</a>
<a name="ln2094">        /*if ( bRacemicStereo[iCurTautMode] || bRelativeStereo[iCurTautMode] || bStereoAbs[iCurTautMode] )*/</a>
<a name="ln2095">        if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_s_STYPE] )) )</a>
<a name="ln2096">        {</a>
<a name="ln2097">            const char *p_stereo = bRelativeStereo[iCurTautMode]? x_rel :</a>
<a name="ln2098">                                   bRacemicStereo[iCurTautMode] ? x_rac : x_abs;</a>
<a name="ln2099">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_TYPS, szTag2, &amp;bAlways );</a>
<a name="ln2100">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2101">            if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2102">                tot_len += MakeDelim( p_stereo, pStr + tot_len, nStrLen-tot_len, &amp;bOverflow);</a>
<a name="ln2103">                bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2104">            }</a>
<a name="ln2105">            if (str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ))</a>
<a name="ln2106">                goto exit_function;</a>
<a name="ln2107">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2108">        }</a>
<a name="ln2109">        if ( !bXml )</a>
<a name="ln2110">        {</a>
<a name="ln2111">            if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; );  /* no abs, inv or racemic stereo */</a>
<a name="ln2112">        }</a>
<a name="ln2113"> </a>
<a name="ln2114">        if ( bXml )</a>
<a name="ln2115">        {</a>
<a name="ln2116">            /* close stereo */</a>
<a name="ln2117">            ind -= inc;</a>
<a name="ln2118">            if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2119">                goto exit_function;</a>
<a name="ln2120">            inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2121">        }</a>
<a name="ln2122">    }</a>
<a name="ln2123">    else</a>
<a name="ln2124">    {</a>
<a name="ln2125">        if ( !bXml )</a>
<a name="ln2126">        {</a>
<a name="ln2127">            if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;////&quot; ); /* sp3, sp2, abs-inv, stereo.type */</a>
<a name="ln2128">        }</a>
<a name="ln2129">    }</a>
<a name="ln2130"> </a>
<a name="ln2131"> </a>
<a name="ln2132">    /****************************************************</a>
<a name="ln2133">     *</a>
<a name="ln2134">     *  Isotopic canonical results</a>
<a name="ln2135">     *</a>
<a name="ln2136">     ****************************************************/</a>
<a name="ln2137">    nCurINChISegment ++; /* switch from M to MI or from F to FI */</a>
<a name="ln2138"> </a>
<a name="ln2139">    /*if ( bIsotopic || !bSecondNonTautPass &amp;&amp; bHasIsoH )*/</a>
<a name="ln2140">    if ( INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_i_IATOMS] ) )</a>
<a name="ln2141">    {</a>
<a name="ln2142">        /*  isotopic #1:  composition -- atoms -- do not output in xml if empty */</a>
<a name="ln2143">        szGetTag( IdentLbl, nTag,  bTag1 = IL_ISOT | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2144">        if ( bXml )</a>
<a name="ln2145">        {</a>
<a name="ln2146">            str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2147">            inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2148">            ind += inc;</a>
<a name="ln2149">        }</a>
<a name="ln2150">        /* isotopic atoms without mobile H.</a>
<a name="ln2151">         * Fixed 2004-06-15: always output if not bXml. Note:</a>
<a name="ln2152">         * Previous condition if( bHasIsotopicAtoms[iCurTautMode] || bIsotopic &amp;&amp; !bXml)</a>
<a name="ln2153">         * did not optput /i in case of only mobile isotopic H</a>
<a name="ln2154">         */</a>
<a name="ln2155">        if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_i_IATOMS] )) )</a>
<a name="ln2156">        {</a>
<a name="ln2157">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_ATMS, szTag2, &amp;bAlways );</a>
<a name="ln2158">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2159">            /*if ( bHasIsotopicAtoms[iCurTautMode] )*/</a>
<a name="ln2160">            if ( INCHI_SEGM_FILL == nSegmAction )</a>
<a name="ln2161">            {</a>
<a name="ln2162">                tot_len2 = str_IsoAtoms(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2163">                                       &amp;bOverflow, bOutType, TAUT_MODE, num_components, bAbcNumbers,</a>
<a name="ln2164">                                       bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2165">                bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2166">            }</a>
<a name="ln2167">            else</a>
<a name="ln2168">            {</a>
<a name="ln2169">                tot_len2 = tot_len;</a>
<a name="ln2170">            }</a>
<a name="ln2171"> </a>
<a name="ln2172">            tot_len = tot_len2;</a>
<a name="ln2173">            if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2174">                goto exit_function;</a>
<a name="ln2175">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2176"> </a>
<a name="ln2177">        }</a>
<a name="ln2178"> </a>
<a name="ln2179">        /*  isotopic #1a:  composition -- exchangeable isotopic H (mobile H only) */</a>
<a name="ln2180">        /*if ( !bSecondNonTautPass &amp;&amp; bHasIsoH )*/</a>
<a name="ln2181">        if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_h_H_ATOMS] )) )</a>
<a name="ln2182">        {</a>
<a name="ln2183">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_XCGA, szTag2, &amp;bAlways );</a>
<a name="ln2184">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2185">            tot_len += MakeIsoHString( num_iso_H, pStr + tot_len, nStrLen-tot_len, TAUT_MODE, &amp;bOverflow);</a>
<a name="ln2186">            bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2187">            if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2188">                goto exit_function;</a>
<a name="ln2189">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2190">        }</a>
<a name="ln2191"> </a>
<a name="ln2192">        /***************************************************</a>
<a name="ln2193">         *</a>
<a name="ln2194">         *       Isotopic stereo</a>
<a name="ln2195">         *</a>
<a name="ln2196">         ***************************************************/</a>
<a name="ln2197"> </a>
<a name="ln2198">        /*if ( bIsotopicStereo[iCurTautMode] )*/</a>
<a name="ln2199">        if ( INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_b_SBONDS] ) ||</a>
<a name="ln2200">             INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_t_SATOMS] ) ||</a>
<a name="ln2201">             INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_m_SP3INV] ) ||</a>
<a name="ln2202">             INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_s_STYPE] ) )</a>
<a name="ln2203">        {</a>
<a name="ln2204">            /*  stereo */</a>
<a name="ln2205">            szGetTag( IdentLbl, nTag,  bTag2 = bTag1 | IL_STER, szTag2, &amp;bAlways );</a>
<a name="ln2206">            if ( bXml )</a>
<a name="ln2207">            {</a>
<a name="ln2208">                str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2209">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2210">                ind += inc;</a>
<a name="ln2211">            }</a>
<a name="ln2212"> </a>
<a name="ln2213">            /************************</a>
<a name="ln2214">              isotopic #2:  sp2</a>
<a name="ln2215">             ************************/</a>
<a name="ln2216">            /*if ( bIsotopicStereoSp2[iCurTautMode]  )*/</a>
<a name="ln2217">            if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_b_SBONDS] )) )</a>
<a name="ln2218">            {</a>
<a name="ln2219">                szGetTag( IdentLbl, nTag,  bTag3 = bTag2 | IL_DBND, szTag3, &amp;bAlways );</a>
<a name="ln2220">                tot_len = str_LineStart( szTag3, NULL, 0, pStr, ind );</a>
<a name="ln2221">                if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2222">                    tot_len = str_IsoSp2(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2223">                                         &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2224">                                         bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2225">                    bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2226">                }</a>
<a name="ln2227">                if ( str_LineEnd( szTag3, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2228">                    goto exit_function;</a>
<a name="ln2229">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2230">            }</a>
<a name="ln2231">            else</a>
<a name="ln2232">            {</a>
<a name="ln2233">                if ( !bXml )</a>
<a name="ln2234">                {</a>
<a name="ln2235">                    if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; ); /* iso sp2 */</a>
<a name="ln2236">                }</a>
<a name="ln2237">            }</a>
<a name="ln2238"> </a>
<a name="ln2239">            /************************</a>
<a name="ln2240">              isotopic #3:  sp3</a>
<a name="ln2241">             ************************/</a>
<a name="ln2242">            /*if ( bIsotopicStereoSp3[iCurTautMode]  )*/</a>
<a name="ln2243">            if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_t_SATOMS] )) )</a>
<a name="ln2244">            {</a>
<a name="ln2245">                bRelRac = bIsotopicRelativeStereo[iCurTautMode] || bIsotopicRacemicStereo[iCurTautMode];</a>
<a name="ln2246">                szGetTag( IdentLbl, nTag,  bTag3 = bTag2 | IL_SP3S, szTag3, &amp;bAlways );</a>
<a name="ln2247">                tot_len = str_LineStart( szTag3, NULL, 0, pStr, ind );</a>
<a name="ln2248">                if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2249">                    tot_len = str_IsoSp3(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2250">                                         &amp;bOverflow, bOutType, TAUT_MODE, num_components, bRelRac,</a>
<a name="ln2251">                                         bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2252">                    bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2253">                }</a>
<a name="ln2254">                if ( str_LineEnd( szTag3, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2255">                    goto exit_function;</a>
<a name="ln2256">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2257">            } else</a>
<a name="ln2258">            {</a>
<a name="ln2259">                if ( !bXml )</a>
<a name="ln2260">                {</a>
<a name="ln2261">                    if ( bPlainTextTags == 1 )</a>
<a name="ln2262">                        inchi_ios_print( output_file, &quot;/&quot; ); /* iso-sp3 */</a>
<a name="ln2263">                }</a>
<a name="ln2264">            }</a>
<a name="ln2265"> </a>
<a name="ln2266">            /* isotopic #4: abs inverted */</a>
<a name="ln2267">            if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_m_SP3INV] )) )</a>
<a name="ln2268">            {</a>
<a name="ln2269">                szGetTag( IdentLbl, nTag,  bTag3 = bTag2 | IL_INVS, szTag3, &amp;bAlways );</a>
<a name="ln2270">                tot_len = str_LineStart( szTag3, NULL, 0, pStr, ind );</a>
<a name="ln2271">                if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2272">                    tot_len = str_IsoStereoAbsInv(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln2273">                                                  &amp;bOverflow, bOutType, num_components);</a>
<a name="ln2274">                    bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2275">                }</a>
<a name="ln2276">                if ( str_LineEnd( szTag3, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2277">                    goto exit_function;</a>
<a name="ln2278">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2279">            }</a>
<a name="ln2280">            else</a>
<a name="ln2281">            {</a>
<a name="ln2282">                if ( !bXml )</a>
<a name="ln2283">                {</a>
<a name="ln2284">                    if ( bPlainTextTags == 1 )</a>
<a name="ln2285">                        inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2286">                }</a>
<a name="ln2287">            }</a>
<a name="ln2288"> </a>
<a name="ln2289">            /* isotopic #5: stereo type. Do not output if it has already been output in non-iso */</a>
<a name="ln2290">            if ( (nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_s_STYPE] )) )</a>
<a name="ln2291">            {</a>
<a name="ln2292">                const char *p_stereo = bIsotopicRelativeStereo[iCurTautMode]? x_rel :</a>
<a name="ln2293">                                       bIsotopicRacemicStereo[iCurTautMode] ? x_rac : x_abs;</a>
<a name="ln2294">                szGetTag( IdentLbl, nTag,  bTag3 = bTag2 | IL_TYPS, szTag3, &amp;bAlways );</a>
<a name="ln2295">                tot_len = str_LineStart( szTag3, NULL, 0, pStr, ind );</a>
<a name="ln2296">                if ( INCHI_SEGM_FILL == nSegmAction ) {</a>
<a name="ln2297">                    tot_len += MakeDelim( p_stereo, pStr + tot_len, nStrLen-tot_len, &amp;bOverflow);</a>
<a name="ln2298">                    bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2299">                }</a>
<a name="ln2300">                if ( str_LineEnd( szTag3, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2301">                    goto exit_function;</a>
<a name="ln2302">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2303">            }</a>
<a name="ln2304">            if ( !bXml )</a>
<a name="ln2305">            {</a>
<a name="ln2306">                if ( bPlainTextTags == 1 )</a>
<a name="ln2307">                    inchi_ios_print( output_file, &quot;/&quot; );  /* no abs, inv or racemic stereo */</a>
<a name="ln2308">            }</a>
<a name="ln2309">            if ( bXml )</a>
<a name="ln2310">            {</a>
<a name="ln2311">                /************************</a>
<a name="ln2312">                  close isotopic stereo</a>
<a name="ln2313">                 ************************/</a>
<a name="ln2314">                ind -= inc;</a>
<a name="ln2315">                if ( str_LineEnd( szTag2, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2316">                    goto exit_function;</a>
<a name="ln2317">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2318">            }</a>
<a name="ln2319">        }</a>
<a name="ln2320">        else</a>
<a name="ln2321">        {</a>
<a name="ln2322">            if ( !bXml )</a>
<a name="ln2323">            {</a>
<a name="ln2324">                /* no isotopic stereo */</a>
<a name="ln2325">                if ( bPlainTextTags == 1 )</a>
<a name="ln2326">                    inchi_ios_print( output_file, &quot;////&quot; ); /* sp3, sp2, abs-inv, stereo.type */</a>
<a name="ln2327">            }</a>
<a name="ln2328">        }</a>
<a name="ln2329"> </a>
<a name="ln2330">        /*  close isotopic */</a>
<a name="ln2331">        if ( bXml )</a>
<a name="ln2332">        {</a>
<a name="ln2333">            ind -= inc;</a>
<a name="ln2334">            if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2335">                goto exit_function;</a>
<a name="ln2336">            inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2337">        }</a>
<a name="ln2338">    }</a>
<a name="ln2339">    else</a>
<a name="ln2340">    {</a>
<a name="ln2341">        if ( !bXml )</a>
<a name="ln2342">        {</a>
<a name="ln2343">            if ( bPlainTextTags == 1 )</a>
<a name="ln2344">                inchi_ios_print( output_file, &quot;///&quot; ); /* isotopic composition, sp2, sp3 */</a>
<a name="ln2345">            if ( bPlainTextTags == 1 )</a>
<a name="ln2346">                inchi_ios_print( output_file, &quot;//&quot; );   /* inv or racemic stereo */</a>
<a name="ln2347">        }</a>
<a name="ln2348">    }</a>
<a name="ln2349"> </a>
<a name="ln2350">#if ( CANON_FIXH_TRANS == 1 )</a>
<a name="ln2351">    if ( bOutType == OUT_NONTAUT &amp;&amp; bOutputType == OUT_TN &amp;&amp; bSecondNonTautPass &amp;&amp;</a>
<a name="ln2352">         INCHI_SEGM_FILL == INChI_SegmentAction( sDifSegs[DIFL_F][DIFS_o_TRANSP] ))</a>
<a name="ln2353">    {</a>
<a name="ln2354">        /* find and print non-tautomeric components transposition, if non-trivial */</a>
<a name="ln2355">        AT_NUMB *nTrans_n, *nTrans_s;</a>
<a name="ln2356"> </a>
<a name="ln2357">        if ( 0 &lt; bin_AuxTautTrans(pINChISort, pINChISort2, &amp;nTrans_n, &amp;nTrans_s, bOutType,  num_components) )</a>
<a name="ln2358">        {</a>
<a name="ln2359">            /* a non-trivial transposition does exist; output start tag */</a>
<a name="ln2360">            szGetTag( IdentLbl, nTag,  bTag1 = IL_TRNS | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2361">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2362">            /* print the transposition, cycle after cycle */</a>
<a name="ln2363">            tot_len = str_AuxTautTrans(nTrans_n, nTrans_s, pStr, nStrLen, tot_len,</a>
<a name="ln2364">                                       &amp;bOverflow, TAUT_MODE, num_components);</a>
<a name="ln2365">            bNonTautIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2366">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2367">                goto exit_function;</a>
<a name="ln2368">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2369">             /* detected transposition */</a>
<a name="ln2370">            *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_TRANSPOS_BAS :</a>
<a name="ln2371">                                                            FLAG_SORT_PRINT_TRANSPOS_REC;</a>
<a name="ln2372">        }</a>
<a name="ln2373">        else</a>
<a name="ln2374">        {</a>
<a name="ln2375">            if ( !bXml )</a>
<a name="ln2376">            {</a>
<a name="ln2377">                if ( bPlainTextTags == 1 )</a>
<a name="ln2378">                    inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2379">            }</a>
<a name="ln2380">        }</a>
<a name="ln2381">    }</a>
<a name="ln2382">#endif</a>
<a name="ln2383"> </a>
<a name="ln2384"> </a>
<a name="ln2385">    /**************************************************************</a>
<a name="ln2386">      At this point the INChI part of the output has been done.</a>
<a name="ln2387">      If this INChI is tautomeric and non-tautomeric results exist</a>
<a name="ln2388">      then we need to output non-tautomeric data:</a>
<a name="ln2389">         fixed H,</a>
<a name="ln2390">         stereo,</a>
<a name="ln2391">         isotopic</a>
<a name="ln2392">         isotopic stereo</a>
<a name="ln2393">    ***************************************************************/</a>
<a name="ln2394">    if ( bOutType == OUT_TN &amp;&amp; !bSecondNonTautPass &amp;&amp;</a>
<a name="ln2395">         bNonTautIsIdenticalToTaut &amp;&amp; bTautomeric &amp;&amp; bNonTautomeric )</a>
<a name="ln2396">    {</a>
<a name="ln2397">            /* Fixed-H layer is empty in the Identifier */</a>
<a name="ln2398">            *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :</a>
<a name="ln2399">                                                            FLAG_SORT_PRINT_NO_NFIX_H_REC;</a>
<a name="ln2400">            *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :</a>
<a name="ln2401">                                                            FLAG_SORT_PRINT_NO_IFIX_H_REC;</a>
<a name="ln2402">    }</a>
<a name="ln2403"> </a>
<a name="ln2404">    if ( bOutType == OUT_TN &amp;&amp; !bNonTautIsIdenticalToTaut /* added 2004-10-04 Fix16 */</a>
<a name="ln2405">#ifdef OLD_ITEM_DISCOVERY</a>
<a name="ln2406">                            &amp;&amp; bTautomeric &amp;&amp; bNonTautomeric</a>
<a name="ln2407">#endif</a>
<a name="ln2408">                            &amp;&amp; INChI_SegmentAction( sDifSegs[DIFL_F][DIFS_f_FORMULA] )</a>
<a name="ln2409">                       /* special case: removed isolated H(+): */</a>
<a name="ln2410">                       /* || iCurTautMode == TAUT_YES &amp;&amp; num_comp[TAUT_YES] &lt; num_comp[TAUT_NON] &amp;&amp;</a>
<a name="ln2411">                             0 &lt; num_comp[TAUT_NON]*/</a>
<a name="ln2412">       )</a>
<a name="ln2413">    {</a>
<a name="ln2414">        /* add the second (non-tautomeric) output */</a>
<a name="ln2415">        bOutType     = OUT_NONTAUT;    /* pick up only non-tautomeric representation of tautomeric */</a>
<a name="ln2416">        iCurTautMode = TAUT_NON;</a>
<a name="ln2417">        pINChISort    = pINChISortTautAndNonTaut[TAUT_NON];</a>
<a name="ln2418">        bSecondNonTautPass = 1;</a>
<a name="ln2419">        nCurINChISegment   = DIFL_F;</a>
<a name="ln2420">        num_components = num_comp[iCurTautMode]; /* number of components could change due to removal of isolated H(+) from tautomeric */</a>
<a name="ln2421">        bFhTag = IL_FIXH;</a>
<a name="ln2422">        szGetTag( IdentLbl, nTag,  bTag1 = bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2423">        if ( bXml )</a>
<a name="ln2424">        {</a>
<a name="ln2425">            /* open non-tautomeric */</a>
<a name="ln2426">            str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2427">            inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2428">            ind += inc;</a>
<a name="ln2429">        }</a>
<a name="ln2430">        /***** constitution non-taut: dot-disconnected Hill formulas: &lt;formula&gt; -- only if different */</a>
<a name="ln2431">        szGetTag( IdentLbl, nTag,  bTag1 = IL_FMLF | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2432">        tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2433">        nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_f_FORMULA] );</a>
<a name="ln2434">        if ( INCHI_SEGM_FILL == nSegmAction )</a>
<a name="ln2435">        {</a>
<a name="ln2436">            tot_len2 = str_HillFormula2(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2437">                                      &amp;bOverflow, bOutType, num_components, bUseMulipliers);</a>
<a name="ln2438">            bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2439">        }</a>
<a name="ln2440">        else</a>
<a name="ln2441">        {</a>
<a name="ln2442">            tot_len2 = tot_len;</a>
<a name="ln2443">        }</a>
<a name="ln2444">        tot_len = tot_len2;</a>
<a name="ln2445">        if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2446">            goto exit_function;</a>
<a name="ln2447">        inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2448"> </a>
<a name="ln2449">        nSegmAction = INChI_SegmentAction( sDifSegs[nCurINChISegment][DIFS_h_H_ATOMS] );</a>
<a name="ln2450">        if ( INCHI_SEGM_FILL == nSegmAction )</a>
<a name="ln2451">        {</a>
<a name="ln2452">            szGetTag( IdentLbl, nTag,  bTag1 = IL_HFIX | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2453">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind ); /* open H-fixed */</a>
<a name="ln2454">            /* output the second non-tautomeric item: fixed H -- do not output in xml if empty */</a>
<a name="ln2455">            tot_len2 = str_FixedH_atoms(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln2456">                                       &amp;bOverflow, bOutType, ATOM_MODE, num_components, bUseMulipliers);</a>
<a name="ln2457">            tot_len = tot_len2;</a>
<a name="ln2458">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -nSegmAction, bPlainTextTags ) )</a>
<a name="ln2459">                goto exit_function;</a>
<a name="ln2460">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2461">            bNonTautNonIsoIdentifierNotEmpty += bSecondNonTautPass;</a>
<a name="ln2462">        }</a>
<a name="ln2463">        goto repeat_INChI_output;</a>
<a name="ln2464">    }</a>
<a name="ln2465">    else</a>
<a name="ln2466">    {</a>
<a name="ln2467">        if ( bOutType == OUT_NONTAUT &amp;&amp; bOutputType == OUT_TN &amp;&amp; bSecondNonTautPass /* &amp;&amp; bTautomeric &amp;&amp; bNonTautomeric*/ )</a>
<a name="ln2468">        {</a>
<a name="ln2469">            /* the second (non-taut) output has been done; restore variables */</a>
<a name="ln2470">            bOutType           = OUT_TN;</a>
<a name="ln2471">            iCurTautMode       = TAUT_YES;</a>
<a name="ln2472">            pINChISort         = pINChISortTautAndNonTaut[TAUT_YES];</a>
<a name="ln2473">            bSecondNonTautPass = 0;</a>
<a name="ln2474">            num_components     = num_comp[iCurTautMode];</a>
<a name="ln2475">            if ( !bNonTautNonIsoIdentifierNotEmpty )</a>
<a name="ln2476">            {</a>
<a name="ln2477">                /* Fixed-H layer is empty in the Identifier */</a>
<a name="ln2478">                *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :</a>
<a name="ln2479">                                                            FLAG_SORT_PRINT_NO_NFIX_H_REC;</a>
<a name="ln2480">            }</a>
<a name="ln2481">            if ( !bNonTautIsoIdentifierNotEmpty )</a>
<a name="ln2482">            {</a>
<a name="ln2483">                /* Fixed-H layer is empty in the Identifier */</a>
<a name="ln2484">                *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :</a>
<a name="ln2485">                                                                FLAG_SORT_PRINT_NO_IFIX_H_REC;</a>
<a name="ln2486">            }</a>
<a name="ln2487">            if ( bXml )</a>
<a name="ln2488">            {</a>
<a name="ln2489">                /*  close non-tautomeric */</a>
<a name="ln2490">                ind -= inc;</a>
<a name="ln2491">                szGetTag( IdentLbl, nTag,  bTag1 = bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2492">                if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2493">                    goto exit_function;</a>
<a name="ln2494">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2495">            }</a>
<a name="ln2496">            bFhTag             = 0;</a>
<a name="ln2497">        }</a>
<a name="ln2498">    }</a>
<a name="ln2499"> </a>
<a name="ln2500"> </a>
<a name="ln2501">    /************************************************</a>
<a name="ln2502">     * output INChI     of the reconnected structure *</a>
<a name="ln2503">     ************************************************/</a>
<a name="ln2504">    bEmbeddedOutputCalled = 0;</a>
<a name="ln2505">    if ( bDisconnectedCoord &amp;&amp; INCHI_BAS == iINChI &amp;&amp;</a>
<a name="ln2506">         (bINChIOutputOptions &amp; INCHI_OUT_EMBED_REC) &amp;&amp; num_components2[INCHI_REC] )</a>
<a name="ln2507">    {</a>
<a name="ln2508">        int nRet;</a>
<a name="ln2509">        bEmbeddedOutputCalled = 1;</a>
<a name="ln2510"> </a>
<a name="ln2511">        if ( !bXml )</a>
<a name="ln2512">        {</a>
<a name="ln2513">             /* output blank line before /R: in case of bPlainTextCommnts=1 */</a>
<a name="ln2514">            inchi_ios_print( output_file, &quot;%s&quot;, pLF );</a>
<a name="ln2515">        }</a>
<a name="ln2516">        /* end of disconnected INChI output */</a>
<a name="ln2517"> </a>
<a name="ln2518">        nRet = OutputINChI1( pStr, nStrLen,</a>
<a name="ln2519">                             pINChISortTautAndNonTaut2,</a>
<a name="ln2520">                             INCHI_REC, NULL,</a>
<a name="ln2521">                             0 /*bDisconnectedCoord*/, bOutputType,</a>
<a name="ln2522">                             bINChIOutputOptions | INCHI_OUT_NO_AUX_INFO,</a>
<a name="ln2523">                             bXml, bAbcNumbers, bCtPredecessors, bNoStructLabels,</a>
<a name="ln2524">                             num_components2, num_non_taut2, num_taut2,</a>
<a name="ln2525">                             output_file, log_file,</a>
<a name="ln2526">                             num_input_struct,</a>
<a name="ln2527">                             szSdfLabel, szSdfValue, lSdfId,</a>
<a name="ln2528">                             pSortPrintINChIFlags,</a>
<a name="ln2529">                             save_opt_bits);</a>
<a name="ln2530">        if ( !nRet )</a>
<a name="ln2531">            goto exit_function; /* error */</a>
<a name="ln2532">    }</a>
<a name="ln2533"> </a>
<a name="ln2534">    if ( bXml )</a>
<a name="ln2535">    {</a>
<a name="ln2536">        /*  close INChI identifier (basic) */</a>
<a name="ln2537">        ind -= inc;</a>
<a name="ln2538">        if ( str_LineEnd( x_basic, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2539">            goto exit_function;</a>
<a name="ln2540">        inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2541">    }</a>
<a name="ln2542">    else</a>
<a name="ln2543">    {</a>
<a name="ln2544">        /* save InChI creation options if requested ...*/</a>
<a name="ln2545">        if ( !bEmbeddedOutputCalled)</a>
<a name="ln2546">        {</a>
<a name="ln2547">            if ( bINChIOutputOptions &amp; INCHI_OUT_SAVEOPT )</a>
<a name="ln2548">            {</a>
<a name="ln2549">                /* ... and not std-InChI output */</a>
<a name="ln2550">                if ( 0 == (bINChIOutputOptions &amp; INCHI_OUT_STDINCHI) )</a>
<a name="ln2551">                {</a>
<a name="ln2552">                    char let1, let2;</a>
<a name="ln2553">                    GetSaveOptLetters(save_opt_bits, &amp;let1, &amp;let2);</a>
<a name="ln2554">                    inchi_ios_print( output_file, &quot;\\%c%c&quot;, let1, let2 );</a>
<a name="ln2555">                }</a>
<a name="ln2556">            }</a>
<a name="ln2557">        }</a>
<a name="ln2558"> </a>
<a name="ln2559">        if ( !bEmbeddedOutputCalled &amp;&amp; !bPlainTextCommnts )</a>
<a name="ln2560">        { /* plain text comment earlier ended with LF */</a>
<a name="ln2561">            inchi_ios_print( output_file, &quot;%s%s&quot;,</a>
<a name="ln2562">                                (!num_components2[0] &amp;&amp; !num_components2[1])? &quot;//&quot;:&quot;&quot;, /* empty InChI=// */</a>
<a name="ln2563">                                (bINChIOutputOptions &amp; INCHI_OUT_NO_AUX_INFO)? &quot;\n&quot; : pTAB );</a>
<a name="ln2564">        /* end of INChI= output */</a>
<a name="ln2565">        }</a>
<a name="ln2566"> </a>
<a name="ln2567"> </a>
<a name="ln2568">    }</a>
<a name="ln2569"> </a>
<a name="ln2570">output_aux_info:</a>
<a name="ln2571"> </a>
<a name="ln2572">    bFhTag = 0;</a>
<a name="ln2573"> </a>
<a name="ln2574">    if( !(bINChIOutputOptions &amp; INCHI_OUT_NO_AUX_INFO) )</a>
<a name="ln2575">    {</a>
<a name="ln2576">        /* output aux info */</a>
<a name="ln2577"> </a>
<a name="ln2578">        /*************************************************************</a>
<a name="ln2579">         *</a>
<a name="ln2580">         *   Aux info non-isotopic</a>
<a name="ln2581">         *</a>
<a name="ln2582">         *************************************************************/</a>
<a name="ln2583"> </a>
<a name="ln2584">        num_components = num_comp[iCurTautMode];</a>
<a name="ln2585">        if ( bXml )</a>
<a name="ln2586">        {</a>
<a name="ln2587">            /*  aux. info header */</a>
<a name="ln2588">            /*  empty line if INChI output has been printed */</a>
<a name="ln2589">            if ( !(bINChIOutputOptions &amp; INCHI_OUT_ONLY_AUX_INFO) )</a>
<a name="ln2590">            {</a>
<a name="ln2591">                inchi_ios_print( output_file, &quot;\n&quot; );</a>
<a name="ln2592">            }</a>
<a name="ln2593">            /*  basic.aux-info title, version */</a>
<a name="ln2594">            tot_len = sprintf(pStr, &quot;%s&lt;%s %s=\&quot;%s\&quot;&quot;,</a>
<a name="ln2595">                SP(ind), x_aux_basic, x_ver, x_curr_ver );</a>
<a name="ln2596">            if ( INCHI_REC == iINChI || (INCHI_BAS == iINChI &amp;&amp; bDisconnectedCoord) )</a>
<a name="ln2597">            {</a>
<a name="ln2598">                tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%d\&quot;&quot;, x_reconnected, iINChI );</a>
<a name="ln2599">            }</a>
<a name="ln2600">            if ( bAbcNumbers )</a>
<a name="ln2601">            {</a>
<a name="ln2602">                /*  type */</a>
<a name="ln2603">                const char *pNumber = x_type_short;</a>
<a name="ln2604">                tot_len += sprintf(pStr+tot_len, &quot; %s=\&quot;%s\&quot;&quot;, x_type, pNumber);</a>
<a name="ln2605">            }</a>
<a name="ln2606"> </a>
<a name="ln2607">            sprintf(pStr+tot_len,&quot;&gt;&quot;);</a>
<a name="ln2608">            inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2609">            ind += inc;</a>
<a name="ln2610">            if ( !(bINChIOutputOptions &amp; INCHI_OUT_ONLY_AUX_INFO) )</a>
<a name="ln2611">            {</a>
<a name="ln2612">                /*  comment */</a>
<a name="ln2613">                tot_len = sprintf( pStr, &quot;%s&lt;%s&gt;&quot;, SP(ind), x_aux_comm );</a>
<a name="ln2614">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2615">            }</a>
<a name="ln2616">        }</a>
<a name="ln2617">        else</a>
<a name="ln2618">        {</a>
<a name="ln2619">            if ( INCHI_BAS == iINChI )</a>
<a name="ln2620">            {</a>
<a name="ln2621">                tot_len = sprintf( pStr, &quot;AuxInfo=&quot; ); /* in wINChI window, separate INChI: from AuxInfo: with blank line */</a>
<a name="ln2622">                inchi_ios_print( output_file, &quot;%s%s%s&quot;,</a>
<a name="ln2623">                                          /* blank line before AuxInfo in winchi window unless it is an annotation */</a>
<a name="ln2624">                                          (bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW) ? &quot;\n&quot;:&quot;&quot;,</a>
<a name="ln2625">                                          pStr,</a>
<a name="ln2626">                                          pLF);</a>
<a name="ln2627">                szGetTag( AuxLbl, nTag,  bTag1 = AL_VERS, szTag1, &amp;bAlways );</a>
<a name="ln2628">                tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2629">                tot_len += sprintf(pStr + tot_len, &quot;%s&quot;, x_curr_ver);</a>
<a name="ln2630">                /* avoid leading slash in plain output */</a>
<a name="ln2631">                if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2632">                    goto exit_function;</a>
<a name="ln2633">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2634">            }</a>
<a name="ln2635">            else</a>
<a name="ln2636">            {</a>
<a name="ln2637">                if ( INCHI_REC == iINChI )</a>
<a name="ln2638">                {</a>
<a name="ln2639">                    szGetTag( AuxLbl, nTag,  bTag1 = AL_REC_, szTag1, &amp;bAlways );</a>
<a name="ln2640">                    inchi_ios_print( output_file, &quot;%s%s&quot;, szTag1, pLF );</a>
<a name="ln2641">                }</a>
<a name="ln2642">            }</a>
<a name="ln2643"> </a>
<a name="ln2644">        }</a>
<a name="ln2645">        /* normalization type */</a>
<a name="ln2646">        if ( num_components2[0] || num_components2[1] )</a>
<a name="ln2647">        {</a>
<a name="ln2648">            szGetTag( AuxLbl, nTag,  bTag1 = AL_NORM, szTag1, &amp;bAlways );</a>
<a name="ln2649">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2650">            tot_len += sprintf( pStr + tot_len, &quot;%d&quot;, (bTautomeric &amp;&amp; bTautomericOutputAllowed)? bTautomeric : 0);</a>
<a name="ln2651">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2652">                goto exit_function;</a>
<a name="ln2653">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2654">        }</a>
<a name="ln2655"> </a>
<a name="ln2656"> </a>
<a name="ln2657"> </a>
<a name="ln2658">repeat_INChI_Aux_output:</a>
<a name="ln2659"> </a>
<a name="ln2660">        /**************************************************************</a>
<a name="ln2661">         *   Original atom numbers in order of canonical numbers</a>
<a name="ln2662">         **************************************************************/</a>
<a name="ln2663">        if ( num_components2[0] || num_components2[1] )</a>
<a name="ln2664">        {</a>
<a name="ln2665">            szGetTag( AuxLbl, nTag,  bTag1 = (bSecondNonTautPass? AL_FIXN : AL_ANBR) | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2666">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2667">            /* original numbering output */</a>
<a name="ln2668">            tot_len = str_AuxNumb(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2669">                                  &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2670">                                  bSecondNonTautPass, bOmitRepetitions);</a>
<a name="ln2671"> </a>
<a name="ln2672">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2673">                goto exit_function;</a>
<a name="ln2674">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2675">        }</a>
<a name="ln2676">        /**********************************************</a>
<a name="ln2677">         *   Symmetry numbers (constit. equivalence)</a>
<a name="ln2678">         **********************************************/</a>
<a name="ln2679">        if ( bAtomEqu[iCurTautMode] )</a>
<a name="ln2680">        {</a>
<a name="ln2681">            /*  aux equ atoms */</a>
<a name="ln2682">            /* 1. Compare to tautomeric equivalence (in case of second, non-taut, pass only) */</a>
<a name="ln2683">            /* 2. Compare to the previous component if (1) failed to find equivalence */</a>
<a name="ln2684">            szGetTag( AuxLbl, nTag,  bTag1 = AL_AEQU | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2685">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2686">            tot_len = str_AuxEqu(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2687">                                 &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2688">                                 bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2689"> </a>
<a name="ln2690">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2691">                goto exit_function;</a>
<a name="ln2692">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2693">        }</a>
<a name="ln2694">        else</a>
<a name="ln2695">        {</a>
<a name="ln2696">            if ( !bXml )</a>
<a name="ln2697">            {</a>
<a name="ln2698">                if ( bPlainTextTags == 1 )</a>
<a name="ln2699">                    inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2700">            }</a>
<a name="ln2701">        }</a>
<a name="ln2702">        /*****************************************************</a>
<a name="ln2703">         *    Tautomeric groups equivalence</a>
<a name="ln2704">         *****************************************************/</a>
<a name="ln2705">        if ( bTautomericOutputAllowed &amp;&amp; bTautomeric &amp;&amp; bTautEqu[iCurTautMode] &amp;&amp; !bSecondNonTautPass )</a>
<a name="ln2706">        {</a>
<a name="ln2707">            /*****************************************************</a>
<a name="ln2708">             *    Tautomeric groups constitutional equivalence</a>
<a name="ln2709">             */</a>
<a name="ln2710">            /*  aux tgroup equ */</a>
<a name="ln2711">            szGetTag( AuxLbl, nTag,  bTag1 = AL_GEQU | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2712">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2713">            tot_len = str_AuxTgroupEqu(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln2714">                                       &amp;bOverflow, bOutType, TAUT_MODE,</a>
<a name="ln2715">                                       num_components, bUseMulipliers);</a>
<a name="ln2716">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2717">                goto exit_function;</a>
<a name="ln2718">            inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2719">        }</a>
<a name="ln2720">        else</a>
<a name="ln2721">        {</a>
<a name="ln2722">            if ( !bXml &amp;&amp; bTautomericOutputAllowed &amp;&amp; bTautomeric )</a>
<a name="ln2723">            {</a>
<a name="ln2724">                if ( bPlainTextTags == 1 )</a>
<a name="ln2725">                    inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2726">            }</a>
<a name="ln2727">        }</a>
<a name="ln2728"> </a>
<a name="ln2729">        /****************************************************</a>
<a name="ln2730">         * Inverted stereo -- sp3 only + canonical numbering</a>
<a name="ln2731">         ****************************************************/</a>
<a name="ln2732">        if ( bInvStereo[iCurTautMode] )</a>
<a name="ln2733">        {</a>
<a name="ln2734">            szGetTag( AuxLbl, nTag,  bTag1 = AL_STER | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2735">            if ( bXml )</a>
<a name="ln2736">            {</a>
<a name="ln2737">                /***************************</a>
<a name="ln2738">                     inv stereo start  tag</a>
<a name="ln2739">                ****************************/</a>
<a name="ln2740">                str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2741">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2742">                ind += inc;</a>
<a name="ln2743">            }</a>
<a name="ln2744">            /****************************</a>
<a name="ln2745">                 inverted sp3 start tag</a>
<a name="ln2746">            *****************************/</a>
<a name="ln2747">            szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_SP3I, szTag2, &amp;bAlways );</a>
<a name="ln2748">            tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2749">            tot_len = str_AuxInvSp3(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2750">                                    &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2751">                                    bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2752">            if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2753">                goto exit_function;</a>
<a name="ln2754">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2755"> </a>
<a name="ln2756">            /*************************************</a>
<a name="ln2757">              inverted sp3  canonical numbering</a>
<a name="ln2758">            **************************************/</a>
<a name="ln2759">            if ( bInvStereoOrigNumb[iCurTautMode] )</a>
<a name="ln2760">            {</a>
<a name="ln2761">                szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_SP3N, szTag2, &amp;bAlways );</a>
<a name="ln2762">                tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2763">                tot_len = str_AuxInvSp3Numb(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2764">                                            &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2765">                                            bSecondNonTautPass, bOmitRepetitions);</a>
<a name="ln2766">                if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2767">                    goto exit_function;</a>
<a name="ln2768">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2769">            }</a>
<a name="ln2770">            else</a>
<a name="ln2771">            {</a>
<a name="ln2772">                if ( !bXml )</a>
<a name="ln2773">                {</a>
<a name="ln2774">                    if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2775">                }</a>
<a name="ln2776">            }</a>
<a name="ln2777"> </a>
<a name="ln2778">            if ( bXml )</a>
<a name="ln2779">            {</a>
<a name="ln2780">                /* close sp3 inv */</a>
<a name="ln2781">                ind -= inc;</a>
<a name="ln2782">                if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2783">                    goto exit_function;</a>
<a name="ln2784">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2785">            }</a>
<a name="ln2786">        }</a>
<a name="ln2787">        else</a>
<a name="ln2788">        {</a>
<a name="ln2789">            if ( !bXml )</a>
<a name="ln2790">            {</a>
<a name="ln2791">                if ( bPlainTextTags == 1 )</a>
<a name="ln2792">                    inchi_ios_print( output_file, &quot;//&quot; );</a>
<a name="ln2793">            } /* Inverted stereo -- sp3 only + canonical numbering */</a>
<a name="ln2794">        }</a>
<a name="ln2795"> </a>
<a name="ln2796"> </a>
<a name="ln2797">        /* omitted undefined/unknown non-isotopic stereo */</a>
<a name="ln2798">        if ( bXml )</a>
<a name="ln2799">        {</a>
<a name="ln2800">            if ( bIgn_UU_Sp2[iCurTautMode] || bIgn_UU_Sp3[iCurTautMode] )</a>
<a name="ln2801">            {</a>
<a name="ln2802">                /* &lt;stereo omit_undef_dbond=&quot;1&quot; omit_undef_sp3=&quot;1&quot;/&gt; */</a>
<a name="ln2803">                szGetTag( IdentLbl, nTag,  bTag1 = IL_STER, szTag1, &amp;bAlways );</a>
<a name="ln2804">                tot_len = PrintXmlStartTag( pStr, ind, 3, szTag1,</a>
<a name="ln2805">                                 (bIgn_UU_Sp2[iCurTautMode])? x_ign_uu_sp2 : NULL, 1,</a>
<a name="ln2806">                                 (bIgn_UU_Sp3[iCurTautMode])? x_ign_uu_sp3 : NULL, 1,</a>
<a name="ln2807">                                 NULL, 0, NULL, 0, NULL, 0, NULL, 0 );</a>
<a name="ln2808">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2809">            }</a>
<a name="ln2810">        }</a>
<a name="ln2811"> </a>
<a name="ln2812">        /***************************************************************</a>
<a name="ln2813">         *</a>
<a name="ln2814">         *  Additional information: charges, radicals,</a>
<a name="ln2815">         *                          special valences, coordinates</a>
<a name="ln2816">         *</a>
<a name="ln2817">         ***************************************************************/</a>
<a name="ln2818">        /**************************************************************</a>
<a name="ln2819">         *</a>
<a name="ln2820">         *   Aux info isotopic</a>
<a name="ln2821">         *</a>
<a name="ln2822">         **************************************************************/</a>
<a name="ln2823">repeat_INChI_Aux_Iso_output:</a>
<a name="ln2824">        /* if InChI Fixed-H isotopic is empty then do not output corresponding AuxInfo */</a>
<a name="ln2825">        i =  bSecondNonTautPass &amp;&amp;</a>
<a name="ln2826">             (*pSortPrintINChIFlags &amp; ((INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :</a>
<a name="ln2827">                                                              FLAG_SORT_PRINT_NO_IFIX_H_REC ));</a>
<a name="ln2828"> </a>
<a name="ln2829">        if ( bIsotopic &amp;&amp; !i &amp;&amp;</a>
<a name="ln2830">                          (bIsotopicOrigNumb[iCurTautMode] ||</a>
<a name="ln2831">                           bIsotopicAtomEqu[iCurTautMode] ||</a>
<a name="ln2832">                           (bTautomericOutputAllowed &amp;&amp; bTautomeric &amp;&amp; bIsotopicTautEqu[iCurTautMode]) ||</a>
<a name="ln2833">                           bInvIsotopicStereo[iCurTautMode] ||</a>
<a name="ln2834">                           (bXml &amp;&amp; ( bIgn_UU_Sp3_Iso[iCurTautMode] || bIgn_UU_Sp2_Iso[iCurTautMode] )) ) )</a>
<a name="ln2835">        {</a>
<a name="ln2836">            /*************************************/</a>
<a name="ln2837">            /*   isotopic aux info header        */</a>
<a name="ln2838">            /*************************************/</a>
<a name="ln2839">            szGetTag( AuxLbl, nTag,  bTag1 = AL_ISOT | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln2840">            if ( bXml )</a>
<a name="ln2841">            {</a>
<a name="ln2842">                str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln2843">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2844">                ind += inc;</a>
<a name="ln2845">            }</a>
<a name="ln2846">            else</a>
<a name="ln2847">            {</a>
<a name="ln2848">                pStr[tot_len = 0] = '\0';</a>
<a name="ln2849">            }</a>
<a name="ln2850">            /*****************************************************************</a>
<a name="ln2851">             *   Original atom numbers in order of isotopic canonical numbers</a>
<a name="ln2852">             *****************************************************************/</a>
<a name="ln2853">            szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_ISON, szTag2, &amp;bAlways );</a>
<a name="ln2854">            if ( bIsotopicOrigNumb[iCurTautMode] )</a>
<a name="ln2855">            {</a>
<a name="ln2856">                tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2857">                tot_len = str_AuxIsoNumb(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2858">                                         &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2859">                                         bSecondNonTautPass, bOmitRepetitions);</a>
<a name="ln2860">                if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2861">                    goto exit_function;</a>
<a name="ln2862">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2863">            }</a>
<a name="ln2864">            else</a>
<a name="ln2865">            {</a>
<a name="ln2866">                if ( !bXml )</a>
<a name="ln2867">                {</a>
<a name="ln2868">                    /*if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; );*/</a>
<a name="ln2869">                    inchi_ios_print( output_file, &quot;%s%s&quot;, szTag2, pLF ); /* mark isotopic output */</a>
<a name="ln2870">                }</a>
<a name="ln2871">            }</a>
<a name="ln2872"> </a>
<a name="ln2873">            /*************************/</a>
<a name="ln2874">            /*  Isotopic symmetry    */</a>
<a name="ln2875">            /*************************/</a>
<a name="ln2876">            if ( bIsotopicAtomEqu[iCurTautMode] )</a>
<a name="ln2877">            {</a>
<a name="ln2878">                /*  atoms */</a>
<a name="ln2879">                szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_AEQU, szTag2, &amp;bAlways );</a>
<a name="ln2880">                tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2881">                tot_len = str_AuxIsoEqu(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2882">                                        &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2883">                                        bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2884">                if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -2/*was -1: Fix15*/, bPlainTextTags ) )</a>
<a name="ln2885">                    goto exit_function;</a>
<a name="ln2886">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2887">            }</a>
<a name="ln2888">            else</a>
<a name="ln2889">            {</a>
<a name="ln2890">                if ( !bXml )</a>
<a name="ln2891">                {</a>
<a name="ln2892">                    if ( bPlainTextTags == 1 )</a>
<a name="ln2893">                        inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2894">                }</a>
<a name="ln2895">            }</a>
<a name="ln2896"> </a>
<a name="ln2897">            /********************************/</a>
<a name="ln2898">            /*  Tautomeric groups, isotopic */</a>
<a name="ln2899">            /********************************/</a>
<a name="ln2900">            if ( bTautomericOutputAllowed &amp;&amp; bTautomeric &amp;&amp; bIsotopicTautEqu[iCurTautMode] )</a>
<a name="ln2901">            {</a>
<a name="ln2902">                /********************************************/</a>
<a name="ln2903">                /*  Isotopic tautomeric groups equivalence */</a>
<a name="ln2904">                /********************************************/</a>
<a name="ln2905">                szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_GEQU, szTag2, &amp;bAlways );</a>
<a name="ln2906">                tot_len = str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2907">                tot_len = str_AuxIsoTgroupEqu(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln2908">                                              &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2909">                                              bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2910">                if ( str_LineEnd( szTag2, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -2/*was -1: Fix15*/, bPlainTextTags ) )</a>
<a name="ln2911">                    goto exit_function;</a>
<a name="ln2912">                inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2913">            }</a>
<a name="ln2914">            else</a>
<a name="ln2915">            {</a>
<a name="ln2916">                if ( !bXml &amp;&amp; bTautomericOutputAllowed &amp;&amp; bTautomeric )</a>
<a name="ln2917">                {</a>
<a name="ln2918">                    if ( bPlainTextTags == 1 )</a>
<a name="ln2919">                        inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2920">                }</a>
<a name="ln2921">            }</a>
<a name="ln2922"> </a>
<a name="ln2923">            /*************************************</a>
<a name="ln2924">             * Isotopic inverted stereo</a>
<a name="ln2925">             *************************************/</a>
<a name="ln2926">            if ( bInvIsotopicStereo[iCurTautMode] )</a>
<a name="ln2927">            {</a>
<a name="ln2928">                szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_STER, szTag2, &amp;bAlways );</a>
<a name="ln2929">                if ( bXml )</a>
<a name="ln2930">                {</a>
<a name="ln2931">                    /************************************</a>
<a name="ln2932">                         inv isotopic stereo start  tag</a>
<a name="ln2933">                    *************************************/</a>
<a name="ln2934">                    str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln2935">                    inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln2936">                    ind += inc;</a>
<a name="ln2937">                }</a>
<a name="ln2938">                /*************************************</a>
<a name="ln2939">                     inverted isotopic sp3 start tag</a>
<a name="ln2940">                **************************************/</a>
<a name="ln2941">                szGetTag( AuxLbl, nTag,  bTag3 = bTag2 | AL_SP3I, szTag3, &amp;bAlways );</a>
<a name="ln2942">                tot_len = str_LineStart( szTag3, NULL, 0, pStr, ind );</a>
<a name="ln2943">                tot_len = str_AuxInvIsoSp3(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2944">                                           &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2945">                                           bSecondNonTautPass, bOmitRepetitions, bUseMulipliers);</a>
<a name="ln2946">                if ( str_LineEnd( szTag3, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2947">                    goto exit_function;</a>
<a name="ln2948">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2949">                /*********************************************</a>
<a name="ln2950">                  inverted isotopic sp3  canonical numbering</a>
<a name="ln2951">                **********************************************/</a>
<a name="ln2952">                if ( bInvIsotopicStereoOrigNumb[iCurTautMode] )</a>
<a name="ln2953">                {</a>
<a name="ln2954">                    szGetTag( AuxLbl, nTag,  bTag3 = bTag2 | AL_SP3N, szTag3, &amp;bAlways );</a>
<a name="ln2955">                    tot_len = str_LineStart( szTag3, NULL, 0, pStr, ind );</a>
<a name="ln2956">                    tot_len = str_AuxInvIsoSp3Numb(pINChISort, pINChISort2, pStr, nStrLen, tot_len,</a>
<a name="ln2957">                                                   &amp;bOverflow, bOutType, TAUT_MODE, num_components,</a>
<a name="ln2958">                                                   bSecondNonTautPass, bOmitRepetitions);</a>
<a name="ln2959">                    if ( str_LineEnd( szTag3, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln2960">                        goto exit_function;</a>
<a name="ln2961">                    inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln2962">                }</a>
<a name="ln2963">                else</a>
<a name="ln2964">                {</a>
<a name="ln2965">                    if ( !bXml )</a>
<a name="ln2966">                    {</a>
<a name="ln2967">                        if ( bPlainTextTags == 1 )</a>
<a name="ln2968">                            inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln2969">                    }</a>
<a name="ln2970">                }</a>
<a name="ln2971">                if ( bXml )</a>
<a name="ln2972">                {</a>
<a name="ln2973">                /* close sp3 inv */</a>
<a name="ln2974">                    ind -= inc;</a>
<a name="ln2975">                    if ( str_LineEnd( szTag2, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln2976">                        goto exit_function;</a>
<a name="ln2977">                    inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln2978">                }</a>
<a name="ln2979">            }</a>
<a name="ln2980">            else</a>
<a name="ln2981">            {</a>
<a name="ln2982">                if ( !bXml )</a>
<a name="ln2983">                {</a>
<a name="ln2984">                    if ( bPlainTextTags == 1 )</a>
<a name="ln2985">                        inchi_ios_print( output_file, &quot;//&quot; );</a>
<a name="ln2986">                }</a>
<a name="ln2987">            }</a>
<a name="ln2988"> </a>
<a name="ln2989">            /* totally omitted undefined/unknown isotopic stereo */</a>
<a name="ln2990">            if ( bXml )</a>
<a name="ln2991">            {</a>
<a name="ln2992">                if ( bIgn_UU_Sp3_Iso[iCurTautMode] || bIgn_UU_Sp2_Iso[iCurTautMode]  )</a>
<a name="ln2993">                {</a>
<a name="ln2994">                    /* &lt;stereo omit_undef_dbond=&quot;1&quot; omit_undef_sp3=&quot;1&quot;/&gt; */</a>
<a name="ln2995">                    szGetTag( IdentLbl, nTag,  bTag1 = IL_STER, szTag1, &amp;bAlways );</a>
<a name="ln2996">                    tot_len = PrintXmlStartTag( pStr, ind, 3, szTag1,</a>
<a name="ln2997">                                     (bIgn_UU_Sp2_Iso[iCurTautMode])? x_ign_uu_sp2 : NULL, 1,</a>
<a name="ln2998">                                     (bIgn_UU_Sp3_Iso[iCurTautMode])? x_ign_uu_sp3 : NULL, 1,</a>
<a name="ln2999">                                     NULL, 0, NULL, 0, NULL, 0, NULL, 0 );</a>
<a name="ln3000">                    inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln3001">                }</a>
<a name="ln3002">            }</a>
<a name="ln3003"> </a>
<a name="ln3004"> </a>
<a name="ln3005">            if ( bXml )</a>
<a name="ln3006">            {</a>
<a name="ln3007">                /*****************  close isotopic ***********************/</a>
<a name="ln3008">                ind -= inc;</a>
<a name="ln3009">                if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3010">                    goto exit_function;</a>
<a name="ln3011">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3012">            }</a>
<a name="ln3013">        } /* Aux info isotopic */</a>
<a name="ln3014"> </a>
<a name="ln3015"> </a>
<a name="ln3016">#if ( CANON_FIXH_TRANS != 1 )</a>
<a name="ln3017">        if ( bSecondNonTautPass )</a>
<a name="ln3018">        {</a>
<a name="ln3019">            /* find and print non-tautomeric components transposition, if non-trivial */</a>
<a name="ln3020">            AT_NUMB *nTrans_n, *nTrans_s;</a>
<a name="ln3021">            if ( 0 &lt; bin_AuxTautTrans(pINChISort, pINChISort2, &amp;nTrans_n, &amp;nTrans_s, bOutType,  num_components) ) {</a>
<a name="ln3022">                /* a non-trivial transposition does exist; output start tag */</a>
<a name="ln3023">                tot_len = str_LineStart( tag=x_aux_trans, NULL, 0, pStr, ind );</a>
<a name="ln3024">                /* print the transposition, cycle after cycle */</a>
<a name="ln3025">                tot_len = str_AuxTautTrans(nTrans_n, nTrans_s, pStr, nStrLen, tot_len,</a>
<a name="ln3026">                                           &amp;bOverflow, TAUT_MODE, num_components);</a>
<a name="ln3027">                if ( str_LineEnd( bXml? tag:p_aux_at_inv_nbr, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln3028">                    goto exit_function;</a>
<a name="ln3029">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3030">                /* detected transposition */</a>
<a name="ln3031">                *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_TRANSPOS_BAS :</a>
<a name="ln3032">                                                                FLAG_SORT_PRINT_TRANSPOS_REC;</a>
<a name="ln3033">            }  else</a>
<a name="ln3034">            if ( !bXml ) {</a>
<a name="ln3035">                if ( bPlainTextTags == 1 ) inchi_ios_print( output_file, &quot;/&quot; );</a>
<a name="ln3036">            }</a>
<a name="ln3037">        }</a>
<a name="ln3038">#endif</a>
<a name="ln3039"> </a>
<a name="ln3040">        /**************************************************************</a>
<a name="ln3041">          At this point the INChI_Aux part of the output has been completed.</a>
<a name="ln3042">          If this INChI is tautomeric and non-tautomeric results exist</a>
<a name="ln3043">          then we need to output non-tautomeric auxilialy data</a>
<a name="ln3044">          (same as above excluding tautomeric information)</a>
<a name="ln3045">          Currently this is enabled for xml output only</a>
<a name="ln3046">        ***************************************************************/</a>
<a name="ln3047"> </a>
<a name="ln3048">        if ( bOutType == OUT_TN &amp;&amp; bTautomeric &amp;&amp; bNonTautomeric &amp;&amp;</a>
<a name="ln3049">            /* Check whether the Fixed-H layer is empty */</a>
<a name="ln3050">            (*pSortPrintINChIFlags &amp; ((INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :</a>
<a name="ln3051">                                                             FLAG_SORT_PRINT_NO_NFIX_H_REC )) &amp;&amp;</a>
<a name="ln3052">            (*pSortPrintINChIFlags &amp; ((INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :</a>
<a name="ln3053">                                                             FLAG_SORT_PRINT_NO_IFIX_H_REC ))</a>
<a name="ln3054">              )</a>
<a name="ln3055">        {</a>
<a name="ln3056">            bNonTautomeric = 0; /* bNonTautIdentifierNotEmpty == 0 =&gt; no fixed H info 02-10-2995 */</a>
<a name="ln3057">        }</a>
<a name="ln3058"> </a>
<a name="ln3059">        if ( bOutType == OUT_TN &amp;&amp; bTautomeric &amp;&amp; bNonTautomeric )</a>
<a name="ln3060">        {</a>
<a name="ln3061">            /* add the second (non-tautomeric) output */</a>
<a name="ln3062">            bOutType     = OUT_NONTAUT;</a>
<a name="ln3063">            iCurTautMode = TAUT_NON;</a>
<a name="ln3064">            pINChISort    = pINChISortTautAndNonTaut[TAUT_NON];</a>
<a name="ln3065">            bSecondNonTautPass = 1;</a>
<a name="ln3066">            num_components = num_comp[iCurTautMode];</a>
<a name="ln3067">            bFhTag = AL_FIXH;</a>
<a name="ln3068">            if ( bXml )</a>
<a name="ln3069">            {</a>
<a name="ln3070">                szGetTag( AuxLbl, nTag,  bTag1 = bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln3071">                str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln3072">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln3073">                ind += inc;</a>
<a name="ln3074">            }</a>
<a name="ln3075">            else</a>
<a name="ln3076">            {</a>
<a name="ln3077">                pStr[tot_len=0] = '\0';</a>
<a name="ln3078">            }</a>
<a name="ln3079"> </a>
<a name="ln3080">            /* if InChI Fixed-H isotopic is empty then do not output corresponding AuxInfo */</a>
<a name="ln3081">            if ( !(*pSortPrintINChIFlags &amp;</a>
<a name="ln3082">                    ((INCHI_BAS == iINChI)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :</a>
<a name="ln3083">                                            FLAG_SORT_PRINT_NO_NFIX_H_REC ))</a>
<a name="ln3084">               )</a>
<a name="ln3085">            {</a>
<a name="ln3086">                goto repeat_INChI_Aux_output;</a>
<a name="ln3087">            }</a>
<a name="ln3088">            else</a>
<a name="ln3089">            {</a>
<a name="ln3090">                goto repeat_INChI_Aux_Iso_output;</a>
<a name="ln3091">            }</a>
<a name="ln3092">        }</a>
<a name="ln3093">        else</a>
<a name="ln3094">        {</a>
<a name="ln3095">            if ( bOutType == OUT_NONTAUT &amp;&amp; bOutputType == OUT_TN &amp;&amp; bTautomeric &amp;&amp; bNonTautomeric )</a>
<a name="ln3096">            {</a>
<a name="ln3097">                /* the second (non-taut) output has been done; restore variables */</a>
<a name="ln3098">                bOutType           = OUT_TN;</a>
<a name="ln3099">                iCurTautMode       = TAUT_YES;</a>
<a name="ln3100">                pINChISort         = pINChISortTautAndNonTaut[TAUT_YES];</a>
<a name="ln3101">                bSecondNonTautPass = 0;</a>
<a name="ln3102">                /* set correct num components for the reversibility info 02-10-2005 */</a>
<a name="ln3103">                num_components     = num_comp[iCurTautMode];</a>
<a name="ln3104">                if ( bXml )</a>
<a name="ln3105">                {</a>
<a name="ln3106">                    /*  close non-tautomeric */</a>
<a name="ln3107">                    szGetTag( AuxLbl, nTag,  bTag1 = bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln3108">                    ind -= inc;</a>
<a name="ln3109">                    if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3110">                        goto exit_function;</a>
<a name="ln3111">                    inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3112">                }</a>
<a name="ln3113">                bFhTag = 0;</a>
<a name="ln3114">            }</a>
<a name="ln3115">        }</a>
<a name="ln3116"> </a>
<a name="ln3117"> </a>
<a name="ln3118">        /***************************************/</a>
<a name="ln3119">        /* charges, radicals, unusual valences */</a>
<a name="ln3120">        /***************************************/</a>
<a name="ln3121">        if ( !bSecondNonTautPass &amp;&amp; bChargesRadVal[iCurTautMode] )</a>
<a name="ln3122">        {</a>
<a name="ln3123">            /*  aux equ atoms */</a>
<a name="ln3124">            /* 1. Compare to tautomeric equivalence (in case of second, non-taut, pass only) */</a>
<a name="ln3125">            /* 2. Compare to the previous component if (1) failed to find equivalence */</a>
<a name="ln3126">            szGetTag( AuxLbl, nTag,  bTag1 = AL_CRV_ | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln3127">            tot_len = str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln3128">            tot_len = str_AuxChargeRadVal(pINChISort, pStr, nStrLen, tot_len,</a>
<a name="ln3129">                                          &amp;bOverflow, bOutType, TAUT_MODE,</a>
<a name="ln3130">                                          num_components, bUseMulipliers);</a>
<a name="ln3131">            if ( str_LineEnd( szTag1, tot_len, nStrLen, &amp;bOverflow, pStr, bXml? 0 : -1, bPlainTextTags ) )</a>
<a name="ln3132">                goto exit_function;</a>
<a name="ln3133">            inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, pLF );</a>
<a name="ln3134">        }</a>
<a name="ln3135"> </a>
<a name="ln3136">        /* output the original input structure -- quick fix */</a>
<a name="ln3137">        if ( !bSecondNonTautPass &amp;&amp; pOrigStruct &amp;&amp; pOrigStruct-&gt;num_atoms &amp;&amp;</a>
<a name="ln3138">             pOrigStruct-&gt;szAtoms &amp;&amp; pOrigStruct-&gt;szBonds &amp;&amp; pOrigStruct-&gt;szCoord )</a>
<a name="ln3139">        {</a>
<a name="ln3140">            int length, cur_pos, line_len, last_pos, nMaxLineLen;</a>
<a name="ln3141">            char *p;</a>
<a name="ln3142">            nMaxLineLen = inchi_min( 80, nStrLen ); /* restrict line length to 80 characters */</a>
<a name="ln3143">            /**********************</a>
<a name="ln3144">               reversibility info</a>
<a name="ln3145">             **********************/</a>
<a name="ln3146">            szGetTag( AuxLbl, nTag,  bTag1 = AL_REVR | bFhTag, szTag1, &amp;bAlways );</a>
<a name="ln3147">            if ( bXml )</a>
<a name="ln3148">            {</a>
<a name="ln3149">                str_LineStart( szTag1, NULL, 0, pStr, ind );</a>
<a name="ln3150">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln3151">                ind += inc;</a>
<a name="ln3152">            }</a>
<a name="ln3153">            /*  === atoms === */</a>
<a name="ln3154">            szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_ATMR, szTag2, &amp;bAlways );</a>
<a name="ln3155">            if ( bXml )</a>
<a name="ln3156">            {</a>
<a name="ln3157">                str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln3158">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln3159">                ind += inc;</a>
<a name="ln3160">                /* first line indent */</a>
<a name="ln3161">                strcpy( pStr, SP(ind));</a>
<a name="ln3162">                tot_len = ind;</a>
<a name="ln3163">            }</a>
<a name="ln3164">            else</a>
<a name="ln3165">            {</a>
<a name="ln3166">                pStr[tot_len = 0] = '\0';</a>
<a name="ln3167">                inchi_ios_print( output_file, &quot;%s%s&quot;, szTag2, pStr );</a>
<a name="ln3168">            }</a>
<a name="ln3169">            p = pOrigStruct-&gt;szAtoms;</a>
<a name="ln3170">            length = strlen( p );</a>
<a name="ln3171">            line_len = nMaxLineLen - tot_len;</a>
<a name="ln3172">            for ( cur_pos = 0; cur_pos &lt; length; cur_pos = last_pos )</a>
<a name="ln3173">            {</a>
<a name="ln3174">                if ( length - cur_pos &gt;= line_len )</a>
<a name="ln3175">                {</a>
<a name="ln3176">                    last_pos = cur_pos + line_len;</a>
<a name="ln3177">                    /* search backward for the nearest first atom letter (always uppercase) */</a>
<a name="ln3178">                    while ( cur_pos &lt; last_pos &amp;&amp; !isupper( UCINT p[last_pos] ) ) {</a>
<a name="ln3179">                        last_pos --;</a>
<a name="ln3180">                    }</a>
<a name="ln3181">                }</a>
<a name="ln3182">                else</a>
<a name="ln3183">                {</a>
<a name="ln3184">                    last_pos = length;</a>
<a name="ln3185">                }</a>
<a name="ln3186">                if ( last_pos &gt; cur_pos )</a>
<a name="ln3187">                {</a>
<a name="ln3188">                    memcpy( pStr + tot_len, p+cur_pos, last_pos - cur_pos );</a>
<a name="ln3189">                    pStr[tot_len + last_pos - cur_pos] = '\0';</a>
<a name="ln3190">                    inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, !bXml &amp;&amp; bPlainTextTags? &quot;&quot; : &quot;\n&quot; );</a>
<a name="ln3191">                }</a>
<a name="ln3192">                else</a>
<a name="ln3193">                {</a>
<a name="ln3194">                    break;</a>
<a name="ln3195">                }</a>
<a name="ln3196">            }</a>
<a name="ln3197">            if ( bXml )</a>
<a name="ln3198">            {</a>
<a name="ln3199">                ind -= inc;</a>
<a name="ln3200">                pStr[0] = '\0';</a>
<a name="ln3201">                if ( str_LineEnd( szTag2, 0, nMaxLineLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3202">                    goto exit_function;</a>
<a name="ln3203">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3204">            }</a>
<a name="ln3205">            else</a>
<a name="ln3206">            {</a>
<a name="ln3207">                if ( pLF[0] )</a>
<a name="ln3208">                {</a>
<a name="ln3209">                    inchi_ios_print( output_file, &quot;%s&quot;, pLF );</a>
<a name="ln3210">                }</a>
<a name="ln3211">            }</a>
<a name="ln3212"> </a>
<a name="ln3213"> </a>
<a name="ln3214">            /*  === bonds === */</a>
<a name="ln3215">            szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_BNDR, szTag2, &amp;bAlways );</a>
<a name="ln3216">            if ( bXml )</a>
<a name="ln3217">            {</a>
<a name="ln3218">                str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln3219">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln3220">                ind += inc;</a>
<a name="ln3221">                /* first line indent */</a>
<a name="ln3222">                strcpy( pStr, SP(ind));</a>
<a name="ln3223">                tot_len = ind;</a>
<a name="ln3224">            }</a>
<a name="ln3225">            else</a>
<a name="ln3226">            {</a>
<a name="ln3227">                pStr[tot_len = 0] = '\0';</a>
<a name="ln3228">                inchi_ios_print( output_file, &quot;%s%s&quot;, szTag2, pStr );</a>
<a name="ln3229">            }</a>
<a name="ln3230"> </a>
<a name="ln3231">            p = pOrigStruct-&gt;szBonds;</a>
<a name="ln3232">            length = strlen( p );</a>
<a name="ln3233">            line_len = nMaxLineLen - tot_len;</a>
<a name="ln3234">            for ( cur_pos = 0; cur_pos &lt; length; cur_pos = last_pos )</a>
<a name="ln3235">            {</a>
<a name="ln3236">                if ( length - cur_pos &gt;= line_len )</a>
<a name="ln3237">                {</a>
<a name="ln3238">                    last_pos = cur_pos + line_len - 1;</a>
<a name="ln3239">                    /* search backward for the nearest first bond delimiter &quot;;&quot; */</a>
<a name="ln3240">                    while ( cur_pos &lt; last_pos &amp;&amp; p[last_pos] != ';' )</a>
<a name="ln3241">                    {</a>
<a name="ln3242">                        last_pos --;</a>
<a name="ln3243">                    }</a>
<a name="ln3244">                    if ( cur_pos &lt; last_pos )</a>
<a name="ln3245">                    {</a>
<a name="ln3246">                        last_pos ++; /* include ';' at the end of the line */</a>
<a name="ln3247">                    }</a>
<a name="ln3248">                }</a>
<a name="ln3249">                else</a>
<a name="ln3250">                {</a>
<a name="ln3251">                    last_pos = length;</a>
<a name="ln3252">                }</a>
<a name="ln3253">                if ( last_pos &gt; cur_pos )</a>
<a name="ln3254">                {</a>
<a name="ln3255">                    memcpy( pStr + tot_len, p+cur_pos, last_pos - cur_pos );</a>
<a name="ln3256">                    pStr[tot_len + last_pos - cur_pos] = '\0';</a>
<a name="ln3257">                    inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, !bXml &amp;&amp; bPlainTextTags? &quot;&quot; : &quot;\n&quot; );</a>
<a name="ln3258">                }</a>
<a name="ln3259">                else</a>
<a name="ln3260">                {</a>
<a name="ln3261">                    break;</a>
<a name="ln3262">                }</a>
<a name="ln3263">            }</a>
<a name="ln3264"> </a>
<a name="ln3265">            if ( bXml )</a>
<a name="ln3266">            {</a>
<a name="ln3267">                ind -= inc;</a>
<a name="ln3268">                pStr[0] = '\0';</a>
<a name="ln3269">                if ( str_LineEnd( szTag2, 0, nMaxLineLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3270">                    goto exit_function;</a>
<a name="ln3271">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3272">            }</a>
<a name="ln3273">            else</a>
<a name="ln3274">            {</a>
<a name="ln3275">                if ( pLF[0] )</a>
<a name="ln3276">                {</a>
<a name="ln3277">                    inchi_ios_print( output_file, &quot;%s&quot;, pLF );</a>
<a name="ln3278">                }</a>
<a name="ln3279">            }</a>
<a name="ln3280"> </a>
<a name="ln3281"> </a>
<a name="ln3282">            /*  === coordinates === */</a>
<a name="ln3283">            szGetTag( AuxLbl, nTag,  bTag2 = bTag1 | AL_XYZR, szTag2, &amp;bAlways );</a>
<a name="ln3284">            if ( bXml )</a>
<a name="ln3285">            {</a>
<a name="ln3286">                str_LineStart( szTag2, NULL, 0, pStr, ind );</a>
<a name="ln3287">                inchi_ios_print( output_file, &quot;%s\n&quot;, pStr );</a>
<a name="ln3288">                ind += inc;</a>
<a name="ln3289">                /* first line indent */</a>
<a name="ln3290">                strcpy( pStr, SP(ind));</a>
<a name="ln3291">                tot_len = ind;</a>
<a name="ln3292">            }</a>
<a name="ln3293">            else</a>
<a name="ln3294">            {</a>
<a name="ln3295">                pStr[tot_len = 0] = '\0';</a>
<a name="ln3296">                inchi_ios_print( output_file, &quot;%s%s&quot;, szTag2, pStr );</a>
<a name="ln3297">            }</a>
<a name="ln3298"> </a>
<a name="ln3299">            p = pOrigStruct-&gt;szCoord;</a>
<a name="ln3300">            length = strlen( p );</a>
<a name="ln3301">            line_len = nMaxLineLen - tot_len;</a>
<a name="ln3302">            for ( cur_pos = 0; cur_pos &lt; length; cur_pos = last_pos )</a>
<a name="ln3303">            {</a>
<a name="ln3304">                if ( length - cur_pos &gt;= line_len )</a>
<a name="ln3305">                {</a>
<a name="ln3306">                    last_pos = cur_pos + line_len - 1;</a>
<a name="ln3307">                    /* search backward for the nearest first coord. delimiter &quot;;&quot; */</a>
<a name="ln3308">                    while ( cur_pos &lt; last_pos &amp;&amp; p[last_pos] != ';' )</a>
<a name="ln3309">                    {</a>
<a name="ln3310">                        last_pos --;</a>
<a name="ln3311">                    }</a>
<a name="ln3312">                    if ( cur_pos &lt; last_pos )</a>
<a name="ln3313">                    {</a>
<a name="ln3314">                        last_pos ++; /* include ';' at the end of the line */</a>
<a name="ln3315">                    }</a>
<a name="ln3316">                }</a>
<a name="ln3317">                else</a>
<a name="ln3318">                {</a>
<a name="ln3319">                    last_pos = length;</a>
<a name="ln3320">                }</a>
<a name="ln3321">                if ( last_pos &gt; cur_pos )</a>
<a name="ln3322">                {</a>
<a name="ln3323">                    memcpy( pStr + tot_len, p+cur_pos, last_pos - cur_pos );</a>
<a name="ln3324">                    pStr[tot_len + last_pos - cur_pos] = '\0';</a>
<a name="ln3325">                    inchi_ios_print( output_file, &quot;%s%s&quot;, pStr, !bXml &amp;&amp; bPlainTextTags? &quot;&quot; : &quot;\n&quot; );</a>
<a name="ln3326">                }</a>
<a name="ln3327">                else</a>
<a name="ln3328">                {</a>
<a name="ln3329">                    break;</a>
<a name="ln3330">                }</a>
<a name="ln3331">            }</a>
<a name="ln3332"> </a>
<a name="ln3333">            if ( bXml )</a>
<a name="ln3334">            {</a>
<a name="ln3335">                ind -= inc;</a>
<a name="ln3336">                pStr[0] = '\0';</a>
<a name="ln3337">                if ( str_LineEnd( szTag2, 0, nMaxLineLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3338">                    goto exit_function;</a>
<a name="ln3339">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3340">            }</a>
<a name="ln3341">            else</a>
<a name="ln3342">            {</a>
<a name="ln3343">                if ( pLF[0] )</a>
<a name="ln3344">                {</a>
<a name="ln3345">                    inchi_ios_print( output_file, &quot;%s&quot;, pLF );</a>
<a name="ln3346">                }</a>
<a name="ln3347">            }</a>
<a name="ln3348"> </a>
<a name="ln3349">            if ( bXml )</a>
<a name="ln3350">            {</a>
<a name="ln3351">                /***************************</a>
<a name="ln3352">                  close reversibility info</a>
<a name="ln3353">                 ***************************/</a>
<a name="ln3354">                ind -= inc;</a>
<a name="ln3355">                if ( str_LineEnd( szTag1, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3356">                    goto exit_function;</a>
<a name="ln3357">                inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3358">            }</a>
<a name="ln3359">        }</a>
<a name="ln3360"> </a>
<a name="ln3361"> </a>
<a name="ln3362"> </a>
<a name="ln3363">        /************************************************</a>
<a name="ln3364">         * output INChI_Aux of the reconnected structure *</a>
<a name="ln3365">         ************************************************/</a>
<a name="ln3366">        bEmbeddedOutputCalled = 0;</a>
<a name="ln3367">        if ( bDisconnectedCoord &amp;&amp; INCHI_BAS == iINChI &amp;&amp; (bINChIOutputOptions &amp; INCHI_OUT_EMBED_REC) &amp;&amp;</a>
<a name="ln3368">             num_components2[INCHI_REC] &amp;&amp; !(bINChIOutputOptions &amp; INCHI_OUT_NO_AUX_INFO) )</a>
<a name="ln3369">        {</a>
<a name="ln3370">            int nRet;</a>
<a name="ln3371">            bEmbeddedOutputCalled = 1;</a>
<a name="ln3372">            if ( !bXml )</a>
<a name="ln3373">            {</a>
<a name="ln3374">                inchi_ios_print( output_file, &quot;%s&quot;, pLF );</a>
<a name="ln3375">            }</a>
<a name="ln3376"> </a>
<a name="ln3377">            nRet = OutputINChI1(pStr, nStrLen,</a>
<a name="ln3378">                                pINChISortTautAndNonTaut2,</a>
<a name="ln3379">                                INCHI_REC,</a>
<a name="ln3380">                                NULL,</a>
<a name="ln3381">                                0 /*bDisconnectedCoord*/, bOutputType,</a>
<a name="ln3382">                                INCHI_OUT_ONLY_AUX_INFO | bINChIOutputOptions,</a>
<a name="ln3383">                                bXml, bAbcNumbers, bCtPredecessors, bNoStructLabels,</a>
<a name="ln3384">                                num_components2,</a>
<a name="ln3385">                                num_non_taut2, num_taut2,</a>
<a name="ln3386">                                output_file, log_file,</a>
<a name="ln3387">                                num_input_struct,</a>
<a name="ln3388">                                szSdfLabel, szSdfValue, lSdfId,</a>
<a name="ln3389">                                pSortPrintINChIFlags,</a>
<a name="ln3390">                                save_opt_bits);</a>
<a name="ln3391">            if ( !nRet )</a>
<a name="ln3392">                goto exit_function; /* error */</a>
<a name="ln3393">        }</a>
<a name="ln3394"> </a>
<a name="ln3395">        /* close INChI_Aux */</a>
<a name="ln3396">        if ( bXml )</a>
<a name="ln3397">        {</a>
<a name="ln3398">                ind -= inc;</a>
<a name="ln3399">            if ( str_LineEnd( x_aux_basic, 0, nStrLen, &amp;bOverflow, pStr, ind, bPlainTextTags ) )</a>
<a name="ln3400">                goto exit_function;</a>
<a name="ln3401">            inchi_ios_print( output_file, &quot;%s&quot;, pStr );</a>
<a name="ln3402">        }</a>
<a name="ln3403">        else</a>
<a name="ln3404">        {</a>
<a name="ln3405">            if ( !bEmbeddedOutputCalled &amp;&amp; !bPlainTextCommnts )</a>
<a name="ln3406">            {</a>
<a name="ln3407">                inchi_ios_print( output_file, &quot;%s\n&quot;, (!num_components2[0] &amp;&amp; !num_components2[1])? &quot;//&quot;:&quot;&quot; );</a>
<a name="ln3408">                /* plain text comment earlier ended with LF */</a>
<a name="ln3409">            }</a>
<a name="ln3410">        }</a>
<a name="ln3411"> </a>
<a name="ln3412"> </a>
<a name="ln3413">        /* in wINChI window, separate AuxInfo: from InChIKey: with blank line */</a>
<a name="ln3414">        inchi_ios_print( output_file, &quot;%s&quot;,</a>
<a name="ln3415">                        (bINChIOutputOptions &amp; INCHI_OUT_WINCHI_WINDOW) ? &quot;\n&quot;:&quot;&quot;);</a>
<a name="ln3416"> </a>
<a name="ln3417"> </a>
<a name="ln3418"> </a>
<a name="ln3419"> </a>
<a name="ln3420">    } /* end of output aux info */</a>
<a name="ln3421"> </a>
<a name="ln3422"> </a>
<a name="ln3423">    ret = 1;</a>
<a name="ln3424">exit_function:</a>
<a name="ln3425"> </a>
<a name="ln3426">    if ( bOverflow )</a>
<a name="ln3427">    {</a>
<a name="ln3428">        strcpy( pStr, &quot;Output buffer overflow&quot;);</a>
<a name="ln3429">        if ( bXml )</a>
<a name="ln3430">        {</a>
<a name="ln3431">            OutputINChIXmlError( output_file, pStr, nStrLen, ind /*, 0*/ /* err number */, pStr, _IS_FATAL );</a>
<a name="ln3432">        }</a>
<a name="ln3433">        else</a>
<a name="ln3434">        {</a>
<a name="ln3435">            inchi_ios_print( output_file, &quot;\nFATAL ERROR: %s\n&quot;, pStr );</a>
<a name="ln3436">        }</a>
<a name="ln3437">    }</a>
<a name="ln3438"> </a>
<a name="ln3439">    /* inchi_free( pStr ); */</a>
<a name="ln3440">    return ret;</a>
<a name="ln3441"> </a>
<a name="ln3442"> </a>
<a name="ln3443">} /* OutputINChI1 */</a>
<a name="ln3444"> </a>
<a name="ln3445"> </a>
<a name="ln3446"> </a>
<a name="ln3447">/***************************************************************/</a>
<a name="ln3448">int str_LineStart( const char *tag, char *tag2, int val2, char *pStr, int ind )</a>
<a name="ln3449">{</a>
<a name="ln3450">    int tot_len = 0;</a>
<a name="ln3451">    if ( ind &gt;= 0 ) {</a>
<a name="ln3452">        if ( ind &gt; 0 ) {</a>
<a name="ln3453">            /* xml: indent */</a>
<a name="ln3454">            memset( pStr + tot_len, ' ', ind );</a>
<a name="ln3455">            tot_len += ind;</a>
<a name="ln3456">        }</a>
<a name="ln3457">        /* xml: tag */</a>
<a name="ln3458">        strcpy( pStr + tot_len, x_line_opening );</a>
<a name="ln3459">        strcat( pStr + tot_len, tag );</a>
<a name="ln3460">        if ( tag2 ) {</a>
<a name="ln3461">            tot_len += strlen(pStr + tot_len);</a>
<a name="ln3462">            tot_len += sprintf( pStr + tot_len, &quot; %s=\&quot;%d\&quot;%s&quot;, tag2, val2, x_close_line );</a>
<a name="ln3463"> </a>
<a name="ln3464">        } else {</a>
<a name="ln3465">            strcat( pStr + tot_len, x_close_line );</a>
<a name="ln3466">            tot_len += strlen(pStr + tot_len);</a>
<a name="ln3467">        }</a>
<a name="ln3468">    } else {</a>
<a name="ln3469">        pStr[tot_len] = '\0';</a>
<a name="ln3470">    }</a>
<a name="ln3471">    return tot_len;</a>
<a name="ln3472">}</a>
<a name="ln3473">/***************************************************************/</a>
<a name="ln3474">int str_LineEnd( const char *tag, int tot_len, int nStrLen, int *bOverflow, char *pStr, int ind, int bPlainTextTags )</a>
<a name="ln3475">{</a>
<a name="ln3476">    static int  add_tag_len = sizeof(x_line_closing)-1 + sizeof(x_close_line)-1;</a>
<a name="ln3477">    int tag_len;</a>
<a name="ln3478">    /* check buffer overflow */</a>
<a name="ln3479">    if ( *bOverflow )</a>
<a name="ln3480">        return 1;</a>
<a name="ln3481">    if ( ind &gt;= 0 ) {  /* xml */</a>
<a name="ln3482">        tag_len = ind + add_tag_len + strlen(tag);</a>
<a name="ln3483">        if ( tot_len + tag_len &lt; nStrLen - 2  ) {</a>
<a name="ln3484">            /* output &quot;   &lt;/tag&gt;\n&quot; */</a>
<a name="ln3485">            tot_len += sprintf( pStr + tot_len, &quot;%s%s%s%s\n&quot;, SP(ind), x_line_closing, tag, x_close_line );</a>
<a name="ln3486">        } else {</a>
<a name="ln3487">            *bOverflow += 1;</a>
<a name="ln3488">            return 1;</a>
<a name="ln3489">        }</a>
<a name="ln3490">    } else { /* plain */</a>
<a name="ln3491">        pStr[tot_len] = '\0'; /* add zero termination 2004-04-26 */</a>
<a name="ln3492">        /* insert plain text tag if:</a>
<a name="ln3493">           (a) pStr has non-zero length, or</a>
<a name="ln3494">           (b) ind &lt; -1</a>
<a name="ln3495">        */</a>
<a name="ln3496"> </a>
<a name="ln3497">        if ( pStr[0] || ind &lt; -1 ) {</a>
<a name="ln3498">            tag_len = bPlainTextTags? strlen( tag ):0;</a>
<a name="ln3499">            if ( tot_len + tag_len  &lt; nStrLen - 2 ) {</a>
<a name="ln3500">                if ( tag_len &gt; 0 ) {</a>
<a name="ln3501">                    /* insert plain text tag */</a>
<a name="ln3502">                    memmove( pStr+tag_len, pStr, tot_len + 1 );</a>
<a name="ln3503">                    memcpy( pStr, tag, tag_len );</a>
<a name="ln3504">                }</a>
<a name="ln3505">            } else {</a>
<a name="ln3506">                *bOverflow += 1;</a>
<a name="ln3507">                return 1;</a>
<a name="ln3508">            }</a>
<a name="ln3509">        }/* else</a>
<a name="ln3510">        if ( bPlainTextTags == 1 ) {</a>
<a name="ln3511">            strcpy( pStr, &quot;/&quot; );</a>
<a name="ln3512">        }*/</a>
<a name="ln3513">    }</a>
<a name="ln3514">    return 0;</a>
<a name="ln3515">}</a>
<a name="ln3516"> </a>
<a name="ln3517"> </a>
<a name="ln3518"> </a>
<a name="ln3519">/**********************************************************************************************/</a>
<a name="ln3520">int CleanOrigCoord( MOL_COORD szCoord, int delim )</a>
<a name="ln3521">{</a>
<a name="ln3522">#define MIN_BOND_LENGTH   (1.0e-6)</a>
<a name="ln3523">    char szVal[LEN_COORD+1];</a>
<a name="ln3524">    MOL_COORD szBuf;</a>
<a name="ln3525">    char *q;</a>
<a name="ln3526">    int len, last, fst, dec_pnt, num_zer=0, len_buf = 0, e;</a>
<a name="ln3527">    int k, i;</a>
<a name="ln3528">    double coord;</a>
<a name="ln3529"> </a>
<a name="ln3530">    for ( k = 0; k &lt; NUM_COORD*LEN_COORD; k += LEN_COORD ) {</a>
<a name="ln3531">        memcpy( szVal, szCoord+k, LEN_COORD );</a>
<a name="ln3532">        szVal[LEN_COORD] = '\0';</a>
<a name="ln3533">        LtrimRtrim(szVal, &amp;len);</a>
<a name="ln3534">        coord = strtod(szVal, &amp;q);</a>
<a name="ln3535">        if ( MIN_BOND_LENGTH &gt; fabs(coord)  ) {</a>
<a name="ln3536">            strcpy( szVal, &quot;0&quot; );</a>
<a name="ln3537">            len = 1;</a>
<a name="ln3538">            num_zer ++;</a>
<a name="ln3539">        } else {</a>
<a name="ln3540">            len = q - szVal;</a>
<a name="ln3541">            /* last = (last mantissa digit position + 1)  */</a>
<a name="ln3542">            if ( (q = strchr(szVal, 'e')) || (q = strchr(szVal, 'E')) ||</a>
<a name="ln3543">                 (q = strchr(szVal, 'd')) || (q = strchr(szVal, 'D')) ) {</a>
<a name="ln3544">                /* floating point */</a>
<a name="ln3545">                last = q - szVal;</a>
<a name="ln3546">                /* remove (+) and leading zeroes from the exponent */</a>
<a name="ln3547">                e = (int)strtol( szVal+last+1, &amp;q, 10 ); /* exponent */</a>
<a name="ln3548">                if ( e ) {</a>
<a name="ln3549">                    /* new exp; update the length */</a>
<a name="ln3550">                    len = last+1+sprintf( szVal+last+1, &quot;%d&quot;, e ); /* print exp without leading zeroes and '+' */</a>
<a name="ln3551">                } else {</a>
<a name="ln3552">                    /* exponent is zero */</a>
<a name="ln3553">                    len = last;</a>
<a name="ln3554">                }</a>
<a name="ln3555">            } else {</a>
<a name="ln3556">                last = len;</a>
<a name="ln3557">            }</a>
<a name="ln3558">            /* fst = (first mantissa digit); fst=1 if the sign is present, otherwise 0 */</a>
<a name="ln3559">            fst = (szVal[0]!='.' &amp;&amp; !isdigit( UCINT szVal[0] ));</a>
<a name="ln3560">            /* dec_pnt = (decimal point position) or last */</a>
<a name="ln3561">            if ( (q = strchr(szVal, '.')) ) {</a>
<a name="ln3562">                dec_pnt = q - szVal;</a>
<a name="ln3563">            } else {</a>
<a name="ln3564">                dec_pnt = last;</a>
<a name="ln3565">            }</a>
<a name="ln3566">            last -= 1; /* last mantissa digit position */</a>
<a name="ln3567">            /* remove trailing zeroes in the range dec_pnt+1..last-1 */</a>
<a name="ln3568">            for ( i = last; dec_pnt &lt; i &amp;&amp;  '0' == szVal[i]; i -- )</a>
<a name="ln3569">                ;</a>
<a name="ln3570">            if ( i == dec_pnt ) {</a>
<a name="ln3571">                i --; /* remove decimal point, too */</a>
<a name="ln3572">            }</a>
<a name="ln3573">            if ( i &lt; last ) {</a>
<a name="ln3574">                memmove( szVal+i+1, szVal+last+1, len-last );</a>
<a name="ln3575">                len -= last-i;</a>
<a name="ln3576">            }</a>
<a name="ln3577">            /* remove leading zeroes */</a>
<a name="ln3578">            for ( i = fst; i &lt; len &amp;&amp; '0' == szVal[i]; i ++ )</a>
<a name="ln3579">                ;</a>
<a name="ln3580">            if ( i &gt; fst ) {</a>
<a name="ln3581">                memmove( szVal + fst, szVal+i, len-fst );</a>
<a name="ln3582">                len -= i-fst;</a>
<a name="ln3583">            }</a>
<a name="ln3584">        }</a>
<a name="ln3585">        if ( len_buf )</a>
<a name="ln3586">            szBuf[len_buf++] = delim;</a>
<a name="ln3587">        memcpy( szBuf + len_buf, szVal, len ); /* does not copy zero termination*/</a>
<a name="ln3588">        len_buf += len;</a>
<a name="ln3589">    }</a>
<a name="ln3590">    /* zero termination */</a>
<a name="ln3591">    if ( len_buf &lt; (int)sizeof(MOL_COORD) ) {</a>
<a name="ln3592">        memset( szBuf+len_buf, 0, sizeof(MOL_COORD) - len_buf);</a>
<a name="ln3593">    }</a>
<a name="ln3594">    memcpy( szCoord, szBuf, sizeof(MOL_COORD) );</a>
<a name="ln3595">    return num_zer;</a>
<a name="ln3596">#undef MIN_BOND_LENGTH</a>
<a name="ln3597">}</a>
<a name="ln3598"> </a>
<a name="ln3599">/******************************************************************************************/</a>
<a name="ln3600">int WriteOrigCoord( int num_inp_atoms, MOL_COORD *szMolCoord, int *i, char *szBuf, int buf_len )</a>
<a name="ln3601">{</a>
<a name="ln3602"> </a>
<a name="ln3603">    int j, num_zer, len, cur_len;</a>
<a name="ln3604">    char *p;</a>
<a name="ln3605">    MOL_COORD szCurCoord;</a>
<a name="ln3606">    cur_len = 0;</a>
<a name="ln3607">    for ( j = *i; j &lt; num_inp_atoms; ) {</a>
<a name="ln3608">        memcpy( szCurCoord, szMolCoord[j], sizeof(szCurCoord));</a>
<a name="ln3609">        num_zer = CleanOrigCoord( szCurCoord, ',' );</a>
<a name="ln3610">        if ( NUM_COORD == num_zer ) {</a>
<a name="ln3611">            len = 0;</a>
<a name="ln3612">        } else {</a>
<a name="ln3613">            if ( (p = (char *)memchr( szCurCoord, '\0', sizeof(szCurCoord))) ) {</a>
<a name="ln3614">                len = p - szCurCoord;</a>
<a name="ln3615">            } else {</a>
<a name="ln3616">                len = sizeof(szCurCoord);</a>
<a name="ln3617">            }</a>
<a name="ln3618">        }</a>
<a name="ln3619">        if ( len + cur_len + 1 &lt; buf_len ) {</a>
<a name="ln3620">            if ( len ) {</a>
<a name="ln3621">                memcpy( szBuf + cur_len, szCurCoord, len * sizeof(szBuf[0]) );</a>
<a name="ln3622">            }</a>
<a name="ln3623">            szBuf[cur_len += len] = ';';</a>
<a name="ln3624">            cur_len ++;</a>
<a name="ln3625">            j ++;</a>
<a name="ln3626">        } else {</a>
<a name="ln3627">            break;</a>
<a name="ln3628">        }</a>
<a name="ln3629">    }</a>
<a name="ln3630">    szBuf[cur_len] = '\0';</a>
<a name="ln3631">    *i = j; /* next item */</a>
<a name="ln3632">    return cur_len;</a>
<a name="ln3633">}</a>
<a name="ln3634">/******************************************************************************************/</a>
<a name="ln3635">/*</a>
<a name="ln3636">  number of atoms</a>
<a name="ln3637">  [c|n]              chiral/nonchiral</a>
<a name="ln3638"> </a>
<a name="ln3639">  Element</a>
<a name="ln3640">  #valence</a>
<a name="ln3641">  +/-[charge&gt;1]</a>
<a name="ln3642">  .#rad  (#rad=1, 2, 3: singlet, doulet, triplet)</a>
<a name="ln3643">  [.]i#iso_mass</a>
<a name="ln3644">  [.]{o|e|u|?} atom parity = {1:2:3:4}</a>
<a name="ln3645">  [.]h[#of 1H&gt;1]</a>
<a name="ln3646">  [.]d[#of 2H&gt;1]</a>
<a name="ln3647">  [.]t[#of 3H&gt;1]</a>
<a name="ln3648"> </a>
<a name="ln3649">  Note: . occurs only once and only if radical or 1-character element</a>
<a name="ln3650">*/</a>
<a name="ln3651">int WriteOrigAtoms( int num_inp_atoms, inp_ATOM *at, int *i, char *szBuf, int buf_len, STRUCT_DATA *sd)</a>
<a name="ln3652">{</a>
<a name="ln3653">    int j, k, n, len, len0, cur_len, val, bonds_val, mw, parity, num_trans, is_ok, b_self;</a>
<a name="ln3654">    static char szIsoH[] = &quot;hdt&quot;;</a>
<a name="ln3655">    char szCurAtom[32];</a>
<a name="ln3656">    AT_NUMB nNeighOrder[MAXVAL], neigh;</a>
<a name="ln3657"> </a>
<a name="ln3658">    cur_len = 0;</a>
<a name="ln3659">    if ( 0 == *i ) {</a>
<a name="ln3660">        cur_len = sprintf( szBuf, &quot;%d%s&quot;, num_inp_atoms,</a>
<a name="ln3661">                                  (sd-&gt;bChiralFlag &amp; FLAG_INP_AT_CHIRAL)?    &quot;c&quot; :</a>
<a name="ln3662">                                  (sd-&gt;bChiralFlag &amp; FLAG_INP_AT_NONCHIRAL)? &quot;n&quot; : &quot;&quot; );</a>
<a name="ln3663">    }</a>
<a name="ln3664">    for ( j = *i; j &lt; num_inp_atoms; ) {</a>
<a name="ln3665">        /* tetrahedral parity treatment */</a>
<a name="ln3666">        parity    = 0;</a>
<a name="ln3667">        num_trans = 0;</a>
<a name="ln3668">        if ( at[j].p_parity ) {</a>
<a name="ln3669">            /* verify neighbors */</a>
<a name="ln3670">            is_ok  = 1;</a>
<a name="ln3671">            b_self = 0;</a>
<a name="ln3672">            for ( n = 0, k = 0; n &lt; MAX_NUM_STEREO_ATOM_NEIGH; n ++ ) {</a>
<a name="ln3673">                neigh = at[j].p_orig_at_num[n]-1;</a>
<a name="ln3674">                if ( is_in_the_list( at[j].neighbor, neigh, at[j].valence ) &amp;&amp;</a>
<a name="ln3675">                     at[neigh].orig_at_number  ==  at[j].p_orig_at_num[n] ) {</a>
<a name="ln3676">                    /* real neighbor */</a>
<a name="ln3677">                    nNeighOrder[k ++] = at[j].p_orig_at_num[n];</a>
<a name="ln3678">                } else</a>
<a name="ln3679">                if ( (int)neigh == j &amp;&amp; at[neigh].orig_at_number  ==  at[j].p_orig_at_num[n] ) {</a>
<a name="ln3680">                    /* central atom is a neighbor */</a>
<a name="ln3681">                    num_trans = n; /* move this neighbor to 0 position permutation parity */</a>
<a name="ln3682">                    b_self ++;</a>
<a name="ln3683">                } else {</a>
<a name="ln3684">                    is_ok = 0;</a>
<a name="ln3685">                    break;</a>
<a name="ln3686">                }</a>
<a name="ln3687">            }</a>
<a name="ln3688">            if ( is_ok &amp;&amp; b_self &lt;= 1 &amp;&amp; b_self + k == MAX_NUM_STEREO_ATOM_NEIGH ) {</a>
<a name="ln3689">                num_trans += insertions_sort( nNeighOrder, k, sizeof(nNeighOrder[0]), comp_AT_RANK );</a>
<a name="ln3690">                if ( ATOM_PARITY_WELL_DEF( at[j].p_parity ) ) {</a>
<a name="ln3691">                    parity = 2 - (num_trans + at[j].p_parity) % 2;</a>
<a name="ln3692">                } else</a>
<a name="ln3693">                if ( ATOM_PARITY_ILL_DEF( at[j].p_parity ) ) {</a>
<a name="ln3694">                    parity = at[j].p_parity;</a>
<a name="ln3695">                } else {</a>
<a name="ln3696">                    ; /* invalid atom parity */</a>
<a name="ln3697">                }</a>
<a name="ln3698">            } else {</a>
<a name="ln3699">                ;/* add error message here */</a>
<a name="ln3700">            }</a>
<a name="ln3701">        }</a>
<a name="ln3702"> </a>
<a name="ln3703">        len = len0 = strlen( at[j].elname );</a>
<a name="ln3704">        memcpy( szCurAtom, at[j].elname, len );</a>
<a name="ln3705">        bonds_val = nBondsValenceInpAt( at+j, NULL, NULL );</a>
<a name="ln3706"> </a>
<a name="ln3707">        if ( (val=needed_unusual_el_valence( at[j].el_number, at[j].charge, at[j].radical,</a>
<a name="ln3708">                                 at[j].chem_bonds_valence, bonds_val, at[j].num_H, at[j].valence )) ||</a>
<a name="ln3709">             at[j].charge || at[j].radical || at[j].iso_atw_diff || NUM_ISO_H(at,j) || parity ) {</a>
<a name="ln3710">            /* valence */</a>
<a name="ln3711">            if ( val ) {</a>
<a name="ln3712">                len += sprintf( szCurAtom + len, &quot;%d&quot;, val &gt; 0? val : 0 );</a>
<a name="ln3713">            }</a>
<a name="ln3714">            /* charge */</a>
<a name="ln3715">            if ( (val = at[j].charge) ) {</a>
<a name="ln3716">                szCurAtom[len++] = val&gt;0? '+' : '-';</a>
<a name="ln3717">                if ( (val = abs(val)) &gt; 1 ) {</a>
<a name="ln3718">                    len += sprintf( szCurAtom + len, &quot;%d&quot;, val );</a>
<a name="ln3719">                }</a>
<a name="ln3720">            }</a>
<a name="ln3721">            /* radical */</a>
<a name="ln3722">            if ( (val = at[j].radical) ) {</a>
<a name="ln3723">                len += sprintf(szCurAtom + len, &quot;.%d&quot;, val);</a>
<a name="ln3724">            }</a>
<a name="ln3725">            /* isotopic shift */</a>
<a name="ln3726">            if ( (val = at[j].iso_atw_diff) ) {</a>
<a name="ln3727">                mw = get_atw_from_elnum( at[j].el_number );</a>
<a name="ln3728">                if ( val == 1 )</a>
<a name="ln3729">                    val = mw;</a>
<a name="ln3730">                else</a>
<a name="ln3731">                if ( val &gt; 0 )</a>
<a name="ln3732">                    val = mw + val -1;</a>
<a name="ln3733">                else</a>
<a name="ln3734">                    val = mw + val;</a>
<a name="ln3735">                len += sprintf( szCurAtom + len, &quot;%si%d&quot;, len == len0? &quot;.&quot;:&quot;&quot;, val );</a>
<a name="ln3736">            }</a>
<a name="ln3737">            /* parity */</a>
<a name="ln3738">            if ( parity ) {</a>
<a name="ln3739">                len += sprintf( szCurAtom + len, &quot;%s%s&quot;, len == len0? &quot;.&quot;:&quot;&quot;,</a>
<a name="ln3740">                                parity == AB_PARITY_ODD?   &quot;o&quot; :</a>
<a name="ln3741">                                parity == AB_PARITY_EVEN?  &quot;e&quot; :</a>
<a name="ln3742">                                parity == AB_PARITY_UNKN?  &quot;u&quot; :</a>
<a name="ln3743">                                parity == AB_PARITY_UNDF?  &quot;?&quot; : &quot;&quot; );</a>
<a name="ln3744">            }</a>
<a name="ln3745">            /* implicit isotopic H */</a>
<a name="ln3746">            if ( NUM_ISO_H(at,j) ) {</a>
<a name="ln3747">                for ( k = 0; k &lt; NUM_H_ISOTOPES; k ++ ) {</a>
<a name="ln3748">                    if ( (val = at[j].num_iso_H[k]) ) {</a>
<a name="ln3749">                        len += sprintf( szCurAtom + len, &quot;%s%c&quot;, len == len0? &quot;.&quot;:&quot;&quot;, szIsoH[k] );</a>
<a name="ln3750">                        if ( val &gt; 1 ) {</a>
<a name="ln3751">                            len += sprintf(szCurAtom + len, &quot;%d&quot;, val);</a>
<a name="ln3752">                        }</a>
<a name="ln3753">                    }</a>
<a name="ln3754">                }</a>
<a name="ln3755">            }</a>
<a name="ln3756">        }</a>
<a name="ln3757">        if ( len + cur_len &lt; buf_len ) {</a>
<a name="ln3758">            memcpy( szBuf + cur_len, szCurAtom, len );</a>
<a name="ln3759">            cur_len += len;</a>
<a name="ln3760">            j ++;</a>
<a name="ln3761">        } else {</a>
<a name="ln3762">            break;</a>
<a name="ln3763">        }</a>
<a name="ln3764">        szBuf[cur_len] = '\0';</a>
<a name="ln3765">        *i = j;</a>
<a name="ln3766"> </a>
<a name="ln3767">    }</a>
<a name="ln3768">    return cur_len;</a>
<a name="ln3769">}</a>
<a name="ln3770">/******************************************************************************************/</a>
<a name="ln3771">/*</a>
<a name="ln3772"> &lt;bonds&gt; bpA;bpAbpA... &lt;/bonds&gt;</a>
<a name="ln3773"> </a>
<a name="ln3774">b = bond type:</a>
<a name="ln3775">=============</a>
<a name="ln3776">w = undefined stereo, double</a>
<a name="ln3777">s = single</a>
<a name="ln3778">d = double</a>
<a name="ln3779">t = triple</a>
<a name="ln3780">a = aromatic</a>
<a name="ln3781">p = up from the current atom to the neighbor</a>
<a name="ln3782">P = uP from the neighbor to the current atom</a>
<a name="ln3783">v = undefined stereo Either, single from the current atom to the neighbor</a>
<a name="ln3784">V = undefined stereo Either, single from the neighbor to the current atom</a>
<a name="ln3785">n = down from the current atom to the neighbor</a>
<a name="ln3786">N = dowN from the neighbor to the current atom</a>
<a name="ln3787"> </a>
<a name="ln3788">p = bond parity:</a>
<a name="ln3789">================</a>
<a name="ln3790">- = odd</a>
<a name="ln3791">+ = even</a>
<a name="ln3792">u = unknown</a>
<a name="ln3793">? = undefined</a>
<a name="ln3794">  = no parity (empty)</a>
<a name="ln3795"> </a>
<a name="ln3796"> </a>
<a name="ln3797">A = neighbor orig. atom number</a>
<a name="ln3798">===============</a>
<a name="ln3799">neighbor orig. atom number &lt; number of the current atom</a>
<a name="ln3800">Number of the current atom: 2 until first &quot;;&quot;, 3 until 2nd &quot;;&quot;, etc.</a>
<a name="ln3801"> </a>
<a name="ln3802">*/</a>
<a name="ln3803"> </a>
<a name="ln3804">/************************************************************************************/</a>
<a name="ln3805">/* output bonds in ascending order of the neighboring atom original numbers */</a>
<a name="ln3806">int WriteOrigBonds( int num_inp_atoms, inp_ATOM *at, int *i, char *szBuf, int buf_len, STRUCT_DATA *sd)</a>
<a name="ln3807">{</a>
<a name="ln3808">    int j, k, k2, kk, len, cur_len, j2=0, bond_stereo, bond_char, bond_parity, bond_parityNM, num_trans;</a>
<a name="ln3809">    char szCurBonds[7*MAXVAL+2]; /* num_neigh*(1 byte bond type + 2 bytes for bond parity up to 4 digits per neighbor number) + at the end one ';' */</a>
<a name="ln3810">    AT_RANK nNeighOrder[MAXVAL];</a>
<a name="ln3811">    int  chain_len, pnxt_atom, pinxt2cur, pinxt_sb_parity_ord;</a>
<a name="ln3812">    int  chain_len2, pnxt_atom2, pinxt2cur2, pinxt_sb_parity_ord2, m1, m2;</a>
<a name="ln3813">    int  pcur_atom, picur2nxt, picur_sb_parity_ord;</a>
<a name="ln3814"> </a>
<a name="ln3815">    cur_len = 0;</a>
<a name="ln3816">    for ( j = *i; j &lt; num_inp_atoms; ) {</a>
<a name="ln3817">        len = 0;</a>
<a name="ln3818">        if ( at[j].valence &gt; 1 ) {</a>
<a name="ln3819">            for ( k = 0; k &lt; at[j].valence; k ++ ) {</a>
<a name="ln3820">                nNeighOrder[k] = k;</a>
<a name="ln3821">            }</a>
<a name="ln3822">            pn_RankForSort = at[j].neighbor;</a>
<a name="ln3823">            num_trans = insertions_sort( nNeighOrder, at[j].valence, sizeof(nNeighOrder[0]), CompRank );</a>
<a name="ln3824">        } else {</a>
<a name="ln3825">            num_trans = 0;</a>
<a name="ln3826">            nNeighOrder[0] = 0;</a>
<a name="ln3827">        }</a>
<a name="ln3828">        for ( kk = 0; kk &lt; at[j].valence; kk ++ ) {</a>
<a name="ln3829">            k = nNeighOrder[kk];</a>
<a name="ln3830">            j2 = at[j].neighbor[k];</a>
<a name="ln3831">            bond_parity = 0;</a>
<a name="ln3832">            bond_parityNM = 0;</a>
<a name="ln3833">            if ( j2 &lt; j ) {</a>
<a name="ln3834">                bond_stereo = at[j].bond_stereo[k];</a>
<a name="ln3835">                switch( at[j].bond_type[k] ) {</a>
<a name="ln3836">                case BOND_TYPE_SINGLE:</a>
<a name="ln3837">                    switch( bond_stereo ) {</a>
<a name="ln3838">                    case  STEREO_SNGL_UP:</a>
<a name="ln3839">                        bond_char = 'p';</a>
<a name="ln3840">                        break;</a>
<a name="ln3841">                    case -STEREO_SNGL_UP:</a>
<a name="ln3842">                        bond_char = 'P';</a>
<a name="ln3843">                        break;</a>
<a name="ln3844">                    case  STEREO_SNGL_DOWN:</a>
<a name="ln3845">                        bond_char = 'n';</a>
<a name="ln3846">                        break;</a>
<a name="ln3847">                    case -STEREO_SNGL_DOWN:</a>
<a name="ln3848">                        bond_char = 'N';</a>
<a name="ln3849">                        break;</a>
<a name="ln3850">#if ( FIX_EITHER_STEREO_IN_AUX_INFO == 1 )</a>
<a name="ln3851">                    case  STEREO_SNGL_EITHER:</a>
<a name="ln3852">                        bond_char = 'v';</a>
<a name="ln3853">                        break;</a>
<a name="ln3854">                    case -STEREO_SNGL_EITHER:</a>
<a name="ln3855">                        bond_char = 'V';</a>
<a name="ln3856">                        break;</a>
<a name="ln3857">#else</a>
<a name="ln3858">                    case  STEREO_SNGL_EITHER:</a>
<a name="ln3859">                    case -STEREO_SNGL_EITHER:</a>
<a name="ln3860">                        bond_char = 'v';</a>
<a name="ln3861">                        break;</a>
<a name="ln3862">#endif</a>
<a name="ln3863">                    default:</a>
<a name="ln3864">                        bond_char = 's';</a>
<a name="ln3865">                        break;</a>
<a name="ln3866">                    }</a>
<a name="ln3867">                    break;</a>
<a name="ln3868">                case BOND_TYPE_DOUBLE:</a>
<a name="ln3869">                    switch( bond_stereo ) {</a>
<a name="ln3870">                    case  STEREO_DBLE_EITHER:</a>
<a name="ln3871">                    case -STEREO_DBLE_EITHER:</a>
<a name="ln3872">                        bond_char = 'w';</a>
<a name="ln3873">                        break;</a>
<a name="ln3874">                    default:</a>
<a name="ln3875">                        bond_char = 'd';</a>
<a name="ln3876">                        break;</a>
<a name="ln3877">                    }</a>
<a name="ln3878">                    break;</a>
<a name="ln3879">                case BOND_TYPE_TRIPLE:</a>
<a name="ln3880">                    bond_char = 't';</a>
<a name="ln3881">                    break;</a>
<a name="ln3882">                case BOND_TYPE_ALTERN:</a>
<a name="ln3883">                    bond_char = 'a';</a>
<a name="ln3884">                    break;</a>
<a name="ln3885">                default:</a>
<a name="ln3886">                    bond_char = 's';</a>
<a name="ln3887">                    break;</a>
<a name="ln3888">                }</a>
<a name="ln3889">                /* check for allene/cumulene */</a>
<a name="ln3890">                k2 = is_in_the_list( at[j2].neighbor, (AT_NUMB)j, at[j2].valence ) - at[j2].neighbor;</a>
<a name="ln3891">                chain_len = chain_len2 = 0;</a>
<a name="ln3892">                if ( at[j].sb_parity[0] ) {</a>
<a name="ln3893">                    for ( m1 = 0; m1 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[j].sb_parity[m1]; m1 ++ ) {</a>
<a name="ln3894">                        if ( k == at[j].sb_ord[m1] ) {</a>
<a name="ln3895">                            chain_len = get_opposite_sb_atom( at, j, k,</a>
<a name="ln3896">                                          &amp;pnxt_atom, &amp;pinxt2cur, &amp;pinxt_sb_parity_ord );</a>
<a name="ln3897">                            break;</a>
<a name="ln3898">                        }</a>
<a name="ln3899">                    }</a>
<a name="ln3900">                }</a>
<a name="ln3901">                if ( at[j2].sb_parity[0] ) {</a>
<a name="ln3902">                    for ( m2 = 0; m2 &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[j2].sb_parity[m2]; m2 ++ ) {</a>
<a name="ln3903">                        if ( k2 == at[j2].sb_ord[m2] ) {</a>
<a name="ln3904">                            chain_len2 = get_opposite_sb_atom( at, j2, k2,</a>
<a name="ln3905">                                           &amp;pnxt_atom2, &amp;pinxt2cur2, &amp;pinxt_sb_parity_ord2 );</a>
<a name="ln3906">                            break;</a>
<a name="ln3907">                        }</a>
<a name="ln3908">                    }</a>
<a name="ln3909">                }</a>
<a name="ln3910">                if ( (chain_len == 1 &amp;&amp; chain_len2 == 1) ||  /* regular stereobond */</a>
<a name="ln3911">                     (chain_len  &gt; 1 &amp;&amp; j  &gt; pnxt_atom) ) {  /* j  is a cumulene endpoint */</a>
<a name="ln3912">                    int m;</a>
<a name="ln3913">                    pcur_atom = j;  /* pcur_atom &gt; pnxt_atom */</a>
<a name="ln3914">                    picur2nxt = k;</a>
<a name="ln3915">                    picur_sb_parity_ord = -1;</a>
<a name="ln3916">                    for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[pcur_atom].sb_parity[m]; m ++ ) {</a>
<a name="ln3917">                        if ( at[pcur_atom].sb_ord[m] == k ) {</a>
<a name="ln3918">                            picur_sb_parity_ord = m;</a>
<a name="ln3919">                            break;</a>
<a name="ln3920">                        }</a>
<a name="ln3921">                    }</a>
<a name="ln3922">                    chain_len2 = 0;</a>
<a name="ln3923">                } else</a>
<a name="ln3924">                if ( chain_len2 &gt; 1 &amp;&amp; j2 &gt; pnxt_atom2  ) { /* j2 is a cumulene endpoint */</a>
<a name="ln3925">                    int m;</a>
<a name="ln3926">                    pcur_atom = j2;</a>
<a name="ln3927">                    picur2nxt = k2;</a>
<a name="ln3928">                    pnxt_atom = pnxt_atom2;</a>
<a name="ln3929">                    pinxt2cur = pinxt2cur2;</a>
<a name="ln3930">                    pinxt_sb_parity_ord = pinxt_sb_parity_ord2;</a>
<a name="ln3931">                    picur_sb_parity_ord = -1;</a>
<a name="ln3932">                    for ( m = 0; m &lt; MAX_NUM_STEREO_BONDS &amp;&amp; at[pcur_atom].sb_parity[m]; m ++ ) {</a>
<a name="ln3933">                        if ( at[pcur_atom].sb_ord[m] == k2 )</a>
<a name="ln3934">                            picur_sb_parity_ord = m;</a>
<a name="ln3935">                    }</a>
<a name="ln3936">                    chain_len  = chain_len2;</a>
<a name="ln3937">                    chain_len2 = 0;</a>
<a name="ln3938">                } else {</a>
<a name="ln3939">                    chain_len = chain_len2 = 0;</a>
<a name="ln3940">                }</a>
<a name="ln3941"> </a>
<a name="ln3942">                /*len += sprintf( szCurBonds + len, &quot;%c%d&quot;, bond_char, val+1);*/</a>
<a name="ln3943">                if ( chain_len ) {</a>
<a name="ln3944">                    /* both atoms belong to a stereo bond */</a>
<a name="ln3945">                    int kc;</a>
<a name="ln3946">                    int p1, p2, p1NM, p2NM, neigh, neigh1, neigh2, bHasMetal, bWellDef;</a>
<a name="ln3947">                    int     bNeighSwitched1, bNeighSwitched2;</a>
<a name="ln3948"> </a>
<a name="ln3949">                    p1   = SB_PARITY_1(at[pcur_atom].sb_parity[picur_sb_parity_ord]);</a>
<a name="ln3950">                    p1NM = SB_PARITY_2(at[pcur_atom].sb_parity[picur_sb_parity_ord]);</a>
<a name="ln3951">                    p2   = SB_PARITY_1(at[pnxt_atom].sb_parity[pinxt_sb_parity_ord]);</a>
<a name="ln3952">                    p2NM = SB_PARITY_2(at[pnxt_atom].sb_parity[pinxt_sb_parity_ord]);</a>
<a name="ln3953"> </a>
<a name="ln3954">                    bWellDef  = ATOM_PARITY_WELL_DEF(p1)   &amp;&amp; ATOM_PARITY_WELL_DEF(p2);</a>
<a name="ln3955">                    bHasMetal = ATOM_PARITY_WELL_DEF(p1NM) &amp;&amp; ATOM_PARITY_WELL_DEF(p2NM);</a>
<a name="ln3956"> </a>
<a name="ln3957">                    bNeighSwitched1 = bNeighSwitched2 = 0;</a>
<a name="ln3958"> </a>
<a name="ln3959">                    if ( bWellDef || bHasMetal ) {</a>
<a name="ln3960"> </a>
<a name="ln3961">                        neigh1  = num_inp_atoms;</a>
<a name="ln3962">                        for ( kc = 0; kc &lt; at[pcur_atom].valence; kc ++ ) {</a>
<a name="ln3963">                            if ( kc == picur2nxt )</a>
<a name="ln3964">                                continue;</a>
<a name="ln3965">                            neigh = at[pcur_atom].neighbor[kc];</a>
<a name="ln3966">                            if ( bHasMetal &amp;&amp; is_el_a_metal( at[neigh].el_number ) )</a>
<a name="ln3967">                                continue;</a>
<a name="ln3968">                            if ( neigh &lt; neigh1 )</a>
<a name="ln3969">                                neigh1 = neigh;</a>
<a name="ln3970">                        }</a>
<a name="ln3971">                        if ( neigh1 &lt; num_inp_atoms ) {</a>
<a name="ln3972">                             bNeighSwitched1 = (neigh1 != at[pcur_atom].neighbor[(int)at[pcur_atom].sn_ord[picur_sb_parity_ord]]);</a>
<a name="ln3973">                        } else {</a>
<a name="ln3974">                            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot find 0D stereobond neighbor&quot;);</a>
<a name="ln3975">                            /*</a>
<a name="ln3976">                            sd-&gt;nStructReadError =  99;</a>
<a name="ln3977">                            sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln3978">                            */</a>
<a name="ln3979"> </a>
<a name="ln3980">                        }</a>
<a name="ln3981"> </a>
<a name="ln3982">                        neigh2  = num_inp_atoms;</a>
<a name="ln3983">                        for ( kc = 0; kc &lt; at[pnxt_atom].valence; kc ++ ) {</a>
<a name="ln3984">                            if ( kc == pinxt2cur )</a>
<a name="ln3985">                                continue;</a>
<a name="ln3986">                            neigh = at[pnxt_atom].neighbor[kc];</a>
<a name="ln3987">                            if ( bHasMetal &amp;&amp; is_el_a_metal( at[neigh].el_number ) )</a>
<a name="ln3988">                                continue;</a>
<a name="ln3989">                            if ( neigh &lt; neigh2 )</a>
<a name="ln3990">                                neigh2 = neigh;</a>
<a name="ln3991">                        }</a>
<a name="ln3992">                        if ( neigh2 &lt; num_inp_atoms ) {</a>
<a name="ln3993">                             bNeighSwitched2 = (neigh2 != at[pnxt_atom].neighbor[(int)at[pnxt_atom].sn_ord[pinxt_sb_parity_ord]]);</a>
<a name="ln3994">                        } else {</a>
<a name="ln3995">                            AddMOLfileError(sd-&gt;pStrErrStruct, &quot;Cannot find 0D stereobond neighbor&quot;);</a>
<a name="ln3996">                            /*</a>
<a name="ln3997">                            sd-&gt;nStructReadError =  99;</a>
<a name="ln3998">                            sd-&gt;nErrorType = _IS_ERROR;</a>
<a name="ln3999">                            */</a>
<a name="ln4000"> </a>
<a name="ln4001">                        }</a>
<a name="ln4002"> </a>
<a name="ln4003">                        if ( neigh1 &lt; num_inp_atoms &amp;&amp; neigh2 &lt; num_inp_atoms ) {</a>
<a name="ln4004">                            if ( ATOM_PARITY_WELL_DEF(p1) &amp;&amp; ATOM_PARITY_WELL_DEF(p2) ) {</a>
<a name="ln4005">                                bond_parity = 2 - (p1 + p2 + bNeighSwitched1 + bNeighSwitched2) % 2;</a>
<a name="ln4006">                            } else {</a>
<a name="ln4007">                                bond_parity = inchi_min( p1, p2 );</a>
<a name="ln4008">                            }</a>
<a name="ln4009"> </a>
<a name="ln4010">                            if ( bHasMetal ) {</a>
<a name="ln4011">                                bond_parityNM = 2 - (p1NM + p2NM + bNeighSwitched1 + bNeighSwitched2) % 2;</a>
<a name="ln4012">                            } else</a>
<a name="ln4013">                            if ( p1NM &amp;&amp; p2NM ) {</a>
<a name="ln4014">                                bond_parityNM = inchi_min( p1NM, p2NM );</a>
<a name="ln4015">                            }</a>
<a name="ln4016">                        }</a>
<a name="ln4017">                    } else {</a>
<a name="ln4018">                        if ( p1 &amp;&amp; p2 ) {</a>
<a name="ln4019">                            bond_parity = inchi_min( p1, p2 );</a>
<a name="ln4020">                        }</a>
<a name="ln4021">                        if ( p1NM &amp;&amp; p2NM ) {</a>
<a name="ln4022">                            bond_parityNM = inchi_min( p1NM, p2NM );</a>
<a name="ln4023">                        }</a>
<a name="ln4024">                        if ( bond_parityNM &amp;&amp; !bond_parity ) {</a>
<a name="ln4025">                            bond_parity = AB_PARITY_UNDF;</a>
<a name="ln4026">                        }</a>
<a name="ln4027">                    }</a>
<a name="ln4028">                }</a>
<a name="ln4029">                len += sprintf( szCurBonds + len, &quot;%c%s%s%d&quot;,</a>
<a name="ln4030"> </a>
<a name="ln4031">                                                  bond_char,</a>
<a name="ln4032"> </a>
<a name="ln4033">                                                  (bond_parity == AB_PARITY_ODD)?  &quot;-&quot; :</a>
<a name="ln4034">                                                  (bond_parity == AB_PARITY_EVEN)? &quot;+&quot; :</a>
<a name="ln4035">                                                  (bond_parity == AB_PARITY_UNKN)? &quot;u&quot; :</a>
<a name="ln4036">                                                  (bond_parity == AB_PARITY_UNDF)? &quot;?&quot; : &quot;&quot;,</a>
<a name="ln4037"> </a>
<a name="ln4038">                                                  (bond_parityNM == AB_PARITY_ODD)?  &quot;-&quot; :</a>
<a name="ln4039">                                                  (bond_parityNM == AB_PARITY_EVEN)? &quot;+&quot; :</a>
<a name="ln4040">                                                  (bond_parityNM == AB_PARITY_UNKN)? &quot;u&quot; :</a>
<a name="ln4041">                                                  (bond_parityNM == AB_PARITY_UNDF)? &quot;?&quot; : &quot;&quot;,</a>
<a name="ln4042"> </a>
<a name="ln4043">                                                  j2+1);</a>
<a name="ln4044">            }</a>
<a name="ln4045">        }</a>
<a name="ln4046">        if ( len + cur_len + 2 &lt; buf_len ) {</a>
<a name="ln4047">            memcpy( szBuf + cur_len, szCurBonds, len );</a>
<a name="ln4048">            cur_len += len;</a>
<a name="ln4049">            szBuf[ cur_len ++ ] = ';';</a>
<a name="ln4050">            j ++;</a>
<a name="ln4051">        } else {</a>
<a name="ln4052">            break;</a>
<a name="ln4053">        }</a>
<a name="ln4054">    }</a>
<a name="ln4055">    szBuf[cur_len] = '\0';</a>
<a name="ln4056">    *i = num_inp_atoms&gt;0? j : 0;</a>
<a name="ln4057">    return cur_len;</a>
<a name="ln4058">}</a>
<a name="ln4059"> </a>
<a name="ln4060"> </a>
<a name="ln4061">#define ORIG_STR_BUFLEN (7*MAXVAL+2)  /* &gt; 7*MAXVAL+2 = 142 */</a>
<a name="ln4062">/******************************************************************************************/</a>
<a name="ln4063">int FillOutOrigStruct( ORIG_ATOM_DATA *orig_inp_data, ORIG_STRUCT *pOrigStruct, STRUCT_DATA *sd )</a>
<a name="ln4064">{</a>
<a name="ln4065">    char szBuf[ORIG_STR_BUFLEN];</a>
<a name="ln4066">    int  i, len, len_coord, len_atoms, len_bonds;</a>
<a name="ln4067">    /* coordinates */</a>
<a name="ln4068">    len_coord = i = 0;</a>
<a name="ln4069"> </a>
<a name="ln4070">    if (orig_inp_data-&gt;szCoord) {</a>
<a name="ln4071"> </a>
<a name="ln4072">        while ( (len = WriteOrigCoord( orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln4073">                                      orig_inp_data-&gt;szCoord, &amp;i, szBuf, sizeof(szBuf) )) ) {</a>
<a name="ln4074">            len_coord += len;</a>
<a name="ln4075">        }</a>
<a name="ln4076">        pOrigStruct-&gt;szCoord = (char*) inchi_malloc( (len_coord + 1)*sizeof(pOrigStruct-&gt;szCoord[0]) );</a>
<a name="ln4077">        i = 0;</a>
<a name="ln4078">        if ( pOrigStruct-&gt;szCoord &amp;&amp;</a>
<a name="ln4079">             len_coord == WriteOrigCoord( orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln4080">                                      orig_inp_data-&gt;szCoord, &amp;i, pOrigStruct-&gt;szCoord, len_coord+1 ) &amp;&amp;</a>
<a name="ln4081">             i == orig_inp_data-&gt;num_inp_atoms ) {</a>
<a name="ln4082">            /* success */</a>
<a name="ln4083">            if ( orig_inp_data-&gt;szCoord ) {</a>
<a name="ln4084">                inchi_free( orig_inp_data-&gt;szCoord );</a>
<a name="ln4085">                orig_inp_data-&gt;szCoord = NULL;</a>
<a name="ln4086">            }</a>
<a name="ln4087">        } else {</a>
<a name="ln4088">            return -1;</a>
<a name="ln4089">        }</a>
<a name="ln4090"> </a>
<a name="ln4091">    }</a>
<a name="ln4092"> </a>
<a name="ln4093">    /* atoms */</a>
<a name="ln4094">    len_atoms = i = 0;</a>
<a name="ln4095">    while ( (len = WriteOrigAtoms( orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln4096">                                  orig_inp_data-&gt;at, &amp;i, szBuf, sizeof(szBuf), sd)) ) {</a>
<a name="ln4097">        len_atoms += len;</a>
<a name="ln4098">        if ( !orig_inp_data-&gt;num_inp_atoms )</a>
<a name="ln4099">            break;</a>
<a name="ln4100">    }</a>
<a name="ln4101">    pOrigStruct-&gt;szAtoms = (char*) inchi_malloc( (len_atoms + 1)*sizeof(pOrigStruct-&gt;szAtoms[0]) );</a>
<a name="ln4102">    i = 0;</a>
<a name="ln4103">    if ( pOrigStruct-&gt;szAtoms &amp;&amp;</a>
<a name="ln4104">         len_atoms == WriteOrigAtoms( orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln4105">                                  orig_inp_data-&gt;at, &amp;i, pOrigStruct-&gt;szAtoms, len_atoms+1, sd ) &amp;&amp;</a>
<a name="ln4106">         i == orig_inp_data-&gt;num_inp_atoms ) {</a>
<a name="ln4107">        ; /* success */</a>
<a name="ln4108">    } else {</a>
<a name="ln4109">        return -1;</a>
<a name="ln4110">    }</a>
<a name="ln4111">    /* bonds */</a>
<a name="ln4112">    len_bonds = 0;</a>
<a name="ln4113">    i = 1;</a>
<a name="ln4114">    while ( (len = WriteOrigBonds( orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln4115">                                  orig_inp_data-&gt;at, &amp;i, szBuf, sizeof(szBuf), NULL)) ) {</a>
<a name="ln4116">        len_bonds += len;</a>
<a name="ln4117">        if ( !orig_inp_data-&gt;num_inp_atoms )</a>
<a name="ln4118">            break;</a>
<a name="ln4119">    }</a>
<a name="ln4120">    pOrigStruct-&gt;szBonds = (char*) inchi_malloc( (len_bonds + 2)*sizeof(pOrigStruct-&gt;szBonds[0]) );</a>
<a name="ln4121">    i = 1;</a>
<a name="ln4122">    if ( pOrigStruct-&gt;szBonds &amp;&amp;</a>
<a name="ln4123">         len_bonds == WriteOrigBonds( orig_inp_data-&gt;num_inp_atoms,</a>
<a name="ln4124">                                  orig_inp_data-&gt;at, &amp;i, pOrigStruct-&gt;szBonds, len_bonds+2, sd ) &amp;&amp;</a>
<a name="ln4125">         i == orig_inp_data-&gt;num_inp_atoms ) {</a>
<a name="ln4126">        ; /* success */</a>
<a name="ln4127">    } else {</a>
<a name="ln4128">        return -1;</a>
<a name="ln4129">    }</a>
<a name="ln4130">    pOrigStruct-&gt;num_atoms = orig_inp_data-&gt;num_inp_atoms;</a>
<a name="ln4131">    return 0;</a>
<a name="ln4132">}</a>
<a name="ln4133">/*****************************************************************/</a>
<a name="ln4134">void FreeOrigStruct(  ORIG_STRUCT *pOrigStruct)</a>
<a name="ln4135">{</a>
<a name="ln4136">    if ( pOrigStruct ) {</a>
<a name="ln4137">        if ( pOrigStruct-&gt;szAtoms )</a>
<a name="ln4138">            inchi_free( pOrigStruct-&gt;szAtoms );</a>
<a name="ln4139">        if ( pOrigStruct-&gt;szBonds )</a>
<a name="ln4140">            inchi_free( pOrigStruct-&gt;szBonds );</a>
<a name="ln4141">        if ( pOrigStruct-&gt;szCoord )</a>
<a name="ln4142">            inchi_free( pOrigStruct-&gt;szCoord );</a>
<a name="ln4143">        memset( pOrigStruct, 0, sizeof(*pOrigStruct) );</a>
<a name="ln4144"> </a>
<a name="ln4145">    }</a>
<a name="ln4146">}</a>
<a name="ln4147"> </a>
<a name="ln4148"> </a>
<a name="ln4149"> </a>
<a name="ln4150">/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln4151">Get the two letters encoding the saved InChI creation options.</a>
<a name="ln4152"> </a>
<a name="ln4153">The first one encodes RecMet/FixedH/SUU/SLUUD options.</a>
<a name="ln4154">Each of options is a binary switch {ON,OFF}, so it totals to 2*2*2*2=16 values</a>
<a name="ln4155">which are encoded by capital letters �A� through �P�.</a>
<a name="ln4156"> </a>
<a name="ln4157">The second character encodes experimental (InChI 1 extension) options KET and 15T.</a>
<a name="ln4158">Each of these options is a binary switch ON/OFF, so there are 2*2=4 combinations,</a>
<a name="ln4159">currently encoded by �A� through �D�.</a>
<a name="ln4160">Note that anything but 'A' here would indicate &quot;extended&quot; InChI 1 Also, there is a</a>
<a name="ln4161">reservation for future needs: the 2nd memo char may accommodate two more ON/OFF</a>
<a name="ln4162">binary options (at 26-base encoding).</a>
<a name="ln4163">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/</a>
<a name="ln4164">void GetSaveOptLetters(unsigned char save_opt_bits, char* let1, char* let2)</a>
<a name="ln4165">{</a>
<a name="ln4166">const char a2p[]=&quot;ABCDEFGHIJKLMNOP&quot;;</a>
<a name="ln4167">    /* SaveOptBits layout: {unused|unused|Ket|15T|RecMet|FixedH|SUU|SLUUD} */</a>
<a name="ln4168">    *let1 = a2p [ (size_t) ( save_opt_bits &amp; 0x0f ) ];</a>
<a name="ln4169">    *let2 = a2p [ (size_t) ( (save_opt_bits &amp; 0x30) &gt;&gt; 4 ) ];</a>
<a name="ln4170">}</a>

</code></pre>
<div class="balloon" rel="674"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pNewErrorText' is always false.</p></div>
<div class="balloon" rel="714"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 714, 724</p></div>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 760, 779, 798</p></div>
<div class="balloon" rel="843"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 843, 853</p></div>
<div class="balloon" rel="969"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 969, 978</p></div>
<div class="balloon" rel="1014"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1014, 1024</p></div>
<div class="balloon" rel="1141"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nTag == 2' is always true.</p></div>
<div class="balloon" rel="1365"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'is' pointer was used unsafely after it was verified against nullptr. Check lines: 1369, 1365.</p></div>
<div class="balloon" rel="1406"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'j == 1' is always true.</p></div>
<div class="balloon" rel="1386"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1386, 1398</p></div>
<div class="balloon" rel="1614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'pINChI->Stereo' pointer was used unsafely after it was verified against nullptr. Check lines: 1541, 1614.</p></div>
<div class="balloon" rel="1617"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'pINChI->StereoIsotopic' pointer was used unsafely after it was verified against nullptr. Check lines: 1541, 1617.</p></div>
<div class="balloon" rel="1614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pINChI->Stereo' pointer was utilized before it was verified against nullptr. Check lines: 1614, 1618.</p></div>
<div class="balloon" rel="1477"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'j == 0' is always true.</p></div>
<div class="balloon" rel="1457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1457, 1469</p></div>
<div class="balloon" rel="1597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: bCurRacemic > 1.</p></div>
<div class="balloon" rel="1598"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'bCurIsoRacemic > 1' is always false.</p></div>
<div class="balloon" rel="1932"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'bFhTag' variable was assigned the same value.</p></div>
<div class="balloon" rel="2000"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'i' variable is assigned to itself.</p></div>
<div class="balloon" rel="2345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 2343, 2345.</p></div>
<div class="balloon" rel="2631"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'bXml' is always false.</p></div>
<div class="balloon" rel="2628"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'tot_len' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2621, 2628.</p></div>
<div class="balloon" rel="3005"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 2990, 3005.</p></div>
<div class="balloon" rel="4083"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'orig_inp_data->szCoord' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

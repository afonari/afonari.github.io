
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>nwchemformat.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">Copyright (C) 2001-2006 by Geoffrey R. Hutchison</a>
<a name="ln3">Some portions Copyright (C) 2004 by Chris Morley</a>
<a name="ln4">Some portions Copyright (C) 2009 by Michael Banck</a>
<a name="ln5"> </a>
<a name="ln6">This program is free software; you can redistribute it and/or modify</a>
<a name="ln7">it under the terms of the GNU General Public License as published by</a>
<a name="ln8">the Free Software Foundation version 2 of the License.</a>
<a name="ln9"> </a>
<a name="ln10">This program is distributed in the hope that it will be useful,</a>
<a name="ln11">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">GNU General Public License for more details.</a>
<a name="ln14">***********************************************************************/</a>
<a name="ln15">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;openbabel/obmolecformat.h&gt;</a>
<a name="ln18">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln19">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln20">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln21">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln22">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln23">#include &lt;openbabel/generic.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">// Required for imaginary frequencies detection</a>
<a name="ln27">#include &lt;cmath&gt;</a>
<a name="ln28">// Required for TS detection in ZTS calculation</a>
<a name="ln29">#include &lt;algorithm&gt;</a>
<a name="ln30">#define HARTREE_TO_KCAL 627.509469</a>
<a name="ln31">#define AU_TO_ANGSTROM 0.529177249</a>
<a name="ln32">#define EV_TO_NM(x) 1239.84193/x</a>
<a name="ln33"> </a>
<a name="ln34">using namespace std;</a>
<a name="ln35">namespace OpenBabel</a>
<a name="ln36">{</a>
<a name="ln37"> </a>
<a name="ln38">  class NWChemOutputFormat : public OBMoleculeFormat</a>
<a name="ln39">  {</a>
<a name="ln40">  public:</a>
<a name="ln41">    //Register this format type ID</a>
<a name="ln42">    NWChemOutputFormat()</a>
<a name="ln43">    {</a>
<a name="ln44">      OBConversion::RegisterFormat(&quot;nwo&quot;,this);</a>
<a name="ln45">    }</a>
<a name="ln46"> </a>
<a name="ln47">    virtual const char* Description() //required</a>
<a name="ln48">    {</a>
<a name="ln49">      return</a>
<a name="ln50">        &quot;NWChem output format\n&quot;</a>
<a name="ln51">        &quot;Read Options e.g. -as\n&quot;</a>
<a name="ln52">        &quot; s  Output single bonds only\n&quot;</a>
<a name="ln53">        &quot; f  Overwrite molecule if more than one\n&quot;</a>
<a name="ln54">        &quot;    calculation with different molecules\n&quot;</a>
<a name="ln55">        &quot;    is present in the output file\n&quot;</a>
<a name="ln56">        &quot;    (last calculation will be prefered)\n&quot;</a>
<a name="ln57">        &quot; b  Disable bonding entirely\n\n&quot;;</a>
<a name="ln58">    };</a>
<a name="ln59"> </a>
<a name="ln60">    virtual const char* SpecificationURL()</a>
<a name="ln61">    {return &quot;http://www.emsl.pnl.gov/docs/nwchem/&quot;;}; //optional</a>
<a name="ln62"> </a>
<a name="ln63">    //Flags() can return be any the following combined by | or be omitted if none apply</a>
<a name="ln64">    // NOTREADABLE  READONEONLY  NOTWRITABLE  WRITEONEONLY</a>
<a name="ln65">    virtual unsigned int Flags()</a>
<a name="ln66">    {</a>
<a name="ln67">      return READONEONLY | NOTWRITABLE;</a>
<a name="ln68">    };</a>
<a name="ln69"> </a>
<a name="ln70">    ////////////////////////////////////////////////////</a>
<a name="ln71">    /// The &quot;API&quot; interface functions</a>
<a name="ln72">    virtual bool ReadMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln73"> </a>
<a name="ln74">  private:</a>
<a name="ln75">    void ReadCoordinates(istream* ifs, OBMol* molecule);</a>
<a name="ln76">    void ReadPartialCharges(istream* ifs, OBMol* molecule);</a>
<a name="ln77">    void ReadOrbitals(istream* ifs, OBMol* molecule);</a>
<a name="ln78">    void ReadMultipoleMoment(istream* ifs, OBMol* molecule);</a>
<a name="ln79"> </a>
<a name="ln80">    void ReadFrequencyCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln81">    void ReadGeometryOptimizationCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln82">    void ReadSinglePointCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln83">    void ReadZTSCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln84">    void ReadTDDFTCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln85">    void ReadMEPCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln86">    void ReadNEBCalculation(istream* ifs, OBMol* molecule);</a>
<a name="ln87">  };</a>
<a name="ln88"> </a>
<a name="ln89">static const char* COORDINATES_PATTERN = &quot;Output coordinates&quot;;</a>
<a name="ln90">static const char* GEOMETRY_OPTIMIZATION_PATTERN = &quot;NWChem Geometry Optimization&quot;;</a>
<a name="ln91">static const char* PROPERTY_CALCULATION_PATTERN = &quot;NWChem Property Module&quot;;</a>
<a name="ln92">static const char* ZTS_CALCULATION_PATTERN = &quot; String method.&quot;;</a>
<a name="ln93">static const char* NEB_CALCULATION_PATTERN = &quot;NWChem Minimum Energy Pathway Program (NEB)&quot;;</a>
<a name="ln94">static const char* PYTHON_CALCULATION_PATTERN = &quot;NWChem Python program&quot;;</a>
<a name="ln95">static const char* ESP_CALCULATION_PATTERN = &quot;NWChem Electrostatic Potential Fit Module&quot;;</a>
<a name="ln96">static const char* SCF_CALCULATION_PATTERN = &quot;SCF Module&quot;;</a>
<a name="ln97">static const char* DFT_CALCULATION_PATTERN = &quot;DFT Module&quot;;</a>
<a name="ln98">static const char* TDDFT_CALCULATION_PATTERN = &quot;TDDFT Module&quot;;</a>
<a name="ln99">static const char* MEP_CALCULATION_PATTERN = &quot;Gonzalez &amp; Schlegel IRC Optimization&quot;;</a>
<a name="ln100">static const char* SCF_ENERGY_PATTERN = &quot;SCF energy =&quot;;</a>
<a name="ln101">static const char* DFT_ENERGY_PATTERN = &quot;DFT energy =&quot;;</a>
<a name="ln102">static const char* FREQUENCY_PATTERN = &quot;NWChem Nuclear Hessian and Frequency Analysis&quot;;</a>
<a name="ln103">static const char* OPTIMIZATION_STEP_PATTERN = &quot;Step       Energy&quot;;</a>
<a name="ln104">static const char* VIBRATIONS_TABLE_PATTERN = &quot;P.Frequency&quot;;</a>
<a name="ln105">static const char* INTENSITIES_TABLE_PATTERN = &quot;Projected Infra Red Intensities&quot;;</a>
<a name="ln106">static const char* DIGITS = &quot;1234567890&quot;;</a>
<a name="ln107">static const char* END_OF_CALCULATION_PATTERN = &quot;times  cpu&quot;;</a>
<a name="ln108">static const char* ORBITAL_START_PATTERN = &quot;Vector&quot;;</a>
<a name="ln109">static const char* ORBITAL_SECTION_PATTERN_1 = &quot;Analysis&quot;;</a>
<a name="ln110">static const char* ORBITAL_SECTION_PATTERN_2 = &quot;rbital&quot;;</a>
<a name="ln111">static const char* BETA_ORBITAL_PATTERN = &quot;Beta&quot;;</a>
<a name="ln112">static const char* MULLIKEN_CHARGES_PATTERN = &quot;Mulliken analysis of the total density&quot;;</a>
<a name="ln113">static const char* GEOMETRY_PATTERN = &quot;Geometry \&quot;geometry\&quot;&quot;;</a>
<a name="ln114">static const char* ZTS_CONVERGED_PATTERN = &quot; The string calculation &quot;;</a>
<a name="ln115">static const char* NBEADS_PATTERN = &quot; Number of replicas&quot;;</a>
<a name="ln116">static const char* ROOT_PATTERN = &quot;Root&quot;;</a>
<a name="ln117">static const char* OSCILATOR_STRENGTH_PATTERN = &quot;Oscillator Strength&quot;;</a>
<a name="ln118">static const char* SPIN_FORBIDDEN_PATTERN = &quot;Spin forbidden&quot;;</a>
<a name="ln119">static const char* MULTIPOLE_MOMENT_PATTERN = &quot;Multipole analysis of the density&quot;;</a>
<a name="ln120">static const char* MEP_STEP_END_PATTERN = &quot;&amp;  Point&quot;;</a>
<a name="ln121">static const char* NEB_BEAD_START_PATTERN = &quot;neb: running bead&quot;;</a>
<a name="ln122">static const char* NEB_BEAD_ENERGY_PATTERN = &quot;neb: final energy&quot;;</a>
<a name="ln123">static const char* NEB_NBEADS_PATTERN = &quot;number of images in path&quot;;</a>
<a name="ln124">static const char* GRADIENT_PATTERN = &quot;ENERGY GRADIENTS&quot;;</a>
<a name="ln125">// Two spaces are nessesary to avoid matching &quot;IRC Optimization converged&quot;</a>
<a name="ln126">static const char* OPTIMIZATION_END_PATTERN = &quot;  Optimization converged&quot;;</a>
<a name="ln127"> </a>
<a name="ln128">  //Make an instance of the format class</a>
<a name="ln129">  NWChemOutputFormat theNWChemOutputFormat;</a>
<a name="ln130"> </a>
<a name="ln131">  class NWChemInputFormat : public OBMoleculeFormat</a>
<a name="ln132">  {</a>
<a name="ln133">  public:</a>
<a name="ln134">    //Register this format type ID</a>
<a name="ln135">    NWChemInputFormat()</a>
<a name="ln136">    {</a>
<a name="ln137">      OBConversion::RegisterFormat(&quot;nw&quot;,this);</a>
<a name="ln138">    }</a>
<a name="ln139"> </a>
<a name="ln140">    virtual const char* Description() //required</a>
<a name="ln141">    {</a>
<a name="ln142">      return</a>
<a name="ln143">        &quot;NWChem input format\n&quot;</a>
<a name="ln144">        &quot;No comments yet\n&quot;;</a>
<a name="ln145">    };</a>
<a name="ln146"> </a>
<a name="ln147">    virtual const char* SpecificationURL()</a>
<a name="ln148">    {return &quot;http://www.emsl.pnl.gov/docs/nwchem/&quot;;}; //optional</a>
<a name="ln149"> </a>
<a name="ln150">    //Flags() can return be any the following combined by | or be omitted if none apply</a>
<a name="ln151">    // NOTREADABLE  READONEONLY  NOTWRITABLE  WRITEONEONLY</a>
<a name="ln152">    virtual unsigned int Flags()</a>
<a name="ln153">    {</a>
<a name="ln154">      return NOTREADABLE | WRITEONEONLY;</a>
<a name="ln155">    };</a>
<a name="ln156"> </a>
<a name="ln157">    ////////////////////////////////////////////////////</a>
<a name="ln158">    /// The &quot;API&quot; interface functions</a>
<a name="ln159">    virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln160"> </a>
<a name="ln161">  };</a>
<a name="ln162"> </a>
<a name="ln163">  //Make an instance of the format class</a>
<a name="ln164">  NWChemInputFormat theNWChemInputFormat;</a>
<a name="ln165"> </a>
<a name="ln166">  /////////////////////////////////////////////////////////////////</a>
<a name="ln167">  /**</a>
<a name="ln168">  Moves stream (ifs) position to end of calculation.</a>
<a name="ln169">  */</a>
<a name="ln170">  static void GotoCalculationEnd(istream* ifs)</a>
<a name="ln171">  {</a>
<a name="ln172">  char buffer[BUFF_SIZE];</a>
<a name="ln173">    while (strstr(buffer, END_OF_CALCULATION_PATTERN) == nullptr)</a>
<a name="ln174">        if (!ifs-&gt;getline(buffer,BUFF_SIZE))</a>
<a name="ln175">            break;</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">  //////////////////////////////////////////////////////</a>
<a name="ln180">  /**</a>
<a name="ln181">  Method reads coordinates from input stream (ifs) and</a>
<a name="ln182">  writes it into supplied OBMol object (molecule).</a>
<a name="ln183">  Input stream must be set to beginning of coordinates</a>
<a name="ln184">  table in nwo file. (Line after &quot;Output coordinates...&quot;)</a>
<a name="ln185">  Stream will be set at next line after geometry table.</a>
<a name="ln186">  If one of input arguments is NULL method returns without</a>
<a name="ln187">  any changes</a>
<a name="ln188">  If &quot;molecule&quot; already contain geometry - method will write</a>
<a name="ln189">  new geometry as conformer.</a>
<a name="ln190">  If &quot;molecule&quot; contain geometry which incompatible with read</a>
<a name="ln191">  data method returns without changes.</a>
<a name="ln192">  */</a>
<a name="ln193">  void NWChemOutputFormat::ReadCoordinates(istream* ifs, OBMol* molecule)</a>
<a name="ln194">  {</a>
<a name="ln195">    if (molecule == nullptr || ifs == nullptr)</a>
<a name="ln196">        return;</a>
<a name="ln197">    vector&lt;string&gt; vs;</a>
<a name="ln198">    char buffer[BUFF_SIZE];</a>
<a name="ln199">    double x, y, z;</a>
<a name="ln200">    unsigned int natoms = molecule-&gt;NumAtoms();</a>
<a name="ln201">    bool from_scratch = false;</a>
<a name="ln202">    double* coordinates;</a>
<a name="ln203">    if (natoms == 0)</a>
<a name="ln204">        from_scratch = true;</a>
<a name="ln205">    else</a>
<a name="ln206">        coordinates = new double[3*natoms];</a>
<a name="ln207">    ifs-&gt;getline(buffer,BUFF_SIZE);	// blank</a>
<a name="ln208">    ifs-&gt;getline(buffer,BUFF_SIZE);	// column headings</a>
<a name="ln209">    ifs-&gt;getline(buffer,BUFF_SIZE);	// ---- ----- ----</a>
<a name="ln210">    ifs-&gt;getline(buffer,BUFF_SIZE);</a>
<a name="ln211">    tokenize(vs,buffer);</a>
<a name="ln212">    unsigned int i=0;</a>
<a name="ln213">    while (vs.size() == 6)</a>
<a name="ln214">    {</a>
<a name="ln215">        x = atof((char*)vs[3].c_str());</a>
<a name="ln216">        y = atof((char*)vs[4].c_str());</a>
<a name="ln217">        z = atof((char*)vs[5].c_str());</a>
<a name="ln218">        if (from_scratch)</a>
<a name="ln219">        {</a>
<a name="ln220">            // set atomic number</a>
<a name="ln221">            OBAtom* atom = molecule-&gt;NewAtom();</a>
<a name="ln222">            atom-&gt;SetAtomicNum(atoi(vs[2].c_str()));</a>
<a name="ln223">            atom-&gt;SetVector(x,y,z);</a>
<a name="ln224">        }</a>
<a name="ln225">        else</a>
<a name="ln226">        {</a>
<a name="ln227">            // check atomic number</a>
<a name="ln228">            if ((i&gt;=natoms) || (molecule-&gt;GetAtom(i+1)-&gt;GetAtomicNum() != atoi(vs[2].c_str())))</a>
<a name="ln229">            {</a>
<a name="ln230">                delete[] coordinates;</a>
<a name="ln231">                return;</a>
<a name="ln232">            }</a>
<a name="ln233">            coordinates[i*3] = x;</a>
<a name="ln234">            coordinates[i*3+1] = y;</a>
<a name="ln235">            coordinates[i*3+2] = z;</a>
<a name="ln236">            i++;</a>
<a name="ln237">        }</a>
<a name="ln238">        if (!ifs-&gt;getline(buffer,BUFF_SIZE))</a>
<a name="ln239">          break;</a>
<a name="ln240">        tokenize(vs,buffer);</a>
<a name="ln241">    }</a>
<a name="ln242">    if (from_scratch) </a>
<a name="ln243">    {</a>
<a name="ln244">        return;</a>
<a name="ln245">    }</a>
<a name="ln246">    if (i != natoms) {</a>
<a name="ln247">        delete[] coordinates;</a>
<a name="ln248">        return;</a>
<a name="ln249">    }</a>
<a name="ln250">    molecule-&gt;AddConformer(coordinates);</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">//////////////////////////////////////////////////////</a>
<a name="ln254">  /**</a>
<a name="ln255">  Method reads charge, dipole and quadrupole moment from input stream (ifs)</a>
<a name="ln256">  and writes them to supplied OBMol object (molecule)</a>
<a name="ln257">  Input stream must be set to beginning of Multipole moment</a>
<a name="ln258">  section in nwo file. (Line after &quot;Multipole analysis of the density&quot;)</a>
<a name="ln259">  Stream will be set to the end of multipole moment section.</a>
<a name="ln260">  */</a>
<a name="ln261">  void NWChemOutputFormat::ReadMultipoleMoment(istream* ifs, OBMol* molecule)</a>
<a name="ln262">  {</a>
<a name="ln263">    if (ifs == nullptr || molecule == nullptr)</a>
<a name="ln264">        return;</a>
<a name="ln265"> </a>
<a name="ln266">    char buffer[BUFF_SIZE];</a>
<a name="ln267">    vector&lt;string&gt; vs;</a>
<a name="ln268">    matrix3x3 quadrupole;</a>
<a name="ln269">    double dipole[3];</a>
<a name="ln270">    int charge;</a>
<a name="ln271">    bool blank_line = false;</a>
<a name="ln272"> </a>
<a name="ln273">    ifs-&gt;getline(buffer, BUFF_SIZE); // -------</a>
<a name="ln274">    ifs-&gt;getline(buffer, BUFF_SIZE); // blank</a>
<a name="ln275">    ifs-&gt;getline(buffer, BUFF_SIZE); // Header</a>
<a name="ln276">    ifs-&gt;getline(buffer, BUFF_SIZE); // -------</a>
<a name="ln277"> </a>
<a name="ln278">    while (ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln279">    {</a>
<a name="ln280">        tokenize(vs, buffer);</a>
<a name="ln281">        // L   x y z        total         alpha         beta         nuclear</a>
<a name="ln282">        // L   x y z        total         open         nuclear</a>
<a name="ln283">        // 0   1 2 3          4             5            6             7</a>
<a name="ln284">        if (vs.size() &lt; 7)</a>
<a name="ln285">        {</a>
<a name="ln286">            if (blank_line)</a>
<a name="ln287">            {</a>
<a name="ln288">                molecule-&gt;SetTotalCharge(charge);</a>
<a name="ln289">                OBVectorData* dipole_moment = new OBVectorData;</a>
<a name="ln290">                dipole_moment-&gt;SetData(vector3(dipole));</a>
<a name="ln291">                dipole_moment-&gt;SetAttribute(&quot;Dipole Moment&quot;);</a>
<a name="ln292">                molecule-&gt;SetData(dipole_moment);</a>
<a name="ln293">                OBMatrixData* quadrupole_moment = new OBMatrixData;</a>
<a name="ln294">                quadrupole_moment-&gt;SetData(quadrupole);</a>
<a name="ln295">                quadrupole_moment-&gt;SetAttribute(&quot;Quadrupole Moment&quot;);</a>
<a name="ln296">                molecule-&gt;SetData(quadrupole_moment);</a>
<a name="ln297">                return;</a>
<a name="ln298">            }</a>
<a name="ln299">            // Second blank line means end of multipole section</a>
<a name="ln300">            blank_line = true;</a>
<a name="ln301">            continue;</a>
<a name="ln302">        }</a>
<a name="ln303">        blank_line = false;</a>
<a name="ln304">        if (vs[0][0] == '0')</a>
<a name="ln305">            charge = atoi(vs[4].c_str());</a>
<a name="ln306">        else if (vs[0][0] == '1')</a>
<a name="ln307">            for (unsigned int i = 0; i &lt; 3; i++)</a>
<a name="ln308">                if (vs[i+1][0] == '1')</a>
<a name="ln309">                    dipole[i] = atof(vs[4].c_str());</a>
<a name="ln310">        else if (vs[0][0] == '2')</a>
<a name="ln311">        {</a>
<a name="ln312">            double value = atof(vs[4].c_str());</a>
<a name="ln313">            unsigned int i[2], j = 0;</a>
<a name="ln314">            for (unsigned int k = 0 ; k&lt;3; k++)</a>
<a name="ln315">            {</a>
<a name="ln316">                if (vs[k+1][0] == '2')</a>
<a name="ln317">                    i[0] = i[1] = k; // Diagonal elements</a>
<a name="ln318">                else if (vs[k+1][0] == '1')</a>
<a name="ln319">                    i[j++] = k;</a>
<a name="ln320">            }</a>
<a name="ln321">            quadrupole.Set(i[0], i[1], value);</a>
<a name="ln322">            quadrupole.Set(i[1], i[0], value);</a>
<a name="ln323">        }</a>
<a name="ln324">        else</a>
<a name="ln325">            return;</a>
<a name="ln326">    }</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  //////////////////////////////////////////////////////</a>
<a name="ln330">  /**</a>
<a name="ln331">  Method reads UV Spectra from input stream (ifs)</a>
<a name="ln332">  and writes them to supplied OBMol object (molecule)</a>
<a name="ln333">  Input stream must be set to beginning of TDDFT</a>
<a name="ln334">  calculation in nwo file. (Line after &quot;NWChem TDDFT Module&quot;)</a>
<a name="ln335">  Stream will be set to the end of calculation.</a>
<a name="ln336">  */</a>
<a name="ln337">  void NWChemOutputFormat::ReadTDDFTCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln338">  {</a>
<a name="ln339">    if (ifs == nullptr || molecule == nullptr)</a>
<a name="ln340">        return;</a>
<a name="ln341"> </a>
<a name="ln342">    char buffer[BUFF_SIZE];</a>
<a name="ln343">    vector&lt;string&gt; vs;</a>
<a name="ln344">    vector&lt;double&gt; wavelengths;</a>
<a name="ln345">    vector&lt;double&gt; oscilator_strengths;</a>
<a name="ln346"> </a>
<a name="ln347">    while (ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln348">    {</a>
<a name="ln349">        if (strstr(buffer, ROOT_PATTERN) != nullptr)</a>
<a name="ln350">        {</a>
<a name="ln351">            tokenize(vs, buffer);</a>
<a name="ln352">            //  Root   1 singlet b2             0.294221372 a.u.                8.0062 eV</a>
<a name="ln353">            //   0     1    2    3                  4        5                    6    7</a>
<a name="ln354">            if (vs.size() &lt; 8)</a>
<a name="ln355">                break;</a>
<a name="ln356">            wavelengths.push_back(EV_TO_NM(atof(vs[6].c_str())));</a>
<a name="ln357">        }</a>
<a name="ln358">        else if (strstr(buffer, OSCILATOR_STRENGTH_PATTERN) != nullptr)</a>
<a name="ln359">        {</a>
<a name="ln360">            if (strstr(buffer, SPIN_FORBIDDEN_PATTERN) != nullptr)</a>
<a name="ln361">                oscilator_strengths.push_back(0);</a>
<a name="ln362">            else</a>
<a name="ln363">            {</a>
<a name="ln364">                tokenize(vs, buffer);</a>
<a name="ln365">                // Dipole Oscillator Strength                         0.01418</a>
<a name="ln366">                //   0        1         2                                3</a>
<a name="ln367">                if (vs.size() &lt; 4)</a>
<a name="ln368">                    break;</a>
<a name="ln369">                oscilator_strengths.push_back(atof(vs[3].c_str()));</a>
<a name="ln370">            }</a>
<a name="ln371">        }</a>
<a name="ln372">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln373">            break;</a>
<a name="ln374">    }</a>
<a name="ln375">    if (wavelengths.size() != oscilator_strengths.size())</a>
<a name="ln376">        return;</a>
<a name="ln377">    OBElectronicTransitionData* et_data = new OBElectronicTransitionData;</a>
<a name="ln378">    et_data-&gt;SetData(wavelengths, oscilator_strengths);</a>
<a name="ln379">    molecule-&gt;SetData(et_data);</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  //////////////////////////////////////////////////////</a>
<a name="ln383">  /**</a>
<a name="ln384">  Method reads partial charges from input stream (ifs)</a>
<a name="ln385">  and writes them to supplied OBMol object (molecule)</a>
<a name="ln386">  Input stream must be set to beginning of charges</a>
<a name="ln387">  table in nwo file. (Line after &quot;Mulliken analysis of the total density&quot;)</a>
<a name="ln388">  Stream will be set at next line after charges table.</a>
<a name="ln389">  If reading charges failed or &quot;molecule&quot; contains</a>
<a name="ln390">  data incompatible with read charges then &quot;molecule&quot;</a>
<a name="ln391">  wont be changed.</a>
<a name="ln392">  */</a>
<a name="ln393">  void NWChemOutputFormat::ReadPartialCharges(istream* ifs, OBMol* molecule)</a>
<a name="ln394">  {</a>
<a name="ln395">    if (molecule == nullptr || ifs == nullptr)</a>
<a name="ln396">        return;</a>
<a name="ln397">    vector&lt;string&gt; vs;</a>
<a name="ln398">    char buffer[BUFF_SIZE];</a>
<a name="ln399">    bool from_scratch = false;</a>
<a name="ln400">    vector&lt;int&gt; charges;</a>
<a name="ln401">    vector&lt;double&gt; partial_charges;</a>
<a name="ln402">    unsigned int natoms = molecule-&gt;NumAtoms();</a>
<a name="ln403"> </a>
<a name="ln404">    if (natoms == 0)</a>
<a name="ln405">        from_scratch = true;</a>
<a name="ln406">    ifs-&gt;getline(buffer,BUFF_SIZE); // ---- ----- ----</a>
<a name="ln407">    ifs-&gt;getline(buffer,BUFF_SIZE);	// blank</a>
<a name="ln408">    ifs-&gt;getline(buffer,BUFF_SIZE);	// column headings</a>
<a name="ln409">    ifs-&gt;getline(buffer,BUFF_SIZE);	// ---- ----- ----</a>
<a name="ln410">    ifs-&gt;getline(buffer,BUFF_SIZE);</a>
<a name="ln411">    tokenize(vs, buffer);</a>
<a name="ln412"> </a>
<a name="ln413">    // N Symbol    Charge     PartialCharge+Charge   ShellCharges</a>
<a name="ln414">    // 0   1          2                3                4,etc</a>
<a name="ln415">    unsigned int i = 1;</a>
<a name="ln416">    while (vs.size() &gt;= 4)</a>
<a name="ln417">    {</a>
<a name="ln418">        int charge = atoi(vs[2].c_str());</a>
<a name="ln419">        if (!from_scratch)</a>
<a name="ln420">        {</a>
<a name="ln421">            if (i &gt; natoms)</a>
<a name="ln422">                return;</a>
<a name="ln423">            if (molecule-&gt;GetAtom(i++)-&gt;GetAtomicNum() != charge)</a>
<a name="ln424">                return;</a>
<a name="ln425">        }</a>
<a name="ln426">        else</a>
<a name="ln427">            charges.push_back(charge);</a>
<a name="ln428">        partial_charges.push_back(atof(vs[3].c_str()) - charge);</a>
<a name="ln429">        ifs-&gt;getline(buffer,BUFF_SIZE);</a>
<a name="ln430">        tokenize(vs, buffer);</a>
<a name="ln431">    }</a>
<a name="ln432"> </a>
<a name="ln433">    if (from_scratch)</a>
<a name="ln434">        molecule-&gt;ReserveAtoms(partial_charges.size());</a>
<a name="ln435">    else if (partial_charges.size() != natoms)</a>
<a name="ln436">        return;</a>
<a name="ln437">    for(unsigned int j=0;j&lt;partial_charges.size();j++)</a>
<a name="ln438">    {</a>
<a name="ln439">        OBAtom* atom;</a>
<a name="ln440">        if (from_scratch)</a>
<a name="ln441">        {</a>
<a name="ln442">            atom = molecule-&gt;NewAtom();</a>
<a name="ln443">            atom-&gt;SetAtomicNum(charges[j]);</a>
<a name="ln444">        }</a>
<a name="ln445">        else</a>
<a name="ln446">        {</a>
<a name="ln447">            atom = molecule-&gt;GetAtom(j+1);</a>
<a name="ln448">        }</a>
<a name="ln449">        atom-&gt;SetPartialCharge(partial_charges[j]);</a>
<a name="ln450">    }</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453"> </a>
<a name="ln454">  //////////////////////////////////////////////////////</a>
<a name="ln455">  /**</a>
<a name="ln456">  Method reads orbital information from input stream (ifs)</a>
<a name="ln457">  and writes them to supplied OBMol object (molecule).</a>
<a name="ln458">  Input stream must be set to beginning of orbital data</a>
<a name="ln459">  section in nwo file. (Line after &quot;... Molecular Orbital Analysis&quot;)</a>
<a name="ln460">  Stream will be set at next line after end of orbital section.</a>
<a name="ln461">  */</a>
<a name="ln462">  void NWChemOutputFormat::ReadOrbitals(istream* ifs, OBMol* molecule)</a>
<a name="ln463">  {</a>
<a name="ln464">    if (ifs == nullptr || molecule == nullptr)</a>
<a name="ln465">        return;</a>
<a name="ln466">    vector&lt;string&gt; vs;</a>
<a name="ln467">    char buffer[BUFF_SIZE];</a>
<a name="ln468">    vector&lt;OBOrbital&gt; orbitals;</a>
<a name="ln469">    OBOrbitalData* orbital_data = new OBOrbitalData;</a>
<a name="ln470">    ifs-&gt;getline(buffer, BUFF_SIZE); // ---------</a>
<a name="ln471">    ifs-&gt;getline(buffer, BUFF_SIZE); // blank line</a>
<a name="ln472"> </a>
<a name="ln473">    while (ifs-&gt;getline(buffer,BUFF_SIZE))</a>
<a name="ln474">    {</a>
<a name="ln475">        if (strstr(buffer, ORBITAL_START_PATTERN))</a>
<a name="ln476">        {</a>
<a name="ln477">            tokenize(vs, buffer);</a>
<a name="ln478">            // Vector   N  Occ=X  E= Y  Symmetry=a'</a>
<a name="ln479">            //   0      1    2    3  4  5(optional)</a>
<a name="ln480">            if (vs.size() &lt; 5)</a>
<a name="ln481">                break; // Orbital data is broken</a>
<a name="ln482"> </a>
<a name="ln483">            double energy = atof(vs[4].c_str()) * HARTREE_TO_KCAL;</a>
<a name="ln484">            double occupation = atof(vs[2].c_str()+4); // Start from symbol after '='</a>
<a name="ln485">            string symbol;</a>
<a name="ln486">            if (vs.size() &gt; 5)</a>
<a name="ln487">                symbol = vs[5].substr(9, string::npos);</a>
<a name="ln488">            else</a>
<a name="ln489">                symbol = &quot; &quot;; // Symmetry is unknown</a>
<a name="ln490">            OBOrbital orbital;</a>
<a name="ln491">            orbital.SetData(energy, occupation, symbol);</a>
<a name="ln492">            orbitals.push_back(orbital);</a>
<a name="ln493"> </a>
<a name="ln494">            ifs-&gt;getline(buffer, BUFF_SIZE); // MO Center ...</a>
<a name="ln495">            ifs-&gt;getline(buffer, BUFF_SIZE); // Table header</a>
<a name="ln496">            ifs-&gt;getline(buffer,BUFF_SIZE); // ----------</a>
<a name="ln497">            while (ifs-&gt;getline(buffer,BUFF_SIZE))</a>
<a name="ln498">                if (strlen(buffer) &lt; 2) // If blank line detected</a>
<a name="ln499">                    break;</a>
<a name="ln500">        }// if Vector ...</a>
<a name="ln501">        else if (strstr(buffer, ORBITAL_SECTION_PATTERN_2) != nullptr &amp;&amp; strstr(buffer, ORBITAL_SECTION_PATTERN_1) != nullptr)</a>
<a name="ln502">        {</a>
<a name="ln503">            orbital_data-&gt;SetAlphaOrbitals(orbitals);</a>
<a name="ln504">            orbital_data-&gt;SetOpenShell(true);</a>
<a name="ln505">            orbitals.clear();</a>
<a name="ln506">            ifs-&gt;getline(buffer, BUFF_SIZE); // ---------</a>
<a name="ln507">            ifs-&gt;getline(buffer, BUFF_SIZE); // blank line</a>
<a name="ln508">        }// if beta orbital section found</a>
<a name="ln509">        else</a>
<a name="ln510">        {</a>
<a name="ln511">            if (orbital_data-&gt;IsOpenShell())</a>
<a name="ln512">                orbital_data-&gt;SetBetaOrbitals(orbitals);</a>
<a name="ln513">            else</a>
<a name="ln514">                orbital_data-&gt;SetAlphaOrbitals(orbitals);</a>
<a name="ln515">            molecule-&gt;SetData(orbital_data);</a>
<a name="ln516">            return;</a>
<a name="ln517">        }</a>
<a name="ln518">    }</a>
<a name="ln519">  delete orbital_data;</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522"> </a>
<a name="ln523">  //////////////////////////////////////////////////////</a>
<a name="ln524">  /**</a>
<a name="ln525">  Method reads IRC steps from input stream (ifs)</a>
<a name="ln526">  and writes it to supplied OBMol object (molecule).</a>
<a name="ln527">  Input stream must be set to beginning of Minimal Energy</a>
<a name="ln528">  Path IRC calculation in nwo file.</a>
<a name="ln529">  (Line after &quot;Gonzalez &amp; Schlegel IRC Optimization&quot;)</a>
<a name="ln530">  Method wont work if &quot;molecule&quot; already contains data</a>
<a name="ln531">  about conformers.</a>
<a name="ln532">  After all stream will be set at the end of calculation.</a>
<a name="ln533">  */</a>
<a name="ln534">  void NWChemOutputFormat::ReadMEPCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln535">  {</a>
<a name="ln536">    if (molecule == nullptr || ifs == nullptr)</a>
<a name="ln537">        return;</a>
<a name="ln538">    if (molecule-&gt;NumConformers() &gt; 0)</a>
<a name="ln539">        return;</a>
<a name="ln540"> </a>
<a name="ln541">    vector&lt;string&gt; vs;</a>
<a name="ln542">    char buffer[BUFF_SIZE];</a>
<a name="ln543">    vector&lt;double&gt; energies;</a>
<a name="ln544"> </a>
<a name="ln545">    while (ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln546">    {</a>
<a name="ln547">        if (strstr(buffer, OPTIMIZATION_END_PATTERN) != nullptr)</a>
<a name="ln548">        {</a>
<a name="ln549">            while(ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln550">            {</a>
<a name="ln551">                if (strstr(buffer, COORDINATES_PATTERN))</a>
<a name="ln552">                    ReadCoordinates(ifs, molecule);</a>
<a name="ln553">                else if (strstr(buffer, OPTIMIZATION_STEP_PATTERN))</a>
<a name="ln554">                {</a>
<a name="ln555">                    ifs-&gt;getline(buffer, BUFF_SIZE); // ------</a>
<a name="ln556">                    ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln557">                    tokenize(vs, buffer);</a>
<a name="ln558">                    molecule-&gt;SetConformer(molecule-&gt;NumConformers() - 1);</a>
<a name="ln559">                    if (vs.size() &gt; 2) // @ NStep   Energy...</a>
<a name="ln560">                        energies.push_back(atof(vs[2].c_str()) * HARTREE_TO_KCAL);</a>
<a name="ln561">                }</a>
<a name="ln562">                else if (strstr(buffer, MULTIPOLE_MOMENT_PATTERN) != nullptr)</a>
<a name="ln563">                    ReadMultipoleMoment(ifs, molecule);</a>
<a name="ln564">                else if (strstr(buffer, MEP_STEP_END_PATTERN) != nullptr)</a>
<a name="ln565">                    break;</a>
<a name="ln566">            }</a>
<a name="ln567">        }</a>
<a name="ln568">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln569">            break;</a>
<a name="ln570">    }</a>
<a name="ln571">    if (energies.size() != molecule-&gt;NumConformers())</a>
<a name="ln572">    {</a>
<a name="ln573">        cerr &lt;&lt; &quot;Number of read energies (&quot; &lt;&lt; energies.size();</a>
<a name="ln574">        cerr &lt;&lt; &quot;) does not match number of read conformers (&quot;;</a>
<a name="ln575">        cerr &lt;&lt; molecule-&gt;NumConformers() &lt;&lt; &quot;)!&quot; &lt;&lt; endl;</a>
<a name="ln576">        return;</a>
<a name="ln577">    }</a>
<a name="ln578">    molecule-&gt;SetEnergies(energies);</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">  //////////////////////////////////////////////////////</a>
<a name="ln583">  /**</a>
<a name="ln584">  Method reads optimization steps from input stream (ifs)</a>
<a name="ln585">  and writes it to supplied OBMol object (molecule).</a>
<a name="ln586">  Input stream must be set to beginning of geometry optimization</a>
<a name="ln587">  calculation in nwo file. (Line after &quot;NWChem Geometry Optimization&quot;)</a>
<a name="ln588">  If no geometry data found then &quot;molecule&quot; wont be changed.</a>
<a name="ln589">  After all stream will be set at the end of calculation.</a>
<a name="ln590">  */</a>
<a name="ln591">  void NWChemOutputFormat::ReadGeometryOptimizationCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln592">  {</a>
<a name="ln593">    if (molecule == nullptr || ifs == nullptr)</a>
<a name="ln594">        return;</a>
<a name="ln595">    vector&lt;string&gt; vs;</a>
<a name="ln596">    char buffer[BUFF_SIZE];</a>
<a name="ln597">    vector&lt;double&gt; energies;</a>
<a name="ln598"> </a>
<a name="ln599">    while (ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln600">    {</a>
<a name="ln601">        if (strstr(buffer, COORDINATES_PATTERN) != nullptr)</a>
<a name="ln602">        {</a>
<a name="ln603">            ReadCoordinates(ifs, molecule);</a>
<a name="ln604">            molecule-&gt;SetConformer(molecule-&gt;NumConformers() - 1);</a>
<a name="ln605">        }</a>
<a name="ln606">        else if (strstr(buffer, ORBITAL_SECTION_PATTERN_2) != nullptr &amp;&amp; strstr(buffer, ORBITAL_SECTION_PATTERN_1) != nullptr)</a>
<a name="ln607">            ReadOrbitals(ifs, molecule);</a>
<a name="ln608">        else if (strstr(buffer, OPTIMIZATION_STEP_PATTERN) != nullptr)</a>
<a name="ln609">        {</a>
<a name="ln610">            // Extract energy</a>
<a name="ln611">            ifs-&gt;getline(buffer, BUFF_SIZE); // ------</a>
<a name="ln612">            ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln613">            tokenize(vs, buffer);</a>
<a name="ln614">            molecule-&gt;SetConformer(molecule-&gt;NumConformers() - 1);</a>
<a name="ln615">            if (vs.size() &gt; 2) // @ NStep   Energy...</a>
<a name="ln616">                energies.push_back(atof(vs[2].c_str()) * HARTREE_TO_KCAL);</a>
<a name="ln617">        }</a>
<a name="ln618">        else if (strstr(buffer, MULTIPOLE_MOMENT_PATTERN) != nullptr)</a>
<a name="ln619">            ReadMultipoleMoment(ifs, molecule);</a>
<a name="ln620">        else if (strstr(buffer, MULLIKEN_CHARGES_PATTERN) != nullptr)</a>
<a name="ln621">            ReadPartialCharges(ifs, molecule);</a>
<a name="ln622">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln623">            break;</a>
<a name="ln624">    }</a>
<a name="ln625">    vector&lt;double&gt; old_energies = molecule-&gt;GetEnergies();</a>
<a name="ln626">    old_energies.reserve(old_energies.size() + energies.size());</a>
<a name="ln627">    old_energies.insert(old_energies.end(), energies.begin(), energies.end());</a>
<a name="ln628">    molecule-&gt;SetEnergies(old_energies);</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  //////////////////////////////////////////////////////</a>
<a name="ln632">  /**</a>
<a name="ln633">  Method reads vibration data and all other avalible data</a>
<a name="ln634">  from input stream (ifs) and writes it to supplied OBMol</a>
<a name="ln635">  object (molecule).</a>
<a name="ln636">  If any of arguments are NULL method will quit without changes.</a>
<a name="ln637">  If molecule does not contain geometry data method quits</a>
<a name="ln638">  without changes.</a>
<a name="ln639">  Input stream must be set to beginning of frequency</a>
<a name="ln640">  calculation in nwo file.</a>
<a name="ln641">  (Line after &quot;NWChem Nuclear Hessian and Frequency Analysis&quot;)</a>
<a name="ln642">  If vibration data not found then only avalible data will be</a>
<a name="ln643">  attached.</a>
<a name="ln644">  Input stream will be set at the end of calculation.</a>
<a name="ln645">  */</a>
<a name="ln646">  void NWChemOutputFormat::ReadFrequencyCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln647">  {</a>
<a name="ln648">    if (ifs == nullptr || molecule == nullptr)</a>
<a name="ln649">        return;</a>
<a name="ln650">    if (molecule-&gt;NumAtoms() == 0)</a>
<a name="ln651">        return;</a>
<a name="ln652">    OBVibrationData* vibration_data = nullptr;</a>
<a name="ln653">    vector&lt;double&gt;  Frequencies, Intensities;</a>
<a name="ln654">    vector&lt;vector&lt;vector3&gt; &gt; Lx;</a>
<a name="ln655">    vector&lt;string&gt; vs;</a>
<a name="ln656">    char buffer[BUFF_SIZE];</a>
<a name="ln657"> </a>
<a name="ln658">    while (ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln659">    {</a>
<a name="ln660">        if (strstr(buffer, VIBRATIONS_TABLE_PATTERN) != nullptr)</a>
<a name="ln661">        {</a>
<a name="ln662">            vector&lt;double&gt; freq;</a>
<a name="ln663">            vector&lt;vector&lt;vector3&gt; &gt; vib;</a>
<a name="ln664">            // freq and vib are auxiliary vectors which hold the data for</a>
<a name="ln665">            // every block of 6 vibrations.</a>
<a name="ln666">            tokenize(vs,buffer);</a>
<a name="ln667">            for(unsigned int i=1; i&lt;vs.size(); ++i)</a>
<a name="ln668">            {</a>
<a name="ln669">                vib.push_back(vector&lt;vector3&gt;());</a>
<a name="ln670">                freq.push_back(atof(vs[i].c_str()));</a>
<a name="ln671">            }</a>
<a name="ln672">            ifs-&gt;getline(buffer,BUFF_SIZE);     // blank line</a>
<a name="ln673">            ifs-&gt;getline(buffer,BUFF_SIZE);</a>
<a name="ln674">            tokenize(vs,buffer);</a>
<a name="ln675">            while(vs.size() &gt; 2)</a>
<a name="ln676">            {</a>
<a name="ln677">                vector&lt;double&gt; x, y, z;</a>
<a name="ln678">                for (unsigned int i = 1; i &lt; vs.size(); i++)</a>
<a name="ln679">                    x.push_back(atof(vs[i].c_str()));</a>
<a name="ln680">                ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln681">                tokenize(vs,buffer);</a>
<a name="ln682">                for (unsigned int i = 1; i &lt; vs.size(); i++)</a>
<a name="ln683">                    y.push_back(atof(vs[i].c_str()));</a>
<a name="ln684">                ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln685">                tokenize(vs,buffer);</a>
<a name="ln686">                for (unsigned int i = 1; i &lt; vs.size(); i++)</a>
<a name="ln687">                    z.push_back(atof(vs[i].c_str()));</a>
<a name="ln688">                ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln689">                tokenize(vs,buffer);</a>
<a name="ln690">                if (x.size() == y.size() &amp;&amp; y.size() == z.size()) {</a>
<a name="ln691">                  // make sure the arrays are equal or we'll crash</a>
<a name="ln692">                  // not sure how to recover if it's not true</a>
<a name="ln693">                  for (unsigned int i = 0; i &lt; freq.size(); i++)</a>
<a name="ln694">                  {</a>
<a name="ln695">                    vib[i].push_back(vector3(x[i], y[i], z[i]));</a>
<a name="ln696">                  }</a>
<a name="ln697">                }</a>
<a name="ln698">            }// while vs.size() &gt; 2</a>
<a name="ln699">            for (unsigned int i = 0; i &lt; freq.size(); i++)</a>
<a name="ln700">            {</a>
<a name="ln701">              if (abs(freq[i]) &gt; 10.0) {</a>
<a name="ln702">                Frequencies.push_back(freq[i]);</a>
<a name="ln703">                Lx.push_back(vib[i]);</a>
<a name="ln704">              }</a>
<a name="ln705">            }// for (unsigned int i = 0; i &lt; freq.size(); i++)</a>
<a name="ln706">        }// if P.Frequency</a>
<a name="ln707">        else if (strstr(buffer, INTENSITIES_TABLE_PATTERN) != nullptr)</a>
<a name="ln708">        {</a>
<a name="ln709">            ifs-&gt;getline(buffer, BUFF_SIZE); // table header</a>
<a name="ln710">            ifs-&gt;getline(buffer, BUFF_SIZE); // table delimiter</a>
<a name="ln711">            ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln712">            tokenize(vs,buffer);</a>
<a name="ln713">            while (vs.size() == 7)</a>
<a name="ln714">            {</a>
<a name="ln715">                if (abs(atof(vs[1].c_str())) &gt; 10.0)</a>
<a name="ln716">                    Intensities.push_back(atof(vs[5].c_str()));</a>
<a name="ln717">                ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln718">                tokenize(vs,buffer);</a>
<a name="ln719">            }</a>
<a name="ln720">        } // if &quot;Projected Infra Red Intensities&quot;</a>
<a name="ln721">        else if (strstr(buffer, MULLIKEN_CHARGES_PATTERN) != nullptr)</a>
<a name="ln722">            ReadPartialCharges(ifs, molecule);</a>
<a name="ln723">        else if (strstr(buffer, MULTIPOLE_MOMENT_PATTERN) != nullptr)</a>
<a name="ln724">            ReadMultipoleMoment(ifs, molecule);</a>
<a name="ln725">        else if (strstr(buffer, ORBITAL_SECTION_PATTERN_2) != nullptr &amp;&amp; strstr(buffer, ORBITAL_SECTION_PATTERN_1) != nullptr)</a>
<a name="ln726">            ReadOrbitals(ifs, molecule);</a>
<a name="ln727">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr) // End of task</a>
<a name="ln728">            break;</a>
<a name="ln729">    }</a>
<a name="ln730">    if (Frequencies.size() == 0)</a>
<a name="ln731">        return;</a>
<a name="ln732"> </a>
<a name="ln733">    vibration_data = new OBVibrationData;</a>
<a name="ln734">    vibration_data-&gt;SetData(Lx, Frequencies, Intensities);</a>
<a name="ln735">    molecule-&gt;SetData(vibration_data);</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  /////////////////////////////////////////////////////////////////</a>
<a name="ln739">  /**</a>
<a name="ln740">  Method reads single point energy and all avalible data from input</a>
<a name="ln741">  stream (ifs) and writes it to supplied OBMol object (molecule)</a>
<a name="ln742">  Input stream must be set to beginning of energy calculation</a>
<a name="ln743">  in nwo file. (Line after &quot;NWChem &lt;theory&gt; Module&quot;)</a>
<a name="ln744">  If energy not found then &quot;molecule&quot; wont be changed.</a>
<a name="ln745">  */</a>
<a name="ln746">  void NWChemOutputFormat::ReadSinglePointCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln747">  {</a>
<a name="ln748">    if (molecule == nullptr || ifs == nullptr)</a>
<a name="ln749">        return;</a>
<a name="ln750">    double energy;</a>
<a name="ln751">    vector&lt;string&gt; vs;</a>
<a name="ln752">    char buffer[BUFF_SIZE];</a>
<a name="ln753"> </a>
<a name="ln754">    while (ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln755">    {</a>
<a name="ln756">        if (strstr(buffer, DFT_ENERGY_PATTERN) != nullptr || strstr(buffer, SCF_ENERGY_PATTERN) != nullptr)</a>
<a name="ln757">        {</a>
<a name="ln758">            tokenize(vs, buffer);</a>
<a name="ln759">            energy = atof(vs[4].c_str()) * HARTREE_TO_KCAL;</a>
<a name="ln760">        }</a>
<a name="ln761">        else if (strstr(buffer, ORBITAL_SECTION_PATTERN_2) != nullptr &amp;&amp; strstr(buffer, ORBITAL_SECTION_PATTERN_1) != nullptr)</a>
<a name="ln762">            ReadOrbitals(ifs, molecule);</a>
<a name="ln763">        else if (strstr(buffer, MULTIPOLE_MOMENT_PATTERN) != nullptr)</a>
<a name="ln764">            ReadMultipoleMoment(ifs, molecule);</a>
<a name="ln765">        else if (strstr(buffer, MULLIKEN_CHARGES_PATTERN) != nullptr)</a>
<a name="ln766">            ReadPartialCharges(ifs, molecule);</a>
<a name="ln767">        else if (strstr(buffer, TDDFT_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln768">            ReadTDDFTCalculation(ifs, molecule);</a>
<a name="ln769">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln770">            break;</a>
<a name="ln771">    }</a>
<a name="ln772">    if (energy == 0)</a>
<a name="ln773">        return;</a>
<a name="ln774">    molecule-&gt;SetEnergy(energy);</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777">  /**</a>
<a name="ln778">  Method reads beads and their energies from NEB calculation from</a>
<a name="ln779">  input stream (ifs) and writes them to supplied OBMol object (molecule)</a>
<a name="ln780">  Input stream must be set to beginning of NEB calculation</a>
<a name="ln781">  in nwo file. (Line after &quot;NWChem Minimum Energy Pathway Program (NEB)&quot;)</a>
<a name="ln782">  If method failed then &quot;molecule&quot; wont be changed.</a>
<a name="ln783">  */</a>
<a name="ln784">  void NWChemOutputFormat::ReadNEBCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln785">  {</a>
<a name="ln786">    if (ifs == nullptr || molecule == nullptr)</a>
<a name="ln787">        return;</a>
<a name="ln788">    unsigned int natoms = molecule-&gt;NumAtoms();</a>
<a name="ln789">    // Inital geometry must be supplied</a>
<a name="ln790">    if (natoms == 0)</a>
<a name="ln791">        return;</a>
<a name="ln792">    char buffer[BUFF_SIZE];</a>
<a name="ln793">    vector&lt;string&gt; vs;</a>
<a name="ln794">    vector&lt;double*&gt; beads;</a>
<a name="ln795">    vector&lt;double&gt; energies;</a>
<a name="ln796">    unsigned int nbeads = 0;</a>
<a name="ln797">    unsigned int current_bead = UINT_MAX;</a>
<a name="ln798"> </a>
<a name="ln799">    while(ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln800">    {</a>
<a name="ln801">        if (strstr(buffer, NEB_BEAD_START_PATTERN) != nullptr)</a>
<a name="ln802">        {</a>
<a name="ln803">            tokenize(vs, buffer);</a>
<a name="ln804">            // neb: running bead                    N</a>
<a name="ln805">            //  0      1      2                     3</a>
<a name="ln806">            if (vs.size() &lt; 4)</a>
<a name="ln807">                break;</a>
<a name="ln808">            current_bead = atoi(vs[3].c_str()) - 1;</a>
<a name="ln809">            // Bead index in array starts from 0</a>
<a name="ln810">            // but in log it starts from 1</a>
<a name="ln811">        }</a>
<a name="ln812">        else if (strstr(buffer, NEB_BEAD_ENERGY_PATTERN) != nullptr)</a>
<a name="ln813">        {</a>
<a name="ln814">            tokenize(vs, buffer);</a>
<a name="ln815">            // neb: final energy  N</a>
<a name="ln816">            //  0     1      2    3</a>
<a name="ln817">            if (vs.size() &lt; 4)</a>
<a name="ln818">                break;</a>
<a name="ln819">            if (current_bead &gt;= nbeads)</a>
<a name="ln820">            {</a>
<a name="ln821">                cerr &lt;&lt; &quot;Current bead out of range: &quot; &lt;&lt; current_bead &lt;&lt; &quot; of &quot; &lt;&lt; nbeads &lt;&lt; endl;</a>
<a name="ln822">                break;</a>
<a name="ln823">            }</a>
<a name="ln824">            energies[current_bead] = atof(vs[3].c_str());</a>
<a name="ln825">        }</a>
<a name="ln826">        else if (strstr(buffer, GRADIENT_PATTERN) != nullptr)</a>
<a name="ln827">        {</a>
<a name="ln828">            ifs-&gt;getline(buffer, BUFF_SIZE); // blank line</a>
<a name="ln829">            ifs-&gt;getline(buffer, BUFF_SIZE); // 1st level header</a>
<a name="ln830">            ifs-&gt;getline(buffer, BUFF_SIZE); // 2nd level header</a>
<a name="ln831">            for (unsigned int i = 0; i&lt;natoms; i++)</a>
<a name="ln832">            {</a>
<a name="ln833">                ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln834">                tokenize(vs, buffer);</a>
<a name="ln835">                // N Symbol     x   y  z    x_grad  y_grad  z_grad</a>
<a name="ln836">                // 0   1        2   3  4       5      6       7</a>
<a name="ln837">                if (vs.size() &lt; 8)</a>
<a name="ln838">                    break;</a>
<a name="ln839">                unsigned int end_of_symbol = vs[1].find_last_not_of(DIGITS) + 1;</a>
<a name="ln840">                if (OBElements::GetAtomicNum(vs[1].substr(0, end_of_symbol).c_str()) != molecule-&gt;GetAtom(i+1)-&gt;GetAtomicNum())</a>
<a name="ln841">                    break;</a>
<a name="ln842">                if (current_bead &gt;= nbeads)</a>
<a name="ln843">                {</a>
<a name="ln844">                    cerr &lt;&lt; &quot;Current bead out of range: &quot; &lt;&lt; current_bead &lt;&lt; &quot; of &quot; &lt;&lt; nbeads &lt;&lt; endl;</a>
<a name="ln845">                    break;</a>
<a name="ln846">                }</a>
<a name="ln847">                beads[current_bead][i*3] = atof(vs[2].c_str())*AU_TO_ANGSTROM;</a>
<a name="ln848">                beads[current_bead][1+i*3] = atof(vs[3].c_str())*AU_TO_ANGSTROM;</a>
<a name="ln849">                beads[current_bead][2+i*3] = atof(vs[4].c_str())*AU_TO_ANGSTROM;</a>
<a name="ln850">            }</a>
<a name="ln851">        }</a>
<a name="ln852">        else if (strstr(buffer, NEB_NBEADS_PATTERN) != nullptr)</a>
<a name="ln853">        {</a>
<a name="ln854">            tokenize(vs, buffer);</a>
<a name="ln855">            // number of images in path         (nbeads) =   N</a>
<a name="ln856">            //   0    1     2    3   4             5     6   7</a>
<a name="ln857">            if (vs.size() &lt; 8)</a>
<a name="ln858">                break;</a>
<a name="ln859">            nbeads = atoi(vs[7].c_str());</a>
<a name="ln860">            beads.reserve(nbeads);</a>
<a name="ln861">            energies.reserve(nbeads);</a>
<a name="ln862">            for (unsigned int i = 0;i&lt;nbeads;i++)</a>
<a name="ln863">            {</a>
<a name="ln864">                beads.push_back(new double[natoms*3]);</a>
<a name="ln865">                energies.push_back(0.0);</a>
<a name="ln866">            }</a>
<a name="ln867">        }</a>
<a name="ln868">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln869">        {</a>
<a name="ln870">            molecule-&gt;SetConformers(beads);</a>
<a name="ln871">            molecule-&gt;SetEnergies(energies);</a>
<a name="ln872">            return;</a>
<a name="ln873">        }</a>
<a name="ln874">    }</a>
<a name="ln875">    cerr &lt;&lt; &quot;Failed to read NEB calculation!&quot; &lt;&lt; endl;</a>
<a name="ln876">    for(unsigned int i = 0; i &lt; beads.size();i++)</a>
<a name="ln877">        delete beads[i];</a>
<a name="ln878">  }</a>
<a name="ln879"> </a>
<a name="ln880">  /////////////////////////////////////////////////////////////////</a>
<a name="ln881">  /**</a>
<a name="ln882">  Method reads beads and their energies from ZTS calculation from</a>
<a name="ln883">  input stream (ifs) and writes them to supplied OBMol object (molecule)</a>
<a name="ln884">  Input stream must be set to beginning of ZTS calculation</a>
<a name="ln885">  in nwo file. (Line after &quot;@ String method.&quot;)</a>
<a name="ln886">  If method failed then &quot;molecule&quot; wont be changed.</a>
<a name="ln887">  */</a>
<a name="ln888">  void NWChemOutputFormat::ReadZTSCalculation(istream* ifs, OBMol* molecule)</a>
<a name="ln889">  {</a>
<a name="ln890">    if (ifs == nullptr || molecule == nullptr)</a>
<a name="ln891">        return;</a>
<a name="ln892">    unsigned int natoms = molecule-&gt;NumAtoms();</a>
<a name="ln893">    // Inital geometry must be supplied</a>
<a name="ln894">    if (natoms == 0)</a>
<a name="ln895">        return;</a>
<a name="ln896">    char buffer[BUFF_SIZE];</a>
<a name="ln897">    vector&lt;string&gt; vs;</a>
<a name="ln898">    vector&lt;double*&gt; beads;</a>
<a name="ln899">    vector&lt;double&gt; energies;</a>
<a name="ln900">    unsigned int nbeads;</a>
<a name="ln901">    while(ifs-&gt;getline(buffer, BUFF_SIZE))</a>
<a name="ln902">    {</a>
<a name="ln903">        if (strstr(buffer, NBEADS_PATTERN) != nullptr)</a>
<a name="ln904">        {</a>
<a name="ln905">            tokenize(vs, buffer);</a>
<a name="ln906">            // @ Number of replicas   =        24</a>
<a name="ln907">            // 0   1     2    3       4        5</a>
<a name="ln908">            if (vs.size() &lt; 6)</a>
<a name="ln909">                break; // Line with number of beads is incomplete</a>
<a name="ln910">            nbeads = atoi(vs[5].c_str());</a>
<a name="ln911">            beads.reserve(nbeads);</a>
<a name="ln912">        }// @ Number of replicas</a>
<a name="ln913">        else if (strstr(buffer, ZTS_CONVERGED_PATTERN) != nullptr)</a>
<a name="ln914">        {</a>
<a name="ln915">            // NWChem does not mark end in this type of calculation,</a>
<a name="ln916">            // so end will be there, where all nessesary data have</a>
<a name="ln917">            // obtained</a>
<a name="ln918">            ifs-&gt;getline(buffer, BUFF_SIZE); // blank line</a>
<a name="ln919">            ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln920">            // @ Bead number =     &lt;N&gt;  Potential Energy =     &lt;Energy&gt;</a>
<a name="ln921">            // 0  1     2    3      4       5       6    7        8</a>
<a name="ln922">            tokenize(vs, buffer);</a>
<a name="ln923">            // Thanks to the commit jeffhammond/nwchem@76d2b8c the beads</a>
<a name="ln924">            // output was broken (in nwchem 6.6+ there is no equal sign after</a>
<a name="ln925">            // 'number'. So all indicies will be counted from the end.</a>
<a name="ln926">            unsigned int vsize = vs.size();</a>
<a name="ln927">            while (vsize &gt; 7)</a>
<a name="ln928">            {</a>
<a name="ln929">                unsigned int bead_number = atoi(vs[vsize-5].c_str());</a>
<a name="ln930">                double bead_energy = atof(vs[vsize-1].c_str()) * HARTREE_TO_KCAL;</a>
<a name="ln931">                ifs-&gt;getline(buffer, BUFF_SIZE); // natoms</a>
<a name="ln932">                if (atoi(buffer) != natoms)</a>
<a name="ln933">                    break; // table contains geometry of different molecule</a>
<a name="ln934">                ifs-&gt;getline(buffer, BUFF_SIZE); // comment</a>
<a name="ln935">                double* bead = new double[natoms*3];</a>
<a name="ln936">                for(unsigned int i = 0; i&lt;natoms; i++)</a>
<a name="ln937">                {</a>
<a name="ln938">                    ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln939">                    tokenize(vs, buffer);</a>
<a name="ln940">                    //  Symbol              X     Y     Z</a>
<a name="ln941">                    //    0                 1     2     3</a>
<a name="ln942">                    if ((vs.size() &lt; 4) || (molecule-&gt;GetAtom(i+1)-&gt;GetAtomicNum() != OBElements::GetAtomicNum(vs[0].c_str())))</a>
<a name="ln943">                        break; // molecule has no such atom or table row incomplete</a>
<a name="ln944"> </a>
<a name="ln945">                    unsigned int atom_idx = i*3;</a>
<a name="ln946">                    bead[atom_idx] = atof(vs[1].c_str()); // X</a>
<a name="ln947">                    bead[atom_idx+1] = atof(vs[2].c_str()); // Y</a>
<a name="ln948">                    bead[atom_idx+2] = atof(vs[3].c_str()); // Z</a>
<a name="ln949">                }</a>
<a name="ln950">                beads.push_back(bead);</a>
<a name="ln951">                energies.push_back(bead_energy);</a>
<a name="ln952">                ifs-&gt;getline(buffer, BUFF_SIZE);</a>
<a name="ln953">                tokenize(vs, buffer);</a>
<a name="ln954">                if (vs.size() &lt;= 1) // blank line</a>
<a name="ln955">                {</a>
<a name="ln956">                    // Looks like it's end of calculation.</a>
<a name="ln957">                    if (bead_number != nbeads)</a>
<a name="ln958">                        break;</a>
<a name="ln959">                    molecule-&gt;SetEnergies(energies);</a>
<a name="ln960">                    molecule-&gt;SetConformers(beads);</a>
<a name="ln961">                    unsigned int ts_position = distance(energies.begin(), max_element(energies.begin(), energies.end()));</a>
<a name="ln962">                    molecule-&gt;SetConformer(ts_position);</a>
<a name="ln963">                    return;</a>
<a name="ln964">                }</a>
<a name="ln965">            }</a>
<a name="ln966">            break;// It is the end of calculation anyway</a>
<a name="ln967">        }//@ Bead number</a>
<a name="ln968">        else if (strstr(buffer, END_OF_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln969">        {</a>
<a name="ln970">            // End of all calculations still required to handle</a>
<a name="ln971">            molecule-&gt;SetEnergies(energies);</a>
<a name="ln972">            molecule-&gt;SetConformers(beads);</a>
<a name="ln973">            unsigned int ts_position = distance(energies.begin(), max_element(energies.begin(), energies.end()));</a>
<a name="ln974">            molecule-&gt;SetConformer(ts_position);</a>
<a name="ln975">            return;</a>
<a name="ln976">        }</a>
<a name="ln977">    }</a>
<a name="ln978">    // Something went wrong. Do some cleanup and exit</a>
<a name="ln979">    for(unsigned int i = 0; i &lt; beads.size();i++)</a>
<a name="ln980">        delete beads[i];</a>
<a name="ln981">  }</a>
<a name="ln982"> </a>
<a name="ln983">  /////////////////////////////////////////////////////////////////</a>
<a name="ln984">  bool NWChemOutputFormat::ReadMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln985">  {</a>
<a name="ln986"> </a>
<a name="ln987">    OBMol* pmol = pOb-&gt;CastAndClear&lt;OBMol&gt;();</a>
<a name="ln988">    if (pmol == nullptr)</a>
<a name="ln989">      return false;</a>
<a name="ln990"> </a>
<a name="ln991">    //Define some references so we can use the old parameter names</a>
<a name="ln992">    istream &amp;ifs = *pConv-&gt;GetInStream();</a>
<a name="ln993">    OBMol &amp;mol = *pmol;</a>
<a name="ln994">    const char* title = pConv-&gt;GetTitle();</a>
<a name="ln995"> </a>
<a name="ln996">    char buffer[BUFF_SIZE];</a>
<a name="ln997"> </a>
<a name="ln998">    mol.BeginModify();</a>
<a name="ln999"> </a>
<a name="ln1000">    // Reading inital parameters of calculation such as</a>
<a name="ln1001">    // used theory and calculation type for better</a>
<a name="ln1002">    // recognition futher output</a>
<a name="ln1003">    while	(ifs.getline(buffer,BUFF_SIZE))</a>
<a name="ln1004">    {</a>
<a name="ln1005">        if (strstr(buffer, GEOMETRY_PATTERN) != nullptr)</a>
<a name="ln1006">        {</a>
<a name="ln1007">            // Input coordinates for calculation</a>
<a name="ln1008">            if (mol.NumAtoms() == 0 || pConv-&gt;IsOption(&quot;f&quot;, OBConversion::INOPTIONS) != nullptr)</a>
<a name="ln1009">            {</a>
<a name="ln1010">                // If coordinates had redefined while calculation</a>
<a name="ln1011">                // in input file and &quot;f&quot; option had supplied then overwrite</a>
<a name="ln1012">                // all previous calculations. Otherwise calculations for</a>
<a name="ln1013">                // new geometry will be considered as new molecule.</a>
<a name="ln1014">                mol.Clear();</a>
<a name="ln1015">                mol.BeginModify();</a>
<a name="ln1016">                ifs.getline(buffer,BUFF_SIZE);// -------------------------</a>
<a name="ln1017">                ifs.getline(buffer,BUFF_SIZE);// blank</a>
<a name="ln1018">                ifs.getline(buffer,BUFF_SIZE);// Output coordinates...</a>
<a name="ln1019">                ReadCoordinates(&amp;ifs, &amp;mol);</a>
<a name="ln1020">            }</a>
<a name="ln1021">            else</a>
<a name="ln1022">            {</a>
<a name="ln1023">                int i;</a>
<a name="ln1024">                for(i=0; buffer[i] != '\0';i++);</a>
<a name="ln1025">                ifs.seekg(-i, ios_base::cur);</a>
<a name="ln1026">                break;</a>
<a name="ln1027">            }</a>
<a name="ln1028">        }</a>
<a name="ln1029">        else if (strstr(buffer, GEOMETRY_OPTIMIZATION_PATTERN) != nullptr)</a>
<a name="ln1030">            ReadGeometryOptimizationCalculation(&amp;ifs, &amp;mol);</a>
<a name="ln1031">        else if (strstr(buffer, FREQUENCY_PATTERN) != nullptr)</a>
<a name="ln1032">            ReadFrequencyCalculation(&amp;ifs, &amp;mol);</a>
<a name="ln1033">        else if(strstr(buffer, SCF_CALCULATION_PATTERN) != strstr(buffer, DFT_CALCULATION_PATTERN))</a>
<a name="ln1034">            ReadSinglePointCalculation(&amp;ifs, &amp;mol);</a>
<a name="ln1035">        else if (strstr(buffer, ZTS_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln1036">            ReadZTSCalculation(&amp;ifs, &amp;mol);</a>
<a name="ln1037">        else if (strstr(buffer, MEP_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln1038">            ReadMEPCalculation(&amp;ifs, &amp;mol);</a>
<a name="ln1039">        else if (strstr(buffer, NEB_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln1040">            ReadNEBCalculation(&amp;ifs, &amp;mol);</a>
<a name="ln1041">        // These calculation handlers still not implemented</a>
<a name="ln1042">        // so we just skip them</a>
<a name="ln1043">        else if (strstr(buffer, PROPERTY_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln1044">            GotoCalculationEnd(&amp;ifs);</a>
<a name="ln1045">        else if (strstr(buffer, ESP_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln1046">            GotoCalculationEnd(&amp;ifs);</a>
<a name="ln1047">        else if (strstr(buffer, PYTHON_CALCULATION_PATTERN) != nullptr)</a>
<a name="ln1048">            GotoCalculationEnd(&amp;ifs);</a>
<a name="ln1049">    }//while</a>
<a name="ln1050"> </a>
<a name="ln1051">    if (mol.NumAtoms() == 0) { // e.g., if we're at the end of a file PR#1737209</a>
<a name="ln1052">      mol.EndModify();</a>
<a name="ln1053">      return false;</a>
<a name="ln1054">    }</a>
<a name="ln1055"> </a>
<a name="ln1056">    if (!pConv-&gt;IsOption(&quot;b&quot;,OBConversion::INOPTIONS))</a>
<a name="ln1057">      mol.ConnectTheDots();</a>
<a name="ln1058">    if (!pConv-&gt;IsOption(&quot;s&quot;,OBConversion::INOPTIONS) &amp;&amp; !pConv-&gt;IsOption(&quot;b&quot;,OBConversion::INOPTIONS))</a>
<a name="ln1059">      mol.PerceiveBondOrders();</a>
<a name="ln1060"> </a>
<a name="ln1061">    mol.EndModify();</a>
<a name="ln1062">    // EndModify adds new conformer equals to current</a>
<a name="ln1063">    // molecule geometry so we will just delete it</a>
<a name="ln1064">    unsigned int nconformers = mol.NumConformers();</a>
<a name="ln1065">    if (nconformers &gt; 1)</a>
<a name="ln1066">        mol.DeleteConformer(nconformers - 1);</a>
<a name="ln1067"> </a>
<a name="ln1068">    mol.SetTitle(title);</a>
<a name="ln1069">    return(true);</a>
<a name="ln1070">  }</a>
<a name="ln1071"> </a>
<a name="ln1072">  ////////////////////////////////////////////////////////////////</a>
<a name="ln1073"> </a>
<a name="ln1074">  bool NWChemInputFormat::WriteMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln1075">  {</a>
<a name="ln1076">    OBMol* pmol = dynamic_cast&lt;OBMol*&gt;(pOb);</a>
<a name="ln1077">    if (pmol == nullptr)</a>
<a name="ln1078">      return false;</a>
<a name="ln1079"> </a>
<a name="ln1080">    //Define some references so we can use the old parameter names</a>
<a name="ln1081">    ostream &amp;ofs = *pConv-&gt;GetOutStream();</a>
<a name="ln1082">    OBMol &amp;mol = *pmol;</a>
<a name="ln1083"> </a>
<a name="ln1084">    char buffer[BUFF_SIZE];</a>
<a name="ln1085"> </a>
<a name="ln1086">    ofs &lt;&lt; &quot;start molecule&quot; &lt;&lt; &quot;\n\n&quot;;</a>
<a name="ln1087">    ofs &lt;&lt; &quot;title &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; mol.GetTitle() &lt;&lt; &quot;\n\n&quot;;</a>
<a name="ln1088"> </a>
<a name="ln1089">    ofs &lt;&lt; &quot;geometry units angstroms print xyz autosym\n&quot;;</a>
<a name="ln1090"> </a>
<a name="ln1091">    FOR_ATOMS_OF_MOL(atom, mol)</a>
<a name="ln1092">      {</a>
<a name="ln1093">        snprintf(buffer, BUFF_SIZE, &quot;%3s%15.5f%15.5f%15.5f\n&quot;,</a>
<a name="ln1094">                OBElements::GetSymbol(atom-&gt;GetAtomicNum()),</a>
<a name="ln1095">                atom-&gt;GetX(),</a>
<a name="ln1096">                atom-&gt;GetY(),</a>
<a name="ln1097">                atom-&gt;GetZ());</a>
<a name="ln1098">        ofs &lt;&lt; buffer;</a>
<a name="ln1099">      }</a>
<a name="ln1100"> </a>
<a name="ln1101">    ofs &lt;&lt; &quot;end\n&quot;;</a>
<a name="ln1102"> </a>
<a name="ln1103">    return(true);</a>
<a name="ln1104">  }</a>
<a name="ln1105"> </a>
<a name="ln1106">} //namespace OpenBabel</a>

</code></pre>
<div class="balloon" rel="173"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized buffer 'buffer' used. Consider checking the first actual argument of the 'strstr' function.</p></div>
<div class="balloon" rel="244"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'coordinates' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'coordinates' used. Consider checking the first actual argument of the 'AddConformer' function.</p></div>
<div class="balloon" rel="957"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'nbeads' used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

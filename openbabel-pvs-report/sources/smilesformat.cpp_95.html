
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>smilesformat.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">Copyright (C) 2005-2007 by Craig A. James, eMolecules Inc.</a>
<a name="ln3">Some portions Copyright (C) 1998-2001 by OpenEye Scientific Software, Inc.</a>
<a name="ln4">Some portions Copyright (C) 2001-2008 by Geoffrey R. Hutchison</a>
<a name="ln5">Some portions Copyright (C) 2004 by Chris Morley</a>
<a name="ln6">Some portions Copyright (C) 2019 by NextMove Software.</a>
<a name="ln7"> </a>
<a name="ln8">This program is free software; you can redistribute it and/or modify</a>
<a name="ln9">it under the terms of the GNU General Public License as published by</a>
<a name="ln10">the Free Software Foundation version 2 of the License.</a>
<a name="ln11"> </a>
<a name="ln12">This program is distributed in the hope that it will be useful,</a>
<a name="ln13">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">GNU General Public License for more details.</a>
<a name="ln16">***********************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18">// This code uses the old OpenEye SMILES parser</a>
<a name="ln19">// but replaces the SMILES export with Craig James canonical smiles</a>
<a name="ln20">// (For regular SMILES, the canonical order is not computed and ignored)</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln23">#include &lt;openbabel/obmolecformat.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln26">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln27">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln28">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln29">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln30">#include &lt;openbabel/generic.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;openbabel/stereo/tetrahedral.h&gt;</a>
<a name="ln34">#include &lt;openbabel/stereo/cistrans.h&gt;</a>
<a name="ln35">#include &lt;openbabel/stereo/squareplanar.h&gt;</a>
<a name="ln36">#include &lt;openbabel/reactionfacade.h&gt;</a>
<a name="ln37">#include &lt;openbabel/stereo/stereo.h&gt;</a>
<a name="ln38">#include &lt;openbabel/obfunctions.h&gt;</a>
<a name="ln39">#include &lt;openbabel/graphsym.h&gt;</a>
<a name="ln40">#include &lt;openbabel/kekulize.h&gt;</a>
<a name="ln41">#include &lt;openbabel/canon.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;smilesvalence.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;limits&gt;</a>
<a name="ln46">#include &lt;iostream&gt;</a>
<a name="ln47">#include &lt;cassert&gt;</a>
<a name="ln48">#include &lt;string&gt;</a>
<a name="ln49"> </a>
<a name="ln50">//#define DEBUG 1</a>
<a name="ln51">#define IMPLICIT_CIS_RING_SIZE 8</a>
<a name="ln52"> </a>
<a name="ln53">using namespace std;</a>
<a name="ln54"> </a>
<a name="ln55">namespace OpenBabel {</a>
<a name="ln56"> </a>
<a name="ln57">  // some constant variables</a>
<a name="ln58">  const char BondUpChar = '\\';</a>
<a name="ln59">  const char BondDownChar = '/';</a>
<a name="ln60"> </a>
<a name="ln61">  // This function return true for sulfur and nitrogen</a>
<a name="ln62">  // (I'm not sure that is the right approach, longterm)</a>
<a name="ln63">  static bool CanHaveLonePair(unsigned int elem)</a>
<a name="ln64">  {</a>
<a name="ln65">    switch (elem) {</a>
<a name="ln66">    case OBElements::Nitrogen:</a>
<a name="ln67">    case OBElements::Sulfur:</a>
<a name="ln68">      return true;</a>
<a name="ln69">    default:</a>
<a name="ln70">      return false;</a>
<a name="ln71">    }</a>
<a name="ln72">  }</a>
<a name="ln73"> </a>
<a name="ln74">  //Base class for SMIFormat and CANSIFormat with most of the functionality</a>
<a name="ln75">  class SMIBaseFormat : public OBMoleculeFormat</a>
<a name="ln76">  {</a>
<a name="ln77">  public:</a>
<a name="ln78">    virtual const char* GetMIMEType()</a>
<a name="ln79">    { return &quot;chemical/x-daylight-smiles&quot;; };</a>
<a name="ln80"> </a>
<a name="ln81">    ////////////////////////////////////////////////////</a>
<a name="ln82">    /// The &quot;API&quot; interface functions</a>
<a name="ln83">    virtual bool ReadMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln84">    virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln85"> </a>
<a name="ln86">    ///////////////////////////////////////////////////////</a>
<a name="ln87"> </a>
<a name="ln88">    virtual const char* TargetClassDescription(){return OBMol::ClassDescription();};</a>
<a name="ln89"> </a>
<a name="ln90">    virtual const char* SpecificationURL()</a>
<a name="ln91">    {return &quot;http://www.daylight.com/smiles/&quot;;};</a>
<a name="ln92"> </a>
<a name="ln93">    virtual int SkipObjects(int n, OBConversion* pConv)</a>
<a name="ln94">    {</a>
<a name="ln95">      if(n==0) return 1; //already points after current line</a>
<a name="ln96">      istream&amp; ifs = *pConv-&gt;GetInStream();</a>
<a name="ln97">      if (ifs.eof())</a>
<a name="ln98">        return -1;</a>
<a name="ln99"> </a>
<a name="ln100">      int i=0;</a>
<a name="ln101">      while(i&lt;n &amp;&amp; ifs.good())</a>
<a name="ln102">        {</a>
<a name="ln103">          if(ifs.peek()!='#')</a>
<a name="ln104">            i++;</a>
<a name="ln105">          ifs.ignore(numeric_limits&lt;streamsize&gt;::max(),'\n');</a>
<a name="ln106">        }</a>
<a name="ln107">      return ifs ? 1 : -1;</a>
<a name="ln108">    }</a>
<a name="ln109">  private:</a>
<a name="ln110">    bool GetInchifiedSMILESMolecule(OBMol *mol, bool useFixedHRecMet);</a>
<a name="ln111">  };</a>
<a name="ln112"> </a>
<a name="ln113">  //**************************************************</a>
<a name="ln114">  class SMIFormat : public SMIBaseFormat</a>
<a name="ln115">  {</a>
<a name="ln116">  public:</a>
<a name="ln117">    //Register this format type ID</a>
<a name="ln118">    SMIFormat()</a>
<a name="ln119">    {</a>
<a name="ln120">      OBConversion::RegisterFormat(&quot;smi&quot;,this, &quot;chemical/x-daylight-smiles&quot;);</a>
<a name="ln121">      OBConversion::RegisterFormat(&quot;smiles&quot;,this, &quot;chemical/x-daylight-smiles&quot;);</a>
<a name="ln122">      OBConversion::RegisterOptionParam(&quot;n&quot;, this);</a>
<a name="ln123">      OBConversion::RegisterOptionParam(&quot;t&quot;, this);</a>
<a name="ln124">      OBConversion::RegisterOptionParam(&quot;r&quot;, this);</a>
<a name="ln125">      OBConversion::RegisterOptionParam(&quot;a&quot;, this);</a>
<a name="ln126">      OBConversion::RegisterOptionParam(&quot;h&quot;, this);</a>
<a name="ln127">      OBConversion::RegisterOptionParam(&quot;x&quot;, this);</a>
<a name="ln128">      OBConversion::RegisterOptionParam(&quot;C&quot;, this);	// &quot;anti-canonical&quot; form (random order)</a>
<a name="ln129">    }</a>
<a name="ln130">    virtual const char* Description()</a>
<a name="ln131">    {</a>
<a name="ln132">      return</a>
<a name="ln133">        &quot;SMILES format\n&quot;</a>
<a name="ln134">        &quot;A linear text format which can describe the connectivity and chirality of a molecule\n&quot;</a>
<a name="ln135">        &quot;Open Babel implements the `OpenSMILES specification &lt;http://opensmiles.org&gt;`_.\n\n&quot;</a>
<a name="ln136"> </a>
<a name="ln137">        &quot;It also implements an extension to this specification for radicals.\n\n&quot;</a>
<a name="ln138"> </a>
<a name="ln139">        &quot;Note that the ``l &lt;atomno&gt;`` option, used to specify a \&quot;last\&quot; atom, is\n&quot;</a>
<a name="ln140">        &quot;intended for the generation of SMILES strings to which additional atoms\n&quot;</a>
<a name="ln141">        &quot;will be concatenated. If the atom specified has an explicit H within a bracket\n&quot;</a>
<a name="ln142">        &quot;(e.g. ``[nH]`` or ``[C@@H]``) the output will have the H removed along with any\n&quot;</a>
<a name="ln143">        &quot;associated stereo symbols.\n\n&quot;</a>
<a name="ln144"> </a>
<a name="ln145">        &quot;.. seealso::\n\n&quot;</a>
<a name="ln146"> </a>
<a name="ln147">        &quot;  The :ref:`Canonical_SMILES_format` produces a canonical representation\n&quot;</a>
<a name="ln148">        &quot;  of the molecule in SMILES format. This is the same as the ``c`` option\n&quot;</a>
<a name="ln149">        &quot;  below but may be more convenient to use.\n\n&quot;</a>
<a name="ln150"> </a>
<a name="ln151">        &quot;Write Options e.g. -xt\n&quot;</a>
<a name="ln152">        &quot;  a  Output atomclass like [C:2], if available\n&quot;</a>
<a name="ln153">        &quot;  c  Output in canonical form\n&quot;</a>
<a name="ln154">        &quot;  U  Universal SMILES\n&quot;</a>
<a name="ln155">        &quot;  I  Inchified SMILES\n&quot;</a>
<a name="ln156">        &quot;  h  Output explicit hydrogens as such\n&quot;</a>
<a name="ln157">        &quot;  i  Do not include isotopic or chiral markings\n&quot;</a>
<a name="ln158">        &quot;  k  Create Kekule SMILES instead of aromatic\n&quot;</a>
<a name="ln159">        &quot;  n  No molecule name\n&quot;</a>
<a name="ln160">        &quot;  r  Radicals lower case eg ethyl is Cc\n&quot;</a>
<a name="ln161">        &quot;  t  Molecule name only\n&quot;</a>
<a name="ln162">        &quot;  x  append X/Y coordinates in canonical-SMILES order\n&quot;</a>
<a name="ln163">        &quot;  C  'anti-canonical' random order (mostly for testing)\n&quot;</a>
<a name="ln164">        &quot;  o  &lt;ordering&gt; Output in user-specified order\n&quot;</a>
<a name="ln165">        &quot;     Ordering should be specified like 4-2-1-3 for a 4-atom molecule.\n&quot;</a>
<a name="ln166">        &quot;     This gives canonical labels 1,2,3,4 to atoms 4,2,1,3 respectively,\n&quot;</a>
<a name="ln167">        &quot;     so that atom 4 will be visited first and the remaining atoms\n&quot;</a>
<a name="ln168">        &quot;     visited in a depth-first manner following the lowest canonical labels.\n&quot;</a>
<a name="ln169">        &quot;  O  Store the SMILES atom order as a space-separated string\n&quot;</a>
<a name="ln170">        &quot;     The string is stored as an OBPairData wth the name\n&quot;</a>
<a name="ln171">        &quot;     'SMILES Atom Order'.\n&quot;</a>
<a name="ln172">        &quot;  F  &lt;atom numbers&gt; Generate SMILES for a fragment\n&quot;</a>
<a name="ln173">        &quot;     The atom numbers should be specified like \&quot;1 2 4 7\&quot;.\n&quot;</a>
<a name="ln174">        &quot;  R  Do not reuse bond closure symbols\n&quot;</a>
<a name="ln175">        &quot;  f  &lt;atomno&gt; Specify the first atom\n&quot;</a>
<a name="ln176">        &quot;     This atom will be used to begin the SMILES string.\n&quot;</a>
<a name="ln177">        &quot;  l  &lt;atomno&gt; Specify the last atom\n&quot;</a>
<a name="ln178">        &quot;     The output will be rearranged so that any additional\n&quot;</a>
<a name="ln179">        &quot;     SMILES added to the end will be attached to this atom.\n&quot;</a>
<a name="ln180">        &quot;  T  &lt;max seconds&gt; Specify the canonicalization timeout\n&quot;</a>
<a name="ln181">        &quot;     Canonicalization can take a while for symmetric molecules and a\n&quot;</a>
<a name="ln182">        &quot;     timeout is used. The default is 5 seconds.\n\n&quot;</a>
<a name="ln183"> </a>
<a name="ln184">        &quot;Read Options e.g. -aa\n&quot;</a>
<a name="ln185">        &quot;  a  Preserve aromaticity present in the SMILES\n&quot;</a>
<a name="ln186">        &quot;     This option should only be used if reading aromatic SMILES\n&quot;</a>
<a name="ln187">        &quot;     generated by the same version of Open Babel. Any other\n&quot;</a>
<a name="ln188">        &quot;     use will lead to undefined behavior. The advantage of this\n&quot;</a>
<a name="ln189">        &quot;     option is that it avoids aromaticity perception, thus speeding\n&quot;</a>
<a name="ln190">        &quot;     up reading SMILES.\n&quot;</a>
<a name="ln191">        &quot;  S  Clean stereochemistry\n&quot;</a>
<a name="ln192">        &quot;     By default, stereochemistry is accepted as given. If you wish\n&quot;</a>
<a name="ln193">        &quot;     to clean up stereochemistry (e.g. by removing tetrahedral\n&quot;</a>
<a name="ln194">        &quot;     stereochemistry where two of the substituents are identical)\n&quot;</a>
<a name="ln195">        &quot;     then specifying this option will reperceive stereocenters.\n&quot;</a>
<a name="ln196">        &quot;\n\n&quot;</a>
<a name="ln197">        ;</a>
<a name="ln198">    }</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">  };</a>
<a name="ln202"> </a>
<a name="ln203">  //Make an instance of the format class</a>
<a name="ln204">  SMIFormat theSMIFormat;</a>
<a name="ln205"> </a>
<a name="ln206">  //**************************************************</a>
<a name="ln207">  class CANSMIFormat : public SMIBaseFormat</a>
<a name="ln208">  {</a>
<a name="ln209">  public:</a>
<a name="ln210">    //Register this format type ID</a>
<a name="ln211">    CANSMIFormat()</a>
<a name="ln212">    {</a>
<a name="ln213">      OBConversion::RegisterFormat(&quot;can&quot;, this, &quot;chemical/x-daylight-cansmiles&quot;);</a>
<a name="ln214">    }</a>
<a name="ln215"> </a>
<a name="ln216">    virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln217">    {</a>
<a name="ln218">      //The &quot;c&quot; option sets us to use canonical ordering</a>
<a name="ln219">      pConv-&gt;AddOption(&quot;c&quot;,OBConversion::OUTOPTIONS);</a>
<a name="ln220">      return SMIBaseFormat::WriteMolecule(pOb, pConv);</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">    ///////////////////////////////////////////////////////</a>
<a name="ln224"> </a>
<a name="ln225">    virtual const char* Description() {</a>
<a name="ln226">      return</a>
<a name="ln227">        &quot;Canonical SMILES format\n&quot;</a>
<a name="ln228">        &quot;A canonical form of the SMILES linear text format\n&quot;</a>
<a name="ln229">        &quot;The SMILES format is a linear text format which can describe the\n&quot;</a>
<a name="ln230">       	&quot;connectivity &quot;</a>
<a name="ln231">        &quot;and chirality of a molecule. Canonical SMILES gives a single\n&quot;</a>
<a name="ln232">       	&quot;'canonical' form for any particular molecule.\n\n&quot;</a>
<a name="ln233"> </a>
<a name="ln234">        &quot;.. seealso::\n\n&quot;</a>
<a name="ln235"> </a>
<a name="ln236">        &quot;  The \&quot;regular\&quot; :ref:`SMILES_format` gives faster\n&quot;</a>
<a name="ln237">        &quot;  output, since no canonical numbering is performed.\n\n&quot;</a>
<a name="ln238"> </a>
<a name="ln239">        &quot;Write Options e.g. -xt\n&quot;</a>
<a name="ln240">        &quot;  a  Output atomclass like [C:2], if available\n&quot;</a>
<a name="ln241">        &quot;  h  Output explicit hydrogens as such\n&quot;</a>
<a name="ln242">        &quot;  i  Do not include isotopic or chiral markings\n&quot;</a>
<a name="ln243">        &quot;  n  No molecule name\n&quot;</a>
<a name="ln244">        &quot;  r  Radicals lower case eg ethyl is Cc\n&quot;</a>
<a name="ln245">        &quot;  t  Molecule name only\n&quot;</a>
<a name="ln246">        &quot;  F  &lt;atom numbers&gt; Generate Canonical SMILES for a fragment\n&quot;</a>
<a name="ln247">        &quot;     The atom numbers should be specified like \&quot;1 2 4 7\&quot;.\n&quot;</a>
<a name="ln248">        &quot;  f  &lt;atomno&gt; Specify the first atom\n&quot;</a>
<a name="ln249">        &quot;     This atom will be used to begin the SMILES string.\n&quot;</a>
<a name="ln250">        &quot;  l  &lt;atomno&gt; Specify the last atom\n&quot;</a>
<a name="ln251">        &quot;     The output will be rearranged so that any additional\n&quot;</a>
<a name="ln252">        &quot;     SMILES added to the end will be attached to this atom.\n&quot;</a>
<a name="ln253">        &quot;     See the :ref:`SMILES_format` for more information.\n\n&quot;;</a>
<a name="ln254">    };</a>
<a name="ln255"> </a>
<a name="ln256">  };</a>
<a name="ln257"> </a>
<a name="ln258">  // Make an instance of the format class</a>
<a name="ln259">  CANSMIFormat theCANSMIFormat;</a>
<a name="ln260"> </a>
<a name="ln261">  //************************************************************</a>
<a name="ln262"> </a>
<a name="ln263">  class OBSmilesParser</a>
<a name="ln264">  {</a>
<a name="ln265">    // simple structs to make code more readable</a>
<a name="ln266"> </a>
<a name="ln267">    // see _extbond</a>
<a name="ln268">    struct ExternalBond</a>
<a name="ln269">    {</a>
<a name="ln270">      int digit;</a>
<a name="ln271">      int prev;</a>
<a name="ln272">      int order;</a>
<a name="ln273">      char updown;</a>
<a name="ln274">    };</a>
<a name="ln275">    // see _rclose</a>
<a name="ln276">    struct RingClosureBond</a>
<a name="ln277">    {</a>
<a name="ln278">      int digit;</a>
<a name="ln279">      int prev;</a>
<a name="ln280">      int order;</a>
<a name="ln281">      char updown;</a>
<a name="ln282">      int numConnections;</a>
<a name="ln283">    };</a>
<a name="ln284"> </a>
<a name="ln285"> </a>
<a name="ln286">    char _updown;</a>
<a name="ln287">    int _order;</a>
<a name="ln288">    int _prev;</a>
<a name="ln289">    int _rxnrole;</a>
<a name="ln290">    const char *_ptr;</a>
<a name="ln291">    bool _preserve_aromaticity;</a>
<a name="ln292">    vector&lt;int&gt;             _vprev;</a>
<a name="ln293">    vector&lt;RingClosureBond&gt; _rclose;</a>
<a name="ln294">    vector&lt;ExternalBond&gt;    _extbond;</a>
<a name="ln295">    vector&lt;int&gt;             _path;</a>
<a name="ln296">    vector&lt;bool&gt;            _avisit;</a>
<a name="ln297">    vector&lt;bool&gt;            _bvisit;</a>
<a name="ln298">    vector&lt;int&gt;             _hcount;</a>
<a name="ln299">    vector&lt;int&gt; PosDouble; //for extension: lc atoms as conjugated double bonds</a>
<a name="ln300"> </a>
<a name="ln301">    struct StereoRingBond</a>
<a name="ln302">    {</a>
<a name="ln303">      vector&lt;OBAtom*&gt; atoms;</a>
<a name="ln304">      vector&lt;char&gt; updown;</a>
<a name="ln305">    };</a>
<a name="ln306">    map&lt;OBBond*, StereoRingBond&gt; _stereorbond; // Remember info on the stereo ring closure bonds</a>
<a name="ln307"> </a>
<a name="ln308">    // stereochimistry</a>
<a name="ln309">    bool chiralWatch; // set when a tetrahedral atom is read</a>
<a name="ln310">    map&lt;OBAtom*, OBTetrahedralStereo::Config*&gt; _tetrahedralMap; // map of tetrahedral atoms and their data</a>
<a name="ln311">    map&lt;OBBond*, char&gt; _upDownMap; // store the '/' &amp; '\' as they occurred in smiles</a>
<a name="ln312">    map&lt;unsigned int, char&gt; _chiralLonePair; // for atoms with potential chiral lone pairs, remember when the l.p. was encountered</a>
<a name="ln313">    bool squarePlanarWatch; // set when a square planar atom is read</a>
<a name="ln314">    map&lt;OBAtom*, OBSquarePlanarStereo::Config*&gt; _squarePlanarMap;</a>
<a name="ln315"> </a>
<a name="ln316">  public:</a>
<a name="ln317"> </a>
<a name="ln318">    OBSmilesParser(bool preserve_aromaticity=false): _preserve_aromaticity(preserve_aromaticity), _rxnrole(1) { }</a>
<a name="ln319">    ~OBSmilesParser() { }</a>
<a name="ln320"> </a>
<a name="ln321">    bool SmiToMol(OBMol&amp;,const string&amp;);</a>
<a name="ln322">    bool ParseSmiles(OBMol&amp;, const string&amp;);</a>
<a name="ln323">    bool ParseSimple(OBMol&amp;);</a>
<a name="ln324">    bool ParseComplex(OBMol&amp;);</a>
<a name="ln325">    bool ParseRingBond(OBMol&amp;);</a>
<a name="ln326">    bool ParseExternalBond(OBMol&amp;);</a>
<a name="ln327">    bool CapExternalBonds(OBMol &amp;mol);</a>
<a name="ln328">    int NumConnections(OBAtom *, bool isImplicitRef=false);</a>
<a name="ln329">    void CreateCisTrans(OBMol &amp;mol);</a>
<a name="ln330">    char SetRingClosureStereo(StereoRingBond rcstereo, OBBond* dbl_bond);</a>
<a name="ln331">    void InsertTetrahedralRef(OBMol &amp;mol, unsigned long id);</a>
<a name="ln332">    void InsertSquarePlanarRef(OBMol &amp;mol, unsigned long id);</a>
<a name="ln333"> </a>
<a name="ln334">    bool IsUp(OBBond*);</a>
<a name="ln335">    bool IsDown(OBBond*);</a>
<a name="ln336">  };</a>
<a name="ln337"> </a>
<a name="ln338">  /////////////////////////////////////////////////////////////////</a>
<a name="ln339">  /* Lines starting with # are ignored. Whitespace at the start (including</a>
<a name="ln340">     blank lines) terminate the input unless -e option is used.</a>
<a name="ln341">     Valid SMILES reactions such as [C]=O.O&gt;[Fe]&gt;O=C=O.[H][H] with non-null</a>
<a name="ln342">     reactant and product are accepted and the reactant, product and</a>
<a name="ln343">     possibly the agent molecules are output when using the Convert interface</a>
<a name="ln344">     (babel commandline). With the OBConversion functions Read, ReadString</a>
<a name="ln345">     and ReadFile all SMILES reactions give an error when read with this format.</a>
<a name="ln346">  */</a>
<a name="ln347">  bool SMIBaseFormat::ReadMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln348">  {</a>
<a name="ln349">    OBMol* pmol = pOb-&gt;CastAndClear&lt;OBMol&gt;();</a>
<a name="ln350"> </a>
<a name="ln351">    istream &amp;ifs = *pConv-&gt;GetInStream();</a>
<a name="ln352">    string ln, smiles, title;</a>
<a name="ln353">    string::size_type pos;</a>
<a name="ln354"> </a>
<a name="ln355">    //Ignore lines that start with #</a>
<a name="ln356">    while(ifs &amp;&amp; ifs.peek()=='#')</a>
<a name="ln357">      if(!getline(ifs, ln))</a>
<a name="ln358">        return false;</a>
<a name="ln359"> </a>
<a name="ln360">    //Get title</a>
<a name="ln361">    if(getline(ifs, ln))</a>
<a name="ln362">    {</a>
<a name="ln363">      pos = ln.find_first_of(&quot; \t&quot;);</a>
<a name="ln364">      if(pos!=string::npos)</a>
<a name="ln365">      {</a>
<a name="ln366">        smiles = ln.substr(0,pos);</a>
<a name="ln367">        title = ln.substr(pos+1);</a>
<a name="ln368">        Trim(title);</a>
<a name="ln369">        pmol-&gt;SetTitle(title.c_str());</a>
<a name="ln370">      }</a>
<a name="ln371">      else</a>
<a name="ln372">        smiles = ln;</a>
<a name="ln373">    }</a>
<a name="ln374"> </a>
<a name="ln375">    pmol-&gt;SetDimension(0);</a>
<a name="ln376">    OBSmilesParser sp(pConv-&gt;IsOption(&quot;a&quot;, OBConversion::INOPTIONS));</a>
<a name="ln377">    if (!pConv-&gt;IsOption(&quot;S&quot;, OBConversion::INOPTIONS))</a>
<a name="ln378">      pmol-&gt;SetChiralityPerceived();</a>
<a name="ln379"> </a>
<a name="ln380">    return sp.SmiToMol(*pmol, smiles); //normal return</a>
<a name="ln381">  }</a>
<a name="ln382"> </a>
<a name="ln383">  //////////////////////////////////////////////</a>
<a name="ln384"> </a>
<a name="ln385">  bool OBSmilesParser::SmiToMol(OBMol &amp;mol,const string &amp;s)</a>
<a name="ln386">  {</a>
<a name="ln387">    _vprev.clear();</a>
<a name="ln388">    _rclose.clear();</a>
<a name="ln389">    _prev=0;</a>
<a name="ln390">    chiralWatch=false;</a>
<a name="ln391">    squarePlanarWatch = false;</a>
<a name="ln392"> </a>
<a name="ln393">    // We allow the empty reaction (&quot;&gt;&gt;&quot;) but not the empty molecule (&quot;&quot;)</a>
<a name="ln394">    if (!ParseSmiles(mol, s) || (!mol.IsReaction() &amp;&amp; mol.NumAtoms() == 0))</a>
<a name="ln395">      {</a>
<a name="ln396">        mol.Clear();</a>
<a name="ln397">        return(false);</a>
<a name="ln398">      }</a>
<a name="ln399"> </a>
<a name="ln400">    // TODO: Is the following a memory leak? - there are return statements above</a>
<a name="ln401">    map&lt;OBAtom*, OBTetrahedralStereo::Config*&gt;::iterator i;</a>
<a name="ln402">    for (i = _tetrahedralMap.begin(); i != _tetrahedralMap.end(); ++i)</a>
<a name="ln403">      delete i-&gt;second;</a>
<a name="ln404">    _tetrahedralMap.clear();</a>
<a name="ln405"> </a>
<a name="ln406">    map&lt;OBAtom*, OBSquarePlanarStereo::Config*&gt;::iterator j;</a>
<a name="ln407">    for (j = _squarePlanarMap.begin(); j != _squarePlanarMap.end(); ++j)</a>
<a name="ln408">      delete j-&gt;second;</a>
<a name="ln409">    _squarePlanarMap.clear();</a>
<a name="ln410"> </a>
<a name="ln411">    mol.SetAutomaticFormalCharge(false);</a>
<a name="ln412"> </a>
<a name="ln413">    return(true);</a>
<a name="ln414">  }</a>
<a name="ln415"> </a>
<a name="ln416">  bool OBSmilesParser::ParseSmiles(OBMol &amp;mol, const std::string &amp;smiles)</a>
<a name="ln417">  {</a>
<a name="ln418">    mol.SetAromaticPerceived(); // Turn off perception until the end of this function</a>
<a name="ln419">    mol.BeginModify();</a>
<a name="ln420"> </a>
<a name="ln421">    for (_ptr=smiles.c_str();*_ptr;_ptr++)</a>
<a name="ln422">    {</a>
<a name="ln423">      switch(*_ptr)</a>
<a name="ln424">      {</a>
<a name="ln425">      case '\r':</a>
<a name="ln426">        if (*(_ptr+1) == '\0') // may have a terminating '\r' due to Windows line-endings</a>
<a name="ln427">          break;</a>
<a name="ln428">        return false;</a>
<a name="ln429">      case '0': case '1': case '2': case '3': case '4':</a>
<a name="ln430">      case '5': case '6': case '7': case '8': case '9':</a>
<a name="ln431">      case '%':  //ring open/close</a>
<a name="ln432">        if (_prev == 0)</a>
<a name="ln433">          return false;</a>
<a name="ln434">        if (!ParseRingBond(mol))</a>
<a name="ln435">          return false;</a>
<a name="ln436">        break;</a>
<a name="ln437">      case '&amp;': //external bond</a>
<a name="ln438">        if (_prev == 0)</a>
<a name="ln439">          return false;</a>
<a name="ln440">        if (!ParseExternalBond(mol))</a>
<a name="ln441">          return false;</a>
<a name="ln442">        break;</a>
<a name="ln443">      case '.':</a>
<a name="ln444">        _prev=0;</a>
<a name="ln445">        break;</a>
<a name="ln446">      case '&gt;':</a>
<a name="ln447">        _prev = 0;</a>
<a name="ln448">        _rxnrole++;</a>
<a name="ln449">        if (_rxnrole == 2) {</a>
<a name="ln450">          mol.SetIsReaction();</a>
<a name="ln451">          // Handle all the reactant atoms</a>
<a name="ln452">          // - the remaining atoms will be handled on-the-fly</a>
<a name="ln453">          FOR_ATOMS_OF_MOL(atom, mol) {</a>
<a name="ln454">            OBPairInteger *pi = new OBPairInteger();</a>
<a name="ln455">            pi-&gt;SetAttribute(&quot;rxnrole&quot;);</a>
<a name="ln456">            pi-&gt;SetValue(1);</a>
<a name="ln457">            atom-&gt;SetData(pi);</a>
<a name="ln458">          }</a>
<a name="ln459">        }</a>
<a name="ln460">        else if (_rxnrole == 4) {</a>
<a name="ln461">          stringstream errorMsg;</a>
<a name="ln462">          errorMsg &lt;&lt; &quot;Too many greater-than signs in SMILES string&quot;;</a>
<a name="ln463">          std::string title = mol.GetTitle();</a>
<a name="ln464">          if (!title.empty())</a>
<a name="ln465">            errorMsg &lt;&lt; &quot; (title is &quot; &lt;&lt; title &lt;&lt; &quot;)&quot;;</a>
<a name="ln466">          errorMsg &lt;&lt; endl;</a>
<a name="ln467">          obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln468">          return false;</a>
<a name="ln469">        }</a>
<a name="ln470">        break;</a>
<a name="ln471">      case '(':</a>
<a name="ln472">        _vprev.push_back(_prev);</a>
<a name="ln473">        break;</a>
<a name="ln474">      case ')':</a>
<a name="ln475">        if(_vprev.empty()) //CM</a>
<a name="ln476">          return false;</a>
<a name="ln477">        _prev = _vprev.back();</a>
<a name="ln478">        _vprev.pop_back();</a>
<a name="ln479">        break;</a>
<a name="ln480">      case '[':</a>
<a name="ln481">        if (!ParseComplex(mol))</a>
<a name="ln482">        {</a>
<a name="ln483">          mol.EndModify();</a>
<a name="ln484">          mol.Clear();</a>
<a name="ln485">          return false;</a>
<a name="ln486">        }</a>
<a name="ln487">        break;</a>
<a name="ln488">      case '-':</a>
<a name="ln489">        if (_prev == 0)</a>
<a name="ln490">          return false;</a>
<a name="ln491">        _order = 1;</a>
<a name="ln492">        break;</a>
<a name="ln493">      case '=':</a>
<a name="ln494">        if (_prev == 0)</a>
<a name="ln495">          return false;</a>
<a name="ln496">        _order = 2;</a>
<a name="ln497">        break;</a>
<a name="ln498">      case '#':</a>
<a name="ln499">        if (_prev == 0)</a>
<a name="ln500">          return false;</a>
<a name="ln501">        _order = 3;</a>
<a name="ln502">        break;</a>
<a name="ln503">      case '$':</a>
<a name="ln504">        if (_prev == 0)</a>
<a name="ln505">          return false;</a>
<a name="ln506">        _order = 4;</a>
<a name="ln507">        break;</a>
<a name="ln508">      case ':':</a>
<a name="ln509">        if (_prev == 0)</a>
<a name="ln510">          return false;</a>
<a name="ln511">        _order = 0; // no-op</a>
<a name="ln512">        break;</a>
<a name="ln513">      case '/':</a>
<a name="ln514">        if (_prev == 0)</a>
<a name="ln515">          return false;</a>
<a name="ln516">        _order = 1;</a>
<a name="ln517">        _updown = BondDownChar;</a>
<a name="ln518">        break;</a>
<a name="ln519">      case '\\':</a>
<a name="ln520">        if (_prev == 0)</a>
<a name="ln521">          return false;</a>
<a name="ln522">        _order = 1;</a>
<a name="ln523">        _updown = BondUpChar;</a>
<a name="ln524">        break;</a>
<a name="ln525">      default:</a>
<a name="ln526">        if (!ParseSimple(mol))</a>
<a name="ln527">        {</a>
<a name="ln528">          mol.EndModify();</a>
<a name="ln529">          mol.Clear();</a>
<a name="ln530">          return false;</a>
<a name="ln531">        }</a>
<a name="ln532">      } // end switch</a>
<a name="ln533">    } // end for _ptr</a>
<a name="ln534"> </a>
<a name="ln535">    // place dummy atoms for each unfilled external bond</a>
<a name="ln536">    if(!_extbond.empty())</a>
<a name="ln537">      CapExternalBonds(mol);</a>
<a name="ln538"> </a>
<a name="ln539">    // Check to see if we've balanced out all ring closures</a>
<a name="ln540">    // They are removed from _rclose when matched</a>
<a name="ln541">    if (!_rclose.empty()) {</a>
<a name="ln542">      mol.EndModify();</a>
<a name="ln543">      mol.Clear();</a>
<a name="ln544"> </a>
<a name="ln545">      stringstream errorMsg;</a>
<a name="ln546">      errorMsg &lt;&lt; &quot;Invalid SMILES string: &quot; &lt;&lt; _rclose.size() &lt;&lt; &quot; unmatched &quot;</a>
<a name="ln547">               &lt;&lt; &quot;ring bonds.&quot; &lt;&lt; endl;</a>
<a name="ln548">      obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln549">      return false; // invalid SMILES since rings aren't properly closed</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">    // Check to see if we've the right number of '&gt;' for reactions</a>
<a name="ln553">    if (_rxnrole &gt; 1 &amp;&amp; _rxnrole !=3) {</a>
<a name="ln554">      mol.EndModify();</a>
<a name="ln555">      stringstream errorMsg;</a>
<a name="ln556">      errorMsg &lt;&lt; &quot;Invalid reaction SMILES string: only a single '&gt;' sign found (two required to be valid).&quot;;</a>
<a name="ln557">      obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln558">      return false; // invalid SMILES since rings aren't properly closed</a>
<a name="ln559">    }</a>
<a name="ln560">    if (mol.IsReaction()) {</a>
<a name="ln561">      OBReactionFacade facade(&amp;mol);</a>
<a name="ln562">      facade.AssignComponentIds();</a>
<a name="ln563">    }</a>
<a name="ln564"> </a>
<a name="ln565">    // Apply the SMILES valence model</a>
<a name="ln566">    FOR_ATOMS_OF_MOL(atom, mol) {</a>
<a name="ln567">      unsigned int idx = atom-&gt;GetIdx();</a>
<a name="ln568">      int hcount = _hcount[idx - 1];</a>
<a name="ln569">      if (hcount == -1) { // Apply SMILES implicit valence model</a>
<a name="ln570">        unsigned int bosum = 0;</a>
<a name="ln571">        FOR_BONDS_OF_ATOM(bond, &amp;(*atom)) {</a>
<a name="ln572">          bosum += bond-&gt;GetBondOrder();</a>
<a name="ln573">        }</a>
<a name="ln574">        unsigned int impval = SmilesValence(atom-&gt;GetAtomicNum(), bosum);</a>
<a name="ln575">        unsigned int imph = impval - bosum;</a>
<a name="ln576">        if (imph &gt; 0 &amp;&amp; atom-&gt;IsAromatic())</a>
<a name="ln577">          imph--;</a>
<a name="ln578">        atom-&gt;SetImplicitHCount(imph);</a>
<a name="ln579">      }</a>
<a name="ln580">      else // valence is explicit e.g. [CH3]</a>
<a name="ln581">        atom-&gt;SetImplicitHCount(hcount);</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    mol.EndModify(false);</a>
<a name="ln585"> </a>
<a name="ln586">    // Unset any aromatic bonds that *are not* in rings where the two aromatic atoms *are* in a ring</a>
<a name="ln587">    // This is rather subtle, but it's correct and reduces the burden of kekulization</a>
<a name="ln588">    FOR_BONDS_OF_MOL(bond, mol) {</a>
<a name="ln589">      if (bond-&gt;IsAromatic() &amp;&amp; !bond-&gt;IsInRing()) {</a>
<a name="ln590">        if (bond-&gt;GetBeginAtom()-&gt;IsInRing() &amp;&amp; bond-&gt;GetEndAtom()-&gt;IsInRing())</a>
<a name="ln591">          bond-&gt;SetAromatic(false);</a>
<a name="ln592">      }</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">    // TODO: Only Kekulize if the molecule has a lower case atom</a>
<a name="ln596">    bool ok = OBKekulize(&amp;mol);</a>
<a name="ln597">    if (!ok) {</a>
<a name="ln598">      stringstream errorMsg;</a>
<a name="ln599">      errorMsg &lt;&lt; &quot;Failed to kekulize aromatic SMILES&quot;;</a>
<a name="ln600">      std::string title = mol.GetTitle();</a>
<a name="ln601">      if (!title.empty())</a>
<a name="ln602">        errorMsg &lt;&lt; &quot; (title is &quot; &lt;&lt; title &lt;&lt; &quot;)&quot;;</a>
<a name="ln603">      errorMsg &lt;&lt; endl;</a>
<a name="ln604">      obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln605">      // return false; // Should we return false for a kekulization failure?</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    // Add the data stored inside the _tetrahedralMap to the atoms now after end</a>
<a name="ln609">    // modify so they don't get lost.</a>
<a name="ln610">    if(!_tetrahedralMap.empty()) {</a>
<a name="ln611">      OBAtom* atom;</a>
<a name="ln612">      map&lt;OBAtom*, OBTetrahedralStereo::Config*&gt;::iterator ChiralSearch;</a>
<a name="ln613">      for(ChiralSearch = _tetrahedralMap.begin(); ChiralSearch != _tetrahedralMap.end(); ++ChiralSearch) {</a>
<a name="ln614">        atom = ChiralSearch-&gt;first;</a>
<a name="ln615">        OBTetrahedralStereo::Config *ts = ChiralSearch-&gt;second;</a>
<a name="ln616">        if (!ts)</a>
<a name="ln617">          continue;</a>
<a name="ln618">        if (ts-&gt;refs.size() != 3)</a>
<a name="ln619">          continue;</a>
<a name="ln620">        if (ts-&gt;refs[2] == OBStereo::NoRef) {</a>
<a name="ln621">          // This happens where there is chiral lone pair or where there simply aren't enough connections</a>
<a name="ln622">          // around a chiral atom. We handle the case where there is a S with a chiral lone pair.</a>
<a name="ln623">          // All other cases are ignored, and raise a warning. (Note that S can be chiral even without</a>
<a name="ln624">          // a lone pair, think of C[S@](=X)(=Y)Cl.</a>
<a name="ln625"> </a>
<a name="ln626">          // We have remembered where to insert the lone pair in the _chiralLonePair map</a>
<a name="ln627">          map&lt;unsigned int, char&gt;::iterator m_it = _chiralLonePair.find(atom-&gt;GetIdx());</a>
<a name="ln628">          if (CanHaveLonePair(atom-&gt;GetAtomicNum()) &amp;&amp; m_it != _chiralLonePair.end()) {</a>
<a name="ln629">            ts-&gt;refs[2] = ts-&gt;refs[1]; ts-&gt;refs[1] = ts-&gt;refs[0];</a>
<a name="ln630">            if (m_it-&gt;second == 0) { // Insert in the 'from' position</a>
<a name="ln631">              ts-&gt;refs[0] = ts-&gt;from;</a>
<a name="ln632">              ts-&gt;from = OBStereo::ImplicitRef;</a>
<a name="ln633">            }</a>
<a name="ln634">            else // Insert in the refs[0] position</a>
<a name="ln635">              ts-&gt;refs[0] = OBStereo::ImplicitRef;</a>
<a name="ln636">          }</a>
<a name="ln637">          else { // Ignored by Open Babel</a>
<a name="ln638">            stringstream ss;</a>
<a name="ln639">            ss &lt;&lt; &quot;Ignoring stereochemistry. Not enough connections to this atom. &quot; &lt;&lt; mol.GetTitle();</a>
<a name="ln640">            obErrorLog.ThrowError(__FUNCTION__, ss.str(), obWarning);</a>
<a name="ln641">            continue;</a>
<a name="ln642">          }</a>
<a name="ln643">        }</a>
<a name="ln644"> </a>
<a name="ln645">        // cout &lt;&lt; &quot;*ts = &quot; &lt;&lt; *ts &lt;&lt; endl;</a>
<a name="ln646">        OBTetrahedralStereo *obts = new OBTetrahedralStereo(&amp;mol);</a>
<a name="ln647">        obts-&gt;SetConfig(*ts);</a>
<a name="ln648">        mol.SetData(obts);</a>
<a name="ln649">      }</a>
<a name="ln650">    }</a>
<a name="ln651"> </a>
<a name="ln652">    // Add the data stored inside the _squarePlanarMap to the atoms now after end</a>
<a name="ln653">    // modify so they don't get lost.</a>
<a name="ln654">    if(!_squarePlanarMap.empty()) {</a>
<a name="ln655">      OBAtom* atom;</a>
<a name="ln656">      map&lt;OBAtom*, OBSquarePlanarStereo::Config*&gt;::iterator ChiralSearch;</a>
<a name="ln657">      for(ChiralSearch = _squarePlanarMap.begin(); ChiralSearch != _squarePlanarMap.end(); ++ChiralSearch) {</a>
<a name="ln658">        atom = ChiralSearch-&gt;first;</a>
<a name="ln659">        OBSquarePlanarStereo::Config *sp = ChiralSearch-&gt;second;</a>
<a name="ln660">        if (!sp)</a>
<a name="ln661">          continue;</a>
<a name="ln662">        if (sp-&gt;refs.size() != 4)</a>
<a name="ln663">          continue;</a>
<a name="ln664"> </a>
<a name="ln665">        // cout &lt;&lt; &quot;*ts = &quot; &lt;&lt; *ts &lt;&lt; endl;</a>
<a name="ln666">        OBSquarePlanarStereo *obsp = new OBSquarePlanarStereo(&amp;mol);</a>
<a name="ln667">        obsp-&gt;SetConfig(*sp);</a>
<a name="ln668">        mol.SetData(obsp);</a>
<a name="ln669">      }</a>
<a name="ln670">    }</a>
<a name="ln671"> </a>
<a name="ln672">    if (!_preserve_aromaticity)</a>
<a name="ln673">      mol.SetAromaticPerceived(false);</a>
<a name="ln674"> </a>
<a name="ln675">    CreateCisTrans(mol);</a>
<a name="ln676"> </a>
<a name="ln677">    return(true);</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  bool OBSmilesParser::IsUp(OBBond *bond)</a>
<a name="ln681">  {</a>
<a name="ln682">    map&lt;OBBond*, char&gt;::iterator UpDownSearch;</a>
<a name="ln683">    UpDownSearch = _upDownMap.find(bond);</a>
<a name="ln684">    if (UpDownSearch != _upDownMap.end())</a>
<a name="ln685">      if (UpDownSearch-&gt;second == BondUpChar)</a>
<a name="ln686">        return true;</a>
<a name="ln687">    return false;</a>
<a name="ln688">  }</a>
<a name="ln689"> </a>
<a name="ln690">  bool OBSmilesParser::IsDown(OBBond *bond)</a>
<a name="ln691">  {</a>
<a name="ln692">    map&lt;OBBond*, char&gt;::iterator UpDownSearch;</a>
<a name="ln693">    UpDownSearch = _upDownMap.find(bond);</a>
<a name="ln694">    if (UpDownSearch != _upDownMap.end())</a>
<a name="ln695">      if (UpDownSearch-&gt;second == BondDownChar)</a>
<a name="ln696">        return true;</a>
<a name="ln697">    return false;</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  char OBSmilesParser::SetRingClosureStereo(StereoRingBond rcstereo, OBBond* dbl_bond)</a>
<a name="ln701">  {</a>
<a name="ln702">    // Ring Closure bonds appear twice (at opening and closure).</a>
<a name="ln703">    // If involved in cis/trans stereo, then the stereo may be</a>
<a name="ln704">    // specified at either end or indeed both. Although Open Babel</a>
<a name="ln705">    // will only write out SMILES with the stereo at one end (the end</a>
<a name="ln706">    // on the double bond), it must handle all cases when reading.</a>
<a name="ln707"> </a>
<a name="ln708">    // For example:</a>
<a name="ln709">    //</a>
<a name="ln710">    //         C</a>
<a name="ln711">    //        /|</a>
<a name="ln712">    //   C = C |</a>
<a name="ln713">    //  /     \|</a>
<a name="ln714">    // C       N</a>
<a name="ln715">    //</a>
<a name="ln716">    // Can be written as:</a>
<a name="ln717">    // (a) C/C=C/1\NC1 -- preferred</a>
<a name="ln718">    // (b) C/C=C1\NC\1</a>
<a name="ln719">    // (c) C/C=C/1\NC\1</a>
<a name="ln720">    //  or indeed by replacing the &quot;\N&quot; with &quot;N&quot;.</a>
<a name="ln721"> </a>
<a name="ln722">    // If the stereo chemistry for a ring closure is inconsistently specified,</a>
<a name="ln723">    // it is ignored. In that case, if a stereo symbol does not exist for its</a>
<a name="ln724">    // partner bond on the double bond (e.g. (b) below), then the stereo is unspecified.</a>
<a name="ln725"> </a>
<a name="ln726">    // (a) C/C=C/1NC\1 -- specified stereo</a>
<a name="ln727">    // (b) C/C=C/1NC/1  -- ignore ring closure stereo =&gt; treated as C/C=C1NC1  =&gt; CC=C1NC1</a>
<a name="ln728">    // (c) C/C=C/1\NC/1 -- ignore ring closure stereo =&gt; treated as C/C=C1\NC1 =&gt; C/C=C/1\NC1</a>
<a name="ln729"> </a>
<a name="ln730">    // The ring closure bond is either up or down with respect</a>
<a name="ln731">    // to the double bond. Our task here is to figure out which it is,</a>
<a name="ln732">    // based on the contents of _stereorbond.</a>
<a name="ln733"> </a>
<a name="ln734">    bool found = false; // We have found the answer</a>
<a name="ln735">    bool updown = true; // The answer</a>
<a name="ln736"> </a>
<a name="ln737">    if (rcstereo.updown[0] == BondUpChar || rcstereo.updown[0] == BondDownChar) { // Is there a stereo symbol at the opening?</a>
<a name="ln738">      bool on_dbl_bond = (rcstereo.atoms[0] == dbl_bond-&gt;GetBeginAtom() || rcstereo.atoms[0] == dbl_bond-&gt;GetEndAtom());</a>
<a name="ln739">      updown = (rcstereo.updown[0]==BondUpChar) ^ on_dbl_bond;</a>
<a name="ln740">      found = true;</a>
<a name="ln741">    }</a>
<a name="ln742">    if (rcstereo.updown[1] == BondUpChar || rcstereo.updown[1] == BondDownChar) { // Is there a stereo symbol at the closing?</a>
<a name="ln743">      bool on_dbl_bond = (rcstereo.atoms[1] == dbl_bond-&gt;GetBeginAtom() || rcstereo.atoms[1] == dbl_bond-&gt;GetEndAtom());</a>
<a name="ln744">      bool new_updown = (rcstereo.updown[1]==BondUpChar) ^ on_dbl_bond;</a>
<a name="ln745">      if (!found) {</a>
<a name="ln746">        updown = new_updown;</a>
<a name="ln747">        found = true;</a>
<a name="ln748">      }</a>
<a name="ln749">      else if (new_updown != updown) {</a>
<a name="ln750">        obErrorLog.ThrowError(__FUNCTION__, &quot;Ignoring the cis/trans stereochemistry specified for the ring closure\n  as it is inconsistent.&quot;, obWarning);</a>
<a name="ln751">        found = false;</a>
<a name="ln752">      }</a>
<a name="ln753">    }</a>
<a name="ln754"> </a>
<a name="ln755">    if (!found)</a>
<a name="ln756">      return 0;</a>
<a name="ln757">    else</a>
<a name="ln758">      return updown ? 1 : 2;</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  void OBSmilesParser::CreateCisTrans(OBMol &amp;mol)</a>
<a name="ln762">  {</a>
<a name="ln763">    // Create a vector of CisTransStereo objects for the molecule</a>
<a name="ln764">    FOR_BONDS_OF_MOL(dbi, mol) {</a>
<a name="ln765"> </a>
<a name="ln766">      OBBond *dbl_bond = &amp;(*dbi);</a>
<a name="ln767"> </a>
<a name="ln768">      // Not a double bond?</a>
<a name="ln769">      if (dbl_bond-&gt;GetBondOrder()!=2 || dbl_bond-&gt;IsAromatic())</a>
<a name="ln770">        continue;</a>
<a name="ln771"> </a>
<a name="ln772">      // Find the single bonds around the atoms connected by the double bond.</a>
<a name="ln773"> </a>
<a name="ln774">      OBAtom *a1 = dbl_bond-&gt;GetBeginAtom();</a>
<a name="ln775">      OBAtom *a2 = dbl_bond-&gt;GetEndAtom();</a>
<a name="ln776"> </a>
<a name="ln777">      // Check that both atoms on the double bond have at least one</a>
<a name="ln778">      // other neighbor, but not more than two other neighbors;</a>
<a name="ln779">      // Note: In theory, we could relax the second requirement but we would</a>
<a name="ln780">      //       need to change the data structure we use to store cis/trans</a>
<a name="ln781">      //       stereo to only store 2 refs instead of 4</a>
<a name="ln782">      int v1 = a1-&gt;GetExplicitDegree();</a>
<a name="ln783">      int v2 = a2-&gt;GetExplicitDegree();</a>
<a name="ln784">      if (v1 &lt; 2 || v1 &gt; 3 || v2 &lt; 2 || v2 &gt; 3) {</a>
<a name="ln785">        continue;</a>
<a name="ln786">      }</a>
<a name="ln787"> </a>
<a name="ln788">      vector&lt;OBAtom*&gt; dbl_bond_atoms;</a>
<a name="ln789">      dbl_bond_atoms.push_back(a1);</a>
<a name="ln790">      dbl_bond_atoms.push_back(a2);</a>
<a name="ln791"> </a>
<a name="ln792">      vector&lt;bool&gt; bond_stereo(2, true); // Store the stereo of the chosen bonds at each end of the dbl bond</a>
<a name="ln793">      vector&lt;OBBond*&gt; stereo_bond(2, nullptr); // These are the chosen stereo bonds</a>
<a name="ln794">      vector&lt;OBBond*&gt; other_bond(2, nullptr);  // These are the 'other' bonds at each end</a>
<a name="ln795"> </a>
<a name="ln796">      for (int i = 0; i &lt; 2; ++i) { // Loop over each end of the double bond in turn</a>
<a name="ln797"> </a>
<a name="ln798">        FOR_BONDS_OF_ATOM(bi, dbl_bond_atoms[i]) {</a>
<a name="ln799">          OBBond *b = &amp;(*bi);</a>
<a name="ln800">          if (b == dbl_bond) continue;</a>
<a name="ln801">          if (!(IsUp(b) || IsDown(b))) {</a>
<a name="ln802">            other_bond[i] = b; // Use this for the 'other' bond</a>
<a name="ln803">            continue;</a>
<a name="ln804">          }</a>
<a name="ln805"> </a>
<a name="ln806">          bool found = true;</a>
<a name="ln807">          bool stereo;</a>
<a name="ln808">          map&lt;OBBond*, StereoRingBond&gt;::iterator sb_it = _stereorbond.find(b);</a>
<a name="ln809">          if (sb_it == _stereorbond.end()) // Not a ring closure</a>
<a name="ln810">            // True/False for &quot;up/down if moved to before the double bond C&quot;</a>
<a name="ln811">            stereo = !(IsUp(b) ^ (b-&gt;GetNbrAtomIdx(dbl_bond_atoms[i]) &lt; dbl_bond_atoms[i]-&gt;GetIdx())) ;</a>
<a name="ln812">          else  {                                                               // Is a ring closure</a>
<a name="ln813">            char bc_result = SetRingClosureStereo(sb_it-&gt;second, dbl_bond);</a>
<a name="ln814">            if (bc_result)</a>
<a name="ln815">              stereo = bc_result == 1 ? true : false;</a>
<a name="ln816">            else</a>
<a name="ln817">              found = false;</a>
<a name="ln818">          }</a>
<a name="ln819"> </a>
<a name="ln820">          if (!found) { // This cannot be used as the stereo bond</a>
<a name="ln821">            other_bond[i] = b; // Use this for the 'other' bond</a>
<a name="ln822">            continue;</a>
<a name="ln823">          }</a>
<a name="ln824"> </a>
<a name="ln825">          if (stereo_bond[i] == nullptr) { // This is a first stereo bond</a>
<a name="ln826">            stereo_bond[i] = b; // Use this for the 'stereo' bond</a>
<a name="ln827">            bond_stereo[i] = stereo;</a>
<a name="ln828">          }</a>
<a name="ln829">          else {               // This is a second stereo bond</a>
<a name="ln830">            if (stereo != bond_stereo[i]) { // Verify that the other stereo bond (on the same atom) has opposite stereo</a>
<a name="ln831">              other_bond[i] = b; // Use this for the 'other' bond</a>
<a name="ln832">            }</a>
<a name="ln833">            else  {</a>
<a name="ln834">              obErrorLog.ThrowError(__FUNCTION__, &quot;Error in cis/trans stereochemistry specified for the double bond\n&quot;, obWarning);</a>
<a name="ln835">              stereo_bond[i] = nullptr;</a>
<a name="ln836">            }</a>
<a name="ln837">          }</a>
<a name="ln838">        }</a>
<a name="ln839">      }</a>
<a name="ln840"> </a>
<a name="ln841">      if (stereo_bond[0] == nullptr || stereo_bond[1] == nullptr) continue; // No cis/trans</a>
<a name="ln842"> </a>
<a name="ln843">      // other_bond will contain NULLs if there are bonds to implicit hydrogens</a>
<a name="ln844">      unsigned int second = (other_bond[0] == nullptr) ? OBStereo::ImplicitRef : other_bond[0]-&gt;GetNbrAtom(a1)-&gt;GetId();</a>
<a name="ln845">      unsigned int fourth = (other_bond[1] == nullptr) ? OBStereo::ImplicitRef : other_bond[1]-&gt;GetNbrAtom(a2)-&gt;GetId();</a>
<a name="ln846"> </a>
<a name="ln847"> </a>
<a name="ln848">      OBCisTransStereo *ct = new OBCisTransStereo(&amp;mol);</a>
<a name="ln849">      OBCisTransStereo::Config cfg;</a>
<a name="ln850">      cfg.begin = a1-&gt;GetId();</a>
<a name="ln851">      cfg.end = a2-&gt;GetId();</a>
<a name="ln852"> </a>
<a name="ln853">       // If bond_stereo[0]==bond_stereo[1], this means cis for stereo_bond[0] and stereo_bond[1].</a>
<a name="ln854">      if (bond_stereo[0] == bond_stereo[1])</a>
<a name="ln855">        cfg.refs = OBStereo::MakeRefs(stereo_bond[0]-&gt;GetNbrAtom(a1)-&gt;GetId(), second,</a>
<a name="ln856">                                      fourth, stereo_bond[1]-&gt;GetNbrAtom(a2)-&gt;GetId());</a>
<a name="ln857">      else</a>
<a name="ln858">        cfg.refs = OBStereo::MakeRefs(stereo_bond[0]-&gt;GetNbrAtom(a1)-&gt;GetId(), second,</a>
<a name="ln859">                                      stereo_bond[1]-&gt;GetNbrAtom(a2)-&gt;GetId(), fourth);</a>
<a name="ln860">      ct-&gt;SetConfig(cfg);</a>
<a name="ln861">      // add the data to the atom</a>
<a name="ln862">      mol.SetData(ct);</a>
<a name="ln863">    }</a>
<a name="ln864">  }</a>
<a name="ln865"> </a>
<a name="ln866">  void OBSmilesParser::InsertTetrahedralRef(OBMol &amp;mol, unsigned long id)</a>
<a name="ln867">  {</a>
<a name="ln868">    map&lt;OBAtom*, OBTetrahedralStereo::Config*&gt;::iterator ChiralSearch;</a>
<a name="ln869">    ChiralSearch = _tetrahedralMap.find(mol.GetAtom(_prev));</a>
<a name="ln870">    if (ChiralSearch != _tetrahedralMap.end() &amp;&amp; ChiralSearch-&gt;second != nullptr)</a>
<a name="ln871">    {</a>
<a name="ln872">      int insertpos = NumConnections(ChiralSearch-&gt;first, id == OBStereo::ImplicitRef) - 2; // -1 indicates &quot;from&quot;</a>
<a name="ln873">      if (insertpos &gt; 2)</a>
<a name="ln874">        return;</a>
<a name="ln875">      if (insertpos &lt; 0) {</a>
<a name="ln876">        if (ChiralSearch-&gt;second-&gt;from != OBStereo::NoRef)</a>
<a name="ln877">          obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Overwriting previous from reference id.&quot;, obWarning);</a>
<a name="ln878"> </a>
<a name="ln879">        (ChiralSearch-&gt;second)-&gt;from = id;</a>
<a name="ln880">        // cerr &lt;&lt; &quot;Adding &quot; &lt;&lt; id &lt;&lt; &quot; at Config.from to &quot; &lt;&lt; ChiralSearch-&gt;second &lt;&lt; endl;</a>
<a name="ln881">      } else {</a>
<a name="ln882">        if (ChiralSearch-&gt;second-&gt;refs[insertpos] != OBStereo::NoRef)</a>
<a name="ln883">          obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Overwriting previously set reference id.&quot;, obWarning);</a>
<a name="ln884"> </a>
<a name="ln885">        (ChiralSearch-&gt;second)-&gt;refs[insertpos] = id;</a>
<a name="ln886">        // cerr &lt;&lt; &quot;Adding &quot; &lt;&lt; id &lt;&lt; &quot; at &quot; &lt;&lt; insertpos &lt;&lt; &quot; to &quot; &lt;&lt; ChiralSearch-&gt;second &lt;&lt; endl;</a>
<a name="ln887">      }</a>
<a name="ln888">    }</a>
<a name="ln889">  }</a>
<a name="ln890"> </a>
<a name="ln891">  void OBSmilesParser::InsertSquarePlanarRef(OBMol &amp;mol, unsigned long id)</a>
<a name="ln892">  {</a>
<a name="ln893">    map&lt;OBAtom*, OBSquarePlanarStereo::Config*&gt;::iterator ChiralSearch;</a>
<a name="ln894">    ChiralSearch = _squarePlanarMap.find(mol.GetAtom(_prev));</a>
<a name="ln895">    if (ChiralSearch != _squarePlanarMap.end() &amp;&amp; ChiralSearch-&gt;second != nullptr)</a>
<a name="ln896">    {</a>
<a name="ln897">      int insertpos = NumConnections(ChiralSearch-&gt;first) - 1;</a>
<a name="ln898">      switch(insertpos) {</a>
<a name="ln899">      case -1:</a>
<a name="ln900">        if (ChiralSearch-&gt;second-&gt;refs[0] != OBStereo::NoRef)</a>
<a name="ln901">          obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Overwriting previous from reference id.&quot;, obWarning);</a>
<a name="ln902">        (ChiralSearch-&gt;second)-&gt;refs[0] = id;</a>
<a name="ln903">        break;</a>
<a name="ln904">      case 0: case 1: case 2: case 3:</a>
<a name="ln905">        if (ChiralSearch-&gt;second-&gt;refs[insertpos] != OBStereo::NoRef)</a>
<a name="ln906">          obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Overwriting previously set reference id.&quot;, obWarning);</a>
<a name="ln907">        (ChiralSearch-&gt;second)-&gt;refs[insertpos] = id;</a>
<a name="ln908">        break;</a>
<a name="ln909">      default:</a>
<a name="ln910">        obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Square planar stereo specified for atom with more than 4 connections.&quot;, obWarning);</a>
<a name="ln911">        break;</a>
<a name="ln912">      }</a>
<a name="ln913">    }</a>
<a name="ln914">  }</a>
<a name="ln915"> </a>
<a name="ln916">  bool OBSmilesParser::ParseSimple(OBMol &amp;mol)</a>
<a name="ln917">  {</a>
<a name="ln918">    int element;</a>
<a name="ln919">    bool arom=false;</a>
<a name="ln920"> </a>
<a name="ln921">    switch(*_ptr)</a>
<a name="ln922">      {</a>
<a name="ln923">      case '*':</a>
<a name="ln924">        element = 0;</a>
<a name="ln925">        arom = false;</a>
<a name="ln926">        break;</a>
<a name="ln927"> </a>
<a name="ln928">      case 'C':</a>
<a name="ln929">        _ptr++;</a>
<a name="ln930">        if (*_ptr == 'l')</a>
<a name="ln931">          {</a>
<a name="ln932">            element = 17;</a>
<a name="ln933">          }</a>
<a name="ln934">        else</a>
<a name="ln935">          {</a>
<a name="ln936">            element = 6;</a>
<a name="ln937">            _ptr--;</a>
<a name="ln938">          }</a>
<a name="ln939">        break;</a>
<a name="ln940"> </a>
<a name="ln941">      case 'N':</a>
<a name="ln942">        element = 7;</a>
<a name="ln943">        break;</a>
<a name="ln944">      case 'O':</a>
<a name="ln945">        element = 8;</a>
<a name="ln946">        break;</a>
<a name="ln947">      case 'S':</a>
<a name="ln948">        element = 16;</a>
<a name="ln949">        break;</a>
<a name="ln950">      case 'P':</a>
<a name="ln951">        element = 15;</a>
<a name="ln952">        break;</a>
<a name="ln953">      case 'F':</a>
<a name="ln954">        element = 9;</a>
<a name="ln955">        break;</a>
<a name="ln956">      case 'I':</a>
<a name="ln957">        element = 53;</a>
<a name="ln958">        break;</a>
<a name="ln959"> </a>
<a name="ln960">      case 'B':</a>
<a name="ln961">        _ptr++;</a>
<a name="ln962">        if (*_ptr == 'r')</a>
<a name="ln963">          {</a>
<a name="ln964">            element = 35;</a>
<a name="ln965">          }</a>
<a name="ln966">        else</a>
<a name="ln967">          {</a>
<a name="ln968">            element = 5;</a>
<a name="ln969">            _ptr--;</a>
<a name="ln970">          }</a>
<a name="ln971">        break;</a>
<a name="ln972"> </a>
<a name="ln973">      // aromatics</a>
<a name="ln974">      case 'b':</a>
<a name="ln975">        arom = true;</a>
<a name="ln976">        element = 5;</a>
<a name="ln977">        break;</a>
<a name="ln978">      case 'c':</a>
<a name="ln979">        arom = true;</a>
<a name="ln980">        element = 6;</a>
<a name="ln981">        break;</a>
<a name="ln982">      case 'n':</a>
<a name="ln983">        arom = true;</a>
<a name="ln984">        element = 7;</a>
<a name="ln985">        break;</a>
<a name="ln986">      case 'o':</a>
<a name="ln987">        arom = true;</a>
<a name="ln988">        element = 8;</a>
<a name="ln989">        break;</a>
<a name="ln990">      case 'p':</a>
<a name="ln991">        arom = true;</a>
<a name="ln992">        element = 15;</a>
<a name="ln993">        break;</a>
<a name="ln994">      case 's':</a>
<a name="ln995">        arom = true;</a>
<a name="ln996">        element = 16;</a>
<a name="ln997">        break;</a>
<a name="ln998">      default:</a>
<a name="ln999">        {</a>
<a name="ln1000">        std::string err;</a>
<a name="ln1001">        err += &quot;SMILES string contains a character '&quot;;</a>
<a name="ln1002">        err += *_ptr;</a>
<a name="ln1003">        err += &quot;' which is invalid&quot;;</a>
<a name="ln1004">        obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1005">          err, obError);</a>
<a name="ln1006">        return false;</a>
<a name="ln1007">        }</a>
<a name="ln1008">      }</a>
<a name="ln1009"> </a>
<a name="ln1010">    OBAtom *atom = mol.NewAtom();</a>
<a name="ln1011">    atom-&gt;SetAtomicNum(element);</a>
<a name="ln1012">    if (_rxnrole &gt; 1) { // Quick test for reaction</a>
<a name="ln1013">      // Set reaction role</a>
<a name="ln1014">      OBPairInteger *pi = new OBPairInteger();</a>
<a name="ln1015">      pi-&gt;SetAttribute(&quot;rxnrole&quot;);</a>
<a name="ln1016">      pi-&gt;SetValue(_rxnrole);</a>
<a name="ln1017">      atom-&gt;SetData(pi);</a>
<a name="ln1018">    }</a>
<a name="ln1019"> </a>
<a name="ln1020">    if (arom)</a>
<a name="ln1021">      atom-&gt;SetAromatic();</a>
<a name="ln1022"> </a>
<a name="ln1023">    if (_prev) //need to add bond</a>
<a name="ln1024">      {</a>
<a name="ln1025">        OBAtom* prevatom = mol.GetAtom(_prev);</a>
<a name="ln1026">        assert(prevatom);</a>
<a name="ln1027">        if (arom &amp;&amp; prevatom-&gt;IsAromatic() &amp;&amp; _order == 0)</a>
<a name="ln1028">          mol.AddBond(_prev, mol.NumAtoms(), 1, OB_AROMATIC_BOND); // this will be kekulized later</a>
<a name="ln1029">        else</a>
<a name="ln1030">          mol.AddBond(_prev, mol.NumAtoms(), _order == 0 ? 1 : _order);</a>
<a name="ln1031">        // store up/down</a>
<a name="ln1032">        if (_updown == BondUpChar || _updown == BondDownChar)</a>
<a name="ln1033">          _upDownMap[mol.GetBond(_prev, mol.NumAtoms())] = _updown;</a>
<a name="ln1034"> </a>
<a name="ln1035">        InsertTetrahedralRef(mol, mol.NumAtoms() - 1);</a>
<a name="ln1036">        InsertSquarePlanarRef(mol, mol.NumAtoms() - 1);</a>
<a name="ln1037">      }</a>
<a name="ln1038"> </a>
<a name="ln1039">    //set values</a>
<a name="ln1040">    _prev = mol.NumAtoms();</a>
<a name="ln1041">    _order = 0; // the default is that no bond symbol has been seen</a>
<a name="ln1042">    _updown = ' ';</a>
<a name="ln1043"> </a>
<a name="ln1044">    _hcount.push_back(-1); // implicit hydrogen count</a>
<a name="ln1045"> </a>
<a name="ln1046">    return(true);</a>
<a name="ln1047">  }</a>
<a name="ln1048"> </a>
<a name="ln1049">  bool OBSmilesParser::ParseComplex(OBMol &amp;mol)</a>
<a name="ln1050">  {</a>
<a name="ln1051">    int element=0;</a>
<a name="ln1052">    bool arom=false;</a>
<a name="ln1053"> </a>
<a name="ln1054">    _ptr++;</a>
<a name="ln1055"> </a>
<a name="ln1056">    // Parse isotope information</a>
<a name="ln1057">    // - we parse anything with 1 to 4 digits</a>
<a name="ln1058">    // - any bigger and we risk overflowing the short int used to</a>
<a name="ln1059">    //   store the isotope information (max 65536)</a>
<a name="ln1060">    int isotope = 0;</a>
<a name="ln1061">    unsigned int size = 0;</a>
<a name="ln1062">    for (;*_ptr &amp;&amp; isdigit(*_ptr) &amp;&amp; size &lt; 5;_ptr++) {</a>
<a name="ln1063">      isotope *= 10;</a>
<a name="ln1064">      isotope += *_ptr - '0';</a>
<a name="ln1065">      size++;</a>
<a name="ln1066">    }</a>
<a name="ln1067">    if (size == 5)</a>
<a name="ln1068">      return false;</a>
<a name="ln1069"> </a>
<a name="ln1070">    //parse element data</a>
<a name="ln1071">    switch(*_ptr)</a>
<a name="ln1072">    {</a>
<a name="ln1073">      case '*':</a>
<a name="ln1074">        element = 0;</a>
<a name="ln1075">        break;</a>
<a name="ln1076"> </a>
<a name="ln1077">      case 'C':</a>
<a name="ln1078">        _ptr++;</a>
<a name="ln1079">        switch(*_ptr)</a>
<a name="ln1080">          {</a>
<a name="ln1081">          case 'a':</a>
<a name="ln1082">            element = 20;</a>
<a name="ln1083">            break;</a>
<a name="ln1084">          case 'd':</a>
<a name="ln1085">            element = 48;</a>
<a name="ln1086">            break;</a>
<a name="ln1087">          case 'e':</a>
<a name="ln1088">            element = 58;</a>
<a name="ln1089">            break;</a>
<a name="ln1090">          case 'f':</a>
<a name="ln1091">            element = 98;</a>
<a name="ln1092">            break;</a>
<a name="ln1093">          case 'l':</a>
<a name="ln1094">            element = 17;</a>
<a name="ln1095">            break;</a>
<a name="ln1096">          case 'm':</a>
<a name="ln1097">            element = 96;</a>
<a name="ln1098">            break;</a>
<a name="ln1099">          case 'n':</a>
<a name="ln1100">            element = 112;</a>
<a name="ln1101">            break;</a>
<a name="ln1102">          case 'o':</a>
<a name="ln1103">            element = 27;</a>
<a name="ln1104">            break;</a>
<a name="ln1105">          case 'r':</a>
<a name="ln1106">            element = 24;</a>
<a name="ln1107">            break;</a>
<a name="ln1108">          case 's':</a>
<a name="ln1109">            element = 55;</a>
<a name="ln1110">            break;</a>
<a name="ln1111">          case 'u':</a>
<a name="ln1112">            element = 29;</a>
<a name="ln1113">            break;</a>
<a name="ln1114">          default:</a>
<a name="ln1115">            element =  6;</a>
<a name="ln1116">            _ptr--;</a>
<a name="ln1117">          }</a>
<a name="ln1118">        break;</a>
<a name="ln1119"> </a>
<a name="ln1120">      case 'N':</a>
<a name="ln1121">        _ptr++;</a>
<a name="ln1122">        switch(*_ptr)</a>
<a name="ln1123">          {</a>
<a name="ln1124">          case 'a':</a>
<a name="ln1125">            element =  11;</a>
<a name="ln1126">            break;</a>
<a name="ln1127">          case 'b':</a>
<a name="ln1128">            element =  41;</a>
<a name="ln1129">            break;</a>
<a name="ln1130">          case 'd':</a>
<a name="ln1131">            element =  60;</a>
<a name="ln1132">            break;</a>
<a name="ln1133">          case 'e':</a>
<a name="ln1134">            element =  10;</a>
<a name="ln1135">            break;</a>
<a name="ln1136">          case 'h':</a>
<a name="ln1137">            element = 113;</a>
<a name="ln1138">            break;</a>
<a name="ln1139">          case 'i':</a>
<a name="ln1140">            element =  28;</a>
<a name="ln1141">            break;</a>
<a name="ln1142">          case 'o':</a>
<a name="ln1143">            element = 102;</a>
<a name="ln1144">            break;</a>
<a name="ln1145">          case 'p':</a>
<a name="ln1146">            element =  93;</a>
<a name="ln1147">            break;</a>
<a name="ln1148">          default:</a>
<a name="ln1149">            element =   7;</a>
<a name="ln1150">            _ptr--;</a>
<a name="ln1151">          }</a>
<a name="ln1152">        break;</a>
<a name="ln1153"> </a>
<a name="ln1154">      case 'O':</a>
<a name="ln1155">        _ptr++;</a>
<a name="ln1156">        switch(*_ptr) {</a>
<a name="ln1157">        case 'g':</a>
<a name="ln1158">          element = 118;</a>
<a name="ln1159">          break;</a>
<a name="ln1160">        case 's':</a>
<a name="ln1161">          element = 76;</a>
<a name="ln1162">          break;</a>
<a name="ln1163">        default:</a>
<a name="ln1164">          element = 8;</a>
<a name="ln1165">          _ptr--;</a>
<a name="ln1166">        }</a>
<a name="ln1167">        break;</a>
<a name="ln1168"> </a>
<a name="ln1169">      case 'P':</a>
<a name="ln1170">        _ptr++;</a>
<a name="ln1171">        switch(*_ptr)</a>
<a name="ln1172">          {</a>
<a name="ln1173">          case 'a':</a>
<a name="ln1174">            element = 91;</a>
<a name="ln1175">            break;</a>
<a name="ln1176">          case 'b':</a>
<a name="ln1177">            element = 82;</a>
<a name="ln1178">            break;</a>
<a name="ln1179">          case 'd':</a>
<a name="ln1180">            element = 46;</a>
<a name="ln1181">            break;</a>
<a name="ln1182">          case 'm':</a>
<a name="ln1183">            element = 61;</a>
<a name="ln1184">            break;</a>
<a name="ln1185">          case 'o':</a>
<a name="ln1186">            element = 84;</a>
<a name="ln1187">            break;</a>
<a name="ln1188">          case 'r':</a>
<a name="ln1189">            element = 59;</a>
<a name="ln1190">            break;</a>
<a name="ln1191">          case 't':</a>
<a name="ln1192">            element = 78;</a>
<a name="ln1193">            break;</a>
<a name="ln1194">          case 'u':</a>
<a name="ln1195">            element = 94;</a>
<a name="ln1196">            break;</a>
<a name="ln1197">          default:</a>
<a name="ln1198">            element = 15;</a>
<a name="ln1199">            _ptr--;</a>
<a name="ln1200">          }</a>
<a name="ln1201">        break;</a>
<a name="ln1202"> </a>
<a name="ln1203">      case('S'):</a>
<a name="ln1204">        _ptr++;</a>
<a name="ln1205">        switch(*_ptr)</a>
<a name="ln1206">          {</a>
<a name="ln1207">          case 'b':</a>
<a name="ln1208">            element = 51;</a>
<a name="ln1209">            break;</a>
<a name="ln1210">          case 'c':</a>
<a name="ln1211">            element = 21;</a>
<a name="ln1212">            break;</a>
<a name="ln1213">          case 'e':</a>
<a name="ln1214">            element = 34;</a>
<a name="ln1215">            break;</a>
<a name="ln1216">          case 'g':</a>
<a name="ln1217">            element = 106;</a>
<a name="ln1218">            break;</a>
<a name="ln1219">          case 'i':</a>
<a name="ln1220">            element = 14;</a>
<a name="ln1221">            break;</a>
<a name="ln1222">          case 'm':</a>
<a name="ln1223">            element = 62;</a>
<a name="ln1224">            break;</a>
<a name="ln1225">          case 'n':</a>
<a name="ln1226">            element = 50;</a>
<a name="ln1227">            break;</a>
<a name="ln1228">          case 'r':</a>
<a name="ln1229">            element = 38;</a>
<a name="ln1230">            break;</a>
<a name="ln1231">          default:</a>
<a name="ln1232">            element = 16;</a>
<a name="ln1233">            _ptr--;</a>
<a name="ln1234">          }</a>
<a name="ln1235">        break;</a>
<a name="ln1236"> </a>
<a name="ln1237">      case 'B':</a>
<a name="ln1238">        _ptr++;</a>
<a name="ln1239">        switch(*_ptr)</a>
<a name="ln1240">          {</a>
<a name="ln1241">          case 'a':</a>
<a name="ln1242">            element = 56;</a>
<a name="ln1243">            break;</a>
<a name="ln1244">          case 'e':</a>
<a name="ln1245">            element =  4;</a>
<a name="ln1246">            break;</a>
<a name="ln1247">          case 'h':</a>
<a name="ln1248">            element =  107;</a>
<a name="ln1249">            break;</a>
<a name="ln1250">          case 'i':</a>
<a name="ln1251">            element = 83;</a>
<a name="ln1252">            break;</a>
<a name="ln1253">          case 'k':</a>
<a name="ln1254">            element = 97;</a>
<a name="ln1255">            break;</a>
<a name="ln1256">          case 'r':</a>
<a name="ln1257">            element = 35;</a>
<a name="ln1258">            break;</a>
<a name="ln1259">          default:</a>
<a name="ln1260">            element = 5;</a>
<a name="ln1261">            _ptr--;</a>
<a name="ln1262">          }</a>
<a name="ln1263">        break;</a>
<a name="ln1264"> </a>
<a name="ln1265">      case 'F':</a>
<a name="ln1266">        _ptr++;</a>
<a name="ln1267">        switch(*_ptr)</a>
<a name="ln1268">          {</a>
<a name="ln1269">          case 'e':</a>
<a name="ln1270">            element = 26;</a>
<a name="ln1271">            break;</a>
<a name="ln1272">          case 'l':</a>
<a name="ln1273">            element = 114;</a>
<a name="ln1274">            break;</a>
<a name="ln1275">          case 'm':</a>
<a name="ln1276">            element = 100;</a>
<a name="ln1277">            break;</a>
<a name="ln1278">          case 'r':</a>
<a name="ln1279">            element = 87;</a>
<a name="ln1280">            break;</a>
<a name="ln1281">          default:</a>
<a name="ln1282">            element = 9;</a>
<a name="ln1283">            _ptr--;</a>
<a name="ln1284">          }</a>
<a name="ln1285">        break;</a>
<a name="ln1286"> </a>
<a name="ln1287">      case 'I':</a>
<a name="ln1288">        _ptr++;</a>
<a name="ln1289">        switch(*_ptr)</a>
<a name="ln1290">          {</a>
<a name="ln1291">          case 'n':</a>
<a name="ln1292">            element = 49;</a>
<a name="ln1293">            break;</a>
<a name="ln1294">          case 'r':</a>
<a name="ln1295">            element = 77;</a>
<a name="ln1296">            break;</a>
<a name="ln1297">          default:</a>
<a name="ln1298">            element = 53;</a>
<a name="ln1299">            _ptr--;</a>
<a name="ln1300">          }</a>
<a name="ln1301">        break;</a>
<a name="ln1302"> </a>
<a name="ln1303">      case 'A':</a>
<a name="ln1304">        _ptr++;</a>
<a name="ln1305">        switch(*_ptr)</a>
<a name="ln1306">          {</a>
<a name="ln1307">          case 'c':</a>
<a name="ln1308">            element = 89;</a>
<a name="ln1309">            break;</a>
<a name="ln1310">          case 'g':</a>
<a name="ln1311">            element = 47;</a>
<a name="ln1312">            break;</a>
<a name="ln1313">          case 'l':</a>
<a name="ln1314">            element = 13;</a>
<a name="ln1315">            break;</a>
<a name="ln1316">          case 'm':</a>
<a name="ln1317">            element = 95;</a>
<a name="ln1318">            break;</a>
<a name="ln1319">          case 'r':</a>
<a name="ln1320">            element = 18;</a>
<a name="ln1321">            break;</a>
<a name="ln1322">          case 's':</a>
<a name="ln1323">            element = 33;</a>
<a name="ln1324">            break;</a>
<a name="ln1325">          case 't':</a>
<a name="ln1326">            element = 85;</a>
<a name="ln1327">            break;</a>
<a name="ln1328">          case 'u':</a>
<a name="ln1329">            element = 79;</a>
<a name="ln1330">            break;</a>
<a name="ln1331">          default:</a>
<a name="ln1332">            return(false);</a>
<a name="ln1333">          }</a>
<a name="ln1334">        break;</a>
<a name="ln1335"> </a>
<a name="ln1336">      case 'D':</a>
<a name="ln1337">        _ptr++;</a>
<a name="ln1338">        switch(*_ptr)</a>
<a name="ln1339">          {</a>
<a name="ln1340">          case 'b':</a>
<a name="ln1341">            element = 105;</a>
<a name="ln1342">            break;</a>
<a name="ln1343">          case 's':</a>
<a name="ln1344">            element = 110;</a>
<a name="ln1345">            break;</a>
<a name="ln1346">          case 'y':</a>
<a name="ln1347">            element = 66;</a>
<a name="ln1348">            break;</a>
<a name="ln1349">          default:</a>
<a name="ln1350">            return(false);</a>
<a name="ln1351">          }</a>
<a name="ln1352">        break;</a>
<a name="ln1353"> </a>
<a name="ln1354">      case 'E':</a>
<a name="ln1355">        _ptr++;</a>
<a name="ln1356">        switch(*_ptr)</a>
<a name="ln1357">          {</a>
<a name="ln1358">          case 'r':</a>
<a name="ln1359">            element = 68;</a>
<a name="ln1360">            break;</a>
<a name="ln1361">          case 's':</a>
<a name="ln1362">            element = 99;</a>
<a name="ln1363">            break;</a>
<a name="ln1364">          case 'u':</a>
<a name="ln1365">            element = 63;</a>
<a name="ln1366">            break;</a>
<a name="ln1367">          default:</a>
<a name="ln1368">            return(false);</a>
<a name="ln1369">          }</a>
<a name="ln1370">        break;</a>
<a name="ln1371"> </a>
<a name="ln1372">      case 'G':</a>
<a name="ln1373">        _ptr++;</a>
<a name="ln1374">        switch (*_ptr)</a>
<a name="ln1375">          {</a>
<a name="ln1376">          case 'a':</a>
<a name="ln1377">            element = 31;</a>
<a name="ln1378">            break;</a>
<a name="ln1379">          case 'd':</a>
<a name="ln1380">            element = 64;</a>
<a name="ln1381">            break;</a>
<a name="ln1382">          case 'e':</a>
<a name="ln1383">            element = 32;</a>
<a name="ln1384">            break;</a>
<a name="ln1385">          default:</a>
<a name="ln1386">            return(false);</a>
<a name="ln1387">          }</a>
<a name="ln1388">        break;</a>
<a name="ln1389"> </a>
<a name="ln1390">      case 'H':</a>
<a name="ln1391">        _ptr++;</a>
<a name="ln1392">        switch (*_ptr)</a>
<a name="ln1393">          {</a>
<a name="ln1394">          case 'e':</a>
<a name="ln1395">            element =  2;</a>
<a name="ln1396">            break;</a>
<a name="ln1397">          case 'f':</a>
<a name="ln1398">            element = 72;</a>
<a name="ln1399">            break;</a>
<a name="ln1400">          case 'g':</a>
<a name="ln1401">            element = 80;</a>
<a name="ln1402">            break;</a>
<a name="ln1403">          case 'o':</a>
<a name="ln1404">            element = 67;</a>
<a name="ln1405">            break;</a>
<a name="ln1406">          case 's':</a>
<a name="ln1407">            element = 108;</a>
<a name="ln1408">            break;</a>
<a name="ln1409">          default:</a>
<a name="ln1410">            element = 1;</a>
<a name="ln1411">            _ptr--;</a>
<a name="ln1412">          }</a>
<a name="ln1413">        break;</a>
<a name="ln1414"> </a>
<a name="ln1415">      case 'K':</a>
<a name="ln1416">        _ptr++;</a>
<a name="ln1417">        if(*_ptr == 'r')</a>
<a name="ln1418">          {</a>
<a name="ln1419">            element = 36;</a>
<a name="ln1420">          }</a>
<a name="ln1421">        else</a>
<a name="ln1422">          {</a>
<a name="ln1423">            element = 19;</a>
<a name="ln1424">            _ptr--;</a>
<a name="ln1425">          }</a>
<a name="ln1426">        break;</a>
<a name="ln1427"> </a>
<a name="ln1428">      case 'L':</a>
<a name="ln1429">        _ptr++;</a>
<a name="ln1430">        switch(*_ptr)</a>
<a name="ln1431">          {</a>
<a name="ln1432">          case 'a':</a>
<a name="ln1433">            element =  57;</a>
<a name="ln1434">            break;</a>
<a name="ln1435">          case 'i':</a>
<a name="ln1436">            element =   3;</a>
<a name="ln1437">            break;</a>
<a name="ln1438">          case 'r':</a>
<a name="ln1439">            element = 103;</a>
<a name="ln1440">            break;</a>
<a name="ln1441">          case 'u':</a>
<a name="ln1442">            element =  71;</a>
<a name="ln1443">            break;</a>
<a name="ln1444">          case 'v':</a>
<a name="ln1445">            element = 116;</a>
<a name="ln1446">            break;</a>
<a name="ln1447">          default:</a>
<a name="ln1448">            return(false);</a>
<a name="ln1449">          }</a>
<a name="ln1450">        break;</a>
<a name="ln1451"> </a>
<a name="ln1452">      case 'M':</a>
<a name="ln1453">        _ptr++;</a>
<a name="ln1454">        switch(*_ptr)</a>
<a name="ln1455">          {</a>
<a name="ln1456">          case 'c':</a>
<a name="ln1457">            element = 115;</a>
<a name="ln1458">            break;</a>
<a name="ln1459">          case 'd':</a>
<a name="ln1460">            element = 101;</a>
<a name="ln1461">            break;</a>
<a name="ln1462">          case 'g':</a>
<a name="ln1463">            element =  12;</a>
<a name="ln1464">            break;</a>
<a name="ln1465">          case 'n':</a>
<a name="ln1466">            element =  25;</a>
<a name="ln1467">            break;</a>
<a name="ln1468">          case 'o':</a>
<a name="ln1469">            element =  42;</a>
<a name="ln1470">            break;</a>
<a name="ln1471">          case 't':</a>
<a name="ln1472">            element =  109;</a>
<a name="ln1473">            break;</a>
<a name="ln1474">          default:</a>
<a name="ln1475">            return(false);</a>
<a name="ln1476">          }</a>
<a name="ln1477">        break;</a>
<a name="ln1478"> </a>
<a name="ln1479">      case 'R':</a>
<a name="ln1480">        _ptr++;</a>
<a name="ln1481">        switch(*_ptr)</a>
<a name="ln1482">          {</a>
<a name="ln1483">          case 'a':</a>
<a name="ln1484">            element = 88;</a>
<a name="ln1485">            break;</a>
<a name="ln1486">          case 'b':</a>
<a name="ln1487">            element = 37;</a>
<a name="ln1488">            break;</a>
<a name="ln1489">          case 'e':</a>
<a name="ln1490">            element = 75;</a>
<a name="ln1491">            break;</a>
<a name="ln1492">          case 'f':</a>
<a name="ln1493">            element = 104;</a>
<a name="ln1494">            break;</a>
<a name="ln1495">          case 'g':</a>
<a name="ln1496">            element = 111;</a>
<a name="ln1497">            break;</a>
<a name="ln1498">          case 'h':</a>
<a name="ln1499">            element = 45;</a>
<a name="ln1500">            break;</a>
<a name="ln1501">          case 'n':</a>
<a name="ln1502">            element = 86;</a>
<a name="ln1503">            break;</a>
<a name="ln1504">          case 'u':</a>
<a name="ln1505">            element = 44;</a>
<a name="ln1506">            break;</a>
<a name="ln1507">          default:</a>
<a name="ln1508">            return(false);</a>
<a name="ln1509">          }</a>
<a name="ln1510">        break;</a>
<a name="ln1511"> </a>
<a name="ln1512">      case 'T':</a>
<a name="ln1513">        _ptr++;</a>
<a name="ln1514">        switch(*_ptr)</a>
<a name="ln1515">          {</a>
<a name="ln1516">          case 'a':</a>
<a name="ln1517">            element = 73;</a>
<a name="ln1518">            break;</a>
<a name="ln1519">          case 'b':</a>
<a name="ln1520">            element = 65;</a>
<a name="ln1521">            break;</a>
<a name="ln1522">          case 'c':</a>
<a name="ln1523">            element = 43;</a>
<a name="ln1524">            break;</a>
<a name="ln1525">          case 'e':</a>
<a name="ln1526">            element = 52;</a>
<a name="ln1527">            break;</a>
<a name="ln1528">          case 'h':</a>
<a name="ln1529">            element = 90;</a>
<a name="ln1530">            break;</a>
<a name="ln1531">          case 'i':</a>
<a name="ln1532">            element = 22;</a>
<a name="ln1533">            break;</a>
<a name="ln1534">          case 'l':</a>
<a name="ln1535">            element = 81;</a>
<a name="ln1536">            break;</a>
<a name="ln1537">          case 'm':</a>
<a name="ln1538">            element = 69;</a>
<a name="ln1539">            break;</a>
<a name="ln1540">          case 's':</a>
<a name="ln1541">            element = 117;</a>
<a name="ln1542">            break;</a>
<a name="ln1543">          default:</a>
<a name="ln1544">            return(false);</a>
<a name="ln1545">          }</a>
<a name="ln1546">        break;</a>
<a name="ln1547"> </a>
<a name="ln1548">      case('U'):  element = 92;</a>
<a name="ln1549">        break;</a>
<a name="ln1550">      case('V'):  element = 23;</a>
<a name="ln1551">        break;</a>
<a name="ln1552">      case('W'):  element = 74;</a>
<a name="ln1553">        break;</a>
<a name="ln1554"> </a>
<a name="ln1555">      case('X'):</a>
<a name="ln1556">        _ptr++;</a>
<a name="ln1557">        if (*_ptr == 'e')</a>
<a name="ln1558">          {</a>
<a name="ln1559">            element = 54;</a>
<a name="ln1560">          }</a>
<a name="ln1561">        else</a>
<a name="ln1562">          {</a>
<a name="ln1563">            return(false);</a>
<a name="ln1564">          }</a>
<a name="ln1565">        break;</a>
<a name="ln1566"> </a>
<a name="ln1567">      case('Y'):</a>
<a name="ln1568">        _ptr++;</a>
<a name="ln1569">        if (*_ptr == 'b')</a>
<a name="ln1570">          {</a>
<a name="ln1571">            element = 70;</a>
<a name="ln1572">          }</a>
<a name="ln1573">        else</a>
<a name="ln1574">          {</a>
<a name="ln1575">            element = 39;</a>
<a name="ln1576">            _ptr--;</a>
<a name="ln1577">          }</a>
<a name="ln1578">        break;</a>
<a name="ln1579"> </a>
<a name="ln1580">      case('Z'):</a>
<a name="ln1581">        _ptr++;</a>
<a name="ln1582">        switch(*_ptr)</a>
<a name="ln1583">          {</a>
<a name="ln1584">          case 'n':</a>
<a name="ln1585">            element = 30;</a>
<a name="ln1586">            break;</a>
<a name="ln1587">          case 'r':</a>
<a name="ln1588">            element = 40;</a>
<a name="ln1589">            break;</a>
<a name="ln1590">          default:</a>
<a name="ln1591">            return false;</a>
<a name="ln1592">          }</a>
<a name="ln1593">        break;</a>
<a name="ln1594"> </a>
<a name="ln1595">      case 'a':</a>
<a name="ln1596">        _ptr++;</a>
<a name="ln1597">        if (*_ptr == 's') {</a>
<a name="ln1598">          arom = true;</a>
<a name="ln1599">          element = 33;</a>
<a name="ln1600">        }</a>
<a name="ln1601">        else</a>
<a name="ln1602">          return false;</a>
<a name="ln1603">        break;</a>
<a name="ln1604"> </a>
<a name="ln1605">      case 'b':</a>
<a name="ln1606">        _ptr++;</a>
<a name="ln1607">        if (*_ptr == 'i') {</a>
<a name="ln1608">          arom = true;</a>
<a name="ln1609">          element = 83;</a>
<a name="ln1610">        }</a>
<a name="ln1611">        else {</a>
<a name="ln1612">          arom = true;</a>
<a name="ln1613">          element = 5;</a>
<a name="ln1614">          _ptr--;</a>
<a name="ln1615">        }</a>
<a name="ln1616">        break;</a>
<a name="ln1617"> </a>
<a name="ln1618">      case 'c':</a>
<a name="ln1619">        arom = true;</a>
<a name="ln1620">        element = 6;</a>
<a name="ln1621">        break;</a>
<a name="ln1622"> </a>
<a name="ln1623">      case 'g':</a>
<a name="ln1624">        _ptr++;</a>
<a name="ln1625">        if (*_ptr == 'e') {</a>
<a name="ln1626">          arom = true;</a>
<a name="ln1627">          element = 32;</a>
<a name="ln1628">        }</a>
<a name="ln1629">        else</a>
<a name="ln1630">          return false;</a>
<a name="ln1631">        break;</a>
<a name="ln1632"> </a>
<a name="ln1633">      case 'n':</a>
<a name="ln1634">        arom = true;</a>
<a name="ln1635">        element = 7;</a>
<a name="ln1636">        break;</a>
<a name="ln1637"> </a>
<a name="ln1638">      case 'o':</a>
<a name="ln1639">        arom = true;</a>
<a name="ln1640">        element = 8;</a>
<a name="ln1641">        break;</a>
<a name="ln1642"> </a>
<a name="ln1643">      case 'p':</a>
<a name="ln1644">        arom = true;</a>
<a name="ln1645">        element = 15;</a>
<a name="ln1646">        break;</a>
<a name="ln1647"> </a>
<a name="ln1648">      case 's':</a>
<a name="ln1649">        arom = true;</a>
<a name="ln1650">        _ptr++;</a>
<a name="ln1651">        switch (*_ptr) {</a>
<a name="ln1652">        case 'e':</a>
<a name="ln1653">          element = 34;</a>
<a name="ln1654">          break;</a>
<a name="ln1655">        case 'i':</a>
<a name="ln1656">          element = 14;</a>
<a name="ln1657">          break;</a>
<a name="ln1658">        case 'n':</a>
<a name="ln1659">          element = 50;</a>
<a name="ln1660">          break;</a>
<a name="ln1661">        case 'b':</a>
<a name="ln1662">          element = 51;</a>
<a name="ln1663">          break;</a>
<a name="ln1664">        default:</a>
<a name="ln1665">          element = 16;</a>
<a name="ln1666">          _ptr--;</a>
<a name="ln1667">        }</a>
<a name="ln1668">        break;</a>
<a name="ln1669"> </a>
<a name="ln1670">      case 't':</a>
<a name="ln1671">        _ptr++;</a>
<a name="ln1672">        if (*_ptr == 'e') {</a>
<a name="ln1673">          arom = true;</a>
<a name="ln1674">          element = 52;</a>
<a name="ln1675">        }</a>
<a name="ln1676">        else</a>
<a name="ln1677">          return false;</a>
<a name="ln1678">        break;</a>
<a name="ln1679"> </a>
<a name="ln1680">      case '#':</a>
<a name="ln1681">        // Only support three digits for this extension</a>
<a name="ln1682">        if ((_ptr[1] == '1' || _ptr[1] == '2') &amp;&amp;</a>
<a name="ln1683">            (_ptr[2] &gt;= '0' &amp;&amp; _ptr[2] &lt;= '9') &amp;&amp;</a>
<a name="ln1684">            (_ptr[3] &gt;= '0' &amp;&amp; _ptr[3] &lt;= '9')) {</a>
<a name="ln1685">          element = (_ptr[1]-'0')*100 + (_ptr[2]-'0')*10 + (_ptr[3]-'0');</a>
<a name="ln1686">          if (element &gt; 255) {</a>
<a name="ln1687">            std::string err = &quot;Element number must be &lt;= 255)&quot;;</a>
<a name="ln1688">            obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1689">              err, obError);</a>
<a name="ln1690">            return false;</a>
<a name="ln1691">          }</a>
<a name="ln1692">          _ptr += 3;</a>
<a name="ln1693">          break;</a>
<a name="ln1694">        }</a>
<a name="ln1695">        /* fall through to default */</a>
<a name="ln1696"> </a>
<a name="ln1697">      default:</a>
<a name="ln1698">        {</a>
<a name="ln1699">          std::string err;</a>
<a name="ln1700">          err += &quot;SMILES string contains a character '&quot;;</a>
<a name="ln1701">          err += *_ptr;</a>
<a name="ln1702">          err += &quot;' which is invalid&quot;;</a>
<a name="ln1703">          obErrorLog.ThrowError(__FUNCTION__,</a>
<a name="ln1704">            err, obError);</a>
<a name="ln1705">          return false;</a>
<a name="ln1706">        }</a>
<a name="ln1707">      }</a>
<a name="ln1708"> </a>
<a name="ln1709">    //handle hydrogen count, stereochemistry, and charge</a>
<a name="ln1710"> </a>
<a name="ln1711">    OBAtom *atom = mol.NewAtom();</a>
<a name="ln1712">    int hcount = 0;</a>
<a name="ln1713">    int charge=0;</a>
<a name="ln1714">    int rad=0;</a>
<a name="ln1715">    int clval=0;</a>
<a name="ln1716">    char tmpc[2];</a>
<a name="ln1717">    tmpc[1] = '\0';</a>
<a name="ln1718"> </a>
<a name="ln1719">    stringstream errorMsg;</a>
<a name="ln1720"> </a>
<a name="ln1721">    for (_ptr++;*_ptr &amp;&amp; *_ptr != ']';_ptr++)</a>
<a name="ln1722">      {</a>
<a name="ln1723">        switch(*_ptr)</a>
<a name="ln1724">          {</a>
<a name="ln1725">          case '@':</a>
<a name="ln1726">            _ptr++;</a>
<a name="ln1727">            if (*_ptr == 'S' &amp;&amp; _ptr[1] == 'P') { // @SP1/2/3</a>
<a name="ln1728">              // square planar atom found</a>
<a name="ln1729">              squarePlanarWatch = true;</a>
<a name="ln1730">              if (_squarePlanarMap.find(atom)==_squarePlanarMap.end()) // Prevent memory leak for malformed smiles (PR#3428432)</a>
<a name="ln1731">                _squarePlanarMap[atom] = new OBSquarePlanarStereo::Config;</a>
<a name="ln1732">              _squarePlanarMap[atom]-&gt;refs = OBStereo::Refs(4, OBStereo::NoRef);</a>
<a name="ln1733">              _squarePlanarMap[atom]-&gt;center = atom-&gt;GetId();</a>
<a name="ln1734">              _ptr += 2;</a>
<a name="ln1735">              switch(*_ptr) {</a>
<a name="ln1736">              case '1':</a>
<a name="ln1737">                _squarePlanarMap[atom]-&gt;shape = OBStereo::ShapeU; break;</a>
<a name="ln1738">              case '2':</a>
<a name="ln1739">                _squarePlanarMap[atom]-&gt;shape = OBStereo::Shape4; break;</a>
<a name="ln1740">              case '3':</a>
<a name="ln1741">                _squarePlanarMap[atom]-&gt;shape = OBStereo::ShapeZ; break;</a>
<a name="ln1742">              default:</a>
<a name="ln1743">                obErrorLog.ThrowError(__FUNCTION__, &quot;Square planar stereochemistry must be one of SP1, SP2 or SP3&quot;, obWarning);</a>
<a name="ln1744">                return false;</a>
<a name="ln1745">              }</a>
<a name="ln1746">            } else {</a>
<a name="ln1747">              // tetrahedral atom found</a>
<a name="ln1748">              chiralWatch=true;</a>
<a name="ln1749">              if (_tetrahedralMap.find(atom)==_tetrahedralMap.end()) // Prevent memory leak for malformed smiles (PR#3428432)</a>
<a name="ln1750">                _tetrahedralMap[atom] = new OBTetrahedralStereo::Config;</a>
<a name="ln1751">              _tetrahedralMap[atom]-&gt;refs = OBStereo::Refs(3, OBStereo::NoRef);</a>
<a name="ln1752">              _tetrahedralMap[atom]-&gt;center = atom-&gt;GetId();</a>
<a name="ln1753">              if (*_ptr == '@') {</a>
<a name="ln1754">                _tetrahedralMap[atom]-&gt;winding = OBStereo::Clockwise;</a>
<a name="ln1755">              } else if (*_ptr == '?') {</a>
<a name="ln1756">                _tetrahedralMap[atom]-&gt;specified = false;</a>
<a name="ln1757">              } else {</a>
<a name="ln1758">                _tetrahedralMap[atom]-&gt;winding = OBStereo::AntiClockwise;</a>
<a name="ln1759">                _ptr--;</a>
<a name="ln1760">              }</a>
<a name="ln1761">            }</a>
<a name="ln1762">            break;</a>
<a name="ln1763">          case '-':</a>
<a name="ln1764">            if (charge) {</a>
<a name="ln1765">              obErrorLog.ThrowError(__FUNCTION__, &quot;Charge can only be specified once&quot;, obWarning);</a>
<a name="ln1766">              return false;</a>
<a name="ln1767">            }</a>
<a name="ln1768">            while (*++_ptr == '-')</a>
<a name="ln1769">              charge--; // handle [O--]</a>
<a name="ln1770">            if (charge == 0) {</a>
<a name="ln1771">              while (isdigit(*_ptr)) // handle [O-2]</a>
<a name="ln1772">                charge = charge * 10 - ((*_ptr++) - '0');</a>
<a name="ln1773">              if (charge == 0) // handle [Cl-]</a>
<a name="ln1774">                charge = -1;</a>
<a name="ln1775">            }</a>
<a name="ln1776">            else</a>
<a name="ln1777">              charge--; // finish handling [Ca++]</a>
<a name="ln1778">            _ptr--;</a>
<a name="ln1779">            break;</a>
<a name="ln1780">          case '+':</a>
<a name="ln1781">            if (charge) {</a>
<a name="ln1782">              obErrorLog.ThrowError(__FUNCTION__, &quot;Charge can only be specified once&quot;, obWarning);</a>
<a name="ln1783">              return false;</a>
<a name="ln1784">            }</a>
<a name="ln1785">            while (*++_ptr == '+')</a>
<a name="ln1786">              charge++; // handle [Ca++]</a>
<a name="ln1787">            if (charge == 0) {</a>
<a name="ln1788">              while (isdigit(*_ptr)) // handle [Ca+2]</a>
<a name="ln1789">                charge = charge * 10 + ((*_ptr++) - '0');</a>
<a name="ln1790">              if (charge == 0) // handle [Na+]</a>
<a name="ln1791">                charge = 1;</a>
<a name="ln1792">            }</a>
<a name="ln1793">            else</a>
<a name="ln1794">              charge++; // finish handling [Ca++]</a>
<a name="ln1795">            _ptr--;</a>
<a name="ln1796">            break;</a>
<a name="ln1797">          case 'H':</a>
<a name="ln1798">            _ptr++;</a>
<a name="ln1799">            if (isdigit(*_ptr))</a>
<a name="ln1800">              {</a>
<a name="ln1801">                tmpc[0] = *_ptr;</a>
<a name="ln1802">                hcount = atoi(tmpc);</a>
<a name="ln1803">              }</a>
<a name="ln1804">            else</a>
<a name="ln1805">              {</a>
<a name="ln1806">                hcount = 1;</a>
<a name="ln1807">                _ptr--;</a>
<a name="ln1808">              }</a>
<a name="ln1809">            break;</a>
<a name="ln1810">          case '.': //CM Feb05</a>
<a name="ln1811">            rad=2;</a>
<a name="ln1812">            if(*(++_ptr)=='.')</a>
<a name="ln1813">              rad=3;</a>
<a name="ln1814">            else</a>
<a name="ln1815">              _ptr--;</a>
<a name="ln1816">            break;</a>
<a name="ln1817"> </a>
<a name="ln1818">          case ':':</a>
<a name="ln1819">            if(!isdigit(*(++_ptr)))</a>
<a name="ln1820">              {</a>
<a name="ln1821">                obErrorLog.ThrowError(__FUNCTION__,&quot;The atom class following : must be a number&quot;, obWarning);</a>
<a name="ln1822">                return false;</a>
<a name="ln1823">              }</a>
<a name="ln1824">            while( isdigit(*_ptr) &amp;&amp; clval &lt; 100000000)</a>
<a name="ln1825">              clval = clval*10 + ((*_ptr++)-'0');</a>
<a name="ln1826">            --_ptr;</a>
<a name="ln1827">            { // a block is needed here to scope the OBPairInteger assignment</a>
<a name="ln1828">              OBPairInteger *atomclass = new OBPairInteger();</a>
<a name="ln1829">              atomclass-&gt;SetAttribute(&quot;Atom Class&quot;);</a>
<a name="ln1830">              atomclass-&gt;SetValue(clval);</a>
<a name="ln1831">              atomclass-&gt;SetOrigin(fileformatInput);</a>
<a name="ln1832">              atom-&gt;SetData(atomclass);</a>
<a name="ln1833">            }</a>
<a name="ln1834">            break;</a>
<a name="ln1835"> </a>
<a name="ln1836">          default:</a>
<a name="ln1837">            return(false);</a>
<a name="ln1838">          }</a>
<a name="ln1839">      }</a>
<a name="ln1840"> </a>
<a name="ln1841">    if (!*_ptr || *_ptr != ']')</a>
<a name="ln1842">      return(false); // we should have a trailing ']' now</a>
<a name="ln1843"> </a>
<a name="ln1844">    if (charge) {</a>
<a name="ln1845">      atom-&gt;SetFormalCharge(charge);</a>
<a name="ln1846">      if (abs(charge) &gt; 10 || (element &amp;&amp; charge &gt; element)) { // if the charge is +/- 10 or more than the number of electrons</a>
<a name="ln1847">        errorMsg &lt;&lt; &quot;Atom &quot; &lt;&lt; atom-&gt;GetIdx() &lt;&lt; &quot; had an unrealistic charge of &quot; &lt;&lt; charge</a>
<a name="ln1848">                 &lt;&lt; &quot;.&quot; &lt;&lt; endl;</a>
<a name="ln1849">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln1850">      }</a>
<a name="ln1851">    }</a>
<a name="ln1852">    if (rad)</a>
<a name="ln1853">      atom-&gt;SetSpinMultiplicity(rad);</a>
<a name="ln1854">    atom-&gt;SetAtomicNum(element);</a>
<a name="ln1855">    atom-&gt;SetIsotope(isotope);</a>
<a name="ln1856">    if (arom)</a>
<a name="ln1857">      atom-&gt;SetAromatic();</a>
<a name="ln1858">    if (_rxnrole &gt; 1) { // Quick test for reaction</a>
<a name="ln1859">      // Set reaction role</a>
<a name="ln1860">      OBPairInteger *pi = new OBPairInteger();</a>
<a name="ln1861">      pi-&gt;SetAttribute(&quot;rxnrole&quot;);</a>
<a name="ln1862">      pi-&gt;SetValue(_rxnrole);</a>
<a name="ln1863">      atom-&gt;SetData(pi);</a>
<a name="ln1864">    }</a>
<a name="ln1865"> </a>
<a name="ln1866">    if (_prev) //need to add bond</a>
<a name="ln1867">      {</a>
<a name="ln1868">        OBAtom* prevatom = mol.GetAtom(_prev);</a>
<a name="ln1869">        if (arom &amp;&amp; prevatom-&gt;IsAromatic() &amp;&amp; _order == 0)</a>
<a name="ln1870">          mol.AddBond(_prev, mol.NumAtoms(), 1, OB_AROMATIC_BOND); // this will be kekulized later</a>
<a name="ln1871">        else</a>
<a name="ln1872">          mol.AddBond(_prev, mol.NumAtoms(), _order == 0 ? 1 : _order);</a>
<a name="ln1873">        // store up/down</a>
<a name="ln1874">        if (_updown == BondUpChar || _updown == BondDownChar)</a>
<a name="ln1875">          _upDownMap[mol.GetBond(_prev, mol.NumAtoms())] = _updown;</a>
<a name="ln1876"> </a>
<a name="ln1877">        if(chiralWatch) { // if tetrahedral atom, set previous as from atom</a>
<a name="ln1878">          _tetrahedralMap[atom]-&gt;from = mol.GetAtom(_prev)-&gt;GetId();</a>
<a name="ln1879">          if (CanHaveLonePair(element)) // Handle chiral lone pair as in X[S@@](Y)Z</a>
<a name="ln1880">            _chiralLonePair[mol.NumAtoms()] = 1; // First of the refs</a>
<a name="ln1881"> </a>
<a name="ln1882">          //cerr &lt;&lt;&quot;NB7: line 1622: Added atom ref &quot;&lt;&lt;_prev&lt;&lt;&quot; at &quot; &lt;&lt; 0 &lt;&lt; &quot; to &quot;&lt;&lt;_mapcd[atom]&lt;&lt;endl;</a>
<a name="ln1883">        }</a>
<a name="ln1884">        if (squarePlanarWatch) { // if squareplanar atom, set previous atom as first ref</a>
<a name="ln1885">          _squarePlanarMap[atom]-&gt;refs[0] = mol.GetAtom(_prev)-&gt;GetId();</a>
<a name="ln1886">          //cerr &lt;&lt;&quot;TV7: line 1748: Added atom ref &quot; &lt;&lt; mol.GetAtom(_prev)-&gt;GetId()</a>
<a name="ln1887">          //     &lt;&lt; &quot; at &quot; &lt;&lt; 0 &lt;&lt; &quot; to &quot; &lt;&lt; _squarePlanarMap[atom] &lt;&lt; endl;</a>
<a name="ln1888">        }</a>
<a name="ln1889">        InsertTetrahedralRef(mol, atom-&gt;GetId());</a>
<a name="ln1890">        InsertSquarePlanarRef(mol, atom-&gt;GetId());</a>
<a name="ln1891">      }</a>
<a name="ln1892">    else</a>
<a name="ln1893">      {</a>
<a name="ln1894">        // Handle chiral lone pair as in [S@@](X)(Y)Z</a>
<a name="ln1895">        if (chiralWatch &amp;&amp; CanHaveLonePair(element)) // Handle chiral lone pair (only S at the moment)</a>
<a name="ln1896">          _chiralLonePair[mol.NumAtoms()] = 0; // 'from' atom</a>
<a name="ln1897">      }</a>
<a name="ln1898"> </a>
<a name="ln1899">    //set values</a>
<a name="ln1900">    _prev = mol.NumAtoms();</a>
<a name="ln1901">    _order = 0;</a>
<a name="ln1902">    _updown = ' ';</a>
<a name="ln1903"> </a>
<a name="ln1904">    if (hcount &gt; 0) {</a>
<a name="ln1905">      if (chiralWatch)</a>
<a name="ln1906">        InsertTetrahedralRef(mol, OBStereo::ImplicitRef);</a>
<a name="ln1907">      if (squarePlanarWatch)</a>
<a name="ln1908">        InsertSquarePlanarRef(mol, OBStereo::ImplicitRef);</a>
<a name="ln1909">    }</a>
<a name="ln1910">    _hcount.push_back(hcount);</a>
<a name="ln1911"> </a>
<a name="ln1912">    chiralWatch=false;</a>
<a name="ln1913">    squarePlanarWatch = false;</a>
<a name="ln1914">    return(true);</a>
<a name="ln1915">  }</a>
<a name="ln1916"> </a>
<a name="ln1917">  bool OBSmilesParser::CapExternalBonds(OBMol &amp;mol)</a>
<a name="ln1918">  {</a>
<a name="ln1919">    if (_extbond.empty())</a>
<a name="ln1920">      return true;</a>
<a name="ln1921"> </a>
<a name="ln1922">    OBAtom *atom;</a>
<a name="ln1923">    vector&lt;ExternalBond&gt;::iterator bond;</a>
<a name="ln1924">    for (bond = _extbond.begin(); bond != _extbond.end(); ++bond) {</a>
<a name="ln1925">      // create new dummy atom</a>
<a name="ln1926">      atom = mol.NewAtom();</a>
<a name="ln1927">      atom-&gt;SetAtomicNum(0);</a>
<a name="ln1928"> </a>
<a name="ln1929">      // bond dummy atom to mol via external bond</a>
<a name="ln1930">      mol.AddBond(bond-&gt;prev, atom-&gt;GetIdx(), bond-&gt;order);</a>
<a name="ln1931">      // store up/down</a>
<a name="ln1932">      if (bond-&gt;updown == BondUpChar || bond-&gt;updown == BondDownChar)</a>
<a name="ln1933">        _upDownMap[mol.GetBond(bond-&gt;prev, atom-&gt;GetIdx())] = bond-&gt;updown;</a>
<a name="ln1934"> </a>
<a name="ln1935">      OBBond *refbond = atom-&gt;GetBond(mol.GetAtom(bond-&gt;prev));</a>
<a name="ln1936"> </a>
<a name="ln1937">      //record external bond information</a>
<a name="ln1938">      OBExternalBondData *xbd;</a>
<a name="ln1939">      if (mol.HasData(OBGenericDataType::ExternalBondData)) {</a>
<a name="ln1940">        xbd = (OBExternalBondData*) mol.GetData(OBGenericDataType::ExternalBondData);</a>
<a name="ln1941">      } else {</a>
<a name="ln1942">        xbd = new OBExternalBondData;</a>
<a name="ln1943">        xbd-&gt;SetOrigin(fileformatInput);</a>
<a name="ln1944">        mol.SetData(xbd);</a>
<a name="ln1945">      }</a>
<a name="ln1946">      xbd-&gt;SetData(atom,refbond, bond-&gt;digit);</a>
<a name="ln1947">      //this data gets cleaned up in mol.Clear.</a>
<a name="ln1948">    }</a>
<a name="ln1949"> </a>
<a name="ln1950">    return true;</a>
<a name="ln1951">  }</a>
<a name="ln1952"> </a>
<a name="ln1953">  bool OBSmilesParser::ParseExternalBond(OBMol &amp;mol)</a>
<a name="ln1954">  {</a>
<a name="ln1955">    int digit;</a>
<a name="ln1956">    char str[10];</a>
<a name="ln1957"> </a>
<a name="ln1958">    //*_ptr should == '&amp;'</a>
<a name="ln1959">    _ptr++;</a>
<a name="ln1960"> </a>
<a name="ln1961">    switch (*_ptr) // check for bond order indicators CC&amp;=1.C&amp;1</a>
<a name="ln1962">      {</a>
<a name="ln1963">      case '-':</a>
<a name="ln1964">        _order = 1;</a>
<a name="ln1965">        _ptr++;</a>
<a name="ln1966">        break;</a>
<a name="ln1967">      case '=':</a>
<a name="ln1968">        _order = 2;</a>
<a name="ln1969">        _ptr++;</a>
<a name="ln1970">        break;</a>
<a name="ln1971">      case '#':</a>
<a name="ln1972">        _order = 3;</a>
<a name="ln1973">        _ptr++;</a>
<a name="ln1974">        break;</a>
<a name="ln1975">      case '$':</a>
<a name="ln1976">        _order = 4;</a>
<a name="ln1977">        _ptr++;</a>
<a name="ln1978">        break;</a>
<a name="ln1979">      case ';':</a>
<a name="ln1980">        _order = 5;</a>
<a name="ln1981">        _ptr++;</a>
<a name="ln1982">        break;</a>
<a name="ln1983">      case '/': //chiral, but _order still == 1</a>
<a name="ln1984">        _order = 1;</a>
<a name="ln1985">        _updown = BondDownChar;</a>
<a name="ln1986">        _ptr++;</a>
<a name="ln1987">        break;</a>
<a name="ln1988">      case '\\': // chiral, but _order still == 1</a>
<a name="ln1989">        _order = 1;</a>
<a name="ln1990">        _updown = BondUpChar;</a>
<a name="ln1991">        _ptr++;</a>
<a name="ln1992">        break;</a>
<a name="ln1993">      default: // no bond indicator just leave order = 0</a>
<a name="ln1994">        break;</a>
<a name="ln1995">      }</a>
<a name="ln1996"> </a>
<a name="ln1997">    if (*_ptr == '%') // external bond indicator &gt; 10</a>
<a name="ln1998">      {</a>
<a name="ln1999">        _ptr++;</a>
<a name="ln2000">        str[0] = *_ptr;</a>
<a name="ln2001">        _ptr++;</a>
<a name="ln2002">        str[1] = *_ptr;</a>
<a name="ln2003">        str[2] = '\0';</a>
<a name="ln2004">      }</a>
<a name="ln2005">    else // simple single digit external bond indicator</a>
<a name="ln2006">      {</a>
<a name="ln2007">        str[0] = *_ptr;</a>
<a name="ln2008">        str[1] = '\0';</a>
<a name="ln2009">      }</a>
<a name="ln2010">    digit = atoi(str);  // convert indicator to digit</a>
<a name="ln2011"> </a>
<a name="ln2012">    //check for dot disconnect closures</a>
<a name="ln2013">    vector&lt;ExternalBond&gt;::iterator bond;</a>
<a name="ln2014">    int upDown, bondOrder;</a>
<a name="ln2015">    for (bond = _extbond.begin(); bond != _extbond.end(); ++bond) {</a>
<a name="ln2016"> </a>
<a name="ln2017">      if (bond-&gt;digit == digit) {</a>
<a name="ln2018">        upDown = (_updown &gt; bond-&gt;updown) ? _updown : bond-&gt;updown;</a>
<a name="ln2019">        bondOrder = (_order &gt; bond-&gt;order) ? _order : bond-&gt;order;</a>
<a name="ln2020">        mol.AddBond(bond-&gt;prev, _prev, bondOrder);</a>
<a name="ln2021">        // store up/down</a>
<a name="ln2022">        if (upDown == BondUpChar || upDown == BondDownChar)</a>
<a name="ln2023">          _upDownMap[mol.GetBond(bond-&gt;prev, _prev)] = upDown;</a>
<a name="ln2024"> </a>
<a name="ln2025"> </a>
<a name="ln2026">        // after adding a bond to atom &quot;_prev&quot;</a>
<a name="ln2027">        // search to see if atom is bonded to a chiral atom</a>
<a name="ln2028">        InsertTetrahedralRef(mol, bond-&gt;prev - 1);</a>
<a name="ln2029">        InsertSquarePlanarRef(mol, bond-&gt;prev - 1);</a>
<a name="ln2030"> </a>
<a name="ln2031">        _extbond.erase(bond);</a>
<a name="ln2032">        _updown = ' ';</a>
<a name="ln2033">        _order = 0;</a>
<a name="ln2034">        return true;</a>
<a name="ln2035">      }</a>
<a name="ln2036">    }</a>
<a name="ln2037"> </a>
<a name="ln2038">    //since no closures save another ext bond</a>
<a name="ln2039">    ExternalBond extBond;</a>
<a name="ln2040">    extBond.digit  = digit;</a>
<a name="ln2041">    extBond.prev   = _prev;</a>
<a name="ln2042">    extBond.order  = _order;</a>
<a name="ln2043">    extBond.updown = _updown;</a>
<a name="ln2044"> </a>
<a name="ln2045">    _extbond.push_back(extBond);</a>
<a name="ln2046">    _order = 0;</a>
<a name="ln2047">    _updown = ' ';</a>
<a name="ln2048"> </a>
<a name="ln2049">    return(true);</a>
<a name="ln2050"> </a>
<a name="ln2051">  }</a>
<a name="ln2052"> </a>
<a name="ln2053">  bool OBSmilesParser::ParseRingBond(OBMol &amp;mol)</a>
<a name="ln2054">  {</a>
<a name="ln2055">    // The ring closure must be associated with a 'prev' atom</a>
<a name="ln2056">    OBAtom* prevatom = mol.GetAtom(_prev);</a>
<a name="ln2057">    if (!prevatom) {</a>
<a name="ln2058">      obErrorLog.ThrowError(__FUNCTION__,&quot;Number not parsed correctly as a ring bond&quot;, obWarning);</a>
<a name="ln2059">      return false;</a>
<a name="ln2060">    }</a>
<a name="ln2061"> </a>
<a name="ln2062">    // Parse the ring closure digit or digits</a>
<a name="ln2063">    int digit = 0;</a>
<a name="ln2064">    if (*_ptr == '%') {</a>
<a name="ln2065">      _ptr++;</a>
<a name="ln2066">      if (*_ptr == '(') { // %(NNN) extension to OpenSMILES</a>
<a name="ln2067">        _ptr++;</a>
<a name="ln2068">        const char* start = _ptr;</a>
<a name="ln2069">        while (isdigit(*_ptr)) {</a>
<a name="ln2070">          digit *= 10;</a>
<a name="ln2071">          digit += *_ptr - '0';</a>
<a name="ln2072">          _ptr++;</a>
<a name="ln2073">          if (_ptr - start &gt; 5) {</a>
<a name="ln2074">            obErrorLog.ThrowError(__FUNCTION__, &quot;Ring closure numbers with more than 5 digits are not supported&quot;, obWarning);</a>
<a name="ln2075">            return false;</a>
<a name="ln2076">          }</a>
<a name="ln2077">        }</a>
<a name="ln2078">        if (*_ptr != ')') {</a>
<a name="ln2079">          obErrorLog.ThrowError(__FUNCTION__, &quot;Matching close parenthesis not found for ring closure number&quot;, obWarning);</a>
<a name="ln2080">          return false;</a>
<a name="ln2081">        }</a>
<a name="ln2082">      }</a>
<a name="ln2083">      else { // % followed by two-digit ring closure</a>
<a name="ln2084">        if (!isdigit(*_ptr) || !isdigit(*(_ptr + 1))) {</a>
<a name="ln2085">          obErrorLog.ThrowError(__FUNCTION__, &quot;Two digits expected after %&quot;, obWarning);</a>
<a name="ln2086">          return false;</a>
<a name="ln2087">        }</a>
<a name="ln2088">        digit = (*_ptr - '0') * 10 + *(_ptr+1) - '0';</a>
<a name="ln2089">        _ptr++;</a>
<a name="ln2090">      }</a>
<a name="ln2091">    }</a>
<a name="ln2092">    else {</a>
<a name="ln2093">      digit = *_ptr - '0';</a>
<a name="ln2094">    }</a>
<a name="ln2095"> </a>
<a name="ln2096">    vector&lt;RingClosureBond&gt;::iterator bond;</a>
<a name="ln2097">    int upDown, bondOrder;</a>
<a name="ln2098">    for (bond = _rclose.begin(); bond != _rclose.end(); ++bond) {</a>
<a name="ln2099">      if (bond-&gt;digit == digit) {</a>
<a name="ln2100">        // Check for self-bonding, e.g. C11</a>
<a name="ln2101">        if (bond-&gt;prev == _prev) {</a>
<a name="ln2102">          obErrorLog.ThrowError(__FUNCTION__, &quot;Invalid SMILES: Ring closures imply atom bonded to itself.&quot;, obWarning);</a>
<a name="ln2103">          return false;</a>
<a name="ln2104">        }</a>
<a name="ln2105">        upDown = (_updown &gt; bond-&gt;updown) ? _updown : bond-&gt;updown;</a>
<a name="ln2106">        bondOrder = (_order &gt; bond-&gt;order) ? _order : bond-&gt;order;</a>
<a name="ln2107">        // Check if this ring closure bond may be aromatic and set order accordingly</a>
<a name="ln2108">        bool aromatic_bond = false;</a>
<a name="ln2109">        if (bondOrder == 0) {</a>
<a name="ln2110">          OBAtom *a1 = mol.GetAtom(bond-&gt;prev);</a>
<a name="ln2111">          OBAtom *a2 = mol.GetAtom(_prev);</a>
<a name="ln2112">          if (a1-&gt;IsAromatic() &amp;&amp; a2-&gt;IsAromatic())</a>
<a name="ln2113">            aromatic_bond = true;</a>
<a name="ln2114">        }</a>
<a name="ln2115">        mol.AddBond(bond-&gt;prev, _prev, bondOrder == 0 ? 1 : bondOrder, aromatic_bond ? OB_AROMATIC_BOND : 0, bond-&gt;numConnections);</a>
<a name="ln2116">        // store up/down</a>
<a name="ln2117">        if (upDown == BondUpChar || upDown == BondDownChar)</a>
<a name="ln2118">          _upDownMap[mol.GetBond(bond-&gt;prev, _prev)] = upDown;</a>
<a name="ln2119"> </a>
<a name="ln2120">        // For assigning cis/trans in the presence of bond closures, we need to</a>
<a name="ln2121">        // remember info on all bond closure bonds.</a>
<a name="ln2122">        StereoRingBond sb;</a>
<a name="ln2123">        sb.updown.push_back(_updown);</a>
<a name="ln2124">        sb.atoms.push_back(mol.GetAtom(_prev));</a>
<a name="ln2125">        sb.updown.push_back(bond-&gt;updown);</a>
<a name="ln2126">        sb.atoms.push_back(mol.GetAtom(bond-&gt;prev));</a>
<a name="ln2127">        _stereorbond[mol.GetBond(bond-&gt;prev, _prev)] = sb; // Store for later</a>
<a name="ln2128"> </a>
<a name="ln2129">        // after adding a bond to atom &quot;_prev&quot;</a>
<a name="ln2130">        // search to see if atom is bonded to a chiral atom</a>
<a name="ln2131">        // need to check both _prev and bond-&gt;prev as closure is direction independent</a>
<a name="ln2132">        InsertTetrahedralRef(mol, bond-&gt;prev - 1);</a>
<a name="ln2133">        InsertSquarePlanarRef(mol, bond-&gt;prev - 1);</a>
<a name="ln2134"> </a>
<a name="ln2135">        // FIXME: needed for squreplanar too??</a>
<a name="ln2136">        map&lt;OBAtom*, OBTetrahedralStereo::Config*&gt;::iterator ChiralSearch;</a>
<a name="ln2137">        ChiralSearch = _tetrahedralMap.find(mol.GetAtom(bond-&gt;prev));</a>
<a name="ln2138">        if (ChiralSearch != _tetrahedralMap.end() &amp;&amp; ChiralSearch-&gt;second != nullptr) {</a>
<a name="ln2139">          int insertpos = bond-&gt;numConnections - 1;</a>
<a name="ln2140">          switch(insertpos) {</a>
<a name="ln2141">          case -1:</a>
<a name="ln2142">            if (ChiralSearch-&gt;second-&gt;from != OBStereo::NoRef)</a>
<a name="ln2143">              obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Overwriting previous from reference id.&quot;, obWarning);</a>
<a name="ln2144">            (ChiralSearch-&gt;second)-&gt;from = mol.GetAtom(_prev)-&gt;GetId();</a>
<a name="ln2145">            break;</a>
<a name="ln2146">          case 0: case 1: case 2:</a>
<a name="ln2147">            if (ChiralSearch-&gt;second-&gt;refs[insertpos] != OBStereo::NoRef)</a>
<a name="ln2148">              obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Overwriting previously set reference id.&quot;, obWarning);</a>
<a name="ln2149">            (ChiralSearch-&gt;second)-&gt;refs[insertpos] = mol.GetAtom(_prev)-&gt;GetId();</a>
<a name="ln2150">            break;</a>
<a name="ln2151">          default:</a>
<a name="ln2152">            obErrorLog.ThrowError(__FUNCTION__, &quot;Warning: Tetrahedral stereo specified for atom with more than 4 connections.&quot;, obWarning);</a>
<a name="ln2153">            break;</a>
<a name="ln2154">          }</a>
<a name="ln2155">        }</a>
<a name="ln2156"> </a>
<a name="ln2157">        //CM ensure neither atoms in ring closure is a radical centre</a>
<a name="ln2158">        OBAtom* patom = mol.GetAtom(_prev);</a>
<a name="ln2159">        patom-&gt;SetSpinMultiplicity(0);</a>
<a name="ln2160">        patom = mol.GetAtom(bond-&gt;prev);</a>
<a name="ln2161">        patom-&gt;SetSpinMultiplicity(0);</a>
<a name="ln2162">        //CM end</a>
<a name="ln2163">        _rclose.erase(bond);</a>
<a name="ln2164">        _updown = ' ';</a>
<a name="ln2165">        _order = 0;</a>
<a name="ln2166">        return true;</a>
<a name="ln2167">      }</a>
<a name="ln2168">    }</a>
<a name="ln2169"> </a>
<a name="ln2170">    //since no closures save another rclose bond</a>
<a name="ln2171">    RingClosureBond ringClosure;</a>
<a name="ln2172">    ringClosure.digit  = digit;</a>
<a name="ln2173">    ringClosure.prev   = _prev;</a>
<a name="ln2174">    ringClosure.order  = _order;</a>
<a name="ln2175">    ringClosure.updown = _updown;</a>
<a name="ln2176"> </a>
<a name="ln2177">    OBAtom* atom = mol.GetAtom(_prev);</a>
<a name="ln2178">    ringClosure.numConnections = NumConnections(atom); //store position to insert closure bond</a>
<a name="ln2179">    _rclose.push_back(ringClosure);</a>
<a name="ln2180">    _order = 0;</a>
<a name="ln2181">    _updown = ' ';</a>
<a name="ln2182"> </a>
<a name="ln2183">    return(true);</a>
<a name="ln2184">  }</a>
<a name="ln2185"> </a>
<a name="ln2186">  // NumConnections finds the number of connections already made to</a>
<a name="ln2187">  // a particular atom. This is used to figure out the correct position</a>
<a name="ln2188">  // to insert an atom ID into atom4refs</a>
<a name="ln2189">  int OBSmilesParser::NumConnections(OBAtom *atom, bool isImplicitRef)</a>
<a name="ln2190">  {</a>
<a name="ln2191">    int val = atom-&gt;GetExplicitDegree();</a>
<a name="ln2192">    // The implicit H is not included in &quot;val&quot; so we need to adjust by 1</a>
<a name="ln2193">    if (isImplicitRef)</a>
<a name="ln2194">      return val+1;</a>
<a name="ln2195"> </a>
<a name="ln2196">    int idx = atom-&gt;GetIdx();</a>
<a name="ln2197">    // Need to adjust for any implicit H (e.g. [C@@H]) but only for atoms after the H.</a>
<a name="ln2198">    // The following line controls for this. It uses the fact the _hcount is only set</a>
<a name="ln2199">    // after this function is called to handle inserting the stereo ref for the implicit H.</a>
<a name="ln2200">    if (idx-1 &lt; _hcount.size() &amp;&amp; _hcount[idx-1] &gt; 0)</a>
<a name="ln2201">      val += _hcount[idx-1];</a>
<a name="ln2202">    vector&lt;RingClosureBond&gt;::iterator bond;</a>
<a name="ln2203">    //correct for multiple closure bonds to a single atom</a>
<a name="ln2204">    for (bond = _rclose.begin(); bond != _rclose.end(); ++bond)</a>
<a name="ln2205">      if (bond-&gt;prev == idx)</a>
<a name="ln2206">        val++;</a>
<a name="ln2207"> </a>
<a name="ln2208">    return val;</a>
<a name="ln2209">  }</a>
<a name="ln2210"> </a>
<a name="ln2211"> </a>
<a name="ln2212">  /*----------------------------------------------------------------------</a>
<a name="ln2213">   * CLASS: OBBondClosureInfo: For recording bond-closure digits as</a>
<a name="ln2214">   * work progresses on canonical SMILES.</a>
<a name="ln2215">   ----------------------------------------------------------------------*/</a>
<a name="ln2216"> </a>
<a name="ln2217">  class OBBondClosureInfo</a>
<a name="ln2218">  {</a>
<a name="ln2219">  public:</a>
<a name="ln2220">    OBAtom *toatom;       // second atom in SMILES order</a>
<a name="ln2221">    OBAtom *fromatom;     // first atom in SMILES order</a>
<a name="ln2222">    OBBond *bond;</a>
<a name="ln2223">    int    ringdigit;</a>
<a name="ln2224">    int    is_open;       // TRUE if SMILES processing hasn't reached 'toatom' yet</a>
<a name="ln2225"> </a>
<a name="ln2226">    OBBondClosureInfo(OBAtom *, OBAtom*, OBBond*, int, bool);</a>
<a name="ln2227">    ~OBBondClosureInfo();</a>
<a name="ln2228">  };</a>
<a name="ln2229"> </a>
<a name="ln2230">  OBBondClosureInfo::OBBondClosureInfo(OBAtom *a1, OBAtom *a2, OBBond *b, int rd, bool open)</a>
<a name="ln2231">  {</a>
<a name="ln2232">    toatom    = a1;</a>
<a name="ln2233">    fromatom  = a2;</a>
<a name="ln2234">    bond      = b;</a>
<a name="ln2235">    ringdigit = rd;</a>
<a name="ln2236">    is_open   = open;</a>
<a name="ln2237">  }</a>
<a name="ln2238"> </a>
<a name="ln2239">  OBBondClosureInfo::~OBBondClosureInfo()</a>
<a name="ln2240">  {</a>
<a name="ln2241">  }</a>
<a name="ln2242"> </a>
<a name="ln2243"> </a>
<a name="ln2244">  /*----------------------------------------------------------------------</a>
<a name="ln2245">   * CLASS: OBCanSmiNode: A Tree structure, each node of which is an atom in</a>
<a name="ln2246">   * the tree being built to write out the SMILES.</a>
<a name="ln2247">   ----------------------------------------------------------------------*/</a>
<a name="ln2248"> </a>
<a name="ln2249">  class OBCanSmiNode</a>
<a name="ln2250">  {</a>
<a name="ln2251">    OBAtom *_atom,*_parent;</a>
<a name="ln2252">    std::vector&lt;OBCanSmiNode*&gt; _child_nodes;</a>
<a name="ln2253">    std::vector&lt;OBBond*&gt; _child_bonds;</a>
<a name="ln2254"> </a>
<a name="ln2255">  public:</a>
<a name="ln2256">    OBCanSmiNode(OBAtom *atom);</a>
<a name="ln2257">    ~OBCanSmiNode();</a>
<a name="ln2258"> </a>
<a name="ln2259">    int Size()</a>
<a name="ln2260">    {</a>
<a name="ln2261">      return(_child_nodes.empty() ? 0 : _child_nodes.size());</a>
<a name="ln2262">    }</a>
<a name="ln2263"> </a>
<a name="ln2264">    void SetParent(OBAtom *a)</a>
<a name="ln2265">    {</a>
<a name="ln2266">      _parent = a;</a>
<a name="ln2267">    }</a>
<a name="ln2268"> </a>
<a name="ln2269">    void AddChildNode(OBCanSmiNode*,OBBond*);</a>
<a name="ln2270"> </a>
<a name="ln2271">    OBAtom *GetAtom()</a>
<a name="ln2272">    {</a>
<a name="ln2273">      return(_atom);</a>
<a name="ln2274">    }</a>
<a name="ln2275"> </a>
<a name="ln2276">    OBAtom *GetParent()</a>
<a name="ln2277">    {</a>
<a name="ln2278">      return(_parent);</a>
<a name="ln2279">    }</a>
<a name="ln2280"> </a>
<a name="ln2281">    OBAtom *GetChildAtom(int i)</a>
<a name="ln2282">    {</a>
<a name="ln2283">      return(_child_nodes[i]-&gt;GetAtom());</a>
<a name="ln2284">    }</a>
<a name="ln2285"> </a>
<a name="ln2286">    OBBond *GetChildBond(int i)</a>
<a name="ln2287">    {</a>
<a name="ln2288">      return(_child_bonds[i]);</a>
<a name="ln2289">    }</a>
<a name="ln2290"> </a>
<a name="ln2291">    OBCanSmiNode *GetChildNode(int i)</a>
<a name="ln2292">    {</a>
<a name="ln2293">      return(_child_nodes[i]);</a>
<a name="ln2294">    }</a>
<a name="ln2295">  };</a>
<a name="ln2296"> </a>
<a name="ln2297"> </a>
<a name="ln2298">  OBCanSmiNode::OBCanSmiNode(OBAtom *atom)</a>
<a name="ln2299">  {</a>
<a name="ln2300">    _atom = atom;</a>
<a name="ln2301">    _parent = nullptr;</a>
<a name="ln2302">    _child_nodes.clear();</a>
<a name="ln2303">    _child_bonds.clear();</a>
<a name="ln2304">  }</a>
<a name="ln2305"> </a>
<a name="ln2306">  void OBCanSmiNode::AddChildNode(OBCanSmiNode *node,OBBond *bond)</a>
<a name="ln2307">  {</a>
<a name="ln2308">    _child_nodes.push_back(node);</a>
<a name="ln2309">    _child_bonds.push_back(bond);</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  OBCanSmiNode::~OBCanSmiNode()</a>
<a name="ln2313">  {</a>
<a name="ln2314">    vector&lt;OBCanSmiNode*&gt;::iterator i;</a>
<a name="ln2315">    for (i = _child_nodes.begin();i != _child_nodes.end();++i)</a>
<a name="ln2316">      delete (*i);</a>
<a name="ln2317">  }</a>
<a name="ln2318"> </a>
<a name="ln2319">  struct OutOptions</a>
<a name="ln2320">  {</a>
<a name="ln2321">    bool isomeric;</a>
<a name="ln2322">    bool kekulesmi;</a>
<a name="ln2323">    bool showatomclass;</a>
<a name="ln2324">    bool showexplicitH;</a>
<a name="ln2325">    bool smarts;</a>
<a name="ln2326">    const char* ordering; // This is a pointer to the string in the original map</a>
<a name="ln2327">    OutOptions(bool _isomeric, bool _kekulesmi, bool _showatomclass, bool _showexplicitH, bool _smarts,</a>
<a name="ln2328">               const char* _ordering):</a>
<a name="ln2329">      isomeric(_isomeric), kekulesmi(_kekulesmi), showatomclass(_showatomclass), showexplicitH(_showexplicitH),</a>
<a name="ln2330">      smarts(_smarts),</a>
<a name="ln2331">      ordering(_ordering)</a>
<a name="ln2332">      {}</a>
<a name="ln2333">  };</a>
<a name="ln2334"> </a>
<a name="ln2335">  /*----------------------------------------------------------------------</a>
<a name="ln2336">   * CLASS OBMol2Cansmi - Declarations</a>
<a name="ln2337">   ----------------------------------------------------------------------*/</a>
<a name="ln2338"> </a>
<a name="ln2339">  class OBMol2Cansmi</a>
<a name="ln2340">  {</a>
<a name="ln2341">    std::vector&lt;int&gt; _atmorder;</a>
<a name="ln2342">    OBBitVec _uatoms,_ubonds;</a>
<a name="ln2343">    std::vector&lt;OBBondClosureInfo&gt; _vopen;</a>
<a name="ln2344">    unsigned int _bcdigit; // Unused unless option &quot;R&quot; is specified</a>
<a name="ln2345">    std::vector&lt;OBCisTransStereo&gt; _cistrans, _unvisited_cistrans;</a>
<a name="ln2346">    std::map&lt;OBBond *, bool&gt; _isup;</a>
<a name="ln2347"> </a>
<a name="ln2348">    bool          _canonicalOutput; // regular or canonical SMILES</a>
<a name="ln2349"> </a>
<a name="ln2350">    OBMol* _pmol;</a>
<a name="ln2351">    OBStereoFacade *_stereoFacade;</a>
<a name="ln2352">    OBConversion* _pconv;</a>
<a name="ln2353"> </a>
<a name="ln2354">    OBAtom* _endatom;</a>
<a name="ln2355">    OBAtom* _startatom;</a>
<a name="ln2356"> </a>
<a name="ln2357">    OutOptions &amp;options;</a>
<a name="ln2358"> </a>
<a name="ln2359">  public:</a>
<a name="ln2360">    OBMol2Cansmi(OutOptions &amp;_options): options(_options)</a>
<a name="ln2361">    {</a>
<a name="ln2362">    }</a>
<a name="ln2363">    ~OBMol2Cansmi()</a>
<a name="ln2364">    {</a>
<a name="ln2365">      delete _stereoFacade;</a>
<a name="ln2366">    }</a>
<a name="ln2367"> </a>
<a name="ln2368">    void         Init(OBMol* pmol, bool canonicalOutput = true, OBConversion* pconv=nullptr);</a>
<a name="ln2369"> </a>
<a name="ln2370">    void         CreateCisTrans(OBMol&amp;);</a>
<a name="ln2371">    char         GetCisTransBondSymbol(OBBond *, OBCanSmiNode *);</a>
<a name="ln2372">    bool         AtomIsChiral(OBAtom *atom);</a>
<a name="ln2373">    bool         BuildCanonTree(OBMol &amp;mol, OBBitVec &amp;frag_atoms,</a>
<a name="ln2374">                                vector&lt;unsigned int&gt; &amp;canonical_order,</a>
<a name="ln2375">                                OBCanSmiNode *node);</a>
<a name="ln2376">    void         CreateFragCansmiString(OBMol&amp;, OBBitVec&amp;, std::string&amp;);</a>
<a name="ln2377">    const char * GetTetrahedralStereo(OBCanSmiNode*,</a>
<a name="ln2378">                                      vector&lt;OBAtom*&gt;&amp;chiral_neighbors,</a>
<a name="ln2379">                                      vector&lt;unsigned int&gt; &amp;symmetry_classes);</a>
<a name="ln2380">    const char*  GetSquarePlanarStereo(OBCanSmiNode*,</a>
<a name="ln2381">                                       vector&lt;OBAtom*&gt;&amp;chiral_neighbors,</a>
<a name="ln2382">                                       vector&lt;unsigned int&gt; &amp;symmetry_classes);</a>
<a name="ln2383">    bool         GetSmilesElement(OBCanSmiNode*,</a>
<a name="ln2384">                                  vector&lt;OBAtom*&gt;&amp;chiral_neighbors,</a>
<a name="ln2385">                                  vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln2386">                                  std::string&amp;);</a>
<a name="ln2387">    int          GetSmilesValence(OBAtom *atom);</a>
<a name="ln2388">    int          GetUnusedIndex();</a>
<a name="ln2389">    vector&lt;OBBondClosureInfo&gt;</a>
<a name="ln2390">    GetCanonClosureDigits(OBAtom *atom,</a>
<a name="ln2391">                          OBBitVec &amp;frag_atoms,</a>
<a name="ln2392">                          vector&lt;unsigned int&gt; &amp;canonical_order);</a>
<a name="ln2393">    bool         IsSuppressedHydrogen(OBAtom *atom);</a>
<a name="ln2394">    void         ToCansmilesString(OBCanSmiNode *node,</a>
<a name="ln2395">                                   std::string &amp;buffer,</a>
<a name="ln2396">                                   OBBitVec &amp;frag_atoms,</a>
<a name="ln2397">                                   vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln2398">                                   vector&lt;unsigned int&gt; &amp;canonical_order);</a>
<a name="ln2399">    bool         HasStereoDblBond(OBBond *, OBAtom *atom);</a>
<a name="ln2400">    void MyFindChildren(OBMol &amp;mol, vector&lt;OBAtom*&gt; &amp;children, OBBitVec &amp;seen, OBAtom *end);</a>
<a name="ln2401">    void GetOutputOrder(std::string &amp;outorder);</a>
<a name="ln2402">    bool         ParseInChI(OBMol &amp;mol, vector&lt;int&gt; &amp;atom_order);</a>
<a name="ln2403">  };</a>
<a name="ln2404"> </a>
<a name="ln2405"> </a>
<a name="ln2406">  /*----------------------------------------------------------------------</a>
<a name="ln2407">   * CLASS OBMol2Cansmi - implementation</a>
<a name="ln2408">   ----------------------------------------------------------------------*/</a>
<a name="ln2409"> </a>
<a name="ln2410">  /***************************************************************************</a>
<a name="ln2411">   * FUNCTION: Init</a>
<a name="ln2412">   *</a>
<a name="ln2413">   * DESCRIPTION:</a>
<a name="ln2414">   *       Initializes the OBMol2Cansmi writer object.</a>
<a name="ln2415">   ***************************************************************************/</a>
<a name="ln2416"> </a>
<a name="ln2417">  void OBMol2Cansmi::Init(OBMol* pmol, bool canonical, OBConversion* pconv)</a>
<a name="ln2418">  {</a>
<a name="ln2419">    _atmorder.clear();</a>
<a name="ln2420">    _atmorder.reserve(pmol-&gt;NumAtoms());</a>
<a name="ln2421">    _uatoms.Clear();</a>
<a name="ln2422">    _ubonds.Clear();</a>
<a name="ln2423">    _vopen.clear();</a>
<a name="ln2424"> </a>
<a name="ln2425">    _pmol = pmol;</a>
<a name="ln2426">    _stereoFacade = new OBStereoFacade(_pmol); // needs to be destroyed in dtor</a>
<a name="ln2427">    _pconv = pconv;</a>
<a name="ln2428">    _canonicalOutput = canonical;</a>
<a name="ln2429"> </a>
<a name="ln2430">    _endatom = nullptr;</a>
<a name="ln2431">    _startatom = nullptr;</a>
<a name="ln2432">  }</a>
<a name="ln2433"> </a>
<a name="ln2434"> </a>
<a name="ln2435">  /***************************************************************************</a>
<a name="ln2436">   * FUNCTION: GetUnusedIndex</a>
<a name="ln2437">   *</a>
<a name="ln2438">   * DESCRIPTION:</a>
<a name="ln2439">   *       Returns the next available bond-closure index for a SMILES.</a>
<a name="ln2440">   *</a>
<a name="ln2441">   *       You could just do this sequentially, not reusing bond-closure</a>
<a name="ln2442">   *       digits, thus (chosen by Option(&quot;R&quot;)):</a>
<a name="ln2443">   *</a>
<a name="ln2444">   *               c1cc2ccccc2cc1          napthalene</a>
<a name="ln2445">   *               c1ccccc1c2ccccc2        biphenyl</a>
<a name="ln2446">   *</a>
<a name="ln2447">   *       But molecules with more than ten rings, this requires the use of</a>
<a name="ln2448">   *       two-digit ring closures (like c1ccccc1C...c%11ccccc%11).  To help</a>
<a name="ln2449">   *       avoid digit reuse, this finds the lowest digit that's not currently</a>
<a name="ln2450">   *       &quot;open&quot;, thus</a>
<a name="ln2451">   *</a>
<a name="ln2452">   *               c1cc2ccccc2cc1          napthalene (same)</a>
<a name="ln2453">   *               c1ccccc1c1ccccc1        biphenyl (reuses &quot;1&quot;)</a>
<a name="ln2454">   *</a>
<a name="ln2455">   ***************************************************************************/</a>
<a name="ln2456"> </a>
<a name="ln2457"> </a>
<a name="ln2458">  int OBMol2Cansmi::GetUnusedIndex()</a>
<a name="ln2459">  {</a>
<a name="ln2460">    if (_pconv-&gt;IsOption(&quot;R&quot;)) {</a>
<a name="ln2461">      // Keep incrementing the bond closure digits (for each connected component)</a>
<a name="ln2462">      _bcdigit++;</a>
<a name="ln2463">      return _bcdigit;</a>
<a name="ln2464">    }</a>
<a name="ln2465"> </a>
<a name="ln2466">    int idx=1;</a>
<a name="ln2467">    vector&lt;OBBondClosureInfo&gt;::iterator j;</a>
<a name="ln2468">    for (j = _vopen.begin();j != _vopen.end();)</a>
<a name="ln2469">      if (j-&gt;ringdigit == idx)</a>
<a name="ln2470">        {</a>
<a name="ln2471">          idx++; //increment idx and start over if digit is already used</a>
<a name="ln2472">          j = _vopen.begin();</a>
<a name="ln2473">        }</a>
<a name="ln2474">      else ++j;</a>
<a name="ln2475"> </a>
<a name="ln2476">    return(idx);</a>
<a name="ln2477">  }</a>
<a name="ln2478"> </a>
<a name="ln2479">  void OBMol2Cansmi::CreateCisTrans(OBMol &amp;mol)</a>
<a name="ln2480">  {</a>
<a name="ln2481">    std::vector&lt;OBGenericData*&gt; vdata = mol.GetAllData(OBGenericDataType::StereoData);</a>
<a name="ln2482">    for (std::vector&lt;OBGenericData*&gt;::iterator data = vdata.begin(); data != vdata.end(); ++data) {</a>
<a name="ln2483">      if (((OBStereoBase*)*data)-&gt;GetType() != OBStereo::CisTrans)</a>
<a name="ln2484">        continue;</a>
<a name="ln2485">      OBCisTransStereo *ct = dynamic_cast&lt;OBCisTransStereo*&gt;(*data);</a>
<a name="ln2486">      if (ct &amp;&amp; ct-&gt;GetConfig().specified) {</a>
<a name="ln2487">        OBCisTransStereo::Config config = ct-&gt;GetConfig();</a>
<a name="ln2488">        OBBond* dbl_bond = mol.GetBond(mol.GetAtomById(config.begin), mol.GetAtomById(config.end));</a>
<a name="ln2489">        if (!dbl_bond)</a>
<a name="ln2490">          continue;</a>
<a name="ln2491">        // Do not output cis/trans bond symbols for double bonds in rings of size IMPLICIT_CIS_RING_SIZE or less</a>
<a name="ln2492">        unsigned int boundedringsize = OBBondGetSmallestRingSize(dbl_bond, IMPLICIT_CIS_RING_SIZE);</a>
<a name="ln2493">        if (boundedringsize == 0) // either not in ring at all, or not in small ring</a>
<a name="ln2494">          _cistrans.push_back(*ct);</a>
<a name="ln2495">      }</a>
<a name="ln2496">    }</a>
<a name="ln2497"> </a>
<a name="ln2498">    _unvisited_cistrans = _cistrans; // Make a copy of _cistrans</a>
<a name="ln2499">  }</a>
<a name="ln2500"> </a>
<a name="ln2501">  bool OBMol2Cansmi::HasStereoDblBond(OBBond *bond, OBAtom *atom)</a>
<a name="ln2502">  {</a>
<a name="ln2503">    // This is a helper function for determining whether to</a>
<a name="ln2504">    // consider writing a cis/trans bond symbol for bond closures.</a>
<a name="ln2505">    // Returns TRUE only if the atom is connected to the cis/trans</a>
<a name="ln2506">    // double bond. To handle the case of conjugated bonds, one must</a>
<a name="ln2507">    // remember that the ring opening preceded the closure, so if the</a>
<a name="ln2508">    // ring opening bond was on a stereocenter, it got the symbol already.</a>
<a name="ln2509"> </a>
<a name="ln2510">    if (!bond || !atom)</a>
<a name="ln2511">      return false;</a>
<a name="ln2512"> </a>
<a name="ln2513">    std::vector&lt;OBCisTransStereo&gt;::iterator ChiralSearch;</a>
<a name="ln2514">    OBAtom *nbr_atom = bond-&gt;GetNbrAtom(atom);</a>
<a name="ln2515"> </a>
<a name="ln2516">    bool stereo_dbl = false;</a>
<a name="ln2517">    if (atom-&gt;HasDoubleBond()) {</a>
<a name="ln2518">      stereo_dbl = true;</a>
<a name="ln2519">      if (nbr_atom-&gt;HasDoubleBond())</a>
<a name="ln2520">        // Check whether the nbr_atom is a begin or end in any CisTransStereo. If so,</a>
<a name="ln2521">        // then the ring opening already had the symbol.</a>
<a name="ln2522">        for (ChiralSearch = _cistrans.begin(); ChiralSearch != _cistrans.end(); ++ChiralSearch) {</a>
<a name="ln2523">          OBCisTransStereo::Config cfg = ChiralSearch-&gt;GetConfig();</a>
<a name="ln2524">          if (nbr_atom-&gt;GetId() == cfg.begin || nbr_atom-&gt;GetId() == cfg.end) {</a>
<a name="ln2525">            // I don't think I need to check whether it has a bond with atom</a>
<a name="ln2526">            stereo_dbl = false;</a>
<a name="ln2527">            break;</a>
<a name="ln2528">          }</a>
<a name="ln2529">        }</a>
<a name="ln2530">    }</a>
<a name="ln2531">    return stereo_dbl;</a>
<a name="ln2532">  }</a>
<a name="ln2533"> </a>
<a name="ln2534">  char OBMol2Cansmi::GetCisTransBondSymbol(OBBond *bond, OBCanSmiNode *node)</a>
<a name="ln2535">  {</a>
<a name="ln2536">    // Given a cis/trans bond and the node in the SMILES tree, figures out</a>
<a name="ln2537">    // whether to write a '/' or '\' symbol.</a>
<a name="ln2538">    // See the comments smilesformat.cpp: FixCisTransBonds().</a>
<a name="ln2539">    //</a>
<a name="ln2540">    // The OBCanSmiNode is the most-recently-written atom in the SMILES string</a>
<a name="ln2541">    // we're creating.  If it is the double-bonded atom, then the substituent</a>
<a name="ln2542">    // follows, so that &quot;up&quot; means '/' and &quot;down&quot; means '\'.  If the OBCanSmiNode</a>
<a name="ln2543">    // atom is the single-bonded atom then the double-bonded atom comes next,</a>
<a name="ln2544">    // in which case &quot;up&quot; means '\' and &quot;down&quot; means '/'.</a>
<a name="ln2545">    //</a>
<a name="ln2546">    // Note that the story is not so simple for conjugated systems where</a>
<a name="ln2547">    // we need to take into account what symbol was already used.</a>
<a name="ln2548"> </a>
<a name="ln2549">    if (!bond /*|| (!bond-&gt;IsUp() &amp;&amp; !bond-&gt;IsDown())*/)</a>
<a name="ln2550">      return '\0';</a>
<a name="ln2551">    OBAtom *atom = node-&gt;GetAtom();</a>
<a name="ln2552">    OBAtom *nbr_atom = bond-&gt;GetNbrAtom(atom);</a>
<a name="ln2553">    OBMol *mol = atom-&gt;GetParent();</a>
<a name="ln2554"> </a>
<a name="ln2555">    // If this bond is in two different obcistransstereos (e.g. a conjugated system)</a>
<a name="ln2556">    // choose the one where the dbl bond atom is *atom (i.e. the one which comes first)</a>
<a name="ln2557">    std::vector&lt;OBCisTransStereo&gt;::iterator ChiralSearch;</a>
<a name="ln2558">    std::vector&lt;unsigned long&gt;::iterator lookup;</a>
<a name="ln2559"> </a>
<a name="ln2560">    bool dbl_bond_first = false;</a>
<a name="ln2561">    if (atom-&gt;HasDoubleBond())</a>
<a name="ln2562">    {</a>
<a name="ln2563">      if (nbr_atom-&gt;HasDoubleBond())</a>
<a name="ln2564">        // Check whether the atom is a center in any CisTransStereo. If so,#</a>
<a name="ln2565">        // then this CisTransStereo takes precedence over any other</a>
<a name="ln2566">        for (ChiralSearch = _cistrans.begin(); ChiralSearch != _cistrans.end(); ++ChiralSearch)</a>
<a name="ln2567">        {</a>
<a name="ln2568">          OBCisTransStereo::Config cfg = ChiralSearch-&gt;GetConfig();</a>
<a name="ln2569">          if (atom-&gt;GetId() == cfg.begin || atom-&gt;GetId() == cfg.end) {</a>
<a name="ln2570">            // I don't think I need to check whether it has a bond with nbr_atom</a>
<a name="ln2571">            dbl_bond_first = true;</a>
<a name="ln2572">            break;</a>
<a name="ln2573">          }</a>
<a name="ln2574">        }</a>
<a name="ln2575">      else</a>
<a name="ln2576">        dbl_bond_first = true;</a>
<a name="ln2577">    }</a>
<a name="ln2578"> </a>
<a name="ln2579">    // Has the symbol for this bond already been set?</a>
<a name="ln2580">    if (_isup.find(bond) == _isup.end()) // No it hasn't</a>
<a name="ln2581">    {</a>
<a name="ln2582">      unsigned int endatom, centeratom;</a>
<a name="ln2583">      if (dbl_bond_first) {</a>
<a name="ln2584">        if (atom-&gt;IsAromatic())</a>
<a name="ln2585">          FOR_BONDS_OF_ATOM (bond, atom)</a>
<a name="ln2586">            if (bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder()==2)</a>
<a name="ln2587">              return 0;</a>
<a name="ln2588">        endatom = nbr_atom-&gt;GetId();</a>
<a name="ln2589">        centeratom = atom-&gt;GetId();</a>
<a name="ln2590">      }</a>
<a name="ln2591">      else {</a>
<a name="ln2592">        if (nbr_atom-&gt;IsAromatic())</a>
<a name="ln2593">          FOR_BONDS_OF_ATOM (bond, nbr_atom)</a>
<a name="ln2594">            if (bond-&gt;IsAromatic() &amp;&amp; bond-&gt;GetBondOrder() == 2)</a>
<a name="ln2595">              return 0;</a>
<a name="ln2596">        endatom = atom-&gt;GetId();</a>
<a name="ln2597">        centeratom = nbr_atom-&gt;GetId();</a>
<a name="ln2598">      }</a>
<a name="ln2599"> </a>
<a name="ln2600">      for (ChiralSearch = _unvisited_cistrans.begin(); ChiralSearch != _unvisited_cistrans.end(); ++ChiralSearch)</a>
<a name="ln2601">      {</a>
<a name="ln2602">        OBCisTransStereo::Config cfg = ChiralSearch-&gt;GetConfig(OBStereo::ShapeU);</a>
<a name="ln2603">        lookup = std::find(cfg.refs.begin(), cfg.refs.end(), endatom);</a>
<a name="ln2604">        if (lookup != cfg.refs.end() &amp;&amp; (cfg.begin == centeratom || cfg.end == centeratom))</a>
<a name="ln2605">        { // Atoms endatom and centeratom are in this OBCisTransStereo</a>
<a name="ln2606"> </a>
<a name="ln2607">          std::vector&lt;OBBond *&gt; refbonds(4, nullptr);</a>
<a name="ln2608">          refbonds[0] = mol-&gt;GetBond(mol-&gt;GetAtomById(cfg.refs[0]), mol-&gt;GetAtomById(cfg.begin));</a>
<a name="ln2609"> </a>
<a name="ln2610">          if (cfg.refs[1] != OBStereo::ImplicitRef) // Could be a hydrogen</a>
<a name="ln2611">            refbonds[1] = mol-&gt;GetBond(mol-&gt;GetAtomById(cfg.refs[1]), mol-&gt;GetAtomById(cfg.begin));</a>
<a name="ln2612"> </a>
<a name="ln2613">          if (cfg.refs[2] != OBStereo::ImplicitRef) // Could be a hydrogen</a>
<a name="ln2614">            refbonds[2] = mol-&gt;GetBond(mol-&gt;GetAtomById(cfg.refs[2]), mol-&gt;GetAtomById(cfg.end));</a>
<a name="ln2615"> </a>
<a name="ln2616">          if (cfg.refs[3] != OBStereo::ImplicitRef) // Could be a hydrogen</a>
<a name="ln2617">            refbonds[3] = mol-&gt;GetBond(mol-&gt;GetAtomById(cfg.refs[3]), mol-&gt;GetAtomById(cfg.end));</a>
<a name="ln2618"> </a>
<a name="ln2619">          // What symbol would the four refs use if before the dbl bond?</a>
<a name="ln2620">          bool config[4] = {true, false, false, true};</a>
<a name="ln2621">          bool use_same_config = true;</a>
<a name="ln2622">          // (The actual config used will be config ^ use_same_config)</a>
<a name="ln2623"> </a>
<a name="ln2624">          // Make sure that the symbol for this bond is true. This ensures</a>
<a name="ln2625">          // a canonical string, so that it's always C/C=C/C and not C\C=C\C.</a>
<a name="ln2626">          for(int i=0;i&lt;4;i++)</a>
<a name="ln2627">            if (refbonds[i] == bond)</a>
<a name="ln2628">              if (!config[i])</a>
<a name="ln2629">              {</a>
<a name="ln2630">                  use_same_config = false;</a>
<a name="ln2631">                  break;</a>
<a name="ln2632">              }</a>
<a name="ln2633">          // If any of the bonds have been previously set, now set them all</a>
<a name="ln2634">          // in the opposite sense</a>
<a name="ln2635">          for(int i=0;i&lt;4;i++)</a>
<a name="ln2636">            if (_isup.find(refbonds[i]) != _isup.end()) // We have already set this one (conjugated bond)</a>
<a name="ln2637">              if (_isup[refbonds[i]] == (config[i] ^ use_same_config))</a>
<a name="ln2638">              {</a>
<a name="ln2639">                use_same_config = !use_same_config;</a>
<a name="ln2640">                break;</a>
<a name="ln2641">              }</a>
<a name="ln2642">          // Set the configuration</a>
<a name="ln2643">          for(int i=0;i&lt;4;i++)</a>
<a name="ln2644">            if (refbonds[i] != nullptr)</a>
<a name="ln2645">              _isup[refbonds[i]] = config[i] ^ use_same_config;</a>
<a name="ln2646">          _unvisited_cistrans.erase(ChiralSearch);</a>
<a name="ln2647">          break; // break out of the ChiralSearch</a>
<a name="ln2648">        }</a>
<a name="ln2649">      }</a>
<a name="ln2650">    }</a>
<a name="ln2651"> </a>
<a name="ln2652">     // If ChiralSearch didn't find the bond, we can't set this symbol</a>
<a name="ln2653">    if (_isup.find(bond) == _isup.end()) return '\0';</a>
<a name="ln2654"> </a>
<a name="ln2655">    if (dbl_bond_first) { // double-bonded atom is first in the SMILES</a>
<a name="ln2656">      if (_isup[bond])</a>
<a name="ln2657">        return '/';</a>
<a name="ln2658">      else</a>
<a name="ln2659">        return '\\';</a>
<a name="ln2660">    }</a>
<a name="ln2661">    else { // double-bonded atom is second in the SMILES</a>
<a name="ln2662">      if (_isup[bond])</a>
<a name="ln2663">        return '\\';</a>
<a name="ln2664">      else</a>
<a name="ln2665">        return '/';</a>
<a name="ln2666">    }</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669"> </a>
<a name="ln2670">  /***************************************************************************</a>
<a name="ln2671">   * FUNCTION: GetSmilesElement</a>
<a name="ln2672">   *</a>
<a name="ln2673">   * DESCRIPTION:</a>
<a name="ln2674">   *       Writes the symbol for an atom, e.g. &quot;C&quot; or &quot;[NH2]&quot; or &quot;[C@@H]&quot;.</a>
<a name="ln2675">   *</a>
<a name="ln2676">   * RETURNS: true (always)</a>
<a name="ln2677">   ***************************************************************************/</a>
<a name="ln2678"> </a>
<a name="ln2679"> </a>
<a name="ln2680">  bool OBMol2Cansmi::GetSmilesElement(OBCanSmiNode *node,</a>
<a name="ln2681">                                      vector&lt;OBAtom*&gt;&amp;chiral_neighbors,</a>
<a name="ln2682">                                      vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln2683">                                      std::string &amp;buffer)</a>
<a name="ln2684">  {</a>
<a name="ln2685">    char symbol[10];</a>
<a name="ln2686">    symbol[0] = '\0'; // make sure to initialize for all paths below</a>
<a name="ln2687"> </a>
<a name="ln2688">    bool bracketElement = false;</a>
<a name="ln2689">    bool normalValence = true;</a>
<a name="ln2690">    bool writeExplicitHydrogen = false;</a>
<a name="ln2691"> </a>
<a name="ln2692">    OBAtom *atom = node-&gt;GetAtom();</a>
<a name="ln2693">    int element = atom-&gt;GetAtomicNum();</a>
<a name="ln2694"> </a>
<a name="ln2695">    // Handle SMILES Valence model, and explicit and implicit hydrogens</a>
<a name="ln2696">    if (IsOutsideOrganicSubset(element))</a>
<a name="ln2697">      bracketElement = true;</a>
<a name="ln2698"> </a>
<a name="ln2699">    unsigned int numExplicitHsToSuppress = 0;</a>
<a name="ln2700">    // Don't suppress any explicit Hs attached if the atom is an H itself (e.g. [H][H]) or -xh was specified</a>
<a name="ln2701">    if (atom-&gt;GetAtomicNum() != OBElements::Hydrogen &amp;&amp; !options.showexplicitH) {</a>
<a name="ln2702">      FOR_NBORS_OF_ATOM(nbr, atom) {</a>
<a name="ln2703">        if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; (!options.isomeric || nbr-&gt;GetIsotope() == 0) &amp;&amp; nbr-&gt;GetExplicitDegree() == 1 &amp;&amp;</a>
<a name="ln2704">          nbr-&gt;GetFormalCharge() == 0 &amp;&amp; (!options.showatomclass || !nbr-&gt;GetData(&quot;Atom Class&quot;)))</a>
<a name="ln2705">          numExplicitHsToSuppress++;</a>
<a name="ln2706">      }</a>
<a name="ln2707">    }</a>
<a name="ln2708"> </a>
<a name="ln2709">    unsigned int numImplicitHs = 0;</a>
<a name="ln2710">    if (options.smarts) {</a>
<a name="ln2711">      if (numExplicitHsToSuppress &gt; 0) {</a>
<a name="ln2712">        bracketElement = true;</a>
<a name="ln2713">        numImplicitHs = numExplicitHsToSuppress;</a>
<a name="ln2714">      }</a>
<a name="ln2715">    }</a>
<a name="ln2716">    else {</a>
<a name="ln2717">      numImplicitHs = atom-&gt;GetImplicitHCount() + numExplicitHsToSuppress;</a>
<a name="ln2718">      if (!bracketElement) {</a>
<a name="ln2719">        if (element == 0) { // asterisk is always hypervalent but we don't bracket it unless has Hs</a>
<a name="ln2720">          if (numImplicitHs &gt; 0)</a>
<a name="ln2721">            bracketElement = true;</a>
<a name="ln2722">        }</a>
<a name="ln2723">        else {</a>
<a name="ln2724">          int bosum = atom-&gt;GetExplicitValence() - numExplicitHsToSuppress;</a>
<a name="ln2725">          unsigned int implicitValence = SmilesValence(element, bosum, false);</a>
<a name="ln2726">          unsigned int defaultNumImplicitHs = implicitValence - bosum;</a>
<a name="ln2727">          if (implicitValence == 0 // hypervalent</a>
<a name="ln2728">             ||  numImplicitHs != defaultNumImplicitHs // undervalent</a>
<a name="ln2729">             || (!options.kekulesmi &amp;&amp; element != 6 &amp;&amp; atom-&gt;IsAromatic() &amp;&amp; numImplicitHs != 0) ) // aromatic nitrogen/phosphorus</a>
<a name="ln2730">            bracketElement = true;</a>
<a name="ln2731">        }</a>
<a name="ln2732">      }</a>
<a name="ln2733">    }</a>
<a name="ln2734"> </a>
<a name="ln2735">    if (atom-&gt;GetFormalCharge() != 0 // charged elements</a>
<a name="ln2736">      || (options.isomeric &amp;&amp; atom-&gt;GetIsotope()) // isotopes</a>
<a name="ln2737">      || (options.showatomclass &amp;&amp; atom-&gt;HasData(&quot;Atom Class&quot;)) ) // If the molecule has Atom Class data and -xa option set and atom has data</a>
<a name="ln2738">      bracketElement = true;</a>
<a name="ln2739"> </a>
<a name="ln2740">    const char* stereo = nullptr;</a>
<a name="ln2741">    if (GetSmilesValence(atom) &gt; 2 &amp;&amp; options.isomeric) {</a>
<a name="ln2742">      stereo = GetTetrahedralStereo(node, chiral_neighbors, symmetry_classes);</a>
<a name="ln2743">      if (stereo == nullptr)</a>
<a name="ln2744">        stereo = GetSquarePlanarStereo(node, chiral_neighbors, symmetry_classes);</a>
<a name="ln2745">    }</a>
<a name="ln2746">    if (stereo != nullptr)</a>
<a name="ln2747">      bracketElement = true;</a>
<a name="ln2748"> </a>
<a name="ln2749">    if (!bracketElement) {</a>
<a name="ln2750"> </a>
<a name="ln2751">      // Ordinary non-bracket element</a>
<a name="ln2752">      if (element) {</a>
<a name="ln2753">        const char* symbol = OBElements::GetSymbol(atom-&gt;GetAtomicNum());</a>
<a name="ln2754">        if ((!options.kekulesmi &amp;&amp; atom-&gt;IsAromatic()) || // aromatic atom</a>
<a name="ln2755">            (atom-&gt;GetSpinMultiplicity() &amp;&amp; _pconv-&gt;IsOption(&quot;r&quot;))) //Radical centres lowercase if r option set</a>
<a name="ln2756">        {</a>
<a name="ln2757">          buffer += symbol[0] + ('a' - 'A');</a>
<a name="ln2758">          if (symbol[1])</a>
<a name="ln2759">            buffer += symbol[1];</a>
<a name="ln2760">        }</a>
<a name="ln2761">        else</a>
<a name="ln2762">          buffer += symbol;</a>
<a name="ln2763">      }</a>
<a name="ln2764"> </a>
<a name="ln2765">      // Atomic number zero - either '*' or an external atom</a>
<a name="ln2766">      else {</a>
<a name="ln2767">        bool external = false;</a>
<a name="ln2768">        vector&lt;pair&lt;int,pair&lt;OBAtom *,OBBond *&gt; &gt; &gt; *externalBonds =</a>
<a name="ln2769">          (vector&lt;pair&lt;int,pair&lt;OBAtom *,OBBond *&gt; &gt; &gt; *)((OBMol*)atom-&gt;GetParent())-&gt;GetData(&quot;extBonds&quot;);</a>
<a name="ln2770">        vector&lt;pair&lt;int,pair&lt;OBAtom *,OBBond *&gt; &gt; &gt;::iterator externalBond;</a>
<a name="ln2771"> </a>
<a name="ln2772">        if (externalBonds) // TODO: This code has bit-rotted and needs some love</a>
<a name="ln2773">          for(externalBond = externalBonds-&gt;begin();externalBond != externalBonds-&gt;end();++externalBond) {</a>
<a name="ln2774">            if (externalBond-&gt;second.first == atom) {</a>
<a name="ln2775">              external = true;</a>
<a name="ln2776">              buffer += '&amp;';</a>
<a name="ln2777">              OBBond *bond = externalBond-&gt;second.second;</a>
<a name="ln2778">              //if (bond-&gt;IsUp()) {</a>
<a name="ln2779">              //  if ( (bond-&gt;GetBeginAtom())-&gt;HasDoubleBond() ||</a>
<a name="ln2780">              //       (bond-&gt;GetEndAtom())-&gt;HasDoubleBond() )</a>
<a name="ln2781">              //    buffer += '\\';</a>
<a name="ln2782">              //}</a>
<a name="ln2783">              //if (bond-&gt;IsDown()) {</a>
<a name="ln2784">              //  if ( (bond-&gt;GetBeginAtom())-&gt;HasDoubleBond() ||</a>
<a name="ln2785">              //       (bond-&gt;GetEndAtom())-&gt;HasDoubleBond() )</a>
<a name="ln2786">              //    buffer += '/';</a>
<a name="ln2787">              //}</a>
<a name="ln2788">              if (bond-&gt;GetBondOrder() == 2 &amp;&amp; !bond-&gt;IsAromatic()) // TODO: need to check for kekulesmi</a>
<a name="ln2789">                buffer += '=';</a>
<a name="ln2790">              if (bond-&gt;GetBondOrder() == 2 &amp;&amp; bond-&gt;IsAromatic())</a>
<a name="ln2791">                buffer += ':';</a>
<a name="ln2792">              if (bond-&gt;GetBondOrder() == 3)</a>
<a name="ln2793">                buffer += '#';</a>
<a name="ln2794">              if (bond-&gt;GetBondOrder() == 4)</a>
<a name="ln2795">                buffer += '$';</a>
<a name="ln2796">              char tmp[10];</a>
<a name="ln2797">              snprintf(tmp, 10, &quot;%d&quot;, externalBond-&gt;first);</a>
<a name="ln2798">              buffer += tmp;</a>
<a name="ln2799">              break;</a>
<a name="ln2800">            }</a>
<a name="ln2801">          }</a>
<a name="ln2802"> </a>
<a name="ln2803">        if(!external)</a>
<a name="ln2804">          buffer += '*';</a>
<a name="ln2805">      }</a>
<a name="ln2806"> </a>
<a name="ln2807">      return true;</a>
<a name="ln2808">    }</a>
<a name="ln2809"> </a>
<a name="ln2810">    // Bracketed atoms, e.g. [Pb], [OH-], [C@]</a>
<a name="ln2811">    buffer += '[';</a>
<a name="ln2812">    unsigned short iso = atom-&gt;GetIsotope();</a>
<a name="ln2813">    if (options.isomeric &amp;&amp; iso) {</a>
<a name="ln2814">      if (iso &gt;= 10000) // max 4 characters</a>
<a name="ln2815">        obErrorLog.ThrowError(__FUNCTION__, &quot;Isotope value larger than 9999. Ignoring value.&quot;, obWarning);</a>
<a name="ln2816">      else {</a>
<a name="ln2817">        char iso[8]; // 7 characters plus null</a>
<a name="ln2818">        snprintf(iso, 8, &quot;%u&quot;, atom-&gt;GetIsotope());</a>
<a name="ln2819">        buffer += iso;</a>
<a name="ln2820">      }</a>
<a name="ln2821">    }</a>
<a name="ln2822">    if (!atom-&gt;GetAtomicNum())</a>
<a name="ln2823">      buffer += '*';</a>
<a name="ln2824">    else {</a>
<a name="ln2825">      if (atom-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; options.smarts)</a>
<a name="ln2826">        buffer += &quot;#1&quot;;</a>
<a name="ln2827">      else {</a>
<a name="ln2828">        unsigned int elem = atom-&gt;GetAtomicNum();</a>
<a name="ln2829">        const char* symbol = OBElements::GetSymbol(elem);</a>
<a name="ln2830">        if (*symbol == '\0') {</a>
<a name="ln2831">          char atomnum[8];  // '#' plus 3 digits plus null</a>
<a name="ln2832">          snprintf(atomnum, 8, &quot;#%u&quot;, elem);</a>
<a name="ln2833">          buffer += atomnum;</a>
<a name="ln2834">        } else if (!options.kekulesmi &amp;&amp; atom-&gt;IsAromatic()) { // aromatic atom</a>
<a name="ln2835">          buffer += symbol[0] + ('a' - 'A');</a>
<a name="ln2836">          if (symbol[1])</a>
<a name="ln2837">            buffer += symbol[1];</a>
<a name="ln2838">        }</a>
<a name="ln2839">        else</a>
<a name="ln2840">          buffer += symbol;</a>
<a name="ln2841">      }</a>
<a name="ln2842">    }</a>
<a name="ln2843"> </a>
<a name="ln2844">    // If chiral, append '@' or '@@'...unless we're creating a SMARTS (&quot;s&quot;) and it's @H or @@H</a>
<a name="ln2845">    if (stereo != nullptr &amp;&amp; !(options.smarts &amp;&amp; atom-&gt;GetImplicitHCount() &gt; 0))</a>
<a name="ln2846">      buffer += stereo;</a>
<a name="ln2847"> </a>
<a name="ln2848">    // Add extra hydrogens.</a>
<a name="ln2849">    int hcount = numImplicitHs;</a>
<a name="ln2850">    if (hcount &gt; 0 &amp;&amp; (atom == _endatom || atom == _startatom)) // Leave a free valence for attachment</a>
<a name="ln2851">      hcount--;</a>
<a name="ln2852">    if (hcount &gt; 0) {</a>
<a name="ln2853">      if (options.smarts &amp;&amp; stereo == nullptr) {</a>
<a name="ln2854">        char tcount[10];</a>
<a name="ln2855">        for (int i = 0; i &lt; hcount; ++i) {</a>
<a name="ln2856">          buffer += &quot;!H&quot;;</a>
<a name="ln2857">          snprintf(tcount, 10, &quot;%d&quot;, i);</a>
<a name="ln2858">          buffer += tcount;</a>
<a name="ln2859">        }</a>
<a name="ln2860">      }</a>
<a name="ln2861">      else {</a>
<a name="ln2862">        buffer += 'H';</a>
<a name="ln2863">        if (hcount &gt; 1) {</a>
<a name="ln2864">          char tcount[10];</a>
<a name="ln2865">          snprintf(tcount, 10, &quot;%d&quot;, hcount);</a>
<a name="ln2866">          buffer += tcount;</a>
<a name="ln2867">        }</a>
<a name="ln2868">      }</a>
<a name="ln2869">    }</a>
<a name="ln2870"> </a>
<a name="ln2871">    // Append charge to the end</a>
<a name="ln2872">    int charge = atom-&gt;GetFormalCharge();</a>
<a name="ln2873">    if (charge != 0) {</a>
<a name="ln2874">      if (charge &gt; 0)</a>
<a name="ln2875">        buffer += '+';</a>
<a name="ln2876">      else</a>
<a name="ln2877">        buffer += '-';</a>
<a name="ln2878"> </a>
<a name="ln2879">      if (abs(charge) &gt; 1) {</a>
<a name="ln2880">        char tchar[10];</a>
<a name="ln2881">        snprintf(tchar, 10, &quot;%d&quot;, abs(charge));</a>
<a name="ln2882">        buffer += tchar;</a>
<a name="ln2883">      }</a>
<a name="ln2884">    }</a>
<a name="ln2885"> </a>
<a name="ln2886">    //atom class e.g. [C:2]</a>
<a name="ln2887">    if (options.showatomclass) {</a>
<a name="ln2888">      OBGenericData *data = atom-&gt;GetData(&quot;Atom Class&quot;);</a>
<a name="ln2889">      if (data) {</a>
<a name="ln2890">        OBPairInteger* acdata = dynamic_cast&lt;OBPairInteger*&gt;(data); // Could replace with C-style cast if willing to live dangerously</a>
<a name="ln2891">        if (acdata) {</a>
<a name="ln2892">          int ac = acdata-&gt;GetGenericValue();</a>
<a name="ln2893">          if (ac &gt;= 0) { // Allow 0, why not?</a>
<a name="ln2894">            buffer += ':';</a>
<a name="ln2895">            char tchar[12]; // maxint has 10 digits</a>
<a name="ln2896">            snprintf(tchar, 12, &quot;%d&quot;, ac);</a>
<a name="ln2897">            buffer += tchar;</a>
<a name="ln2898">          }</a>
<a name="ln2899">        }</a>
<a name="ln2900">      }</a>
<a name="ln2901">    }</a>
<a name="ln2902"> </a>
<a name="ln2903">    buffer += ']';</a>
<a name="ln2904"> </a>
<a name="ln2905">    return true;</a>
<a name="ln2906">  }</a>
<a name="ln2907"> </a>
<a name="ln2908">  /***************************************************************************</a>
<a name="ln2909">   * FUNCTION: AtomIsChiral</a>
<a name="ln2910">   *</a>
<a name="ln2911">   * DESCRIPTION:</a>
<a name="ln2912">   *       Returns TRUE if the atom is genuinely chiral, that is, it meets</a>
<a name="ln2913">   *       the criteria from OBAtom::IsChiral, and additionally it actually</a>
<a name="ln2914">   *       has a connected hash or wedge bond.</a>
<a name="ln2915">   *</a>
<a name="ln2916">   *       We arbitrarily reject chiral nitrogen because for our purposes there's</a>
<a name="ln2917">   *       no need to consider it.</a>
<a name="ln2918">   *</a>
<a name="ln2919">   *       NOTE: This is a simplistic test.  When the full SMILES canonicalization</a>
<a name="ln2920">   *       includes chiral markings, this should check the symmetry classes</a>
<a name="ln2921">   *       of the neighbors, not the hash/wedge bonds.</a>
<a name="ln2922">   ***************************************************************************/</a>
<a name="ln2923"> </a>
<a name="ln2924">  bool OBMol2Cansmi::AtomIsChiral(OBAtom *atom)</a>
<a name="ln2925">  {</a>
<a name="ln2926">    unsigned long atomid = atom-&gt;GetId();</a>
<a name="ln2927">    return _stereoFacade-&gt;HasTetrahedralStereo(atomid) || _stereoFacade-&gt;HasSquarePlanarStereo(atomid);</a>
<a name="ln2928">  }</a>
<a name="ln2929"> </a>
<a name="ln2930">  /***************************************************************************</a>
<a name="ln2931">   * FUNCTION: GetTetrahedralStereo</a>
<a name="ln2932">   *</a>
<a name="ln2933">   * DESCRIPTION:</a>
<a name="ln2934">   *       If the atom is chiral, return either &quot;@&quot; or &quot;@@&quot;. Otherwise 0.</a>
<a name="ln2935">   ***************************************************************************/</a>
<a name="ln2936"> </a>
<a name="ln2937">  const char* OBMol2Cansmi::GetTetrahedralStereo(OBCanSmiNode *node,</a>
<a name="ln2938">                                          vector&lt;OBAtom*&gt; &amp;chiral_neighbors,</a>
<a name="ln2939">                                          vector&lt;unsigned int&gt; &amp;symmetry_classes)</a>
<a name="ln2940">  {</a>
<a name="ln2941">    // If not enough chiral neighbors were passed in, we're done</a>
<a name="ln2942">    if (chiral_neighbors.size() &lt; 4)</a>
<a name="ln2943">      return nullptr;</a>
<a name="ln2944"> </a>
<a name="ln2945">    OBAtom *atom = node-&gt;GetAtom();</a>
<a name="ln2946">    OBTetrahedralStereo *ts = _stereoFacade-&gt;GetTetrahedralStereo(atom-&gt;GetId());</a>
<a name="ln2947">    // If atom is not a tetrahedral center, we're done</a>
<a name="ln2948">    if (!ts)</a>
<a name="ln2949">      return nullptr;</a>
<a name="ln2950"> </a>
<a name="ln2951">    // get the Config struct defining the stereochemistry</a>
<a name="ln2952">    OBTetrahedralStereo::Config atomConfig = ts-&gt;GetConfig();</a>
<a name="ln2953"> </a>
<a name="ln2954">    // Unspecified or unknown stereochemistry</a>
<a name="ln2955">    if (!atomConfig.specified || (atomConfig.specified &amp;&amp; atomConfig.winding==OBStereo::UnknownWinding))</a>
<a name="ln2956">      return nullptr;</a>
<a name="ln2957"> </a>
<a name="ln2958">    // create a Config struct with the chiral_neighbors in canonical output order</a>
<a name="ln2959">    OBStereo::Refs canonRefs;</a>
<a name="ln2960">    for (vector&lt;OBAtom*&gt;::const_iterator atom_it = chiral_neighbors.begin() + 1; atom_it != chiral_neighbors.end(); ++atom_it) {</a>
<a name="ln2961">      if (*atom_it)</a>
<a name="ln2962">        canonRefs.push_back((*atom_it)-&gt;GetId());</a>
<a name="ln2963">      else // Handle a chiral lone pair, represented by a NULL OBAtom* in chiral_neighbors</a>
<a name="ln2964">        canonRefs.push_back(OBStereo::ImplicitRef);</a>
<a name="ln2965">    }</a>
<a name="ln2966">    OBTetrahedralStereo::Config canConfig;</a>
<a name="ln2967">    canConfig.center = atom-&gt;GetId();</a>
<a name="ln2968">    if (chiral_neighbors[0])</a>
<a name="ln2969">      canConfig.from = chiral_neighbors[0]-&gt;GetId();</a>
<a name="ln2970">    else // Handle a chiral lone pair, represented by a NULL OBAtom* in chiral_neighbors</a>
<a name="ln2971">      canConfig.from = OBStereo::ImplicitRef;</a>
<a name="ln2972">    canConfig.refs = canonRefs;</a>
<a name="ln2973"> </a>
<a name="ln2974">    // canConfig is clockwise</a>
<a name="ln2975">    if (atomConfig == canConfig)</a>
<a name="ln2976">      return &quot;@@&quot;;</a>
<a name="ln2977">    else</a>
<a name="ln2978">      return &quot;@&quot;;</a>
<a name="ln2979">  }</a>
<a name="ln2980"> </a>
<a name="ln2981">  /***************************************************************************</a>
<a name="ln2982">   * FUNCTION: GetSquarePlanarStereo</a>
<a name="ln2983">   *</a>
<a name="ln2984">   * DESCRIPTION:</a>
<a name="ln2985">   *       If the atom is chiral, return either '@SP1', '@SP2' or '@SP'.</a>
<a name="ln2986">   *       Otherwise, return 0.</a>
<a name="ln2987">   ***************************************************************************/</a>
<a name="ln2988"> </a>
<a name="ln2989">  const char* OBMol2Cansmi::GetSquarePlanarStereo(OBCanSmiNode *node,</a>
<a name="ln2990">                                           vector&lt;OBAtom*&gt; &amp;chiral_neighbors,</a>
<a name="ln2991">                                           vector&lt;unsigned int&gt; &amp;symmetry_classes)</a>
<a name="ln2992">  {</a>
<a name="ln2993">    // If no chiral neighbors were passed in, we're done</a>
<a name="ln2994">    if (chiral_neighbors.size() &lt; 4)</a>
<a name="ln2995">      return nullptr;</a>
<a name="ln2996"> </a>
<a name="ln2997">    OBAtom *atom = node-&gt;GetAtom();</a>
<a name="ln2998"> </a>
<a name="ln2999">    OBSquarePlanarStereo *sp = _stereoFacade-&gt;GetSquarePlanarStereo(atom-&gt;GetId());</a>
<a name="ln3000">    // If atom is not a square-planar center, we're done</a>
<a name="ln3001">    if (!sp)</a>
<a name="ln3002">      return nullptr;</a>
<a name="ln3003"> </a>
<a name="ln3004">    // get the Config struct defining the stereochemistry</a>
<a name="ln3005">    OBSquarePlanarStereo::Config atomConfig = sp-&gt;GetConfig();</a>
<a name="ln3006"> </a>
<a name="ln3007">    if (!atomConfig.specified)</a>
<a name="ln3008">      return nullptr;</a>
<a name="ln3009"> </a>
<a name="ln3010">    // create a Config struct with the chiral_neighbors in canonical output order</a>
<a name="ln3011">    OBStereo::Refs canonRefs = OBStereo::MakeRefs(chiral_neighbors[0]-&gt;GetId(),</a>
<a name="ln3012">        chiral_neighbors[1]-&gt;GetId(), chiral_neighbors[2]-&gt;GetId(), chiral_neighbors[3]-&gt;GetId());</a>
<a name="ln3013">    OBSquarePlanarStereo::Config canConfig;</a>
<a name="ln3014">    canConfig.center = atom-&gt;GetId();</a>
<a name="ln3015">    canConfig.refs = canonRefs;</a>
<a name="ln3016"> </a>
<a name="ln3017">    // canConfig is U shape</a>
<a name="ln3018">    if (atomConfig == canConfig)</a>
<a name="ln3019">      return &quot;@SP1&quot;;</a>
<a name="ln3020"> </a>
<a name="ln3021">    canConfig.shape = OBStereo::Shape4;</a>
<a name="ln3022">    if (atomConfig == canConfig)</a>
<a name="ln3023">      return &quot;@SP2&quot;;</a>
<a name="ln3024"> </a>
<a name="ln3025">    canConfig.shape = OBStereo::ShapeZ;</a>
<a name="ln3026">    if (atomConfig == canConfig)</a>
<a name="ln3027">      return &quot;@SP3&quot;;</a>
<a name="ln3028"> </a>
<a name="ln3029">    return nullptr;</a>
<a name="ln3030">  }</a>
<a name="ln3031"> </a>
<a name="ln3032">  //! Adaptation of OBMol::FindChildren to allow a vector of OBAtoms to be passed in</a>
<a name="ln3033">  //  MOVE THIS TO OBMOL FOR 2.4</a>
<a name="ln3034">  void OBMol2Cansmi::MyFindChildren(OBMol &amp;mol, vector&lt;OBAtom*&gt; &amp;children, OBBitVec &amp;seen, OBAtom *end)</a>
<a name="ln3035">  {</a>
<a name="ln3036">    OBBitVec curr,next;</a>
<a name="ln3037"> </a>
<a name="ln3038">    OBBitVec used(seen);</a>
<a name="ln3039">    used |= end-&gt;GetIdx();</a>
<a name="ln3040">    curr |= end-&gt;GetIdx();</a>
<a name="ln3041">    children.clear();</a>
<a name="ln3042"> </a>
<a name="ln3043">    int i;</a>
<a name="ln3044">    OBAtom *atom,*nbr;</a>
<a name="ln3045">    vector&lt;OBBond*&gt;::iterator j;</a>
<a name="ln3046"> </a>
<a name="ln3047">    for (;;)</a>
<a name="ln3048">      {</a>
<a name="ln3049">        next.Clear();</a>
<a name="ln3050">        for (i = curr.NextBit(-1);i != curr.EndBit();i = curr.NextBit(i))</a>
<a name="ln3051">          {</a>
<a name="ln3052">            atom = mol.GetAtom(i);</a>
<a name="ln3053">            for (nbr = atom-&gt;BeginNbrAtom(j);nbr;nbr = atom-&gt;NextNbrAtom(j))</a>
<a name="ln3054">              if (!used[nbr-&gt;GetIdx()])</a>
<a name="ln3055">                {</a>
<a name="ln3056">                  children.push_back(nbr);</a>
<a name="ln3057">                  next |= nbr-&gt;GetIdx();</a>
<a name="ln3058">                  used |= nbr-&gt;GetIdx();</a>
<a name="ln3059">                }</a>
<a name="ln3060">          }</a>
<a name="ln3061">        if (next.IsEmpty())</a>
<a name="ln3062">          break;</a>
<a name="ln3063">        curr = next;</a>
<a name="ln3064">      }</a>
<a name="ln3065">  }</a>
<a name="ln3066"> </a>
<a name="ln3067">  // Do we need to write out a bond symbol for this bond?</a>
<a name="ln3068">  // No - if it's aromatic</a>
<a name="ln3069">  // Otherwise, yes if the bond order is not 1</a>
<a name="ln3070">  // If the bond order *is* 1, then only if the bond is in a ring and between aromatic atoms</a>
<a name="ln3071">  static bool NeedsBondSymbol(OBBond* bond)</a>
<a name="ln3072">  {</a>
<a name="ln3073">    if (bond-&gt;IsAromatic())</a>
<a name="ln3074">      return false;</a>
<a name="ln3075">    switch (bond-&gt;GetBondOrder()) {</a>
<a name="ln3076">    case 1:</a>
<a name="ln3077">      if (bond-&gt;IsInRing() &amp;&amp; bond-&gt;GetBeginAtom()-&gt;IsAromatic() &amp;&amp; bond-&gt;GetEndAtom()-&gt;IsAromatic())</a>
<a name="ln3078">        return true;</a>
<a name="ln3079">      return false;</a>
<a name="ln3080">    default: // bond orders != 1</a>
<a name="ln3081">      return true;</a>
<a name="ln3082">    }</a>
<a name="ln3083">  }</a>
<a name="ln3084"> </a>
<a name="ln3085">  /***************************************************************************</a>
<a name="ln3086">   * FUNCTION: BuildCanonTree</a>
<a name="ln3087">   *</a>
<a name="ln3088">   * DESCRIPTION:</a>
<a name="ln3089">   *       Builds the SMILES tree, in canonical order, for the specified</a>
<a name="ln3090">   *       molecular fragment.</a>
<a name="ln3091">   ***************************************************************************/</a>
<a name="ln3092"> </a>
<a name="ln3093">  bool OBMol2Cansmi::BuildCanonTree(OBMol &amp;mol,</a>
<a name="ln3094">                                    OBBitVec &amp;frag_atoms,</a>
<a name="ln3095">                                    vector&lt;unsigned int&gt; &amp;canonical_order,</a>
<a name="ln3096">                                    OBCanSmiNode *node)</a>
<a name="ln3097">  {</a>
<a name="ln3098">    vector&lt;OBBond*&gt;::iterator i;</a>
<a name="ln3099">    OBAtom *nbr, *atom;</a>
<a name="ln3100">    vector&lt;OBAtom *&gt; sort_nbrs;</a>
<a name="ln3101">    vector&lt;OBAtom *&gt;::iterator ai;</a>
<a name="ln3102">    OBBond *bond;</a>
<a name="ln3103">    OBCanSmiNode *next;</a>
<a name="ln3104">    int idx;</a>
<a name="ln3105"> </a>
<a name="ln3106">    atom = node-&gt;GetAtom();</a>
<a name="ln3107"> </a>
<a name="ln3108">#if DEBUG</a>
<a name="ln3109">    cout &lt;&lt; &quot;BuildCanonTree: &quot; &lt;&lt; OBElements::GetSymbol(atom-&gt;GetAtomicNum()) &lt;&lt; &quot;, &quot; &lt;&lt; atom-&gt;GetIdx() &lt;&lt; &quot;, canorder &quot; &lt;&lt; canonical_order[atom-&gt;GetIdx()-1] &lt;&lt; &quot;\n&quot;;</a>
<a name="ln3110">#endif</a>
<a name="ln3111"> </a>
<a name="ln3112">    // Create a vector of neighbors sorted by canonical order, but favor</a>
<a name="ln3113">    // double and triple bonds over single and aromatic.  This causes</a>
<a name="ln3114">    // ring-closure digits to avoid double and triple bonds.</a>
<a name="ln3115">    //</a>
<a name="ln3116">    // Since there are typically just one to three neighbors, we just do a</a>
<a name="ln3117">    // ordered insertion rather than sorting.</a>
<a name="ln3118"> </a>
<a name="ln3119">    bool favor_multiple = true; // Visit 'multiple' bonds first</a>
<a name="ln3120">    if (options.ordering)</a>
<a name="ln3121">      favor_multiple = false; // Visit in strict canonical order (if using user-specified order)</a>
<a name="ln3122"> </a>
<a name="ln3123">    for (nbr = atom-&gt;BeginNbrAtom(i); nbr; nbr = atom-&gt;NextNbrAtom(i)) {</a>
<a name="ln3124"> </a>
<a name="ln3125">      idx = nbr-&gt;GetIdx();</a>
<a name="ln3126">      //if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; IsSuppressedHydrogen(nbr)) {</a>
<a name="ln3127">      //  _uatoms.SetBitOn(nbr-&gt;GetIdx());        // mark suppressed hydrogen, so it won't be considered</a>
<a name="ln3128">      //  continue;                               // later when looking for more fragments.</a>
<a name="ln3129">      //}</a>
<a name="ln3130">      if (_uatoms[idx] || !frag_atoms.BitIsSet(idx))</a>
<a name="ln3131">        continue;</a>
<a name="ln3132"> </a>
<a name="ln3133">      OBBond *nbr_bond = atom-&gt;GetBond(nbr);</a>
<a name="ln3134">      unsigned int nbr_bond_order = nbr_bond-&gt;GetBondOrder();</a>
<a name="ln3135">      int new_needs_bsymbol = NeedsBondSymbol(nbr_bond);</a>
<a name="ln3136"> </a>
<a name="ln3137">      for (ai = sort_nbrs.begin(); ai != sort_nbrs.end(); ++ai) {</a>
<a name="ln3138">        bond = atom-&gt;GetBond(*ai);</a>
<a name="ln3139">        unsigned int bond_order = bond-&gt;GetBondOrder();</a>
<a name="ln3140">        int sorted_needs_bsymbol = NeedsBondSymbol(bond);</a>
<a name="ln3141">        if (favor_multiple &amp;&amp; new_needs_bsymbol &amp;&amp; !sorted_needs_bsymbol) {</a>
<a name="ln3142">          sort_nbrs.insert(ai, nbr);</a>
<a name="ln3143">          ai = sort_nbrs.begin();//insert invalidated ai; set it to fail next test</a>
<a name="ln3144">          break;</a>
<a name="ln3145">        }</a>
<a name="ln3146">        if (   (!favor_multiple || new_needs_bsymbol == sorted_needs_bsymbol)</a>
<a name="ln3147">               &amp;&amp; canonical_order[idx-1] &lt; canonical_order[(*ai)-&gt;GetIdx()-1]) {</a>
<a name="ln3148">          sort_nbrs.insert(ai, nbr);</a>
<a name="ln3149">          ai = sort_nbrs.begin();//insert invalidated ai; set it to fail next test</a>
<a name="ln3150">          break;</a>
<a name="ln3151">        }</a>
<a name="ln3152">      }</a>
<a name="ln3153">      if (ai == sort_nbrs.end())</a>
<a name="ln3154">        sort_nbrs.push_back(nbr);</a>
<a name="ln3155">    }</a>
<a name="ln3156"> </a>
<a name="ln3157">    _uatoms.SetBitOn(atom-&gt;GetIdx());     //mark the atom as visited</a>
<a name="ln3158"> </a>
<a name="ln3159">    if (_endatom &amp;&amp; !_uatoms.BitIsSet(_endatom-&gt;GetIdx()) &amp;&amp; sort_nbrs.size() &gt; 1) {</a>
<a name="ln3160">      // If you have specified an _endatom, the following section rearranges</a>
<a name="ln3161">      // sort_nbrs as follows:</a>
<a name="ln3162">      //   - if a branch does not lead to the end atom, move it to the front</a>
<a name="ln3163">      //     (i.e. visit it first)</a>
<a name="ln3164">      //   - otherwise move it to the end</a>
<a name="ln3165">      // This section is skipped if sort_nbrs has only a single member, or if</a>
<a name="ln3166">      // we have already visited _endatom.</a>
<a name="ln3167"> </a>
<a name="ln3168">      vector&lt;OBAtom*&gt; children;</a>
<a name="ln3169">      MyFindChildren(mol, children, _uatoms, _endatom);</a>
<a name="ln3170"> </a>
<a name="ln3171">      vector&lt;OBAtom*&gt; front, end;</a>
<a name="ln3172">      for (vector&lt;OBAtom *&gt;::iterator it=sort_nbrs.begin(); it!=sort_nbrs.end(); ++it)</a>
<a name="ln3173">        if (std::find(children.begin(), children.end(), *it) == children.end() &amp;&amp; *it != _endatom)</a>
<a name="ln3174">          front.push_back(*it);</a>
<a name="ln3175">        else</a>
<a name="ln3176">          end.push_back(*it);</a>
<a name="ln3177">      sort_nbrs = front;</a>
<a name="ln3178">      sort_nbrs.insert(sort_nbrs.end(), end.begin(), end.end());</a>
<a name="ln3179">    }</a>
<a name="ln3180"> </a>
<a name="ln3181">    // Build the next layer of nodes, in canonical order</a>
<a name="ln3182">    for (ai = sort_nbrs.begin(); ai != sort_nbrs.end(); ++ai) {</a>
<a name="ln3183">      nbr = *ai;</a>
<a name="ln3184">      idx = nbr-&gt;GetIdx();</a>
<a name="ln3185">      if (_uatoms[idx])   // depth-first search may have used this atom since</a>
<a name="ln3186">        continue;         // we sorted the bonds above</a>
<a name="ln3187">      bond = atom-&gt;GetBond(nbr);</a>
<a name="ln3188">      _ubonds.SetBitOn(bond-&gt;GetIdx());</a>
<a name="ln3189">      next = new OBCanSmiNode(nbr);</a>
<a name="ln3190">      next-&gt;SetParent(atom);</a>
<a name="ln3191">      node-&gt;AddChildNode(next, bond);</a>
<a name="ln3192">      BuildCanonTree(mol, frag_atoms, canonical_order, next);</a>
<a name="ln3193">    }</a>
<a name="ln3194"> </a>
<a name="ln3195">    return(true);</a>
<a name="ln3196">  }</a>
<a name="ln3197"> </a>
<a name="ln3198"> </a>
<a name="ln3199"> </a>
<a name="ln3200">  /***************************************************************************</a>
<a name="ln3201">   * FUNCTION: GetCanonClosureDigits</a>
<a name="ln3202">   *</a>
<a name="ln3203">   * DESCRIPTION:</a>
<a name="ln3204">   *       Given an atom, returns the ring-closure digits for that atom, in</a>
<a name="ln3205">   *       the form of a vector of digit/OBBond* pair.  Some of the digits may</a>
<a name="ln3206">   *       be for newly-opened rings (the matching digit occurs later in the</a>
<a name="ln3207">   *       SMILES string), and some may be for closing rings (the matching</a>
<a name="ln3208">   *       digit occurred earlier in the string).</a>
<a name="ln3209">   *</a>
<a name="ln3210">   *       Canonicalization requires that atoms with more than one digit</a>
<a name="ln3211">   *       have the digits assigned in a canonical fashion.  For example,</a>
<a name="ln3212">   *       the SMILES  &quot;CC12(NCCC2)CCC1&quot; and &quot;CC12(NCCC1)CCC2&quot; are the</a>
<a name="ln3213">   *       same molecule; we need to assign the digits of the first &quot;C12&quot;</a>
<a name="ln3214">   *       such that it always comes out one way or the other.</a>
<a name="ln3215">   *</a>
<a name="ln3216">   *       This needs to find closing bonds (ring bonds already assigned a</a>
<a name="ln3217">   *       digit) and opening bonds (ring bonds not encountered yet).</a>
<a name="ln3218">   *</a>
<a name="ln3219">   *    Closing Bonds:</a>
<a name="ln3220">   *       This is easy: open bonds are already stored in the _vopen vector,</a>
<a name="ln3221">   *       in canonical order.  Just find open bonds to this atom and copy</a>
<a name="ln3222">   *       them from _vopen to our return vector.</a>
<a name="ln3223">   *</a>
<a name="ln3224">   *    Opening Bonds:</a>
<a name="ln3225">   *       This function looks through the bonds for this atoms and finds</a>
<a name="ln3226">   *       any that aren't on the _ubonds &quot;used&quot; list, (and also are non-H</a>
<a name="ln3227">   *       and are in this fragment).  Any such bonds must be ring-closure</a>
<a name="ln3228">   *       bonds.  If there is more than one, they are ordered by the</a>
<a name="ln3229">   *       canonical order of the bonds' neighbor atoms; that is, the bond</a>
<a name="ln3230">   *       to the lowest canonical-ordered neighbor is assigned the first</a>
<a name="ln3231">   *       available number, and upwards in neighbor-atom canonical order.</a>
<a name="ln3232">   ***************************************************************************/</a>
<a name="ln3233"> </a>
<a name="ln3234">  vector&lt;OBBondClosureInfo&gt;</a>
<a name="ln3235">  OBMol2Cansmi::GetCanonClosureDigits(OBAtom *atom,</a>
<a name="ln3236">                                      OBBitVec &amp;frag_atoms,</a>
<a name="ln3237">                                      vector&lt;unsigned int&gt; &amp;canonical_order)</a>
<a name="ln3238">  {</a>
<a name="ln3239">    vector&lt;OBBondClosureInfo&gt; vp_closures;</a>
<a name="ln3240">    vector&lt;OBBond*&gt; vbonds;</a>
<a name="ln3241">    vector&lt;OBBond*&gt;::iterator bi;</a>
<a name="ln3242">    vector&lt;OBBond*&gt;::iterator i;</a>
<a name="ln3243">    OBBond *bond1, *bond2;</a>
<a name="ln3244">    OBAtom *nbr1, *nbr2;</a>
<a name="ln3245">    int nbr1_canorder, nbr2_canorder;</a>
<a name="ln3246"> </a>
<a name="ln3247">    vp_closures.clear();</a>
<a name="ln3248">    vbonds.clear();</a>
<a name="ln3249"> </a>
<a name="ln3250">    // Find new ring-closure bonds for this atom</a>
<a name="ln3251">    for (bond1 = atom-&gt;BeginBond(i); bond1; bond1 = atom-&gt;NextBond(i)) {</a>
<a name="ln3252"> </a>
<a name="ln3253">      // Is this a ring-closure neighbor?</a>
<a name="ln3254">      if (_ubonds.BitIsSet(bond1-&gt;GetIdx()))</a>
<a name="ln3255">        continue;</a>
<a name="ln3256">      nbr1 = bond1-&gt;GetNbrAtom(atom);</a>
<a name="ln3257">      // Skip hydrogens before checking canonical_order</a>
<a name="ln3258">      // PR#1999348</a>
<a name="ln3259">      if (   (nbr1-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; IsSuppressedHydrogen(nbr1))</a>
<a name="ln3260">             || !frag_atoms.BitIsSet(nbr1-&gt;GetIdx()))</a>
<a name="ln3261">        continue;</a>
<a name="ln3262"> </a>
<a name="ln3263">      nbr1_canorder = canonical_order[nbr1-&gt;GetIdx()-1];</a>
<a name="ln3264"> </a>
<a name="ln3265">      // Insert into the bond-vector in canonical order (by neighbor atom order)</a>
<a name="ln3266">      for (bi = vbonds.begin(); bi != vbonds.end(); ++bi) {</a>
<a name="ln3267">        bond2 = *bi;</a>
<a name="ln3268">        nbr2 = bond2-&gt;GetNbrAtom(atom);</a>
<a name="ln3269">        nbr2_canorder = canonical_order[nbr2-&gt;GetIdx()-1];</a>
<a name="ln3270">        if (nbr1_canorder &lt; nbr2_canorder) {</a>
<a name="ln3271">          vbonds.insert(bi, bond1);</a>
<a name="ln3272">          bi = vbonds.begin();//insert invalidated bi; set it to fail next test</a>
<a name="ln3273">          break;</a>
<a name="ln3274">        }</a>
<a name="ln3275">      }</a>
<a name="ln3276">      if (bi == vbonds.end())     // highest one (or first one) - append to end</a>
<a name="ln3277">        vbonds.push_back(bond1);</a>
<a name="ln3278">    }</a>
<a name="ln3279"> </a>
<a name="ln3280">    // If we found new open bonds, assign a bond-closure digits to each one,</a>
<a name="ln3281">    // add it to _vopen, and add it to the return vector.</a>
<a name="ln3282">    for (bi = vbonds.begin(); bi != vbonds.end(); ++bi) {</a>
<a name="ln3283">      bond1 = *bi;</a>
<a name="ln3284">      _ubonds.SetBitOn(bond1-&gt;GetIdx());</a>
<a name="ln3285">      int digit = GetUnusedIndex();</a>
<a name="ln3286">      int bo = (bond1-&gt;IsAromatic())? 1 : bond1-&gt;GetBondOrder();  // CJ: why was this line added?  bo is never used?</a>
<a name="ln3287">      _vopen.push_back(OBBondClosureInfo(bond1-&gt;GetNbrAtom(atom), atom, bond1, digit, true));</a>
<a name="ln3288">      vp_closures.push_back(OBBondClosureInfo(bond1-&gt;GetNbrAtom(atom), atom, bond1, digit, true));</a>
<a name="ln3289">    }</a>
<a name="ln3290"> </a>
<a name="ln3291"> </a>
<a name="ln3292">    // Now look through the list of open closure-bonds and find any to this</a>
<a name="ln3293">    // atom (but watch out for the ones we just added).  For each one found,</a>
<a name="ln3294">    // add it to the return vector, and erase it from _vopen.</a>
<a name="ln3295"> </a>
<a name="ln3296">    if (!_vopen.empty()) {</a>
<a name="ln3297">      vector&lt;OBBondClosureInfo&gt;::iterator j;</a>
<a name="ln3298">      for (j = _vopen.begin(); j != _vopen.end(); ) {</a>
<a name="ln3299">        if (j-&gt;toatom == atom) {</a>
<a name="ln3300">          OBBondClosureInfo bci = *j;</a>
<a name="ln3301">          _vopen.erase(j);                // take bond off &quot;open&quot; list</a>
<a name="ln3302">          bci.is_open = false;            // mark it &quot;closed&quot;</a>
<a name="ln3303">          vp_closures.push_back(bci);     // and add it to this atom's list</a>
<a name="ln3304">          j = _vopen.begin();             // reset iterator</a>
<a name="ln3305">        }</a>
<a name="ln3306">        else</a>
<a name="ln3307">          ++j;</a>
<a name="ln3308">      }</a>
<a name="ln3309">    }</a>
<a name="ln3310"> </a>
<a name="ln3311">    return(vp_closures);</a>
<a name="ln3312">  }</a>
<a name="ln3313"> </a>
<a name="ln3314"> </a>
<a name="ln3315">  /***************************************************************************</a>
<a name="ln3316">   * FUNCTION: IsSuppressedHydrogen</a>
<a name="ln3317">   *</a>
<a name="ln3318">   * DESCRIPTION:</a>
<a name="ln3319">   *       For a hydrogen atom, returns TRUE if the atom is not [2H] or [3H], only</a>
<a name="ln3320">   *       has one bond, and is not bonded to another hydrogen.</a>
<a name="ln3321">   *</a>
<a name="ln3322">   *       NOTE: Return value is nonsensical if you pass it a non-hydrogen</a>
<a name="ln3323">   *       atom.  Presumably, you're calling this because you've found a</a>
<a name="ln3324">   *       hydrogen and want to know if it goes in the SMILES.</a>
<a name="ln3325">   ***************************************************************************/</a>
<a name="ln3326"> </a>
<a name="ln3327">  bool OBMol2Cansmi::IsSuppressedHydrogen(OBAtom *atom)</a>
<a name="ln3328">  {</a>
<a name="ln3329">    if (atom-&gt;GetIsotope() != 0)          // Deuterium or Tritium</a>
<a name="ln3330">      return false;</a>
<a name="ln3331">    if (atom-&gt;GetExplicitDegree() != 1)          // not exactly one bond</a>
<a name="ln3332">      return false;</a>
<a name="ln3333"> </a>
<a name="ln3334">    FOR_NBORS_OF_ATOM(nbr, atom) {</a>
<a name="ln3335">      if (nbr-&gt;GetAtomicNum() == 1)       // neighbor is hydrogen</a>
<a name="ln3336">        return false;</a>
<a name="ln3337">    }</a>
<a name="ln3338"> </a>
<a name="ln3339">    return true;</a>
<a name="ln3340">  }</a>
<a name="ln3341"> </a>
<a name="ln3342">  /***************************************************************************</a>
<a name="ln3343">   * FUNCTION: GetSmilesValence</a>
<a name="ln3344">   *</a>
<a name="ln3345">   * DESCRIPTION:</a>
<a name="ln3346">   *       This is like GetHvyDegree(), but it returns the &quot;valence&quot; of an</a>
<a name="ln3347">   *       atom as it appears in the SMILES string.  In particular, hydrogens</a>
<a name="ln3348">   *       count if they will appear explicitly -- see IsSuppressedHydrogen()</a>
<a name="ln3349">   *       above.</a>
<a name="ln3350">   ***************************************************************************/</a>
<a name="ln3351"> </a>
<a name="ln3352">  int OBMol2Cansmi::GetSmilesValence(OBAtom *atom)</a>
<a name="ln3353">  {</a>
<a name="ln3354">    int count = 0;</a>
<a name="ln3355"> </a>
<a name="ln3356">    if (atom-&gt;GetAtomicNum() == OBElements::Hydrogen)</a>
<a name="ln3357">      return atom-&gt;GetExplicitDegree();</a>
<a name="ln3358"> </a>
<a name="ln3359">    if (options.showexplicitH)</a>
<a name="ln3360">      return atom-&gt;GetExplicitDegree();</a>
<a name="ln3361"> </a>
<a name="ln3362">    FOR_NBORS_OF_ATOM(nbr, atom) {</a>
<a name="ln3363">      if (nbr-&gt;GetAtomicNum() != OBElements::Hydrogen</a>
<a name="ln3364">            || nbr-&gt;GetIsotope() != 0</a>
<a name="ln3365">            || nbr-&gt;GetExplicitDegree() != 1)</a>
<a name="ln3366">        count++;</a>
<a name="ln3367">    }</a>
<a name="ln3368">    return(count);</a>
<a name="ln3369">  }</a>
<a name="ln3370"> </a>
<a name="ln3371"> </a>
<a name="ln3372">  /***************************************************************************</a>
<a name="ln3373">   * FUNCTION: ToCansmilesString</a>
<a name="ln3374">   *</a>
<a name="ln3375">   * DESCRIPTION:</a>
<a name="ln3376">   *       Recursively writes the canonical SMILES string to a buffer.  Writes</a>
<a name="ln3377">   *       this node, then selects each of the child nodes (in canonical</a>
<a name="ln3378">   *       order) and writes them.</a>
<a name="ln3379">   *</a>
<a name="ln3380">   *       Chirality is the tricky bit here.  Before we can write out a chiral</a>
<a name="ln3381">   *       atom, we have to &quot;look ahead&quot; to determine the order in which the</a>
<a name="ln3382">   *       neighbor atoms are/will be written.</a>
<a name="ln3383">   *</a>
<a name="ln3384">   *       The SMILES language defines the order-of-appearance of a ring-closure</a>
<a name="ln3385">   *       bond as the position of the digit, in the SMILES, not the actual atom.</a>
<a name="ln3386">   *       For example, the fragments N[C@H](C)Br, and N[C@H]1(Br)CCCC1 have</a>
<a name="ln3387">   *       the same chiral center, because the &quot;1&quot; in the second one is a &quot;stand</a>
<a name="ln3388">   *       in&quot; for the &quot;C&quot; in the first, even though the actual carbon atom appears</a>
<a name="ln3389">   *       after the Bromine atom in the second string.</a>
<a name="ln3390">   ***************************************************************************/</a>
<a name="ln3391"> </a>
<a name="ln3392">  void OBMol2Cansmi::ToCansmilesString(OBCanSmiNode *node,</a>
<a name="ln3393">                                       std::string &amp;buffer,</a>
<a name="ln3394">                                       OBBitVec &amp;frag_atoms,</a>
<a name="ln3395">                                       vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln3396">                                       vector&lt;unsigned int&gt; &amp;canonical_order)</a>
<a name="ln3397">  {</a>
<a name="ln3398">    OBAtom *atom = node-&gt;GetAtom();</a>
<a name="ln3399">    vector&lt;OBAtom *&gt; chiral_neighbors;</a>
<a name="ln3400"> </a>
<a name="ln3401">    // Get the ring-closure digits in canonical order.  We'll use these in</a>
<a name="ln3402">    // two places: First, for figuring out chirality, then later for writing</a>
<a name="ln3403">    // the actual ring-closure digits to the string.</a>
<a name="ln3404">    vector&lt;OBBondClosureInfo&gt; vclose_bonds = GetCanonClosureDigits(atom, frag_atoms, canonical_order);</a>
<a name="ln3405"> </a>
<a name="ln3406">    // First thing: Figure out chirality.  We start by creating a vector of the neighbors</a>
<a name="ln3407">    // in the order in which they'll appear in the canonical SMILES string.  This is more</a>
<a name="ln3408">    // complex than you'd guess because of implicit/explicit H and ring-closure digits.</a>
<a name="ln3409"> </a>
<a name="ln3410">    // Don't include chiral symbol on _endatom or _startatom.</a>
<a name="ln3411">    // Otherwise, we end up with C[C@@H](Br)(Cl), where the C has 4 neighbours already</a>
<a name="ln3412">    // and we cannot concatenate another SMILES string without creating a 5-valent C.</a>
<a name="ln3413"> </a>
<a name="ln3414">    bool is_chiral = AtomIsChiral(atom);</a>
<a name="ln3415">    if (is_chiral &amp;&amp; atom!=_endatom &amp;&amp; atom!=_startatom) {</a>
<a name="ln3416"> </a>
<a name="ln3417">      // If there's a parent node, it's the first atom in the ordered neighbor-vector</a>
<a name="ln3418">      // used for chirality.</a>
<a name="ln3419">      if (node-&gt;GetParent()) {</a>
<a name="ln3420">        chiral_neighbors.push_back(node-&gt;GetParent());</a>
<a name="ln3421">      }</a>
<a name="ln3422"> </a>
<a name="ln3423">      // Next for chirality order will be hydrogen -- since it occurs</a>
<a name="ln3424">      // inside the atom's [] brackets, it's always before other neighbors.</a>
<a name="ln3425">      //</a>
<a name="ln3426">      // Note that we check the regular neighbor list, NOT the canonical</a>
<a name="ln3427">      // SMILES tree, because hydrogens normally aren't part of the canonical</a>
<a name="ln3428">      // SMILES, but we still need them to figure out chirality.</a>
<a name="ln3429">      //</a>
<a name="ln3430">      // There are two cases: it's explicit in the OBMol object but should be</a>
<a name="ln3431">      // written inside the brackets, i.e. &quot;[C@H]&quot;, or it is explicit and</a>
<a name="ln3432">      // must be outside the brackets, such as for deuterium.  (A hydrogen</a>
<a name="ln3433">      // that will appear explicitly in the SMILES as a separate atom is</a>
<a name="ln3434">      // treated like any other atom when calculating the chirality.)</a>
<a name="ln3435"> </a>
<a name="ln3436">      if (!options.showexplicitH) {</a>
<a name="ln3437">        FOR_NBORS_OF_ATOM(i_nbr, atom) {</a>
<a name="ln3438">          OBAtom *nbr = &amp;(*i_nbr);</a>
<a name="ln3439">          if (nbr-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; IsSuppressedHydrogen(nbr)) {</a>
<a name="ln3440">            chiral_neighbors.push_back(nbr);</a>
<a name="ln3441">            break;        // quit loop: only be one H if atom is chiral</a>
<a name="ln3442">          }</a>
<a name="ln3443">        }</a>
<a name="ln3444">      }</a>
<a name="ln3445"> </a>
<a name="ln3446">      // Handle implict H by adding a NULL OBAtom*</a>
<a name="ln3447">      if(atom-&gt;GetImplicitHCount() == 1)</a>
<a name="ln3448">        chiral_neighbors.push_back(nullptr);</a>
<a name="ln3449"> </a>
<a name="ln3450">      // Ok, done with H. Now we need to consider the case where there is a chiral</a>
<a name="ln3451">      // lone pair. If it exists (and we won't know for sure until we've counted up</a>
<a name="ln3452">      // all the neighbours) it will go in here</a>
<a name="ln3453">      int lonepair_location = chiral_neighbors.size();</a>
<a name="ln3454"> </a>
<a name="ln3455">      // Ok, done with all that. Next in the SMILES will be the ring-closure characters.</a>
<a name="ln3456">      // So we need to find the corresponding atoms and add them to the list.</a>
<a name="ln3457">      // (We got the canonical ring-closure list earlier.)</a>
<a name="ln3458">      if (!vclose_bonds.empty()) {</a>
<a name="ln3459">        vector&lt;OBBondClosureInfo&gt;::iterator i;</a>
<a name="ln3460">        for (i = vclose_bonds.begin();i != vclose_bonds.end();++i) {</a>
<a name="ln3461">          OBBond *bond = i-&gt;bond;</a>
<a name="ln3462">          OBAtom *nbr = bond-&gt;GetNbrAtom(atom);</a>
<a name="ln3463">          chiral_neighbors.push_back(nbr);</a>
<a name="ln3464">        }</a>
<a name="ln3465">      }</a>
<a name="ln3466"> </a>
<a name="ln3467">      // Finally, add the &quot;regular&quot; neighbors, the &quot;child&quot; nodes in the</a>
<a name="ln3468">      // canonical-SMILES tree, to the chiral-neighbors list.</a>
<a name="ln3469">      for (int i = 0; i &lt; node-&gt;Size(); i++) {</a>
<a name="ln3470">        OBAtom *nbr = node-&gt;GetChildAtom(i);</a>
<a name="ln3471">        chiral_neighbors.push_back(nbr);</a>
<a name="ln3472">      }</a>
<a name="ln3473"> </a>
<a name="ln3474">      // Handle a chiral lone-pair on a sulfur, by inserting a NULL OBAtom* at the</a>
<a name="ln3475">      // appropriate location</a>
<a name="ln3476">      if (chiral_neighbors.size() == 3 &amp;&amp; CanHaveLonePair(atom-&gt;GetAtomicNum())) // Handle sulfur</a>
<a name="ln3477">        chiral_neighbors.insert(chiral_neighbors.begin() + lonepair_location, nullptr);</a>
<a name="ln3478"> </a>
<a name="ln3479">    }</a>
<a name="ln3480"> </a>
<a name="ln3481">    // Write the current atom to the string</a>
<a name="ln3482">    GetSmilesElement(node, chiral_neighbors, symmetry_classes, buffer);</a>
<a name="ln3483"> </a>
<a name="ln3484">    _atmorder.push_back(atom-&gt;GetIdx());  //store the atom ordering</a>
<a name="ln3485"> </a>
<a name="ln3486">    // Write ring-closure digits</a>
<a name="ln3487">    if (!vclose_bonds.empty()) {</a>
<a name="ln3488">      vector&lt;OBBondClosureInfo&gt;::iterator bci;</a>
<a name="ln3489">      for (bci = vclose_bonds.begin(); bci != vclose_bonds.end(); ++bci) {</a>
<a name="ln3490">        if (!bci-&gt;is_open)</a>
<a name="ln3491">        { // Ring closure</a>
<a name="ln3492">          char bs[2] = { '\0', '\0' };</a>
<a name="ln3493">          // Only get symbol for ring closures on the dbl bond</a>
<a name="ln3494">          if (HasStereoDblBond(bci-&gt;bond, node-&gt;GetAtom()))</a>
<a name="ln3495">            bs[0] = GetCisTransBondSymbol(bci-&gt;bond, node);</a>
<a name="ln3496">          if (bs[0])</a>
<a name="ln3497">            buffer += bs;	// append &quot;/&quot; or &quot;\&quot;</a>
<a name="ln3498">          else</a>
<a name="ln3499">          {</a>
<a name="ln3500">            switch (bci-&gt;bond-&gt;GetBondOrder())</a>
<a name="ln3501">            {</a>
<a name="ln3502">            case 1:</a>
<a name="ln3503">              if (!bci-&gt;bond-&gt;IsAromatic() &amp;&amp; bci-&gt;bond-&gt;IsInRing() &amp;&amp; bci-&gt;bond-&gt;GetBeginAtom()-&gt;IsAromatic() &amp;&amp; bci-&gt;bond-&gt;GetEndAtom()-&gt;IsAromatic())</a>
<a name="ln3504">                buffer += '-';</a>
<a name="ln3505">              break;</a>
<a name="ln3506">            case 2:</a>
<a name="ln3507">              if (options.kekulesmi || !bci-&gt;bond-&gt;IsAromatic())</a>
<a name="ln3508">                buffer += '=';</a>
<a name="ln3509">              break;</a>
<a name="ln3510">            case 3:</a>
<a name="ln3511">              buffer += '#'; break;</a>
<a name="ln3512">            case 4:</a>
<a name="ln3513">              buffer += '$'; break;</a>
<a name="ln3514">            }</a>
<a name="ln3515">          }</a>
<a name="ln3516">        }</a>
<a name="ln3517">        else</a>
<a name="ln3518">        { // Ring opening</a>
<a name="ln3519">          char bs[2] = { '\0', '\0' };</a>
<a name="ln3520">          // Only get symbol for ring openings on the dbl bond</a>
<a name="ln3521">          if (!HasStereoDblBond(bci-&gt;bond, bci-&gt;bond-&gt;GetNbrAtom(node-&gt;GetAtom())))</a>
<a name="ln3522">            bs[0] = GetCisTransBondSymbol(bci-&gt;bond, node);</a>
<a name="ln3523">          if (bs[0])</a>
<a name="ln3524">            buffer += bs;	// append &quot;/&quot; or &quot;\&quot;</a>
<a name="ln3525">        }</a>
<a name="ln3526">        if (bci-&gt;ringdigit &gt; 9) {</a>
<a name="ln3527">          buffer += '%';</a>
<a name="ln3528">          if (bci-&gt;ringdigit &gt; 99)</a>
<a name="ln3529">            buffer += '(';</a>
<a name="ln3530">          char digits[8];</a>
<a name="ln3531">          snprintf(digits, 8, &quot;%d&quot;, bci-&gt;ringdigit);</a>
<a name="ln3532">          buffer += digits;</a>
<a name="ln3533">          if (bci-&gt;ringdigit &gt; 99)</a>
<a name="ln3534">            buffer += ')';</a>
<a name="ln3535">        }</a>
<a name="ln3536">        else</a>
<a name="ln3537">          buffer += (char)(bci-&gt;ringdigit + '0');</a>
<a name="ln3538">      }</a>
<a name="ln3539">    }</a>
<a name="ln3540"> </a>
<a name="ln3541">    // Write child bonds, then recursively follow paths to child nodes</a>
<a name="ln3542">    // to print the SMILES for each child branch.</a>
<a name="ln3543"> </a>
<a name="ln3544">    OBBond *bond;</a>
<a name="ln3545">    for (int i = 0;i &lt; node-&gt;Size();i++) {</a>
<a name="ln3546">      bond = node-&gt;GetChildBond(i);</a>
<a name="ln3547">      if (i+1 &lt; node-&gt;Size() || node-&gt;GetAtom() == _endatom)</a>
<a name="ln3548">        buffer += '(';</a>
<a name="ln3549"> </a>
<a name="ln3550">      switch (bond-&gt;GetBondOrder()) {</a>
<a name="ln3551">      case 1:</a>
<a name="ln3552">        char cc[2];</a>
<a name="ln3553">        cc[0] = GetCisTransBondSymbol(bond, node);</a>
<a name="ln3554">        if (cc[0] != '\0') {</a>
<a name="ln3555">          cc[1] = '\0';</a>
<a name="ln3556">          buffer += cc;</a>
<a name="ln3557">        }</a>
<a name="ln3558">        else {</a>
<a name="ln3559">          // Write a single bond symbol if not aromatic but end atoms are both aromatic</a>
<a name="ln3560">          // This will speed up reading as it will avoid ring perception around line 563 (bond-&gt;IsInRing())</a>
<a name="ln3561">          // TODO: Consider making the test for IsInRing() an option</a>
<a name="ln3562">          if (!bond-&gt;IsAromatic() &amp;&amp; bond-&gt;IsInRing() &amp;&amp; bond-&gt;GetBeginAtom()-&gt;IsAromatic() &amp;&amp; bond-&gt;GetEndAtom()-&gt;IsAromatic())</a>
<a name="ln3563">            buffer += '-';</a>
<a name="ln3564">        }</a>
<a name="ln3565">        break;</a>
<a name="ln3566">      case 2:</a>
<a name="ln3567">        if (options.kekulesmi || !bond-&gt;IsAromatic())</a>
<a name="ln3568">          buffer += '=';</a>
<a name="ln3569">        break;</a>
<a name="ln3570">      case 3:</a>
<a name="ln3571">        buffer += '#';</a>
<a name="ln3572">        break;</a>
<a name="ln3573">      case 4:</a>
<a name="ln3574">        buffer += '$';</a>
<a name="ln3575">      }</a>
<a name="ln3576"> </a>
<a name="ln3577">      ToCansmilesString(node-&gt;GetChildNode(i),buffer, frag_atoms, symmetry_classes, canonical_order);</a>
<a name="ln3578">      if (i+1 &lt; node-&gt;Size() || node-&gt;GetAtom() == _endatom)</a>
<a name="ln3579">        buffer += ')';</a>
<a name="ln3580">    }</a>
<a name="ln3581">  }</a>
<a name="ln3582"> </a>
<a name="ln3583">  /****************************************************************************</a>
<a name="ln3584">   * FUNCTION: StandardLabels</a>
<a name="ln3585">   *</a>
<a name="ln3586">   * DESCRIPTION:</a>
<a name="ln3587">   *        Creates a set of non-canonical labels for the fragment atoms</a>
<a name="ln3588">   * ***************************************************************************/</a>
<a name="ln3589">  void StandardLabels(OBMol *pMol, OBBitVec *frag_atoms,</a>
<a name="ln3590">                      vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln3591">                      vector&lt;unsigned int&gt; &amp;labels)</a>
<a name="ln3592">  {</a>
<a name="ln3593">    FOR_ATOMS_OF_MOL(atom, *pMol) {</a>
<a name="ln3594">      if (frag_atoms-&gt;BitIsSet(atom-&gt;GetIdx())) {</a>
<a name="ln3595">        labels.push_back(atom-&gt;GetIdx() - 1);</a>
<a name="ln3596">        symmetry_classes.push_back(atom-&gt;GetIdx() - 1);</a>
<a name="ln3597">      }</a>
<a name="ln3598">      else{</a>
<a name="ln3599">        labels.push_back(OBStereo::ImplicitRef); //to match situation when canonical ordering. Just a big number?</a>
<a name="ln3600">        symmetry_classes.push_back(OBStereo::ImplicitRef);</a>
<a name="ln3601">      }</a>
<a name="ln3602">    }</a>
<a name="ln3603">  }</a>
<a name="ln3604"> </a>
<a name="ln3605">  /***************************************************************************</a>
<a name="ln3606">   * FUNCTION: RandomLabels</a>
<a name="ln3607">   *</a>
<a name="ln3608">   * DESCRIPTION:</a>
<a name="ln3609">   *    Creates a set of random labels for the fragment atoms.  Primarily</a>
<a name="ln3610">   *    for testing: you can create a bunch of random SMILES for the same</a>
<a name="ln3611">   *    molecule, and use those to test the canonicalizer.</a>
<a name="ln3612">   ***************************************************************************/</a>
<a name="ln3613"> </a>
<a name="ln3614">  void RandomLabels(OBMol *pMol, OBBitVec &amp;frag_atoms,</a>
<a name="ln3615">      vector&lt;unsigned int&gt; &amp;symmetry_classes,</a>
<a name="ln3616">      vector&lt;unsigned int&gt; &amp;labels)</a>
<a name="ln3617">  {</a>
<a name="ln3618">    int natoms = pMol-&gt;NumAtoms();</a>
<a name="ln3619">    OBBitVec used(natoms);</a>
<a name="ln3620"> </a>
<a name="ln3621">    FOR_ATOMS_OF_MOL(atom, *pMol) {</a>
<a name="ln3622">      if (frag_atoms.BitIsSet(atom-&gt;GetIdx())) {</a>
<a name="ln3623">        int r = rand() % natoms;</a>
<a name="ln3624">        while (used.BitIsSet(r)) {</a>
<a name="ln3625">          r = (r + 1) % natoms;         // find an unused number</a>
<a name="ln3626">        }</a>
<a name="ln3627">        used.SetBitOn(r);</a>
<a name="ln3628">        labels.push_back(r);</a>
<a name="ln3629">        symmetry_classes.push_back(r);</a>
<a name="ln3630">      }</a>
<a name="ln3631">      else{</a>
<a name="ln3632">        labels.push_back(OBStereo::ImplicitRef); //to match situation when canonical ordering. Just a big number?</a>
<a name="ln3633">        symmetry_classes.push_back(OBStereo::ImplicitRef);</a>
<a name="ln3634">      }</a>
<a name="ln3635">    }</a>
<a name="ln3636">  }</a>
<a name="ln3637"> </a>
<a name="ln3638">  //! Same as tokenize, except in treatment of multiple delimiters. Tokenize</a>
<a name="ln3639">  //! treats multiple delimiters as a single delimiter. It also ignores delimiters</a>
<a name="ln3640">  //! in the first or last position. In contrast, mytokenize treats each instance of</a>
<a name="ln3641">  //! the delimiter as the end/start of a new token.</a>
<a name="ln3642">  bool mytokenize(std::vector&lt;std::string&gt; &amp;vcr, std::string &amp;s,</a>
<a name="ln3643">                      const char *delimstr)</a>
<a name="ln3644">  {</a>
<a name="ln3645">    vcr.clear();</a>
<a name="ln3646">    size_t startpos=0,endpos=0;</a>
<a name="ln3647"> </a>
<a name="ln3648">    size_t s_size = s.size();</a>
<a name="ln3649">    for (;;)</a>
<a name="ln3650">      {</a>
<a name="ln3651">        //startpos = s.find_first_not_of(delimstr,startpos);</a>
<a name="ln3652">        endpos = s.find_first_of(delimstr,startpos);</a>
<a name="ln3653">        if (endpos &lt;= s_size &amp;&amp; startpos &lt;= s_size)</a>
<a name="ln3654">          {</a>
<a name="ln3655">            vcr.push_back(s.substr(startpos,endpos-startpos));</a>
<a name="ln3656">          }</a>
<a name="ln3657">        else</a>
<a name="ln3658">          {</a>
<a name="ln3659">            if (startpos &lt;= s_size)</a>
<a name="ln3660">              vcr.push_back(s.substr(startpos,s_size-startpos));</a>
<a name="ln3661">            break;</a>
<a name="ln3662">          }</a>
<a name="ln3663"> </a>
<a name="ln3664">        startpos = endpos+1;</a>
<a name="ln3665">      }</a>
<a name="ln3666">    return(true);</a>
<a name="ln3667">  }</a>
<a name="ln3668"> </a>
<a name="ln3669">  // Returns canonical label order</a>
<a name="ln3670">  bool OBMol2Cansmi::ParseInChI(OBMol &amp;mol, vector&lt;int&gt; &amp;atom_order)</a>
<a name="ln3671">  {</a>
<a name="ln3672">    OBConversion MolConv;</a>
<a name="ln3673">    MolConv.SetOutFormat(&quot;InChI&quot;);</a>
<a name="ln3674">    MolConv.SetAuxConv(nullptr); //temporary until a proper OBConversion copy constructor written</a>
<a name="ln3675">    stringstream newstream;</a>
<a name="ln3676">    MolConv.SetOutStream(&amp;newstream);</a>
<a name="ln3677">    // I'm sure there's a better way of preventing InChI warning output</a>
<a name="ln3678">    MolConv.AddOption(&quot;w&quot;, OBConversion::OUTOPTIONS);</a>
<a name="ln3679">    MolConv.AddOption(&quot;a&quot;, OBConversion::OUTOPTIONS);</a>
<a name="ln3680">    MolConv.AddOption(&quot;X&quot;, OBConversion::OUTOPTIONS, &quot;RecMet FixedH&quot;);</a>
<a name="ln3681">    //pInChIFormat-&gt;WriteMolecule(&amp;mol, &amp;MolConv);</a>
<a name="ln3682">    MolConv.Write(&amp;mol);</a>
<a name="ln3683"> </a>
<a name="ln3684">    vector&lt;string&gt; splitlines;</a>
<a name="ln3685">    string tmp = newstream.str();</a>
<a name="ln3686">    tokenize(splitlines, tmp,&quot;\n&quot;);</a>
<a name="ln3687">    vector&lt;string&gt; split, split_aux;</a>
<a name="ln3688">    string aux_part;</a>
<a name="ln3689"> </a>
<a name="ln3690">    size_t rm_start = splitlines.at(0).find(&quot;/r&quot;); // Correct for reconnected metal if necessary</a>
<a name="ln3691">    if (rm_start == string::npos) {</a>
<a name="ln3692">      tokenize(split, splitlines.at(0),&quot;/&quot;);</a>
<a name="ln3693">      aux_part = splitlines.at(1); // Use the normal labels</a>
<a name="ln3694">    }</a>
<a name="ln3695">    else {</a>
<a name="ln3696">      tmp = splitlines.at(0).substr(rm_start);</a>
<a name="ln3697">      tokenize(split, tmp, &quot;/&quot;);</a>
<a name="ln3698">      split.insert(split.begin(), &quot;&quot;);</a>
<a name="ln3699">      size_t rm_start_b = splitlines.at(1).find(&quot;/R:&quot;);</a>
<a name="ln3700">      aux_part = splitlines.at(1).substr(rm_start_b); // Use the reconnected metal labels</a>
<a name="ln3701">    }</a>
<a name="ln3702">    tokenize(split_aux, aux_part, &quot;/&quot;);</a>
<a name="ln3703"> </a>
<a name="ln3704">    // Parse the canonical labels</a>
<a name="ln3705">    vector&lt;vector&lt;int&gt; &gt; canonical_labels;</a>
<a name="ln3706">    vector&lt;string&gt; s_components, s_atoms;</a>
<a name="ln3707"> </a>
<a name="ln3708">    tmp = split_aux.at(2).substr(2);</a>
<a name="ln3709">    tokenize(s_components, tmp, &quot;;&quot;);</a>
<a name="ln3710">    for(vector&lt;string&gt;::iterator it=s_components.begin(); it!=s_components.end(); ++it) {</a>
<a name="ln3711">      tokenize(s_atoms, *it, &quot;,&quot;);</a>
<a name="ln3712">      vector&lt;int&gt; atoms;</a>
<a name="ln3713">      for(vector&lt;string&gt;::iterator itb=s_atoms.begin(); itb!=s_atoms.end(); ++itb)</a>
<a name="ln3714">        atoms.push_back(atoi(itb-&gt;c_str()));</a>
<a name="ln3715">      canonical_labels.push_back(atoms);</a>
<a name="ln3716">    }</a>
<a name="ln3717"> </a>
<a name="ln3718">    // Adjust the canonical labels if necessary using a /F section</a>
<a name="ln3719">    size_t f_start = aux_part.find(&quot;/F:&quot;);</a>
<a name="ln3720">    if (f_start != string::npos) {</a>
<a name="ln3721">      tmp = aux_part.substr(f_start+3);</a>
<a name="ln3722">      tokenize(split_aux, tmp, &quot;/&quot;);</a>
<a name="ln3723">      tokenize(s_components, split_aux.at(0), &quot;;&quot;);</a>
<a name="ln3724">      vector&lt;vector&lt;int&gt; &gt; new_canonical_labels;</a>
<a name="ln3725">      int total = 0;</a>
<a name="ln3726">      for(vector&lt;string&gt;::iterator it=s_components.begin(); it!=s_components.end(); ++it) {</a>
<a name="ln3727">        // e.g. &quot;1,2,3;2m&quot; means replace the first component by &quot;1,2,3&quot;</a>
<a name="ln3728">        //                       but keep the next two unchanged</a>
<a name="ln3729">        if (*(it-&gt;rbegin()) == 'm') {</a>
<a name="ln3730">          int mult;</a>
<a name="ln3731">          if (it-&gt;size()==1)</a>
<a name="ln3732">            mult = 1;</a>
<a name="ln3733">          else</a>
<a name="ln3734">            mult = atoi(it-&gt;substr(0, it-&gt;size()-1).c_str());</a>
<a name="ln3735">          new_canonical_labels.insert(new_canonical_labels.end(),</a>
<a name="ln3736">            canonical_labels.begin()+total, canonical_labels.begin()+total+mult);</a>
<a name="ln3737">          total += mult;</a>
<a name="ln3738">        }</a>
<a name="ln3739">        else {</a>
<a name="ln3740">          tokenize(s_atoms, *it, &quot;,&quot;);</a>
<a name="ln3741">          vector&lt;int&gt; atoms;</a>
<a name="ln3742">          for(vector&lt;string&gt;::iterator itb=s_atoms.begin(); itb!=s_atoms.end(); ++itb)</a>
<a name="ln3743">            atoms.push_back(atoi(itb-&gt;c_str()));</a>
<a name="ln3744">          new_canonical_labels.push_back(atoms);</a>
<a name="ln3745">          total++;</a>
<a name="ln3746">        }</a>
<a name="ln3747">      }</a>
<a name="ln3748">      canonical_labels = new_canonical_labels;</a>
<a name="ln3749">    }</a>
<a name="ln3750"> </a>
<a name="ln3751">    // Flatten the canonical_labels</a>
<a name="ln3752">    for(vector&lt;vector&lt;int&gt; &gt;::iterator it=canonical_labels.begin(); it!=canonical_labels.end(); ++it) {</a>
<a name="ln3753">      atom_order.insert(atom_order.end(), it-&gt;begin(), it-&gt;end());</a>
<a name="ln3754">    }</a>
<a name="ln3755"> </a>
<a name="ln3756">    return true;</a>
<a name="ln3757">  }</a>
<a name="ln3758"> </a>
<a name="ln3759">  /**</a>
<a name="ln3760">   * Helper function for getFragment below.</a>
<a name="ln3761">   */</a>
<a name="ln3762">  void addNbrs(OBBitVec &amp;fragment, OBAtom *atom, const OBBitVec &amp;mask)</a>
<a name="ln3763">  {</a>
<a name="ln3764">    FOR_NBORS_OF_ATOM (nbr, atom) {</a>
<a name="ln3765">      if (!mask.BitIsSet(nbr-&gt;GetIdx()))</a>
<a name="ln3766">        continue;</a>
<a name="ln3767">      // skip visited atoms</a>
<a name="ln3768">      if (fragment.BitIsSet(nbr-&gt;GetIdx()))</a>
<a name="ln3769">        continue;</a>
<a name="ln3770">      // add the neighbor atom to the fragment</a>
<a name="ln3771">      fragment.SetBitOn(nbr-&gt;GetIdx());</a>
<a name="ln3772">      // recurse...</a>
<a name="ln3773">      addNbrs(fragment, &amp;*nbr, mask);</a>
<a name="ln3774">    }</a>
<a name="ln3775">  }</a>
<a name="ln3776"> </a>
<a name="ln3777">  /**</a>
<a name="ln3778">   * Create an OBBitVec objects with bets set for the fragment consisting of all</a>
<a name="ln3779">   * atoms for which there is a path to atom without going through skip. These</a>
<a name="ln3780">   * fragment bitvecs are indexed by atom idx (i.e. OBAtom::GetIdx()).</a>
<a name="ln3781">   */</a>
<a name="ln3782">  OBBitVec getFragment(OBAtom *atom, const OBBitVec &amp;mask)</a>
<a name="ln3783">  {</a>
<a name="ln3784">    OBBitVec fragment;</a>
<a name="ln3785">    fragment.SetBitOn(atom-&gt;GetIdx());</a>
<a name="ln3786">    // start the recursion</a>
<a name="ln3787">    addNbrs(fragment, atom, mask);</a>
<a name="ln3788">    return fragment;</a>
<a name="ln3789">  }</a>
<a name="ln3790"> </a>
<a name="ln3791">  /***************************************************************************</a>
<a name="ln3792">   * FUNCTION: CreateFragCansmiString</a>
<a name="ln3793">   *</a>
<a name="ln3794">   * DESCRIPTION:</a>
<a name="ln3795">   *       Selects the &quot;root&quot; atom, which will be first in the SMILES, then</a>
<a name="ln3796">   *       builds a tree in canonical order, and finally generates the SMILES.</a>
<a name="ln3797">   *       If there are then atoms that haven't been visited (i.e. a molecule</a>
<a name="ln3798">   *       with disconnected parts), selects a new root from the remaining</a>
<a name="ln3799">   *       atoms and repeats the process.</a>
<a name="ln3800">   ***************************************************************************/</a>
<a name="ln3801"> </a>
<a name="ln3802">  void OBMol2Cansmi::CreateFragCansmiString(OBMol &amp;mol, OBBitVec &amp;frag_atoms, std::string &amp;buffer)</a>
<a name="ln3803">  {</a>
<a name="ln3804">    //cout &lt;&lt; &quot;CreateFragCansmiString()&quot; &lt;&lt; endl;</a>
<a name="ln3805">    OBAtom *atom;</a>
<a name="ln3806">    OBCanSmiNode *root;</a>
<a name="ln3807">    buffer[0] = '\0';</a>
<a name="ln3808">    vector&lt;OBNodeBase*&gt;::iterator ai;</a>
<a name="ln3809">    vector&lt;unsigned int&gt; symmetry_classes, canonical_order;</a>
<a name="ln3810">    symmetry_classes.reserve(mol.NumAtoms());</a>
<a name="ln3811">    canonical_order.reserve(mol.NumAtoms());</a>
<a name="ln3812"> </a>
<a name="ln3813">    // Remember the desired endatom, if specified</a>
<a name="ln3814">    const char* pp = _pconv-&gt;IsOption(&quot;l&quot;);</a>
<a name="ln3815">    unsigned int atom_idx  = pp ? atoi(pp) : 0;</a>
<a name="ln3816">    if (atom_idx &gt;= 1 &amp;&amp; atom_idx &lt;= mol.NumAtoms())</a>
<a name="ln3817">      _endatom = mol.GetAtom(atom_idx);</a>
<a name="ln3818">    // Was a start atom specified?</a>
<a name="ln3819">    pp = _pconv-&gt;IsOption(&quot;f&quot;);</a>
<a name="ln3820">    atom_idx  = pp ? atoi(pp) : 0;</a>
<a name="ln3821">    if (atom_idx &gt;= 1 &amp;&amp; atom_idx &lt;= mol.NumAtoms())</a>
<a name="ln3822">      _startatom = mol.GetAtom(atom_idx);</a>
<a name="ln3823"> </a>
<a name="ln3824">    // Was an atom ordering specified?</a>
<a name="ln3825">    const char* ppo = options.ordering;</a>
<a name="ln3826">    vector&lt;string&gt; s_atom_order;</a>
<a name="ln3827">    vector&lt;int&gt; atom_order;</a>
<a name="ln3828">    if (ppo) {</a>
<a name="ln3829">      tokenize(s_atom_order,ppo,&quot;-()&quot;);</a>
<a name="ln3830">      if (s_atom_order.size() != mol.NumHvyAtoms())</a>
<a name="ln3831">        ppo = nullptr;</a>
<a name="ln3832">      else {</a>
<a name="ln3833">        for (vector&lt;string&gt;::const_iterator cit=s_atom_order.begin(); cit!=s_atom_order.end(); ++cit)</a>
<a name="ln3834">          atom_order.push_back(atoi(cit-&gt;c_str()));</a>
<a name="ln3835">        atom_idx = atom_order.at(0);</a>
<a name="ln3836">        if (atom_idx &gt;= 1 &amp;&amp; atom_idx &lt;= mol.NumAtoms())</a>
<a name="ln3837">          _startatom = mol.GetAtom(atom_idx);</a>
<a name="ln3838">      }</a>
<a name="ln3839">    }</a>
<a name="ln3840">    // Was Universal SMILES requested?</a>
<a name="ln3841">    bool universal_smiles = _pconv-&gt;IsOption(&quot;U&quot;);</a>
<a name="ln3842">    if (universal_smiles) {</a>
<a name="ln3843">      bool parsedOkay = ParseInChI(mol, atom_order);</a>
<a name="ln3844">      if (!parsedOkay)</a>
<a name="ln3845">        universal_smiles = false;</a>
<a name="ln3846">    }</a>
<a name="ln3847"> </a>
<a name="ln3848">    // First, create a canonical ordering vector for the atoms.  Canonical</a>
<a name="ln3849">    // labels are zero indexed, corresponding to &quot;atom-&gt;GetIdx()-1&quot;.</a>
<a name="ln3850">    if (_canonicalOutput) {</a>
<a name="ln3851"> </a>
<a name="ln3852">      // Find the (dis)connected fragments.</a>
<a name="ln3853">      OBBitVec visited;</a>
<a name="ln3854">      std::vector&lt;OBBitVec&gt; fragments;</a>
<a name="ln3855">      for (std::size_t i = 0; i &lt; mol.NumAtoms(); ++i) {</a>
<a name="ln3856">        if (!frag_atoms.BitIsSet(i+1) || visited.BitIsSet(i+1))</a>
<a name="ln3857">          continue;</a>
<a name="ln3858">        fragments.push_back(getFragment(mol.GetAtom(i+1), frag_atoms));</a>
<a name="ln3859">        visited |= fragments.back();</a>
<a name="ln3860">      }</a>
<a name="ln3861"> </a>
<a name="ln3862">      // Determine symmetry classes for each disconnected fragment separately</a>
<a name="ln3863">      symmetry_classes.resize(mol.NumAtoms());</a>
<a name="ln3864">      for (std::size_t i = 0; i &lt; fragments.size(); ++i) {</a>
<a name="ln3865">        OBGraphSym gs(&amp;mol, &amp;(fragments[i]));</a>
<a name="ln3866">        vector&lt;unsigned int&gt; tmp;</a>
<a name="ln3867">        gs.GetSymmetry(tmp);</a>
<a name="ln3868"> </a>
<a name="ln3869">        for (std::size_t j = 0; j &lt; mol.NumAtoms(); ++j)</a>
<a name="ln3870">          if (fragments[i].BitIsSet(j+1))</a>
<a name="ln3871">            symmetry_classes[j] = tmp[j];</a>
<a name="ln3872">      }</a>
<a name="ln3873"> </a>
<a name="ln3874">      /*</a>
<a name="ln3875">      OBGraphSym gs(&amp;mol, &amp;frag_atoms);</a>
<a name="ln3876">      gs.GetSymmetry(symmetry_classes);</a>
<a name="ln3877">      */</a>
<a name="ln3878"> </a>
<a name="ln3879">      // Was a canonicalization timeout given?</a>
<a name="ln3880">      unsigned int maxSeconds = 5;</a>
<a name="ln3881">      const char *timeoutString = _pconv-&gt;IsOption(&quot;T&quot;);</a>
<a name="ln3882">      if (timeoutString) {</a>
<a name="ln3883">        std::stringstream ss(timeoutString);</a>
<a name="ln3884">        if (!(ss &gt;&gt; maxSeconds)) {</a>
<a name="ln3885">          obErrorLog.ThrowError(__FUNCTION__, &quot;Canonicalization timeout should be a number&quot;, obWarning);</a>
<a name="ln3886">          maxSeconds = 5;</a>
<a name="ln3887">        }</a>
<a name="ln3888">      }</a>
<a name="ln3889"> </a>
<a name="ln3890">      CanonicalLabels(&amp;mol, symmetry_classes, canonical_order, frag_atoms, maxSeconds);</a>
<a name="ln3891">    }</a>
<a name="ln3892">    else {</a>
<a name="ln3893">      if (_pconv-&gt;IsOption(&quot;C&quot;)) {      // &quot;C&quot; == &quot;anti-canonical form&quot;</a>
<a name="ln3894">        RandomLabels(&amp;mol, frag_atoms, symmetry_classes, canonical_order);</a>
<a name="ln3895">      } else if (ppo || universal_smiles) { // user-specified or InChI canonical labels</a>
<a name="ln3896">        canonical_order.resize(mol.NumAtoms());</a>
<a name="ln3897">        symmetry_classes.resize(mol.NumAtoms());</a>
<a name="ln3898">        int idx = 3; // Start the labels at 3 (to leave space for special values 0, 1 and 2)</a>
<a name="ln3899">        for (int i=0; i&lt;atom_order.size(); ++i)</a>
<a name="ln3900">          if (canonical_order[atom_order[i] - 1] == 0) { // Ignore ring closures (for &quot;U&quot;)</a>
<a name="ln3901">            canonical_order[atom_order[i] - 1] = idx;</a>
<a name="ln3902">            symmetry_classes[atom_order[i] - 1] = idx;</a>
<a name="ln3903">            ++idx;</a>
<a name="ln3904">          }</a>
<a name="ln3905">        for (int i=0; i&lt;canonical_order.size(); ++i)</a>
<a name="ln3906">          if (canonical_order[i] == 0) { // Explicit hydrogens</a>
<a name="ln3907">            if (mol.GetAtom(i+1)-&gt;GetAtomicNum() == OBElements::Hydrogen &amp;&amp; mol.GetAtom(i+1)-&gt;GetIsotope()!=0) { // [2H] or [3H]</a>
<a name="ln3908">              canonical_order[i] = mol.GetAtom(i+1)-&gt;GetIsotope() - 1; // i.e. 1 or 2</a>
<a name="ln3909">              symmetry_classes[i] = canonical_order[i];</a>
<a name="ln3910">            }</a>
<a name="ln3911">          }</a>
<a name="ln3912">      } else {</a>
<a name="ln3913">        StandardLabels(&amp;mol, &amp;frag_atoms, symmetry_classes, canonical_order);</a>
<a name="ln3914">      }</a>
<a name="ln3915">    }</a>
<a name="ln3916"> </a>
<a name="ln3917">    // OUTER LOOP: Handles dot-disconnected structures and reactions.  Finds the</a>
<a name="ln3918">    // lowest unmarked canorder atom in the current reaction role, and starts there</a>
<a name="ln3919">    // to generate a SMILES.</a>
<a name="ln3920">    // Repeats until no atoms remain unmarked.</a>
<a name="ln3921"> </a>
<a name="ln3922">    bool new_rxn_role = false; // flag to indicate whether we have started a new reaction role</a>
<a name="ln3923">    bool isrxn = mol.IsReaction();</a>
<a name="ln3924">    OBReactionFacade rxn(&amp;mol);</a>
<a name="ln3925">    unsigned int rxnrole = 1; // reactants</a>
<a name="ln3926">    while (1) {</a>
<a name="ln3927">      if (_pconv-&gt;IsOption(&quot;R&quot;))</a>
<a name="ln3928">        _bcdigit = 0; // Reset the bond closure index for each disconnected component</a>
<a name="ln3929"> </a>
<a name="ln3930">      // It happens that the lowest canonically-numbered atom is usually</a>
<a name="ln3931">      // a good place to start the canonical SMILES.</a>
<a name="ln3932">      OBAtom *root_atom;</a>
<a name="ln3933">      unsigned int lowest_canorder = 999999;</a>
<a name="ln3934">      root_atom = nullptr;</a>
<a name="ln3935"> </a>
<a name="ln3936">      // If we specified a startatom_idx &amp; it's in this fragment, use it to start the fragment</a>
<a name="ln3937">      if (_startatom)</a>
<a name="ln3938">        if (!_uatoms[_startatom-&gt;GetIdx()] &amp;&amp;</a>
<a name="ln3939">           frag_atoms.BitIsSet(_startatom-&gt;GetIdx()) &amp;&amp;</a>
<a name="ln3940">           (!isrxn || rxn.GetRole(_startatom)==rxnrole))</a>
<a name="ln3941">          root_atom = _startatom;</a>
<a name="ln3942"> </a>
<a name="ln3943">      if (root_atom == nullptr) {</a>
<a name="ln3944">        for (atom = mol.BeginAtom(ai); atom; atom = mol.NextAtom(ai)) {</a>
<a name="ln3945">          int idx = atom-&gt;GetIdx();</a>
<a name="ln3946">          if (//atom-&gt;GetAtomicNum() != OBElements::Hydrogen       // don't start with a hydrogen</a>
<a name="ln3947">              !_uatoms[idx]          // skip atoms already used (for fragments)</a>
<a name="ln3948">              &amp;&amp; frag_atoms.BitIsSet(idx)// skip atoms not in this fragment</a>
<a name="ln3949">              &amp;&amp; (!isrxn || rxn.GetRole(atom)==rxnrole) // skip atoms not in this rxn role</a>
<a name="ln3950">              //&amp;&amp; !atom-&gt;IsChiral()    // don't use chiral atoms as root node</a>
<a name="ln3951">              &amp;&amp; canonical_order[idx-1] &lt; lowest_canorder) {</a>
<a name="ln3952">            root_atom = atom;</a>
<a name="ln3953">            lowest_canorder = canonical_order[idx-1];</a>
<a name="ln3954">          }</a>
<a name="ln3955">        }</a>
<a name="ln3956">        // For Inchified or Universal SMILES, if the start atom is an [O-] attached to atom X, choose any =O attached to X instead.</a>
<a name="ln3957">        //          Ditto for [S-] and =S.</a>
<a name="ln3958">        if ((_pconv-&gt;IsOption(&quot;I&quot;) || universal_smiles)</a>
<a name="ln3959">             &amp;&amp; root_atom &amp;&amp; root_atom-&gt;GetFormalCharge()==-1  &amp;&amp; root_atom-&gt;GetExplicitDegree() == 1</a>
<a name="ln3960">             &amp;&amp; root_atom-&gt;HasSingleBond() &amp;&amp; (root_atom-&gt;GetAtomicNum() == OBElements::Oxygen || root_atom-&gt;GetAtomicNum() == OBElements::Sulfur)) {</a>
<a name="ln3961">          OBBondIterator bi = root_atom-&gt;BeginBonds();</a>
<a name="ln3962">          OBAtom* central = root_atom-&gt;BeginNbrAtom(bi);</a>
<a name="ln3963">          FOR_NBORS_OF_ATOM(nbr, central) {</a>
<a name="ln3964">            if (root_atom == &amp;*nbr) continue;</a>
<a name="ln3965">            if (nbr-&gt;GetAtomicNum() == root_atom-&gt;GetAtomicNum() &amp;&amp; nbr-&gt;GetExplicitDegree() == 1 &amp;&amp; nbr-&gt;HasDoubleBond()) {</a>
<a name="ln3966">              root_atom = &amp;*nbr;</a>
<a name="ln3967">              break;</a>
<a name="ln3968">            }</a>
<a name="ln3969">          }</a>
<a name="ln3970">        }</a>
<a name="ln3971">      }</a>
<a name="ln3972"> </a>
<a name="ln3973">      // No atom found?  If it's not a reaction, then we've done all fragments.</a>
<a name="ln3974">      // If it is, then increment the rxn role and try again.</a>
<a name="ln3975">      if (root_atom == nullptr) {</a>
<a name="ln3976">        if (mol.IsReaction()) {</a>
<a name="ln3977">          rxnrole++;</a>
<a name="ln3978">          if (rxnrole==4)</a>
<a name="ln3979">            break;</a>
<a name="ln3980">          buffer += '&gt;';</a>
<a name="ln3981">          new_rxn_role = true;</a>
<a name="ln3982">          continue;</a>
<a name="ln3983">        }</a>
<a name="ln3984">        else</a>
<a name="ln3985">          break;</a>
<a name="ln3986">      }</a>
<a name="ln3987"> </a>
<a name="ln3988">      // Clear out closures in case structure is dot disconnected</a>
<a name="ln3989">      //      _atmorder.clear();</a>
<a name="ln3990">      _vopen.clear();</a>
<a name="ln3991"> </a>
<a name="ln3992">      // Dot disconnected structure or new rxn role?</a>
<a name="ln3993">      if (new_rxn_role)</a>
<a name="ln3994">        new_rxn_role = false;</a>
<a name="ln3995">      else if (!buffer.empty())</a>
<a name="ln3996">        buffer += '.';</a>
<a name="ln3997"> </a>
<a name="ln3998">      root = new OBCanSmiNode (root_atom);</a>
<a name="ln3999"> </a>
<a name="ln4000">      BuildCanonTree(mol, frag_atoms, canonical_order, root);</a>
<a name="ln4001">      ToCansmilesString(root, buffer, frag_atoms, symmetry_classes, canonical_order);</a>
<a name="ln4002">      delete root;</a>
<a name="ln4003">    }</a>
<a name="ln4004">  }</a>
<a name="ln4005"> </a>
<a name="ln4006">  void OBMol2Cansmi::GetOutputOrder(std::string &amp;outorder)</a>
<a name="ln4007">  {</a>
<a name="ln4008">    std::vector&lt;int&gt;::iterator it = _atmorder.begin();</a>
<a name="ln4009">    if (it != _atmorder.end()) {</a>
<a name="ln4010">      char tmp[15];</a>
<a name="ln4011">      snprintf(tmp, 15, &quot;%d&quot;, *it);</a>
<a name="ln4012">      outorder += tmp;</a>
<a name="ln4013">      ++it;</a>
<a name="ln4014">      for (; it != _atmorder.end(); ++it) {</a>
<a name="ln4015">        snprintf(tmp, 15, &quot;%d&quot;, *it);</a>
<a name="ln4016">        outorder += ' ';</a>
<a name="ln4017">        outorder += tmp;</a>
<a name="ln4018">      }</a>
<a name="ln4019">    }</a>
<a name="ln4020">  }</a>
<a name="ln4021"> </a>
<a name="ln4022">  /*----------------------------------------------------------------------</a>
<a name="ln4023">   * END OF CLASS: OBMol2Cansmi</a>
<a name="ln4024">   ----------------------------------------------------------------------*/</a>
<a name="ln4025"> </a>
<a name="ln4026"> </a>
<a name="ln4027"> </a>
<a name="ln4028">  /***************************************************************************</a>
<a name="ln4029">   * FUNCTION: CreateCansmiString</a>
<a name="ln4030">   *</a>
<a name="ln4031">   * DESCRIPTION:</a>
<a name="ln4032">   *       Writes the canonical SMILES for a molecule or molecular fragment</a>
<a name="ln4033">   *       to the given buffer.</a>
<a name="ln4034">   *</a>
<a name="ln4035">   *       frag_atoms represents atoms in a fragment of the molecule; the</a>
<a name="ln4036">   *       SMILES will contain those atoms only.</a>
<a name="ln4037">   *</a>
<a name="ln4038">   *       (Note: This is an ordinary public C++ function, not a member</a>
<a name="ln4039">   *       of any class.)</a>
<a name="ln4040">   *</a>
<a name="ln4041">   ***************************************************************************/</a>
<a name="ln4042"> </a>
<a name="ln4043">  void CreateCansmiString(OBMol &amp;mol, std::string &amp;buffer, OBBitVec &amp;frag_atoms, OBConversion* pConv)</a>
<a name="ln4044">  {</a>
<a name="ln4045">    bool canonical = pConv-&gt;IsOption(&quot;c&quot;) != nullptr;</a>
<a name="ln4046"> </a>
<a name="ln4047">    OutOptions options(!pConv-&gt;IsOption(&quot;i&quot;), pConv-&gt;IsOption(&quot;k&quot;),</a>
<a name="ln4048">      pConv-&gt;IsOption(&quot;a&quot;),</a>
<a name="ln4049">      pConv-&gt;IsOption(&quot;h&quot;), pConv-&gt;IsOption(&quot;s&quot;),</a>
<a name="ln4050">      pConv-&gt;IsOption(&quot;o&quot;));</a>
<a name="ln4051"> </a>
<a name="ln4052">    OBMol2Cansmi m2s(options);</a>
<a name="ln4053">    m2s.Init(&amp;mol, canonical, pConv);</a>
<a name="ln4054"> </a>
<a name="ln4055">    if (options.isomeric) {</a>
<a name="ln4056">      PerceiveStereo(&amp;mol);</a>
<a name="ln4057">      m2s.CreateCisTrans(mol); // No need for this if not iso</a>
<a name="ln4058">    }</a>
<a name="ln4059">    else {</a>
<a name="ln4060">      // Not isomeric - be sure there are no Z coordinates, clear</a>
<a name="ln4061">      // all stereo-center and cis/trans information.</a>
<a name="ln4062">      OBBond *bond;</a>
<a name="ln4063">      vector&lt;OBBond*&gt;::iterator bi;</a>
<a name="ln4064">      for (bond = mol.BeginBond(bi); bond; bond = mol.NextBond(bi)) {</a>
<a name="ln4065">        bond-&gt;SetHash(false);</a>
<a name="ln4066">        bond-&gt;SetWedge(false);</a>
<a name="ln4067">      }</a>
<a name="ln4068">    }</a>
<a name="ln4069"> </a>
<a name="ln4070">    if (!options.showexplicitH) {</a>
<a name="ln4071">      // If the fragment includes explicit hydrogens, exclude them.</a>
<a name="ln4072">      // They won't appear in the SMILES anyway (unless they're attached to</a>
<a name="ln4073">      // a chiral center, or it's something like [H][H]).</a>
<a name="ln4074">      FOR_ATOMS_OF_MOL(iatom, mol) {</a>
<a name="ln4075">        OBAtom *atom = &amp;(*iatom);</a>
<a name="ln4076">        if (frag_atoms.BitIsSet(atom-&gt;GetIdx()) &amp;&amp; atom-&gt;GetAtomicNum() == OBElements::Hydrogen</a>
<a name="ln4077">          &amp;&amp; (!options.isomeric || m2s.IsSuppressedHydrogen(atom))) {</a>
<a name="ln4078">          frag_atoms.SetBitOff(atom-&gt;GetIdx());</a>
<a name="ln4079">        }</a>
<a name="ln4080">      }</a>
<a name="ln4081">    }</a>
<a name="ln4082"> </a>
<a name="ln4083">    m2s.CreateFragCansmiString(mol, frag_atoms, buffer);</a>
<a name="ln4084"> </a>
<a name="ln4085">    if (pConv-&gt;IsOption(&quot;O&quot;)) { // record smiles atom order info</a>
<a name="ln4086">      // This atom order data is useful not just for canonical SMILES</a>
<a name="ln4087">      // Could also save canonical bond order if anyone desires</a>
<a name="ln4088">      OBPairData *canData;</a>
<a name="ln4089">      if (!mol.HasData(&quot;SMILES Atom Order&quot;)) {</a>
<a name="ln4090">        // Create new OBPairData</a>
<a name="ln4091">        canData = new OBPairData;</a>
<a name="ln4092">        canData-&gt;SetAttribute(&quot;SMILES Atom Order&quot;);</a>
<a name="ln4093">        canData-&gt;SetOrigin(OpenBabel::local);</a>
<a name="ln4094">        mol.SetData(canData);</a>
<a name="ln4095">      }</a>
<a name="ln4096">      else {</a>
<a name="ln4097">        // Recanonicalizing - update existing new OBPairData</a>
<a name="ln4098">        canData = (OBPairData *)mol.GetData(&quot;SMILES Atom Order&quot;);</a>
<a name="ln4099">      }</a>
<a name="ln4100">      std::string atmorder;</a>
<a name="ln4101">      m2s.GetOutputOrder(atmorder);</a>
<a name="ln4102">      canData-&gt;SetValue(atmorder);</a>
<a name="ln4103">    }</a>
<a name="ln4104">  }</a>
<a name="ln4105"> </a>
<a name="ln4106">  bool SMIBaseFormat::GetInchifiedSMILESMolecule(OBMol *mol, bool useFixedHRecMet)</a>
<a name="ln4107">  {</a>
<a name="ln4108">    OBConversion MolConv;</a>
<a name="ln4109"> </a>
<a name="ln4110">    OBFormat* pInChIFormat = MolConv.FindFormat(&quot;InChI&quot;);</a>
<a name="ln4111">    if (pInChIFormat == nullptr) {</a>
<a name="ln4112">      obErrorLog.ThrowError(__FUNCTION__, &quot;InChI format not available&quot;, obError);</a>
<a name="ln4113">      return false;</a>
<a name="ln4114">    }</a>
<a name="ln4115">    stringstream newstream;</a>
<a name="ln4116">    MolConv.SetOutStream(&amp;newstream);</a>
<a name="ln4117">    if (useFixedHRecMet) {</a>
<a name="ln4118">      MolConv.AddOption(&quot;w&quot;, OBConversion::OUTOPTIONS);</a>
<a name="ln4119">      MolConv.AddOption(&quot;X&quot;, OBConversion::OUTOPTIONS, &quot;RecMet FixedH&quot;);</a>
<a name="ln4120">    }</a>
<a name="ln4121">    else</a>
<a name="ln4122">      MolConv.AddOption(&quot;w&quot;, OBConversion::OUTOPTIONS);</a>
<a name="ln4123">    bool success = pInChIFormat-&gt;WriteMolecule(mol, &amp;MolConv);</a>
<a name="ln4124">    if (!success) return false;</a>
<a name="ln4125">    string inchi = newstream.str();</a>
<a name="ln4126">    if (inchi.size() == 0) return false;</a>
<a name="ln4127">    vector&lt;string&gt; vs;</a>
<a name="ln4128">    tokenize(vs, inchi);</a>
<a name="ln4129">    MolConv.SetInFormat(pInChIFormat);</a>
<a name="ln4130">    success = MolConv.ReadString(mol, vs.at(0));</a>
<a name="ln4131">    mol-&gt;DeleteData(&quot;inchi&quot;); // Tidy up this side-effect</a>
<a name="ln4132">    return success;</a>
<a name="ln4133">  }</a>
<a name="ln4134"> </a>
<a name="ln4135">  static const char* NewLine()</a>
<a name="ln4136">  {</a>
<a name="ln4137">#ifdef _WIN32</a>
<a name="ln4138">    return &quot;\r\n&quot;;</a>
<a name="ln4139">#else</a>
<a name="ln4140">    return &quot;\n&quot;;</a>
<a name="ln4141">#endif</a>
<a name="ln4142">  }</a>
<a name="ln4143"> </a>
<a name="ln4144">  //////////////////////////////////////////////////</a>
<a name="ln4145">  bool SMIBaseFormat::WriteMolecule(OBBase* pOb,OBConversion* pConv)</a>
<a name="ln4146">  {</a>
<a name="ln4147">    //cout &lt;&lt; &quot;SMIBaseFromat::WriteMolecule()&quot; &lt;&lt; endl;</a>
<a name="ln4148">    OBMol* pmol = dynamic_cast&lt;OBMol*&gt;(pOb);</a>
<a name="ln4149"> </a>
<a name="ln4150">    // Define some references so we can use the old parameter names</a>
<a name="ln4151">    ostream &amp;ofs = *pConv-&gt;GetOutStream();</a>
<a name="ln4152"> </a>
<a name="ln4153">    // Inchified SMILES? If so, then replace mol with the new 'normalised' one</a>
<a name="ln4154">    if (pConv-&gt;IsOption(&quot;I&quot;)) {</a>
<a name="ln4155">      bool success = GetInchifiedSMILESMolecule(pmol, false);</a>
<a name="ln4156">      if (!success) {</a>
<a name="ln4157">        ofs &lt;&lt; NewLine();</a>
<a name="ln4158">        obErrorLog.ThrowError(__FUNCTION__, &quot;Cannot generate Universal NSMILES for this molecule&quot;, obError);</a>
<a name="ln4159">        return false;</a>
<a name="ln4160">      }</a>
<a name="ln4161">    }</a>
<a name="ln4162"> </a>
<a name="ln4163">    // Title only option?</a>
<a name="ln4164">    if(pConv-&gt;IsOption(&quot;t&quot;)) {</a>
<a name="ln4165">      ofs &lt;&lt; pmol-&gt;GetTitle() &lt;&lt; NewLine();</a>
<a name="ln4166">      return true;</a>
<a name="ln4167">    }</a>
<a name="ln4168"> </a>
<a name="ln4169">    // Option 'x' needs &quot;SMILES Atom Order&quot; to be set</a>
<a name="ln4170">    // FIXME: When we support features of CXN extended SMILES</a>
<a name="ln4171">    //        we can rewrite this</a>
<a name="ln4172">    if (pConv-&gt;IsOption(&quot;x&quot;))</a>
<a name="ln4173">      pConv-&gt;AddOption(&quot;O&quot;);</a>
<a name="ln4174"> </a>
<a name="ln4175">    std::string buffer;</a>
<a name="ln4176">    buffer.reserve(1000);</a>
<a name="ln4177"> </a>
<a name="ln4178">    // If there is data attached called &quot;SMILES_Fragment&quot;, then it's</a>
<a name="ln4179">    // an ascii OBBitVec, representing the atoms of a fragment.  The</a>
<a name="ln4180">    // SMILES generated will only include these fragment atoms.</a>
<a name="ln4181"> </a>
<a name="ln4182">    OBBitVec fragatoms(pmol-&gt;NumAtoms());</a>
<a name="ln4183"> </a>
<a name="ln4184">    OBPairData *dp = (OBPairData *) pmol-&gt;GetData(&quot;SMILES_Fragment&quot;);</a>
<a name="ln4185">    const char* ppF = pConv-&gt;IsOption(&quot;F&quot;);</a>
<a name="ln4186">    if (dp) {</a>
<a name="ln4187">      fragatoms.FromString(dp-&gt;GetValue(), pmol-&gt;NumAtoms());</a>
<a name="ln4188">    }</a>
<a name="ln4189">    else if (ppF) { // Use info from option &quot;F&quot;</a>
<a name="ln4190">      fragatoms.FromString(ppF, pmol-&gt;NumAtoms());</a>
<a name="ln4191">    }</a>
<a name="ln4192">    // If no &quot;SMILES_Fragment&quot; data, fill the entire OBBitVec</a>
<a name="ln4193">    // with 1's so that the SMILES will be for the whole molecule.</a>
<a name="ln4194">    else {</a>
<a name="ln4195">      FOR_ATOMS_OF_MOL(a, *pmol)</a>
<a name="ln4196">        {</a>
<a name="ln4197">          fragatoms.SetBitOn(a-&gt;GetIdx());</a>
<a name="ln4198">        }</a>
<a name="ln4199">    }</a>
<a name="ln4200"> </a>
<a name="ln4201">    if (pmol-&gt;NumAtoms() &gt; 0 || pmol-&gt;IsReaction()) {</a>
<a name="ln4202">      CreateCansmiString(*pmol, buffer, fragatoms, pConv);</a>
<a name="ln4203">    }</a>
<a name="ln4204"> </a>
<a name="ln4205">    bool writenewline = false;</a>
<a name="ln4206">    if(!pConv-&gt;IsOption(&quot;smilesonly&quot;)) {</a>
<a name="ln4207"> </a>
<a name="ln4208">      if(!pConv-&gt;IsOption(&quot;n&quot;)) {</a>
<a name="ln4209">        buffer += '\t';</a>
<a name="ln4210">        buffer += pmol-&gt;GetTitle();</a>
<a name="ln4211">      }</a>
<a name="ln4212"> </a>
<a name="ln4213">      if (pConv-&gt;IsOption(&quot;x&quot;) &amp;&amp; pmol-&gt;HasData(&quot;SMILES Atom Order&quot;)) {</a>
<a name="ln4214">        vector&lt;string&gt; vs;</a>
<a name="ln4215">        string canorder = pmol-&gt;GetData(&quot;SMILES Atom Order&quot;)-&gt;GetValue();</a>
<a name="ln4216">        tokenize(vs, canorder);</a>
<a name="ln4217">        buffer += '\t';</a>
<a name="ln4218">        char tmp[15];</a>
<a name="ln4219">        for (unsigned int i = 0; i &lt; vs.size(); i++) {</a>
<a name="ln4220">          int idx = atoi(vs[i].c_str());</a>
<a name="ln4221">          OBAtom *atom = pmol-&gt;GetAtom(idx);</a>
<a name="ln4222">          if (i &gt; 0)</a>
<a name="ln4223">            buffer += ',';</a>
<a name="ln4224">          snprintf(tmp, 15, &quot;%.4f&quot;, atom-&gt;GetX());</a>
<a name="ln4225">          buffer += tmp;</a>
<a name="ln4226">          buffer += ',';</a>
<a name="ln4227">          snprintf(tmp, 15, &quot;%.4f&quot;, atom-&gt;GetY());</a>
<a name="ln4228">          buffer += tmp;</a>
<a name="ln4229">        }</a>
<a name="ln4230">      }</a>
<a name="ln4231"> </a>
<a name="ln4232">      if(!pConv-&gt;IsOption(&quot;nonewline&quot;))</a>
<a name="ln4233">        writenewline = true;</a>
<a name="ln4234">    }</a>
<a name="ln4235"> </a>
<a name="ln4236">    ofs &lt;&lt; buffer;</a>
<a name="ln4237">    if (writenewline)</a>
<a name="ln4238">      ofs &lt;&lt; NewLine();</a>
<a name="ln4239"> </a>
<a name="ln4240">    return true;</a>
<a name="ln4241">  }</a>
<a name="ln4242"> </a>
<a name="ln4243">  //********************************************************</a>
<a name="ln4244">  class FIXFormat : public OBMoleculeFormat</a>
<a name="ln4245">  {</a>
<a name="ln4246">  public:</a>
<a name="ln4247">    //Register this format type ID</a>
<a name="ln4248">    FIXFormat()</a>
<a name="ln4249">    {</a>
<a name="ln4250">      OBConversion::RegisterFormat(&quot;fix&quot;,this);</a>
<a name="ln4251">    }</a>
<a name="ln4252"> </a>
<a name="ln4253">    virtual const char* Description() //required</a>
<a name="ln4254">    {</a>
<a name="ln4255">      return</a>
<a name="ln4256">        &quot;SMILES FIX format\n&quot;</a>
<a name="ln4257">        &quot;  No comments yet\n&quot;;</a>
<a name="ln4258">    };</a>
<a name="ln4259"> </a>
<a name="ln4260">    virtual const char* SpecificationURL()</a>
<a name="ln4261">    {return &quot;&quot;;}; //optional</a>
<a name="ln4262"> </a>
<a name="ln4263">    //Flags() can return be any the following combined by | or be omitted if none apply</a>
<a name="ln4264">    // NOTREADABLE  READONEONLY  NOTWRITABLE  WRITEONEONLY</a>
<a name="ln4265">    virtual unsigned int Flags()</a>
<a name="ln4266">    {</a>
<a name="ln4267">      return NOTREADABLE;</a>
<a name="ln4268">    };</a>
<a name="ln4269"> </a>
<a name="ln4270">    ////////////////////////////////////////////////////</a>
<a name="ln4271">    /// The &quot;API&quot; interface functions</a>
<a name="ln4272">    virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln4273"> </a>
<a name="ln4274">  };</a>
<a name="ln4275"> </a>
<a name="ln4276">  //Make an instance of the format class</a>
<a name="ln4277">  FIXFormat theFIXFormat;</a>
<a name="ln4278"> </a>
<a name="ln4279">  /////////////////////////////////////////////////////////////////</a>
<a name="ln4280"> </a>
<a name="ln4281">  bool FIXFormat::WriteMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln4282">  {</a>
<a name="ln4283">    OBMol* pmol = dynamic_cast&lt;OBMol*&gt;(pOb);</a>
<a name="ln4284">    if (pmol == nullptr)</a>
<a name="ln4285">      return false;</a>
<a name="ln4286"> </a>
<a name="ln4287">    //Define some references so we can use the old parameter names</a>
<a name="ln4288">    ostream &amp;ofs = *pConv-&gt;GetOutStream();</a>
<a name="ln4289">    OBMol &amp;mol = *pmol;</a>
<a name="ln4290"> </a>
<a name="ln4291">    std::string buffer;</a>
<a name="ln4292">    OutOptions options(!pConv-&gt;IsOption(&quot;i&quot;), pConv-&gt;IsOption(&quot;k&quot;),</a>
<a name="ln4293">      pConv-&gt;IsOption(&quot;a&quot;),</a>
<a name="ln4294">      pConv-&gt;IsOption(&quot;h&quot;), pConv-&gt;IsOption(&quot;s&quot;),</a>
<a name="ln4295">      pConv-&gt;IsOption(&quot;o&quot;));</a>
<a name="ln4296">    OBMol2Cansmi m2s(options);</a>
<a name="ln4297"> </a>
<a name="ln4298">    m2s.Init(pmol, true, pConv);</a>
<a name="ln4299"> </a>
<a name="ln4300">    // We're outputting a full molecule</a>
<a name="ln4301">    // so we pass a bitvec for all atoms</a>
<a name="ln4302">    OBBitVec allbits(mol.NumAtoms());</a>
<a name="ln4303">    FOR_ATOMS_OF_MOL(a, mol) {</a>
<a name="ln4304">      allbits.SetBitOn(a-&gt;GetIdx());</a>
<a name="ln4305">    }</a>
<a name="ln4306"> </a>
<a name="ln4307">    if (mol.NumAtoms() &gt; 0) {</a>
<a name="ln4308">      CreateCansmiString(mol, buffer, allbits, pConv);</a>
<a name="ln4309">    }</a>
<a name="ln4310">    ofs &lt;&lt; buffer &lt;&lt; endl;</a>
<a name="ln4311"> </a>
<a name="ln4312">    OBAtom *atom;</a>
<a name="ln4313">    vector&lt;int&gt;::iterator i;</a>
<a name="ln4314">    // Retrieve the canonical order of the molecule</a>
<a name="ln4315">    std::string orderString;</a>
<a name="ln4316">    m2s.GetOutputOrder(orderString);</a>
<a name="ln4317">    vector&lt;string&gt; canonical_order;</a>
<a name="ln4318">    tokenize(canonical_order, orderString);</a>
<a name="ln4319"> </a>
<a name="ln4320">    int j;</a>
<a name="ln4321">    int atomIdx;</a>
<a name="ln4322">    char coords[100];</a>
<a name="ln4323">    for (j = 0;j &lt; mol.NumConformers();j++)</a>
<a name="ln4324">      {</a>
<a name="ln4325">        mol.SetConformer(j);</a>
<a name="ln4326">        for (unsigned int index = 0; index &lt; canonical_order.size();</a>
<a name="ln4327">             ++index) {</a>
<a name="ln4328">          atomIdx = atoi(canonical_order[index].c_str());</a>
<a name="ln4329">          atom = mol.GetAtom(atomIdx);</a>
<a name="ln4330">          snprintf(coords, 100, &quot;%9.3f %9.3f %9.3f&quot;, atom-&gt;GetX(), atom-&gt;GetY(), atom-&gt;GetZ());</a>
<a name="ln4331">          ofs &lt;&lt; coords &lt;&lt; endl;</a>
<a name="ln4332">        }</a>
<a name="ln4333">      }</a>
<a name="ln4334">    return(true);</a>
<a name="ln4335">  }</a>
<a name="ln4336"> </a>
<a name="ln4337">} // end namespace OpenBabel</a>

</code></pre>
<div class="balloon" rel="827"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'stereo' used.</p></div>
<div class="balloon" rel="2955"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!atomConfig.specified' and 'atomConfig.specified'. </p></div>
<div class="balloon" rel="4165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'pmol'.</p></div>
<div class="balloon" rel="318"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _updown, _order, _prev, _ptr, chiralWatch, squarePlanarWatch.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

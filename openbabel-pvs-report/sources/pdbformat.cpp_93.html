
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pdbformat.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**********************************************************************</a>
<a name="ln2">Copyright (C) 1998-2001 by OpenEye Scientific Software, Inc.</a>
<a name="ln3">Some portions Copyright (C) 2003-2006 Geoffrey R. Hutchison</a>
<a name="ln4">Some portions Copyright (C) 2004 by Chris Morley</a>
<a name="ln5"> </a>
<a name="ln6">This program is free software; you can redistribute it and/or modify</a>
<a name="ln7">it under the terms of the GNU General Public License as published by</a>
<a name="ln8">the Free Software Foundation version 2 of the License.</a>
<a name="ln9"> </a>
<a name="ln10">This program is distributed in the hope that it will be useful,</a>
<a name="ln11">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">GNU General Public License for more details.</a>
<a name="ln14">***********************************************************************/</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;openbabel/babelconfig.h&gt;</a>
<a name="ln17">#include &lt;openbabel/obmolecformat.h&gt;</a>
<a name="ln18">#include &lt;openbabel/obfunctions.h&gt;</a>
<a name="ln19">#include &lt;openbabel/mol.h&gt;</a>
<a name="ln20">#include &lt;openbabel/atom.h&gt;</a>
<a name="ln21">#include &lt;openbabel/bond.h&gt;</a>
<a name="ln22">#include &lt;openbabel/obiter.h&gt;</a>
<a name="ln23">#include &lt;openbabel/elements.h&gt;</a>
<a name="ln24">#include &lt;openbabel/generic.h&gt;</a>
<a name="ln25">#include &lt;openbabel/data.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;vector&gt;</a>
<a name="ln28">#include &lt;map&gt;</a>
<a name="ln29">#include &lt;cstdlib&gt;</a>
<a name="ln30">#include &lt;algorithm&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;sstream&gt;</a>
<a name="ln33"> </a>
<a name="ln34">using namespace std;</a>
<a name="ln35">namespace OpenBabel</a>
<a name="ln36">{</a>
<a name="ln37">  class PDBFormat : public OBMoleculeFormat</a>
<a name="ln38">  {</a>
<a name="ln39">  public:</a>
<a name="ln40">    //Register this format type ID</a>
<a name="ln41">    PDBFormat()</a>
<a name="ln42">    { </a>
<a name="ln43">      OBConversion::RegisterFormat(&quot;pdb&quot;,this, &quot;chemical/x-pdb&quot;);</a>
<a name="ln44">      OBConversion::RegisterFormat(&quot;ent&quot;,this, &quot;chemical/x-pdb&quot;);</a>
<a name="ln45"> </a>
<a name="ln46">      OBConversion::RegisterOptionParam(&quot;s&quot;, this, 0, OBConversion::INOPTIONS);</a>
<a name="ln47">      OBConversion::RegisterOptionParam(&quot;b&quot;, this, 0, OBConversion::INOPTIONS);</a>
<a name="ln48">      OBConversion::RegisterOptionParam(&quot;c&quot;, this, 0, OBConversion::INOPTIONS);</a>
<a name="ln49"> </a>
<a name="ln50">      OBConversion::RegisterOptionParam(&quot;o&quot;, this, 0, OBConversion::OUTOPTIONS);</a>
<a name="ln51">      OBConversion::RegisterOptionParam(&quot;n&quot;, this, 0, OBConversion::OUTOPTIONS);</a>
<a name="ln52">    }</a>
<a name="ln53"> </a>
<a name="ln54">    virtual const char* Description() //required</a>
<a name="ln55">    {</a>
<a name="ln56">      return</a>
<a name="ln57">        &quot;Protein Data Bank format\n&quot;</a>
<a name="ln58">        &quot;Read Options e.g. -as\n&quot;</a>
<a name="ln59">        &quot;  s  Output single bonds only\n&quot;</a>
<a name="ln60">        &quot;  b  Disable bonding entirely\n&quot;</a>
<a name="ln61">        &quot;  c  Ignore CONECT records\n\n&quot;</a>
<a name="ln62"> </a>
<a name="ln63">        &quot;Write Options, e.g. -xo\n&quot;</a>
<a name="ln64">        &quot;  n  Do not write duplicate CONECT records to indicate bond order\n&quot;</a>
<a name="ln65">        &quot;  o  Write origin in space group label (CRYST1 section)\n\n&quot;;</a>
<a name="ln66">    };</a>
<a name="ln67"> </a>
<a name="ln68">    virtual const char* SpecificationURL()</a>
<a name="ln69">    { return &quot;http://www.wwpdb.org/docs.html&quot;;};</a>
<a name="ln70"> </a>
<a name="ln71">    virtual const char* GetMIMEType()</a>
<a name="ln72">    { return &quot;chemical/x-pdb&quot;; };</a>
<a name="ln73"> </a>
<a name="ln74">    //*** This section identical for most OBMol conversions ***</a>
<a name="ln75">    ////////////////////////////////////////////////////</a>
<a name="ln76">    /// The &quot;API&quot; interface functions</a>
<a name="ln77">  	virtual int SkipObjects(int n, OBConversion* pConv);</a>
<a name="ln78">    virtual bool ReadMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln79">    virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv);</a>
<a name="ln80"> </a>
<a name="ln81">  };</a>
<a name="ln82">  //***</a>
<a name="ln83"> </a>
<a name="ln84">  //Make an instance of the format class</a>
<a name="ln85">  PDBFormat thePDBFormat;</a>
<a name="ln86"> </a>
<a name="ln87">  ////////////////////////////////////////////////////</a>
<a name="ln88">  /// Utility functions</a>
<a name="ln89">  static void fixRhombohedralSpaceGroupWriter(string &amp;strHM);</a>
<a name="ln90">  static void fixRhombohedralSpaceGroupReader(string &amp;strHM);</a>
<a name="ln91">  static bool parseAtomRecord(char *buffer, OBMol &amp; mol, int chainNum);</a>
<a name="ln92">  static bool parseConectRecord(char *buffer, OBMol &amp; mol);</a>
<a name="ln93">  static bool readIntegerFromRecord(char *buffer, unsigned int columnAsSpecifiedInPDB, long int *target);</a>
<a name="ln94"> </a>
<a name="ln95">  //extern OBResidueData    resdat; now in mol.h</a>
<a name="ln96"> </a>
<a name="ln97">  /////////////////////////////////////////////////////////////////</a>
<a name="ln98"> 	int PDBFormat::SkipObjects(int n, OBConversion* pConv)</a>
<a name="ln99">  {</a>
<a name="ln100">    if (n == 0)</a>
<a name="ln101">      ++ n;</a>
<a name="ln102">    istream &amp;ifs = *pConv-&gt;GetInStream();</a>
<a name="ln103">    char buffer[BUFF_SIZE];</a>
<a name="ln104">    while (n &amp;&amp; ifs.getline(buffer,BUFF_SIZE))</a>
<a name="ln105">      {</a>
<a name="ln106">        if (EQn(buffer,&quot;ENDMDL&quot;,6))</a>
<a name="ln107">          -- n;</a>
<a name="ln108">      }</a>
<a name="ln109"> </a>
<a name="ln110">    return ifs.good() ? 1 : -1;</a>
<a name="ln111">  }</a>
<a name="ln112">  /////////////////////////////////////////////////////////////////</a>
<a name="ln113">   template &lt;typename T&gt; string to_string(T pNumber)</a>
<a name="ln114">  {</a>
<a name="ln115">    ostringstream oOStrStream;</a>
<a name="ln116">    oOStrStream &lt;&lt; pNumber;</a>
<a name="ln117">    return oOStrStream.str();</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  /////////////////////////////////////////////////////////////////</a>
<a name="ln121">  bool PDBFormat::ReadMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln122">  {</a>
<a name="ln123"> </a>
<a name="ln124">    OBMol* pmol = pOb-&gt;CastAndClear&lt;OBMol&gt;();</a>
<a name="ln125">    if (pmol == nullptr)</a>
<a name="ln126">      return false;</a>
<a name="ln127"> </a>
<a name="ln128">    //Define some references so we can use the old parameter names</a>
<a name="ln129">    istream &amp;ifs = *pConv-&gt;GetInStream();</a>
<a name="ln130">    OBMol &amp;mol = *pmol;</a>
<a name="ln131">    const char* title = pConv-&gt;GetTitle();</a>
<a name="ln132"> </a>
<a name="ln133">    int chainNum = 1;</a>
<a name="ln134">    char buffer[BUFF_SIZE] = {0,};</a>
<a name="ln135">    string line, key, value;</a>
<a name="ln136">    OBPairData *dp;</a>
<a name="ln137"> </a>
<a name="ln138">    mol.SetTitle(title);</a>
<a name="ln139">    // We need to prevent chains perception routines from running while</a>
<a name="ln140">    // we are adding residues from the PDB file</a>
<a name="ln141">    mol.SetChainsPerceived();</a>
<a name="ln142"> </a>
<a name="ln143">    mol.BeginModify();</a>
<a name="ln144">    bool ateend = false;</a>
<a name="ln145">    while (ifs.good() &amp;&amp; ifs.getline(buffer,BUFF_SIZE))</a>
<a name="ln146">      {</a>
<a name="ln147">        if (EQn(buffer,&quot;ENDMDL&quot;,6)) {</a>
<a name="ln148">          ateend = true;</a>
<a name="ln149">          break;</a>
<a name="ln150">        }</a>
<a name="ln151">        if (EQn(buffer,&quot;END&quot;,3)) {</a>
<a name="ln152">          // eat anything until the next ENDMDL</a>
<a name="ln153">          while (ifs.getline(buffer,BUFF_SIZE) &amp;&amp; !EQn(buffer,&quot;ENDMDL&quot;,6));</a>
<a name="ln154">          ateend = true;</a>
<a name="ln155">          break;</a>
<a name="ln156">        }</a>
<a name="ln157">        if (EQn(buffer,&quot;TER&quot;,3)) {</a>
<a name="ln158">          chainNum++;</a>
<a name="ln159">          continue;</a>
<a name="ln160">        }</a>
<a name="ln161">        if (EQn(buffer,&quot;ATOM&quot;,4) || EQn(buffer,&quot;HETATM&quot;,6))</a>
<a name="ln162">          {</a>
<a name="ln163">            if( ! parseAtomRecord(buffer,mol,chainNum))</a>
<a name="ln164">              {</a>
<a name="ln165">                stringstream errorMsg;</a>
<a name="ln166">                errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file\n&quot;</a>
<a name="ln167">                         &lt;&lt; &quot;  Problems reading a ATOM/HETATM record.\n&quot;;</a>
<a name="ln168">                obErrorLog.ThrowError(__FUNCTION__, errorMsg.str() , obError);</a>
<a name="ln169">              }</a>
<a name="ln170">            continue;</a>
<a name="ln171">          }</a>
<a name="ln172"> </a>
<a name="ln173">        if (EQn(buffer,&quot;CONECT&quot;,6)) {</a>
<a name="ln174">          // Don't parse a CONECT record if the user tells us to ignore them</a>
<a name="ln175">          if (!pConv-&gt;IsOption(&quot;c&quot;,OBConversion::INOPTIONS)) {</a>
<a name="ln176">            parseConectRecord(buffer,mol);</a>
<a name="ln177">            continue;</a>
<a name="ln178">          }</a>
<a name="ln179">        }</a>
<a name="ln180"> </a>
<a name="ln181">        // crystal cells</a>
<a name="ln182">        if (EQn(buffer,&quot;CRYST1&quot;,6)) {</a>
<a name="ln183">          float a, b, c, alpha, beta, gamma;</a>
<a name="ln184">          string group = &quot;&quot;;</a>
<a name="ln185"> </a>
<a name="ln186">          sscanf (&amp;(buffer[6]), &quot;%9f%9f%9f%7f%7f%7f&quot;, &amp;a, &amp;b, &amp;c,</a>
<a name="ln187">                  &amp;alpha, &amp;beta, &amp;gamma);</a>
<a name="ln188">          buffer[66] = '\0';</a>
<a name="ln189">          group += &amp;(buffer[55]);</a>
<a name="ln190">          Trim (group);</a>
<a name="ln191">          fixRhombohedralSpaceGroupReader(group);</a>
<a name="ln192"> </a>
<a name="ln193">          OBUnitCell *pCell=new OBUnitCell;</a>
<a name="ln194">          pCell-&gt;SetOrigin(fileformatInput);</a>
<a name="ln195">          pCell-&gt;SetData(a,b,c,alpha,beta,gamma);</a>
<a name="ln196">          pCell-&gt;SetSpaceGroup(group);</a>
<a name="ln197">          pmol-&gt;SetData(pCell);</a>
<a name="ln198">          continue;</a>
<a name="ln199">        }</a>
<a name="ln200"> </a>
<a name="ln201">        // another record type, add it as an OBPairData entry</a>
<a name="ln202">        line = buffer;</a>
<a name="ln203">        // if the file is valid, all lines should have more than 6 characters</a>
<a name="ln204">        if (line.length() &lt; 6)</a>
<a name="ln205">          {</a>
<a name="ln206">            stringstream errorMsg;</a>
<a name="ln207">            errorMsg &lt;&lt; &quot;ERROR: not a valid PDB file&quot; &lt;&lt; endl;</a>
<a name="ln208">            obErrorLog.ThrowError(__FUNCTION__, errorMsg.str() , obError);</a>
<a name="ln209">            return false;</a>
<a name="ln210">          }</a>
<a name="ln211">        key = line.substr(0,6); // the first 6 characters are the record name</a>
<a name="ln212">        Trim(key);</a>
<a name="ln213">        value = line.substr(6);</a>
<a name="ln214"> </a>
<a name="ln215">        // We haven't found this record yet</a>
<a name="ln216">        if (!mol.HasData(key)) {</a>
<a name="ln217">          dp = new OBPairData;</a>
<a name="ln218">          dp-&gt;SetAttribute(key);</a>
<a name="ln219">          dp-&gt;SetValue(value);</a>
<a name="ln220">          dp-&gt;SetOrigin(fileformatInput);</a>
<a name="ln221">          mol.SetData(dp);</a>
<a name="ln222">        }</a>
<a name="ln223">        // Add on additional lines</a>
<a name="ln224">        else {</a>
<a name="ln225">          dp = static_cast&lt;OBPairData*&gt;(mol.GetData(key));</a>
<a name="ln226">          line = dp-&gt;GetValue();</a>
<a name="ln227">          line += '\n';</a>
<a name="ln228">          line += value;</a>
<a name="ln229">          dp-&gt;SetValue(line);</a>
<a name="ln230">        }</a>
<a name="ln231">      }</a>
<a name="ln232"> </a>
<a name="ln233">    if (!mol.NumAtoms()) { // skip the rest of this processing</a>
<a name="ln234">      mol.EndModify();</a>
<a name="ln235">      return ateend; //explicitly empty molecules are not invalid</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">    resdat.AssignBonds(mol);</a>
<a name="ln239">    /*assign hetatm bonds based on distance*/</a>
<a name="ln240"> </a>
<a name="ln241">    mol.EndModify();</a>
<a name="ln242">    // Clear all virtual bond data</a>
<a name="ln243">    vector&lt;OBGenericData*&gt; vbonds = mol.GetAllData(OBGenericDataType::VirtualBondData);</a>
<a name="ln244">    mol.DeleteData(vbonds);</a>
<a name="ln245"> </a>
<a name="ln246">    if (!pConv-&gt;IsOption(&quot;b&quot;,OBConversion::INOPTIONS))</a>
<a name="ln247">      mol.ConnectTheDots();</a>
<a name="ln248"> </a>
<a name="ln249">    if (!pConv-&gt;IsOption(&quot;s&quot;,OBConversion::INOPTIONS) &amp;&amp; !pConv-&gt;IsOption(&quot;b&quot;,OBConversion::INOPTIONS))</a>
<a name="ln250">      mol.PerceiveBondOrders();</a>
<a name="ln251"> </a>
<a name="ln252">    // EndModify() blows away the chains perception flag so we set it again here</a>
<a name="ln253">    mol.SetChainsPerceived();</a>
<a name="ln254"> </a>
<a name="ln255">    // Guess how many hydrogens are present on each atom based on typical valencies</a>
<a name="ln256">    FOR_ATOMS_OF_MOL(matom, mol)</a>
<a name="ln257">      OBAtomAssignTypicalImplicitHydrogens(&amp;*matom);</a>
<a name="ln258"> </a>
<a name="ln259">    // clean out remaining blank lines</a>
<a name="ln260">    std::streampos ipos;</a>
<a name="ln261">    do</a>
<a name="ln262">    {</a>
<a name="ln263">      ipos = ifs.tellg();</a>
<a name="ln264">      ifs.getline(buffer,BUFF_SIZE);</a>
<a name="ln265">    }</a>
<a name="ln266">    while(strlen(buffer) == 0 &amp;&amp; !ifs.eof() );</a>
<a name="ln267">    ifs.seekg(ipos);</a>
<a name="ln268"> </a>
<a name="ln269">    return(true);</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  /////////////////////////////////////////////////////////////////////////</a>
<a name="ln273">  //! Utility function to read a 5-digit integer starting from a specified column</a>
<a name="ln274">  /*! This function reads a 5-digit integer, starting from column</a>
<a name="ln275">    columnAsSpecifiedInPDB from the buffer, converts it to a long</a>
<a name="ln276">    integer, and returns either false or true, if the conversion was</a>
<a name="ln277">    successful or not. If the conversion was not successful, the target</a>
<a name="ln278">    is set to a random value.</a>
<a name="ln279"> </a>
<a name="ln280">    For instance, the PDB Format Description for a CONECT record specifies</a>
<a name="ln281"> </a>
<a name="ln282">    COLUMNS        DATA TYPE        FIELD           DEFINITION</a>
<a name="ln283">    ---------------------------------------------------------------------------------</a>
<a name="ln284">    1 -  6         Record name      &quot;CONECT&quot;</a>
<a name="ln285">    7 - 11         Integer          serial          Atom serial number</a>
<a name="ln286">    ...</a>
<a name="ln287"> </a>
<a name="ln288">    To read the Atom serial number, you would call</a>
<a name="ln289"> </a>
<a name="ln290">    long int target;</a>
<a name="ln291">    if ( readIntegerFromRecord(buffer, 7, &amp;target) == false ) {</a>
<a name="ln292">    cerr &lt;&lt; &quot;Could not parse&quot; &lt;&lt; endl;</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">    This function does not check the length of the buffer, or</a>
<a name="ln296">    strlen(buffer). If the buffer is not long enough =&gt; SEGFAULT.</a>
<a name="ln297">  */</a>
<a name="ln298">  static bool readIntegerFromRecord(char *buffer, unsigned int columnAsSpecifiedInPDB, long int *target)</a>
<a name="ln299">  {</a>
<a name="ln300">    char integerBuffer[6];</a>
<a name="ln301">    integerBuffer[5] = '\0';</a>
<a name="ln302"> </a>
<a name="ln303">    strncpy(integerBuffer, buffer+columnAsSpecifiedInPDB-1, 5);</a>
<a name="ln304"> </a>
<a name="ln305">    char *errorCheckingEndPtr;</a>
<a name="ln306">    *target = strtol(integerBuffer, &amp;errorCheckingEndPtr, 10);</a>
<a name="ln307">    if (integerBuffer == errorCheckingEndPtr)</a>
<a name="ln308">      return(false);</a>
<a name="ln309">    return(true);</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  //! Read a CONECT record</a>
<a name="ln313">  /*! This function reads a CONECT record, as specified</a>
<a name="ln314">    http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html,</a>
<a name="ln315">    in short:</a>
<a name="ln316"> </a>
<a name="ln317">    COLUMNS         DATA TYPE        FIELD           DEFINITION</a>
<a name="ln318">    ---------------------------------------------------------------------------------</a>
<a name="ln319">    1 -  6         Record name      &quot;CONECT&quot;</a>
<a name="ln320">    7 - 11         Integer          serial          Atom serial number</a>
<a name="ln321">    12 - 16         Integer          serial          Serial number of bonded atom</a>
<a name="ln322">    17 - 21         Integer          serial          Serial number of bonded atom</a>
<a name="ln323">    22 - 26         Integer          serial          Serial number of bonded atom</a>
<a name="ln324">    27 - 31         Integer          serial          Serial number of bonded atom</a>
<a name="ln325">    32 - 36         Integer          serial          Serial number of hydrogen bonded atom</a>
<a name="ln326">    37 - 41         Integer          serial          Serial number of hydrogen bonded atom</a>
<a name="ln327">    42 - 46         Integer          serial          Serial number of salt bridged atom</a>
<a name="ln328">    47 - 51         Integer          serial          Serial number of hydrogen bonded atom</a>
<a name="ln329">    52 - 56         Integer          serial          Serial number of hydrogen bonded atom</a>
<a name="ln330">    57 - 61         Integer          serial          Serial number of salt bridged atom</a>
<a name="ln331"> </a>
<a name="ln332">    Hydrogen bonds and salt bridges are ignored. --Stefan Kebekus.</a>
<a name="ln333">  */</a>
<a name="ln334"> </a>
<a name="ln335">  bool parseConectRecord(char *buffer,OBMol &amp;mol)</a>
<a name="ln336">  {</a>
<a name="ln337">    stringstream errorMsg;</a>
<a name="ln338">    string clearError;</a>
<a name="ln339"> </a>
<a name="ln340">    // Setup strings and string buffers</a>
<a name="ln341">    vector&lt;string&gt; vs;</a>
<a name="ln342">    buffer[70] = '\0';</a>
<a name="ln343">    if (strlen(buffer) &lt; 70)</a>
<a name="ln344">      {</a>
<a name="ln345">        errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file\n&quot;</a>
<a name="ln346">                 &lt;&lt; &quot;  Problems reading a CONECT record.\n&quot;</a>
<a name="ln347">                 &lt;&lt; &quot;  According to the PDB specification,\n&quot;</a>
<a name="ln348">                 &lt;&lt; &quot;  the record should have 70 columns, but OpenBabel found &quot;</a>
<a name="ln349">                 &lt;&lt; strlen(buffer) &lt;&lt; &quot; columns.&quot; &lt;&lt; endl;</a>
<a name="ln350">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str() , obInfo);</a>
<a name="ln351">        errorMsg.str(clearError);</a>
<a name="ln352">      }</a>
<a name="ln353"> </a>
<a name="ln354">    // Serial number of the first atom, read from column 7-11 of the</a>
<a name="ln355">    // connect record, to which the other atoms connect to.</a>
<a name="ln356">    long int startAtomSerialNumber;</a>
<a name="ln357">    // A pointer to the first atom.</a>
<a name="ln358">    OBAtom *firstAtom = nullptr;</a>
<a name="ln359">    // Serial numbers of the atoms which bind to firstAtom, read from</a>
<a name="ln360">    // columns 12-16, 17-21, 22-27 and 27-31 of the connect record. Note</a>
<a name="ln361">    // that we reserve space for 5 integers, but read only four of</a>
<a name="ln362">    // them. This is to simplify the determination of the bond order;</a>
<a name="ln363">    // see below.</a>
<a name="ln364">    long int boundedAtomsSerialNumbers[5]  = {0,0,0,0,0};</a>
<a name="ln365">    // Bools which tell us which of the serial numbers in</a>
<a name="ln366">    // boundedAtomsSerialNumbers are read from the file, and which are</a>
<a name="ln367">    // invalid</a>
<a name="ln368">    bool boundedAtomsSerialNumbersValid[5] = {false, false, false, false, false};</a>
<a name="ln369"> </a>
<a name="ln370">    // Pragmatic approach -- too many non-standard PDB files out there</a>
<a name="ln371">    // (including some old ones from us)</a>
<a name="ln372">    // So if we have a small number of atoms, then try to break by spaces</a>
<a name="ln373">    // Otherwise (i.e., NumAtoms() &gt; 9,999 we need to go by position)</a>
<a name="ln374">    // We'll switch back and forth a few times to save duplicating common code</a>
<a name="ln375"> </a>
<a name="ln376">    if (mol.NumAtoms() &lt;= 9999)</a>
<a name="ln377">      {</a>
<a name="ln378">        // make sure we don't look at salt bridges or whatever, so cut the buffer short</a>
<a name="ln379">        buffer[32] = '\0';</a>
<a name="ln380">        tokenize(vs,buffer);</a>
<a name="ln381">        if( vs.empty() || vs.size() &lt; 2)</a>
<a name="ln382">          return false;</a>
<a name="ln383">        vs.erase(vs.begin()); // remove &quot;CONECT&quot;</a>
<a name="ln384"> </a>
<a name="ln385">        startAtomSerialNumber = atoi(vs[0].c_str());</a>
<a name="ln386">      }</a>
<a name="ln387">    else</a>
<a name="ln388">      {</a>
<a name="ln389">        if (readIntegerFromRecord(buffer, 7, &amp;startAtomSerialNumber) == false)</a>
<a name="ln390">          {</a>
<a name="ln391">            errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file\n&quot;</a>
<a name="ln392">                     &lt;&lt; &quot;  Problems reading a CONECT record.\n&quot;</a>
<a name="ln393">                     &lt;&lt; &quot;  According to the PDB specification,\n&quot;</a>
<a name="ln394">                     &lt;&lt; &quot;  columns 7-11 should contain the serial number of an atom.\n&quot;</a>
<a name="ln395">                     &lt;&lt; &quot;  THIS CONECT RECORD WILL BE IGNORED.&quot; &lt;&lt; endl;</a>
<a name="ln396">            obErrorLog.ThrowError(__FUNCTION__, errorMsg.str() , obWarning);</a>
<a name="ln397">            return(false);</a>
<a name="ln398">          }</a>
<a name="ln399">      }</a>
<a name="ln400"> </a>
<a name="ln401">    vector&lt;OBAtom*&gt;::iterator i;</a>
<a name="ln402">    for (OBAtom *a1 = mol.BeginAtom(i);a1;a1 = mol.NextAtom(i)) {</a>
<a name="ln403">      // atoms may not have residue information, but if they do,</a>
<a name="ln404">      // check serial numbers</a>
<a name="ln405">      if (a1-&gt;GetResidue() != nullptr &amp;&amp;</a>
<a name="ln406">          static_cast&lt;long int&gt;(a1-&gt;GetResidue()-&gt;</a>
<a name="ln407">                                GetSerialNum(a1)) == startAtomSerialNumber)</a>
<a name="ln408">        {</a>
<a name="ln409">          firstAtom = a1;</a>
<a name="ln410">          break;</a>
<a name="ln411">        }</a>
<a name="ln412">    }</a>
<a name="ln413"> </a>
<a name="ln414">    if (firstAtom == nullptr)</a>
<a name="ln415">      {</a>
<a name="ln416">        errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file:\n&quot;</a>
<a name="ln417">                 &lt;&lt; &quot;  Problems reading a CONECT record.\n&quot;</a>
<a name="ln418">                 &lt;&lt; &quot;  According to the PDB specification,\n&quot;</a>
<a name="ln419">                 &lt;&lt; &quot;  columns 7-11 should contain the serial number of an atom.\n&quot;</a>
<a name="ln420">                 &lt;&lt; &quot;  No atom was found with this serial number.\n&quot;</a>
<a name="ln421">                 &lt;&lt; &quot;  THIS CONECT RECORD WILL BE IGNORED.&quot; &lt;&lt; endl;</a>
<a name="ln422">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str() , obWarning);</a>
<a name="ln423">        return(false);</a>
<a name="ln424">      }</a>
<a name="ln425"> </a>
<a name="ln426">    if (mol.NumAtoms() &lt; 9999)</a>
<a name="ln427">      {</a>
<a name="ln428">        if (vs.size() &gt; 1) boundedAtomsSerialNumbers[0] = atoi(vs[1].c_str());</a>
<a name="ln429">        if (vs.size() &gt; 2) boundedAtomsSerialNumbers[1] = atoi(vs[2].c_str());</a>
<a name="ln430">        if (vs.size() &gt; 3) boundedAtomsSerialNumbers[2] = atoi(vs[3].c_str());</a>
<a name="ln431">        if (vs.size() &gt; 4) boundedAtomsSerialNumbers[3] = atoi(vs[4].c_str());</a>
<a name="ln432"> </a>
<a name="ln433">        unsigned int limit = 4;</a>
<a name="ln434">        if (vs.size() &lt;= 4)</a>
<a name="ln435">          limit = vs.size() - 1;</a>
<a name="ln436"> </a>
<a name="ln437">        for (unsigned int s = 0; s &lt; limit; ++s)</a>
<a name="ln438">          boundedAtomsSerialNumbersValid[s] = true;</a>
<a name="ln439">      }</a>
<a name="ln440">    else</a>
<a name="ln441">      {</a>
<a name="ln442">        // Now read the serial numbers. If the first serial number is not</a>
<a name="ln443">        // present, this connect record probably contains only hydrogen</a>
<a name="ln444">        // bonds and salt bridges, which we ignore. In that case, we just</a>
<a name="ln445">        // exit gracefully.</a>
<a name="ln446">        boundedAtomsSerialNumbersValid[0] = readIntegerFromRecord(buffer, 12, boundedAtomsSerialNumbers+0);</a>
<a name="ln447">        if (boundedAtomsSerialNumbersValid[0] == false)</a>
<a name="ln448">          return(true);</a>
<a name="ln449">        boundedAtomsSerialNumbersValid[1] = readIntegerFromRecord(buffer, 17, boundedAtomsSerialNumbers+1);</a>
<a name="ln450">        boundedAtomsSerialNumbersValid[2] = readIntegerFromRecord(buffer, 22, boundedAtomsSerialNumbers+2);</a>
<a name="ln451">        boundedAtomsSerialNumbersValid[3] = readIntegerFromRecord(buffer, 27, boundedAtomsSerialNumbers+3);</a>
<a name="ln452">      }</a>
<a name="ln453"> </a>
<a name="ln454">    // Now iterate over the VALID boundedAtomsSerialNumbers and connect</a>
<a name="ln455">    // the atoms.</a>
<a name="ln456">    for(unsigned int k=0; boundedAtomsSerialNumbersValid[k]; k++)</a>
<a name="ln457">      {</a>
<a name="ln458">        // Find atom that is connected to, write an error message</a>
<a name="ln459">        OBAtom *connectedAtom = nullptr;</a>
<a name="ln460">        for (OBAtom *a1 = mol.BeginAtom(i);a1;a1 = mol.NextAtom(i)) {</a>
<a name="ln461">          // again, atoms may not have residues, but if they do, check serials</a>
<a name="ln462">          if (a1-&gt;GetResidue() != nullptr &amp;&amp;</a>
<a name="ln463">              static_cast&lt;long int&gt;(a1-&gt;GetResidue()-&gt;</a>
<a name="ln464">                                    GetSerialNum(a1)) == boundedAtomsSerialNumbers[k])</a>
<a name="ln465">            {</a>
<a name="ln466">              connectedAtom = a1;</a>
<a name="ln467">              break;</a>
<a name="ln468">            }</a>
<a name="ln469">        }</a>
<a name="ln470">        if (connectedAtom == nullptr)</a>
<a name="ln471">          {</a>
<a name="ln472">            errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file:\n&quot;</a>
<a name="ln473">                     &lt;&lt; &quot;  Problems reading a CONECT record.\n&quot;</a>
<a name="ln474">                     &lt;&lt; &quot;  According to the PDB specification,\n&quot;</a>
<a name="ln475">                     &lt;&lt; &quot;  Atoms with serial #&quot; &lt;&lt; startAtomSerialNumber</a>
<a name="ln476">                     &lt;&lt; &quot; and #&quot; &lt;&lt; boundedAtomsSerialNumbers[k]</a>
<a name="ln477">                     &lt;&lt; &quot; should be connected\n&quot;</a>
<a name="ln478">                     &lt;&lt; &quot;  However, an atom with serial #&quot; &lt;&lt; boundedAtomsSerialNumbers[k] &lt;&lt; &quot; was not found.\n&quot;</a>
<a name="ln479">                     &lt;&lt; &quot;  THIS CONECT RECORD WILL BE IGNORED.&quot; &lt;&lt; endl;</a>
<a name="ln480">            obErrorLog.ThrowError(__FUNCTION__, errorMsg.str() , obWarning);</a>
<a name="ln481">            return(false);</a>
<a name="ln482">          }</a>
<a name="ln483"> </a>
<a name="ln484">        // Figure the bond order</a>
<a name="ln485">        unsigned char order = 0;</a>
<a name="ln486">        while(boundedAtomsSerialNumbersValid[k+order+1] &amp;&amp; (boundedAtomsSerialNumbers[k+order]</a>
<a name="ln487">                                                            == boundedAtomsSerialNumbers[k+order+1]))</a>
<a name="ln488">          order++;</a>
<a name="ln489">        k += order;</a>
<a name="ln490"> </a>
<a name="ln491">        // Generate the bond</a>
<a name="ln492">        if (firstAtom-&gt;GetIdx() &lt; connectedAtom-&gt;GetIdx()) { // record the bond 'in one direction' only</a>
<a name="ln493">          OBBond *bond = mol.GetBond(firstAtom, connectedAtom);</a>
<a name="ln494">          if (!bond)</a>
<a name="ln495">            mol.AddBond(firstAtom-&gt;GetIdx(), connectedAtom-&gt;GetIdx(), order+1);</a>
<a name="ln496">          else // An additional CONECT record with the same firstAtom that references</a>
<a name="ln497">               // a bond created in the previous CONECT record.</a>
<a name="ln498">               // For example, the 1136-&gt;1138 double bond in the following:</a>
<a name="ln499">               //   CONECT 1136 1128 1137 1137 1138</a>
<a name="ln500">               //   CONECT 1136 1138 1139</a>
<a name="ln501">            bond-&gt;SetBondOrder(bond-&gt;GetBondOrder() + order+1);</a>
<a name="ln502">        }</a>
<a name="ln503"> </a>
<a name="ln504">      }</a>
<a name="ln505">    return(true);</a>
<a name="ln506">  }</a>
<a name="ln507"> </a>
<a name="ln508">  //////////////////////////////////////////////////////////////////////////////</a>
<a name="ln509">  bool PDBFormat::WriteMolecule(OBBase* pOb, OBConversion* pConv)</a>
<a name="ln510">  {</a>
<a name="ln511">    OBMol* pmol = dynamic_cast&lt;OBMol*&gt;(pOb);</a>
<a name="ln512">    if (pmol == nullptr)</a>
<a name="ln513">      return false;</a>
<a name="ln514"> </a>
<a name="ln515">    //Define some references so we can use the old parameter names</a>
<a name="ln516">    ostream &amp;ofs = *pConv-&gt;GetOutStream();</a>
<a name="ln517">    OBMol &amp;mol = *pmol;</a>
<a name="ln518"> </a>
<a name="ln519">    unsigned int i;</a>
<a name="ln520">    char buffer[BUFF_SIZE];</a>
<a name="ln521">    char type_name[10], padded_name[10];</a>
<a name="ln522">    char the_res[10];</a>
<a name="ln523">    char the_chain = ' ';</a>
<a name="ln524">    const char *element_name;</a>
<a name="ln525">    int res_num;</a>
<a name="ln526">    char the_insertioncode = ' ';</a>
<a name="ln527">    bool het=true;</a>
<a name="ln528">    int model_num = 0;</a>
<a name="ln529">    const int MAX_HM_NAME_LEN = 11;</a>
<a name="ln530"> </a>
<a name="ln531">    if (!pConv-&gt;IsLast() || pConv-&gt;GetOutputIndex() &gt; 1)</a>
<a name="ln532">      { // More than one molecule record</a>
<a name="ln533">        model_num = pConv-&gt;GetOutputIndex(); // MODEL 1-based index</a>
<a name="ln534">        snprintf(buffer, BUFF_SIZE, &quot;MODEL %8d&quot;, model_num);</a>
<a name="ln535">        ofs &lt;&lt; buffer &lt;&lt; endl;</a>
<a name="ln536">      }</a>
<a name="ln537"> </a>
<a name="ln538">    // write back all fields (REMARKS, HELIX, SHEET, SITE, ...)</a>
<a name="ln539">    bool compndWritten = false;</a>
<a name="ln540">    bool authorWritten = false;</a>
<a name="ln541">    std::vector&lt;OBGenericData*&gt; pairData = mol.GetAllData(OBGenericDataType::PairData);</a>
<a name="ln542">    for (std::vector&lt;OBGenericData*&gt;::iterator data = pairData.begin(); data != pairData.end(); ++data) {</a>
<a name="ln543">      OBPairData *pd = static_cast&lt;OBPairData*&gt;(*data);</a>
<a name="ln544">      string attr = pd-&gt;GetAttribute();</a>
<a name="ln545"> </a>
<a name="ln546">      // filter to make sure we are writing pdb fields only</a>
<a name="ln547">      if (attr != &quot;HEADER&quot; &amp;&amp; attr != &quot;OBSLTE&quot; &amp;&amp; attr != &quot;TITLE&quot; &amp;&amp; attr != &quot;SPLIT&quot; &amp;&amp;</a>
<a name="ln548">          attr != &quot;CAVEAT&quot; &amp;&amp; attr != &quot;COMPND&quot; &amp;&amp; attr != &quot;SOURCE&quot; &amp;&amp; attr != &quot;KEYWDS&quot; &amp;&amp;</a>
<a name="ln549">          attr != &quot;EXPDTA&quot; &amp;&amp; attr != &quot;NUMMDL&quot; &amp;&amp; attr != &quot;MDLTYP&quot; &amp;&amp; attr != &quot;AUTHOR&quot; &amp;&amp;</a>
<a name="ln550">          attr != &quot;REVDAT&quot; &amp;&amp; attr != &quot;SPRSDE&quot; &amp;&amp; attr != &quot;JRNL&quot; &amp;&amp; attr != &quot;REMARK&quot; &amp;&amp;</a>
<a name="ln551">          attr != &quot;DBREF&quot; &amp;&amp; attr != &quot;DBREF1&quot; &amp;&amp; attr != &quot;DBREF2&quot; &amp;&amp; attr != &quot;SEQADV&quot; &amp;&amp;</a>
<a name="ln552">          attr != &quot;SEQRES&quot; &amp;&amp; attr != &quot;MODRES&quot; &amp;&amp; attr != &quot;HET&quot; &amp;&amp; attr != &quot;HETNAM&quot; &amp;&amp;</a>
<a name="ln553">          attr != &quot;HETSYN&quot; &amp;&amp; attr != &quot;FORMUL&quot; &amp;&amp; attr != &quot;HELIX&quot; &amp;&amp; attr != &quot;SHEET&quot; &amp;&amp;</a>
<a name="ln554">          attr != &quot;SSBOND&quot; &amp;&amp; attr != &quot;LINK&quot; &amp;&amp; attr != &quot;CISPEP&quot; &amp;&amp; attr != &quot;SITE&quot; &amp;&amp;</a>
<a name="ln555">          attr != &quot;ORIGX1&quot; &amp;&amp; attr != &quot;ORIGX2&quot; &amp;&amp; attr != &quot;ORIGX3&quot; &amp;&amp; attr != &quot;SCALE1&quot; &amp;&amp;</a>
<a name="ln556">          attr != &quot;SCALE2&quot; &amp;&amp; attr != &quot;SCALE3&quot; &amp;&amp; attr != &quot;MATRIX1&quot; &amp;&amp; attr != &quot;MATRIX2&quot; &amp;&amp;</a>
<a name="ln557">          attr != &quot;MATRIX3&quot; &amp;&amp; attr != &quot;MODEL&quot;)</a>
<a name="ln558">        continue;</a>
<a name="ln559"> </a>
<a name="ln560">      if (attr == &quot;COMPND&quot;)</a>
<a name="ln561">        compndWritten = true;</a>
<a name="ln562">      if (attr == &quot;AUTHOR&quot;)</a>
<a name="ln563">        authorWritten = true;</a>
<a name="ln564"> </a>
<a name="ln565">      // compute spacing needed. HELIX, SITE, HET, ... are trimmed when reading</a>
<a name="ln566">      int nSpacing = 6 - attr.size();</a>
<a name="ln567">      for (int i = 0; i &lt; nSpacing; ++i)</a>
<a name="ln568">        attr += &quot; &quot;;</a>
<a name="ln569"> </a>
<a name="ln570"> </a>
<a name="ln571">      std::string lines = pd-&gt;GetValue();</a>
<a name="ln572">      string::size_type last = 0;</a>
<a name="ln573">      string::size_type pos = lines.find('\n');</a>
<a name="ln574">      while (last != string::npos) {</a>
<a name="ln575">        string line = lines.substr(last, pos - last);</a>
<a name="ln576">        if (pos == string::npos)</a>
<a name="ln577">          last = string::npos;</a>
<a name="ln578">        else</a>
<a name="ln579">          last = pos + 1;</a>
<a name="ln580">        pos = lines.find('\n', last);</a>
<a name="ln581"> </a>
<a name="ln582">        ofs &lt;&lt; attr &lt;&lt; line &lt;&lt; endl;</a>
<a name="ln583">      }</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586">    if (!compndWritten) {</a>
<a name="ln587">      if (strlen(mol.GetTitle()) &gt; 0)</a>
<a name="ln588">        snprintf(buffer, BUFF_SIZE, &quot;COMPND    %s &quot;,mol.GetTitle());</a>
<a name="ln589">      else</a>
<a name="ln590">        snprintf(buffer, BUFF_SIZE, &quot;COMPND    UNNAMED&quot;);</a>
<a name="ln591">      ofs &lt;&lt; buffer &lt;&lt; endl;</a>
<a name="ln592">    }</a>
<a name="ln593"> </a>
<a name="ln594">    if (!authorWritten) {</a>
<a name="ln595">      snprintf(buffer, BUFF_SIZE, &quot;AUTHOR    GENERATED BY OPEN BABEL %s&quot;,BABEL_VERSION);</a>
<a name="ln596">      ofs &lt;&lt; buffer &lt;&lt; endl;</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    // Write CRYST1 record, containing unit cell parameters, space group</a>
<a name="ln600">    // and Z value (supposed to be 1)</a>
<a name="ln601">    if (pmol-&gt;HasData(OBGenericDataType::UnitCell))</a>
<a name="ln602">      {</a>
<a name="ln603">        OBUnitCell *pUC = (OBUnitCell*)pmol-&gt;GetData(OBGenericDataType::UnitCell);</a>
<a name="ln604">        if(pUC-&gt;GetSpaceGroup()){</a>
<a name="ln605">          string tmpHM=pUC-&gt;GetSpaceGroup()-&gt;GetHMName();</a>
<a name="ln606">          fixRhombohedralSpaceGroupWriter(tmpHM);</a>
<a name="ln607"> </a>
<a name="ln608">          // Do we have an extended HM symbol, with origin choice as &quot;:1&quot; or &quot;:2&quot; ? If so, remove it.</a>
<a name="ln609">          size_t n=tmpHM.find(&quot;:&quot;);</a>
<a name="ln610">          if(n!=string::npos) tmpHM=tmpHM.substr(0, n);</a>
<a name="ln611"> </a>
<a name="ln612">          if (pConv-&gt;IsOption(&quot;o&quot;, OBConversion::OUTOPTIONS))</a>
<a name="ln613">            {</a>
<a name="ln614">              unsigned int origin = pUC-&gt;GetSpaceGroup()-&gt;GetOriginAlternative();</a>
<a name="ln615">              if (origin == pUC-&gt;GetSpaceGroup()-&gt;HEXAGONAL_ORIGIN)</a>
<a name="ln616">                tmpHM[0] = 'H';</a>
<a name="ln617">              else if (origin &gt; 0)</a>
<a name="ln618">                tmpHM += &quot;:&quot; + to_string(origin);</a>
<a name="ln619"> </a>
<a name="ln620">              if (tmpHM.length() &gt; MAX_HM_NAME_LEN)</a>
<a name="ln621">              {</a>
<a name="ln622">                tmpHM.erase(std::remove(tmpHM.begin(), tmpHM.end(), ' '),</a>
<a name="ln623">                            tmpHM.end());</a>
<a name="ln624">              }</a>
<a name="ln625">            }</a>
<a name="ln626"> </a>
<a name="ln627">          snprintf(buffer, BUFF_SIZE,</a>
<a name="ln628">                   &quot;CRYST1%9.3f%9.3f%9.3f%7.2f%7.2f%7.2f %-11s 1&quot;,</a>
<a name="ln629">                   pUC-&gt;GetA(), pUC-&gt;GetB(), pUC-&gt;GetC(),</a>
<a name="ln630">                   pUC-&gt;GetAlpha(), pUC-&gt;GetBeta(), pUC-&gt;GetGamma(),</a>
<a name="ln631">                   tmpHM.c_str());</a>
<a name="ln632">        }</a>
<a name="ln633">        else</a>
<a name="ln634">          snprintf(buffer, BUFF_SIZE,</a>
<a name="ln635">                   &quot;CRYST1%9.3f%9.3f%9.3f%7.2f%7.2f%7.2f %-11s 1&quot;,</a>
<a name="ln636">                   pUC-&gt;GetA(), pUC-&gt;GetB(), pUC-&gt;GetC(),</a>
<a name="ln637">                   pUC-&gt;GetAlpha(), pUC-&gt;GetBeta(), pUC-&gt;GetGamma(),</a>
<a name="ln638">                   &quot;P1&quot;);</a>
<a name="ln639"> </a>
<a name="ln640">        ofs &lt;&lt; buffer &lt;&lt; endl;</a>
<a name="ln641">      }</a>
<a name="ln642"> </a>
<a name="ln643">    // before we write any records, we should check to see if any coord &lt; -1000</a>
<a name="ln644">    // which will cause errors in the formatting</a>
<a name="ln645"> </a>
<a name="ln646">    double minX, minY, minZ;</a>
<a name="ln647">    minX = minY = minZ = -999.0f;</a>
<a name="ln648">    FOR_ATOMS_OF_MOL(a, mol)</a>
<a name="ln649">      {</a>
<a name="ln650">        if (a-&gt;GetX() &lt; minX)</a>
<a name="ln651">          minX = a-&gt;GetX();</a>
<a name="ln652">        if (a-&gt;GetY() &lt; minY)</a>
<a name="ln653">          minY = a-&gt;GetY();</a>
<a name="ln654">        if (a-&gt;GetZ() &lt; minZ)</a>
<a name="ln655">          minZ = a-&gt;GetZ();</a>
<a name="ln656">      }</a>
<a name="ln657">    vector3 transV = VZero;</a>
<a name="ln658">    if (minX &lt; -999.0)</a>
<a name="ln659">      transV.SetX(-1.0*minX - 900.0);</a>
<a name="ln660">    if (minY &lt; -999.0)</a>
<a name="ln661">      transV.SetY(-1.0*minY - 900.0);</a>
<a name="ln662">    if (minZ &lt; -999.0)</a>
<a name="ln663">      transV.SetZ(-1.0*minZ - 900.0);</a>
<a name="ln664"> </a>
<a name="ln665">    // if minX, minY, or minZ was never changed, shift will be 0.0f</a>
<a name="ln666">    // otherwise, move enough so that smallest coord is &gt; -999.0f</a>
<a name="ln667">    mol.Translate(transV);</a>
<a name="ln668"> </a>
<a name="ln669">    OBAtom *atom;</a>
<a name="ln670">    OBResidue *res;</a>
<a name="ln671">    for (i = 1; i &lt;= mol.NumAtoms(); i++)</a>
<a name="ln672">      {</a>
<a name="ln673">        atom = mol.GetAtom(i);</a>
<a name="ln674">        strncpy(type_name, OBElements::GetSymbol(atom-&gt;GetAtomicNum()), sizeof(type_name));</a>
<a name="ln675">        type_name[sizeof(type_name) - 1] = '\0';</a>
<a name="ln676"> </a>
<a name="ln677">        //two char. elements are on position 13 and 14 one char. start at 14</a>
<a name="ln678">        if (strlen(type_name) &gt; 1)</a>
<a name="ln679">          type_name[1] = toupper(type_name[1]);</a>
<a name="ln680">        else</a>
<a name="ln681">          {</a>
<a name="ln682">            char tmp[10];</a>
<a name="ln683">            strncpy(tmp, type_name, 9); // make sure to null-terminate tmp</a>
<a name="ln684">            snprintf(type_name, sizeof(type_name), &quot; %-3s&quot;, tmp);</a>
<a name="ln685">          }</a>
<a name="ln686"> </a>
<a name="ln687">        if ((res = atom-&gt;GetResidue()) != nullptr)</a>
<a name="ln688">          {</a>
<a name="ln689">            het = res-&gt;IsHetAtom(atom);</a>
<a name="ln690">            snprintf(the_res,4,&quot;%s&quot;,(char*)res-&gt;GetName().c_str());</a>
<a name="ln691">            the_res[4] = '\0';</a>
<a name="ln692">            snprintf(type_name,5,&quot;%s&quot;,(char*)res-&gt;GetAtomID(atom).c_str());</a>
<a name="ln693">            the_chain = res-&gt;GetChain();</a>
<a name="ln694"> </a>
<a name="ln695">            //two char. elements are on position 13 and 14 one char. start at 14</a>
<a name="ln696">            if (strlen(OBElements::GetSymbol(atom-&gt;GetAtomicNum())) == 1)</a>
<a name="ln697">              {</a>
<a name="ln698">                if (strlen(type_name) &lt; 4)</a>
<a name="ln699">                  {</a>
<a name="ln700">                    char tmp[10];</a>
<a name="ln701">                    strncpy(tmp, type_name, 9); // make sure to null-terminate tmp</a>
<a name="ln702">                    snprintf(padded_name, sizeof(padded_name), &quot; %-3s&quot;, tmp);</a>
<a name="ln703">                    strncpy(type_name,padded_name,4);</a>
<a name="ln704">                    type_name[4] = '\0';</a>
<a name="ln705">                  }</a>
<a name="ln706">                else</a>
<a name="ln707">                  {</a>
<a name="ln708">                    /*</a>
<a name="ln709">                      type_name[4] = type_name[3];</a>
<a name="ln710">                      type_name[3] = type_name[2];</a>
<a name="ln711">                      type_name[2] = type_name[1];</a>
<a name="ln712">                      type_name[1] = type_name[0];</a>
<a name="ln713">                      type_name[0] = type_name[4];</a>
<a name="ln714">                    */</a>
<a name="ln715">                    type_name[4] = '\0';</a>
<a name="ln716">                  }</a>
<a name="ln717">              }</a>
<a name="ln718">            res_num = res-&gt;GetNum();</a>
<a name="ln719">            the_insertioncode = res-&gt;GetInsertionCode();</a>
<a name="ln720">            if (0 == the_insertioncode) the_insertioncode=' ';</a>
<a name="ln721">          }</a>
<a name="ln722">        else</a>
<a name="ln723">          {</a>
<a name="ln724">            strcpy(the_res,&quot;UNK&quot;);</a>
<a name="ln725">            the_res[3] = '\0';</a>
<a name="ln726">            snprintf(padded_name,sizeof(padded_name), &quot;%s&quot;,type_name);</a>
<a name="ln727">            strncpy(type_name,padded_name,4);</a>
<a name="ln728">            type_name[4] = '\0';</a>
<a name="ln729">            res_num = 1;</a>
<a name="ln730">            the_insertioncode=' ';</a>
<a name="ln731">          }</a>
<a name="ln732"> </a>
<a name="ln733">        element_name = OBElements::GetSymbol(atom-&gt;GetAtomicNum());</a>
<a name="ln734"> </a>
<a name="ln735">        int charge = atom-&gt;GetFormalCharge();</a>
<a name="ln736">        char scharge[3] = { ' ', ' ', '\0' };</a>
<a name="ln737">        if(0 != charge)</a>
<a name="ln738">          {</a>
<a name="ln739">            snprintf(scharge, 3, &quot;%+d&quot;, charge);</a>
<a name="ln740">            char tmp = scharge[1];</a>
<a name="ln741">            scharge[1] = scharge[0];</a>
<a name="ln742">            scharge[0] = tmp;</a>
<a name="ln743">          }</a>
<a name="ln744"> </a>
<a name="ln745">        double occup = 1.0;</a>
<a name="ln746">        if (atom-&gt;HasData(&quot;_atom_site_occupancy&quot;))</a>
<a name="ln747">        {</a>
<a name="ln748">         OBPairFloatingPoint *occup_fp = dynamic_cast&lt;OBPairFloatingPoint*&gt; (atom-&gt;GetData(&quot;_atom_site_occupancy&quot;));</a>
<a name="ln749">         occup = occup_fp-&gt;GetGenericValue();</a>
<a name="ln750">        }</a>
<a name="ln751"> </a>
<a name="ln752">        snprintf(buffer, BUFF_SIZE, &quot;%s%5d %-4s %-3s %c%4d%c   %8.3f%8.3f%8.3f%6.2f  0.00          %2s%2s\n&quot;,</a>
<a name="ln753">                 het?&quot;HETATM&quot;:&quot;ATOM  &quot;,</a>
<a name="ln754">                 i,</a>
<a name="ln755">                 type_name,</a>
<a name="ln756">                 the_res,</a>
<a name="ln757">                 the_chain,</a>
<a name="ln758">                 res_num,</a>
<a name="ln759">                 the_insertioncode,</a>
<a name="ln760">                 atom-&gt;GetX(),</a>
<a name="ln761">                 atom-&gt;GetY(),</a>
<a name="ln762">                 atom-&gt;GetZ(),</a>
<a name="ln763">                 occup,</a>
<a name="ln764">                 element_name,</a>
<a name="ln765">                 scharge);</a>
<a name="ln766">        ofs &lt;&lt; buffer;</a>
<a name="ln767">      }</a>
<a name="ln768"> </a>
<a name="ln769">    OBAtom *nbr;</a>
<a name="ln770">    vector&lt;OBBond*&gt;::iterator k;</a>
<a name="ln771">    for (i = 1; i &lt;= mol.NumAtoms(); i ++)</a>
<a name="ln772">      {</a>
<a name="ln773">        atom = mol.GetAtom(i);</a>
<a name="ln774">        if (atom-&gt;GetExplicitDegree() == 0)</a>
<a name="ln775">          continue; // no need to write a CONECT record -- no bonds</a>
<a name="ln776"> </a>
<a name="ln777">        // Write out up to 4 real bonds per line PR#1711154</a>
<a name="ln778">        int currentValence = 0;</a>
<a name="ln779">        for (nbr = atom-&gt;BeginNbrAtom(k);nbr;nbr = atom-&gt;NextNbrAtom(k))</a>
<a name="ln780">          {</a>
<a name="ln781">            OBBond *bond = mol.GetBond(atom, nbr);</a>
<a name="ln782">            if(!bond) continue;</a>
<a name="ln783">            unsigned bondorder = bond-&gt;GetBondOrder();</a>
<a name="ln784">            if(bondorder == 0 || pConv-&gt;IsOption(&quot;n&quot;, OBConversion::OUTOPTIONS)) </a>
<a name="ln785">              bondorder = 1;</a>
<a name="ln786">            //a non-standard convention is to store bond orders by</a>
<a name="ln787">            //replicating conect records</a>
<a name="ln788">            for(unsigned bo = 0; bo &lt; bondorder; bo++) {</a>
<a name="ln789">              if ((currentValence % 4) == 0) {</a>
<a name="ln790">                if (currentValence &gt; 0) {</a>
<a name="ln791">                  // Add the trailing space to finish the previous record</a>
<a name="ln792">                  ofs &lt;&lt; &quot;                                       \n&quot;;</a>
<a name="ln793">                }</a>
<a name="ln794">                // write the start of a new CONECT record</a>
<a name="ln795">                snprintf(buffer, BUFF_SIZE, &quot;CONECT%5d&quot;, i);</a>
<a name="ln796">                ofs &lt;&lt; buffer;</a>
<a name="ln797">              }</a>
<a name="ln798">              currentValence++;</a>
<a name="ln799">              snprintf(buffer, BUFF_SIZE, &quot;%5d&quot;, nbr-&gt;GetIdx());</a>
<a name="ln800">              ofs &lt;&lt; buffer;</a>
<a name="ln801">            }</a>
<a name="ln802">          }</a>
<a name="ln803"> </a>
<a name="ln804">        // Add trailing spaces</a>
<a name="ln805">        while ((currentValence % 4) != 0) {</a>
<a name="ln806">          ofs &lt;&lt; &quot;     &quot;;</a>
<a name="ln807">          currentValence++;</a>
<a name="ln808">        }</a>
<a name="ln809">        ofs &lt;&lt; &quot;                                       \n&quot;;</a>
<a name="ln810">      }</a>
<a name="ln811"> </a>
<a name="ln812">    snprintf(buffer, BUFF_SIZE, &quot;MASTER        0    0    0    0    0    0    0    0 &quot;);</a>
<a name="ln813">    ofs &lt;&lt; buffer;</a>
<a name="ln814">    snprintf(buffer, BUFF_SIZE, &quot;%4d    0 %4d    0\n&quot;,mol.NumAtoms(),mol.NumAtoms());</a>
<a name="ln815">    ofs &lt;&lt; buffer;</a>
<a name="ln816"> </a>
<a name="ln817">    if (model_num) {</a>
<a name="ln818">      ofs &lt;&lt; &quot;ENDMDL&quot; &lt;&lt; endl;</a>
<a name="ln819">	  if (pConv-&gt;IsLast()) {</a>
<a name="ln820">	    ofs &lt;&lt; &quot;END\n&quot;;</a>
<a name="ln821">	  }</a>
<a name="ln822">    }</a>
<a name="ln823">	else {</a>
<a name="ln824">	  ofs &lt;&lt; &quot;END\n&quot;;</a>
<a name="ln825">	}</a>
<a name="ln826"> </a>
<a name="ln827">    return(true);</a>
<a name="ln828">  }</a>
<a name="ln829"> </a>
<a name="ln830">  ////////////////////////////////////////////////////////////////</a>
<a name="ln831">  static void fixRhombohedralSpaceGroupWriter(string &amp;strHM)</a>
<a name="ln832">  {</a>
<a name="ln833">    /* This is due to the requirment of PDB to name rhombohedral groups</a>
<a name="ln834">       with H (http://deposit.rcsb.org/adit/docs/pdb_atom_format.html) */</a>
<a name="ln835">    const int SIZE = 7;</a>
<a name="ln836">    const char* groups[SIZE]  =   {&quot;R 3:H&quot;,</a>
<a name="ln837">                                   &quot;R -3:H&quot;,</a>
<a name="ln838">                                   &quot;R 3 2:H&quot;,</a>
<a name="ln839">                                   &quot;R 3 m:H&quot;,</a>
<a name="ln840">                                   &quot;R 3 c:H&quot;,</a>
<a name="ln841">                                   &quot;R -3 m:H&quot;,</a>
<a name="ln842">                                   &quot;R -3 c:H&quot;};</a>
<a name="ln843"> </a>
<a name="ln844">    std::vector&lt;string&gt; vec(groups, groups + SIZE);</a>
<a name="ln845">    if(std::find(vec.begin(), vec.end(), strHM) != vec.end())</a>
<a name="ln846">    {</a>
<a name="ln847">      strHM[0] = 'H';</a>
<a name="ln848">    }</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  static void fixRhombohedralSpaceGroupReader(string &amp;strHM)</a>
<a name="ln852">  {</a>
<a name="ln853">    /* This is due to the requirment of PDB to name rhombohedral groups</a>
<a name="ln854">       with H (http://deposit.rcsb.org/adit/docs/pdb_atom_format.html) */</a>
<a name="ln855">    const int SIZE = 7;</a>
<a name="ln856">    const char* groups[SIZE]  =   {&quot;H 3&quot;,</a>
<a name="ln857">                                   &quot;H -3&quot;,</a>
<a name="ln858">                                   &quot;H 3 2&quot;,</a>
<a name="ln859">                                   &quot;H 3 m&quot;,</a>
<a name="ln860">                                   &quot;H 3 c&quot;,</a>
<a name="ln861">                                   &quot;H -3 m&quot;,</a>
<a name="ln862">                                   &quot;H -3 c&quot;};</a>
<a name="ln863"> </a>
<a name="ln864">    std::vector&lt;string&gt; vec(groups, groups + SIZE);</a>
<a name="ln865"> </a>
<a name="ln866">    if(std::find(vec.begin(), vec.end(), strHM) != vec.end())</a>
<a name="ln867">    {</a>
<a name="ln868">      strHM[0] = 'R';</a>
<a name="ln869">      strHM += &quot;:H&quot;;</a>
<a name="ln870">    }</a>
<a name="ln871">  }</a>
<a name="ln872"> </a>
<a name="ln873">  /*</a>
<a name="ln874"> </a>
<a name="ln875">     From http://deposit.rcsb.org/adit/docs/pdb_atom_format.html</a>
<a name="ln876"> </a>
<a name="ln877">	COLUMNS        DATA TYPE       CONTENTS</a>
<a name="ln878">	--------------------------------------------------------------------------------</a>
<a name="ln879">	 1 -  6        Record name     &quot;ATOM  &quot;</a>
<a name="ln880">	 7 - 11        Integer         Atom serial number.</a>
<a name="ln881">	13 - 16        Atom            Atom name.</a>
<a name="ln882">	17             Character       Alternate location indicator.</a>
<a name="ln883">	18 - 20        Residue name    Residue name.</a>
<a name="ln884">	22             Character       Chain identifier.</a>
<a name="ln885">	23 - 26        Integer         Residue sequence number.</a>
<a name="ln886">	27             AChar           Code for insertion of residues.</a>
<a name="ln887">	31 - 38        Real(8.3)       Orthogonal coordinates for X in Angstroms.</a>
<a name="ln888">	39 - 46        Real(8.3)       Orthogonal coordinates for Y in Angstroms.</a>
<a name="ln889">	47 - 54        Real(8.3)       Orthogonal coordinates for Z in Angstroms.</a>
<a name="ln890">	55 - 60        Real(6.2)       Occupancy.</a>
<a name="ln891">	61 - 66        Real(6.2)       Temperature factor (Default = 0.0).</a>
<a name="ln892">	73 - 76        LString(4)      Segment identifier, left-justified.</a>
<a name="ln893">	77 - 78        LString(2)      Element symbol, right-justified.</a>
<a name="ln894">	79 - 80        LString(2)      Charge on the atom.</a>
<a name="ln895">  */</a>
<a name="ln896">  static bool parseAtomRecord(char *buffer, OBMol &amp;mol,int /*chainNum*/)</a>
<a name="ln897">  /* ATOMFORMAT &quot;(i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,a2,a2)&quot; */</a>
<a name="ln898">  {</a>
<a name="ln899">    string sbuf = &amp;buffer[6];</a>
<a name="ln900">    if (sbuf.size() &lt; 48)</a>
<a name="ln901">      return(false);</a>
<a name="ln902"> </a>
<a name="ln903">    bool hetatm = (EQn(buffer,&quot;HETATM&quot;,6)) ? true : false;</a>
<a name="ln904">    bool elementFound = false; // true if correct element found in col 77-78</a>
<a name="ln905"> </a>
<a name="ln906">    /* serial number */</a>
<a name="ln907">    string serno = sbuf.substr(0,5);</a>
<a name="ln908"> </a>
<a name="ln909">    /* atom name */</a>
<a name="ln910">    string atmid = sbuf.substr(6,4);</a>
<a name="ln911"> </a>
<a name="ln912">    /* chain */</a>
<a name="ln913">    char chain = sbuf.substr(15,1)[0];</a>
<a name="ln914"> </a>
<a name="ln915">    /* insertion code */</a>
<a name="ln916">    char insertioncode = sbuf.substr(27-6-1,1)[0];</a>
<a name="ln917">    if (' '==insertioncode) insertioncode=0;</a>
<a name="ln918">    /* element */</a>
<a name="ln919">    string element = &quot;  &quot;;</a>
<a name="ln920">    if (sbuf.size() &gt; 71)</a>
<a name="ln921">      {</a>
<a name="ln922">        element = sbuf.substr(70,2);</a>
<a name="ln923">        if (isalpha(element[1]))</a>
<a name="ln924">          {</a>
<a name="ln925">            if (element[0] == ' ')</a>
<a name="ln926">              {</a>
<a name="ln927">                element.erase(0, 1);</a>
<a name="ln928">                elementFound = true;</a>
<a name="ln929">              }</a>
<a name="ln930">            else if (isalpha(element[0]))</a>
<a name="ln931">              {</a>
<a name="ln932">                elementFound = true;</a>
<a name="ln933">                element[1] = tolower(element[1]);</a>
<a name="ln934">              }</a>
<a name="ln935">          }</a>
<a name="ln936">      }</a>
<a name="ln937"> </a>
<a name="ln938">    if (!elementFound)</a>
<a name="ln939">      {</a>
<a name="ln940">        stringstream errorMsg;</a>
<a name="ln941">        errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file\n&quot;</a>
<a name="ln942">                 &lt;&lt; &quot;  Problems reading a HETATM or ATOM record.\n&quot;</a>
<a name="ln943">                 &lt;&lt; &quot;  According to the PDB specification,\n&quot;</a>
<a name="ln944">                 &lt;&lt; &quot;  columns 77-78 should contain the element symbol of an atom.\n&quot;</a>
<a name="ln945">                 &lt;&lt; &quot;  but OpenBabel found '&quot; &lt;&lt; element &lt;&lt; &quot;' (atom &quot; &lt;&lt; mol.NumAtoms()+1 &lt;&lt; &quot;)&quot;;</a>
<a name="ln946">        obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln947">      }</a>
<a name="ln948"> </a>
<a name="ln949">    // charge - optional</a>
<a name="ln950">    string scharge;</a>
<a name="ln951">    if (sbuf.size() &gt; 73)</a>
<a name="ln952">      {</a>
<a name="ln953">        scharge = sbuf.substr(72,2);</a>
<a name="ln954">      }</a>
<a name="ln955"> </a>
<a name="ln956">    //trim spaces on the right and left sides</a>
<a name="ln957">    while (!atmid.empty() &amp;&amp; atmid[0] == ' ')</a>
<a name="ln958">      atmid = atmid.erase(0, 1);</a>
<a name="ln959"> </a>
<a name="ln960">    while (!atmid.empty() &amp;&amp; atmid[atmid.size()-1] == ' ')</a>
<a name="ln961">      atmid = atmid.substr(0,atmid.size()-1);</a>
<a name="ln962"> </a>
<a name="ln963">    /* residue name */</a>
<a name="ln964">    string resname = sbuf.substr(11,3);</a>
<a name="ln965">    if (resname == &quot;   &quot;)</a>
<a name="ln966">      resname = &quot;UNK&quot;;</a>
<a name="ln967">    else</a>
<a name="ln968">      {</a>
<a name="ln969">        while (!resname.empty() &amp;&amp; resname[0] == ' ')</a>
<a name="ln970">          resname = resname.substr(1,resname.size()-1);</a>
<a name="ln971"> </a>
<a name="ln972">        while (!resname.empty() &amp;&amp; resname[resname.size()-1] == ' ')</a>
<a name="ln973">          resname = resname.substr(0,resname.size()-1);</a>
<a name="ln974">      }</a>
<a name="ln975"> </a>
<a name="ln976">    string type;</a>
<a name="ln977">    if (!elementFound) {</a>
<a name="ln978">      // OK, we have to fall back to determining the element from the atom type</a>
<a name="ln979">      // This is unreliable, but there's no other choice</a>
<a name="ln980">      if (EQn(buffer,&quot;ATOM&quot;,4)) {</a>
<a name="ln981">        type = atmid.substr(0,2);</a>
<a name="ln982">        if (isdigit(type[0])) {</a>
<a name="ln983">          // sometimes non-standard files have, e.g 11HH</a>
<a name="ln984">          if (!isdigit(type[1])) type = atmid.substr(1,1);</a>
<a name="ln985">          else type = atmid.substr(2,1);</a>
<a name="ln986">        } else if ((sbuf[6] == ' ' &amp;&amp;</a>
<a name="ln987">                   strncasecmp(type.c_str(), &quot;Zn&quot;, 2) != 0 &amp;&amp;</a>
<a name="ln988">                   strncasecmp(type.c_str(), &quot;Fe&quot;, 2) != 0) ||</a>
<a name="ln989">                   isdigit(type[1]))	//type[1] is digit in Platon</a>
<a name="ln990">          type = atmid.substr(0,1);     // one-character element</a>
<a name="ln991"> </a>
<a name="ln992"> </a>
<a name="ln993">        if (resname.substr(0,2) == &quot;AS&quot; || resname[0] == 'N') {</a>
<a name="ln994">          if (atmid == &quot;AD1&quot;)</a>
<a name="ln995">            type = &quot;O&quot;;</a>
<a name="ln996">          if (atmid == &quot;AD2&quot;)</a>
<a name="ln997">            type = &quot;N&quot;;</a>
<a name="ln998">        }</a>
<a name="ln999">        if (resname.substr(0,3) == &quot;HIS&quot; || resname[0] == 'H') {</a>
<a name="ln1000">          if (atmid == &quot;AD1&quot; || atmid == &quot;AE2&quot;)</a>
<a name="ln1001">            type = &quot;N&quot;;</a>
<a name="ln1002">          if (atmid == &quot;AE1&quot; || atmid == &quot;AD2&quot;)</a>
<a name="ln1003">            type = &quot;C&quot;;</a>
<a name="ln1004">        }</a>
<a name="ln1005">        if (resname.substr(0,2) == &quot;GL&quot; || resname[0] == 'Q') {</a>
<a name="ln1006">          if (atmid == &quot;AE1&quot;)</a>
<a name="ln1007">            type = &quot;O&quot;;</a>
<a name="ln1008">          if (atmid == &quot;AE2&quot;)</a>
<a name="ln1009">            type = &quot;N&quot;;</a>
<a name="ln1010">        }</a>
<a name="ln1011">        // fix: #2002557</a>
<a name="ln1012">        if (atmid[0] == 'H' &amp;&amp;</a>
<a name="ln1013">            (atmid[1] == 'D' || atmid[1] == 'E' ||</a>
<a name="ln1014">             atmid[1] == 'G' || atmid[1] == 'H' ||</a>
<a name="ln1015">             atmid[1] == 'N')) // HD, HE, HG, HH, HN...</a>
<a name="ln1016">          type = &quot;H&quot;;</a>
<a name="ln1017"> </a>
<a name="ln1018">        if (type.size() == 2)</a>
<a name="ln1019">          type[1] = tolower(type[1]);</a>
<a name="ln1020"> </a>
<a name="ln1021">      } else { //must be hetatm record</a>
<a name="ln1022">        if (isalpha(element[1]) &amp;&amp; (isalpha(element[0]) || (element[0] == ' '))) {</a>
<a name="ln1023">          if (isalpha(element[0]))</a>
<a name="ln1024">            type = element.substr(0,2);</a>
<a name="ln1025">          else</a>
<a name="ln1026">            type = element.substr(1,1);</a>
<a name="ln1027"> </a>
<a name="ln1028">          if (type.size() == 2)</a>
<a name="ln1029">            type[1] = tolower(type[1]);</a>
<a name="ln1030">        } else { // no element column to use</a>
<a name="ln1031">          if (isalpha(atmid[0])) {</a>
<a name="ln1032">            if (atmid.size() &gt; 2)</a>
<a name="ln1033">              type = atmid.substr(0,2);</a>
<a name="ln1034">            else if (atmid[0] == 'A') // alpha prefix</a>
<a name="ln1035">              type = atmid.substr(1, atmid.size() - 1);</a>
<a name="ln1036">            else</a>
<a name="ln1037">              type = atmid.substr(0,1);</a>
<a name="ln1038">          } else if (atmid[0] == ' ')</a>
<a name="ln1039">            type = atmid.substr(1,1); // one char element</a>
<a name="ln1040">          else</a>
<a name="ln1041">            type = atmid.substr(1,2);</a>
<a name="ln1042"> </a>
<a name="ln1043">          // Some cleanup steps</a>
<a name="ln1044">          if (atmid == resname) {</a>
<a name="ln1045">            type = atmid;</a>
<a name="ln1046">            if (type.size() == 2)</a>
<a name="ln1047">              type[1] = tolower(type[1]);</a>
<a name="ln1048">          } else</a>
<a name="ln1049">            if (resname == &quot;ADR&quot; || resname == &quot;COA&quot; || resname == &quot;FAD&quot; ||</a>
<a name="ln1050">                resname == &quot;GPG&quot; || resname == &quot;NAD&quot; || resname == &quot;NAL&quot; ||</a>
<a name="ln1051">                resname == &quot;NDP&quot; || resname == &quot;ABA&quot;) {</a>
<a name="ln1052">              if (type.size() &gt; 1)</a>
<a name="ln1053">                type = type.substr(0,1);</a>
<a name="ln1054">              //type.erase(1,type.size()-1);</a>
<a name="ln1055">            } else // other residues</a>
<a name="ln1056">              if (isdigit(type[0])){</a>
<a name="ln1057">                type = type.substr(1,1);</a>
<a name="ln1058">              }</a>
<a name="ln1059">              else</a>
<a name="ln1060">                if (type.size() &gt; 1 &amp;&amp; isdigit(type[1]))</a>
<a name="ln1061">                  type = type.substr(0,1);</a>
<a name="ln1062">                else</a>
<a name="ln1063">                  if (type.size() &gt; 1 &amp;&amp; isalpha(type[1])) {</a>
<a name="ln1064">                    if (type[0] == 'O' &amp;&amp; type[1] == 'H')</a>
<a name="ln1065">                      type = type.substr(0,1); // no &quot;Oh&quot; element (e.g. 1MBN)</a>
<a name="ln1066">                    else if(isupper(type[1])) {</a>
<a name="ln1067">                      type[1] = tolower(type[1]);</a>
<a name="ln1068">                    }</a>
<a name="ln1069">                  }</a>
<a name="ln1070">        }</a>
<a name="ln1071"> </a>
<a name="ln1072">      } // HETATM records</a>
<a name="ln1073">    } // no element column to use</a>
<a name="ln1074"> </a>
<a name="ln1075">    OBAtom atom;</a>
<a name="ln1076">    /* X, Y, Z */</a>
<a name="ln1077">    string xstr = sbuf.substr(24,8);</a>
<a name="ln1078">    string ystr = sbuf.substr(32,8);</a>
<a name="ln1079">    string zstr = sbuf.substr(40,8);</a>
<a name="ln1080">    vector3 v(atof(xstr.c_str()),atof(ystr.c_str()),atof(zstr.c_str()));</a>
<a name="ln1081">    atom.SetVector(v);</a>
<a name="ln1082"> </a>
<a name="ln1083">    double occupancy = atof(sbuf.substr(48, 6).c_str());</a>
<a name="ln1084">    OBPairFloatingPoint* occup = new OBPairFloatingPoint;</a>
<a name="ln1085">    occup-&gt;SetAttribute(&quot;_atom_site_occupancy&quot;);</a>
<a name="ln1086">    if (occupancy &lt;= 0.0 || occupancy &gt; 1.0){</a>
<a name="ln1087">      occupancy = 1.0;</a>
<a name="ln1088">    }</a>
<a name="ln1089">    occup-&gt;SetValue(occupancy);</a>
<a name="ln1090">    occup-&gt;SetOrigin(fileformatInput);</a>
<a name="ln1091">    atom.SetData(occup);</a>
<a name="ln1092"> </a>
<a name="ln1093">    // useful for debugging unknown atom types (e.g., PR#1577238)</a>
<a name="ln1094">    //    cout &lt;&lt; mol.NumAtoms() + 1  &lt;&lt; &quot; : '&quot; &lt;&lt; element &lt;&lt; &quot;'&quot; &lt;&lt; &quot; &quot; &lt;&lt; OBElements::GetAtomicNum(element.c_str()) &lt;&lt; endl;</a>
<a name="ln1095">    if (elementFound)</a>
<a name="ln1096">      atom.SetAtomicNum(OBElements::GetAtomicNum(element.c_str()));</a>
<a name="ln1097">    else { // use our old-style guess from athe atom type</a>
<a name="ln1098">      unsigned int atomic_num = OBElements::GetAtomicNum(type.c_str());</a>
<a name="ln1099">      if (atomic_num ==  0) { //try one character if two character element not found</a>
<a name="ln1100">        type = type.substr(0,1);</a>
<a name="ln1101">        atomic_num = OBElements::GetAtomicNum(type.c_str());</a>
<a name="ln1102">      }</a>
<a name="ln1103">      atom.SetAtomicNum(atomic_num);</a>
<a name="ln1104">    }</a>
<a name="ln1105"> </a>
<a name="ln1106">    if ( (! scharge.empty()) &amp;&amp; &quot;  &quot; != scharge )</a>
<a name="ln1107">      {</a>
<a name="ln1108">        if ( isdigit(scharge[0]) &amp;&amp; ('+' == scharge[1] || '-' == scharge[1]) )</a>
<a name="ln1109">          {</a>
<a name="ln1110">            const char reorderCharge[3] = { scharge[1], scharge[0], '\0' };</a>
<a name="ln1111">            const int charge = atoi(reorderCharge);</a>
<a name="ln1112">            atom.SetFormalCharge(charge);</a>
<a name="ln1113">          }</a>
<a name="ln1114">        else</a>
<a name="ln1115">          {</a>
<a name="ln1116">            stringstream errorMsg;</a>
<a name="ln1117">            errorMsg &lt;&lt; &quot;WARNING: Problems reading a PDB file\n&quot;</a>
<a name="ln1118">                     &lt;&lt; &quot;  Problems reading a HETATM or ATOM record.\n&quot;</a>
<a name="ln1119">                     &lt;&lt; &quot;  According to the PDB specification,\n&quot;</a>
<a name="ln1120">                     &lt;&lt; &quot;  columns 79-80 should contain charge of the atom\n&quot;</a>
<a name="ln1121">                     &lt;&lt; &quot;  but OpenBabel found '&quot; &lt;&lt; scharge &lt;&lt; &quot;' (atom &quot; &lt;&lt; mol.NumAtoms()+1 &lt;&lt; &quot;).&quot;;</a>
<a name="ln1122">            obErrorLog.ThrowError(__FUNCTION__, errorMsg.str(), obWarning);</a>
<a name="ln1123">          }</a>
<a name="ln1124">      }</a>
<a name="ln1125">    else {</a>
<a name="ln1126">      atom.SetFormalCharge(0);</a>
<a name="ln1127">    }</a>
<a name="ln1128"> </a>
<a name="ln1129">    /* residue sequence number */</a>
<a name="ln1130">    string resnum = sbuf.substr(16,4);</a>
<a name="ln1131">    OBResidue *res  = (mol.NumResidues() &gt; 0) ? mol.GetResidue(mol.NumResidues()-1) : nullptr;</a>
<a name="ln1132">    if (res == nullptr</a>
<a name="ln1133">        || res-&gt;GetName() != resname</a>
<a name="ln1134">        || res-&gt;GetNumString() != resnum</a>
<a name="ln1135">        || res-&gt;GetChain() != chain</a>
<a name="ln1136">        || res-&gt;GetInsertionCode() != insertioncode)</a>
<a name="ln1137">      {</a>
<a name="ln1138">        vector&lt;OBResidue*&gt;::iterator ri;</a>
<a name="ln1139">        for (res = mol.BeginResidue(ri) ; res ; res = mol.NextResidue(ri))</a>
<a name="ln1140">          if (res-&gt;GetName() == resname</a>
<a name="ln1141">              &amp;&amp; res-&gt;GetNumString() == resnum</a>
<a name="ln1142">              &amp;&amp; static_cast&lt;int&gt;(res-&gt;GetChain()) == chain</a>
<a name="ln1143">              &amp;&amp; static_cast&lt;int&gt;(res-&gt;GetInsertionCode()) == insertioncode) {</a>
<a name="ln1144">            if (insertioncode) fprintf(stderr,&quot;I: identified residue wrt insertion code: '%c'\n&quot;,insertioncode);</a>
<a name="ln1145">            break;</a>
<a name="ln1146">          }</a>
<a name="ln1147"> </a>
<a name="ln1148">        if (res == nullptr) {</a>
<a name="ln1149">          res = mol.NewResidue();</a>
<a name="ln1150">          res-&gt;SetChain(chain);</a>
<a name="ln1151">          res-&gt;SetName(resname);</a>
<a name="ln1152">          res-&gt;SetNum(resnum);</a>
<a name="ln1153">          res-&gt;SetInsertionCode(insertioncode);</a>
<a name="ln1154">        }</a>
<a name="ln1155">      }</a>
<a name="ln1156"> </a>
<a name="ln1157">    if (!mol.AddAtom(atom))</a>
<a name="ln1158">      return(false);</a>
<a name="ln1159">    else {</a>
<a name="ln1160">      OBAtom *atom = mol.GetAtom(mol.NumAtoms());</a>
<a name="ln1161"> </a>
<a name="ln1162">      res-&gt;AddAtom(atom);</a>
<a name="ln1163">      res-&gt;SetSerialNum(atom, atoi(serno.c_str()));</a>
<a name="ln1164">      res-&gt;SetAtomID(atom, sbuf.substr(6,4));</a>
<a name="ln1165">      res-&gt;SetHetAtom(atom, hetatm);</a>
<a name="ln1166"> </a>
<a name="ln1167">      return(true);</a>
<a name="ln1168">    }</a>
<a name="ln1169">  } // end reading atom records</a>
<a name="ln1170"> </a>
<a name="ln1171">} //namespace OpenBabel</a>

</code></pre>
<div class="balloon" rel="261"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v663/" target="_blank">V663</a> Infinite loop is possible. The 'cin.eof()' condition is insufficient to break from the loop. Consider adding the 'cin.fail()' function call to the conditional expression.</p></div>
<div class="balloon" rel="749"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'occup_fp'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
